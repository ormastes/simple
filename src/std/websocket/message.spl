# WebSocket Message Module
# Handles message fragmentation, reassembly, and multi-frame operations

from std.websocket.types import OPCODE_TEXT
from std.websocket.types import OPCODE_BINARY
from std.websocket.types import OPCODE_CONTINUATION
from std.websocket.frame import create_frame
from std.websocket.frame import generate_masking_key
from std.websocket.frame import parse_frame
from std.websocket.frame import extract_mask_key
from std.websocket.frame import extract_payload
from std.websocket.handshake import text_to_bytes

# ==============================================================================
# Message Fragmentation
# ==============================================================================

fn split_into_chunks(data: List<i64>, chunk_size: i64) -> List<List<i64>>:
    val result = []
    val len = data.length()
    var offset = 0

    while offset < len:
        val chunk = []
        val remaining = len - offset
        val size = if remaining < chunk_size: remaining else: chunk_size

        var i = 0
        while i < size:
            chunk.push(data.at(offset + i))
            i = i + 1

        result.push(chunk)
        offset = offset + size

    result

fn create_fragmented_text(text_data: text, chunk_size: i64, is_masked: i64) -> List<List<i64>>:
    val payload = text_to_bytes(text_data)
    val chunks = split_into_chunks(payload, chunk_size)
    val num_chunks = chunks.length()
    val frames = []

    var i = 0
    while i < num_chunks:
        val chunk = chunks.at(i)
        val is_final = if i == num_chunks - 1: 1 else: 0
        val opcode = if i == 0: OPCODE_TEXT else: OPCODE_CONTINUATION
        val mask_key = if is_masked == 1: generate_masking_key() else: []
        val frame = create_frame(is_final, opcode, is_masked, chunk, mask_key)
        frames.push(frame)
        i = i + 1

    frames

fn create_fragmented_binary(data: List<i64>, chunk_size: i64, is_masked: i64) -> List<List<i64>>:
    val chunks = split_into_chunks(data, chunk_size)
    val num_chunks = chunks.length()
    val frames = []

    var i = 0
    while i < num_chunks:
        val chunk = chunks.at(i)
        val is_final = if i == num_chunks - 1: 1 else: 0
        val opcode = if i == 0: OPCODE_BINARY else: OPCODE_CONTINUATION
        val mask_key = if is_masked == 1: generate_masking_key() else: []
        val frame = create_frame(is_final, opcode, is_masked, chunk, mask_key)
        frames.push(frame)
        i = i + 1

    frames

# ==============================================================================
# Message Reassembly
# ==============================================================================

fn reassemble_fragments(fragments: List<List<i64>>) -> List<i64>:
    val result = []
    val num_fragments = fragments.length()

    var i = 0
    while i < num_fragments:
        val fragment = fragments.at(i)
        val len = fragment.length()
        var j = 0
        while j < len:
            result.push(fragment.at(j))
            j = j + 1
        i = i + 1

    result

fn merge_payloads(payloads: List<List<i64>>) -> List<i64>:
    reassemble_fragments(payloads)

# ==============================================================================
# Multi-Frame Operations
# ==============================================================================

fn concatenate_frames(frames: List<List<i64>>) -> List<i64>:
    val result = []
    val num_frames = frames.length()

    var i = 0
    while i < num_frames:
        val frame = frames.at(i)
        val len = frame.length()
        var j = 0
        while j < len:
            result.push(frame.at(j))
            j = j + 1
        i = i + 1

    result

fn extract_all_payloads(frames: List<List<i64>>) -> List<List<i64>>:
    val result = []
    val num_frames = frames.length()

    var i = 0
    while i < num_frames:
        val frame = frames.at(i)
        val parsed = parse_frame(frame)
        if parsed.length() > 0:
            val header_size = parsed.at(4)
            val payload_length = parsed.at(3)
            val masked = parsed.at(2)
            val mask_key = extract_mask_key(frame, header_size, masked)
            val payload = extract_payload(frame, header_size, payload_length, mask_key)
            result.push(payload)
        i = i + 1

    result
