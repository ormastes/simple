# HTML Parser Utilities Module (Facade)
#
# Provides comprehensive HTML5 parsing and DOM tree construction.
# - Tokenization: tags, attributes, text, comments
# - DOM tree construction: hierarchical element tree
# - Tree navigation: parent, children, siblings, descendants
# - Query operations: find by tag, id, class
# - HTML entities: decode common and numeric entities
# - Pretty printing: indented HTML output
# - Validation: void elements, tag names
# - Error recovery: auto-close unclosed tags
#
# This is a facade module that re-exports functionality from specialized submodules.

# =============================================================================
# Type Constants and Validation (from html/types.spl)
# =============================================================================

# Token types
val TOKEN_TAG_OPEN = "tag_open"
val TOKEN_TAG_CLOSE = "tag_close"
val TOKEN_TAG_SELF_CLOSE = "tag_self"
val TOKEN_TEXT = "text"
val TOKEN_COMMENT = "comment"
val TOKEN_DOCTYPE = "doctype"
val TOKEN_EOF = "eof"

# Node types
val NODE_ELEMENT = "element"
val NODE_TEXT = "text"
val NODE_COMMENT = "comment"
val NODE_DOCTYPE = "doctype"

fn is_void_element(tag: text) -> bool:
    val normalized = tag.to_lowercase()
    var result = false
    if normalized == "area":
        result = true
    if normalized == "base":
        result = true
    if normalized == "br":
        result = true
    if normalized == "col":
        result = true
    if normalized == "embed":
        result = true
    if normalized == "hr":
        result = true
    if normalized == "img":
        result = true
    if normalized == "input":
        result = true
    if normalized == "link":
        result = true
    if normalized == "meta":
        result = true
    if normalized == "param":
        result = true
    if normalized == "source":
        result = true
    if normalized == "track":
        result = true
    if normalized == "wbr":
        result = true
    result

fn has_optional_close(tag: text) -> bool:
    val normalized = tag.to_lowercase()
    var result = false
    if normalized == "p":
        result = true
    if normalized == "li":
        result = true
    if normalized == "dt":
        result = true
    if normalized == "dd":
        result = true
    if normalized == "option":
        result = true
    if normalized == "thead":
        result = true
    if normalized == "tbody":
        result = true
    if normalized == "tfoot":
        result = true
    if normalized == "tr":
        result = true
    if normalized == "td":
        result = true
    if normalized == "th":
        result = true
    result

fn is_valid_tag_name(tag: text) -> bool:
    var result = false
    if tag.length() > 0:
        val first_char = tag.substring(0, 1)
        if is_alpha(first_char):
            result = true
            var i = 1
            while i < tag.length():
                val c = tag.substring(i, i + 1)
                if not is_tag_name_char(c):
                    result = false
                    i = tag.length()
                else:
                    i = i + 1
    result

fn is_valid_attr_name(attr: text) -> bool:
    var result = false
    if attr.length() > 0:
        val first_char = attr.substring(0, 1)
        if is_alpha(first_char):
            result = true
            var i = 1
            while i < attr.length():
                val c = attr.substring(i, i + 1)
                if not is_attr_name_char(c):
                    result = false
                    i = tag.length()
                else:
                    i = i + 1
    result

# =============================================================================
# Character Classification (from html/lexer.spl)
# =============================================================================

fn is_whitespace(c: text) -> bool:
    var result = false
    if c == " ":
        result = true
    if c == "\t":
        result = true
    if c == "\n":
        result = true
    if c == "\r":
        result = true
    result

fn is_alpha(c: text) -> bool:
    val code = c.char_code_at(0)
    var result = false
    if code >= 65:
        if code <= 90:
            result = true
    if code >= 97:
        if code <= 122:
            result = true
    result

fn is_digit(c: text) -> bool:
    val code = c.char_code_at(0)
    var result = false
    if code >= 48:
        if code <= 57:
            result = true
    result

fn is_alphanumeric(c: text) -> bool:
    var result = is_alpha(c)
    if is_digit(c):
        result = true
    result

fn is_tag_name_char(c: text) -> bool:
    var result = is_alphanumeric(c)
    if c == "-":
        result = true
    if c == "_":
        result = true
    if c == ":":
        result = true
    result

fn is_attr_name_char(c: text) -> bool:
    var result = is_alphanumeric(c)
    if c == "-":
        result = true
    if c == "_":
        result = true
    if c == ":":
        result = true
    if c == ".":
        result = true
    result

# =============================================================================
# HTML Entity Encoding/Decoding (from html/entities.spl)
# =============================================================================

fn decode_html_entity(entity: text) -> text:
    var result = entity

    # Named entities
    if entity == "lt":
        result = "<"
    if entity == "gt":
        result = ">"
    if entity == "amp":
        result = "&"
    if entity == "quot":
        result = "\""
    if entity == "apos":
        result = "'"
    if entity == "nbsp":
        result = " "
    if entity == "copy":
        result = "©"
    if entity == "reg":
        result = "®"
    if entity == "trade":
        result = "™"
    if entity == "euro":
        result = "€"
    if entity == "pound":
        result = "£"
    if entity == "yen":
        result = "¥"
    if entity == "cent":
        result = "¢"
    if entity == "sect":
        result = "§"
    if entity == "deg":
        result = "°"
    if entity == "plusmn":
        result = "±"
    if entity == "micro":
        result = "µ"
    if entity == "para":
        result = "¶"
    if entity == "middot":
        result = "·"
    if entity == "frac14":
        result = "¼"
    if entity == "frac12":
        result = "½"
    if entity == "frac34":
        result = "¾"
    if entity == "times":
        result = "×"
    if entity == "divide":
        result = "÷"
    if entity == "hearts":
        result = "♥"
    if entity == "clubs":
        result = "♣"
    if entity == "diams":
        result = "♦"
    if entity == "spades":
        result = "♠"

    # Numeric entities (decimal)
    if entity.starts_with("#"):
        val num_part = entity.substring(1, entity.length())
        if num_part.length() > 0:
            var is_hex = false
            var final_num = num_part
            if num_part.starts_with("x"):
                is_hex = true
                final_num = num_part.substring(1, num_part.length())
            if final_num.length() > 0:
                var code = 0
                if is_hex:
                    result = entity
                else:
                    var i = 0
                    var valid = true
                    while i < final_num.length():
                        val c = final_num.substring(i, i + 1)
                        if is_digit(c):
                            val digit = c.char_code_at(0) - 48
                            code = code * 10 + digit
                        else:
                            valid = false
                            i = final_num.length()
                        i = i + 1
                    if valid:
                        if code > 0:
                            if code < 128:
                                result = text_from_char_code(code)

    result

fn decode_html_entities(input: text) -> text:
    var result = ""
    var i = 0
    while i < input.length():
        val c = input.substring(i, i + 1)
        if c == "&":
            var end_pos = i + 1
            var found_semi = false
            while end_pos < input.length():
                val ec = input.substring(end_pos, end_pos + 1)
                if ec == ";":
                    found_semi = true
                    end_pos = end_pos + 1
                    end_pos = input.length()
                else:
                    end_pos = end_pos + 1
                    if end_pos - i > 20:
                        end_pos = input.length()

            if found_semi:
                val entity_full = input.substring(i + 1, end_pos - 1)
                val decoded = decode_html_entity(entity_full)
                result = result + decoded
                i = end_pos
            else:
                result = result + c
                i = i + 1
        else:
            result = result + c
            i = i + 1
    result

fn encode_html_entities(input: text) -> text:
    var result = ""
    var i = 0
    while i < input.length():
        val c = input.substring(i, i + 1)
        if c == "<":
            result = result + "&lt;"
        else:
            if c == ">":
                result = result + "&gt;"
            else:
                if c == "&":
                    result = result + "&amp;"
                else:
                    if c == "\"":
                        result = result + "&quot;"
                    else:
                        result = result + c
        i = i + 1
    result

fn text_from_char_code(code: i64) -> text:
    var result = ""
    if code == 32:
        result = " "
    if code == 33:
        result = "!"
    if code == 34:
        result = "\""
    if code == 35:
        result = "#"
    if code == 36:
        result = "$"
    if code == 37:
        result = "%"
    if code == 38:
        result = "&"
    if code == 39:
        result = "'"
    if code == 40:
        result = "("
    if code == 41:
        result = ")"
    if code == 42:
        result = "*"
    if code == 43:
        result = "+"
    if code == 44:
        result = ","
    if code == 45:
        result = "-"
    if code == 46:
        result = "."
    if code == 47:
        result = "/"
    if code >= 48:
        if code <= 57:
            result = text_from_digit(code - 48)
    if code == 58:
        result = ":"
    if code == 59:
        result = ";"
    if code == 60:
        result = "<"
    if code == 61:
        result = "="
    if code == 62:
        result = ">"
    if code == 63:
        result = "?"
    if code == 64:
        result = "@"
    if code >= 65:
        if code <= 90:
            result = text_from_upper(code - 65)
    if code >= 97:
        if code <= 122:
            result = text_from_lower(code - 97)
    result

fn text_from_digit(n: i64) -> text:
    var result = ""
    if n == 0:
        result = "0"
    if n == 1:
        result = "1"
    if n == 2:
        result = "2"
    if n == 3:
        result = "3"
    if n == 4:
        result = "4"
    if n == 5:
        result = "5"
    if n == 6:
        result = "6"
    if n == 7:
        result = "7"
    if n == 8:
        result = "8"
    if n == 9:
        result = "9"
    result

fn text_from_upper(n: i64) -> text:
    var result = ""
    if n == 0:
        result = "A"
    if n == 1:
        result = "B"
    if n == 2:
        result = "C"
    if n == 3:
        result = "D"
    if n == 4:
        result = "E"
    if n == 5:
        result = "F"
    if n == 6:
        result = "G"
    if n == 7:
        result = "H"
    if n == 8:
        result = "I"
    if n == 9:
        result = "J"
    if n == 10:
        result = "K"
    if n == 11:
        result = "L"
    if n == 12:
        result = "M"
    if n == 13:
        result = "N"
    if n == 14:
        result = "O"
    if n == 15:
        result = "P"
    if n == 16:
        result = "Q"
    if n == 17:
        result = "R"
    if n == 18:
        result = "S"
    if n == 19:
        result = "T"
    if n == 20:
        result = "U"
    if n == 21:
        result = "V"
    if n == 22:
        result = "W"
    if n == 23:
        result = "X"
    if n == 24:
        result = "Y"
    if n == 25:
        result = "Z"
    result

fn text_from_lower(n: i64) -> text:
    var result = ""
    if n == 0:
        result = "a"
    if n == 1:
        result = "b"
    if n == 2:
        result = "c"
    if n == 3:
        result = "d"
    if n == 4:
        result = "e"
    if n == 5:
        result = "f"
    if n == 6:
        result = "g"
    if n == 7:
        result = "h"
    if n == 8:
        result = "i"
    if n == 9:
        result = "j"
    if n == 10:
        result = "k"
    if n == 11:
        result = "l"
    if n == 12:
        result = "m"
    if n == 13:
        result = "n"
    if n == 14:
        result = "o"
    if n == 15:
        result = "p"
    if n == 16:
        result = "q"
    if n == 17:
        result = "r"
    if n == 18:
        result = "s"
    if n == 19:
        result = "t"
    if n == 20:
        result = "u"
    if n == 21:
        result = "v"
    if n == 22:
        result = "w"
    if n == 23:
        result = "x"
    if n == 24:
        result = "y"
    if n == 25:
        result = "z"
    result

# =============================================================================
# Tokenization (from html/lexer.spl)
# =============================================================================

fn skip_whitespace(html: text, pos: i64) -> i64:
    var result = pos
    while result < html.length():
        val c = html.substring(result, result + 1)
        if is_whitespace(c):
            result = result + 1
        else:
            result = html.length()
    result

fn read_tag_name(html: text, pos: i64) -> (text, i64):
    var name = ""
    var current = pos
    while current < html.length():
        val c = html.substring(current, current + 1)
        if is_tag_name_char(c):
            name = name + c
            current = current + 1
        else:
            current = html.length()
    (name, current)

fn read_attr_name(html: text, pos: i64) -> (text, i64):
    var name = ""
    var current = pos
    while current < html.length():
        val c = html.substring(current, current + 1)
        if is_attr_name_char(c):
            name = name + c
            current = current + 1
        else:
            current = html.length()
    (name, current)

fn read_attr_value(html: text, pos: i64) -> (text, i64):
    var current = pos
    var value = ""

    if current < html.length():
        val first_char = html.substring(current, current + 1)
        if first_char == "\"":
            current = current + 1
            while current < html.length():
                val c = html.substring(current, current + 1)
                if c == "\"":
                    current = current + 1
                    current = html.length()
                else:
                    value = value + c
                    current = current + 1
        else:
            if first_char == "'":
                current = current + 1
                while current < html.length():
                    val c = html.substring(current, current + 1)
                    if c == "'":
                        current = current + 1
                        current = html.length()
                    else:
                        value = value + c
                        current = current + 1
            else:
                while current < html.length():
                    val c = html.substring(current, current + 1)
                    var is_end = is_whitespace(c)
                    if c == ">":
                        is_end = true
                    if is_end:
                        current = html.length()
                    else:
                        value = value + c
                        current = current + 1

    (value, current)

fn parse_attributes(html: text, start_pos: i64, end_pos: i64) -> list:
    var attrs = []
    var pos = start_pos

    while pos < end_pos:
        pos = skip_whitespace(html, pos)
        if pos >= end_pos:
            pos = end_pos
        else:
            val name_result = read_attr_name(html, pos)
            val attr_name = name_result[0]
            pos = name_result[1]

            if attr_name.length() > 0:
                pos = skip_whitespace(html, pos)
                var attr_value = ""

                if pos < end_pos:
                    val next_char = html.substring(pos, pos + 1)
                    if next_char == "=":
                        pos = pos + 1
                        pos = skip_whitespace(html, pos)
                        val value_result = read_attr_value(html, pos)
                        attr_value = value_result[0]
                        pos = value_result[1]
                    else:
                        attr_value = attr_name

                attrs = attrs.append((attr_name, attr_value))
            else:
                pos = end_pos

    attrs

fn tokenize_next(html: text, pos: i64) -> (text, text, list, i64):
    var token_type = TOKEN_EOF
    var token_value = ""
    var token_attrs = []
    var new_pos = pos

    if pos >= html.length():
        token_type = TOKEN_EOF
        new_pos = pos
    else:
        val c = html.substring(pos, pos + 1)
        if c == "<":
            if pos + 1 < html.length():
                val next_c = html.substring(pos + 1, pos + 2)
                if next_c == "!":
                    if pos + 3 < html.length():
                        val prefix = html.substring(pos, pos + 4)
                        if prefix == "<!--":
                            token_type = TOKEN_COMMENT
                            var end_pos = pos + 4
                            var found_end = false
                            while end_pos < html.length() - 2:
                                val ending = html.substring(end_pos, end_pos + 3)
                                if ending == "-->":
                                    token_value = html.substring(pos + 4, end_pos)
                                    new_pos = end_pos + 3
                                    found_end = true
                                    end_pos = html.length()
                                else:
                                    end_pos = end_pos + 1
                            if not found_end:
                                token_value = html.substring(pos + 4, html.length())
                                new_pos = html.length()
                        else:
                            val doctype_prefix = html.substring(pos, pos + 9)
                            var is_doctype = false
                            if doctype_prefix.to_lowercase() == "<!doctype":
                                is_doctype = true
                            if is_doctype:
                                token_type = TOKEN_DOCTYPE
                                var end_pos = pos + 9
                                while end_pos < html.length():
                                    val ec = html.substring(end_pos, end_pos + 1)
                                    if ec == ">":
                                        token_value = html.substring(pos + 9, end_pos)
                                        new_pos = end_pos + 1
                                        end_pos = html.length()
                                    else:
                                        end_pos = end_pos + 1
                            else:
                                token_type = TOKEN_TEXT
                                token_value = c
                                new_pos = pos + 1
                    else:
                        token_type = TOKEN_TEXT
                        token_value = c
                        new_pos = pos + 1
                else:
                    if next_c == "/":
                        token_type = TOKEN_TAG_CLOSE
                        var tag_start = pos + 2
                        val tag_result = read_tag_name(html, tag_start)
                        token_value = tag_result[0]
                        var tag_end = tag_result[1]
                        tag_end = skip_whitespace(html, tag_end)
                        if tag_end < html.length():
                            val close_c = html.substring(tag_end, tag_end + 1)
                            if close_c == ">":
                                new_pos = tag_end + 1
                            else:
                                new_pos = tag_end
                        else:
                            new_pos = tag_end
                    else:
                        var tag_start = pos + 1
                        val tag_result = read_tag_name(html, tag_start)
                        token_value = tag_result[0]
                        var tag_end = tag_result[1]
                        tag_end = skip_whitespace(html, tag_end)

                        var attr_start = tag_end
                        var found_close = false
                        var is_self_closing = false
                        while tag_end < html.length():
                            val ec = html.substring(tag_end, tag_end + 1)
                            if ec == ">":
                                token_attrs = parse_attributes(html, attr_start, tag_end)
                                found_close = true
                                new_pos = tag_end + 1
                                tag_end = html.length()
                            else:
                                if ec == "/":
                                    if tag_end + 1 < html.length():
                                        val next_ec = html.substring(tag_end + 1, tag_end + 2)
                                        if next_ec == ">":
                                            token_attrs = parse_attributes(html, attr_start, tag_end)
                                            is_self_closing = true
                                            found_close = true
                                            new_pos = tag_end + 2
                                            tag_end = html.length()
                                        else:
                                            tag_end = tag_end + 1
                                    else:
                                        tag_end = tag_end + 1
                                else:
                                    tag_end = tag_end + 1

                        if found_close:
                            if is_self_closing:
                                token_type = TOKEN_TAG_SELF_CLOSE
                            else:
                                token_type = TOKEN_TAG_OPEN
                        else:
                            token_type = TOKEN_TEXT
                            token_value = c
                            new_pos = pos + 1
            else:
                token_type = TOKEN_TEXT
                token_value = c
                new_pos = pos + 1
        else:
            token_type = TOKEN_TEXT
            var text_end = pos
            while text_end < html.length():
                val tc = html.substring(text_end, text_end + 1)
                if tc == "<":
                    text_end = html.length()
                else:
                    text_end = text_end + 1
            token_value = html.substring(pos, text_end)
            new_pos = text_end

    (token_type, token_value, token_attrs, new_pos)

fn tokenize_html(html: text) -> list:
    var tokens = []
    var pos = 0

    while pos < html.length():
        val result = tokenize_next(html, pos)
        val token_type = result[0]
        val token_value = result[1]
        val token_attrs = result[2]
        pos = result[3]

        if token_type != TOKEN_EOF:
            tokens = tokens.append((token_type, token_value, token_attrs))

    tokens

# =============================================================================
# DOM Node Creation (from html/dom.spl)
# =============================================================================

fn create_element(tag: text, attrs: list, children: list) -> tuple:
    (NODE_ELEMENT, tag, attrs, children, nil)

fn create_text_node(text: text) -> tuple:
    (NODE_TEXT, nil, [], [], text)

fn create_comment_node(text: text) -> tuple:
    (NODE_COMMENT, nil, [], [], text)

fn create_doctype_node(text: text) -> tuple:
    (NODE_DOCTYPE, nil, [], [], text)

fn node_type(node: tuple) -> text:
    node[0]

fn node_tag(node: tuple) -> text:
    node[1]

fn node_attrs(node: tuple) -> list:
    node[2]

fn node_children(node: tuple) -> list:
    node[3]

fn node_text(node: tuple) -> text:
    node[4]

# =============================================================================
# DOM Tree Construction (from html/parser.spl)
# =============================================================================

fn parse_html(html: text) -> tuple:
    val tokens = tokenize_html(html)
    var root_children = []
    var tag_stack = []
    var i = 0

    while i < tokens.length():
        val token = tokens[i]
        val token_type = token[0]
        val token_value = token[1]
        val token_attrs = token[2]

        if token_type == TOKEN_TAG_OPEN:
            val elem = create_element(token_value, token_attrs, [])

            if tag_stack.length() > 0:
                val parent_idx = tag_stack.length() - 1
                val parent_info = tag_stack[parent_idx]
                val parent_node = parent_info[0]
                val parent_children = node_children(parent_node)
                val updated_children = parent_children.append(elem)
                val updated_parent = (node_type(parent_node), node_tag(parent_node), node_attrs(parent_node), updated_children, node_text(parent_node))
                tag_stack = tag_stack.set(parent_idx, (updated_parent, parent_info[1]))
            else:
                root_children = root_children.append(elem)

            var should_push = true
            if is_void_element(token_value):
                should_push = false

            if should_push:
                tag_stack = tag_stack.append((elem, token_value))
        else:
            if token_type == TOKEN_TAG_CLOSE:
                if tag_stack.length() > 0:
                    val top_info = tag_stack[tag_stack.length() - 1]
                    val top_tag = top_info[1]
                    val top_tag_lower = top_tag.to_lowercase()
                    val close_tag_lower = token_value.to_lowercase()

                    if top_tag_lower == close_tag_lower:
                        tag_stack = tag_stack.slice(0, tag_stack.length() - 1)
                    else:
                        var found_match = false
                        var match_idx = tag_stack.length() - 1
                        while match_idx >= 0:
                            val check_info = tag_stack[match_idx]
                            val check_tag = check_info[1]
                            val check_tag_lower = check_tag.to_lowercase()
                            if check_tag_lower == close_tag_lower:
                                found_match = true
                                match_idx = -1
                            else:
                                match_idx = match_idx - 1

                        if found_match:
                            var close_count = tag_stack.length() - match_idx - 1
                            var j = 0
                            while j < close_count:
                                tag_stack = tag_stack.slice(0, tag_stack.length() - 1)
                                j = j + 1
            else:
                if token_type == TOKEN_TAG_SELF_CLOSE:
                    val elem = create_element(token_value, token_attrs, [])
                    if tag_stack.length() > 0:
                        val parent_idx = tag_stack.length() - 1
                        val parent_info = tag_stack[parent_idx]
                        val parent_node = parent_info[0]
                        val parent_children = node_children(parent_node)
                        val updated_children = parent_children.append(elem)
                        val updated_parent = (node_type(parent_node), node_tag(parent_node), node_attrs(parent_node), updated_children, node_text(parent_node))
                        tag_stack = tag_stack.set(parent_idx, (updated_parent, parent_info[1]))
                    else:
                        root_children = root_children.append(elem)
                else:
                    if token_type == TOKEN_TEXT:
                        val trimmed = token_value.trim()
                        if trimmed.length() > 0:
                            val decoded = decode_html_entities(token_value)
                            val text_node = create_text_node(decoded)
                            if tag_stack.length() > 0:
                                val parent_idx = tag_stack.length() - 1
                                val parent_info = tag_stack[parent_idx]
                                val parent_node = parent_info[0]
                                val parent_children = node_children(parent_node)
                                val updated_children = parent_children.append(text_node)
                                val updated_parent = (node_type(parent_node), node_tag(parent_node), node_attrs(parent_node), updated_children, node_text(parent_node))
                                tag_stack = tag_stack.set(parent_idx, (updated_parent, parent_info[1]))
                            else:
                                root_children = root_children.append(text_node)
                    else:
                        if token_type == TOKEN_COMMENT:
                            val comment_node = create_comment_node(token_value)
                            if tag_stack.length() > 0:
                                val parent_idx = tag_stack.length() - 1
                                val parent_info = tag_stack[parent_idx]
                                val parent_node = parent_info[0]
                                val parent_children = node_children(parent_node)
                                val updated_children = parent_children.append(comment_node)
                                val updated_parent = (node_type(parent_node), node_tag(parent_node), node_attrs(parent_node), updated_children, node_text(parent_node))
                                tag_stack = tag_stack.set(parent_idx, (updated_parent, parent_info[1]))
                            else:
                                root_children = root_children.append(comment_node)
                        else:
                            if token_type == TOKEN_DOCTYPE:
                                val doctype_node = create_doctype_node(token_value)
                                root_children = root_children.append(doctype_node)

        i = i + 1

    while tag_stack.length() > 0:
        tag_stack = tag_stack.slice(0, tag_stack.length() - 1)

    create_element("root", [], root_children)

# =============================================================================
# Tree Navigation (from html/dom.spl)
# =============================================================================

fn get_element_attr(node: tuple, attr_name: text) -> text:
    val attrs = node_attrs(node)
    var result = nil
    var i = 0
    while i < attrs.length():
        val attr = attrs[i]
        val name = attr[0]
        if name == attr_name:
            result = attr[1]
            i = attrs.length()
        else:
            i = i + 1
    result

fn has_element_attr(node: tuple, attr_name: text) -> bool:
    val attr_value = get_element_attr(node, attr_name)
    attr_value != nil

fn get_element_id(node: tuple) -> text:
    get_element_attr(node, "id")

fn get_element_class(node: tuple) -> text:
    get_element_attr(node, "class")

fn has_class(node: tuple, class_name: text) -> bool:
    val class_attr = get_element_class(node)
    var result = false
    if class_attr != nil:
        val classes = class_attr.split(" ")
        var i = 0
        while i < classes.length():
            val cls = classes[i].trim()
            if cls == class_name:
                result = true
                i = classes.length()
            else:
                i = i + 1
    result

fn find_by_tag(node: tuple, tag_name: text) -> list:
    var results = []
    val tag_lower = tag_name.to_lowercase()
    val node_tag_name = node_tag(node)

    if node_tag_name != nil:
        val node_tag_lower = node_tag_name.to_lowercase()
        if node_tag_lower == tag_lower:
            results = results.append(node)

    val children = node_children(node)
    var i = 0
    while i < children.length():
        val child = children[i]
        val child_results = find_by_tag(child, tag_name)
        results = results.concat(child_results)
        i = i + 1

    results

fn find_by_id(node: tuple, id: text) -> tuple:
    var result = nil
    val node_id = get_element_id(node)

    if node_id != nil:
        if node_id == id:
            result = node

    if result == nil:
        val children = node_children(node)
        var i = 0
        while i < children.length():
            if result == nil:
                val child = children[i]
                val child_result = find_by_id(child, id)
                if child_result != nil:
                    result = child_result
            i = i + 1

    result

fn find_by_class(node: tuple, class_name: text) -> list:
    var results = []

    if has_class(node, class_name):
        results = results.append(node)

    val children = node_children(node)
    var i = 0
    while i < children.length():
        val child = children[i]
        val child_results = find_by_class(child, class_name)
        results = results.concat(child_results)
        i = i + 1

    results

fn get_descendants(node: tuple) -> list:
    var results = []
    val children = node_children(node)
    var i = 0
    while i < children.length():
        val child = children[i]
        results = results.append(child)
        val child_descendants = get_descendants(child)
        results = results.concat(child_descendants)
        i = i + 1
    results

fn get_text_content(node: tuple) -> text:
    var result = ""
    val ntype = node_type(node)

    if ntype == NODE_TEXT:
        result = node_text(node)
    else:
        if ntype == NODE_ELEMENT:
            val children = node_children(node)
            var i = 0
            while i < children.length():
                val child = children[i]
                val child_text = get_text_content(child)
                result = result + child_text
                i = i + 1

    result

# =============================================================================
# HTML Serialization (from html/serializer.spl)
# =============================================================================

fn render_attrs(attrs: list) -> text:
    var result = ""
    var i = 0
    while i < attrs.length():
        val attr = attrs[i]
        val name = attr[0]
        val value = attr[1]
        result = result + " " + name
        if value != name:
            val escaped = encode_html_entities(value)
            result = result + "=\"" + escaped + "\""
        i = i + 1
    result

fn render_html_node(node: tuple, indent_level: i64, pretty: bool) -> text:
    var result = ""
    val ntype = node_type(node)
    val indent_str = create_indent(indent_level)

    if ntype == NODE_ELEMENT:
        val tag = node_tag(node)
        val attrs = node_attrs(node)
        val children = node_children(node)
        val attrs_str = render_attrs(attrs)

        if pretty:
            result = result + indent_str
        result = result + "<" + tag + attrs_str + ">"

        if children.length() > 0:
            var has_element_child = false
            var i = 0
            while i < children.length():
                val child = children[i]
                val child_type = node_type(child)
                if child_type == NODE_ELEMENT:
                    has_element_child = true
                i = i + 1

            if has_element_child:
                if pretty:
                    result = result + "\n"

            i = 0
            while i < children.length():
                val child = children[i]
                val child_html = render_html_node(child, indent_level + 1, pretty)
                result = result + child_html
                i = i + 1

            if has_element_child:
                if pretty:
                    result = result + indent_str

        result = result + "</" + tag + ">"
        if pretty:
            result = result + "\n"
    else:
        if ntype == NODE_TEXT:
            val text = node_text(node)
            val encoded = encode_html_entities(text)
            result = encoded
        else:
            if ntype == NODE_COMMENT:
                val text = node_text(node)
                if pretty:
                    result = indent_str
                result = result + "<!--" + text + "-->"
                if pretty:
                    result = result + "\n"
            else:
                if ntype == NODE_DOCTYPE:
                    val text = node_text(node)
                    if pretty:
                        result = indent_str
                    result = result + "<!DOCTYPE" + text + ">"
                    if pretty:
                        result = result + "\n"

    result

fn create_indent(level: i64) -> text:
    var result = ""
    var i = 0
    while i < level:
        result = result + "  "
        i = i + 1
    result

fn render_html(node: tuple, pretty: bool) -> text:
    var result = ""
    val children = node_children(node)
    var i = 0
    while i < children.length():
        val child = children[i]
        val child_html = render_html_node(child, 0, pretty)
        result = result + child_html
        i = i + 1
    result

fn render_html_pretty(node: tuple) -> text:
    render_html(node, true)

fn render_html_compact(node: tuple) -> text:
    render_html(node, false)

# =============================================================================
# Utility Functions (from html/utilities.spl)
# =============================================================================

fn strip_html_tags(html: text) -> text:
    val tree = parse_html(html)
    get_text_content(tree)

fn extract_links(node: tuple) -> list:
    val anchors = find_by_tag(node, "a")
    var links = []
    var i = 0
    while i < anchors.length():
        val anchor = anchors[i]
        val href = get_element_attr(anchor, "href")
        if href != nil:
            links = links.append(href)
        i = i + 1
    links

fn extract_images(node: tuple) -> list:
    val imgs = find_by_tag(node, "img")
    var images = []
    var i = 0
    while i < imgs.length():
        val img = imgs[i]
        val src = get_element_attr(img, "src")
        val alt = get_element_attr(img, "alt")
        if src != nil:
            images = images.append((src, alt))
        i = i + 1
    images

fn get_title(node: tuple) -> text:
    val titles = find_by_tag(node, "title")
    var result = nil
    if titles.length() > 0:
        val title_node = titles[0]
        result = get_text_content(title_node).trim()
    result

fn get_meta_content(node: tuple, name: text) -> text:
    val metas = find_by_tag(node, "meta")
    var result = nil
    var i = 0
    while i < metas.length():
        if result == nil:
            val meta = metas[i]
            val meta_name = get_element_attr(meta, "name")
            if meta_name != nil:
                if meta_name == name:
                    result = get_element_attr(meta, "content")
        i = i + 1
    result

fn find_first_by_tag(node: tuple, tag_name: text) -> tuple:
    var result = nil
    val tag_lower = tag_name.to_lowercase()
    val node_tag_name = node_tag(node)

    if node_tag_name != nil:
        val node_tag_lower = node_tag_name.to_lowercase()
        if node_tag_lower == tag_lower:
            result = node

    if result == nil:
        val children = node_children(node)
        var i = 0
        while i < children.length():
            if result == nil:
                val child = children[i]
                result = find_first_by_tag(child, tag_name)
            i = i + 1

    result

fn has_tag(node: tuple, tag_name: text) -> bool:
    val found = find_first_by_tag(node, tag_name)
    found != nil

fn get_element_count_by_tag(node: tuple, tag_name: text) -> i64:
    val elements = find_by_tag(node, tag_name)
    elements.length()

fn find_by_attr(node: tuple, attr_name: text, attr_value: text) -> list:
    var results = []
    val node_attr = get_element_attr(node, attr_name)

    if node_attr != nil:
        if node_attr == attr_value:
            results = results.append(node)

    val children = node_children(node)
    var i = 0
    while i < children.length():
        val child = children[i]
        val child_results = find_by_attr(child, attr_name, attr_value)
        results = results.concat(child_results)
        i = i + 1

    results

fn find_first_by_class(node: tuple, class_name: text) -> tuple:
    var result = nil

    if has_class(node, class_name):
        result = node

    if result == nil:
        val children = node_children(node)
        var i = 0
        while i < children.length():
            if result == nil:
                val child = children[i]
                result = find_first_by_class(child, class_name)
            i = i + 1

    result

fn filter_elements(node: tuple, predicate_tag: text) -> list:
    var results = []
    val tag_lower = predicate_tag.to_lowercase()
    val node_tag_name = node_tag(node)

    if node_tag_name != nil:
        val node_tag_lower = node_tag_name.to_lowercase()
        if node_tag_lower == tag_lower:
            results = results.append(node)

    val children = node_children(node)
    var i = 0
    while i < children.length():
        val child = children[i]
        val child_results = filter_elements(child, predicate_tag)
        results = results.concat(child_results)
        i = i + 1

    results

fn get_siblings(parent: tuple, target: tuple) -> list:
    var siblings = []
    val children = node_children(parent)
    var i = 0
    while i < children.length():
        val child = children[i]
        if child != target:
            siblings = siblings.append(child)
        i = i + 1
    siblings

fn get_first_child(node: tuple) -> tuple:
    val children = node_children(node)
    var result = nil
    if children.length() > 0:
        result = children[0]
    result

fn get_last_child(node: tuple) -> tuple:
    val children = node_children(node)
    var result = nil
    if children.length() > 0:
        result = children[children.length() - 1]
    result

fn get_child_count(node: tuple) -> i64:
    val children = node_children(node)
    children.length()

fn is_empty_element(node: tuple) -> bool:
    val children = node_children(node)
    children.length() == 0

fn has_children(node: tuple) -> bool:
    val children = node_children(node)
    children.length() > 0

fn has_text_content(node: tuple) -> bool:
    val text = get_text_content(node).trim()
    text.length() > 0

fn add_child(node: tuple, child: tuple) -> tuple:
    val ntype = node_type(node)
    val tag = node_tag(node)
    val attrs = node_attrs(node)
    val children = node_children(node)
    val text = node_text(node)
    val new_children = children.append(child)
    (ntype, tag, attrs, new_children, text)

fn set_attr(node: tuple, attr_name: text, attr_value: text) -> tuple:
    val ntype = node_type(node)
    val tag = node_tag(node)
    val old_attrs = node_attrs(node)
    val children = node_children(node)
    val text = node_text(node)

    var new_attrs = []
    var i = 0
    while i < old_attrs.length():
        val attr = old_attrs[i]
        val name = attr[0]
        if name != attr_name:
            new_attrs = new_attrs.append(attr)
        i = i + 1

    new_attrs = new_attrs.append((attr_name, attr_value))

    (ntype, tag, new_attrs, children, text)

fn remove_attr(node: tuple, attr_name: text) -> tuple:
    val ntype = node_type(node)
    val tag = node_tag(node)
    val old_attrs = node_attrs(node)
    val children = node_children(node)
    val text = node_text(node)

    var new_attrs = []
    var i = 0
    while i < old_attrs.length():
        val attr = old_attrs[i]
        val name = attr[0]
        if name != attr_name:
            new_attrs = new_attrs.append(attr)
        i = i + 1

    (ntype, tag, new_attrs, children, text)

fn set_children(node: tuple, new_children: list) -> tuple:
    val ntype = node_type(node)
    val tag = node_tag(node)
    val attrs = node_attrs(node)
    val text = node_text(node)
    (ntype, tag, attrs, new_children, text)

fn clear_children(node: tuple) -> tuple:
    set_children(node, [])

fn set_text(node: tuple, new_text: text) -> tuple:
    val ntype = node_type(node)
    val tag = node_tag(node)
    val attrs = node_attrs(node)
    val children = node_children(node)
    (ntype, tag, attrs, children, new_text)

fn parse_fragment(html: text) -> list:
    val tree = parse_html(html)
    node_children(tree)

fn render_fragment(nodes: list, pretty: bool) -> text:
    var result = ""
    var i = 0
    while i < nodes.length():
        val node = nodes[i]
        val node_html = render_html_node(node, 0, pretty)
        result = result + node_html
        i = i + 1
    result

fn render_fragment_pretty(nodes: list) -> text:
    render_fragment(nodes, true)

fn render_fragment_compact(nodes: list) -> text:
    render_fragment(nodes, false)

fn get_table_rows(table: tuple) -> list:
    find_by_tag(table, "tr")

fn get_table_cells(row: tuple) -> list:
    var cells = find_by_tag(row, "td")
    val headers = find_by_tag(row, "th")
    cells.concat(headers)

fn get_table_headers(table: tuple) -> list:
    find_by_tag(table, "th")

fn extract_table_data(table: tuple) -> list:
    var data = []
    val rows = get_table_rows(table)
    var i = 0
    while i < rows.length():
        val row = rows[i]
        val cells = get_table_cells(row)
        var row_data = []
        var j = 0
        while j < cells.length():
            val cell = cells[j]
            val cell_text = get_text_content(cell).trim()
            row_data = row_data.append(cell_text)
            j = j + 1
        data = data.append(row_data)
        i = i + 1
    data

fn get_form_inputs(form: tuple) -> list:
    find_by_tag(form, "input")

fn get_form_field_value(form: tuple, field_name: text) -> text:
    val inputs = get_form_inputs(form)
    var result = nil
    var i = 0
    while i < inputs.length():
        if result == nil:
            val input = inputs[i]
            val name = get_element_attr(input, "name")
            if name != nil:
                if name == field_name:
                    result = get_element_attr(input, "value")
        i = i + 1
    result

fn get_form_action(form: tuple) -> text:
    get_element_attr(form, "action")

fn get_form_method(form: tuple) -> text:
    val method = get_element_attr(form, "method")
    var result = "get"
    if method != nil:
        result = method.to_lowercase()
    result

fn get_list_items(list_node: tuple) -> list:
    find_by_tag(list_node, "li")

fn extract_list_text(list_node: tuple) -> list:
    val items = get_list_items(list_node)
    var texts = []
    var i = 0
    while i < items.length():
        val item = items[i]
        val text = get_text_content(item).trim()
        texts = texts.append(text)
        i = i + 1
    texts

fn count_elements(node: tuple) -> i64:
    var count = 0
    val ntype = node_type(node)
    if ntype == NODE_ELEMENT:
        count = 1
    val children = node_children(node)
    var i = 0
    while i < children.length():
        val child = children[i]
        count = count + count_elements(child)
        i = i + 1
    count

fn count_text_nodes(node: tuple) -> i64:
    var count = 0
    val ntype = node_type(node)
    if ntype == NODE_TEXT:
        count = 1
    val children = node_children(node)
    var i = 0
    while i < children.length():
        val child = children[i]
        count = count + count_text_nodes(child)
        i = i + 1
    count

fn get_max_depth(node: tuple) -> i64:
    var max = 0
    val children = node_children(node)
    var i = 0
    while i < children.length():
        val child = children[i]
        val child_depth = get_max_depth(child)
        if child_depth > max:
            max = child_depth
        i = i + 1
    max + 1

fn count_all_nodes(node: tuple) -> i64:
    var count = 1
    val children = node_children(node)
    var i = 0
    while i < children.length():
        val child = children[i]
        count = count + count_all_nodes(child)
        i = i + 1
    count

fn count_comments(node: tuple) -> i64:
    var count = 0
    val ntype = node_type(node)
    if ntype == NODE_COMMENT:
        count = 1
    val children = node_children(node)
    var i = 0
    while i < children.length():
        val child = children[i]
        count = count + count_comments(child)
        i = i + 1
    count

fn get_total_text_length(node: tuple) -> i64:
    val text = get_text_content(node)
    text.length()

fn get_attr_count(node: tuple) -> i64:
    val attrs = node_attrs(node)
    attrs.length()

fn get_total_attrs(node: tuple) -> i64:
    var count = get_attr_count(node)
    val children = node_children(node)
    var i = 0
    while i < children.length():
        val child = children[i]
        count = count + get_total_attrs(child)
        i = i + 1
    count

fn has_doctype(node: tuple) -> bool:
    val children = node_children(node)
    var result = false
    var i = 0
    while i < children.length():
        val child = children[i]
        val ntype = node_type(child)
        if ntype == NODE_DOCTYPE:
            result = true
            i = children.length()
        else:
            i = i + 1
    result

fn has_html_tag(node: tuple) -> bool:
    has_tag(node, "html")

fn has_head_tag(node: tuple) -> bool:
    has_tag(node, "head")

fn has_body_tag(node: tuple) -> bool:
    has_tag(node, "body")

fn is_well_formed_document(node: tuple) -> bool:
    var result = has_html_tag(node)
    if result:
        result = has_head_tag(node)
    if result:
        result = has_body_tag(node)
    result

fn node_to_string(node: tuple) -> text:
    val ntype = node_type(node)
    var result = "Node("

    if ntype == NODE_ELEMENT:
        val tag = node_tag(node)
        val attrs = node_attrs(node)
        val children = node_children(node)
        result = result + "ELEMENT, " + tag + ", " + attrs.length().to_text() + " attrs, " + children.length().to_text() + " children"
    else:
        if ntype == NODE_TEXT:
            val text = node_text(node)
            var preview = text
            if preview.length() > 30:
                preview = preview.substring(0, 30) + "..."
            result = result + "TEXT, \"" + preview + "\""
        else:
            if ntype == NODE_COMMENT:
                val text = node_text(node)
                var preview = text
                if preview.length() > 30:
                    preview = preview.substring(0, 30) + "..."
                result = result + "COMMENT, \"" + preview + "\""
            else:
                if ntype == NODE_DOCTYPE:
                    val text = node_text(node)
                    result = result + "DOCTYPE, \"" + text + "\""
                else:
                    result = result + ntype

    result = result + ")"
    result

fn print_tree(node: tuple, indent: i64):
    val indent_str = create_indent(indent)
    print indent_str + node_to_string(node)

    val children = node_children(node)
    var i = 0
    while i < children.length():
        val child = children[i]
        print_tree(child, indent + 1)
        i = i + 1

fn get_tree_summary(node: tuple) -> text:
    val total_nodes = count_all_nodes(node)
    val elements = count_elements(node)
    val text_nodes = count_text_nodes(node)
    val comments = count_comments(node)
    val depth = get_max_depth(node)

    var result = "Tree Summary:\n"
    result = result + "  Total nodes: " + total_nodes.to_text() + "\n"
    result = result + "  Elements: " + elements.to_text() + "\n"
    result = result + "  Text nodes: " + text_nodes.to_text() + "\n"
    result = result + "  Comments: " + comments.to_text() + "\n"
    result = result + "  Max depth: " + depth.to_text()
    result
