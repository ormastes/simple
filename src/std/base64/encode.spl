# Base64 Encode Module
#
# Encoding functions for Base64, Base32, hex, and binary formats

use base64::types::{BASE64_ALPHABET, BASE64_URL_ALPHABET, BASE32_ALPHABET, BASE32_HEX_ALPHABET, HEX_ALPHABET_LOWER, HEX_ALPHABET_UPPER, PADDING_CHAR}
use base64::utilities::{text_to_bytes, list_length, list_get, text_concat, base64_index_to_char, text_char_at, byte_to_bits, int_to_text}

# ============================================================================
# STANDARD BASE64 ENCODING
# ============================================================================

# Encode data using standard Base64
fn encode_base64(data: text) -> text:
    encode_base64_with_alphabet(data, BASE64_ALPHABET, true)

# Encode data using standard Base64 without padding
fn encode_base64_no_pad(data: text) -> text:
    encode_base64_with_alphabet(data, BASE64_ALPHABET, false)

# Encode using custom alphabet with optional padding
fn encode_base64_with_alphabet(data: text, alphabet: text, use_padding: bool) -> text:
    var bytes = text_to_bytes(data)
    var result = ""
    var i = 0
    var len = list_length(bytes)

    # Process 3 bytes at a time
    while i < len:
        var b1 = list_get(bytes, i)
        var b2 = 0
        var b3 = 0
        var has_b2 = false
        var has_b3 = false

        if i + 1 < len:
            b2 = list_get(bytes, i + 1)
            has_b2 = true
        if i + 2 < len:
            b3 = list_get(bytes, i + 2)
            has_b3 = true

        # Convert 3 bytes to 4 Base64 characters
        # First character: top 6 bits of b1
        var idx1 = b1 / 4
        var c1 = base64_index_to_char(idx1, alphabet)
        result = text_concat(result, c1)

        # Second character: bottom 2 bits of b1 + top 4 bits of b2
        var idx2 = ((b1 % 4) * 16) + (b2 / 16)
        var c2 = base64_index_to_char(idx2, alphabet)
        result = text_concat(result, c2)

        # Third character
        if has_b2:
            var idx3 = ((b2 % 16) * 4) + (b3 / 64)
            var c3 = base64_index_to_char(idx3, alphabet)
            result = text_concat(result, c3)
        else:
            if use_padding:
                result = text_concat(result, PADDING_CHAR)

        # Fourth character
        if has_b3:
            var idx4 = b3 % 64
            var c4 = base64_index_to_char(idx4, alphabet)
            result = text_concat(result, c4)
        else:
            if use_padding:
                result = text_concat(result, PADDING_CHAR)

        i = i + 3

    result

# ============================================================================
# URL-SAFE BASE64 ENCODING
# ============================================================================

# Encode data using URL-safe Base64
fn encode_base64_url(data: text) -> text:
    encode_base64_with_alphabet(data, BASE64_URL_ALPHABET, true)

# Encode data using URL-safe Base64 without padding
fn encode_base64_url_no_pad(data: text) -> text:
    encode_base64_with_alphabet(data, BASE64_URL_ALPHABET, false)

# ============================================================================
# BASE32 ENCODING
# ============================================================================

# Encode data using standard Base32
fn encode_base32(data: text) -> text:
    encode_base32_with_alphabet(data, BASE32_ALPHABET, true)

# Encode data using Base32 hex alphabet
fn encode_base32_hex(data: text) -> text:
    encode_base32_with_alphabet(data, BASE32_HEX_ALPHABET, true)

# Encode data using Base32 without padding
fn encode_base32_no_pad(data: text) -> text:
    encode_base32_with_alphabet(data, BASE32_ALPHABET, false)

# Encode using custom Base32 alphabet
fn encode_base32_with_alphabet(data: text, alphabet: text, use_padding: bool) -> text:
    var bytes = text_to_bytes(data)
    var result = ""
    var i = 0
    var len = list_length(bytes)

    # Process 5 bytes at a time (40 bits -> 8 characters of 5 bits each)
    while i < len:
        var b1 = list_get(bytes, i)
        var b2 = 0
        var b3 = 0
        var b4 = 0
        var b5 = 0
        var count = 1

        if i + 1 < len:
            b2 = list_get(bytes, i + 1)
            count = 2
        if i + 2 < len:
            b3 = list_get(bytes, i + 2)
            count = 3
        if i + 3 < len:
            b4 = list_get(bytes, i + 3)
            count = 4
        if i + 4 < len:
            b5 = list_get(bytes, i + 4)
            count = 5

        # Convert 5 bytes to 8 Base32 characters (5 bits each)
        var idx1 = b1 / 8
        var c1 = text_char_at(alphabet, idx1)
        result = text_concat(result, c1)

        var idx2 = ((b1 % 8) * 4) + (b2 / 64)
        var c2 = text_char_at(alphabet, idx2)
        result = text_concat(result, c2)

        if count >= 2:
            var idx3 = (b2 / 2) % 32
            var c3 = text_char_at(alphabet, idx3)
            result = text_concat(result, c3)

            var idx4 = ((b2 % 2) * 16) + (b3 / 16)
            var c4 = text_char_at(alphabet, idx4)
            result = text_concat(result, c4)
        else:
            if use_padding:
                result = text_concat(result, PADDING_CHAR)
                result = text_concat(result, PADDING_CHAR)

        if count >= 3:
            var idx5 = ((b3 % 16) * 2) + (b4 / 128)
            var c5 = text_char_at(alphabet, idx5)
            result = text_concat(result, c5)
        else:
            if use_padding:
                result = text_concat(result, PADDING_CHAR)

        if count >= 4:
            var idx6 = (b4 / 4) % 32
            var c6 = text_char_at(alphabet, idx6)
            result = text_concat(result, c6)

            var idx7 = ((b4 % 4) * 8) + (b5 / 32)
            var c7 = text_char_at(alphabet, idx7)
            result = text_concat(result, c7)
        else:
            if use_padding:
                result = text_concat(result, PADDING_CHAR)
                result = text_concat(result, PADDING_CHAR)

        if count >= 5:
            var idx8 = b5 % 32
            var c8 = text_char_at(alphabet, idx8)
            result = text_concat(result, c8)
        else:
            if use_padding:
                result = text_concat(result, PADDING_CHAR)

        i = i + 5

    result

# ============================================================================
# HEXADECIMAL ENCODING
# ============================================================================

# Encode data as lowercase hexadecimal
fn encode_hex(data: text) -> text:
    encode_hex_with_alphabet(data, HEX_ALPHABET_LOWER)

# Encode data as uppercase hexadecimal
fn encode_hex_upper(data: text) -> text:
    encode_hex_with_alphabet(data, HEX_ALPHABET_UPPER)

# Encode data as lowercase hexadecimal (alias)
fn encode_hex_lower(data: text) -> text:
    encode_hex_with_alphabet(data, HEX_ALPHABET_LOWER)

# Encode using custom hex alphabet
fn encode_hex_with_alphabet(data: text, alphabet: text) -> text:
    var bytes = text_to_bytes(data)
    var result = ""
    var i = 0
    var len = list_length(bytes)

    while i < len:
        var byte_val = list_get(bytes, i)
        var high = byte_val / 16
        var low = byte_val % 16
        var high_char = text_char_at(alphabet, high)
        var low_char = text_char_at(alphabet, low)
        result = text_concat(result, high_char)
        result = text_concat(result, low_char)
        i = i + 1

    result

# ============================================================================
# BINARY ENCODING
# ============================================================================

# Encode data as binary string (8 bits per byte)
fn encode_binary(bytes: list) -> text:
    var result = ""
    var i = 0
    var len = list_length(bytes)

    while i < len:
        var byte_val = list_get(bytes, i)
        var bits = byte_to_bits(byte_val)
        if i > 0:
            result = text_concat(result, " ")
        result = text_concat(result, bits)
        i = i + 1

    result

# ============================================================================
# INTEGER ENCODING
# ============================================================================

# Encode integer as Base64
fn encode_int(n: i64) -> text:
    var text_repr = int_to_text(n)
    encode_base64(text_repr)

# ============================================================================
# CHUNKED/MULTILINE ENCODING
# ============================================================================

# Encode data with line breaks at specified length
fn encode_chunked(data: text, line_length: i64) -> text:
    var encoded = encode_base64(data)
    var multiline_util = use base64::utilities::{encode_multiline}
    multiline_util.encode_multiline(encoded, line_length)

# ============================================================================
# STREAMING ENCODING
# ============================================================================

# Encode data in streaming chunks
fn encode_stream(data: text, chunk_size: i64) -> list:
    var result = []
    var i = 0
    var text_util = use base64::utilities::{text_length, text_substring, list_append}
    var len = text_util.text_length(data)

    while i < len:
        var end = i + chunk_size
        if end > len:
            end = len
        var chunk = text_util.text_substring(data, i, end)
        var encoded = encode_base64(chunk)
        result = text_util.list_append(result, encoded)
        i = end

    result
