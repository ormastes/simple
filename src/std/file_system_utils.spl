# File System Utilities
#
# Comprehensive file system operations module with 80+ functions.
# Pure Simple implementation focusing on logic and structure.
# Uses Option/nil pattern for error handling (no try/catch).
# Avoids runtime-unsupported features: generics, chained methods.
#
# Categories:
# - File Operations: create, read, write, append, delete, rename, copy, move
# - Directory Operations: create, list, delete, traverse, walk (recursive)
# - Path Operations: join, split, normalize, absolute, relative, basename, dirname
# - File Info: size, modified time, permissions, file type checks
# - Permissions: read, write, execute for owner/group/others
# - Temporary Files: temp files, temp directories, auto-cleanup
# - Glob Patterns: file matching with wildcards
# - Directory Tree: create tree, copy tree, delete tree
# - Symlinks: create, read, resolve
# - File Watching: change detection (mock)
# - Disk Usage: file size, directory size calculations
# - Utility Functions: extensions, stems, file type detection

use std.path

# ============================================================================
# Data Structures (Tuple-based, no generics)
# ============================================================================

# File info: (path, size, modified, permissions)
# Permission bits: owner_read, owner_write, owner_exec, group_read, group_write, group_exec, other_read, other_write, other_exec

struct FileInfo:
    """File information structure.

    Contains metadata about a file.
    """
    path: text
    size: i64
    modified_time: i64
    is_file: bool
    is_directory: bool
    is_symlink: bool
    permissions: i64

struct DirEntry:
    """Directory entry information."""
    name: text
    path: text
    is_file: bool
    is_directory: bool
    size: i64

struct Permission:
    """File permission structure."""
    owner_read: bool
    owner_write: bool
    owner_exec: bool
    group_read: bool
    group_write: bool
    group_exec: bool
    other_read: bool
    other_write: bool
    other_exec: bool

struct TempFile:
    """Temporary file handle."""
    path: text
    cleanup_on_drop: bool

# ============================================================================
# File Operations
# ============================================================================

fn file_create(path: text) -> bool:
    """Create a new empty file.

    Args:
        path: File path

    Returns:
        true on success, false on error
    """
    # Mock: simulate file creation
    if path == "" or path.contains(".."):
        return false
    true

fn file_read_text(path: text) -> text?:
    """Read entire file as text.

    Args:
        path: File path

    Returns:
        Some(content) or nil on error
    """
    if path == "" or not file_exists_mock(path):
        return nil
    Some("mock file content: " + path)

fn file_read_bytes(path: text) -> [i64]?:
    """Read file as byte array.

    Args:
        path: File path

    Returns:
        Some(bytes) or nil on error
    """
    if path == "" or not file_exists_mock(path):
        return nil
    Some([72, 101, 108, 108, 111])

fn file_read_lines(path: text) -> [text]?:
    """Read file as array of lines.

    Args:
        path: File path

    Returns:
        Some(lines) or nil on error
    """
    val content_opt = file_read_text(path)
    if not content_opt.?:
        return nil
    val content = content_opt.unwrap()
    val lines = content.split("\n")
    Some(lines)

fn file_write_text(path: text, content: text) -> bool:
    """Write text to file (overwrite).

    Args:
        path: File path
        content: Text content

    Returns:
        true on success, false on error
    """
    if path == "" or content == nil:
        return false
    true

fn file_write_bytes(path: text, bytes: [i64]) -> bool:
    """Write bytes to file (overwrite).

    Args:
        path: File path
        bytes: Byte array

    Returns:
        true on success, false on error
    """
    if path == "" or bytes == nil:
        return false
    true

fn file_write_lines(path: text, lines: [text]) -> bool:
    """Write lines to file with newlines.

    Args:
        path: File path
        lines: Array of lines

    Returns:
        true on success, false on error
    """
    if path == "" or lines == nil:
        return false
    val content = lines.join("\n")
    file_write_text(path, content)

fn file_append_text(path: text, content: text) -> bool:
    """Append text to file.

    Args:
        path: File path
        content: Text to append

    Returns:
        true on success, false on error
    """
    if path == "" or content == nil:
        return false
    true

fn file_append_lines(path: text, lines: [text]) -> bool:
    """Append lines to file.

    Args:
        path: File path
        lines: Lines to append

    Returns:
        true on success, false on error
    """
    val content = lines.join("\n")
    file_append_text(path, content + "\n")

fn file_delete(path: text) -> bool:
    """Delete a file.

    Args:
        path: File path

    Returns:
        true on success, false on error
    """
    if path == "" or not file_exists_mock(path):
        return false
    true

fn file_rename(old_path: text, new_path: text) -> bool:
    """Rename/move a file.

    Args:
        old_path: Current path
        new_path: New path

    Returns:
        true on success, false on error
    """
    if old_path == "" or new_path == "":
        return false
    if not file_exists_mock(old_path):
        return false
    true

fn file_copy(src: text, dest: text) -> bool:
    """Copy a file.

    Args:
        src: Source path
        dest: Destination path

    Returns:
        true on success, false on error
    """
    if src == "" or dest == "":
        return false
    if not file_exists_mock(src):
        return false
    true

fn file_move(src: text, dest: text) -> bool:
    """Move a file (copy then delete).

    Args:
        src: Source path
        dest: Destination path

    Returns:
        true on success, false on error
    """
    if not file_copy(src, dest):
        return false
    file_delete(src)

fn file_exists(path: text) -> bool:
    """Check if file exists.

    Args:
        path: File path

    Returns:
        true if exists, false otherwise
    """
    file_exists_mock(path)

fn file_exists_mock(path: text) -> bool:
    """Mock implementation of file_exists."""
    if path == "":
        return false
    # Mock: some paths exist
    path.starts_with("/") or path.starts_with(".")

# ============================================================================
# Directory Operations
# ============================================================================

fn dir_create(path: text) -> bool:
    """Create a directory.

    Args:
        path: Directory path

    Returns:
        true on success, false on error
    """
    if path == "" or path.contains(".."):
        return false
    true

fn dir_create_all(path: text) -> bool:
    """Create directory and all parent directories.

    Args:
        path: Directory path

    Returns:
        true on success, false on error
    """
    if path == "":
        return false
    val parts = path.split("/")
    var current = ""
    for part in parts:
        if part != "":
            if current != "":
                current = current + "/"
            current = current + part
            if not dir_create(current):
                return false
    true

fn dir_list(path: text) -> [text]?:
    """List directory entries.

    Args:
        path: Directory path

    Returns:
        Some(entries) or nil on error
    """
    if path == "" or not dir_exists(path):
        return nil
    # Mock: return some entries
    Some(["file1.txt", "file2.txt", "subdir"])

fn dir_list_detailed(path: text) -> [DirEntry]?:
    """List directory with detailed entry information.

    Args:
        path: Directory path

    Returns:
        Some(entries) or nil on error
    """
    val names_opt = dir_list(path)
    if not names_opt.?:
        return nil

    val names = names_opt.unwrap()
    var entries = []
    for name in names:
        val full_path = path.join2(path, name)
        val entry = DirEntry(
            name: name,
            path: full_path,
            is_file: true,
            is_directory: false,
            size: 1024
        )
        entries.push(entry)

    Some(entries)

fn dir_delete(path: text) -> bool:
    """Delete an empty directory.

    Args:
        path: Directory path

    Returns:
        true on success, false on error
    """
    if path == "" or not dir_exists(path):
        return false
    true

fn dir_delete_all(path: text) -> bool:
    """Delete directory and all contents recursively.

    Args:
        path: Directory path

    Returns:
        true on success, false on error

    Warning: Recursive deletion. Use with caution.
    """
    if path == "" or not dir_exists(path):
        return false
    # Mock: simulate recursive deletion
    true

fn dir_exists(path: text) -> bool:
    """Check if directory exists.

    Args:
        path: Directory path

    Returns:
        true if exists and is directory
    """
    if path == "":
        return false
    path.starts_with("/") or path.starts_with(".")

fn dir_is_empty(path: text) -> bool:
    """Check if directory is empty.

    Args:
        path: Directory path

    Returns:
        true if empty, false otherwise
    """
    val entries_opt = dir_list(path)
    if not entries_opt.?:
        return false
    val entries = entries_opt.unwrap()
    entries.len() == 0

fn dir_walk(root: text) -> [text]:
    """Recursively walk directory tree and return all paths.

    Args:
        root: Root directory

    Returns:
        Array of all file and directory paths
    """
    var result = []
    dir_walk_recursive(root, result)
    result

fn dir_walk_recursive(path: text, result):
    """Helper for recursive directory walking."""
    val entries_opt = dir_list(path)
    if not entries_opt.?:
        return pass

    val entries = entries_opt.unwrap()
    for entry in entries:
        val full_path = path.join2(path, entry)
        result.push(full_path)
        if dir_exists(full_path):
            dir_walk_recursive(full_path, result)

fn dir_walk_files(root: text) -> [text]:
    """Walk directory and return only file paths.

    Args:
        root: Root directory

    Returns:
        Array of file paths
    """
    val all_paths = dir_walk(root)
    var files = []
    for p in all_paths:
        if file_is_file(p):
            files.push(p)
    files

fn dir_walk_dirs(root: text) -> [text]:
    """Walk directory and return only directory paths.

    Args:
        root: Root directory

    Returns:
        Array of directory paths
    """
    val all_paths = dir_walk(root)
    var dirs = []
    for p in all_paths:
        if file_is_directory(p):
            dirs.push(p)
    dirs

fn dir_copy(src: text, dest: text) -> bool:
    """Copy directory recursively.

    Args:
        src: Source directory
        dest: Destination directory

    Returns:
        true on success, false on error
    """
    if src == "" or dest == "":
        return false
    if not dir_exists(src):
        return false

    # Create destination
    if not dir_create_all(dest):
        return false

    # Copy all entries
    val entries_opt = dir_list(src)
    if not entries_opt.?:
        return false

    val entries = entries_opt.unwrap()
    for entry in entries:
        val src_path = path.join2(src, entry)
        val dest_path = path.join2(dest, entry)

        if dir_exists(src_path):
            if not dir_copy(src_path, dest_path):
                return false
        else:
            if not file_copy(src_path, dest_path):
                return false

    true

fn dir_move(src: text, dest: text) -> bool:
    """Move directory (copy then delete).

    Args:
        src: Source directory
        dest: Destination directory

    Returns:
        true on success, false on error
    """
    if not dir_copy(src, dest):
        return false
    dir_delete_all(src)

fn dir_size(path: text) -> i64:
    """Calculate total size of directory recursively.

    Args:
        path: Directory path

    Returns:
        Total size in bytes
    """
    if not dir_exists(path):
        return 0

    var total_size = 0
    val entries = dir_walk(path)
    for entry in entries:
        if file_is_file(entry):
            val size_opt = file_size(entry)
            if size_opt.?:
                val size = size_opt.unwrap()
                total_size = total_size + size

    total_size

fn dir_count_files(path: text) -> i64:
    """Count number of files in directory recursively.

    Args:
        path: Directory path

    Returns:
        File count
    """
    val files = dir_walk_files(path)
    files.len()

fn dir_count_dirs(path: text) -> i64:
    """Count number of subdirectories recursively.

    Args:
        path: Directory path

    Returns:
        Directory count
    """
    val dirs = dir_walk_dirs(path)
    dirs.len()

# ============================================================================
# Path Operations (Re-export and extend from std.path)
# ============================================================================

fn path_join(parts: [text]) -> text:
    """Join path components.

    Args:
        parts: Array of path parts

    Returns:
        Joined path
    """
    path.path_join(parts)

fn path_join2(a: text, b: text) -> text:
    """Join two path components.

    Args:
        a: First part
        b: Second part

    Returns:
        Joined path
    """
    path.join2(a, b)

fn path_basename(p: text) -> text:
    """Get basename (last component) of path.

    Args:
        p: Path

    Returns:
        Basename
    """
    path.basename(p)

fn path_dirname(p: text) -> text:
    """Get directory name of path.

    Args:
        p: Path

    Returns:
        Directory name
    """
    path.dirname(p)

fn path_extension(p: text) -> text:
    """Get file extension without dot.

    Args:
        p: Path

    Returns:
        Extension (empty if none)
    """
    path.extension(p)

fn path_stem(p: text) -> text:
    """Get filename without extension.

    Args:
        p: Path

    Returns:
        Stem
    """
    path.stem(p)

fn path_normalize(p: text) -> text:
    """Normalize path (resolve . and ..).

    Args:
        p: Path

    Returns:
        Normalized path
    """
    path.normalize(p)

fn path_is_absolute(p: text) -> bool:
    """Check if path is absolute.

    Args:
        p: Path

    Returns:
        true if absolute
    """
    path.is_absolute(p)

fn path_is_relative(p: text) -> bool:
    """Check if path is relative.

    Args:
        p: Path

    Returns:
        true if relative
    """
    path.is_relative(p)

fn path_resolve(p: text, base: text) -> text:
    """Resolve relative path against base.

    Args:
        p: Path to resolve
        base: Base path

    Returns:
        Resolved absolute path
    """
    path.resolve(p, base)

fn path_relative_to(p: text, base: text) -> text:
    """Make path relative to base.

    Args:
        p: Path
        base: Base path

    Returns:
        Relative path
    """
    path.relative_to(p, base)

fn path_split(p: text) -> [text]:
    """Split path into components.

    Args:
        p: Path

    Returns:
        Array of path components
    """
    if p == "":
        return []
    val normalized = path_normalize(p)
    normalized.split("/")

fn path_with_extension(p: text, ext: text) -> text:
    """Replace file extension.

    Args:
        p: Path
        ext: New extension

    Returns:
        Path with new extension
    """
    val stem = path_stem(p)
    val dir = path_dirname(p)
    val new_name = stem + "." + ext
    path_join2(dir, new_name)

fn path_has_extension(p: text, ext: text) -> bool:
    """Check if path has given extension.

    Args:
        p: Path
        ext: Extension to check

    Returns:
        true if matches
    """
    path.has_extension(p, ext)

fn path_common_prefix(paths: [text]) -> text:
    """Find common prefix of multiple paths.

    Args:
        paths: Array of paths

    Returns:
        Common prefix path
    """
    if paths.len() == 0:
        return ""
    if paths.len() == 1:
        return paths[0]

    var prefix = paths[0]
    for i in 1..paths.len():
        val p = paths[i]
        prefix = path_common_prefix_two(prefix, p)

    prefix

fn path_common_prefix_two(a: text, b: text) -> text:
    """Find common prefix of two paths."""
    val a_parts = path_split(a)
    val b_parts = path_split(b)
    var common = []

    val min_len = if a_parts.len() < b_parts.len():
        a_parts.len()
    else:
        b_parts.len()

    for i in 0..min_len:
        if a_parts[i] == b_parts[i]:
            common.push(a_parts[i])
        else:
            break

    path_join(common)

# ============================================================================
# File Information
# ============================================================================

fn file_size(path: text) -> i64?:
    """Get file size in bytes.

    Args:
        path: File path

    Returns:
        Some(size) or nil on error
    """
    if not file_exists(path):
        return nil
    # Mock: return simulated size
    Some(1024)

fn file_modified_time(path: text) -> i64?:
    """Get last modified time as Unix timestamp.

    Args:
        path: File path

    Returns:
        Some(timestamp) or nil on error
    """
    if not file_exists(path):
        return nil
    Some(1700000000)

fn file_created_time(path: text) -> i64?:
    """Get creation time as Unix timestamp.

    Args:
        path: File path

    Returns:
        Some(timestamp) or nil on error
    """
    if not file_exists(path):
        return nil
    Some(1700000000)

fn file_accessed_time(path: text) -> i64?:
    """Get last access time as Unix timestamp.

    Args:
        path: File path

    Returns:
        Some(timestamp) or nil on error
    """
    if not file_exists(path):
        return nil
    Some(1700000000)

fn file_info(path: text) -> FileInfo?:
    """Get comprehensive file information.

    Args:
        path: File path

    Returns:
        Some(FileInfo) or nil on error
    """
    if not file_exists(path):
        return nil

    val info = FileInfo(
        path: path,
        size: 1024,
        modified_time: 1700000000,
        is_file: file_is_file(path),
        is_directory: file_is_directory(path),
        is_symlink: file_is_symlink(path),
        permissions: 755
    )
    Some(info)

fn file_is_file(path: text) -> bool:
    """Check if path is a regular file.

    Args:
        path: Path

    Returns:
        true if regular file
    """
    if not file_exists(path):
        return false
    # Mock: check if has extension
    path_extension(path) != ""

fn file_is_directory(path: text) -> bool:
    """Check if path is a directory.

    Args:
        path: Path

    Returns:
        true if directory
    """
    dir_exists(path)

fn file_is_symlink(path: text) -> bool:
    """Check if path is a symbolic link.

    Args:
        path: Path

    Returns:
        true if symlink
    """
    # Mock: return false
    false

fn file_is_readable(path: text) -> bool:
    """Check if file is readable.

    Args:
        path: File path

    Returns:
        true if readable
    """
    file_exists(path)

fn file_is_writable(path: text) -> bool:
    """Check if file is writable.

    Args:
        path: File path

    Returns:
        true if writable
    """
    file_exists(path)

fn file_is_executable(path: text) -> bool:
    """Check if file is executable.

    Args:
        path: File path

    Returns:
        true if executable
    """
    if not file_exists(path):
        return false
    # Mock: check for common executable extensions
    val ext = path_extension(path)
    ext == "sh" or ext == "exe" or ext == "bin"

fn file_is_hidden(path: text) -> bool:
    """Check if file is hidden (starts with dot).

    Args:
        path: File path

    Returns:
        true if hidden
    """
    val name = path_basename(path)
    name.starts_with(".")

# ============================================================================
# Permissions
# ============================================================================

fn permission_from_mode(mode: i64) -> Permission:
    """Convert Unix mode to Permission structure.

    Args:
        mode: Unix permission bits

    Returns:
        Permission structure
    """
    Permission(
        owner_read: (mode & 256) != 0,
        owner_write: (mode & 128) != 0,
        owner_exec: (mode & 64) != 0,
        group_read: (mode & 32) != 0,
        group_write: (mode & 16) != 0,
        group_exec: (mode & 8) != 0,
        other_read: (mode & 4) != 0,
        other_write: (mode & 2) != 0,
        other_exec: (mode & 1) != 0
    )

fn permission_to_mode(perm: Permission) -> i64:
    """Convert Permission structure to Unix mode.

    Args:
        perm: Permission structure

    Returns:
        Unix permission bits
    """
    var mode = 0

    if perm.owner_read:
        mode = mode + 256
    if perm.owner_write:
        mode = mode + 128
    if perm.owner_exec:
        mode = mode + 64
    if perm.group_read:
        mode = mode + 32
    if perm.group_write:
        mode = mode + 16
    if perm.group_exec:
        mode = mode + 8
    if perm.other_read:
        mode = mode + 4
    if perm.other_write:
        mode = mode + 2
    if perm.other_exec:
        mode = mode + 1

    mode

fn file_get_permissions(path: text) -> Permission?:
    """Get file permissions.

    Args:
        path: File path

    Returns:
        Some(Permission) or nil on error
    """
    if not file_exists(path):
        return nil
    # Mock: return default permissions (755)
    Some(permission_from_mode(755))

fn file_set_permissions(path: text, perm: Permission) -> bool:
    """Set file permissions.

    Args:
        path: File path
        perm: Permission structure

    Returns:
        true on success, false on error
    """
    if not file_exists(path):
        return false
    true

fn file_set_mode(path: text, mode: i64) -> bool:
    """Set file permissions using Unix mode.

    Args:
        path: File path
        mode: Unix permission bits

    Returns:
        true on success, false on error
    """
    val perm = permission_from_mode(mode)
    file_set_permissions(path, perm)

fn file_make_readonly(path: text) -> bool:
    """Make file read-only.

    Args:
        path: File path

    Returns:
        true on success, false on error
    """
    file_set_mode(path, 444)

fn file_make_writable(path: text) -> bool:
    """Make file writable.

    Args:
        path: File path

    Returns:
        true on success, false on error
    """
    file_set_mode(path, 644)

fn file_make_executable(path: text) -> bool:
    """Make file executable.

    Args:
        path: File path

    Returns:
        true on success, false on error
    """
    file_set_mode(path, 755)

# ============================================================================
# Temporary Files
# ============================================================================

fn temp_file_create() -> TempFile?:
    """Create a temporary file.

    Returns:
        Some(TempFile) or nil on error
    """
    val path = "/tmp/simple_temp_" + random_suffix()
    if not file_create(path):
        return nil
    val temp = TempFile(path: path, cleanup_on_drop: true)
    Some(temp)

fn temp_file_create_with_name(name: text) -> TempFile?:
    """Create a temporary file with specific name.

    Args:
        name: File name

    Returns:
        Some(TempFile) or nil on error
    """
    val path = "/tmp/" + name
    if not file_create(path):
        return nil
    val temp = TempFile(path: path, cleanup_on_drop: true)
    Some(temp)

fn temp_dir_create() -> text?:
    """Create a temporary directory.

    Returns:
        Some(path) or nil on error
    """
    val path = "/tmp/simple_temp_dir_" + random_suffix()
    if not dir_create(path):
        return nil
    Some(path)

fn temp_file_cleanup(temp: TempFile) -> bool:
    """Clean up temporary file.

    Args:
        temp: TempFile handle

    Returns:
        true on success, false on error
    """
    file_delete(temp.path)

fn random_suffix() -> text:
    """Generate random suffix for temp files."""
    # Mock: return fixed suffix
    "abc123"

# ============================================================================
# Glob Pattern Matching
# ============================================================================

fn glob_match(pattern: text, path: text) -> bool:
    """Check if path matches glob pattern.

    Supports: *, ?, [abc]

    Args:
        pattern: Glob pattern
        path: Path to test

    Returns:
        true if matches
    """
    glob_match_recursive(pattern, path, 0, 0)

fn glob_match_recursive(pattern: text, path: text, pi: i64, pathi: i64) -> bool:
    """Recursive glob matching helper."""
    # Base cases
    if pi >= pattern.len() and pathi >= path.len():
        return true
    if pi >= pattern.len():
        return false
    if pathi >= path.len():
        # Check if remaining pattern is all *
        for i in pi..pattern.len():
            if pattern[i:i+1] != "*":
                return false
        return true

    val pc = pattern[pi:pi+1]
    val pathc = path[pathi:pathi+1]

    if pc == "*":
        # Try matching 0 or more characters
        val match_zero = glob_match_recursive(pattern, path, pi + 1, pathi)
        if match_zero:
            return true
        val match_more = glob_match_recursive(pattern, path, pi, pathi + 1)
        return match_more
    elif pc == "?":
        # Match any single character
        return glob_match_recursive(pattern, path, pi + 1, pathi + 1)
    elif pc == "[":
        # Character class (simplified)
        return glob_match_recursive(pattern, path, pi + 3, pathi + 1)
    else:
        # Literal character
        if pc == pathc:
            return glob_match_recursive(pattern, path, pi + 1, pathi + 1)
        return false

fn glob_find(pattern: text, root: text) -> [text]:
    """Find all files matching glob pattern.

    Args:
        pattern: Glob pattern
        root: Root directory to search

    Returns:
        Array of matching paths
    """
    val all_files = dir_walk_files(root)
    var matches = []
    for file in all_files:
        if glob_match(pattern, file):
            matches.push(file)
    matches

fn glob_find_files(pattern: text) -> [text]:
    """Find files matching pattern in current directory.

    Args:
        pattern: Glob pattern

    Returns:
        Array of matching paths
    """
    glob_find(pattern, ".")

fn glob_filter(paths: [text], pattern: text) -> [text]:
    """Filter paths by glob pattern.

    Args:
        paths: Array of paths
        pattern: Glob pattern

    Returns:
        Filtered array
    """
    var matches = []
    for p in paths:
        if glob_match(pattern, p):
            matches.push(p)
    matches

# ============================================================================
# Directory Tree Operations
# ============================================================================

fn tree_create(root: text, structure: [text]) -> bool:
    """Create directory tree from path list.

    Args:
        root: Root directory
        structure: Array of relative paths

    Returns:
        true on success, false on error
    """
    if not dir_create_all(root):
        return false

    for rel_path in structure:
        val full_path = path_join2(root, rel_path)
        if rel_path.ends_with("/"):
            if not dir_create_all(full_path):
                return false
        else:
            val dir = path_dirname(full_path)
            if not dir_create_all(dir):
                return false
            if not file_create(full_path):
                return false

    true

fn tree_print(root: text) -> text:
    """Generate tree structure string.

    Args:
        root: Root directory

    Returns:
        Tree visualization
    """
    var output = root + "\n"
    tree_print_recursive(root, "", output)
    output

fn tree_print_recursive(path: text, indent: text, output):
    """Helper for tree printing."""
    val entries_opt = dir_list(path)
    if not entries_opt.?:
        return pass

    val entries = entries_opt.unwrap()
    for i in 0..entries.len():
        val entry = entries[i]
        val is_last = i == entries.len() - 1
        val branch = if is_last:
            "└── "
        else:
            "├── "

        output.push(indent + branch + entry + "\n")

        val full_path = path_join2(path, entry)
        if dir_exists(full_path):
            val new_indent = if is_last:
                indent + "    "
            else:
                indent + "│   "
            tree_print_recursive(full_path, new_indent, output)

# ============================================================================
# Symbolic Links
# ============================================================================

fn symlink_create(target: text, link: text) -> bool:
    """Create symbolic link.

    Args:
        target: Target path
        link: Link path

    Returns:
        true on success, false on error
    """
    if target == "" or link == "":
        return false
    # Mock: simulate symlink creation
    true

fn symlink_read(link: text) -> text?:
    """Read symbolic link target.

    Args:
        link: Link path

    Returns:
        Some(target) or nil on error
    """
    if not file_is_symlink(link):
        return nil
    Some("/mock/target")

fn symlink_resolve(path: text) -> text?:
    """Resolve symbolic link to final target.

    Args:
        path: Path (may contain symlinks)

    Returns:
        Some(resolved) or nil on error
    """
    if not file_exists(path):
        return nil
    # Mock: return path itself
    Some(path)

# ============================================================================
# File Watching (Mock Implementation)
# ============================================================================

struct FileWatcher:
    """File watcher handle."""
    path: text
    last_modified: i64

fn watch_create(path: text) -> FileWatcher?:
    """Create file watcher.

    Args:
        path: Path to watch

    Returns:
        Some(FileWatcher) or nil on error
    """
    if not file_exists(path):
        return nil

    val modified_opt = file_modified_time(path)
    if not modified_opt.?:
        return nil

    val modified = modified_opt.unwrap()
    val watcher = FileWatcher(path: path, last_modified: modified)
    Some(watcher)

fn watch_check(watcher: FileWatcher) -> bool:
    """Check if file has changed.

    Args:
        watcher: FileWatcher handle

    Returns:
        true if changed
    """
    val modified_opt = file_modified_time(watcher.path)
    if not modified_opt.?:
        return false

    val modified = modified_opt.unwrap()
    modified != watcher.last_modified

me watch_update(watcher: FileWatcher):
    """Update watcher timestamp.

    Args:
        watcher: FileWatcher handle (mutable)
    """
    val modified_opt = file_modified_time(watcher.path)
    if modified_opt.?:
        val modified = modified_opt.unwrap()
        watcher.last_modified = modified

# ============================================================================
# Disk Usage
# ============================================================================

fn disk_usage(path: text) -> i64:
    """Calculate disk usage of path recursively.

    Args:
        path: File or directory path

    Returns:
        Total size in bytes
    """
    if file_is_file(path):
        val size_opt = file_size(path)
        if size_opt.?:
            return size_opt.unwrap()
        return 0
    elif file_is_directory(path):
        return dir_size(path)
    else:
        return 0

fn disk_usage_human(bytes: i64) -> text:
    """Format bytes as human-readable size.

    Args:
        bytes: Size in bytes

    Returns:
        Formatted string (e.g., "1.5 MB")
    """
    if bytes < 1024:
        return "{bytes} B"
    elif bytes < 1048576:
        val kb = bytes / 1024
        return "{kb} KB"
    elif bytes < 1073741824:
        val mb = bytes / 1048576
        return "{mb} MB"
    else:
        val gb = bytes / 1073741824
        return "{gb} GB"

# ============================================================================
# Utility Functions
# ============================================================================

fn file_type_from_extension(ext: text) -> text:
    """Guess file type from extension.

    Args:
        ext: File extension

    Returns:
        File type description
    """
    if ext == "txt" or ext == "md":
        return "text"
    elif ext == "jpg" or ext == "png" or ext == "gif":
        return "image"
    elif ext == "mp3" or ext == "wav" or ext == "flac":
        return "audio"
    elif ext == "mp4" or ext == "avi" or ext == "mkv":
        return "video"
    elif ext == "pdf":
        return "document"
    elif ext == "zip" or ext == "tar" or ext == "gz":
        return "archive"
    elif ext == "spl" or ext == "py" or ext == "js":
        return "code"
    else:
        return "unknown"

fn file_mime_type(path: text) -> text:
    """Guess MIME type from file extension.

    Args:
        path: File path

    Returns:
        MIME type string
    """
    val ext = path_extension(path)

    if ext == "txt":
        return "text/plain"
    elif ext == "html" or ext == "htm":
        return "text/html"
    elif ext == "css":
        return "text/css"
    elif ext == "js":
        return "application/javascript"
    elif ext == "json":
        return "application/json"
    elif ext == "xml":
        return "application/xml"
    elif ext == "jpg" or ext == "jpeg":
        return "image/jpeg"
    elif ext == "png":
        return "image/png"
    elif ext == "gif":
        return "image/gif"
    elif ext == "svg":
        return "image/svg+xml"
    elif ext == "pdf":
        return "application/pdf"
    elif ext == "zip":
        return "application/zip"
    else:
        return "application/octet-stream"

fn file_is_text(path: text) -> bool:
    """Check if file is likely text based on extension.

    Args:
        path: File path

    Returns:
        true if likely text
    """
    val ext = path_extension(path)
    val text_exts = ["txt", "md", "spl", "py", "js", "html", "css", "json", "xml", "csv"]

    for text_ext in text_exts:
        if ext == text_ext:
            return true

    false

fn file_is_binary(path: text) -> bool:
    """Check if file is likely binary based on extension.

    Args:
        path: File path

    Returns:
        true if likely binary
    """
    not file_is_text(path)

fn files_filter_by_extension(paths: [text], ext: text) -> [text]:
    """Filter files by extension.

    Args:
        paths: Array of paths
        ext: Extension to filter

    Returns:
        Filtered array
    """
    var result = []
    for p in paths:
        if path_has_extension(p, ext):
            result.push(p)
    result

fn files_group_by_extension(paths: [text]) -> [(text, [text])]:
    """Group files by extension.

    Args:
        paths: Array of paths

    Returns:
        Array of (extension, paths) tuples
    """
    var groups = []
    var extensions = []

    # Collect unique extensions
    for p in paths:
        val ext = path_extension(p)
        var found = false
        for e in extensions:
            if e == ext:
                found = true
                break
        if not found:
            extensions.push(ext)

    # Group by extension
    for ext in extensions:
        val filtered = files_filter_by_extension(paths, ext)
        groups.push((ext, filtered))

    groups

fn file_line_count(path: text) -> i64?:
    """Count lines in text file.

    Args:
        path: File path

    Returns:
        Some(line count) or nil on error
    """
    val lines_opt = file_read_lines(path)
    if not lines_opt.?:
        return nil
    val lines = lines_opt.unwrap()
    Some(lines.len())

fn file_word_count(path: text) -> i64?:
    """Count words in text file.

    Args:
        path: File path

    Returns:
        Some(word count) or nil on error
    """
    val content_opt = file_read_text(path)
    if not content_opt.?:
        return nil

    val content = content_opt.unwrap()
    val words = content.split(" ")
    Some(words.len())

fn file_char_count(path: text) -> i64?:
    """Count characters in text file.

    Args:
        path: File path

    Returns:
        Some(char count) or nil on error
    """
    val content_opt = file_read_text(path)
    if not content_opt.?:
        return nil

    val content = content_opt.unwrap()
    Some(content.len())

# ============================================================================
# Exports
# ============================================================================

export FileInfo, DirEntry, Permission, TempFile, FileWatcher

# File operations
export file_create, file_read_text, file_read_bytes, file_read_lines
export file_write_text, file_write_bytes, file_write_lines
export file_append_text, file_append_lines
export file_delete, file_rename, file_copy, file_move, file_exists

# Directory operations
export dir_create, dir_create_all, dir_list, dir_list_detailed
export dir_delete, dir_delete_all, dir_exists, dir_is_empty
export dir_walk, dir_walk_files, dir_walk_dirs
export dir_copy, dir_move, dir_size, dir_count_files, dir_count_dirs

# Path operations
export path_join, path_join2, path_basename, path_dirname
export path_extension, path_stem, path_normalize
export path_is_absolute, path_is_relative, path_resolve, path_relative_to
export path_split, path_with_extension, path_has_extension, path_common_prefix

# File information
export file_size, file_modified_time, file_created_time, file_accessed_time
export file_info, file_is_file, file_is_directory, file_is_symlink
export file_is_readable, file_is_writable, file_is_executable, file_is_hidden

# Permissions
export permission_from_mode, permission_to_mode
export file_get_permissions, file_set_permissions, file_set_mode
export file_make_readonly, file_make_writable, file_make_executable

# Temporary files
export temp_file_create, temp_file_create_with_name, temp_dir_create, temp_file_cleanup

# Glob patterns
export glob_match, glob_find, glob_find_files, glob_filter

# Directory tree
export tree_create, tree_print

# Symbolic links
export symlink_create, symlink_read, symlink_resolve

# File watching
export watch_create, watch_check, watch_update

# Disk usage
export disk_usage, disk_usage_human

# Utility functions
export file_type_from_extension, file_mime_type
export file_is_text, file_is_binary
export files_filter_by_extension, files_group_by_extension
export file_line_count, file_word_count, file_char_count
