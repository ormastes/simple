# Huffman Coding Utilities Module
# Provides comprehensive utilities for Huffman encoding/decoding and data compression
# Uses tuple-based tree representation: (is_leaf, symbol, frequency, left, right)

# Constants
val HUFFMAN_LEAF_MARKER = 1
val HUFFMAN_INTERNAL_MARKER = 0
val HUFFMAN_MAX_SYMBOLS = 256
val HUFFMAN_BIT_ZERO = "0"
val HUFFMAN_BIT_ONE = "1"

# Tree Node Structure (as tuple)
# Leaf node: (1, symbol, frequency, nil, nil)
# Internal node: (0, -1, frequency, left_node, right_node)

# ============================================================================
# CORE NODE OPERATIONS
# ============================================================================

fn huffman_create_leaf(symbol, frequency):
    """Create a Huffman tree leaf node"""
    (HUFFMAN_LEAF_MARKER, symbol, frequency, nil, nil)

fn huffman_create_internal(left, right):
    """Create a Huffman tree internal node"""
    val left_freq = huffman_get_frequency(left)
    val right_freq = huffman_get_frequency(right)
    val combined_freq = left_freq + right_freq
    (HUFFMAN_INTERNAL_MARKER, -1, combined_freq, left, right)

fn huffman_is_leaf(node):
    """Check if node is a leaf"""
    if node == nil:
        false
    else:
        val marker = node[0]
        marker == HUFFMAN_LEAF_MARKER

fn huffman_get_symbol(node):
    """Get symbol from node (only valid for leaf nodes)"""
    if node == nil:
        -1
    else:
        node[1]

fn huffman_get_frequency(node):
    """Get frequency from node"""
    if node == nil:
        0
    else:
        node[2]

fn huffman_get_left(node):
    """Get left child of internal node"""
    if node == nil:
        nil
    else:
        node[3]

fn huffman_get_right(node):
    """Get right child of internal node"""
    if node == nil:
        nil
    else:
        node[4]

# ============================================================================
# FREQUENCY ANALYSIS
# ============================================================================

fn huffman_count_frequencies(data):
    """Count frequency of each byte in data, returns array of 256 frequencies"""
    var freq_table = array_new(HUFFMAN_MAX_SYMBOLS, 0)
    var i = 0
    val data_len = string_length(data)

    while i < data_len:
        val byte_val = string_byte_at(data, i)
        val old_count = array_get(freq_table, byte_val)
        var new_count = old_count + 1
        array_set(freq_table, byte_val, new_count)
        i = i + 1

    freq_table

fn huffman_create_frequency_list(freq_table):
    """Convert frequency array to list of (symbol, frequency) tuples"""
    var result = []
    var i = 0

    while i < HUFFMAN_MAX_SYMBOLS:
        val freq = array_get(freq_table, i)
        if freq > 0:
            result = array_append(result, (i, freq))
        i = i + 1

    result

fn huffman_get_unique_symbols(data):
    """Get count of unique symbols in data"""
    val freq_table = huffman_count_frequencies(data)
    var count = 0
    var i = 0

    while i < HUFFMAN_MAX_SYMBOLS:
        val freq = array_get(freq_table, i)
        if freq > 0:
            count = count + 1
        i = i + 1

    count

# ============================================================================
# TREE CONSTRUCTION - PRIORITY QUEUE HELPERS
# ============================================================================

fn huffman_pq_insert(queue, node):
    """Insert node into priority queue (sorted by frequency)"""
    var result = []
    val node_freq = huffman_get_frequency(node)
    var inserted = false
    var i = 0
    val queue_len = array_length(queue)

    while i < queue_len:
        val curr = array_get(queue, i)
        val curr_freq = huffman_get_frequency(curr)

        if not inserted:
            if node_freq <= curr_freq:
                result = array_append(result, node)
                inserted = true

        result = array_append(result, curr)
        i = i + 1

    if not inserted:
        result = array_append(result, node)

    result

fn huffman_pq_pop(queue):
    """Remove and return minimum frequency node from priority queue"""
    val queue_len = array_length(queue)
    if queue_len == 0:
        nil
    else:
        val min_node = array_get(queue, 0)
        var new_queue = []
        var i = 1

        while i < queue_len:
            val node = array_get(queue, i)
            new_queue = array_append(new_queue, node)
            i = i + 1

        (min_node, new_queue)

fn huffman_pq_size(queue):
    """Get size of priority queue"""
    array_length(queue)

# ============================================================================
# TREE CONSTRUCTION - MAIN ALGORITHM
# ============================================================================

fn huffman_build_tree(freq_table):
    """Build Huffman tree from frequency table using greedy algorithm"""
    val freq_list = huffman_create_frequency_list(freq_table)
    val list_len = array_length(freq_list)

    if list_len == 0:
        nil
    else:
        if list_len == 1:
            val pair = array_get(freq_list, 0)
            val symbol = pair[0]
            val freq = pair[1]
            huffman_create_leaf(symbol, freq)
        else:
            var pq = []
            var i = 0

            while i < list_len:
                val pair = array_get(freq_list, i)
                val symbol = pair[0]
                val freq = pair[1]
                val leaf = huffman_create_leaf(symbol, freq)
                pq = huffman_pq_insert(pq, leaf)
                i = i + 1

            while huffman_pq_size(pq) > 1:
                val pop1 = huffman_pq_pop(pq)
                val left = pop1[0]
                val pq1 = pop1[1]

                val pop2 = huffman_pq_pop(pq1)
                val right = pop2[0]
                val pq2 = pop2[1]

                val internal = huffman_create_internal(left, right)
                pq = huffman_pq_insert(pq2, internal)

            val final_pop = huffman_pq_pop(pq)
            final_pop[0]

fn huffman_build_tree_from_data(data):
    """Build Huffman tree directly from input data"""
    val freq_table = huffman_count_frequencies(data)
    huffman_build_tree(freq_table)

# ============================================================================
# CODE TABLE GENERATION
# ============================================================================

fn huffman_build_code_table_helper(node, prefix, table):
    """Recursive helper to build code table"""
    if node == nil:
        table
    else:
        val is_leaf = huffman_is_leaf(node)
        if is_leaf:
            val symbol = huffman_get_symbol(node)
            array_set(table, symbol, prefix)
            table
        else:
            val left = huffman_get_left(node)
            val right = huffman_get_right(node)
            val left_prefix = string_concat(prefix, HUFFMAN_BIT_ZERO)
            val right_prefix = string_concat(prefix, HUFFMAN_BIT_ONE)

            var updated_table = huffman_build_code_table_helper(left, left_prefix, table)
            updated_table = huffman_build_code_table_helper(right, right_prefix, updated_table)
            updated_table

fn huffman_build_code_table(tree):
    """Build code table mapping symbols to bit strings"""
    var table = array_new(HUFFMAN_MAX_SYMBOLS, "")
    huffman_build_code_table_helper(tree, "", table)

fn huffman_get_code(code_table, symbol):
    """Get Huffman code for a symbol"""
    array_get(code_table, symbol)

# ============================================================================
# ENCODING
# ============================================================================

fn huffman_encode_symbol(symbol, code_table):
    """Encode a single symbol using code table"""
    huffman_get_code(code_table, symbol)

fn huffman_encode_data(data, code_table):
    """Encode data string using Huffman code table"""
    var result = ""
    var i = 0
    val data_len = string_length(data)

    while i < data_len:
        val byte_val = string_byte_at(data, i)
        val code = huffman_encode_symbol(byte_val, code_table)
        result = string_concat(result, code)
        i = i + 1

    result

fn huffman_encode(data):
    """Full encoding pipeline: build tree, generate codes, encode data"""
    val tree = huffman_build_tree_from_data(data)
    if tree == nil:
        nil
    else:
        val code_table = huffman_build_code_table(tree)
        val encoded = huffman_encode_data(data, code_table)
        (tree, encoded)

# ============================================================================
# DECODING
# ============================================================================

fn huffman_decode_symbol(tree, bits, start_pos):
    """Decode one symbol from bit string, returns (symbol, next_position)"""
    var node = tree
    var pos = start_pos
    val bits_len = string_length(bits)

    while pos < bits_len:
        val is_leaf = huffman_is_leaf(node)
        if is_leaf:
            val symbol = huffman_get_symbol(node)
            return (symbol, pos)

        val bit = string_char_at(bits, pos)
        if bit == HUFFMAN_BIT_ZERO:
            node = huffman_get_left(node)
        else:
            node = huffman_get_right(node)

        pos = pos + 1

    val is_leaf = huffman_is_leaf(node)
    if is_leaf:
        val symbol = huffman_get_symbol(node)
        (symbol, pos)
    else:
        (-1, pos)

fn huffman_decode_data(tree, bits):
    """Decode bit string using Huffman tree"""
    var result = []
    var pos = 0
    val bits_len = string_length(bits)

    while pos < bits_len:
        val decoded = huffman_decode_symbol(tree, bits, pos)
        val symbol = decoded[0]
        val next_pos = decoded[1]

        if symbol == -1:
            return nil

        result = array_append(result, symbol)
        pos = next_pos

    result

fn huffman_decode(tree, bits):
    """Full decoding pipeline: decode bits to symbol array"""
    huffman_decode_data(tree, bits)

fn huffman_symbols_to_string(symbols):
    """Convert symbol array to string"""
    var result = ""
    var i = 0
    val symbols_len = array_length(symbols)

    while i < symbols_len:
        val symbol = array_get(symbols, i)
        val char_str = string_from_byte(symbol)
        result = string_concat(result, char_str)
        i = i + 1

    result

# ============================================================================
# TREE ANALYSIS
# ============================================================================

fn huffman_tree_height_helper(node):
    """Calculate tree height"""
    if node == nil:
        0
    else:
        val is_leaf = huffman_is_leaf(node)
        if is_leaf:
            1
        else:
            val left = huffman_get_left(node)
            val right = huffman_get_right(node)
            val left_height = huffman_tree_height_helper(left)
            val right_height = huffman_tree_height_helper(right)
            val max_height = if left_height > right_height: left_height else: right_height
            max_height + 1

fn huffman_tree_height(tree):
    """Get height of Huffman tree"""
    huffman_tree_height_helper(tree)

fn huffman_count_nodes(node):
    """Count total nodes in tree"""
    if node == nil:
        0
    else:
        val is_leaf = huffman_is_leaf(node)
        if is_leaf:
            1
        else:
            val left = huffman_get_left(node)
            val right = huffman_get_right(node)
            val left_count = huffman_count_nodes(left)
            val right_count = huffman_count_nodes(right)
            1 + left_count + right_count

fn huffman_count_leaves(node):
    """Count leaf nodes in tree"""
    if node == nil:
        0
    else:
        val is_leaf = huffman_is_leaf(node)
        if is_leaf:
            1
        else:
            val left = huffman_get_left(node)
            val right = huffman_get_right(node)
            val left_count = huffman_count_leaves(left)
            val right_count = huffman_count_leaves(right)
            left_count + right_count

fn huffman_validate_tree(node):
    """Validate that tree structure is correct"""
    if node == nil:
        false
    else:
        val is_leaf = huffman_is_leaf(node)
        if is_leaf:
            val symbol = huffman_get_symbol(node)
            val freq = huffman_get_frequency(node)
            var valid = symbol >= 0
            valid = valid and symbol < HUFFMAN_MAX_SYMBOLS
            valid = valid and freq > 0
            valid
        else:
            val left = huffman_get_left(node)
            val right = huffman_get_right(node)
            val freq = huffman_get_frequency(node)

            if left == nil or right == nil:
                false
            else:
                val left_freq = huffman_get_frequency(left)
                val right_freq = huffman_get_frequency(right)
                val freq_valid = freq == left_freq + right_freq
                val left_valid = huffman_validate_tree(left)
                val right_valid = huffman_validate_tree(right)

                var result = freq_valid
                result = result and left_valid
                result = result and right_valid
                result

# ============================================================================
# CODE LENGTH ANALYSIS
# ============================================================================

fn huffman_code_length_distribution(code_table):
    """Get distribution of code lengths"""
    var dist = array_new(32, 0)
    var i = 0

    while i < HUFFMAN_MAX_SYMBOLS:
        val code = array_get(code_table, i)
        val code_len = string_length(code)
        if code_len > 0:
            val old_count = array_get(dist, code_len)
            var new_count = old_count + 1
            dist = array_set(dist, code_len, new_count)
        i = i + 1

    dist

fn huffman_average_code_length(code_table, freq_table):
    """Calculate weighted average code length"""
    var total_bits = 0
    var total_symbols = 0
    var i = 0

    while i < HUFFMAN_MAX_SYMBOLS:
        val freq = array_get(freq_table, i)
        if freq > 0:
            val code = array_get(code_table, i)
            val code_len = string_length(code)
            total_bits = total_bits + code_len * freq
            total_symbols = total_symbols + freq
        i = i + 1

    if total_symbols == 0:
        0
    else:
        total_bits / total_symbols

fn huffman_min_code_length(code_table):
    """Find minimum code length"""
    var min_len = 999999
    var i = 0

    while i < HUFFMAN_MAX_SYMBOLS:
        val code = array_get(code_table, i)
        val code_len = string_length(code)
        if code_len > 0:
            if code_len < min_len:
                min_len = code_len
        i = i + 1

    if min_len == 999999:
        0
    else:
        min_len

fn huffman_max_code_length(code_table):
    """Find maximum code length"""
    var max_len = 0
    var i = 0

    while i < HUFFMAN_MAX_SYMBOLS:
        val code = array_get(code_table, i)
        val code_len = string_length(code)
        if code_len > max_len:
            max_len = code_len
        i = i + 1

    max_len

# ============================================================================
# CANONICAL HUFFMAN CODES
# ============================================================================

fn huffman_sort_by_length_then_symbol(code_table):
    """Create sorted list of (symbol, code_length) pairs"""
    var pairs = []
    var i = 0

    while i < HUFFMAN_MAX_SYMBOLS:
        val code = array_get(code_table, i)
        val code_len = string_length(code)
        if code_len > 0:
            pairs = array_append(pairs, (i, code_len))
        i = i + 1

    huffman_sort_pairs(pairs)

fn huffman_sort_pairs(pairs):
    """Sort (symbol, length) pairs by length then symbol (bubble sort)"""
    var result = pairs
    val n = array_length(result)
    var i = 0

    while i < n:
        var j = 0
        while j < n - 1 - i:
            val pair1 = array_get(result, j)
            val pair2 = array_get(result, j + 1)
            val len1 = pair1[1]
            val len2 = pair2[1]
            val sym1 = pair1[0]
            val sym2 = pair2[0]

            var should_swap = false
            if len1 > len2:
                should_swap = true
            else:
                if len1 == len2:
                    if sym1 > sym2:
                        should_swap = true

            if should_swap:
                result = array_set(result, j, pair2)
                result = array_set(result, j + 1, pair1)

            j = j + 1
        i = i + 1

    result

fn huffman_int_to_binary(value, length):
    """Convert integer to binary string of specified length"""
    var result = ""
    var v = value
    var i = 0

    while i < length:
        val bit = v % 2
        val bit_str = if bit == 0: HUFFMAN_BIT_ZERO else: HUFFMAN_BIT_ONE
        result = string_concat(bit_str, result)
        v = v / 2
        i = i + 1

    result

fn huffman_build_canonical_codes(sorted_pairs):
    """Build canonical Huffman codes from sorted pairs"""
    var table = array_new(HUFFMAN_MAX_SYMBOLS, "")
    var code_value = 0
    var prev_length = 0
    var i = 0
    val pairs_len = array_length(sorted_pairs)

    while i < pairs_len:
        val pair = array_get(sorted_pairs, i)
        val symbol = pair[0]
        val length = pair[1]

        if i > 0:
            code_value = code_value << (length - prev_length)

        val code_str = huffman_int_to_binary(code_value, length)
        table = array_set(table, symbol, code_str)

        code_value = code_value + 1
        prev_length = length
        i = i + 1

    table

fn huffman_canonicalize(code_table):
    """Convert code table to canonical Huffman codes"""
    val sorted = huffman_sort_by_length_then_symbol(code_table)
    huffman_build_canonical_codes(sorted)

# ============================================================================
# TREE SERIALIZATION
# ============================================================================

fn huffman_serialize_tree(node):
    """Serialize tree to string format (preorder traversal)"""
    if node == nil:
        "N"
    else:
        val is_leaf = huffman_is_leaf(node)
        if is_leaf:
            val symbol = huffman_get_symbol(node)
            val sym_str = int_to_string(symbol)
            string_concat("L", sym_str)
        else:
            val left = huffman_get_left(node)
            val right = huffman_get_right(node)
            val left_str = huffman_serialize_tree(left)
            val right_str = huffman_serialize_tree(right)
            var result = "I"
            result = string_concat(result, ",")
            result = string_concat(result, left_str)
            result = string_concat(result, ",")
            result = string_concat(result, right_str)
            result

fn huffman_deserialize_tree_helper(tokens, pos):
    """Helper to deserialize tree, returns (node, next_position)"""
    val tokens_len = array_length(tokens)
    if pos >= tokens_len:
        (nil, pos)
    else:
        val token = array_get(tokens, pos)
        val token_len = string_length(token)
        if token_len == 0:
            (nil, pos + 1)
        else:
            val first_char = string_char_at(token, 0)
            if first_char == "N":
                (nil, pos + 1)
            else:
                if first_char == "L":
                    val sym_str = string_substring(token, 1, token_len)
                    val symbol = string_to_int(sym_str)
                    val leaf = huffman_create_leaf(symbol, 0)
                    (leaf, pos + 1)
                else:
                    if first_char == "I":
                        val left_result = huffman_deserialize_tree_helper(tokens, pos + 1)
                        val left = left_result[0]
                        val pos2 = left_result[1]

                        val right_result = huffman_deserialize_tree_helper(tokens, pos2)
                        val right = right_result[0]
                        val pos3 = right_result[1]

                        val internal = huffman_create_internal(left, right)
                        (internal, pos3)
                    else:
                        (nil, pos + 1)

fn huffman_deserialize_tree(serialized):
    """Deserialize tree from string format"""
    val tokens = string_split(serialized, ",")
    val result = huffman_deserialize_tree_helper(tokens, 0)
    result[0]

# ============================================================================
# COMPRESSION UTILITIES
# ============================================================================

fn huffman_bits_to_bytes(bits):
    """Convert bit string to byte array (pad with zeros)"""
    val bits_len = string_length(bits)
    val padding = 8 - bits_len % 8
    val final_padding = if padding == 8: 0 else: padding

    var padded = bits
    var p = 0
    while p < final_padding:
        padded = string_concat(padded, HUFFMAN_BIT_ZERO)
        p = p + 1

    val padded_len = string_length(padded)
    val byte_count = padded_len / 8
    var bytes = []
    var i = 0

    while i < byte_count:
        val start = i * 8
        val end = start + 8
        val byte_bits = string_substring(padded, start, end)
        val byte_val = huffman_binary_to_int(byte_bits)
        bytes = array_append(bytes, byte_val)
        i = i + 1

    bytes

fn huffman_binary_to_int(bits):
    """Convert binary string to integer"""
    var result = 0
    var i = 0
    val bits_len = string_length(bits)

    while i < bits_len:
        val bit = string_char_at(bits, i)
        result = result * 2
        if bit == HUFFMAN_BIT_ONE:
            result = result + 1
        i = i + 1

    result

fn huffman_bytes_to_bits(bytes):
    """Convert byte array to bit string"""
    var result = ""
    var i = 0
    val bytes_len = array_length(bytes)

    while i < bytes_len:
        val byte_val = array_get(bytes, i)
        val bits = huffman_int_to_binary(byte_val, 8)
        result = string_concat(result, bits)
        i = i + 1

    result

fn huffman_compression_ratio(original_size, compressed_size):
    """Calculate compression ratio"""
    if original_size == 0:
        0
    else:
        compressed_size / original_size

fn huffman_space_savings(original_size, compressed_size):
    """Calculate space savings percentage"""
    if original_size == 0:
        0
    else:
        val saved = original_size - compressed_size
        saved * 100 / original_size

# ============================================================================
# PREFIX CODE VALIDATION
# ============================================================================

fn huffman_is_prefix(code1, code2):
    """Check if code1 is prefix of code2"""
    val len1 = string_length(code1)
    val len2 = string_length(code2)

    if len1 > len2:
        false
    else:
        val prefix = string_substring(code2, 0, len1)
        code1 == prefix

fn huffman_validate_prefix_property(code_table):
    """Validate that no code is prefix of another"""
    var codes = []
    var i = 0

    while i < HUFFMAN_MAX_SYMBOLS:
        val code = array_get(code_table, i)
        val code_len = string_length(code)
        if code_len > 0:
            codes = array_append(codes, code)
        i = i + 1

    val codes_len = array_length(codes)
    var j = 0

    while j < codes_len:
        val code1 = array_get(codes, j)
        var k = 0

        while k < codes_len:
            if j != k:
                val code2 = array_get(codes, k)
                val is_prefix = huffman_is_prefix(code1, code2)
                if is_prefix:
                    return false
            k = k + 1

        j = j + 1

    true

# ============================================================================
# STATISTICS AND REPORTING
# ============================================================================

fn huffman_calculate_entropy(freq_table, total_symbols):
    """Calculate Shannon entropy of data"""
    var entropy = 0
    var i = 0

    while i < HUFFMAN_MAX_SYMBOLS:
        val freq = array_get(freq_table, i)
        if freq > 0:
            val prob = freq / total_symbols
            val log_prob = math_log2(prob)
            entropy = entropy - prob * log_prob
        i = i + 1

    entropy

fn huffman_compression_efficiency(avg_code_len, entropy):
    """Calculate compression efficiency (ratio of avg code length to entropy)"""
    if entropy == 0:
        0
    else:
        avg_code_len / entropy

fn huffman_total_data_size(data):
    """Get total size of data in bytes"""
    string_length(data)

fn huffman_compressed_bit_count(encoded_bits):
    """Get bit count of encoded data"""
    string_length(encoded_bits)

fn huffman_compressed_byte_count(encoded_bits):
    """Get byte count of encoded data (with padding)"""
    val bit_count = string_length(encoded_bits)
    val byte_count = bit_count / 8
    val remainder = bit_count % 8
    if remainder > 0:
        byte_count + 1
    else:
        byte_count

# ============================================================================
# UTILITY HELPERS
# ============================================================================

fn huffman_create_single_symbol_tree(symbol):
    """Create tree for data with single unique symbol"""
    huffman_create_leaf(symbol, 1)

fn huffman_is_empty_tree(tree):
    """Check if tree is empty"""
    tree == nil

fn huffman_get_tree_root(tree):
    """Get root node of tree (identity function)"""
    tree

fn huffman_compare_trees(tree1, tree2):
    """Check if two trees are structurally equal"""
    if tree1 == nil and tree2 == nil:
        true
    else:
        if tree1 == nil or tree2 == nil:
            false
        else:
            val is_leaf1 = huffman_is_leaf(tree1)
            val is_leaf2 = huffman_is_leaf(tree2)

            if is_leaf1 and is_leaf2:
                val sym1 = huffman_get_symbol(tree1)
                val sym2 = huffman_get_symbol(tree2)
                sym1 == sym2
            else:
                if is_leaf1 or is_leaf2:
                    false
                else:
                    val left1 = huffman_get_left(tree1)
                    val left2 = huffman_get_left(tree2)
                    val right1 = huffman_get_right(tree1)
                    val right2 = huffman_get_right(tree2)

                    val left_eq = huffman_compare_trees(left1, left2)
                    val right_eq = huffman_compare_trees(right1, right2)

                    var result = left_eq
                    result = result and right_eq
                    result

# ============================================================================
# MAIN COMPRESSION/DECOMPRESSION PIPELINE
# ============================================================================

fn huffman_compress(data):
    """Full compression pipeline with tree and encoded data"""
    val unique_count = huffman_get_unique_symbols(data)
    if unique_count == 0:
        nil
    else:
        val tree = huffman_build_tree_from_data(data)
        val code_table = huffman_build_code_table(tree)
        val encoded = huffman_encode_data(data, code_table)
        val tree_str = huffman_serialize_tree(tree)
        (tree_str, encoded)

fn huffman_decompress(tree_str, encoded):
    """Full decompression pipeline"""
    val tree = huffman_deserialize_tree(tree_str)
    if tree == nil:
        nil
    else:
        val symbols = huffman_decode(tree, encoded)
        if symbols == nil:
            nil
        else:
            huffman_symbols_to_string(symbols)

fn huffman_compress_to_bytes(data):
    """Compress data to byte array"""
    val compressed = huffman_compress(data)
    if compressed == nil:
        nil
    else:
        val tree_str = compressed[0]
        val encoded = compressed[1]
        val bytes = huffman_bits_to_bytes(encoded)
        (tree_str, bytes)

fn huffman_decompress_from_bytes(tree_str, bytes):
    """Decompress from byte array"""
    val bits = huffman_bytes_to_bits(bytes)
    huffman_decompress(tree_str, bits)
