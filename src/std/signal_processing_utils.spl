# signal_processing_utils.spl - Comprehensive Digital Signal Processing Module
# Provides filters, transforms, resampling, windowing, and signal analysis

# ============================================================================
# CONSTANTS
# ============================================================================

val PI = 3.141592653589793
val TWO_PI = 6.283185307179586
val HALF_PI = 1.5707963267948966

# ============================================================================
# BASIC MATH UTILITIES
# ============================================================================

fn abs_f64(x: f64) -> f64:
    if x < 0.0:
        return 0.0 - x
    return x

fn sqrt_f64(x: f64) -> f64:
    # Newton-Raphson method for square root
    if x < 0.0:
        return 0.0
    if x == 0.0:
        return 0.0

    var guess = x / 2.0
    var iteration = 0
    while iteration < 20:
        var next_guess = (guess + x / guess) / 2.0
        var diff = abs_f64(next_guess - guess)
        if diff < 0.000001:
            return next_guess
        guess = next_guess
        iteration = iteration + 1
    return guess

fn pow_f64(base: f64, exp: f64) -> f64:
    # Simple power function for integer exponents
    if exp == 0.0:
        return 1.0
    if exp == 1.0:
        return base

    var result = 1.0
    var abs_exp = abs_f64(exp)
    var i = 0.0
    while i < abs_exp:
        result = result * base
        i = i + 1.0

    if exp < 0.0:
        return 1.0 / result
    return result

fn sin_f64(x: f64) -> f64:
    # Taylor series approximation for sine
    var norm_x = x
    while norm_x > PI:
        norm_x = norm_x - TWO_PI
    while norm_x < 0.0 - PI:
        norm_x = norm_x + TWO_PI

    var term = norm_x
    var sum = term
    var i = 1
    while i < 15:
        var mult = 0.0 - (norm_x * norm_x)
        var denom = (2 * i) * (2 * i + 1)
        term = term * mult / denom
        sum = sum + term
        i = i + 1
    return sum

fn cos_f64(x: f64) -> f64:
    # cos(x) = sin(x + Ï€/2)
    return sin_f64(x + HALF_PI)

fn tan_f64(x: f64) -> f64:
    var cos_val = cos_f64(x)
    if abs_f64(cos_val) < 0.000001:
        return 0.0
    return sin_f64(x) / cos_val

fn atan_f64(x: f64) -> f64:
    # Approximation for arctangent
    if abs_f64(x) > 1.0:
        var sign = 1.0
        if x < 0.0:
            sign = 0.0 - 1.0
        var inv = 1.0 / x
        return sign * (HALF_PI - atan_f64(inv * sign))

    var x2 = x * x
    var x3 = x2 * x
    var x5 = x3 * x2
    var x7 = x5 * x2
    return x - x3 / 3.0 + x5 / 5.0 - x7 / 7.0

fn atan2_f64(y: f64, x: f64) -> f64:
    if x > 0.0:
        return atan_f64(y / x)
    if x < 0.0:
        if y >= 0.0:
            return atan_f64(y / x) + PI
        return atan_f64(y / x) - PI
    if y > 0.0:
        return HALF_PI
    if y < 0.0:
        return 0.0 - HALF_PI
    return 0.0

fn exp_f64(x: f64) -> f64:
    # Taylor series for e^x
    if x > 50.0:
        return 1.0e20
    if x < 0.0 - 50.0:
        return 0.0

    var sum = 1.0
    var term = 1.0
    var i = 1
    while i < 30:
        term = term * x / i
        sum = sum + term
        i = i + 1
    return sum

fn log_f64(x: f64) -> f64:
    # Natural logarithm using series expansion
    if x <= 0.0:
        return 0.0
    if x == 1.0:
        return 0.0

    # For x near 1, use ln(1+u) series
    if x > 0.5 and x < 1.5:
        var u = x - 1.0
        var u2 = u * u
        var u3 = u2 * u
        var u4 = u3 * u
        var u5 = u4 * u
        return u - u2/2.0 + u3/3.0 - u4/4.0 + u5/5.0

    # For larger x, reduce range
    var exp_count = 0.0
    var reduced = x
    while reduced > 2.0:
        reduced = reduced / 2.0
        exp_count = exp_count + 1.0
    while reduced < 0.5:
        reduced = reduced * 2.0
        exp_count = exp_count - 1.0

    var ln2 = 0.693147180559945
    return log_f64(reduced) + exp_count * ln2

fn log10_f64(x: f64) -> f64:
    var ln10 = 2.302585092994046
    return log_f64(x) / ln10

fn floor_f64(x: f64) -> f64:
    var int_part = x
    if x < 0.0 and x != int_part:
        return int_part - 1.0
    return int_part

fn ceil_f64(x: f64) -> f64:
    var int_part = x
    if x > 0.0 and x != int_part:
        return int_part + 1.0
    return int_part

# ============================================================================
# ARRAY UTILITIES
# ============================================================================

fn array_copy(src: list, dest: list, n: i64):
    var i = 0
    while i < n:
        dest[i] = src[i]
        i = i + 1
    pass

fn array_fill(arr: list, value: f64, n: i64):
    var i = 0
    while i < n:
        arr[i] = value
        i = i + 1
    pass

fn array_add(a: list, b: list, result: list, n: i64):
    var i = 0
    while i < n:
        result[i] = a[i] + b[i]
        i = i + 1
    pass

fn array_multiply(arr: list, scalar: f64, result: list, n: i64):
    var i = 0
    while i < n:
        result[i] = arr[i] * scalar
        i = i + 1
    pass

fn array_max(arr: list, n: i64) -> f64:
    if n == 0:
        return 0.0
    var max_val = arr[0]
    var i = 1
    while i < n:
        if arr[i] > max_val:
            max_val = arr[i]
        i = i + 1
    return max_val

fn array_min(arr: list, n: i64) -> f64:
    if n == 0:
        return 0.0
    var min_val = arr[0]
    var i = 1
    while i < n:
        if arr[i] < min_val:
            min_val = arr[i]
        i = i + 1
    return min_val

fn array_sum(arr: list, n: i64) -> f64:
    var sum = 0.0
    var i = 0
    while i < n:
        sum = sum + arr[i]
        i = i + 1
    return sum

fn array_mean(arr: list, n: i64) -> f64:
    if n == 0:
        return 0.0
    return array_sum(arr, n) / n

# ============================================================================
# SIGNAL GENERATION
# ============================================================================

fn generate_sine(frequency: f64, sample_rate: f64, duration: f64, amplitude: f64, output: list) -> i64:
    # Generate sine wave
    var n_samples = duration * sample_rate
    var i = 0
    while i < n_samples:
        var t = i / sample_rate
        var phase = TWO_PI * frequency * t
        output[i] = amplitude * sin_f64(phase)
        i = i + 1
    return n_samples

fn generate_cosine(frequency: f64, sample_rate: f64, duration: f64, amplitude: f64, output: list) -> i64:
    # Generate cosine wave
    var n_samples = duration * sample_rate
    var i = 0
    while i < n_samples:
        var t = i / sample_rate
        var phase = TWO_PI * frequency * t
        output[i] = amplitude * cos_f64(phase)
        i = i + 1
    return n_samples

fn generate_square(frequency: f64, sample_rate: f64, duration: f64, amplitude: f64, output: list) -> i64:
    # Generate square wave
    var n_samples = duration * sample_rate
    var period = 1.0 / frequency
    var i = 0
    while i < n_samples:
        var t = i / sample_rate
        var phase_time = t - floor_f64(t / period) * period
        if phase_time < period / 2.0:
            output[i] = amplitude
        else:
            output[i] = 0.0 - amplitude
        i = i + 1
    return n_samples

fn generate_sawtooth(frequency: f64, sample_rate: f64, duration: f64, amplitude: f64, output: list) -> i64:
    # Generate sawtooth wave
    var n_samples = duration * sample_rate
    var period = 1.0 / frequency
    var i = 0
    while i < n_samples:
        var t = i / sample_rate
        var phase_time = t - floor_f64(t / period) * period
        output[i] = 2.0 * amplitude * (phase_time / period - 0.5)
        i = i + 1
    return n_samples

fn generate_triangle(frequency: f64, sample_rate: f64, duration: f64, amplitude: f64, output: list) -> i64:
    # Generate triangle wave
    var n_samples = duration * sample_rate
    var period = 1.0 / frequency
    var i = 0
    while i < n_samples:
        var t = i / sample_rate
        var phase_time = t - floor_f64(t / period) * period
        var phase_norm = phase_time / period
        if phase_norm < 0.25:
            output[i] = 4.0 * amplitude * phase_norm
        else:
            if phase_norm < 0.75:
                output[i] = 2.0 * amplitude - 4.0 * amplitude * phase_norm
            else:
                output[i] = 4.0 * amplitude * phase_norm - 4.0 * amplitude
        i = i + 1
    return n_samples

fn generate_white_noise(amplitude: f64, n_samples: i64, seed: i64, output: list):
    # Generate white noise using simple LCG
    var state = seed
    var i = 0
    while i < n_samples:
        state = (state * 1103515245 + 12345) % 2147483648
        var norm = (state / 1073741824.0) - 1.0
        output[i] = amplitude * norm
        i = i + 1
    pass

fn generate_chirp(f_start: f64, f_end: f64, sample_rate: f64, duration: f64, amplitude: f64, output: list) -> i64:
    # Generate linear chirp (frequency sweep)
    var n_samples = duration * sample_rate
    var k = (f_end - f_start) / duration
    var i = 0
    while i < n_samples:
        var t = i / sample_rate
        var phase = TWO_PI * (f_start * t + 0.5 * k * t * t)
        output[i] = amplitude * sin_f64(phase)
        i = i + 1
    return n_samples

# ============================================================================
# WINDOW FUNCTIONS
# ============================================================================

fn window_rectangular(n: i64, output: list):
    # Rectangular (boxcar) window
    var i = 0
    while i < n:
        output[i] = 1.0
        i = i + 1
    pass

fn window_hamming(n: i64, output: list):
    # Hamming window
    var i = 0
    while i < n:
        var phase = TWO_PI * i / (n - 1)
        output[i] = 0.54 - 0.46 * cos_f64(phase)
        i = i + 1
    pass

fn window_hanning(n: i64, output: list):
    # Hanning (Hann) window
    var i = 0
    while i < n:
        var phase = TWO_PI * i / (n - 1)
        output[i] = 0.5 * (1.0 - cos_f64(phase))
        i = i + 1
    pass

fn window_blackman(n: i64, output: list):
    # Blackman window
    var a0 = 0.42
    var a1 = 0.5
    var a2 = 0.08
    var i = 0
    while i < n:
        var phase1 = TWO_PI * i / (n - 1)
        var phase2 = 2.0 * phase1
        output[i] = a0 - a1 * cos_f64(phase1) + a2 * cos_f64(phase2)
        i = i + 1
    pass

fn window_kaiser(n: i64, beta: f64, output: list):
    # Kaiser window (simplified - using approximation)
    var alpha = (n - 1) / 2.0
    var i = 0
    while i < n:
        var x = (i - alpha) / alpha
        var arg = beta * sqrt_f64(1.0 - x * x)
        # Simplified I0 Bessel function approximation
        var bessel = 1.0 + arg * arg / 4.0
        output[i] = bessel / (1.0 + beta * beta / 4.0)
        i = i + 1
    pass

fn window_bartlett(n: i64, output: list):
    # Bartlett (triangular) window
    var mid = (n - 1) / 2.0
    var i = 0
    while i < n:
        output[i] = 1.0 - abs_f64((i - mid) / mid)
        i = i + 1
    pass

fn apply_window(signal: list, window: list, output: list, n: i64):
    # Apply window function to signal
    var i = 0
    while i < n:
        output[i] = signal[i] * window[i]
        i = i + 1
    pass

# ============================================================================
# CONVOLUTION AND CORRELATION
# ============================================================================

fn convolve(signal: list, sig_len: i64, kernel: list, kern_len: i64, output: list) -> i64:
    # 1D convolution
    var out_len = sig_len + kern_len - 1
    var i = 0
    while i < out_len:
        output[i] = 0.0
        i = i + 1

    i = 0
    while i < sig_len:
        var j = 0
        while j < kern_len:
            var out_idx = i + j
            output[out_idx] = output[out_idx] + signal[i] * kernel[j]
            j = j + 1
        i = i + 1

    return out_len

fn correlate(signal1: list, len1: i64, signal2: list, len2: i64, output: list) -> i64:
    # Cross-correlation
    var out_len = len1 + len2 - 1
    var i = 0
    while i < out_len:
        output[i] = 0.0
        i = i + 1

    i = 0
    while i < len1:
        var j = 0
        while j < len2:
            var out_idx = i + j
            output[out_idx] = output[out_idx] + signal1[i] * signal2[len2 - 1 - j]
            j = j + 1
        i = i + 1

    return out_len

fn autocorrelate(signal: list, n: i64, max_lag: i64, output: list):
    # Autocorrelation
    var lag = 0
    while lag <= max_lag:
        var sum = 0.0
        var i = 0
        while i < n - lag:
            sum = sum + signal[i] * signal[i + lag]
            i = i + 1
        output[lag] = sum / (n - lag)
        lag = lag + 1
    pass

# ============================================================================
# FILTERING - FIR FILTERS
# ============================================================================

fn fir_filter(signal: list, sig_len: i64, coeffs: list, num_taps: i64, output: list):
    # Apply FIR filter
    var i = 0
    while i < sig_len:
        var sum = 0.0
        var j = 0
        while j < num_taps:
            var sig_idx = i - j
            if sig_idx >= 0:
                sum = sum + coeffs[j] * signal[sig_idx]
            j = j + 1
        output[i] = sum
        i = i + 1
    pass

fn fir_lowpass_coeffs(cutoff_freq: f64, sample_rate: f64, num_taps: i64, coeffs: list):
    # Design FIR lowpass filter using windowed sinc
    var fc = cutoff_freq / sample_rate
    var mid = (num_taps - 1) / 2.0

    var i = 0
    while i < num_taps:
        var n = i - mid
        if abs_f64(n) < 0.001:
            coeffs[i] = 2.0 * fc
        else:
            var sinc_arg = TWO_PI * fc * n
            coeffs[i] = sin_f64(sinc_arg) / (PI * n)

        # Apply Hamming window
        var phase = TWO_PI * i / (num_taps - 1)
        var window_val = 0.54 - 0.46 * cos_f64(phase)
        coeffs[i] = coeffs[i] * window_val
        i = i + 1

    # Normalize
    var sum = array_sum(coeffs, num_taps)
    if abs_f64(sum) > 0.001:
        i = 0
        while i < num_taps:
            coeffs[i] = coeffs[i] / sum
            i = i + 1
    pass

fn fir_highpass_coeffs(cutoff_freq: f64, sample_rate: f64, num_taps: i64, coeffs: list):
    # Design FIR highpass filter
    fir_lowpass_coeffs(cutoff_freq, sample_rate, num_taps, coeffs)

    # Spectral inversion
    var i = 0
    while i < num_taps:
        coeffs[i] = 0.0 - coeffs[i]
        i = i + 1

    var mid = (num_taps - 1) / 2
    coeffs[mid] = coeffs[mid] + 1.0
    pass

fn fir_bandpass_coeffs(low_freq: f64, high_freq: f64, sample_rate: f64, num_taps: i64, coeffs: list):
    # Design FIR bandpass filter
    var low_coeffs = []
    var high_coeffs = []

    fir_lowpass_coeffs(high_freq, sample_rate, num_taps, high_coeffs)
    fir_lowpass_coeffs(low_freq, sample_rate, num_taps, low_coeffs)

    # Subtract lowpass from lowpass
    var i = 0
    while i < num_taps:
        coeffs[i] = high_coeffs[i] - low_coeffs[i]
        i = i + 1
    pass

fn fir_bandstop_coeffs(low_freq: f64, high_freq: f64, sample_rate: f64, num_taps: i64, coeffs: list):
    # Design FIR bandstop filter
    fir_bandpass_coeffs(low_freq, high_freq, sample_rate, num_taps, coeffs)

    # Spectral inversion
    var i = 0
    while i < num_taps:
        coeffs[i] = 0.0 - coeffs[i]
        i = i + 1

    var mid = (num_taps - 1) / 2
    coeffs[mid] = coeffs[mid] + 1.0
    pass

# ============================================================================
# FILTERING - IIR FILTERS (BIQUAD CASCADE)
# ============================================================================

fn biquad_filter(signal: list, sig_len: i64, b0: f64, b1: f64, b2: f64, a1: f64, a2: f64, output: list):
    # Apply single biquad section
    var x1 = 0.0
    var x2 = 0.0
    var y1 = 0.0
    var y2 = 0.0

    var i = 0
    while i < sig_len:
        var x0 = signal[i]
        var y0 = b0 * x0 + b1 * x1 + b2 * x2 - a1 * y1 - a2 * y2

        output[i] = y0

        x2 = x1
        x1 = x0
        y2 = y1
        y1 = y0
        i = i + 1
    pass

fn butterworth_lowpass_biquad(cutoff_freq: f64, sample_rate: f64, coeffs: list):
    # Design 2nd order Butterworth lowpass biquad coefficients
    # Returns [b0, b1, b2, a1, a2]
    var omega = TWO_PI * cutoff_freq / sample_rate
    var omega_s = sin_f64(omega)
    var omega_c = cos_f64(omega)
    var alpha = omega_s / (2.0 * 1.414213562373095)  # Q = 1/sqrt(2)

    var a0 = 1.0 + alpha
    coeffs[0] = (1.0 - omega_c) / (2.0 * a0)  # b0
    coeffs[1] = (1.0 - omega_c) / a0           # b1
    coeffs[2] = (1.0 - omega_c) / (2.0 * a0)  # b2
    coeffs[3] = (0.0 - 2.0 * omega_c) / a0     # a1
    coeffs[4] = (1.0 - alpha) / a0             # a2
    pass

fn butterworth_highpass_biquad(cutoff_freq: f64, sample_rate: f64, coeffs: list):
    # Design 2nd order Butterworth highpass biquad coefficients
    var omega = TWO_PI * cutoff_freq / sample_rate
    var omega_s = sin_f64(omega)
    var omega_c = cos_f64(omega)
    var alpha = omega_s / (2.0 * 1.414213562373095)

    var a0 = 1.0 + alpha
    coeffs[0] = (1.0 + omega_c) / (2.0 * a0)  # b0
    coeffs[1] = (0.0 - (1.0 + omega_c)) / a0   # b1
    coeffs[2] = (1.0 + omega_c) / (2.0 * a0)  # b2
    coeffs[3] = (0.0 - 2.0 * omega_c) / a0     # a1
    coeffs[4] = (1.0 - alpha) / a0             # a2
    pass

fn butterworth_bandpass_biquad(center_freq: f64, bandwidth: f64, sample_rate: f64, coeffs: list):
    # Design 2nd order Butterworth bandpass biquad coefficients
    var omega = TWO_PI * center_freq / sample_rate
    var omega_s = sin_f64(omega)
    var omega_c = cos_f64(omega)
    var bw_norm = bandwidth / sample_rate
    var alpha = omega_s * bw_norm

    var a0 = 1.0 + alpha
    coeffs[0] = alpha / a0                     # b0
    coeffs[1] = 0.0                            # b1
    coeffs[2] = (0.0 - alpha) / a0             # b2
    coeffs[3] = (0.0 - 2.0 * omega_c) / a0     # a1
    coeffs[4] = (1.0 - alpha) / a0             # a2
    pass

fn butterworth_bandstop_biquad(center_freq: f64, bandwidth: f64, sample_rate: f64, coeffs: list):
    # Design 2nd order Butterworth bandstop (notch) biquad coefficients
    var omega = TWO_PI * center_freq / sample_rate
    var omega_s = sin_f64(omega)
    var omega_c = cos_f64(omega)
    var bw_norm = bandwidth / sample_rate
    var alpha = omega_s * bw_norm

    var a0 = 1.0 + alpha
    coeffs[0] = 1.0 / a0                       # b0
    coeffs[1] = (0.0 - 2.0 * omega_c) / a0     # b1
    coeffs[2] = 1.0 / a0                       # b2
    coeffs[3] = (0.0 - 2.0 * omega_c) / a0     # a1
    coeffs[4] = (1.0 - alpha) / a0             # a2
    pass

fn chebyshev_lowpass_biquad(cutoff_freq: f64, sample_rate: f64, ripple_db: f64, coeffs: list):
    # Design 2nd order Chebyshev Type I lowpass biquad
    # Simplified version with fixed parameters
    var epsilon = sqrt_f64(pow_f64(10.0, ripple_db / 10.0) - 1.0)
    var omega = TWO_PI * cutoff_freq / sample_rate
    var omega_s = sin_f64(omega)
    var omega_c = cos_f64(omega)

    # Simplified calculation
    var alpha = omega_s / 2.0
    var a0 = 1.0 + alpha

    coeffs[0] = (1.0 - omega_c) / (2.0 * a0)
    coeffs[1] = (1.0 - omega_c) / a0
    coeffs[2] = (1.0 - omega_c) / (2.0 * a0)
    coeffs[3] = (0.0 - 2.0 * omega_c) / a0
    coeffs[4] = (1.0 - alpha) / a0
    pass

fn bessel_lowpass_biquad(cutoff_freq: f64, sample_rate: f64, coeffs: list):
    # Design 2nd order Bessel lowpass biquad (approximation)
    var omega = TWO_PI * cutoff_freq / sample_rate
    var omega_s = sin_f64(omega)
    var omega_c = cos_f64(omega)

    # Bessel Q factor for 2nd order
    var q = 0.577350269189626  # 1/sqrt(3)
    var alpha = omega_s / (2.0 * q)

    var a0 = 1.0 + alpha
    coeffs[0] = (1.0 - omega_c) / (2.0 * a0)
    coeffs[1] = (1.0 - omega_c) / a0
    coeffs[2] = (1.0 - omega_c) / (2.0 * a0)
    coeffs[3] = (0.0 - 2.0 * omega_c) / a0
    coeffs[4] = (1.0 - alpha) / a0
    pass

# ============================================================================
# RESAMPLING
# ============================================================================

fn downsample(signal: list, sig_len: i64, factor: i64, output: list) -> i64:
    # Downsample by integer factor
    var out_len = sig_len / factor
    var i = 0
    while i < out_len:
        output[i] = signal[i * factor]
        i = i + 1
    return out_len

fn upsample(signal: list, sig_len: i64, factor: i64, output: list) -> i64:
    # Upsample by integer factor (zero-stuffing)
    var out_len = sig_len * factor
    var i = 0
    while i < out_len:
        output[i] = 0.0
        i = i + 1

    i = 0
    while i < sig_len:
        output[i * factor] = signal[i]
        i = i + 1

    return out_len

fn interpolate_linear(signal: list, sig_len: i64, factor: i64, output: list) -> i64:
    # Linear interpolation upsampling
    var out_len = sig_len * factor

    var i = 0
    while i < sig_len - 1:
        var base_idx = i * factor
        output[base_idx] = signal[i]

        var j = 1
        while j < factor:
            var alpha = j / factor
            var interp_val = signal[i] * (1.0 - alpha) + signal[i + 1] * alpha
            output[base_idx + j] = interp_val
            j = j + 1
        i = i + 1

    output[out_len - 1] = signal[sig_len - 1]
    return out_len

fn resample_ratio(signal: list, sig_len: i64, up_factor: i64, down_factor: i64, output: list) -> i64:
    # Resample by rational ratio (up_factor / down_factor)
    var temp = []
    var temp_len = upsample(signal, sig_len, up_factor, temp)
    return downsample(temp, temp_len, down_factor, output)

# ============================================================================
# MOVING FILTERS
# ============================================================================

fn moving_average(signal: list, sig_len: i64, window_size: i64, output: list):
    # Moving average filter
    var i = 0
    while i < sig_len:
        var sum = 0.0
        var count = 0
        var j = 0
        while j < window_size:
            var idx = i - j
            if idx >= 0:
                sum = sum + signal[idx]
                count = count + 1
            j = j + 1
        output[i] = sum / count
        i = i + 1
    pass

fn median_filter(signal: list, sig_len: i64, window_size: i64, output: list):
    # Median filter (simplified - for small windows)
    var temp = []
    var i = 0
    while i < sig_len:
        var count = 0
        var j = 0
        while j < window_size:
            var idx = i - window_size / 2 + j
            if idx >= 0 and idx < sig_len:
                temp[count] = signal[idx]
                count = count + 1
            j = j + 1

        # Simple bubble sort for median
        var k = 0
        while k < count - 1:
            var m = 0
            while m < count - k - 1:
                if temp[m] > temp[m + 1]:
                    var swap = temp[m]
                    temp[m] = temp[m + 1]
                    temp[m + 1] = swap
                m = m + 1
            k = k + 1

        output[i] = temp[count / 2]
        i = i + 1
    pass

fn savitzky_golay_smooth(signal: list, sig_len: i64, window_size: i64, output: list):
    # Savitzky-Golay smoothing filter (quadratic, simplified)
    # Using pre-computed coefficients for common window sizes
    var half_window = window_size / 2

    var i = 0
    while i < sig_len:
        var sum = 0.0
        var norm = 0.0

        var j = 0
        while j < window_size:
            var idx = i - half_window + j
            if idx >= 0 and idx < sig_len:
                # Simplified quadratic coefficients
                var offset = j - half_window
                var coeff = 1.0 - abs_f64(offset) / (half_window + 1.0)
                sum = sum + signal[idx] * coeff
                norm = norm + coeff
            j = j + 1

        if norm > 0.0:
            output[i] = sum / norm
        else:
            output[i] = signal[i]
        i = i + 1
    pass

fn exponential_moving_average(signal: list, sig_len: i64, alpha: f64, output: list):
    # Exponential moving average (EMA)
    if sig_len == 0:
        return pass

    output[0] = signal[0]
    var i = 1
    while i < sig_len:
        output[i] = alpha * signal[i] + (1.0 - alpha) * output[i - 1]
        i = i + 1
    pass

# ============================================================================
# SPECTRAL ANALYSIS
# ============================================================================

fn periodogram(signal: list, sig_len: i64, power_spectrum: list):
    # Simple periodogram (power spectral density estimate)
    # This is a simplified version - real FFT would be used
    var i = 0
    while i < sig_len / 2:
        var freq_component_real = 0.0
        var freq_component_imag = 0.0

        var j = 0
        while j < sig_len:
            var phase = TWO_PI * i * j / sig_len
            freq_component_real = freq_component_real + signal[j] * cos_f64(phase)
            freq_component_imag = freq_component_imag + signal[j] * sin_f64(phase)
            j = j + 1

        var magnitude_sq = freq_component_real * freq_component_real + freq_component_imag * freq_component_imag
        power_spectrum[i] = magnitude_sq / (sig_len * sig_len)
        i = i + 1
    pass

fn welch_method(signal: list, sig_len: i64, segment_len: i64, overlap: i64, power_spectrum: list):
    # Welch's method for spectral estimation
    var hop_size = segment_len - overlap
    var num_segments = (sig_len - overlap) / hop_size

    # Initialize output
    var i = 0
    while i < segment_len / 2:
        power_spectrum[i] = 0.0
        i = i + 1

    # Window
    var window = []
    window_hamming(segment_len, window)

    # Process segments
    var seg = 0
    while seg < num_segments:
        var start = seg * hop_size
        if start + segment_len > sig_len:
            break

        var segment = []
        var windowed = []

        i = 0
        while i < segment_len:
            segment[i] = signal[start + i]
            i = i + 1

        apply_window(segment, window, windowed, segment_len)

        var seg_spectrum = []
        periodogram(windowed, segment_len, seg_spectrum)

        i = 0
        while i < segment_len / 2:
            power_spectrum[i] = power_spectrum[i] + seg_spectrum[i]
            i = i + 1

        seg = seg + 1

    # Average
    if num_segments > 0:
        i = 0
        while i < segment_len / 2:
            power_spectrum[i] = power_spectrum[i] / num_segments
            i = i + 1
    pass

# ============================================================================
# ENVELOPE DETECTION
# ============================================================================

fn envelope_hilbert(signal: list, sig_len: i64, envelope: list):
    # Simplified envelope detection using Hilbert transform approximation
    # This uses finite difference approximation
    var i = 0
    while i < sig_len:
        var window = 5
        var analytic_imag = 0.0

        var j = 1
        while j <= window / 2:
            var forward_idx = i + j
            var backward_idx = i - j

            if forward_idx < sig_len and backward_idx >= 0:
                analytic_imag = analytic_imag + (signal[forward_idx] - signal[backward_idx]) / j
            j = j + 1

        var magnitude = sqrt_f64(signal[i] * signal[i] + analytic_imag * analytic_imag)
        envelope[i] = magnitude
        i = i + 1
    pass

fn envelope_peak_detection(signal: list, sig_len: i64, window_size: i64, envelope: list):
    # Peak-based envelope detection
    var i = 0
    while i < sig_len:
        var max_val = 0.0
        var j = 0
        while j < window_size:
            var idx = i - window_size / 2 + j
            if idx >= 0 and idx < sig_len:
                var abs_val = abs_f64(signal[idx])
                if abs_val > max_val:
                    max_val = abs_val
            j = j + 1
        envelope[i] = max_val
        i = i + 1
    pass

fn envelope_rms(signal: list, sig_len: i64, window_size: i64, envelope: list):
    # RMS-based envelope detection
    var i = 0
    while i < sig_len:
        var sum_sq = 0.0
        var count = 0
        var j = 0
        while j < window_size:
            var idx = i - window_size / 2 + j
            if idx >= 0 and idx < sig_len:
                sum_sq = sum_sq + signal[idx] * signal[idx]
                count = count + 1
            j = j + 1

        if count > 0:
            envelope[i] = sqrt_f64(sum_sq / count)
        else:
            envelope[i] = 0.0
        i = i + 1
    pass

# ============================================================================
# SIGNAL METRICS
# ============================================================================

fn rms_value(signal: list, sig_len: i64) -> f64:
    # Root mean square value
    var sum_sq = 0.0
    var i = 0
    while i < sig_len:
        sum_sq = sum_sq + signal[i] * signal[i]
        i = i + 1
    return sqrt_f64(sum_sq / sig_len)

fn peak_value(signal: list, sig_len: i64) -> f64:
    # Peak absolute value
    var max_val = 0.0
    var i = 0
    while i < sig_len:
        var abs_val = abs_f64(signal[i])
        if abs_val > max_val:
            max_val = abs_val
        i = i + 1
    return max_val

fn crest_factor(signal: list, sig_len: i64) -> f64:
    # Crest factor (peak / RMS)
    var peak = peak_value(signal, sig_len)
    var rms = rms_value(signal, sig_len)
    if rms == 0.0:
        return 0.0
    return peak / rms

fn signal_power(signal: list, sig_len: i64) -> f64:
    # Average signal power
    var sum_sq = 0.0
    var i = 0
    while i < sig_len:
        sum_sq = sum_sq + signal[i] * signal[i]
        i = i + 1
    return sum_sq / sig_len

fn snr_ratio(signal: list, noise: list, sig_len: i64) -> f64:
    # Signal-to-noise ratio
    var signal_pwr = signal_power(signal, sig_len)
    var noise_pwr = signal_power(noise, sig_len)
    if noise_pwr == 0.0:
        return 0.0
    return signal_pwr / noise_pwr

fn snr_db(signal: list, noise: list, sig_len: i64) -> f64:
    # Signal-to-noise ratio in dB
    var ratio = snr_ratio(signal, noise, sig_len)
    if ratio <= 0.0:
        return 0.0
    return 10.0 * log10_f64(ratio)

fn thd_estimate(signal: list, sig_len: i64, fundamental_freq: f64, sample_rate: f64, num_harmonics: i64) -> f64:
    # Total harmonic distortion estimate
    var fundamental_power = 0.0
    var harmonic_power = 0.0

    # Estimate fundamental power (simplified)
    var spectrum = []
    periodogram(signal, sig_len, spectrum)

    var fund_bin = fundamental_freq * sig_len / sample_rate
    fundamental_power = spectrum[fund_bin]

    # Estimate harmonic powers
    var h = 2
    while h <= num_harmonics:
        var harm_bin = h * fund_bin
        if harm_bin < sig_len / 2:
            harmonic_power = harmonic_power + spectrum[harm_bin]
        h = h + 1

    if fundamental_power == 0.0:
        return 0.0
    return sqrt_f64(harmonic_power / fundamental_power)

fn sinad_db(signal: list, noise_and_distortion: list, sig_len: i64) -> f64:
    # Signal to noise and distortion ratio in dB
    var signal_pwr = signal_power(signal, sig_len)
    var nad_pwr = signal_power(noise_and_distortion, sig_len)
    if nad_pwr == 0.0:
        return 0.0
    return 10.0 * log10_f64(signal_pwr / nad_pwr)

# ============================================================================
# ZERO CROSSING AND PEAK DETECTION
# ============================================================================

fn zero_crossings(signal: list, sig_len: i64) -> i64:
    # Count zero crossings
    var count = 0
    var i = 1
    while i < sig_len:
        var product = signal[i - 1] * signal[i]
        if product < 0.0:
            count = count + 1
        i = i + 1
    return count

fn zero_crossing_rate(signal: list, sig_len: i64, sample_rate: f64) -> f64:
    # Zero crossing rate (crossings per second)
    var crossings = zero_crossings(signal, sig_len)
    var duration = sig_len / sample_rate
    return crossings / duration

fn find_peaks(signal: list, sig_len: i64, threshold: f64, peak_indices: list) -> i64:
    # Find peaks above threshold
    var num_peaks = 0
    var i = 1
    while i < sig_len - 1:
        var is_peak = signal[i] > signal[i - 1]
        is_peak = is_peak and signal[i] > signal[i + 1]
        is_peak = is_peak and signal[i] > threshold

        if is_peak:
            peak_indices[num_peaks] = i
            num_peaks = num_peaks + 1
        i = i + 1
    return num_peaks

fn find_valleys(signal: list, sig_len: i64, threshold: f64, valley_indices: list) -> i64:
    # Find valleys below threshold
    var num_valleys = 0
    var i = 1
    while i < sig_len - 1:
        var is_valley = signal[i] < signal[i - 1]
        is_valley = is_valley and signal[i] < signal[i + 1]
        is_valley = is_valley and signal[i] < threshold

        if is_valley:
            valley_indices[num_valleys] = i
            num_valleys = num_valleys + 1
        i = i + 1
    return num_valleys

# ============================================================================
# DC REMOVAL AND NORMALIZATION
# ============================================================================

fn remove_dc(signal: list, sig_len: i64, output: list):
    # Remove DC component (mean)
    var mean = array_mean(signal, sig_len)
    var i = 0
    while i < sig_len:
        output[i] = signal[i] - mean
        i = i + 1
    pass

fn normalize_signal(signal: list, sig_len: i64, output: list):
    # Normalize signal to [-1, 1]
    var max_abs = 0.0
    var i = 0
    while i < sig_len:
        var abs_val = abs_f64(signal[i])
        if abs_val > max_abs:
            max_abs = abs_val
        i = i + 1

    if max_abs == 0.0:
        array_copy(signal, output, sig_len)
        return pass

    i = 0
    while i < sig_len:
        output[i] = signal[i] / max_abs
        i = i + 1
    pass

fn normalize_rms(signal: list, sig_len: i64, target_rms: f64, output: list):
    # Normalize signal to target RMS value
    var current_rms = rms_value(signal, sig_len)
    if current_rms == 0.0:
        array_copy(signal, output, sig_len)
        return pass

    var scale = target_rms / current_rms
    var i = 0
    while i < sig_len:
        output[i] = signal[i] * scale
        i = i + 1
    pass

# ============================================================================
# DIFFERENTIATION AND INTEGRATION
# ============================================================================

fn differentiate(signal: list, sig_len: i64, sample_rate: f64, output: list):
    # Numerical differentiation
    output[0] = 0.0
    var i = 1
    while i < sig_len:
        output[i] = (signal[i] - signal[i - 1]) * sample_rate
        i = i + 1
    pass

fn integrate(signal: list, sig_len: i64, sample_period: f64, output: list):
    # Numerical integration (cumulative sum * dt)
    output[0] = signal[0] * sample_period
    var i = 1
    while i < sig_len:
        output[i] = output[i - 1] + signal[i] * sample_period
        i = i + 1
    pass

# ============================================================================
# FREQUENCY ESTIMATION
# ============================================================================

fn estimate_frequency_zero_crossing(signal: list, sig_len: i64, sample_rate: f64) -> f64:
    # Estimate fundamental frequency using zero crossing rate
    var zcr = zero_crossing_rate(signal, sig_len, sample_rate)
    return zcr / 2.0

fn estimate_frequency_autocorr(signal: list, sig_len: i64, sample_rate: f64) -> f64:
    # Estimate fundamental frequency using autocorrelation
    var max_lag = sig_len / 2
    var autocorr = []
    autocorrelate(signal, sig_len, max_lag, autocorr)

    # Find first peak after zero lag
    var peak_lag = 1
    var max_val = autocorr[1]
    var i = 2
    while i < max_lag:
        if autocorr[i] > max_val:
            var is_peak = autocorr[i] > autocorr[i - 1]
            is_peak = is_peak and autocorr[i] > autocorr[i + 1]
            if is_peak:
                max_val = autocorr[i]
                peak_lag = i
        i = i + 1

    return sample_rate / peak_lag

# ============================================================================
# END OF MODULE
# ============================================================================
