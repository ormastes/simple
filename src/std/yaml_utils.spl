# YAML Parsing and Generation Module
# Provides comprehensive YAML support with parsing, serialization, and manipulation

# ============================================================================
# YAML Value Types
# ============================================================================
# YAML values are represented as tuples: (type, value)
# Types: "mapping", "sequence", "scalar", "null"
# - mapping: (type, List of (key, value) tuples)
# - sequence: (type, List of values)
# - scalar: (type, (scalar_type, content)) where scalar_type is "string", "number", "boolean", "null"

# ============================================================================
# Value Constructors
# ============================================================================

fn yaml_null() -> (text, (text, text)):
    """Create a YAML null value."""
    ("scalar", ("null", "null"))

fn yaml_boolean(value: bool) -> (text, (text, text)):
    """Create a YAML boolean value."""
    val str_value = if value: "true" else: "false"
    ("scalar", ("boolean", str_value))

fn yaml_number(value: text) -> (text, (text, text)):
    """Create a YAML number value."""
    ("scalar", ("number", value))

fn yaml_string(value: text) -> (text, (text, text)):
    """Create a YAML string value."""
    ("scalar", ("string", value))

fn yaml_sequence(items: list) -> (text, list):
    """Create a YAML sequence value."""
    ("sequence", items)

fn yaml_mapping(pairs: list) -> (text, list):
    """Create a YAML mapping value."""
    ("mapping", pairs)

# ============================================================================
# Value Type Checks
# ============================================================================

fn is_yaml_null(value: (text, any)) -> bool:
    """Check if value is a YAML null."""
    val value_type = value.0
    val value_data = value.1
    var result = false
    if value_type == "scalar":
        val scalar_type = value_data.0
        result = scalar_type == "null"
    result

fn is_yaml_boolean(value: (text, any)) -> bool:
    """Check if value is a YAML boolean."""
    val value_type = value.0
    val value_data = value.1
    var result = false
    if value_type == "scalar":
        val scalar_type = value_data.0
        result = scalar_type == "boolean"
    result

fn is_yaml_number(value: (text, any)) -> bool:
    """Check if value is a YAML number."""
    val value_type = value.0
    val value_data = value.1
    var result = false
    if value_type == "scalar":
        val scalar_type = value_data.0
        result = scalar_type == "number"
    result

fn is_yaml_string(value: (text, any)) -> bool:
    """Check if value is a YAML string."""
    val value_type = value.0
    val value_data = value.1
    var result = false
    if value_type == "scalar":
        val scalar_type = value_data.0
        result = scalar_type == "string"
    result

fn is_yaml_sequence(value: (text, any)) -> bool:
    """Check if value is a YAML sequence."""
    val value_type = value.0
    value_type == "sequence"

fn is_yaml_mapping(value: (text, any)) -> bool:
    """Check if value is a YAML mapping."""
    val value_type = value.0
    value_type == "mapping"

fn is_yaml_scalar(value: (text, any)) -> bool:
    """Check if value is a YAML scalar."""
    val value_type = value.0
    value_type == "scalar"

# ============================================================================
# Value Extraction
# ============================================================================

fn yaml_get_scalar_type(value: (text, any)) -> text:
    """Get the scalar type from a scalar value."""
    val value_data = value.1
    value_data.0

fn yaml_get_scalar_content(value: (text, any)) -> text:
    """Get the scalar content from a scalar value."""
    val value_data = value.1
    value_data.1

fn yaml_get_sequence_items(value: (text, any)) -> list:
    """Get items from a sequence value."""
    value.1

fn yaml_get_mapping_pairs(value: (text, any)) -> list:
    """Get key-value pairs from a mapping value."""
    value.1

# ============================================================================
# Mapping Operations
# ============================================================================

fn yaml_mapping_get(mapping: (text, any), key: text) -> any:
    """Get value from mapping by key. Returns nil if not found."""
    val pairs = yaml_get_mapping_pairs(mapping)
    var result = nil
    var i = 0
    var found = false
    while i < pairs.length() and not found:
        val pair = pairs.get(i)
        val pair_key = pair.0
        val pair_value = pair.1
        if pair_key == key:
            result = pair_value
            found = true
        i = i + 1
    result

fn yaml_mapping_has(mapping: (text, any), key: text) -> bool:
    """Check if mapping contains key."""
    val pairs = yaml_get_mapping_pairs(mapping)
    var found = false
    var i = 0
    while i < pairs.length() and not found:
        val pair = pairs.get(i)
        val pair_key = pair.0
        if pair_key == key:
            found = true
        i = i + 1
    found

fn yaml_mapping_set(mapping: (text, any), key: text, value: any) -> (text, list):
    """Set value in mapping. Returns new mapping."""
    val pairs = yaml_get_mapping_pairs(mapping)
    var new_pairs = []
    var found = false
    var i = 0
    while i < pairs.length():
        val pair = pairs.get(i)
        val pair_key = pair.0
        val pair_value = pair.1
        if pair_key == key:
            new_pairs = new_pairs.append((key, value))
            found = true
        else:
            new_pairs = new_pairs.append(pair)
        i = i + 1
    if not found:
        new_pairs = new_pairs.append((key, value))
    yaml_mapping(new_pairs)

fn yaml_mapping_remove(mapping: (text, any), key: text) -> (text, list):
    """Remove key from mapping. Returns new mapping."""
    val pairs = yaml_get_mapping_pairs(mapping)
    var new_pairs = []
    var i = 0
    while i < pairs.length():
        val pair = pairs.get(i)
        val pair_key = pair.0
        if pair_key != key:
            new_pairs = new_pairs.append(pair)
        i = i + 1
    yaml_mapping(new_pairs)

fn yaml_mapping_keys(mapping: (text, any)) -> list:
    """Get all keys from mapping."""
    val pairs = yaml_get_mapping_pairs(mapping)
    var keys = []
    var i = 0
    while i < pairs.length():
        val pair = pairs.get(i)
        val pair_key = pair.0
        keys = keys.append(pair_key)
        i = i + 1
    keys

fn yaml_mapping_values(mapping: (text, any)) -> list:
    """Get all values from mapping."""
    val pairs = yaml_get_mapping_pairs(mapping)
    var values = []
    var i = 0
    while i < pairs.length():
        val pair = pairs.get(i)
        val pair_value = pair.1
        values = values.append(pair_value)
        i = i + 1
    values

fn yaml_mapping_size(mapping: (text, any)) -> i64:
    """Get number of entries in mapping."""
    val pairs = yaml_get_mapping_pairs(mapping)
    pairs.length()

# ============================================================================
# Sequence Operations
# ============================================================================

fn yaml_sequence_get(sequence: (text, any), index: i64) -> any:
    """Get item from sequence by index. Returns nil if out of bounds."""
    val items = yaml_get_sequence_items(sequence)
    var result = nil
    var is_valid = index >= 0
    is_valid = is_valid and index < items.length()
    if is_valid:
        result = items.get(index)
    result

fn yaml_sequence_set(sequence: (text, any), index: i64, value: any) -> (text, list):
    """Set item in sequence. Returns new sequence."""
    val items = yaml_get_sequence_items(sequence)
    var new_items = []
    var i = 0
    while i < items.length():
        if i == index:
            new_items = new_items.append(value)
        else:
            val item = items.get(i)
            new_items = new_items.append(item)
        i = i + 1
    yaml_sequence(new_items)

fn yaml_sequence_append(sequence: (text, any), value: any) -> (text, list):
    """Append item to sequence. Returns new sequence."""
    val items = yaml_get_sequence_items(sequence)
    val new_items = items.append(value)
    yaml_sequence(new_items)

fn yaml_sequence_length(sequence: (text, any)) -> i64:
    """Get length of sequence."""
    val items = yaml_get_sequence_items(sequence)
    items.length()

fn yaml_sequence_insert(sequence: (text, any), index: i64, value: any) -> (text, list):
    """Insert item at index in sequence. Returns new sequence."""
    val items = yaml_get_sequence_items(sequence)
    var new_items = []
    var i = 0
    while i < items.length():
        if i == index:
            new_items = new_items.append(value)
        val item = items.get(i)
        new_items = new_items.append(item)
        i = i + 1
    if index >= items.length():
        new_items = new_items.append(value)
    yaml_sequence(new_items)

fn yaml_sequence_remove(sequence: (text, any), index: i64) -> (text, list):
    """Remove item at index from sequence. Returns new sequence."""
    val items = yaml_get_sequence_items(sequence)
    var new_items = []
    var i = 0
    while i < items.length():
        if i != index:
            val item = items.get(i)
            new_items = new_items.append(item)
        i = i + 1
    yaml_sequence(new_items)

# ============================================================================
# String Escaping and Unescaping
# ============================================================================

fn yaml_escape_string(str: text) -> text:
    """Escape special characters in a string for YAML."""
    var result = ""
    var i = 0
    while i < str.length():
        val ch = str.substring(i, i + 1)
        if ch == "\\":
            result = result + "\\\\"
        else if ch == "\"":
            result = result + "\\\""
        else if ch == "\n":
            result = result + "\\n"
        else if ch == "\r":
            result = result + "\\r"
        else if ch == "\t":
            result = result + "\\t"
        else:
            result = result + ch
        i = i + 1
    result

fn yaml_unescape_string(str: text) -> text:
    """Unescape YAML escape sequences in a string."""
    var result = ""
    var i = 0
    while i < str.length():
        val ch = str.substring(i, i + 1)
        if ch == "\\":
            var next_i = i + 1
            var has_next = next_i < str.length()
            if has_next:
                val next_ch = str.substring(next_i, next_i + 1)
                if next_ch == "\\":
                    result = result + "\\"
                    i = i + 1
                else if next_ch == "\"":
                    result = result + "\""
                    i = i + 1
                else if next_ch == "n":
                    result = result + "\n"
                    i = i + 1
                else if next_ch == "r":
                    result = result + "\r"
                    i = i + 1
                else if next_ch == "t":
                    result = result + "\t"
                    i = i + 1
                else:
                    result = result + ch
            else:
                result = result + ch
        else:
            result = result + ch
        i = i + 1
    result

fn yaml_needs_quotes(str: text) -> bool:
    """Check if a string needs quotes in YAML."""
    var needs = false
    var temp_str = str.trim()
    if temp_str.length() == 0:
        needs = true
    if not needs:
        val first_ch = temp_str.substring(0, 1)
        var is_special_first = first_ch == "-"
        is_special_first = is_special_first or first_ch == "?"
        is_special_first = is_special_first or first_ch == ":"
        is_special_first = is_special_first or first_ch == "["
        is_special_first = is_special_first or first_ch == "]"
        is_special_first = is_special_first or first_ch == "{"
        is_special_first = is_special_first or first_ch == "}"
        is_special_first = is_special_first or first_ch == "#"
        is_special_first = is_special_first or first_ch == "&"
        is_special_first = is_special_first or first_ch == "*"
        is_special_first = is_special_first or first_ch == "!"
        is_special_first = is_special_first or first_ch == "|"
        is_special_first = is_special_first or first_ch == ">"
        is_special_first = is_special_first or first_ch == "'"
        is_special_first = is_special_first or first_ch == "\""
        if is_special_first:
            needs = true
    if not needs:
        var has_special = str.contains(":")
        has_special = has_special or str.contains("#")
        has_special = has_special or str.contains("\n")
        has_special = has_special or str.contains("\r")
        if has_special:
            needs = true
    needs

fn yaml_quote_string(str: text, style: text) -> text:
    """Quote a string in YAML with given style: 'single', 'double', or 'plain'."""
    var result = str
    if style == "single":
        result = "'" + str.replace("'", "''") + "'"
    else if style == "double":
        val escaped = yaml_escape_string(str)
        result = "\"" + escaped + "\""
    result

# ============================================================================
# Indentation Utilities
# ============================================================================

fn yaml_detect_indentation(yaml_text: text) -> i64:
    """Detect indentation level from YAML text."""
    var indent = 2
    val lines = yaml_text.split("\n")
    var i = 0
    var found = false
    while i < lines.length() and not found:
        val line = lines.get(i)
        val trimmed = line.trim_start()
        var line_has_content = trimmed.length() > 0
        val first_ch = line.substring(0, 1)
        line_has_content = line_has_content and first_ch == " "
        if line_has_content:
            var spaces = 0
            var j = 0
            var counting = true
            while j < line.length() and counting:
                val ch = line.substring(j, j + 1)
                if ch == " ":
                    spaces = spaces + 1
                else:
                    counting = false
                j = j + 1
            if spaces > 0:
                indent = spaces
                found = true
        i = i + 1
    indent

fn yaml_indent(text: text, level: i64, indent_size: i64) -> text:
    """Add indentation to text."""
    val spaces_count = level * indent_size
    var spaces = ""
    var i = 0
    while i < spaces_count:
        spaces = spaces + " "
        i = i + 1
    spaces + text

fn yaml_validate_indentation(yaml_text: text) -> bool:
    """Validate indentation structure of YAML text."""
    var valid = true
    val lines = yaml_text.split("\n")
    var prev_indent = 0
    var i = 0
    while i < lines.length() and valid:
        val line = lines.get(i)
        val trimmed = line.trim_start()
        val has_content = trimmed.length() > 0
        if has_content:
            var spaces = 0
            var j = 0
            var counting = true
            while j < line.length() and counting:
                val ch = line.substring(j, j + 1)
                if ch == " ":
                    spaces = spaces + 1
                else:
                    counting = false
                j = j + 1
            var indent_diff = spaces - prev_indent
            if indent_diff < 0:
                indent_diff = 0 - indent_diff
            var is_reasonable = indent_diff == 0
            is_reasonable = is_reasonable or indent_diff == 2
            is_reasonable = is_reasonable or indent_diff == 4
            if not is_reasonable:
                valid = false
            prev_indent = spaces
        i = i + 1
    valid

# ============================================================================
# Scalar Parsing
# ============================================================================

fn yaml_parse_scalar(value: text) -> (text, (text, text)):
    """Parse a scalar value from text."""
    val trimmed = value.trim()
    var result = yaml_string(trimmed)
    var is_null = trimmed == "null"
    is_null = is_null or trimmed == "~"
    is_null = is_null or trimmed == ""
    if is_null:
        result = yaml_null()
    var is_true = trimmed == "true"
    is_true = is_true or trimmed == "True"
    is_true = is_true or trimmed == "TRUE"
    is_true = is_true or trimmed == "yes"
    is_true = is_true or trimmed == "Yes"
    is_true = is_true or trimmed == "YES"
    var is_false = trimmed == "false"
    is_false = is_false or trimmed == "False"
    is_false = is_false or trimmed == "FALSE"
    is_false = is_false or trimmed == "no"
    is_false = is_false or trimmed == "No"
    is_false = is_false or trimmed == "NO"
    if is_true:
        result = yaml_boolean(true)
    if is_false:
        result = yaml_boolean(false)
    var looks_like_number = false
    var has_digit = false
    var j = 0
    while j < trimmed.length():
        val ch = trimmed.substring(j, j + 1)
        var is_num_char = ch >= "0"
        is_num_char = is_num_char and ch <= "9"
        var is_sign = ch == "-"
        is_sign = is_sign or ch == "+"
        var is_dot = ch == "."
        var is_valid_num_char = is_num_char
        is_valid_num_char = is_valid_num_char or is_sign
        is_valid_num_char = is_valid_num_char or is_dot
        if is_num_char:
            has_digit = true
        if not is_valid_num_char:
            looks_like_number = false
            j = trimmed.length()
        else:
            looks_like_number = true
        j = j + 1
    looks_like_number = looks_like_number and has_digit
    if looks_like_number:
        result = yaml_number(trimmed)
    if trimmed.starts_with("\"") and trimmed.ends_with("\""):
        val unquoted = trimmed.substring(1, trimmed.length() - 1)
        val unescaped = yaml_unescape_string(unquoted)
        result = yaml_string(unescaped)
    if trimmed.starts_with("'") and trimmed.ends_with("'"):
        val unquoted = trimmed.substring(1, trimmed.length() - 1)
        val cleaned = unquoted.replace("''", "'")
        result = yaml_string(cleaned)
    result

fn yaml_parse_type_tag(tag: text) -> text:
    """Parse YAML type tag and return the type."""
    var result = "string"
    if tag == "!!str":
        result = "string"
    else if tag == "!!int":
        result = "number"
    else if tag == "!!float":
        result = "number"
    else if tag == "!!bool":
        result = "boolean"
    else if tag == "!!null":
        result = "null"
    result

# ============================================================================
# Flow Style Parsing
# ============================================================================

fn yaml_parse_flow_sequence(text: text) -> (text, list):
    """Parse flow sequence [item1, item2, ...]."""
    var items = []
    val content_start = text.index_of("[")
    val content_end = text.last_index_of("]")
    var has_brackets = content_start >= 0
    has_brackets = has_brackets and content_end >= 0
    if has_brackets:
        val start_idx = content_start + 1
        val content = text.substring(start_idx, content_end)
        val parts = content.split(",")
        var i = 0
        while i < parts.length():
            val part = parts.get(i)
            val trimmed = part.trim()
            if trimmed.length() > 0:
                val item = yaml_parse_scalar(trimmed)
                items = items.append(item)
            i = i + 1
    yaml_sequence(items)

fn yaml_parse_flow_mapping(text: text) -> (text, list):
    """Parse flow mapping {key1: value1, key2: value2, ...}."""
    var pairs = []
    val content_start = text.index_of("{")
    val content_end = text.last_index_of("}")
    var has_braces = content_start >= 0
    has_braces = has_braces and content_end >= 0
    if has_braces:
        val start_idx = content_start + 1
        val content = text.substring(start_idx, content_end)
        val parts = content.split(",")
        var i = 0
        while i < parts.length():
            val part = parts.get(i)
            val colon_idx = part.index_of(":")
            if colon_idx >= 0:
                val key = part.substring(0, colon_idx)
                val key_trimmed = key.trim()
                val value_start = colon_idx + 1
                val value = part.substring(value_start, part.length())
                val value_trimmed = value.trim()
                val value_obj = yaml_parse_scalar(value_trimmed)
                pairs = pairs.append((key_trimmed, value_obj))
            i = i + 1
    yaml_mapping(pairs)

# ============================================================================
# Block Style Parsing
# ============================================================================

fn yaml_parse_block_lines(lines: list, start_idx: i64) -> ((text, any), i64):
    """Parse block style YAML from lines starting at start_idx. Returns (value, next_idx)."""
    var result = yaml_null()
    var next_idx = start_idx + 1
    if start_idx >= lines.length():
        return (result, next_idx)
    val line = lines.get(start_idx)
    val trimmed = line.trim()
    if trimmed.length() == 0:
        return (result, next_idx)
    if trimmed.starts_with("#"):
        return (result, next_idx)
    var base_indent = 0
    var j = 0
    var counting = true
    while j < line.length() and counting:
        val ch = line.substring(j, j + 1)
        if ch == " ":
            base_indent = base_indent + 1
        else:
            counting = false
        j = j + 1
    if trimmed.starts_with("-"):
        var items = []
        var current_idx = start_idx
        var parsing = true
        while current_idx < lines.length() and parsing:
            val seq_line = lines.get(current_idx)
            val seq_trimmed = seq_line.trim()
            var seq_indent = 0
            var k = 0
            var seq_counting = true
            while k < seq_line.length() and seq_counting:
                val ch = seq_line.substring(k, k + 1)
                if ch == " ":
                    seq_indent = seq_indent + 1
                else:
                    seq_counting = false
                k = k + 1
            var is_same_level = seq_indent == base_indent
            is_same_level = is_same_level and seq_trimmed.starts_with("-")
            if is_same_level:
                val item_content = seq_trimmed.substring(1, seq_trimmed.length())
                val item_trimmed = item_content.trim()
                val item = yaml_parse_scalar(item_trimmed)
                items = items.append(item)
                current_idx = current_idx + 1
            else if seq_indent > base_indent:
                current_idx = current_idx + 1
            else:
                parsing = false
        result = yaml_sequence(items)
        next_idx = current_idx
    val colon_idx = trimmed.index_of(":")
    if colon_idx >= 0:
        var pairs = []
        var current_idx = start_idx
        var parsing = true
        while current_idx < lines.length() and parsing:
            val map_line = lines.get(current_idx)
            val map_trimmed = map_line.trim()
            var map_indent = 0
            var k = 0
            var map_counting = true
            while k < map_line.length() and map_counting:
                val ch = map_line.substring(k, k + 1)
                if ch == " ":
                    map_indent = map_indent + 1
                else:
                    map_counting = false
                k = k + 1
            val map_colon = map_trimmed.index_of(":")
            var is_same_level = map_indent == base_indent
            is_same_level = is_same_level and map_colon >= 0
            if is_same_level:
                val key = map_trimmed.substring(0, map_colon)
                val key_trimmed = key.trim()
                val value_start = map_colon + 1
                val value = map_trimmed.substring(value_start, map_trimmed.length())
                val value_trimmed = value.trim()
                val value_obj = yaml_parse_scalar(value_trimmed)
                pairs = pairs.append((key_trimmed, value_obj))
                current_idx = current_idx + 1
            else if map_indent > base_indent:
                current_idx = current_idx + 1
            else:
                parsing = false
        result = yaml_mapping(pairs)
        next_idx = current_idx
    (result, next_idx)

fn yaml_parse_block(yaml_text: text) -> (text, any):
    """Parse block style YAML text."""
    val lines = yaml_text.split("\n")
    val parse_result = yaml_parse_block_lines(lines, 0)
    parse_result.0

# ============================================================================
# Main Parser
# ============================================================================

fn yaml_parse(yaml_text: text) -> (text, any):
    """Parse YAML text into a value structure."""
    val trimmed = yaml_text.trim()
    var result = yaml_null()
    if trimmed.starts_with("["):
        result = yaml_parse_flow_sequence(trimmed)
    if trimmed.starts_with("{"):
        result = yaml_parse_flow_mapping(trimmed)
    var has_newline = trimmed.contains("\n")
    if not trimmed.starts_with("[") and not trimmed.starts_with("{"):
        if has_newline:
            result = yaml_parse_block(trimmed)
        else:
            result = yaml_parse_scalar(trimmed)
    result

# ============================================================================
# Serialization
# ============================================================================

fn yaml_serialize_scalar(value: (text, any), indent_level: i64, indent_size: i64) -> text:
    """Serialize a scalar value to YAML."""
    val scalar_data = value.1
    val scalar_type = scalar_data.0
    val scalar_content = scalar_data.1
    var result = scalar_content
    if scalar_type == "string":
        if yaml_needs_quotes(scalar_content):
            result = yaml_quote_string(scalar_content, "double")
        else:
            result = scalar_content
    result

fn yaml_serialize_sequence_block(value: (text, any), indent_level: i64, indent_size: i64) -> text:
    """Serialize a sequence value to YAML in block style."""
    val items = yaml_get_sequence_items(value)
    var result = ""
    var i = 0
    while i < items.length():
        val item = items.get(i)
        val item_type = item.0
        var item_text = ""
        if item_type == "scalar":
            item_text = yaml_serialize_scalar(item, indent_level, indent_size)
        else if item_type == "sequence":
            item_text = yaml_serialize_sequence_block(item, indent_level + 1, indent_size)
        else if item_type == "mapping":
            item_text = yaml_serialize_mapping_block(item, indent_level + 1, indent_size)
        val indented = yaml_indent("- " + item_text, indent_level, indent_size)
        if i > 0:
            result = result + "\n"
        result = result + indented
        i = i + 1
    result

fn yaml_serialize_mapping_block(value: (text, any), indent_level: i64, indent_size: i64) -> text:
    """Serialize a mapping value to YAML in block style."""
    val pairs = yaml_get_mapping_pairs(value)
    var result = ""
    var i = 0
    while i < pairs.length():
        val pair = pairs.get(i)
        val key = pair.0
        val val_obj = pair.1
        val val_type = val_obj.0
        var val_text = ""
        if val_type == "scalar":
            val_text = yaml_serialize_scalar(val_obj, indent_level, indent_size)
        else if val_type == "sequence":
            val_text = "\n" + yaml_serialize_sequence_block(val_obj, indent_level + 1, indent_size)
        else if val_type == "mapping":
            val_text = "\n" + yaml_serialize_mapping_block(val_obj, indent_level + 1, indent_size)
        val line = key + ": " + val_text
        val indented = yaml_indent(line, indent_level, indent_size)
        if i > 0:
            result = result + "\n"
        result = result + indented
        i = i + 1
    result

fn yaml_serialize_flow_sequence(value: (text, any)) -> text:
    """Serialize a sequence value to YAML in flow style."""
    val items = yaml_get_sequence_items(value)
    var result = "["
    var i = 0
    while i < items.length():
        val item = items.get(i)
        val item_type = item.0
        var item_text = ""
        if item_type == "scalar":
            item_text = yaml_serialize_scalar(item, 0, 0)
        else if item_type == "sequence":
            item_text = yaml_serialize_flow_sequence(item)
        else if item_type == "mapping":
            item_text = yaml_serialize_flow_mapping(item)
        if i > 0:
            result = result + ", "
        result = result + item_text
        i = i + 1
    result = result + "]"
    result

fn yaml_serialize_flow_mapping(value: (text, any)) -> text:
    """Serialize a mapping value to YAML in flow style."""
    val pairs = yaml_get_mapping_pairs(value)
    var result = "{"
    var i = 0
    while i < pairs.length():
        val pair = pairs.get(i)
        val key = pair.0
        val val_obj = pair.1
        val val_type = val_obj.0
        var val_text = ""
        if val_type == "scalar":
            val_text = yaml_serialize_scalar(val_obj, 0, 0)
        else if val_type == "sequence":
            val_text = yaml_serialize_flow_sequence(val_obj)
        else if val_type == "mapping":
            val_text = yaml_serialize_flow_mapping(val_obj)
        if i > 0:
            result = result + ", "
        result = result + key + ": " + val_text
        i = i + 1
    result = result + "}"
    result

fn yaml_serialize(value: (text, any), style: text) -> text:
    """Serialize a YAML value to text. Style can be 'block' or 'flow'."""
    val value_type = value.0
    var result = ""
    if style == "flow":
        if value_type == "scalar":
            result = yaml_serialize_scalar(value, 0, 0)
        else if value_type == "sequence":
            result = yaml_serialize_flow_sequence(value)
        else if value_type == "mapping":
            result = yaml_serialize_flow_mapping(value)
    else:
        if value_type == "scalar":
            result = yaml_serialize_scalar(value, 0, 2)
        else if value_type == "sequence":
            result = yaml_serialize_sequence_block(value, 0, 2)
        else if value_type == "mapping":
            result = yaml_serialize_mapping_block(value, 0, 2)
    result

fn yaml_serialize_block(value: (text, any)) -> text:
    """Serialize a YAML value to block style."""
    yaml_serialize(value, "block")

fn yaml_serialize_flow(value: (text, any)) -> text:
    """Serialize a YAML value to flow style."""
    yaml_serialize(value, "flow")

# ============================================================================
# Multi-Document Support
# ============================================================================

fn yaml_parse_documents(yaml_text: text) -> list:
    """Parse multiple YAML documents separated by ---."""
    var documents = []
    val parts = yaml_text.split("---")
    var i = 0
    while i < parts.length():
        val part = parts.get(i)
        val trimmed = part.trim()
        if trimmed.length() > 0:
            val doc = yaml_parse(trimmed)
            documents = documents.append(doc)
        i = i + 1
    documents

fn yaml_serialize_documents(documents: list, style: text) -> text:
    """Serialize multiple YAML documents with --- separators."""
    var result = ""
    var i = 0
    while i < documents.length():
        val doc = documents.get(i)
        val serialized = yaml_serialize(doc, style)
        if i > 0:
            result = result + "\n---\n"
        result = result + serialized
        i = i + 1
    result

# ============================================================================
# Anchor and Alias Support (Basic)
# ============================================================================

fn yaml_create_anchor(name: text, value: (text, any)) -> (text, (text, (text, any))):
    """Create an anchor with a name and value."""
    ("anchor", (name, value))

fn yaml_create_alias(name: text) -> (text, text):
    """Create an alias reference to an anchor."""
    ("alias", name)

fn yaml_is_anchor(value: (text, any)) -> bool:
    """Check if value is an anchor."""
    val value_type = value.0
    value_type == "anchor"

fn yaml_is_alias(value: (text, any)) -> bool:
    """Check if value is an alias."""
    val value_type = value.0
    value_type == "alias"

fn yaml_get_anchor_name(anchor: (text, any)) -> text:
    """Get the name from an anchor."""
    val anchor_data = anchor.1
    anchor_data.0

fn yaml_get_anchor_value(anchor: (text, any)) -> (text, any):
    """Get the value from an anchor."""
    val anchor_data = anchor.1
    anchor_data.1

fn yaml_get_alias_name(alias: (text, any)) -> text:
    """Get the reference name from an alias."""
    alias.1

fn yaml_resolve_aliases(value: (text, any), anchors: list) -> (text, any):
    """Resolve aliases in a YAML value using provided anchors."""
    var result = value
    val value_type = value.0
    if value_type == "alias":
        val alias_name = yaml_get_alias_name(value)
        var i = 0
        var found = false
        while i < anchors.length() and not found:
            val anchor = anchors.get(i)
            val anchor_name = yaml_get_anchor_name(anchor)
            if anchor_name == alias_name:
                result = yaml_get_anchor_value(anchor)
                found = true
            i = i + 1
    result

# ============================================================================
# Utility Functions
# ============================================================================

fn yaml_pretty_print(value: (text, any)) -> text:
    """Pretty print a YAML value in block style."""
    yaml_serialize_block(value)

fn yaml_compact_print(value: (text, any)) -> text:
    """Compact print a YAML value in flow style."""
    yaml_serialize_flow(value)

fn yaml_deep_copy(value: (text, any)) -> (text, any):
    """Create a deep copy of a YAML value."""
    val serialized = yaml_serialize_block(value)
    yaml_parse(serialized)

fn yaml_merge_mappings(m1: (text, any), m2: (text, any)) -> (text, list):
    """Merge two mappings. Values from m2 override m1."""
    val pairs1 = yaml_get_mapping_pairs(m1)
    val pairs2 = yaml_get_mapping_pairs(m2)
    var result_pairs = pairs1
    var i = 0
    while i < pairs2.length():
        val pair = pairs2.get(i)
        val key = pair.0
        val value = pair.1
        var temp = yaml_mapping(result_pairs)
        temp = yaml_mapping_set(temp, key, value)
        result_pairs = yaml_get_mapping_pairs(temp)
        i = i + 1
    yaml_mapping(result_pairs)

fn yaml_equals(v1: (text, any), v2: (text, any)) -> bool:
    """Check if two YAML values are equal."""
    val s1 = yaml_serialize_flow(v1)
    val s2 = yaml_serialize_flow(v2)
    s1 == s2

fn yaml_to_string(value: (text, any)) -> text:
    """Convert YAML value to string representation."""
    yaml_serialize_block(value)

fn yaml_from_string(str: text) -> (text, any):
    """Parse YAML from string."""
    yaml_parse(str)

# ============================================================================
# Advanced Utility Functions
# ============================================================================

fn yaml_mapping_contains_value(mapping: (text, any), value: (text, any)) -> bool:
    """Check if mapping contains a specific value."""
    val values = yaml_mapping_values(mapping)
    var found = false
    var i = 0
    while i < values.length() and not found:
        val v = values.get(i)
        if yaml_equals(v, value):
            found = true
        i = i + 1
    found

fn yaml_sequence_contains(sequence: (text, any), value: (text, any)) -> bool:
    """Check if sequence contains a specific value."""
    val items = yaml_get_sequence_items(sequence)
    var found = false
    var i = 0
    while i < items.length() and not found:
        val item = items.get(i)
        if yaml_equals(item, value):
            found = true
        i = i + 1
    found

fn yaml_sequence_index_of(sequence: (text, any), value: (text, any)) -> i64:
    """Get index of value in sequence. Returns -1 if not found."""
    val items = yaml_get_sequence_items(sequence)
    var result = -1
    var i = 0
    var found = false
    while i < items.length() and not found:
        val item = items.get(i)
        if yaml_equals(item, value):
            result = i
            found = true
        i = i + 1
    result

fn yaml_sequence_reverse(sequence: (text, any)) -> (text, list):
    """Reverse the order of items in a sequence."""
    val items = yaml_get_sequence_items(sequence)
    var new_items = []
    var i = items.length() - 1
    while i >= 0:
        val item = items.get(i)
        new_items = new_items.append(item)
        i = i - 1
    yaml_sequence(new_items)

fn yaml_sequence_slice(sequence: (text, any), start: i64, end: i64) -> (text, list):
    """Get a slice of a sequence from start to end (exclusive)."""
    val items = yaml_get_sequence_items(sequence)
    var new_items = []
    var i = start
    while i < end and i < items.length():
        if i >= 0:
            val item = items.get(i)
            new_items = new_items.append(item)
        i = i + 1
    yaml_sequence(new_items)

fn yaml_mapping_filter_keys(mapping: (text, any), keys: list) -> (text, list):
    """Filter mapping to only include specified keys."""
    val pairs = yaml_get_mapping_pairs(mapping)
    var new_pairs = []
    var i = 0
    while i < pairs.length():
        val pair = pairs.get(i)
        val key = pair.0
        var should_include = false
        var j = 0
        while j < keys.length():
            val filter_key = keys.get(j)
            if key == filter_key:
                should_include = true
            j = j + 1
        if should_include:
            new_pairs = new_pairs.append(pair)
        i = i + 1
    yaml_mapping(new_pairs)

fn yaml_mapping_exclude_keys(mapping: (text, any), keys: list) -> (text, list):
    """Filter mapping to exclude specified keys."""
    val pairs = yaml_get_mapping_pairs(mapping)
    var new_pairs = []
    var i = 0
    while i < pairs.length():
        val pair = pairs.get(i)
        val key = pair.0
        var should_exclude = false
        var j = 0
        while j < keys.length():
            val filter_key = keys.get(j)
            if key == filter_key:
                should_exclude = true
            j = j + 1
        if not should_exclude:
            new_pairs = new_pairs.append(pair)
        i = i + 1
    yaml_mapping(new_pairs)

fn yaml_is_empty(value: (text, any)) -> bool:
    """Check if a YAML value is empty (null, empty sequence, or empty mapping)."""
    val value_type = value.0
    var is_empty = false
    if value_type == "scalar":
        is_empty = is_yaml_null(value)
    else if value_type == "sequence":
        val items = yaml_get_sequence_items(value)
        is_empty = items.length() == 0
    else if value_type == "mapping":
        val pairs = yaml_get_mapping_pairs(value)
        is_empty = pairs.length() == 0
    is_empty

fn yaml_get_nested(value: (text, any), path: list) -> any:
    """Get nested value using a path list. Returns nil if not found."""
    var current = value
    var i = 0
    var found = true
    while i < path.length() and found:
        val key = path.get(i)
        val current_type = current.0
        if current_type == "mapping":
            val next_val = yaml_mapping_get(current, key)
            if next_val == nil:
                found = false
                current = yaml_null()
            else:
                current = next_val
        else:
            found = false
            current = yaml_null()
        i = i + 1
    if found:
        current
    else:
        nil

fn yaml_set_nested(value: (text, any), path: list, new_value: (text, any)) -> (text, any):
    """Set nested value using a path list. Creates intermediate mappings as needed."""
    var result = value
    if path.length() == 0:
        return new_value
    if path.length() == 1:
        val key = path.get(0)
        if is_yaml_mapping(value):
            result = yaml_mapping_set(value, key, new_value)
        return result
    val first_key = path.get(0)
    var rest_path = []
    var i = 1
    while i < path.length():
        val p = path.get(i)
        rest_path = rest_path.append(p)
        i = i + 1
    var nested = yaml_mapping_get(value, first_key)
    if nested == nil:
        nested = yaml_mapping([])
    val updated_nested = yaml_set_nested(nested, rest_path, new_value)
    result = yaml_mapping_set(value, first_key, updated_nested)
    result

fn yaml_count_nodes(value: (text, any)) -> i64:
    """Count total number of nodes in a YAML structure."""
    val value_type = value.0
    var count = 1
    if value_type == "sequence":
        val items = yaml_get_sequence_items(value)
        var i = 0
        while i < items.length():
            val item = items.get(i)
            count = count + yaml_count_nodes(item)
            i = i + 1
    else if value_type == "mapping":
        val pairs = yaml_get_mapping_pairs(value)
        var i = 0
        while i < pairs.length():
            val pair = pairs.get(i)
            val v = pair.1
            count = count + yaml_count_nodes(v)
            i = i + 1
    count

fn yaml_depth(value: (text, any)) -> i64:
    """Calculate maximum depth of a YAML structure."""
    val value_type = value.0
    var max_depth = 1
    if value_type == "sequence":
        val items = yaml_get_sequence_items(value)
        var i = 0
        while i < items.length():
            val item = items.get(i)
            val item_depth = yaml_depth(item)
            if item_depth > max_depth:
                max_depth = item_depth
            i = i + 1
        max_depth = max_depth + 1
    else if value_type == "mapping":
        val pairs = yaml_get_mapping_pairs(value)
        var i = 0
        while i < pairs.length():
            val pair = pairs.get(i)
            val v = pair.1
            val v_depth = yaml_depth(v)
            if v_depth > max_depth:
                max_depth = v_depth
            i = i + 1
        max_depth = max_depth + 1
    max_depth

fn yaml_flatten_mapping(mapping: (text, any), prefix: text, separator: text) -> (text, list):
    """Flatten nested mapping into single-level mapping with dotted keys."""
    var result_pairs = []
    val pairs = yaml_get_mapping_pairs(mapping)
    var i = 0
    while i < pairs.length():
        val pair = pairs.get(i)
        val key = pair.0
        val value = pair.1
        val full_key = if prefix == "": key else: prefix + separator + key
        val value_type = value.0
        if value_type == "mapping":
            val nested_flat = yaml_flatten_mapping(value, full_key, separator)
            val nested_pairs = yaml_get_mapping_pairs(nested_flat)
            var j = 0
            while j < nested_pairs.length():
                val nested_pair = nested_pairs.get(j)
                result_pairs = result_pairs.append(nested_pair)
                j = j + 1
        else:
            result_pairs = result_pairs.append((full_key, value))
        i = i + 1
    yaml_mapping(result_pairs)

fn yaml_validate_schema(value: (text, any), schema_type: text) -> bool:
    """Basic schema validation. Types: 'mapping', 'sequence', 'string', 'number', 'boolean', 'null'."""
    val value_type = value.0
    var valid = false
    if schema_type == "mapping":
        valid = is_yaml_mapping(value)
    else if schema_type == "sequence":
        valid = is_yaml_sequence(value)
    else if schema_type == "string":
        valid = is_yaml_string(value)
    else if schema_type == "number":
        valid = is_yaml_number(value)
    else if schema_type == "boolean":
        valid = is_yaml_boolean(value)
    else if schema_type == "null":
        valid = is_yaml_null(value)
    valid

# ============================================================================
# End of Module
# ============================================================================

