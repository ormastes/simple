# Numeric Utilities
#
# Additional numeric helper functions beyond math.spl.
# Pure Simple implementation - no external dependencies.
#
# Functions:
# - is_even / is_odd: Check parity
# - is_power_of_two: Check if power of 2
# - next_power_of_two: Find next power of 2
# - digit_count: Count digits in number
# - digit_sum: Sum of digits
# - reverse_digits: Reverse digits of number
# - is_palindrome: Check if digits form palindrome
# - gcd / lcm: Already in math.spl, but helpers here
# - is_prime_simple: Simple primality test
# - factors: Find all factors
# - divisors_count: Count divisors

# ============================================================================
# Parity Checks
# ============================================================================

fn is_even(n: i64) -> bool:
    """Check if number is even."""
    n % 2 == 0

fn is_odd(n: i64) -> bool:
    """Check if number is odd."""
    n % 2 != 0

# ============================================================================
# Power of Two
# ============================================================================

fn is_power_of_two(n: i64) -> bool:
    """Check if number is a power of 2.

    Uses bit manipulation: power of 2 has exactly one bit set.
    n & (n-1) == 0 for powers of 2 (but this needs bitwise ops).

    For now, use division approach.
    """
    if n <= 0:
        return false

    var x = n
    while x > 1:
        if x % 2 != 0:
            return false
        x = x / 2

    true

fn next_power_of_two(n: i64) -> i64:
    """Find the next power of 2 >= n.

    Examples:
        next_power_of_two(5) = 8
        next_power_of_two(16) = 16
        next_power_of_two(17) = 32
    """
    if n <= 1:
        return 1

    var power = 1
    while power < n:
        power = power * 2

    power

fn previous_power_of_two(n: i64) -> i64:
    """Find the largest power of 2 <= n."""
    if n < 1:
        return 0

    var power = 1
    while power * 2 <= n:
        power = power * 2

    power

# ============================================================================
# Digit Operations
# ============================================================================

fn digit_count(n: i64) -> i64:
    """Count the number of digits in a number.

    Negative numbers count the minus sign as not a digit.
    digit_count(-123) = 3
    """
    if n == 0:
        return 1

    var x = n
    if x < 0:
        x = -x

    var count = 0
    while x > 0:
        count = count + 1
        x = x / 10

    count

fn digit_sum(n: i64) -> i64:
    """Sum of all digits in number.

    For negative numbers, uses absolute value.
    digit_sum(-123) = 6
    """
    var x = n
    if x < 0:
        x = -x

    var sum = 0
    while x > 0:
        sum = sum + (x % 10)
        x = x / 10

    sum

fn reverse_digits(n: i64) -> i64:
    """Reverse the digits of a number.

    Examples:
        reverse_digits(123) = 321
        reverse_digits(-456) = -654
    """
    val is_negative = n < 0
    var x = if is_negative: -n else: n

    var result = 0
    while x > 0:
        result = result * 10 + (x % 10)
        x = x / 10

    if is_negative:
        -result
    else:
        result

fn is_palindrome(n: i64) -> bool:
    """Check if number's digits form a palindrome.

    Uses absolute value for negative numbers.
    """
    var x = n
    if x < 0:
        x = -x

    x == reverse_digits(x)

# ============================================================================
# Divisibility and Factors
# ============================================================================

fn is_divisible(n: i64, divisor: i64) -> bool:
    """Check if n is divisible by divisor."""
    if divisor == 0:
        return false

    n % divisor == 0

fn gcd_simple(a: i64, b: i64) -> i64:
    """Greatest common divisor using Euclidean algorithm.

    Note: math.spl has math_gcd, this is a duplicate for convenience.
    """
    var x = a
    var y = b

    if x < 0:
        x = -x
    if y < 0:
        y = -y

    while y != 0:
        val temp = y
        y = x % y
        x = temp

    x

fn lcm_simple(a: i64, b: i64) -> i64:
    """Least common multiple.

    Note: math.spl has math_lcm, this is a duplicate for convenience.
    """
    if a == 0 or b == 0:
        return 0

    val g = gcd_simple(a, b)
    (a / g) * b

fn factors(n: i64) -> [i64]:
    """Find all positive factors of n.

    Returns sorted array of factors.
    factors(12) = [1, 2, 3, 4, 6, 12]
    """
    if n <= 0:
        return []

    var result = []
    var i = 1
    while i * i <= n:
        if n % i == 0:
            result.push(i)
            val other = n / i
            if other != i:
                result.push(other)
        i = i + 1

    # Sort (simple bubble sort for small arrays)
    var len = result.len()
    var swapped = true
    while swapped:
        swapped = false
        var j = 0
        while j < len - 1:
            if result[j] > result[j + 1]:
                val temp = result[j]
                result[j] = result[j + 1]
                result[j + 1] = temp
                swapped = true
            j = j + 1

    result

fn divisors_count(n: i64) -> i64:
    """Count the number of positive divisors of n."""
    if n <= 0:
        return 0

    var count = 0
    var i = 1
    while i * i <= n:
        if n % i == 0:
            count = count + 1
            if i != n / i:
                count = count + 1
        i = i + 1

    count

# ============================================================================
# Primality Testing
# ============================================================================

fn is_prime_simple(n: i64) -> bool:
    """Simple primality test using trial division.

    Checks divisibility up to sqrt(n).
    Suitable for small numbers; not optimized for large primes.
    """
    if n <= 1:
        return false
    if n == 2:
        return true
    if n % 2 == 0:
        return false

    var i = 3
    while i * i <= n:
        if n % i == 0:
            return false
        i = i + 2

    true

# ============================================================================
# Number Properties
# ============================================================================

fn is_perfect_square(n: i64) -> bool:
    """Check if number is a perfect square."""
    if n < 0:
        return false

    val root = isqrt(n)
    root * root == n

fn isqrt(n: i64) -> i64:
    """Integer square root using Newton's method.

    Returns floor(sqrt(n)).
    """
    if n < 0:
        return 0
    if n == 0:
        return 0
    if n == 1:
        return 1

    # Newton's method: x_new = (x + n/x) / 2
    var x = n / 2
    var prev = 0

    while x != prev:
        prev = x
        x = (x + n / x) / 2

    x

fn is_perfect_number(n: i64) -> bool:
    """Check if number equals sum of its proper divisors.

    A perfect number is a positive integer that equals the sum of
    its proper positive divisors (excluding itself).
    Examples: 6 = 1+2+3, 28 = 1+2+4+7+14
    """
    if n <= 1:
        return false

    var sum = 1  # 1 is always a proper divisor
    var i = 2
    while i * i <= n:
        if n % i == 0:
            sum = sum + i
            if i != n / i and i * i != n:
                sum = sum + (n / i)
        i = i + 1

    sum == n

# ============================================================================
# Range Operations
# ============================================================================

fn sum_range(start: i64, end: i64) -> i64:
    """Sum of integers from start to end-1.

    sum_range(1, 5) = 1+2+3+4 = 10
    """
    if start >= end:
        return 0

    # Use formula: n*(n+1)/2 for 1..n
    # For start..end: sum(1..end-1) - sum(1..start-1)
    val n1 = end - 1
    val n2 = start - 1

    val sum1 = n1 * (n1 + 1) / 2
    val sum2 = n2 * (n2 + 1) / 2

    sum1 - sum2

fn product_range(start: i64, end: i64) -> i64:
    """Product of integers from start to end-1.

    product_range(2, 5) = 2*3*4 = 24
    """
    if start >= end:
        return 1

    var product = 1
    var i = start
    while i < end:
        product = product * i
        i = i + 1

    product

# ============================================================================
# Integer Conversion
# ============================================================================

fn to_binary_string(n: i64) -> text:
    """Convert integer to binary string representation.

    to_binary_string(5) = "101"
    to_binary_string(0) = "0"
    """
    if n == 0:
        return "0"

    var x = n
    if x < 0:
        x = -x

    var result = ""
    while x > 0:
        val bit = x % 2
        result = (if bit == 0: "0" else: "1") + result
        x = x / 2

    if n < 0:
        "-" + result
    else:
        result

fn from_binary_string(s: text) -> i64?:
    """Parse binary string to integer.

    from_binary_string("101") = Some(5)
    from_binary_string("invalid") = nil
    """
    if s.len() == 0:
        return nil

    var start_pos = 0
    var is_negative = false

    if s[0..1] == "-":
        is_negative = true
        start_pos = 1

    var result = 0
    var i = start_pos
    while i < s.len():
        val ch = s[i..i+1]
        if ch == "0":
            result = result * 2
        elif ch == "1":
            result = result * 2 + 1
        else:
            return nil
        i = i + 1

    if is_negative:
        Some(-result)
    else:
        Some(result)
