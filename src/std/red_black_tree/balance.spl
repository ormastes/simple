# Red-Black Tree Balance and Validation Operations
#
# Functions for validating tree properties and computing balance metrics.

from .types import BLACK
from .types import tree_root, tree_nil
from .types import node_left, node_right
from .types import is_nil_node, is_red, is_black

# ============================================================================
# TREE STATISTICS
# ============================================================================

# Calculate tree height (longest path from root to leaf)
fn rb_height(tree):
    val root = tree_root(tree)
    val nil_sentinel = tree_nil(tree)
    calculate_height(root, nil_sentinel)

# Helper to calculate height
fn calculate_height(node, nil_sentinel):
    if is_nil_node(node, nil_sentinel):
        0
    else:
        val left = node_left(node)
        val right = node_right(node)
        val left_height = calculate_height(left, nil_sentinel)
        val right_height = calculate_height(right, nil_sentinel)
        val max_height = if left_height > right_height:
            left_height
        else:
            right_height
        max_height + 1

# Calculate black height (number of black nodes on path to leaf)
fn black_height(tree):
    val root = tree_root(tree)
    val nil_sentinel = tree_nil(tree)
    calculate_black_height(root, nil_sentinel)

# Helper to calculate black height
fn calculate_black_height(node, nil_sentinel):
    if is_nil_node(node, nil_sentinel):
        1
    else:
        val left = node_left(node)
        val bh = calculate_black_height(left, nil_sentinel)
        val node_is_black = is_black(node, nil_sentinel)
        if node_is_black:
            bh + 1
        else:
            bh

# ============================================================================
# TREE VALIDATION
# ============================================================================

# Validate Red-Black tree properties
fn is_valid_rbtree(tree):
    val root = tree_root(tree)
    val nil_sentinel = tree_nil(tree)

    if is_nil_node(root, nil_sentinel):
        true
    else:
        # Property 2: Root is black
        val root_is_black = is_black(root, nil_sentinel)

        if root_is_black == false:
            false
        else:
            # Check other properties
            val valid = validate_rbtree_properties(root, nil_sentinel)
            valid.0

# Validate Red-Black properties recursively
# Returns (valid, black_height)
fn validate_rbtree_properties(node, nil_sentinel):
    if is_nil_node(node, nil_sentinel):
        (true, 1)
    else:
        # Property 4: Red node has black children
        val node_is_red = is_red(node, nil_sentinel)

        if node_is_red:
            val left = node_left(node)
            val right = node_right(node)
            val left_is_red = is_red(left, nil_sentinel)
            val right_is_red = is_red(right, nil_sentinel)

            if left_is_red:
                (false, 0)
            else:
                if right_is_red:
                    (false, 0)
                else:
                    validate_subtrees(node, nil_sentinel)
        else:
            validate_subtrees(node, nil_sentinel)

# Validate both subtrees and check black height
fn validate_subtrees(node, nil_sentinel):
    val left = node_left(node)
    val right = node_right(node)

    val left_result = validate_rbtree_properties(left, nil_sentinel)
    val left_valid = left_result.0
    val left_bh = left_result.1

    if left_valid == false:
        (false, 0)
    else:
        val right_result = validate_rbtree_properties(right, nil_sentinel)
        val right_valid = right_result.0
        val right_bh = right_result.1

        if right_valid == false:
            (false, 0)
        else:
            # Property 5: Equal black height
            if left_bh != right_bh:
                (false, 0)
            else:
                val node_is_black = is_black(node, nil_sentinel)
                val bh = if node_is_black:
                    left_bh + 1
                else:
                    left_bh
                (true, bh)
