# Red-Black Tree Delete Operations
#
# Functions for deleting values and fixing tree properties after deletion.

from .types import BLACK
from .types import tree_root, set_tree_root, tree_nil, decrement_tree_size
from .types import node_value, node_left, node_right, node_parent, node_color
from .types import set_node_parent, set_node_left, set_node_right, set_node_color
from .types import is_nil_node, is_red, is_black, get_color
from .rotation import rotate_left, rotate_right
from .search import search_node, tree_minimum

# ============================================================================
# DELETION
# ============================================================================

# Transplant subtree v in place of subtree u
fn rb_transplant(tree, u, v):
    val nil_sentinel = tree_nil(tree)
    val u_parent = node_parent(u)
    var new_root = tree_root(tree)

    if is_nil_node(u_parent, nil_sentinel):
        # u is root
        new_root = v
    else:
        val parent_left = node_left(u_parent)
        if u == parent_left:
            val new_parent = set_node_left(u_parent, v)
            ()
        else:
            val new_parent = set_node_right(u_parent, v)
            ()

    var new_v = v
    if is_nil_node(v, nil_sentinel) == false:
        new_v = set_node_parent(v, u_parent)
    else:
        ()

    val result_tree = set_tree_root(tree, new_root)
    (result_tree, new_v)

# Delete a value from the tree
fn rb_delete(tree, value):
    val nil_sentinel = tree_nil(tree)
    val root = tree_root(tree)

    # Find node to delete
    val z = search_node(root, value, nil_sentinel)

    if is_nil_node(z, nil_sentinel):
        # Value not found
        tree
    else:
        var y = z
        var y_original_color = node_color(y)
        var x = nil_sentinel
        var result_tree = tree

        val z_left = node_left(z)
        val z_right = node_right(z)
        val z_left_is_nil = is_nil_node(z_left, nil_sentinel)
        val z_right_is_nil = is_nil_node(z_right, nil_sentinel)

        if z_left_is_nil:
            # No left child
            x = z_right
            val transplant_result = rb_transplant(result_tree, z, z_right)
            result_tree = transplant_result.0
            x = transplant_result.1
        else:
            if z_right_is_nil:
                # No right child
                x = z_left
                val transplant_result = rb_transplant(result_tree, z, z_left)
                result_tree = transplant_result.0
                x = transplant_result.1
            else:
                # Two children - find successor
                y = tree_minimum(z_right, nil_sentinel)
                y_original_color = node_color(y)
                x = node_right(y)

                val y_parent = node_parent(y)
                if y_parent == z:
                    if is_nil_node(x, nil_sentinel) == false:
                        x = set_node_parent(x, y)
                    else:
                        ()
                else:
                    val transplant_result1 = rb_transplant(result_tree, y, node_right(y))
                    result_tree = transplant_result1.0
                    y = set_node_right(y, z_right)
                    val y_right = node_right(y)
                    if is_nil_node(y_right, nil_sentinel) == false:
                        val new_y_right = set_node_parent(y_right, y)
                        ()
                    else:
                        ()

                val transplant_result2 = rb_transplant(result_tree, z, y)
                result_tree = transplant_result2.0
                y = set_node_left(y, z_left)
                val y_left = node_left(y)
                if is_nil_node(y_left, nil_sentinel) == false:
                    val new_y_left = set_node_parent(y_left, y)
                    ()
                else:
                    ()
                y = set_node_color(y, node_color(z))

        # Update size
        result_tree = decrement_tree_size(result_tree)

        # Fix Red-Black properties if needed
        if y_original_color == BLACK:
            delete_fixup(result_tree, x)
        else:
            result_tree

# Fix Red-Black properties after deletion
fn delete_fixup(tree, x):
    val nil_sentinel = tree_nil(tree)
    var current = x
    var result_tree = tree
    val root = tree_root(result_tree)

    var current_is_black = is_black(current, nil_sentinel)
    var current_is_not_root = current != root
    var continue = current_is_black
    if continue:
        continue = current_is_not_root
    else:
        ()

    if continue:
        val parent = node_parent(current)
        val parent_left = node_left(parent)

        if current == parent_left:
            # Current is left child
            result_tree = delete_fixup_left(result_tree, current)
        else:
            # Current is right child
            result_tree = delete_fixup_right(result_tree, current)
    else:
        ()

    # Ensure current is black
    if is_nil_node(current, nil_sentinel) == false:
        val new_current = set_node_color(current, BLACK)
        result_tree
    else:
        result_tree

# Delete fixup when node is left child
fn delete_fixup_left(tree, x):
    val nil_sentinel = tree_nil(tree)
    var result_tree = tree
    var parent = node_parent(x)
    var sibling = node_right(parent)

    # Case 1: Sibling is red
    if is_red(sibling, nil_sentinel):
        sibling = set_node_color(sibling, BLACK)
        parent = set_node_color(parent, RED)
        val rotate_result = rotate_left(result_tree, parent)
        result_tree = rotate_result.0
        parent = node_parent(x)
        sibling = node_right(parent)
    else:
        ()

    # Case 2: Sibling and both children are black
    val sibling_left = node_left(sibling)
    val sibling_right = node_right(sibling)
    val left_is_black = is_black(sibling_left, nil_sentinel)
    val right_is_black = is_black(sibling_right, nil_sentinel)

    if left_is_black:
        if right_is_black:
            sibling = set_node_color(sibling, RED)
            result_tree = delete_fixup(result_tree, parent)
        else:
            # Case 4: Sibling is black, far child is red
            sibling = set_node_color(sibling, get_color(parent, nil_sentinel))
            parent = set_node_color(parent, BLACK)
            val new_sibling_right = set_node_color(sibling_right, BLACK)
            val rotate_result = rotate_left(result_tree, parent)
            result_tree = rotate_result.0
    else:
        # Case 3: Sibling is black, near child is red, far child is black
        if right_is_black:
            val new_sibling_left = set_node_color(sibling_left, BLACK)
            sibling = set_node_color(sibling, RED)
            val rotate_result = rotate_right(result_tree, sibling)
            result_tree = rotate_result.0
            parent = node_parent(x)
            sibling = node_right(parent)
        else:
            ()

        # Case 4
        sibling = set_node_color(sibling, get_color(parent, nil_sentinel))
        parent = set_node_color(parent, BLACK)
        val sibling_right2 = node_right(sibling)
        val new_sibling_right2 = set_node_color(sibling_right2, BLACK)
        val rotate_result = rotate_left(result_tree, parent)
        result_tree = rotate_result.0

    result_tree

# Delete fixup when node is right child (symmetric to left)
fn delete_fixup_right(tree, x):
    val nil_sentinel = tree_nil(tree)
    var result_tree = tree
    var parent = node_parent(x)
    var sibling = node_left(parent)

    # Case 1: Sibling is red
    if is_red(sibling, nil_sentinel):
        sibling = set_node_color(sibling, BLACK)
        parent = set_node_color(parent, RED)
        val rotate_result = rotate_right(result_tree, parent)
        result_tree = rotate_result.0
        parent = node_parent(x)
        sibling = node_left(parent)
    else:
        ()

    # Case 2: Sibling and both children are black
    val sibling_left = node_left(sibling)
    val sibling_right = node_right(sibling)
    val left_is_black = is_black(sibling_left, nil_sentinel)
    val right_is_black = is_black(sibling_right, nil_sentinel)

    if right_is_black:
        if left_is_black:
            sibling = set_node_color(sibling, RED)
            result_tree = delete_fixup(result_tree, parent)
        else:
            # Case 4: Sibling is black, far child is red
            sibling = set_node_color(sibling, get_color(parent, nil_sentinel))
            parent = set_node_color(parent, BLACK)
            val new_sibling_left = set_node_color(sibling_left, BLACK)
            val rotate_result = rotate_right(result_tree, parent)
            result_tree = rotate_result.0
    else:
        # Case 3: Sibling is black, near child is red, far child is black
        if left_is_black:
            val new_sibling_right = set_node_color(sibling_right, BLACK)
            sibling = set_node_color(sibling, RED)
            val rotate_result = rotate_left(result_tree, sibling)
            result_tree = rotate_result.0
            parent = node_parent(x)
            sibling = node_left(parent)
        else:
            ()

        # Case 4
        sibling = set_node_color(sibling, get_color(parent, nil_sentinel))
        parent = set_node_color(parent, BLACK)
        val sibling_left2 = node_left(sibling)
        val new_sibling_left2 = set_node_color(sibling_left2, BLACK)
        val rotate_result = rotate_right(result_tree, parent)
        result_tree = rotate_result.0

    result_tree

# Delete multiple values
fn rb_delete_many(tree, values):
    if values == []:
        tree
    else:
        val first = values.0
        val rest = values[1:]
        var new_tree = rb_delete(tree, first)
        rb_delete_many(new_tree, rest)
