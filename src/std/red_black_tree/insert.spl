# Red-Black Tree Insert Operations
#
# Functions for inserting values and fixing tree properties after insertion.

from .types import RED, BLACK
from .types import tree_root, set_tree_root, tree_nil, increment_tree_size
from .types import create_node, node_value, node_left, node_right, node_parent
from .types import set_node_parent, set_node_left, set_node_right, set_node_color
from .types import is_nil_node, is_red
from .rotation import rotate_left, rotate_right

# ============================================================================
# INSERTION
# ============================================================================

# Insert a value into the tree
fn rb_insert(tree, value):
    val nil_sentinel = tree_nil(tree)
    val root = tree_root(tree)

    # Create new red node
    val new_node = create_node(value, RED, nil_sentinel, nil_sentinel, nil_sentinel)

    # Standard BST insertion
    var y = nil_sentinel
    var x = root
    var x_is_nil = is_nil_node(x, nil_sentinel)

    # Find insertion point
    if x_is_nil == false:
        y = x
        val node_val = node_value(x)

        if value < node_val:
            x = node_left(x)
        else:
            x = node_right(x)

        x_is_nil = is_nil_node(x, nil_sentinel)

        if x_is_nil == false:
            y = x
            val node_val2 = node_value(x)

            if value < node_val2:
                x = node_left(x)
            else:
                x = node_right(x)

            x_is_nil = is_nil_node(x, nil_sentinel)

            if x_is_nil == false:
                # Deep tree - use helper
                y = insert_find_parent(x, value, nil_sentinel)
            else:
                ()
        else:
            ()
    else:
        ()

    # Set parent
    var inserted_node = set_node_parent(new_node, y)

    # Insert node
    var new_root = root
    if is_nil_node(y, nil_sentinel):
        # Tree was empty
        new_root = inserted_node
    else:
        val y_val = node_value(y)
        if value < y_val:
            y = set_node_left(y, inserted_node)
        else:
            y = set_node_right(y, inserted_node)

    # Update tree
    var result_tree = set_tree_root(tree, new_root)
    result_tree = increment_tree_size(result_tree)

    # Fix Red-Black properties
    insert_fixup(result_tree, inserted_node)

# Helper to find parent for insertion in deep tree
fn insert_find_parent(node, value, nil_sentinel):
    val node_val = node_value(node)
    val next = if value < node_val:
        node_left(node)
    else:
        node_right(node)

    if is_nil_node(next, nil_sentinel):
        node
    else:
        insert_find_parent(next, value, nil_sentinel)

# Fix Red-Black properties after insertion
# Handles three cases:
# Case 1: Uncle is red - recolor
# Case 2: Uncle is black, node is right child - left rotate
# Case 3: Uncle is black, node is left child - right rotate and recolor
fn insert_fixup(tree, z):
    val nil_sentinel = tree_nil(tree)
    var current = z
    var result_tree = tree

    # Get parent and check color
    var parent = node_parent(current)
    var parent_is_red = is_red(parent, nil_sentinel)

    if parent_is_red:
        # Get grandparent
        val grandparent = node_parent(parent)
        val gp_left = node_left(grandparent)

        if parent == gp_left:
            # Parent is left child
            val uncle = node_right(grandparent)
            val uncle_is_red = is_red(uncle, nil_sentinel)

            if uncle_is_red:
                # Case 1: Uncle is red - recolor
                parent = set_node_color(parent, BLACK)
                val new_uncle = set_node_color(uncle, BLACK)
                val new_gp = set_node_color(grandparent, RED)
                current = new_gp
                result_tree = set_tree_root(result_tree, tree_root(result_tree))

                # Continue fixup at grandparent
                parent = node_parent(current)
                parent_is_red = is_red(parent, nil_sentinel)

                if parent_is_red:
                    result_tree = insert_fixup_continue(result_tree, current)
                else:
                    ()
            else:
                # Uncle is black
                val parent_right = node_right(parent)

                if current == parent_right:
                    # Case 2: Node is right child - left rotate
                    current = parent
                    val rotate_result = rotate_left(result_tree, current)
                    result_tree = rotate_result.0
                    parent = node_parent(current)
                else:
                    ()

                # Case 3: Node is left child - right rotate and recolor
                parent = set_node_color(parent, BLACK)
                val gp2 = node_parent(parent)
                val new_gp2 = set_node_color(gp2, RED)
                val rotate_result2 = rotate_right(result_tree, new_gp2)
                result_tree = rotate_result2.0

        else:
            # Parent is right child (symmetric)
            val uncle = node_left(grandparent)
            val uncle_is_red = is_red(uncle, nil_sentinel)

            if uncle_is_red:
                # Case 1: Uncle is red - recolor
                parent = set_node_color(parent, BLACK)
                val new_uncle = set_node_color(uncle, BLACK)
                val new_gp = set_node_color(grandparent, RED)
                current = new_gp
                result_tree = set_tree_root(result_tree, tree_root(result_tree))

                # Continue fixup at grandparent
                parent = node_parent(current)
                parent_is_red = is_red(parent, nil_sentinel)

                if parent_is_red:
                    result_tree = insert_fixup_continue(result_tree, current)
                else:
                    ()
            else:
                # Uncle is black
                val parent_left = node_left(parent)

                if current == parent_left:
                    # Case 2: Node is left child - right rotate
                    current = parent
                    val rotate_result = rotate_right(result_tree, current)
                    result_tree = rotate_result.0
                    parent = node_parent(current)
                else:
                    ()

                # Case 3: Node is right child - left rotate and recolor
                parent = set_node_color(parent, BLACK)
                val gp2 = node_parent(parent)
                val new_gp2 = set_node_color(gp2, RED)
                val rotate_result2 = rotate_left(result_tree, new_gp2)
                result_tree = rotate_result2.0
    else:
        ()

    # Ensure root is black
    val root = tree_root(result_tree)
    val new_root = set_node_color(root, BLACK)
    set_tree_root(result_tree, new_root)

# Continue insert fixup (helper to avoid deep nesting)
fn insert_fixup_continue(tree, node):
    insert_fixup(tree, node)

# Insert multiple values
fn rb_insert_many(tree, values):
    if values == []:
        tree
    else:
        val first = values.0
        val rest = values[1:]
        var new_tree = rb_insert(tree, first)
        rb_insert_many(new_tree, rest)
