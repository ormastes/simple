# std.coverage - Coverage Check Module for Simple Language
#
# Provides check_coverage() API for validating code coverage thresholds.

extern fn rt_env_get(key: text) -> text
extern fn rt_file_exists(path: text) -> bool
extern fn rt_file_read(path: text) -> text

struct FileResult:
    path: text
    lines_total: i64
    lines_covered: i64
    branches_total: i64
    branches_covered: i64
    functions_total: i64
    functions_covered: i64
    coverage_percent: f64

struct CoverageResult:
    passed: bool
    actual: f64
    threshold: f64
    files_matched: i64
    coverage_type: text
    pattern: text
    minimum_check: bool
    details: [FileResult]

var _coverage_tag_enabled: bool = false
var _coverage_data_loaded: bool = false
var _coverage_data_path: text = ""
var _coverage_files: [FileResult] = []
var _coverage_last_error: text = ""

fn enable_coverage_tag():
    _coverage_tag_enabled = true

fn disable_coverage_tag():
    _coverage_tag_enabled = false

fn is_coverage_tag_enabled() -> bool:
    _coverage_tag_enabled

fn _validate_coverage_access():
    if not _coverage_tag_enabled:
        _coverage_error("CoverageNotEnabledException: check_coverage() requires @coverage tag.")

fn _coverage_error(msg: text):
    _coverage_last_error = msg

fn get_coverage_error() -> text:
    _coverage_last_error

fn clear_coverage_error():
    _coverage_last_error = ""

fn _get_coverage_data_path() -> text:
    val env_path = rt_env_get("SIMPLE_COVERAGE_DATA")
    if env_path != nil and env_path != "":
        return env_path
    ".coverage/coverage.json"

fn _load_coverage_data():
    if _coverage_data_loaded:
        return
    val path = _get_coverage_data_path()
    _coverage_data_path = path
    if not rt_file_exists(path):
        _coverage_error("CoverageDataNotFoundException: No coverage data at " + path)
        return
    _coverage_data_loaded = true

fn _match_pattern(pattern: text, path: text) -> bool:
    if pattern.contains("**"):
        return true
    if pattern.contains("*"):
        return path.ends_with(".spl")
    pattern == path

fn _calculate_coverage(coverage_type: text, files: [FileResult]) -> f64:
    if files.len() == 0:
        return 100.0
    if coverage_type == "line":
        var total = 0
        var covered = 0
        for f in files:
            total = total + f.lines_total
            covered = covered + f.lines_covered
        if total == 0:
            return 100.0
        return (covered as f64 / total as f64) * 100.0
    if coverage_type == "branch":
        var total = 0
        var covered = 0
        for f in files:
            total = total + f.branches_total
            covered = covered + f.branches_covered
        if total == 0:
            return 100.0
        return (covered as f64 / total as f64) * 100.0
    if coverage_type == "function":
        var total = 0
        var covered = 0
        for f in files:
            total = total + f.functions_total
            covered = covered + f.functions_covered
        if total == 0:
            return 100.0
        return (covered as f64 / total as f64) * 100.0
    _coverage_error("InvalidCoverageTypeException: " + coverage_type)
    0.0

fn check_coverage(coverage_type: text, pattern: text, minimum: f64 = 0.0, maximum: f64 = 100.0, minimum_check: bool = true) -> CoverageResult:
    _validate_coverage_access()
    if _coverage_last_error != "":
        return CoverageResult { passed: false, actual: 0.0, threshold: minimum, files_matched: 0, coverage_type: coverage_type, pattern: pattern, minimum_check: minimum_check, details: [] }
    
    _load_coverage_data()
    if _coverage_last_error != "":
        return CoverageResult { passed: false, actual: 0.0, threshold: minimum, files_matched: 0, coverage_type: coverage_type, pattern: pattern, minimum_check: minimum_check, details: [] }
    
    val matched = _coverage_files.filter(\f: _match_pattern(pattern, f.path))
    val actual = _calculate_coverage(coverage_type, matched)
    val threshold = if minimum_check: minimum else: maximum
    val passed = if minimum_check: actual >= minimum else: actual <= maximum
    
    CoverageResult { passed: passed, actual: actual, threshold: threshold, files_matched: matched.len(), coverage_type: coverage_type, pattern: pattern, minimum_check: minimum_check, details: matched }

fn coverage_describe(name: text, block: fn()):
    enable_coverage_tag()
    print name
    block()
    disable_coverage_tag()

fn coverage_it(name: text, block: fn()):
    enable_coverage_tag()
    clear_coverage_error()
    block()
    if _coverage_last_error != "":
        print "  it " + name + " ... FAILED"
    else:
        print "  it " + name + " ... ok"
    disable_coverage_tag()

fn get_coverage_summary() -> text:
    "Coverage: loaded=" + _coverage_data_loaded.to_string()

fn print_coverage_report():
    print "Coverage Report"
    print "Files: " + _coverage_files.len().to_string()

fn reload_coverage_data():
    _coverage_data_loaded = false
    _coverage_files = []
    _load_coverage_data()
