# Segment Tree Query Operations
#
# This module contains functions for querying segment trees
# (range sum, min, max, gcd, lcm).

import std.segment_tree.utilities

# Query sum in range [l, r] recursively
# node: current node index
# start, end: range that current node represents
# l, r: query range
fn query_sum_helper(tree: list, node: i64, start: i64, end: i64, l: i64, r: i64) -> i64:
    # No overlap
    if r < start:
        return 0
    if l > end:
        return 0

    # Complete overlap
    if l <= start:
        if r >= end:
            return tree.get(node)

    # Partial overlap - recurse on children
    val mid = utilities.get_mid(start, end)
    val left = utilities.left_child(node)
    val right = utilities.right_child(node)

    val left_sum = query_sum_helper(tree, left, start, mid, l, r)
    val right_sum = query_sum_helper(tree, right, mid + 1, end, l, r)

    return left_sum + right_sum

# Query sum in range [l, r]
fn range_sum(tree_tuple: (list, i64, text), l: i64, r: i64) -> i64:
    val tree = tree_tuple.0
    val n = tree_tuple.1

    if n == 0:
        return 0
    if l < 0:
        return 0
    if r >= n:
        return 0
    if l > r:
        return 0

    return query_sum_helper(tree, 0, 0, n - 1, l, r)

# Query minimum in range [l, r] recursively
fn query_min_helper(tree: list, node: i64, start: i64, end: i64, l: i64, r: i64) -> i64:
    # No overlap - return large value
    if r < start:
        return 1000000000
    if l > end:
        return 1000000000

    # Complete overlap
    if l <= start:
        if r >= end:
            return tree.get(node)

    # Partial overlap
    val mid = utilities.get_mid(start, end)
    val left = utilities.left_child(node)
    val right = utilities.right_child(node)

    val left_min = query_min_helper(tree, left, start, mid, l, r)
    val right_min = query_min_helper(tree, right, mid + 1, end, l, r)

    var result = left_min
    if right_min < result:
        result = right_min

    return result

# Query minimum in range [l, r]
fn range_min(tree_tuple: (list, i64, text), l: i64, r: i64) -> i64:
    val tree = tree_tuple.0
    val n = tree_tuple.1

    if n == 0:
        return 0
    if l < 0:
        return 0
    if r >= n:
        return 0
    if l > r:
        return 0

    return query_min_helper(tree, 0, 0, n - 1, l, r)

# Query maximum in range [l, r] recursively
fn query_max_helper(tree: list, node: i64, start: i64, end: i64, l: i64, r: i64) -> i64:
    # No overlap - return small value
    if r < start:
        return -1000000000
    if l > end:
        return -1000000000

    # Complete overlap
    if l <= start:
        if r >= end:
            return tree.get(node)

    # Partial overlap
    val mid = utilities.get_mid(start, end)
    val left = utilities.left_child(node)
    val right = utilities.right_child(node)

    val left_max = query_max_helper(tree, left, start, mid, l, r)
    val right_max = query_max_helper(tree, right, mid + 1, end, l, r)

    var result = left_max
    if right_max > result:
        result = right_max

    return result

# Query maximum in range [l, r]
fn range_max(tree_tuple: (list, i64, text), l: i64, r: i64) -> i64:
    val tree = tree_tuple.0
    val n = tree_tuple.1

    if n == 0:
        return 0
    if l < 0:
        return 0
    if r >= n:
        return 0
    if l > r:
        return 0

    return query_max_helper(tree, 0, 0, n - 1, l, r)

# Query GCD in range [l, r] recursively
fn query_gcd_helper(tree: list, node: i64, start: i64, end: i64, l: i64, r: i64) -> i64:
    # No overlap
    if r < start:
        return 0
    if l > end:
        return 0

    # Complete overlap
    if l <= start:
        if r >= end:
            return tree.get(node)

    # Partial overlap
    val mid = utilities.get_mid(start, end)
    val left = utilities.left_child(node)
    val right = utilities.right_child(node)

    val left_gcd = query_gcd_helper(tree, left, start, mid, l, r)
    val right_gcd = query_gcd_helper(tree, right, mid + 1, end, l, r)

    return utilities.gcd(left_gcd, right_gcd)

# Query GCD in range [l, r]
fn range_gcd(tree_tuple: (list, i64, text), l: i64, r: i64) -> i64:
    val tree = tree_tuple.0
    val n = tree_tuple.1

    if n == 0:
        return 0
    if l < 0:
        return 0
    if r >= n:
        return 0
    if l > r:
        return 0

    return query_gcd_helper(tree, 0, 0, n - 1, l, r)

# Query LCM in range
fn query_lcm_helper(tree: list, node: i64, start: i64, end: i64, l: i64, r: i64) -> i64:
    if r < start:
        return 1
    if l > end:
        return 1

    if l <= start:
        if r >= end:
            return tree.get(node)

    val mid = utilities.get_mid(start, end)
    val left = utilities.left_child(node)
    val right = utilities.right_child(node)

    val left_lcm = query_lcm_helper(tree, left, start, mid, l, r)
    val right_lcm = query_lcm_helper(tree, right, mid + 1, end, l, r)

    return utilities.lcm(left_lcm, right_lcm)

# Range LCM query
fn range_lcm(tree_tuple: (list, i64, text), l: i64, r: i64) -> i64:
    val tree = tree_tuple.0
    val n = tree_tuple.1

    if n == 0:
        return 0
    if l < 0:
        return 0
    if r >= n:
        return 0
    if l > r:
        return 0

    return query_lcm_helper(tree, 0, 0, n - 1, l, r)

# Calculate average in range [l, r]
fn range_average(tree_tuple: (list, i64, text), l: i64, r: i64) -> i64:
    val sum = range_sum(tree_tuple, l, r)
    val count = r - l + 1

    if count == 0:
        return 0

    return sum / count

# Get element at index from original array (via leaf query)
fn get_element(tree_tuple: (list, i64, text), index: i64) -> i64:
    val tree = tree_tuple.0
    val n = tree_tuple.1

    if index < 0:
        return 0
    if index >= n:
        return 0

    # Query single element range
    return range_sum(tree_tuple, index, index)

# Convert tree back to array by querying each element
fn tree_to_array(tree_tuple: (list, i64, text)) -> list:
    val n = tree_tuple.1
    var result = []

    var i = 0
    while i < n:
        val elem = get_element(tree_tuple, i)
        result.append(elem)
        i = i + 1

    return result

# Verify tree correctness by comparing with brute force
fn verify_sum_tree(tree_tuple: (list, i64, text), arr: list) -> i64:
    val n = arr.length()

    var l = 0
    while l < n:
        var r = l
        while r < n:
            # Tree query
            val tree_sum = range_sum(tree_tuple, l, r)

            # Brute force
            var brute_sum = 0
            var i = l
            while i <= r:
                brute_sum = brute_sum + arr.get(i)
                i = i + 1

            if tree_sum != brute_sum:
                return 0

            r = r + 1
        l = l + 1

    return 1

# Count elements greater than threshold in range [l, r]
fn count_greater_helper(tree: list, node: i64, start: i64, end: i64, l: i64, r: i64, threshold: i64, arr: list) -> i64:
    # No overlap
    if r < start:
        return 0
    if l > end:
        return 0

    # For leaves, check actual value
    var leaf_check = utilities.is_leaf(start, end)
    if leaf_check == 1:
        val value = arr.get(start)
        if value > threshold:
            return 1
        return 0

    # Recurse on children
    val mid = utilities.get_mid(start, end)
    val left = utilities.left_child(node)
    val right = utilities.right_child(node)

    val left_count = count_greater_helper(tree, left, start, mid, l, r, threshold, arr)
    val right_count = count_greater_helper(tree, right, mid + 1, end, l, r, threshold, arr)

    return left_count + right_count

# Count elements greater than threshold
fn count_elements_greater(tree_tuple: (list, i64, text), l: i64, r: i64, threshold: i64, arr: list) -> i64:
    val tree = tree_tuple.0
    val n = tree_tuple.1

    if n == 0:
        return 0
    if l < 0:
        return 0
    if r >= n:
        return 0
    if l > r:
        return 0

    return count_greater_helper(tree, 0, 0, n - 1, l, r, threshold, arr)

# Find first index where value >= target (binary search on segment tree)
fn first_at_least(tree_tuple: (list, i64, text), target: i64) -> i64:
    val n = tree_tuple.1

    var i = 0
    while i < n:
        val value = get_element(tree_tuple, i)
        if value >= target:
            return i
        i = i + 1

    return -1

# Find last index where value <= target
fn last_at_most(tree_tuple: (list, i64, text), target: i64) -> i64:
    val n = tree_tuple.1
    var result = -1

    var i = 0
    while i < n:
        val value = get_element(tree_tuple, i)
        if value <= target:
            result = i
        i = i + 1

    return result

# Check if all elements in range [l, r] are equal
fn range_all_equal(tree_tuple: (list, i64, text), l: i64, r: i64) -> i64:
    if l > r:
        return 0
    if l < 0:
        return 0
    if r >= tree_tuple.1:
        return 0

    val first_val = get_element(tree_tuple, l)

    var i = l + 1
    while i <= r:
        val current_val = get_element(tree_tuple, i)
        if current_val != first_val:
            return 0
        i = i + 1

    return 1

# Find longest increasing subarray in range
fn longest_increasing(tree_tuple: (list, i64, text), l: i64, r: i64) -> i64:
    if l > r:
        return 0
    if l >= tree_tuple.1:
        return 0

    var max_length = 1
    var current_length = 1

    var i = l + 1
    while i <= r:
        if i < tree_tuple.1:
            val prev_val = get_element(tree_tuple, i - 1)
            val curr_val = get_element(tree_tuple, i)

            if curr_val > prev_val:
                current_length = current_length + 1
                if current_length > max_length:
                    max_length = current_length
            else:
                current_length = 1
        i = i + 1

    return max_length

# Find longest decreasing subarray in range
fn longest_decreasing(tree_tuple: (list, i64, text), l: i64, r: i64) -> i64:
    if l > r:
        return 0
    if l >= tree_tuple.1:
        return 0

    var max_length = 1
    var current_length = 1

    var i = l + 1
    while i <= r:
        if i < tree_tuple.1:
            val prev_val = get_element(tree_tuple, i - 1)
            val curr_val = get_element(tree_tuple, i)

            if curr_val < prev_val:
                current_length = current_length + 1
                if current_length > max_length:
                    max_length = current_length
            else:
                current_length = 1
        i = i + 1

    return max_length
