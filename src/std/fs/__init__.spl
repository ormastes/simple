"""
Filesystem Module - Advanced file and directory operations

@tag:stdlib
@tag:api

This module provides comprehensive filesystem operations beyond basic I/O,
including path manipulation, directory traversal, file metadata, and
cross-platform compatibility.

Core Features:
  - Path manipulation (join, normalize, absolute/relative conversion)
  - Directory operations (create, list, walk, remove)
  - File operations (read, write, copy, delete, metadata)
  - Cross-platform support (Windows, Linux, macOS)
  - Memory-mapped file I/O for large files
  - File locking and atomic operations

Submodules:
  - path: Cross-platform path handling (Path, File, Directory classes)

Basic Usage:
    use std.fs.path.{Path, File, Directory}

    # Path manipulation
    val config_path = Path.new("/etc/app").join("config.toml")
    print config_path.to_string()  # "/etc/app/config.toml"

    # File operations
    val file = File.new(config_path)
    if file.exists():
        val content = file.read()
        print "Config: {content}"

    # Directory operations
    val dir = Directory.new(Path.new("/tmp/data"))
    dir.create_all()
    val entries = dir.list()

SDoctest Examples:

Example 1: Path Manipulation and Metadata
    use std.fs.path.{Path}

    # Create path from components
    val home = Path.new("/home/user")
    val docs = home.join("documents").join("report.pdf")

    # Extract components
    print docs.file_name()      # "report.pdf"
    print docs.file_stem()      # "report"
    print docs.extension()      # "pdf"

    # Change extension
    val txt_version = docs.with_extension("txt")
    print txt_version.to_string()  # "/home/user/documents/report.txt"

Example 2: Directory Traversal and File Discovery
    use std.fs.path.{Path, Directory}

    # List directory contents
    val project = Path.new(".")
    val dir = Directory.new(project)

    # Get all entries
    val entries = dir.list()
    print "Found {entries.len()} items"

    # Get full paths
    val paths = dir.list_paths()
    for path in paths:
        if path.extension() == "spl":
            print "Simple file: {path.to_string()}"

Example 3: File Operations with Error Handling
    use std.fs.path.{Path, File}

    val temp_file = Path.new("/tmp/test.txt")
    val file = File.new(temp_file)

    # Write and verify
    val write_ok = file.write("Hello, filesystem!")
    if write_ok and file.exists():
        val content = file.read()
        print content  # "Hello, filesystem!"

        # Copy to backup
        val backup = Path.new("/tmp/test.backup.txt")
        file.copy_to(backup)

        # Clean up
        file.delete()

Example 4: Cross-Platform Path Handling
    use std.fs.path.{Path, get_home_dir, get_temp_dir}
    use std.platform.{is_windows, is_unix}

    # Get platform-specific directories
    val home = get_home_dir()
    val temp = get_temp_dir()

    print "Home: {home.to_string()}"
    print "Temp: {temp.to_string()}"

    # Platform-aware path construction
    val config = if is_windows():
        home.join("AppData").join("Local").join("myapp")
    else:
        home.join(".config").join("myapp")

    print "Config dir: {config.to_string()}"

Performance Notes:
  - Use memory-mapped I/O (app.io.file_mmap_read_*) for files >10MB
  - File.read() loads entire file into memory - use streaming for large files
  - Directory.list() reads all entries at once - not suitable for huge directories
  - Path operations are lightweight (string manipulation only)

Platform Compatibility:
  - Windows: Supports both forward slash (/) and backslash (\\) separators
  - Unix: Uses forward slash (/) separator exclusively
  - Path normalization handles platform differences automatically
  - Use std.platform module for platform detection

Related Modules:
  - app.io.file_ops: Low-level file I/O and memory mapping
  - app.io.dir_ops: Directory creation and traversal
  - std.platform: Platform detection and path utilities
  - std.glob: Pattern matching for file discovery

See Also:
  - doc/guide/filesystem_operations.md
  - src/std/fs/path.spl - Full Path API documentation
"""

# All submodules are automatically available.
