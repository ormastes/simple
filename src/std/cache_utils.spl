# Cache and Memoization Utilities
#
# Pure Simple implementation of caching strategies and memoization.
# Array-based implementations compatible with runtime limitations.
#
# Cache Strategies:
# - LRU (Least Recently Used)
# - FIFO (First In First Out)
# - LFU (Least Frequently Used)
# - TTL (Time To Live)
#
# Features:
# - Cache operations: get, put, evict, clear
# - Cache statistics: hits, misses, hit rate
# - Simple memoization for functions
# - Configurable capacity limits
#
# Functions:
# - cache_lru_new: Create LRU cache
# - cache_lru_get: Get value from LRU cache
# - cache_lru_put: Put value into LRU cache
# - cache_lru_clear: Clear LRU cache
# - cache_lru_stats: Get LRU cache statistics
# - cache_fifo_new: Create FIFO cache
# - cache_fifo_get: Get value from FIFO cache
# - cache_fifo_put: Put value into FIFO cache
# - cache_fifo_clear: Clear FIFO cache
# - cache_fifo_stats: Get FIFO cache statistics
# - cache_lfu_new: Create LFU cache
# - cache_lfu_get: Get value from LFU cache
# - cache_lfu_put: Put value into LFU cache
# - cache_lfu_clear: Clear LFU cache
# - cache_lfu_stats: Get LFU cache statistics
# - cache_ttl_new: Create TTL cache
# - cache_ttl_get: Get value from TTL cache
# - cache_ttl_put: Put value into TTL cache
# - cache_ttl_clear: Clear TTL cache
# - cache_ttl_cleanup: Remove expired entries
# - cache_ttl_stats: Get TTL cache statistics
# - memo_create: Create memoization cache
# - memo_call: Call function with memoization
# - memo_clear: Clear memoization cache

import string

# ============================================================================
# Helper Functions
# ============================================================================

fn _get_timestamp() -> i64:
    """Get current timestamp (simulated with counter for testing)."""
    # In real implementation, this would return actual system time
    # For now, we use a counter-based approach
    1000000

fn _hash_key(key: text) -> i64:
    """Hash a string key to i64."""
    text_hash(key)

fn _find_key_index(keys, key: text) -> i64:
    """Find index of key in keys array. Returns -1 if not found."""
    var i = 0
    while i < keys.len():
        if keys[i] == key:
            return i
        i = i + 1
    -1

fn _remove_at_index(arr, index: i64):
    """Remove element at index from array. Returns new array."""
    var result = []
    var i = 0
    while i < arr.len():
        if i != index:
            result.push(arr[i])
        i = i + 1
    result

# ============================================================================
# LRU Cache (Least Recently Used)
# ============================================================================

fn cache_lru_new(capacity: i64):
    """Create a new LRU cache with given capacity.

    Returns a cache dictionary with:
    - keys: Array of keys in access order (most recent last)
    - values: Array of values corresponding to keys
    - capacity: Maximum number of entries
    - hits: Number of cache hits
    - misses: Number of cache misses
    """
    {
        'type': 'lru',
        'keys': [],
        'values': [],
        'capacity': capacity,
        'hits': 0,
        'misses': 0
    }

fn cache_lru_get(cache, key: text):
    """Get value from LRU cache. Returns nil if not found.
    Updates access order on hit."""
    val keys = cache['keys']
    val values = cache['values']
    val index = _find_key_index(keys, key)

    if index >= 0:
        # Hit: move to end (most recently used)
        cache['hits'] = cache['hits'] + 1
        val value = values[index]

        # Remove from current position
        cache['keys'] = _remove_at_index(keys, index)
        cache['values'] = _remove_at_index(values, index)

        # Add to end
        var new_keys = cache['keys']
        new_keys.push(key)
        cache['keys'] = new_keys

        var new_values = cache['values']
        new_values.push(value)
        cache['values'] = new_values

        return value
    else:
        # Miss
        cache['misses'] = cache['misses'] + 1
        return nil

fn cache_lru_put(cache, key: text, value):
    """Put value into LRU cache.
    Evicts least recently used entry if at capacity."""
    val keys = cache['keys']
    val values = cache['values']
    val index = _find_key_index(keys, key)

    if index >= 0:
        # Update existing entry
        cache['keys'] = _remove_at_index(keys, index)
        cache['values'] = _remove_at_index(values, index)
    else:
        # New entry - check capacity
        if keys.len() >= cache['capacity']:
            # Evict least recently used (first element)
            cache['keys'] = keys[1:]
            cache['values'] = values[1:]

    # Add to end (most recently used)
    var new_keys = cache['keys']
    new_keys.push(key)
    cache['keys'] = new_keys

    var new_values = cache['values']
    new_values.push(value)
    cache['values'] = new_values

    cache

fn cache_lru_clear(cache):
    """Clear all entries from LRU cache."""
    cache['keys'] = []
    cache['values'] = []
    cache

fn cache_lru_size(cache) -> i64:
    """Get current number of entries in LRU cache."""
    val keys = cache['keys']
    keys.len()

fn cache_lru_contains(cache, key: text) -> bool:
    """Check if key exists in LRU cache."""
    val keys = cache['keys']
    _find_key_index(keys, key) >= 0

fn cache_lru_stats(cache):
    """Get LRU cache statistics.

    Returns dictionary with:
    - hits: Number of cache hits
    - misses: Number of cache misses
    - hit_rate: Hit rate as percentage (0.0 to 100.0)
    - size: Current number of entries
    - capacity: Maximum capacity
    """
    val hits = cache['hits']
    val misses = cache['misses']
    val total = hits + misses

    var hit_rate = 0.0
    if total > 0:
        hit_rate = (hits * 100.0) / total

    {
        'hits': hits,
        'misses': misses,
        'hit_rate': hit_rate,
        'size': cache_lru_size(cache),
        'capacity': cache['capacity']
    }

# ============================================================================
# FIFO Cache (First In First Out)
# ============================================================================

fn cache_fifo_new(capacity: i64):
    """Create a new FIFO cache with given capacity.

    Returns a cache dictionary with:
    - keys: Array of keys in insertion order
    - values: Array of values corresponding to keys
    - capacity: Maximum number of entries
    - hits: Number of cache hits
    - misses: Number of cache misses
    """
    {
        'type': 'fifo',
        'keys': [],
        'values': [],
        'capacity': capacity,
        'hits': 0,
        'misses': 0
    }

fn cache_fifo_get(cache, key: text):
    """Get value from FIFO cache. Returns nil if not found.
    Does NOT update order on access (unlike LRU)."""
    val keys = cache['keys']
    val values = cache['values']
    val index = _find_key_index(keys, key)

    if index >= 0:
        cache['hits'] = cache['hits'] + 1
        return values[index]
    else:
        cache['misses'] = cache['misses'] + 1
        return nil

fn cache_fifo_put(cache, key: text, value):
    """Put value into FIFO cache.
    Evicts oldest entry if at capacity."""
    val keys = cache['keys']
    val values = cache['values']
    val index = _find_key_index(keys, key)

    if index >= 0:
        # Update existing entry in place
        var new_values = cache['values']
        new_values[index] = value
        cache['values'] = new_values
    else:
        # New entry - check capacity
        if keys.len() >= cache['capacity']:
            # Evict first entry (oldest)
            cache['keys'] = keys[1:]
            cache['values'] = values[1:]

        # Add to end
        var new_keys = cache['keys']
        new_keys.push(key)
        cache['keys'] = new_keys

        var new_values = cache['values']
        new_values.push(value)
        cache['values'] = new_values

    cache

fn cache_fifo_clear(cache):
    """Clear all entries from FIFO cache."""
    cache['keys'] = []
    cache['values'] = []
    cache

fn cache_fifo_size(cache) -> i64:
    """Get current number of entries in FIFO cache."""
    val keys = cache['keys']
    keys.len()

fn cache_fifo_contains(cache, key: text) -> bool:
    """Check if key exists in FIFO cache."""
    val keys = cache['keys']
    _find_key_index(keys, key) >= 0

fn cache_fifo_stats(cache):
    """Get FIFO cache statistics."""
    val hits = cache['hits']
    val misses = cache['misses']
    val total = hits + misses

    var hit_rate = 0.0
    if total > 0:
        hit_rate = (hits * 100.0) / total

    {
        'hits': hits,
        'misses': misses,
        'hit_rate': hit_rate,
        'size': cache_fifo_size(cache),
        'capacity': cache['capacity']
    }

# ============================================================================
# LFU Cache (Least Frequently Used)
# ============================================================================

fn cache_lfu_new(capacity: i64):
    """Create a new LFU cache with given capacity.

    Returns a cache dictionary with:
    - keys: Array of keys
    - values: Array of values corresponding to keys
    - frequencies: Array of access frequencies
    - capacity: Maximum number of entries
    - hits: Number of cache hits
    - misses: Number of cache misses
    """
    {
        'type': 'lfu',
        'keys': [],
        'values': [],
        'frequencies': [],
        'capacity': capacity,
        'hits': 0,
        'misses': 0
    }

fn cache_lfu_get(cache, key: text):
    """Get value from LFU cache. Returns nil if not found.
    Increments frequency counter on hit."""
    val keys = cache['keys']
    val values = cache['values']
    val frequencies = cache['frequencies']
    val index = _find_key_index(keys, key)

    if index >= 0:
        cache['hits'] = cache['hits'] + 1

        # Increment frequency
        var new_frequencies = frequencies
        new_frequencies[index] = frequencies[index] + 1
        cache['frequencies'] = new_frequencies

        return values[index]
    else:
        cache['misses'] = cache['misses'] + 1
        return nil

fn cache_lfu_put(cache, key: text, value):
    """Put value into LFU cache.
    Evicts least frequently used entry if at capacity."""
    val keys = cache['keys']
    val values = cache['values']
    val frequencies = cache['frequencies']
    val index = _find_key_index(keys, key)

    if index >= 0:
        # Update existing entry
        var new_values = values
        new_values[index] = value
        cache['values'] = new_values

        # Increment frequency
        var new_frequencies = frequencies
        new_frequencies[index] = frequencies[index] + 1
        cache['frequencies'] = new_frequencies
    else:
        # New entry - check capacity
        if keys.len() >= cache['capacity']:
            # Find least frequently used entry
            var min_freq = frequencies[0]
            var min_index = 0
            var i = 1
            while i < frequencies.len():
                if frequencies[i] < min_freq:
                    min_freq = frequencies[i]
                    min_index = i
                i = i + 1

            # Evict least frequently used
            cache['keys'] = _remove_at_index(keys, min_index)
            cache['values'] = _remove_at_index(values, min_index)
            cache['frequencies'] = _remove_at_index(frequencies, min_index)

        # Add new entry with frequency 1
        var new_keys = cache['keys']
        new_keys.push(key)
        cache['keys'] = new_keys

        var new_values = cache['values']
        new_values.push(value)
        cache['values'] = new_values

        var new_frequencies = cache['frequencies']
        new_frequencies.push(1)
        cache['frequencies'] = new_frequencies

    cache

fn cache_lfu_clear(cache):
    """Clear all entries from LFU cache."""
    cache['keys'] = []
    cache['values'] = []
    cache['frequencies'] = []
    cache

fn cache_lfu_size(cache) -> i64:
    """Get current number of entries in LFU cache."""
    val keys = cache['keys']
    keys.len()

fn cache_lfu_contains(cache, key: text) -> bool:
    """Check if key exists in LFU cache."""
    val keys = cache['keys']
    _find_key_index(keys, key) >= 0

fn cache_lfu_stats(cache):
    """Get LFU cache statistics."""
    val hits = cache['hits']
    val misses = cache['misses']
    val total = hits + misses

    var hit_rate = 0.0
    if total > 0:
        hit_rate = (hits * 100.0) / total

    {
        'hits': hits,
        'misses': misses,
        'hit_rate': hit_rate,
        'size': cache_lfu_size(cache),
        'capacity': cache['capacity']
    }

# ============================================================================
# TTL Cache (Time To Live)
# ============================================================================

fn cache_ttl_new(capacity: i64, ttl_seconds: i64):
    """Create a new TTL cache with given capacity and TTL.

    Returns a cache dictionary with:
    - keys: Array of keys
    - values: Array of values corresponding to keys
    - expiry_times: Array of expiry timestamps
    - capacity: Maximum number of entries
    - ttl: Time to live in seconds
    - hits: Number of cache hits
    - misses: Number of cache misses
    """
    {
        'type': 'ttl',
        'keys': [],
        'values': [],
        'expiry_times': [],
        'capacity': capacity,
        'ttl': ttl_seconds,
        'hits': 0,
        'misses': 0
    }

fn cache_ttl_get(cache, key: text):
    """Get value from TTL cache. Returns nil if not found or expired."""
    val keys = cache['keys']
    val values = cache['values']
    val expiry_times = cache['expiry_times']
    val index = _find_key_index(keys, key)

    if index >= 0:
        val now = _get_timestamp()
        val expiry = expiry_times[index]

        if now < expiry:
            # Not expired - hit
            cache['hits'] = cache['hits'] + 1
            return values[index]
        else:
            # Expired - remove entry and count as miss
            cache['keys'] = _remove_at_index(keys, index)
            cache['values'] = _remove_at_index(values, index)
            cache['expiry_times'] = _remove_at_index(expiry_times, index)
            cache['misses'] = cache['misses'] + 1
            return nil
    else:
        cache['misses'] = cache['misses'] + 1
        return nil

fn cache_ttl_put(cache, key: text, value):
    """Put value into TTL cache with expiry time.
    Evicts oldest entry if at capacity."""
    val keys = cache['keys']
    val values = cache['values']
    val expiry_times = cache['expiry_times']
    val index = _find_key_index(keys, key)
    val now = _get_timestamp()
    val expiry = now + cache['ttl']

    if index >= 0:
        # Update existing entry
        var new_values = values
        new_values[index] = value
        cache['values'] = new_values

        var new_expiry_times = expiry_times
        new_expiry_times[index] = expiry
        cache['expiry_times'] = new_expiry_times
    else:
        # New entry - check capacity
        if keys.len() >= cache['capacity']:
            # Evict first entry (oldest)
            cache['keys'] = keys[1:]
            cache['values'] = values[1:]
            cache['expiry_times'] = expiry_times[1:]

        # Add new entry
        var new_keys = cache['keys']
        new_keys.push(key)
        cache['keys'] = new_keys

        var new_values = cache['values']
        new_values.push(value)
        cache['values'] = new_values

        var new_expiry_times = cache['expiry_times']
        new_expiry_times.push(expiry)
        cache['expiry_times'] = new_expiry_times

    cache

fn cache_ttl_clear(cache):
    """Clear all entries from TTL cache."""
    cache['keys'] = []
    cache['values'] = []
    cache['expiry_times'] = []
    cache

fn cache_ttl_cleanup(cache):
    """Remove all expired entries from TTL cache."""
    val now = _get_timestamp()
    val keys = cache['keys']
    val values = cache['values']
    val expiry_times = cache['expiry_times']

    var new_keys = []
    var new_values = []
    var new_expiry_times = []

    var i = 0
    while i < keys.len():
        if now < expiry_times[i]:
            # Not expired - keep it
            new_keys.push(keys[i])
            new_values.push(values[i])
            new_expiry_times.push(expiry_times[i])
        i = i + 1

    cache['keys'] = new_keys
    cache['values'] = new_values
    cache['expiry_times'] = new_expiry_times
    cache

fn cache_ttl_size(cache) -> i64:
    """Get current number of entries in TTL cache."""
    val keys = cache['keys']
    keys.len()

fn cache_ttl_contains(cache, key: text) -> bool:
    """Check if key exists in TTL cache and is not expired."""
    val keys = cache['keys']
    val expiry_times = cache['expiry_times']
    val index = _find_key_index(keys, key)

    if index >= 0:
        val now = _get_timestamp()
        return now < expiry_times[index]
    else:
        return false

fn cache_ttl_stats(cache):
    """Get TTL cache statistics."""
    val hits = cache['hits']
    val misses = cache['misses']
    val total = hits + misses

    var hit_rate = 0.0
    if total > 0:
        hit_rate = (hits * 100.0) / total

    {
        'hits': hits,
        'misses': misses,
        'hit_rate': hit_rate,
        'size': cache_ttl_size(cache),
        'capacity': cache['capacity'],
        'ttl': cache['ttl']
    }

# ============================================================================
# Memoization
# ============================================================================

fn memo_create(capacity: i64):
    """Create a memoization cache using LRU strategy.

    Returns a memoization cache that stores function call results.
    """
    cache_lru_new(capacity)

fn memo_call(memo_cache, key: text, compute_fn):
    """Call function with memoization.

    Args:
    - memo_cache: Memoization cache created with memo_create
    - key: String key for this computation
    - compute_fn: Function to call if result not cached (takes no args)

    Returns: Cached or computed result.
    """
    val cached = cache_lru_get(memo_cache, key)
    if cached != nil:
        return cached

    # Not cached - compute and store
    val result = compute_fn()
    cache_lru_put(memo_cache, key, result)
    result

fn memo_clear(memo_cache):
    """Clear memoization cache."""
    cache_lru_clear(memo_cache)

fn memo_stats(memo_cache):
    """Get memoization cache statistics."""
    cache_lru_stats(memo_cache)

# ============================================================================
# Generic Cache Operations
# ============================================================================

fn cache_get(cache, key: text):
    """Generic cache get operation. Works with any cache type."""
    val cache_type = cache['type']
    if cache_type == 'lru':
        cache_lru_get(cache, key)
    elif cache_type == 'fifo':
        cache_fifo_get(cache, key)
    elif cache_type == 'lfu':
        cache_lfu_get(cache, key)
    elif cache_type == 'ttl':
        cache_ttl_get(cache, key)
    else:
        nil

fn cache_put(cache, key: text, value):
    """Generic cache put operation. Works with any cache type."""
    val cache_type = cache['type']
    if cache_type == 'lru':
        cache_lru_put(cache, key, value)
    elif cache_type == 'fifo':
        cache_fifo_put(cache, key, value)
    elif cache_type == 'lfu':
        cache_lfu_put(cache, key, value)
    elif cache_type == 'ttl':
        cache_ttl_put(cache, key, value)
    else:
        cache

fn cache_clear(cache):
    """Generic cache clear operation. Works with any cache type."""
    val cache_type = cache['type']
    if cache_type == 'lru':
        cache_lru_clear(cache)
    elif cache_type == 'fifo':
        cache_fifo_clear(cache)
    elif cache_type == 'lfu':
        cache_lfu_clear(cache)
    elif cache_type == 'ttl':
        cache_ttl_clear(cache)
    else:
        cache

fn cache_size(cache) -> i64:
    """Generic cache size operation. Works with any cache type."""
    val cache_type = cache['type']
    if cache_type == 'lru':
        cache_lru_size(cache)
    elif cache_type == 'fifo':
        cache_fifo_size(cache)
    elif cache_type == 'lfu':
        cache_lfu_size(cache)
    elif cache_type == 'ttl':
        cache_ttl_size(cache)
    else:
        0

fn cache_contains(cache, key: text) -> bool:
    """Generic cache contains operation. Works with any cache type."""
    val cache_type = cache['type']
    if cache_type == 'lru':
        cache_lru_contains(cache, key)
    elif cache_type == 'fifo':
        cache_fifo_contains(cache, key)
    elif cache_type == 'lfu':
        cache_lfu_contains(cache, key)
    elif cache_type == 'ttl':
        cache_ttl_contains(cache, key)
    else:
        false

fn cache_stats(cache):
    """Generic cache stats operation. Works with any cache type."""
    val cache_type = cache['type']
    if cache_type == 'lru':
        cache_lru_stats(cache)
    elif cache_type == 'fifo':
        cache_fifo_stats(cache)
    elif cache_type == 'lfu':
        cache_lfu_stats(cache)
    elif cache_type == 'ttl':
        cache_ttl_stats(cache)
    else:
        {'hits': 0, 'misses': 0, 'hit_rate': 0.0, 'size': 0, 'capacity': 0}

# ============================================================================
# Cache Utilities
# ============================================================================

fn cache_hit_rate(cache) -> f64:
    """Calculate hit rate for cache."""
    val stats = cache_stats(cache)
    stats['hit_rate']

fn cache_miss_rate(cache) -> f64:
    """Calculate miss rate for cache."""
    100.0 - cache_hit_rate(cache)

fn cache_is_empty(cache) -> bool:
    """Check if cache is empty."""
    cache_size(cache) == 0

fn cache_is_full(cache) -> bool:
    """Check if cache is at capacity."""
    cache_size(cache) >= cache['capacity']

fn cache_get_or_default(cache, key: text, default_value):
    """Get value from cache or return default if not found."""
    val value = cache_get(cache, key)
    if value == nil:
        default_value
    else:
        value

fn cache_get_or_compute(cache, key: text, compute_fn):
    """Get value from cache or compute and cache if not found."""
    val value = cache_get(cache, key)
    if value == nil:
        val computed = compute_fn()
        cache_put(cache, key, computed)
        return computed
    else:
        return value

# ============================================================================
# Example Usage Functions
# ============================================================================

fn cache_example_lru():
    """Example of using LRU cache."""
    val cache = cache_lru_new(3)

    # Add entries
    cache_lru_put(cache, "a", 1)
    cache_lru_put(cache, "b", 2)
    cache_lru_put(cache, "c", 3)

    # Access to update order
    val val_a = cache_lru_get(cache, "a")

    # Add one more - should evict "b" (least recently used)
    cache_lru_put(cache, "d", 4)

    # Get stats
    cache_lru_stats(cache)

fn cache_example_fifo():
    """Example of using FIFO cache."""
    val cache = cache_fifo_new(3)

    cache_fifo_put(cache, "a", 1)
    cache_fifo_put(cache, "b", 2)
    cache_fifo_put(cache, "c", 3)

    # Add one more - should evict "a" (first in)
    cache_fifo_put(cache, "d", 4)

    cache_fifo_stats(cache)

fn cache_example_lfu():
    """Example of using LFU cache."""
    val cache = cache_lfu_new(3)

    cache_lfu_put(cache, "a", 1)
    cache_lfu_put(cache, "b", 2)
    cache_lfu_put(cache, "c", 3)

    # Access "a" multiple times
    cache_lfu_get(cache, "a")
    cache_lfu_get(cache, "a")
    cache_lfu_get(cache, "a")

    # Add one more - should evict "b" or "c" (least frequently used)
    cache_lfu_put(cache, "d", 4)

    cache_lfu_stats(cache)

fn cache_example_ttl():
    """Example of using TTL cache."""
    val cache = cache_ttl_new(10, 60)

    cache_ttl_put(cache, "session_123", "user_data")
    cache_ttl_put(cache, "session_456", "admin_data")

    # Get value (within TTL)
    val session = cache_ttl_get(cache, "session_123")

    # Clean up expired entries
    cache_ttl_cleanup(cache)

    cache_ttl_stats(cache)

fn cache_example_memo():
    """Example of using memoization."""
    val memo = memo_create(100)

    # Expensive computation
    fn expensive_computation():
        var sum = 0
        var i = 0
        while i < 1000:
            sum = sum + i
            i = i + 1
        sum

    # First call - computes
    val result1 = memo_call(memo, "sum_1000", expensive_computation)

    # Second call - cached
    val result2 = memo_call(memo, "sum_1000", expensive_computation)

    memo_stats(memo)

# ============================================================================
# Exports
# ============================================================================

export cache_lru_new, cache_lru_get, cache_lru_put, cache_lru_clear
export cache_lru_size, cache_lru_contains, cache_lru_stats
export cache_fifo_new, cache_fifo_get, cache_fifo_put, cache_fifo_clear
export cache_fifo_size, cache_fifo_contains, cache_fifo_stats
export cache_lfu_new, cache_lfu_get, cache_lfu_put, cache_lfu_clear
export cache_lfu_size, cache_lfu_contains, cache_lfu_stats
export cache_ttl_new, cache_ttl_get, cache_ttl_put, cache_ttl_clear
export cache_ttl_size, cache_ttl_contains, cache_ttl_cleanup, cache_ttl_stats
export memo_create, memo_call, memo_clear, memo_stats
export cache_get, cache_put, cache_clear, cache_size, cache_contains, cache_stats
export cache_hit_rate, cache_miss_rate, cache_is_empty, cache_is_full
export cache_get_or_default, cache_get_or_compute
export cache_example_lru, cache_example_fifo, cache_example_lfu
export cache_example_ttl, cache_example_memo
