# compression/lz4.spl - RLE compression implementation
#
# Run-Length Encoding (RLE) - consecutive identical characters replaced with count+char
# Example: "aaabbb" -> "3a3b"

# Encode text using RLE - consecutive identical characters replaced with count+char
fn rle_encode(text):
    if text == nil:
        return nil

    val len = text.length()
    if len == 0:
        return ""

    var result = ""
    var current = text[0]
    var count = 1
    var i = 1

    loop:
        if i >= len:
            break

        val ch = text[i]
        if ch == current:
            count = count + 1
        else:
            result = result + count.to_text() + current
            current = ch
            count = 1

        i = i + 1

    # Add last run
    result = result + count.to_text() + current
    return result

# Decode RLE-encoded text back to original
fn rle_decode(encoded):
    if encoded == nil:
        return nil

    val len = encoded.length()
    if len == 0:
        return ""

    var result = ""
    var i = 0
    var count_str = ""

    loop:
        if i >= len:
            break

        val ch = encoded[i]

        # Check if digit
        val is_digit = false
        if ch >= "0":
            if ch <= "9":
                is_digit = true

        if is_digit:
            count_str = count_str + ch
        else:
            # ch is the character to repeat
            if count_str.length() > 0:
                val count = parse_int(count_str)
                var j = 0
                loop:
                    if j >= count:
                        break
                    result = result + ch
                    j = j + 1
                count_str = ""

        i = i + 1

    return result

# Encode bytes array using RLE
fn rle_encode_bytes(bytes):
    if bytes == nil:
        return nil

    val len = bytes.length()
    if len == 0:
        return []

    var result = []
    var current = bytes[0]
    var count = 1
    var i = 1

    loop:
        if i >= len:
            break

        val b = bytes[i]
        if b == current:
            if count < 255:  # Cap at 255 for single byte
                count = count + 1
            else:
                result = result + [count, current]
                count = 1
        else:
            result = result + [count, current]
            current = b
            count = 1

        i = i + 1

    # Add last run
    result = result + [count, current]
    return result

# Decode RLE-encoded bytes back to original
fn rle_decode_bytes(encoded):
    if encoded == nil:
        return nil

    val len = encoded.length()
    if len == 0:
        return []

    var result = []
    var i = 0

    loop:
        if i + 1 >= len:
            break

        val count = encoded[i]
        val byte = encoded[i + 1]

        var j = 0
        loop:
            if j >= count:
                break
            result = result + [byte]
            j = j + 1

        i = i + 2

    return result

# Check if text is suitable for RLE compression
fn rle_is_compressible(text):
    if text == nil:
        return false

    val len = text.length()
    if len < 2:
        return false

    var runs = 0
    var run_length = 1
    var i = 1

    loop:
        if i >= len:
            break

        if text[i] == text[i - 1]:
            run_length = run_length + 1
        else:
            if run_length >= 3:  # Run of 3+ is worth compressing
                runs = runs + 1
            run_length = 1

        i = i + 1

    if run_length >= 3:
        runs = runs + 1

    return runs > 0

# Adaptive RLE - switches between literal and run mode
fn adaptive_rle_encode(text):
    if text == nil:
        return nil

    val len = text.length()
    if len == 0:
        return []

    var tokens = []
    var i = 0

    loop:
        if i >= len:
            break

        val ch = text[i]
        var run_len = 1
        var j = i + 1

        # Count run length
        loop:
            if j >= len:
                break

            if text[j] == ch:
                run_len = run_len + 1
                j = j + 1
            else:
                break

        if run_len >= 4:
            # Encode as run
            tokens = tokens + [["run", ch, run_len]]
            i = i + run_len
        else:
            # Encode as literal
            tokens = tokens + [["lit", ch, 1]]
            i = i + 1

    return tokens

# Decode adaptive RLE
fn adaptive_rle_decode(tokens):
    if tokens == nil:
        return ""

    var result = ""
    var i = 0

    loop:
        if i >= tokens.length():
            break

        val token = tokens[i]
        val mode = token[0]
        val ch = token[1]
        val count = token[2]

        var j = 0
        loop:
            if j >= count:
                break

            result = result + ch
            j = j + 1

        i = i + 1

    return result

# Parse integer from text
fn parse_int(text):
    if text == nil:
        return 0

    var result = 0
    var i = 0

    loop:
        if i >= text.length():
            break

        val ch = text[i]
        var digit = 0

        if ch == "0":
            digit = 0
        if ch == "1":
            digit = 1
        if ch == "2":
            digit = 2
        if ch == "3":
            digit = 3
        if ch == "4":
            digit = 4
        if ch == "5":
            digit = 5
        if ch == "6":
            digit = 6
        if ch == "7":
            digit = 7
        if ch == "8":
            digit = 8
        if ch == "9":
            digit = 9

        result = result * 10 + digit
        i = i + 1

    return result
