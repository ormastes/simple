# RSA Encryption and Decryption
#
# Raw and padded RSA encryption/decryption operations

import src.std.array as array
import src.std.rsa.types as types
import src.std.rsa.modular as modular
import src.std.rsa.key_gen as key_gen
import src.std.rsa.byte_conversion as byte_conversion
import src.std.rsa.padding as padding

# RSA raw encryption (no padding): c = m^e mod n
fn rsa_raw_encrypt(message: list, public_key: list) -> list:
    val n = array.get(public_key, 0)
    val e = array.get(public_key, 1)

    return modular.bigint_mod_exp(message, e, n)

# RSA raw decryption (no padding): m = c^d mod n
fn rsa_raw_decrypt(ciphertext: list, private_key: list) -> list:
    val n = array.get(private_key, 0)
    val d = array.get(private_key, 1)

    return modular.bigint_mod_exp(ciphertext, d, n)

# RSA raw decryption with CRT (faster)
fn rsa_raw_decrypt_crt(ciphertext: list, private_key: list) -> list:
    val n = array.get(private_key, 0)
    val d = array.get(private_key, 1)
    val p = array.get(private_key, 2)
    val q = array.get(private_key, 3)
    val dP = array.get(private_key, 4)
    val dQ = array.get(private_key, 5)
    val qInv = array.get(private_key, 6)

    val m1 = modular.bigint_mod_exp(ciphertext, dP, p)
    val m2 = modular.bigint_mod_exp(ciphertext, dQ, q)

    var h_temp = types.bigint_zero()
    val cmp = types.bigint_compare(m1, m2)
    if cmp >= 0:
        h_temp = types.bigint_sub(m1, m2)
    else:
        val diff = types.bigint_sub(m2, m1)
        h_temp = types.bigint_sub(p, diff)

    val h_temp2 = types.bigint_mul(qInv, h_temp)
    val h = types.bigint_mod(h_temp2, p)

    val hq = types.bigint_mul(h, q)
    val m = types.bigint_add(m2, hq)

    return m

# RSA encrypt text with PKCS#1 v1.5 padding
fn rsa_encrypt(plaintext: text, public_key: list) -> list:
    val n = array.get(public_key, 0)
    val bits_bi = array.get(public_key, 2)

    val key_bits = key_gen.get_key_bits(public_key)
    val key_bytes = key_bits / 8

    val message_bytes = byte_conversion.text_to_bytes(plaintext)

    val padded = padding.pkcs1_pad_type2(message_bytes, key_bytes)

    val message_bi = byte_conversion.bytes_to_bigint(padded)

    val ciphertext_bi = rsa_raw_encrypt(message_bi, public_key)

    val ciphertext_bytes = byte_conversion.bigint_to_bytes(ciphertext_bi, key_bytes)

    return ciphertext_bytes

# RSA decrypt to text with PKCS#1 v1.5 padding
fn rsa_decrypt(ciphertext: list, private_key: list) -> text:
    val n = array.get(private_key, 0)
    val key_bits = key_gen.get_key_bits(private_key)
    val key_bytes = key_bits / 8

    val ciphertext_bi = byte_conversion.bytes_to_bigint(ciphertext)

    val padded_bi = rsa_raw_decrypt_crt(ciphertext_bi, private_key)

    val padded_bytes = byte_conversion.bigint_to_bytes(padded_bi, key_bytes)

    val message_bytes = padding.pkcs1_unpad(padded_bytes)

    return byte_conversion.bytes_to_text(message_bytes)

# Encrypt bytes directly (not text)
fn rsa_encrypt_bytes(message: list, public_key: list) -> list:
    val n = array.get(public_key, 0)
    val key_bits = key_gen.get_key_bits(public_key)
    val key_bytes = key_bits / 8

    val padded = padding.pkcs1_pad_type2(message, key_bytes)

    val message_bi = byte_conversion.bytes_to_bigint(padded)

    val ciphertext_bi = rsa_raw_encrypt(message_bi, public_key)

    val ciphertext_bytes = byte_conversion.bigint_to_bytes(ciphertext_bi, key_bytes)

    return ciphertext_bytes

# Decrypt bytes directly (not text)
fn rsa_decrypt_bytes(ciphertext: list, private_key: list) -> list:
    val n = array.get(private_key, 0)
    val key_bits = key_gen.get_key_bits(private_key)
    val key_bytes = key_bits / 8

    val ciphertext_bi = byte_conversion.bytes_to_bigint(ciphertext)

    val padded_bi = rsa_raw_decrypt_crt(ciphertext_bi, private_key)

    val padded_bytes = byte_conversion.bigint_to_bytes(padded_bi, key_bytes)

    val message_bytes = padding.pkcs1_unpad(padded_bytes)

    return message_bytes
