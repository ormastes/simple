# RSA BigInt Types and Basic Operations
#
# BigInt representation using list of limbs (little-endian)
# Base: 2^30 (30 bits per limb to avoid overflow)

import src.std.array as array
import src.std.math as math

val BIGINT_BASE = 1073741824  # 2^30
val BIGINT_BITS_PER_LIMB = 30

# Create a BigInt from an integer
fn bigint_from_i64(n: i64) -> list:
    if n == 0:
        return [0]

    var result = []
    var value = n

    while value > 0:
        val limb = value % BIGINT_BASE
        result = array.push(result, limb)
        value = value / BIGINT_BASE

    return result

# Create a zero BigInt
fn bigint_zero() -> list:
    return [0]

# Create a one BigInt
fn bigint_one() -> list:
    return [1]

# Check if BigInt is zero
fn bigint_is_zero(a: list) -> bool:
    if array.length(a) == 0:
        return true
    if array.length(a) == 1:
        val first = array.get(a, 0)
        return first == 0
    return false

# Check if BigInt is one
fn bigint_is_one(a: list) -> bool:
    if array.length(a) != 1:
        return false
    val first = array.get(a, 0)
    return first == 1

# Compare two BigInts: -1 if a < b, 0 if a == b, 1 if a > b
fn bigint_compare(a: list, b: list) -> i64:
    val len_a = array.length(a)
    val len_b = array.length(b)

    if len_a < len_b:
        return -1
    if len_a > len_b:
        return 1

    # Same length, compare limbs from most significant
    var i = len_a - 1
    while i >= 0:
        val limb_a = array.get(a, i)
        val limb_b = array.get(b, i)

        if limb_a < limb_b:
            return -1
        if limb_a > limb_b:
            return 1

        i = i - 1

    return 0

# Remove leading zeros from BigInt
fn bigint_normalize(a: list) -> list:
    var len = array.length(a)

    while len > 1:
        val last = array.get(a, len - 1)
        if last != 0:
            break
        len = len - 1

    if len == array.length(a):
        return a

    var result = []
    var i = 0
    while i < len:
        val limb = array.get(a, i)
        result = array.push(result, limb)
        i = i + 1

    return result

# Add two BigInts
fn bigint_add(a: list, b: list) -> list:
    val len_a = array.length(a)
    val len_b = array.length(b)
    val max_len = math.max(len_a, len_b)

    var result = []
    var carry = 0
    var i = 0

    while i < max_len:
        var sum = carry

        if i < len_a:
            val limb_a = array.get(a, i)
            sum = sum + limb_a

        if i < len_b:
            val limb_b = array.get(b, i)
            sum = sum + limb_b

        result = array.push(result, sum % BIGINT_BASE)
        carry = sum / BIGINT_BASE
        i = i + 1

    if carry > 0:
        result = array.push(result, carry)

    return bigint_normalize(result)

# Subtract two BigInts (assumes a >= b)
fn bigint_sub(a: list, b: list) -> list:
    val cmp = bigint_compare(a, b)
    if cmp == 0:
        return bigint_zero()
    if cmp < 0:
        return bigint_zero()

    val len_a = array.length(a)
    val len_b = array.length(b)

    var result = []
    var borrow = 0
    var i = 0

    while i < len_a:
        var limb_a = array.get(a, i)
        limb_a = limb_a - borrow

        var limb_b = 0
        if i < len_b:
            limb_b = array.get(b, i)

        if limb_a < limb_b:
            limb_a = limb_a + BIGINT_BASE
            borrow = 1
        else:
            borrow = 0

        result = array.push(result, limb_a - limb_b)
        i = i + 1

    return bigint_normalize(result)

# Multiply two BigInts (schoolbook algorithm)
fn bigint_mul(a: list, b: list) -> list:
    val len_a = array.length(a)
    val len_b = array.length(b)

    if bigint_is_zero(a):
        return bigint_zero()
    if bigint_is_zero(b):
        return bigint_zero()

    var result = []
    var i = 0
    while i < len_a + len_b:
        result = array.push(result, 0)
        i = i + 1

    i = 0
    while i < len_a:
        val limb_a = array.get(a, i)
        var carry = 0
        var j = 0

        while j < len_b:
            val limb_b = array.get(b, j)
            val idx = i + j
            val current = array.get(result, idx)

            val prod = limb_a * limb_b + current + carry
            result = array.set(result, idx, prod % BIGINT_BASE)
            carry = prod / BIGINT_BASE
            j = j + 1

        if carry > 0:
            val idx = i + len_b
            val current = array.get(result, idx)
            result = array.set(result, idx, current + carry)

        i = i + 1

    return bigint_normalize(result)

# Multiply BigInt by a small integer
fn bigint_mul_i64(a: list, n: i64) -> list:
    if n == 0:
        return bigint_zero()
    if n == 1:
        return a

    val len_a = array.length(a)
    var result = []
    var carry = 0
    var i = 0

    while i < len_a:
        val limb = array.get(a, i)
        val prod = limb * n + carry
        result = array.push(result, prod % BIGINT_BASE)
        carry = prod / BIGINT_BASE
        i = i + 1

    if carry > 0:
        result = array.push(result, carry)

    return bigint_normalize(result)

# Divide BigInt by small integer, return (quotient, remainder)
fn bigint_divmod_i64(a: list, n: i64) -> list:
    if n == 0:
        return [bigint_zero(), bigint_zero()]
    if n == 1:
        return [a, bigint_zero()]

    val len_a = array.length(a)
    var quotient = []
    var remainder = 0
    var i = len_a - 1

    while i >= 0:
        val limb = array.get(a, i)
        val dividend = remainder * BIGINT_BASE + limb
        val q = dividend / n
        remainder = dividend % n
        quotient = array.push(quotient, q)
        i = i - 1

    var rev_quotient = []
    i = array.length(quotient) - 1
    while i >= 0:
        val elem = array.get(quotient, i)
        rev_quotient = array.push(rev_quotient, elem)
        i = i - 1

    val norm_quot = bigint_normalize(rev_quotient)
    val remainder_bi = bigint_from_i64(remainder)
    return [norm_quot, remainder_bi]

# Shift BigInt left by n bits
fn bigint_shift_left(a: list, n: i64) -> list:
    if n == 0:
        return a
    if bigint_is_zero(a):
        return a

    val limb_shift = n / BIGINT_BITS_PER_LIMB
    val bit_shift = n % BIGINT_BITS_PER_LIMB

    var result = []

    var i = 0
    while i < limb_shift:
        result = array.push(result, 0)
        i = i + 1

    if bit_shift == 0:
        i = 0
        val len_a = array.length(a)
        while i < len_a:
            val limb = array.get(a, i)
            result = array.push(result, limb)
            i = i + 1
        return result

    val len_a = array.length(a)
    var carry = 0
    i = 0

    while i < len_a:
        val limb = array.get(a, i)
        val shifted = limb * math.pow(2, bit_shift)
        val new_limb = shifted % BIGINT_BASE
        val new_carry = shifted / BIGINT_BASE
        result = array.push(result, new_limb + carry)
        carry = new_carry
        i = i + 1

    if carry > 0:
        result = array.push(result, carry)

    return bigint_normalize(result)

# Shift BigInt right by n bits
fn bigint_shift_right(a: list, n: i64) -> list:
    if n == 0:
        return a
    if bigint_is_zero(a):
        return a

    val limb_shift = n / BIGINT_BITS_PER_LIMB
    val bit_shift = n % BIGINT_BITS_PER_LIMB

    val len_a = array.length(a)
    if limb_shift >= len_a:
        return bigint_zero()

    var result = []

    if bit_shift == 0:
        var i = limb_shift
        while i < len_a:
            val limb = array.get(a, i)
            result = array.push(result, limb)
            i = i + 1
        return bigint_normalize(result)

    val divisor = math.pow(2, bit_shift)
    var i = limb_shift
    var carry = 0

    while i < len_a:
        val limb = array.get(a, i)
        val combined = limb + carry * BIGINT_BASE
        val new_limb = combined / divisor
        carry = combined % divisor
        result = array.push(result, new_limb)
        i = i + 1

    return bigint_normalize(result)

# Get bit at position n (0-indexed from LSB)
fn bigint_get_bit(a: list, n: i64) -> i64:
    val limb_idx = n / BIGINT_BITS_PER_LIMB
    val bit_idx = n % BIGINT_BITS_PER_LIMB

    val len_a = array.length(a)
    if limb_idx >= len_a:
        return 0

    val limb = array.get(a, limb_idx)
    val mask = math.pow(2, bit_idx)
    val masked = limb / mask
    return masked % 2

# Set bit at position n
fn bigint_set_bit(a: list, n: i64) -> list:
    val limb_idx = n / BIGINT_BITS_PER_LIMB
    val bit_idx = n % BIGINT_BITS_PER_LIMB

    var result = a
    val len_a = array.length(a)

    while array.length(result) <= limb_idx:
        result = array.push(result, 0)

    val limb = array.get(result, limb_idx)
    val mask = math.pow(2, bit_idx)
    val new_limb = limb + mask
    result = array.set(result, limb_idx, new_limb)

    return result

# Count bits in BigInt
fn bigint_bit_length(a: list) -> i64:
    val norm = bigint_normalize(a)
    val len = array.length(norm)

    if len == 0:
        return 0
    if bigint_is_zero(norm):
        return 0

    val top_limb = array.get(norm, len - 1)
    val base_bits = (len - 1) * BIGINT_BITS_PER_LIMB

    var bits = 0
    var temp = top_limb
    while temp > 0:
        bits = bits + 1
        temp = temp / 2

    return base_bits + bits

# Divide two BigInts, return (quotient, remainder)
fn bigint_divmod(a: list, b: list) -> list:
    val cmp = bigint_compare(a, b)
    if cmp < 0:
        return [bigint_zero(), a]
    if cmp == 0:
        return [bigint_one(), bigint_zero()]

    if bigint_is_zero(b):
        return [bigint_zero(), bigint_zero()]

    var quotient = bigint_zero()
    var remainder = bigint_zero()

    val bit_len = bigint_bit_length(a)
    var i = bit_len - 1

    while i >= 0:
        remainder = bigint_shift_left(remainder, 1)

        val bit = bigint_get_bit(a, i)
        if bit == 1:
            remainder = bigint_add(remainder, bigint_one())

        val cmp_rem = bigint_compare(remainder, b)
        if cmp_rem >= 0:
            remainder = bigint_sub(remainder, b)
            quotient = bigint_set_bit(quotient, i)

        i = i - 1

    return [bigint_normalize(quotient), bigint_normalize(remainder)]

# Modulo operation
fn bigint_mod(a: list, b: list) -> list:
    val divmod_result = bigint_divmod(a, b)
    return array.get(divmod_result, 1)

# Check if number is even
fn bigint_is_even(n: list) -> bool:
    val two = bigint_from_i64(2)
    val divmod_2 = bigint_divmod(n, two)
    val remainder = array.get(divmod_2, 1)
    return bigint_is_zero(remainder)

# Check if number is odd
fn bigint_is_odd(n: list) -> bool:
    return !bigint_is_even(n)

# Absolute difference between two BigInts
fn bigint_abs_diff(a: list, b: list) -> list:
    val cmp = bigint_compare(a, b)
    if cmp >= 0:
        return bigint_sub(a, b)
    else:
        return bigint_sub(b, a)

# Power function for BigInt (not modular)
fn bigint_pow(base: list, exp: i64) -> list:
    if exp == 0:
        return bigint_one()
    if exp == 1:
        return base

    var result = bigint_one()
    var i = 0

    while i < exp:
        result = bigint_mul(result, base)
        i = i + 1

    return result
