# JSON Formatter for Machine-Readable Output
#
# Provides structured JSON output for tools, IDEs, and LLM integration.

use std.text.{NL}
use compiler_shared.diagnostics.{Diagnostic, Severity, Span, Label}

# JSON formatter for structured diagnostic output
struct JsonFormatter:
    pretty: bool

impl JsonFormatter:
    # Create a new JSON formatter (compact output)
    static fn new() -> JsonFormatter:
        JsonFormatter(pretty: false)

    # Create a formatter with pretty-printed JSON
    static fn pretty() -> JsonFormatter:
        JsonFormatter(pretty: true)

    # Format a single diagnostic as JSON
    fn format(diagnostic: Diagnostic) -> text:
        self.diagnostic_to_json(diagnostic, 0)

    # Format multiple diagnostics as JSON array
    fn format_multiple(diagnostics: [Diagnostic]) -> text:
        if self.pretty:
            var parts = []
            for diag in diagnostics:
                parts.push(self.indent(2) + self.diagnostic_to_json(diag, 2))
            "[\n" + parts.join(",\n") + "\n]"
        else:
            var parts = []
            for diag in diagnostics:
                parts.push(self.diagnostic_to_json(diag, 0))
            "[" + parts.join(",") + "]"

    # Convert diagnostic to JSON object
    fn diagnostic_to_json(diagnostic: Diagnostic, indent_level: i64) -> text:
        var fields: [text] = []

        # Severity (required)
        fields.push(self.json_field("severity", self.json_string(diagnostic.severity.to_string()), indent_level + 2))

        # Message (required)
        fields.push(self.json_field("message", self.json_string(diagnostic.message), indent_level + 2))

        # Code (optional)
        if diagnostic.code.?:
            fields.push(self.json_field("code", self.json_string(diagnostic.code.unwrap()), indent_level + 2))

        # Span (optional)
        if diagnostic.span.?:
            fields.push(self.json_field("span", self.span_to_json(diagnostic.span.unwrap(), indent_level + 2), indent_level + 2))

        # Labels (optional)
        if not diagnostic.labels.is_empty():
            fields.push(self.json_field("labels", self.labels_to_json(diagnostic.labels, indent_level + 2), indent_level + 2))

        # Notes (optional)
        if not diagnostic.notes.is_empty():
            fields.push(self.json_field("notes", self.string_array_to_json(diagnostic.notes), indent_level + 2))

        # Help (optional)
        if diagnostic.help.?:
            fields.push(self.json_field("help", self.json_string(diagnostic.help.unwrap()), indent_level + 2))

        # Build object
        if self.pretty:
            val ind = self.indent(indent_level)
            val inner_ind = self.indent(indent_level + 2)
            "{\n{inner_ind}{fields.join(\",\n\" + inner_ind)}\n{ind}}"
        else:
            "{" + fields.join(",") + "}"

    # Convert span to JSON
    fn span_to_json(span: Span, indent_level: i64) -> text:
        var fields: [text] = []
        fields.push(self.json_field("start", span.start.to_string(), indent_level + 2))
        fields.push(self.json_field("end", span.end.to_string(), indent_level + 2))
        fields.push(self.json_field("line", span.line.to_string(), indent_level + 2))
        fields.push(self.json_field("column", span.column.to_string(), indent_level + 2))

        if self.pretty:
            val ind = self.indent(indent_level)
            val inner_ind = self.indent(indent_level + 2)
            "{\n{inner_ind}{fields.join(\",\n\" + inner_ind)}\n{ind}}"
        else:
            "{" + fields.join(",") + "}"

    # Convert labels to JSON array
    fn labels_to_json(labels: [Label], indent_level: i64) -> text:
        var items: [text] = []

        for label in labels:
            var label_fields: [text] = []
            label_fields.push(self.json_field("span", self.span_to_json(label.span, indent_level + 2), indent_level + 2))
            label_fields.push(self.json_field("message", self.json_string(label.message), indent_level + 2))

            val label_obj = if self.pretty:
                val ind = self.indent(indent_level)
                val inner_ind = self.indent(indent_level + 2)
                "{\n{inner_ind}{label_fields.join(\",\n\" + inner_ind)}\n{ind}}"
            else:
                "{" + label_fields.join(",") + "}"

            items.push(label_obj)

        if self.pretty:
            val ind = self.indent(indent_level)
            val inner_ind = self.indent(indent_level + 2)
            "[\n{inner_ind}{items.join(\",\n\" + inner_ind)}\n{ind}]"
        else:
            "[" + items.join(",") + "]"

    # Convert string array to JSON
    fn string_array_to_json(strings: [text]) -> text:
        val items = strings.map(\s: self.json_string(s))

        if self.pretty:
            "[" + items.join(", ") + "]"
        else:
            "[" + items.join(",") + "]"

    # Create JSON field (key: value)
    fn json_field(key: text, value: text, indent_level: i64) -> text:
        if self.pretty:
            "\"{key}\": {value}"
        else:
            "\"{key}\":{value}"

    # Escape and quote a string for JSON
    fn json_string(s: text) -> text:
        # Escape special characters
        var escaped = s
        escaped = escaped.replace("\\", "\\\\")
        escaped = escaped.replace("\"", "\\\"")
        escaped = escaped.replace(NL, "\\n")
        escaped = escaped.replace("\r", "\\r")
        escaped = escaped.replace("\t", "\\t")

        "\"{escaped}\""

    # Create indentation string
    fn indent(level: i64) -> text:
        if not self.pretty:
            return ""

        " ".repeat(level)

# Public exports
export JsonFormatter
