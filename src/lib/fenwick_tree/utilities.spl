# Fenwick Tree Utilities and Helper Functions
#
# Purpose: Common utilities, metrics, statistics, and helper operations
#
# Contains:
# - Size and statistics functions
# - Min/max value operations
# - Counting operations
# - Finding indices
# - Debugging utilities
# - Application-specific operations (inversion count, coordinate compression)
# - 2D Fenwick tree operations

# Import utilities from other modules
mod fenwick_tree.types
mod fenwick_tree.query
mod fenwick_tree.update
mod fenwick_tree.construction
mod fenwick_tree.range_ops

# ============================================================================
# Utility and Inspection Functions
# ============================================================================

# Get tree size
fn get_size(fenwick_tree) -> i64:
    """Get number of elements in Fenwick tree.

    Returns:
      Size n (not including tree[0])

    Time: O(1)
    """
    fenwick_tree.1

# Get total sum of all elements
fn total_sum(fenwick_tree) -> i64:
    """Get sum of all elements in tree.

    Equivalent to prefix_sum(n).

    Time: O(log n)
    """
    val n = fenwick_tree.1
    prefix_sum(fenwick_tree, n)

# Check if tree is empty (all zeros)
fn is_empty(fenwick_tree) -> bool:
    """Check if all elements are zero.

    Time: O(log n)
    """
    val sum = total_sum(fenwick_tree)
    sum == 0

# Get minimum value in tree
fn min_value(fenwick_tree) -> i64:
    """Find minimum value in tree.

    Time: O(n log n)
    """
    val n = fenwick_tree.1
    if n == 0:
        return 0

    var min_val = point_query(fenwick_tree, 1)
    var i = 2
    while i <= n:
        val val = point_query(fenwick_tree, i)
        if val < min_val:
            min_val = val
        i = i + 1

    min_val

# Get maximum value in tree
fn max_value(fenwick_tree) -> i64:
    """Find maximum value in tree.

    Time: O(n log n)
    """
    val n = fenwick_tree.1
    if n == 0:
        return 0

    var max_val = point_query(fenwick_tree, 1)
    var i = 2
    while i <= n:
        val val = point_query(fenwick_tree, i)
        if val > max_val:
            max_val = val
        i = i + 1

    max_val

# Count non-zero elements
fn count_non_zero(fenwick_tree) -> i64:
    """Count number of non-zero elements.

    Time: O(n log n)
    """
    val n = fenwick_tree.1
    var count = 0

    var i = 1
    while i <= n:
        val val = point_query(fenwick_tree, i)
        if val != 0:
            count = count + 1
        i = i + 1

    count

# Count positive elements
fn count_positive(fenwick_tree) -> i64:
    """Count number of positive elements.

    Time: O(n log n)
    """
    val n = fenwick_tree.1
    var count = 0

    var i = 1
    while i <= n:
        val val = point_query(fenwick_tree, i)
        if val > 0:
            count = count + 1
        i = i + 1

    count

# Count negative elements
fn count_negative(fenwick_tree) -> i64:
    """Count number of negative elements.

    Time: O(n log n)
    """
    val n = fenwick_tree.1
    var count = 0

    var i = 1
    while i <= n:
        val val = point_query(fenwick_tree, i)
        if val < 0:
            count = count + 1
        i = i + 1

    count

# Get average value
fn average_value(fenwick_tree) -> i64:
    """Calculate average of all elements.

    Returns integer division result.

    Time: O(log n)
    """
    val n = fenwick_tree.1
    if n == 0:
        return 0
    val sum = total_sum(fenwick_tree)
    sum / n

# Get median value (approximate)
fn median_value(fenwick_tree) -> i64:
    """Find median value (middle element).

    Time: O(n log n)
    """
    val n = fenwick_tree.1
    if n == 0:
        return 0

    val arr = tree_to_array(fenwick_tree)
    val sorted_arr = arr.sort()
    sorted_arr[n / 2]

# Find first positive value
fn find_first_positive(fenwick_tree) -> i64:
    """Find index of first positive element.

    Returns -1 if no positive element found.

    Time: O(n log n)
    """
    val n = fenwick_tree.1

    var i = 1
    while i <= n:
        val val = point_query(fenwick_tree, i)
        if val > 0:
            return i
        i = i + 1

    -1

# Find first negative value
fn find_first_negative(fenwick_tree) -> i64:
    """Find index of first negative element.

    Returns -1 if no negative element found.

    Time: O(n log n)
    """
    val n = fenwick_tree.1

    var i = 1
    while i <= n:
        val val = point_query(fenwick_tree, i)
        if val < 0:
            return i
        i = i + 1

    -1

# Find index of maximum value
fn find_max_index(fenwick_tree) -> i64:
    """Find index of maximum element.

    Returns -1 if tree is empty.

    Time: O(n log n)
    """
    val n = fenwick_tree.1
    if n == 0:
        return -1

    var max_idx = 1
    var max_val = point_query(fenwick_tree, 1)

    var i = 2
    while i <= n:
        val val = point_query(fenwick_tree, i)
        if val > max_val:
            max_val = val
            max_idx = i
        i = i + 1

    max_idx

# Find index of minimum value
fn find_min_index(fenwick_tree) -> i64:
    """Find index of minimum element.

    Returns -1 if tree is empty.

    Time: O(n log n)
    """
    val n = fenwick_tree.1
    if n == 0:
        return -1

    var min_idx = 1
    var min_val = point_query(fenwick_tree, 1)

    var i = 2
    while i <= n:
        val val = point_query(fenwick_tree, i)
        if val < min_val:
            min_val = val
            min_idx = i
        i = i + 1

    min_idx

# ============================================================================
# Advanced Applications
# ============================================================================

# Count elements less than value
fn count_less_than(fenwick_tree, value: i64) -> i64:
    """Count elements strictly less than value in frequency tree.

    Assumes Fenwick tree stores frequencies.

    Args:
      fenwick_tree: Frequency tree
      value: Threshold value

    Returns:
      Count of elements < value

    Time: O(log n)
    """
    if value <= 1:
        return 0
    prefix_sum(fenwick_tree, value - 1)

# Count elements greater than value
fn count_greater_than(fenwick_tree, value: i64) -> i64:
    """Count elements strictly greater than value in frequency tree.

    Args:
      fenwick_tree: Frequency tree
      value: Threshold value

    Returns:
      Count of elements > value

    Time: O(log n)
    """
    val n = fenwick_tree.1
    val total = prefix_sum(fenwick_tree, n)
    val less_eq = prefix_sum(fenwick_tree, value)
    total - less_eq

# Count elements in range [low, high]
fn count_in_range(fenwick_tree, low: i64, high: i64) -> i64:
    """Count elements in range [low, high] in frequency tree.

    Time: O(log n)
    """
    range_sum(fenwick_tree, low, high)

# ============================================================================
# Application: Inversion Count
# ============================================================================

# Count inversions in array using Fenwick tree
fn inversion_count(arr: list) -> i64:
    """Count number of inversions in array.

    An inversion is a pair (i, j) where i < j but arr[i] > arr[j].
    Uses Fenwick tree with coordinate compression.

    Algorithm:
      1. Create frequency tree
      2. For each element from right to left:
         - Count elements smaller than current (inversions)
         - Update frequency tree

    Args:
      arr: Input array

    Returns:
      Number of inversions

    Time: O(n log n)
    Space: O(n)

    Example:
      arr = [3, 1, 2]
      Inversions: (0,1), (0,2) = 2
    """
    val n = arr.len()
    if n <= 1:
        return 0

    var max_val = arr[0]
    var i = 1
    while i < n:
        if arr[i] > max_val:
            max_val = arr[i]
        i = i + 1

    var tree = create_fenwick_tree(max_val)
    var count = 0

    i = n - 1
    while i >= 0:
        val val = arr[i]
        if val > 1:
            val smaller = prefix_sum(tree, val - 1)
            count = count + smaller
        tree = update(tree, val, 1)
        i = i - 1

    count

# ============================================================================
# Application: Coordinate Compression
# ============================================================================

# Compress coordinates to smaller range
fn compress_coordinates(values: list) -> (list, list):
    """Compress large coordinate values to smaller range.

    Maps values to ranks [1, n] preserving order.
    Useful when coordinate space is large but sparse.

    Args:
      values: Array of values to compress

    Returns:
      (compressed, mapping) where:
        - compressed: Array of ranks [1..n]
        - mapping: Sorted unique values

    Time: O(n log n)

    Example:
      values = [100, 50, 200, 50]
      compressed = [2, 1, 3, 1]
      mapping = [50, 100, 200]
    """
    val n = values.len()

    var sorted_vals = []
    var i = 0
    while i < n:
        sorted_vals.push(values[i])
        i = i + 1
    sorted_vals = sorted_vals.sort()

    var unique = []
    if n > 0:
        unique.push(sorted_vals[0])
    i = 1
    while i < n:
        if sorted_vals[i] != sorted_vals[i - 1]:
            unique.push(sorted_vals[i])
        i = i + 1

    var compressed = []
    i = 0
    while i < n:
        val val = values[i]
        var rank = 1
        var j = 0
        while j < unique.len():
            if unique[j] == val:
                rank = j + 1
            j = j + 1
        compressed.push(rank)
        i = i + 1

    (compressed, unique)

# ============================================================================
# Debugging and Visualization
# ============================================================================

# Get internal tree array (for debugging)
fn get_internal_array(fenwick_tree) -> list:
    """Get the internal tree array (1-indexed with tree[0]=0).

    Useful for debugging and understanding tree structure.

    Returns:
      Internal array including tree[0]

    Time: O(n)
    """
    val tree = fenwick_tree.0
    var result = []
    var i = 0
    while i < tree.len():
        result.push(tree[i])
        i = i + 1
    result

# Get tree height (max depth)
fn get_tree_height(fenwick_tree) -> i64:
    """Get the height of Fenwick tree structure.

    Height is approximately logâ‚‚(n).

    Time: O(1)
    """
    val n = fenwick_tree.1
    if n == 0:
        return 0

    var height = 0
    var temp = n
    while temp > 0:
        temp = temp / 2
        height = height + 1
    height

# ============================================================================
# 2D Fenwick Tree Operations
# ============================================================================

# Create empty 2D Fenwick tree
fn create_2d_fenwick(rows: i64, cols: i64) -> (list, i64, i64):
    """Create an empty 2D Fenwick tree.

    Supports efficient 2D range sum queries on matrices.
    Both dimensions use 1-indexing.

    Args:
      rows: Number of rows
      cols: Number of columns

    Returns:
      (tree, rows, cols) tuple where tree is 2D array

    Time: O(rows * cols)
    Space: O(rows * cols)
    """
    var tree = []

    var r = 0
    while r <= rows:
        var row = []
        var c = 0
        while c <= cols:
            row.push(0)
            c = c + 1
        tree.push(row)
        r = r + 1

    (tree, rows, cols)

# Build 2D Fenwick tree from matrix
fn create_2d_fenwick_from_matrix(matrix: list) -> (list, i64, i64):
    """Build 2D Fenwick tree from a matrix.

    Args:
      matrix: 2D array (0-indexed)

    Returns:
      2D Fenwick tree

    Time: O(rows * cols * log(rows) * log(cols))
    """
    val rows = matrix.len()
    if rows == 0:
        return create_2d_fenwick(0, 0)

    val cols = matrix[0].len()
    var tree_2d = create_2d_fenwick(rows, cols)

    var r = 0
    while r < rows:
        var c = 0
        while c < cols:
            val value = matrix[r][c]
            tree_2d = update_2d(tree_2d, r + 1, c + 1, value)
            c = c + 1
        r = r + 1

    tree_2d

# Update single cell in 2D Fenwick tree
fn update_2d(tree_2d, row: i64, col: i64, delta: i64) -> (list, i64, i64):
    """Add delta to cell at (row, col) in 2D Fenwick tree.

    Updates all parent cells in both dimensions.

    Algorithm:
      r = row
      while r <= rows:
        c = col
        while c <= cols:
          tree[r][c] += delta
          c = c + (c & -c)
        r = r + (r & -r)

    Args:
      tree_2d: (tree, rows, cols) tuple
      row: 1-indexed row
      col: 1-indexed column
      delta: Value to add

    Returns:
      Updated 2D Fenwick tree

    Time: O(log(rows) * log(cols))
    """
    val tree = tree_2d.0
    val rows = tree_2d.1
    val cols = tree_2d.2

    if row < 1:
        return tree_2d
    if row > rows:
        return tree_2d
    if col < 1:
        return tree_2d
    if col > cols:
        return tree_2d

    var r = row
    while r <= rows:
        var c = col
        while c <= cols:
            val row_data = tree[r]
            val current = row_data[c]
            row_data[c] = current + delta
            c = get_parent(c)
        r = get_parent(r)

    (tree, rows, cols)

# Query prefix sum in 2D (from (1,1) to (row, col))
fn prefix_sum_2d(tree_2d, row: i64, col: i64) -> i64:
    """Compute 2D prefix sum from (1,1) to (row, col).

    Returns sum of all elements in rectangle from (1,1) to (row,col).

    Algorithm:
      sum = 0
      r = row
      while r > 0:
        c = col
        while c > 0:
          sum += tree[r][c]
          c = c - (c & -c)
        r = r - (r & -r)
      return sum

    Args:
      tree_2d: (tree, rows, cols) tuple
      row: 1-indexed row boundary
      col: 1-indexed column boundary

    Returns:
      Sum of rectangle (1,1) to (row, col)

    Time: O(log(rows) * log(cols))
    """
    val tree = tree_2d.0
    val rows = tree_2d.1
    val cols = tree_2d.2

    if row < 0:
        return 0
    if col < 0:
        return 0
    if row > rows:
        return prefix_sum_2d(tree_2d, rows, col)
    if col > cols:
        return prefix_sum_2d(tree_2d, row, cols)

    var sum = 0
    var r = row
    while r > 0:
        var c = col
        while c > 0:
            val row_data = tree[r]
            val value = row_data[c]
            sum = sum + value
            c = get_next(c)
        r = get_next(r)

    sum

# Query 2D range sum for rectangle (r1,c1) to (r2,c2)
fn range_sum_2d(tree_2d, r1: i64, c1: i64, r2: i64, c2: i64) -> i64:
    """Compute sum of rectangle from (r1,c1) to (r2,c2).

    Uses inclusion-exclusion principle:
      sum = prefix(r2,c2) - prefix(r1-1,c2) - prefix(r2,c1-1) + prefix(r1-1,c1-1)

    Args:
      tree_2d: (tree, rows, cols) tuple
      r1: Top row (1-indexed, inclusive)
      c1: Left column (1-indexed, inclusive)
      r2: Bottom row (1-indexed, inclusive)
      c2: Right column (1-indexed, inclusive)

    Returns:
      Sum of rectangle (r1,c1) to (r2,c2)

    Time: O(log(rows) * log(cols))

    Example:
      Matrix:
        1 2 3
        4 5 6
        7 8 9
      range_sum_2d(tree, 1, 1, 2, 2) = 1+2+4+5 = 12
    """
    if r1 > r2:
        return 0
    if c1 > c2:
        return 0
    if r1 < 1:
        return range_sum_2d(tree_2d, 1, c1, r2, c2)
    if c1 < 1:
        return range_sum_2d(tree_2d, r1, 1, r2, c2)

    val sum1 = prefix_sum_2d(tree_2d, r2, c2)
    val sum2 = prefix_sum_2d(tree_2d, r1 - 1, c2)
    val sum3 = prefix_sum_2d(tree_2d, r2, c1 - 1)
    val sum4 = prefix_sum_2d(tree_2d, r1 - 1, c1 - 1)

    sum1 - sum2 - sum3 + sum4

# Query single cell in 2D tree
fn query_2d(tree_2d, row: i64, col: i64) -> i64:
    """Query value at single cell (row, col).

    Time: O(log(rows) * log(cols))
    """
    range_sum_2d(tree_2d, row, col, row, col)
