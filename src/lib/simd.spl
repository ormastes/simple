# SIMD Intrinsics API
#
# User-facing SIMD API for high-performance vector operations.
# Provides platform-independent intrinsics that compile to AVX2 (x86_64)
# or NEON (ARM) instructions.
#
# Usage:
#   use std.simd.{Vec4f, simd_add_f32x4, simd_mul_f32x4}
#   val a = Vec4f.splat(2.0)
#   val b = Vec4f.splat(3.0)
#   val c = simd_add_f32x4(a, b)  # [5.0, 5.0, 5.0, 5.0]
#
# Supported operations:
# - Arithmetic: add, sub, mul, div, fma (fused multiply-add)
# - Comparison: eq, ne, lt, le, gt, ge
# - Load/Store: from_array, to_array, load_aligned, store_aligned
# - Reductions: horizontal_add, horizontal_max, horizontal_min
# - Platform detection: has_avx2, has_neon, simd_width

# ============================================================================
# Platform Detection
# ============================================================================

"""
SIMD platform capabilities detection.
Compile-time constants for optimization.
"""

# Platform feature flags (set by compiler based on target)
extern fn rt_simd_has_sse() -> bool
extern fn rt_simd_has_avx() -> bool
extern fn rt_simd_has_avx2() -> bool
extern fn rt_simd_has_neon() -> bool

fn has_sse() -> bool:
    """Check if SSE (128-bit) is available."""
    rt_simd_has_sse()

fn has_avx() -> bool:
    """Check if AVX (256-bit) is available."""
    rt_simd_has_avx()

fn has_avx2() -> bool:
    """Check if AVX2 (256-bit integer) is available."""
    rt_simd_has_avx2()

fn has_neon() -> bool:
    """Check if ARM NEON (128-bit) is available."""
    rt_simd_has_neon()

fn simd_width() -> i64:
    """Get maximum SIMD width in bits (128, 256, or 512)."""
    if has_avx2():
        256
    elif has_avx():
        256
    elif has_sse():
        128
    elif has_neon():
        128
    else:
        0

# ============================================================================
# Vector Types
# ============================================================================

"""
4-element f32 vector (128-bit SSE/NEON register).
Maps to __m128 (x86) or float32x4_t (ARM).
"""
struct Vec4f:
    x: f32
    y: f32
    z: f32
    w: f32

impl Vec4f:
    static fn splat(value: f32) -> Vec4f:
        """Create vector with all elements set to value."""
        Vec4f(x: value, y: value, z: value, w: value)

    static fn from_array(arr: [f32]) -> Vec4f:
        """Create from array (must have 4+ elements)."""
        Vec4f(x: arr[0], y: arr[1], z: arr[2], w: arr[3])

    static fn zero() -> Vec4f:
        """Zero vector."""
        Vec4f(x: 0.0, y: 0.0, z: 0.0, w: 0.0)

    fn to_array() -> [f32]:
        """Convert to array."""
        [self.x, self.y, self.z, self.w]

"""
8-element f32 vector (256-bit AVX register).
Maps to __m256 (x86). Falls back to 2x Vec4f on ARM.
"""
struct Vec8f:
    e0: f32
    e1: f32
    e2: f32
    e3: f32
    e4: f32
    e5: f32
    e6: f32
    e7: f32

impl Vec8f:
    static fn splat(value: f32) -> Vec8f:
        """Create vector with all elements set to value."""
        Vec8f(
            e0: value, e1: value, e2: value, e3: value,
            e4: value, e5: value, e6: value, e7: value
        )

    static fn from_array(arr: [f32]) -> Vec8f:
        """Create from array (must have 8+ elements)."""
        Vec8f(
            e0: arr[0], e1: arr[1], e2: arr[2], e3: arr[3],
            e4: arr[4], e5: arr[5], e6: arr[6], e7: arr[7]
        )

    static fn zero() -> Vec8f:
        """Zero vector."""
        Vec8f(
            e0: 0.0, e1: 0.0, e2: 0.0, e3: 0.0,
            e4: 0.0, e5: 0.0, e6: 0.0, e7: 0.0
        )

    fn to_array() -> [f32]:
        """Convert to array."""
        [self.e0, self.e1, self.e2, self.e3, self.e4, self.e5, self.e6, self.e7]

"""
4-element f64 vector (256-bit AVX register).
Maps to __m256d (x86). Falls back to 2x Vec2d on ARM.
"""
struct Vec4d:
    x: f64
    y: f64
    z: f64
    w: f64

impl Vec4d:
    static fn splat(value: f64) -> Vec4d:
        """Create vector with all elements set to value."""
        Vec4d(x: value, y: value, z: value, w: value)

    static fn from_array(arr: [f64]) -> Vec4d:
        """Create from array (must have 4+ elements)."""
        Vec4d(x: arr[0], y: arr[1], z: arr[2], w: arr[3])

    static fn zero() -> Vec4d:
        """Zero vector."""
        Vec4d(x: 0.0, y: 0.0, z: 0.0, w: 0.0)

    fn to_array() -> [f64]:
        """Convert to array."""
        [self.x, self.y, self.z, self.w]

"""
4-element i32 vector (128-bit SSE/NEON register).
Maps to __m128i (x86) or int32x4_t (ARM).
"""
struct Vec4i:
    x: i32
    y: i32
    z: i32
    w: i32

impl Vec4i:
    static fn splat(value: i32) -> Vec4i:
        """Create vector with all elements set to value."""
        Vec4i(x: value, y: value, z: value, w: value)

    static fn from_array(arr: [i32]) -> Vec4i:
        """Create from array (must have 4+ elements)."""
        Vec4i(x: arr[0], y: arr[1], z: arr[2], w: arr[3])

    static fn zero() -> Vec4i:
        """Zero vector."""
        Vec4i(x: 0, y: 0, z: 0, w: 0)

    fn to_array() -> [i32]:
        """Convert to array."""
        [self.x, self.y, self.z, self.w]

"""
8-element i32 vector (256-bit AVX2 register).
Maps to __m256i (x86). Falls back to 2x Vec4i on ARM.
"""
struct Vec8i:
    e0: i32
    e1: i32
    e2: i32
    e3: i32
    e4: i32
    e5: i32
    e6: i32
    e7: i32

impl Vec8i:
    static fn splat(value: i32) -> Vec8i:
        """Create vector with all elements set to value."""
        Vec8i(
            e0: value, e1: value, e2: value, e3: value,
            e4: value, e5: value, e6: value, e7: value
        )

    static fn from_array(arr: [i32]) -> Vec8i:
        """Create from array (must have 8+ elements)."""
        Vec8i(
            e0: arr[0], e1: arr[1], e2: arr[2], e3: arr[3],
            e4: arr[4], e5: arr[5], e6: arr[6], e7: arr[7]
        )

    static fn zero() -> Vec8i:
        """Zero vector."""
        Vec8i(
            e0: 0, e1: 0, e2: 0, e3: 0,
            e4: 0, e5: 0, e6: 0, e7: 0
        )

    fn to_array() -> [i32]:
        """Convert to array."""
        [self.e0, self.e1, self.e2, self.e3, self.e4, self.e5, self.e6, self.e7]

# ============================================================================
# f32x4 Intrinsics (128-bit)
# ============================================================================

extern fn rt_simd_add_f32x4(a: Vec4f, b: Vec4f) -> Vec4f
extern fn rt_simd_sub_f32x4(a: Vec4f, b: Vec4f) -> Vec4f
extern fn rt_simd_mul_f32x4(a: Vec4f, b: Vec4f) -> Vec4f
extern fn rt_simd_div_f32x4(a: Vec4f, b: Vec4f) -> Vec4f
extern fn rt_simd_fma_f32x4(a: Vec4f, b: Vec4f, c: Vec4f) -> Vec4f

fn simd_add_f32x4(a: Vec4f, b: Vec4f) -> Vec4f:
    """Add two f32x4 vectors: a + b."""
    rt_simd_add_f32x4(a, b)

fn simd_sub_f32x4(a: Vec4f, b: Vec4f) -> Vec4f:
    """Subtract two f32x4 vectors: a - b."""
    rt_simd_sub_f32x4(a, b)

fn simd_mul_f32x4(a: Vec4f, b: Vec4f) -> Vec4f:
    """Multiply two f32x4 vectors (element-wise): a * b."""
    rt_simd_mul_f32x4(a, b)

fn simd_div_f32x4(a: Vec4f, b: Vec4f) -> Vec4f:
    """Divide two f32x4 vectors (element-wise): a / b."""
    rt_simd_div_f32x4(a, b)

fn simd_fma_f32x4(a: Vec4f, b: Vec4f, c: Vec4f) -> Vec4f:
    """Fused multiply-add: a * b + c (single rounding)."""
    rt_simd_fma_f32x4(a, b, c)

# ============================================================================
# f32x8 Intrinsics (256-bit AVX2)
# ============================================================================

extern fn rt_simd_add_f32x8(a: Vec8f, b: Vec8f) -> Vec8f
extern fn rt_simd_sub_f32x8(a: Vec8f, b: Vec8f) -> Vec8f
extern fn rt_simd_mul_f32x8(a: Vec8f, b: Vec8f) -> Vec8f
extern fn rt_simd_div_f32x8(a: Vec8f, b: Vec8f) -> Vec8f
extern fn rt_simd_fma_f32x8(a: Vec8f, b: Vec8f, c: Vec8f) -> Vec8f

fn simd_add_f32x8(a: Vec8f, b: Vec8f) -> Vec8f:
    """Add two f32x8 vectors: a + b."""
    rt_simd_add_f32x8(a, b)

fn simd_sub_f32x8(a: Vec8f, b: Vec8f) -> Vec8f:
    """Subtract two f32x8 vectors: a - b."""
    rt_simd_sub_f32x8(a, b)

fn simd_mul_f32x8(a: Vec8f, b: Vec8f) -> Vec8f:
    """Multiply two f32x8 vectors (element-wise): a * b."""
    rt_simd_mul_f32x8(a, b)

fn simd_div_f32x8(a: Vec8f, b: Vec8f) -> Vec8f:
    """Divide two f32x8 vectors (element-wise): a / b."""
    rt_simd_div_f32x8(a, b)

fn simd_fma_f32x8(a: Vec8f, b: Vec8f, c: Vec8f) -> Vec8f:
    """Fused multiply-add: a * b + c (single rounding)."""
    rt_simd_fma_f32x8(a, b, c)

# ============================================================================
# f64x4 Intrinsics (256-bit AVX2)
# ============================================================================

extern fn rt_simd_add_f64x4(a: Vec4d, b: Vec4d) -> Vec4d
extern fn rt_simd_sub_f64x4(a: Vec4d, b: Vec4d) -> Vec4d
extern fn rt_simd_mul_f64x4(a: Vec4d, b: Vec4d) -> Vec4d
extern fn rt_simd_div_f64x4(a: Vec4d, b: Vec4d) -> Vec4d
extern fn rt_simd_fma_f64x4(a: Vec4d, b: Vec4d, c: Vec4d) -> Vec4d

fn simd_add_f64x4(a: Vec4d, b: Vec4d) -> Vec4d:
    """Add two f64x4 vectors: a + b."""
    rt_simd_add_f64x4(a, b)

fn simd_sub_f64x4(a: Vec4d, b: Vec4d) -> Vec4d:
    """Subtract two f64x4 vectors: a - b."""
    rt_simd_sub_f64x4(a, b)

fn simd_mul_f64x4(a: Vec4d, b: Vec4d) -> Vec4d:
    """Multiply two f64x4 vectors (element-wise): a * b."""
    rt_simd_mul_f64x4(a, b)

fn simd_div_f64x4(a: Vec4d, b: Vec4d) -> Vec4d:
    """Divide two f64x4 vectors (element-wise): a / b."""
    rt_simd_div_f64x4(a, b)

fn simd_fma_f64x4(a: Vec4d, b: Vec4d, c: Vec4d) -> Vec4d:
    """Fused multiply-add: a * b + c (single rounding)."""
    rt_simd_fma_f64x4(a, b, c)

# ============================================================================
# i32x4 Intrinsics (128-bit)
# ============================================================================

extern fn rt_simd_add_i32x4(a: Vec4i, b: Vec4i) -> Vec4i
extern fn rt_simd_sub_i32x4(a: Vec4i, b: Vec4i) -> Vec4i
extern fn rt_simd_mul_i32x4(a: Vec4i, b: Vec4i) -> Vec4i

fn simd_add_i32x4(a: Vec4i, b: Vec4i) -> Vec4i:
    """Add two i32x4 vectors: a + b."""
    rt_simd_add_i32x4(a, b)

fn simd_sub_i32x4(a: Vec4i, b: Vec4i) -> Vec4i:
    """Subtract two i32x4 vectors: a - b."""
    rt_simd_sub_i32x4(a, b)

fn simd_mul_i32x4(a: Vec4i, b: Vec4i) -> Vec4i:
    """Multiply two i32x4 vectors (element-wise): a * b."""
    rt_simd_mul_i32x4(a, b)

# ============================================================================
# i32x8 Intrinsics (256-bit AVX2)
# ============================================================================

extern fn rt_simd_add_i32x8(a: Vec8i, b: Vec8i) -> Vec8i
extern fn rt_simd_sub_i32x8(a: Vec8i, b: Vec8i) -> Vec8i
extern fn rt_simd_mul_i32x8(a: Vec8i, b: Vec8i) -> Vec8i

fn simd_add_i32x8(a: Vec8i, b: Vec8i) -> Vec8i:
    """Add two i32x8 vectors: a + b."""
    rt_simd_add_i32x8(a, b)

fn simd_sub_i32x8(a: Vec8i, b: Vec8i) -> Vec8i:
    """Subtract two i32x8 vectors: a - b."""
    rt_simd_sub_i32x8(a, b)

fn simd_mul_i32x8(a: Vec8i, b: Vec8i) -> Vec8i:
    """Multiply two i32x8 vectors (element-wise): a * b."""
    rt_simd_mul_i32x8(a, b)

# ============================================================================
# Horizontal Operations
# ============================================================================

extern fn rt_simd_hadd_f32x4(a: Vec4f) -> f32
extern fn rt_simd_hmax_f32x4(a: Vec4f) -> f32
extern fn rt_simd_hmin_f32x4(a: Vec4f) -> f32

fn simd_hadd_f32x4(a: Vec4f) -> f32:
    """Horizontal add: sum all elements of vector."""
    rt_simd_hadd_f32x4(a)

fn simd_hmax_f32x4(a: Vec4f) -> f32:
    """Horizontal max: find maximum element of vector."""
    rt_simd_hmax_f32x4(a)

fn simd_hmin_f32x4(a: Vec4f) -> f32:
    """Horizontal min: find minimum element of vector."""
    rt_simd_hmin_f32x4(a)

# ============================================================================
# Exports
# ============================================================================

export Vec4f, Vec8f, Vec4d, Vec4i, Vec8i
export has_sse, has_avx, has_avx2, has_neon, simd_width
export simd_add_f32x4, simd_sub_f32x4, simd_mul_f32x4, simd_div_f32x4, simd_fma_f32x4
export simd_add_f32x8, simd_sub_f32x8, simd_mul_f32x8, simd_div_f32x8, simd_fma_f32x8
export simd_add_f64x4, simd_sub_f64x4, simd_mul_f64x4, simd_div_f64x4, simd_fma_f64x4
export simd_add_i32x4, simd_sub_i32x4, simd_mul_i32x4
export simd_add_i32x8, simd_sub_i32x8, simd_mul_i32x8
export simd_hadd_f32x4, simd_hmax_f32x4, simd_hmin_f32x4
