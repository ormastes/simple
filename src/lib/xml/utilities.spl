# XML Utilities Module
# Provides utility functions for XML processing including entity encoding,
# document creation, cloning, comparison, and transformation operations

# =============================================================================
# Entity Encoding/Decoding
# =============================================================================

fn xml_encode_entities(text_val: text) -> text:
    # Encode XML entities
    var result = text_val
    result = result.replace("&", "&amp;")
    result = result.replace("<", "&lt;")
    result = result.replace(">", "&gt;")
    result = result.replace("\"", "&quot;")
    result = result.replace("'", "&apos;")
    result

fn xml_decode_entities(text_val: text) -> text:
    # Decode XML entities
    var result = text_val
    result = result.replace("&lt;", "<")
    result = result.replace("&gt;", ">")
    result = result.replace("&quot;", "\"")
    result = result.replace("&apos;", "'")
    result = result.replace("&amp;", "&")
    result

fn xml_encode_attr_value(text_val: text) -> text:
    # Encode attribute value (includes quotes)
    xml_encode_entities(text_val)

fn xml_decode_attr_value(text_val: text) -> text:
    # Decode attribute value
    xml_decode_entities(text_val)

# =============================================================================
# Document Creation Utilities
# =============================================================================

fn xml_create_cdata(content: text) -> text:
    # Create CDATA section
    "<![CDATA[" + content + "]]>"

fn xml_create_comment(content: text) -> text:
    # Create XML comment
    "<!-- " + content + " -->"

fn xml_create_processing_instruction(target: text, data: text) -> text:
    # Create processing instruction
    "<?" + target + " " + data + "?>"

fn xml_create_declaration(version: text, encoding: text, standalone: text) -> text:
    # Create XML declaration
    var decl = "<?xml version=\"" + version + "\""

    if encoding.len() > 0:
        decl = decl + " encoding=\"" + encoding + "\""

    if standalone.len() > 0:
        decl = decl + " standalone=\"" + standalone + "\""

    decl = decl + "?>"
    decl

# =============================================================================
# Element Operations
# =============================================================================

fn xml_clone(element: tuple) -> tuple:
    # Deep clone an element
    val tag = xml_get_tag(element)
    val attrs = xml_get_attributes(element)
    val text_val = xml_get_text(element)
    val children = xml_get_children(element)

    # Clone attributes
    var cloned_attrs = []
    var i = 0
    val attr_len = attrs.len()

    while i < attr_len:
        val attr = attrs[i]
        cloned_attrs = cloned_attrs.append(attr)
        i = i + 1

    # Clone children
    var cloned_children = []
    var j = 0
    val child_len = children.len()

    while j < child_len:
        val child = children[j]
        val cloned_child = xml_clone(child)
        cloned_children = cloned_children.append(cloned_child)
        j = j + 1

    xml_element(tag, cloned_attrs, cloned_children, text_val)

fn xml_equals(elem1: tuple, elem2: tuple) -> bool:
    # Compare two elements for equality
    val tag1 = xml_get_tag(elem1)
    val tag2 = xml_get_tag(elem2)

    if tag1 != tag2:
        return false

    val text1 = xml_get_text(elem1)
    val text2 = xml_get_text(elem2)

    if text1 != text2:
        return false

    val attrs1 = xml_get_attributes(elem1)
    val attrs2 = xml_get_attributes(elem2)

    if attrs1.len() != attrs2.len():
        return false

    val children1 = xml_get_children(elem1)
    val children2 = xml_get_children(elem2)

    if children1.len() != children2.len():
        return false

    # Compare children
    var i = 0
    val len = children1.len()

    while i < len:
        val child1 = children1[i]
        val child2 = children2[i]
        val are_equal = xml_equals(child1, child2)

        if not are_equal:
            return false

        i = i + 1

    true

fn xml_get_depth(element: tuple) -> i64:
    # Get maximum depth of element tree
    val children = xml_get_children(element)
    var max_depth = 0
    var i = 0
    val len = children.len()

    while i < len:
        val child = children[i]
        val child_depth = xml_get_depth(child)

        if child_depth > max_depth:
            max_depth = child_depth

        i = i + 1

    max_depth + 1

fn xml_count_elements(element: tuple) -> i64:
    # Count total number of elements in tree
    var count = 1
    val children = xml_get_children(element)
    var i = 0
    val len = children.len()

    while i < len:
        val child = children[i]
        val child_count = xml_count_elements(child)
        count = count + child_count
        i = i + 1

    count

# =============================================================================
# Tree Navigation
# =============================================================================

fn xml_get_parent_map(root: tuple) -> list:
    # Build a mapping of child to parent relationships
    # Returns list of (child, parent) tuples
    var map = []
    val children = xml_get_children(root)
    var i = 0
    val len = children.len()

    while i < len:
        val child = children[i]
        map = map.append((child, root))

        # Recursively process children
        val child_map = xml_get_parent_map(child)
        var j = 0
        val child_len = child_map.len()

        while j < child_len:
            map = map.append(child_map[j])
            j = j + 1

        i = i + 1

    map

fn xml_get_siblings(element: tuple, parent: tuple) -> list:
    # Get all sibling elements (excluding the element itself)
    var siblings = []
    val children = xml_get_children(parent)
    var i = 0
    val len = children.len()

    while i < len:
        val child = children[i]
        if not xml_equals(child, element):
            siblings = siblings.append(child)
        i = i + 1

    siblings

fn xml_get_next_sibling(element: tuple, parent: tuple) -> tuple:
    # Get the next sibling element
    val children = xml_get_children(parent)
    var i = 0
    val len = children.len()
    var found = false

    while i < len:
        val child = children[i]
        if found:
            return child
        if xml_equals(child, element):
            found = true
        i = i + 1

    xml_element_simple("")

fn xml_get_prev_sibling(element: tuple, parent: tuple) -> tuple:
    # Get the previous sibling element
    val children = xml_get_children(parent)
    var prev = xml_element_simple("")
    var i = 0
    val len = children.len()

    while i < len:
        val child = children[i]
        if xml_equals(child, element):
            return prev
        prev = child
        i = i + 1

    xml_element_simple("")

fn xml_insert_before(parent: tuple, new_child: tuple, ref_child: tuple) -> tuple:
    # Insert new child before reference child
    val children = xml_get_children(parent)
    var new_children = []
    var i = 0
    val len = children.len()

    while i < len:
        val child = children[i]
        if xml_equals(child, ref_child):
            new_children = new_children.append(new_child)
        new_children = new_children.append(child)
        i = i + 1

    xml_set_children(parent, new_children)

fn xml_insert_after(parent: tuple, new_child: tuple, ref_child: tuple) -> tuple:
    # Insert new child after reference child
    val children = xml_get_children(parent)
    var new_children = []
    var i = 0
    val len = children.len()

    while i < len:
        val child = children[i]
        new_children = new_children.append(child)
        if xml_equals(child, ref_child):
            new_children = new_children.append(new_child)
        i = i + 1

    xml_set_children(parent, new_children)

fn xml_replace_element(parent: tuple, old_elem: tuple, new_elem: tuple) -> tuple:
    # Replace old element with new element
    val children = xml_get_children(parent)
    var new_children = []
    var i = 0
    val len = children.len()

    while i < len:
        val child = children[i]
        if xml_equals(child, old_elem):
            new_children = new_children.append(new_elem)
        else:
            new_children = new_children.append(child)
        i = i + 1

    xml_set_children(parent, new_children)

fn xml_is_ancestor(ancestor: tuple, descendant: tuple) -> bool:
    # Check if ancestor is an ancestor of descendant
    val descendants = xml_get_descendants(ancestor)
    var i = 0
    val len = descendants.len()

    while i < len:
        val desc = descendants[i]
        if xml_equals(desc, descendant):
            return true
        i = i + 1

    false

# =============================================================================
# Advanced Queries
# =============================================================================

fn xml_get_attribute_value_or_default(element: tuple, attr_name: text, default_value: text) -> text:
    # Get attribute value with default fallback
    val value = xml_get_attr(element, attr_name)
    if value.len() == 0:
        return default_value
    value

fn xml_has_child_with_tag(element: tuple, tag_name: text) -> bool:
    # Check if element has a direct child with specified tag
    val children = xml_get_children(element)
    var i = 0
    val len = children.len()

    while i < len:
        val child = children[i]
        val child_tag = xml_get_tag(child)
        if child_tag == tag_name:
            return true
        i = i + 1

    false

fn xml_count_children_with_tag(element: tuple, tag_name: text) -> i64:
    # Count direct children with specified tag
    val children = xml_get_children(element)
    var count = 0
    var i = 0
    val len = children.len()

    while i < len:
        val child = children[i]
        val child_tag = xml_get_tag(child)
        if child_tag == tag_name:
            count = count + 1
        i = i + 1

    count

# =============================================================================
# Transformation Operations
# =============================================================================

fn xml_merge_attributes(elem1: tuple, elem2: tuple) -> tuple:
    # Merge attributes from elem2 into elem1 (elem2 takes precedence)
    var result = elem1
    val attrs2 = xml_get_attributes(elem2)
    var i = 0
    val len = attrs2.len()

    while i < len:
        val attr = attrs2[i]
        val name = attr.0
        val value = attr.1
        result = xml_set_attr(result, name, value)
        i = i + 1

    result

fn xml_strip_attributes(element: tuple) -> tuple:
    # Remove all attributes from element and its descendants
    var result = xml_clear_attrs(element)
    val children = xml_get_children(result)
    var new_children = []
    var i = 0
    val len = children.len()

    while i < len:
        val child = children[i]
        val stripped_child = xml_strip_attributes(child)
        new_children = new_children.append(stripped_child)
        i = i + 1

    xml_set_children(result, new_children)

fn xml_normalize_text(element: tuple) -> tuple:
    # Normalize whitespace in all text content
    val text_val = xml_get_text(element)
    var normalized = text_val.trim()
    normalized = normalized.replace("\n", " ")
    normalized = normalized.replace("\r", " ")
    normalized = normalized.replace("\t", " ")

    # Collapse multiple spaces
    while normalized.contains("  "):
        normalized = normalized.replace("  ", " ")

    var result = xml_set_text(element, normalized)

    # Recursively normalize children
    val children = xml_get_children(result)
    var new_children = []
    var i = 0
    val len = children.len()

    while i < len:
        val child = children[i]
        val normalized_child = xml_normalize_text(child)
        new_children = new_children.append(normalized_child)
        i = i + 1

    xml_set_children(result, new_children)

fn xml_compact(element: tuple) -> tuple:
    # Remove empty text nodes and normalize whitespace
    var result = element
    val text_val = xml_get_text(result)
    val trimmed = text_val.trim()

    if trimmed.len() == 0:
        result = xml_set_text(result, "")

    # Process children
    val children = xml_get_children(result)
    var new_children = []
    var i = 0
    val len = children.len()

    while i < len:
        val child = children[i]
        val compacted_child = xml_compact(child)

        # Only add if not empty
        val child_text = xml_get_text(compacted_child)
        val has_kids = xml_has_children(compacted_child)

        if child_text.len() > 0 or has_kids:
            new_children = new_children.append(compacted_child)

        i = i + 1

    xml_set_children(result, new_children)

fn xml_reverse_children(element: tuple) -> tuple:
    # Reverse the order of children
    val children = xml_get_children(element)
    var reversed = []
    var i = children.len() - 1

    while i >= 0:
        reversed = reversed.append(children[i])
        i = i - 1

    xml_set_children(element, reversed)

fn xml_sort_children_by_tag(element: tuple) -> tuple:
    # Sort children alphabetically by tag name (simple bubble sort)
    val children = xml_get_children(element)
    var sorted = children
    val len = sorted.len()
    var i = 0

    while i < len:
        var j = 0
        while j < len - i - 1:
            val tag1 = xml_get_tag(sorted[j])
            val tag2 = xml_get_tag(sorted[j + 1])

            if tag1 > tag2:
                val temp = sorted[j]
                sorted[j] = sorted[j + 1]
                sorted[j + 1] = temp

            j = j + 1
        i = i + 1

    xml_set_children(element, sorted)

fn xml_flatten(element: tuple) -> list:
    # Flatten element tree to list of elements
    var result = [element]
    val descendants = xml_get_descendants(element)
    var i = 0
    val len = descendants.len()

    while i < len:
        result = result.append(descendants[i])
        i = i + 1

    result

# =============================================================================
# Helper Functions (from other modules)
# =============================================================================

fn xml_get_tag(element: tuple) -> text:
    element.0

fn xml_get_attributes(element: tuple) -> list:
    element.1

fn xml_get_children(element: tuple) -> list:
    element.2

fn xml_get_text(element: tuple) -> text:
    element.3

fn xml_element(tag: text, attributes: list, children: list, text_content: text) -> tuple:
    (tag, attributes, children, text_content)

fn xml_element_simple(tag: text) -> tuple:
    val empty_attrs = []
    val empty_children = []
    xml_element(tag, empty_attrs, empty_children, "")

fn xml_set_children(element: tuple, new_children: list) -> tuple:
    val tag = xml_get_tag(element)
    val attrs = xml_get_attributes(element)
    val text_val = xml_get_text(element)
    xml_element(tag, attrs, new_children, text_val)

fn xml_set_text(element: tuple, new_text: text) -> tuple:
    val tag = xml_get_tag(element)
    val attrs = xml_get_attributes(element)
    val children = xml_get_children(element)
    xml_element(tag, attrs, children, new_text)

fn xml_has_children(element: tuple) -> bool:
    val count = xml_get_child_count(element)
    count > 0

fn xml_get_child_count(element: tuple) -> i64:
    val children = xml_get_children(element)
    children.len()

fn xml_get_descendants(element: tuple) -> list:
    var results = []
    val children = xml_get_children(element)
    var i = 0
    val len = children.len()

    while i < len:
        val child = children[i]
        results = results.append(child)

        val child_descendants = xml_get_descendants(child)
        var j = 0
        val desc_len = child_descendants.len()

        while j < desc_len:
            results = results.append(child_descendants[j])
            j = j + 1

        i = i + 1

    results

fn xml_get_attr(element: tuple, attr_name: text) -> text:
    val attrs = xml_get_attributes(element)
    var result = ""
    var i = 0
    val len = attrs.len()
    var found = false

    while i < len and not found:
        val attr = attrs[i]
        val name = attr.0
        val value = attr.1
        if name == attr_name:
            result = value
            found = true
        i = i + 1

    result

fn xml_set_attr(element: tuple, attr_name: text, attr_value: text) -> tuple:
    val old_attrs = xml_get_attributes(element)
    var new_attrs = []
    var i = 0
    val len = old_attrs.len()
    var found = false

    while i < len:
        val attr = old_attrs[i]
        val name = attr.0
        val value = attr.1
        if name == attr_name:
            new_attrs = new_attrs.append((attr_name, attr_value))
            found = true
        else:
            new_attrs = new_attrs.append(attr)
        i = i + 1

    if not found:
        new_attrs = new_attrs.append((attr_name, attr_value))

    xml_set_attributes(element, new_attrs)

fn xml_set_attributes(element: tuple, new_attrs: list) -> tuple:
    val tag = xml_get_tag(element)
    val children = xml_get_children(element)
    val text_val = xml_get_text(element)
    xml_element(tag, new_attrs, children, text_val)

fn xml_clear_attrs(element: tuple) -> tuple:
    val empty_attrs = []
    xml_set_attributes(element, empty_attrs)
