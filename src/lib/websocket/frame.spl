# WebSocket Frame Module
# Implements frame encoding, decoding, masking, and parsing

from std.websocket.types import OPCODE_TEXT
from std.websocket.types import OPCODE_BINARY
from std.websocket.types import OPCODE_CONTINUATION
from std.websocket.types import OPCODE_PING
from std.websocket.types import OPCODE_PONG
from std.websocket.types import OPCODE_CLOSE
from std.websocket.types import FIN_BIT
from std.websocket.types import MASK_BIT
from std.websocket.types import OPCODE_MASK
from std.websocket.types import PAYLOAD_LEN_MASK
from std.websocket.types import PAYLOAD_LEN_EXTENDED_16
from std.websocket.types import PAYLOAD_LEN_EXTENDED_64
from std.websocket.handshake import text_to_bytes

# ==============================================================================
# Masking Functions
# ==============================================================================

fn generate_masking_key() -> List<i64>:
    val time = Platform.timestamp()
    val seed = time % 256

    val key1 = (seed * 37) % 256
    val key2 = (seed * 73) % 256
    val key3 = (seed * 109) % 256
    val key4 = (seed * 157) % 256

    [key1, key2, key3, key4]

fn mask_payload(payload: List<i64>, mask_key: List<i64>) -> List<i64>:
    val result = []
    val len = payload.length()
    var i = 0

    while i < len:
        val byte = payload.at(i)
        val key_byte = mask_key.at(i % 4)
        val masked = byte ^ key_byte
        result.push(masked)
        i = i + 1

    result

fn unmask_payload(payload: List<i64>, mask_key: List<i64>) -> List<i64>:
    mask_payload(payload, mask_key)

# ==============================================================================
# Frame Creation
# ==============================================================================

fn create_frame(is_final: i64, opcode: i64, is_masked: i64, payload: List<i64>, mask_key: List<i64>) -> List<i64>:
    val result = []

    # First byte: FIN + RSV + opcode
    val fin_bit = if is_final == 1: FIN_BIT else: 0
    val byte1 = fin_bit | opcode
    result.push(byte1)

    # Second byte: MASK + payload length
    val payload_len = payload.length()
    val mask_bit = if is_masked == 1: MASK_BIT else: 0

    if payload_len < PAYLOAD_LEN_EXTENDED_16:
        val byte2 = mask_bit | payload_len
        result.push(byte2)
    else:
        if payload_len < 65536:
            val byte2 = mask_bit | PAYLOAD_LEN_EXTENDED_16
            result.push(byte2)
            val len_hi = (payload_len >> 8) & 0xFF
            val len_lo = payload_len & 0xFF
            result.push(len_hi)
            result.push(len_lo)
        else:
            val byte2 = mask_bit | PAYLOAD_LEN_EXTENDED_64
            result.push(byte2)
            # 64-bit length (we only support up to 32-bit)
            result.push(0)
            result.push(0)
            result.push(0)
            result.push(0)
            val len_b3 = (payload_len >> 24) & 0xFF
            val len_b2 = (payload_len >> 16) & 0xFF
            val len_b1 = (payload_len >> 8) & 0xFF
            val len_b0 = payload_len & 0xFF
            result.push(len_b3)
            result.push(len_b2)
            result.push(len_b1)
            result.push(len_b0)

    # Masking key (if masked)
    if is_masked == 1:
        result.push(mask_key.at(0))
        result.push(mask_key.at(1))
        result.push(mask_key.at(2))
        result.push(mask_key.at(3))

        # Masked payload
        val masked_payload = mask_payload(payload, mask_key)
        var i = 0
        while i < payload_len:
            result.push(masked_payload.at(i))
            i = i + 1
    else:
        # Unmasked payload
        var i = 0
        while i < payload_len:
            result.push(payload.at(i))
            i = i + 1

    result

fn create_text_frame(text_data: text, is_final: i64, is_masked: i64) -> List<i64>:
    val payload = text_to_bytes(text_data)
    val mask_key = if is_masked == 1: generate_masking_key() else: []
    create_frame(is_final, OPCODE_TEXT, is_masked, payload, mask_key)

fn create_binary_frame(data: List<i64>, is_final: i64, is_masked: i64) -> List<i64>:
    val mask_key = if is_masked == 1: generate_masking_key() else: []
    create_frame(is_final, OPCODE_BINARY, is_masked, data, mask_key)

fn create_continuation_frame(data: List<i64>, is_final: i64, is_masked: i64) -> List<i64>:
    val mask_key = if is_masked == 1: generate_masking_key() else: []
    create_frame(is_final, OPCODE_CONTINUATION, is_masked, data, mask_key)

fn create_ping_frame(data: List<i64>, is_masked: i64) -> List<i64>:
    val mask_key = if is_masked == 1: generate_masking_key() else: []
    create_frame(1, OPCODE_PING, is_masked, data, mask_key)

fn create_pong_frame(data: List<i64>, is_masked: i64) -> List<i64>:
    val mask_key = if is_masked == 1: generate_masking_key() else: []
    create_frame(1, OPCODE_PONG, is_masked, data, mask_key)

fn create_text_frame_from_bytes(payload: List<i64>, is_final: i64, is_masked: i64) -> List<i64>:
    val mask_key = if is_masked == 1: generate_masking_key() else: []
    create_frame(is_final, OPCODE_TEXT, is_masked, payload, mask_key)

fn create_ping_text(text_data: text, is_masked: i64) -> List<i64>:
    val payload = text_to_bytes(text_data)
    create_ping_frame(payload, is_masked)

fn create_pong_text(text_data: text, is_masked: i64) -> List<i64>:
    val payload = text_to_bytes(text_data)
    create_pong_frame(payload, is_masked)

fn create_pong_response(ping_payload: List<i64>, is_masked: i64) -> List<i64>:
    create_pong_frame(ping_payload, is_masked)

# ==============================================================================
# Frame Parsing
# ==============================================================================

fn parse_frame_header(data: List<i64>) -> List<i64>:
    val len = data.length()
    if len < 2:
        return []

    val byte1 = data.at(0)
    val byte2 = data.at(1)

    val fin = if (byte1 & FIN_BIT) != 0: 1 else: 0
    val opcode = byte1 & OPCODE_MASK
    val masked = if (byte2 & MASK_BIT) != 0: 1 else: 0
    val payload_len_initial = byte2 & PAYLOAD_LEN_MASK

    var header_size = 2
    var payload_length = payload_len_initial

    if payload_len_initial == PAYLOAD_LEN_EXTENDED_16:
        if len < 4:
            return []
        val len_hi = data.at(2)
        val len_lo = data.at(3)
        payload_length = (len_hi << 8) | len_lo
        header_size = 4
    else:
        if payload_len_initial == PAYLOAD_LEN_EXTENDED_64:
            if len < 10:
                return []
            val len_b3 = data.at(6)
            val len_b2 = data.at(7)
            val len_b1 = data.at(8)
            val len_b0 = data.at(9)
            payload_length = (len_b3 << 24) | (len_b2 << 16) | (len_b1 << 8) | len_b0
            header_size = 10

    if masked == 1:
        header_size = header_size + 4

    [fin, opcode, masked, payload_length, header_size]

fn extract_mask_key(data: List<i64>, header_size: i64, is_masked: i64) -> List<i64>:
    if is_masked == 0:
        return []

    val offset = header_size - 4
    val k0 = data.at(offset)
    val k1 = data.at(offset + 1)
    val k2 = data.at(offset + 2)
    val k3 = data.at(offset + 3)

    [k0, k1, k2, k3]

fn extract_payload(data: List<i64>, header_size: i64, payload_length: i64, mask_key: List<i64>) -> List<i64>:
    val result = []
    var i = 0

    while i < payload_length:
        val offset = header_size + i
        if offset < data.length():
            val byte = data.at(offset)
            result.push(byte)
        i = i + 1

    if mask_key.length() == 4:
        unmask_payload(result, mask_key)
    else:
        result

fn parse_frame(data: List<i64>) -> List<i64>:
    val header = parse_frame_header(data)
    if header.length() == 0:
        return []

    val fin = header.at(0)
    val opcode = header.at(1)
    val masked = header.at(2)
    val payload_length = header.at(3)
    val header_size = header.at(4)

    val total_size = header_size + payload_length
    if data.length() < total_size:
        return []

    val mask_key = extract_mask_key(data, header_size, masked)
    val payload = extract_payload(data, header_size, payload_length, mask_key)

    [fin, opcode, masked, payload_length, total_size]

fn get_frame_payload(data: List<i64>, header_size: i64, payload_length: i64, mask_key: List<i64>) -> List<i64>:
    extract_payload(data, header_size, payload_length, mask_key)

fn get_frame_metadata(data: List<i64>) -> List<i64>:
    parse_frame_header(data)

fn has_complete_frame(data: List<i64>) -> i64:
    val header = parse_frame_header(data)
    if header.length() == 0:
        return 0

    val payload_length = header.at(3)
    val header_size = header.at(4)
    val required_size = header_size + payload_length

    if data.length() >= required_size: 1 else: 0

fn required_bytes_for_frame(data: List<i64>) -> i64:
    val header = parse_frame_header(data)
    if header.length() == 0:
        return 2

    val payload_length = header.at(3)
    val header_size = header.at(4)
    val required_size = header_size + payload_length
    val current_size = data.length()

    if current_size >= required_size:
        0
    else:
        required_size - current_size
