# HTTP Utility Functions
#
# Provides utility functions for HTTP processing including
# authentication helpers and base64 encoding/decoding.

import common from "std/http/common"

# ============================================================================
# Authentication Helpers
# ============================================================================

# Parse Basic Authentication header
# Returns: (username, password) or nil if invalid
fn parse_basic_auth(header: text) -> tuple:
    if not header.starts_with("Basic "):
        return nil

    val encoded = header.substring(6, header.length())

    # In real implementation, would base64 decode
    # For now, simplified version
    val decoded = base64_decode_simple(encoded)

    val colon_pos = decoded.index_of(":")

    if colon_pos < 0:
        return nil

    val username = decoded.substring(0, colon_pos)
    val password = decoded.substring(colon_pos + 1, decoded.length())

    return (username, password)

# Build Basic Authentication header value
fn build_basic_auth(username: text, password: text) -> text:
    var credentials = username
    credentials = credentials + ":"
    credentials = credentials + password

    val encoded = base64_encode_simple(credentials)

    var result = "Basic "
    result = result + encoded

    return result

# Parse Bearer token from Authorization header
fn parse_bearer_token(header: text) -> text:
    if not header.starts_with("Bearer "):
        return nil

    return header.substring(7, header.length())

# Build Bearer Authorization header value
fn build_bearer_auth(token: text) -> text:
    var result = "Bearer "
    result = result + token
    return result

# ============================================================================
# Base64 Encoding/Decoding
# ============================================================================

# Base64 encoding (RFC 4648 standard)
fn base64_encode_simple(input: text) -> text:
    var alphabet = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"
    var result = ""
    var i = 0
    var input_len = input.length()

    while i < input_len:
        var b0 = input.char_code_at(i)
        var b1 = 0
        var b2 = 0
        var has_b1 = false
        var has_b2 = false

        if i + 1 < input_len:
            b1 = input.char_code_at(i + 1)
            has_b1 = true
        if i + 2 < input_len:
            b2 = input.char_code_at(i + 2)
            has_b2 = true

        # First 6 bits of b0
        var idx0 = (b0 >> 2) & 63
        result = result + alphabet.substring(idx0, idx0 + 1)

        # Last 2 bits of b0 + first 4 bits of b1
        var idx1 = ((b0 & 3) << 4) | ((b1 >> 4) & 15)
        result = result + alphabet.substring(idx1, idx1 + 1)

        # Last 4 bits of b1 + first 2 bits of b2
        if has_b1:
            var idx2 = ((b1 & 15) << 2) | ((b2 >> 6) & 3)
            result = result + alphabet.substring(idx2, idx2 + 1)
        else:
            result = result + "="

        # Last 6 bits of b2
        if has_b2:
            var idx3 = b2 & 63
            result = result + alphabet.substring(idx3, idx3 + 1)
        else:
            result = result + "="

        i = i + 3

    return result

# Base64 decoding (RFC 4648 standard)
fn base64_decode_simple(encoded: text) -> text:
    var result = ""
    var i = 0
    var enc_len = encoded.length()

    while i < enc_len:
        var c0 = _b64_char_val(encoded, i)
        var c1 = _b64_char_val(encoded, i + 1)
        var c2 = _b64_char_val(encoded, i + 2)
        var c3 = _b64_char_val(encoded, i + 3)

        # First byte: 6 bits from c0 + top 2 bits from c1
        var byte0 = ((c0 << 2) | (c1 >> 4)) & 255
        result = result + text.from_char_code(byte0)

        # Second byte (if not padding)
        if c2 >= 0:
            var byte1 = ((c1 << 4) | (c2 >> 2)) & 255
            result = result + text.from_char_code(byte1)

        # Third byte (if not padding)
        if c3 >= 0:
            var byte2 = ((c2 << 6) | c3) & 255
            result = result + text.from_char_code(byte2)

        i = i + 4

    return result

# Helper: get Base64 value for character at position
fn _b64_char_val(s: text, pos: i64) -> i64:
    if pos >= s.length():
        return -1
    var code = s.char_code_at(pos)
    # A-Z: 65-90 -> 0-25
    if code >= 65:
        if code <= 90:
            return code - 65
    # a-z: 97-122 -> 26-51
    if code >= 97:
        if code <= 122:
            return code - 71
    # 0-9: 48-57 -> 52-61
    if code >= 48:
        if code <= 57:
            return code + 4
    # '+' = 43 -> 62
    if code == 43:
        return 62
    # '/' = 47 -> 63
    if code == 47:
        return 63
    # '=' padding
    -1

# ============================================================================
# General Utility Functions
# ============================================================================

# Trim whitespace from text
fn trim(text: text) -> text:
    var start = 0
    var end_val = text.length()

    # Trim from start
    while start < end_val:
        val ch = text[start]
        var is_space = false
        if ch == " ":
            is_space = true
        if ch == "\t":
            is_space = true
        if ch == "\r":
            is_space = true
        if ch == "\n":
            is_space = true

        if is_space:
            start = start + 1
        else:
            break

    # Trim from end
    while end_val > start:
        val pos = end_val - 1
        val ch = text[pos]
        var is_space = false
        if ch == " ":
            is_space = true
        if ch == "\t":
            is_space = true
        if ch == "\r":
            is_space = true
        if ch == "\n":
            is_space = true

        if is_space:
            end_val = end_val - 1
        else:
            break

    if start >= end_val:
        return ""

    return text.substring(start, end_val)

# Check if text contains substring
fn contains(text: text, substring: text) -> bool:
    return text.index_of(substring) >= 0

# Index of substring with start position
fn index_of(text: text, substring: text, start: i64) -> i64:
    return common.index_of(text, substring, start)
