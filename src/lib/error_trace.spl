# Error Return Trace - Zig-style propagation path tracking
#
# Records the path an error travels through ? operator sites.
# Zero cost on success path - trace only populated when error occurs.
#
# Design:
# - ErrorSite struct for a single ? propagation site (file, line, function)
# - ErrorTrace struct with fixed-capacity buffer (default 32)
# - Module-level state (one active trace at a time)
# - Opt-in at top level via error_trace_begin() / error_trace_end()
#
# Usage:
#   error_trace_begin()
#   val result = some_fallible_operation()
#   val trace = error_trace_end()
#   print error_trace_format()
#
# ? operator integration:
#   When ? propagates nil, call:
#   error_trace_push(@file, @line, @function)
#
# Note:
# - ErrorSite is the FIRST struct - supports direct construction when imported
# - ErrorTrace uses error_trace_new() factory function
# - Capacity defaults to 32; pushes beyond capacity are silently dropped

# ============================================================================
# Data Structures
# ============================================================================

struct ErrorSite:
    # A single ? propagation site - file, line, function name.
    file: text
    line: i64
    function: text

struct ErrorTrace:
    # Fixed-capacity trace of error propagation sites.
    sites: [ErrorSite]
    depth: i64
    capacity: i64

# ============================================================================
# Factory Functions
# ============================================================================

fn error_trace_new() -> ErrorTrace:
    # Create a fresh empty trace with default capacity 32.
    ErrorTrace(sites: [], depth: 0, capacity: 32)

fn error_trace_new_with_capacity(cap: i64) -> ErrorTrace:
    # Create a fresh empty trace with given capacity.
    ErrorTrace(sites: [], depth: 0, capacity: cap)

fn error_site_new(file: text, line: i64, function: text) -> ErrorSite:
    # Create an error site record.
    ErrorSite(file: file, line: line, function: function)

# ============================================================================
# Module State (one active trace at a time)
# ============================================================================

var _active_trace_sites: [ErrorSite] = []
var _active_trace_depth: i64 = 0
var _active_trace_capacity: i64 = 32
var _trace_active: bool = false

# ============================================================================
# API
# ============================================================================

fn error_trace_begin():
    # Start collecting error propagation sites.
    _active_trace_sites = []
    _active_trace_depth = 0
    _active_trace_capacity = 32
    _trace_active = true

fn error_trace_end() -> ErrorTrace:
    # Stop collecting. Returns the collected trace.
    _trace_active = false
    ErrorTrace(
        sites: _active_trace_sites,
        depth: _active_trace_depth,
        capacity: _active_trace_capacity
    )

fn error_trace_push(file: text, line: i64, function: text):
    # Record a ? site. Called by ? operator desugaring.
    if not _trace_active:
        return
    if _active_trace_depth >= _active_trace_capacity:
        return
    val site = ErrorSite(file: file, line: line, function: function)
    _active_trace_sites.push(site)
    _active_trace_depth = _active_trace_depth + 1

fn error_trace_clear():
    # Reset the active trace.
    _active_trace_sites = []
    _active_trace_depth = 0
    _trace_active = false

fn error_trace_depth() -> i64:
    # How many sites have been recorded.
    _active_trace_depth

fn error_trace_is_active() -> bool:
    # Whether trace collection is currently active.
    _trace_active

fn error_trace_format() -> text:
    # Format the trace as a human-readable string.
    if _active_trace_depth == 0:
        return "Error propagation trace: (empty)"
    var result = "Error propagation trace:\n"
    for site in _active_trace_sites:
        val loc = site.file + ":" + text(site.line)
        result = result + "  " + loc + " in " + site.function + "\n"
    result

fn error_site_at(idx: i64) -> ErrorSite:
    # Get the site at a given index. Returns empty site if out of bounds.
    if idx < 0:
        return ErrorSite(file: "", line: 0, function: "")
    if idx >= _active_trace_depth:
        return ErrorSite(file: "", line: 0, function: "")
    _active_trace_sites[idx]

# ============================================================================
# Trace Inspection (on a completed ErrorTrace value)
# ============================================================================

fn trace_depth(trace: ErrorTrace) -> i64:
    # Get depth of a completed trace.
    trace.depth

fn trace_site_at(trace: ErrorTrace, idx: i64) -> ErrorSite:
    # Get a site from a completed trace by index.
    if idx < 0:
        return ErrorSite(file: "", line: 0, function: "")
    if idx >= trace.depth:
        return ErrorSite(file: "", line: 0, function: "")
    trace.sites[idx]

fn trace_format(trace: ErrorTrace) -> text:
    # Format a completed ErrorTrace as a human-readable string.
    if trace.depth == 0:
        return "Error propagation trace: (empty)"
    var result = "Error propagation trace:\n"
    for site in trace.sites:
        val loc = site.file + ":" + text(site.line)
        result = result + "  " + loc + " in " + site.function + "\n"
    result

# ============================================================================
# Exports
# ============================================================================

export ErrorSite, ErrorTrace
export error_trace_new, error_trace_new_with_capacity, error_site_new
export error_trace_begin, error_trace_end, error_trace_push, error_trace_clear
export error_trace_depth, error_trace_is_active, error_trace_format, error_site_at
export trace_depth, trace_site_at, trace_format
