# Segment Tree Range Operations
#
# This module contains advanced range-based operations like
# range sum with target, range set, range multiply, inversions.

import std.segment_tree.query
import std.segment_tree.update

# Find range [l, r] with maximum sum
fn max_sum_range(tree_tuple: (list, i64, text), range_size: i64) -> (i64, i64):
    val n = tree_tuple.1

    if range_size > n:
        return (0, 0)
    if range_size <= 0:
        return (0, 0)

    var max_sum = query.range_sum(tree_tuple, 0, range_size - 1)
    var max_start = 0

    var i = 1
    while i + range_size <= n:
        val current_sum = query.range_sum(tree_tuple, i, i + range_size - 1)
        if current_sum > max_sum:
            max_sum = current_sum
            max_start = i
        i = i + 1

    return (max_start, max_start + range_size - 1)

# Count ranges with sum equal to target
fn count_ranges_with_sum(tree_tuple: (list, i64, text), target: i64) -> i64:
    val n = tree_tuple.1
    var count = 0

    var l = 0
    while l < n:
        var r = l
        while r < n:
            val sum = query.range_sum(tree_tuple, l, r)
            if sum == target:
                count = count + 1
            r = r + 1
        l = l + 1

    return count

# Set all elements in range [l, r] to value
fn range_set(tree_tuple: (list, i64, text), l: i64, r: i64, value: i64) -> (list, i64, text):
    var current = tree_tuple

    var i = l
    while i <= r:
        if i < current.1:
            current = update.update_point(current, i, value)
        i = i + 1

    return current

# Multiply all elements in range [l, r] by factor
fn range_multiply(tree_tuple: (list, i64, text), l: i64, r: i64, factor: i64) -> (list, i64, text):
    var current = tree_tuple

    var i = l
    while i <= r:
        if i < current.1:
            val old_value = query.get_element(current, i)
            val new_value = old_value * factor
            current = update.update_point(current, i, new_value)
        i = i + 1

    return current

# Count inversions in range [l, r]
fn count_inversions(tree_tuple: (list, i64, text), l: i64, r: i64) -> i64:
    var count = 0

    var i = l
    while i <= r:
        var j = i + 1
        while j <= r:
            val val_i = query.get_element(tree_tuple, i)
            val val_j = query.get_element(tree_tuple, j)
            if val_i > val_j:
                count = count + 1
            j = j + 1
        i = i + 1

    return count
