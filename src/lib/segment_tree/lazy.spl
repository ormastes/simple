# Segment Tree Lazy Propagation
#
# This module contains lazy propagation implementation for efficient
# range updates with O(log n) complexity.

import std.segment_tree.utilities
import std.segment_tree.build

# Create lazy segment tree for range updates
fn create_lazy_tree(arr: list) -> (list, list, i64, text):
    val n = arr.length()
    if n == 0:
        val empty = []
        return (empty, empty, 0, "sum")

    val tree_size = utilities.get_tree_size(n)
    var tree = []
    var lazy = []

    # Initialize both arrays
    var i = 0
    while i < tree_size:
        tree.append(0)
        lazy.append(0)
        i = i + 1

    # Build the tree
    build.build_sum_tree_helper(arr, tree, 0, 0, n - 1)

    return (tree, lazy, n, "sum")

# Push lazy value down to children
fn push_lazy(tree: list, lazy: list, node: i64, start: i64, end: i64):
    val lazy_val = lazy.get(node)

    # No pending update
    if lazy_val == 0:
        return ()

    # Apply pending update to current node
    val range_size = end - start + 1
    val current = tree.get(node)
    tree.set(node, current + lazy_val * range_size)

    # If not leaf, propagate to children
    var leaf_check = utilities.is_leaf(start, end)
    if leaf_check == 0:
        val left = utilities.left_child(node)
        val right = utilities.right_child(node)

        val left_lazy = lazy.get(left)
        lazy.set(left, left_lazy + lazy_val)

        val right_lazy = lazy.get(right)
        lazy.set(right, right_lazy + lazy_val)

    # Clear current node's lazy value
    lazy.set(node, 0)

# Update range [l, r] by adding value (with lazy propagation)
fn update_range_helper(tree: list, lazy: list, node: i64, start: i64, end: i64, l: i64, r: i64, value: i64):
    # Push pending updates
    push_lazy(tree, lazy, node, start, end)

    # No overlap
    if r < start:
        return ()
    if l > end:
        return ()

    # Complete overlap
    if l <= start:
        if r >= end:
            val range_size = end - start + 1
            val current = tree.get(node)
            tree.set(node, current + value * range_size)

            # Mark children as lazy if not leaf
            var leaf_check = utilities.is_leaf(start, end)
            if leaf_check == 0:
                val left = utilities.left_child(node)
                val right = utilities.right_child(node)

                val left_lazy = lazy.get(left)
                lazy.set(left, left_lazy + value)

                val right_lazy = lazy.get(right)
                lazy.set(right, right_lazy + value)

            return ()

    # Partial overlap
    val mid = utilities.get_mid(start, end)
    val left = utilities.left_child(node)
    val right = utilities.right_child(node)

    update_range_helper(tree, lazy, left, start, mid, l, r, value)
    update_range_helper(tree, lazy, right, mid + 1, end, l, r, value)

    # Update current node
    val left_val = tree.get(left)
    val right_val = tree.get(right)
    tree.set(node, left_val + right_val)

# Update range [l, r] by adding value
fn update_range(tree_tuple: (list, list, i64, text), l: i64, r: i64, value: i64) -> (list, list, i64, text):
    val tree = tree_tuple.0
    val lazy = tree_tuple.1
    val n = tree_tuple.2
    val tree_type = tree_tuple.3

    if n == 0:
        return tree_tuple
    if l < 0:
        return tree_tuple
    if r >= n:
        return tree_tuple
    if l > r:
        return tree_tuple

    update_range_helper(tree, lazy, 0, 0, n - 1, l, r, value)
    return (tree, lazy, n, tree_type)

# Range add (alias for update_range)
fn range_add(tree_tuple: (list, list, i64, text), l: i64, r: i64, value: i64) -> (list, list, i64, text):
    return update_range(tree_tuple, l, r, value)

# Query sum with lazy propagation
fn query_sum_lazy_helper(tree: list, lazy: list, node: i64, start: i64, end: i64, l: i64, r: i64) -> i64:
    # Push pending updates
    push_lazy(tree, lazy, node, start, end)

    # No overlap
    if r < start:
        return 0
    if l > end:
        return 0

    # Complete overlap
    if l <= start:
        if r >= end:
            return tree.get(node)

    # Partial overlap
    val mid = utilities.get_mid(start, end)
    val left = utilities.left_child(node)
    val right = utilities.right_child(node)

    val left_sum = query_sum_lazy_helper(tree, lazy, left, start, mid, l, r)
    val right_sum = query_sum_lazy_helper(tree, lazy, right, mid + 1, end, l, r)

    return left_sum + right_sum

# Query sum from lazy tree
fn range_sum_lazy(tree_tuple: (list, list, i64, text), l: i64, r: i64) -> i64:
    val tree = tree_tuple.0
    val lazy = tree_tuple.1
    val n = tree_tuple.2

    if n == 0:
        return 0
    if l < 0:
        return 0
    if r >= n:
        return 0
    if l > r:
        return 0

    return query_sum_lazy_helper(tree, lazy, 0, 0, n - 1, l, r)
