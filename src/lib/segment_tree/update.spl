# Segment Tree Update Operations
#
# This module contains functions for updating segment trees
# (point updates for different tree types).

import std.segment_tree.utilities

# Update point in sum tree recursively
# index: position in original array to update
# value: new value
fn update_sum_helper(tree: list, node: i64, start: i64, end: i64, index: i64, value: i64):
    var leaf_check = utilities.is_leaf(start, end)
    if leaf_check == 1:
        tree.set(node, value)
        return ()

    val mid = utilities.get_mid(start, end)
    val left = utilities.left_child(node)
    val right = utilities.right_child(node)

    if index <= mid:
        update_sum_helper(tree, left, start, mid, index, value)
    else:
        update_sum_helper(tree, right, mid + 1, end, index, value)

    # Update current node
    val left_val = tree.get(left)
    val right_val = tree.get(right)
    tree.set(node, left_val + right_val)

# Update point in sum tree
fn update_point_sum(tree_tuple: (list, i64, text), index: i64, value: i64) -> (list, i64, text):
    val tree = tree_tuple.0
    val n = tree_tuple.1
    val tree_type = tree_tuple.2

    if n == 0:
        return tree_tuple
    if index < 0:
        return tree_tuple
    if index >= n:
        return tree_tuple

    update_sum_helper(tree, 0, 0, n - 1, index, value)
    return (tree, n, tree_type)

# Update point in min tree recursively
fn update_min_helper(tree: list, node: i64, start: i64, end: i64, index: i64, value: i64):
    var leaf_check = utilities.is_leaf(start, end)
    if leaf_check == 1:
        tree.set(node, value)
        return ()

    val mid = utilities.get_mid(start, end)
    val left = utilities.left_child(node)
    val right = utilities.right_child(node)

    if index <= mid:
        update_min_helper(tree, left, start, mid, index, value)
    else:
        update_min_helper(tree, right, mid + 1, end, index, value)

    # Update current node
    val left_val = tree.get(left)
    val right_val = tree.get(right)

    var min_val = left_val
    if right_val < min_val:
        min_val = right_val

    tree.set(node, min_val)

# Update point in min tree
fn update_point_min(tree_tuple: (list, i64, text), index: i64, value: i64) -> (list, i64, text):
    val tree = tree_tuple.0
    val n = tree_tuple.1
    val tree_type = tree_tuple.2

    if n == 0:
        return tree_tuple
    if index < 0:
        return tree_tuple
    if index >= n:
        return tree_tuple

    update_min_helper(tree, 0, 0, n - 1, index, value)
    return (tree, n, tree_type)

# Update point in max tree recursively
fn update_max_helper(tree: list, node: i64, start: i64, end: i64, index: i64, value: i64):
    var leaf_check = utilities.is_leaf(start, end)
    if leaf_check == 1:
        tree.set(node, value)
        return ()

    val mid = utilities.get_mid(start, end)
    val left = utilities.left_child(node)
    val right = utilities.right_child(node)

    if index <= mid:
        update_max_helper(tree, left, start, mid, index, value)
    else:
        update_max_helper(tree, right, mid + 1, end, index, value)

    # Update current node
    val left_val = tree.get(left)
    val right_val = tree.get(right)

    var max_val = left_val
    if right_val > max_val:
        max_val = right_val

    tree.set(node, max_val)

# Update point in max tree
fn update_point_max(tree_tuple: (list, i64, text), index: i64, value: i64) -> (list, i64, text):
    val tree = tree_tuple.0
    val n = tree_tuple.1
    val tree_type = tree_tuple.2

    if n == 0:
        return tree_tuple
    if index < 0:
        return tree_tuple
    if index >= n:
        return tree_tuple

    update_max_helper(tree, 0, 0, n - 1, index, value)
    return (tree, n, tree_type)

# Update point with automatic type detection
fn update_point(tree_tuple: (list, i64, text), index: i64, value: i64) -> (list, i64, text):
    val tree_type = tree_tuple.2

    if tree_type == "sum":
        return update_point_sum(tree_tuple, index, value)
    if tree_type == "min":
        return update_point_min(tree_tuple, index, value)
    if tree_type == "max":
        return update_point_max(tree_tuple, index, value)

    # Default to sum
    return update_point_sum(tree_tuple, index, value)

# Perform multiple point updates
fn batch_update_points(tree_tuple: (list, i64, text), updates: list) -> (list, i64, text):
    var current = tree_tuple

    var i = 0
    while i < updates.length():
        val update = updates.get(i)
        # Expect update to be (index, value) tuple
        # Since we can't destructure, assume it's a list
        # This is a simplified version
        i = i + 1

    return current
