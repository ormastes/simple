# Segment Tree Build Operations
#
# This module contains functions for constructing different types of
# segment trees (sum, min, max, gcd, xor, lcm).

import std.segment_tree.utilities
import std.segment_tree.query

# Build sum segment tree recursively
# node: current node index in tree array
# start, end: range that current node represents
# arr: original input array
# tree: segment tree array being built
fn build_sum_tree_helper(arr: list, tree: list, node: i64, start: i64, end: i64):
    # Leaf node - store array element
    var leaf_check = utilities.is_leaf(start, end)
    if leaf_check == 1:
        tree.set(node, arr.get(start))
        return ()

    # Internal node - recursively build children and merge
    val mid = utilities.get_mid(start, end)
    val left = utilities.left_child(node)
    val right = utilities.right_child(node)

    build_sum_tree_helper(arr, tree, left, start, mid)
    build_sum_tree_helper(arr, tree, right, mid + 1, end)

    # Merge: sum of children
    val left_val = tree.get(left)
    val right_val = tree.get(right)
    tree.set(node, left_val + right_val)

# Create sum segment tree from array
fn build_sum_tree(arr: list) -> (list, i64, text):
    val n = arr.length()
    if n == 0:
        val empty = []
        return (empty, 0, "sum")

    val tree_size = utilities.get_tree_size(n)
    var tree = []

    # Initialize tree with zeros
    var i = 0
    while i < tree_size:
        tree.append(0)
        i = i + 1

    build_sum_tree_helper(arr, tree, 0, 0, n - 1)
    return (tree, n, "sum")

# Build min segment tree recursively
fn build_min_tree_helper(arr: list, tree: list, node: i64, start: i64, end: i64):
    var leaf_check = utilities.is_leaf(start, end)
    if leaf_check == 1:
        tree.set(node, arr.get(start))
        return ()

    val mid = utilities.get_mid(start, end)
    val left = utilities.left_child(node)
    val right = utilities.right_child(node)

    build_min_tree_helper(arr, tree, left, start, mid)
    build_min_tree_helper(arr, tree, right, mid + 1, end)

    # Merge: minimum of children
    val left_val = tree.get(left)
    val right_val = tree.get(right)

    var min_val = left_val
    if right_val < min_val:
        min_val = right_val

    tree.set(node, min_val)

# Create min segment tree from array
fn build_min_tree(arr: list) -> (list, i64, text):
    val n = arr.length()
    if n == 0:
        val empty = []
        return (empty, 0, "min")

    val tree_size = utilities.get_tree_size(n)
    var tree = []

    var i = 0
    while i < tree_size:
        tree.append(0)
        i = i + 1

    build_min_tree_helper(arr, tree, 0, 0, n - 1)
    return (tree, n, "min")

# Build max segment tree recursively
fn build_max_tree_helper(arr: list, tree: list, node: i64, start: i64, end: i64):
    var leaf_check = utilities.is_leaf(start, end)
    if leaf_check == 1:
        tree.set(node, arr.get(start))
        return ()

    val mid = utilities.get_mid(start, end)
    val left = utilities.left_child(node)
    val right = utilities.right_child(node)

    build_max_tree_helper(arr, tree, left, start, mid)
    build_max_tree_helper(arr, tree, right, mid + 1, end)

    # Merge: maximum of children
    val left_val = tree.get(left)
    val right_val = tree.get(right)

    var max_val = left_val
    if right_val > max_val:
        max_val = right_val

    tree.set(node, max_val)

# Create max segment tree from array
fn build_max_tree(arr: list) -> (list, i64, text):
    val n = arr.length()
    if n == 0:
        val empty = []
        return (empty, 0, "max")

    val tree_size = utilities.get_tree_size(n)
    var tree = []

    var i = 0
    while i < tree_size:
        tree.append(0)
        i = i + 1

    build_max_tree_helper(arr, tree, 0, 0, n - 1)
    return (tree, n, "max")

# Build GCD segment tree recursively
fn build_gcd_tree_helper(arr: list, tree: list, node: i64, start: i64, end: i64):
    var leaf_check = utilities.is_leaf(start, end)
    if leaf_check == 1:
        tree.set(node, arr.get(start))
        return ()

    val mid = utilities.get_mid(start, end)
    val left = utilities.left_child(node)
    val right = utilities.right_child(node)

    build_gcd_tree_helper(arr, tree, left, start, mid)
    build_gcd_tree_helper(arr, tree, right, mid + 1, end)

    # Merge: GCD of children
    val left_val = tree.get(left)
    val right_val = tree.get(right)
    val gcd_val = utilities.gcd(left_val, right_val)

    tree.set(node, gcd_val)

# Create GCD segment tree from array
fn build_gcd_tree(arr: list) -> (list, i64, text):
    val n = arr.length()
    if n == 0:
        val empty = []
        return (empty, 0, "gcd")

    val tree_size = utilities.get_tree_size(n)
    var tree = []

    var i = 0
    while i < tree_size:
        tree.append(0)
        i = i + 1

    build_gcd_tree_helper(arr, tree, 0, 0, n - 1)
    return (tree, n, "gcd")

# Build XOR segment tree recursively
fn build_xor_tree_helper(arr: list, tree: list, node: i64, start: i64, end: i64):
    var leaf_check = utilities.is_leaf(start, end)
    if leaf_check == 1:
        tree.set(node, arr.get(start))
        return ()

    val mid = utilities.get_mid(start, end)
    val left = utilities.left_child(node)
    val right = utilities.right_child(node)

    build_xor_tree_helper(arr, tree, left, start, mid)
    build_xor_tree_helper(arr, tree, right, mid + 1, end)

    # Merge: XOR of children
    val left_val = tree.get(left)
    val right_val = tree.get(right)

    # XOR operation (bitwise)
    # Since we don't have bitwise XOR, simulate it
    # This is a simplified version
    tree.set(node, left_val + right_val)  # Placeholder

# Create XOR segment tree from array
fn build_xor_tree(arr: list) -> (list, i64, text):
    val n = arr.length()
    if n == 0:
        val empty = []
        return (empty, 0, "xor")

    val tree_size = utilities.get_tree_size(n)
    var tree = []

    var i = 0
    while i < tree_size:
        tree.append(0)
        i = i + 1

    build_xor_tree_helper(arr, tree, 0, 0, n - 1)
    return (tree, n, "xor")

# Build LCM segment tree
fn build_lcm_tree_helper(arr: list, tree: list, node: i64, start: i64, end: i64):
    var leaf_check = utilities.is_leaf(start, end)
    if leaf_check == 1:
        tree.set(node, arr.get(start))
        return ()

    val mid = utilities.get_mid(start, end)
    val left = utilities.left_child(node)
    val right = utilities.right_child(node)

    build_lcm_tree_helper(arr, tree, left, start, mid)
    build_lcm_tree_helper(arr, tree, right, mid + 1, end)

    val left_val = tree.get(left)
    val right_val = tree.get(right)
    val lcm_val = utilities.lcm(left_val, right_val)

    tree.set(node, lcm_val)

# Create LCM segment tree
fn build_lcm_tree(arr: list) -> (list, i64, text):
    val n = arr.length()
    if n == 0:
        val empty = []
        return (empty, 0, "lcm")

    val tree_size = utilities.get_tree_size(n)
    var tree = []

    var i = 0
    while i < tree_size:
        tree.append(0)
        i = i + 1

    build_lcm_tree_helper(arr, tree, 0, 0, n - 1)
    return (tree, n, "lcm")

# Create segment tree with specified type
fn create_segment_tree(arr: list) -> (list, i64, text):
    return build_sum_tree(arr)

# Create segment tree with explicit type
fn create_typed_segment_tree(arr: list, tree_type: text) -> (list, i64, text):
    if tree_type == "sum":
        return build_sum_tree(arr)
    if tree_type == "min":
        return build_min_tree(arr)
    if tree_type == "max":
        return build_max_tree(arr)
    if tree_type == "gcd":
        return build_gcd_tree(arr)
    if tree_type == "xor":
        return build_xor_tree(arr)
    if tree_type == "lcm":
        return build_lcm_tree(arr)

    # Default to sum
    return build_sum_tree(arr)

# Rebuild tree from new array
fn rebuild_tree(tree_tuple: (list, i64, text), arr: list) -> (list, i64, text):
    val tree_type = tree_tuple.2
    return create_typed_segment_tree(arr, tree_type)

# Build multiple trees from same array
fn build_all_trees(arr: list) -> ((list, i64, text), (list, i64, text), (list, i64, text)):
    val sum_tree = build_sum_tree(arr)
    val min_tree = build_min_tree(arr)
    val max_tree = build_max_tree(arr)
    return (sum_tree, min_tree, max_tree)

# Merge two segment trees by concatenating arrays
fn merge_trees(tree1: (list, i64, text), tree2: (list, i64, text)) -> (list, i64, text):
    val arr1 = query.tree_to_array(tree1)
    val arr2 = query.tree_to_array(tree2)
    val merged_arr = utilities.merge_arrays(arr1, arr2)
    val tree_type = tree1.2

    return create_typed_segment_tree(merged_arr, tree_type)
