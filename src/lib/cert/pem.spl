# PEM Format Encoding/Decoding
#
# This module handles PEM (Privacy-Enhanced Mail) format for certificates.

use std.text.{NL}

# PEM Format Constants
val PEM_CERT_BEGIN = "-----BEGIN CERTIFICATE-----"
val PEM_CERT_END = "-----END CERTIFICATE-----"

fn base64_encode(bytes: text) -> text:
    # Simple base64 encoding implementation
    val alphabet = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"
    var result = ""
    var i = 0
    val len = bytes.length()

    while i < len:
        val byte1 = bytes.char_code_at(i)
        val byte2 = if i + 1 < len: bytes.char_code_at(i + 1) else: 0
        val byte3 = if i + 2 < len: bytes.char_code_at(i + 2) else: 0

        val idx1 = byte1 >> 2
        val idx2 = ((byte1 & 3) << 4) | (byte2 >> 4)
        val idx3 = ((byte2 & 15) << 2) | (byte3 >> 6)
        val idx4 = byte3 & 63

        result = result + alphabet.char_at(idx1)
        result = result + alphabet.char_at(idx2)
        val char3 = if i + 1 < len: alphabet.char_at(idx3) else: "="
        result = result + char3
        val char4 = if i + 2 < len: alphabet.char_at(idx4) else: "="
        result = result + char4

        i = i + 3

    result

fn base64_decode(encoded: text) -> text:
    # Simple base64 decoding implementation
    val alphabet = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"
    var result = ""
    var i = 0
    val clean = encoded.replace(NL, "").replace("\r", "").replace(" ", "")
    val len = clean.length()

    while i < len:
        if i + 3 >= len:
            break

        val char1 = clean.char_at(i)
        val char2 = clean.char_at(i + 1)
        val char3 = clean.char_at(i + 2)
        val char4 = clean.char_at(i + 3)

        val idx1 = alphabet.index_of(char1)
        val idx2 = alphabet.index_of(char2)
        val idx3 = if char3 == "=": 0 else: alphabet.index_of(char3)
        val idx4 = if char4 == "=": 0 else: alphabet.index_of(char4)

        if idx1 < 0 or idx2 < 0:
            break

        val byte1 = (idx1 << 2) | (idx2 >> 4)
        result = result + text.from_char_code(byte1)

        if char3 != "=":
            val byte2 = ((idx2 & 15) << 4) | (idx3 >> 2)
            result = result + text.from_char_code(byte2)

        if char4 != "=":
            val byte3 = ((idx3 & 3) << 6) | idx4
            result = result + text.from_char_code(byte3)

        i = i + 4

    result

fn is_pem_format(data: text) -> bool:
    # Check if data is in PEM format
    val has_begin = data.contains(PEM_CERT_BEGIN)
    val has_end = data.contains(PEM_CERT_END)
    has_begin and has_end

fn extract_pem_data(pem: text) -> text:
    # Extract base64 data from PEM format
    val begin_idx = pem.index_of(PEM_CERT_BEGIN)
    if begin_idx < 0:
        return nil

    val after_begin = begin_idx + PEM_CERT_BEGIN.length()
    val end_idx = pem.index_of(PEM_CERT_END)
    if end_idx < 0:
        return nil

    val base64_data = pem.substring(after_begin, end_idx)
    base64_data.trim()

fn pem_decode(pem: text) -> text:
    # Decode PEM format to DER bytes
    val base64_data = extract_pem_data(pem)
    if base64_data == nil:
        return nil

    base64_decode(base64_data)

fn pem_encode(der: text, cert_type: text) -> text:
    # Encode DER bytes to PEM format
    val base64_data = base64_encode(der)
    var result = "-----BEGIN {cert_type}-----\n"

    # Split into 64-character lines
    var i = 0
    while i < base64_data.length():
        val line_len = if i + 64 < base64_data.length(): 64 else: base64_data.length() - i
        val line = base64_data.substring(i, i + line_len)
        result = result + line + NL
        i = i + 64

    result = result + "-----END {cert_type}-----\n"
    result

fn split_pem_chain(pem_chain: text) -> text:
    # Split multiple PEM certificates into array
    var certs = []
    var current_cert = ""
    var in_cert = false

    val lines = pem_chain.split(NL)
    var i = 0
    while i < lines.length():
        val line = lines[i]

        if line.contains(PEM_CERT_BEGIN):
            in_cert = true
            current_cert = line + NL
        else:
            if line.contains(PEM_CERT_END):
                current_cert = current_cert + line + NL
                certs = certs + [current_cert]
                current_cert = ""
                in_cert = false
            else:
                if in_cert:
                    current_cert = current_cert + line + NL

        i = i + 1

    certs
