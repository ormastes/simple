# Certificate Utility Functions
#
# This module provides utility functions for certificate fingerprints,
# information extraction, and formatting.

fn simple_hash(data: text, seed: i64) -> i64:
    # DJB2 hash variant - produces consistent hash values
    var hash = seed
    if hash == 0:
        hash = 5381
    var i = 0
    var data_len = data.length()

    while i < data_len:
        val char_code = data.char_code_at(i)
        hash = ((hash << 5) + hash) + char_code  # hash * 33 + c
        i = i + 1

    hash

fn bytes_to_hex(bytes: text) -> text:
    # Convert bytes to hexadecimal string
    val hex_chars = "0123456789ABCDEF"
    var result = ""
    var i = 0

    while i < bytes.length():
        val byte_val = bytes.char_code_at(i)
        val high = (byte_val >> 4) & 15
        val low = byte_val & 15
        result = result + hex_chars.char_at(high) + hex_chars.char_at(low)
        i = i + 1

    result

fn certificate_fingerprint(cert: text) -> text:
    # Calculate certificate fingerprint using SHA-256 on the raw DER data
    val der = get_raw_der(cert)
    val hex = _sha256_hex_of_text(der)
    hex

fn sha256_fingerprint(cert: text) -> text:
    # Calculate SHA-256 fingerprint of certificate DER encoding
    val der = get_raw_der(cert)
    val hex = _sha256_hex_of_text(der)
    # Format as colon-separated uppercase hex pairs (standard fingerprint format)
    var formatted = ""
    var i = 0
    var hex_len = hex.length()
    while i < hex_len:
        if i > 0:
            var is_even = (i % 2) == 0
            if is_even:
                formatted = formatted + ":"
        var ch = hex.substring(i, i + 1)
        formatted = formatted + ch.to_upper()
        i = i + 1
    formatted

fn sha1_fingerprint(cert: text) -> text:
    # Calculate SHA-1 fingerprint of certificate
    # SHA-1 produces 20 bytes (40 hex chars)
    val der = get_raw_der(cert)
    val hex = _sha1_hex_of_text(der)
    # Format as colon-separated uppercase hex pairs
    var formatted = ""
    var i = 0
    var hex_len = hex.length()
    while i < hex_len:
        if i > 0:
            var is_even = (i % 2) == 0
            if is_even:
                formatted = formatted + ":"
        var ch = hex.substring(i, i + 1)
        formatted = formatted + ch.to_upper()
        i = i + 1
    formatted

# Internal SHA-256 that takes text and returns hex string
fn _sha256_hex_of_text(data: text) -> text:
    val mask32 = 4294967295
    var h0 = 1779033703
    var h1 = 3144134277
    var h2 = 1013904242
    var h3 = 2773480762
    var h4 = 1359893119
    var h5 = 2600822924
    var h6 = 528734635
    var h7 = 1541459225

    var kk = [
        1116352408, 1899447441, 3049323471, 3921009573,
        961987163, 1508970993, 2453635748, 2870763221,
        3624381080, 310598401, 607225278, 1426881987,
        1925078388, 2162078206, 2614888103, 3248222580,
        3835390401, 4022224774, 264347078, 604807628,
        770255983, 1249150122, 1555081692, 1996064986,
        2554220882, 2821834349, 2952996808, 3210313671,
        3336571891, 3584528711, 113926993, 338241895,
        666307205, 773529912, 1294757372, 1396182291,
        1695183700, 1986661051, 2177026350, 2456956037,
        2730485921, 2820302411, 3259730800, 3345764771,
        3516065817, 3600352804, 4094571909, 275423344,
        430227734, 506948616, 659060556, 883997877,
        958139571, 1322822218, 1537002063, 1747873779,
        1955562222, 2024104815, 2227730452, 2361852424,
        2428436474, 2756734187, 3204031479, 3329325298
    ]

    var data_len = data.length()
    var bytes = []
    var bi = 0
    while bi < data_len:
        bytes.push(data.char_code_at(bi))
        bi = bi + 1

    bytes.push(128)
    var pad_target = data_len + 1
    var pad_zeros = 56 - (pad_target % 64)
    if pad_zeros < 0:
        pad_zeros = pad_zeros + 64
    var pz = 0
    while pz < pad_zeros:
        bytes.push(0)
        pz = pz + 1

    var bit_length = data_len * 8
    bytes.push(0)
    bytes.push(0)
    bytes.push(0)
    bytes.push(0)
    bytes.push((bit_length >> 24) & 255)
    bytes.push((bit_length >> 16) & 255)
    bytes.push((bit_length >> 8) & 255)
    bytes.push(bit_length & 255)

    var total_len = bytes.length()
    var block_off = 0
    while block_off < total_len:
        var w = []
        var wi = 0
        while wi < 16:
            var base = block_off + (wi * 4)
            var word = ((bytes[base] & 255) << 24) | ((bytes[base + 1] & 255) << 16) | ((bytes[base + 2] & 255) << 8) | (bytes[base + 3] & 255)
            word = word & mask32
            w.push(word)
            wi = wi + 1

        wi = 16
        while wi < 64:
            var w15 = w[wi - 15] & mask32
            var w2 = w[wi - 2] & mask32
            var s0 = (((w15 >> 7) | (w15 << 25)) ^ ((w15 >> 18) | (w15 << 14)) ^ (w15 >> 3)) & mask32
            var s1 = (((w2 >> 17) | (w2 << 15)) ^ ((w2 >> 19) | (w2 << 13)) ^ (w2 >> 10)) & mask32
            var new_w = (w[wi - 16] + s0 + w[wi - 7] + s1) & mask32
            w.push(new_w)
            wi = wi + 1

        var a = h0
        var b = h1
        var c = h2
        var d = h3
        var e = h4
        var f = h5
        var g = h6
        var hv = h7

        var ri = 0
        while ri < 64:
            var ea = e & mask32
            var big_s1 = (((ea >> 6) | (ea << 26)) ^ ((ea >> 11) | (ea << 21)) ^ ((ea >> 25) | (ea << 7))) & mask32
            var ch = ((ea & (f & mask32)) ^ ((~ea & mask32) & (g & mask32))) & mask32
            var temp1 = (hv + big_s1 + ch + kk[ri] + w[ri]) & mask32
            var aa = a & mask32
            var big_s0 = (((aa >> 2) | (aa << 30)) ^ ((aa >> 13) | (aa << 19)) ^ ((aa >> 22) | (aa << 10))) & mask32
            var maj = ((aa & (b & mask32)) ^ (aa & (c & mask32)) ^ ((b & mask32) & (c & mask32))) & mask32
            var temp2 = (big_s0 + maj) & mask32

            hv = g
            g = f
            f = e
            e = (d + temp1) & mask32
            d = c
            c = b
            b = a
            a = (temp1 + temp2) & mask32
            ri = ri + 1

        h0 = (h0 + a) & mask32
        h1 = (h1 + b) & mask32
        h2 = (h2 + c) & mask32
        h3 = (h3 + d) & mask32
        h4 = (h4 + e) & mask32
        h5 = (h5 + f) & mask32
        h6 = (h6 + g) & mask32
        h7 = (h7 + hv) & mask32
        block_off = block_off + 64

    var hex_chars = "0123456789abcdef"
    var result = ""
    var h_vals = [h0, h1, h2, h3, h4, h5, h6, h7]
    var hi = 0
    while hi < 8:
        var word = h_vals[hi] & mask32
        var nidx = 7
        while nidx >= 0:
            var nibble = (word >> (nidx * 4)) & 15
            result = result + hex_chars.substring(nibble, nibble + 1)
            nidx = nidx - 1
        hi = hi + 1
    result

# Internal SHA-1 that takes text and returns hex string
fn _sha1_hex_of_text(data: text) -> text:
    val mask32 = 4294967295
    var h0 = 1732584193   # 0x67452301
    var h1 = 4023233417   # 0xEFCDAB89
    var h2 = 2562383102   # 0x98BADCFE
    var h3 = 271733878    # 0x10325476
    var h4 = 3285377520   # 0xC3D2E1F0

    var data_len = data.length()
    var bytes = []
    var bi = 0
    while bi < data_len:
        bytes.push(data.char_code_at(bi))
        bi = bi + 1

    bytes.push(128)
    var pad_target = data_len + 1
    var pad_zeros = 56 - (pad_target % 64)
    if pad_zeros < 0:
        pad_zeros = pad_zeros + 64
    var pz = 0
    while pz < pad_zeros:
        bytes.push(0)
        pz = pz + 1

    var bit_length = data_len * 8
    bytes.push(0)
    bytes.push(0)
    bytes.push(0)
    bytes.push(0)
    bytes.push((bit_length >> 24) & 255)
    bytes.push((bit_length >> 16) & 255)
    bytes.push((bit_length >> 8) & 255)
    bytes.push(bit_length & 255)

    var total_len = bytes.length()
    var block_off = 0
    while block_off < total_len:
        var w = []
        var wi = 0
        while wi < 16:
            var base = block_off + (wi * 4)
            var word = ((bytes[base] & 255) << 24) | ((bytes[base + 1] & 255) << 16) | ((bytes[base + 2] & 255) << 8) | (bytes[base + 3] & 255)
            word = word & mask32
            w.push(word)
            wi = wi + 1

        # Extend to 80 words
        wi = 16
        while wi < 80:
            var xor_val = w[wi - 3] ^ w[wi - 8] ^ w[wi - 14] ^ w[wi - 16]
            # Left rotate by 1
            var rotated = ((xor_val << 1) | (xor_val >> 31)) & mask32
            w.push(rotated)
            wi = wi + 1

        var a = h0
        var b = h1
        var c = h2
        var d = h3
        var e = h4

        var ri = 0
        while ri < 80:
            var f_val = 0
            var k_val = 0
            if ri < 20:
                f_val = ((b & c) ^ ((~b & mask32) & d)) & mask32
                k_val = 1518500249   # 0x5A827999
            else:
                if ri < 40:
                    f_val = (b ^ c ^ d) & mask32
                    k_val = 1859775393   # 0x6ED9EBA1
                else:
                    if ri < 60:
                        f_val = ((b & c) ^ (b & d) ^ (c & d)) & mask32
                        k_val = 2400959708   # 0x8F1BBCDC
                    else:
                        f_val = (b ^ c ^ d) & mask32
                        k_val = 3395469782   # 0xCA62C1D6

            var a_rot = ((a << 5) | (a >> 27)) & mask32
            var temp = (a_rot + f_val + e + k_val + w[ri]) & mask32
            e = d
            d = c
            c = ((b << 30) | (b >> 2)) & mask32
            b = a
            a = temp
            ri = ri + 1

        h0 = (h0 + a) & mask32
        h1 = (h1 + b) & mask32
        h2 = (h2 + c) & mask32
        h3 = (h3 + d) & mask32
        h4 = (h4 + e) & mask32
        block_off = block_off + 64

    var hex_chars = "0123456789abcdef"
    var result = ""
    var h_vals = [h0, h1, h2, h3, h4]
    var hi = 0
    while hi < 5:
        var word = h_vals[hi] & mask32
        var nidx = 7
        while nidx >= 0:
            var nibble = (word >> (nidx * 4)) & 15
            result = result + hex_chars.substring(nibble, nibble + 1)
            nidx = nidx - 1
        hi = hi + 1
    result

fn certificate_to_string(cert: text) -> text:
    # Convert certificate to human-readable string
    var result = "Certificate:\n"
    result = result + "  Version: {get_version(cert)}\n"
    result = result + "  Serial Number: {get_serial_number(cert)}\n"

    val issuer = get_issuer(cert)
    result = result + "  Issuer: {dn_to_string(issuer)}\n"

    val subject = get_subject(cert)
    result = result + "  Subject: {dn_to_string(subject)}\n"

    val validity = get_validity(cert)
    val not_before = validity[0]
    val not_after = validity[1]
    result = result + "  Valid from: {not_before[0]}-{not_before[1]}-{not_before[2]}\n"
    result = result + "  Valid to: {not_after[0]}-{not_after[1]}-{not_after[2]}\n"

    val pub_key = get_public_key(cert)
    result = result + "  Public Key: {pub_key[2]} bits\n"

    val is_ca = is_ca_certificate(cert)
    result = result + "  CA: {is_ca}\n"

    result

fn certificates_match(cert1: text, cert2: text) -> bool:
    # Check if two certificates are identical
    val serial1 = get_serial_number(cert1)
    val serial2 = get_serial_number(cert2)

    if serial1 != serial2:
        return false

    val subject1 = get_subject(cert1)
    val subject2 = get_subject(cert2)

    val cn1 = get_common_name(subject1)
    val cn2 = get_common_name(subject2)

    cn1 == cn2

fn get_certificate_purposes(cert: text) -> text:
    # Determine certificate purposes from extensions
    var purposes = []

    val is_ca = is_ca_certificate(cert)
    if is_ca:
        purposes = purposes + ["CA"]

    val key_usage = get_key_usage(cert)
    if key_usage != nil:
        if has_key_usage_flag(cert, KU_DIGITAL_SIGNATURE):
            purposes = purposes + ["Digital Signature"]
        if has_key_usage_flag(cert, KU_KEY_ENCIPHERMENT):
            purposes = purposes + ["Key Encipherment"]
        if has_key_usage_flag(cert, KU_KEY_CERT_SIGN):
            purposes = purposes + ["Certificate Signing"]

    purposes

fn extract_certificate_info(cert: text) -> text:
    # Extract all key information from certificate as tuple
    val subject = get_subject(cert)
    val issuer = get_issuer(cert)
    val validity = get_validity(cert)
    val serial = get_serial_number(cert)
    val is_ca = is_ca_certificate(cert)
    val dns_names = get_dns_names(cert)
    val key_bits = get_public_key_bits(cert)

    (subject, issuer, validity, serial, is_ca, dns_names, key_bits)
