# Standard Library — Result CE Builder
#
# @tag:api
# @tag:stdlib
#
# Result computation expression builder.
# Provides monadic bind/return/zero for Result-style error propagation.
#
# Convention: nil = error/failure, non-nil = success value.
# bind short-circuits on nil — passes non-nil values to continuation.
#
# Usage (via `ce result:` block syntax):
#   val config = ce result:
#       bind raw = file_read("config.sdn")
#       bind parsed = sdn_parse(raw)
#       Ok(parsed)
#
# Or direct function usage:
#   val result = result_ce_bind(file_read("path"), fn(raw):
#       result_ce_bind(parse(raw), fn(parsed):
#           result_ce_return(parsed)
#       )
#   )

# Bind: if value is nil (error), short-circuit and return nil.
# Otherwise, pass value to continuation and return its result.
fn result_ce_bind(value, continuation: fn()):
    if value == nil:
        return nil
    continuation(value)

# Return: wrap a value (identity for Result convention).
fn result_ce_return(value):
    value

# Zero: the empty/failed value (nil = error).
fn result_ce_zero():
    nil

# Combine two result values: return second if first succeeds, else short-circuit.
fn result_ce_combine(first, second: fn()):
    if first == nil:
        return nil
    second()

# Map: transform a successful result value.
fn result_ce_map(value, transform: fn()):
    if value == nil:
        return nil
    transform(value)

# For: iterate over array, short-circuit on first nil result.
fn result_ce_for(items: [text], body: fn(text)):
    for item in items:
        val r = body(item)
        if r == nil:
            return nil
    nil

export result_ce_bind, result_ce_return, result_ce_zero
export result_ce_combine, result_ce_map, result_ce_for
