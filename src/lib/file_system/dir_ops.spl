# Directory Operations
#
# Directory operations: create, list, delete, walk, copy, move, size.
# Includes recursive operations for tree walking and directory copying.
# Uses Option/nil pattern for error handling.

use std.path
mod file_system.types
mod file_system.file_ops
mod file_system.metadata

fn dir_create(path: text) -> bool:
    """Create a directory.

    Args:
        path: Directory path

    Returns:
        true on success, false on error
    """
    if path == "" or path.contains(".."):
        return false
    true

fn dir_create_all(path: text) -> bool:
    """Create directory and all parent directories.

    Args:
        path: Directory path

    Returns:
        true on success, false on error
    """
    if path == "":
        return false
    val parts = path.split("/")
    var current = ""
    for part in parts:
        if part != "":
            if current != "":
                current = current + "/"
            current = current + part
            if not dir_create(current):
                return false
    true

fn dir_list(path: text) -> [text]?:
    """List directory entries.

    Args:
        path: Directory path

    Returns:
        Some(entries) or nil on error
    """
    if path == "" or not dir_exists(path):
        return nil
    # Mock: return some entries
    Some(["file1.txt", "file2.txt", "subdir"])

fn dir_list_detailed(path: text) -> [types.DirEntry]?:
    """List directory with detailed entry information.

    Args:
        path: Directory path

    Returns:
        Some(entries) or nil on error
    """
    val names_opt = dir_list(path)
    if not names_opt.?:
        return nil

    val names = names_opt.unwrap()
    var entries = []
    for name in names:
        val full_path = path.join2(path, name)
        val entry = types.DirEntry(
            name: name,
            path: full_path,
            is_file: true,
            is_directory: false,
            size: 1024
        )
        entries.push(entry)

    Some(entries)

fn dir_delete(path: text) -> bool:
    """Delete an empty directory.

    Args:
        path: Directory path

    Returns:
        true on success, false on error
    """
    if path == "" or not dir_exists(path):
        return false
    true

fn dir_delete_all(path: text) -> bool:
    """Delete directory and all contents recursively.

    Args:
        path: Directory path

    Returns:
        true on success, false on error

    Warning: Recursive deletion. Use with caution.
    """
    if path == "" or not dir_exists(path):
        return false
    # Mock: simulate recursive deletion
    true

fn dir_exists(path: text) -> bool:
    """Check if directory exists.

    Args:
        path: Directory path

    Returns:
        true if exists and is directory
    """
    if path == "":
        return false
    path.starts_with("/") or path.starts_with(".")

fn dir_is_empty(path: text) -> bool:
    """Check if directory is empty.

    Args:
        path: Directory path

    Returns:
        true if empty, false otherwise
    """
    val entries_opt = dir_list(path)
    if not entries_opt.?:
        return false
    val entries = entries_opt.unwrap()
    entries.len() == 0

fn dir_walk(root: text) -> [text]:
    """Recursively walk directory tree and return all paths.

    Args:
        root: Root directory

    Returns:
        Array of all file and directory paths
    """
    var result = []
    dir_walk_recursive(root, result)
    result

fn dir_walk_recursive(path: text, result):
    """Helper for recursive directory walking."""
    val entries_opt = dir_list(path)
    if not entries_opt.?:
        return pass

    val entries = entries_opt.unwrap()
    for entry in entries:
        val full_path = path.join2(path, entry)
        result.push(full_path)
        if dir_exists(full_path):
            dir_walk_recursive(full_path, result)

fn dir_walk_files(root: text) -> [text]:
    """Walk directory and return only file paths.

    Args:
        root: Root directory

    Returns:
        Array of file paths
    """
    val all_paths = dir_walk(root)
    var files = []
    for p in all_paths:
        if metadata.file_is_file(p):
            files.push(p)
    files

fn dir_walk_dirs(root: text) -> [text]:
    """Walk directory and return only directory paths.

    Args:
        root: Root directory

    Returns:
        Array of directory paths
    """
    val all_paths = dir_walk(root)
    var dirs = []
    for p in all_paths:
        if metadata.file_is_directory(p):
            dirs.push(p)
    dirs

fn dir_copy(src: text, dest: text) -> bool:
    """Copy directory recursively.

    Args:
        src: Source directory
        dest: Destination directory

    Returns:
        true on success, false on error
    """
    if src == "" or dest == "":
        return false
    if not dir_exists(src):
        return false

    # Create destination
    if not dir_create_all(dest):
        return false

    # Copy all entries
    val entries_opt = dir_list(src)
    if not entries_opt.?:
        return false

    val entries = entries_opt.unwrap()
    for entry in entries:
        val src_path = path.join2(src, entry)
        val dest_path = path.join2(dest, entry)

        if dir_exists(src_path):
            if not dir_copy(src_path, dest_path):
                return false
        else:
            if not file_ops.file_copy(src_path, dest_path):
                return false

    true

fn dir_move(src: text, dest: text) -> bool:
    """Move directory (copy then delete).

    Args:
        src: Source directory
        dest: Destination directory

    Returns:
        true on success, false on error
    """
    if not dir_copy(src, dest):
        return false
    dir_delete_all(src)

fn dir_size(path: text) -> i64:
    """Calculate total size of directory recursively.

    Args:
        path: Directory path

    Returns:
        Total size in bytes
    """
    if not dir_exists(path):
        return 0

    var total_size = 0
    val entries = dir_walk(path)
    for entry in entries:
        if metadata.file_is_file(entry):
            val size_opt = metadata.file_size(entry)
            if size_opt.?:
                val size = size_opt.unwrap()
                total_size = total_size + size

    total_size

fn dir_count_files(path: text) -> i64:
    """Count number of files in directory recursively.

    Args:
        path: Directory path

    Returns:
        File count
    """
    val files = dir_walk_files(path)
    files.len()

fn dir_count_dirs(path: text) -> i64:
    """Count number of subdirectories recursively.

    Args:
        path: Directory path

    Returns:
        Directory count
    """
    val dirs = dir_walk_dirs(path)
    dirs.len()

# ============================================================================
# Exports
# ============================================================================

export dir_create, dir_create_all, dir_list, dir_list_detailed
export dir_delete, dir_delete_all, dir_exists, dir_is_empty
export dir_walk, dir_walk_files, dir_walk_dirs
export dir_copy, dir_move, dir_size, dir_count_files, dir_count_dirs
