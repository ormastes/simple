# Path Operations
#
# Path manipulation: join, split, normalize, basename, dirname, extension.
# Re-exports and extends functionality from std.path module.
# All operations are platform-agnostic using forward slashes.

use std.path

fn path_join(parts: [text]) -> text:
    """Join path components.

    Args:
        parts: Array of path parts

    Returns:
        Joined path
    """
    path.path_join(parts)

fn path_join2(a: text, b: text) -> text:
    """Join two path components.

    Args:
        a: First part
        b: Second part

    Returns:
        Joined path
    """
    path.join2(a, b)

fn path_basename(p: text) -> text:
    """Get basename (last component) of path.

    Args:
        p: Path

    Returns:
        Basename
    """
    path.basename(p)

fn path_dirname(p: text) -> text:
    """Get directory name of path.

    Args:
        p: Path

    Returns:
        Directory name
    """
    path.dirname(p)

fn path_extension(p: text) -> text:
    """Get file extension without dot.

    Args:
        p: Path

    Returns:
        Extension (empty if none)
    """
    path.extension(p)

fn path_stem(p: text) -> text:
    """Get filename without extension.

    Args:
        p: Path

    Returns:
        Stem
    """
    path.stem(p)

fn path_normalize(p: text) -> text:
    """Normalize path (resolve . and ..).

    Args:
        p: Path

    Returns:
        Normalized path
    """
    path.normalize(p)

fn path_is_absolute(p: text) -> bool:
    """Check if path is absolute.

    Args:
        p: Path

    Returns:
        true if absolute
    """
    path.is_absolute(p)

fn path_is_relative(p: text) -> bool:
    """Check if path is relative.

    Args:
        p: Path

    Returns:
        true if relative
    """
    path.is_relative(p)

fn path_resolve(p: text, base: text) -> text:
    """Resolve relative path against base.

    Args:
        p: Path to resolve
        base: Base path

    Returns:
        Resolved absolute path
    """
    path.resolve(p, base)

fn path_relative_to(p: text, base: text) -> text:
    """Make path relative to base.

    Args:
        p: Path
        base: Base path

    Returns:
        Relative path
    """
    path.relative_to(p, base)

fn path_split(p: text) -> [text]:
    """Split path into components.

    Args:
        p: Path

    Returns:
        Array of path components
    """
    if p == "":
        return []
    val normalized = path_normalize(p)
    normalized.split("/")

fn path_with_extension(p: text, ext: text) -> text:
    """Replace file extension.

    Args:
        p: Path
        ext: New extension

    Returns:
        Path with new extension
    """
    val stem = path_stem(p)
    val dir = path_dirname(p)
    val new_name = stem + "." + ext
    path_join2(dir, new_name)

fn path_has_extension(p: text, ext: text) -> bool:
    """Check if path has given extension.

    Args:
        p: Path
        ext: Extension to check

    Returns:
        true if matches
    """
    path.has_extension(p, ext)

fn path_common_prefix(paths: [text]) -> text:
    """Find common prefix of multiple paths.

    Args:
        paths: Array of paths

    Returns:
        Common prefix path
    """
    if paths.len() == 0:
        return ""
    if paths.len() == 1:
        return paths[0]

    var prefix = paths[0]
    for i in 1..paths.len():
        val p = paths[i]
        prefix = path_common_prefix_two(prefix, p)

    prefix

fn path_common_prefix_two(a: text, b: text) -> text:
    """Find common prefix of two paths."""
    val a_parts = path_split(a)
    val b_parts = path_split(b)
    var common = []

    val min_len = if a_parts.len() < b_parts.len():
        a_parts.len()
    else:
        b_parts.len()

    for i in 0..min_len:
        if a_parts[i] == b_parts[i]:
            common.push(a_parts[i])
        else:
            break

    path_join(common)

# ============================================================================
# Exports
# ============================================================================

export path_join, path_join2, path_basename, path_dirname
export path_extension, path_stem, path_normalize
export path_is_absolute, path_is_relative, path_resolve, path_relative_to
export path_split, path_with_extension, path_has_extension, path_common_prefix
