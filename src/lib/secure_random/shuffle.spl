# Shuffle and Sampling Operations
#
# Functions for random choice, sampling, and shuffling

import "generate" as Generate

# Choose random element from list
fn secure_choice(items: list):
    if items.length() == 0:
        return nil
    var index = Generate.secure_random_int(0, items.length() - 1)
    items.get(index)

# Sample n elements from list (without replacement)
fn secure_sample(items: list, n: i64) -> list:
    if n >= items.length():
        return secure_shuffle(items)
    var remaining = []
    var i = 0
    while i < items.length():
        remaining.append(items.get(i))
        i = i + 1
    var result = []
    var count = 0
    while count < n:
        if remaining.length() == 0:
            break
        var index = Generate.secure_random_int(0, remaining.length() - 1)
        result.append(remaining.get(index))
        var new_remaining = []
        var j = 0
        while j < remaining.length():
            if j != index:
                new_remaining.append(remaining.get(j))
            j = j + 1
        remaining = new_remaining
        count = count + 1
    result

# Shuffle list (Fisher-Yates shuffle)
fn secure_shuffle(items: list) -> list:
    var result = []
    var i = 0
    while i < items.length():
        result.append(items.get(i))
        i = i + 1
    var n = result.length()
    var j = n - 1
    while j > 0:
        var k = Generate.secure_random_int(0, j)
        var temp = result.get(j)
        result.set(j, result.get(k))
        result.set(k, temp)
        j = j - 1
    result

# Weighted random choice
fn secure_weighted_choice(items: list, weights: list):
    if items.length() != weights.length():
        return nil
    if items.length() == 0:
        return nil
    var total = 0.0
    var i = 0
    while i < weights.length():
        total = total + weights.get(i)
        i = i + 1
    if total <= 0.0:
        return nil
    var rand = Generate.secure_random_float() * total
    var cumulative = 0.0
    var j = 0
    while j < items.length():
        cumulative = cumulative + weights.get(j)
        if rand < cumulative:
            return items.get(j)
        j = j + 1
    items.get(items.length() - 1)

# Generate random permutation of integers [0, n)
fn secure_random_permutation(n: i64) -> list:
    var items = []
    var i = 0
    while i < n:
        items.append(i)
        i = i + 1
    secure_shuffle(items)

# Generate random subset (each element included with probability p)
fn secure_random_subset(items: list, probability: f64) -> list:
    var result = []
    var i = 0
    while i < items.length():
        var rand = Generate.secure_random_float()
        if rand < probability:
            result.append(items.get(i))
        i = i + 1
    result

export secure_choice
export secure_sample
export secure_shuffle
export secure_weighted_choice
export secure_random_permutation
export secure_random_subset
