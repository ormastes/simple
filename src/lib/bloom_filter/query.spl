# Bloom Filter Query Operations

from "std/bloom_filter/types" import get_bit, count_set_bits
from "std/bloom_filter/utilities" import multi_hash, fingerprint, fnv1a_hash, hash_combine
from "std/bloom_filter/create" import expected_error_rate
import math from "std/math"

# ============================================================================
# STANDARD BLOOM FILTER
# ============================================================================

# Check if an item might be in the Bloom filter
fn bf_contains(filter: tuple, item: text) -> bool:
    val size = filter[1]
    val num_hashes = filter[2]
    val bits = filter[3]

    val indices = multi_hash(item, num_hashes, size)
    for i in 0..indices.length():
        val index = indices[i]
        if not get_bit(bits, index):
            return false
    true

# Get the number of items added to the filter
fn bf_count(filter: tuple) -> i64:
    filter[4]

# Get the fill ratio (proportion of bits set)
fn bf_fill_ratio(filter: tuple) -> f64:
    val size = filter[1]
    val bits = filter[3]
    val set_bits = count_set_bits(bits, size)
    set_bits.to_f64() / size.to_f64()

# Estimate the number of items in the filter using fill ratio
# Formula: n â‰ˆ -(m/k) * ln(1 - X/m)
# where X = number of bits set
fn estimate_items(filter: tuple) -> i64:
    val size = filter[1]
    val num_hashes = filter[2]
    val bits = filter[3]

    val set_bits = count_set_bits(bits, size)
    val x = set_bits.to_f64()
    val m = size.to_f64()
    val k = num_hashes.to_f64()

    if x >= m:
        size  # Filter is full
    else:
        val ratio = 1.0 - (x / m)
        val ln_ratio = math.ln(ratio)
        val estimate = -(m / k) * ln_ratio
        estimate.to_i64()

# Calculate actual error rate based on current state
fn actual_error_rate(filter: tuple) -> f64:
    val size = filter[1]
    val num_hashes = filter[2]
    val item_count = filter[4]
    expected_error_rate(size, num_hashes, item_count)

# Check if filter is empty (no items added)
fn is_empty(filter: tuple) -> bool:
    filter[4] == 0

# ============================================================================
# COUNTING BLOOM FILTER
# ============================================================================

# Check if item is in counting filter
fn cf_contains(filter: tuple, item: text) -> bool:
    val size = filter[1]
    val num_hashes = filter[2]
    val counters = filter[3]

    val indices = multi_hash(item, num_hashes, size)
    for i in 0..indices.length():
        val index = indices[i]
        if counters[index] == 0:
            return false
    true

# Get counter value for an item (minimum counter)
fn cf_get_count(filter: tuple, item: text) -> i64:
    val size = filter[1]
    val num_hashes = filter[2]
    val counters = filter[3]

    val indices = multi_hash(item, num_hashes, size)
    var min_count = 255
    for i in 0..indices.length():
        val index = indices[i]
        val count = counters[index]
        if count < min_count:
            min_count = count
    min_count

# ============================================================================
# SCALABLE BLOOM FILTER
# ============================================================================

# Check if item is in scalable filter
fn sf_contains(filter: tuple, item: text) -> bool:
    val filters = filter[4]
    for i in 0..filters.length():
        val sub_filter = filters[i]
        if bf_contains(sub_filter, item):
            return true
    false

# Get total items in scalable filter
fn sf_count(filter: tuple) -> i64:
    filter[5]

# Get number of sub-filters
fn sf_num_filters(filter: tuple) -> i64:
    val filters = filter[4]
    filters.length()

# Get total capacity across all filters
fn sf_total_capacity(filter: tuple) -> i64:
    val initial_capacity = filter[1]
    val growth_factor = filter[3]
    val filters = filter[4]

    var total = 0
    for i in 0..filters.length():
        val capacity = initial_capacity * (growth_factor ** i)
        total = total + capacity
    total

# ============================================================================
# CUCKOO FILTER
# ============================================================================

# Find fingerprint in bucket
fn find_in_bucket_cuckoo(bucket: List, fp: i64) -> bool:
    for i in 0..bucket.length():
        if bucket[i] == fp:
            return true
    false

# Get alternate bucket index for cuckoo hashing
fn cuckoo_alt_index_query(index: i64, fp: i64, bucket_count: i64) -> i64:
    val hash_fp = hash_combine(index, fp)
    (index ^ hash_fp) % bucket_count

# Check if item is in cuckoo filter
fn cuckoo_contains(filter: tuple, item: text) -> bool:
    val bucket_count = filter[1]
    val fingerprint_size = filter[3]
    val buckets = filter[4]

    val fp = fingerprint(item, fingerprint_size)
    val h1 = fnv1a_hash(item) % bucket_count
    val h2 = cuckoo_alt_index_query(h1, fp, bucket_count)

    val bucket1 = buckets[h1]
    val bucket2 = buckets[h2]

    find_in_bucket_cuckoo(bucket1, fp) or find_in_bucket_cuckoo(bucket2, fp)

# Get item count in cuckoo filter
fn cuckoo_count(filter: tuple) -> i64:
    filter[5]

# Get load factor (fullness) of cuckoo filter
fn cuckoo_load_factor(filter: tuple) -> f64:
    val bucket_count = filter[1]
    val bucket_size = filter[2]
    val item_count = filter[5]
    val total_slots = bucket_count * bucket_size
    item_count.to_f64() / total_slots.to_f64()
