# JWT Encoding Module
#
# This module handles Base64URL encoding and JSON encoding operations.

# ============================================================================
# Base64URL Encoding/Decoding
# ============================================================================

# Base64 character set
fn base64_chars() -> text:
    "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"

# Base64URL character set (replaces + with -, / with _)
fn base64url_chars() -> text:
    "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_"

# Get character index in Base64 alphabet
fn base64_char_index(c: text, alphabet: text) -> i64:
    var i = 0
    var len = alphabet.length()
    while i < len:
        var ch = alphabet.substring(i, i + 1)
        if ch == c:
            return i
        i = i + 1
    return -1

# Encode bytes to Base64
fn base64_encode(data: text) -> text:
    var result = ""
    var alphabet = base64_chars()
    var len = data.length()
    var i = 0

    while i < len:
        var b1 = data.char_code_at(i)
        var b2 = 0
        var b3 = 0

        if i + 1 < len:
            b2 = data.char_code_at(i + 1)
        if i + 2 < len:
            b3 = data.char_code_at(i + 2)

        # Convert 3 bytes to 4 Base64 characters
        var idx1 = b1 >> 2
        var idx2 = ((b1 & 3) << 4) | (b2 >> 4)
        var idx3 = ((b2 & 15) << 2) | (b3 >> 6)
        var idx4 = b3 & 63

        var c1 = alphabet.substring(idx1, idx1 + 1)
        result = result + c1
        var c2 = alphabet.substring(idx2, idx2 + 1)
        result = result + c2

        if i + 1 < len:
            var c3 = alphabet.substring(idx3, idx3 + 1)
            result = result + c3
        else:
            result = result + "="

        if i + 2 < len:
            var c4 = alphabet.substring(idx4, idx4 + 1)
            result = result + c4
        else:
            result = result + "="

        i = i + 3

    return result

# Decode Base64 to bytes
fn base64_decode(encoded: text) -> text:
    var alphabet = base64_chars()
    var result = ""
    var len = encoded.length()
    var i = 0

    # Remove padding
    var clean = encoded.replace("=", "")
    var clean_len = clean.length()

    while i < clean_len:
        var c1 = clean.substring(i, i + 1)
        var idx1 = base64_char_index(c1, alphabet)

        if i + 1 >= clean_len:
            break

        var c2 = clean.substring(i + 1, i + 2)
        var idx2 = base64_char_index(c2, alphabet)

        # First byte
        var b1 = (idx1 << 2) | (idx2 >> 4)
        result = result + text.from_char_code(b1)

        if i + 2 < clean_len:
            var c3 = clean.substring(i + 2, i + 3)
            var idx3 = base64_char_index(c3, alphabet)
            var b2 = ((idx2 & 15) << 4) | (idx3 >> 2)
            result = result + text.from_char_code(b2)

        if i + 3 < clean_len:
            var c4 = clean.substring(i + 3, i + 4)
            var idx4 = base64_char_index(c4, alphabet)
            var b3 = ((idx3 & 3) << 6) | idx4
            result = result + text.from_char_code(b3)

        i = i + 4

    return result

# Encode to Base64URL (URL-safe Base64 without padding)
fn base64url_encode(data: text) -> text:
    var b64 = base64_encode(data)
    var result = b64.replace("+", "-")
    result = result.replace("/", "_")
    result = result.replace("=", "")
    return result

# Decode from Base64URL
fn base64url_decode(encoded: text) -> text:
    var b64 = encoded.replace("-", "+")
    b64 = b64.replace("_", "/")

    # Add padding
    var mod = b64.length() % 4
    if mod == 2:
        b64 = b64 + "=="
    if mod == 3:
        b64 = b64 + "="

    return base64_decode(b64)

# Strip Base64 padding
fn strip_padding(encoded: text) -> text:
    return encoded.replace("=", "")

# Add Base64 padding
fn pad_base64(encoded: text) -> text:
    var mod = encoded.length() % 4
    if mod == 0:
        return encoded
    if mod == 2:
        return encoded + "=="
    if mod == 3:
        return encoded + "="
    return encoded

# ============================================================================
# JSON Encoding/Decoding
# ============================================================================

# Escape string for JSON
fn json_escape_string(s: text) -> text:
    var result = s
    result = result.replace("\\", "\\\\")
    result = result.replace("\"", "\\\"")
    result = result.replace("\n", "\\n")
    result = result.replace("\r", "\\r")
    result = result.replace("\t", "\\t")
    return result

# Encode list of tuples to JSON object
fn json_encode_object(tuples: list) -> text:
    var result = "{"
    var i = 0
    var len = tuples.length()

    while i < len:
        var tuple = tuples.at(i)
        var key = tuple.at(0)
        var value = tuple.at(1)

        if i > 0:
            result = result + ","

        var escaped_key = json_escape_string(key)
        result = result + "\"" + escaped_key + "\":"

        # Encode value based on type
        var value_str = text.from_any(value)

        # Check if value is numeric
        var is_numeric = false
        var first_char = ""
        if value_str.length() > 0:
            first_char = value_str.substring(0, 1)

        var is_digit = first_char == "0" or first_char == "1" or first_char == "2"
        is_digit = is_digit or first_char == "3" or first_char == "4"
        is_digit = is_digit or first_char == "5" or first_char == "6"
        is_digit = is_digit or first_char == "7" or first_char == "8"
        is_digit = is_digit or first_char == "9" or first_char == "-"

        if is_digit:
            result = result + value_str
        else:
            var escaped_value = json_escape_string(value_str)
            result = result + "\"" + escaped_value + "\""

        i = i + 1

    result = result + "}"
    return result

# Encode claims list to JSON
fn json_encode(claims: list) -> text:
    return json_encode_object(claims)

# Convert claims to JSON string (alias)
fn claims_to_json(claims: list) -> text:
    return json_encode(claims)

# Pretty-print JSON
fn json_stringify(claims: list) -> text:
    return json_encode(claims)
