# JWT Signing Module
#
# This module handles HMAC-SHA256/384/512 signing operations.

# ============================================================================
# SHA-256 Implementation
# ============================================================================

# SHA-256 constants (first 32 bits of fractional parts of cube roots of first 64 primes)
fn sha256_k() -> list:
    return [
        1116352408, 1899447441, 3049323471, 3921009573,
        961987163, 1508970993, 2453635748, 2870763221,
        3624381080, 310598401, 607225278, 1426881987,
        1925078388, 2162078206, 2614888103, 3248222580,
        3835390401, 4022224774, 264347078, 604807628,
        770255983, 1249150122, 1555081692, 1996064986,
        2554220882, 2821834349, 2952996808, 3210313671,
        3336571891, 3584528711, 113926993, 338241895,
        666307205, 773529912, 1294757372, 1396182291,
        1695183700, 1986661051, 2177026350, 2456956037,
        2730485921, 2820302411, 3259730800, 3345764771,
        3516065817, 3600352804, 4094571909, 275423344,
        430227734, 506948616, 659060556, 883997877,
        958139571, 1322822218, 1537002063, 1747873779,
        1955562222, 2024104815, 2227730452, 2361852424,
        2428436474, 2756734187, 3204031479, 3329325298
    ]

# Right rotate 32-bit integer
fn rotr32(n: i64, b: i64) -> i64:
    var mask = 4294967295  # 0xFFFFFFFF
    var n_masked = n & mask
    var shifted = n_masked >> b
    var rotated = n_masked << (32 - b)
    var result = (shifted | rotated) & mask
    return result

# Real SHA-256 hash per FIPS 180-4.
# Returns hex-encoded digest string (64 hex characters).
fn sha256_hash(message: text) -> text:
    var mask32 = 4294967295  # 0xFFFFFFFF

    # Initial hash values
    var h0 = 1779033703
    var h1 = 3144134277
    var h2 = 1013904242
    var h3 = 2773480762
    var h4 = 1359893119
    var h5 = 2600822924
    var h6 = 528734635
    var h7 = 1541459225

    # Round constants
    var kk = sha256_k()

    # Convert message to bytes
    var msg_len = message.length()
    var bytes = []
    var bi = 0
    while bi < msg_len:
        bytes.push(message.char_code_at(bi))
        bi = bi + 1

    # Pre-processing: pad to 512-bit blocks
    var data_len = bytes.length()
    bytes.push(128)  # 0x80

    var pad_target = data_len + 1
    var pad_zeros = 56 - (pad_target % 64)
    if pad_zeros < 0:
        pad_zeros = pad_zeros + 64
    var pz = 0
    while pz < pad_zeros:
        bytes.push(0)
        pz = pz + 1

    # Append 64-bit big-endian length in bits
    var bit_length = data_len * 8
    bytes.push(0)
    bytes.push(0)
    bytes.push(0)
    bytes.push(0)
    bytes.push((bit_length >> 24) & 255)
    bytes.push((bit_length >> 16) & 255)
    bytes.push((bit_length >> 8) & 255)
    bytes.push(bit_length & 255)

    # Process each 64-byte block
    var total_len = bytes.length()
    var block_off = 0
    while block_off < total_len:
        # Build message schedule w[0..63]
        var w = []
        var wi = 0
        while wi < 16:
            var base = block_off + (wi * 4)
            var b0 = bytes[base] & 255
            var b1_v = bytes[base + 1] & 255
            var b2_v = bytes[base + 2] & 255
            var b3_v = bytes[base + 3] & 255
            var word = ((b0 << 24) | (b1_v << 16) | (b2_v << 8) | b3_v) & mask32
            w.push(word)
            wi = wi + 1

        wi = 16
        while wi < 64:
            var w15 = w[wi - 15] & mask32
            var w2 = w[wi - 2] & mask32
            var r7 = ((w15 >> 7) | (w15 << 25)) & mask32
            var r18 = ((w15 >> 18) | (w15 << 14)) & mask32
            var sh3 = (w15 >> 3) & mask32
            var s0 = (r7 ^ r18 ^ sh3) & mask32
            var r17 = ((w2 >> 17) | (w2 << 15)) & mask32
            var r19 = ((w2 >> 19) | (w2 << 13)) & mask32
            var sh10 = (w2 >> 10) & mask32
            var s1 = (r17 ^ r19 ^ sh10) & mask32
            var new_w = (w[wi - 16] + s0 + w[wi - 7] + s1) & mask32
            w.push(new_w)
            wi = wi + 1

        var a = h0
        var b = h1
        var c = h2
        var d = h3
        var e = h4
        var f = h5
        var g = h6
        var hv = h7

        var ri = 0
        while ri < 64:
            var ea = e & mask32
            var er6 = ((ea >> 6) | (ea << 26)) & mask32
            var er11 = ((ea >> 11) | (ea << 21)) & mask32
            var er25 = ((ea >> 25) | (ea << 7)) & mask32
            var big_s1 = (er6 ^ er11 ^ er25) & mask32
            var ch = ((ea & (f & mask32)) ^ ((~ea & mask32) & (g & mask32))) & mask32
            var temp1 = (hv + big_s1 + ch + kk[ri] + w[ri]) & mask32

            var aa = a & mask32
            var ar2 = ((aa >> 2) | (aa << 30)) & mask32
            var ar13 = ((aa >> 13) | (aa << 19)) & mask32
            var ar22 = ((aa >> 22) | (aa << 10)) & mask32
            var big_s0 = (ar2 ^ ar13 ^ ar22) & mask32
            var maj = ((aa & (b & mask32)) ^ (aa & (c & mask32)) ^ ((b & mask32) & (c & mask32))) & mask32
            var temp2 = (big_s0 + maj) & mask32

            hv = g
            g = f
            f = e
            e = (d + temp1) & mask32
            d = c
            c = b
            b = a
            a = (temp1 + temp2) & mask32
            ri = ri + 1

        h0 = (h0 + a) & mask32
        h1 = (h1 + b) & mask32
        h2 = (h2 + c) & mask32
        h3 = (h3 + d) & mask32
        h4 = (h4 + e) & mask32
        h5 = (h5 + f) & mask32
        h6 = (h6 + g) & mask32
        h7 = (h7 + hv) & mask32

        block_off = block_off + 64

    # Convert hash words to hex string
    var hex_chars = "0123456789abcdef"
    var result = ""
    var h_vals = [h0, h1, h2, h3, h4, h5, h6, h7]
    var hi = 0
    while hi < 8:
        var word = h_vals[hi] & mask32
        var nibble_idx = 7
        while nibble_idx >= 0:
            var nibble = (word >> (nibble_idx * 4)) & 15
            var hex_char = hex_chars.substring(nibble, nibble + 1)
            result = result + hex_char
            nibble_idx = nibble_idx - 1
        hi = hi + 1

    return result

# ============================================================================
# HMAC-SHA Implementation
# ============================================================================

# HMAC-SHA256 (simplified)
fn hmac_sha256(key: text, message: text) -> text:
    # Simplified HMAC implementation for demonstration
    # In production, use proper HMAC-SHA256 via FFI

    var block_size = 64  # SHA-256 block size
    var key_len = key.length()

    # Adjust key length
    var actual_key = key
    if key_len > block_size:
        actual_key = sha256_hash(key)

    # Pad key to block size
    var padded_key = actual_key
    while padded_key.length() < block_size:
        padded_key = padded_key + "\x00"

    # Create inner and outer padded keys
    var i_pad = ""
    var o_pad = ""
    var i = 0

    while i < block_size:
        var k_byte = 0
        if i < padded_key.length():
            k_byte = padded_key.char_code_at(i)

        var i_byte = k_byte ^ 54  # 0x36
        i_pad = i_pad + text.from_char_code(i_byte)

        var o_byte = k_byte ^ 92  # 0x5c
        o_pad = o_pad + text.from_char_code(o_byte)

        i = i + 1

    # HMAC = H(o_pad || H(i_pad || message))
    var inner_msg = i_pad + message
    var inner_hash = sha256_hash(inner_msg)
    var outer_msg = o_pad + inner_hash
    var result = sha256_hash(outer_msg)

    return result

# HMAC-SHA384 (simplified - uses SHA-256 as base for demonstration)
fn hmac_sha384(key: text, message: text) -> text:
    # In production, implement proper SHA-384
    # For now, use SHA-256 with different initialization
    var hash1 = hmac_sha256(key, message)
    var hash2 = hmac_sha256(key + "384", message)
    return hash1 + hash2.substring(0, 8)

# HMAC-SHA512 (simplified - uses SHA-256 as base for demonstration)
fn hmac_sha512(key: text, message: text) -> text:
    # In production, implement proper SHA-512
    # For now, use SHA-256 with different initialization
    var hash1 = hmac_sha256(key, message)
    var hash2 = hmac_sha256(key + "512", message)
    return hash1 + hash2

# ============================================================================
# Signing Functions
# ============================================================================

# Sign data with HS256
fn sign_hs256(data: text, secret: text) -> text:
    return hmac_sha256(secret, data)

# Sign data with HS384
fn sign_hs384(data: text, secret: text) -> text:
    return hmac_sha384(secret, data)

# Sign data with HS512
fn sign_hs512(data: text, secret: text) -> text:
    return hmac_sha512(secret, data)

# Sign data with specified algorithm
fn sign_with_algorithm(data: text, secret: text, alg: text) -> text:
    if alg == "HS256":
        return sign_hs256(data, secret)
    if alg == "HS384":
        return sign_hs384(data, secret)
    if alg == "HS512":
        return sign_hs512(data, secret)
    return ""

# Constant-time string comparison (prevent timing attacks)
fn constant_time_compare(a: text, b: text) -> bool:
    var a_len = a.length()
    var b_len = b.length()

    # Different lengths = not equal, but check entire strings anyway
    var result = a_len == b_len
    var max_len = a_len
    if b_len > max_len:
        max_len = b_len

    var i = 0
    while i < max_len:
        var a_char = 0
        var b_char = 0

        if i < a_len:
            a_char = a.char_code_at(i)
        if i < b_len:
            b_char = b.char_code_at(i)

        var equal_chars = a_char == b_char
        if not equal_chars:
            result = false

        i = i + 1

    return result
