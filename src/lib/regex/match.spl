# Regular Expression Matching Module

from .types import RegexPattern, MatchResult
from .parse import is_digit_char, is_word_char, is_whitespace_char

# ============================================================================
# SIMPLE PATTERN MATCHING (for basic patterns without NFA)
# ============================================================================

fn simple_literal_match(pattern: text, text_str: text, start: i64) -> bool:
    """Match literal pattern at position start."""
    if start + pattern.len() > text_str.len():
        return false

    var i = 0
    while i < pattern.len():
        if pattern[i:i + 1] != text_str[start + i:start + i + 1]:
            return false
        i = i + 1
    true

fn simple_wildcard_match(pattern: text, text_str: text, start: i64) -> bool:
    """Match pattern with wildcards (. matches any char)."""
    if start + pattern.len() > text_str.len():
        return false

    var i = 0
    while i < pattern.len():
        val p_ch = pattern[i:i + 1]
        if p_ch != ".":
            if p_ch != text_str[start + i:start + i + 1]:
                return false
        i = i + 1
    true

fn match_char_at(pattern: text, text_str: text, p_pos: i64, t_pos: i64) -> bool:
    """Match single pattern character against text character."""
    if t_pos >= text_str.len():
        return false

    val p_ch = pattern[p_pos:p_pos + 1]
    val t_ch = text_str[t_pos:t_pos + 1]

    if p_ch == ".":
        return true

    if p_ch == "\\":
        if p_pos + 1 < pattern.len():
            val esc = pattern[p_pos + 1:p_pos + 2]
            if esc == "d":
                return is_digit_char(t_ch)
            if esc == "w":
                return is_word_char(t_ch)
            if esc == "s":
                return is_whitespace_char(t_ch)
            if esc == "n":
                return t_ch == "\n"
            if esc == "t":
                return t_ch == "\t"
            return t_ch == esc
        return false

    p_ch == t_ch

fn matches_simple(pattern: text, text_str: text) -> bool:
    """Simple pattern matching for basic patterns (no complex features)."""
    # Handle anchors
    var pat = pattern
    var anchored_start = false
    var anchored_end = false

    if pat.len() > 0 and pat[0:1] == "^":
        anchored_start = true
        pat = pat[1:]

    if pat.len() > 0 and pat[pat.len() - 1:pat.len()] == "$":
        anchored_end = true
        pat = pat[0:pat.len() - 1]

    # Try matching at each position
    if anchored_start:
        if anchored_end:
            return simple_wildcard_match(pat, text_str, 0) and pat.len() == text_str.len()
        return simple_wildcard_match(pat, text_str, 0)

    if anchored_end:
        val start = text_str.len() - pat.len()
        if start < 0:
            return false
        return simple_wildcard_match(pat, text_str, start)

    # Try at each position
    var i = 0
    while i <= text_str.len() - pat.len():
        if simple_wildcard_match(pat, text_str, i):
            return true
        i = i + 1
    false

# ============================================================================
# PATTERN COMPILATION
# ============================================================================

fn compile_pattern(pattern: text) -> RegexPattern:
    """Compile regex pattern into internal representation."""
    from .parse import validate_pattern

    val error = validate_pattern(pattern)
    if error != "":
        # Return invalid pattern marker
        return RegexPattern(
            pattern_str: pattern,
            start_state: -1,
            accept_state: -1,
            states: [],
            anchored_start: false,
            anchored_end: false,
            group_count: 0
        )

    # Detect anchors
    var anchored_start = false
    var anchored_end = false
    var pat = pattern

    if pat.len() > 0 and pat[0:1] == "^":
        anchored_start = true
        pat = pat[1:]

    if pat.len() > 0 and pat[pat.len() - 1:pat.len()] == "$":
        anchored_end = true
        pat = pat[0:pat.len() - 1]

    # Count groups
    var group_count = 0
    var i = 0
    while i < pat.len():
        if pat[i:i + 1] == "(":
            group_count = group_count + 1
        if pat[i:i + 1] == "\\":
            i = i + 1
        i = i + 1

    RegexPattern(
        pattern_str: pattern,
        start_state: 0,
        accept_state: 1,
        states: [pattern],
        anchored_start: anchored_start,
        anchored_end: anchored_end,
        group_count: group_count
    )

# ============================================================================
# MATCHING FUNCTIONS
# ============================================================================

fn is_match(regex: RegexPattern, text_str: text) -> bool:
    """Check if pattern matches anywhere in text."""
    matches(regex, text_str)

fn matches(regex: RegexPattern, text_str: text) -> bool:
    """Check if pattern matches anywhere in text (alias for is_match)."""
    if regex.start_state == -1:
        return false

    # Use simple matching for now
    matches_simple(regex.pattern_str, text_str)

fn match_at(regex: RegexPattern, text_str: text, pos: i64) -> MatchResult:
    """Try to match pattern starting at position pos."""
    if regex.start_state == -1:
        return MatchResult(matched: false, start_pos: 0, end_pos: 0, groups: [])

    if pos < 0 or pos >= text_str.len():
        return MatchResult(matched: false, start_pos: 0, end_pos: 0, groups: [])

    # Simple implementation: try literal match
    val substr = text_str[pos:]
    if matches_simple(regex.pattern_str, substr):
        # Find match length (simplified)
        val len = estimate_match_length(regex.pattern_str, substr)
        val groups = [text_str[pos:pos + len]]
        return MatchResult(matched: true, start_pos: pos, end_pos: pos + len, groups: groups)

    MatchResult(matched: false, start_pos: 0, end_pos: 0, groups: [])

fn estimate_match_length(pattern: text, text_str: text) -> i64:
    """Estimate length of match (simplified version)."""
    from .parse import is_special_char

    # Remove anchors
    var pat = pattern
    if pat.len() > 0 and pat[0:1] == "^":
        pat = pat[1:]
    if pat.len() > 0 and pat[pat.len() - 1:pat.len()] == "$":
        pat = pat[0:pat.len() - 1]

    # For simple patterns, return pattern length
    var len = 0
    var i = 0
    while i < pat.len():
        val ch = pat[i:i + 1]
        if ch == "\\":
            i = i + 2
            len = len + 1
        else:
            if ch == "." or is_special_char(ch) == false:
                len = len + 1
            i = i + 1
    len

fn match_full(regex: RegexPattern, text_str: text) -> bool:
    """Check if pattern matches entire text (implicitly anchored)."""
    val result = match_at(regex, text_str, 0)
    val full_match = result.matched and result.start_pos == 0
    full_match and result.end_pos == text_str.len()

fn match_prefix(regex: RegexPattern, text_str: text) -> bool:
    """Check if pattern matches at start of text."""
    val result = match_at(regex, text_str, 0)
    result.matched and result.start_pos == 0

fn match_suffix(regex: RegexPattern, text_str: text) -> bool:
    """Check if pattern matches at end of text."""
    from .utilities import ends_with_pattern
    ends_with_pattern(regex, text_str)

fn contains_match(regex: RegexPattern, text_str: text) -> bool:
    """Check if text contains pattern match anywhere."""
    matches(regex, text_str)

export compile_pattern
export is_match, matches, match_at, match_full, match_prefix, match_suffix, contains_match
