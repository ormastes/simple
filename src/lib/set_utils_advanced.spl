# Set Utilities - Advanced Operations
#
# Extracted from set_utils.spl. Contains:
# - Advanced: set_powerset, set_cartesian_product, set_comprehension
# - Iteration: set_foreach, set_reduce, set_any, set_all, set_count, set_find
# - Copying: set_copy, set_clone
# - Utility: set_min, set_max, set_sum, set_product, set_to_string
# - Convenience: set_pop, set_sample, set_split_at
# - Examples: _example_basic_usage, _example_set_algebra, etc.

use lib.set_utils.{
    _to_key, set_new, set_from_array, set_add, set_remove,
    set_contains, set_size, set_is_empty, set_to_array, set_to_sorted_array,
    set_union, set_intersection, set_difference, set_symmetric_difference,
    set_map, set_filter, set_partition
}

# ============================================================================
# Advanced Set Operations
# ============================================================================

fn set_powerset(s):
    """Generate the powerset (set of all subsets).
    Returns array of sets.

    Warning: Size grows exponentially (2^n). Use with small sets.

    Example:
        val s = set_from_array([1, 2])
        val ps = set_powerset(s)
        # [{}, {1}, {2}, {1, 2}]
    """
    val elements = set_to_array(s)
    var subsets = [{}]

    for elem in elements:
        val ek = "{elem}"
        var new_subsets = []
        for subset in subsets:
            # Build new subset by copying existing + adding elem directly
            var ns = {}
            for k in subset.keys():
                ns[k] = subset[k]
            ns[ek] = elem
            new_subsets = new_subsets.push(ns)
        for ns in new_subsets:
            subsets = subsets.push(ns)

    subsets

fn set_cartesian_product(a, b):
    """Compute Cartesian product of two sets.
    Returns set of tuples (pairs).

    Example:
        val a = set_from_array([1, 2])
        val b = set_from_array(["x", "y"])
        val prod = set_cartesian_product(a, b)
        # {(1, "x"), (1, "y"), (2, "x"), (2, "y")}
    """
    var result = {}
    for k1 in a.keys():
        for k2 in b.keys():
            val pair = (a[k1], b[k2])
            val pk = "{pair}"
            result[pk] = pair
    result

fn set_comprehension(source, predicate, mapper):
    """Set comprehension: {mapper(x) | x <- source if predicate(x)}.

    Example:
        val s = set_from_array([1, 2, 3, 4, 5])
        val comp = set_comprehension(s, \x: x % 2 == 0, \x: x * x)
        # {4, 16} - squares of even numbers
    """
    var result = {}
    for k in source.keys():
        if predicate(source[k]):
            val mapped = mapper(source[k])
            val mk = "{mapped}"
            result[mk] = mapped
    result

# ============================================================================
# Iteration Operations
# ============================================================================

fn set_foreach(s, action):
    """Execute action for each element in the set.

    Example:
        val s = set_from_array([1, 2, 3])
        set_foreach(s, \x: print("{x}"))
    """
    for k in s.keys():
        action(s[k])
    nil

fn set_reduce(s, initial, reducer):
    """Reduce set to a single value using reducer function.

    Example:
        val s = set_from_array([1, 2, 3, 4])
        val sum = set_reduce(s, 0, \acc, x: acc + x)  # 10
    """
    var acc = initial
    for k in s.keys():
        acc = reducer(acc, s[k])
    acc

fn set_any(s, predicate) -> bool:
    """Check if any element satisfies the predicate.

    Example:
        val s = set_from_array([1, 2, 3, 4])
        set_any(s, \x: x > 3)  # true
    """
    for k in s.keys():
        if predicate(s[k]):
            return true
    false

fn set_all(s, predicate) -> bool:
    """Check if all elements satisfy the predicate.

    Example:
        val s = set_from_array([2, 4, 6, 8])
        set_all(s, \x: x % 2 == 0)  # true
    """
    for k in s.keys():
        if not predicate(s[k]):
            return false
    true

fn set_count(s, predicate) -> i64:
    """Count elements that satisfy the predicate.

    Example:
        val s = set_from_array([1, 2, 3, 4, 5])
        set_count(s, \x: x % 2 == 0)  # 2
    """
    var count = 0
    for k in s.keys():
        if predicate(s[k]):
            count = count + 1
    count

fn set_find(s, predicate):
    """Find first element satisfying predicate. Returns nil if not found.

    Note: Order is not guaranteed in sets.

    Example:
        val s = set_from_array([1, 2, 3, 4, 5])
        val found = set_find(s, \x: x > 3)  # Could be 4 or 5
    """
    for k in s.keys():
        if predicate(s[k]):
            return s[k]
    nil

# ============================================================================
# Set Copying
# ============================================================================

fn set_copy(s):
    """Create a shallow copy of the set.

    Example:
        val s1 = set_from_array([1, 2, 3])
        val s2 = set_copy(s1)
        set_equals(s1, s2)  # true
    """
    var result = {}
    for k in s.keys():
        result[k] = s[k]
    result

fn set_clone(s):
    """Alias for set_copy.

    Example:
        val s2 = set_clone(s1)
    """
    set_copy(s)

# ============================================================================
# Set Utility Operations
# ============================================================================

fn set_min(s):
    """Find minimum element in set. Returns nil for empty set.

    Example:
        val s = set_from_array([3, 1, 4, 1, 5])
        set_min(s)  # 1
    """
    val arr = set_to_array(s)
    if arr.len() == 0:
        return nil
    var min_val = arr[0]
    var i = 1
    while i < arr.len():
        if arr[i] < min_val:
            min_val = arr[i]
        i = i + 1
    min_val

fn set_max(s):
    """Find maximum element in set. Returns nil for empty set.

    Example:
        val s = set_from_array([3, 1, 4, 1, 5])
        set_max(s)  # 5
    """
    val arr = set_to_array(s)
    if arr.len() == 0:
        return nil
    var max_val = arr[0]
    var i = 1
    while i < arr.len():
        if arr[i] > max_val:
            max_val = arr[i]
        i = i + 1
    max_val

fn set_sum(s):
    """Sum all numeric elements in set.

    Example:
        val s = set_from_array([1, 2, 3, 4])
        set_sum(s)  # 10
    """
    set_reduce(s, 0, \acc, x: acc + x)

fn set_product(s):
    """Multiply all numeric elements in set.

    Example:
        val s = set_from_array([2, 3, 4])
        set_product(s)  # 24
    """
    set_reduce(s, 1, \acc, x: acc * x)

# ============================================================================
# Set Display
# ============================================================================

fn set_to_string(s) -> text:
    """Convert set to string representation.

    Example:
        val s = set_from_array([1, 2, 3])
        set_to_string(s)  # "{1, 2, 3}" (order may vary)
    """
    val arr = set_to_sorted_array(s)
    if arr.len() == 0:
        return "{}"

    var result = "{"
    var i = 0
    while i < arr.len():
        if i > 0:
            result = result + ", "
        result = result + "{arr[i]}"
        i = i + 1
    result + "}"

# ============================================================================
# Convenience Functions
# ============================================================================

fn set_pop(s):
    """Remove and return an arbitrary element from the set.
    Returns tuple (element, new_set) or (nil, s) if empty.

    Example:
        var s = set_from_array([1, 2, 3])
        val result = set_pop(s)
        val elem = result[0]
        s = result[1]
    """
    val keys = s.keys()
    if keys.len() == 0:
        return (nil, s)

    val first_key = keys[0]
    val elem = s[first_key]
    val new_set = set_remove(s, elem)
    (elem, new_set)

fn set_sample(s):
    """Get an arbitrary element from the set without removing it.
    Returns nil if empty.

    Example:
        val s = set_from_array([1, 2, 3])
        val elem = set_sample(s)  # Could be 1, 2, or 3
    """
    val keys = s.keys()
    if keys.len() == 0:
        return nil
    s[keys[0]]

fn set_split_at(s, n: i64):
    """Split set into two sets at position n.
    Returns tuple (first_n_elements_set, rest_set).

    Note: Order is not guaranteed.

    Example:
        val s = set_from_array([1, 2, 3, 4, 5])
        val parts = set_split_at(s, 3)
        # parts[0] has 3 elements, parts[1] has 2
    """
    val keys = s.keys()
    if n >= keys.len():
        return (s, set_new())
    if n <= 0:
        return (set_new(), s)

    var first_part = {}
    var second_part = {}
    var i = 0
    for k in keys:
        if i < n:
            first_part[k] = s[k]
        else:
            second_part[k] = s[k]
        i = i + 1
    (first_part, second_part)

# ============================================================================
# Examples and Usage
# ============================================================================

fn _example_basic_usage():
    """Example: Basic set operations"""
    # Create a set
    var s = set_new()
    s = set_add(s, 1)
    s = set_add(s, 2)
    s = set_add(s, 3)
    s = set_add(s, 2)  # Duplicate ignored

    print("Size: {set_size(s)}")  # 3
    print("Contains 2: {set_contains(s, 2)}")  # true
    print("Contains 5: {set_contains(s, 5)}")  # false

    # Remove element
    s = set_remove(s, 2)
    print("After removing 2: {set_to_string(s)}")

fn _example_set_algebra():
    """Example: Set algebra operations"""
    val a = set_from_array([1, 2, 3, 4])
    val b = set_from_array([3, 4, 5, 6])

    print("Union: {set_to_string(set_union(a, b))}")
    print("Intersection: {set_to_string(set_intersection(a, b))}")
    print("Difference A-B: {set_to_string(set_difference(a, b))}")
    print("Symmetric diff: {set_to_string(set_symmetric_difference(a, b))}")

fn _example_transformations():
    """Example: Set transformations"""
    val s = set_from_array([1, 2, 3, 4, 5])

    # Map: square all numbers
    val squared = set_map(s, \x: x * x)
    print("Squared: {set_to_string(squared)}")

    # Filter: keep only even numbers
    val evens = set_filter(s, \x: x % 2 == 0)
    print("Evens: {set_to_string(evens)}")

    # Partition: separate even and odd
    val parts = set_partition(s, \x: x % 2 == 0)
    print("Even partition: {set_to_string(parts[0])}")
    print("Odd partition: {set_to_string(parts[1])}")

fn _example_advanced():
    """Example: Advanced operations"""
    val s = set_from_array([1, 2, 3])

    # Powerset
    val ps = set_powerset(s)
    print("Powerset size: {ps.len()}")  # 2^3 = 8

    # Cartesian product
    val colors = set_from_array(["red", "blue"])
    val sizes = set_from_array(["S", "M"])
    val combos = set_cartesian_product(colors, sizes)
    print("Combinations: {set_size(combos)}")  # 4

    # Set comprehension
    val numbers = set_from_array([1, 2, 3, 4, 5, 6])
    val result = set_comprehension(numbers, \x: x % 2 == 0, \x: x * x)
    print("Squares of evens: {set_to_string(result)}")  # {4, 16, 36}

export set_powerset, set_cartesian_product, set_comprehension
export set_foreach, set_reduce, set_any, set_all, set_count, set_find
export set_copy, set_clone
export set_min, set_max, set_sum, set_product
export set_to_string
export set_pop, set_sample, set_split_at
