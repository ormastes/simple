# =============================================================================
# Table Detection and Parsing (4 functions)
# =============================================================================

fn is_table_separator_line(line: text) -> bool:
    val trimmed = trim(line)
    if trimmed.length() < 3:
        return false
    if not starts_with(trimmed, "|"):
        return false
    var i = 1
    var len = trimmed.length()
    var has_dash = false
    while i < len:
        val c = trimmed.char_at(i)
        if c == "-":
            has_dash = true
        else:
            if c != "|" and c != ":" and c != " ":
                return false
        i = i + 1
    has_dash

fn parse_table_row(line: text) -> array:
    var cells = []
    var current = ""
    var i = 0
    var len = line.length()
    var in_cell = false
    while i < len:
        val c = line.char_at(i)
        if c == "|":
            if in_cell:
                val trimmed = trim(current)
                cells = cells.push(trimmed)
                current = ""
            in_cell = true
        else:
            current = current + c
        i = i + 1
    if current.length() > 0:
        val trimmed = trim(current)
        cells = cells.push(trimmed)
    cells

fn parse_table_alignments(line: text) -> array:
    val cells = parse_table_row(line)
    var alignments = []
    var i = 0
    var len = cells.length()
    while i < len:
        val cell = cells.get(i)
        val left = starts_with(cell, ":")
        val right = ends_with(cell, ":")
        var align = "left"
        if left and right:
            align = "center"
        else:
            if right:
                align = "right"
        alignments = alignments.push(align)
        i = i + 1
    alignments

fn is_table_row_line(line: text) -> bool:
    val trimmed = trim(line)
    if trimmed.length() == 0:
        return false
    starts_with(trimmed, "|")

# =============================================================================
# Inline Parsing Helpers (5 functions)
# =============================================================================

fn find_matching_delim(s: text, delim: text, start: i64) -> i64:
    var i = start
    var len = s.length()
    var delim_len = delim.length()
    while i < len - delim_len + 1:
        var match = true
        var j = 0
        while j < delim_len:
            val ch = s.char_at(i + j)
            val delim_ch = delim.char_at(j)
            if ch != delim_ch:
                match = false
                break
            j = j + 1
        if match:
            if i > 0:
                val prev = s.char_at(i - 1)
                if prev != "\\":
                    return i
            else:
                return i
        i = i + 1
    -1

fn find_unescaped_char(s: text, c: text, start: i64) -> i64:
    var i = start
    var len = s.length()
    while i < len:
        val ch = s.char_at(i)
        if ch == c:
            if not is_escaped(s, i):
                return i
        i = i + 1
    -1

fn count_emphasis_markers(s: text, start: i64) -> i64:
    var count = 0
    var i = start
    var len = s.length()
    if i >= len:
        return 0
    val marker = s.char_at(i)
    while i < len and s.char_at(i) == marker:
        count = count + 1
        i = i + 1
    count

fn extract_url_from_link(s: text) -> tuple:
    var url = ""
    var title = ""
    val space_pos = find_char(s, " ", 0)
    if space_pos == -1:
        url = s
    else:
        url = s.substring(0, space_pos)
        var title_part = s.substring(space_pos + 1, s.length())
        title_part = trim(title_part)
        if starts_with(title_part, "\"") and ends_with(title_part, "\""):
            title = title_part.substring(1, title_part.length() - 1)
    (url, title)

fn is_valid_url_char(c: text) -> bool:
    if is_alphanumeric(c):
        return true
    val special = c == ":" or c == "/" or c == "." or c == "-" or c == "_"
    val more = c == "?" or c == "=" or c == "&" or c == "#" or c == "%"
    special or more

# =============================================================================
# Inline Token Parsing (8 functions)
# =============================================================================

fn parse_bold(s: text, start: i64) -> tuple:
    val close = find_matching_delim(s, "**", start + 2)
    if close == -1:
        return (nil, start + 1)
    val content = s.substring(start + 2, close)
    val tokens = parse_inline_tokens(content)
    val token = ("bold", tokens)
    (token, close + 2)

fn parse_italic(s: text, start: i64) -> tuple:
    val close = find_matching_delim(s, "*", start + 1)
    if close == -1:
        return (nil, start + 1)
    val content = s.substring(start + 1, close)
    val tokens = parse_inline_tokens(content)
    val token = ("italic", tokens)
    (token, close + 1)

fn parse_code(s: text, start: i64) -> tuple:
    val close = find_char(s, "`", start + 1)
    if close == -1:
        return (nil, start + 1)
    val content = s.substring(start + 1, close)
    val token = ("code", content)
    (token, close + 1)

fn parse_link(s: text, start: i64, is_image: bool) -> tuple:
    var pos = start + 1
    val close_bracket = find_char(s, "]", pos)
    if close_bracket == -1:
        return (nil, start + 1)
    val text_content = s.substring(pos, close_bracket)
    pos = close_bracket + 1
    if pos >= s.length():
        return (nil, start + 1)
    val paren = s.char_at(pos)
    if paren != "(":
        return (nil, start + 1)
    pos = pos + 1
    val close_paren = find_char(s, ")", pos)
    if close_paren == -1:
        return (nil, start + 1)
    val url_part = s.substring(pos, close_paren)
    val url_data = extract_url_from_link(url_part)
    val url = url_data.0
    val title = url_data.1
    if is_image:
        val token = ("image", text_content, url, title)
        return (token, close_paren + 1)
    val text_tokens = parse_inline_tokens(text_content)
    val token = ("link", text_tokens, url, title)
    (token, close_paren + 1)

fn parse_image(s: text, start: i64) -> tuple:
    parse_link(s, start + 1, true)

fn parse_autolink(s: text, start: i64) -> tuple:
    val close = find_char(s, ">", start + 1)
    if close == -1:
        return (nil, start + 1)
    val url = s.substring(start + 1, close)
    val token = ("autolink", url)
    (token, close + 1)

fn parse_strikethrough(s: text, start: i64) -> tuple:
    val close = find_matching_delim(s, "~~", start + 2)
    if close == -1:
        return (nil, start + 1)
    val content = s.substring(start + 2, close)
    val tokens = parse_inline_tokens(content)
    val token = ("strikethrough", tokens)
    (token, close + 2)

fn parse_line_break(s: text, start: i64) -> tuple:
    val token = ("line_break")
    (token, start + 4)

# =============================================================================
# Main Inline Tokenizer (1 function)
# =============================================================================

fn parse_inline_tokens(s: text) -> array:
    var tokens = []
    var i = 0
    var len = s.length()
    var current_text = ""
    while i < len:
        val c = s.char_at(i)
        if c == "\\":
            if i + 1 < len:
                val next = s.char_at(i + 1)
                current_text = current_text + next
                i = i + 2
            else:
                current_text = current_text + c
                i = i + 1
        else:
            if c == "*":
                if i + 1 < len and s.char_at(i + 1) == "*":
                    if current_text.length() > 0:
                        val text_token = ("text", current_text)
                        tokens = tokens.push(text_token)
                        current_text = ""
                    val result = parse_bold(s, i)
                    val token = result.0
                    val next_i = result.1
                    if token != nil:
                        tokens = tokens.push(token)
                        i = next_i
                    else:
                        current_text = current_text + c
                        i = i + 1
                else:
                    if current_text.length() > 0:
                        val text_token = ("text", current_text)
                        tokens = tokens.push(text_token)
                        current_text = ""
                    val result = parse_italic(s, i)
                    val token = result.0
                    val next_i = result.1
                    if token != nil:
                        tokens = tokens.push(token)
                        i = next_i
                    else:
                        current_text = current_text + c
                        i = i + 1
            else:
                if c == "`":
                    if current_text.length() > 0:
                        val text_token = ("text", current_text)
                        tokens = tokens.push(text_token)
                        current_text = ""
                    val result = parse_code(s, i)
                    val token = result.0
                    val next_i = result.1
                    if token != nil:
                        tokens = tokens.push(token)
                        i = next_i
                    else:
                        current_text = current_text + c
                        i = i + 1
                else:
                    if c == "[":
                        if current_text.length() > 0:
                            val text_token = ("text", current_text)
                            tokens = tokens.push(text_token)
                            current_text = ""
                        val result = parse_link(s, i, false)
                        val token = result.0
                        val next_i = result.1
                        if token != nil:
                            tokens = tokens.push(token)
                            i = next_i
                        else:
                            current_text = current_text + c
                            i = i + 1
                    else:
                        if c == "!":
                            if i + 1 < len and s.char_at(i + 1) == "[":
                                if current_text.length() > 0:
                                    val text_token = ("text", current_text)
                                    tokens = tokens.push(text_token)
                                    current_text = ""
                                val result = parse_image(s, i)
                                val token = result.0
                                val next_i = result.1
                                if token != nil:
                                    tokens = tokens.push(token)
                                    i = next_i
                                else:
                                    current_text = current_text + c
                                    i = i + 1
                            else:
                                current_text = current_text + c
                                i = i + 1
                        else:
                            if c == "<":
                                if i + 1 < len:
                                    val peek = s.substring(i + 1, len)
                                    val is_link = starts_with(peek, "http://") or starts_with(peek, "https://")
                                    val has_at = find_char(peek, "@", 0) != -1
                                    if is_link or has_at:
                                        if current_text.length() > 0:
                                            val text_token = ("text", current_text)
                                            tokens = tokens.push(text_token)
                                            current_text = ""
                                        val result = parse_autolink(s, i)
                                        val token = result.0
                                        val next_i = result.1
                                        if token != nil:
                                            tokens = tokens.push(token)
                                            i = next_i
                                        else:
                                            current_text = current_text + c
                                            i = i + 1
                                    else:
                                        current_text = current_text + c
                                        i = i + 1
                                else:
                                    current_text = current_text + c
                                    i = i + 1
                            else:
                                if c == "~":
                                    if i + 1 < len and s.char_at(i + 1) == "~":
                                        if current_text.length() > 0:
                                            val text_token = ("text", current_text)
                                            tokens = tokens.push(text_token)
                                            current_text = ""
                                        val result = parse_strikethrough(s, i)
                                        val token = result.0
                                        val next_i = result.1
                                        if token != nil:
                                            tokens = tokens.push(token)
                                            i = next_i
                                        else:
                                            current_text = current_text + c
                                            i = i + 1
                                    else:
                                        current_text = current_text + c
                                        i = i + 1
                                else:
                                    current_text = current_text + c
                                    i = i + 1
    if current_text.length() > 0:
        val text_token = ("text", current_text)
        tokens = tokens.push(text_token)
    tokens
