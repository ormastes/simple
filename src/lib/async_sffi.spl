# Async SFFI - Pure Simple FFI Wrappers
#
# This module provides Pure Simple implementations of async FFI functions.
# No external FFI required - everything is implemented in Simple!
#
# Two-tier SFFI pattern:
# - Tier 1: Extern declarations (for future optimization)
# - Tier 2: Pure Simple fallbacks (working now)

# ============================================================================
# Global State (Pure Simple) - Public module-level vars
# ============================================================================

# Task ID counter (global state)
pub var NEXT_TASK_ID = 0

# Waker registry - pre-allocated for 64 tasks
pub var WAKER_REGISTRY = [
    false, false, false, false, false, false, false, false,
    false, false, false, false, false, false, false, false,
    false, false, false, false, false, false, false, false,
    false, false, false, false, false, false, false, false,
    false, false, false, false, false, false, false, false,
    false, false, false, false, false, false, false, false,
    false, false, false, false, false, false, false, false,
    false, false, false, false, false, false, false, false
]

# ============================================================================
# Task Management (Pure Simple)
# ============================================================================

fn task_alloc_id() -> usize:
    """Allocate unique task ID (Pure Simple implementation)."""
    val id = NEXT_TASK_ID
    NEXT_TASK_ID = NEXT_TASK_ID + 1
    id

fn task_reset_counter():
    """Reset task ID counter (for testing)."""
    NEXT_TASK_ID = 0

# ============================================================================
# Waker Management (Pure Simple)
# ============================================================================

fn waker_signal(scheduler_ref: usize, task_id: usize):
    """Signal that a task should be woken (Pure Simple stub).

    Note: Registry is pre-allocated for 64 tasks.
    """
    if task_id < 64:
        WAKER_REGISTRY[task_id] = true

fn waker_check(task_id: usize) -> bool:
    """Check if task has pending wake signal."""
    if task_id < 64:
        WAKER_REGISTRY[task_id]
    else:
        false

fn waker_clear(task_id: usize):
    """Clear wake signal for task."""
    if task_id < 64:
        WAKER_REGISTRY[task_id] = false

fn waker_reset():
    """Reset all waker state (for testing)."""
    # Reset all entries to false
    var i = 0
    while i < 64:
        WAKER_REGISTRY[i] = false
        i = i + 1

# ============================================================================
# Optional: Extern declarations for future optimization
# ============================================================================
#
# When the runtime implements these as native functions, they'll be used
# instead of the Pure Simple versions above.
#
# extern fn rt_task_alloc_id() -> usize
# extern fn rt_waker_signal(scheduler_ref: usize, task_id: usize)
# extern fn rt_waker_check(task_id: usize) -> bool

# ============================================================================
# Exports
# ============================================================================

export NEXT_TASK_ID
export WAKER_REGISTRY
export task_alloc_id
export task_reset_counter
export waker_signal
export waker_check
export waker_clear
export waker_reset

# ============================================================================
# Usage Example
# ============================================================================
#
# Pure Simple mode (no FFI):
#   use std.async_sffi.*
#   val id = task_alloc_id()  # Uses Pure Simple counter
#   waker_signal(0, id)       # Records wake request
#
# Future optimization (with FFI):
#   Same code, but rt_task_alloc_id() used automatically
#   when available in runtime
