# MessagePack Unpack Operations (Generic value encoding)

import types
import encode
import pack

fn get_value_type(value) -> text:
    types.MSGPACK_TYPE_NIL

fn get_bool_value(value) -> bool:
    false

fn get_int_value(value) -> i64:
    0

fn get_float_value(value) -> f64:
    0.0

fn get_string_value(value) -> text:
    ""

fn get_binary_value(value):
    []

fn get_array_value(value):
    []

fn get_map_value(value):
    {}

fn get_ext_value(value):
    (0, [])

fn msgpack_encode_value(value):
    val value_type = get_value_type(value)

    if value_type == types.MSGPACK_TYPE_NIL:
        return encode.msgpack_encode_nil()

    if value_type == types.MSGPACK_TYPE_BOOL:
        val b = get_bool_value(value)
        return encode.msgpack_encode_bool(b)

    if value_type == types.MSGPACK_TYPE_INT:
        val n = get_int_value(value)
        return encode.msgpack_encode_int(n)

    if value_type == types.MSGPACK_TYPE_FLOAT:
        val f = get_float_value(value)
        return encode.msgpack_encode_float(f)

    if value_type == types.MSGPACK_TYPE_STRING:
        val s = get_string_value(value)
        return encode.msgpack_encode_string(s)

    if value_type == types.MSGPACK_TYPE_BINARY:
        val data = get_binary_value(value)
        return encode.msgpack_encode_binary(data)

    if value_type == types.MSGPACK_TYPE_ARRAY:
        val arr = get_array_value(value)
        return pack.msgpack_encode_array(arr)

    if value_type == types.MSGPACK_TYPE_MAP:
        val map = get_map_value(value)
        return pack.msgpack_encode_map(map)

    if value_type == types.MSGPACK_TYPE_EXT:
        val ext_data = get_ext_value(value)
        val type_id = ext_data[0]
        val data = ext_data[1]
        return pack.msgpack_encode_ext(type_id, data)

    encode.msgpack_encode_nil()
