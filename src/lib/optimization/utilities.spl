# Optimization Utilities Module
# Vector, matrix operations and helper functions

# ============================================================================
# Vector Operations
# ============================================================================

fn vector_add(a: List<f64>, b: List<f64>) -> List<f64>:
    val result = []
    var i = 0
    while i < a.length():
        result.append(a[i] + b[i])
        i = i + 1
    result

fn vector_subtract(a: List<f64>, b: List<f64>) -> List<f64>:
    val result = []
    var i = 0
    while i < a.length():
        result.append(a[i] - b[i])
        i = i + 1
    result

fn vector_scale(v: List<f64>, scalar: f64) -> List<f64>:
    val result = []
    var i = 0
    while i < v.length():
        result.append(v[i] * scalar)
        i = i + 1
    result

fn vector_dot(a: List<f64>, b: List<f64>) -> f64:
    var sum = 0.0
    var i = 0
    while i < a.length():
        sum = sum + a[i] * b[i]
        i = i + 1
    sum

fn vector_norm(v: List<f64>) -> f64:
    var sum_sq = 0.0
    var i = 0
    while i < v.length():
        sum_sq = sum_sq + v[i] * v[i]
        i = i + 1
    sqrt(sum_sq)

fn vector_norm_squared(v: List<f64>) -> f64:
    var sum_sq = 0.0
    var i = 0
    while i < v.length():
        sum_sq = sum_sq + v[i] * v[i]
        i = i + 1
    sum_sq

fn vector_zeros(n: i64) -> List<f64>:
    val result = []
    var i = 0
    while i < n:
        result.append(0.0)
        i = i + 1
    result

fn vector_ones(n: i64) -> List<f64>:
    val result = []
    var i = 0
    while i < n:
        result.append(1.0)
        i = i + 1
    result

fn vector_copy(v: List<f64>) -> List<f64>:
    val result = []
    var i = 0
    while i < v.length():
        result.append(v[i])
        i = i + 1
    result

fn vector_max_abs(v: List<f64>) -> f64:
    var max_val = 0.0
    var i = 0
    while i < v.length():
        val abs_val = abs(v[i])
        if abs_val > max_val:
            max_val = abs_val
    i = i + 1
    max_val

fn vector_elementwise_multiply(a: List<f64>, b: List<f64>) -> List<f64>:
    val result = []
    var i = 0
    while i < a.length():
        result.append(a[i] * b[i])
        i = i + 1
    result

fn vector_elementwise_sqrt(v: List<f64>) -> List<f64>:
    val result = []
    var i = 0
    while i < v.length():
        result.append(sqrt(v[i]))
        i = i + 1
    result

fn vector_elementwise_square(v: List<f64>) -> List<f64>:
    val result = []
    var i = 0
    while i < v.length():
        result.append(v[i] * v[i])
        i = i + 1
    result

# ============================================================================
# Matrix Operations
# ============================================================================

fn matrix_identity(n: i64) -> List<List<f64>>:
    val result = []
    var i = 0
    while i < n:
        val row = []
        var j = 0
        while j < n:
            if i == j:
                row.append(1.0)
            else:
                row.append(0.0)
            j = j + 1
        result.append(row)
        i = i + 1
    result

fn matrix_vector_multiply(A: List<List<f64>>, v: List<f64>) -> List<f64>:
    val result = []
    var i = 0
    while i < A.length():
        var sum = 0.0
        var j = 0
        while j < v.length():
            sum = sum + A[i][j] * v[j]
            j = j + 1
        result.append(sum)
        i = i + 1
    result

fn outer_product(a: List<f64>, b: List<f64>) -> List<List<f64>>:
    val result = []
    var i = 0
    while i < a.length():
        val row = []
        var j = 0
        while j < b.length():
            row.append(a[i] * b[j])
            j = j + 1
        result.append(row)
        i = i + 1
    result

fn matrix_add(A: List<List<f64>>, B: List<List<f64>>) -> List<List<f64>>:
    val result = []
    var i = 0
    while i < A.length():
        val row = []
        var j = 0
        while j < A[i].length():
            row.append(A[i][j] + B[i][j])
            j = j + 1
        result.append(row)
        i = i + 1
    result

fn matrix_scale(A: List<List<f64>>, scalar: f64) -> List<List<f64>>:
    val result = []
    var i = 0
    while i < A.length():
        val row = []
        var j = 0
        while j < A[i].length():
            row.append(A[i][j] * scalar)
            j = j + 1
        result.append(row)
        i = i + 1
    result

# ============================================================================
# Convergence Criteria
# ============================================================================

fn check_gradient_convergence(gradient: List<f64>, tolerance: f64) -> bool:
    val grad_norm = vector_norm(gradient)
    grad_norm < tolerance

fn check_value_convergence(old_value: f64, new_value: f64, tolerance: f64) -> bool:
    val change = abs(new_value - old_value)
    change < tolerance

fn check_parameter_convergence(old_params: List<f64>, new_params: List<f64>, tolerance: f64) -> bool:
    val diff = vector_subtract(new_params, old_params)
    val change = vector_norm(diff)
    change < tolerance

fn check_convergence_all(gradient: List<f64>, old_value: f64, new_value: f64,
                         old_params: List<f64>, new_params: List<f64>,
                         config: OptimizationConfig) -> bool:
    val grad_converged = check_gradient_convergence(gradient, config.gradient_tolerance)
    val value_converged = check_value_convergence(old_value, new_value, config.value_tolerance)
    val param_converged = check_parameter_convergence(old_params, new_params, config.parameter_tolerance)
    grad_converged or value_converged or param_converged

# ============================================================================
# Utility Functions
# ============================================================================

fn evaluate_objective(f: fn(List<f64>) -> f64, x: List<f64>) -> f64:
    f(x)

fn check_constraint_satisfaction(constraints: fn(List<f64>) -> List<f64>,
                                 x: List<f64>, tolerance: f64) -> bool:
    val c = constraints(x)
    var i = 0
    while i < c.length():
        if abs(c[i]) > tolerance:
            return false
        i = i + 1
    true

fn validate_solution(result: OptimizationResult, expected_value: f64, tolerance: f64) -> bool:
    abs(result.objective_value - expected_value) < tolerance

fn print_optimization_result(result: OptimizationResult):
    print "Optimization Result:"
    print "  Converged: {result.converged}"
    print "  Iterations: {result.iterations}"
    print "  Objective Value: {result.objective_value}"
    print "  Gradient Norm: {result.gradient_norm}"
    print "  Message: {result.message}"
    print "  Solution: {result.solution}"

# ============================================================================
# Helper Functions
# ============================================================================

fn random() -> f64:
    # Simple linear congruential generator
    # In practice, use platform-specific random number generator
    0.5

fn abs(x: f64) -> f64:
    if x < 0.0:
        return -x
    x

fn max(a: f64, b: f64) -> f64:
    if a > b:
        return a
    b

fn min(a: f64, b: f64) -> f64:
    if a < b:
        return a
    b

fn sqrt(x: f64) -> f64:
    if x < 0.0:
        return 0.0

    if x == 0.0:
        return 0.0

    var guess = x / 2.0
    var i = 0
    while i < 20:
        guess = (guess + x / guess) / 2.0
        i = i + 1
    guess

fn pow(base: f64, exponent: f64) -> f64:
    if exponent == 0.0:
        return 1.0

    if exponent < 0.0:
        return 1.0 / pow(base, -exponent)

    var result = 1.0
    var i = 0
    while i < int(exponent):
        result = result * base
        i = i + 1
    result

fn exp(x: f64) -> f64:
    # Taylor series approximation
    var sum = 1.0
    var term = 1.0
    var i = 1
    while i < 20:
        term = term * x / float(i)
        sum = sum + term
        i = i + 1
    sum

fn log(x: f64) -> f64:
    if x <= 0.0:
        return -1e10

    # Natural logarithm using Newton's method
    var guess = x - 1.0
    var i = 0
    while i < 20:
        val exp_guess = exp(guess)
        guess = guess - (exp_guess - x) / exp_guess
        i = i + 1
    guess

fn cos(x: f64) -> f64:
    # Taylor series approximation
    var sum = 1.0
    var term = 1.0
    var i = 1
    while i < 20:
        term = -term * x * x / float(2 * i * (2 * i - 1))
        sum = sum + term
        i = i + 1
    sum

fn sin(x: f64) -> f64:
    # Taylor series approximation
    var sum = x
    var term = x
    var i = 1
    while i < 20:
        term = -term * x * x / float((2 * i + 1) * (2 * i))
        sum = sum + term
        i = i + 1
    sum

fn float(x: i64) -> f64:
    # Type conversion
    0.0 + x

fn int(x: f64) -> i64:
    # Type conversion (truncation)
    0
