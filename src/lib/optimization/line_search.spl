# Line Search Algorithms Module
# Backtracking, Wolfe, and golden section search methods

fn backtracking_line_search(f: fn(List<f64>) -> f64, x: List<f64>, direction: List<f64>,
                            gradient: List<f64>, alpha_init: f64, rho: f64, c: f64) -> LineSearchResult:
    var alpha = alpha_init
    val f_x = f(x)
    val grad_dot_dir = vector_dot(gradient, direction)
    var iterations = 0
    val max_iter = 50

    while iterations < max_iter:
        val scaled_dir = vector_scale(direction, alpha)
        val new_point = vector_add(x, scaled_dir)
        val f_new = f(new_point)

        val armijo_condition = f_new <= f_x + c * alpha * grad_dot_dir
        if armijo_condition:
            return LineSearchResult(
                alpha: alpha,
                new_point: new_point,
                new_value: f_new,
                success: true,
                iterations: iterations
            )

        alpha = alpha * rho
        iterations = iterations + 1

    val scaled_dir = vector_scale(direction, alpha)
    val new_point = vector_add(x, scaled_dir)
    LineSearchResult(
        alpha: alpha,
        new_point: new_point,
        new_value: f(new_point),
        success: false,
        iterations: iterations
    )

fn wolfe_line_search(f: fn(List<f64>) -> f64, grad_f: fn(List<f64>) -> List<f64>,
                     x: List<f64>, direction: List<f64>, alpha_init: f64,
                     c1: f64, c2: f64) -> LineSearchResult:
    var alpha = alpha_init
    val f_x = f(x)
    val grad_x = grad_f(x)
    val grad_dot_dir = vector_dot(grad_x, direction)
    var iterations = 0
    val max_iter = 30

    while iterations < max_iter:
        val scaled_dir = vector_scale(direction, alpha)
        val new_point = vector_add(x, scaled_dir)
        val f_new = f(new_point)

        val armijo = f_new <= f_x + c1 * alpha * grad_dot_dir

        if armijo:
            val grad_new = grad_f(new_point)
            val grad_new_dot_dir = vector_dot(grad_new, direction)
            val curvature = abs(grad_new_dot_dir) <= c2 * abs(grad_dot_dir)

            if curvature:
                return LineSearchResult(
                    alpha: alpha,
                    new_point: new_point,
                    new_value: f_new,
                    success: true,
                    iterations: iterations
                )

        alpha = alpha * 0.5
        iterations = iterations + 1

    val scaled_dir = vector_scale(direction, alpha)
    val new_point = vector_add(x, scaled_dir)
    LineSearchResult(
        alpha: alpha,
        new_point: new_point,
        new_value: f(new_point),
        success: false,
        iterations: iterations
    )

fn golden_section_search(f: fn(f64) -> f64, a: f64, b: f64, tolerance: f64) -> f64:
    val phi = (1.0 + sqrt(5.0)) / 2.0
    val resphi = 2.0 - phi

    var x1 = a + resphi * (b - a)
    var x2 = b - resphi * (b - a)
    var f1 = f(x1)
    var f2 = f(x2)

    var a_curr = a
    var b_curr = b

    while abs(b_curr - a_curr) > tolerance:
        if f1 < f2:
            b_curr = x2
            x2 = x1
            f2 = f1
            x1 = a_curr + resphi * (b_curr - a_curr)
            f1 = f(x1)
        else:
            a_curr = x1
            x1 = x2
            f1 = f2
            x2 = b_curr - resphi * (b_curr - a_curr)
            f2 = f(x2)

    (a_curr + b_curr) / 2.0
