# Standard Library — Sequence CE Builder
#
# @tag:api
# @tag:stdlib
#
# Sequence computation expression builder.
# Collects values yielded inside a ce seq: block into an array.
#
# Usage (via `ce seq:` block syntax):
#   val evens = ce seq:
#       bind n = range_items(0, 10)
#       if n % 2 == 0:
#           yield n
#
# Or direct:
#   val result = seq_ce_run_int(fn():
#       seq_ce_yield_int(1)
#       seq_ce_yield_int(2)
#       seq_ce_yield_int(3)
#   )

# Internal accumulator (module-level for simple interpreter support)
var _seq_ce_buffer: [i64] = []
var _seq_ce_text_buffer: [text] = []

# Begin a sequence CE run — clears the buffer.
fn seq_ce_begin():
    _seq_ce_buffer = []
    _seq_ce_text_buffer = []

# Yield an integer value into the sequence.
fn seq_ce_yield_int(value: i64):
    _seq_ce_buffer.push(value)

# Yield a text value into the sequence.
fn seq_ce_yield_text(value: text):
    _seq_ce_text_buffer.push(value)

# End the sequence and return collected integer values.
fn seq_ce_end_int() -> [i64]:
    _seq_ce_buffer

# End the sequence and return collected text values.
fn seq_ce_end_text() -> [text]:
    _seq_ce_text_buffer

# Bind for sequences: iterate over an array, yielding each element.
fn seq_ce_bind_array(items: [text], body: fn(text)):
    for item in items:
        body(item)

# Return: no-op for sequences (return value is not used directly).
fn seq_ce_return(value):
    value

# Zero: empty sequence.
fn seq_ce_zero() -> [text]:
    []

# Run a sequence producer function and collect integer results.
fn seq_ce_run_int(producer: fn()) -> [i64]:
    seq_ce_begin()
    producer()
    seq_ce_end_int()

# Run a sequence producer function and collect text results.
fn seq_ce_run_text(producer: fn()) -> [text]:
    seq_ce_begin()
    producer()
    seq_ce_end_text()

export seq_ce_begin, seq_ce_yield_int, seq_ce_yield_text
export seq_ce_end_int, seq_ce_end_text
export seq_ce_bind_array, seq_ce_return, seq_ce_zero
export seq_ce_run_int, seq_ce_run_text
