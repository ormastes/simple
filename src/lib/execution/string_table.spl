# String Table Loader for Semihosting Protocol
#
# Loads .smt (String Metadata Table) files and provides string lookup by ID.
# Used by protocol parser to reconstruct human-readable text from binary frames.

use app.io.mod.{file_read, file_exists}

# String table entry
class StringEntry:
    id: i32
    text: text
    param_count: i32
    format_types: [i32]

impl StringEntry:
    static fn create(id: i32, text: text, params: i32) -> StringEntry:
        StringEntry(
            id: id,
            text: text,
            param_count: params,
            format_types: []
        )

# String lookup table
class StringTable:
    entries: [StringEntry]

impl StringTable:
    static fn empty() -> StringTable:
        StringTable(entries: [])

    # Add entry to table
    me add(entry: StringEntry):
        self.entries.push(entry)

    # Lookup string by ID
    fn get(id: i32) -> text?:
        for entry in self.entries:
            if entry.id == id:
                return Some(entry.text)
        nil

    # Get entry by ID
    fn get_entry(id: i32) -> StringEntry?:
        for entry in self.entries:
            if entry.id == id:
                return Some(entry)
        nil

    # Count entries
    fn count() -> i32:
        self.entries.len() as i32

# Load string table from .smt JSON file
fn load_string_table(path: text) -> Result<StringTable, text>:
    if not file_exists(path):
        return Err("SMT file not found: {path}")

    val content = file_read(path)
    if content.len() == 0:
        return Err("Empty SMT file: {path}")

    # Parse JSON (simplified parser for Phase 2.1)
    val table = parse_smt_json(content)?

    Ok(table)

# Simple JSON parser for .smt files
fn parse_smt_json(json: text) -> Result<StringTable, text>:
    var table = StringTable.empty()

    # Find "strings" array
    val strings_start = json.index_of("\"strings\"")
    if strings_start < 0:
        return Err("No 'strings' field in SMT file")

    # Extract entries (simplified - looks for id/text pairs)
    var pos = strings_start
    while pos < json.len():
        # Find next "id": field
        val id_pos = json.index_of("\"id\":", pos)
        if id_pos < 0:
            break

        # Extract ID value
        val id = extract_number(json, id_pos + 5)?

        # Find "text": field
        val text_pos = json.index_of("\"text\":", id_pos)
        if text_pos < 0:
            break

        # Extract text value
        val text_val = extract_string(json, text_pos + 7)?

        # Find "params": field
        val params_pos = json.index_of("\"params\":", text_pos)
        val params = if params_pos > 0:
            extract_number(json, params_pos + 9)?
        else:
            0

        # Add entry
        table.add(StringEntry.create(id, text_val, params))

        pos = text_pos + text_val.len()

    Ok(table)

# Extract number from JSON
fn extract_number(json: text, start: i32) -> Result<i32, text>:
    # Skip whitespace
    var pos = start
    while pos < json.len() and (json[pos:pos+1] == " " or json[pos:pos+1] == "\t"):
        pos = pos + 1

    # Extract digits
    var num_str = ""
    while pos < json.len():
        val ch = json[pos:pos+1]
        if ch >= "0" and ch <= "9":
            num_str = num_str + ch
            pos = pos + 1
        else:
            break

    if num_str.len() == 0:
        return Err("No number found")

    # Parse to integer
    Ok(parse_i32(num_str))

# Extract string from JSON (handles escaped characters)
fn extract_string(json: text, start: i32) -> Result<text, text>:
    # Skip whitespace and find opening quote
    var pos = start
    while pos < json.len() and json[pos:pos+1] != "\"":
        pos = pos + 1

    if pos >= json.len():
        return Err("No opening quote found")

    pos = pos + 1  # Skip opening quote

    # Extract until closing quote
    var result = ""
    while pos < json.len():
        val ch = json[pos:pos+1]

        if ch == "\\":
            # Handle escape sequence
            pos = pos + 1
            if pos >= json.len():
                break

            val escaped = json[pos:pos+1]
            if escaped == "n":
                result = result + "\n"
            elif escaped == "t":
                result = result + "\t"
            elif escaped == "\"":
                result = result + "\""
            elif escaped == "\\":
                result = result + "\\"
            else:
                result = result + escaped
            pos = pos + 1
        elif ch == "\"":
            # Found closing quote
            break
        else:
            result = result + ch
            pos = pos + 1

    Ok(result)

# Parse integer from string (simple version)
fn parse_i32(s: text) -> i32:
    var result: i32 = 0
    var i = 0

    while i < s.len():
        val ch = s[i:i+1]
        if ch >= "0" and ch <= "9":
            val digit = char_to_digit(ch)
            result = result * 10 + digit
        i = i + 1

    result

fn char_to_digit(ch: text) -> i32:
    match ch:
        "0": 0
        "1": 1
        "2": 2
        "3": 3
        "4": 4
        "5": 5
        "6": 6
        "7": 7
        "8": 8
        "9": 9
        _: 0
