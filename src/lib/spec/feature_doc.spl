# Feature Documentation Framework
# Provides metadata, registry, and documentation generation for features.

use std.text.{NL}

# Feature metadata
struct FeatureMetadata:
    id: i64
    name: text
    category: text
    difficulty: i64
    status: text
    impl_type: text
    spec_ref: text
    files: [text]
    tests: [text]
    description: text
    code_examples: [text]
    dependencies: [i64]
    required_by: [i64]
    notes: text

# Module-level registry
var _registry: [FeatureMetadata] = []

# Clear the feature registry
fn clear_feature_registry():
    _registry = []

# Register a feature
fn register_feature(meta: FeatureMetadata):
    _registry = _registry.merge([meta])

# Get all registered features
fn get_all_features() -> [FeatureMetadata]:
    _registry

# Get features by category
fn get_features_by_category(cat: text) -> [FeatureMetadata]:
    var result: [FeatureMetadata] = []
    for f in _registry:
        if f.category == cat:
            result = result.merge([f])
    result

# Get all unique categories
fn get_all_categories() -> [text]:
    var cats: [text] = []
    for f in _registry:
        var found = false
        for c in cats:
            if c == f.category:
                found = true
        if not found:
            cats = cats.merge([f.category])
    cats

# Get difficulty label
fn get_difficulty_label(level: i64) -> text:
    if level == 1:
        "Trivial"
    elif level == 2:
        "Easy"
    elif level == 3:
        "Medium"
    elif level == 4:
        "Hard"
    elif level == 5:
        "Very Hard"
    else:
        "Unknown"

# Format feature filename with zero-padded ID
fn format_feature_filename(id: i64, name: text) -> text:
    val lower_name = name.lower().replace(" ", "_")
    if id < 10:
        "000{id}_{lower_name}.md"
    elif id < 100:
        "00{id}_{lower_name}.md"
    elif id < 1000:
        "0{id}_{lower_name}.md"
    else:
        "{id}_{lower_name}.md"

# Generate markdown documentation for a single feature
fn generate_feature_doc(id: i64) -> text?:
    for f in _registry:
        if f.id == id:
            var md = "# {f.name}" + NL + NL
            md = md + "| Property | Value |" + NL
            md = md + "|----------|-------|" + NL
            md = md + "| **Feature ID** | #{f.id} |" + NL
            md = md + "| **Category** | {f.category} |" + NL
            md = md + "| **Difficulty** | {get_difficulty_label(f.difficulty)} |" + NL
            md = md + "| **Status** | {f.status} |" + NL
            md = md + "| **Implementation** | {f.impl_type} |" + NL
            md = md + NL + "## Description" + NL + NL + "{f.description}" + NL
            if f.notes.len() > 0:
                md = md + NL + "## Notes" + NL + NL + "{f.notes}" + NL
            return Some(md)
    nil

# Generate category index
fn generate_category_index(cat: text) -> text:
    val features = get_features_by_category(cat)
    var md = "# {cat} Features" + NL + NL
    for f in features:
        md = md + "- [{f.name}]({format_feature_filename(f.id, f.name)})" + NL
    md

# Generate master index
fn generate_master_index() -> text:
    val cats = get_all_categories()
    val all = get_all_features()
    var md = "# Feature Index" + NL + NL
    md = md + "## Summary" + NL + NL
    md = md + "Total features: {all.len()}" + NL + NL
    md = md + "## Categories" + NL + NL
    for cat in cats:
        val cat_features = get_features_by_category(cat)
        md = md + "### {cat}" + NL + NL
        for f in cat_features:
            md = md + "- {f.name} (#{f.id})" + NL
        md = md + NL
    md
