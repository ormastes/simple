# Pure Simple Parser (Refactored)
# All parsing functions are now methods on Parser class

use lib.parser.lexer (Token, TokenKind, lex_source)
use lib.parser.ast (Expr, Stmt, Pattern, TypeExpr, Module, BinOp, UnaryOp, Literal)

export parse, parse_expr, parse_stmt, ParseError

# Parse error
struct ParseError:
    message: text
    line: i64
    column: i64

# Parser state with all parsing methods
class Parser:
    tokens: [Token]
    current: i64

    # ===== Core Parser Methods =====

    fn is_at_end() -> bool:
        if self.current >= self.tokens.len():
            true
        else:
            match self.tokens[self.current].kind:
                case TokenKind.Eof: true
                case _: false

    fn peek() -> Token:
        if self.current < self.tokens.len():
            self.tokens[self.current]
        else:
            self.tokens[self.tokens.len() - 1]

    fn previous() -> Token:
        if self.current > 0:
            self.tokens[self.current - 1]
        else:
            self.tokens[0]

    me advance() -> Token:
        if not self.is_at_end():
            self.current = self.current + 1
        self.previous()

    fn check(kind: text) -> bool:
        if self.is_at_end():
            false
        else:
            match self.peek().kind:
                case TokenKind.Keyword(k): k == kind
                case TokenKind.Operator(o): o == kind
                case _: false

    me consume_keyword(keyword: text) -> bool:
        if self.check(keyword):
            self.advance()
            true
        else:
            false

    me consume_operator(op: text) -> bool:
        if self.check(op):
            self.advance()
            true
        else:
            false

    me match_token(kind: TokenKind) -> bool:
        if self.is_at_end():
            false
        else:
            match self.peek().kind:
                case k:
                    if k == kind:
                        self.advance()
                        true
                    else:
                        false

    # ===== Statement Parsing =====

    me parse_statement() -> Result<Stmt, ParseError>:
        # Skip newlines
        while self.match_token(TokenKind.Newline):
            ()

        # Import statement
        if self.check("use"):
            return self.parse_import()

        # Export statement
        if self.check("export"):
            return self.parse_export()

        # Function definition
        if self.check("fn"):
            return self.parse_function()

        # Variable declaration
        if self.check("val") or self.check("var"):
            return self.parse_let()

        # Struct definition
        if self.check("struct"):
            return self.parse_struct()

        # Enum definition
        if self.check("enum"):
            return self.parse_enum()

        # Return statement
        if self.check("return"):
            return self.parse_return()

        # While loop
        if self.check("while"):
            return self.parse_while()

        # For loop
        if self.check("for"):
            return self.parse_for()

        # Expression statement
        match self.parse_expression():
            case Ok(expr):
                Ok(Stmt.Expr(expr))
            case Err(e):
                Err(e)

    me parse_function() -> Result<Stmt, ParseError>:
        self.consume_keyword("fn")

        # Function name
        val name = match self.peek().kind:
            case TokenKind.Identifier(n):
                self.advance()
                n
            case _:
                return Err(ParseError(
                    message: "Expected function name",
                    line: self.peek().line,
                    column: self.peek().column
                ))

        # Parameters
        self.consume_operator("(")
        var params: [text] = []

        while not self.check(")"):
            match self.peek().kind:
                case TokenKind.Identifier(p):
                    self.advance()
                    params.push(p)
                    if not self.check(")"):
                        self.consume_operator(",")
                case _:
                    break

        self.consume_operator(")")

        # Return type (optional)
        var return_type: TypeExpr? = nil
        if self.consume_operator("->"):
            match self.parse_type():
                case Ok(t):
                    return_type = Some(t)
                case Err(e):
                    return Err(e)

        # Body
        self.consume_operator(":")
        match self.parse_block():
            case Ok(body):
                Ok(Stmt.Function(name, params, return_type, body))
            case Err(e):
                Err(e)

    me parse_let() -> Result<Stmt, ParseError>:
        val is_val = self.consume_keyword("val")
        if not is_val:
            self.consume_keyword("var")

        # Variable name
        val name = match self.peek().kind:
            case TokenKind.Identifier(n):
                self.advance()
                n
            case _:
                return Err(ParseError(
                    message: "Expected variable name",
                    line: self.peek().line,
                    column: self.peek().column
                ))

        # Type annotation (optional)
        var type_expr: TypeExpr? = nil
        if self.consume_operator(":"):
            match self.parse_type():
                case Ok(t):
                    type_expr = Some(t)
                case Err(e):
                    return Err(e)

        # Initializer
        self.consume_operator("=")
        match self.parse_expression():
            case Ok(expr):
                Ok(Stmt.Let(name, type_expr, expr))
            case Err(e):
                Err(e)

    me parse_struct() -> Result<Stmt, ParseError>:
        self.consume_keyword("struct")

        val name = match self.peek().kind:
            case TokenKind.Identifier(n):
                self.advance()
                n
            case _:
                return Err(ParseError(
                    message: "Expected struct name",
                    line: self.peek().line,
                    column: self.peek().column
                ))

        self.consume_operator(":")

        var fields: [(text, TypeExpr)] = []
        # Parse fields (simplified)

        Ok(Stmt.Struct(name, fields))

    me parse_enum() -> Result<Stmt, ParseError>:
        self.consume_keyword("enum")

        val name = match self.peek().kind:
            case TokenKind.Identifier(n):
                self.advance()
                n
            case _:
                return Err(ParseError(
                    message: "Expected enum name",
                    line: self.peek().line,
                    column: self.peek().column
                ))

        self.consume_operator(":")

        var variants: [(text, [TypeExpr])] = []
        # Parse variants (simplified)

        Ok(Stmt.Enum(name, variants))

    me parse_return() -> Result<Stmt, ParseError>:
        self.consume_keyword("return")

        if self.check("\n") or self.is_at_end():
            Ok(Stmt.Return(nil))
        else:
            match self.parse_expression():
                case Ok(expr):
                    Ok(Stmt.Return(Some(expr)))
                case Err(e):
                    Err(e)

    me parse_while() -> Result<Stmt, ParseError>:
        self.consume_keyword("while")

        match self.parse_expression():
            case Ok(cond):
                self.consume_operator(":")
                match self.parse_block():
                    case Ok(body):
                        Ok(Stmt.While(cond, body))
                    case Err(e):
                        Err(e)
            case Err(e):
                Err(e)

    me parse_for() -> Result<Stmt, ParseError>:
        self.consume_keyword("for")

        val var_name = match self.peek().kind:
            case TokenKind.Identifier(n):
                self.advance()
                n
            case _:
                return Err(ParseError(
                    message: "Expected loop variable",
                    line: self.peek().line,
                    column: self.peek().column
                ))

        self.consume_keyword("in")

        match self.parse_expression():
            case Ok(iter):
                self.consume_operator(":")
                match self.parse_block():
                    case Ok(body):
                        Ok(Stmt.For(var_name, iter, body))
                    case Err(e):
                        Err(e)
            case Err(e):
                Err(e)

    me parse_import() -> Result<Stmt, ParseError>:
        # use module.{name1, name2}
        self.consume_keyword("use")

        # Parse module path (e.g., "lib.pure.parser")
        var module_path = ""
        while true:
            match self.peek().kind:
                case TokenKind.Identifier(name):
                    self.advance()
                    module_path = if module_path == "": name else: module_path + "." + name
                case _:
                    break

            if self.check("."):
                self.advance()
            else:
                break

        if module_path == "":
            return Err(ParseError(
                message: "Expected module name after 'use'",
                line: self.peek().line,
                column: self.peek().column
            ))

        # Parse imported names: {name1, name2} or nothing
        var names: [text] = []

        if self.check("{"):
            self.advance()

            while not self.check("}") and not self.is_at_end():
                match self.peek().kind:
                    case TokenKind.Identifier(name):
                        self.advance()
                        names.push(name)
                    case _:
                        return Err(ParseError(
                            message: "Expected name in import list",
                            line: self.peek().line,
                            column: self.peek().column
                        ))

                if self.check("}"):
                    break
                elif self.check(","):
                    self.advance()
                else:
                    return Err(ParseError(
                        message: "Expected ',' or '}' in import list",
                        line: self.peek().line,
                        column: self.peek().column
                    ))

            self.consume_operator("}")

        Ok(Stmt.Import(module_path, names))

    me parse_export() -> Result<Stmt, ParseError>:
        # export name1, name2
        self.consume_keyword("export")

        var names: [text] = []

        while true:
            match self.peek().kind:
                case TokenKind.Identifier(name):
                    self.advance()
                    names.push(name)
                case _:
                    if names.len() == 0:
                        return Err(ParseError(
                            message: "Expected name after 'export'",
                            line: self.peek().line,
                            column: self.peek().column
                        ))
                    break

            if self.check(","):
                self.advance()
            else:
                break

        Ok(Stmt.Export(names))

    me parse_block() -> Result<[Stmt], ParseError>:
        var statements: [Stmt] = []

        # Expect newline after colon
        while self.match_token(TokenKind.Newline):
            ()

        # Expect indent
        if not self.match_token(TokenKind.Indent):
            # Single-line block (inline)
            match self.parse_statement():
                case Ok(stmt):
                    statements.push(stmt)
                    return Ok(statements)
                case Err(e):
                    return Err(e)

        # Multi-line block: parse until dedent
        while not self.match_token(TokenKind.Dedent) and not self.is_at_end():
            # Skip empty lines
            if self.match_token(TokenKind.Newline):
                ()
            else:
                match self.parse_statement():
                    case Ok(stmt):
                        statements.push(stmt)
                    case Err(e):
                        return Err(e)

        Ok(statements)

    # ===== Expression Parsing =====

    me parse_expression() -> Result<Expr, ParseError>:
        self.parse_pipeline()

    me parse_pipeline() -> Result<Expr, ParseError>:
        match self.parse_coalesce():
            case Ok(left):
                var current = left
                while self.check("|>") or self.check(">>") or self.check("<<") or self.check("~>") or self.check("//"):
                    val op_token = self.advance()
                    val op = match op_token.kind:
                        case TokenKind.Operator("|>"): BinOp.Pipe
                        case TokenKind.Operator(">>"): BinOp.ComposeForward
                        case TokenKind.Operator("<<"): BinOp.ComposeBackward
                        case TokenKind.Operator("~>"): BinOp.LayerConnect
                        case TokenKind.Operator("//"): BinOp.Parallel
                        case _: BinOp.Pipe
                    match self.parse_coalesce():
                        case Ok(right):
                            current = Expr.Binary(op, current, right)
                        case Err(e):
                            return Err(e)
                Ok(current)
            case Err(e):
                Err(e)

    me parse_coalesce() -> Result<Expr, ParseError>:
        match self.parse_logical_or():
            case Ok(left):
                var current = left
                while self.check("??"):
                    self.advance()
                    match self.parse_logical_or():
                        case Ok(right):
                            current = Expr.Binary(BinOp.Coalesce, current, right)
                        case Err(e):
                            return Err(e)
                Ok(current)
            case Err(e):
                Err(e)

    me parse_logical_or() -> Result<Expr, ParseError>:
        match self.parse_logical_and():
            case Ok(left):
                var current = left
                while self.check("||"):
                    self.advance()
                    match self.parse_logical_and():
                        case Ok(right):
                            current = Expr.Binary(BinOp.Or, current, right)
                        case Err(e):
                            return Err(e)
                Ok(current)
            case Err(e):
                Err(e)

    me parse_logical_and() -> Result<Expr, ParseError>:
        match self.parse_equality():
            case Ok(left):
                var current = left
                while self.check("&&"):
                    self.advance()
                    match self.parse_equality():
                        case Ok(right):
                            current = Expr.Binary(BinOp.And, current, right)
                        case Err(e):
                            return Err(e)
                Ok(current)
            case Err(e):
                Err(e)

    me parse_equality() -> Result<Expr, ParseError>:
        match self.parse_comparison():
            case Ok(left):
                var current = left
                while self.check("==") or self.check("!="):
                    val op_token = self.advance()
                    val op = match op_token.kind:
                        case TokenKind.Operator("=="): BinOp.Eq
                        case TokenKind.Operator("!="): BinOp.NotEq
                        case _: BinOp.Eq
                    match self.parse_comparison():
                        case Ok(right):
                            current = Expr.Binary(op, current, right)
                        case Err(e):
                            return Err(e)
                Ok(current)
            case Err(e):
                Err(e)

    me parse_comparison() -> Result<Expr, ParseError>:
        match self.parse_bitwise_or():
            case Ok(left):
                var current = left
                while self.check("<") or self.check(">") or self.check("<=") or self.check(">="):
                    val op_token = self.advance()
                    val op = match op_token.kind:
                        case TokenKind.Operator("<"): BinOp.Lt
                        case TokenKind.Operator(">"): BinOp.Gt
                        case TokenKind.Operator("<="): BinOp.LtEq
                        case TokenKind.Operator(">="): BinOp.GtEq
                        case _: BinOp.Lt
                    match self.parse_bitwise_or():
                        case Ok(right):
                            current = Expr.Binary(op, current, right)
                        case Err(e):
                            return Err(e)
                Ok(current)
            case Err(e):
                Err(e)

    me parse_bitwise_or() -> Result<Expr, ParseError>:
        match self.parse_bitwise_xor():
            case Ok(left):
                var current = left
                while self.check("|"):
                    self.advance()
                    match self.parse_bitwise_xor():
                        case Ok(right):
                            current = Expr.Binary(BinOp.BitOr, current, right)
                        case Err(e):
                            return Err(e)
                Ok(current)
            case Err(e):
                Err(e)

    me parse_bitwise_xor() -> Result<Expr, ParseError>:
        match self.parse_bitwise_and():
            case Ok(left):
                var current = left
                while self.check("^"):
                    self.advance()
                    match self.parse_bitwise_and():
                        case Ok(right):
                            current = Expr.Binary(BinOp.BitXor, current, right)
                        case Err(e):
                            return Err(e)
                Ok(current)
            case Err(e):
                Err(e)

    me parse_bitwise_and() -> Result<Expr, ParseError>:
        match self.parse_shift():
            case Ok(left):
                var current = left
                while self.check("&"):
                    self.advance()
                    match self.parse_shift():
                        case Ok(right):
                            current = Expr.Binary(BinOp.BitAnd, current, right)
                        case Err(e):
                            return Err(e)
                Ok(current)
            case Err(e):
                Err(e)

    me parse_shift() -> Result<Expr, ParseError>:
        match self.parse_addition():
            case Ok(left):
                var current = left
                while self.check("<<") or self.check(">>"):
                    val op_token = self.advance()
                    val op = match op_token.kind:
                        case TokenKind.Operator("<<"): BinOp.BitShl
                        case TokenKind.Operator(">>"): BinOp.BitShr
                        case _: BinOp.BitShl
                    match self.parse_addition():
                        case Ok(right):
                            current = Expr.Binary(op, current, right)
                        case Err(e):
                            return Err(e)
                Ok(current)
            case Err(e):
                Err(e)

    me parse_addition() -> Result<Expr, ParseError>:
        match self.parse_multiplication():
            case Ok(left):
                var current = left
                while self.check("+") or self.check("-"):
                    val op_token = self.advance()
                    val op = match op_token.kind:
                        case TokenKind.Operator("+"): BinOp.Add
                        case TokenKind.Operator("-"): BinOp.Sub
                        case _: BinOp.Add
                    match self.parse_multiplication():
                        case Ok(right):
                            current = Expr.Binary(op, current, right)
                        case Err(e):
                            return Err(e)
                Ok(current)
            case Err(e):
                Err(e)

    me parse_multiplication() -> Result<Expr, ParseError>:
        match self.parse_power():
            case Ok(left):
                var current = left
                while self.check("*") or self.check("/") or self.check("%"):
                    val op_token = self.advance()
                    val op = match op_token.kind:
                        case TokenKind.Operator("*"): BinOp.Mul
                        case TokenKind.Operator("/"): BinOp.Div
                        case TokenKind.Operator("%"): BinOp.Mod
                        case _: BinOp.Mul
                    match self.parse_power():
                        case Ok(right):
                            current = Expr.Binary(op, current, right)
                        case Err(e):
                            return Err(e)
                Ok(current)
            case Err(e):
                Err(e)

    me parse_power() -> Result<Expr, ParseError>:
        match self.parse_unary():
            case Ok(left):
                if self.check("**"):
                    self.advance()
                    match self.parse_power():
                        case Ok(right):
                            Ok(Expr.Binary(BinOp.Pow, left, right))
                        case Err(e):
                            Err(e)
                else:
                    Ok(left)
            case Err(e):
                Err(e)

    me parse_unary() -> Result<Expr, ParseError>:
        if self.check("-") or self.check("!") or self.check("~"):
            val op_token = self.advance()
            val op = match op_token.kind:
                case TokenKind.Operator("-"): UnaryOp.Neg
                case TokenKind.Operator("!"): UnaryOp.Not
                case TokenKind.Operator("~"): UnaryOp.Not
                case _: UnaryOp.Neg

            match self.parse_unary():
                case Ok(right):
                    Ok(Expr.Unary(op, right))
                case Err(e):
                    Err(e)
        else:
            self.parse_postfix()

    me parse_postfix() -> Result<Expr, ParseError>:
        match self.parse_primary():
            case Ok(expr):
                self.parse_postfix_loop(expr)
            case Err(e):
                Err(e)

    me parse_postfix_loop(expr: Expr) -> Result<Expr, ParseError>:
        var current = expr

        while true:
            # Field access or method call
            if self.check("."):
                self.advance()
                match self.peek().kind:
                    case TokenKind.Identifier(name):
                        self.advance()
                        if self.check("("):
                            self.advance()
                            match self.parse_call_args():
                                case Ok(args):
                                    self.consume_operator(")")
                                    current = Expr.Method(current, name, args)
                                case Err(e):
                                    return Err(e)
                        else:
                            current = Expr.Field(current, name)
                    case _:
                        return Err(ParseError(
                            message: "Expected field or method name after '.'",
                            line: self.peek().line,
                            column: self.peek().column
                        ))

            # Indexing or slicing
            elif self.check("["):
                self.advance()
                match self.parse_index_or_slice(current):
                    case Ok(indexed):
                        current = indexed
                    case Err(e):
                        return Err(e)

            # Function call
            elif self.check("("):
                self.advance()
                match self.parse_call_args():
                    case Ok(args):
                        self.consume_operator(")")
                        current = Expr.Call(current, args)
                    case Err(e):
                        return Err(e)
            else:
                break

        Ok(current)

    me parse_call_args() -> Result<[Expr], ParseError>:
        var args: [Expr] = []

        if self.check(")"):
            return Ok(args)

        while true:
            match self.parse_expression():
                case Ok(arg):
                    args.push(arg)
                case Err(e):
                    return Err(e)

            if self.check(")"):
                break
            elif self.check(","):
                self.advance()
                if self.check(")"):
                    break
            else:
                return Err(ParseError(
                    message: "Expected ',' or ')' in argument list",
                    line: self.peek().line,
                    column: self.peek().column
                ))

        Ok(args)

    me parse_index_or_slice(expr: Expr) -> Result<Expr, ParseError>:
        var start: Expr? = nil
        var end: Expr? = nil
        var step: Expr? = nil

        if not self.check(":"):
            match self.parse_expression():
                case Ok(s):
                    start = Some(s)
                case Err(e):
                    return Err(e)

        if self.check("]"):
            self.advance()
            match start:
                case Some(idx):
                    return Ok(Expr.Index(expr, idx))
                case nil:
                    return Err(ParseError(
                        message: "Empty index expression",
                        line: self.peek().line,
                        column: self.peek().column
                    ))

        if self.consume_operator(":"):
            if not self.check(":") and not self.check("]"):
                match self.parse_expression():
                    case Ok(e):
                        end = Some(e)
                    case Err(err):
                        return Err(err)

            if self.consume_operator(":"):
                if not self.check("]"):
                    match self.parse_expression():
                        case Ok(s):
                            step = Some(s)
                        case Err(err):
                            return Err(err)

        self.consume_operator("]")
        Ok(Expr.Slice(expr, start, end, step))

    me parse_primary() -> Result<Expr, ParseError>:
        val token = self.peek()

        match token.kind:
            case TokenKind.Number(n):
                self.advance()
                Ok(Expr.Literal(Literal.Int(42)))

            case TokenKind.String(s):
                self.advance()
                # Check if string has interpolation
                if s.contains("{"):
                    self.parse_string_interpolation(s)
                else:
                    Ok(Expr.Literal(Literal.String(s)))

            case TokenKind.Keyword("true"):
                self.advance()
                Ok(Expr.Literal(Literal.Bool(true)))

            case TokenKind.Keyword("false"):
                self.advance()
                Ok(Expr.Literal(Literal.Bool(false)))

            case TokenKind.Identifier(name):
                self.advance()
                Ok(Expr.Identifier(name))

            case TokenKind.Operator("("):
                self.advance()
                match self.parse_expression():
                    case Ok(expr):
                        self.consume_operator(")")
                        Ok(expr)
                    case Err(e):
                        Err(e)

            case TokenKind.Operator("["):
                self.advance()
                var elements: [Expr] = []
                if self.check("]"):
                    self.advance()
                    return Ok(Expr.List(elements))
                while true:
                    match self.parse_expression():
                        case Ok(elem):
                            elements.push(elem)
                        case Err(e):
                            return Err(e)
                    if self.check("]"):
                        self.advance()
                        break
                    elif self.check(","):
                        self.advance()
                        if self.check("]"):
                            self.advance()
                            break
                    else:
                        return Err(ParseError(
                            message: "Expected ',' or ']' in array literal",
                            line: self.peek().line,
                            column: self.peek().column
                        ))
                Ok(Expr.List(elements))

            case TokenKind.Operator("\\"):
                # Short lambda form: \x: expr or \x, y: expr
                self.parse_lambda_short()

            case TokenKind.Keyword("fn"):
                # Long lambda form: fn(x): expr or fn(x, y): expr
                self.parse_lambda_long()

            case _:
                Err(ParseError(
                    message: "Expected expression",
                    line: token.line,
                    column: token.column
                ))

    me parse_string_interpolation(s: text) -> Result<Expr, ParseError>:
        # Parse "Hello {name} world {x + 1}" into parts
        # For now, simplified: just detect {...} and mark as interpolation
        # Full implementation would parse expressions inside braces

        var parts: [Expr] = []
        var current = ""
        var i = 0
        var in_brace = false
        var brace_content = ""

        while i < s.len():
            val ch = s[i:i + 1]

            if ch == "{" and not in_brace:
                # Save current string part
                if current.len() > 0:
                    parts.push(Expr.Literal(Literal.String(current)))
                    current = ""
                in_brace = true
                brace_content = ""
            elif ch == "}" and in_brace:
                # Parse expression in braces
                match parse_expr(brace_content):
                    case Ok(expr):
                        parts.push(expr)
                    case Err(e):
                        return Err(ParseError(
                            message: "Failed to parse interpolated expression: {e.message}",
                            line: self.peek().line,
                            column: self.peek().column
                        ))
                in_brace = false
                brace_content = ""
            elif in_brace:
                brace_content = brace_content + ch
            else:
                current = current + ch

            i = i + 1

        # Add remaining string part
        if current.len() > 0:
            parts.push(Expr.Literal(Literal.String(current)))

        Ok(Expr.StringInterpolation(parts))

    me parse_lambda_short() -> Result<Expr, ParseError>:
        # Short lambda: \x: expr or \x, y: expr
        self.advance()  # consume \

        var params: [text] = []

        # Parse parameter list (no parens)
        while true:
            match self.peek().kind:
                case TokenKind.Identifier(name):
                    self.advance()
                    params.push(name)
                case _:
                    return Err(ParseError(
                        message: "Expected parameter name in lambda",
                        line: self.peek().line,
                        column: self.peek().column
                    ))

            # Check for more params or colon
            if self.check(":"):
                break
            elif self.check(","):
                self.advance()
            else:
                return Err(ParseError(
                    message: "Expected ',' or ':' in lambda",
                    line: self.peek().line,
                    column: self.peek().column
                ))

        # Consume colon
        self.consume_operator(":")

        # Parse body expression
        match self.parse_expression():
            case Ok(body):
                Ok(Expr.Lambda(params, body))
            case Err(e):
                Err(e)

    me parse_lambda_long() -> Result<Expr, ParseError>:
        # Long lambda: fn(x): expr or fn(x, y): expr
        self.advance()  # consume fn

        # Expect opening paren
        if not self.check("("):
            return Err(ParseError(
                message: "Expected '(' after 'fn' in lambda",
                line: self.peek().line,
                column: self.peek().column
            ))

        self.advance()  # consume (

        var params: [text] = []

        # Parse parameter list
        if not self.check(")"):
            while true:
                match self.peek().kind:
                    case TokenKind.Identifier(name):
                        self.advance()
                        params.push(name)
                    case _:
                        return Err(ParseError(
                            message: "Expected parameter name in lambda",
                            line: self.peek().line,
                            column: self.peek().column
                        ))

                if self.check(")"):
                    break
                elif self.check(","):
                    self.advance()
                else:
                    return Err(ParseError(
                        message: "Expected ',' or ')' in lambda parameters",
                        line: self.peek().line,
                        column: self.peek().column
                    ))

        self.consume_operator(")")
        self.consume_operator(":")

        # Parse body expression
        match self.parse_expression():
            case Ok(body):
                Ok(Expr.Lambda(params, body))
            case Err(e):
                Err(e)

    me parse_type() -> Result<TypeExpr, ParseError>:
        match self.peek().kind:
            case TokenKind.Identifier(name):
                self.advance()
                Ok(TypeExpr.Named(name))
            case _:
                Err(ParseError(
                    message: "Expected type",
                    line: self.peek().line,
                    column: self.peek().column
                ))

# ===== Public API Functions =====

fn parse(source: text) -> Result<Module, ParseError>:
    val tokens = lex_source(source)
    var parser = Parser(tokens: tokens, current: 0)

    var statements: [Stmt] = []
    while not parser.is_at_end():
        match parser.parse_statement():
            case Ok(stmt):
                statements.push(stmt)
            case Err(e):
                return Err(e)

    Ok(Module(statements: statements))

fn parse_expr(source: text) -> Result<Expr, ParseError>:
    val tokens = lex_source(source)
    var parser = Parser(tokens: tokens, current: 0)
    parser.parse_expression()

fn parse_stmt(source: text) -> Result<Stmt, ParseError>:
    val tokens = lex_source(source)
    var parser = Parser(tokens: tokens, current: 0)
    parser.parse_statement()
