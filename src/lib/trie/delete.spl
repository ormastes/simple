# Trie Delete Operations
#
# Functions for deleting words from tries.

# Deletes a word from the trie
# Args:
#   trie: The trie root node
#   word: String to delete
# Returns: true if word was deleted, false if not found
fn trie_delete(trie, word):
    trie_delete_helper(trie, word, 0)

# Helper function for deleting a word (recursive simulation)
# Args:
#   node: Current trie node
#   word: Word to delete
#   index: Current position in word
# Returns: true if node should be deleted, false otherwise
fn trie_delete_helper(node, word, index):
    if node == nil:
        return false

    var len = word.length()

    if index == len:
        if not node["is_end"]:
            return false

        node["is_end"] = false
        var children = node["children"]
        return children.size() == 0

    var ch = word.char_at(index)
    var children = node["children"]

    if not children.has_key(ch):
        return false

    var child_node = children[ch]
    var should_delete = trie_delete_helper(child_node, word, index + 1)

    if should_delete:
        children.remove(ch)
        var remaining = children.size()
        return remaining == 0 and not node["is_end"]

    false

# Deletes multiple words at once
# Args:
#   trie: The trie root node
#   words: List of words to delete
# Returns: Number of words successfully deleted
fn trie_delete_all(trie, words):
    var count = 0
    var i = 0
    var len = words.length()

    while i < len:
        var deleted = trie_delete(trie, words[i])
        if deleted:
            count = count + 1
        i = i + 1

    count

# Removes words based on a predicate function
# Args:
#   trie: The trie root node
#   predicate: Function that takes a word and returns boolean
# Returns: nil (modifies trie in place)
fn trie_remove_if(trie, predicate):
    var words = trie_all_words(trie)
    var i = 0
    var len = words.length()

    while i < len:
        var word = words[i]
        if predicate(word):
            trie_delete(trie, word)
        i = i + 1

    nil

# Forward declaration for trie_all_words (defined in traversal.spl)
fn trie_all_words(trie):
    var results = []
    trie_collect_words(trie, "", results)
    results

# Forward declaration for trie_collect_words (defined in traversal.spl)
fn trie_collect_words(node, current, results):
    if node["is_end"]:
        results.append(current)

    var children = node["children"]
    var keys = children.keys()
    var i = 0
    var len = keys.length()

    while i < len:
        var ch = keys[i]
        var child = children[ch]
        var next_str = current + ch
        trie_collect_words(child, next_str, results)
        i = i + 1

    nil
