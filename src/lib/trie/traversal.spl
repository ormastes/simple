# Trie Traversal Operations
#
# Functions for traversing tries and collecting words and paths.

# Gets all words stored in the trie
# Args:
#   trie: The trie root node
# Returns: List of all words in the trie
fn trie_all_words(trie):
    var results = []
    trie_collect_words(trie, "", results)
    results

# Helper function to collect all words from a node
# Args:
#   node: Starting trie node
#   current: Current string built so far
#   results: List to append results to
# Returns: nil
fn trie_collect_words(node, current, results):
    if node["is_end"]:
        results.append(current)

    var children = node["children"]
    var keys = children.keys()
    var i = 0
    var len = keys.length()

    while i < len:
        var ch = keys[i]
        var child = children[ch]
        var next_str = current + ch
        trie_collect_words(child, next_str, results)
        i = i + 1

    nil

# Gets all unique prefixes in the trie (including complete words)
# Args:
#   trie: The trie root node
# Returns: List of all prefixes
fn trie_all_unique_prefixes(trie):
    var results = []
    trie_collect_all_prefixes(trie, "", results)
    results

# Helper function to collect all prefixes from a node
# Args:
#   node: Starting trie node
#   current: Current string built so far
#   results: List to append results to
# Returns: nil
fn trie_collect_all_prefixes(node, current, results):
    if current.length() > 0:
        results.append(current)

    var children = node["children"]
    var keys = children.keys()
    var i = 0
    var len = keys.length()

    while i < len:
        var ch = keys[i]
        var child = children[ch]
        var next_str = current + ch
        trie_collect_all_prefixes(child, next_str, results)
        i = i + 1

    nil

# Gets all paths from root to end nodes as list of characters
# Args:
#   trie: The trie root node
# Returns: List of paths (each path is a list of characters)
fn trie_all_paths(trie):
    var results = []
    trie_collect_paths(trie, [], results)
    results

# Helper function to collect all paths
# Args:
#   node: Current trie node
#   current_path: Current path of characters
#   results: List to append paths to
# Returns: nil
fn trie_collect_paths(node, current_path, results):
    if node["is_end"]:
        results.append(current_path)

    var children = node["children"]
    var keys = children.keys()
    var i = 0
    var len = keys.length()

    while i < len:
        var ch = keys[i]
        var child = children[ch]
        var new_path = []
        var j = 0
        var path_len = current_path.length()
        while j < path_len:
            new_path.append(current_path[j])
            j = j + 1
        new_path.append(ch)
        trie_collect_paths(child, new_path, results)
        i = i + 1

    nil

# Filters words based on a predicate function
# Args:
#   trie: The trie root node
#   predicate: Function that takes a word and returns boolean
# Returns: New trie containing only words matching predicate
fn trie_filter(trie, predicate):
    var result = trie_create()
    var words = trie_all_words(trie)
    var i = 0
    var len = words.length()

    while i < len:
        var word = words[i]
        if predicate(word):
            trie_insert(result, word)
        i = i + 1

    result

# Maps words to new values and creates new trie
# Args:
#   trie: The trie root node
#   mapper: Function that takes a word and returns new word
# Returns: New trie with transformed words
fn trie_map(trie, mapper):
    var result = trie_create()
    var words = trie_all_words(trie)
    var i = 0
    var len = words.length()

    while i < len:
        var new_word = mapper(words[i])
        trie_insert(result, new_word)
        i = i + 1

    result

# Forward declarations (defined in other modules)
fn trie_create():
    {
        "children": {},
        "is_end": false
    }

fn trie_insert(trie, word):
    var current = trie
    var i = 0
    var len = word.length()

    while i < len:
        var ch = word.char_at(i)
        var children = current["children"]

        if not children.has_key(ch):
            children[ch] = trie_node()

        current = children[ch]
        i = i + 1

    current["is_end"] = true
    nil

fn trie_node():
    {
        "children": {},
        "is_end": false
    }
