# Algorithm Utilities Module
#
# Sorting algorithms, searching algorithms, and list manipulation utilities.
# All operations work on i64 lists and are pure Simple implementations.
#
# Categories:
# - Helpers: is_sorted, lists_equal, swap (delegate to array.spl)
# - Sorting: bubble_sort, selection_sort, insertion_sort, quick_sort, merge_sort
# - Searching: linear_search, binary_search, find_min/max, find_min/max_index
# - Manipulation: reverse_list, take, drop, sum, count_occurrences, etc.
#
# All functions are pure Simple - no external dependencies required.

# Import canonical implementations
use std.array.{array_is_sorted, array_equals, array_reverse}

# ============================================================================
# Exports
# ============================================================================

export is_sorted, lists_equal, swap
export bubble_sort, selection_sort, insertion_sort, quick_sort, merge_sort, merge_sorted
export linear_search, binary_search, find_min, find_max, find_min_index, find_max_index
export reverse_list, take, drop, sum, count_occurrences, find_all_indices
export remove_duplicates, is_prefix, is_suffix, find_sublist

# ============================================================================
# Helper Functions
# ============================================================================

fn is_sorted(list: [i64]) -> bool:
    """Check if list is sorted in ascending order.

    Delegates to array_is_sorted() from std.array.

    Example:
        is_sorted([1, 2, 3, 4])  # true
        is_sorted([1, 3, 2])     # false
    """
    array_is_sorted(list)

fn lists_equal(a: [i64], b: [i64]) -> bool:
    """Check if two lists are equal element-wise.

    Delegates to array_equals() from std.array.

    Example:
        lists_equal([1, 2, 3], [1, 2, 3])  # true
        lists_equal([1, 2], [1, 2, 3])     # false
    """
    array_equals(a, b)

fn swap(list: [i64], i: i64, j: i64) -> [i64]:
    """Swap elements at indices i and j. Returns new list.

    Example:
        swap([1, 2, 3], i=0, j=2)  # [3, 2, 1]
    """
    var result = list
    val temp = result[i]
    result[i] = result[j]
    result[j] = temp
    result

# ============================================================================
# Sorting Algorithms
# ============================================================================

fn bubble_sort(list: [i64]) -> [i64]:
    """Bubble sort algorithm. O(n²) time complexity.

    Example:
        bubble_sort([3, 1, 4, 1, 5])  # [1, 1, 3, 4, 5]
    """
    var result = list
    val n = result.len()
    for i in 0..n:
        for j in 0..(n - i - 1):
            if result[j] > result[j + 1]:
                result = swap(result, i=j, j=j + 1)
    result

fn selection_sort(list: [i64]) -> [i64]:
    """Selection sort algorithm. O(n²) time complexity.

    Example:
        selection_sort([64, 25, 12, 22, 11])  # [11, 12, 22, 25, 64]
    """
    var result = list
    val n = result.len()
    for i in 0..n:
        var min_idx = i
        for j in (i + 1)..n:
            if result[j] < result[min_idx]:
                min_idx = j
        if min_idx != i:
            result = swap(result, i=i, j=min_idx)
    result

fn insertion_sort(list: [i64]) -> [i64]:
    """Insertion sort algorithm. O(n²) time complexity, efficient for small lists.

    Example:
        insertion_sort([12, 11, 13, 5, 6])  # [5, 6, 11, 12, 13]
    """
    var result = list
    val n = result.len()
    for i in 1..n:
        val key = result[i]
        var j = i - 1
        while j >= 0 and result[j] > key:
            result[j + 1] = result[j]
            j = j - 1
        result[j + 1] = key
    result

fn quick_sort(list: [i64]) -> [i64]:
    """Quick sort algorithm. O(n log n) average time complexity.

    Example:
        quick_sort([10, 7, 8, 9, 1, 5])  # [1, 5, 7, 8, 9, 10]
    """
    if list.len() <= 1:
        return list
    val pivot = list[list.len() / 2]
    var less: [i64] = []
    var equal: [i64] = []
    var greater: [i64] = []
    for x in list:
        if x < pivot:
            less = less + [x]
        else if x == pivot:
            equal = equal + [x]
        else:
            greater = greater + [x]
    quick_sort(less) + equal + quick_sort(greater)

fn merge_sort(list: [i64]) -> [i64]:
    """Merge sort algorithm. O(n log n) time complexity, stable sort.

    Example:
        merge_sort([38, 27, 43, 3, 9, 82, 10])  # [3, 9, 10, 27, 38, 43, 82]
    """
    if list.len() <= 1:
        return list
    val mid = list.len() / 2
    var left: [i64] = []
    var right: [i64] = []
    for i in 0..mid:
        left = left + [list[i]]
    for i in mid..list.len():
        right = right + [list[i]]
    merge_sorted(left=merge_sort(left), right=merge_sort(right))

fn merge_sorted(left: [i64], right: [i64]) -> [i64]:
    """Merge two sorted lists. Helper for merge_sort.

    Example:
        merge_sorted(left=[1, 3, 5], right=[2, 4, 6])  # [1, 2, 3, 4, 5, 6]
    """
    var result: [i64] = []
    var i = 0
    var j = 0
    while i < left.len() and j < right.len():
        if left[i] <= right[j]:
            result = result.push(left[i])
            i = i + 1
        else:
            result = result.push(right[j])
            j = j + 1
    while i < left.len():
        result = result.push(left[i])
        i = i + 1
    while j < right.len():
        result = result.push(right[j])
        j = j + 1
    result

# ============================================================================
# Search Algorithms
# ============================================================================

fn linear_search(list: [i64], target: i64) -> i64?:
    """Linear search. Returns index of first occurrence or nil.

    Example:
        linear_search([1, 2, 3, 4], target=3)  # 2
        linear_search([1, 2, 3], target=5)     # nil
    """
    for i in 0..list.len():
        if list[i] == target:
            return i
    nil

fn binary_search(list: [i64], target: i64) -> i64?:
    """Binary search on sorted list. Returns index or nil.

    Example:
        binary_search([1, 2, 3, 4, 5], target=3)  # 2
        binary_search([1, 3, 5], target=2)        # nil
    """
    var low = 0
    var high = list.len() - 1
    while low <= high:
        val mid = (low + high) / 2
        if list[mid] == target:
            return mid
        else if list[mid] < target:
            low = mid + 1
        else:
            high = mid - 1
    nil

fn find_min(list: [i64]) -> i64?:
    """Find minimum value in list. Returns nil for empty list.

    Example:
        find_min([3, 1, 4, 1, 5])  # 1
        find_min([])               # nil
    """
    if list.len() == 0:
        return nil
    var min_val = list[0]
    for x in list:
        if x < min_val:
            min_val = x
    min_val

fn find_max(list: [i64]) -> i64?:
    """Find maximum value in list. Returns nil for empty list.

    Example:
        find_max([3, 1, 4, 1, 5])  # 5
        find_max([])               # nil
    """
    if list.len() == 0:
        return nil
    var max_val = list[0]
    for x in list:
        if x > max_val:
            max_val = x
    max_val

fn find_min_index(list: [i64]) -> i64?:
    """Find index of minimum value. Returns nil for empty list.

    Example:
        find_min_index([3, 1, 4, 1, 5])  # 1
    """
    if list.len() == 0:
        return nil
    var min_idx = 0
    for i in 1..list.len():
        if list[i] < list[min_idx]:
            min_idx = i
    min_idx

fn find_max_index(list: [i64]) -> i64?:
    """Find index of maximum value. Returns nil for empty list.

    Example:
        find_max_index([3, 1, 4, 1, 5])  # 4
    """
    if list.len() == 0:
        return nil
    var max_idx = 0
    for i in 1..list.len():
        if list[i] > list[max_idx]:
            max_idx = i
    max_idx

# ============================================================================
# List Manipulation
# ============================================================================

fn reverse_list(list: [i64]) -> [i64]:
    """Reverse a list.

    Delegates to array_reverse() from std.array.

    Example:
        reverse_list([1, 2, 3, 4])  # [4, 3, 2, 1]
    """
    array_reverse(list)

fn take(list: [i64], n: i64) -> [i64]:
    """Take first n elements from list.

    Example:
        take([1, 2, 3, 4, 5], n=3)  # [1, 2, 3]
    """
    var result: [i64] = []
    val count = if n < list.len(): n else: list.len()
    for i in 0..count:
        result = result.push(list[i])
    result

fn drop(list: [i64], n: i64) -> [i64]:
    """Drop first n elements from list.

    Example:
        drop([1, 2, 3, 4, 5], n=2)  # [3, 4, 5]
    """
    if n >= list.len():
        return []
    var result: [i64] = []
    for i in n..list.len():
        result = result.push(list[i])
    result

fn sum(list: [i64]) -> i64:
    """Sum all elements in list.

    Example:
        sum([1, 2, 3, 4, 5])  # 15
    """
    var total = 0
    for x in list:
        total = total + x
    total

fn count_occurrences(list: [i64], target: i64) -> i64:
    """Count occurrences of target in list.

    Example:
        count_occurrences([1, 2, 1, 3, 1], target=1)  # 3
    """
    var match_count = 0
    for x in list:
        if x == target:
            match_count = match_count + 1
    match_count

fn find_all_indices(list: [i64], target: i64) -> [i64]:
    """Find all indices where target appears.

    Example:
        find_all_indices([1, 2, 1, 3, 1], target=1)  # [0, 2, 4]
    """
    var indices: [i64] = []
    for i in 0..list.len():
        if list[i] == target:
            indices = indices.push(i)
    indices

fn remove_duplicates(list: [i64]) -> [i64]:
    """Remove duplicate values, preserving first occurrence.

    Example:
        remove_duplicates([1, 2, 1, 3, 2])  # [1, 2, 3]
    """
    var seen = {}
    var result: [i64] = []
    for x in list:
        val key = "{x}"
        if not seen.contains_key(key):
            seen[key] = true
            result = result.push(x)
    result

fn is_prefix(prefix: [i64], list: [i64]) -> bool:
    """Check if prefix is a prefix of list.

    Example:
        is_prefix([1, 2], [1, 2, 3, 4])  # true
        is_prefix([1, 3], [1, 2, 3])     # false
    """
    if prefix.len() > list.len():
        return false
    for i in 0..prefix.len():
        if prefix[i] != list[i]:
            return false
    true

fn is_suffix(suffix: [i64], list: [i64]) -> bool:
    """Check if suffix is a suffix of list.

    Example:
        is_suffix([3, 4], [1, 2, 3, 4])  # true
        is_suffix([2, 4], [1, 2, 3, 4])  # false
    """
    if suffix.len() > list.len():
        return false
    val offset = list.len() - suffix.len()
    for i in 0..suffix.len():
        if suffix[i] != list[offset + i]:
            return false
    true

fn find_sublist(haystack: [i64], needle: [i64]) -> i64?:
    """Find first occurrence of needle sublist in haystack.

    Example:
        find_sublist([1, 2, 3, 4, 5], [3, 4])  # 2
        find_sublist([1, 2, 3], [4, 5])        # nil
    """
    if needle.len() > haystack.len():
        return nil
    for i in 0..(haystack.len() - needle.len() + 1):
        var found = true
        for j in 0..needle.len():
            if haystack[i + j] != needle[j]:
                found = false
        if found:
            return i
    nil
