# Queue Dequeue Operations
#
# Functions for removing elements from queues

# Remove and return item from the front of the queue
fn queue_dequeue(queue):
    if queue.items.len() == 0:
        return nil
    val item = queue.items[0]
    var new_items = []
    var i = 1
    while i < queue.items.len():
        new_items.push(queue.items[i])
        i = i + 1
    queue.items = new_items
    Some(item)

# Pop and return item from the top of the stack
fn stack_pop(stack):
    if stack.items.len() == 0:
        return nil
    val idx = stack.items.len() - 1
    val item = stack.items[idx]
    var new_items = []
    var i = 0
    while i < idx:
        new_items.push(stack.items[i])
        i = i + 1
    stack.items = new_items
    Some(item)

# Remove and return item from the front of deque
fn deque_pop_front(deque):
    if deque.items.len() == 0:
        return nil
    val item = deque.items[0]
    var new_items = []
    var i = 1
    while i < deque.items.len():
        new_items.push(deque.items[i])
        i = i + 1
    deque.items = new_items
    Some(item)

# Remove and return item from the back of deque
fn deque_pop_back(deque):
    if deque.items.len() == 0:
        return nil
    val idx = deque.items.len() - 1
    val item = deque.items[idx]
    var new_items = []
    var i = 0
    while i < idx:
        new_items.push(deque.items[i])
        i = i + 1
    deque.items = new_items
    Some(item)

# View the front item without removing it
fn queue_peek(queue):
    if queue.items.len() == 0:
        return nil
    Some(queue.items[0])

# View the top item without removing it
fn stack_peek(stack):
    if stack.items.len() == 0:
        return nil
    Some(stack.items[stack.items.len() - 1])

# View the front item of deque without removing it
fn deque_peek_front(deque):
    if deque.items.len() == 0:
        return nil
    Some(deque.items[0])

# View the back item of deque without removing it
fn deque_peek_back(deque):
    if deque.items.len() == 0:
        return nil
    Some(deque.items[deque.items.len() - 1])

# Read and remove oldest item from buffer
fn cbuffer_read(cbuffer):
    if cbuffer_is_empty(cbuffer):
        return nil
    val item = cbuffer.items[cbuffer.head]
    val was_full = cbuffer.full
    cbuffer.full = false
    cbuffer.head = (cbuffer.head + 1) % cbuffer.items.len()
    if not was_full and cbuffer.head == cbuffer.tail:
        cbuffer.head = 0
        cbuffer.tail = 0
        cbuffer.items = []
    Some(item)

# View oldest item from buffer without removing it
fn cbuffer_peek(cbuffer):
    if cbuffer_is_empty(cbuffer):
        return nil
    Some(cbuffer.items[cbuffer.head])

# Helper for circular buffer
fn cbuffer_is_empty(cbuffer):
    not cbuffer.full and cbuffer.head == cbuffer.tail

export queue_dequeue
export stack_pop
export deque_pop_front
export deque_pop_back
export queue_peek
export stack_peek
export deque_peek_front
export deque_peek_back
export cbuffer_read
export cbuffer_peek
