# @alloc
# Array Advanced Collection Utilities
#
# Extracted from array.spl. Contains:
# - group_consecutive, transpose, cartesian_product
# - frequencies, mode, median
# - intersect, difference, union, is_subset
# - starts_with, ends_with, index_of_subarray, contains_subarray

# ============================================================================
# Advanced Collection Utilities (from collection_utils.spl)
# ============================================================================

fn array_group_consecutive(arr):
    """Group consecutive equal elements.

    Example:
        array_group_consecutive([1,1,2,2,2,3,1])
        # [[1,1], [2,2,2], [3], [1]]
    """
    if arr.len() == 0:
        return []

    var result = []
    var current_group = [arr[0]]

    var i = 1
    while i < arr.len():
        if arr[i] == arr[i-1]:
            current_group.push(arr[i])
        else:
            result.push(current_group)
            current_group = [arr[i]]
        i = i + 1

    result.push(current_group)
    result

fn array_transpose(matrix):
    """Transpose a 2D array (matrix).

    Example:
        array_transpose([[1,2,3], [4,5,6]])
        # [[1,4], [2,5], [3,6]]
    """
    if matrix.len() == 0:
        return []

    val rows = matrix.len()
    val cols = matrix[0].len()

    var result = []
    var col = 0
    while col < cols:
        var new_row = []
        var row = 0
        while row < rows:
            new_row.push(matrix[row][col])
            row = row + 1
        result.push(new_row)
        col = col + 1

    result

fn array_cartesian_product(arr1, arr2):
    """Cartesian product of two arrays.

    Returns array of tuples representing all pairs.

    Example:
        array_cartesian_product([1,2], [3,4])
        # [(1,3), (1,4), (2,3), (2,4)]
    """
    var result = []

    for a in arr1:
        for b in arr2:
            result.push((a, b))

    result

fn array_frequencies(arr):
    """Count element frequencies.

    Returns array of (element, count) tuples.

    Example:
        array_frequencies([1,2,2,3,3,3])
        # [(1,1), (2,2), (3,3)]
    """
    var counts = []

    for item in arr:
        var found = false
        var idx = 0
        while idx < counts.len():
            val (elem, count) = counts[idx]
            if elem == item:
                counts[idx] = (elem, count + 1)
                found = true
                break
            idx = idx + 1

        if not found:
            counts.push((item, 1))

    counts

fn array_mode(arr):
    """Find most common element.

    Returns the element that appears most frequently.
    If multiple elements tie, returns the first one encountered.

    Returns nil for empty array.
    """
    if arr.len() == 0:
        return nil

    val freqs = array_frequencies(arr)

    var max_count = 0
    var mode_elem = nil

    for (elem, count) in freqs:
        if count > max_count:
            max_count = count
            mode_elem = elem

    mode_elem

fn array_median(arr):
    """Find median value of sorted numeric array. Delegates to median_i64 from math.spl.

    Array must be sorted for correct result.
    Returns nil for empty array.
    """
    median_i64(arr)

fn array_intersect(arr1, arr2):
    """Find common elements (set intersection).

    Returns elements that appear in both arrays.
    Duplicates are removed.

    Example:
        array_intersect([1,2,3], [2,3,4])  # [2,3]
    """
    var result = []
    var seen = []

    for item in arr1:
        var in_arr2 = false
        for item2 in arr2:
            if item == item2:
                in_arr2 = true
                break

        var already_added = false
        for s in seen:
            if s == item:
                already_added = true
                break

        if in_arr2 and not already_added:
            result.push(item)
            seen.push(item)

    result

fn array_difference(arr1, arr2):
    """Find elements in arr1 but not in arr2 (set difference).

    Example:
        array_difference([1,2,3,4], [2,4])  # [1,3]
    """
    var result = []

    for item in arr1:
        var in_arr2 = false
        for item2 in arr2:
            if item == item2:
                in_arr2 = true
                break

        if not in_arr2:
            var already_added = false
            for r in result:
                if r == item:
                    already_added = true
                    break

            if not already_added:
                result.push(item)

    result

fn array_union(arr1, arr2):
    """Combine unique elements from both arrays (set union).

    Example:
        array_union([1,2,3], [3,4,5])  # [1,2,3,4,5]
    """
    var result = []
    var seen = []

    for item in arr1:
        var already_added = false
        for s in seen:
            if s == item:
                already_added = true
                break

        if not already_added:
            result.push(item)
            seen.push(item)

    for item in arr2:
        var already_added = false
        for s in seen:
            if s == item:
                already_added = true
                break

        if not already_added:
            result.push(item)
            seen.push(item)

    result

fn array_is_subset(arr1, arr2):
    """Check if arr1 is a subset of arr2.

    Returns true if all elements of arr1 are in arr2.
    """
    for item in arr1:
        var found = false
        for item2 in arr2:
            if item == item2:
                found = true
                break

        if not found:
            return false

    true

fn array_starts_with(arr, prefix):
    """Check if array starts with given prefix array.

    Example:
        array_starts_with([1,2,3,4], [1,2])  # true
    """
    if prefix.len() > arr.len():
        return false

    var i = 0
    while i < prefix.len():
        if arr[i] != prefix[i]:
            return false
        i = i + 1

    true

fn array_ends_with(arr, suffix):
    """Check if array ends with given suffix array.

    Example:
        array_ends_with([1,2,3,4], [3,4])  # true
    """
    if suffix.len() > arr.len():
        return false

    val offset = arr.len() - suffix.len()
    var i = 0
    while i < suffix.len():
        if arr[offset + i] != suffix[i]:
            return false
        i = i + 1

    true

fn array_index_of_subarray(arr, subarray):
    """Find index of first occurrence of subarray.

    Returns -1 if not found.

    Example:
        array_index_of_subarray([1,2,3,2,3], [2,3])  # 1
    """
    if subarray.len() == 0 or subarray.len() > arr.len():
        return -1

    var i = 0
    while i <= arr.len() - subarray.len():
        var match = true
        var j = 0
        while j < subarray.len():
            if arr[i + j] != subarray[j]:
                match = false
                break
            j = j + 1

        if match:
            return i

        i = i + 1

    -1

fn array_contains_subarray(arr, subarray):
    """Check if array contains subarray.

    Example:
        array_contains_subarray([1,2,3,4], [2,3])  # true
    """
    array_index_of_subarray(arr, subarray) >= 0


export array_group_consecutive, array_transpose, array_cartesian_product
export array_frequencies, array_mode, array_median
export array_intersect, array_difference, array_union, array_is_subset
export array_starts_with, array_ends_with
export array_index_of_subarray, array_contains_subarray
