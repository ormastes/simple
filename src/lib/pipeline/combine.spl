# Pipeline Execution and Combinators
#
# Functions for executing pipelines and combining operations.

# ============================================================================
# Exports
# ============================================================================

export run_pipeline, run_with_error_handling, run_pipeline_safe
export create_etl_pipeline, extract_step, transform_etl_step, load_step
export create_callback_chain, add_callback, run_callbacks
export create_promise, resolve_promise, then_promise, catch_promise

# ============================================================================
# Pipeline Execution
# ============================================================================

fn run_pipeline(pipeline, data):
    """Execute the pipeline on input data.

    Runs all steps in sequence, passing output to next step.

    Example:
        val result = run_pipeline(pipeline, 5)
    """
    var current = data
    val steps = pipeline["steps"]
    for step in steps:
        current = step(current)
    current

fn run_with_error_handling(pipeline, data):
    """Execute pipeline with error handling.

    Returns { success: true, data: result } or { success: false, error: msg }.

    Example:
        val result = run_with_error_handling(pipeline, input)
        if result["success"]:
            print("Result: {result["data"]}")
    """
    var current = data
    val steps = pipeline["steps"]
    var error = nil

    for step in steps:
        if error != nil:
            return { success: false, error: error, data: current }

        # Check if step returns error format
        val step_result = step(current)
        if step_result != nil:
            val is_dict = true  # Assume dict-like check
            # Check for error field
            if is_dict:
                val has_error = step_result.get("error", nil)
                if has_error != nil:
                    error = has_error
                    current = step_result.get("data", current)
                else:
                    current = step_result
            else:
                current = step_result
        else:
            current = step_result

    { success: true, data: current }

fn run_pipeline_safe(pipeline, data, default_value):
    """Execute pipeline and return default value on error.

    Example:
        val result = run_pipeline_safe(pipeline, data, 0)
    """
    val result = run_with_error_handling(pipeline, data)
    if result["success"]:
        result["data"]
    else:
        default_value

# ============================================================================
# ETL Pipeline Patterns
# ============================================================================

fn create_etl_pipeline(extract_fn, transform_fn, load_fn):
    """Create a standard ETL (Extract-Transform-Load) pipeline.

    Example:
        val etl = create_etl_pipeline(
            \source: fetch_data(source),
            \data: clean_and_validate(data),
            \data: save_to_db(data)
        )
    """
    pipeline_from_functions([extract_fn, transform_fn, load_fn])

fn extract_step(source_fn):
    """Create an extraction step for ETL.

    Example:
        val extract = extract_step(\config: read_csv(config["path"]))
    """
    source_fn

fn transform_etl_step(transformations):
    """Create a transformation step with multiple operations.

    Args:
        transformations: Array of transformation functions

    Example:
        val transform = transform_etl_step([clean, validate, normalize])
    """
    \data: {
        var result = data
        for transform_fn in transformations:
            result = transform_fn(result)
        result
    }

fn load_step(destination_fn):
    """Create a load step for ETL.

    Example:
        val load = load_step(\data: write_to_database(data))
    """
    destination_fn

# ============================================================================
# Callback Chain Pattern
# ============================================================================

fn create_callback_chain():
    """Create a callback chain for async-like patterns.

    Returns callback chain object with callbacks array.

    Example:
        val chain = create_callback_chain()
    """
    { callbacks: [], metadata: { type: "callback_chain" } }

fn add_callback(chain, callback_fn):
    """Add callback to callback chain.

    Returns new chain with callback added.

    Example:
        chain = add_callback(chain, \result: process(result))
    """
    val new_callbacks = chain["callbacks"] + [callback_fn]
    { callbacks: new_callbacks, metadata: chain["metadata"] }

fn run_callbacks(chain, initial_data):
    """Execute all callbacks in sequence with initial data.

    Example:
        val result = run_callbacks(chain, input)
    """
    var current = initial_data
    for callback in chain["callbacks"]:
        current = callback(current)
    current

# ============================================================================
# Promise Pattern (Async-like)
# ============================================================================

fn create_promise():
    """Create a promise-like object.

    Returns promise object with pending state.

    Example:
        val promise = create_promise()
    """
    {
        state: "pending",
        value: nil,
        error: nil,
        then_handlers: [],
        catch_handlers: []
    }

fn resolve_promise(promise, value):
    """Resolve promise with value.

    Returns new promise in resolved state.

    Example:
        promise = resolve_promise(promise, 42)
    """
    val new_promise = promise
    new_promise["state"] = "resolved"
    new_promise["value"] = value

    # Execute then handlers
    for handler in promise["then_handlers"]:
        handler(value)

    new_promise

fn then_promise(promise, handler_fn):
    """Add then handler to promise.

    Example:
        promise = then_promise(promise, \val: process(val))
    """
    val new_handlers = promise["then_handlers"] + [handler_fn]
    val new_promise = promise
    new_promise["then_handlers"] = new_handlers

    # If already resolved, execute immediately
    if promise["state"] == "resolved":
        handler_fn(promise["value"])

    new_promise

fn catch_promise(promise, handler_fn):
    """Add error handler to promise.

    Example:
        promise = catch_promise(promise, \err: handle_error(err))
    """
    val new_handlers = promise["catch_handlers"] + [handler_fn]
    val new_promise = promise
    new_promise["catch_handlers"] = new_handlers

    # If already rejected, execute immediately
    if promise["state"] == "rejected":
        handler_fn(promise["error"])

    new_promise
