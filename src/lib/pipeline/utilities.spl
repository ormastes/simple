# Pipeline Utility Steps and Inspection
#
# Utility steps and functions for pipeline inspection and debugging.

# ============================================================================
# Exports
# ============================================================================

export tap_step, each_step, batch_step, debatch_step
export throttle_step, debounce_step
export cache_step, memoize_step, log_step
export pipeline_length, pipeline_steps, describe_pipeline

# ============================================================================
# Utility Steps
# ============================================================================

fn tap_step(inspect_fn):
    """Create a tap step for side effects (logging, debugging).

    Executes inspect_fn but returns original data unchanged.

    Example:
        val log = tap_step(\x: print("Value: {x}"))
        p = add_step(p, log)
    """
    \data: {
        inspect_fn(data)
        data
    }

fn each_step(action_fn):
    """Execute action on each element in array (side effects).

    Returns original array unchanged.

    Example:
        val print_each = each_step(\x: print("Item: {x}"))
    """
    \data: {
        for item in data:
            action_fn(item)
        data
    }

fn batch_step(batch_size):
    """Batch array elements into chunks.

    Useful for processing large datasets in batches.

    Example:
        val batch = batch_step(10)
        p = add_step(p, batch)
    """
    \data: {
        if batch_size <= 0:
            return [data]

        var batches = []
        var current_batch = []
        var count = 0

        for item in data:
            current_batch = current_batch + [item]
            count = count + 1

            if count >= batch_size:
                batches = batches + [current_batch]
                current_batch = []
                count = 0

        # Add remaining items
        if current_batch.len() > 0:
            batches = batches + [current_batch]

        batches
    }

fn debatch_step():
    """Flatten batched data back into single array.

    Inverse of batch_step.

    Example:
        val debatch = debatch_step()
        p = add_step(p, debatch)
    """
    \data: data.flatten()

fn log_step(prefix):
    """Log data with prefix (debugging utility).

    Example:
        val log = log_step("DEBUG")
    """
    \data: {
        print("{prefix}: {data}")
        data
    }

fn cache_step(cache_dict):
    """Cache results based on cache_dict.

    Simple caching mechanism using dict lookup.

    Example:
        val cache = {}
        val cached = cache_step(cache)
    """
    \data: {
        # Simple cache lookup by key
        val key = data.to_string()
        val cached = cache_dict.get(key, nil)
        if cached != nil:
            cached
        else:
            # Would normally compute and cache, but just return data
            data
    }

fn memoize_step(step_fn, memo_dict):
    """Memoize step results to avoid recomputation.

    Example:
        val memo = {}
        val memoized = memoize_step(expensive_fn, memo)
    """
    \data: {
        val key = data.to_string()
        val cached = memo_dict.get(key, nil)
        if cached != nil:
            cached
        else:
            val result = step_fn(data)
            memo_dict[key] = result
            result
    }

fn throttle_step(min_interval):
    """Throttle step execution (conceptual - requires time tracking).

    In practice, would need timing infrastructure.

    Example:
        val throttled = throttle_step(1000)  # 1 second minimum
    """
    \data: {
        # Placeholder - would need timing state
        data
    }

fn debounce_step(delay):
    """Debounce step execution (conceptual - requires time tracking).

    In practice, would need timing infrastructure.

    Example:
        val debounced = debounce_step(500)  # 500ms delay
    """
    \data: {
        # Placeholder - would need timing state
        data
    }

# ============================================================================
# Pipeline Inspection
# ============================================================================

fn pipeline_length(pipeline):
    """Get number of steps in pipeline.

    Example:
        val len = pipeline_length(my_pipeline)
    """
    pipeline["steps"].len()

fn pipeline_steps(pipeline):
    """Get array of steps from pipeline.

    Example:
        val steps = pipeline_steps(my_pipeline)
    """
    pipeline["steps"]

fn describe_pipeline(pipeline):
    """Get description of pipeline structure.

    Returns dict with pipeline metadata.

    Example:
        val desc = describe_pipeline(my_pipeline)
        print("Steps: {desc["count"]}")
    """
    {
        step_count: pipeline["steps"].len(),
        metadata: pipeline["metadata"],
        has_steps: pipeline["steps"].len() > 0
    }
