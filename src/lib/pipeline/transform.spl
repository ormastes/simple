# Pipeline Transformation Steps
#
# Transformation steps for pipelines: map, filter, reduce, flat_map, etc.

# ============================================================================
# Exports
# ============================================================================

export map_step, filter_step, reduce_step, flat_map_step
export transform_step, validate_step, accumulate_step

# ============================================================================
# Transformation Steps
# ============================================================================

fn map_step(transform_fn):
    """Create a map transformation step for arrays.

    Applies transform_fn to each element in the input array.

    Example:
        val double = map_step(\x: x * 2)
        p = add_step(p, double)
    """
    \data: data.map(transform_fn)

fn filter_step(predicate_fn):
    """Create a filter step for arrays.

    Keeps only elements where predicate_fn returns true.

    Example:
        val evens = filter_step(\x: x % 2 == 0)
        p = add_step(p, evens)
    """
    \data: data.filter(predicate_fn)

fn reduce_step(init_value, reducer_fn):
    """Create a reduce step for arrays.

    Reduces array to single value using reducer_fn.

    Example:
        val sum = reduce_step(0, \acc, x: acc + x)
        p = add_step(p, sum)
    """
    \data: data.reduce(init_value, reducer_fn)

fn flat_map_step(transform_fn):
    """Create a flat-map step for arrays.

    Maps then flattens the result (useful for expanding elements).

    Example:
        val expand = flat_map_step(\x: [x, x * 2])
        p = add_step(p, expand)
    """
    \data: data.map(transform_fn).flatten()

fn transform_step(transform_fn):
    """Create a generic transformation step.

    Applies transform_fn directly to the data.

    Example:
        val process = transform_step(\x: { value: x, processed: true })
        p = add_step(p, process)
    """
    transform_fn

fn accumulate_step(init_value, accumulator_fn):
    """Create an accumulation step that tracks state.

    Similar to reduce but returns all intermediate values.

    Example:
        val running_sum = accumulate_step(0, \acc, x: acc + x)
    """
    \data: {
        var acc = init_value
        var results = []
        for item in data:
            acc = accumulator_fn(acc, item)
            results = results + [acc]
        results
    }

fn validate_step(validator_fn, error_msg):
    """Validate data and return error if validation fails.

    Example:
        val check_positive = validate_step(\x: x > 0, "Must be positive")
    """
    \data: {
        if validator_fn(data):
            data
        else:
            { error: error_msg, data: data }
    }
