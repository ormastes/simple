# Cryptographic Types and Basic Utilities
#
# Core utilities for cryptographic operations:
# - Bit rotation and shifting operations (32-bit and 64-bit)
# - Modular arithmetic helpers
# - Byte/hex conversion functions
# - Text/byte encoding/decoding

# =============================================================================
# Bit Operation Utilities
# =============================================================================

# Right rotate for 32-bit values
fn rotr32(x: i64, n: i64) -> i64:
    val mask = 0xFFFFFFFF
    val x_masked = x & mask
    val shifted = (x_masked >> n) | ((x_masked << (32 - n)) & mask)
    shifted & mask

# Right rotate for 64-bit values
fn rotr64(x: i64, n: i64) -> i64:
    # For 64-bit, we need to be careful with overflow
    val high = x >> n
    val low = x << (64 - n)
    high | low

# Right shift for 32-bit values
fn shr32(x: i64, n: i64) -> i64:
    val mask = 0xFFFFFFFF
    ((x & mask) >> n) & mask

# Right shift for 64-bit values
fn shr64(x: i64, n: i64) -> i64:
    x >> n

# Addition modulo 2^32
fn add_mod32(a: i64, b: i64) -> i64:
    val mask = 0xFFFFFFFF
    (a + b) & mask

# Addition modulo 2^64 (for SHA-512)
fn add_mod64(a: i64, b: i64) -> i64:
    # Simple's i64 handles this naturally
    a + b

# Left rotate for 32-bit values (used in SHA-1 and MD5)
fn rotl32(x: i64, n: i64) -> i64:
    val mask = 0xFFFFFFFF
    val x_masked = x & mask
    val shifted = ((x_masked << n) | (x_masked >> (32 - n))) & mask
    shifted

# =============================================================================
# Byte/Hex Conversion Utilities
# =============================================================================

# Convert byte list to hexadecimal string
fn bytes_to_hex(bytes: list) -> text:
    var result = ""
    var i = 0
    while i < bytes.len():
        val byte = bytes.get(i)
        val high = (byte >> 4) & 0xF
        val low = byte & 0xF

        # Convert nibbles to hex chars
        val high_char = if high < 10:
            "0123456789".get(high)
        else:
            "abcdef".get(high - 10)

        val low_char = if low < 10:
            "0123456789".get(low)
        else:
            "abcdef".get(low - 10)

        result = result + high_char + low_char
        i = i + 1

    result

# Convert hexadecimal string to byte list
fn hex_to_bytes(hex: text) -> list:
    var bytes = []
    var i = 0

    while i < hex.len():
        if i + 1 >= hex.len():
            # Odd length, pad with 0
            bytes.push(0)
            i = i + 1
        else:
            val high_char = hex.get(i)
            val low_char = hex.get(i + 1)

            # Convert hex chars to nibbles
            var high = 0
            if high_char >= "0" && high_char <= "9":
                high = "0123456789".find(high_char)
            else:
                if high_char >= "a" && high_char <= "f":
                    high = 10 + "abcdef".find(high_char)
                else:
                    if high_char >= "A" && high_char <= "F":
                        high = 10 + "ABCDEF".find(high_char)

            var low = 0
            if low_char >= "0" && low_char <= "9":
                low = "0123456789".find(low_char)
            else:
                if low_char >= "a" && low_char <= "f":
                    low = 10 + "abcdef".find(low_char)
                else:
                    if low_char >= "A" && low_char <= "F":
                        low = 10 + "ABCDEF".find(low_char)

            bytes.push((high << 4) | low)
            i = i + 2

    bytes

# Convert text to byte list (UTF-8 encoding)
fn text_to_bytes(text: text) -> list:
    var bytes = []
    var i = 0

    while i < text.len():
        val char = text.get(i)
        val code = char.ord()

        # Simple UTF-8 encoding (ASCII range for now)
        if code < 128:
            bytes.push(code)
        else:
            # For non-ASCII, we'll use a simple encoding
            # In production, full UTF-8 encoding would be needed
            bytes.push(code & 0xFF)

        i = i + 1

    bytes

# Convert byte list to text (UTF-8 decoding)
fn bytes_to_text(bytes: list) -> text:
    var result = ""
    var i = 0

    while i < bytes.len():
        val byte = bytes.get(i)
        result = result + byte.chr()
        i = i + 1

    result

# Convert hash to uppercase hex
fn hash_to_upper_hex(hash: list) -> text:
    val hex = bytes_to_hex(hash)
    var result = ""
    var i = 0

    while i < hex.len():
        val char = hex.get(i)
        val upper_char = if char >= "a" && char <= "f":
            char.upper()
        else:
            char

        result = result + upper_char
        i = i + 1

    result

# XOR two byte lists
fn xor_bytes(a: list, b: list) -> list:
    var result = []
    var i = 0

    val min_len = if a.len() < b.len():
        a.len()
    else:
        b.len()

    while i < min_len:
        result.push(a.get(i) ^ b.get(i))
        i = i + 1

    result

# Truncate hash to specified byte length
fn truncate_hash(hash: list, length: i64) -> list:
    var result = []
    var i = 0

    while i < length && i < hash.len():
        result.push(hash.get(i))
        i = i + 1

    result
