# HMAC (Hash-based Message Authentication Code)
#
# Provides HMAC implementation for SHA-256, SHA-512, and SHA-1
# HMAC is used for message authentication and integrity verification
#
# Recommended: Use HMAC-SHA256 or HMAC-SHA512

mod crypto.types
mod crypto.sha256
mod crypto.sha512
mod crypto.legacy_hash

# =============================================================================
# HMAC-SHA256
# =============================================================================

# HMAC-SHA256
fn hmac_sha256(key: text, message: text) -> list:
    val key_bytes = text_to_bytes(key)
    val message_bytes = text_to_bytes(message)
    hmac_sha256_bytes(key_bytes, message_bytes)

# HMAC-SHA256 with byte inputs
fn hmac_sha256_bytes(key_bytes: list, message_bytes: list) -> list:
    val block_size = 64  # SHA-256 block size

    # Prepare key
    var k = []
    if key_bytes.len() > block_size:
        # Hash the key if too long
        k = sha256_bytes(key_bytes)
    else:
        var i = 0
        while i < key_bytes.len():
            k.push(key_bytes.get(i))
            i = i + 1

    # Pad key to block size
    while k.len() < block_size:
        k.push(0)

    # Create inner and outer padded keys
    var i_key_pad = []
    var o_key_pad = []
    var i = 0
    while i < block_size:
        val k_byte = k.get(i)
        i_key_pad.push(k_byte ^ 0x36)
        o_key_pad.push(k_byte ^ 0x5c)
        i = i + 1

    # Inner hash: H((K ⊕ ipad) || message)
    var inner_input = []
    i = 0
    while i < i_key_pad.len():
        inner_input.push(i_key_pad.get(i))
        i = i + 1
    i = 0
    while i < message_bytes.len():
        inner_input.push(message_bytes.get(i))
        i = i + 1

    val inner_hash = sha256_bytes(inner_input)

    # Outer hash: H((K ⊕ opad) || inner_hash)
    var outer_input = []
    i = 0
    while i < o_key_pad.len():
        outer_input.push(o_key_pad.get(i))
        i = i + 1
    i = 0
    while i < inner_hash.len():
        outer_input.push(inner_hash.get(i))
        i = i + 1

    sha256_bytes(outer_input)

# =============================================================================
# HMAC-SHA512
# =============================================================================

# HMAC-SHA512
fn hmac_sha512(key: text, message: text) -> list:
    val key_bytes = text_to_bytes(key)
    val message_bytes = text_to_bytes(message)
    hmac_sha512_bytes(key_bytes, message_bytes)

# HMAC-SHA512 with byte inputs
fn hmac_sha512_bytes(key_bytes: list, message_bytes: list) -> list:
    val block_size = 128  # SHA-512 block size

    # Prepare key
    var k = []
    if key_bytes.len() > block_size:
        k = sha512_bytes(key_bytes)
    else:
        var i = 0
        while i < key_bytes.len():
            k.push(key_bytes.get(i))
            i = i + 1

    # Pad key to block size
    while k.len() < block_size:
        k.push(0)

    # Create inner and outer padded keys
    var i_key_pad = []
    var o_key_pad = []
    var i = 0
    while i < block_size:
        val k_byte = k.get(i)
        i_key_pad.push(k_byte ^ 0x36)
        o_key_pad.push(k_byte ^ 0x5c)
        i = i + 1

    # Inner hash
    var inner_input = []
    i = 0
    while i < i_key_pad.len():
        inner_input.push(i_key_pad.get(i))
        i = i + 1
    i = 0
    while i < message_bytes.len():
        inner_input.push(message_bytes.get(i))
        i = i + 1

    val inner_hash = sha512_bytes(inner_input)

    # Outer hash
    var outer_input = []
    i = 0
    while i < o_key_pad.len():
        outer_input.push(o_key_pad.get(i))
        i = i + 1
    i = 0
    while i < inner_hash.len():
        outer_input.push(inner_hash.get(i))
        i = i + 1

    sha512_bytes(outer_input)

# =============================================================================
# HMAC-SHA1 (DEPRECATED)
# =============================================================================

# HMAC-SHA1 (DEPRECATED)
fn hmac_sha1(key: text, message: text) -> list:
    val key_bytes = text_to_bytes(key)
    val message_bytes = text_to_bytes(message)
    hmac_sha1_bytes(key_bytes, message_bytes)

# HMAC-SHA1 with byte inputs (DEPRECATED)
fn hmac_sha1_bytes(key_bytes: list, message_bytes: list) -> list:
    val block_size = 64  # SHA-1 block size

    # Prepare key
    var k = []
    if key_bytes.len() > block_size:
        k = sha1_bytes(key_bytes)
    else:
        var i = 0
        while i < key_bytes.len():
            k.push(key_bytes.get(i))
            i = i + 1

    # Pad key
    while k.len() < block_size:
        k.push(0)

    # Create padded keys
    var i_key_pad = []
    var o_key_pad = []
    var i = 0
    while i < block_size:
        val k_byte = k.get(i)
        i_key_pad.push(k_byte ^ 0x36)
        o_key_pad.push(k_byte ^ 0x5c)
        i = i + 1

    # Inner hash
    var inner_input = []
    i = 0
    while i < i_key_pad.len():
        inner_input.push(i_key_pad.get(i))
        i = i + 1
    i = 0
    while i < message_bytes.len():
        inner_input.push(message_bytes.get(i))
        i = i + 1

    val inner_hash = sha1_bytes(inner_input)

    # Outer hash
    var outer_input = []
    i = 0
    while i < o_key_pad.len():
        outer_input.push(o_key_pad.get(i))
        i = i + 1
    i = 0
    while i < inner_hash.len():
        outer_input.push(inner_hash.get(i))
        i = i + 1

    sha1_bytes(outer_input)

# =============================================================================
# Generic HMAC with algorithm selection
# =============================================================================

# HMAC with algorithm selection
fn hmac_with_algorithm(key: text, message: text, algorithm: text) -> list:
    if algorithm == "sha256":
        hmac_sha256(key, message)
    else:
        if algorithm == "sha512":
            hmac_sha512(key, message)
        else:
            if algorithm == "sha1":
                hmac_sha1(key, message)
            else:
                # Default to SHA-256
                hmac_sha256(key, message)
