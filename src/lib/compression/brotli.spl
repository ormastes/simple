# compression/brotli.spl - Huffman coding implementation
#
# Huffman Coding - variable-length prefix coding
# Uses frequency analysis to assign shorter codes to more common characters

# Count character frequencies in text
fn count_frequencies(text):
    if text == nil:
        return nil

    var freqs = []  # List of (char, count) tuples
    var i = 0
    val len = text.length()

    loop:
        if i >= len:
            break

        val ch = text[i]
        var found = false
        var j = 0
        var new_freqs = []

        # Update existing or add new
        loop:
            if j >= freqs.length():
                break

            val entry = freqs[j]
            val freq_ch = entry[0]
            val freq_count = entry[1]

            if freq_ch == ch:
                new_freqs = new_freqs + [[ch, freq_count + 1]]
                found = true
            else:
                new_freqs = new_freqs + [[freq_ch, freq_count]]

            j = j + 1

        if found:
            freqs = new_freqs
        else:
            freqs = freqs + [[ch, 1]]

        i = i + 1

    return freqs

# Sort frequencies by count (descending)
fn sort_frequencies(freqs):
    if freqs == nil:
        return nil

    val len = freqs.length()
    if len <= 1:
        return freqs

    # Simple bubble sort
    var sorted = freqs
    var i = 0

    loop:
        if i >= len:
            break

        var j = 0
        loop:
            if j >= len - i - 1:
                break

            val curr = sorted[j]
            val next = sorted[j + 1]

            if curr[1] < next[1]:
                # Swap
                var new_sorted = []
                var k = 0
                loop:
                    if k >= sorted.length():
                        break

                    if k == j:
                        new_sorted = new_sorted + [next]
                    else:
                        if k == j + 1:
                            new_sorted = new_sorted + [curr]
                        else:
                            new_sorted = new_sorted + [sorted[k]]

                    k = k + 1

                sorted = new_sorted

            j = j + 1

        i = i + 1

    return sorted

# Calculate Shannon entropy of data
fn calculate_entropy(text):
    if text == nil:
        return 0.0

    val len = text.length()
    if len == 0:
        return 0.0

    val freqs = count_frequencies(text)
    if freqs == nil:
        return 0.0

    var entropy = 0.0
    var i = 0

    loop:
        if i >= freqs.length():
            break

        val entry = freqs[i]
        val count = entry[1]
        val prob = count.to_float() / len.to_float()

        # entropy -= prob * log2(prob)
        if prob > 0.0:
            val log_prob = log2(prob)
            entropy = entropy - (prob * log_prob)

        i = i + 1

    return entropy

# Estimate theoretical best compression ratio
fn estimate_compressibility(text):
    if text == nil:
        return 1.0

    val len = text.length()
    if len == 0:
        return 1.0

    val entropy = calculate_entropy(text)

    # Theoretical best: entropy bits per symbol vs 8 bits per char
    val ratio = entropy / 8.0
    return ratio

# Encode text using Huffman coding
fn huffman_encode(text):
    if text == nil:
        return nil

    val len = text.length()
    if len == 0:
        return ["", [], 0]

    # Build frequency table
    val freqs = count_frequencies(text)

    # Build Huffman tree
    val tree = build_huffman_tree(freqs)

    # Generate codes
    val codes = generate_huffman_codes(tree)

    # Encode text
    var encoded = ""
    var i = 0

    loop:
        if i >= len:
            break

        val ch = text[i]
        val code = huffman_lookup_code(codes, ch)

        if code != nil:
            encoded = encoded + code

        i = i + 1

    # Return: (encoded_bits, codes_table, original_length)
    return [encoded, codes, len]

# Decode Huffman-encoded data
fn huffman_decode(encoded_data):
    if encoded_data == nil:
        return nil

    val bits = encoded_data[0]
    val codes = encoded_data[1]
    val orig_len = encoded_data[2]

    if bits == nil:
        return ""

    # Build reverse lookup: code -> char
    var reverse = []
    var i = 0

    loop:
        if i >= codes.length():
            break

        val entry = codes[i]
        val ch = entry[0]
        val code = entry[1]
        reverse = reverse + [[code, ch]]

        i = i + 1

    # Decode bits
    var result = ""
    var current = ""
    var j = 0

    loop:
        if j >= bits.length():
            break

        current = current + bits[j]

        # Check if current matches any code
        var k = 0
        var found = false

        loop:
            if k >= reverse.length():
                break

            val entry = reverse[k]
            val code = entry[0]
            val ch = entry[1]

            if code == current:
                result = result + ch
                current = ""
                found = true
                break

            k = k + 1

        j = j + 1

    return result

# Calculate base-2 logarithm
fn log2(x):
    if x <= 0.0:
        return 0.0

    # Simple approximation using natural log
    # log2(x) = ln(x) / ln(2)
    val ln_x = ln(x)
    val ln_2 = 0.693147180559945309417

    return ln_x / ln_2

# Calculate natural logarithm (approximation)
fn ln(x):
    if x <= 0.0:
        return 0.0

    # Taylor series approximation for ln(1 + x)
    # Works best when x is close to 1
    var y = x - 1.0
    var result = 0.0
    var term = y
    var i = 1

    loop:
        if i > 100:  # Limit iterations
            break

        if term.abs() < 0.0000001:  # Convergence
            break

        if i % 2 == 1:
            result = result + term / i.to_float()
        else:
            result = result - term / i.to_float()

        term = term * y
        i = i + 1

    return result

# Import Huffman tree operations from types module
fn build_huffman_tree(freqs):
    # This is a placeholder - will be imported from types.spl
    return nil

fn generate_huffman_codes(root):
    # This is a placeholder - will be imported from types.spl
    return []

fn huffman_lookup_code(codes, char):
    # This is a placeholder - will be imported from types.spl
    return nil
