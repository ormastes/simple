# Regular Expression Utilities Module

from .types import RegexPattern, MatchResult

# ============================================================================
# GROUP FUNCTIONS
# ============================================================================

fn capture_groups(regex: RegexPattern, text_str: text) -> [text]:
    """Extract capture groups from first match."""
    from .replace import find_first

    val result = find_first(regex, text_str)
    if result.matched:
        result.groups
    else:
        []

fn group_count(regex: RegexPattern) -> i64:
    """Get number of capture groups in pattern."""
    regex.group_count

fn get_group(result: MatchResult, index: i64) -> text:
    """Get capture group at index from match result."""
    if index < 0 or index >= result.groups.len():
        return ""
    result.groups[index]

fn has_groups(regex: RegexPattern) -> bool:
    """Check if pattern has capture groups."""
    regex.group_count > 0

# ============================================================================
# ANCHOR FUNCTIONS
# ============================================================================

fn starts_with_pattern(regex: RegexPattern, text_str: text) -> bool:
    """Check if text starts with pattern match."""
    from .match import match_at

    if regex.start_state == -1:
        return false

    val result = match_at(regex, text_str, 0)
    result.matched and result.start_pos == 0

fn ends_with_pattern(regex: RegexPattern, text_str: text) -> bool:
    """Check if text ends with pattern match."""
    from .match import match_at

    if regex.start_state == -1:
        return false

    # Try matching from end backwards
    var i = text_str.len() - 1
    while i >= 0:
        val result = match_at(regex, text_str, i)
        if result.matched and result.end_pos == text_str.len():
            return true
        i = i - 1
    false

# ============================================================================
# QUANTIFIER HELPERS
# ============================================================================

fn pattern_zero_or_more(base: text) -> text:
    """Create pattern for zero or more matches of base."""
    base + "*"

fn pattern_one_or_more(base: text) -> text:
    """Create pattern for one or more matches of base."""
    base + "+"

fn pattern_optional(base: text) -> text:
    """Create pattern for optional base."""
    base + "?"

fn pattern_exactly(base: text, n: i64) -> text:
    """Create pattern for exactly n matches of base."""
    base + "{" + "{n}" + "}"

fn pattern_between(base: text, min_val: i64, max_val: i64) -> text:
    """Create pattern for between min and max matches of base."""
    base + "{" + "{min_val}" + "," + "{max_val}" + "}"

fn pattern_at_least(base: text, min_val: i64) -> text:
    """Create pattern for at least min matches of base."""
    base + "{" + "{min_val}" + ",}"

# ============================================================================
# CHARACTER CLASS PATTERNS
# ============================================================================

fn pattern_digit() -> text:
    """Pattern matching any digit."""
    "\\d"

fn pattern_word() -> text:
    """Pattern matching word character."""
    "\\w"

fn pattern_whitespace() -> text:
    """Pattern matching whitespace."""
    "\\s"

fn pattern_not_digit() -> text:
    """Pattern matching non-digit."""
    "\\D"

fn pattern_not_word() -> text:
    """Pattern matching non-word character."""
    "\\W"

fn pattern_not_whitespace() -> text:
    """Pattern matching non-whitespace."""
    "\\S"

fn pattern_any_char() -> text:
    """Pattern matching any character."""
    "."

fn pattern_char_class(chars: text) -> text:
    """Create character class pattern [chars]."""
    "[" + chars + "]"

fn pattern_negated_class(chars: text) -> text:
    """Create negated character class pattern [^chars]."""
    "[^" + chars + "]"

fn pattern_range(start: text, end_val: text) -> text:
    """Create range pattern [start-end]."""
    "[" + start + "-" + end_val + "]"

# ============================================================================
# ANCHOR PATTERNS
# ============================================================================

fn pattern_start() -> text:
    """Pattern matching start of text."""
    "^"

fn pattern_end() -> text:
    """Pattern matching end of text."""
    "$"

fn pattern_word_boundary() -> text:
    """Pattern matching word boundary (not implemented yet)."""
    "\\b"

fn pattern_anchored(base: text, start: bool, end_val: bool) -> text:
    """Create anchored pattern."""
    var result = base
    if start:
        result = "^" + result
    if end_val:
        result = result + "$"
    result

# ============================================================================
# ALTERNATION PATTERNS
# ============================================================================

fn pattern_alternation(patterns: [text]) -> text:
    """Create alternation pattern (a|b|c)."""
    if patterns.len() == 0:
        return ""
    if patterns.len() == 1:
        return patterns[0]

    var result = patterns[0]
    for i in 1..patterns.len():
        result = result + "|" + patterns[i]
    result

fn pattern_group(base: text) -> text:
    """Create capturing group pattern."""
    "(" + base + ")"

fn pattern_non_capturing_group(base: text) -> text:
    """Create non-capturing group pattern."""
    "(?:" + base + ")"

# ============================================================================
# COMMON PATTERNS
# ============================================================================

fn pattern_email() -> text:
    """Common email pattern (simplified)."""
    "[a-zA-Z0-9]+@[a-zA-Z0-9]+\\.[a-z]+"

fn pattern_url() -> text:
    """Common URL pattern (simplified)."""
    "https?://[a-zA-Z0-9.-]+(/[a-zA-Z0-9.-]*)?"

fn pattern_phone_us() -> text:
    """US phone number pattern."""
    "\\d{3}-\\d{3}-\\d{4}"

fn pattern_phone_us_flexible() -> text:
    """Flexible US phone pattern."""
    "\\(?\\d{3}\\)?[- ]?\\d{3}[- ]?\\d{4}"

fn pattern_zip_us() -> text:
    """US ZIP code pattern."""
    "\\d{5}(-\\d{4})?"

fn pattern_ipv4() -> text:
    """IPv4 address pattern (simplified)."""
    "\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}"

fn pattern_hex_color() -> text:
    """Hex color pattern (#RGB or #RRGGBB)."""
    "#[0-9a-fA-F]{3}([0-9a-fA-F]{3})?"

fn pattern_identifier() -> text:
    """Programming identifier pattern."""
    "[a-zA-Z_][a-zA-Z0-9_]*"

fn pattern_integer() -> text:
    """Integer pattern (with optional sign)."""
    "-?\\d+"

fn pattern_decimal() -> text:
    """Decimal number pattern."""
    "-?\\d+\\.\\d+"

fn pattern_number() -> text:
    """General number pattern (int or decimal)."""
    "-?\\d+(\\.\\d+)?"

# ============================================================================
# QUICK UTILITY FUNCTIONS
# ============================================================================

fn test_pattern(pattern: text, text_str: text) -> bool:
    """Quick test: compile and match in one call."""
    from .match import compile_pattern, matches

    val regex = compile_pattern(pattern)
    matches(regex, text_str)

fn quick_match(pattern: text, text_str: text) -> bool:
    """Alias for test_pattern."""
    test_pattern(pattern, text_str)

fn find_pattern(pattern: text, text_str: text) -> text:
    """Find first match and return matched text."""
    from .match import compile_pattern
    from .replace import find_first

    val regex = compile_pattern(pattern)
    val result = find_first(regex, text_str)
    if result.matched and result.groups.len() > 0:
        result.groups[0]
    else:
        ""

fn extract_pattern(pattern: text, text_str: text) -> [text]:
    """Extract all matches from text."""
    from .match import compile_pattern
    from .replace import extract_all

    val regex = compile_pattern(pattern)
    extract_all(regex, text_str)

fn replace_pattern(pattern: text, text_str: text, replacement: text) -> text:
    """Quick replace: compile and replace all in one call."""
    from .match import compile_pattern
    from .replace import replace_all

    val regex = compile_pattern(pattern)
    replace_all(regex, text_str, replacement)

fn split_pattern(pattern: text, text_str: text) -> [text]:
    """Quick split: compile and split in one call."""
    from .match import compile_pattern
    from .replace import split

    val regex = compile_pattern(pattern)
    split(regex, text_str)

# ============================================================================
# STRING ANALYSIS
# ============================================================================

fn is_email(text_str: text) -> bool:
    """Check if text is a valid email address."""
    from .match import compile_pattern, match_full

    val regex = compile_pattern(pattern_email())
    match_full(regex, text_str)

fn is_url(text_str: text) -> bool:
    """Check if text is a valid URL."""
    from .match import compile_pattern, match_full

    val regex = compile_pattern(pattern_url())
    match_full(regex, text_str)

fn is_phone_us(text_str: text) -> bool:
    """Check if text is a valid US phone number."""
    from .match import compile_pattern, match_full

    val regex = compile_pattern(pattern_phone_us())
    match_full(regex, text_str)

fn is_integer(text_str: text) -> bool:
    """Check if text is an integer."""
    from .match import compile_pattern, match_full

    val regex = compile_pattern(pattern_integer())
    match_full(regex, text_str)

fn is_number(text_str: text) -> bool:
    """Check if text is a number."""
    from .match import compile_pattern, match_full

    val regex = compile_pattern(pattern_number())
    match_full(regex, text_str)

fn is_hex_color(text_str: text) -> bool:
    """Check if text is a hex color code."""
    from .match import compile_pattern, match_full

    val regex = compile_pattern(pattern_hex_color())
    match_full(regex, text_str)

fn is_identifier(text_str: text) -> bool:
    """Check if text is a valid programming identifier."""
    from .match import compile_pattern, match_full

    val regex = compile_pattern(pattern_identifier())
    match_full(regex, text_str)

export capture_groups, group_count, get_group, has_groups
export starts_with_pattern, ends_with_pattern
export pattern_zero_or_more, pattern_one_or_more, pattern_optional
export pattern_exactly, pattern_between, pattern_at_least
export pattern_digit, pattern_word, pattern_whitespace
export pattern_not_digit, pattern_not_word, pattern_not_whitespace
export pattern_any_char, pattern_char_class, pattern_negated_class, pattern_range
export pattern_start, pattern_end, pattern_word_boundary, pattern_anchored
export pattern_alternation, pattern_group, pattern_non_capturing_group
export pattern_email, pattern_url, pattern_phone_us, pattern_phone_us_flexible
export pattern_zip_us, pattern_ipv4, pattern_hex_color, pattern_identifier
export pattern_integer, pattern_decimal, pattern_number
export test_pattern, quick_match, find_pattern, extract_pattern
export replace_pattern, split_pattern
export is_email, is_url, is_phone_us, is_integer, is_number
export is_hex_color, is_identifier
