# Regular Expression Replacement Module

from .types import RegexPattern, MatchResult

# ============================================================================
# FINDING FUNCTIONS
# ============================================================================

fn find_first(regex: RegexPattern, text_str: text) -> MatchResult:
    """Find first match in text."""
    from .match import match_at

    if regex.start_state == -1:
        return MatchResult(matched: false, start_pos: 0, end_pos: 0, groups: [])

    # Try matching at each position
    var i = 0
    while i < text_str.len():
        val result = match_at(regex, text_str, i)
        if result.matched:
            return result
        i = i + 1

    MatchResult(matched: false, start_pos: 0, end_pos: 0, groups: [])

fn find_all(regex: RegexPattern, text_str: text) -> [MatchResult]:
    """Find all non-overlapping matches in text."""
    from .match import match_at

    var results: [MatchResult] = []
    var pos = 0

    while pos < text_str.len():
        val result = match_at(regex, text_str, pos)
        if result.matched:
            results = results.push(result)
            # Move past this match
            val new_pos = result.end_pos
            if new_pos > pos:
                pos = new_pos
            else:
                pos = pos + 1
        else:
            pos = pos + 1

    results

fn find_at(regex: RegexPattern, text_str: text, pos: i64) -> MatchResult:
    """Find match starting at or after position pos."""
    from .match import match_at

    if pos < 0 or pos >= text_str.len():
        return MatchResult(matched: false, start_pos: 0, end_pos: 0, groups: [])

    var i = pos
    while i < text_str.len():
        val result = match_at(regex, text_str, i)
        if result.matched:
            return result
        i = i + 1

    MatchResult(matched: false, start_pos: 0, end_pos: 0, groups: [])

fn count_matches(regex: RegexPattern, text_str: text) -> i64:
    """Count number of matches in text."""
    val matches_list = find_all(regex, text_str)
    matches_list.len()

fn extract_all(regex: RegexPattern, text_str: text) -> [text]:
    """Extract all matched substrings."""
    val matches_list = find_all(regex, text_str)
    var results: [text] = []
    for m in matches_list:
        if m.groups.len() > 0:
            results = results.push(m.groups[0])
    results

fn match_length(result: MatchResult) -> i64:
    """Get length of match."""
    if result.matched:
        result.end_pos - result.start_pos
    else:
        0

# ============================================================================
# REPLACEMENT FUNCTIONS
# ============================================================================

fn replace(regex: RegexPattern, text_str: text, replacement: text) -> text:
    """Replace first match with replacement string."""
    replace_first(regex, text_str, replacement)

fn replace_first(regex: RegexPattern, text_str: text, replacement: text) -> text:
    """Replace first match with replacement string."""
    val result = find_first(regex, text_str)
    if not result.matched:
        return text_str

    val before = text_str[0:result.start_pos]
    val after = text_str[result.end_pos:]
    before + replacement + after

fn replace_all(regex: RegexPattern, text_str: text, replacement: text) -> text:
    """Replace all matches with replacement string."""
    val matches_list = find_all(regex, text_str)
    if matches_list.len() == 0:
        return text_str

    var result = ""
    var last_pos = 0

    for m in matches_list:
        # Add text before match
        result = result + text_str[last_pos:m.start_pos]
        # Add replacement
        result = result + replacement
        last_pos = m.end_pos

    # Add remaining text
    result = result + text_str[last_pos:]
    result

fn replace_n(regex: RegexPattern, text_str: text, replacement: text, n: i64) -> text:
    """Replace first n matches with replacement string."""
    if n <= 0:
        return text_str

    val matches_list = find_all(regex, text_str)
    if matches_list.len() == 0:
        return text_str

    var result = ""
    var last_pos = 0
    var count = 0

    for m in matches_list:
        if count >= n:
            break

        # Add text before match
        result = result + text_str[last_pos:m.start_pos]
        # Add replacement
        result = result + replacement
        last_pos = m.end_pos
        count = count + 1

    # Add remaining text
    result = result + text_str[last_pos:]
    result

# ============================================================================
# SPLITTING FUNCTIONS
# ============================================================================

fn split(regex: RegexPattern, text_str: text) -> [text]:
    """Split text on pattern matches."""
    val matches_list = find_all(regex, text_str)
    if matches_list.len() == 0:
        return [text_str]

    var parts: [text] = []
    var last_pos = 0

    for m in matches_list:
        # Add text before match
        val part = text_str[last_pos:m.start_pos]
        parts = parts.push(part)
        last_pos = m.end_pos

    # Add remaining text
    val final_part = text_str[last_pos:]
    parts = parts.push(final_part)
    parts

fn split_n(regex: RegexPattern, text_str: text, n: i64) -> [text]:
    """Split text on pattern matches, up to n splits."""
    if n <= 0:
        return [text_str]

    val matches_list = find_all(regex, text_str)
    if matches_list.len() == 0:
        return [text_str]

    var parts: [text] = []
    var last_pos = 0
    var count = 0

    for m in matches_list:
        if count >= n:
            break

        # Add text before match
        val part = text_str[last_pos:m.start_pos]
        parts = parts.push(part)
        last_pos = m.end_pos
        count = count + 1

    # Add remaining text
    val final_part = text_str[last_pos:]
    parts = parts.push(final_part)
    parts

fn split_max(regex: RegexPattern, text_str: text, max_parts: i64) -> [text]:
    """Split text, returning at most max_parts parts."""
    if max_parts <= 1:
        return [text_str]

    split_n(regex, text_str, max_parts - 1)

export find_first, find_all, find_at, count_matches, extract_all, match_length
export replace, replace_first, replace_all, replace_n
export split, split_n, split_max
