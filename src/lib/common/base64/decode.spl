# Base64 Decode Module
#
# Decoding functions for Base64, Base32, hex, and binary formats

use base64::types::{BASE64_ALPHABET, BASE64_URL_ALPHABET, BASE32_ALPHABET, BASE32_HEX_ALPHABET, PADDING_CHAR}
use base64::utilities::{strip_whitespace, add_padding, text_char_at, text_length, text_substring, char_to_base64_index, list_append, bytes_to_text, find_char_in_alphabet, list_get, bits_to_byte, text_to_int}

# ============================================================================
# STANDARD BASE64 DECODING
# ============================================================================

# Decode standard Base64 encoded data
fn decode_base64(encoded: text) -> text:
    decode_base64_with_alphabet(encoded, BASE64_ALPHABET)

# Decode URL-safe Base64 encoded data
fn decode_base64_url(encoded: text) -> text:
    decode_base64_with_alphabet(encoded, BASE64_URL_ALPHABET)

# Decode Base64 using custom alphabet
fn decode_base64_with_alphabet(encoded: text, alphabet: text) -> text:
    var clean = strip_whitespace(encoded)
    var with_padding = add_padding(clean)
    var result_bytes = []
    var i = 0
    var len = text_length(with_padding)

    # Process 4 characters at a time
    while i < len:
        var c1 = text_char_at(with_padding, i)
        var c2 = text_char_at(with_padding, i + 1)
        var c3 = text_char_at(with_padding, i + 2)
        var c4 = text_char_at(with_padding, i + 3)

        if c1 == PADDING_CHAR:
            i = 999999  # Break loop
        else:
            var idx1 = char_to_base64_index(c1, alphabet)
            var idx2 = char_to_base64_index(c2, alphabet)

            # First byte: 6 bits from idx1 + top 2 bits from idx2
            var b1 = (idx1 * 4) + (idx2 / 16)
            result_bytes = list_append(result_bytes, b1)

            if c3 != PADDING_CHAR:
                var idx3 = char_to_base64_index(c3, alphabet)
                # Second byte: bottom 4 bits from idx2 + top 4 bits from idx3
                var b2 = ((idx2 % 16) * 16) + (idx3 / 4)
                result_bytes = list_append(result_bytes, b2)

                if c4 != PADDING_CHAR:
                    var idx4 = char_to_base64_index(c4, alphabet)
                    # Third byte: bottom 2 bits from idx3 + 6 bits from idx4
                    var b3 = ((idx3 % 4) * 64) + idx4
                    result_bytes = list_append(result_bytes, b3)

        i = i + 4

    bytes_to_text(result_bytes)

# ============================================================================
# BASE32 DECODING
# ============================================================================

# Decode standard Base32 encoded data
fn decode_base32(encoded: text) -> text:
    decode_base32_with_alphabet(encoded, BASE32_ALPHABET)

# Decode Base32 hex encoded data
fn decode_base32_hex(encoded: text) -> text:
    decode_base32_with_alphabet(encoded, BASE32_HEX_ALPHABET)

# Decode Base32 using custom alphabet
fn decode_base32_with_alphabet(encoded: text, alphabet: text) -> text:
    var clean = strip_whitespace(encoded)
    var result_bytes = []
    var i = 0
    var len = text_length(clean)

    # Process 8 characters at a time
    while i < len:
        var chars = []
        var j = 0
        while j < 8:
            if i + j < len:
                var c = text_char_at(clean, i + j)
                if c != PADDING_CHAR:
                    var idx = find_char_in_alphabet(c, alphabet)
                    chars = list_append(chars, idx)
                else:
                    chars = list_append(chars, -1)
            else:
                chars = list_append(chars, -1)
            j = j + 1

        # Convert 8 Base32 characters back to 5 bytes
        var idx1 = list_get(chars, 0)
        var idx2 = list_get(chars, 1)
        if idx1 >= 0:
            if idx2 >= 0:
                var b1 = (idx1 * 8) + (idx2 / 4)
                result_bytes = list_append(result_bytes, b1)

        var idx3 = list_get(chars, 2)
        var idx4 = list_get(chars, 3)
        if idx2 >= 0:
            if idx3 >= 0:
                if idx4 >= 0:
                    var b2 = ((idx2 % 4) * 64) + (idx3 * 2) + (idx4 / 16)
                    result_bytes = list_append(result_bytes, b2)

        var idx5 = list_get(chars, 4)
        if idx4 >= 0:
            if idx5 >= 0:
                var b3 = ((idx4 % 16) * 16) + (idx5 / 2)
                result_bytes = list_append(result_bytes, b3)

        var idx6 = list_get(chars, 5)
        var idx7 = list_get(chars, 6)
        if idx5 >= 0:
            if idx6 >= 0:
                if idx7 >= 0:
                    var b4 = ((idx5 % 2) * 128) + (idx6 * 4) + (idx7 / 8)
                    result_bytes = list_append(result_bytes, b4)

        var idx8 = list_get(chars, 7)
        if idx7 >= 0:
            if idx8 >= 0:
                var b5 = ((idx7 % 8) * 32) + idx8
                result_bytes = list_append(result_bytes, b5)

        i = i + 8

    bytes_to_text(result_bytes)

# ============================================================================
# HEXADECIMAL DECODING
# ============================================================================

# Decode hexadecimal encoded data (case-insensitive)
fn decode_hex(encoded: text) -> text:
    var clean = strip_whitespace(encoded)
    var result_bytes = []
    var i = 0
    var len = text_length(clean)

    while i < len:
        var high_char = text_char_at(clean, i)
        var low_char = text_char_at(clean, i + 1)

        var high_val = hex_char_to_value(high_char)
        var low_val = hex_char_to_value(low_char)

        var byte_val = (high_val * 16) + low_val
        result_bytes = list_append(result_bytes, byte_val)

        i = i + 2

    bytes_to_text(result_bytes)

# Convert hex character to value (0-15)
fn hex_char_to_value(c: text) -> i64:
    if c == "0": return 0
    if c == "1": return 1
    if c == "2": return 2
    if c == "3": return 3
    if c == "4": return 4
    if c == "5": return 5
    if c == "6": return 6
    if c == "7": return 7
    if c == "8": return 8
    if c == "9": return 9
    if c == "a": return 10
    if c == "b": return 11
    if c == "c": return 12
    if c == "d": return 13
    if c == "e": return 14
    if c == "f": return 15
    if c == "A": return 10
    if c == "B": return 11
    if c == "C": return 12
    if c == "D": return 13
    if c == "E": return 14
    if c == "F": return 15
    0

# ============================================================================
# BINARY DECODING
# ============================================================================

# Decode binary string to bytes
fn decode_binary(encoded: text) -> list:
    var clean = strip_whitespace(encoded)
    var result = []
    var i = 0
    var len = text_length(clean)

    while i < len:
        var bits = text_substring(clean, i, i + 8)
        var byte_val = bits_to_byte(bits)
        result = list_append(result, byte_val)
        i = i + 8

    result

# ============================================================================
# INTEGER DECODING
# ============================================================================

# Decode Base64 to integer
fn decode_to_int(encoded: text) -> i64:
    var decoded = decode_base64(encoded)
    text_to_int(decoded)

# ============================================================================
# CHUNKED DECODING
# ============================================================================

# Decode chunked encoded data
fn decode_chunked(encoded: text) -> text:
    var clean = strip_whitespace(encoded)
    decode_base64(clean)

# ============================================================================
# STREAMING DECODING
# ============================================================================

# Decode streaming chunks
fn decode_stream(encoded_chunks: list, chunk_size: i64) -> text:
    var result = ""
    var i = 0
    var text_util = use base64::utilities::{list_length, text_concat}
    var len = text_util.list_length(encoded_chunks)

    while i < len:
        var chunk = list_get(encoded_chunks, i)
        # Note: In real implementation, chunk would be text
        # Here we're treating it as encoded already
        var decoded = ""  # Would decode chunk
        result = text_util.text_concat(result, decoded)
        i = i + 1

    result
