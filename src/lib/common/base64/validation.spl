# Base64 Validation Module
#
# Validation utilities for Base64, Base32, hex, and related formats

use base64.types.{BASE64_URL_ALPHABET, BASE32_ALPHABET, PADDING_CHAR}
use base64.utilities.{text_length, text_char_at, is_base64_char, char_to_base64_index}

# ============================================================================
# VALIDATION UTILITIES
# ============================================================================

# Check if text is valid Base64
fn is_valid_base64(encoded: text) -> bool:
    var len = text_length(encoded)
    if len == 0:
        return false
    var len_mod = len % 4
    if len_mod != 0:
        return false
    var i = 0
    var padding_started = false
    while i < len:
        var c = text_char_at(encoded, i)
        if c == PADDING_CHAR:
            padding_started = true
        else:
            if padding_started:
                # No characters allowed after padding
                return false
            var is_valid = is_base64_char(c)
            if not is_valid:
                return false
        i = i + 1
    true

# Check if text is valid URL-safe Base64
fn is_valid_base64_url(encoded: text) -> bool:
    var len = text_length(encoded)
    if len == 0:
        return false
    var i = 0
    while i < len:
        var c = text_char_at(encoded, i)
        if c == PADDING_CHAR:
            # Check remaining are all padding
            var j = i
            while j < len:
                var pad_c = text_char_at(encoded, j)
                if pad_c != PADDING_CHAR:
                    return false
                j = j + 1
            return true
        var alphabet = BASE64_URL_ALPHABET
        var idx = char_to_base64_index(c, alphabet)
        if idx < 0:
            return false
        i = i + 1
    true

# Check if text is valid hexadecimal
fn is_valid_hex(encoded: text) -> bool:
    var len = text_length(encoded)
    if len == 0:
        return false
    var len_mod = len % 2
    if len_mod != 0:
        return false
    var i = 0
    while i < len:
        var c = text_char_at(encoded, i)
        var is_hex = is_hex_char(c)
        if not is_hex:
            return false
        i = i + 1
    true

# Check if character is valid hex digit
fn is_hex_char(c: text) -> bool:
    var lower = "0123456789abcdef"
    var upper = "0123456789ABCDEF"
    var i = 0
    while i < 16:
        var lower_c = text_char_at(lower, i)
        var upper_c = text_char_at(upper, i)
        if c == lower_c:
            return true
        if c == upper_c:
            return true
        i = i + 1
    false

# Check if text is valid Base32
fn is_valid_base32(encoded: text) -> bool:
    var len = text_length(encoded)
    if len == 0:
        return false
    var i = 0
    while i < len:
        var c = text_char_at(encoded, i)
        if c == PADDING_CHAR:
            # Check remaining are all padding
            var j = i
            while j < len:
                var pad_c = text_char_at(encoded, j)
                if pad_c != PADDING_CHAR:
                    return false
                j = j + 1
            return true
        var alphabet = BASE32_ALPHABET
        var found = false
        var j = 0
        while j < 32:
            var alphabet_c = text_char_at(alphabet, j)
            if c == alphabet_c:
                found = true
                j = 999
            j = j + 1
        if not found:
            return false
        i = i + 1
    true
