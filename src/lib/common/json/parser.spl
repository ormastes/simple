# JSON Parser
#
# Purpose: Tokenization and parsing of JSON text into JSON values
#
# Contains:
# - Tokenization: json_tokenize, json_skip_whitespace
# - Parsing: json_parse, json_parse_with_error, json_parse_tokens
# - Value parsing: json_parse_value_at, json_parse_object_at, json_parse_array_at


# Import types for constructors
mod json.types

fn json_skip_whitespace(text: text, pos: i64) -> i64:
    """Skip whitespace characters.

    Args:
        text: Input text
        pos: Current position

    Returns:
        Position after whitespace
    """
    var p = pos
    while p < text.len():
        val c = text.char_at(p)
        if c == " " or c == "\n" or c == "\r" or c == "\t":
            p = p + 1
        else:
            return p
    p

fn json_tokenize(text: text) -> [(text, text)]:
    """Tokenize JSON text.

    Args:
        text: JSON text

    Returns:
        Array of (token_type, token_value) tuples
        Token types: "LBRACE", "RBRACE", "LBRACKET", "RBRACKET", "COLON", "COMMA",
                     "STRING", "NUMBER", "TRUE", "FALSE", "NULL"

    Example:
        json_tokenize("{\"key\": 42}")
    """
    var tokens: [(text, text)] = []
    var pos = 0
    while pos < text.len():
        pos = json_skip_whitespace(text, pos)
        if pos >= text.len():
            break
        val c = text.char_at(pos)
        if c == "{":
            tokens = tokens + [("LBRACE", "{")]
            pos = pos + 1
        else:
            if c == "}":
                tokens = tokens + [("RBRACE", "}")]
                pos = pos + 1
            else:
                if c == "[":
                    tokens = tokens + [("LBRACKET", "[")]
                    pos = pos + 1
                else:
                    if c == "]":
                        tokens = tokens + [("RBRACKET", "]")]
                        pos = pos + 1
                    else:
                        if c == ":":
                            tokens = tokens + [("COLON", ":")]
                            pos = pos + 1
                        else:
                            if c == ",":
                                tokens = tokens + [("COMMA", ",")]
                                pos = pos + 1
                            else:
                                if c == "\"":
                                    var str_val = ""
                                    pos = pos + 1
                                    var escaped = false
                                    while pos < text.len():
                                        val sc = text.char_at(pos)
                                        if escaped:
                                            str_val = str_val + "\\" + sc
                                            escaped = false
                                            pos = pos + 1
                                        else:
                                            if sc == "\\":
                                                escaped = true
                                                pos = pos + 1
                                            else:
                                                if sc == "\"":
                                                    pos = pos + 1
                                                    break
                                                else:
                                                    str_val = str_val + sc
                                                    pos = pos + 1
                                    tokens = tokens + [("STRING", str_val)]
                                else:
                                    if c == "t":
                                        if text.slice(pos, pos + 4) == "true":
                                            tokens = tokens + [("TRUE", "true")]
                                            pos = pos + 4
                                        else:
                                            pos = pos + 1
                                    else:
                                        if c == "f":
                                            if text.slice(pos, pos + 5) == "false":
                                                tokens = tokens + [("FALSE", "false")]
                                                pos = pos + 5
                                            else:
                                                pos = pos + 1
                                        else:
                                            if c == "n":
                                                if text.slice(pos, pos + 4) == "null":
                                                    tokens = tokens + [("NULL", "null")]
                                                    pos = pos + 4
                                                else:
                                                    pos = pos + 1
                                            else:
                                                if c == "-" or (c >= "0" and c <= "9"):
                                                    var num_str = ""
                                                    while pos < text.len():
                                                        val nc = text.char_at(pos)
                                                        if nc == "-" or nc == "." or nc == "e" or nc == "E" or nc == "+" or (nc >= "0" and nc <= "9"):
                                                            num_str = num_str + nc
                                                            pos = pos + 1
                                                        else:
                                                            break
                                                    tokens = tokens + [("NUMBER", num_str)]
                                                else:
                                                    pos = pos + 1
    tokens

fn json_unescape_string(s: text) -> text:
    """Unescape JSON string.

    Args:
        s: Escaped string

    Returns:
        Unescaped string

    Example:
        json_unescape_string("hello\\nworld")  # "hello\nworld"
    """
    var result = ""
    var i = 0
    while i < s.len():
        val c = s.char_at(i)
        if c == "\\":
            if i + 1 < s.len():
                val next = s.char_at(i + 1)
                if next == "\"":
                    result = result + "\""
                    i = i + 2
                else:
                    if next == "\\":
                        result = result + "\\"
                        i = i + 2
                    else:
                        if next == "n":
                            result = result + "\n"
                            i = i + 2
                        else:
                            if next == "r":
                                result = result + "\r"
                                i = i + 2
                            else:
                                if next == "t":
                                    result = result + "\t"
                                    i = i + 2
                                else:
                                    result = result + c
                                    i = i + 1
            else:
                result = result + c
                i = i + 1
        else:
            result = result + c
            i = i + 1
    result

fn json_parse_value_at(tokens: [(text, text)], pos: i64) -> (bool, any, text, i64):
    """Parse value at token position.

    Args:
        tokens: Token array
        pos: Current position

    Returns:
        (success, value, error_message, next_position)
    """
    if pos >= tokens.len():
        return (false, nil, "Unexpected end of input", pos)
    val token = tokens[pos]
    val token_type = token.0
    val token_value = token.1
    if token_type == "STRING":
        val unescaped = json_unescape_string(token_value)
        return (true, json_string(unescaped), "", pos + 1)
    if token_type == "NUMBER":
        val num = token_value.to_float()
        return (true, json_number(num), "", pos + 1)
    if token_type == "TRUE":
        return (true, json_boolean(true), "", pos + 1)
    if token_type == "FALSE":
        return (true, json_boolean(false), "", pos + 1)
    if token_type == "NULL":
        return (true, json_null(), "", pos + 1)
    if token_type == "LBRACKET":
        return json_parse_array_at(tokens, pos)
    if token_type == "LBRACE":
        return json_parse_object_at(tokens, pos)
    (false, nil, "Unexpected token: {token_type}", pos)

fn json_parse_array_at(tokens: [(text, text)], pos: i64) -> (bool, any, text, i64):
    """Parse array at token position.

    Args:
        tokens: Token array
        pos: Current position (should be at LBRACKET)

    Returns:
        (success, array_value, error_message, next_position)
    """
    var p = pos + 1
    var elements: [any] = []
    while p < tokens.len():
        val token = tokens[p]
        val token_type = token.0
        if token_type == "RBRACKET":
            return (true, json_array(elements), "", p + 1)
        if elements.len() > 0:
            if token_type != "COMMA":
                return (false, nil, "Expected comma in array", p)
            p = p + 1
        val result = json_parse_value_at(tokens, p)
        val success = result.0
        val value = result.1
        val error_msg = result.2
        val next_pos = result.3
        if not success:
            return (false, nil, error_msg, next_pos)
        elements = elements + [value]
        p = next_pos
    (false, nil, "Unclosed array", p)

fn json_parse_object_at(tokens: [(text, text)], pos: i64) -> (bool, any, text, i64):
    """Parse object at token position.

    Args:
        tokens: Token array
        pos: Current position (should be at LBRACE)

    Returns:
        (success, object_value, error_message, next_position)
    """
    var p = pos + 1
    var pairs: {text: any} = {}
    while p < tokens.len():
        val token = tokens[p]
        val token_type = token.0
        if token_type == "RBRACE":
            return (true, json_object(pairs), "", p + 1)
        if pairs.len() > 0:
            if token_type != "COMMA":
                return (false, nil, "Expected comma in object", p)
            p = p + 1
            if p >= tokens.len():
                return (false, nil, "Unexpected end in object", p)
            val next_token = tokens[p]
            val next_type = next_token.0
            if next_type == "RBRACE":
                return (true, json_object(pairs), "", p + 1)
        if p >= tokens.len():
            return (false, nil, "Unexpected end in object", p)
        val key_token = tokens[p]
        val key_type = key_token.0
        val key_value = key_token.1
        if key_type != "STRING":
            return (false, nil, "Expected string key in object", p)
        val key = json_unescape_string(key_value)
        p = p + 1
        if p >= tokens.len():
            return (false, nil, "Unexpected end after key", p)
        val colon_token = tokens[p]
        val colon_type = colon_token.0
        if colon_type != "COLON":
            return (false, nil, "Expected colon after key", p)
        p = p + 1
        val result = json_parse_value_at(tokens, p)
        val success = result.0
        val value = result.1
        val error_msg = result.2
        val next_pos = result.3
        if not success:
            return (false, nil, error_msg, next_pos)
        pairs[key] = value
        p = next_pos
    (false, nil, "Unclosed object", p)

fn json_parse_tokens(tokens: [(text, text)]) -> (bool, any, text, i64):
    """Parse tokens into JSON value.

    Args:
        tokens: Array of tokens from json_tokenize

    Returns:
        (success, value, error_message, position)

    Example:
        json_parse_tokens(json_tokenize("{\"key\": 42}"))
    """
    if tokens.len() == 0:
        return (false, nil, "Empty input", 0)
    val result = json_parse_value_at(tokens, 0)
    result

fn json_parse(text: text) -> any:
    """Parse JSON text to value.

    Args:
        text: JSON text

    Returns:
        JSON value if successful, nil otherwise

    Example:
        val data = json_parse("{\"name\": \"Alice\"}")
    """
    val tokens = json_tokenize(text)
    val result = json_parse_tokens(tokens)
    if result.0:
        return result.1
    nil

fn json_parse_with_error(text: text) -> (any, text):
    """Parse JSON text with error message.

    Args:
        text: JSON text

    Returns:
        (value, error_message) - value is nil if error occurred

    Example:
        val (data, error) = json_parse_with_error(json_text)
        if error != "":
            print "Parse error: {error}"
    """
    val tokens = json_tokenize(text)
    val result = json_parse_tokens(tokens)
    if result.0:
        return (result.1, "")
    (nil, result.2)

export *
