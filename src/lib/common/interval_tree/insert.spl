# Interval Tree - Insertion Operations

use interval_tree.types.{
    interval_compare, interval_set_data, interval_data,
    color_red, color_black,
    node_new, node_color, node_interval, node_left, node_right,
    node_set_color, node_set_left, node_set_right, node_set_children,
    is_red
}

# ============================================================================
# Rotations
# ============================================================================

fn rotate_left(node: any) -> any:
    if node == nil:
        nil
    else:
        val n = node as (i64, (i64, i64, i64), i64, any, any)
        val right = node_right(n)

        if right == nil:
            node
        else:
            val r = right as (i64, (i64, i64, i64), i64, any, any)
            val right_left = node_left(r)

            # Update node with new right child
            val new_node = node_set_right(n, right_left)
            val updated_node = update_max_end(new_node)

            # Update right with new left child
            val new_right = node_set_left(r, updated_node)
            val updated_right = update_max_end(new_right)

            updated_right

fn rotate_right(node: any) -> any:
    if node == nil:
        nil
    else:
        val n = node as (i64, (i64, i64, i64), i64, any, any)
        val left = node_left(n)

        if left == nil:
            node
        else:
            val l = left as (i64, (i64, i64, i64), i64, any, any)
            val left_right = node_right(l)

            # Update node with new left child
            val new_node = node_set_left(n, left_right)
            val updated_node = update_max_end(new_node)

            # Update left with new right child
            val new_left = node_set_right(l, updated_node)
            val updated_left = update_max_end(new_left)

            updated_left

fn flip_colors(node: any) -> any:
    if node == nil:
        nil
    else:
        val n = node as (i64, (i64, i64, i64), i64, any, any)
        val current_color = node_color(n)
        val new_color = if current_color == color_red(): color_black() else: color_red()
        val new_node = node_set_color(n, new_color)

        val left = node_left(n)
        val right = node_right(n)

        # Flip left child color
        var new_left = left
        if left != nil:
            val l = left as (i64, (i64, i64, i64), i64, any, any)
            val left_color = node_color(l)
            val new_left_color = if left_color == color_red(): color_black() else: color_red()
            new_left = node_set_color(l, new_left_color)
        else:
            ()

        # Flip right child color
        var new_right = right
        if right != nil:
            val r = right as (i64, (i64, i64, i64), i64, any, any)
            val right_color = node_color(r)
            val new_right_color = if right_color == color_red(): color_black() else: color_red()
            new_right = node_set_color(r, new_right_color)
        else:
            ()

        node_set_children(new_node, new_left, new_right)

fn update_max_end(node: any) -> any:
    if node == nil:
        nil
    else:
        val n = node as (i64, (i64, i64, i64), i64, any, any)
        val interval = node_interval(n)
        val left = node_left(n)
        val right = node_right(n)
        val new_max = compute_max_end(interval, left, right)
        node_set_max_end(n, new_max)

# ============================================================================
# Insertion
# ============================================================================

fn insert(tree: any, interval: (i64, i64, i64)) -> any:
    val result = insert_helper(tree, interval)

    # Ensure root is black
    if result == nil:
        nil
    else:
        val r = result as (i64, (i64, i64, i64), i64, any, any)
        node_set_color(r, color_black())

fn insert_helper(node: any, interval: (i64, i64, i64)) -> any:
    if node == nil:
        node_new(color_red(), interval)
    else:
        val n = node as (i64, (i64, i64, i64), i64, any, any)
        val node_interval = node_interval(n)
        val cmp = interval_compare(interval, node_interval)

        var result = n
        if cmp < 0:
            val left = node_left(n)
            val new_left = insert_helper(left, interval)
            result = node_set_left(n, new_left)
        else: if cmp > 0:
            val right = node_right(n)
            val new_right = insert_helper(right, interval)
            result = node_set_right(n, new_right)
        else:
            # Equal interval, update data
            val new_interval = interval_set_data(node_interval, interval_data(interval))
            result = node_set_interval(n, new_interval)

        balance(result)

fn balance(node: any) -> any:
    if node == nil:
        nil
    else:
        var n = node
        val node_data = n as (i64, (i64, i64, i64), i64, any, any)
        val left = node_left(node_data)
        val right = node_right(node_data)

        # Fix right-leaning red
        val right_is_red = is_red(right)
        val left_is_red = is_red(left)

        if right_is_red and not left_is_red:
            n = rotate_left(n)
        else:
            ()

        # Fix two reds in a row on left
        val updated = n as (i64, (i64, i64, i64), i64, any, any)
        val new_left = node_left(updated)
        val left_left = if new_left == nil: nil else: node_left(new_left as (i64, (i64, i64, i64), i64, any, any))

        if is_red(new_left) and is_red(left_left):
            n = rotate_right(n)
        else:
            ()

        # Fix two red children
        val balanced = n as (i64, (i64, i64, i64), i64, any, any)
        val final_left = node_left(balanced)
        val final_right = node_right(balanced)

        if is_red(final_left) and is_red(final_right):
            n = flip_colors(n)
        else:
            ()

        n

# ============================================================================
# Exports
# ============================================================================

export rotate_left, rotate_right, flip_colors
export insert, insert_helper, balance
