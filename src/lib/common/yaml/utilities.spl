# YAML Utilities Module
# String escaping, indentation, helpers


# String Escaping and Unescaping
# ============================================================================

fn yaml_escape_string(str: text) -> text:
    """Escape special characters in a string for YAML."""
    var result = ""
    var i = 0
    while i < str.length():
        val ch = str.substring(i, i + 1)
        if ch == "\\":
            result = result + "\\\\"
        else if ch == "\"":
            result = result + "\\\""
        else if ch == "\n":
            result = result + "\\n"
        else if ch == "\r":
            result = result + "\\r"
        else if ch == "\t":
            result = result + "\\t"
        else:
            result = result + ch
        i = i + 1
    result

fn yaml_unescape_string(str: text) -> text:
    """Unescape YAML escape sequences in a string."""
    var result = ""
    var i = 0
    while i < str.length():
        val ch = str.substring(i, i + 1)
        if ch == "\\":
            var next_i = i + 1
            var has_next = next_i < str.length()
            if has_next:
                val next_ch = str.substring(next_i, next_i + 1)
                if next_ch == "\\":
                    result = result + "\\"
                    i = i + 1
                else if next_ch == "\"":
                    result = result + "\""
                    i = i + 1
                else if next_ch == "n":
                    result = result + "\n"
                    i = i + 1
                else if next_ch == "r":
                    result = result + "\r"
                    i = i + 1
                else if next_ch == "t":
                    result = result + "\t"
                    i = i + 1
                else:
                    result = result + ch
            else:
                result = result + ch
        else:
            result = result + ch
        i = i + 1
    result

fn yaml_needs_quotes(str: text) -> bool:
    """Check if a string needs quotes in YAML."""
    var needs = false
    var temp_str = str.trim()
    if temp_str.length() == 0:
        needs = true
    if not needs:
        val first_ch = temp_str.substring(0, 1)
        var is_special_first = first_ch == "-"
        is_special_first = is_special_first or first_ch == "?"
        is_special_first = is_special_first or first_ch == ":"
        is_special_first = is_special_first or first_ch == "["
        is_special_first = is_special_first or first_ch == "]"
        is_special_first = is_special_first or first_ch == "{"
        is_special_first = is_special_first or first_ch == "}"
        is_special_first = is_special_first or first_ch == "#"
        is_special_first = is_special_first or first_ch == "&"
        is_special_first = is_special_first or first_ch == "*"
        is_special_first = is_special_first or first_ch == "!"
        is_special_first = is_special_first or first_ch == "|"
        is_special_first = is_special_first or first_ch == ">"
        is_special_first = is_special_first or first_ch == "'"
        is_special_first = is_special_first or first_ch == "\""
        if is_special_first:
            needs = true
    if not needs:
        var has_special = str.contains(":")
        has_special = has_special or str.contains("#")
        has_special = has_special or str.contains("\n")
        has_special = has_special or str.contains("\r")
        if has_special:
            needs = true
    needs

fn yaml_quote_string(str: text, style: text) -> text:
    """Quote a string in YAML with given style: 'single', 'double', or 'plain'."""
    var result = str
    if style == "single":
        result = "'" + str.replace("'", "''") + "'"
    else if style == "double":
        val escaped = yaml_escape_string(str)
        result = "\"" + escaped + "\""
    result

# ============================================================================
# Indentation Utilities
# ============================================================================

fn yaml_detect_indentation(yaml_text: text) -> i64:
    """Detect indentation level from YAML text."""
    var indent = 2
    val lines = yaml_text.split("\n")
    var i = 0
    var found = false
    while i < lines.length() and not found:
        val line = lines.get(i)
        val trimmed = line.trim_start()
        var line_has_content = trimmed.length() > 0
        val first_ch = line.substring(0, 1)
        line_has_content = line_has_content and first_ch == " "
        if line_has_content:
            var spaces = 0
            var j = 0
            var counting = true
            while j < line.length() and counting:
                val ch = line.substring(j, j + 1)
                if ch == " ":
                    spaces = spaces + 1
                else:
                    counting = false
                j = j + 1
            if spaces > 0:
                indent = spaces
                found = true
        i = i + 1
    indent

fn yaml_indent(text: text, level: i64, indent_size: i64) -> text:
    """Add indentation to text."""
    val spaces_count = level * indent_size
    var spaces = ""
    var i = 0
    while i < spaces_count:
        spaces = spaces + " "
        i = i + 1
    spaces + text

fn yaml_validate_indentation(yaml_text: text) -> bool:
    """Validate indentation structure of YAML text."""
    var valid = true
    val lines = yaml_text.split("\n")
    var prev_indent = 0
    var i = 0
    while i < lines.length() and valid:
        val line = lines.get(i)
        val trimmed = line.trim_start()
        val has_content = trimmed.length() > 0
        if has_content:
            var spaces = 0
            var j = 0
            var counting = true
            while j < line.length() and counting:
                val ch = line.substring(j, j + 1)
                if ch == " ":
                    spaces = spaces + 1
                else:
                    counting = false
                j = j + 1
            var indent_diff = spaces - prev_indent
            if indent_diff < 0:
                indent_diff = 0 - indent_diff
            var is_reasonable = indent_diff == 0
            is_reasonable = is_reasonable or indent_diff == 2
            is_reasonable = is_reasonable or indent_diff == 4
            if not is_reasonable:
                valid = false
            prev_indent = spaces
        i = i + 1
    valid

# ============================================================================
# Mapping Operations
# ============================================================================

fn yaml_mapping_get(mapping: (text, any), key: text) -> any:
    """Get value from mapping by key. Returns nil if not found."""
    val pairs = yaml_get_mapping_pairs(mapping)
    var result = nil
    var i = 0
    var found = false
    while i < pairs.length() and not found:
        val pair = pairs.get(i)
        val pair_key = pair.0
        val pair_value = pair.1
        if pair_key == key:
            result = pair_value
            found = true
        i = i + 1
    result

fn yaml_mapping_has(mapping: (text, any), key: text) -> bool:
    """Check if mapping contains key."""
    val pairs = yaml_get_mapping_pairs(mapping)
    var found = false
    var i = 0
    while i < pairs.length() and not found:
        val pair = pairs.get(i)
        val pair_key = pair.0
        if pair_key == key:
            found = true
        i = i + 1
    found

fn yaml_mapping_set(mapping: (text, any), key: text, value: any) -> (text, list):
    """Set value in mapping. Returns new mapping."""
    val pairs = yaml_get_mapping_pairs(mapping)
    var new_pairs = []
    var found = false
    var i = 0
    while i < pairs.length():
        val pair = pairs.get(i)
        val pair_key = pair.0
        val pair_value = pair.1
        if pair_key == key:
            new_pairs = new_pairs.append((key, value))
            found = true
        else:
            new_pairs = new_pairs.append(pair)
        i = i + 1
    if not found:
        new_pairs = new_pairs.append((key, value))
    yaml_mapping(new_pairs)

fn yaml_mapping_remove(mapping: (text, any), key: text) -> (text, list):
    """Remove key from mapping. Returns new mapping."""
    val pairs = yaml_get_mapping_pairs(mapping)
    var new_pairs = []
    var i = 0
    while i < pairs.length():
        val pair = pairs.get(i)
        val pair_key = pair.0
        if pair_key != key:
            new_pairs = new_pairs.append(pair)
        i = i + 1
    yaml_mapping(new_pairs)

fn yaml_mapping_keys(mapping: (text, any)) -> list:
    """Get all keys from mapping."""
    val pairs = yaml_get_mapping_pairs(mapping)
    var keys = []
    var i = 0
    while i < pairs.length():
        val pair = pairs.get(i)
        val pair_key = pair.0
        keys = keys.append(pair_key)
        i = i + 1
    keys

fn yaml_mapping_values(mapping: (text, any)) -> list:
    """Get all values from mapping."""
    val pairs = yaml_get_mapping_pairs(mapping)
    var values = []
    var i = 0
    while i < pairs.length():
        val pair = pairs.get(i)
        val pair_value = pair.1
        values = values.append(pair_value)
        i = i + 1
    values

fn yaml_mapping_size(mapping: (text, any)) -> i64:
    """Get number of entries in mapping."""
    val pairs = yaml_get_mapping_pairs(mapping)
    pairs.length()

# ============================================================================
# Sequence Operations
# ============================================================================

fn yaml_sequence_get(sequence: (text, any), index: i64) -> any:
    """Get item from sequence by index. Returns nil if out of bounds."""
    val items = yaml_get_sequence_items(sequence)
    var result = nil
    var is_valid = index >= 0
    is_valid = is_valid and index < items.length()
    if is_valid:
        result = items.get(index)
    result

fn yaml_sequence_set(sequence: (text, any), index: i64, value: any) -> (text, list):
    """Set item in sequence. Returns new sequence."""
    val items = yaml_get_sequence_items(sequence)
    var new_items = []
    var i = 0
    while i < items.length():
        if i == index:
            new_items = new_items.append(value)
        else:
            val item = items.get(i)
            new_items = new_items.append(item)
        i = i + 1
    yaml_sequence(new_items)

fn yaml_sequence_append(sequence: (text, any), value: any) -> (text, list):
    """Append item to sequence. Returns new sequence."""
    val items = yaml_get_sequence_items(sequence)
    val new_items = items.append(value)
    yaml_sequence(new_items)

fn yaml_sequence_length(sequence: (text, any)) -> i64:
    """Get length of sequence."""
    val items = yaml_get_sequence_items(sequence)
    items.length()

fn yaml_sequence_insert(sequence: (text, any), index: i64, value: any) -> (text, list):
    """Insert item at index in sequence. Returns new sequence."""
    val items = yaml_get_sequence_items(sequence)
    var new_items = []
    var i = 0
    while i < items.length():
        if i == index:
            new_items = new_items.append(value)
        val item = items.get(i)
        new_items = new_items.append(item)
        i = i + 1
    if index >= items.length():
        new_items = new_items.append(value)
    yaml_sequence(new_items)

fn yaml_sequence_remove(sequence: (text, any), index: i64) -> (text, list):
    """Remove item at index from sequence. Returns new sequence."""
    val items = yaml_get_sequence_items(sequence)
    var new_items = []
    var i = 0
    while i < items.length():
        if i != index:
            val item = items.get(i)
            new_items = new_items.append(item)
        i = i + 1
    yaml_sequence(new_items)

# ============================================================================
# Utility Functions
# ============================================================================

fn yaml_pretty_print(value: (text, any)) -> text:
    """Pretty print a YAML value in block style."""
    yaml_serialize_block(value)

fn yaml_compact_print(value: (text, any)) -> text:
    """Compact print a YAML value in flow style."""
    yaml_serialize_flow(value)

fn yaml_deep_copy(value: (text, any)) -> (text, any):
    """Create a deep copy of a YAML value."""
    val serialized = yaml_serialize_block(value)
    yaml_parse(serialized)

fn yaml_merge_mappings(m1: (text, any), m2: (text, any)) -> (text, list):
    """Merge two mappings. Values from m2 override m1."""
    val pairs1 = yaml_get_mapping_pairs(m1)
    val pairs2 = yaml_get_mapping_pairs(m2)
    var result_pairs = pairs1
    var i = 0
    while i < pairs2.length():
        val pair = pairs2.get(i)
        val key = pair.0
        val value = pair.1
        var temp = yaml_mapping(result_pairs)
        temp = yaml_mapping_set(temp, key, value)
        result_pairs = yaml_get_mapping_pairs(temp)
        i = i + 1
    yaml_mapping(result_pairs)

fn yaml_equals(v1: (text, any), v2: (text, any)) -> bool:
    """Check if two YAML values are equal."""
    val s1 = yaml_serialize_flow(v1)
    val s2 = yaml_serialize_flow(v2)
    s1 == s2

fn yaml_to_string(value: (text, any)) -> text:
    """Convert YAML value to string representation."""
    yaml_serialize_block(value)

fn yaml_from_string(str: text) -> (text, any):
    """Parse YAML from string."""
    yaml_parse(str)

# ============================================================================
# Advanced Utility Functions
# ============================================================================

fn yaml_mapping_contains_value(mapping: (text, any), value: (text, any)) -> bool:
    """Check if mapping contains a specific value."""
    val values = yaml_mapping_values(mapping)
    var found = false
    var i = 0
    while i < values.length() and not found:
        val v = values.get(i)
        if yaml_equals(v, value):
            found = true
        i = i + 1
    found

fn yaml_sequence_contains(sequence: (text, any), value: (text, any)) -> bool:
    """Check if sequence contains a specific value."""
    val items = yaml_get_sequence_items(sequence)
    var found = false
    var i = 0
    while i < items.length() and not found:
        val item = items.get(i)
        if yaml_equals(item, value):
            found = true
        i = i + 1
    found

fn yaml_sequence_index_of(sequence: (text, any), value: (text, any)) -> i64:
    """Get index of value in sequence. Returns -1 if not found."""
    val items = yaml_get_sequence_items(sequence)
    var result = -1
    var i = 0
    var found = false
    while i < items.length() and not found:
        val item = items.get(i)
        if yaml_equals(item, value):
            result = i
            found = true
        i = i + 1
    result

fn yaml_sequence_reverse(sequence: (text, any)) -> (text, list):
    """Reverse the order of items in a sequence."""
    val items = yaml_get_sequence_items(sequence)
    var new_items = []
    var i = items.length() - 1
    while i >= 0:
        val item = items.get(i)
        new_items = new_items.append(item)
        i = i - 1
    yaml_sequence(new_items)

fn yaml_sequence_slice(sequence: (text, any), start: i64, end: i64) -> (text, list):
    """Get a slice of a sequence from start to end (exclusive)."""
    val items = yaml_get_sequence_items(sequence)
    var new_items = []
    var i = start
    while i < end and i < items.length():
        if i >= 0:
            val item = items.get(i)
            new_items = new_items.append(item)
        i = i + 1
    yaml_sequence(new_items)

fn yaml_mapping_filter_keys(mapping: (text, any), keys: list) -> (text, list):
    """Filter mapping to only include specified keys."""
    val pairs = yaml_get_mapping_pairs(mapping)
    var new_pairs = []
    var i = 0
    while i < pairs.length():
        val pair = pairs.get(i)
        val key = pair.0
        var should_include = false
        var j = 0
        while j < keys.length():
            val filter_key = keys.get(j)
            if key == filter_key:
                should_include = true
            j = j + 1
        if should_include:
            new_pairs = new_pairs.append(pair)
        i = i + 1
    yaml_mapping(new_pairs)

fn yaml_mapping_exclude_keys(mapping: (text, any), keys: list) -> (text, list):
    """Filter mapping to exclude specified keys."""
    val pairs = yaml_get_mapping_pairs(mapping)
    var new_pairs = []
    var i = 0
    while i < pairs.length():
        val pair = pairs.get(i)
        val key = pair.0
        var should_exclude = false
        var j = 0
        while j < keys.length():
            val filter_key = keys.get(j)
            if key == filter_key:
                should_exclude = true
            j = j + 1
        if not should_exclude:
            new_pairs = new_pairs.append(pair)
        i = i + 1
    yaml_mapping(new_pairs)

fn yaml_is_empty(value: (text, any)) -> bool:
    """Check if a YAML value is empty (null, empty sequence, or empty mapping)."""
    val value_type = value.0
    var is_empty = false
    if value_type == "scalar":
        is_empty = is_yaml_null(value)
    else if value_type == "sequence":
        val items = yaml_get_sequence_items(value)
        is_empty = items.length() == 0
    else if value_type == "mapping":
        val pairs = yaml_get_mapping_pairs(value)
        is_empty = pairs.length() == 0
    is_empty

fn yaml_get_nested(value: (text, any), path: list) -> any:
    """Get nested value using a path list. Returns nil if not found."""
    var current = value
    var i = 0
    var found = true
    while i < path.length() and found:
        val key = path.get(i)
        val current_type = current.0
        if current_type == "mapping":
            val next_val = yaml_mapping_get(current, key)
            if next_val == nil:
                found = false
                current = yaml_null()
            else:
                current = next_val
        else:
            found = false
            current = yaml_null()
        i = i + 1
    if found:
        current
    else:
        nil

fn yaml_set_nested(value: (text, any), path: list, new_value: (text, any)) -> (text, any):
    """Set nested value using a path list. Creates intermediate mappings as needed."""
    var result = value
    if path.length() == 0:
        return new_value
    if path.length() == 1:
        val key = path.get(0)
        if is_yaml_mapping(value):
            result = yaml_mapping_set(value, key, new_value)
        return result
    val first_key = path.get(0)
    var rest_path = []
    var i = 1
    while i < path.length():
        val p = path.get(i)
        rest_path = rest_path.append(p)
        i = i + 1
    var nested = yaml_mapping_get(value, first_key)
    if nested == nil:
        nested = yaml_mapping([])
    val updated_nested = yaml_set_nested(nested, rest_path, new_value)
    result = yaml_mapping_set(value, first_key, updated_nested)
    result

fn yaml_count_nodes(value: (text, any)) -> i64:
    """Count total number of nodes in a YAML structure."""
    val value_type = value.0
    var count = 1
    if value_type == "sequence":
        val items = yaml_get_sequence_items(value)
        var i = 0
        while i < items.length():
            val item = items.get(i)
            count = count + yaml_count_nodes(item)
            i = i + 1
    else if value_type == "mapping":
        val pairs = yaml_get_mapping_pairs(value)
        var i = 0
        while i < pairs.length():
            val pair = pairs.get(i)
            val v = pair.1
            count = count + yaml_count_nodes(v)
            i = i + 1
    count

fn yaml_depth(value: (text, any)) -> i64:
    """Calculate maximum depth of a YAML structure."""
    val value_type = value.0
    var max_depth = 1
    if value_type == "sequence":
        val items = yaml_get_sequence_items(value)
        var i = 0
        while i < items.length():
            val item = items.get(i)
            val item_depth = yaml_depth(item)
            if item_depth > max_depth:
                max_depth = item_depth
            i = i + 1
        max_depth = max_depth + 1
    else if value_type == "mapping":
        val pairs = yaml_get_mapping_pairs(value)
        var i = 0
        while i < pairs.length():
            val pair = pairs.get(i)
            val v = pair.1
            val v_depth = yaml_depth(v)
            if v_depth > max_depth:
                max_depth = v_depth
            i = i + 1
        max_depth = max_depth + 1
    max_depth

fn yaml_flatten_mapping(mapping: (text, any), prefix: text, separator: text) -> (text, list):
    """Flatten nested mapping into single-level mapping with dotted keys."""
    var result_pairs = []
    val pairs = yaml_get_mapping_pairs(mapping)
    var i = 0
    while i < pairs.length():
        val pair = pairs.get(i)
        val key = pair.0
        val value = pair.1
        val full_key = if prefix == "": key else: prefix + separator + key
        val value_type = value.0
        if value_type == "mapping":
            val nested_flat = yaml_flatten_mapping(value, full_key, separator)
            val nested_pairs = yaml_get_mapping_pairs(nested_flat)
            var j = 0
            while j < nested_pairs.length():
                val nested_pair = nested_pairs.get(j)
                result_pairs = result_pairs.append(nested_pair)
                j = j + 1
        else:
            result_pairs = result_pairs.append((full_key, value))
        i = i + 1
    yaml_mapping(result_pairs)

fn yaml_validate_schema(value: (text, any), schema_type: text) -> bool:
    """Basic schema validation. Types: 'mapping', 'sequence', 'string', 'number', 'boolean', 'null'."""
    val value_type = value.0
    var valid = false
    if schema_type == "mapping":
        valid = is_yaml_mapping(value)
    else if schema_type == "sequence":
        valid = is_yaml_sequence(value)
    else if schema_type == "string":
        valid = is_yaml_string(value)
    else if schema_type == "number":
        valid = is_yaml_number(value)
    else if schema_type == "boolean":
        valid = is_yaml_boolean(value)
    else if schema_type == "null":
        valid = is_yaml_null(value)
    valid

# ============================================================================
# End of Module
# ============================================================================


# ============================================================================
# EXPORTS
# ============================================================================

export yaml_escape_string, yaml_unescape_string, yaml_needs_quotes, yaml_quote_string
export yaml_detect_indentation, yaml_indent, yaml_validate_indentation
export yaml_mapping_get, yaml_mapping_has, yaml_mapping_set, yaml_mapping_remove
export yaml_mapping_keys, yaml_mapping_values, yaml_mapping_size
export yaml_sequence_get, yaml_sequence_set, yaml_sequence_append, yaml_sequence_length
export yaml_sequence_insert, yaml_sequence_remove
export yaml_pretty_print, yaml_compact_print, yaml_deep_copy, yaml_merge_mappings
export yaml_equals, yaml_to_string, yaml_from_string
export yaml_mapping_contains_value, yaml_sequence_contains, yaml_sequence_index_of
export yaml_sequence_reverse, yaml_sequence_slice
export yaml_mapping_filter_keys, yaml_mapping_exclude_keys
export yaml_is_empty, yaml_get_nested, yaml_set_nested
export yaml_count_nodes, yaml_depth, yaml_flatten_mapping, yaml_validate_schema
