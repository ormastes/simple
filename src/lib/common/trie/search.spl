# Trie Search Operations
#
# Functions for searching words, prefixes, and patterns in tries.

# Searches for a complete word in the trie
# Args:
#   trie: The trie root node
#   word: String to search for
# Returns: true if word exists as complete word, false otherwise
fn trie_search(trie, word):
    var node = trie_find_node(trie, word)
    if node == nil:
        false
    else:
        node["is_end"]

# Checks if a word exists in the trie (alias for trie_search)
# Args:
#   trie: The trie root node
#   word: String to check
# Returns: true if word exists, false otherwise
fn trie_contains(trie, word):
    trie_search(trie, word)

# Checks if any word in the trie starts with the given prefix
# Args:
#   trie: The trie root node
#   prefix: String prefix to check
# Returns: true if prefix exists, false otherwise
fn trie_starts_with(trie, prefix):
    var node = trie_find_node(trie, prefix)
    node != nil

# Finds the trie node corresponding to a given string
# Args:
#   trie: The trie root node
#   str: String to find node for
# Returns: The trie node if found, nil otherwise
fn trie_find_node(trie, str):
    var current = trie
    var i = 0
    var len = str.length()

    while i < len:
        var ch = str.char_at(i)
        var children = current["children"]

        if not children.has_key(ch):
            return nil

        current = children[ch]
        i = i + 1

    current

# Searches for words matching a wildcard pattern
# Args:
#   trie: The trie root node
#   pattern: Pattern string with ? (any single char) and * (any sequence)
# Returns: List of matching words
fn trie_wildcard_search(trie, pattern):
    var results = []
    trie_wildcard_search_helper(trie, pattern, 0, "", results)
    results

# Helper function for wildcard search
# Args:
#   node: Current trie node
#   pattern: Pattern to match
#   p_index: Current position in pattern
#   current: Current string built so far
#   results: List to append results to
# Returns: nil
fn trie_wildcard_search_helper(node, pattern, p_index, current, results):
    var p_len = pattern.length()

    if p_index == p_len:
        if node["is_end"]:
            results.append(current)
        return nil

    var ch = pattern.char_at(p_index)
    var children = node["children"]

    if ch == "?":
        var keys = children.keys()
        var i = 0
        var len = keys.length()

        while i < len:
            var key = keys[i]
            var child = children[key]
            var next_str = current + key
            trie_wildcard_search_helper(child, pattern, p_index + 1, next_str, results)
            i = i + 1
    elif ch == "*":
        trie_wildcard_star_helper(node, pattern, p_index, current, results)
    else:
        if children.has_key(ch):
            var child = children[ch]
            var next_str = current + ch
            trie_wildcard_search_helper(child, pattern, p_index + 1, next_str, results)

    nil

# Helper function for * wildcard matching
# Args:
#   node: Current trie node
#   pattern: Pattern to match
#   p_index: Current position in pattern (at *)
#   current: Current string built so far
#   results: List to append results to
# Returns: nil
fn trie_wildcard_star_helper(node, pattern, p_index, current, results):
    trie_wildcard_search_helper(node, pattern, p_index + 1, current, results)

    var children = node["children"]
    var keys = children.keys()
    var i = 0
    var len = keys.length()

    while i < len:
        var key = keys[i]
        var child = children[key]
        var next_str = current + key
        trie_wildcard_star_helper(child, pattern, p_index, next_str, results)
        i = i + 1

    nil

# Finds words matching a specific pattern (exact length with ?)
# Args:
#   trie: The trie root node
#   pattern: Pattern with ? for any character
# Returns: List of matching words
fn trie_words_with_pattern(trie, pattern):
    trie_wildcard_search(trie, pattern)

# Finds all words ending with a specific suffix
# Args:
#   trie: The trie root node
#   suffix: The suffix to search for
# Returns: List of words ending with the suffix
fn trie_words_ending_with(trie, suffix):
    var all_words = trie_all_words(trie)
    var results = []
    var i = 0
    var len = all_words.length()
    var suffix_len = suffix.length()

    while i < len:
        var word = all_words[i]
        var word_len = word.length()
        if word_len >= suffix_len:
            var word_suffix = word.slice(word_len - suffix_len, word_len)
            if word_suffix == suffix:
                results.append(word)
        i = i + 1

    results

# Finds all words containing a substring
# Args:
#   trie: The trie root node
#   substring: The substring to search for
# Returns: List of words containing the substring
fn trie_words_containing(trie, substring):
    var all_words = trie_all_words(trie)
    var results = []
    var i = 0
    var len = all_words.length()

    while i < len:
        var word = all_words[i]
        if word.contains(substring):
            results.append(word)
        i = i + 1

    results

# Finds all anagrams of a word in the trie
# Args:
#   trie: The trie root node
#   word: The word to find anagrams of
# Returns: List of anagrams found in the trie
fn trie_find_anagrams(trie, word):
    var sorted_word = trie_sort_chars(word)
    var all_words = trie_all_words(trie)
    var results = []
    var i = 0
    var len = all_words.length()

    while i < len:
        var candidate = all_words[i]
        if candidate.length() == word.length():
            var sorted_candidate = trie_sort_chars(candidate)
            if sorted_candidate == sorted_word:
                results.append(candidate)
        i = i + 1

    results

# Helper function to sort characters in a string
# Args:
#   str: String to sort
# Returns: String with characters sorted
fn trie_sort_chars(str):
    var chars = []
    var i = 0
    var len = str.length()

    while i < len:
        chars.append(str.char_at(i))
        i = i + 1

    chars.sort()
    var result = ""
    var j = 0
    var chars_len = chars.length()

    while j < chars_len:
        result = result + chars[j]
        j = j + 1

    result

# Finds the closest matching word using edit distance
# Args:
#   trie: The trie root node
#   word: The word to find matches for
#   max_distance: Maximum edit distance allowed
# Returns: List of words within the edit distance
fn trie_fuzzy_search(trie, word, max_distance):
    var all_words = trie_all_words(trie)
    var results = []
    var i = 0
    var len = all_words.length()

    while i < len:
        var candidate = all_words[i]
        var distance = trie_edit_distance(word, candidate)
        if distance <= max_distance:
            results.append(candidate)
        i = i + 1

    results

# Computes Levenshtein edit distance between two strings
# Args:
#   str1: First string
#   str2: Second string
# Returns: Edit distance
fn trie_edit_distance(str1, str2):
    var len1 = str1.length()
    var len2 = str2.length()

    if len1 == 0:
        return len2
    if len2 == 0:
        return len1

    var matrix = []
    var i = 0

    while i <= len1:
        var row = []
        var j = 0
        while j <= len2:
            row.append(0)
            j = j + 1
        matrix.append(row)
        i = i + 1

    var x = 0
    while x <= len1:
        matrix[x][0] = x
        x = x + 1

    var y = 0
    while y <= len2:
        matrix[0][y] = y
        y = y + 1

    var m = 1
    while m <= len1:
        var n = 1
        while n <= len2:
            var cost = 1
            if str1.char_at(m - 1) == str2.char_at(n - 1):
                cost = 0

            var deletion = matrix[m - 1][n] + 1
            var insertion = matrix[m][n - 1] + 1
            var substitution = matrix[m - 1][n - 1] + cost

            var min_val = deletion
            if insertion < min_val:
                min_val = insertion
            if substitution < min_val:
                min_val = substitution

            matrix[m][n] = min_val
            n = n + 1
        m = m + 1

    matrix[len1][len2]

# Checks multiple words for existence
# Args:
#   trie: The trie root node
#   words: List of words to check
# Returns: List of booleans indicating existence
fn trie_contains_batch(trie, words):
    var results = []
    var i = 0
    var len = words.length()

    while i < len:
        results.append(trie_contains(trie, words[i]))
        i = i + 1

    results

# Checks if a trie contains any word from a list
# Args:
#   trie: The trie root node
#   words: List of words to check
# Returns: true if any word exists in trie, false otherwise
fn trie_contains_any(trie, words):
    var i = 0
    var len = words.length()

    while i < len:
        if trie_contains(trie, words[i]):
            return true
        i = i + 1

    false

# Checks if a trie contains all words from a list
# Args:
#   trie: The trie root node
#   words: List of words to check
# Returns: true if all words exist in trie, false otherwise
fn trie_contains_all(trie, words):
    var i = 0
    var len = words.length()

    while i < len:
        if not trie_contains(trie, words[i]):
            return false
        i = i + 1

    true

# Forward declaration for trie_all_words (defined in traversal.spl)
fn trie_all_words(trie):
    var results = []
    trie_collect_words(trie, "", results)
    results

# Forward declaration for trie_collect_words (defined in traversal.spl)
fn trie_collect_words(node, current, results):
    if node["is_end"]:
        results.append(current)

    var children = node["children"]
    var keys = children.keys()
    var i = 0
    var len = keys.length()

    while i < len:
        var ch = keys[i]
        var child = children[ch]
        var next_str = current + ch
        trie_collect_words(child, next_str, results)
        i = i + 1

    nil
