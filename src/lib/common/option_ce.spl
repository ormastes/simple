# Standard Library — Option CE Builder
#
# @tag:api
# @tag:stdlib
#
# Option computation expression builder.
# Provides monadic bind/return/zero for Option-style null propagation.
#
# Convention: nil = None (absent), non-nil = Some(value).
# bind short-circuits on nil — passes Some values to continuation.
#
# Usage (via `ce option:` block syntax):
#   val name = ce option:
#       bind user = find_user(id)
#       bind profile = load_profile(user.profile_id)
#       profile.display_name
#
# Or direct:
#   val name = option_ce_bind(find_user(id), fn(user):
#       option_ce_bind(load_profile(user.profile_id), fn(profile):
#           option_ce_return(profile.display_name)
#       )
#   )

# Bind: if value is nil (None), short-circuit.
# Otherwise pass to continuation.
fn option_ce_bind(value, continuation: fn()):
    if value == nil:
        return nil
    continuation(value)

# Return: lift a value into the Option context (identity).
fn option_ce_return(value):
    value

# Zero: nil (None).
fn option_ce_zero():
    nil

# Or-else: if value is nil, use the alternative.
fn option_ce_or_else(value, alternative: fn()):
    if value != nil:
        return value
    alternative()

# Map: transform a Some value, preserve None.
fn option_ce_map(value, transform: fn()):
    if value == nil:
        return nil
    transform(value)

# Filter: if predicate fails, turn Some into None.
fn option_ce_filter(value, predicate: fn() -> bool):
    if value == nil:
        return nil
    if predicate(value):
        return value
    nil

export option_ce_bind, option_ce_return, option_ce_zero
export option_ce_or_else, option_ce_map, option_ce_filter
