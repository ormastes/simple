# Suffix Tree Utilities Module

# ============================================================================
# Utility Functions
# ============================================================================

fn suffix_tree_size(tree: (text, list, i64)) -> i64:
    """Get number of nodes in the tree"""
    list_length(tree.1)

fn suffix_tree_height(tree: (text, list, i64)) -> i64:
    """Get height of the tree"""
    suffix_tree_node_height(tree, tree.2)

fn suffix_tree_node_height(tree: (text, list, i64), node_id: i64) -> i64:
    """Get height of subtree rooted at node_id"""
    val nodes = tree.1
    val node = list_get(nodes, node_id)
    val children = node.2

    if list_length(children) == 0:
        return 0

    var max_height = 0
    var child_idx = 0

    while child_idx < list_length(children):
        val child_entry = list_get(children, child_idx)
        val child_id = child_entry.1
        val child_height = suffix_tree_node_height(tree, child_id)

        if child_height > max_height:
            max_height = child_height

        child_idx = child_idx + 1

    max_height + 1

fn suffix_tree_num_leaves(tree: (text, list, i64)) -> i64:
    """Count number of leaf nodes"""
    suffix_tree_count_leaves(tree, tree.2)

fn suffix_tree_count_leaves(tree: (text, list, i64), node_id: i64) -> i64:
    """Count leaves in subtree rooted at node_id"""
    val nodes = tree.1
    val node = list_get(nodes, node_id)
    val children = node.2

    if list_length(children) == 0:
        return 1

    var count = 0
    var child_idx = 0

    while child_idx < list_length(children):
        val child_entry = list_get(children, child_idx)
        val child_id = child_entry.1
        count = count + suffix_tree_count_leaves(tree, child_id)
        child_idx = child_idx + 1

    count

fn suffix_tree_node_depth(tree: (text, list, i64), node_id: i64) -> i64:
    """Get string depth (length of path from root) to node"""
    val nodes = tree.1
    val node = list_get(nodes, node_id)

    if node_id == tree.2:
        return 0

    val edge_start = node.0
    val edge_end = node.1
    val edge_len = edge_end - edge_start

    # Find parent and add parent's depth
    var parent_id = suffix_tree_find_parent(tree, node_id)

    if parent_id == -1:
        return edge_len

    val parent_depth = suffix_tree_node_depth(tree, parent_id)
    parent_depth + edge_len

fn suffix_tree_find_parent(tree: (text, list, i64), node_id: i64) -> i64:
    """Find parent of given node"""
    val nodes = tree.1
    var parent_idx = 0

    while parent_idx < list_length(nodes):
        val parent = list_get(nodes, parent_idx)
        val children = parent.2

        var child_idx = 0
        while child_idx < list_length(children):
            val child_entry = list_get(children, child_idx)
            val child_id = child_entry.1

            if child_id == node_id:
                return parent_idx

            child_idx = child_idx + 1

        parent_idx = parent_idx + 1

    -1

fn suffix_tree_path_to_node(tree: (text, list, i64), node_id: i64) -> text:
    """Get string label of path from root to node"""
    if node_id == tree.2:
        return ""

    val nodes = tree.1
    val node = list_get(nodes, node_id)
    val text_val = tree.0

    val edge_start = node.0
    val edge_end = node.1
    val edge_label = text_slice(text_val, edge_start, edge_end)

    val parent_id = suffix_tree_find_parent(tree, node_id)

    if parent_id == -1:
        return edge_label

    val parent_path = suffix_tree_path_to_node(tree, parent_id)
    text_concat(parent_path, edge_label)

fn suffix_tree_get_node(tree: (text, list, i64), node_id: i64) -> (i64, i64, list, any, i64):
    """Get node by ID"""
    list_get(tree.1, node_id)

fn suffix_tree_root(tree: (text, list, i64)) -> (i64, i64, list, any, i64):
    """Get root node"""
    suffix_tree_get_node(tree, tree.2)

# ============================================================================
# Visualization and Debugging
# ============================================================================

fn suffix_tree_to_string(tree: (text, list, i64)) -> text:
    """Convert tree to string representation"""
    val root_id = tree.2
    suffix_tree_node_to_string(tree, root_id, 0)

fn suffix_tree_node_to_string(tree: (text, list, i64), node_id: i64, indent: i64) -> text:
    """Convert node subtree to string with indentation"""
    val nodes = tree.1
    val node = list_get(nodes, node_id)
    val children = node.2

    var result = ""
    var i = 0

    while i < indent:
        result = text_concat(result, "  ")
        i = i + 1

    val path = suffix_tree_path_to_node(tree, node_id)
    result = text_concat(result, "Node ")
    result = text_concat(result, text_from_int(node_id))
    result = text_concat(result, ": ")
    result = text_concat(result, path)
    result = text_concat(result, "\n")

    var child_idx = 0
    while child_idx < list_length(children):
        val child_entry = list_get(children, child_idx)
        val child_id = child_entry.1
        val child_str = suffix_tree_node_to_string(tree, child_id, indent + 1)
        result = text_concat(result, child_str)
        child_idx = child_idx + 1

    result

fn suffix_tree_print(tree: (text, list, i64)):
    """Print tree structure"""
    val str_repr = suffix_tree_to_string(tree)
    print(str_repr)
    pass

fn suffix_tree_validate(tree: (text, list, i64)) -> bool:
    """Validate tree structure integrity"""
    val nodes = tree.1
    val root_id = tree.2

    if root_id < 0:
        return false

    if root_id >= list_length(nodes):
        return false

    # Check all nodes are valid
    var node_idx = 0
    while node_idx < list_length(nodes):
        val node = list_get(nodes, node_idx)
        val children = node.2

        var child_idx = 0
        while child_idx < list_length(children):
            val child_entry = list_get(children, child_idx)
            val child_id = child_entry.1

            if child_id < 0:
                return false

            if child_id >= list_length(nodes):
                return false

            child_idx = child_idx + 1

        node_idx = node_idx + 1

    true

fn suffix_tree_statistics(tree: (text, list, i64)) -> (i64, i64, i64, i64):
    """Get tree statistics (size, height, leaves, internal_nodes)"""
    val size = suffix_tree_size(tree)
    val height = suffix_tree_height(tree)
    val leaves = suffix_tree_num_leaves(tree)
    val internal = size - leaves

    (size, height, leaves, internal)

# ============================================================================
# Helper Functions (Text Operations)
# ============================================================================

fn text_length(s: text) -> i64:
    """Get text length"""
    var len = 0
    var i = 0
    var done = false

    while not done:
        var error = nil
        val ch = text_char_at_safe(s, i, error)
        if error != nil:
            done = true
        else:
            len = len + 1
            i = i + 1

    len

fn text_char_at(s: text, index: i64) -> text:
    """Get character at index"""
    text_slice(s, index, index + 1)

fn text_char_at_safe(s: text, index: i64, error: any) -> text:
    """Get character at index safely"""
    val len = text_length(s)
    if index < 0:
        error = "out of bounds"
        return ""
    if index >= len:
        error = "out of bounds"
        return ""
    text_slice(s, index, index + 1)

fn text_slice(s: text, start: i64, end: i64) -> text:
    """Slice text [start:end)"""
    var result = ""
    var i = start

    while i < end:
        result = text_concat(result, text_char_at(s, i))
        i = i + 1

    result

fn text_slice_from(s: text, start: i64) -> text:
    """Slice text from start to end"""
    val len = text_length(s)
    text_slice(s, start, len)

fn text_concat(s1: text, s2: text) -> text:
    """Concatenate two texts"""
    "{s1}{s2}"

fn text_compare(s1: text, s2: text) -> i64:
    """Compare two texts (-1: s1<s2, 0: equal, 1: s1>s2)"""
    val len1 = text_length(s1)
    val len2 = text_length(s2)
    val min_len = if len1 < len2: len1 else: len2

    var i = 0
    while i < min_len:
        val c1 = text_char_at(s1, i)
        val c2 = text_char_at(s2, i)

        if c1 < c2:
            return -1
        if c1 > c2:
            return 1

        i = i + 1

    if len1 < len2:
        return -1
    if len1 > len2:
        return 1
    0

fn text_contains(s: text, substring: text) -> bool:
    """Check if text contains substring"""
    val len = text_length(s)
    val sub_len = text_length(substring)

    if sub_len > len:
        return false

    var i = 0
    while i <= len - sub_len:
        var match = true
        var j = 0

        while j < sub_len:
            val c1 = text_char_at(s, i + j)
            val c2 = text_char_at(substring, j)

            if c1 != c2:
                match = false
                j = sub_len

            j = j + 1

        if match:
            return true

        i = i + 1

    false

fn text_common_prefix_length(s1: text, s2: text) -> i64:
    """Get length of common prefix"""
    val len1 = text_length(s1)
    val len2 = text_length(s2)
    val min_len = if len1 < len2: len1 else: len2

    var i = 0
    while i < min_len:
        val c1 = text_char_at(s1, i)
        val c2 = text_char_at(s2, i)

        if c1 != c2:
            return i

        i = i + 1

    min_len

fn text_split(s: text, delimiter: text) -> list:
    """Split text by delimiter"""
    var parts = []
    var current = ""
    val len = text_length(s)
    val del_len = text_length(delimiter)
    var i = 0

    while i < len:
        var is_delimiter = true
        var j = 0

        while j < del_len:
            if i + j >= len:
                is_delimiter = false
                j = del_len
            else:
                val c1 = text_char_at(s, i + j)
                val c2 = text_char_at(delimiter, j)

                if c1 != c2:
                    is_delimiter = false
                    j = del_len

            j = j + 1

        if is_delimiter:
            parts = list_append(parts, current)
            current = ""
            i = i + del_len
        else:
            current = text_concat(current, text_char_at(s, i))
            i = i + 1

    if text_length(current) > 0:
        parts = list_append(parts, current)

    parts

fn text_from_char(c: text) -> text:
    """Convert single char to text"""
    c

fn text_from_int(n: i64) -> text:
    """Convert integer to text"""
    if n == 0:
        return "0"

    if n < 0:
        return text_concat("-", text_from_int(0 - n))

    var digits = ""
    var num = n

    while num > 0:
        val digit = num % 10
        val digit_char = if digit == 0: "0"
            else: if digit == 1: "1"
            else: if digit == 2: "2"
            else: if digit == 3: "3"
            else: if digit == 4: "4"
            else: if digit == 5: "5"
            else: if digit == 6: "6"
            else: if digit == 7: "7"
            else: if digit == 8: "8"
            else: "9"

        digits = text_concat(digit_char, digits)
        num = num / 10

    digits

# ============================================================================
# List Helper Functions
# ============================================================================

fn list_length(lst: list) -> i64:
    """Get list length"""
    var len = 0
    var i = 0
    var done = false

    while not done:
        var error = nil
        val item = list_get_safe(lst, i, error)
        if error != nil:
            done = true
        else:
            len = len + 1
            i = i + 1

    len

fn list_get(lst: list, index: i64) -> any:
    """Get list item at index"""
    lst[index]

fn list_get_safe(lst: list, index: i64, error: any) -> any:
    """Get list item safely"""
    val len = list_length(lst)
    if index < 0:
        error = "out of bounds"
        return nil
    if index >= len:
        error = "out of bounds"
        return nil
    lst[index]

fn list_set(lst: list, index: i64, value: any) -> list:
    """Set list item at index"""
    var new_list = []
    var i = 0
    val len = list_length(lst)

    while i < len:
        if i == index:
            new_list = list_append(new_list, value)
        else:
            new_list = list_append(new_list, list_get(lst, i))
        i = i + 1

    new_list

fn list_append(lst: list, item: any) -> list:
    """Append item to list"""
    [*lst, item]

fn list_concat(lst1: list, lst2: list) -> list:
    """Concatenate two lists"""
    var result = lst1
    var i = 0
    val len = list_length(lst2)

    while i < len:
        result = list_append(result, list_get(lst2, i))
        i = i + 1

    result

fn suffix_tree_memory_estimate(tree: (text, list, i64)) -> i64:
    """Estimate memory usage of suffix tree in bytes (approximate)"""
    val text_len = text_length(tree.0)
    val num_nodes = suffix_tree_size(tree)
    val text_bytes = text_len * 8
    val node_bytes = num_nodes * 64
    text_bytes + node_bytes

# Export all public functions
