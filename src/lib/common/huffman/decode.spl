# Huffman Decoding Module
# Decoding operations

import huffman.types

# ============================================================================
# DECODING
# ============================================================================

fn huffman_decode_symbol(tree, bits, start_pos):
    """Decode one symbol from bit string, returns (symbol, next_position)"""
    var node = tree
    var pos = start_pos
    val bits_len = string_length(bits)

    while pos < bits_len:
        val is_leaf = huffman_is_leaf(node)
        if is_leaf:
            val symbol = huffman_get_symbol(node)
            return (symbol, pos)

        val bit = string_char_at(bits, pos)
        if bit == HUFFMAN_BIT_ZERO:
            node = huffman_get_left(node)
        else:
            node = huffman_get_right(node)

        pos = pos + 1

    val is_leaf = huffman_is_leaf(node)
    if is_leaf:
        val symbol = huffman_get_symbol(node)
        (symbol, pos)
    else:
        (-1, pos)

fn huffman_decode_data(tree, bits):
    """Decode bit string using Huffman tree"""
    var result = []
    var pos = 0
    val bits_len = string_length(bits)

    while pos < bits_len:
        val decoded = huffman_decode_symbol(tree, bits, pos)
        val symbol = decoded[0]
        val next_pos = decoded[1]

        if symbol == -1:
            return nil

        result = array_append(result, symbol)
        pos = next_pos

    result

fn huffman_decode(tree, bits):
    """Full decoding pipeline: decode bits to symbol array"""
    huffman_decode_data(tree, bits)

fn huffman_symbols_to_string(symbols):
    """Convert symbol array to string"""
    var result = ""
    var i = 0
    val symbols_len = array_length(symbols)

    while i < symbols_len:
        val symbol = array_get(symbols, i)
        val char_str = string_from_byte(symbol)
        result = string_concat(result, char_str)
        i = i + 1

    result
