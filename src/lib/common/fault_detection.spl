# Fault Detection
#
# Shared fault detection for stack overflow and timeout detection
# across interpreter and compiled modes.
#
# Port of rust/common/src/fault_detection.rs
# Note: Rust uses atomics; Simple uses module-level mutable state.
# Thread safety is provided by the runtime's GIL or per-actor isolation.

# ============================================================================
# Stack Overflow Detection
# ============================================================================

var recursion_depth: i64 = 0
var max_recursion_depth: i64 = 1000
var stack_overflow_detection_enabled: bool = true

fn set_stack_overflow_detection_enabled(enabled: bool):
    """Enable or disable stack overflow detection."""
    stack_overflow_detection_enabled = enabled

fn is_stack_overflow_detection_enabled() -> bool:
    stack_overflow_detection_enabled

fn set_max_recursion_depth(depth: i64):
    """Set the maximum recursion depth limit."""
    max_recursion_depth = depth

fn get_max_recursion_depth() -> i64:
    max_recursion_depth

fn reset_recursion_depth():
    """Reset the recursion counter to zero."""
    recursion_depth = 0

fn increment_recursion_depth() -> bool:
    """Increment depth counter. Returns false if limit exceeded."""
    if not stack_overflow_detection_enabled:
        return true
    recursion_depth = recursion_depth + 1
    recursion_depth <= max_recursion_depth

fn decrement_recursion_depth():
    """Decrement depth counter (floor at 0)."""
    if recursion_depth > 0:
        recursion_depth = recursion_depth - 1

fn current_recursion_depth() -> i64:
    recursion_depth

# ============================================================================
# Timeout Detection
# ============================================================================

var timeout_exceeded: bool = false

fn is_timeout_exceeded() -> bool:
    """Check if timeout has been exceeded (set by watchdog thread)."""
    timeout_exceeded

fn set_timeout_exceeded():
    """Mark timeout as exceeded."""
    timeout_exceeded = true

fn reset_timeout():
    """Reset timeout flag."""
    timeout_exceeded = false

# ============================================================================
# Combined Check
# ============================================================================

enum FaultKind:
    """Type of fault detected."""
    StackOverflow(depth: i64, limit: i64)
    Timeout

fn check_faults() -> FaultKind?:
    """Check for any active fault condition."""
    if timeout_exceeded:
        return Some(FaultKind.Timeout)
    if stack_overflow_detection_enabled and recursion_depth > max_recursion_depth:
        return Some(FaultKind.StackOverflow(
            depth: recursion_depth,
            limit: max_recursion_depth
        ))
    nil

export FaultKind
export set_stack_overflow_detection_enabled, is_stack_overflow_detection_enabled
export set_max_recursion_depth, get_max_recursion_depth, reset_recursion_depth
export increment_recursion_depth, decrement_recursion_depth, current_recursion_depth
export is_timeout_exceeded, set_timeout_exceeded, reset_timeout
export check_faults
