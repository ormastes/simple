# Rope Search and Comparison Module
# Functions for searching and comparing ropes

# ============================================================================
# INDEXING AND ACCESS
# ============================================================================

fn rope_char_at(node: any, index: i64) -> text:
    # Get character at index (O(log n))
    if node == nil:
        return ""

    var len = rope_length(node)
    if index < 0 or index >= len:
        return ""

    if rope_is_leaf(node):
        var value = node.4
        return value.substring(index, index + 1)

    # Concat node: search left or right
    var weight = node.1
    var left = node.2
    var right = node.3

    if index < weight:
        return rope_char_at(left, index)

    var right_index = index - weight
    rope_char_at(right, right_index)

fn rope_substring(node: any, start: i64, end: i64) -> text:
    # Extract substring from rope
    if node == nil:
        return ""

    var len = rope_length(node)
    if start < 0:
        start = 0
    if end > len:
        end = len
    if start >= end:
        return ""

    # Extract by splitting and converting
    var parts = rope_split_at(node, start)
    var left = parts.0
    var middle_right = parts.1

    var sub_len = end - start
    var parts2 = rope_split_at(middle_right, sub_len)
    var middle = parts2.0

    rope_to_string(middle)

# ============================================================================
# SEARCH OPERATIONS
# ============================================================================

fn rope_find(node: any, pattern: text) -> i64:
    # Find first occurrence of pattern, return index or -1
    var s = rope_to_string(node)
    s.index_of(pattern)

fn rope_find_all(node: any, pattern: text) -> any:
    # Find all occurrences of pattern, return list of indices
    var s = rope_to_string(node)
    var result = []
    var pos = 0

    while pos < s.length():
        var found = s.substring(pos, s.length()).index_of(pattern)
        if found == -1:
            return result

        var index = pos + found
        result = result.append(index)
        pos = index + pattern.length()

    result

fn rope_contains(node: any, pattern: text) -> bool:
    # Check if rope contains pattern
    var index = rope_find(node, pattern)
    index != -1

fn rope_starts_with(node: any, prefix: text) -> bool:
    # Check if rope starts with prefix
    var len = prefix.length()
    if len == 0:
        return true

    var rope_len = rope_length(node)
    if len > rope_len:
        return false

    var substr = rope_substring(node, 0, len)
    substr == prefix

fn rope_ends_with(node: any, suffix: text) -> bool:
    # Check if rope ends with suffix
    var len = suffix.length()
    if len == 0:
        return true

    var rope_len = rope_length(node)
    if len > rope_len:
        return false

    var start = rope_len - len
    var substr = rope_substring(node, start, rope_len)
    substr == suffix

# ============================================================================
# COMPARISON OPERATIONS
# ============================================================================

fn rope_equals(a: any, b: any) -> bool:
    # Check if two ropes are equal
    if a == nil and b == nil:
        return true
    if a == nil or b == nil:
        return false

    var len_a = rope_length(a)
    var len_b = rope_length(b)

    if len_a != len_b:
        return false

    var str_a = rope_to_string(a)
    var str_b = rope_to_string(b)

    str_a == str_b

fn rope_compare(a: any, b: any) -> i64:
    # Compare two ropes lexicographically
    # Returns: -1 if a < b, 0 if a == b, 1 if a > b
    var str_a = rope_to_string(a)
    var str_b = rope_to_string(b)

    if str_a < str_b:
        return -1
    if str_a > str_b:
        return 1
    0
