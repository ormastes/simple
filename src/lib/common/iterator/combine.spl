# Iterator Combination
#
# Functions for combining multiple iterators.

import iterator/types (iter_next_internal)
import iterator/create (iter_from_array)
import iterator/reduce (iter_collect)

export iter_zip, iter_chain, iter_interleave
export iter_cartesian_product, iter_product_with
export iter_merge, iter_merge_with

fn iter_zip(iter1, iter2):
    """Zip two iterators into tuples. Stops when either exhausts.

    Example:
        val it1 = iter_from_array([1, 2, 3])
        val it2 = iter_from_array([4, 5, 6])
        iter_collect(iter_zip(it1, it2))  # [(1, 4), (2, 5), (3, 6)]
    """
    var result = []
    var continue = true

    while continue:
        val next1 = iter_next_internal(iter1)
        val elem1 = next1[0]
        val has1 = next1[1]

        val next2 = iter_next_internal(iter2)
        val elem2 = next2[0]
        val has2 = next2[1]

        if has1 and has2:
            result.push((elem1, elem2))
        else:
            continue = false

    iter_from_array(result)

fn iter_chain(iter1, iter2):
    """Chain two iterators together.

    Example:
        val it1 = iter_from_array([1, 2])
        val it2 = iter_from_array([3, 4])
        iter_collect(iter_chain(it1, it2))  # [1, 2, 3, 4]
    """
    var result = []

    # Consume first iterator
    var continue = true
    while continue:
        val next_result = iter_next_internal(iter1)
        val elem = next_result[0]
        val has_more = next_result[1]

        if has_more:
            result.push(elem)
        else:
            continue = false

    # Consume second iterator
    continue = true
    while continue:
        val next_result = iter_next_internal(iter2)
        val elem = next_result[0]
        val has_more = next_result[1]

        if has_more:
            result.push(elem)
        else:
            continue = false

    iter_from_array(result)

fn iter_interleave(iter1, iter2):
    """Interleave elements from two iterators alternately.

    Continues until both are exhausted.

    Example:
        val it1 = iter_from_array([1, 2, 3])
        val it2 = iter_from_array([10, 20])
        iter_collect(iter_interleave(it1, it2))  # [1, 10, 2, 20, 3]
    """
    var result = []
    var continue = true
    var toggle = true

    while continue:
        if toggle:
            val next1 = iter_next_internal(iter1)
            val elem1 = next1[0]
            val has1 = next1[1]

            if has1:
                result.push(elem1)

            toggle = false
        else:
            val next2 = iter_next_internal(iter2)
            val elem2 = next2[0]
            val has2 = next2[1]

            if has2:
                result.push(elem2)

            toggle = true

        # Check if both exhausted
        val peek1 = iter_next_internal(iter1)
        val has_more1 = peek1[1]
        val peek2 = iter_next_internal(iter2)
        val has_more2 = peek2[1]

        if not has_more1 and not has_more2:
            continue = false
        else:
            # Put back peeked elements
            if has_more1:
                iter1["index"] = iter1["index"] - 1
            if has_more2:
                iter2["index"] = iter2["index"] - 1

    iter_from_array(result)

fn iter_cartesian_product(iter1, iter2):
    """Compute cartesian product of two iterators.

    Returns iterator of tuples (a, b) for all a in iter1, b in iter2.

    Example:
        val it1 = iter_from_array([1, 2])
        val it2 = iter_from_array([3, 4])
        iter_collect(iter_cartesian_product(it1, it2))
        # [(1, 3), (1, 4), (2, 3), (2, 4)]
    """
    val items1 = iter_collect(iter1)
    val items2 = iter_collect(iter2)
    var result = []

    for item1 in items1:
        for item2 in items2:
            result.push((item1, item2))

    iter_from_array(result)

fn iter_product_with(iter1, iter2, f):
    """Compute cartesian product and apply function to each pair.

    Example:
        val it1 = iter_from_array([1, 2])
        val it2 = iter_from_array([3, 4])
        iter_collect(iter_product_with(it1, it2, \a, b: a + b))
        # [4, 5, 5, 6]
    """
    val items1 = iter_collect(iter1)
    val items2 = iter_collect(iter2)
    var result = []

    for item1 in items1:
        for item2 in items2:
            result.push(f(item1, item2))

    iter_from_array(result)

fn iter_merge(iter1, iter2):
    """Merge two sorted iterators maintaining sort order.

    Assumes both iterators are already sorted.

    Example:
        val it1 = iter_from_array([1, 3, 5])
        val it2 = iter_from_array([2, 4, 6])
        iter_collect(iter_merge(it1, it2))  # [1, 2, 3, 4, 5, 6]
    """
    var result = []
    var next1 = iter_next_internal(iter1)
    var elem1 = next1[0]
    var has1 = next1[1]
    var next2 = iter_next_internal(iter2)
    var elem2 = next2[0]
    var has2 = next2[1]

    while has1 and has2:
        if elem1 <= elem2:
            result.push(elem1)
            next1 = iter_next_internal(iter1)
            elem1 = next1[0]
            has1 = next1[1]
        else:
            result.push(elem2)
            next2 = iter_next_internal(iter2)
            elem2 = next2[0]
            has2 = next2[1]

    # Consume remaining elements
    if has1:
        result.push(elem1)
        var continue = true
        while continue:
            val next_result = iter_next_internal(iter1)
            val elem = next_result[0]
            val has_more = next_result[1]
            if has_more:
                result.push(elem)
            else:
                continue = false

    if has2:
        result.push(elem2)
        var continue = true
        while continue:
            val next_result = iter_next_internal(iter2)
            val elem = next_result[0]
            val has_more = next_result[1]
            if has_more:
                result.push(elem)
            else:
                continue = false

    iter_from_array(result)

fn iter_merge_with(iter1, iter2, compare_fn):
    """Merge two iterators using custom comparison function.

    compare_fn(a, b) should return true if a should come before b.

    Example:
        val it1 = iter_from_array([5, 3, 1])
        val it2 = iter_from_array([6, 4, 2])
        iter_collect(iter_merge_with(it1, it2, \a, b: a > b))
        # [6, 5, 4, 3, 2, 1]
    """
    var result = []
    var next1 = iter_next_internal(iter1)
    var elem1 = next1[0]
    var has1 = next1[1]
    var next2 = iter_next_internal(iter2)
    var elem2 = next2[0]
    var has2 = next2[1]

    while has1 and has2:
        if compare_fn(elem1, elem2):
            result.push(elem1)
            next1 = iter_next_internal(iter1)
            elem1 = next1[0]
            has1 = next1[1]
        else:
            result.push(elem2)
            next2 = iter_next_internal(iter2)
            elem2 = next2[0]
            has2 = next2[1]

    # Consume remaining
    if has1:
        result.push(elem1)
        var continue = true
        while continue:
            val next_result = iter_next_internal(iter1)
            val elem = next_result[0]
            val has_more = next_result[1]
            if has_more:
                result.push(elem)
            else:
                continue = false

    if has2:
        result.push(elem2)
        var continue = true
        while continue:
            val next_result = iter_next_internal(iter2)
            val elem = next_result[0]
            val has_more = next_result[1]
            if has_more:
                result.push(elem)
            else:
                continue = false

    iter_from_array(result)
