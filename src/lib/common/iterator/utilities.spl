# Iterator Utilities
#
# Utility functions for inspecting and working with iterators.

import iterator/types (iter_next_internal)
import iterator/create (iter_from_array, iter_empty)
import iterator/reduce (iter_collect, iter_count)

export iter_chunk, iter_window
export iter_peek, iter_inspect, iter_for_each
export iter_len, iter_empty?, iter_single?

fn iter_chunk(iter, size):
    """Split iterator into chunks of given size.

    Last chunk may be smaller.

    Example:
        val it = iter_from_array([1, 2, 3, 4, 5])
        iter_collect(iter_chunk(it, 2))  # [[1, 2], [3, 4], [5]]
    """
    if size <= 0:
        return iter_empty()

    var result = []
    var current_chunk = []
    var continue = true

    while continue:
        val next_result = iter_next_internal(iter)
        val elem = next_result[0]
        val has_more = next_result[1]

        if has_more:
            current_chunk.push(elem)
            if current_chunk.len() == size:
                result.push(current_chunk)
                current_chunk = []
        else:
            if current_chunk.len() > 0:
                result.push(current_chunk)
            continue = false

    iter_from_array(result)

fn iter_window(iter, size):
    """Create sliding windows of given size.

    Example:
        val it = iter_from_array([1, 2, 3, 4])
        iter_collect(iter_window(it, 2))  # [[1, 2], [2, 3], [3, 4]]
    """
    if size <= 0:
        return iter_empty()

    val all_items = iter_collect(iter)

    if all_items.len() < size:
        return iter_empty()

    var result = []
    var i = 0
    while i <= all_items.len() - size:
        var window = []
        var j = 0
        while j < size:
            window.push(all_items[i + j])
            j = j + 1
        result.push(window)
        i = i + 1

    iter_from_array(result)

fn iter_peek(iter, action):
    """Execute action on each element while passing through.

    Useful for debugging and logging.

    Example:
        val it = iter_from_array([1, 2, 3])
        val peeked = iter_peek(it, \x: print("Saw: {x}"))
        iter_collect(peeked)  # [1, 2, 3] (with print side effects)
    """
    var result = []
    var continue = true

    while continue:
        val next_result = iter_next_internal(iter)
        val elem = next_result[0]
        val has_more = next_result[1]

        if has_more:
            action(elem)
            result.push(elem)
        else:
            continue = false

    iter_from_array(result)

fn iter_inspect(iter, action):
    """Alias for iter_peek. Execute action on each element.

    Example:
        val it = iter_from_array([1, 2, 3])
        val inspected = iter_inspect(it, \x: print(x))
        iter_collect(inspected)  # [1, 2, 3] (with print side effects)
    """
    iter_peek(iter, action)

fn iter_for_each(iter, action):
    """Execute action on each element (consuming iterator).

    Example:
        val it = iter_from_array([1, 2, 3])
        iter_for_each(it, \x: print(x))  # Prints 1, 2, 3
    """
    var continue = true

    while continue:
        val next_result = iter_next_internal(iter)
        val elem = next_result[0]
        val has_more = next_result[1]

        if has_more:
            action(elem)
        else:
            continue = false

    nil

fn iter_len(iter):
    """Get length by consuming iterator.

    Alias for iter_count.

    Example:
        val it = iter_from_array([1, 2, 3, 4, 5])
        iter_len(it)  # 5
    """
    iter_count(iter)

fn iter_empty?(iter):
    """Check if iterator is empty without consuming.

    Example:
        val it = iter_empty()
        iter_empty?(it)  # true
    """
    iter["done"]

fn iter_single?(iter):
    """Check if iterator has exactly one element.

    Example:
        val it = iter_from_array([42])
        iter_single?(it)  # true
    """
    val items = iter_collect(iter)
    items.len() == 1
