# Type Conversion Functions
#
# Provides type conversion utilities for parsing and converting between types.
# Pure Simple implementation - no external dependencies.
#
# Functions:
# - digit_value: Get numeric value of a digit character
# - safe_parse_int: Safely parse text to integer (returns 0 on failure)
# - parse_u16: Parse text to unsigned 16-bit integer (0..65535)
# - parse_u32: Parse text to unsigned 32-bit integer (0..4294967295)
# - parse_u64: Parse text to unsigned 64-bit integer (0..i64 max)
# - i64_to_usize: Convert i64 to usize (clamps negatives to 0)
# - usize_to_i64: Convert usize to i64 (identity on this runtime)

# ============================================================================
# Helper: Digit Value Lookup
# ============================================================================

fn digit_value(ch: text) -> i64:
    """Get the numeric value of a digit character. Returns -1 for non-digits."""
    if ch == "0": return 0
    if ch == "1": return 1
    if ch == "2": return 2
    if ch == "3": return 3
    if ch == "4": return 4
    if ch == "5": return 5
    if ch == "6": return 6
    if ch == "7": return 7
    if ch == "8": return 8
    if ch == "9": return 9
    return -1

# ============================================================================
# Safe Integer Parsing
# ============================================================================

fn safe_parse_int(s: text) -> i64:
    """Safely parse text to i64. Returns 0 for invalid input."""
    val trimmed = s.trim()
    if trimmed.len() == 0:
        return 0
    var start = 0
    var negative = false
    if trimmed[0] == "-":
        negative = true
        start = 1
    if start >= trimmed.len():
        return 0
    var result = 0
    var i = start
    while i < trimmed.len():
        val d = digit_value(trimmed[i])
        if d < 0:
            return 0
        result = result * 10 + d
        i = i + 1
    if negative:
        return -result
    result

# ============================================================================
# Unsigned Integer Parsing
# ============================================================================

fn parse_u16(s: text) -> i64:
    """Parse text as unsigned 16-bit integer. Returns 0 for invalid or out-of-range input."""
    val num = safe_parse_int(s)
    if num < 0 or num > 65535:
        0
    else:
        num

fn parse_u32(s: text) -> i64:
    """Parse text as unsigned 32-bit integer. Returns 0 for invalid or out-of-range input."""
    val num = safe_parse_int(s)
    if num < 0 or num > 4294967295:
        0
    else:
        num

fn parse_u64(s: text) -> i64:
    """Parse text as unsigned 64-bit integer. Limited to i64 max. Returns 0 for invalid input."""
    val num = safe_parse_int(s)
    if num < 0:
        0
    else:
        num

# ============================================================================
# Integer Type Conversions
# ============================================================================

fn i64_to_usize(n: i64) -> i64:
    """Convert i64 to usize. Clamps negative values to 0."""
    if n < 0:
        0
    else:
        n

fn usize_to_i64(n: i64) -> i64:
    """Convert usize to i64. Identity operation (runtime uses i64 for all integers)."""
    n

# ============================================================================
# Additional Conversion Utilities
# ============================================================================

fn to_bool(s: text) -> bool:
    """Convert text to boolean. Returns true for 'true', '1', 'yes', 'on'."""
    val lower = s.trim().lower()
    lower == "true" or lower == "1" or lower == "yes" or lower == "on"

fn bool_to_text(b: bool) -> text:
    """Convert boolean to text."""
    if b:
        "true"
    else:
        "false"

fn i64_to_text(n: i64) -> text:
    """Convert i64 to text."""
    "{n}"

fn f64_to_text(n: f64) -> text:
    """Convert f64 to text."""
    "{n}"
