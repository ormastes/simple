# Color Blending and Mixing Functions
#
# Purpose: Color combination and blend modes
#
# Contains:
# - Color mixing (weighted average)
# - Blend modes (multiply, screen, overlay)
# - Color averaging
# - Color schemes (triadic, analogous, etc.)

# ============================================================================
# Color Mixing Functions
# ============================================================================

fn mix(color1: Color, color2: Color, weight: i64) -> Color:
    """Mix two colors with weight (0-100). 0 = all color1, 100 = all color2."""
    val w = clamp(weight, 0, 100)
    val w1 = 100 - w
    val w2 = w

    val r = (color1.r * w1 + color2.r * w2) / 100
    val g = (color1.g * w1 + color2.g * w2) / 100
    val b = (color1.b * w1 + color2.b * w2) / 100
    val a = (color1.a * w1 + color2.a * w2) / 100

    from_rgba(r, g, b, a)

fn blend(color1: Color, color2: Color) -> Color:
    """Blend two colors equally (50/50 mix)."""
    mix(color1, color2, 50)

fn average(colors: [Color]) -> Color:
    """Average multiple colors."""
    if colors.length() == 0:
        return from_rgb(0, 0, 0)

    var total_r = 0
    var total_g = 0
    var total_b = 0
    var total_a = 0

    var i = 0
    while i < colors.length():
        val c = colors[i]
        total_r = total_r + c.r
        total_g = total_g + c.g
        total_b = total_b + c.b
        total_a = total_a + c.a
        i = i + 1

    val count = colors.length()
    val avg_r = total_r / count
    val avg_g = total_g / count
    val avg_b = total_b / count
    val avg_a = total_a / count

    from_rgba(avg_r, avg_g, avg_b, avg_a)

fn multiply(color1: Color, color2: Color) -> Color:
    """Multiply blend mode (darker result)."""
    val r = (color1.r * color2.r) / 255
    val g = (color1.g * color2.g) / 255
    val b = (color1.b * color2.b) / 255
    from_rgb(r, g, b)

fn screen(color1: Color, color2: Color) -> Color:
    """Screen blend mode (lighter result)."""
    val r = 255 - ((255 - color1.r) * (255 - color2.r)) / 255
    val g = 255 - ((255 - color1.g) * (255 - color2.g)) / 255
    val b = 255 - ((255 - color1.b) * (255 - color2.b)) / 255
    from_rgb(r, g, b)

fn overlay(color1: Color, color2: Color) -> Color:
    """Overlay blend mode (combination of multiply and screen)."""
    var r = 0
    if color1.r < 128:
        r = (2 * color1.r * color2.r) / 255
    else:
        r = 255 - (2 * (255 - color1.r) * (255 - color2.r)) / 255

    var g = 0
    if color1.g < 128:
        g = (2 * color1.g * color2.g) / 255
    else:
        g = 255 - (2 * (255 - color1.g) * (255 - color2.g)) / 255

    var b = 0
    if color1.b < 128:
        b = (2 * color1.b * color2.b) / 255
    else:
        b = 255 - (2 * (255 - color1.b) * (255 - color2.b)) / 255

    from_rgb(r, g, b)

# ============================================================================
# Color Scheme Functions
# ============================================================================

fn complement(color: Color) -> Color:
    """Get complementary color (opposite on color wheel)."""
    adjust_hue(color, 180)

fn triadic(color: Color) -> [Color]:
    """Get triadic color scheme (3 colors equally spaced)."""
    val color2 = adjust_hue(color, 120)
    val color3 = adjust_hue(color, 240)
    [color, color2, color3]

fn analogous(color: Color) -> [Color]:
    """Get analogous color scheme (3 adjacent colors)."""
    val color2 = adjust_hue(color, 30)
    val color3 = adjust_hue(color, -30)
    [color3, color, color2]

fn split_complement(color: Color) -> [Color]:
    """Get split complementary scheme."""
    val comp = complement(color)
    val color2 = adjust_hue(comp, 30)
    val color3 = adjust_hue(comp, -30)
    [color, color2, color3]

fn tetradic(color: Color) -> [Color]:
    """Get tetradic/rectangular color scheme (4 colors)."""
    val color2 = adjust_hue(color, 90)
    val color3 = adjust_hue(color, 180)
    val color4 = adjust_hue(color, 270)
    [color, color2, color3, color4]

fn monochromatic(color: Color) -> [Color]:
    """Get monochromatic scheme (variations in lightness)."""
    val dark = darken(color, 30)
    val darker = darken(color, 15)
    val lighter = lighten(color, 15)
    val light = lighten(color, 30)
    [dark, darker, color, lighter, light]

# ============================================================================
# Helper Functions
# ============================================================================

fn clamp(value: i64, min_val: i64, max_val: i64) -> i64:
    """Clamp value between min and max."""
    if value < min_val:
        return min_val
    if value > max_val:
        return max_val
    value

fn from_rgb(r: i64, g: i64, b: i64) -> Color:
    """Create a color from RGB values (0-255)."""
    Color(
        r: clamp(r, 0, 255),
        g: clamp(g, 0, 255),
        b: clamp(b, 0, 255),
        a: 255
    )

fn from_rgba(r: i64, g: i64, b: i64, a: i64) -> Color:
    """Create a color from RGBA values (0-255)."""
    Color(
        r: clamp(r, 0, 255),
        g: clamp(g, 0, 255),
        b: clamp(b, 0, 255),
        a: clamp(a, 0, 255)
    )

fn adjust_hue(color: Color, degrees: i64) -> Color:
    """Rotate hue by degrees (0-360)."""
    val hsl_tuple = rgb_to_hsl(color)
    val h = hsl_tuple.0
    val s = hsl_tuple.1
    val l = hsl_tuple.2
    val new_h = (h + degrees) % 360
    hsl_to_rgb(new_h, s, l)

fn lighten(color: Color, amount: i64) -> Color:
    """Lighten color by amount (0-100)."""
    val hsl_tuple = rgb_to_hsl(color)
    val h = hsl_tuple.0
    val s = hsl_tuple.1
    val l = hsl_tuple.2
    val new_l = clamp(l + amount, 0, 100)
    hsl_to_rgb(h, s, new_l)

fn darken(color: Color, amount: i64) -> Color:
    """Darken color by amount (0-100)."""
    val hsl_tuple = rgb_to_hsl(color)
    val h = hsl_tuple.0
    val s = hsl_tuple.1
    val l = hsl_tuple.2
    val new_l = clamp(l - amount, 0, 100)
    hsl_to_rgb(h, s, new_l)

fn rgb_to_hsl(color: Color) -> (i64, i64, i64):
    """Convert RGB to HSL. Returns (h: 0-360, s: 0-100, l: 0-100)."""
    val r_norm = color.r / 255
    val g_norm = color.g / 255
    val b_norm = color.b / 255

    val max_val = max3(r_norm, g_norm, b_norm)
    val min_val = min3(r_norm, g_norm, b_norm)
    val delta = max_val - min_val

    val l = (max_val + min_val) / 2

    if delta == 0:
        return (0, 0, l * 100)

    var s = 0
    if l < 50:
        s = delta / (max_val + min_val)
    else:
        s = delta / (200 - max_val - min_val)

    var h = 0
    if max_val == r_norm:
        val hue_component = (g_norm - b_norm) / delta
        h = (hue_component * 60) % 360
    else:
        if max_val == g_norm:
            val hue_component = (b_norm - r_norm) / delta
            h = ((hue_component + 2) * 60) % 360
        else:
            val hue_component = (r_norm - g_norm) / delta
            h = ((hue_component + 4) * 60) % 360

    if h < 0:
        h = h + 360

    (h, s * 100, l * 100)

fn hsl_to_rgb(h: i64, s: i64, l: i64) -> Color:
    """Convert HSL to RGB."""
    val h_norm = h % 360
    val s_norm = clamp(s, 0, 100)
    val l_norm = clamp(l, 0, 100)

    if s_norm == 0:
        val gray = (l_norm * 255) / 100
        return from_rgb(gray, gray, gray)

    var c = 0
    if l_norm < 50:
        c = (2 * l_norm * s_norm) / 100
    else:
        c = (200 - 2 * l_norm) * s_norm / 100

    val x = c * (100 - abs((h_norm % 120) - 60)) / 100
    val m = l_norm - c / 2

    var r_prime = 0
    var g_prime = 0
    var b_prime = 0

    if h_norm < 60:
        r_prime = c
        g_prime = x
        b_prime = 0
    else:
        if h_norm < 120:
            r_prime = x
            g_prime = c
            b_prime = 0
        else:
            if h_norm < 180:
                r_prime = 0
                g_prime = c
                b_prime = x
            else:
                if h_norm < 240:
                    r_prime = 0
                    g_prime = x
                    b_prime = c
                else:
                    if h_norm < 300:
                        r_prime = x
                        g_prime = 0
                        b_prime = c
                    else:
                        r_prime = c
                        g_prime = 0
                        b_prime = x

    val r = ((r_prime + m) * 255) / 100
    val g = ((g_prime + m) * 255) / 100
    val b = ((b_prime + m) * 255) / 100

    from_rgb(r, g, b)

fn max3(a: i64, b: i64, c: i64) -> i64:
    """Get maximum of three values."""
    var result = a
    if b > result:
        result = b
    if c > result:
        result = c
    result

fn min3(a: i64, b: i64, c: i64) -> i64:
    """Get minimum of three values."""
    var result = a
    if b < result:
        result = b
    if c < result:
        result = c
    result

fn abs(value: i64) -> i64:
    """Absolute value."""
    if value < 0:
        return 0 - value
    value

export mix, blend, average, multiply, screen, overlay
export complement, triadic, analogous, split_complement, tetradic, monochromatic
