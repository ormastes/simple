# K-d Tree Utilities
# Point set operations, debugging, validation, and analysis

import kd_tree.types

# ============================================================================
# Utility Functions
# ============================================================================

fn kdtree_print_node(node, depth: i64):
    # Print node information (for debugging)
    if node == nil:
        return

    var indent = ""
    var i = 0
    while i < depth:
        indent = indent + "  "
        i = i + 1

    val dim = kdnode_get_dim(node)
    val value = kdnode_get_value(node)
    val point = kdnode_get_point(node)

    print "{indent}Dim: {dim}, Value: {value}"

    val left = kdnode_get_left(node)
    val right = kdnode_get_right(node)

    if left != nil:
        print "{indent}Left:"
        kdtree_print_node(left, depth + 1)

    if right != nil:
        print "{indent}Right:"
        kdtree_print_node(right, depth + 1)

fn kdtree_validate(node, depth: i64, k: i64) -> i64:
    # Validate K-d tree structure
    if node == nil:
        return 1

    val dim = kdnode_get_dim(node)
    val expected_dim = depth % k
    if dim != expected_dim:
        return 0

    val left = kdnode_get_left(node)
    val right = kdnode_get_right(node)

    val left_valid = kdtree_validate(left, depth + 1, k)
    if left_valid == 0:
        return 0

    val right_valid = kdtree_validate(right, depth + 1, k)
    if right_valid == 0:
        return 0

    1

# ============================================================================
# Point Set Operations
# ============================================================================

fn points_deduplicate(points: List<List<i64>>) -> List<List<i64>>:
    # Remove duplicate points
    var result = []
    var i = 0
    while i < points.length():
        val point = points.get(i)
        var is_duplicate = 0
        var j = 0
        while j < result.length():
            val existing = result.get(j)
            val is_equal = point_equal(point, existing)
            if is_equal == 1:
                is_duplicate = 1
                break
            j = j + 1
        if is_duplicate == 0:
            result.push(point)
        i = i + 1
    result

fn points_closest_pair(points: List<List<i64>>, metric: i64) -> List:
    # Find closest pair of points
    # Returns [point1, point2, distance]
    if points.length() < 2:
        return [[], [], 999999999]

    var min_dist = 999999999
    var p1 = points.get(0)
    var p2 = points.get(1)

    var i = 0
    while i < points.length():
        val point1 = points.get(i)
        var j = i + 1
        while j < points.length():
            val point2 = points.get(j)
            val dist = point_distance(point1, point2, metric)
            if dist < min_dist:
                min_dist = dist
                p1 = point1
                p2 = point2
            j = j + 1
        i = i + 1

    [p1, p2, min_dist]

fn points_centroid(points: List<List<i64>>) -> List<i64>:
    # Calculate centroid of point set
    if points.length() == 0:
        return []

    val first = points.get(0)
    val k = first.length()

    var sums = []
    var d = 0
    while d < k:
        sums.push(0)
        d = d + 1

    var i = 0
    while i < points.length():
        val point = points.get(i)
        var j = 0
        while j < k:
            val coord = point.get(j)
            val sum = sums.get(j)
            sums.set(j, sum + coord)
            j = j + 1
        i = i + 1

    var centroid = []
    var c = 0
    while c < k:
        val sum = sums.get(c)
        val avg = sum / points.length()
        centroid.push(avg)
        c = c + 1

    centroid

fn points_farthest_from(points: List<List<i64>>, center: List<i64>, metric: i64) -> List<i64>:
    # Find point farthest from center
    if points.length() == 0:
        return []

    var max_dist = 0
    var farthest = points.get(0)

    var i = 0
    while i < points.length():
        val point = points.get(i)
        val dist = point_distance(point, center, metric)
        if dist > max_dist:
            max_dist = dist
            farthest = point
        i = i + 1

    farthest
