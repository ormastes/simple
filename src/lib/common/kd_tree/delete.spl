# K-d Tree Deletion Operations
# Single and bulk point removal

import kd_tree.types

# ============================================================================
# Removal Operations
# ============================================================================

fn kdtree_find_min_in_dim(node, target_dim: i64, current_dim: i64, k: i64) -> List<i64>:
    # Find point with minimum value in target dimension
    if node == nil:
        return []

    val point = kdnode_get_point(node)

    if current_dim == target_dim:
        val left = kdnode_get_left(node)
        if left == nil:
            return point
        return kdtree_find_min_in_dim(left, target_dim, (current_dim + 1) % k, k)

    val left = kdnode_get_left(node)
    val right = kdnode_get_right(node)

    var min_point = point
    var min_val = point.get(target_dim)

    if left != nil:
        val left_min = kdtree_find_min_in_dim(left, target_dim, (current_dim + 1) % k, k)
        if left_min.length() > 0:
            val left_val = left_min.get(target_dim)
            if left_val < min_val:
                min_point = left_min
                min_val = left_val

    if right != nil:
        val right_min = kdtree_find_min_in_dim(right, target_dim, (current_dim + 1) % k, k)
        if right_min.length() > 0:
            val right_val = right_min.get(target_dim)
            if right_val < min_val:
                min_point = right_min
                min_val = right_val

    min_point

fn kdtree_remove_recursive(node, point: List<i64>, depth: i64, k: i64):
    # Recursively remove point from tree
    if node == nil:
        return nil

    val node_point = kdnode_get_point(node)
    val is_equal = point_equal(node_point, point)

    if is_equal == 1:
        val right = kdnode_get_right(node)
        if right != nil:
            val dim = kdnode_get_dim(node)
            val replacement = kdtree_find_min_in_dim(right, dim, (depth + 1) % k, k)
            val new_val = replacement.get(dim)
            val new_node = kdnode_create(dim, new_val, replacement)
            val new_right = kdtree_remove_recursive(right, replacement, depth + 1, k)
            kdnode_set_right(new_node, new_right)
            val left = kdnode_get_left(node)
            kdnode_set_left(new_node, left)
            return new_node

        val left = kdnode_get_left(node)
        if left != nil:
            val dim = kdnode_get_dim(node)
            val replacement = kdtree_find_min_in_dim(left, dim, (depth + 1) % k, k)
            val new_val = replacement.get(dim)
            val new_node = kdnode_create(dim, new_val, replacement)
            val new_left = kdtree_remove_recursive(left, replacement, depth + 1, k)
            kdnode_set_right(new_node, new_left)
            return new_node

        return nil

    val dim = kdnode_get_dim(node)
    val pivot = kdnode_get_value(node)
    val coord = point.get(dim)

    if coord < pivot:
        val left = kdnode_get_left(node)
        val new_left = kdtree_remove_recursive(left, point, depth + 1, k)
        kdnode_set_left(node, new_left)
    else:
        val right = kdnode_get_right(node)
        val new_right = kdtree_remove_recursive(right, point, depth + 1, k)
        kdnode_set_right(node, new_right)

    node

fn kdtree_remove(node, point: List<i64>):
    # Remove point from K-d tree
    if node == nil:
        return nil
    val k = point_dimension(point)
    kdtree_remove_recursive(node, point, 0, k)

# ============================================================================
# Bulk Operations
# ============================================================================

fn kdtree_bulk_remove(node, points: List<List<i64>>):
    # Remove multiple points from tree
    var current = node
    var i = 0
    while i < points.length():
        val point = points.get(i)
        current = kdtree_remove(current, point)
        i = i + 1
    current
