describe "Target Spec Matching":
    it "skipped":
        skip("TargetArch import not available")

# describe "Target Spec Matching":
#     it "skipped":
#         skip("undefined identifier: host_arch - TargetArch import not available")
#
# # # Target Spec Matching
# # #
# # # Shared logic for parsing and matching target specifications
# # # used by asm match/assert. Validates arch, os, abi, backend
# # # against the current build target.
# #
# # use std.common.target.TargetArch
# #
# # export MatchResult, match_target_spec, check_exhaustiveness, all_target_archs
# #
# # enum MatchResult:
# #     Matched
# #     NotMatched
# #     MatchedWithNote(text)
# #
# # fn match_target_spec(archs: [text], has_os: bool, os: text,
# #                      has_abi: bool, abi: text, has_backend: bool, backend: text,
# #                      ver_ops: [text], ver_vals: [i64],
# #                      target_arch: text, target_os: text,
# #                      target_abi: text, target_backend: text,
# #                      target_backend_version: i64) -> MatchResult:
# #     # Check arch (required, supports pipe groups)
# #     var arch_matched = false
# #     for arch in archs:
# #         val lower_arch = arch.lower()
# #         val lower_target = target_arch.lower()
# #         val norm_arch = normalize_arch(lower_arch)
# #         val norm_target = normalize_arch(lower_target)
# #         if norm_arch == norm_target:
# #             arch_matched = true
# #             break
# #     if not arch_matched:
# #         return MatchResult.NotMatched
# #
# #     if has_os:
# #         val lower_os = os.lower()
# #         val lower_target_os = target_os.lower()
# #         if lower_os != "_" and lower_os != lower_target_os:
# #             return MatchResult.NotMatched
# #
# #     if has_abi:
# #         val lower_abi = abi.lower()
# #         val lower_target_abi = target_abi.lower()
# #         if lower_abi != "_" and lower_abi != lower_target_abi:
# #             return MatchResult.NotMatched
# #
# #     if has_backend:
# #         val lower_be = backend.lower()
# #         val lower_target_be = target_backend.lower()
# #         if lower_be != "_" and lower_be != lower_target_be:
# #             return MatchResult.NotMatched
# #
# #     var has_note = false
# #     var note_msg = ""
# #     for i in 0..ver_ops.len():
# #         val op = ver_ops[i]
# #         val ver = ver_vals[i]
# #         val tv = target_backend_version
# #         if op == ">=":
# #             if tv < ver:
# #                 return MatchResult.NotMatched
# #         elif op == "==":
# #             if tv != ver:
# #                 return MatchResult.NotMatched
# #         elif op == "<":
# #             if tv >= ver:
# #                 return MatchResult.NotMatched
# #         elif op == "~=":
# #             if tv != ver:
# #                 has_note = true
# #                 note_msg = "recommended backend version: {backend} {ver}, found: {backend} {tv}"
# #
# #     if has_note:
# #         return MatchResult.MatchedWithNote(note_msg)
# #     MatchResult.Matched
# #
# # fn normalize_arch(name: text) -> text:
# #     match name:
# #         case "x86-64" | "amd64" | "x64": "x86_64"
# #         case "arm64": "aarch64"
# #         case "armv7" | "arm32" | "thumbv7m" | "cortex-m": "arm"
# #         case "riscv32gc" | "rv32": "riscv32"
# #         case "riscv64gc" | "rv64": "riscv64"
# #         case "i686" | "i386": "x86"
# #         case "wasm": "wasm32"
# #         case "atmega" | "attiny": "avr"
# #         case "8051" | "mcs-51": "mcs51"
# #         case _: name
# #
# # fn check_exhaustiveness(arms_archs: [[text]], arms_is_wildcard: [bool],
# #                         all_archs: [text]) -> [text]:
# #     var missing: [text] = []
# #     for arch in all_archs:
# #         var covered = false
# #         for i in 0..arms_is_wildcard.len():
# #             if arms_is_wildcard[i]:
# #                 covered = true
# #                 break
# #             val arm_archs = arms_archs[i]
# #             for a in arm_archs:
# #                 if normalize_arch(a.lower()) == normalize_arch(arch.lower()):
# #                     covered = true
# #                     break
# #             if covered:
# #                 break
# #         if not covered:
# #             missing.push(arch)
# #     missing
# #
# # fn all_target_archs() -> [text]:
# #     ["x86_64", "x86", "aarch64", "arm", "riscv64", "riscv32",
# #      "wasm32", "wasm64", "avr", "mcs51", "msp430"]
#
