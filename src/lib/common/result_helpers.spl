# Result Type Helpers
#
# Functions for working with Result types (Ok/Err pattern).
# Split from functions.spl for modularity.
#
# Total Functions: 28

fn Ok(value):
    """Create an Ok Result.

    Example:
        val result = Ok(42)
    """
    (ok: value, err: nil)

fn Err(error):
    """Create an Err Result.

    Example:
        val result = Err("File not found")
    """
    (ok: nil, err: error)

fn result_is_ok(result):
    """Check if Result is Ok.

    Example:
        result_is_ok(Ok(42))  # true
        result_is_ok(Err("error"))  # false
    """
    if val (ok: value, err: _) = result:
        value.?
    else:
        false

fn result_is_err(result):
    """Check if Result is Err.

    Example:
        result_is_err(Err("error"))  # true
        result_is_err(Ok(42))  # false
    """
    if val (ok: _, err: error) = result:
        error.?
    else:
        false

fn result_unwrap_or(result, default_val):
    """Unwrap Ok value or return default.

    Example:
        result_unwrap_or(Ok(42), 0)  # 42
        result_unwrap_or(Err("e"), 0)  # 0
    """
    if val (ok: value, err: _) = result:
        if value.?:
            return value
    default_val

fn result_unwrap_err_or(result, default_err):
    """Unwrap Err value or return default error.

    Example:
        result_unwrap_err_or(Err("bad"), "none")  # "bad"
        result_unwrap_err_or(Ok(42), "none")  # "none"
    """
    if val (ok: _, err: error) = result:
        if error.?:
            return error
    default_err

fn result_unwrap_or_else(result, f: fn()):
    """Unwrap Ok value or call function to get default.

    Lazy evaluation - function only called if Err.

    Example:
        result_unwrap_or_else(Ok(42), \: expensive_default())
    """
    if val (ok: value, err: _) = result:
        if value.?:
            return value
    f()

fn result_map(result, f):
    """Map function over Ok value.

    Example:
        result_map(Ok(5), \x: x * 2)  # Ok(10)
        result_map(Err("e"), \x: x * 2)  # Err("e")
    """
    if val (ok: value, err: _) = result:
        if value.?:
            return Ok(f(value))
    result

fn result_map_err(result, f):
    """Map function over Err value.

    Example:
        result_map_err(Err("io"), \e: "Error: {e}")  # Err("Error: io")
        result_map_err(Ok(5), \e: "Error: {e}")  # Ok(5)
    """
    if val (ok: _, err: error) = result:
        if error.?:
            return Err(f(error))
    result

fn result_flat_map(result, f):
    """FlatMap function over Result (f returns Result).

    Example:
        result_flat_map(Ok(5), \x: Ok(x * 2))  # Ok(10)
        result_flat_map(Ok(5), \x: Err("bad"))  # Err("bad")
        result_flat_map(Err("e"), \x: Ok(x * 2))  # Err("e")
    """
    if val (ok: value, err: _) = result:
        if value.?:
            return f(value)
    result

fn result_and_then(result1, result2):
    """Return second Result if first is Ok, first if Err.

    Example:
        result_and_then(Ok(5), Ok(10))  # Ok(10)
        result_and_then(Err("e"), Ok(10))  # Err("e")
        result_and_then(Ok(5), Err("e"))  # Err("e")
    """
    if result_is_ok(result1):
        result2
    else:
        result1

fn result_or_else(result, f: fn()):
    """Return Result or call function to get alternative Result.

    Example:
        result_or_else(Ok(5), \: Ok(0))  # Ok(5)
        result_or_else(Err("e"), \: Ok(0))  # Ok(0)
    """
    if result_is_ok(result):
        result
    else:
        f()

fn result_or(result1, result2):
    """Return first Ok Result, or second if first is Err.

    Example:
        result_or(Ok(5), Ok(10))  # Ok(5)
        result_or(Err("e"), Ok(10))  # Ok(10)
        result_or(Err("e1"), Err("e2"))  # Err("e2")
    """
    if result_is_ok(result1):
        result1
    else:
        result2

fn result_flatten(nested_result):
    """Flatten Result<Result<T>> to Result<T>.

    Example:
        result_flatten(Ok(Ok(5)))  # Ok(5)
        result_flatten(Ok(Err("e")))  # Err("e")
        result_flatten(Err("e"))  # Err("e")
    """
    if val (ok: value, err: _) = nested_result:
        if value.?:
            return value
    nested_result

fn result_transpose_opt(result):
    """Convert Result<Option<T>> to Option<Result<T>>.

    Example:
        result_transpose_opt(Ok(Some(5)))  # Some(Ok(5))
        result_transpose_opt(Ok(nil))  # nil
        result_transpose_opt(Err("e"))  # Some(Err("e"))
    """
    if val (ok: value, err: _) = result:
        if value.?:
            if value.?:
                return Some(Ok(value))
            else:
                return nil
    elif val (ok: _, err: error) = result:
        if error.?:
            return Some(Err(error))
    nil

fn result_ok(result):
    """Extract Ok value as Option.

    Returns Some(value) if Ok, nil if Err.

    Example:
        result_ok(Ok(42))  # Some(42)
        result_ok(Err("e"))  # nil
    """
    if val (ok: value, err: _) = result:
        if value.?:
            return Some(value)
    nil

fn result_err(result):
    """Extract Err value as Option.

    Returns Some(error) if Err, nil if Ok.

    Example:
        result_err(Err("bad"))  # Some("bad")
        result_err(Ok(42))  # nil
    """
    if val (ok: _, err: error) = result:
        if error.?:
            return Some(error)
    nil

fn result_collect(results):
    """Convert array of Results to Result of array.

    Returns Ok([...]) if all are Ok, Err(first_error) if any is Err.

    Example:
        result_collect([Ok(1), Ok(2), Ok(3)])  # Ok([1,2,3])
        result_collect([Ok(1), Err("e"), Ok(3)])  # Err("e")
    """
    var values = []

    for result in results:
        if val (ok: value, err: _) = result:
            if value.?:
                values.push(value)
            else:
                return result
        elif val (ok: _, err: error) = result:
            if error.?:
                return result

    Ok(values)

fn result_all_ok(results):
    """Check if all Results are Ok.

    Example:
        result_all_ok([Ok(1), Ok(2)])  # true
        result_all_ok([Ok(1), Err("e")])  # false
    """
    for result in results:
        if not result_is_ok(result):
            return false
    true

fn result_any_ok(results):
    """Check if any Result is Ok.

    Example:
        result_any_ok([Err("e1"), Ok(2), Err("e2")])  # true
        result_any_ok([Err("e1"), Err("e2")])  # false
    """
    for result in results:
        if result_is_ok(result):
            return true
    false

fn result_first_ok(results):
    """Get first Ok Result from array.

    Returns first Ok found, or last Err if all are Err.

    Example:
        result_first_ok([Err("e1"), Ok(2), Ok(3)])  # Ok(2)
        result_first_ok([Err("e1"), Err("e2")])  # Err("e2")
    """
    var last_err = nil
    for result in results:
        if result_is_ok(result):
            return result
        else:
            last_err = result
    last_err ?? Err("No results")

fn result_partition(results):
    """Partition Results into Ok values and Err values.

    Returns tuple of ([ok_values], [err_values]).

    Example:
        result_partition([Ok(1), Err("e1"), Ok(3), Err("e2")])
        # ([1, 3], ["e1", "e2"])
    """
    var oks = []
    var errs = []

    for result in results:
        if val (ok: value, err: _) = result:
            if value.?:
                oks.push(value)
        elif val (ok: _, err: error) = result:
            if error.?:
                errs.push(error)

    (oks, errs)

fn result_iter(result, f: fn()):
    """Execute function if Ok, do nothing if Err.

    Example:
        result_iter(Ok(5), \x: print(x))  # prints 5
        result_iter(Err("e"), \x: print(x))  # does nothing
    """
    if val (ok: value, err: _) = result:
        if value.?:
            f(value)

fn result_iter_err(result, f: fn()):
    """Execute function if Err, do nothing if Ok.

    Example:
        result_iter_err(Err("bad"), \e: print("Error: {e}"))
    """
    if val (ok: _, err: error) = result:
        if error.?:
            f(error)

fn result_zip(result1, result2):
    """Combine two Results into Result of tuple.

    Returns Ok((a, b)) if both are Ok, Err otherwise.

    Example:
        result_zip(Ok(1), Ok(2))  # Ok((1, 2))
        result_zip(Ok(1), Err("e"))  # Err("e")
        result_zip(Err("e1"), Err("e2"))  # Err("e1")
    """
    if val (ok: value1, err: _) = result1:
        if value1.?:
            if val (ok: value2, err: _) = result2:
                if value2.?:
                    return Ok((value1, value2))

    # Return first error encountered
    if result_is_err(result1):
        return result1
    result2

fn result_zip_with(result1, result2, f):
    """Combine two Results with function.

    Example:
        result_zip_with(Ok(2), Ok(3), \a, b: a + b)  # Ok(5)
        result_zip_with(Ok(2), Err("e"), \a, b: a + b)  # Err("e")
    """
    if val (ok: value1, err: _) = result1:
        if value1.?:
            if val (ok: value2, err: _) = result2:
                if value2.?:
                    return Ok(f(value1, value2))

    if result_is_err(result1):
        return result1
    result2

fn result_from_option(opt, error_message):
    """Convert Option to Result.

    Returns Ok(value) if Some, Err(error_message) if nil.

    Example:
        result_from_option(Some(42), "missing")  # Ok(42)
        result_from_option(nil, "missing")  # Err("missing")
    """
    if val value = opt:
        Ok(value)
    else:
        Err(error_message)

fn result_from_predicate(value, predicate, error_message):
    """Create Ok if predicate is true, Err otherwise.

    Example:
        result_from_predicate(5, \x: x > 3, "too small")  # Ok(5)
        result_from_predicate(2, \x: x > 3, "too small")  # Err("too small")
    """
    if predicate(value):
        Ok(value)
    else:
        Err(error_message)

fn result_to_option(result):
    """Convert Result to Option, discarding error.

    Example:
        result_to_option(Ok(42))  # Some(42)
        result_to_option(Err("e"))  # nil
    """
    result_ok(result)

export *
