# Fraction Arithmetic Operations

fn add(a: (i64, i64), b: (i64, i64)) -> (i64, i64):
    val num_a = a.0
    val den_a = a.1
    val num_b = b.0
    val den_b = b.1

    val num = num_a * den_b + num_b * den_a
    val den = den_a * den_b

    return reduce((num, den))

fn subtract(a: (i64, i64), b: (i64, i64)) -> (i64, i64):
    val num_a = a.0
    val den_a = a.1
    val num_b = b.0
    val den_b = b.1

    val num = num_a * den_b - num_b * den_a
    val den = den_a * den_b

    return reduce((num, den))

fn multiply(a: (i64, i64), b: (i64, i64)) -> (i64, i64):
    val num_a = a.0
    val den_a = a.1
    val num_b = b.0
    val den_b = b.1

    val num = num_a * num_b
    val den = den_a * den_b

    return reduce((num, den))

fn divide(a: (i64, i64), b: (i64, i64)) -> (i64, i64):
    val num_b = b.0
    val den_b = b.1

    if num_b == 0:
        print "Error: division by zero"
        return (0, 1)

    return multiply(a, (den_b, num_b))

fn negate(frac: (i64, i64)) -> (i64, i64):
    return (-frac.0, frac.1)

fn abs_frac(frac: (i64, i64)) -> (i64, i64):
    val num = frac.0
    val abs_num = if num < 0: -num else: num
    return (abs_num, frac.1)

fn power(frac: (i64, i64), exp: i64) -> (i64, i64):
    if exp == 0:
        return (1, 1)

    if exp < 0:
        val recip = reciprocal(frac)
        return power(recip, -exp)

    val num = frac.0
    val den = frac.1

    var result_num = 1
    var result_den = 1
    var i = 0

    loop:
        if i >= exp:
            break

        result_num = result_num * num
        result_den = result_den * den
        i = i + 1

    return reduce((result_num, result_den))

fn reciprocal(frac: (i64, i64)) -> (i64, i64):
    val num = frac.0
    val den = frac.1

    if num == 0:
        print "Error: reciprocal of zero undefined"
        return (0, 1)

    if num < 0:
        return (-den, -num)

    return (den, num)
