# Regular Expression Engine - Matcher
#
# Regex compilation and matching operations.

from .types import MatchResult
from .parser import parse_regex
from .nfa import nfa_create, nfa_set_start, nfa_set_accept, thompson_from_ast, nfa_simulate

# ============================================================================
# MATCHING API
# ============================================================================

fn regex_compile(pattern: text) -> any:
    """Compile regex pattern to NFA. Returns (success, nfa, error_msg)."""
    val parse_result = parse_regex(pattern)
    val parse_success = parse_result.0
    if not parse_success:
        val error = parse_result.3
        return (false, nil, error)
    val ast = parse_result.1
    var nfa = nfa_create()
    val thompson_result = thompson_from_ast(ast, nfa)
    nfa = thompson_result.0
    val start = thompson_result.1
    val accept = thompson_result.2
    nfa = nfa_set_start(nfa, start)
    nfa = nfa_set_accept(nfa, accept)
    (true, nfa, "")

fn regex_match(pattern: text, input: text) -> bool:
    """Test if entire input matches pattern."""
    val compile_result = regex_compile(pattern)
    val success = compile_result.0
    if not success:
        return false
    val nfa = compile_result.1
    nfa_simulate(nfa, input)

fn regex_test(pattern: text, input: text) -> bool:
    """Test if pattern matches anywhere in input."""
    val compile_result = regex_compile(pattern)
    val success = compile_result.0
    if not success:
        return false
    val nfa = compile_result.1
    var pos = 0
    while pos <= input.len():
        val substring = input[pos:input.len()]
        if nfa_simulate(nfa, substring):
            return true
        pos = pos + 1
    false

fn regex_find(pattern: text, input: text) -> any:
    """Find first match of pattern in input. Returns (found, start, end, matched_text)."""
    val compile_result = regex_compile(pattern)
    val success = compile_result.0
    if not success:
        return (false, -1, -1, "")
    val nfa = compile_result.1
    var pos = 0
    while pos <= input.len():
        var end = pos
        while end <= input.len():
            val substring = input[pos:end]
            if nfa_simulate(nfa, substring):
                return (true, pos, end, substring)
            end = end + 1
        pos = pos + 1
    (false, -1, -1, "")

fn regex_find_all(pattern: text, input: text) -> [any]:
    """Find all matches of pattern in input. Returns array of (start, end, matched_text)."""
    var matches = []
    val compile_result = regex_compile(pattern)
    val success = compile_result.0
    if not success:
        return matches
    val nfa = compile_result.1
    var pos = 0
    while pos < input.len():
        var found = false
        var end = pos + 1
        while end <= input.len() and not found:
            val substring = input[pos:end]
            if nfa_simulate(nfa, substring):
                matches.push((pos, end, substring))
                found = true
                pos = end
            end = end + 1
        if not found:
            pos = pos + 1
    matches

fn regex_exec(pattern: text, input: text) -> any:
    """Execute regex and return match result with groups."""
    val find_result = regex_find(pattern, input)
    val found = find_result.0
    if not found:
        return MatchResult(matched: false, start_pos: -1, end_pos: -1, groups: [], group_names: {})
    val start = find_result.1
    val end = find_result.2
    val text_match = find_result.3
    val groups = [(start, end, text_match)]
    MatchResult(matched: true, start_pos: start, end_pos: end, groups: groups, group_names: {})

export regex_compile, regex_match, regex_test, regex_find, regex_find_all, regex_exec
