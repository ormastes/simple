# @alloc
# String Extension Methods
#
# Provides string utility functions not available as built-in methods.
# Built on top of string_core.spl for fundamental operations.
#
# Functions:
# - text_hash: FNV-1a hash for strings
# - text_trim_start_matches: Remove prefix pattern repeatedly
# - text_trim_end_matches: Remove suffix pattern repeatedly
# - Character search and manipulation utilities

# Import core string operations
use std.string_core.{char_code, char_from_code, str_to_lower, str_to_upper, str_capitalize, str_reverse, str_trim, is_whitespace_char}
# Import formatting utilities
use std.format_utils.{wrap_text}

# Re-export for compatibility
export char_code, char_from_code

# ============================================================================
# ASCII Character Code Lookup (imported from string_core)
# ============================================================================
# char_code() and char_from_code() are imported above and re-exported

# ============================================================================
# Newline Constants
# ============================================================================

val LF = "\n"           # Line Feed (Unix/Linux/macOS) - ASCII 10
val CR = "\r"           # Carriage Return (old Mac) - ASCII 13
val CRLF = "\r\n"       # Carriage Return + Line Feed (Windows)
val _NL = "\n"          # Explicit LF (always \n, for byte comparisons)
val NL = "\n"           # Default newline (LF). Use platform_newline() for OS-specific.

# ============================================================================
# String Hashing
# ============================================================================

fn text_hash(s: text) -> i64:
    """FNV-1a hash of a string. Returns a deterministic i64 hash value."""
    var hash = 2166136261
    var i = 0
    while i < s.len():
        val code = char_code(s[i])
        hash = (hash xor code) * 16777619
        i = i + 1
    hash

# ============================================================================
# Trim Matching Patterns
# ============================================================================

fn text_trim_start_matches(s: text, pattern: text) -> text:
    """Remove all occurrences of pattern from the start of the string."""
    if pattern.len() == 0:
        return s
    var result = s
    while result.starts_with(pattern):
        result = result[pattern.len():]
    result

fn text_trim_end_matches(s: text, pattern: text) -> text:
    """Remove all occurrences of pattern from the end of the string."""
    if pattern.len() == 0:
        return s
    var result = s
    while result.ends_with(pattern):
        result = result[0:result.len() - pattern.len()]
    result

# ============================================================================
# Character Search
# ============================================================================

# text_contains_char and text_index_of_char removed - use contains_char and index_of_char instead

# ============================================================================
# Additional String Utilities
# ============================================================================

# text_repeat removed - use repeat_str instead

fn text_pad_left(s: text, width: i64, pad_char: text) -> text:
    """Pad string on the left to reach desired width."""
    var result = s
    while result.len() < width:
        result = pad_char + result
    result

fn text_pad_right(s: text, width: i64, pad_char: text) -> text:
    """Pad string on the right to reach desired width."""
    var result = s
    while result.len() < width:
        result = result + pad_char
    result

fn text_is_digit(ch: text) -> bool:
    """Check if a single character is a digit (0-9)."""
    ch == "0" or ch == "1" or ch == "2" or ch == "3" or ch == "4" or ch == "5" or ch == "6" or ch == "7" or ch == "8" or ch == "9"

fn text_is_alpha(ch: text) -> bool:
    """Check if a single character is alphabetic (a-z, A-Z)."""
    val code = char_code(ch)
    (code >= 65 and code <= 90) or (code >= 97 and code <= 122)

fn text_is_alphanumeric(ch: text) -> bool:
    """Check if a single character is alphanumeric."""
    text_is_alpha(ch) or text_is_digit(ch)

# ============================================================================
# String Manipulation (merged from string_utils.spl)
# ============================================================================

fn repeat_str(s: text, n: i64) -> text:
    """Repeat a string n times."""
    if n <= 0:
        return ""
    var result = ""
    for _ in 0..n:
        result = result + s
    result

fn reverse_str(s: text) -> text:
    """Reverse a string. Delegates to string_core."""
    str_reverse(s)

fn join_strs(list: [text], sep: text) -> text:
    """Join a list of strings with a separator."""
    if list.len() == 0:
        return ""
    var result = list[0]
    for i in 1..list.len():
        result = result + sep + list[i]
    result

fn contains_char(s: text, c: text) -> bool:
    """Check if string contains a character."""
    if c.len() != 1:
        return false
    for i in 0..s.len():
        if s[i:i + 1] == c:
            return true
    false

fn count_char(s: text, c: text) -> i64:
    """Count occurrences of a character in a string."""
    if c.len() != 1:
        return 0
    var count = 0
    for i in 0..s.len():
        if s[i:i + 1] == c:
            count = count + 1
    count

fn index_of_char(s: text, c: text) -> i64?:
    """Find first index of a character. Returns nil if not found."""
    if c.len() != 1:
        return nil
    for i in 0..s.len():
        if s[i:i + 1] == c:
            return i
    nil

fn last_index_of_char(s: text, c: text) -> i64?:
    """Find last index of a character. Returns nil if not found."""
    if c.len() != 1:
        return nil
    var i = s.len() - 1
    while i >= 0:
        if s[i:i + 1] == c:
            return i
        i = i - 1
    nil

fn starts_with_char(s: text, c: text) -> bool:
    """Check if string starts with a character."""
    if s.len() == 0:
        return false
    if c.len() != 1:
        return false
    s[0:1] == c

fn ends_with_char(s: text, c: text) -> bool:
    """Check if string ends with a character."""
    if s.len() == 0:
        return false
    if c.len() != 1:
        return false
    s[s.len() - 1:s.len()] == c

fn char_at(s: text, index: i64) -> text:
    """Get character at index. Returns empty string if out of bounds."""
    if index < 0 or index >= s.len():
        return ""
    s[index:index + 1]

fn is_whitespace(s: text) -> bool:
    """Check if string contains only whitespace characters."""
    if s.len() == 0:
        return true
    for i in 0..s.len():
        val c = s[i:i + 1]
        if c != " " and c != "\t" and c != "\n" and c != "\r":
            return false
    true

fn is_empty(s: text) -> bool:
    """Check if string is empty."""
    s.len() == 0

fn is_blank(s: text) -> bool:
    """Check if string is empty or contains only whitespace."""
    is_whitespace(s)

fn compare_case_insensitive(a: text, b: text) -> bool:
    """Compare two strings ignoring case."""
    to_lowercase_str(a) == to_lowercase_str(b)

fn to_lowercase_str(s: text) -> text:
    """Convert string to lowercase (ASCII only). Delegates to string_core."""
    str_to_lower(s)

fn to_uppercase_str(s: text) -> text:
    """Convert string to uppercase (ASCII only). Delegates to string_core."""
    str_to_upper(s)

fn capitalize_first(s: text) -> text:
    """Capitalize first letter of string. Delegates to string_core."""
    str_capitalize(s)

fn split_on_char(s: text, c: text) -> [text]:
    """Split string on a character."""
    if c.len() != 1:
        return [s]
    var result: [text] = []
    var current = ""
    for i in 0..s.len():
        val ch = s[i:i + 1]
        if ch == c:
            result = result.push(current)
            current = ""
        else:
            current = current + ch
    result.push(current)

fn str_lines(s: text) -> [text]:
    """Split string into lines."""
    split_on_char(s, "\n")

# str_words removed - use split_whitespace instead

# char_from_code() is imported from string_core above

# ============================================================================
# Integer Parsing
# ============================================================================

# Parse i64 from string with safe fallback (bootstrap runtime compatible)
fn parse_i64_safe(s: text) -> i64:
    var result = 0
    var sign = 1
    var start = 0

    if s.len() > 0 and s[0:1] == "-":
        sign = -1
        start = 1

    for i in start..s.len():
        val ch = s[i:i+1]
        if ch >= "0" and ch <= "9":
            val digit = char_to_digit(ch)
            result = result * 10 + digit
        else:
            break

    result * sign

# Convert single digit character to integer
fn char_to_digit(ch: text) -> i64:
    if ch == "0": 0
    else if ch == "1": 1
    else if ch == "2": 2
    else if ch == "3": 3
    else if ch == "4": 4
    else if ch == "5": 5
    else if ch == "6": 6
    else if ch == "7": 7
    else if ch == "8": 8
    else if ch == "9": 9
    else: 0

# ============================================================================
# Platform-Aware Newline Functions
# ============================================================================

fn platform_newline() -> text:
    """Get platform-specific newline sequence.
    Returns CRLF on Windows, LF on Unix-like systems."""
    use app.io.mod.{env_get}
    val os_env = env_get("OS")
    val is_win = os_env.contains("Windows")
    if is_win: CRLF else: LF

fn normalize_newlines(s: text) -> text:
    """Normalize all newline types to LF.
    Converts CRLF (Windows) and CR (old Mac) to LF (Unix)."""
    var step1 = s.replace(CRLF, LF)
    step1.replace(CR, LF)

# ============================================================================
# Convenience Aliases and Wrappers
# ============================================================================

# Common aliases for compatibility with different naming conventions
fn parse_i64(s: text) -> i64:
    """Alias for parse_i64_safe."""
    parse_i64_safe(s)

fn to_int_or(s: text, default_val: i64) -> i64:
    """Parse string to integer with fallback default."""
    if s.len() == 0:
        return default_val
    parse_i64_safe(s)

fn split_lines(s: text) -> [text]:
    """Alias for str_lines."""
    str_lines(s)

fn string_hash(s: text) -> i64:
    """Alias for text_hash."""
    text_hash(s)

fn string_to_lowercase(s: text) -> text:
    """Alias for to_lowercase_str."""
    to_lowercase_str(s)

fn string_to_uppercase(s: text) -> text:
    """Alias for to_uppercase_str."""
    to_uppercase_str(s)

fn string_trim(s: text) -> text:
    """Trim whitespace from both ends of string. Delegates to string_core."""
    str_trim(s)

# is_whitespace_char is imported from string_core above

fn string_split(s: text, delimiter: text) -> [text]:
    """Split string on delimiter (general version)."""
    if delimiter.len() == 1:
        return split_on_char(s, delimiter)
    # For multi-char delimiters, simple implementation
    var result: [text] = []
    var current = ""
    var i = 0
    while i < s.len():
        if i + delimiter.len() <= s.len() and s[i:i+delimiter.len()] == delimiter:
            result = result.push(current)
            current = ""
            i = i + delimiter.len()
        else:
            current = current + s[i:i+1]
            i = i + 1
    result.push(current)

# ============================================================================
# Advanced Character Classification (from text_utils)
# ============================================================================

fn is_uppercase_char(ch: text) -> bool:
    """Check if character is uppercase.

    Example:
        is_uppercase_char("A")  # true
        is_uppercase_char("a")  # false
    """
    if ch.len() != 1:
        return false

    val code = ch[0]
    code >= 'A' and code <= 'Z'

fn is_lowercase_char(ch: text) -> bool:
    """Check if character is lowercase.

    Example:
        is_lowercase_char("a")  # true
        is_lowercase_char("A")  # false
    """
    if ch.len() != 1:
        return false

    val code = ch[0]
    code >= 'a' and code <= 'z'

# ============================================================================
# Advanced Tokenization (from text_utils)
# ============================================================================

fn split_whitespace(text: text):
    """Split text by whitespace, removing empty tokens.

    Example:
        split_whitespace("hello   world  \n foo")  # ["hello", "world", "foo"]
    """
    val parts = text.split(" ")
    var result = []

    for part in parts:
        val trimmed = part.trim()
        if trimmed.len() > 0:
            result.push(trimmed)

    result

fn extract_words(text: text):
    """Extract words (alphanumeric sequences) from text.

    Example:
        extract_words("Hello, world! 123")  # ["Hello", "world", "123"]
    """
    var words = []
    var current_word = ""
    var i = 0

    while i < text.len():
        val ch = text[i]
        if text_is_alphanumeric(ch):
            current_word = current_word + ch
        else:
            if current_word.len() > 0:
                words.push(current_word)
                current_word = ""
        i = i + 1

    if current_word.len() > 0:
        words.push(current_word)

    words

# ============================================================================
# Line Processing (from text_utils)
# ============================================================================

fn trim_lines(lines):
    """Trim whitespace from each line.

    Example:
        trim_lines(["  hello  ", "  world  "])  # ["hello", "world"]
    """
    var result = []
    for line in lines:
        result.push(line.trim())
    result

fn remove_empty_lines(lines):
    """Remove empty or whitespace-only lines.

    Example:
        remove_empty_lines(["hello", "", "world", "  "])
        # ["hello", "world"]
    """
    var result = []
    for line in lines:
        if line.trim().len() > 0:
            result.push(line)
    result

fn number_lines(lines, start: i64):
    """Add line numbers to lines.

    Example:
        number_lines(["hello", "world"], 1)
        # ["1: hello", "2: world"]
    """
    var result = []
    var i = 0

    while i < lines.len():
        val line_num = start + i
        result.push("{line_num}: {lines[i]}")
        i = i + 1

    result

fn prefix_lines(lines, prefix: text):
    """Add prefix to each line.

    Example:
        prefix_lines(["hello", "world"], "> ")
        # ["> hello", "> world"]
    """
    var result = []
    for line in lines:
        result.push(prefix + line)
    result

fn suffix_lines(lines, suffix: text):
    """Add suffix to each line.

    Example:
        suffix_lines(["hello", "world"], "!")
        # ["hello!", "world!"]
    """
    var result = []
    for line in lines:
        result.push(line + suffix)
    result

# ============================================================================
# Advanced Case Conversion (from text_utils)
# ============================================================================

fn to_title_case(text: text) -> text:
    """Convert text to title case (capitalize first letter of each word).

    Example:
        to_title_case("hello world")  # "Hello World"
    """
    var result = ""
    var capitalize_next = true
    var i = 0

    while i < text.len():
        val ch = text[i]

        if is_whitespace_char(ch):
            result = result + ch
            capitalize_next = true
        elif capitalize_next and text_is_alpha(ch):
            if is_lowercase_char(ch):
                val upper_code = ch[0] - 32
                result = result + upper_code
            else:
                result = result + ch
            capitalize_next = false
        else:
            if is_uppercase_char(ch):
                val lower_code = ch[0] + 32
                result = result + lower_code
            else:
                result = result + ch

        i = i + 1

    result

fn to_snake_case(text: text) -> text:
    """Convert text to snake_case.

    Example:
        to_snake_case("HelloWorld")  # "hello_world"
        to_snake_case("hello world")  # "hello_world"
    """
    var result = ""
    var i = 0

    while i < text.len():
        val ch = text[i]

        if is_whitespace_char(ch):
            result = result + "_"
        elif is_uppercase_char(ch):
            if i > 0 and not is_whitespace_char(text[i-1]):
                result = result + "_"
            val lower_code = ch[0] + 32
            result = result + lower_code
        else:
            result = result + ch

        i = i + 1

    result

fn to_camel_case(text: text) -> text:
    """Convert text to camelCase.

    Example:
        to_camel_case("hello world")  # "helloWorld"
        to_camel_case("hello_world")  # "helloWorld"
    """
    var result = ""
    var capitalize_next = false
    var i = 0

    while i < text.len():
        val ch = text[i]

        if ch == " " or ch == "_":
            capitalize_next = true
        elif capitalize_next and text_is_alpha(ch):
            if is_lowercase_char(ch):
                val upper_code = ch[0] - 32
                result = result + upper_code
            else:
                result = result + ch
            capitalize_next = false
        else:
            result = result + ch

        i = i + 1

    result

# ============================================================================
# Word Operations (from text_utils)
# ============================================================================

fn word_count(text: text) -> i64:
    """Count words in text.

    Example:
        word_count("Hello world, how are you?")  # 5
    """
    val words = extract_words(text)
    words.len()

fn word_wrap(text: text, width: i64):
    """Wrap text to specified width.

    Delegates to wrap_text() from std.format_utils.

    Returns array of lines.

    Example:
        word_wrap("The quick brown fox", 10)
        # ["The quick", "brown fox"]
    """
    wrap_text(text, width)

fn reverse_words(text: text) -> text:
    """Reverse order of words in text.

    Example:
        reverse_words("hello world")  # "world hello"
    """
    val words = split_whitespace(text)
    var reversed = []
    var i = words.len() - 1

    while i >= 0:
        reversed.push(words[i])
        i = i - 1

    reversed.join(" ")

fn longest_word(text: text):
    """Find longest word in text.

    Returns (word, length) tuple or nil.

    Example:
        longest_word("The quick brown fox")  # ("quick", 5)
    """
    val words = extract_words(text)
    if words.len() == 0:
        return nil

    var longest = words[0]
    var max_len = longest.len()

    for word in words:
        if word.len() > max_len:
            longest = word
            max_len = word.len()

    (longest, max_len)

# ============================================================================
# Text Analysis (from text_utils)
# ============================================================================

fn char_frequency(text: text):
    """Calculate character frequency.

    Returns array of (char, count) tuples.

    Example:
        char_frequency("hello")
        # [('h',1), ('e',1), ('l',2), ('o',1)]
    """
    var counts = []
    var i = 0

    while i < text.len():
        val ch = text[i]

        # Find or add character
        var found = false
        var j = 0
        while j < counts.len():
            val (char, count) = counts[j]
            if char == ch:
                counts[j] = (char, count + 1)
                found = true
                break
            j = j + 1

        if not found:
            counts.push((ch, 1))

        i = i + 1

    counts

fn most_common_char(text: text):
    """Find most common character.

    Returns (char, count) tuple or nil.

    Example:
        most_common_char("hello")  # ('l', 2)
    """
    val freqs = char_frequency(text)
    if freqs.len() == 0:
        return nil

    var max_char = nil
    var max_count = 0

    for (char, count) in freqs:
        if count > max_count:
            max_char = char
            max_count = count

    (max_char, max_count)

fn most_common_words(text: text, n: i64):
    """Find n most common words.

    Example:
        most_common_words("hello world hello", 1)
        # [("hello", 2)]
    """
    val words = extract_words(text)

    # Count word frequencies
    var counts = []
    for word in words:
        var found = false
        var i = 0
        while i < counts.len():
            val (w, count) = counts[i]
            if w == word:
                counts[i] = (w, count + 1)
                found = true
                break
            i = i + 1

        if not found:
            counts.push((word, 1))

    # Sort by frequency (simple selection sort)
    var sorted = counts
    var i = 0
    while i < sorted.len() - 1:
        var max_idx = i
        var j = i + 1
        while j < sorted.len():
            val (_, count1) = sorted[max_idx]
            val (_, count2) = sorted[j]
            if count2 > count1:
                max_idx = j
            j = j + 1

        if max_idx != i:
            val temp = sorted[i]
            sorted[i] = sorted[max_idx]
            sorted[max_idx] = temp

        i = i + 1

    # Take top n
    var result = []
    i = 0
    while i < n and i < sorted.len():
        result.push(sorted[i])
        i = i + 1

    result

# ============================================================================
# Indentation (from text_utils)
# ============================================================================

fn detect_indent(lines):
    """Detect indentation level of first indented line.

    Returns number of leading spaces.

    Example:
        detect_indent(["hello", "  world", "    foo"])  # 2
    """
    for line in lines:
        var spaces = 0
        var i = 0

        while i < line.len():
            if line[i] == ' ':
                spaces = spaces + 1
            else:
                break
            i = i + 1

        if spaces > 0:
            return spaces

    0

fn normalize_indent(lines, new_indent: i64):
    """Normalize indentation to specified number of spaces.

    Example:
        normalize_indent(["  hello", "    world"], 4)
        # ["    hello", "        world"]
    """
    val current_indent = detect_indent(lines)
    if current_indent == 0:
        return lines

    var result = []

    for line in lines:
        # Count leading spaces
        var spaces = 0
        var i = 0
        while i < line.len():
            if line[i] == ' ':
                spaces = spaces + 1
            else:
                break
            i = i + 1

        # Calculate new indentation
        val indent_level = spaces / current_indent
        val new_spaces = indent_level * new_indent

        # Build new line
        var new_line = ""
        var j = 0
        while j < new_spaces:
            new_line = new_line + " "
            j = j + 1

        # Add rest of line
        new_line = new_line + line[spaces..]
        result.push(new_line)

    result

fn dedent_lines(lines):
    """Remove common leading whitespace from all lines.

    Example:
        dedent_lines(["  hello", "    world"])
        # ["hello", "  world"]
    """
    val min_indent = detect_indent(lines)
    if min_indent == 0:
        return lines

    var result = []

    for line in lines:
        if line.len() >= min_indent:
            result.push(line[min_indent..])
        else:
            result.push(line)

    result

# ============================================================================
# String Similarity (from text_utils)
# ============================================================================

fn levenshtein_distance(s1: text, s2: text) -> i64:
    """Calculate Levenshtein (edit) distance between two strings.

    Number of single-character edits needed to transform s1 into s2.

    Example:
        levenshtein_distance("kitten", "sitting")  # 3
    """
    val len1 = s1.len()
    val len2 = s2.len()

    # Create distance matrix
    var dp = []
    var i = 0
    while i <= len1:
        var row = []
        var j = 0
        while j <= len2:
            row.push(0)
            j = j + 1
        dp.push(row)
        i = i + 1

    # Initialize first row and column
    i = 0
    while i <= len1:
        dp[i][0] = i
        i = i + 1

    var j = 0
    while j <= len2:
        dp[0][j] = j
        j = j + 1

    # Fill matrix
    i = 1
    while i <= len1:
        j = 1
        while j <= len2:
            val cost = if s1[i-1] == s2[j-1]: 0 else: 1

            val delete = dp[i-1][j] + 1
            val insert = dp[i][j-1] + 1
            val substitute = dp[i-1][j-1] + cost

            var min = delete
            if insert < min:
                min = insert
            if substitute < min:
                min = substitute

            dp[i][j] = min
            j = j + 1
        i = i + 1

    dp[len1][len2]

fn hamming_distance(s1: text, s2: text):
    """Calculate Hamming distance (must be same length).

    Number of positions where characters differ.

    Example:
        hamming_distance("karolin", "kathrin")  # 3
    """
    if s1.len() != s2.len():
        return nil

    var distance = 0
    var i = 0

    while i < s1.len():
        if s1[i] != s2[i]:
            distance = distance + 1
        i = i + 1

    distance

# ============================================================================
# Advanced Text Joining (from text_utils)
# ============================================================================

fn join_with_separator(items, separator: text, final_separator: text) -> text:
    """Join items with different final separator.

    Example:
        join_with_separator(["a", "b", "c"], ", ", " and ")
        # "a, b and c"
    """
    if items.len() == 0:
        return ""
    if items.len() == 1:
        return items[0]

    var result = items[0]
    var i = 1

    while i < items.len() - 1:
        result = result + separator + items[i]
        i = i + 1

    result = result + final_separator + items[items.len() - 1]
    result

fn join_natural(items) -> text:
    """Join items naturally with commas and 'and'.

    Example:
        join_natural(["Alice", "Bob", "Charlie"])
        # "Alice, Bob, and Charlie"
    """
    join_with_separator(items, ", ", ", and ")

# ============================================================================
# JSON Escaping
# ============================================================================

fn escape_json(s: text) -> text:
    """Escape special characters for JSON strings.

    Escapes: backslash, double quote, newline, carriage return, tab

    Example:
        escape_json("Hello\\n\\\"World\\\"") -> "Hello\\\\n\\\\\\\"World\\\\\\\""
    """
    var r = s.replace("\\", "\\\\")
    r = r.replace("\"", "\\\"")
    r = r.replace("\n", "\\n")
    r = r.replace("\r", "\\r")
    r = r.replace("\t", "\\t")
    r

# ============================================================================
# Exports
# ============================================================================

# Newline constants and functions
export LF, CR, CRLF, NL, _NL
export platform_newline, normalize_newlines

# Core character and string functions
export char_code, text_hash
export text_trim_start_matches, text_trim_end_matches
# text_contains_char, text_index_of_char, text_repeat removed - use contains_char, index_of_char, repeat_str
export text_pad_left, text_pad_right
export text_is_digit, text_is_alpha, text_is_alphanumeric
export repeat_str, reverse_str, join_strs
export contains_char, count_char, index_of_char, last_index_of_char
export starts_with_char, ends_with_char, char_at
export is_whitespace, is_empty, is_blank
export compare_case_insensitive, to_lowercase_str, to_uppercase_str, capitalize_first
export split_on_char, str_lines
# str_words removed - use split_whitespace
export char_from_code
export parse_i64_safe, char_to_digit
export escape_json

# Advanced character classification
export is_uppercase_char, is_lowercase_char

# Advanced tokenization
export split_whitespace, extract_words

# Line processing
export trim_lines, remove_empty_lines, number_lines
export prefix_lines, suffix_lines

# Advanced case conversion
export to_title_case, to_snake_case, to_camel_case

# Word operations
export word_count, word_wrap, reverse_words, longest_word

# Text analysis
export char_frequency, most_common_char, most_common_words

# Indentation
export detect_indent, normalize_indent, dedent_lines

# String similarity
export levenshtein_distance, hamming_distance

# Advanced text joining
export join_with_separator, join_natural

# Convenience aliases
export parse_i64, to_int_or, split_lines, string_hash
export string_to_lowercase, string_to_uppercase, string_trim, string_split
