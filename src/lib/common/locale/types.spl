# Locale Type Definitions and Core Operations
# Provides locale data structures, creation, parsing, and validation.

# ============================================================================
# GLOBAL STATE (Message Catalogs)
# ============================================================================

var global_messages = ""  # Will store serialized message catalog

# ============================================================================
# LOCALE CREATION AND PARSING
# ============================================================================

fn create_locale(language: text, region: text) -> (text, text, text, text):
    # Creates a locale tuple from language and region codes.
    # Returns: (language, region, script, variant)
    #
    # Args:
    #   language: ISO 639 language code (e.g., "en", "es", "fr")
    #   region: ISO 3166 region code (e.g., "US", "GB", "FR")
    #
    # Example:
    #   val locale = create_locale("en", "US")  # English (United States)
    (language, region, "", "")

fn create_locale_full(language: text, region: text, script: text, variant: text) -> (text, text, text, text):
    # Creates a complete locale tuple with all components.
    # Returns: (language, region, script, variant)
    #
    # Args:
    #   language: ISO 639 language code
    #   region: ISO 3166 region code
    #   script: ISO 15924 script code (e.g., "Hans", "Latn")
    #   variant: Variant identifier
    #
    # Example:
    #   val locale = create_locale_full("zh", "CN", "Hans", "")  # Simplified Chinese
    (language, region, script, variant)

fn parse_locale(locale_code: text) -> (text, text, text, text):
    # Parses a BCP 47 locale code into components.
    # Returns: (language, region, script, variant) or ("", "", "", "") on error
    #
    # Supported formats:
    #   "en" -> ("en", "", "", "")
    #   "en-US" -> ("en", "US", "", "")
    #   "zh-Hans-CN" -> ("zh", "CN", "Hans", "")
    #
    # Example:
    #   val locale = parse_locale("fr-FR")  # ("fr", "FR", "", "")

    var parts = locale_code.split("-")
    var len = parts.length()

    if len == 0:
        return ("", "", "", "")

    if len == 1:
        return (parts.get(0), "", "", "")

    if len == 2:
        return (parts.get(0), parts.get(1), "", "")

    if len == 3:
        return (parts.get(0), parts.get(2), parts.get(1), "")

    # len >= 4
    (parts.get(0), parts.get(2), parts.get(1), parts.get(3))

fn locale_to_code(locale: (text, text, text, text)) -> text:
    # Converts a locale tuple to BCP 47 code string.
    # Returns: Locale code string (e.g., "en-US", "zh-Hans-CN")
    #
    # Example:
    #   val code = locale_to_code(("en", "US", "", ""))  # "en-US"

    var language = locale.0
    var region = locale.1
    var script = locale.2
    var variant = locale.3

    var code = language

    if script != "":
        code = code + "-" + script

    if region != "":
        code = code + "-" + region

    if variant != "":
        code = code + "-" + variant

    code

fn default_locale() -> (text, text, text, text):
    # Returns the default locale (en-US).
    # Returns: ("en", "US", "", "")
    ("en", "US", "", "")

# ============================================================================
# LOCALE PROPERTY ACCESSORS
# ============================================================================

fn get_language(locale: (text, text, text, text)) -> text:
    # Gets the language code from a locale.
    # Example: get_language(("en", "US", "", "")) -> "en"
    locale.0

fn get_region(locale: (text, text, text, text)) -> text:
    # Gets the region code from a locale.
    # Example: get_region(("en", "US", "", "")) -> "US"
    locale.1

fn get_script(locale: (text, text, text, text)) -> text:
    # Gets the script code from a locale.
    # Example: get_script(("zh", "CN", "Hans", "")) -> "Hans"
    locale.2

fn get_variant(locale: (text, text, text, text)) -> text:
    # Gets the variant from a locale.
    # Example: get_variant(("en", "US", "", "posix")) -> "posix"
    locale.3

fn locale_equals(locale1: (text, text, text, text), locale2: (text, text, text, text)) -> bool:
    # Checks if two locales are equal.
    # Returns: true if all components match
    var lang_match = locale1.0 == locale2.0
    var region_match = locale1.1 == locale2.1
    var script_match = locale1.2 == locale2.2
    var variant_match = locale1.3 == locale2.3

    var first_check = lang_match and region_match
    var second_check = script_match and variant_match
    first_check and second_check

# ============================================================================
# COMMON LOCALE CONSTRUCTORS
# ============================================================================

fn locale_en_us() -> (text, text, text, text):
    # English (United States)
    ("en", "US", "", "")

fn locale_en_gb() -> (text, text, text, text):
    # English (United Kingdom)
    ("en", "GB", "", "")

fn locale_es_es() -> (text, text, text, text):
    # Spanish (Spain)
    ("es", "ES", "", "")

fn locale_es_mx() -> (text, text, text, text):
    # Spanish (Mexico)
    ("es", "MX", "", "")

fn locale_fr_fr() -> (text, text, text, text):
    # French (France)
    ("fr", "FR", "", "")

fn locale_fr_ca() -> (text, text, text, text):
    # French (Canada)
    ("fr", "CA", "", "")

fn locale_de_de() -> (text, text, text, text):
    # German (Germany)
    ("de", "DE", "", "")

fn locale_it_it() -> (text, text, text, text):
    # Italian (Italy)
    ("it", "IT", "", "")

fn locale_pt_br() -> (text, text, text, text):
    # Portuguese (Brazil)
    ("pt", "BR", "", "")

fn locale_pt_pt() -> (text, text, text, text):
    # Portuguese (Portugal)
    ("pt", "PT", "", "")

fn locale_ja_jp() -> (text, text, text, text):
    # Japanese (Japan)
    ("ja", "JP", "", "")

fn locale_zh_cn() -> (text, text, text, text):
    # Chinese (China, Simplified)
    ("zh", "CN", "Hans", "")

fn locale_zh_tw() -> (text, text, text, text):
    # Chinese (Taiwan, Traditional)
    ("zh", "TW", "Hant", "")

fn locale_ko_kr() -> (text, text, text, text):
    # Korean (South Korea)
    ("ko", "KR", "", "")

fn locale_ar_sa() -> (text, text, text, text):
    # Arabic (Saudi Arabia)
    ("ar", "SA", "", "")

fn locale_ar_ae() -> (text, text, text, text):
    # Arabic (UAE)
    ("ar", "AE", "", "")

fn locale_ru_ru() -> (text, text, text, text):
    # Russian (Russia)
    ("ru", "RU", "", "")

fn locale_hi_in() -> (text, text, text, text):
    # Hindi (India)
    ("hi", "IN", "", "")

fn locale_nl_nl() -> (text, text, text, text):
    # Dutch (Netherlands)
    ("nl", "NL", "", "")

fn locale_sv_se() -> (text, text, text, text):
    # Swedish (Sweden)
    ("sv", "SE", "", "")

fn locale_pl_pl() -> (text, text, text, text):
    # Polish (Poland)
    ("pl", "PL", "", "")

# ============================================================================
# LOCALE VALIDATION
# ============================================================================

fn is_valid_language_code(code: text) -> bool:
    # Checks if a language code is valid (simplified check).
    # Returns: true if valid ISO 639 code format

    var len = code.length()
    len == 2 or len == 3

fn is_valid_region_code(code: text) -> bool:
    # Checks if a region code is valid (simplified check).
    # Returns: true if valid ISO 3166 code format

    var len = code.length()
    len == 2

fn is_valid_locale(locale: (text, text, text, text)) -> bool:
    # Checks if a locale tuple is valid.
    # Returns: true if language code is valid

    var lang = locale.0
    is_valid_language_code(lang)
