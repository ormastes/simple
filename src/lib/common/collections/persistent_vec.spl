# Persistent Vector
#
# Immutable vector with structural sharing (array-copy implementation).
# Every mutation returns a NEW vector â€” original is never modified.

class PersistentVec:
    items: []

    fn len() -> i64:
        self.items.len()

    fn is_empty() -> bool:
        self.items.len() == 0

    fn push(element) -> PersistentVec:
        var new_items = []
        for item in self.items:
            new_items.push(item)
        new_items.push(element)
        PersistentVec(items: new_items)

    fn pop() -> PersistentVec:
        if self.items.len() == 0:
            return PersistentVec(items: [])
        var new_items = []
        val end_idx = self.items.len() - 1
        var i = 0
        for item in self.items:
            if i < end_idx:
                new_items.push(item)
            i = i + 1
        PersistentVec(items: new_items)

    fn get(index: i64):
        val n = self.items.len()
        if n == 0:
            return nil
        var idx = index
        if idx < 0:
            idx = n + idx
        if idx < 0:
            return nil
        if idx >= n:
            return nil
        self.items[idx]

    fn set(index: i64, value) -> PersistentVec:
        val n = self.items.len()
        var idx = index
        if idx < 0:
            idx = n + idx
        if idx < 0:
            return self.copy()
        if idx >= n:
            return self.copy()
        var new_items = []
        var i = 0
        for item in self.items:
            if i == idx:
                new_items.push(value)
            else:
                new_items.push(item)
            i = i + 1
        PersistentVec(items: new_items)

    fn first():
        if self.items.len() == 0:
            return nil
        self.items[0]

    fn last():
        if self.items.len() == 0:
            return nil
        self.items[self.items.len() - 1]

    fn contains(element) -> bool:
        for item in self.items:
            if item == element:
                return true
        false

    fn concat(other: PersistentVec) -> PersistentVec:
        var new_items = []
        for item in self.items:
            new_items.push(item)
        for item in other.items:
            new_items.push(item)
        PersistentVec(items: new_items)

    fn map(f: fn()) -> PersistentVec:
        var new_items = []
        for item in self.items:
            new_items.push(f(item))
        PersistentVec(items: new_items)

    fn filter(pred: fn()) -> PersistentVec:
        var new_items = []
        for item in self.items:
            if pred(item):
                new_items.push(item)
        PersistentVec(items: new_items)

    fn fold(init, f: fn()):
        var acc = init
        for item in self.items:
            acc = f(acc, item)
        acc

    fn take(n: i64) -> PersistentVec:
        var new_items = []
        var i = 0
        for item in self.items:
            if i < n:
                new_items.push(item)
            i = i + 1
        PersistentVec(items: new_items)

    fn drop(n: i64) -> PersistentVec:
        var new_items = []
        var i = 0
        for item in self.items:
            if i >= n:
                new_items.push(item)
            i = i + 1
        PersistentVec(items: new_items)

    fn slice(start_idx: i64, end_idx: i64) -> PersistentVec:
        var new_items = []
        var i = 0
        for item in self.items:
            val in_range = i >= start_idx and i < end_idx
            if in_range:
                new_items.push(item)
            i = i + 1
        PersistentVec(items: new_items)

    fn reverse() -> PersistentVec:
        var new_items = []
        val n = self.items.len()
        var i = n - 1
        for _ in self.items:
            new_items.push(self.items[i])
            i = i - 1
        PersistentVec(items: new_items)

    fn to_array():
        var result = []
        for item in self.items:
            result.push(item)
        result

    fn copy() -> PersistentVec:
        var new_items = []
        for item in self.items:
            new_items.push(item)
        PersistentVec(items: new_items)

fn PersistentVec__empty() -> PersistentVec:
    PersistentVec(items: [])

fn PersistentVec__from_array(arr) -> PersistentVec:
    var new_items = []
    for item in arr:
        new_items.push(item)
    PersistentVec(items: new_items)

fn PersistentVec__of(arr) -> PersistentVec:
    PersistentVec__from_array(arr)

export PersistentVec, PersistentVec__empty, PersistentVec__from_array, PersistentVec__of
