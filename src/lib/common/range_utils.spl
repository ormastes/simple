# Range Utilities
#
# Helper functions for working with ranges and intervals.
# Pure Simple implementation - no external dependencies.
#
# Supports numeric ranges, range operations, and interval arithmetic.
# All ranges are inclusive on both ends unless noted.
#
# Functions:
# - Range construction: make_range, range_from, range_to
# - Range predicates: in_range, overlaps, contains_range
# - Range operations: intersection, union, merge_ranges
# - Range iteration: range_map, range_fold, range_filter
# - Range transformation: expand, shrink, shift, split_range
# - Range queries: size, midpoint, clamp_to_range

# ============================================================================
# Range Construction
# ============================================================================

fn make_range(start: i64, end: i64):
    """Create a range from start to end (inclusive).

    Example:
        make_range(1, 10)  # Range from 1 to 10
    """
    [start, end]

fn range_from(start: i64, length: i64):
    """Create a range from start with given length.

    Example:
        range_from(5, 3)  # (start: 5, end: 7)
    """
    [start, start + length - 1]

fn range_to(end: i64, length: i64):
    """Create a range ending at end with given length.

    Example:
        range_to(10, 3)  # (start: 8, end: 10)
    """
    [end - length + 1, end]

fn unit_range():
    """Create a unit range [0, 0].

    Example:
        unit_range()  # [0, 0]
    """
    [0, 0]

fn infinite_range_from(start: i64):
    """Create a conceptual infinite range from start.

    Note: Represented with very large end value.

    Example:
        infinite_range_from(0)  # (start: 0, end: i64_max)
    """
    [start, 9223372036854775807]

# ============================================================================
# Range Predicates
# ============================================================================

fn in_range(value: i64, range):
    """Check if value is within range (inclusive).

    Example:
        in_range(5, (start: 1, end: 10))  # true
        in_range(15, (start: 1, end: 10))  # false
    """
    val s = range[0]
    val e = range[1]
    value >= s and value <= e

fn is_empty_range(range):
    """Check if range is empty (start > end).

    Example:
        is_empty_range((start: 5, end: 3))  # true
        is_empty_range((start: 1, end: 10))  # false
    """
    val s = range[0]
    val e = range[1]
    s > e

fn is_valid_range(range):
    """Check if range is valid (start <= end).

    Example:
        is_valid_range((start: 1, end: 10))  # true
        is_valid_range((start: 10, end: 5))  # false
    """
    not is_empty_range(range)

fn overlaps(range1, range2):
    """Check if two ranges overlap.

    Example:
        overlaps((start: 1, end: 5), (start: 3, end: 8))  # true
        overlaps((start: 1, end: 5), (start: 6, end: 10))  # false
    """
    val s1 = range1[0]
    val e1 = range1[1]
    val s2 = range2[0]
    val e2 = range2[1]
    s1 <= e2 and s2 <= e1

fn contains_range(outer, inner):
    """Check if outer range contains inner range.

    Example:
        contains_range((start: 1, end: 10), (start: 3, end: 7))  # true
        contains_range((start: 1, end: 10), (start: 8, end: 15))  # false
    """
    val s1 = outer[0]
    val e1 = outer[1]
    val s2 = inner[0]
    val e2 = inner[1]
    s1 <= s2 and e1 >= e2

fn is_adjacent(range1, range2):
    """Check if ranges are adjacent (touching but not overlapping).

    Example:
        is_adjacent((start: 1, end: 5), (start: 6, end: 10))  # true
        is_adjacent((start: 1, end: 5), (start: 7, end: 10))  # false
    """
    val s1 = range1[0]
    val e1 = range1[1]
    val s2 = range2[0]
    val e2 = range2[1]
    e1 + 1 == s2 or e2 + 1 == s1

# ============================================================================
# Range Operations
# ============================================================================

fn intersection(range1, range2):
    """Find intersection of two ranges.

    Returns Some(range) if they overlap, nil otherwise.

    Example:
        intersection((start: 1, end: 5), (start: 3, end: 8))
        # Some((start: 3, end: 5))
    """
    if not overlaps(range1, range2):
        return nil

    val s1 = range1[0]
    val e1 = range1[1]
    val s2 = range2[0]
    val e2 = range2[1]

    val new_start = if s1 > s2: s1 else: s2
    val new_end = if e1 < e2: e1 else: e2

    Some([new_start, new_end])

fn union_ranges(range1, range2):
    """Find union of two ranges.

    Returns Some(range) if they overlap or are adjacent, nil otherwise.

    Example:
        union_ranges((start: 1, end: 5), (start: 3, end: 8))
        # Some((start: 1, end: 8))
    """
    if not overlaps(range1, range2) and not is_adjacent(range1, range2):
        return nil

    val s1 = range1[0]
    val e1 = range1[1]
    val s2 = range2[0]
    val e2 = range2[1]

    val new_start = if s1 < s2: s1 else: s2
    val new_end = if e1 > e2: e1 else: e2

    Some([new_start, new_end])

fn merge_overlapping_ranges(ranges):
    """Merge all overlapping or adjacent ranges.

    Returns array of non-overlapping ranges.

    Example:
        merge_overlapping_ranges([
            (start: 1, end: 5),
            (start: 3, end: 8),
            (start: 10, end: 15)
        ])
        # [(start: 1, end: 8), (start: 10, end: 15)]
    """
    if ranges.len() == 0:
        return []

    # Sort ranges by start position
    var sorted = ranges
    var i = 0
    while i < sorted.len() - 1:
        var j = i + 1
        while j < sorted.len():
            val s1 = sorted[i][0]
            val s2 = sorted[j][0]
            if s2 < s1:
                val temp = sorted[i]
                sorted[i] = sorted[j]
                sorted[j] = temp
            j = j + 1
        i = i + 1

    var merged = [sorted[0]]
    i = 1

    while i < sorted.len():
        val last_idx = merged.len() - 1
        val current = sorted[i]

        val maybe_union = union_ranges(merged[last_idx], current)
        if val new_range = maybe_union:
            merged[last_idx] = new_range
        else:
            merged.push(current)

        i = i + 1

    merged

# ============================================================================
# Range Queries
# ============================================================================

fn range_size(range):
    """Calculate size (length) of range.

    Returns 0 for empty ranges.

    Example:
        range_size((start: 1, end: 10))  # 10
        range_size((start: 5, end: 5))   # 1
    """
    val s = range[0]
    val e = range[1]
    if s > e:
        return 0
    e - s + 1

fn range_midpoint(range):
    """Find midpoint of range.

    Example:
        range_midpoint((start: 1, end: 10))  # 5
        range_midpoint((start: 1, end: 11))  # 6
    """
    val s = range[0]
    val e = range[1]
    s + (e - s) / 2

fn clamp_to_range(value: i64, range):
    """Clamp value to be within range.

    Example:
        clamp_to_range(5, (start: 1, end: 10))   # 5
        clamp_to_range(15, (start: 1, end: 10))  # 10
        clamp_to_range(-5, (start: 1, end: 10))  # 1
    """
    val s = range[0]
    val e = range[1]
    if value < s:
        return s
    if value > e:
        return e
    value

fn range_distance(range1, range2):
    """Calculate distance between two ranges.

    Returns 0 if ranges overlap.

    Example:
        range_distance((start: 1, end: 5), (start: 8, end: 10))  # 2
        range_distance((start: 1, end: 5), (start: 3, end: 10))  # 0
    """
    if overlaps(range1, range2):
        return 0

    val s1 = range1[0]
    val e1 = range1[1]
    val s2 = range2[0]
    val e2 = range2[1]

    if e1 < s2:
        s2 - e1 - 1
    else:
        s1 - e2 - 1

# ============================================================================
# Range Transformation
# ============================================================================

fn expand_range(range, amount: i64):
    """Expand range by amount on both sides.

    Example:
        expand_range((start: 5, end: 10), 2)  # (start: 3, end: 12)
    """
    val s = range[0]
    val e = range[1]
    [s - amount, e + amount]

fn shrink_range(range, amount: i64):
    """Shrink range by amount on both sides.

    May result in empty range if amount is too large.

    Example:
        shrink_range((start: 5, end: 10), 1)  # (start: 6, end: 9)
    """
    val s = range[0]
    val e = range[1]
    [s + amount, e - amount]

fn shift_range(range, offset: i64):
    """Shift range by offset.

    Example:
        shift_range((start: 5, end: 10), 3)   # (start: 8, end: 13)
        shift_range((start: 5, end: 10), -2)  # (start: 3, end: 8)
    """
    val s = range[0]
    val e = range[1]
    [s + offset, e + offset]

fn split_range(range, at: i64):
    """Split range at position.

    Returns tuple of two ranges, or nil if position is outside range.

    Example:
        split_range((start: 1, end: 10), 5)
        # Some(((start: 1, end: 5), (start: 6, end: 10)))
    """
    val s = range[0]
    val e = range[1]

    if at < s or at > e:
        return nil

    val left = [s, at]
    val right = [at + 1, e]

    Some([left, right])

fn split_range_into_n(range, n: i64):
    """Split range into n roughly equal parts.

    Example:
        split_range_into_n((start: 1, end: 10), 3)
        # [(start: 1, end: 3), (start: 4, end: 6), (start: 7, end: 10)]
    """
    if n <= 0:
        return []

    val s = range[0]
    val e = range[1]
    val total_size = range_size(range)
    val chunk_size = total_size / n

    var result = []
    var current = s
    var i = 0

    while i < n - 1:
        val chunk_end = current + chunk_size - 1
        result.push([current, chunk_end])
        current = chunk_end + 1
        i = i + 1

    # Last chunk gets remainder
    result.push([current, e])

    result

# ============================================================================
# Range Iteration
# ============================================================================

fn range_to_array(range):
    """Convert range to array of values.

    Warning: Can be expensive for large ranges.

    Example:
        range_to_array((start: 1, end: 5))  # [1, 2, 3, 4, 5]
    """
    val s = range[0]
    val e = range[1]
    var result = []
    var i = s

    while i <= e:
        result.push(i)
        i = i + 1

    result

fn range_map(range, f):
    """Map function over range values.

    Example:
        range_map((start: 1, end: 5), \\x: x * 2)  # [2, 4, 6, 8, 10]
    """
    val s = range[0]
    val e = range[1]
    var result = []
    var i = s

    while i <= e:
        result.push(f(i))
        i = i + 1

    result

fn range_fold(range, initial, f):
    """Fold over range values.

    Example:
        range_fold((start: 1, end: 5), 0, \\acc, x: acc + x)  # 15
    """
    val s = range[0]
    val e = range[1]
    var acc = initial
    var i = s

    while i <= e:
        acc = f(acc, i)
        i = i + 1

    acc

fn range_filter(range, predicate):
    """Filter range values by predicate.

    Returns array of values that match predicate.

    Example:
        range_filter((start: 1, end: 10), \\x: x % 2 == 0)
        # [2, 4, 6, 8, 10]
    """
    val s = range[0]
    val e = range[1]
    var result = []
    var i = s

    while i <= e:
        if predicate(i):
            result.push(i)
        i = i + 1

    result

fn range_any(range, predicate):
    """Check if any value in range matches predicate.

    Example:
        range_any((start: 1, end: 10), \\x: x > 5)  # true
    """
    val s = range[0]
    val e = range[1]
    var i = s

    while i <= e:
        if predicate(i):
            return true
        i = i + 1

    false

fn range_all(range, predicate):
    """Check if all values in range match predicate.

    Example:
        range_all((start: 1, end: 10), \\x: x > 0)  # true
    """
    val s = range[0]
    val e = range[1]
    var i = s

    while i <= e:
        if not predicate(i):
            return false
        i = i + 1

    true

# ============================================================================
# Range Comparison
# ============================================================================

fn range_equals(range1, range2):
    """Check if two ranges are equal.

    Example:
        range_equals((start: 1, end: 10), (start: 1, end: 10))  # true
    """
    val s1 = range1[0]
    val e1 = range1[1]
    val s2 = range2[0]
    val e2 = range2[1]
    s1 == s2 and e1 == e2

fn range_before(range1, range2):
    """Check if range1 is completely before range2.

    Example:
        range_before((start: 1, end: 5), (start: 6, end: 10))  # true
    """
    val e1 = range1[1]
    val s2 = range2[0]
    e1 < s2

fn range_after(range1, range2):
    """Check if range1 is completely after range2.

    Example:
        range_after((start: 6, end: 10), (start: 1, end: 5))  # true
    """
    range_before(range2, range1)

# ============================================================================
# Range Utilities
# ============================================================================

fn normalize_range(range):
    """Normalize range so start <= end.

    Swaps start and end if start > end.

    Example:
        normalize_range((start: 10, end: 1))  # (start: 1, end: 10)
    """
    val s = range[0]
    val e = range[1]
    if s <= e:
        range
    else:
        [e, s]

fn range_complement(range, universe):
    """Find complement of range within universe.

    Returns array of ranges that are in universe but not in range.

    Example:
        range_complement((start: 5, end: 8), (start: 1, end: 10))
        # [(start: 1, end: 4), (start: 9, end: 10)]
    """
    val s = range[0]
    val e = range[1]
    val us = universe[0]
    val ue = universe[1]

    var result = []

    # Before range
    if us < s:
        result.push([us, s - 1])

    # After range
    if e < ue:
        result.push([e + 1, ue])

    result
