# bcrypt Key Derivation - Blowfish and Eksblowfish Implementation
#
# Contains the Blowfish cipher core, key schedule, and the Eksblowfish
# (Expensive Key Schedule) variant used by bcrypt.
#
# Depends on: types.spl (constants, bitwise ops, byte helpers)

use std.common.bcrypt.types.{*}

# ============================================================================
# BLOWFISH CIPHER - Core Implementation
# ============================================================================

# Create initial Blowfish state
# Returns tuple: (P-array, S-box0, S-box1, S-box2, S-box3)
fn blowfish_init_state() -> list[list[i64]]:
    var p_array = BLOWFISH_P_INIT
    var s0 = BLOWFISH_S0_INIT
    var s1 = BLOWFISH_S1_INIT
    var s2 = BLOWFISH_S2_INIT
    var s3 = BLOWFISH_S3_INIT
    [p_array, s0, s1, s2, s3]

# Blowfish F-function (Feistel function)
# Takes 32-bit input and S-boxes, returns 32-bit output
fn blowfish_f(x: i64, s_boxes: list[list[i64]]) -> i64:
    var s0 = s_boxes[0]
    var s1 = s_boxes[1]
    var s2 = s_boxes[2]
    var s3 = s_boxes[3]

    # Split x into 4 bytes
    var a = extract_byte(x, 0)
    var b = extract_byte(x, 1)
    var c = extract_byte(x, 2)
    var d = extract_byte(x, 3)

    # F = ((S0[a] + S1[b]) XOR S2[c]) + S3[d]
    var s0_val = s0[a]
    var s1_val = s1[b]
    var s2_val = s2[c]
    var s3_val = s3[d]

    var temp1 = u32_add(s0_val, s1_val)
    var temp2 = u32_xor(temp1, s2_val)
    var result = u32_add(temp2, s3_val)
    result

# Blowfish encryption of one 64-bit block
# Returns tuple: (left32, right32)
fn blowfish_encrypt_block(left: i64, right: i64, state: list[list[i64]]) -> list[i64]:
    var p_array = state[0]
    var s_boxes = [state[1], state[2], state[3], state[4]]

    var l = left
    var r = right

    # 16 rounds of Feistel network
    var round = 0
    while round < BLOWFISH_ROUNDS:
        l = u32_xor(l, p_array[round])
        var f_result = blowfish_f(l, s_boxes)
        r = u32_xor(r, f_result)

        # Swap L and R
        var temp = l
        l = r
        r = temp

        round = round + 1

    # Undo last swap
    var temp = l
    l = r
    r = temp

    # Final XORs
    r = u32_xor(r, p_array[16])
    l = u32_xor(l, p_array[17])

    [l, r]

# Blowfish decryption of one 64-bit block (for completeness)
fn blowfish_decrypt_block(left: i64, right: i64, state: list[list[i64]]) -> list[i64]:
    var p_array = state[0]
    var s_boxes = [state[1], state[2], state[3], state[4]]

    var l = left
    var r = right

    # Run in reverse
    l = u32_xor(l, p_array[17])
    r = u32_xor(r, p_array[16])

    var round = BLOWFISH_ROUNDS - 1
    while round >= 0:
        var temp = l
        l = r
        r = temp

        var f_result = blowfish_f(l, s_boxes)
        r = u32_xor(r, f_result)
        l = u32_xor(l, p_array[round])

        round = round - 1

    [l, r]

# ============================================================================
# BLOWFISH KEY SCHEDULE
# ============================================================================

# Expand key into P-array and S-boxes
fn blowfish_expand_key(key_bytes: list[i64], state: list[list[i64]]) -> list[list[i64]]:
    var p_array = state[0]
    var s0 = state[1]
    var s1 = state[2]
    var s2 = state[3]
    var s3 = state[4]

    # XOR key bytes into P-array (cycling through key if necessary)
    var key_len = key_bytes.length()
    var key_pos = 0
    var i = 0
    while i < BLOWFISH_P_ARRAY_SIZE:
        var key_word = 0
        var j = 0
        while j < 4:
            var key_byte = key_bytes[key_pos]
            key_word = u32_or(u32_shl(key_word, 8), key_byte)
            key_pos = (key_pos + 1) % key_len
            j = j + 1
        p_array[i] = u32_xor(p_array[i], key_word)
        i = i + 1

    # Encrypt all-zero string to initialize P and S
    var left = 0
    var right = 0

    # Update P-array
    i = 0
    while i < BLOWFISH_P_ARRAY_SIZE:
        var temp_state = [p_array, s0, s1, s2, s3]
        var encrypted = blowfish_encrypt_block(left, right, temp_state)
        left = encrypted[0]
        right = encrypted[1]
        p_array[i] = left
        p_array[i + 1] = right
        i = i + 2

    # Update S-boxes
    var box_idx = 0
    while box_idx < 4:
        var s_box = [s0, s1, s2, s3][box_idx]
        i = 0
        while i < BLOWFISH_S_BOX_SIZE:
            var temp_state = [p_array, s0, s1, s2, s3]
            var encrypted = blowfish_encrypt_block(left, right, temp_state)
            left = encrypted[0]
            right = encrypted[1]
            s_box[i] = left
            s_box[i + 1] = right
            i = i + 2

        # Update the appropriate S-box
        if box_idx == 0: s0 = s_box
        if box_idx == 1: s1 = s_box
        if box_idx == 2: s2 = s_box
        if box_idx == 3: s3 = s_box

        box_idx = box_idx + 1

    [p_array, s0, s1, s2, s3]

# ============================================================================
# EKSBLOWFISH - Expensive Key Schedule
# ============================================================================

# Expand key with salt (Eksblowfish modification)
fn eksblowfish_expand_key_with_salt(key_bytes: list[i64], salt_bytes: list[i64], state: list[list[i64]]) -> list[list[i64]]:
    var p_array = state[0]
    var s0 = state[1]
    var s1 = state[2]
    var s2 = state[3]
    var s3 = state[4]

    # XOR key into P-array (same as Blowfish)
    var key_len = key_bytes.length()
    var key_pos = 0
    var i = 0
    while i < BLOWFISH_P_ARRAY_SIZE:
        var key_word = 0
        var j = 0
        while j < 4:
            var key_byte = key_bytes[key_pos]
            key_word = u32_or(u32_shl(key_word, 8), key_byte)
            key_pos = (key_pos + 1) % key_len
            j = j + 1
        p_array[i] = u32_xor(p_array[i], key_word)
        i = i + 1

    # Encrypt with salt instead of zeros
    var salt_len = salt_bytes.length()
    var salt_pos = 0
    var left = 0
    var right = 0

    # Update P-array with salt
    i = 0
    while i < BLOWFISH_P_ARRAY_SIZE:
        # Build left and right from salt
        var j = 0
        while j < 4:
            left = u32_or(u32_shl(left, 8), salt_bytes[salt_pos])
            salt_pos = (salt_pos + 1) % salt_len
            j = j + 1

        j = 0
        while j < 4:
            right = u32_or(u32_shl(right, 8), salt_bytes[salt_pos])
            salt_pos = (salt_pos + 1) % salt_len
            j = j + 1

        var temp_state = [p_array, s0, s1, s2, s3]
        var encrypted = blowfish_encrypt_block(left, right, temp_state)
        left = encrypted[0]
        right = encrypted[1]
        p_array[i] = left
        p_array[i + 1] = right
        i = i + 2

    # Update S-boxes with salt
    var box_idx = 0
    while box_idx < 4:
        var s_box = [s0, s1, s2, s3][box_idx]
        i = 0
        while i < BLOWFISH_S_BOX_SIZE:
            var j = 0
            while j < 4:
                left = u32_or(u32_shl(left, 8), salt_bytes[salt_pos])
                salt_pos = (salt_pos + 1) % salt_len
                j = j + 1

            j = 0
            while j < 4:
                right = u32_or(u32_shl(right, 8), salt_bytes[salt_pos])
                salt_pos = (salt_pos + 1) % salt_len
                j = j + 1

            var temp_state = [p_array, s0, s1, s2, s3]
            var encrypted = blowfish_encrypt_block(left, right, temp_state)
            left = encrypted[0]
            right = encrypted[1]
            s_box[i] = left
            s_box[i + 1] = right
            i = i + 2

        if box_idx == 0: s0 = s_box
        if box_idx == 1: s1 = s_box
        if box_idx == 2: s2 = s_box
        if box_idx == 3: s3 = s_box

        box_idx = box_idx + 1

    [p_array, s0, s1, s2, s3]

# Perform Eksblowfish key setup with cost factor
fn eksblowfish_setup(password: text, salt_bytes: list[i64], cost: i64) -> list[list[i64]]:
    var key_bytes = text_to_bytes(password)
    var state = blowfish_init_state()

    # Initial expansion with key and salt
    state = eksblowfish_expand_key_with_salt(key_bytes, salt_bytes, state)

    # Repeat 2^cost times
    var rounds = 1
    var i = 0
    while i < cost:
        rounds = rounds * 2
        i = i + 1

    var round = 0
    while round < rounds:
        state = blowfish_expand_key(key_bytes, state)
        state = blowfish_expand_key(salt_bytes, state)
        round = round + 1

    state
