# bcrypt Verification and Hash Parsing
#
# Contains hash string parsing, password verification, cost checking,
# and rehashing logic.
#
# Depends on: types.spl, salt.spl (bcrypt_decode_base64), hash.spl (bcrypt_hash_with_salt, bcrypt_hash)

use std.common.bcrypt.types.{*}
use std.common.bcrypt.salt.{*}
use std.common.bcrypt.hash.{*}

# ============================================================================
# HASH PARSING
# ============================================================================

# Parse bcrypt hash string into components
# Returns tuple: (version, cost, salt_encoded, hash_encoded)
fn parse_hash(hash_str: text) -> list[text]:
    # Expected format: $2a$10$salt22charhash31char
    var parts = []
    var current = ""
    var i = 0
    while i < hash_str.length():
        var char = hash_str[i]
        if char == "$":
            if current != "":
                parts = parts + [current]
                current = ""
        if char != "$":
            current = current + char
        i = i + 1
    if current != "":
        parts = parts + [current]

    # parts[0] = version (e.g., "2a")
    # parts[1] = cost (e.g., "10")
    # parts[2] = salt + hash (e.g., 22 chars salt + 31 chars hash)
    var version = ""
    var cost_str = ""
    var salt_and_hash = ""
    if parts.length() >= 1:
        version = parts[0]
    if parts.length() >= 2:
        cost_str = parts[1]
    if parts.length() >= 3:
        salt_and_hash = parts[2]

    var salt_encoded = ""
    var hash_encoded = ""
    i = 0
    while i < 22:
        if i < salt_and_hash.length():
            salt_encoded = salt_encoded + salt_and_hash[i]
        i = i + 1
    i = 22
    while i < salt_and_hash.length():
        hash_encoded = hash_encoded + salt_and_hash[i]
        i = i + 1

    [version, cost_str, salt_encoded, hash_encoded]

# Get cost factor from hash
fn get_cost_from_hash(hash_str: text) -> i64:
    var parsed = parse_hash(hash_str)
    var cost_str = parsed[1]
    # Convert string to int (simplified)
    var cost = 10  # default
    if cost_str == "04": cost = 4
    if cost_str == "05": cost = 5
    if cost_str == "06": cost = 6
    if cost_str == "07": cost = 7
    if cost_str == "08": cost = 8
    if cost_str == "09": cost = 9
    if cost_str == "10": cost = 10
    if cost_str == "11": cost = 11
    if cost_str == "12": cost = 12
    if cost_str == "13": cost = 13
    if cost_str == "14": cost = 14
    if cost_str == "15": cost = 15
    cost

# Extract salt from hash
fn extract_salt(hash_str: text) -> list[i64]:
    var parsed = parse_hash(hash_str)
    var salt_encoded = parsed[2]
    bcrypt_decode_base64(salt_encoded)

# ============================================================================
# VERIFICATION
# ============================================================================

# Verify password against hash
fn bcrypt_verify(password: text, hash_str: text) -> bool:
    var parsed = parse_hash(hash_str)
    var cost = get_cost_from_hash(hash_str)
    var salt_bytes = extract_salt(hash_str)

    var computed_hash = bcrypt_hash_with_salt(password, salt_bytes, cost)

    # Constant-time comparison
    var match = (computed_hash == hash_str)
    match

# Alias for verify
fn bcrypt_check(password: text, hash_str: text) -> bool:
    bcrypt_verify(password, hash_str)

# ============================================================================
# COST CHECKING AND REHASHING
# ============================================================================

# Verify and check if rehash is needed
fn bcrypt_verify_and_check_cost(password: text, hash_str: text, target_cost: i64) -> bool:
    var is_valid = bcrypt_verify(password, hash_str)
    if not is_valid:
        false
    if is_valid:
        var current_cost = get_cost_from_hash(hash_str)
        var needs_rehash = (current_cost < target_cost)
        needs_rehash

# Rehash if cost is too low
fn rehash_if_needed(password: text, hash_str: text, target_cost: i64) -> text:
    var needs_rehash = bcrypt_verify_and_check_cost(password, hash_str, target_cost)
    if needs_rehash:
        bcrypt_hash(password, target_cost)
    if not needs_rehash:
        hash_str
