# bcrypt Hash Functions
#
# Contains the core bcrypt hashing logic: the internal hash function that
# encrypts the magic string, hash formatting, and the public hash API.
#
# Depends on: types.spl, key_derivation.spl, salt.spl

use std.common.bcrypt.types.{*}
use std.common.bcrypt.key_derivation.{*}
use std.common.bcrypt.salt.{*}

# ============================================================================
# BCRYPT HASH FUNCTIONS
# ============================================================================

# Core bcrypt hashing function
fn bcrypt_hash_internal(password: text, salt_bytes: list[i64], cost: i64) -> list[i64]:
    # Perform Eksblowfish key setup
    var state = eksblowfish_setup(password, salt_bytes, cost)

    # Encrypt magic string "OrpheanBeholderScryDoubt" (24 bytes) 64 times
    var magic_bytes = text_to_bytes(BCRYPT_MAGIC)
    var ciphertext = magic_bytes

    var round = 0
    while round < 64:
        # Encrypt in 8-byte blocks
        var i = 0
        while i < ciphertext.length():
            if i + 7 < ciphertext.length():
                # Pack 8 bytes into two 32-bit words
                var left = pack_u32(ciphertext[i], ciphertext[i + 1], ciphertext[i + 2], ciphertext[i + 3])
                var right = pack_u32(ciphertext[i + 4], ciphertext[i + 5], ciphertext[i + 6], ciphertext[i + 7])

                # Encrypt
                var encrypted = blowfish_encrypt_block(left, right, state)
                var enc_left = encrypted[0]
                var enc_right = encrypted[1]

                # Unpack back to bytes
                ciphertext[i] = extract_byte(enc_left, 0)
                ciphertext[i + 1] = extract_byte(enc_left, 1)
                ciphertext[i + 2] = extract_byte(enc_left, 2)
                ciphertext[i + 3] = extract_byte(enc_left, 3)
                ciphertext[i + 4] = extract_byte(enc_right, 0)
                ciphertext[i + 5] = extract_byte(enc_right, 1)
                ciphertext[i + 6] = extract_byte(enc_right, 2)
                ciphertext[i + 7] = extract_byte(enc_right, 3)
            i = i + 8
        round = round + 1

    # Return first 23 bytes as hash
    var hash_bytes = []
    var i = 0
    while i < BCRYPT_HASH_LEN:
        if i < ciphertext.length():
            hash_bytes = hash_bytes + [ciphertext[i]]
        i = i + 1
    hash_bytes

# Format bcrypt hash string
fn format_hash(salt_bytes: list[i64], cost: i64, hash_bytes: list[i64]) -> text:
    var version = "$2a$"
    var cost_str = ""
    if cost < 10:
        cost_str = "0" + cost.to_text()
    if cost >= 10:
        cost_str = cost.to_text()
    var salt_encoded = encode_salt(salt_bytes, cost)
    var hash_encoded = bcrypt_encode_base64(hash_bytes)

    # Trim hash to 31 chars
    var hash_trimmed = ""
    var i = 0
    while i < 31:
        if i < hash_encoded.length():
            hash_trimmed = hash_trimmed + hash_encoded[i]
        i = i + 1

    version + cost_str + "$" + salt_encoded + hash_trimmed

# Hash password with specified cost
fn bcrypt_hash(password: text, cost: i64) -> text:
    var salt_bytes = generate_salt()
    bcrypt_hash_with_salt(password, salt_bytes, cost)

# Hash password with provided salt
fn bcrypt_hash_with_salt(password: text, salt_bytes: list[i64], cost: i64) -> text:
    var hash_bytes = bcrypt_hash_internal(password, salt_bytes, cost)
    format_hash(salt_bytes, cost, hash_bytes)

# Create hash with default cost
fn bcrypt_hash_default(password: text) -> text:
    bcrypt_hash(password, DEFAULT_COST)

# Create hash with high security cost
fn bcrypt_hash_secure(password: text) -> text:
    bcrypt_hash(password, RECOMMENDED_COST)
