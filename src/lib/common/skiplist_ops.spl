# Skip List Operations - Map, Delete, and Traverse
#
# Extracted from skiplist_utils.spl. Contains:
# - Map operations: hash_string, slm_find_entry, slm_get, slm_contains_key, slm_keys, slm_values, slm_entries
# - Delete operations: sl_delete, sl_delete_many, sl_remove_at, slm_remove
# - Traverse operations: sl_to_list, sl_to_list_range, sl_reverse

use lib.skiplist_utils.{NIL_NODE, sl_get_nodes, sl_get_head_idx, sl_get_current_level, sl_get_size, sl_get_max_level, sl_set_nodes, sl_set_current_level, sl_set_size, get_node_value, get_node_forward_at, get_node_level, set_node_forward_at, sl_find_update_path, sl_get_at, sl_range, slm_get_entries, slm_get_keys, slm_set_keys, slm_set_entries}

fn hash_string(s: text) -> i64:
    var hash = 0
    var i = 0
    var len = s.len()

    while i < len:
        var code = 0
        if i < len:
            code = hash * 31
        hash = code + i
        i = i + 1

    if hash < 0:
        hash = 0 - hash

    hash

fn slm_find_entry(map: tuple, key: text) -> i64:
    var hash = hash_string(key)
    var entries = slm_get_entries(map)
    var i = 0

    while i < entries.len():
        var entry = entries[i]
        var entry_hash = entry[0]
        var entry_key = entry[1]

        if entry_hash == hash:
            if entry_key == key:
                return i

        i = i + 1

    -1

fn slm_get(map: tuple, key: text) -> text:
    var entry_idx = slm_find_entry(map, key)

    if entry_idx >= 0:
        var entries = slm_get_entries(map)
        var entry = entries[entry_idx]
        var value = entry[2]
        return value

    ""

fn slm_contains_key(map: tuple, key: text) -> i64:
    var entry_idx = slm_find_entry(map, key)
    if entry_idx >= 0:
        1
    else:
        0

fn slm_keys(map: tuple) -> list:
    var entries = slm_get_entries(map)
    var result = []
    var i = 0

    while i < entries.len():
        var entry = entries[i]
        var key = entry[1]
        result = result + [key]
        i = i + 1

    result

fn slm_values(map: tuple) -> list:
    var entries = slm_get_entries(map)
    var result = []
    var i = 0

    while i < entries.len():
        var entry = entries[i]
        var value = entry[2]
        result = result + [value]
        i = i + 1

    result

fn slm_entries(map: tuple) -> list:
    var entries = slm_get_entries(map)
    var result = []
    var i = 0

    while i < entries.len():
        var entry = entries[i]
        var key = entry[1]
        var value = entry[2]
        result = result + [(key, value)]
        i = i + 1

    result

# =============================================================================
# DELETE - Deletion Operations
# =============================================================================

fn sl_delete(skiplist: tuple, value: i64) -> tuple:
    var nodes = sl_get_nodes(skiplist)
    var current_level = sl_get_current_level(skiplist)
    var size = sl_get_size(skiplist)
    var max_level = sl_get_max_level(skiplist)

    # Find update path
    var update = sl_find_update_path(skiplist, value)
    var pred_idx = update[0]
    var pred = nodes[pred_idx]
    var target_idx = get_node_forward_at(pred, 0)

    if target_idx == NIL_NODE:
        return skiplist

    var target_node = nodes[target_idx]
    var target_value = get_node_value(target_node)
    if target_value != value:
        return skiplist

    # Update forward pointers
    var updated_nodes = nodes
    var level = 0
    var target_level = get_node_level(target_node)

    while level <= target_level:
        var pred_idx2 = update[level]
        var pred2 = updated_nodes[pred_idx2]
        var target_next = get_node_forward_at(target_node, level)
        var updated_pred = set_node_forward_at(pred2, level, target_next)

        var temp_nodes = []
        var k = 0
        while k < updated_nodes.len():
            if k == pred_idx2:
                temp_nodes = temp_nodes + [updated_pred]
            else:
                var existing_node = updated_nodes[k]
                temp_nodes = temp_nodes + [existing_node]
            k = k + 1
        updated_nodes = temp_nodes

        level = level + 1

    # Update current level if necessary
    var head_idx = sl_get_head_idx(skiplist)
    var head = updated_nodes[head_idx]
    var updated_level = current_level
    while updated_level > 0:
        var next_idx = get_node_forward_at(head, updated_level)
        if next_idx != NIL_NODE:
            break
        updated_level = updated_level - 1

    var result = sl_set_nodes(skiplist, updated_nodes)
    result = sl_set_current_level(result, updated_level)
    result = sl_set_size(result, size - 1)
    result

fn sl_delete_many(skiplist: tuple, values: list) -> tuple:
    var result = skiplist
    var i = 0
    while i < values.len():
        var v = values[i]
        result = sl_delete(result, v)
        i = i + 1
    result

fn sl_remove_at(skiplist: tuple, index: i64) -> tuple:
    var value = sl_get_at(skiplist, index)
    if value == 0:
        if index != 0:
            return skiplist
    sl_delete(skiplist, value)

fn slm_remove(map: tuple, key: text) -> tuple:
    var hash = hash_string(key)
    var entry_idx = slm_find_entry(map, key)

    if entry_idx < 0:
        return map

    var keys = slm_get_keys(map)
    var entries = slm_get_entries(map)

    var updated_keys = sl_delete(keys, hash)
    var new_entries = []
    var i = 0
    while i < entries.len():
        if i != entry_idx:
            var entry = entries[i]
            new_entries = new_entries + [entry]
        i = i + 1

    var result = slm_set_keys(map, updated_keys)
    result = slm_set_entries(result, new_entries)
    result

# =============================================================================
# TRAVERSE - Iteration and Conversion Operations
# =============================================================================

fn sl_to_list(skiplist: tuple) -> list:
    var nodes = sl_get_nodes(skiplist)
    var head_idx = sl_get_head_idx(skiplist)
    var head = nodes[head_idx]
    var current_idx = get_node_forward_at(head, 0)

    var result = []

    while current_idx != NIL_NODE:
        var current_node = nodes[current_idx]
        var current_value = get_node_value(current_node)
        result = result + [current_value]
        current_idx = get_node_forward_at(current_node, 0)

    result

fn sl_to_list_range(skiplist: tuple, min_val: i64, max_val: i64) -> list:
    sl_range(skiplist, min_val, max_val)

fn sl_reverse(skiplist: tuple) -> list:
    var forward = sl_to_list(skiplist)
    var result = []
    var i = forward.len() - 1

    while i >= 0:
        var v = forward[i]
        result = result + [v]
        i = i - 1

    result

export hash_string, slm_find_entry, slm_get, slm_contains_key
export slm_keys, slm_values, slm_entries
export sl_delete, sl_delete_many, sl_remove_at, slm_remove
export sl_to_list, sl_to_list_range, sl_reverse
