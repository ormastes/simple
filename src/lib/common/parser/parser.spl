# Pure Simple Parser (Refactored)
# Core parser methods and statement parsing. Expression parsing is in parser_expr.spl.

use std.parser.lexer (Token, TokenKind, lex_source)
use std.parser.ast (Expr, Stmt, Pattern, TypeExpr, Module, BinOp, UnaryOp, Literal)

# Expression parsing methods added to Parser via impl block in parser_expr.spl
use lib.common.parser.parser_expr.{*}

export parse, parse_expr, parse_stmt, ParseError, Parser

# Parse error
struct ParseError:
    message: text
    line: i64
    column: i64

# Parser state with all parsing methods
class Parser:
    tokens: [Token]
    current: i64

    # ===== Core Parser Methods =====

    fn is_at_end() -> bool:
        if self.current >= self.tokens.len():
            true
        else:
            match self.tokens[self.current].kind:
                case TokenKind.Eof: true
                case _: false

    fn peek() -> Token:
        if self.current < self.tokens.len():
            self.tokens[self.current]
        else:
            self.tokens[self.tokens.len() - 1]

    fn previous() -> Token:
        if self.current > 0:
            self.tokens[self.current - 1]
        else:
            self.tokens[0]

    me advance() -> Token:
        if not self.is_at_end():
            self.current = self.current + 1
        self.previous()

    fn check(kind: text) -> bool:
        if self.is_at_end():
            false
        else:
            match self.peek().kind:
                case TokenKind.Keyword(k): k == kind
                case TokenKind.Operator(o): o == kind
                case _: false

    me consume_keyword(keyword: text) -> bool:
        if self.check(keyword):
            self.advance()
            true
        else:
            false

    me consume_operator(op: text) -> bool:
        if self.check(op):
            self.advance()
            true
        else:
            false

    me match_token(kind: TokenKind) -> bool:
        if self.is_at_end():
            false
        else:
            match self.peek().kind:
                case k:
                    if k == kind:
                        self.advance()
                        true
                    else:
                        false

    # ===== Statement Parsing =====

    me parse_statement() -> Result<Stmt, ParseError>:
        # Skip newlines
        while self.match_token(TokenKind.Newline):
            ()

        # Import statement
        if self.check("use"):
            return self.parse_import()

        # Export statement
        if self.check("export"):
            return self.parse_export()

        # Function definition
        if self.check("fn"):
            return self.parse_function()

        # Variable declaration
        if self.check("val") or self.check("var"):
            return self.parse_let()

        # Struct definition
        if self.check("struct"):
            return self.parse_struct()

        # Enum definition
        if self.check("enum"):
            return self.parse_enum()

        # Return statement
        if self.check("return"):
            return self.parse_return()

        # While loop
        if self.check("while"):
            return self.parse_while()

        # For loop
        if self.check("for"):
            return self.parse_for()

        # Expression statement
        match self.parse_expression():
            case Ok(expr):
                Ok(Stmt.Expr(expr))
            case Err(e):
                Err(e)

    me parse_function() -> Result<Stmt, ParseError>:
        self.consume_keyword("fn")

        # Function name
        val name = match self.peek().kind:
            case TokenKind.Identifier(n):
                self.advance()
                n
            case _:
                return Err(ParseError(
                    message: "Expected function name",
                    line: self.peek().line,
                    column: self.peek().column
                ))

        # Parameters
        self.consume_operator("(")
        var params: [text] = []

        while not self.check(")"):
            match self.peek().kind:
                case TokenKind.Identifier(p):
                    self.advance()
                    params.push(p)
                    if not self.check(")"):
                        self.consume_operator(",")
                case _:
                    break

        self.consume_operator(")")

        # Return type (optional)
        var return_type: TypeExpr? = nil
        if self.consume_operator("->"):
            match self.parse_type():
                case Ok(t):
                    return_type = Some(t)
                case Err(e):
                    return Err(e)

        # Body
        self.consume_operator(":")
        match self.parse_block():
            case Ok(body):
                Ok(Stmt.Function(name, params, return_type, body))
            case Err(e):
                Err(e)

    me parse_let() -> Result<Stmt, ParseError>:
        val is_val = self.consume_keyword("val")
        if not is_val:
            self.consume_keyword("var")

        # Variable name
        val name = match self.peek().kind:
            case TokenKind.Identifier(n):
                self.advance()
                n
            case _:
                return Err(ParseError(
                    message: "Expected variable name",
                    line: self.peek().line,
                    column: self.peek().column
                ))

        # Type annotation (optional)
        var type_expr: TypeExpr? = nil
        if self.consume_operator(":"):
            match self.parse_type():
                case Ok(t):
                    type_expr = Some(t)
                case Err(e):
                    return Err(e)

        # Initializer
        self.consume_operator("=")
        match self.parse_expression():
            case Ok(expr):
                Ok(Stmt.Let(name, type_expr, expr))
            case Err(e):
                Err(e)

    me parse_struct() -> Result<Stmt, ParseError>:
        self.consume_keyword("struct")

        val name = match self.peek().kind:
            case TokenKind.Identifier(n):
                self.advance()
                n
            case _:
                return Err(ParseError(
                    message: "Expected struct name",
                    line: self.peek().line,
                    column: self.peek().column
                ))

        self.consume_operator(":")

        var fields: [(text, TypeExpr)] = []
        # Parse fields (simplified)

        Ok(Stmt.Struct(name, fields))

    me parse_enum() -> Result<Stmt, ParseError>:
        self.consume_keyword("enum")

        val name = match self.peek().kind:
            case TokenKind.Identifier(n):
                self.advance()
                n
            case _:
                return Err(ParseError(
                    message: "Expected enum name",
                    line: self.peek().line,
                    column: self.peek().column
                ))

        self.consume_operator(":")

        var variants: [(text, [TypeExpr])] = []
        # Parse variants (simplified)

        Ok(Stmt.Enum(name, variants))

    me parse_return() -> Result<Stmt, ParseError>:
        self.consume_keyword("return")

        if self.check("\n") or self.is_at_end():
            Ok(Stmt.Return(nil))
        else:
            match self.parse_expression():
                case Ok(expr):
                    Ok(Stmt.Return(Some(expr)))
                case Err(e):
                    Err(e)

    me parse_while() -> Result<Stmt, ParseError>:
        self.consume_keyword("while")

        match self.parse_expression():
            case Ok(cond):
                self.consume_operator(":")
                match self.parse_block():
                    case Ok(body):
                        Ok(Stmt.While(cond, body))
                    case Err(e):
                        Err(e)
            case Err(e):
                Err(e)

    me parse_for() -> Result<Stmt, ParseError>:
        self.consume_keyword("for")

        val var_name = match self.peek().kind:
            case TokenKind.Identifier(n):
                self.advance()
                n
            case _:
                return Err(ParseError(
                    message: "Expected loop variable",
                    line: self.peek().line,
                    column: self.peek().column
                ))

        self.consume_keyword("in")

        match self.parse_expression():
            case Ok(iter):
                self.consume_operator(":")
                match self.parse_block():
                    case Ok(body):
                        Ok(Stmt.For(var_name, iter, body))
                    case Err(e):
                        Err(e)
            case Err(e):
                Err(e)

    me parse_import() -> Result<Stmt, ParseError>:
        # use module.{name1, name2}
        self.consume_keyword("use")

        # Parse module path (e.g., "std.pure.parser")
        var module_path = ""
        while true:
            match self.peek().kind:
                case TokenKind.Identifier(name):
                    self.advance()
                    module_path = if module_path == "": name else: module_path + "." + name
                case _:
                    break

            if self.check("."):
                self.advance()
            else:
                break

        if module_path == "":
            return Err(ParseError(
                message: "Expected module name after 'use'",
                line: self.peek().line,
                column: self.peek().column
            ))

        # Parse imported names: {name1, name2} or nothing
        var names: [text] = []

        if self.check("{"):
            self.advance()

            while not self.check("}") and not self.is_at_end():
                match self.peek().kind:
                    case TokenKind.Identifier(name):
                        self.advance()
                        names.push(name)
                    case _:
                        return Err(ParseError(
                            message: "Expected name in import list",
                            line: self.peek().line,
                            column: self.peek().column
                        ))

                if self.check("}"):
                    break
                elif self.check(","):
                    self.advance()
                else:
                    return Err(ParseError(
                        message: "Expected ',' or '}' in import list",
                        line: self.peek().line,
                        column: self.peek().column
                    ))

            self.consume_operator("}")

        Ok(Stmt.Import(module_path, names))

    me parse_export() -> Result<Stmt, ParseError>:
        # export name1, name2
        self.consume_keyword("export")

        var names: [text] = []

        while true:
            match self.peek().kind:
                case TokenKind.Identifier(name):
                    self.advance()
                    names.push(name)
                case _:
                    if names.len() == 0:
                        return Err(ParseError(
                            message: "Expected name after 'export'",
                            line: self.peek().line,
                            column: self.peek().column
                        ))
                    break

            if self.check(","):
                self.advance()
            else:
                break

        Ok(Stmt.Export(names))

    me parse_block() -> Result<[Stmt], ParseError>:
        var statements: [Stmt] = []

        # Expect newline after colon
        while self.match_token(TokenKind.Newline):
            ()

        # Expect indent
        if not self.match_token(TokenKind.Indent):
            # Single-line block (inline)
            match self.parse_statement():
                case Ok(stmt):
                    statements.push(stmt)
                    return Ok(statements)
                case Err(e):
                    return Err(e)

        # Multi-line block: parse until dedent
        while not self.match_token(TokenKind.Dedent) and not self.is_at_end():
            # Skip empty lines
            if self.match_token(TokenKind.Newline):
                ()
            else:
                match self.parse_statement():
                    case Ok(stmt):
                        statements.push(stmt)
                    case Err(e):
                        return Err(e)

        Ok(statements)


# ===== Public API Functions =====

fn parse(source: text) -> Result<Module, ParseError>:
    val tokens = lex_source(source)
    var parser = Parser(tokens: tokens, current: 0)

    var statements: [Stmt] = []
    while not parser.is_at_end():
        match parser.parse_statement():
            case Ok(stmt):
                statements.push(stmt)
            case Err(e):
                return Err(e)

    Ok(Module(statements: statements))

fn parse_expr(source: text) -> Result<Expr, ParseError>:
    val tokens = lex_source(source)
    var parser = Parser(tokens: tokens, current: 0)
    parser.parse_expression()

fn parse_stmt(source: text) -> Result<Stmt, ParseError>:
    val tokens = lex_source(source)
    var parser = Parser(tokens: tokens, current: 0)
    parser.parse_statement()
