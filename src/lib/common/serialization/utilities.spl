# Serialization - Utility Functions

use serialization.serialize.{char_code_safe, write_varint, serialize_int}
use serialization.formats.{is_numeric_text}

# ============================================================================
# Pretty Printing
# ============================================================================

fn pretty_print_indent(s: text, level: i64) -> text:
    """Add indentation to string."""
    var indent = ""
    var i = 0
    while i < level:
        indent = indent + "  "
        i = i + 1
    indent + s

fn pretty_list(items: [text], indent: i64) -> text:
    """Pretty print list with indentation."""
    if items.len() == 0:
        return "[]"

    var result = "[\n"
    var i = 0
    while i < items.len():
        val item_indent = pretty_print_indent(items[i], indent + 1)
        result = result + item_indent
        if i < items.len() - 1:
            result = result + ","
        result = result + "\n"
        i = i + 1

    val close = pretty_print_indent("]", indent)
    result = result + close
    result

fn pretty_tuple(values: [text], indent: i64) -> text:
    """Pretty print tuple with indentation."""
    if values.len() == 0:
        return "()"

    var result = "(\n"
    var i = 0
    while i < values.len():
        val value_indent = pretty_print_indent(values[i], indent + 1)
        result = result + value_indent
        if i < values.len() - 1:
            result = result + ","
        result = result + "\n"
        i = i + 1

    val close = pretty_print_indent(")", indent)
    result = result + close
    result

fn pretty_dict(entries: [(text, text)], indent: i64) -> text:
    """Pretty print dict with indentation."""
    if entries.len() == 0:
        return "{}"

    var result = "{\n"
    var i = 0
    while i < entries.len():
        val entry = entries[i]
        val key = entry.0
        val value = entry.1
        val line = key + ": " + value
        val line_indent = pretty_print_indent(line, indent + 1)
        result = result + line_indent
        if i < entries.len() - 1:
            result = result + ","
        result = result + "\n"
        i = i + 1

    val close = pretty_print_indent("}", indent)
    result = result + close
    result

# ============================================================================
# Type Tagging
# ============================================================================

fn tag_type(obj_repr: text, type_name: text) -> text:
    """Add type tag to serialized object."""
    "@" + type_name + "{" + obj_repr + "}"

fn get_type_tag(serialized: text) -> text?:
    """Extract type tag from serialized object."""
    if serialized.len() < 3:
        return nil
    if serialized[0:1] != "@":
        return nil

    var i = 1
    while i < serialized.len():
        val ch = serialized[i:i+1]
        if ch == "{":
            return serialized[1:i]
        i = i + 1

    nil

fn strip_type_tag(serialized: text) -> text:
    """Remove type tag from serialized object, returning inner content."""
    val tag = get_type_tag(serialized)
    if tag == nil:
        return serialized

    var i = 1
    while i < serialized.len():
        val ch = serialized[i:i+1]
        if ch == "{":
            if i + 1 < serialized.len():
                return serialized[i+1:serialized.len()-1]
        i = i + 1

    serialized

# ============================================================================
# Schema Validation
# ============================================================================

fn define_schema(fields: [(text, text)]) -> text:
    """Define a schema with field names and type names."""
    serialize_dict(fields)

fn validate_field_type(value: text, expected_type: text) -> bool:
    """Validate that serialized value matches expected type."""
    if expected_type == "int":
        return is_numeric_text(value)
    else if expected_type == "bool":
        return value == "true" or value == "false"
    else if expected_type == "nil":
        return value == "nil"
    else if expected_type == "text":
        return value[0:1] == "\""
    else if expected_type == "list":
        return value[0:1] == "["
    else if expected_type == "tuple":
        return value[0:1] == "("
    else if expected_type == "dict":
        return value[0:1] == "{"

    true

# ============================================================================
# Versioning
# ============================================================================

fn add_version(serialized: text, version: i64) -> text:
    """Add version number to serialized object."""
    "{v: {version}, data: " + serialized + "}"

fn get_version(versioned: text) -> i64?:
    """Extract version number from versioned object."""
    if not versioned.starts_with("{v: "):
        return nil

    var i = 4
    var num_text = ""
    while i < versioned.len():
        val ch = versioned[i:i+1]
        if ch == ",":
            return parse_int_safe(num_text)
        val is_digit = ch >= "0" and ch <= "9"
        if is_digit:
            num_text = num_text + ch
        i = i + 1

    nil

fn parse_int_safe(s: text) -> i64:
    """Parse integer from text, return 0 on error."""
    if s.len() == 0:
        return 0

    var result = 0
    var sign = 1
    var start = 0

    if s[0:1] == "-":
        sign = -1
        start = 1

    var i = start
    while i < s.len():
        val ch = s[i:i+1]
        val is_digit = ch >= "0" and ch <= "9"
        if is_digit:
            val digit = char_to_digit_safe(ch)
            result = result * 10 + digit
        else:
            break
        i = i + 1

    result * sign

fn char_to_digit_safe(ch: text) -> i64:
    """Convert digit character to integer."""
    if ch == "0": return 0
    if ch == "1": return 1
    if ch == "2": return 2
    if ch == "3": return 3
    if ch == "4": return 4
    if ch == "5": return 5
    if ch == "6": return 6
    if ch == "7": return 7
    if ch == "8": return 8
    if ch == "9": return 9
    0

fn strip_version(versioned: text) -> text:
    """Remove version wrapper, returning inner data."""
    if not versioned.starts_with("{v: "):
        return versioned

    var i = 0
    while i < versioned.len() - 6:
        val substr = versioned[i:i+6]
        if substr == "data: ":
            val start = i + 6
            val end = versioned.len() - 1
            if end > start:
                return versioned[start:end]
        i = i + 1

    versioned

# ============================================================================
# Deep Cloning and Comparison
# ============================================================================

fn deep_clone_int(n: i64) -> i64: n
fn deep_clone_bool(b: bool) -> bool: b
fn deep_clone_text(s: text) -> text: s

fn deep_clone_list_int(items: [i64]) -> [i64]:
    var result = []
    for item in items:
        result = result.push(item)
    result

fn deep_clone_list_text(items: [text]) -> [text]:
    var result = []
    for item in items:
        result = result.push(item)
    result

fn shallow_clone_list_int(items: [i64]) -> [i64]:
    deep_clone_list_int(items)

fn shallow_clone_list_text(items: [text]) -> [text]:
    deep_clone_list_text(items)

fn deep_equal_int(a: i64, b: i64) -> bool: a == b
fn deep_equal_bool(a: bool, b: bool) -> bool: a == b
fn deep_equal_text(a: text, b: text) -> bool: a == b

fn deep_equal_list_int(a: [i64], b: [i64]) -> bool:
    if a.len() != b.len():
        return false

    var i = 0
    while i < a.len():
        if a[i] != b[i]:
            return false
        i = i + 1

    true

fn deep_equal_list_text(a: [text], b: [text]) -> bool:
    if a.len() != b.len():
        return false

    var i = 0
    while i < a.len():
        if a[i] != b[i]:
            return false
        i = i + 1

    true

# ============================================================================
# Structural Hashing
# ============================================================================

fn structural_hash_int(n: i64) -> i64:
    var h = n * 2654435761
    h = h xor (h >> 16)
    h

fn structural_hash_bool(b: bool) -> i64:
    if b: return 1
    0

fn structural_hash_text(s: text) -> i64:
    var hash = 2166136261
    var i = 0
    while i < s.len():
        val code = char_code_safe(s[i:i+1])
        hash = (hash xor code) * 16777619
        i = i + 1
    hash

fn structural_hash_list_int(items: [i64]) -> i64:
    var hash = 2166136261
    for item in items:
        val item_hash = structural_hash_int(item)
        hash = (hash xor item_hash) * 16777619
    hash

fn structural_hash_list_text(items: [text]) -> i64:
    var hash = 2166136261
    for item in items:
        val item_hash = structural_hash_text(item)
        hash = (hash xor item_hash) * 16777619
    hash

fn combine_hashes(h1: i64, h2: i64) -> i64:
    h1 * 31 + h2

# ============================================================================
# Compression/Encryption Markers
# ============================================================================

fn mark_compressed(serialized: text) -> text:
    "@Compressed{" + serialized + "}"

fn is_compressed(serialized: text) -> bool:
    val tag = get_type_tag(serialized)
    if tag == nil:
        return false
    tag == "Compressed"

fn mark_encrypted(serialized: text) -> text:
    "@Encrypted{" + serialized + "}"

fn is_encrypted(serialized: text) -> bool:
    val tag = get_type_tag(serialized)
    if tag == nil:
        return false
    tag == "Encrypted"

# ============================================================================
# Byte Array Utilities
# ============================================================================

fn write_bytes(data: [i64]) -> [i64]:
    var result = write_varint(data.len())
    for byte_val in data:
        result = result.push(byte_val)
    result

fn read_bytes(bytes: [i64], offset: i64, length: i64) -> ([i64], i64):
    var result = []
    var i = 0
    while i < length:
        if offset + i < bytes.len():
            result = result.push(bytes[offset + i])
        i = i + 1
    (result, length)

fn read_bytes_with_length(bytes: [i64], offset: i64) -> ([i64], i64):
    val len_result = read_varint(bytes, offset)
    val length = len_result.0
    val len_consumed = len_result.1

    val data_result = read_bytes(bytes, offset + len_consumed, length)
    val data = data_result.0
    val total_consumed = len_consumed + length

    (data, total_consumed)

# ============================================================================
# Hex Conversion
# ============================================================================

fn bytes_to_hex(bytes: [i64]) -> text:
    var result = ""
    for byte_val in bytes:
        val hex = int_to_hex(byte_val)
        result = result + hex
    result

fn int_to_hex(n: i64) -> text:
    val high = n / 16
    val low = n % 16
    digit_to_hex(high) + digit_to_hex(low)

fn digit_to_hex(d: i64) -> text:
    if d == 0: return "0"
    if d == 1: return "1"
    if d == 2: return "2"
    if d == 3: return "3"
    if d == 4: return "4"
    if d == 5: return "5"
    if d == 6: return "6"
    if d == 7: return "7"
    if d == 8: return "8"
    if d == 9: return "9"
    if d == 10: return "a"
    if d == 11: return "b"
    if d == 12: return "c"
    if d == 13: return "d"
    if d == 14: return "e"
    if d == 15: return "f"
    "0"

fn hex_to_bytes(hex: text) -> [i64]:
    var result = []
    var i = 0
    while i < hex.len():
        if i + 1 < hex.len():
            val high = hex_to_digit(hex[i:i+1])
            val low = hex_to_digit(hex[i+1:i+2])
            val byte_val = high * 16 + low
            result = result.push(byte_val)
            i = i + 2
        else:
            i = i + 1
    result

fn hex_to_digit(h: text) -> i64:
    if h == "0": return 0
    if h == "1": return 1
    if h == "2": return 2
    if h == "3": return 3
    if h == "4": return 4
    if h == "5": return 5
    if h == "6": return 6
    if h == "7": return 7
    if h == "8": return 8
    if h == "9": return 9
    if h == "a" or h == "A": return 10
    if h == "b" or h == "B": return 11
    if h == "c" or h == "C": return 12
    if h == "d" or h == "D": return 13
    if h == "e" or h == "E": return 14
    if h == "f" or h == "F": return 15
    0

# ============================================================================
# Exports
# ============================================================================

export pretty_print_indent, pretty_list, pretty_tuple, pretty_dict
export tag_type, get_type_tag, strip_type_tag
export define_schema, validate_field_type
export add_version, get_version, strip_version, parse_int_safe, char_to_digit_safe
export deep_clone_int, deep_clone_bool, deep_clone_text, deep_clone_list_int, deep_clone_list_text
export shallow_clone_list_int, shallow_clone_list_text
export deep_equal_int, deep_equal_bool, deep_equal_text, deep_equal_list_int, deep_equal_list_text
export structural_hash_int, structural_hash_bool, structural_hash_text
export structural_hash_list_int, structural_hash_list_text, combine_hashes
export mark_compressed, is_compressed, mark_encrypted, is_encrypted
export write_bytes, read_bytes, read_bytes_with_length
export bytes_to_hex, int_to_hex, hex_to_bytes
