# Red-Black Tree Search Operations
#
# Functions for searching, finding min/max, and successor/predecessor operations.

from .types import tree_root, tree_nil, tree_size
from .types import node_value, node_left, node_right, node_parent
from .types import is_nil_node

# ============================================================================
# TREE MINIMUM AND MAXIMUM
# ============================================================================

# Find minimum node in subtree rooted at node
fn tree_minimum(node, nil_sentinel):
    var current = node
    var parent = nil_sentinel
    var keep_going = true

    if is_nil_node(current, nil_sentinel):
        keep_going = false
    else:
        ()

    if keep_going:
        var left = node_left(current)
        var continue = is_nil_node(left, nil_sentinel) == false

        if continue:
            if continue:
                current = left
                left = node_left(current)
                continue = is_nil_node(left, nil_sentinel) == false
            else:
                ()

            if continue:
                current = left
                left = node_left(current)
                continue = is_nil_node(left, nil_sentinel) == false
            else:
                ()

            if continue:
                current = left
                left = node_left(current)
                continue = is_nil_node(left, nil_sentinel) == false
            else:
                ()

            if continue:
                current = left
                left = node_left(current)
                continue = is_nil_node(left, nil_sentinel) == false
            else:
                ()

            if continue:
                # Deep tree - recursive helper
                current = tree_minimum_helper(current, nil_sentinel)
            else:
                ()
        else:
            ()
    else:
        ()

    current

# Recursive helper for deep trees
fn tree_minimum_helper(node, nil_sentinel):
    val left = node_left(node)
    if is_nil_node(left, nil_sentinel):
        node
    else:
        tree_minimum_helper(left, nil_sentinel)

# Find maximum node in subtree rooted at node
fn tree_maximum(node, nil_sentinel):
    var current = node
    var parent = nil_sentinel
    var keep_going = true

    if is_nil_node(current, nil_sentinel):
        keep_going = false
    else:
        ()

    if keep_going:
        var right = node_right(current)
        var continue = is_nil_node(right, nil_sentinel) == false

        if continue:
            if continue:
                current = right
                right = node_right(current)
                continue = is_nil_node(right, nil_sentinel) == false
            else:
                ()

            if continue:
                current = right
                right = node_right(current)
                continue = is_nil_node(right, nil_sentinel) == false
            else:
                ()

            if continue:
                current = right
                right = node_right(current)
                continue = is_nil_node(right, nil_sentinel) == false
            else:
                ()

            if continue:
                current = right
                right = node_right(current)
                continue = is_nil_node(right, nil_sentinel) == false
            else:
                ()

            if continue:
                # Deep tree - recursive helper
                current = tree_maximum_helper(current, nil_sentinel)
            else:
                ()
        else:
            ()
    else:
        ()

    current

# Recursive helper for deep trees
fn tree_maximum_helper(node, nil_sentinel):
    val right = node_right(node)
    if is_nil_node(right, nil_sentinel):
        node
    else:
        tree_maximum_helper(right, nil_sentinel)

# Get minimum value in tree
fn rb_min(tree):
    val root = tree_root(tree)
    val nil_sentinel = tree_nil(tree)

    if is_nil_node(root, nil_sentinel):
        nil
    else:
        val min_node = tree_minimum(root, nil_sentinel)
        node_value(min_node)

# Get maximum value in tree
fn rb_max(tree):
    val root = tree_root(tree)
    val nil_sentinel = tree_nil(tree)

    if is_nil_node(root, nil_sentinel):
        nil
    else:
        val max_node = tree_maximum(root, nil_sentinel)
        node_value(max_node)

# ============================================================================
# SUCCESSOR AND PREDECESSOR
# ============================================================================

# Find successor node (next larger value)
fn successor(node, nil_sentinel):
    val right = node_right(node)

    if is_nil_node(right, nil_sentinel) == false:
        # Minimum in right subtree
        tree_minimum(right, nil_sentinel)
    else:
        # Go up until we find a left ancestor
        var current = node
        var parent = node_parent(current)
        var keep_going = is_nil_node(parent, nil_sentinel) == false

        if keep_going:
            val parent_right = node_right(parent)
            var is_right_child = current == parent_right
            keep_going = is_right_child

            if keep_going:
                current = parent
                parent = node_parent(current)
                keep_going = is_nil_node(parent, nil_sentinel) == false

                if keep_going:
                    val parent_right2 = node_right(parent)
                    is_right_child = current == parent_right2
                    keep_going = is_right_child

                    if keep_going:
                        current = parent
                        parent = node_parent(current)
                        keep_going = is_nil_node(parent, nil_sentinel) == false

                        if keep_going:
                            # Deep path - use helper
                            parent = successor_helper(current, parent, nil_sentinel)
                        else:
                            ()
                    else:
                        ()
                else:
                    ()
            else:
                ()
        else:
            ()

        parent

# Helper for finding successor up the tree
fn successor_helper(node, parent, nil_sentinel):
    if is_nil_node(parent, nil_sentinel):
        parent
    else:
        val parent_right = node_right(parent)
        if node == parent_right:
            val grandparent = node_parent(parent)
            successor_helper(parent, grandparent, nil_sentinel)
        else:
            parent

# Find predecessor node (next smaller value)
fn predecessor(node, nil_sentinel):
    val left = node_left(node)

    if is_nil_node(left, nil_sentinel) == false:
        # Maximum in left subtree
        tree_maximum(left, nil_sentinel)
    else:
        # Go up until we find a right ancestor
        var current = node
        var parent = node_parent(current)
        var keep_going = is_nil_node(parent, nil_sentinel) == false

        if keep_going:
            val parent_left = node_left(parent)
            var is_left_child = current == parent_left
            keep_going = is_left_child

            if keep_going:
                current = parent
                parent = node_parent(current)
                keep_going = is_nil_node(parent, nil_sentinel) == false

                if keep_going:
                    val parent_left2 = node_left(parent)
                    is_left_child = current == parent_left2
                    keep_going = is_left_child

                    if keep_going:
                        current = parent
                        parent = node_parent(current)
                        keep_going = is_nil_node(parent, nil_sentinel) == false

                        if keep_going:
                            # Deep path - use helper
                            parent = predecessor_helper(current, parent, nil_sentinel)
                        else:
                            ()
                    else:
                        ()
                else:
                    ()
            else:
                ()
        else:
            ()

        parent

# Helper for finding predecessor up the tree
fn predecessor_helper(node, parent, nil_sentinel):
    if is_nil_node(parent, nil_sentinel):
        parent
    else:
        val parent_left = node_left(parent)
        if node == parent_left:
            val grandparent = node_parent(parent)
            predecessor_helper(parent, grandparent, nil_sentinel)
        else:
            parent

# Find successor by value
fn rb_successor(tree, value):
    val nil_sentinel = tree_nil(tree)
    val node = search_node(tree_root(tree), value, nil_sentinel)

    if is_nil_node(node, nil_sentinel):
        nil
    else:
        val succ = successor(node, nil_sentinel)
        if is_nil_node(succ, nil_sentinel):
            nil
        else:
            node_value(succ)

# Find predecessor by value
fn rb_predecessor(tree, value):
    val nil_sentinel = tree_nil(tree)
    val node = search_node(tree_root(tree), value, nil_sentinel)

    if is_nil_node(node, nil_sentinel):
        nil
    else:
        val pred = predecessor(node, nil_sentinel)
        if is_nil_node(pred, nil_sentinel):
            nil
        else:
            node_value(pred)

# ============================================================================
# SEARCH OPERATIONS
# ============================================================================

# Search for a node with given value
fn search_node(node, value, nil_sentinel):
    if is_nil_node(node, nil_sentinel):
        nil_sentinel
    else:
        val node_val = node_value(node)

        if value == node_val:
            node
        else:
            if value < node_val:
                val left = node_left(node)
                search_node(left, value, nil_sentinel)
            else:
                val right = node_right(node)
                search_node(right, value, nil_sentinel)

# Search for value in tree (returns true if found)
fn rb_search(tree, value):
    val root = tree_root(tree)
    val nil_sentinel = tree_nil(tree)
    val result = search_node(root, value, nil_sentinel)
    is_nil_node(result, nil_sentinel) == false

# Alias for rb_search
fn rb_contains(tree, value):
    rb_search(tree, value)

# Get tree size (number of nodes)
fn rb_size(tree):
    tree_size(tree)
