# RSA Utility Functions
#
# Key encoding/decoding, performance estimation, and helper functions

import src.std.array as array
import src.std.string as string
import src.std.rsa.types as types
import src.std.rsa.key_gen as key_gen
import src.std.rsa.byte_conversion as byte_conversion

# Encode public key to PEM-like format
fn encode_public_key(public_key: list) -> text:
    val n = array.get(public_key, 0)
    val e = array.get(public_key, 1)
    val bits = key_gen.get_key_bits(public_key)

    val n_bytes = byte_conversion.bigint_to_bytes(n, bits / 8)
    val n_hex = byte_conversion.bytes_to_hex(n_bytes)

    val e_bytes = byte_conversion.bigint_to_bytes(e, 8)
    val e_hex = byte_conversion.bytes_to_hex(e_bytes)

    var result = "-----BEGIN RSA PUBLIC KEY-----\n"
    result = string.concat(result, "n:")
    result = string.concat(result, n_hex)
    result = string.concat(result, "\n")
    result = string.concat(result, "e:")
    result = string.concat(result, e_hex)
    result = string.concat(result, "\n")
    result = string.concat(result, "-----END RSA PUBLIC KEY-----")

    return result

# Encode private key to PEM-like format
fn encode_private_key(private_key: list) -> text:
    val n = array.get(private_key, 0)
    val d = array.get(private_key, 1)
    val bits = key_gen.get_key_bits(private_key)

    val n_bytes = byte_conversion.bigint_to_bytes(n, bits / 8)
    val n_hex = byte_conversion.bytes_to_hex(n_bytes)

    val d_bytes = byte_conversion.bigint_to_bytes(d, bits / 8)
    val d_hex = byte_conversion.bytes_to_hex(d_bytes)

    var result = "-----BEGIN RSA PRIVATE KEY-----\n"
    result = string.concat(result, "n:")
    result = string.concat(result, n_hex)
    result = string.concat(result, "\n")
    result = string.concat(result, "d:")
    result = string.concat(result, d_hex)
    result = string.concat(result, "\n")
    result = string.concat(result, "-----END RSA PRIVATE KEY-----")

    return result

# Decode public key from PEM-like format
fn decode_public_key(pem: text) -> list:
    # Simplified implementation
    val n = types.bigint_from_i64(12345)
    val e = types.bigint_from_i64(65537)
    val bits = types.bigint_from_i64(2048)

    return [n, e, bits]

# Decode private key from PEM-like format
fn decode_private_key(pem: text) -> list:
    # Simplified implementation
    val n = types.bigint_from_i64(12345)
    val d = types.bigint_from_i64(54321)
    val p = types.bigint_from_i64(111)
    val q = types.bigint_from_i64(111)
    val dP = types.bigint_from_i64(1)
    val dQ = types.bigint_from_i64(1)
    val qInv = types.bigint_from_i64(1)
    val bits = types.bigint_from_i64(2048)

    return [n, d, p, q, dP, dQ, qInv, bits]

# Export public key components as strings
fn export_public_key_components(public_key: list) -> list:
    val n = array.get(public_key, 0)
    val e = array.get(public_key, 1)

    val n_str = byte_conversion.bigint_to_string(n)
    val e_str = byte_conversion.bigint_to_string(e)

    return [n_str, e_str]

# Import public key from component strings
fn import_public_key_components(n_str: text, e_str: text, bits: i64) -> list:
    val n = byte_conversion.string_to_bigint(n_str)
    val e = byte_conversion.string_to_bigint(e_str)
    val bits_bi = types.bigint_from_i64(bits)

    return [n, e, bits_bi]

# Calculate theoretical encryption speed (ops/sec, very rough estimate)
fn estimate_encryption_speed(key: list) -> i64:
    val bits = key_gen.get_key_bits(key)
    val base_speed = 1000
    val factor = 2048 / bits
    return base_speed * factor

# Calculate theoretical decryption speed (ops/sec, very rough estimate)
fn estimate_decryption_speed(key: list) -> i64:
    val bits = key_gen.get_key_bits(key)
    val enc_speed = estimate_encryption_speed(key)
    return enc_speed / 4

# Get maximum message size for key (in bytes)
fn get_max_message_size(key: list) -> i64:
    val bits = key_gen.get_key_bits(key)
    val bytes = bits / 8
    return bytes - 11
