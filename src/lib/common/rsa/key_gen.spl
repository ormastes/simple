# RSA Key Generation
#
# Public/private key pair generation and key operations

import src.std.array as array
import src.std.rsa.types as types
import src.std.rsa.modular as modular
import src.std.rsa.primality as primality

# RSA Public Key: (n, e, bits)
# RSA Private Key: (n, d, p, q, dP, dQ, qInv, bits)

# Generate RSA keypair with default public exponent (65537)
fn generate_rsa_keypair(bits: i64) -> list:
    val e = types.bigint_from_i64(65537)
    return generate_rsa_keys(e, bits)

# Generate RSA keypair with custom public exponent
fn generate_rsa_keys(e: list, bits: i64) -> list:
    val prime_bits = bits / 2
    var p = primality.generate_prime(prime_bits)
    var q = primality.generate_prime(prime_bits)

    var attempts = 0
    while types.bigint_compare(p, q) == 0:
        q = primality.generate_prime(prime_bits)
        attempts = attempts + 1
        if attempts > 10:
            break

    val n = types.bigint_mul(p, q)

    val p_minus_1 = types.bigint_sub(p, types.bigint_one())
    val q_minus_1 = types.bigint_sub(q, types.bigint_one())
    val phi = types.bigint_mul(p_minus_1, q_minus_1)

    val d = modular.bigint_mod_inverse(e, phi)

    val dP = types.bigint_mod(d, p_minus_1)
    val dQ = types.bigint_mod(d, q_minus_1)
    val qInv = modular.bigint_mod_inverse(q, p)

    val public_key = [n, e, types.bigint_from_i64(bits)]
    val private_key = [n, d, p, q, dP, dQ, qInv, types.bigint_from_i64(bits)]

    return [public_key, private_key]

# Generate RSA keypair with specific primes (for testing)
fn generate_rsa_keys_from_primes(p: list, q: list, e: list) -> list:
    val n = types.bigint_mul(p, q)

    val p_minus_1 = types.bigint_sub(p, types.bigint_one())
    val q_minus_1 = types.bigint_sub(q, types.bigint_one())
    val phi = types.bigint_mul(p_minus_1, q_minus_1)

    val d = modular.bigint_mod_inverse(e, phi)

    val dP = types.bigint_mod(d, p_minus_1)
    val dQ = types.bigint_mod(d, q_minus_1)
    val qInv = modular.bigint_mod_inverse(q, p)

    val bits = types.bigint_bit_length(n)
    val bits_bi = types.bigint_from_i64(bits)

    val public_key = [n, e, bits_bi]
    val private_key = [n, d, p, q, dP, dQ, qInv, bits_bi]

    return [public_key, private_key]

# Get modulus from public key
fn get_public_modulus(public_key: list) -> list:
    return array.get(public_key, 0)

# Get public exponent from public key
fn get_public_exponent(public_key: list) -> list:
    return array.get(public_key, 1)

# Get key size in bits
fn get_key_bits(key: list) -> i64:
    val bits_bi = array.get(key, 2)
    val divmod_result = types.bigint_divmod_i64(bits_bi, 1)
    val quotient = array.get(divmod_result, 0)

    val len = array.length(quotient)
    if len == 0:
        return 0
    if types.bigint_is_zero(quotient):
        return 0

    val first_limb = array.get(quotient, 0)
    return first_limb

# Check if key is secure (>= 2048 bits)
fn is_key_secure(key: list) -> bool:
    val bits = get_key_bits(key)
    return bits >= 2048

# Check if two keys are a valid keypair
fn is_valid_keypair(public_key: list, private_key: list) -> bool:
    val pub_n = array.get(public_key, 0)
    val priv_n = array.get(private_key, 0)

    val cmp = types.bigint_compare(pub_n, priv_n)
    return cmp == 0

# Get modulus size in bits
fn get_modulus_bits(key: list) -> i64:
    val n = array.get(key, 0)
    return types.bigint_bit_length(n)
