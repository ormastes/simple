# src/std/types/mapped.spl
# Mapped Types Library for Simple Language
#
# @tag:api
# @tag:stdlib
# @tag:experimental
#
# TypeScript-inspired mapped type transforms:
#   Partial<T>   — all fields become optional
#   Readonly<T>  — all fields become readonly
#   Stringify<T> — all fields become text
#   Pick<T,K>    — keep only the listed keys
#   Omit<T,K>    — remove the listed keys
#   Required<T>  — all optional fields become required
#
# These are runtime stubs.  When @traits is fully working at compile
# time, these functions will be upgraded to perform actual field-level
# transformations via @traits(fields, T) + static_for.
#
# Usage:
#   use std.mapped.{partial, readonly_type, stringify_type}
#   use std.mapped.{pick_type, omit_type, required_type}
#   use std.mapped.{field_names_csv, has_field_check}
#   use std.mapped.{make_optional_field, make_required_field}
#   use std.mapped.{is_mapped_result, mapped_result_get_type}

# ============================================================================
# Core Result Type
# ============================================================================
#
# MappedResult is the FIRST struct — it supports direct named-field
# construction (MappedResult(type_name: ..., transform: ..., description: ...)).
# All subsequent types must use factory functions.

struct MappedResult:
    type_name: text
    transform: text
    description: text

# Factory for MappedResult (used internally and exported for callers
# who need a structured value rather than a plain text description).
fn mapped_result_new(name: text, transform: text, desc: text) -> MappedResult:
    # Creates a MappedResult value directly (first-struct rule).
    MappedResult(type_name: name, transform: transform, description: desc)

# ============================================================================
# Mapped Type Factory Functions
# ============================================================================

fn partial(type_name: text) -> text:
    # Partial<T> — every field of T becomes optional (field?).
    # When @traits is available this will enumerate fields and suffix each
    # with '?'.  For now returns the canonical description string.
    "Partial<" + type_name + ">"

fn readonly_type(type_name: text) -> text:
    # Readonly<T> — every field of T becomes immutable.
    # When @traits is available this will mark each field as readonly.
    "Readonly<" + type_name + ">"

fn stringify_type(type_name: text) -> text:
    # Stringify<T> — every field of T is replaced with a text representation.
    # When @traits is available this will map each field type to 'text'.
    "Stringify<" + type_name + ">"

fn pick_type(type_name: text, keys: text) -> text:
    # Pick<T, Keys> — produce a type with only the fields listed in keys.
    # keys is a comma-separated list of field names, e.g. "name,age".
    "Pick<" + type_name + ", " + keys + ">"

fn omit_type(type_name: text, keys: text) -> text:
    # Omit<T, Keys> — produce a type with all fields EXCEPT those in keys.
    # keys is a comma-separated list of field names to exclude.
    "Omit<" + type_name + ", " + keys + ">"

fn required_type(type_name: text) -> text:
    # Required<T> — every optional field of T becomes mandatory.
    # When @traits is available this will strip '?' from each field.
    "Required<" + type_name + ">"

# ============================================================================
# Field Manipulation Helpers
# ============================================================================

fn field_names_csv(type_name: text) -> text:
    # Returns the field names of type_name as a comma-separated string.
    # Stub: @traits(fields, T) is not yet available at runtime.
    "use @traits(fields, " + type_name + ")"

fn has_field_check(type_name: text, field: text) -> bool:
    # Returns true when type_name has a field named field.
    # Stub: always returns false until @traits(has_member, T, name) is wired up.
    false

fn make_optional_field(field_name: text) -> text:
    # Returns the optional-field notation for field_name (e.g. "age?").
    field_name + "?"

fn make_required_field(field_name: text) -> text:
    # Returns the required-field notation for field_name (e.g. "age!").
    field_name + "!"

# ============================================================================
# Type Guard Helpers
# ============================================================================

fn is_mapped_result(v: i64) -> bool:
    # Placeholder type guard.  Returns false — in a compiled build this
    # would check the runtime tag of v against MappedResult.
    false

fn mapped_result_get_type(name: text, transform: text) -> text:
    # Returns a human-readable description combining the type name and the
    # transform that was applied, e.g. "Partial<User>".
    transform + "<" + name + ">"

# ============================================================================
# Exports
# ============================================================================

export mapped_result_new
export partial, readonly_type, stringify_type
export pick_type, omit_type, required_type
export field_names_csv, has_field_check
export make_optional_field, make_required_field
export is_mapped_result, mapped_result_get_type
