# Unicode Math Character Tables
#
# Lookup functions for Unicode mathematical symbols.
# Pure Simple implementation - no external dependencies.
#
# Functions:
# - greek: Greek letter lookup ("alpha" -> "α")
# - superscript: Convert digits/letters to superscript ("123" -> "¹²³")
# - subscript: Convert digits/letters to subscript ("123" -> "₁₂₃")
# - math_sym: Math symbol lookup ("sum" -> "∑")
# - math_op: Operator symbol lookup ("leq" -> "≤")
# - bracket_top/bracket_mid/bracket_bot: Matrix bracket pieces
# - greek_upper: Uppercase Greek ("Gamma" -> "Γ")

# ============================================================================
# Greek Letters
# ============================================================================

fn greek(name: text) -> text:
    """Look up lowercase Greek letter by name. Returns name unchanged if not found.

    Example:
        greek("alpha")   # "α"
        greek("omega")   # "ω"
    """
    if name == "alpha": return "α"
    if name == "beta": return "β"
    if name == "gamma": return "γ"
    if name == "delta": return "δ"
    if name == "epsilon": return "ε"
    if name == "zeta": return "ζ"
    if name == "eta": return "η"
    if name == "theta": return "θ"
    if name == "iota": return "ι"
    if name == "kappa": return "κ"
    if name == "lambda": return "λ"
    if name == "mu": return "μ"
    if name == "nu": return "ν"
    if name == "xi": return "ξ"
    if name == "omicron": return "ο"
    if name == "pi": return "π"
    if name == "rho": return "ρ"
    if name == "sigma": return "σ"
    if name == "tau": return "τ"
    if name == "upsilon": return "υ"
    if name == "phi": return "φ"
    if name == "chi": return "χ"
    if name == "psi": return "ψ"
    if name == "omega": return "ω"
    # Variant forms
    if name == "varepsilon": return "ϵ"
    if name == "vartheta": return "ϑ"
    if name == "varphi": return "ϕ"
    if name == "varrho": return "ϱ"
    if name == "varpi": return "ϖ"
    if name == "varkappa": return "ϰ"
    if name == "partial": return "∂"
    if name == "nabla": return "∇"
    name

fn greek_upper(name: text) -> text:
    """Look up uppercase Greek letter by name. Returns name unchanged if not found.

    Example:
        greek_upper("Gamma")   # "Γ"
        greek_upper("Sigma")   # "Σ"
    """
    if name == "Gamma": return "Γ"
    if name == "Delta": return "Δ"
    if name == "Theta": return "Θ"
    if name == "Lambda": return "Λ"
    if name == "Xi": return "Ξ"
    if name == "Pi": return "Π"
    if name == "Sigma": return "Σ"
    if name == "Upsilon": return "Υ"
    if name == "Phi": return "Φ"
    if name == "Psi": return "Ψ"
    if name == "Omega": return "Ω"
    name

# ============================================================================
# Superscript / Subscript
# ============================================================================

fn superscript_char(ch: text) -> text:
    """Convert a single character to its superscript form.

    Example:
        superscript_char("2")  # "²"
        superscript_char("+")  # "⁺"
    """
    if ch == "0": return "⁰"
    if ch == "1": return "¹"
    if ch == "2": return "²"
    if ch == "3": return "³"
    if ch == "4": return "⁴"
    if ch == "5": return "⁵"
    if ch == "6": return "⁶"
    if ch == "7": return "⁷"
    if ch == "8": return "⁸"
    if ch == "9": return "⁹"
    if ch == "+": return "⁺"
    if ch == "-": return "⁻"
    if ch == "=": return "⁼"
    if ch == "(": return "⁽"
    if ch == ")": return "⁾"
    if ch == "n": return "ⁿ"
    if ch == "i": return "ⁱ"
    if ch == "x": return "ˣ"
    ch

fn subscript_char(ch: text) -> text:
    """Convert a single character to its subscript form.

    Example:
        subscript_char("2")  # "₂"
        subscript_char("+")  # "₊"
    """
    if ch == "0": return "₀"
    if ch == "1": return "₁"
    if ch == "2": return "₂"
    if ch == "3": return "₃"
    if ch == "4": return "₄"
    if ch == "5": return "₅"
    if ch == "6": return "₆"
    if ch == "7": return "₇"
    if ch == "8": return "₈"
    if ch == "9": return "₉"
    if ch == "+": return "₊"
    if ch == "-": return "₋"
    if ch == "=": return "₌"
    if ch == "(": return "₍"
    if ch == ")": return "₎"
    if ch == "a": return "ₐ"
    if ch == "e": return "ₑ"
    if ch == "o": return "ₒ"
    if ch == "x": return "ₓ"
    if ch == "h": return "ₕ"
    if ch == "k": return "ₖ"
    if ch == "l": return "ₗ"
    if ch == "m": return "ₘ"
    if ch == "n": return "ₙ"
    if ch == "p": return "ₚ"
    if ch == "s": return "ₛ"
    if ch == "t": return "ₜ"
    if ch == "i": return "ᵢ"
    if ch == "j": return "ⱼ"
    if ch == "r": return "ᵣ"
    ch

fn superscript(s: text) -> text:
    """Convert a string of digits/letters to superscript.

    Example:
        superscript("23")    # "²³"
        superscript("n+1")   # "ⁿ⁺¹"
    """
    var result = ""
    var idx = 0
    for ch in s:
        result = result + superscript_char(ch)
        idx = idx + 1
    result

fn subscript(s: text) -> text:
    """Convert a string of digits/letters to subscript.

    Example:
        subscript("12")    # "₁₂"
        subscript("i+1")   # "ᵢ₊₁"
    """
    var result = ""
    var idx = 0
    for ch in s:
        result = result + subscript_char(ch)
        idx = idx + 1
    result

# ============================================================================
# Math Symbols
# ============================================================================

fn math_sym(name: text) -> text:
    """Look up a math symbol by name. Returns name unchanged if not found.

    Example:
        math_sym("sum")       # "∑"
        math_sym("integral")  # "∫"
        math_sym("infinity")  # "∞"
    """
    # Calculus
    if name == "sum": return "∑"
    if name == "product": return "∏"
    if name == "coproduct": return "∐"
    if name == "integral": return "∫"
    if name == "double_integral": return "∬"
    if name == "triple_integral": return "∭"
    if name == "contour_integral": return "∮"
    if name == "surface_integral": return "∯"
    if name == "volume_integral": return "∰"
    # Roots
    if name == "sqrt": return "√"
    if name == "cbrt": return "∛"
    if name == "fourthrt": return "∜"
    # Constants
    if name == "infinity": return "∞"
    if name == "pi_sym": return "π"
    if name == "euler": return "ℯ"
    if name == "imaginary": return "ℑ"
    if name == "real_part": return "ℜ"
    if name == "planck": return "ℏ"
    if name == "aleph": return "ℵ"
    # Quantifiers
    if name == "forall": return "∀"
    if name == "exists": return "∃"
    if name == "nexists": return "∄"
    # Logic
    if name == "and": return "∧"
    if name == "or": return "∨"
    if name == "not": return "¬"
    if name == "top": return "⊤"
    if name == "bot": return "⊥"
    if name == "proves": return "⊢"
    if name == "models": return "⊨"
    if name == "therefore": return "∴"
    if name == "because": return "∵"
    # Sets
    if name == "in": return "∈"
    if name == "notin": return "∉"
    if name == "subset": return "⊂"
    if name == "superset": return "⊃"
    if name == "subseteq": return "⊆"
    if name == "supseteq": return "⊇"
    if name == "union": return "∪"
    if name == "intersection": return "∩"
    if name == "emptyset": return "∅"
    if name == "setminus": return "∖"
    # Number sets (double-struck)
    if name == "naturals": return "ℕ"
    if name == "integers": return "ℤ"
    if name == "rationals": return "ℚ"
    if name == "reals": return "ℝ"
    if name == "complex": return "ℂ"
    if name == "primes": return "ℙ"
    # Miscellaneous
    if name == "degree": return "°"
    if name == "prime": return "′"
    if name == "double_prime": return "″"
    if name == "triple_prime": return "‴"
    if name == "ellipsis": return "…"
    if name == "vellipsis": return "⋮"
    if name == "hellipsis": return "⋯"
    if name == "dellipsis": return "⋱"
    if name == "compose": return "∘"
    if name == "tensor": return "⊗"
    if name == "direct_sum": return "⊕"
    if name == "dot_product": return "⊙"
    name

# ============================================================================
# Operator Symbols
# ============================================================================

fn math_op(name: text) -> text:
    """Look up a math operator by name. Returns name unchanged if not found.

    Example:
        math_op("leq")       # "≤"
        math_op("neq")       # "≠"
        math_op("approx")    # "≈"
    """
    # Comparison
    if name == "leq": return "≤"
    if name == "geq": return "≥"
    if name == "neq": return "≠"
    if name == "approx": return "≈"
    if name == "equiv": return "≡"
    if name == "nequiv": return "≢"
    if name == "cong": return "≅"
    if name == "sim": return "∼"
    if name == "ll": return "≪"
    if name == "gg": return "≫"
    if name == "propto": return "∝"
    if name == "defeq": return "≔"
    # Arithmetic
    if name == "pm": return "±"
    if name == "mp": return "∓"
    if name == "times": return "×"
    if name == "div": return "÷"
    if name == "cdot": return "·"
    if name == "star": return "∗"
    # Arrows
    if name == "to": return "→"
    if name == "from": return "←"
    if name == "lr": return "↔"
    if name == "implies": return "⇒"
    if name == "implied_by": return "⇐"
    if name == "iff": return "⇔"
    if name == "mapsto": return "↦"
    if name == "long_to": return "⟶"
    if name == "long_implies": return "⟹"
    if name == "long_iff": return "⟺"
    if name == "surjection": return "↠"
    if name == "injection": return "↣"
    name

# ============================================================================
# Box Drawing / Bracket Pieces (for matrices, fractions)
# ============================================================================

fn hline(width: i64) -> text:
    """Create a horizontal line of given width using box-drawing chars.

    Example:
        hline(5)  # "─────"
    """
    var result = ""
    var i = 0
    for _ in 0..width:
        result = result + "─"
        i = i + 1
    result

fn bracket_left_top() -> text:
    """Left square bracket top: ⎡"""
    "⎡"

fn bracket_left_mid() -> text:
    """Left square bracket extension: ⎢"""
    "⎢"

fn bracket_left_bot() -> text:
    """Left square bracket bottom: ⎣"""
    "⎣"

fn bracket_right_top() -> text:
    """Right square bracket top: ⎤"""
    "⎤"

fn bracket_right_mid() -> text:
    """Right square bracket extension: ⎥"""
    "⎥"

fn bracket_right_bot() -> text:
    """Right square bracket bottom: ⎦"""
    "⎦"

fn paren_left_top() -> text:
    """Left parenthesis top: ⎛"""
    "⎛"

fn paren_left_mid() -> text:
    """Left parenthesis extension: ⎜"""
    "⎜"

fn paren_left_bot() -> text:
    """Left parenthesis bottom: ⎝"""
    "⎝"

fn paren_right_top() -> text:
    """Right parenthesis top: ⎞"""
    "⎞"

fn paren_right_mid() -> text:
    """Right parenthesis extension: ⎟"""
    "⎟"

fn paren_right_bot() -> text:
    """Right parenthesis bottom: ⎠"""
    "⎠"

fn brace_left_top() -> text:
    """Left curly brace top: ⎧"""
    "⎧"

fn brace_left_mid() -> text:
    """Left curly brace middle: ⎨"""
    "⎨"

fn brace_left_bot() -> text:
    """Left curly brace bottom: ⎩"""
    "⎩"

fn brace_right_top() -> text:
    """Right curly brace top: ⎫"""
    "⎫"

fn brace_right_mid() -> text:
    """Right curly brace middle: ⎬"""
    "⎬"

fn brace_right_bot() -> text:
    """Right curly brace bottom: ⎭"""
    "⎭"

fn brace_ext() -> text:
    """Curly brace extension: ⎪"""
    "⎪"
