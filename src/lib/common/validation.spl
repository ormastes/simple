# Validation Utilities
#
# Common validation functions for input checking and data validation.
# Pure Simple implementation - no external dependencies.
#
# Functions:
# - is_valid_identifier: Check if string is valid Simple identifier
# - is_numeric: Check if string contains only digits
# - is_alphanumeric: Check if string is alphanumeric
# - is_hex_string: Check if string is valid hexadecimal
# - is_email_like: Basic email format check
# - is_positive: Check if number is positive
# - is_non_negative: Check if number is non-negative
# - clamp: Constrain value to range
# - validate_length: Check if string length is in range


# ============================================================================
# String Pattern Validation
# ============================================================================

fn is_valid_identifier(s: text) -> bool:
    """Check if string is a valid Simple identifier.

    Rules:
    - Must start with letter or underscore
    - Can contain letters, digits, underscores
    - Cannot be empty
    """
    if s.len() == 0:
        return false

    # Check first character
    val first = s[0..1]
    val first_valid = (first >= "a" and first <= "z") or
                      (first >= "A" and first <= "Z") or
                      first == "_"

    if not first_valid:
        return false

    # Check remaining characters
    var i = 1
    while i < s.len():
        val ch = s[i..i+1]
        val valid = (ch >= "a" and ch <= "z") or
                    (ch >= "A" and ch <= "Z") or
                    (ch >= "0" and ch <= "9") or
                    ch == "_"

        if not valid:
            return false

        i = i + 1

    true

fn is_numeric(s: text) -> bool:
    """Check if string contains only numeric digits (0-9)."""
    if s.len() == 0:
        return false

    var i = 0
    while i < s.len():
        val ch = s[i..i+1]
        if not (ch >= "0" and ch <= "9"):
            return false
        i = i + 1

    true

fn is_alphanumeric(s: text) -> bool:
    """Check if string contains only letters and digits."""
    if s.len() == 0:
        return false

    var i = 0
    while i < s.len():
        val ch = s[i..i+1]
        val valid = (ch >= "a" and ch <= "z") or
                    (ch >= "A" and ch <= "Z") or
                    (ch >= "0" and ch <= "9")

        if not valid:
            return false

        i = i + 1

    true

fn is_hex_string(s: text) -> bool:
    """Check if string is valid hexadecimal (0-9, a-f, A-F)."""
    if s.len() == 0:
        return false

    var i = 0
    while i < s.len():
        val ch = s[i..i+1]
        val valid = (ch >= "0" and ch <= "9") or
                    (ch >= "a" and ch <= "f") or
                    (ch >= "A" and ch <= "F")

        if not valid:
            return false

        i = i + 1

    true

fn is_email_like(s: text) -> bool:
    """Basic email format check (contains @ and at least one dot after @).

    This is a simple check, not RFC-compliant email validation.
    """
    if s.len() < 3:
        return false

    # Find @ symbol
    var at_pos = -1
    var i = 0
    while i < s.len():
        if s[i..i+1] == "@":
            if at_pos >= 0:
                # Multiple @ symbols
                return false
            at_pos = i
        i = i + 1

    if at_pos <= 0 or at_pos >= s.len() - 2:
        # No @, or @ at start/end
        return false

    # Check for dot after @
    var has_dot_after_at = false
    i = at_pos + 1
    while i < s.len():
        if s[i..i+1] == ".":
            if i < s.len() - 1:
                has_dot_after_at = true
        i = i + 1

    has_dot_after_at

# ============================================================================
# Numeric Validation
# ============================================================================

fn is_positive_i64(value: i64) -> bool:
    """Check if integer is positive (> 0)."""
    value > 0

fn is_positive_f64(value: f64) -> bool:
    """Check if float is positive (> 0.0)."""
    value > 0.0

fn is_non_negative_i64(value: i64) -> bool:
    """Check if integer is non-negative (>= 0)."""
    value >= 0

fn is_non_negative_f64(value: f64) -> bool:
    """Check if float is non-negative (>= 0.0)."""
    value >= 0.0

fn is_positive(x: i64) -> bool:
    """Check if number is strictly positive (> 0).

    Untyped alias for is_positive_i64() for convenience.

    Example:
        is_positive(5)   # true
        is_positive(0)   # false
        is_positive(-5)  # false
    """
    is_positive_i64(x)

fn is_negative(x: i64) -> bool:
    """Check if number is strictly negative (< 0).

    Example:
        is_negative(-5)  # true
        is_negative(0)   # false
        is_negative(5)   # false
    """
    x < 0

fn is_non_negative(x: i64) -> bool:
    """Check if number is non-negative (>= 0).

    Untyped alias for is_non_negative_i64() for convenience.

    Example:
        is_non_negative(0)   # true
        is_non_negative(5)   # true
        is_non_negative(-5)  # false
    """
    is_non_negative_i64(x)

fn is_zero(x: i64) -> bool:
    """Check if number is zero.

    Example:
        is_zero(0)   # true
        is_zero(5)   # false
        is_zero(-5)  # false
    """
    x == 0

fn clamp(value: i64, min: i64, max: i64) -> i64:
    """Constrain integer value to range [min, max].

    Untyped alias for clamp_i64() for convenience.
    """
    clamp_i64(value, min, max)

fn clamp_i64(value: i64, min: i64, max: i64) -> i64:
    """Constrain integer value to range [min, max]."""
    if value < min:
        return min
    if value > max:
        return max
    value

fn clamp_f64(value: f64, min: f64, max: f64) -> f64:
    """Constrain float value to range [min, max]."""
    if value < min:
        return min
    if value > max:
        return max
    value

# ============================================================================
# Length Validation
# ============================================================================

fn validate_length(s: text, min_len: i64, max_len: i64) -> bool:
    """Check if string length is within range [min_len, max_len]."""
    val len = s.len()
    len >= min_len and len <= max_len

fn validate_min_length(s: text, min_len: i64) -> bool:
    """Check if string meets minimum length requirement."""
    s.len() >= min_len

fn validate_max_length(s: text, max_len: i64) -> bool:
    """Check if string doesn't exceed maximum length."""
    s.len() <= max_len

# ============================================================================
# Collection Validation
# ============================================================================

fn validate_array_length(arr, min_len: i64, max_len: i64) -> bool:
    """Check if array length is within range [min_len, max_len]."""
    val len = arr.len()
    len >= min_len and len <= max_len

fn is_empty_array(arr) -> bool:
    """Check if array is empty."""
    arr.len() == 0

fn is_non_empty_array(arr) -> bool:
    """Check if array has at least one element."""
    arr.len() > 0

fn is_empty(s: text) -> bool:
    """Check if string is empty.

    Example:
        is_empty("")       # true
        is_empty("hello")  # false
    """
    s.len() == 0

fn is_not_empty(s: text) -> bool:
    """Check if string is not empty.

    Example:
        is_not_empty("hello")  # true
        is_not_empty("")       # false
    """
    s.len() > 0

fn is_in_range(x: i64, min_val: i64, max_val: i64) -> bool:
    """Check if number is in range [min, max] (inclusive).

    Example:
        is_in_range(x=5, min_val=0, max_val=10)   # true
        is_in_range(x=-1, min_val=0, max_val=10)  # false
        is_in_range(x=11, min_val=0, max_val=10)  # false
    """
    x >= min_val and x <= max_val

fn is_outside_range(x: i64, min_val: i64, max_val: i64) -> bool:
    """Check if number is outside range [min, max].

    Example:
        is_outside_range(x=-1, min_val=0, max_val=10)  # true
        is_outside_range(x=11, min_val=0, max_val=10)  # true
        is_outside_range(x=5, min_val=0, max_val=10)   # false
    """
    x < min_val or x > max_val

fn is_divisible(x: i64, divisor: i64) -> bool:
    """Check if x is divisible by divisor (x % divisor == 0).

    Example:
        is_divisible(x=10, divisor=2)  # true
        is_divisible(x=10, divisor=3)  # false
    """
    if divisor == 0:
        return false
    x % divisor == 0

fn is_multiple_of(x: i64, factor: i64) -> bool:
    """Check if x is a multiple of factor (same as is_divisible).

    Example:
        is_multiple_of(x=15, factor=3)  # true
        is_multiple_of(x=15, factor=4)  # false
    """
    is_divisible(x, factor)

# ============================================================================
# String Content Validation
# ============================================================================

fn contains_only_letters(s: text) -> bool:
    """Check if string contains only letters (a-z, A-Z)."""
    if s.len() == 0:
        return false

    var i = 0
    while i < s.len():
        val ch = s[i..i+1]
        val valid = (ch >= "a" and ch <= "z") or (ch >= "A" and ch <= "Z")
        if not valid:
            return false
        i = i + 1

    true

fn contains_only_digits(s: text) -> bool:
    """Alias for is_numeric for consistency."""
    is_numeric(s)

fn contains_whitespace(s: text) -> bool:
    """Check if string contains any whitespace characters."""
    val nl_char = "\n"[0:1]
    var i = 0
    while i < s.len():
        val ch = s[i..i+1]
        if ch == " " or ch == "\t" or ch == nl_char or ch == "\r":
            return true
        i = i + 1
    false

fn starts_with_letter(s: text) -> bool:
    """Check if string starts with a letter."""
    if s.len() == 0:
        return false

    val first = s[0..1]
    (first >= "a" and first <= "z") or (first >= "A" and first <= "Z")

# ============================================================================
# Format Validation
# ============================================================================

fn is_valid_version(s: text) -> bool:
    """Check if string looks like a semantic version (e.g., "1.2.3").

    Very basic check: contains only digits and dots, has at least one dot.
    """
    if s.len() == 0:
        return false

    var has_dot = false
    var has_digit = false

    var i = 0
    while i < s.len():
        val ch = s[i..i+1]
        if ch == ".":
            has_dot = true
        elif ch >= "0" and ch <= "9":
            has_digit = true
        else:
            return false
        i = i + 1

    has_dot and has_digit

fn is_valid_path_component(s: text) -> bool:
    """Check if string is valid as a path component.

    Disallows: empty, starts with dot, contains slashes or backslashes.
    """
    if s.len() == 0:
        return false

    if s[0..1] == ".":
        return false

    var i = 0
    while i < s.len():
        val ch = s[i..i+1]
        if ch == "/" or ch == "\\":
            return false
        i = i + 1

    true

# ============================================================================
# Validation Result Helpers
# ============================================================================

fn require(condition: bool, message: text) -> text?:
    """Return error message if condition is false, nil otherwise.

    Usage:
        val error = require(age >= 18, "Must be 18 or older")
        if error.?:
            return Err(error.unwrap())
    """
    if condition:
        nil
    else:
        Some(message)

fn require_all(conditions: [(bool, text)]) -> [text]:
    """Check multiple conditions and collect all error messages.

    Returns array of error messages for failed conditions.

    Usage:
        val errors = require_all([
            (age >= 18, "Must be 18+"),
            (name.len() > 0, "Name required")
        ])
        if errors.len() > 0:
            return Err(errors.join("; "))
    """
    var errors = []
    for (condition, message) in conditions:
        if not condition:
            errors.push(message)
    errors
