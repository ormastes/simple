# AVL Tree Search Operations

use avl_tree.types.{is_nil, get_value, get_left, get_right}
use avl_tree.create.{get_root}

# ============================================================================
# Search Operations
# ============================================================================

# Search for a value in the tree (returns true if found)
fn avl_search(tree, value: i64) -> bool:
    val root = get_root(tree)
    search_node(root, value)

# Search in a node subtree
fn search_node(node, value: i64) -> bool:
    if is_nil(node):
        return false
    val node_value = get_value(node)
    if value == node_value:
        return true
    if value < node_value:
        val left = get_left(node)
        return search_node(left, value)
    val right = get_right(node)
    search_node(right, value)

# Check if tree contains a value
fn avl_contains(tree, value: i64) -> bool:
    avl_search(tree, value)

# Find node with value (returns node or nil)
fn find_node(node, value: i64):
    if is_nil(node):
        return nil
    val node_value = get_value(node)
    if value == node_value:
        return node
    if value < node_value:
        val left = get_left(node)
        return find_node(left, value)
    val right = get_right(node)
    find_node(right, value)

# ============================================================================
# Min/Max Operations
# ============================================================================

# Find minimum value in tree
fn avl_min(tree) -> i64:
    val root = get_root(tree)
    val min_node = find_min_node(root)
    if is_nil(min_node):
        return 0
    get_value(min_node)

# Find maximum value in tree
fn avl_max(tree) -> i64:
    val root = get_root(tree)
    val max_node = find_max_node(root)
    if is_nil(max_node):
        return 0
    get_value(max_node)

# Find node with minimum value in subtree
fn find_min_node(node):
    if is_nil(node):
        return nil
    val left = get_left(node)
    if is_nil(left):
        return node
    find_min_node(left)

# Find node with maximum value in subtree
fn find_max_node(node):
    if is_nil(node):
        return nil
    val right = get_right(node)
    if is_nil(right):
        return node
    find_max_node(right)

# ============================================================================
# Successor/Predecessor Operations
# ============================================================================

# Find inorder successor of a value in tree
fn inorder_successor(tree, value: i64) -> i64:
    val root = get_root(tree)
    val result = find_successor(root, value, nil)
    if is_nil(result):
        return 0
    get_value(result)

# Find successor node
fn find_successor(node, value: i64, successor):
    if is_nil(node):
        return successor

    val node_value = get_value(node)

    # If value is less than node, node might be successor
    if value < node_value:
        val left = get_left(node)
        return find_successor(left, value, node)

    # If value is greater or equal, go right
    val right = get_right(node)
    find_successor(right, value, successor)

# Find inorder predecessor of a value in tree
fn inorder_predecessor(tree, value: i64) -> i64:
    val root = get_root(tree)
    val result = find_predecessor(root, value, nil)
    if is_nil(result):
        return 0
    get_value(result)

# Find predecessor node
fn find_predecessor(node, value: i64, predecessor):
    if is_nil(node):
        return predecessor

    val node_value = get_value(node)

    # If value is greater than node, node might be predecessor
    if value > node_value:
        val right = get_right(node)
        return find_predecessor(right, value, node)

    # If value is less or equal, go left
    val left = get_left(node)
    find_predecessor(left, value, predecessor)

# Find successor of a node
fn successor(node):
    if is_nil(node):
        return nil
    val right = get_right(node)
    if is_nil(right):
        return nil
    find_min_node(right)

# Find predecessor of a node
fn predecessor(node):
    if is_nil(node):
        return nil
    val left = get_left(node)
    if is_nil(left):
        return nil
    find_max_node(left)

# ============================================================================
# Floor and Ceiling Operations
# ============================================================================

# Floor: largest element <= value
fn floor(tree, value: i64) -> i64:
    val root = get_root(tree)
    val result = find_floor(root, value, nil)
    if is_nil(result):
        return 0
    get_value(result)

# Find floor node
fn find_floor(node, value: i64, best):
    if is_nil(node):
        return best

    val node_value = get_value(node)

    # If node value equals target, that's the floor
    if node_value == value:
        return node

    # If node value > target, floor is in left subtree
    if node_value > value:
        val left = get_left(node)
        return find_floor(left, value, best)

    # If node value < target, this might be floor, but check right
    val right = get_right(node)
    find_floor(right, value, node)

# Ceiling: smallest element >= value
fn ceiling(tree, value: i64) -> i64:
    val root = get_root(tree)
    val result = find_ceiling(root, value, nil)
    if is_nil(result):
        return 0
    get_value(result)

# Find ceiling node
fn find_ceiling(node, value: i64, best):
    if is_nil(node):
        return best

    val node_value = get_value(node)

    # If node value equals target, that's the ceiling
    if node_value == value:
        return node

    # If node value < target, ceiling is in right subtree
    if node_value < value:
        val right = get_right(node)
        return find_ceiling(right, value, best)

    # If node value > target, this might be ceiling, but check left
    val left = get_left(node)
    find_ceiling(left, value, node)
