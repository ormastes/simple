# CSV Utility Functions

# ============================================================================
# Character and String Utilities
# ============================================================================

fn is_quote_char(c: text, quote: text) -> bool:
    c == quote

fn is_delimiter_char(c: text, delimiter: text) -> bool:
    c == delimiter

fn is_newline_char(c: text) -> bool:
    val result = c == "\n"
    result

fn is_carriage_return(c: text) -> bool:
    val result = c == "\r"
    result

fn is_whitespace_char(c: text) -> bool:
    val is_space = c == " "
    val is_tab = c == "\t"
    val is_nl = c == "\n"
    val is_cr = c == "\r"
    val result1 = is_space or is_tab
    val result2 = is_nl or is_cr
    val final_result = result1 or result2
    final_result

fn char_at(s: text, index: i64) -> text:
    val len = s.length()
    if index < 0 or index >= len:
        return ""
    val substring = s.substring(index, index + 1)
    substring

fn string_contains_char(s: text, c: text) -> text:
    val index = s.find(c)
    if index == -1:
        return "no"
    "yes"

# ============================================================================
# String Trimming
# ============================================================================

fn trim_left(s: text) -> text:
    var i = 0
    val len = s.length()
    loop:
        if i >= len:
            break
        val c = char_at(s, i)
        val is_ws = is_whitespace_char(c)
        if not is_ws:
            break
        i = i + 1
    val result = s.substring(i, len)
    result

fn trim_right(s: text) -> text:
    var i = s.length()
    loop:
        if i <= 0:
            break
        val c = char_at(s, i - 1)
        val is_ws = is_whitespace_char(c)
        if not is_ws:
            break
        i = i - 1
    val result = s.substring(0, i)
    result

fn trim_whitespace(s: text) -> text:
    val temp = trim_left(s)
    val result = trim_right(temp)
    result

fn trim_field(field: text, should_trim: bool) -> text:
    if not should_trim:
        return field
    val result = trim_whitespace(field)
    result

# ============================================================================
# Field Escaping and Unescaping
# ============================================================================

fn escape_quote_in_field(field: text, quote_char: text, escape_char: text) -> text:
    var result = ""
    var i = 0
    val len = field.length()
    loop:
        if i >= len:
            break
        val c = char_at(field, i)
        val is_q = is_quote_char(c, quote_char)
        if is_q:
            result = result + escape_char
            result = result + c
        else:
            result = result + c
        i = i + 1
    result

fn unescape_field(field: text, quote_char: text, escape_char: text) -> text:
    var result = ""
    var i = 0
    val len = field.length()
    loop:
        if i >= len:
            break
        val c = char_at(field, i)
        val is_esc = c == escape_char
        if is_esc:
            val next_i = i + 1
            if next_i < len:
                val next_c = char_at(field, next_i)
                val is_q = is_quote_char(next_c, quote_char)
                if is_q:
                    result = result + next_c
                    i = i + 2
                else:
                    result = result + c
                    i = i + 1
            else:
                result = result + c
                i = i + 1
        else:
            result = result + c
            i = i + 1
    result

fn needs_quoting(field: text, delimiter: text, quote_char: text) -> bool:
    val has_delimiter = string_contains_char(field, delimiter)
    val has_quote = string_contains_char(field, quote_char)
    val has_newline = string_contains_char(field, "\n")
    val has_cr = string_contains_char(field, "\r")
    val result1 = has_delimiter == "yes"
    val result2 = has_quote == "yes"
    val result3 = has_newline == "yes"
    val result4 = has_cr == "yes"
    val temp1 = result1 or result2
    val temp2 = result3 or result4
    val final = temp1 or temp2
    final

fn escape_field(field: text, config: CsvConfig) -> text:
    val needs_q = needs_quoting(field, config.delimiter, config.quote_char)
    if not needs_q:
        return field
    val escaped = escape_quote_in_field(field, config.quote_char, config.escape_char)
    var result = config.quote_char
    result = result + escaped
    result = result + config.quote_char
    result

# ============================================================================
# Comparison
# ============================================================================

fn compare_text_fields(field1: text, field2: text) -> i64:
    if field1 < field2:
        return -1
    if field1 > field2:
        return 1
    0

fn compare_numeric_fields(field1: text, field2: text) -> i64:
    val is_num1 = is_numeric_field(field1)
    val is_num2 = is_numeric_field(field2)
    if not is_num1 or not is_num2:
        return compare_text_fields(field1, field2)
    if field1 < field2:
        return -1
    if field1 > field2:
        return 1
    0

fn is_numeric_field(field: text) -> bool:
    val trimmed = trim_whitespace(field)
    val len = trimmed.length()
    if len == 0:
        return false

    var i = 0
    var has_digit = false
    var has_dot = false

    loop:
        if i >= len:
            break
        val c = char_at(trimmed, i)
        val is_minus = c == "-"
        val is_plus = c == "+"
        val is_dot = c == "."
        val is_digit = c >= "0" and c <= "9"

        if is_minus or is_plus:
            if i != 0:
                return false
        else:
            if is_dot:
                if has_dot:
                    return false
                has_dot = true
            else:
                if is_digit:
                    has_digit = true
                else:
                    return false
        i = i + 1

    has_digit
