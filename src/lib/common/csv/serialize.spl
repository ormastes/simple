# CSV Writing and Serialization Functions

use lib.common.csv.utilities.{string_contains_char, char_at, is_quote_char, needs_quoting, escape_field}

# ============================================================================
# CSV Writing Functions
# ============================================================================

fn write_csv_row(fields: list, config: CsvConfig) -> text:
    var result = ""
    var i = 0
    val field_count = fields.length()

    loop:
        if i >= field_count:
            break
        val field = fields.at(i)
        val escaped = escape_field(field, config)
        result = result + escaped
        val next_i = i + 1
        if next_i < field_count:
            result = result + config.delimiter
        i = i + 1

    result

fn write_csv_table(table: CsvTable) -> text:
    var result = ""
    val has_headers = table.headers.length() > 0

    if has_headers:
        val header_line = write_csv_row(table.headers, table.config)
        result = result + header_line
        result = result + table.config.line_ending

    var i = 0
    val row_count = table.rows.length()
    loop:
        if i >= row_count:
            break
        val row = table.rows.at(i)
        val row_line = write_csv_row(row, table.config)
        result = result + row_line
        val next_i = i + 1
        if next_i < row_count:
            result = result + table.config.line_ending
        i = i + 1

    result

fn write_csv_rows(rows: list, config: CsvConfig) -> text:
    val empty_headers = []
    val table = CsvTable(headers: empty_headers, rows: rows, config: config)
    write_csv_table(table)

fn write_csv_simple(rows: list) -> text:
    val config = default_csv_config()
    write_csv_rows(rows, config)

fn write_csv_with_headers(headers: list, rows: list, config: CsvConfig) -> text:
    val table = CsvTable(headers: headers, rows: rows, config: config)
    write_csv_table(table)

# ============================================================================
# Export Functions
# ============================================================================

fn table_to_string(table: CsvTable) -> text:
    write_csv_table(table)

fn rows_to_string(rows: list) -> text:
    write_csv_simple(rows)

fn rows_to_tsv(rows: list) -> text:
    val config = create_tsv_config()
    write_csv_rows(rows, config)

fn rows_to_csv_crlf(rows: list) -> text:
    val config = create_crlf_config()
    write_csv_rows(rows, config)

# Placeholder imports
fn default_csv_config() -> CsvConfig:
    CsvConfig(
        delimiter: ",",
        quote_char: "\"",
        escape_char: "\"",
        line_ending: "\n",
        trim_whitespace: false,
        skip_empty_lines: false
    )

fn create_tsv_config() -> CsvConfig:
    val base = default_csv_config()
    config_with_delimiter(base, "\t")

fn create_crlf_config() -> CsvConfig:
    val base = default_csv_config()
    config_with_line_ending(base, "\r\n")

fn config_with_delimiter(config: CsvConfig, delimiter: text) -> CsvConfig:
    CsvConfig(
        delimiter: delimiter,
        quote_char: config.quote_char,
        escape_char: config.escape_char,
        line_ending: config.line_ending,
        trim_whitespace: config.trim_whitespace,
        skip_empty_lines: config.skip_empty_lines
    )

fn config_with_line_ending(config: CsvConfig, line_ending: text) -> CsvConfig:
    CsvConfig(
        delimiter: config.delimiter,
        quote_char: config.quote_char,
        escape_char: config.escape_char,
        line_ending: line_ending,
        trim_whitespace: config.trim_whitespace,
        skip_empty_lines: config.skip_empty_lines
    )
