# Quadtree Utility Functions

from "std/quadtree/types" import node_bounds, node_capacity, node_point_count, node_depth, point_new, point_x, point_y, point_distance, point_equals, bounds_contains_point
from "std/quadtree/query" import node_query_range, quadtree_query_radius
from "std/quadtree/insert" import node_insert_point

# === Utility Functions ===

fn quadtree_all_points(tree):
    # Get all points in the quadtree
    val bounds = node_bounds(tree)
    node_query_range(tree, bounds)

fn quadtree_to_list(tree):
    # Convert quadtree to flat list of points
    quadtree_all_points(tree)

fn quadtree_is_empty(tree):
    # Check if quadtree is empty
    val count = quadtree_count(tree)
    count == 0

fn quadtree_contains(tree, x, y):
    # Check if quadtree contains a point at coordinates
    val bounds = node_bounds(tree)
    val point = point_new(x, y, nil)
    bounds_contains_point(bounds, point)

fn quadtree_count(tree):
    # Count total points in quadtree
    node_point_count(tree)

fn quadtree_depth(tree):
    # Get depth of quadtree
    node_depth(tree)

fn quadtree_bounds(tree):
    # Get bounds of quadtree
    node_bounds(tree)

# === Collision Detection ===

fn quadtree_find_collisions(tree, radius):
    # Find all pairs of points within radius of each other
    val all_points = node_query_range(tree, node_bounds(tree))
    var collisions = []
    var i = 0
    val count = len(all_points)
    while i < count:
        val p1 = all_points[i]
        val x = point_x(p1)
        val y = point_y(p1)
        val nearby = quadtree_query_radius(tree, x, y, radius)
        var j = 0
        val nearby_count = len(nearby)
        while j < nearby_count:
            val p2 = nearby[j]
            val is_same = point_equals(p1, p2)
            if not is_same:
                val dist = point_distance(p1, p2)
                val colliding = dist <= radius
                if colliding:
                    collisions = collisions + [(p1, p2)]
            j = j + 1
        i = i + 1
    collisions
