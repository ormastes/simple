# Quadtree Query Operations

from "std/quadtree/types" import node_bounds, node_is_leaf, node_points, node_child_nw, node_child_ne, node_child_sw, node_child_se, bounds_intersects_bounds, bounds_contains_point, bounds_intersects_circle, bounds_min_x, bounds_max_x, bounds_min_y, bounds_max_y, bounds_center_x, bounds_center_y, point_x, point_y, point_distance, point_new, bounds_new, node_point_count
from "std/quadtree/split" import point_equals

# === Quadtree Query Operations ===

fn node_query_range_helper(node, range_bounds, result):
    # Helper to collect points within range bounds
    val bounds = node_bounds(node)
    val intersects = bounds_intersects_bounds(bounds, range_bounds)
    if not intersects:
        result
    else:
        val is_leaf = node_is_leaf(node)
        if is_leaf:
            val points = node_points(node)
            var i = 0
            val count = len(points)
            var acc = result
            while i < count:
                val point = points[i]
                val in_range = bounds_contains_point(range_bounds, point)
                if in_range:
                    acc = acc + [point]
                i = i + 1
            acc
        else:
            # Check all four children
            val nw = node_child_nw(node)
            val ne = node_child_ne(node)
            val sw = node_child_sw(node)
            val se = node_child_se(node)
            var acc = result
            acc = node_query_range_helper(nw, range_bounds, acc)
            acc = node_query_range_helper(ne, range_bounds, acc)
            acc = node_query_range_helper(sw, range_bounds, acc)
            acc = node_query_range_helper(se, range_bounds, acc)
            acc

fn node_query_range(node, range_bounds):
    # Query all points within a rectangular range
    node_query_range_helper(node, range_bounds, [])

fn node_query_radius_helper(node, center_x, center_y, radius, result):
    # Helper to collect points within circular radius
    val bounds = node_bounds(node)
    val intersects = bounds_intersects_circle(bounds, center_x, center_y, radius)
    if not intersects:
        result
    else:
        val is_leaf = node_is_leaf(node)
        if is_leaf:
            val points = node_points(node)
            var i = 0
            val count = len(points)
            var acc = result
            val radius_sq = radius * radius
            while i < count:
                val point = points[i]
                val px = point_x(point)
                val py = point_y(point)
                val dx = px - center_x
                val dy = py - center_y
                val dist_sq = dx * dx + dy * dy
                val in_radius = dist_sq <= radius_sq
                if in_radius:
                    acc = acc + [point]
                i = i + 1
            acc
        else:
            # Check all four children
            val nw = node_child_nw(node)
            val ne = node_child_ne(node)
            val sw = node_child_sw(node)
            val se = node_child_se(node)
            var acc = result
            acc = node_query_radius_helper(nw, center_x, center_y, radius, acc)
            acc = node_query_radius_helper(ne, center_x, center_y, radius, acc)
            acc = node_query_radius_helper(sw, center_x, center_y, radius, acc)
            acc = node_query_radius_helper(se, center_x, center_y, radius, acc)
            acc

fn node_query_radius(node, center_x, center_y, radius):
    # Query all points within a circular radius
    node_query_radius_helper(node, center_x, center_y, radius, [])

fn node_nearest_neighbor_helper(node, target_x, target_y, best_point, best_dist_sq):
    # Helper to find nearest neighbor
    val bounds = node_bounds(node)

    # Early exit if this node can't have a closer point
    val min_x = bounds_min_x(bounds)
    val max_x = bounds_max_x(bounds)
    val min_y = bounds_min_y(bounds)
    val max_y = bounds_max_y(bounds)

    var closest_x = target_x
    if target_x < min_x:
        closest_x = min_x
    if target_x > max_x:
        closest_x = max_x

    var closest_y = target_y
    if target_y < min_y:
        closest_y = min_y
    if target_y > max_y:
        closest_y = max_y

    val dx = target_x - closest_x
    val dy = target_y - closest_y
    val min_possible_dist_sq = dx * dx + dy * dy

    val has_best = best_point != nil
    if has_best:
        val too_far = min_possible_dist_sq > best_dist_sq
        if too_far:
            (best_point, best_dist_sq)
        else:
            node_nearest_neighbor_search(node, target_x, target_y, best_point, best_dist_sq)
    else:
        node_nearest_neighbor_search(node, target_x, target_y, best_point, best_dist_sq)

fn node_nearest_neighbor_search(node, target_x, target_y, best_point, best_dist_sq):
    # Core search logic for nearest neighbor
    val is_leaf = node_is_leaf(node)
    if is_leaf:
        val points = node_points(node)
        var i = 0
        val count = len(points)
        var curr_best = best_point
        var curr_best_dist = best_dist_sq
        while i < count:
            val point = points[i]
            val px = point_x(point)
            val py = point_y(point)
            val dx = px - target_x
            val dy = py - target_y
            val dist_sq = dx * dx + dy * dy
            val has_curr = curr_best != nil
            if has_curr:
                val is_closer = dist_sq < curr_best_dist
                if is_closer:
                    curr_best = point
                    curr_best_dist = dist_sq
            else:
                curr_best = point
                curr_best_dist = dist_sq
            i = i + 1
        (curr_best, curr_best_dist)
    else:
        # Check children in order of proximity to target
        val nw = node_child_nw(node)
        val ne = node_child_ne(node)
        val sw = node_child_sw(node)
        val se = node_child_se(node)

        # Determine order by target location
        val bounds = node_bounds(node)
        val cx = bounds_center_x(bounds)
        val cy = bounds_center_y(bounds)
        val is_west = target_x < cx
        val is_north = target_y < cy

        var result = (best_point, best_dist_sq)

        # Search closest quadrant first
        if is_north and is_west:
            result = node_nearest_neighbor_helper(nw, target_x, target_y, result[0], result[1])
            result = node_nearest_neighbor_helper(ne, target_x, target_y, result[0], result[1])
            result = node_nearest_neighbor_helper(sw, target_x, target_y, result[0], result[1])
            result = node_nearest_neighbor_helper(se, target_x, target_y, result[0], result[1])
        else:
            if is_north:
                result = node_nearest_neighbor_helper(ne, target_x, target_y, result[0], result[1])
                result = node_nearest_neighbor_helper(nw, target_x, target_y, result[0], result[1])
                result = node_nearest_neighbor_helper(se, target_x, target_y, result[0], result[1])
                result = node_nearest_neighbor_helper(sw, target_x, target_y, result[0], result[1])
            else:
                if is_west:
                    result = node_nearest_neighbor_helper(sw, target_x, target_y, result[0], result[1])
                    result = node_nearest_neighbor_helper(nw, target_x, target_y, result[0], result[1])
                    result = node_nearest_neighbor_helper(se, target_x, target_y, result[0], result[1])
                    result = node_nearest_neighbor_helper(ne, target_x, target_y, result[0], result[1])
                else:
                    result = node_nearest_neighbor_helper(se, target_x, target_y, result[0], result[1])
                    result = node_nearest_neighbor_helper(sw, target_x, target_y, result[0], result[1])
                    result = node_nearest_neighbor_helper(ne, target_x, target_y, result[0], result[1])
                    result = node_nearest_neighbor_helper(nw, target_x, target_y, result[0], result[1])

        result

fn node_nearest_neighbor(node, target_x, target_y):
    # Find nearest neighbor to target coordinates
    val result = node_nearest_neighbor_helper(node, target_x, target_y, nil, 0.0)
    result[0]

fn quadtree_query_range(tree, min_x, min_y, max_x, max_y):
    # Query all points in a rectangular range
    val range_bounds = bounds_new(min_x, min_y, max_x, max_y)
    node_query_range(tree, range_bounds)

fn quadtree_query_radius(tree, center_x, center_y, radius):
    # Query all points within a circular radius
    node_query_radius(tree, center_x, center_y, radius)

fn quadtree_nearest(tree, x, y):
    # Find the nearest point to given coordinates
    node_nearest_neighbor(tree, x, y)

fn quadtree_k_nearest(tree, x, y, k):
    # Find k nearest neighbors to point (simple implementation)
    val all_points = node_query_range(tree, node_bounds(tree))
    var distances = []
    var i = 0
    val count = len(all_points)
    val target = point_new(x, y, nil)
    while i < count:
        val point = all_points[i]
        val dist = point_distance(target, point)
        distances = distances + [(point, dist)]
        i = i + 1

    # Sort by distance (bubble sort for simplicity)
    var sorted = distances
    var n = len(sorted)
    var swapped = true
    while swapped:
        swapped = false
        var idx = 1
        while idx < n:
            val prev = sorted[idx - 1]
            val curr = sorted[idx]
            val prev_dist = prev[1]
            val curr_dist = curr[1]
            if prev_dist > curr_dist:
                var temp = sorted[idx - 1]
                sorted[idx - 1] = sorted[idx]
                sorted[idx] = temp
                swapped = true
            idx = idx + 1
        n = n - 1

    # Take first k
    var result = []
    var j = 0
    var max_j = k
    val sorted_count = len(sorted)
    if sorted_count < max_j:
        max_j = sorted_count
    while j < max_j:
        val entry = sorted[j]
        val point = entry[0]
        result = result + [point]
        j = j + 1
    result
