# DOM Node Creation and Navigation
#
# Provides DOM node creation, attribute access, tree traversal, and queries.

# =============================================================================
# Node Creation
# =============================================================================

fn create_element(tag: text, attrs: list, children: list) -> tuple:
    (NODE_ELEMENT, tag, attrs, children, nil)

fn create_text_node(text: text) -> tuple:
    (NODE_TEXT, nil, [], [], text)

fn create_comment_node(text: text) -> tuple:
    (NODE_COMMENT, nil, [], [], text)

fn create_doctype_node(text: text) -> tuple:
    (NODE_DOCTYPE, nil, [], [], text)

# =============================================================================
# Node Accessors
# =============================================================================

fn node_type(node: tuple) -> text:
    node[0]

fn node_tag(node: tuple) -> text:
    node[1]

fn node_attrs(node: tuple) -> list:
    node[2]

fn node_children(node: tuple) -> list:
    node[3]

fn node_text(node: tuple) -> text:
    node[4]

# =============================================================================
# Attribute Operations
# =============================================================================

fn get_element_attr(node: tuple, attr_name: text) -> text:
    val attrs = node_attrs(node)
    var result = nil
    var i = 0
    while i < attrs.length():
        val attr = attrs[i]
        val name = attr[0]
        if name == attr_name:
            result = attr[1]
            i = attrs.length()
        else:
            i = i + 1
    result

fn has_element_attr(node: tuple, attr_name: text) -> bool:
    val attr_value = get_element_attr(node, attr_name)
    attr_value != nil

fn get_element_id(node: tuple) -> text:
    get_element_attr(node, "id")

fn get_element_class(node: tuple) -> text:
    get_element_attr(node, "class")

fn has_class(node: tuple, class_name: text) -> bool:
    val class_attr = get_element_class(node)
    var result = false
    if class_attr != nil:
        val classes = class_attr.split(" ")
        var i = 0
        while i < classes.length():
            val cls = classes[i].trim()
            if cls == class_name:
                result = true
                i = classes.length()
            else:
                i = i + 1
    result

# =============================================================================
# Tree Query Operations
# =============================================================================

fn find_by_tag(node: tuple, tag_name: text) -> list:
    var results = []
    val tag_lower = tag_name.to_lowercase()
    val node_tag_name = node_tag(node)

    if node_tag_name != nil:
        val node_tag_lower = node_tag_name.to_lowercase()
        if node_tag_lower == tag_lower:
            results = results.append(node)

    val children = node_children(node)
    var i = 0
    while i < children.length():
        val child = children[i]
        val child_results = find_by_tag(child, tag_name)
        results = results.concat(child_results)
        i = i + 1

    results

fn find_by_id(node: tuple, id: text) -> tuple:
    var result = nil
    val node_id = get_element_id(node)

    if node_id != nil:
        if node_id == id:
            result = node

    if result == nil:
        val children = node_children(node)
        var i = 0
        while i < children.length():
            if result == nil:
                val child = children[i]
                val child_result = find_by_id(child, id)
                if child_result != nil:
                    result = child_result
            i = i + 1

    result

fn find_by_class(node: tuple, class_name: text) -> list:
    var results = []

    if has_class(node, class_name):
        results = results.append(node)

    val children = node_children(node)
    var i = 0
    while i < children.length():
        val child = children[i]
        val child_results = find_by_class(child, class_name)
        results = results.concat(child_results)
        i = i + 1

    results

fn find_by_attr(node: tuple, attr_name: text, attr_value: text) -> list:
    var results = []
    val node_attr = get_element_attr(node, attr_name)

    if node_attr != nil:
        if node_attr == attr_value:
            results = results.append(node)

    val children = node_children(node)
    var i = 0
    while i < children.length():
        val child = children[i]
        val child_results = find_by_attr(child, attr_name, attr_value)
        results = results.concat(child_results)
        i = i + 1

    results

fn find_first_by_tag(node: tuple, tag_name: text) -> tuple:
    var result = nil
    val tag_lower = tag_name.to_lowercase()
    val node_tag_name = node_tag(node)

    if node_tag_name != nil:
        val node_tag_lower = node_tag_name.to_lowercase()
        if node_tag_lower == tag_lower:
            result = node

    if result == nil:
        val children = node_children(node)
        var i = 0
        while i < children.length():
            if result == nil:
                val child = children[i]
                result = find_first_by_tag(child, tag_name)
            i = i + 1

    result

fn find_first_by_class(node: tuple, class_name: text) -> tuple:
    var result = nil

    if has_class(node, class_name):
        result = node

    if result == nil:
        val children = node_children(node)
        var i = 0
        while i < children.length():
            if result == nil:
                val child = children[i]
                result = find_first_by_class(child, class_name)
            i = i + 1

    result

fn filter_elements(node: tuple, predicate_tag: text) -> list:
    var results = []
    val tag_lower = predicate_tag.to_lowercase()
    val node_tag_name = node_tag(node)

    if node_tag_name != nil:
        val node_tag_lower = node_tag_name.to_lowercase()
        if node_tag_lower == tag_lower:
            results = results.append(node)

    val children = node_children(node)
    var i = 0
    while i < children.length():
        val child = children[i]
        val child_results = filter_elements(child, predicate_tag)
        results = results.concat(child_results)
        i = i + 1

    results

fn has_tag(node: tuple, tag_name: text) -> bool:
    val found = find_first_by_tag(node, tag_name)
    found != nil

fn get_element_count_by_tag(node: tuple, tag_name: text) -> i64:
    val elements = find_by_tag(node, tag_name)
    elements.length()

# =============================================================================
# Tree Navigation
# =============================================================================

fn get_descendants(node: tuple) -> list:
    var results = []
    val children = node_children(node)
    var i = 0
    while i < children.length():
        val child = children[i]
        results = results.append(child)
        val child_descendants = get_descendants(child)
        results = results.concat(child_descendants)
        i = i + 1
    results

fn get_siblings(parent: tuple, target: tuple) -> list:
    var siblings = []
    val children = node_children(parent)
    var i = 0
    while i < children.length():
        val child = children[i]
        if child != target:
            siblings = siblings.append(child)
        i = i + 1
    siblings

fn get_first_child(node: tuple) -> tuple:
    val children = node_children(node)
    var result = nil
    if children.length() > 0:
        result = children[0]
    result

fn get_last_child(node: tuple) -> tuple:
    val children = node_children(node)
    var result = nil
    if children.length() > 0:
        result = children[children.length() - 1]
    result

fn get_child_count(node: tuple) -> i64:
    val children = node_children(node)
    children.length()

fn is_empty_element(node: tuple) -> bool:
    val children = node_children(node)
    children.length() == 0

fn has_children(node: tuple) -> bool:
    val children = node_children(node)
    children.length() > 0

# =============================================================================
# Text Content Extraction
# =============================================================================

fn get_text_content(node: tuple) -> text:
    var result = ""
    val ntype = node_type(node)

    if ntype == NODE_TEXT:
        result = node_text(node)
    else:
        if ntype == NODE_ELEMENT:
            val children = node_children(node)
            var i = 0
            while i < children.length():
                val child = children[i]
                val child_text = get_text_content(child)
                result = result + child_text
                i = i + 1

    result

fn has_text_content(node: tuple) -> bool:
    val text = get_text_content(node).trim()
    text.length() > 0

# =============================================================================
# Element Modification (returns new nodes)
# =============================================================================

fn add_child(node: tuple, child: tuple) -> tuple:
    val ntype = node_type(node)
    val tag = node_tag(node)
    val attrs = node_attrs(node)
    val children = node_children(node)
    val text = node_text(node)
    val new_children = children.append(child)
    (ntype, tag, attrs, new_children, text)

fn set_attr(node: tuple, attr_name: text, attr_value: text) -> tuple:
    val ntype = node_type(node)
    val tag = node_tag(node)
    val old_attrs = node_attrs(node)
    val children = node_children(node)
    val text = node_text(node)

    # Remove existing attribute with same name
    var new_attrs = []
    var i = 0
    while i < old_attrs.length():
        val attr = old_attrs[i]
        val name = attr[0]
        if name != attr_name:
            new_attrs = new_attrs.append(attr)
        i = i + 1

    # Add new attribute
    new_attrs = new_attrs.append((attr_name, attr_value))

    (ntype, tag, new_attrs, children, text)

fn remove_attr(node: tuple, attr_name: text) -> tuple:
    val ntype = node_type(node)
    val tag = node_tag(node)
    val old_attrs = node_attrs(node)
    val children = node_children(node)
    val text = node_text(node)

    var new_attrs = []
    var i = 0
    while i < old_attrs.length():
        val attr = old_attrs[i]
        val name = attr[0]
        if name != attr_name:
            new_attrs = new_attrs.append(attr)
        i = i + 1

    (ntype, tag, new_attrs, children, text)

fn set_children(node: tuple, new_children: list) -> tuple:
    val ntype = node_type(node)
    val tag = node_tag(node)
    val attrs = node_attrs(node)
    val text = node_text(node)
    (ntype, tag, attrs, new_children, text)

fn clear_children(node: tuple) -> tuple:
    set_children(node, [])

fn set_text(node: tuple, new_text: text) -> tuple:
    val ntype = node_type(node)
    val tag = node_tag(node)
    val attrs = node_attrs(node)
    val children = node_children(node)
    (ntype, tag, attrs, children, new_text)

# =============================================================================
# Node Type Constants
# =============================================================================

val NODE_ELEMENT = "element"
val NODE_TEXT = "text"
val NODE_COMMENT = "comment"
val NODE_DOCTYPE = "doctype"
