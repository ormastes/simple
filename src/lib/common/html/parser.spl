# HTML Parser and DOM Tree Construction
#
# Builds a DOM tree from HTML tokens with error recovery.

# =============================================================================
# DOM Tree Construction
# =============================================================================

fn parse_html(html: text) -> tuple:
    val tokens = tokenize_html(html)
    var root_children = []
    var tag_stack = []
    var i = 0

    while i < tokens.length():
        val token = tokens[i]
        val token_type = token[0]
        val token_value = token[1]
        val token_attrs = token[2]

        if token_type == TOKEN_TAG_OPEN:
            # Create element
            val elem = create_element(token_value, token_attrs, [])

            # Add to parent or root
            if tag_stack.length() > 0:
                val parent_idx = tag_stack.length() - 1
                val parent_info = tag_stack[parent_idx]
                val parent_node = parent_info[0]
                val parent_children = node_children(parent_node)
                val updated_children = parent_children.append(elem)
                val updated_parent = (node_type(parent_node), node_tag(parent_node), node_attrs(parent_node), updated_children, node_text(parent_node))
                tag_stack = tag_stack.set(parent_idx, (updated_parent, parent_info[1]))
            else:
                root_children = root_children.append(elem)

            # Check if void element
            var should_push = true
            if is_void_element(token_value):
                should_push = false

            if should_push:
                tag_stack = tag_stack.append((elem, token_value))
        else:
            if token_type == TOKEN_TAG_CLOSE:
                # Close matching tag
                if tag_stack.length() > 0:
                    val top_info = tag_stack[tag_stack.length() - 1]
                    val top_tag = top_info[1]
                    val top_tag_lower = top_tag.to_lowercase()
                    val close_tag_lower = token_value.to_lowercase()

                    if top_tag_lower == close_tag_lower:
                        tag_stack = tag_stack.slice(0, tag_stack.length() - 1)
                    else:
                        # Mismatched close - try to find matching open
                        var found_match = false
                        var match_idx = tag_stack.length() - 1
                        while match_idx >= 0:
                            val check_info = tag_stack[match_idx]
                            val check_tag = check_info[1]
                            val check_tag_lower = check_tag.to_lowercase()
                            if check_tag_lower == close_tag_lower:
                                found_match = true
                                match_idx = -1
                            else:
                                match_idx = match_idx - 1

                        if found_match:
                            # Auto-close intervening tags
                            var close_count = tag_stack.length() - match_idx - 1
                            var j = 0
                            while j < close_count:
                                tag_stack = tag_stack.slice(0, tag_stack.length() - 1)
                                j = j + 1
            else:
                if token_type == TOKEN_TAG_SELF_CLOSE:
                    # Self-closing tag
                    val elem = create_element(token_value, token_attrs, [])
                    if tag_stack.length() > 0:
                        val parent_idx = tag_stack.length() - 1
                        val parent_info = tag_stack[parent_idx]
                        val parent_node = parent_info[0]
                        val parent_children = node_children(parent_node)
                        val updated_children = parent_children.append(elem)
                        val updated_parent = (node_type(parent_node), node_tag(parent_node), node_attrs(parent_node), updated_children, node_text(parent_node))
                        tag_stack = tag_stack.set(parent_idx, (updated_parent, parent_info[1]))
                    else:
                        root_children = root_children.append(elem)
                else:
                    if token_type == TOKEN_TEXT:
                        # Text node
                        val trimmed = token_value.trim()
                        if trimmed.length() > 0:
                            val decoded = decode_html_entities(token_value)
                            val text_node = create_text_node(decoded)
                            if tag_stack.length() > 0:
                                val parent_idx = tag_stack.length() - 1
                                val parent_info = tag_stack[parent_idx]
                                val parent_node = parent_info[0]
                                val parent_children = node_children(parent_node)
                                val updated_children = parent_children.append(text_node)
                                val updated_parent = (node_type(parent_node), node_tag(parent_node), node_attrs(parent_node), updated_children, node_text(parent_node))
                                tag_stack = tag_stack.set(parent_idx, (updated_parent, parent_info[1]))
                            else:
                                root_children = root_children.append(text_node)
                    else:
                        if token_type == TOKEN_COMMENT:
                            # Comment node
                            val comment_node = create_comment_node(token_value)
                            if tag_stack.length() > 0:
                                val parent_idx = tag_stack.length() - 1
                                val parent_info = tag_stack[parent_idx]
                                val parent_node = parent_info[0]
                                val parent_children = node_children(parent_node)
                                val updated_children = parent_children.append(comment_node)
                                val updated_parent = (node_type(parent_node), node_tag(parent_node), node_attrs(parent_node), updated_children, node_text(parent_node))
                                tag_stack = tag_stack.set(parent_idx, (updated_parent, parent_info[1]))
                            else:
                                root_children = root_children.append(comment_node)
                        else:
                            if token_type == TOKEN_DOCTYPE:
                                # Doctype node
                                val doctype_node = create_doctype_node(token_value)
                                root_children = root_children.append(doctype_node)

        i = i + 1

    # Auto-close remaining open tags
    while tag_stack.length() > 0:
        tag_stack = tag_stack.slice(0, tag_stack.length() - 1)

    # Return root element with all children
    create_element("root", [], root_children)

# =============================================================================
# HTML Fragment Operations
# =============================================================================

fn parse_fragment(html: text) -> list:
    val tree = parse_html(html)
    node_children(tree)

# =============================================================================
# Dependencies (from other modules)
# =============================================================================

val TOKEN_TAG_OPEN = "tag_open"
val TOKEN_TAG_CLOSE = "tag_close"
val TOKEN_TAG_SELF_CLOSE = "tag_self"
val TOKEN_TEXT = "text"
val TOKEN_COMMENT = "comment"
val TOKEN_DOCTYPE = "doctype"

val NODE_ELEMENT = "element"
val NODE_TEXT = "text"
val NODE_COMMENT = "comment"
val NODE_DOCTYPE = "doctype"

fn create_element(tag: text, attrs: list, children: list) -> tuple:
    (NODE_ELEMENT, tag, attrs, children, nil)

fn create_text_node(text: text) -> tuple:
    (NODE_TEXT, nil, [], [], text)

fn create_comment_node(text: text) -> tuple:
    (NODE_COMMENT, nil, [], [], text)

fn create_doctype_node(text: text) -> tuple:
    (NODE_DOCTYPE, nil, [], [], text)

fn node_type(node: tuple) -> text:
    node[0]

fn node_tag(node: tuple) -> text:
    node[1]

fn node_attrs(node: tuple) -> list:
    node[2]

fn node_children(node: tuple) -> list:
    node[3]

fn node_text(node: tuple) -> text:
    node[4]

# Placeholder imports - these will be resolved by facade
fn tokenize_html(html: text) -> list:
    []

fn is_void_element(tag: text) -> bool:
    false

fn decode_html_entities(text: text) -> text:
    text
