# Linear Algebra - Matrix Operations (Extended)
#
# Extracted from matrix_ops.spl. Contains:
# - Determinant calculation
# - Row reduction (REF, RREF)
# - Matrix norms (Frobenius, L1, infinity)
# - Matrix-vector operations
# - Utility functions (copy, fill, equals, is_close)

from .types import LA_EPSILON
use lib.common.linear_algebra.matrix_ops.{la_matrix_dimensions, la_matrix_is_square, la_matrix_create}

# ============================================================================
# Matrix Determinant
# ============================================================================

fn la_matrix_determinant(matrix: [[f64]]) -> f64?:
    """Calculate determinant of square matrix using LU decomposition."""
    if not la_matrix_is_square(matrix):
        return nil
    val n = matrix.len()
    if n == 1:
        return matrix[0][0]
    if n == 2:
        return matrix[0][0] * matrix[1][1] - matrix[0][1] * matrix[1][0]
    val lu_result = la_matrix_lu_decomposition(matrix)
    if not lu_result.?:
        return nil
    val lower = lu_result[0]
    val upper = lu_result[1]
    val parity = lu_result[2]
    var det = parity
    var i = 0
    while i < n:
        det = det * upper[i][i]
        i = i + 1
    det

# ============================================================================
# Matrix Row Operations and Reduction
# ============================================================================

fn la_matrix_row_reduce(matrix: [[f64]]) -> [[f64]]:
    """Row reduce to row echelon form (REF)."""
    la_matrix_ref(matrix)

fn la_matrix_ref(matrix: [[f64]]) -> [[f64]]:
    """Convert to row echelon form."""
    val dims = la_matrix_dimensions(matrix)
    val rows = dims[0]
    val cols = dims[1]
    var result = la_matrix_copy(matrix)
    var pivot_row = 0
    var pivot_col = 0
    while pivot_row < rows and pivot_col < cols:
        var max_row = pivot_row
        var max_val = result[pivot_row][pivot_col]
        if max_val < 0.0:
            max_val = -max_val
        var i = pivot_row + 1
        while i < rows:
            var abs_val = result[i][pivot_col]
            if abs_val < 0.0:
                abs_val = -abs_val
            if abs_val > max_val:
                max_val = abs_val
                max_row = i
            i = i + 1
        if max_val < LA_EPSILON:
            pivot_col = pivot_col + 1
        else:
            if max_row != pivot_row:
                val temp_row = result[pivot_row]
                result[pivot_row] = result[max_row]
                result[max_row] = temp_row
            i = pivot_row + 1
            while i < rows:
                val factor = result[i][pivot_col] / result[pivot_row][pivot_col]
                result[i][pivot_col] = 0.0
                var j = pivot_col + 1
                while j < cols:
                    result[i][j] = result[i][j] - factor * result[pivot_row][j]
                    j = j + 1
                i = i + 1
            pivot_row = pivot_row + 1
            pivot_col = pivot_col + 1
    result

fn la_matrix_rref(matrix: [[f64]]) -> [[f64]]:
    """Convert to reduced row echelon form."""
    val dims = la_matrix_dimensions(matrix)
    val rows = dims[0]
    val cols = dims[1]
    var result = la_matrix_ref(matrix)
    var i = rows - 1
    while i >= 0:
        var pivot_col = -1
        var j = 0
        while j < cols:
            var abs_val = result[i][j]
            if abs_val < 0.0:
                abs_val = -abs_val
            if abs_val > LA_EPSILON:
                pivot_col = j
                j = cols
            j = j + 1
        if pivot_col >= 0:
            val pivot_val = result[i][pivot_col]
            j = 0
            while j < cols:
                result[i][j] = result[i][j] / pivot_val
                j = j + 1
            var k = 0
            while k < i:
                val factor = result[k][pivot_col]
                j = 0
                while j < cols:
                    result[k][j] = result[k][j] - factor * result[i][j]
                    j = j + 1
                k = k + 1
        i = i - 1
    result

# ============================================================================
# Matrix Norms
# ============================================================================

fn la_matrix_norm_frobenius(matrix: [[f64]]) -> f64:
    """Calculate Frobenius norm (square root of sum of squared elements)."""
    var sum = 0.0
    for row in matrix:
        for elem in row:
            sum = sum + elem * elem
    var sqrt_val = sum
    var iteration = 0
    while iteration < 20:
        if sqrt_val == 0.0:
            return 0.0
        sqrt_val = (sqrt_val + sum / sqrt_val) / 2.0
        iteration = iteration + 1
    sqrt_val

fn la_matrix_norm_l1(matrix: [[f64]]) -> f64:
    """Calculate L1 norm (maximum absolute column sum)."""
    val dims = la_matrix_dimensions(matrix)
    val rows = dims[0]
    val cols = dims[1]
    var max_sum = 0.0
    var j = 0
    while j < cols:
        var col_sum = 0.0
        var i = 0
        while i < rows:
            var abs_elem = matrix[i][j]
            if abs_elem < 0.0:
                abs_elem = -abs_elem
            col_sum = col_sum + abs_elem
            i = i + 1
        if col_sum > max_sum:
            max_sum = col_sum
        j = j + 1
    max_sum

fn la_matrix_norm_inf(matrix: [[f64]]) -> f64:
    """Calculate infinity norm (maximum absolute row sum)."""
    var max_sum = 0.0
    for row in matrix:
        var row_sum = 0.0
        for elem in row:
            var abs_elem = elem
            if abs_elem < 0.0:
                abs_elem = -abs_elem
            row_sum = row_sum + abs_elem
        if row_sum > max_sum:
            max_sum = row_sum
    max_sum

# ============================================================================
# Matrix-Vector Operations
# ============================================================================

fn la_matrix_vector_multiply(matrix: [[f64]], vector: [f64]) -> [f64]?:
    """Multiply matrix by column vector."""
    val dims = la_matrix_dimensions(matrix)
    val rows = dims[0]
    val cols = dims[1]
    if cols != vector.len():
        return nil
    var result = []
    var i = 0
    while i < rows:
        var sum = 0.0
        var j = 0
        while j < cols:
            sum = sum + matrix[i][j] * vector[j]
            j = j + 1
        result.push(sum)
        i = i + 1
    result

# ============================================================================
# Utility Functions
# ============================================================================

fn la_matrix_copy(matrix: [[f64]]) -> [[f64]]:
    """Create deep copy of matrix."""
    var result = []
    for row in matrix:
        var new_row = []
        for elem in row:
            new_row.push(elem)
        result.push(new_row)
    result

fn la_matrix_fill(matrix: [[f64]], value: f64) -> [[f64]]:
    """Fill all elements of matrix with value."""
    val dims = la_matrix_dimensions(matrix)
    val rows = dims[0]
    val cols = dims[1]
    la_matrix_create(rows, cols, value)

fn la_matrix_equals(m1: [[f64]], m2: [[f64]]) -> bool:
    """Check if two matrices are exactly equal."""
    val dims1 = la_matrix_dimensions(m1)
    val dims2 = la_matrix_dimensions(m2)
    val rows1 = dims1[0]
    val cols1 = dims1[1]
    val rows2 = dims2[0]
    val cols2 = dims2[1]
    if rows1 != rows2 or cols1 != cols2:
        return false
    var i = 0
    while i < rows1:
        var j = 0
        while j < cols1:
            if m1[i][j] != m2[i][j]:
                return false
            j = j + 1
        i = i + 1
    true

fn la_matrix_is_close(m1: [[f64]], m2: [[f64]], tolerance: f64) -> bool:
    """Check if two matrices are approximately equal within tolerance."""
    val dims1 = la_matrix_dimensions(m1)
    val dims2 = la_matrix_dimensions(m2)
    val rows1 = dims1[0]
    val cols1 = dims1[1]
    val rows2 = dims2[0]
    val cols2 = dims2[1]
    if rows1 != rows2 or cols1 != cols2:
        return false
    var i = 0
    while i < rows1:
        var j = 0
        while j < cols1:
            val diff = m1[i][j] - m2[i][j]
            var abs_diff = diff
            if abs_diff < 0.0:
                abs_diff = -abs_diff
            if abs_diff > tolerance:
                return false
            j = j + 1
        i = i + 1
    true

# Exports
export la_matrix_determinant, la_matrix_row_reduce, la_matrix_ref, la_matrix_rref
export la_matrix_norm_frobenius, la_matrix_norm_l1, la_matrix_norm_inf
export la_matrix_vector_multiply
export la_matrix_copy, la_matrix_fill, la_matrix_equals, la_matrix_is_close
