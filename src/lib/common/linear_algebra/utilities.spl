# Linear Algebra - Utilities
#
# Core utility functions used across linear algebra modules.
# These are fundamental operations with no external dependencies.

from .types import LA_EPSILON

# ============================================================================
# Matrix Utility Functions
# ============================================================================

fn la_matrix_dimensions(matrix: [[f64]]) -> (i64, i64):
    """Get matrix dimensions (rows, cols).

    Example:
        la_matrix_dimensions([[1.0, 2.0], [3.0, 4.0]])  # (2, 2)
    """
    if matrix.len() == 0:
        return (0, 0)
    (matrix.len(), matrix[0].len())

fn la_matrix_copy(matrix: [[f64]]) -> [[f64]]:
    """Create deep copy of matrix."""
    var result = []
    for row in matrix:
        var new_row = []
        for elem in row:
            new_row.push(elem)
        result.push(new_row)
    result

fn la_matrix_create(rows: i64, cols: i64, fill_value: f64) -> [[f64]]:
    """Create matrix filled with specified value."""
    var matrix = []
    var i = 0
    while i < rows:
        var row = []
        var j = 0
        while j < cols:
            row.push(fill_value)
            j = j + 1
        matrix.push(row)
        i = i + 1
    matrix

fn la_matrix_zero(rows: i64, cols: i64) -> [[f64]]:
    """Create zero matrix."""
    la_matrix_create(rows, cols, 0.0)

fn la_matrix_identity(n: i64) -> [[f64]]:
    """Create n√ón identity matrix."""
    var matrix = la_matrix_zero(n, n)
    var i = 0
    while i < n:
        matrix[i][i] = 1.0
        i = i + 1
    matrix

fn la_matrix_is_square(matrix: [[f64]]) -> bool:
    """Check if matrix is square."""
    val dims = la_matrix_dimensions(matrix)
    val rows = dims[0]
    val cols = dims[1]
    rows == cols and rows > 0

fn la_matrix_get_column(matrix: [[f64]], col: i64) -> [f64]?:
    """Get column as array."""
    if matrix.len() == 0:
        return nil
    if col < 0 or col >= matrix[0].len():
        return nil
    var column = []
    for row in matrix:
        column.push(row[col])
    column

fn la_matrix_from_columns(cols: [[f64]]) -> [[f64]]:
    """Create matrix from array of column arrays."""
    if cols.len() == 0:
        return []
    val rows = cols[0].len()
    val columns = cols.len()
    var matrix = []
    var i = 0
    while i < rows:
        var row = []
        var j = 0
        while j < columns:
            row.push(cols[j][i])
            j = j + 1
        matrix.push(row)
        i = i + 1
    matrix

fn la_matrix_from_rows(rows: [[f64]]) -> [[f64]]:
    """Create matrix from array of row arrays."""
    rows

# ============================================================================
# Vector Utility Functions
# ============================================================================

fn la_vector_dot(v1: [f64], v2: [f64]) -> f64?:
    """Calculate dot product of two vectors."""
    if v1.len() != v2.len():
        return nil
    var sum = 0.0
    var i = 0
    while i < v1.len():
        sum = sum + v1[i] * v2[i]
        i = i + 1
    sum

fn la_vector_scalar_multiply(v: [f64], scalar: f64) -> [f64]:
    """Multiply vector by scalar."""
    var result = []
    for elem in v:
        result.push(elem * scalar)
    result

fn la_vector_subtract(v1: [f64], v2: [f64]) -> [f64]?:
    """Subtract two vectors element-wise."""
    if v1.len() != v2.len():
        return nil
    var result = []
    var i = 0
    while i < v1.len():
        result.push(v1[i] - v2[i])
        i = i + 1
    result

fn la_vector_magnitude(v: [f64]) -> f64?:
    """Calculate magnitude (L2 norm) of vector."""
    val dot = la_vector_dot(v, v)
    if not dot.?:
        return nil
    var sqrt_val = dot
    var iteration = 0
    while iteration < 20:
        if sqrt_val == 0.0:
            return 0.0
        sqrt_val = (sqrt_val + dot / sqrt_val) / 2.0
        iteration = iteration + 1
    sqrt_val

fn la_vector_normalize(v: [f64]) -> [f64]?:
    """Normalize vector to unit length."""
    val mag = la_vector_magnitude(v)
    if not mag.?:
        return nil
    if mag < LA_EPSILON:
        return nil
    la_vector_scalar_multiply(v, 1.0 / mag)

fn la_vector_outer_product(v1: [f64], v2: [f64]) -> [[f64]]:
    """Calculate outer product (tensor product) of two vectors."""
    var result = []
    for elem1 in v1:
        var row = []
        for elem2 in v2:
            row.push(elem1 * elem2)
        result.push(row)
    result

# ============================================================================
# Matrix-Vector Operations
# ============================================================================

fn la_matrix_vector_multiply(matrix: [[f64]], vector: [f64]) -> [f64]?:
    """Multiply matrix by column vector."""
    val dims = la_matrix_dimensions(matrix)
    val rows = dims[0]
    val cols = dims[1]
    if cols != vector.len():
        return nil
    var result = []
    var i = 0
    while i < rows:
        var sum = 0.0
        var j = 0
        while j < cols:
            sum = sum + matrix[i][j] * vector[j]
            j = j + 1
        result.push(sum)
        i = i + 1
    result

# ============================================================================
# Exports
# ============================================================================

export la_matrix_dimensions, la_matrix_copy, la_matrix_create, la_matrix_zero
export la_matrix_identity, la_matrix_is_square, la_matrix_get_column
export la_matrix_from_columns, la_matrix_from_rows
export la_vector_dot, la_vector_scalar_multiply, la_vector_subtract
export la_vector_magnitude, la_vector_normalize, la_vector_outer_product
export la_matrix_vector_multiply
