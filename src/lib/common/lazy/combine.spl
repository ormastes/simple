# Stream Combination Operations
#
# Functions for combining multiple streams:
# - Zip (parallel combination)
# - Chain (sequential combination)
# - Concat (multiple stream concatenation)

import types: stream_next_internal
import create: stream_from_list

# ============================================================================
# Exports
# ============================================================================

export stream_zip, stream_chain, stream_concat

# ============================================================================
# Stream Combinators - Zip and Chain
# ============================================================================

fn stream_zip(stream1, stream2):
    """Zip two streams into stream of tuples. Stops when either exhausts.

    Example:
        val s1 = stream_from_list([1, 2, 3])
        val s2 = stream_from_list([4, 5, 6])
        stream_to_list(stream_zip(s1, s2))  # [(1, 4), (2, 5), (3, 6)]
    """
    var result = []
    var continue = true

    while continue:
        val next1 = stream_next_internal(stream1)
        val elem1 = next1[0]
        val has1 = next1[1]

        val next2 = stream_next_internal(stream2)
        val elem2 = next2[0]
        val has2 = next2[1]

        if has1 and has2:
            result.push((elem1, elem2))
        else:
            continue = false

    stream_from_list(result)

fn stream_chain(stream1, stream2):
    """Chain two streams together - stream2 starts after stream1 exhausts.

    Example:
        val s1 = stream_from_list([1, 2])
        val s2 = stream_from_list([3, 4])
        stream_to_list(stream_chain(s1, s2))  # [1, 2, 3, 4]
    """
    var result = []

    # Consume first stream
    var continue = true
    while continue:
        val next_result = stream_next_internal(stream1)
        val elem = next_result[0]
        val has_next = next_result[1]

        if has_next:
            result.push(elem)
        else:
            continue = false

    # Consume second stream
    continue = true
    while continue:
        val next_result = stream_next_internal(stream2)
        val elem = next_result[0]
        val has_next = next_result[1]

        if has_next:
            result.push(elem)
        else:
            continue = false

    stream_from_list(result)

fn stream_concat(streams):
    """Concatenate a list of streams into a single stream.

    Example:
        val s1 = stream_from_list([1, 2])
        val s2 = stream_from_list([3, 4])
        val s3 = stream_from_list([5, 6])
        stream_to_list(stream_concat([s1, s2, s3]))  # [1, 2, 3, 4, 5, 6]
    """
    var result = []

    for stream in streams:
        var continue = true
        while continue:
            val next_result = stream_next_internal(stream)
            val elem = next_result[0]
            val has_next = next_result[1]

            if has_next:
                result.push(elem)
            else:
                continue = false

    stream_from_list(result)
