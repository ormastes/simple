# Scrypt PBKDF2 Module
# BlockMix and ROMix implementation using PBKDF2

import scrypt.salsa20
import scrypt.types
import crypto_utils

# =============================================================================
# BLOCKMIX AND ROMIX IMPLEMENTATION
# =============================================================================

fn block_mix_salsa8(block: list, r: i64) -> list:
    """BlockMix function using Salsa20/8.

    Mixes a block of 2*r 64-byte sub-blocks.

    Algorithm:
    1. X = B[2*r-1]
    2. For i = 0 to 2*r-1:
         X = Salsa20/8(X XOR B[i])
         Y[i] = X
    3. Return Y (with even/odd reordering)

    Example:
        val mixed = block_mix_salsa8(block, 8)
    """
    val block_count = 2 * r

    # X = B[2*r-1] (last 64-byte block)
    var X = []
    var start = (block_count - 1) * 64
    var i = 0
    while i < 64:
        X.push(block.get(start + i))
        i = i + 1

    # Y will hold the results
    var Y = []
    i = 0
    while i < block_count * 64:
        Y.push(0)
        i = i + 1

    # Process each block
    var block_idx = 0
    while block_idx < block_count:
        # X = Salsa20/8(X XOR B[block_idx])
        start = block_idx * 64

        # XOR X with B[block_idx]
        var xor_block = []
        i = 0
        while i < 64:
            val x_byte = X.get(i)
            val b_byte = block.get(start + i)
            xor_block.push(x_byte ^ b_byte)
            i = i + 1

        # Convert to words, apply Salsa20/8, convert back to bytes
        val words = salsa20_bytes_to_words(xor_block)
        val mixed_words = salsa20_8_core(words)
        X = salsa20_words_to_bytes(mixed_words)

        # Store in Y (will reorder later)
        i = 0
        while i < 64:
            Y.set(block_idx * 64 + i, X.get(i))
            i = i + 1

        block_idx = block_idx + 1

    # Reorder Y: even-indexed blocks first, then odd-indexed blocks
    var result = []
    i = 0
    while i < block_count * 64:
        result.push(0)
        i = i + 1

    # Copy even blocks to first half
    block_idx = 0
    var dest_idx = 0
    while block_idx < block_count:
        if block_idx % 2 == 0:
            i = 0
            while i < 64:
                val byte = Y.get(block_idx * 64 + i)
                result.set(dest_idx * 64 + i, byte)
                i = i + 1
            dest_idx = dest_idx + 1
        block_idx = block_idx + 1

    # Copy odd blocks to second half
    block_idx = 0
    while block_idx < block_count:
        if block_idx % 2 == 1:
            i = 0
            while i < 64:
                val byte = Y.get(block_idx * 64 + i)
                result.set(dest_idx * 64 + i, byte)
                i = i + 1
            dest_idx = dest_idx + 1
        block_idx = block_idx + 1

    result

fn integerify(block: list, r: i64) -> i64:
    """Extract an integer from a block for indexing.

    Uses the last 64-byte sub-block and interprets first 4 bytes
    as little-endian integer.

    Example:
        val index = integerify(block, 8)
    """
    val block_count = 2 * r
    val start = (block_count - 1) * 64

    # Get first 4 bytes of last block as little-endian integer
    val b0 = block.get(start)
    val b1 = block.get(start + 1)
    val b2 = block.get(start + 2)
    val b3 = block.get(start + 3)

    val value = b0 | (b1 << 8) | (b2 << 16) | (b3 << 24)
    value & 0xFFFFFFFF

fn xor_blocks(block1: list, block2: list) -> list:
    """XOR two blocks of equal length.

    Example:
        val result = xor_blocks(b1, b2)
    """
    var result = []
    var i = 0
    while i < block1.len():
        val b1 = block1.get(i)
        val b2 = block2.get(i)
        result.push(b1 ^ b2)
        i = i + 1
    result

fn romix(block: list, N: i64, r: i64) -> list:
    """ROMix function - the memory-hard component of scrypt.

    Algorithm:
    1. X = B
    2. For i = 0 to N-1:
         V[i] = X
         X = BlockMix(X)
    3. For i = 0 to N-1:
         j = Integerify(X) mod N
         X = BlockMix(X XOR V[j])
    4. Return X

    This requires storing N blocks in memory (V array).

    Example:
        val result = romix(block, 16384, 8)
    """
    val block_size = 128 * r

    # Initialize V array to store N blocks
    var V = []
    var i = 0
    while i < N:
        V.push([])
        i = i + 1

    # X = B
    var X = []
    i = 0
    while i < block.len():
        X.push(block.get(i))
        i = i + 1

    # Fill V array
    i = 0
    while i < N:
        # V[i] = X
        var v_block = []
        var j = 0
        while j < X.len():
            v_block.push(X.get(j))
            j = j + 1
        V.set(i, v_block)

        # X = BlockMix(X)
        X = block_mix_salsa8(X, r)

        i = i + 1

    # Random access phase
    i = 0
    while i < N:
        # j = Integerify(X) mod N
        val j_value = integerify(X, r)
        val j = j_value % N

        # X = BlockMix(X XOR V[j])
        val v_j = V.get(j)
        val xor_result = xor_blocks(X, v_j)
        X = block_mix_salsa8(xor_result, r)

        i = i + 1

    X

# =============================================================================
# PBKDF2 WRAPPER (using crypto_utils)
# =============================================================================

fn pbkdf2_hmac_sha256(password: text, salt: text, iterations: i64, dkLen: i64) -> list:
    """PBKDF2-HMAC-SHA256 wrapper.

    Uses crypto_utils implementation.

    Example:
        val key = pbkdf2_hmac_sha256("password", "salt", 1, 32)
    """
    val password_bytes = crypto_utils.text_to_bytes(password)
    val salt_bytes = crypto_utils.text_to_bytes(salt)
    crypto_utils.pbkdf2_sha256_bytes(password_bytes, salt_bytes, iterations, dkLen)

fn pbkdf2_hmac_sha256_bytes(password_bytes: list, salt_bytes: list, iterations: i64, dkLen: i64) -> list:
    """PBKDF2-HMAC-SHA256 for byte arrays.

    Example:
        val key = pbkdf2_hmac_sha256_bytes(pwd_bytes, salt_bytes, 1, 32)
    """
    crypto_utils.pbkdf2_sha256_bytes(password_bytes, salt_bytes, iterations, dkLen)

