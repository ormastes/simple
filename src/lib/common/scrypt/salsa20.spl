# Scrypt Salsa20 Module
# Salsa20/8 core implementation

import crypto_utils

# SALSA20/8 CORE IMPLEMENTATION
# =============================================================================

fn salsa20_quarterround(y: list, a: i64, b: i64, c: i64, d: i64):
    """Salsa20 quarterround operation.

    Updates 4 words of the state using XOR and rotation.
    """
    val y_a = y.get(a)
    val y_b = y.get(b)
    val y_c = y.get(c)
    val y_d = y.get(d)

    # b ^= (a + d) <<< 7
    val sum_ad = crypto_utils.add_mod32(y_a, y_d)
    val rotl_7 = crypto_utils.rotl32(sum_ad, 7)
    val new_b = y_b ^ rotl_7
    y.set(b, new_b)

    # c ^= (b + a) <<< 9
    val sum_ba = crypto_utils.add_mod32(new_b, y_a)
    val rotl_9 = crypto_utils.rotl32(sum_ba, 9)
    val new_c = y_c ^ rotl_9
    y.set(c, new_c)

    # d ^= (c + b) <<< 13
    val sum_cb = crypto_utils.add_mod32(new_c, new_b)
    val rotl_13 = crypto_utils.rotl32(sum_cb, 13)
    val new_d = y_d ^ rotl_13
    y.set(d, new_d)

    # a ^= (d + c) <<< 18
    val sum_dc = crypto_utils.add_mod32(new_d, new_c)
    val rotl_18 = crypto_utils.rotl32(sum_dc, 18)
    val new_a = y_a ^ rotl_18
    y.set(a, new_a)

    y

fn rotl32(x: i64, n: i64) -> i64:
    """Left rotate for 32-bit values.

    Helper for Salsa20 quarterround.
    """
    val mask = 0xFFFFFFFF
    val x_masked = x & mask
    val shifted = ((x_masked << n) | (x_masked >> (32 - n))) & mask
    shifted

fn salsa20_8_core(input: list) -> list:
    """Salsa20/8 core function.

    Performs 8 rounds (4 double rounds) of the Salsa20 core.
    Input and output are 16 words (64 bytes).

    Example:
        val output = salsa20_8_core(input)
    """
    # Copy input to working state
    var x = []
    var i = 0
    while i < 16:
        x.push(input.get(i))
        i = i + 1

    # Perform 8 rounds (4 double rounds)
    var round = 0
    while round < 4:
        # Odd round - column quarterrounds
        salsa20_quarterround(x, 0, 4, 8, 12)
        salsa20_quarterround(x, 5, 9, 13, 1)
        salsa20_quarterround(x, 10, 14, 2, 6)
        salsa20_quarterround(x, 15, 3, 7, 11)

        # Even round - row quarterrounds
        salsa20_quarterround(x, 0, 1, 2, 3)
        salsa20_quarterround(x, 5, 6, 7, 4)
        salsa20_quarterround(x, 10, 11, 8, 9)
        salsa20_quarterround(x, 15, 12, 13, 14)

        round = round + 1

    # Add input to output
    var result = []
    i = 0
    while i < 16:
        val sum = crypto_utils.add_mod32(x.get(i), input.get(i))
        result.push(sum)
        i = i + 1

    result

fn salsa20_words_to_bytes(words: list) -> list:
    """Convert 16 words (32-bit) to 64 bytes (little-endian).

    Example:
        val bytes = salsa20_words_to_bytes(words)
    """
    var bytes = []
    var i = 0
    while i < words.len():
        val word = words.get(i)
        # Little-endian encoding
        bytes.push(word & 0xFF)
        bytes.push((word >> 8) & 0xFF)
        bytes.push((word >> 16) & 0xFF)
        bytes.push((word >> 24) & 0xFF)
        i = i + 1
    bytes

fn salsa20_bytes_to_words(bytes: list) -> list:
    """Convert 64 bytes to 16 words (32-bit) (little-endian).

    Example:
        val words = salsa20_bytes_to_words(bytes)
    """
    var words = []
    var i = 0
    while i < bytes.len():
        if i + 3 < bytes.len():
            val b0 = bytes.get(i)
            val b1 = bytes.get(i + 1)
            val b2 = bytes.get(i + 2)
            val b3 = bytes.get(i + 3)
            val word = b0 | (b1 << 8) | (b2 << 16) | (b3 << 24)
            words.push(word & 0xFFFFFFFF)
        i = i + 4
    words

