# Data Structure Utilities Module
#
# Stack, Queue, and Deque implementations for i64 values.
# All structures are array-based and support common operations.
#
# Categories:
# - Stack: LIFO (Last-In-First-Out) structure
# - Queue: FIFO (First-In-First-Out) structure
# - Deque: Double-ended queue (operations on both ends)
#
# All operations preserve immutability where possible.

# ============================================================================
# Exports
# ============================================================================

export Stack, Queue, Deque
export stack_from_list, queue_from_list, deque_from_list
export stack_get, queue_get, reverse_stack, merge_queues

# ============================================================================
# Stack (LIFO)
# ============================================================================

class Stack:
    items: [i64]

impl Stack:
    static fn create() -> Stack:
        Stack(items: [])

    fn is_empty() -> bool:
        self.items.len() == 0

    fn size() -> i64:
        self.items.len()

    me push(item: i64):
        self.items = self.items + [item]

    me pop() -> i64?:
        if self.items.len() == 0:
            return nil
        val last = self.items[self.items.len() - 1]
        # Remove last element by copying all but last
        var new_items: [i64] = []
        for i in 0..(self.items.len() - 1):
            new_items = new_items + [self.items[i]]
        self.items = new_items
        last

    fn peek() -> i64?:
        if self.items.len() == 0:
            return nil
        self.items[self.items.len() - 1]

    me clear():
        self.items = []

    fn to_list() -> [i64]:
        self.items

# ============================================================================
# Queue (FIFO)
# ============================================================================

class Queue:
    items: [i64]

impl Queue:
    static fn create() -> Queue:
        Queue(items: [])

    fn is_empty() -> bool:
        self.items.len() == 0

    fn size() -> i64:
        self.items.len()

    me enqueue(item: i64):
        self.items = self.items + [item]

    me dequeue() -> i64?:
        if self.items.len() == 0:
            return nil
        val first = self.items[0]
        # Remove first element by copying all but first
        var new_items: [i64] = []
        for i in 1..self.items.len():
            new_items = new_items + [self.items[i]]
        self.items = new_items
        first

    fn peek() -> i64?:
        if self.items.len() == 0:
            return nil
        self.items[0]

    me clear():
        self.items = []

# ============================================================================
# Deque (Double-Ended Queue)
# ============================================================================

class Deque:
    items: [i64]

impl Deque:
    static fn create() -> Deque:
        Deque(items: [])

    fn is_empty() -> bool:
        self.items.len() == 0

    fn size() -> i64:
        self.items.len()

    me push_front(item: i64):
        self.items = [item] + self.items

    me push_back(item: i64):
        self.items = self.items + [item]

    me pop_front() -> i64?:
        if self.items.len() == 0:
            return nil
        val first = self.items[0]
        # Remove first element
        var new_items: [i64] = []
        for i in 1..self.items.len():
            new_items = new_items + [self.items[i]]
        self.items = new_items
        first

    me pop_back() -> i64?:
        if self.items.len() == 0:
            return nil
        val last = self.items[self.items.len() - 1]
        # Remove last element
        var new_items: [i64] = []
        for i in 0..(self.items.len() - 1):
            new_items = new_items + [self.items[i]]
        self.items = new_items
        last

    fn peek_front() -> i64?:
        if self.items.len() == 0:
            return nil
        self.items[0]

    fn peek_back() -> i64?:
        if self.items.len() == 0:
            return nil
        self.items[self.items.len() - 1]

    me clear():
        self.items = []

# ============================================================================
# Helper Functions
# ============================================================================

fn stack_from_list(items: [i64]) -> Stack:
    """Create a stack from a list of items."""
    var stack = Stack.create()
    for item in items:
        stack.push(item)
    stack

fn queue_from_list(items: [i64]) -> Queue:
    """Create a queue from a list of items."""
    var queue = Queue.create()
    for item in items:
        queue.enqueue(item)
    queue

fn deque_from_list(items: [i64]) -> Deque:
    """Create a deque from a list of items."""
    var deque = Deque.create()
    for item in items:
        deque.push_back(item)
    deque

fn stack_get(stack: Stack, idx: i64) -> i64?:
    """Get element from stack by index (0 = top)."""
    val list = stack.to_list()
    if idx >= list.len():
        return nil
    list[list.len() - 1 - idx]

fn queue_get(queue: Queue, idx: i64) -> i64?:
    """Get element from queue by index (0 = front)."""
    if idx >= queue.size():
        return nil
    queue.items[idx]

fn reverse_stack(stack: Stack) -> Stack:
    """Reverse a stack."""
    var result = Stack.create()
    val items = stack.to_list()
    for item in items:
        result.push(item)
    var reversed = Stack.create()
    for _ in 0..items.len():
        val popped = result.pop()
        if popped != nil:
            reversed.push(popped)
    reversed

fn merge_queues(q1: Queue, q2: Queue) -> Queue:
    """Merge two queues."""
    var result = Queue.create()
    for item in q1.items:
        result.enqueue(item)
    for item in q2.items:
        result.enqueue(item)
    result
