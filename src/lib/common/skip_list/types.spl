# Skip List Type Definitions and Constants
#
# This module defines the core data structures, constants, and type accessors
# for the skip list implementation.

# =============================================================================
# Constants and Configuration
# =============================================================================

# Maximum number of levels in the skip list (supports 2^32 elements at p=0.5)
val MAX_LEVELS = 32

# Probability for level promotion (geometric distribution parameter)
val LEVEL_PROMOTION_PROBABILITY = 0.5

# Sentinel value representing null/nil node references
val NIL_REF = -1

# Minimum value for node keys (sentinel for head node)
val MIN_KEY = -9223372036854775808

# Maximum value for node keys
val MAX_KEY = 9223372036854775807

# Default initial capacity hint
val DEFAULT_CAPACITY = 16

# =============================================================================
# Random Number Generation (LCG for Probabilistic Level Assignment)
# =============================================================================

# Global RNG state (Linear Congruential Generator)
var rng_state = 1234567891

# Initialize or reseed the random number generator
fn sl_seed_rng(seed: i64):
    var state = rng_state
    state = seed
    rng_state = state

# Generate next pseudo-random integer using LCG algorithm
# Parameters: a = 1103515245, c = 12345, m = 2^31
fn sl_next_random() -> i64:
    var state = rng_state
    var a = 1103515245
    var c = 12345
    var m = 2147483648
    var next_val = ((state * a) + c) % m
    if next_val < 0:
        next_val = 0 - next_val
    rng_state = next_val
    next_val

# Generate random float in range [0.0, 1.0)
fn sl_random_uniform() -> f64:
    var rand_int = sl_next_random()
    var m = 2147483648.0
    var rand_float = rand_int
    rand_float / m

# Generate random boolean with given probability
fn sl_random_bool(probability: f64) -> i64:
    var r = sl_random_uniform()
    if r < probability:
        1
    else:
        0

# =============================================================================
# Node Structure (Tuple-Based)
# =============================================================================

# Node representation: (key: i64, value: i64, level: i64, forward: list)
# - key: Node key for ordering
# - value: Associated value
# - level: Maximum level of this node (0-based)
# - forward: Array of forward pointers (node indices), size = level + 1

# Create a new skip list node with specified level
fn sl_create_node(key: i64, value: i64, level: i64) -> tuple:
    var forward_ptrs = []
    var i = 0
    while i <= level:
        forward_ptrs.push(NIL_REF)
        i = i + 1
    (key, value, level, forward_ptrs)

# Get node key
fn sl_node_key(node: tuple) -> i64:
    var k = node[0]
    k

# Get node value
fn sl_node_value(node: tuple) -> i64:
    var v = node[1]
    v

# Get node level
fn sl_node_level(node: tuple) -> i64:
    var lvl = node[2]
    lvl

# Get node forward pointers array
fn sl_node_forward(node: tuple) -> list:
    var fwd = node[3]
    fwd

# Set node value (returns new node)
fn sl_node_set_value(node: tuple, new_value: i64) -> tuple:
    var key = sl_node_key(node)
    var level = sl_node_level(node)
    var forward = sl_node_forward(node)
    (key, new_value, level, forward)

# Get forward pointer at specific level
fn sl_node_get_forward(node: tuple, lvl: i64) -> i64:
    var forward = sl_node_forward(node)
    var ptr = forward[lvl]
    ptr

# Set forward pointer at specific level (returns new node)
fn sl_node_set_forward(node: tuple, lvl: i64, target_idx: i64) -> tuple:
    var key = sl_node_key(node)
    var value = sl_node_value(node)
    var level = sl_node_level(node)
    var forward = sl_node_forward(node)

    var new_forward = []
    var i = 0
    while i <= level:
        if i == lvl:
            new_forward.push(target_idx)
        else:
            var existing_ptr = forward[i]
            new_forward.push(existing_ptr)
        i = i + 1

    (key, value, level, new_forward)

# =============================================================================
# Skip List Structure (Tuple-Based)
# =============================================================================

# SkipList representation: (nodes: list, head_idx: i64, level: i64, size: i64)
# - nodes: Array of all nodes (index-based references)
# - head_idx: Index of the head sentinel node
# - level: Current maximum level in use
# - size: Number of elements (excluding head)

# Get nodes array from skip list
fn sl_get_nodes(skiplist: tuple) -> list:
    var n = skiplist[0]
    n

# Get head index from skip list
fn sl_get_head_idx(skiplist: tuple) -> i64:
    var h = skiplist[1]
    h

# Get current level from skip list
fn sl_get_level(skiplist: tuple) -> i64:
    var lvl = skiplist[2]
    lvl

# Get size from skip list
fn sl_get_size(skiplist: tuple) -> i64:
    var sz = skiplist[3]
    sz

# Set nodes array in skip list (returns new skip list)
fn sl_set_nodes(skiplist: tuple, nodes: list) -> tuple:
    var head_idx = sl_get_head_idx(skiplist)
    var level = sl_get_level(skiplist)
    var size = sl_get_size(skiplist)
    (nodes, head_idx, level, size)

# Set current level in skip list (returns new skip list)
fn sl_set_level(skiplist: tuple, new_level: i64) -> tuple:
    var nodes = sl_get_nodes(skiplist)
    var head_idx = sl_get_head_idx(skiplist)
    var size = sl_get_size(skiplist)
    (nodes, head_idx, new_level, size)

# Set size in skip list (returns new skip list)
fn sl_set_size(skiplist: tuple, new_size: i64) -> tuple:
    var nodes = sl_get_nodes(skiplist)
    var head_idx = sl_get_head_idx(skiplist)
    var level = sl_get_level(skiplist)
    (nodes, head_idx, level, new_size)

# Generate random level using geometric distribution with p=0.5
# Returns level in range [0, MAX_LEVELS - 1]
fn sl_generate_level() -> i64:
    var lvl = 0
    while sl_random_bool(LEVEL_PROMOTION_PROBABILITY) == 1:
        lvl = lvl + 1
        if lvl >= MAX_LEVELS - 1:
            return MAX_LEVELS - 1
    lvl

# Generate level with custom probability
fn sl_generate_level_with_prob(prob: f64) -> i64:
    var lvl = 0
    while sl_random_bool(prob) == 1:
        lvl = lvl + 1
        if lvl >= MAX_LEVELS - 1:
            return MAX_LEVELS - 1
    lvl

# Check if level should be promoted (for dynamic adjustment)
fn sl_should_promote_level(current_level: i64) -> i64:
    if current_level >= MAX_LEVELS - 1:
        return 0
    sl_random_bool(LEVEL_PROMOTION_PROBABILITY)

# Check if level should be demoted (for dynamic adjustment)
fn sl_should_demote_level(current_level: i64) -> i64:
    if current_level <= 0:
        return 0
    var demote_threshold = 0.25
    sl_random_bool(demote_threshold)
