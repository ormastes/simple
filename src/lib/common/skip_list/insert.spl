# Skip List Insertion Operations
#
# This module provides functions for inserting elements into skip lists.

import types
import search

# Insert key-value pair into skip list
fn sl_insert(skiplist: tuple, key: i64, value: i64) -> tuple:
    var nodes = types.sl_get_nodes(skiplist)
    var current_level = types.sl_get_level(skiplist)
    var size = types.sl_get_size(skiplist)

    var update = search.sl_find_update_path(skiplist, key)
    var pred_idx = update[0]

    if pred_idx != types.NIL_REF:
        var pred_node = nodes[pred_idx]
        var next_idx = types.sl_node_get_forward(pred_node, 0)

        if next_idx != types.NIL_REF:
            var next_node = nodes[next_idx]
            var next_key = types.sl_node_key(next_node)

            if next_key == key:
                var updated_node = types.sl_node_set_value(next_node, value)
                var new_nodes = []
                var i = 0
                while i < nodes.len():
                    if i == next_idx:
                        new_nodes = new_nodes + [updated_node]
                    else:
                        var existing = nodes[i]
                        new_nodes = new_nodes + [existing]
                    i = i + 1
                return types.sl_set_nodes(skiplist, new_nodes)

    var new_level = types.sl_generate_level()
    var updated_level = current_level

    if new_level > current_level:
        var lvl = current_level + 1
        var head_idx = types.sl_get_head_idx(skiplist)
        while lvl <= new_level:
            var new_update = []
            var j = 0
            while j < types.MAX_LEVELS:
                if j == lvl:
                    new_update = new_update + [head_idx]
                else:
                    var existing = update[j]
                    new_update = new_update + [existing]
                j = j + 1
            update = new_update
            lvl = lvl + 1
        updated_level = new_level

    var new_node = types.sl_create_node(key, value, new_level)
    var new_idx = nodes.len()
    var updated_nodes = nodes + [new_node]

    var insert_level = 0
    while insert_level <= new_level:
        var pred_idx2 = update[insert_level]
        var pred_node2 = updated_nodes[pred_idx2]
        var next_idx2 = types.sl_node_get_forward(pred_node2, insert_level)

        var updated_new_node = types.sl_node_set_forward(new_node, insert_level, next_idx2)
        var temp_nodes = []
        var k = 0
        while k < updated_nodes.len():
            if k == new_idx:
                temp_nodes = temp_nodes + [updated_new_node]
            else:
                var existing_node = updated_nodes[k]
                temp_nodes = temp_nodes + [existing_node]
            k = k + 1
        updated_nodes = temp_nodes
        new_node = updated_new_node

        var updated_pred = types.sl_node_set_forward(pred_node2, insert_level, new_idx)
        var temp_nodes2 = []
        var m = 0
        while m < updated_nodes.len():
            if m == pred_idx2:
                temp_nodes2 = temp_nodes2 + [updated_pred]
            else:
                var existing_node2 = updated_nodes[m]
                temp_nodes2 = temp_nodes2 + [existing_node2]
            m = m + 1
        updated_nodes = temp_nodes2

        insert_level = insert_level + 1

    var result = types.sl_set_nodes(skiplist, updated_nodes)
    result = types.sl_set_level(result, updated_level)
    result = types.sl_set_size(result, size + 1)
    result

# Insert multiple key-value pairs
fn sl_insert_many(skiplist: tuple, pairs: list) -> tuple:
    var result = skiplist
    var i = 0
    while i < pairs.len():
        var pair = pairs[i]
        var key = pair[0]
        var value = pair[1]
        result = sl_insert(result, key, value)
        i = i + 1
    result

# Insert or update key-value pair
fn sl_put(skiplist: tuple, key: i64, value: i64) -> tuple:
    sl_insert(skiplist, key, value)

# Update multiple values
fn sl_update_many(skiplist: tuple, pairs: list) -> tuple:
    sl_insert_many(skiplist, pairs)
