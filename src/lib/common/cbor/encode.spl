# CBOR Encoding Functions
# All cbor_encode_* functions for producing CBOR byte arrays.

use std.common.cbor.major_types.{*}
use std.common.cbor.types.{*}

# ============================================================================
# INTEGER ENCODING
# ============================================================================

fn encode_uint(major: i64, value: i64) -> [i64]:
    """Encode unsigned integer with given major type.
    Returns byte array with initial byte and optional additional bytes."""
    if value < 0:
        return []

    # Immediate value (0..23)
    if value <= 23:
        val initial = make_initial_byte(major, value)
        return [initial]

    # 1-byte uint8 (24..255)
    if value <= 255:
        val initial = make_initial_byte(major, addl_uint8())
        return [initial, value]

    # 2-byte uint16 (256..65535)
    if value <= 65535:
        val initial = make_initial_byte(major, addl_uint16())
        val high_byte = value / 256
        val low_byte = value % 256
        return [initial, high_byte, low_byte]

    # 4-byte uint32 (up to 2^32-1)
    if value <= 4294967295:
        val initial = make_initial_byte(major, addl_uint32())
        var result = [initial]
        var remaining = value
        var i = 0
        while i < 4:
            val divisor = 1 << (24 - i * 8)
            val byte_val = remaining / divisor
            result = result.push(byte_val)
            remaining = remaining % divisor
            i = i + 1
        return result

    # 8-byte uint64
    val initial = make_initial_byte(major, addl_uint64())
    var result = [initial]
    var remaining = value
    var i = 0
    while i < 8:
        val shift_amount = 56 - i * 8
        var divisor = 1
        var j = 0
        while j < shift_amount:
            divisor = divisor * 2
            j = j + 1
        val byte_val = remaining / divisor
        result = result.push(byte_val % 256)
        remaining = remaining % divisor
        i = i + 1
    result

fn cbor_encode_unsigned(value: i64) -> [i64]:
    """Encode unsigned integer (major type 0)."""
    encode_uint(major_unsigned_int(), value)

fn cbor_encode_int(value: i64) -> [i64]:
    """Encode signed integer (major type 0 or 1)."""
    if value >= 0:
        return cbor_encode_unsigned(value)
    # Negative: encode as major type 1 with (-1 - value)
    val encoded_value = -1 - value
    encode_uint(major_negative_int(), encoded_value)

# ============================================================================
# STRING ENCODING
# ============================================================================

fn cbor_encode_bytes(bytes: [i64]) -> [i64]:
    """Encode byte string (major type 2)."""
    val length = bytes.len()
    val header = encode_uint(major_byte_string(), length)
    bytes_concat(header, bytes)

fn cbor_encode_text(text: text) -> [i64]:
    """Encode text string (major type 3)."""
    val utf8_bytes = text_to_bytes(text)
    val length = utf8_bytes.len()
    val header = encode_uint(major_text_string(), length)
    bytes_concat(header, utf8_bytes)

# ============================================================================
# ARRAY AND MAP ENCODING
# ============================================================================

fn cbor_encode_array_header(length: i64) -> [i64]:
    """Encode array header (major type 4) with definite length."""
    encode_uint(major_array(), length)

fn cbor_encode_array_start() -> [i64]:
    """Encode start of indefinite-length array."""
    val initial = make_initial_byte(major_array(), addl_indefinite())
    [initial]

fn cbor_encode_map_header(length: i64) -> [i64]:
    """Encode map header (major type 5) with definite length."""
    encode_uint(major_map(), length)

fn cbor_encode_map_start() -> [i64]:
    """Encode start of indefinite-length map."""
    val initial = make_initial_byte(major_map(), addl_indefinite())
    [initial]

fn cbor_encode_break() -> [i64]:
    """Encode break stop code for indefinite-length items."""
    val initial = make_initial_byte(major_simple_float(), simple_break())
    [initial]

# ============================================================================
# SIMPLE VALUES ENCODING
# ============================================================================

fn cbor_encode_false() -> [i64]:
    """Encode boolean false."""
    val initial = make_initial_byte(major_simple_float(), simple_false())
    [initial]

fn cbor_encode_true() -> [i64]:
    """Encode boolean true."""
    val initial = make_initial_byte(major_simple_float(), simple_true())
    [initial]

fn cbor_encode_bool(value: bool) -> [i64]:
    """Encode boolean value."""
    if value:
        return cbor_encode_true()
    cbor_encode_false()

fn cbor_encode_null() -> [i64]:
    """Encode null/nil value."""
    val initial = make_initial_byte(major_simple_float(), simple_null())
    [initial]

fn cbor_encode_undefined() -> [i64]:
    """Encode undefined value."""
    val initial = make_initial_byte(major_simple_float(), simple_undefined())
    [initial]

fn cbor_encode_simple(value: i64) -> [i64]:
    """Encode simple value (0..19 are unassigned, 32..255 need uint8)."""
    if value < 0:
        return []
    if value <= 19:
        val initial = make_initial_byte(major_simple_float(), value)
        return [initial]
    if value <= 255:
        val initial = make_initial_byte(major_simple_float(), addl_uint8())
        return [initial, value]
    []

# ============================================================================
# FLOATING-POINT ENCODING (SIMPLIFIED)
# ============================================================================

fn cbor_encode_float64(value: f64) -> [i64]:
    """Encode double-precision float (simplified - stores as integer for now)."""
    # In real implementation, would convert float bits to 8 bytes
    # For now, convert to integer representation
    val int_value = value.to_int()
    val initial = make_initial_byte(major_simple_float(), simple_float64())
    var result = [initial]
    # Simplified: encode as 8-byte integer
    var remaining = int_value
    var i = 0
    while i < 8:
        result = result.push(remaining % 256)
        remaining = remaining / 256
        i = i + 1
    result

fn cbor_encode_float32(value: f64) -> [i64]:
    """Encode single-precision float (simplified)."""
    val int_value = value.to_int()
    val initial = make_initial_byte(major_simple_float(), simple_float32())
    var result = [initial]
    # Simplified: encode as 4-byte integer
    var remaining = int_value
    var i = 0
    while i < 4:
        result = result.push(remaining % 256)
        remaining = remaining / 256
        i = i + 1
    result

# ============================================================================
# TAGGED VALUES ENCODING
# ============================================================================

fn cbor_encode_tagged(tag: i64, value: [i64]) -> [i64]:
    """Encode tagged value (major type 6).
    tag: semantic tag number
    value: CBOR-encoded data item"""
    val tag_header = encode_uint(major_tag(), tag)
    bytes_concat(tag_header, value)

fn cbor_encode_timestamp(unix_seconds: i64) -> [i64]:
    """Encode Unix timestamp (tag 1 + integer)."""
    val value_bytes = cbor_encode_int(unix_seconds)
    cbor_encode_tagged(tag_epoch_datetime(), value_bytes)

fn cbor_encode_datetime_string(iso8601: text) -> [i64]:
    """Encode ISO 8601 datetime string (tag 0 + text)."""
    val value_bytes = cbor_encode_text(iso8601)
    cbor_encode_tagged(tag_datetime_string(), value_bytes)

fn cbor_encode_uri(uri: text) -> [i64]:
    """Encode URI (tag 32 + text)."""
    val value_bytes = cbor_encode_text(uri)
    cbor_encode_tagged(tag_uri(), value_bytes)

fn cbor_encode_regex(pattern: text) -> [i64]:
    """Encode regular expression (tag 35 + text)."""
    val value_bytes = cbor_encode_text(pattern)
    cbor_encode_tagged(tag_regex(), value_bytes)

fn cbor_encode_base64(data: text) -> [i64]:
    """Encode base64-expected data (tag 22 + text)."""
    val value_bytes = cbor_encode_text(data)
    cbor_encode_tagged(tag_base64(), value_bytes)

fn cbor_encode_base64url(data: text) -> [i64]:
    """Encode base64url-expected data (tag 21 + text)."""
    val value_bytes = cbor_encode_text(data)
    cbor_encode_tagged(tag_base64url(), value_bytes)

fn cbor_encode_base16(data: text) -> [i64]:
    """Encode base16/hex-expected data (tag 23 + text)."""
    val value_bytes = cbor_encode_text(data)
    cbor_encode_tagged(tag_base16(), value_bytes)

fn cbor_encode_mime(mime_message: text) -> [i64]:
    """Encode MIME message (tag 36 + text)."""
    val value_bytes = cbor_encode_text(mime_message)
    cbor_encode_tagged(tag_mime(), value_bytes)

fn cbor_encode_self_describe(value: [i64]) -> [i64]:
    """Encode self-describing CBOR (magic tag 55799 + value)."""
    cbor_encode_tagged(tag_self_describe(), value)
