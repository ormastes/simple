# CBOR Utilities
# Diagnostic notation, hexdump, and other utility functions.

use std.common.cbor.major_types.*
use std.common.cbor.types.*
use std.common.cbor.decode.*

# ============================================================================
# DIAGNOSTIC NOTATION (HUMAN-READABLE REPRESENTATION)
# ============================================================================

fn cbor_to_diagnostic(bytes: [i64], offset: i64) -> (text, i64):
    """Convert CBOR item to diagnostic notation text.
    Returns (text, bytes_consumed) or ("", 0) on error."""
    if offset >= bytes.len():
        return ("", 0)

    val type_info = cbor_decode_type(bytes, offset)
    val major = type_info.0
    val addl = type_info.1

    # Unsigned integer
    if major == major_unsigned_int():
        val int_result = cbor_decode_unsigned(bytes, offset)
        val value = int_result.0
        val consumed = int_result.1
        return ("{value}", consumed)

    # Negative integer
    if major == major_negative_int():
        val int_result = cbor_decode_int(bytes, offset)
        val value = int_result.0
        val consumed = int_result.1
        return ("{value}", consumed)

    # Byte string
    if major == major_byte_string():
        val bytes_result = cbor_decode_bytes(bytes, offset)
        val data = bytes_result.0
        val consumed = bytes_result.1
        return ("h'<bytes>'", consumed)

    # Text string
    if major == major_text_string():
        val text_result = cbor_decode_text(bytes, offset)
        val text = text_result.0
        val consumed = text_result.1
        return ("\"{text}\"", consumed)

    # Simple values
    if major == major_simple_float():
        if addl == simple_false():
            return ("false", 1)
        if addl == simple_true():
            return ("true", 1)
        if addl == simple_null():
            return ("null", 1)
        if addl == simple_undefined():
            return ("undefined", 1)
        if addl == simple_break():
            return ("break", 1)

    ("?", 1)

# ============================================================================
# UTILITY - HEXDUMP
# ============================================================================

fn cbor_hexdump(bytes: [i64]) -> text:
    """Create hexdump of CBOR bytes for debugging."""
    var result = ""
    var i = 0
    while i < bytes.len():
        val byte_val = bytes[i]
        val high = byte_val / 16
        val low = byte_val % 16
        var high_char = "0"
        var low_char = "0"

        if high == 0: high_char = "0"
        if high == 1: high_char = "1"
        if high == 2: high_char = "2"
        if high == 3: high_char = "3"
        if high == 4: high_char = "4"
        if high == 5: high_char = "5"
        if high == 6: high_char = "6"
        if high == 7: high_char = "7"
        if high == 8: high_char = "8"
        if high == 9: high_char = "9"
        if high == 10: high_char = "a"
        if high == 11: high_char = "b"
        if high == 12: high_char = "c"
        if high == 13: high_char = "d"
        if high == 14: high_char = "e"
        if high == 15: high_char = "f"

        if low == 0: low_char = "0"
        if low == 1: low_char = "1"
        if low == 2: low_char = "2"
        if low == 3: low_char = "3"
        if low == 4: low_char = "4"
        if low == 5: low_char = "5"
        if low == 6: low_char = "6"
        if low == 7: low_char = "7"
        if low == 8: low_char = "8"
        if low == 9: low_char = "9"
        if low == 10: low_char = "a"
        if low == 11: low_char = "b"
        if low == 12: low_char = "c"
        if low == 13: low_char = "d"
        if low == 14: low_char = "e"
        if low == 15: low_char = "f"

        result = result + high_char + low_char
        if i + 1 < bytes.len():
            result = result + " "
        i = i + 1
    result
