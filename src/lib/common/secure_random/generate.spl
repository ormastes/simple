# Random Number Generation Core
#
# Core functions for generating random bytes, integers, and floats

import "types" as Types
import "entropy" as Entropy
import "utilities" as Utils

# ChaCha20 quarter round
fn chacha20_quarter_round(state: list, a: i64, b: i64, c: i64, d: i64):
    var val_a = state.get(a)
    var val_b = state.get(b)
    var val_c = state.get(c)
    var val_d = state.get(d)
    val_a = (val_a + val_b) & 0xFFFFFFFF
    state.set(a, val_a)
    val_d = val_d ^ val_a
    val_d = Utils.rotate_left(val_d, 16)
    state.set(d, val_d)
    val_c = (val_c + val_d) & 0xFFFFFFFF
    state.set(c, val_c)
    val_b = val_b ^ val_c
    val_b = Utils.rotate_left(val_b, 12)
    state.set(b, val_b)
    val_a = state.get(a)
    val_a = (val_a + val_b) & 0xFFFFFFFF
    state.set(a, val_a)
    val_d = state.get(d)
    val_d = val_d ^ val_a
    val_d = Utils.rotate_left(val_d, 8)
    state.set(d, val_d)
    val_c = state.get(c)
    val_c = (val_c + val_d) & 0xFFFFFFFF
    state.set(c, val_c)
    val_b = state.get(b)
    val_b = val_b ^ val_c
    val_b = Utils.rotate_left(val_b, 7)
    state.set(b, val_b)

# ChaCha20 block function
fn chacha20_block(key: list, nonce: list, counter: i64) -> list:
    var state = []
    state.append(Types.CHACHA_CONST_0)
    state.append(Types.CHACHA_CONST_1)
    state.append(Types.CHACHA_CONST_2)
    state.append(Types.CHACHA_CONST_3)
    var i = 0
    while i < 8:
        if i < key.length():
            state.append(key.get(i) & 0xFFFFFFFF)
        else:
            state.append(0)
        i = i + 1
    state.append(counter & 0xFFFFFFFF)
    var j = 0
    while j < 3:
        if j < nonce.length():
            state.append(nonce.get(j) & 0xFFFFFFFF)
        else:
            state.append(0)
        j = j + 1
    var initial_state = []
    var k = 0
    while k < 16:
        initial_state.append(state.get(k))
        k = k + 1
    var round = 0
    while round < Types.CHACHA_ROUNDS:
        if round % 2 == 0:
            chacha20_quarter_round(state, 0, 4, 8, 12)
            chacha20_quarter_round(state, 1, 5, 9, 13)
            chacha20_quarter_round(state, 2, 6, 10, 14)
            chacha20_quarter_round(state, 3, 7, 11, 15)
        else:
            chacha20_quarter_round(state, 0, 5, 10, 15)
            chacha20_quarter_round(state, 1, 6, 11, 12)
            chacha20_quarter_round(state, 2, 7, 8, 13)
            chacha20_quarter_round(state, 3, 4, 9, 14)
        round = round + 1
    var m = 0
    while m < 16:
        var val = state.get(m)
        var init_val = initial_state.get(m)
        state.set(m, (val + init_val) & 0xFFFFFFFF)
        m = m + 1
    var output = []
    var n = 0
    while n < 16:
        var word = state.get(n)
        var bytes = Utils.u32_to_bytes_le(word)
        var p = 0
        while p < 4:
            output.append(bytes.get(p))
            p = p + 1
        n = n + 1
    output

# Initialize CSPRNG state
fn init_csprng_state():
    if Types.global_csprng_state == nil:
        Entropy.init_entropy_pools()
        var entropy = Entropy.collect_execution_entropy()
        Entropy.add_entropy(entropy)
        var more_entropy = Entropy.collect_time_entropy()
        Entropy.add_entropy(more_entropy)
        var seed = Entropy.get_reseed_entropy()
        var key = []
        var i = 0
        while i < 8:
            if i * 4 < seed.length():
                var word = Utils.bytes_to_u32_le(seed, i * 4)
                key.append(word)
            else:
                key.append(0)
            i = i + 1
        Types.global_csprng_state = (key, 0, [], 0, 0, true)

# Get current CSPRNG state
fn get_csprng_state():
    init_csprng_state()
    Types.global_csprng_state

# Reseed CSPRNG if needed
fn reseed_if_needed(state):
    var bytes_generated = state.4
    if bytes_generated >= Types.RESEED_THRESHOLD:
        reseed_csprng(state)

# Force reseed CSPRNG
fn reseed_csprng(state):
    var entropy = Entropy.collect_execution_entropy()
    Entropy.add_entropy(entropy)
    var more_entropy = Entropy.collect_time_entropy()
    Entropy.add_entropy(more_entropy)
    var reseed_data = Entropy.get_reseed_entropy()
    var old_key = state.0
    var new_key = []
    var i = 0
    while i < 8:
        var old_word = 0
        if i < old_key.length():
            old_word = old_key.get(i)
        var new_word = 0
        if i * 4 < reseed_data.length():
            new_word = Utils.bytes_to_u32_le(reseed_data, i * 4)
        new_key.append((old_word ^ new_word) & 0xFFFFFFFF)
        i = i + 1
    var counter = state.1
    var pool = state.2
    var reseed_count = state.3
    Types.global_csprng_state = (new_key, counter, pool, reseed_count + 1, 0, true)

# Generate n random bytes
fn secure_random_bytes(n: i64) -> list:
    init_csprng_state()
    var state = get_csprng_state()
    var result = []
    var bytes_needed = n
    var counter = state.1
    var key = state.0
    var nonce = [0x12345678, 0x9ABCDEF0, 0x13579BDF]
    while bytes_needed > 0:
        var block = chacha20_block(key, nonce, counter)
        counter = counter + 1
        var i = 0
        while i < block.length():
            if bytes_needed > 0:
                result.append(block.get(i))
                bytes_needed = bytes_needed - 1
            i = i + 1
    var pool = state.2
    var reseed_count = state.3
    var bytes_generated = state.4 + n
    Types.global_csprng_state = (key, counter, pool, reseed_count, bytes_generated, true)
    reseed_if_needed(Types.global_csprng_state)
    result

# Fill buffer with random bytes
fn fill_random_bytes(buffer: list, n: i64):
    var random_bytes = secure_random_bytes(n)
    var i = 0
    while i < n:
        if i < buffer.length():
            buffer.set(i, random_bytes.get(i))
        else:
            buffer.append(random_bytes.get(i))
        i = i + 1

# Generate random u32
fn secure_random_u32() -> i64:
    var bytes = secure_random_bytes(4)
    Utils.bytes_to_u32_le(bytes, 0)

# Generate random u64
fn secure_random_u64() -> i64:
    var bytes = secure_random_bytes(8)
    var low = Utils.bytes_to_u32_le(bytes, 0)
    var high = Utils.bytes_to_u32_le(bytes, 4)
    (high << 32) | low

# Generate random integer in range [min, max]
fn secure_random_int(min: i64, max: i64) -> i64:
    if min >= max:
        return min
    var range = max - min + 1
    var bytes_needed = 4
    if range > 0xFFFFFFFF:
        bytes_needed = 8
    var max_valid = 0xFFFFFFFF
    if bytes_needed == 8:
        max_valid = 0xFFFFFFFFFFFFFFFF
    var limit = max_valid - (max_valid % range)
    var attempts = 0
    while attempts < 1000:
        var rand_val = 0
        if bytes_needed == 4:
            rand_val = secure_random_u32()
        else:
            rand_val = secure_random_u64()
        if rand_val < limit:
            return min + (rand_val % range)
        attempts = attempts + 1
    var fallback = secure_random_u32()
    min + (fallback % range)

# Generate random float in [0.0, 1.0)
fn secure_random_float() -> f64:
    var rand = secure_random_u32()
    var divisor = 4294967296.0
    rand / divisor

# Generate random float in [min, max)
fn secure_random_range(min: f64, max: f64) -> f64:
    var rand = secure_random_float()
    min + rand * (max - min)

# Generate random double (higher precision)
fn secure_random_double() -> f64:
    var high = secure_random_u32()
    var low = secure_random_u32()
    var combined = (high << 20) | (low >> 12)
    var divisor = 9007199254740992.0
    combined / divisor

# Generate random boolean
fn secure_random_bool() -> bool:
    var rand = secure_random_u32()
    (rand & 1) == 1

# Generate random byte
fn secure_random_byte() -> i64:
    var bytes = secure_random_bytes(1)
    bytes.get(0) & 0xFF

# Generate random bytes as hex string
fn secure_random_hex(n: i64) -> text:
    var bytes = secure_random_bytes(n)
    Utils.bytes_to_hex(bytes)

# Generate random alphanumeric string
fn secure_random_alnum(length: i64) -> text:
    var charset = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789"
    generate_password(length, charset)

# Generate random lowercase string
fn secure_random_lowercase(length: i64) -> text:
    generate_password(length, "abcdefghijklmnopqrstuvwxyz")

# Generate random uppercase string
fn secure_random_uppercase(length: i64) -> text:
    generate_password(length, "ABCDEFGHIJKLMNOPQRSTUVWXYZ")

# Generate random digit string
fn secure_random_digits(length: i64) -> text:
    generate_password(length, "0123456789")

# Generate password with custom character set
fn generate_password(length: i64, charset: text) -> text:
    var result = ""
    var charset_len = charset.length()
    if charset_len == 0:
        return result
    var i = 0
    while i < length:
        var index = secure_random_int(0, charset_len - 1)
        var c = charset.get(index)
        result = result + c
        i = i + 1
    result

# Generate secure password (mixed case, digits, symbols)
fn generate_secure_password(length: i64) -> text:
    var lowercase = "abcdefghijklmnopqrstuvwxyz"
    var uppercase = "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
    var digits = "0123456789"
    var symbols = "!@#$%^&*()_+-=[]{}|;:,.<>?"
    var all_chars = lowercase + uppercase + digits + symbols
    var result = ""
    if length >= 4:
        var idx1 = secure_random_int(0, lowercase.length() - 1)
        result = result + lowercase.get(idx1)
        var idx2 = secure_random_int(0, uppercase.length() - 1)
        result = result + uppercase.get(idx2)
        var idx3 = secure_random_int(0, digits.length() - 1)
        result = result + digits.get(idx3)
        var idx4 = secure_random_int(0, symbols.length() - 1)
        result = result + symbols.get(idx4)
        var remaining = length - 4
        var i = 0
        while i < remaining:
            var idx = secure_random_int(0, all_chars.length() - 1)
            result = result + all_chars.get(idx)
            i = i + 1
        var chars = []
        var j = 0
        while j < result.length():
            chars.append(result.get(j))
            j = j + 1
        var shuffled = secure_shuffle(chars)
        result = ""
        var k = 0
        while k < shuffled.length():
            result = result + shuffled.get(k)
            k = k + 1
    else:
        result = generate_password(length, all_chars)
    result

# Generate alphanumeric password
fn generate_alphanumeric_password(length: i64) -> text:
    var charset = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789"
    generate_password(length, charset)

# Generate PIN (numeric only)
fn generate_pin(length: i64) -> text:
    generate_password(length, "0123456789")

# Generate UUID v4 (random UUID)
fn generate_uuid_v4() -> text:
    var bytes = secure_random_bytes(16)
    bytes.set(6, (bytes.get(6) & 0x0F) | 0x40)
    bytes.set(8, (bytes.get(8) & 0x3F) | 0x80)
    var hex = Utils.bytes_to_hex(bytes)
    var part1 = hex.substring(0, 8)
    var part2 = hex.substring(8, 12)
    var part3 = hex.substring(12, 16)
    var part4 = hex.substring(16, 20)
    var part5 = hex.substring(20, 32)
    part1 + "-" + part2 + "-" + part3 + "-" + part4 + "-" + part5

# Generate UUID as hex string (no dashes)
fn generate_uuid_hex() -> text:
    var bytes = secure_random_bytes(16)
    Utils.bytes_to_hex(bytes)

# Generate random token (raw bytes)
fn generate_token(length: i64) -> list:
    secure_random_bytes(length)

# Generate hex token
fn generate_hex_token(length: i64) -> text:
    var bytes = secure_random_bytes(length)
    Utils.bytes_to_hex(bytes)

# Generate base64 token
fn generate_base64_token(length: i64) -> text:
    var bytes = secure_random_bytes(length)
    Utils.bytes_to_base64(bytes)

# Forward declaration for shuffle
fn secure_shuffle(items: list) -> list:
    var result = []
    var i = 0
    while i < items.length():
        result.append(items.get(i))
        i = i + 1
    var n = result.length()
    var j = n - 1
    while j > 0:
        var k = secure_random_int(0, j)
        var temp = result.get(j)
        result.set(j, result.get(k))
        result.set(k, temp)
        j = j - 1
    result

# Reset CSPRNG
fn reset_csprng():
    Types.global_csprng_state = nil
    Types.entropy_pools = nil
    Types.pool_reseed_counter = 0

# Check if CSPRNG is initialized
fn is_csprng_initialized() -> bool:
    if Types.global_csprng_state == nil:
        return false
    var state = Types.global_csprng_state
    state.5

# Get CSPRNG statistics
fn get_csprng_stats():
    init_csprng_state()
    var state = get_csprng_state()
    var reseed_count = state.3
    var bytes_generated = state.4
    (reseed_count, bytes_generated)

# Force immediate reseed
fn force_reseed():
    init_csprng_state()
    reseed_csprng(get_csprng_state())

export chacha20_block
export secure_random_bytes
export fill_random_bytes
export secure_random_u32
export secure_random_u64
export secure_random_int
export secure_random_float
export secure_random_range
export secure_random_double
export secure_random_bool
export secure_random_byte
export secure_random_hex
export secure_random_alnum
export secure_random_lowercase
export secure_random_uppercase
export secure_random_digits
export generate_password
export generate_secure_password
export generate_alphanumeric_password
export generate_pin
export generate_uuid_v4
export generate_uuid_hex
export generate_token
export generate_hex_token
export generate_base64_token
export reset_csprng
export is_csprng_initialized
export get_csprng_stats
export force_reseed
