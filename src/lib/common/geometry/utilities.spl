# Geometry Utility Functions
#
# Transformations, bounding boxes, collisions, and misc utilities

use std.common.validation.{clamp_f64}

import "std/math" as math
import "std/geometry/types" as types
import "std/geometry/point" as point
import "std/geometry/line" as line
import "std/geometry/circle" as circle
import "std/geometry/polygon" as polygon

# ============================================================================
# Collision Detection
# ============================================================================

# Point-in-polygon test (alias for polygon_contains_point)
fn collision_point_in_polygon(poly: [(f64, f64)], p: (f64, f64)) -> bool:
    polygon.polygon_contains_point(poly, p)

# Circle-circle collision
fn collision_circle_circle(c1: ((f64, f64), f64), c2: ((f64, f64), f64)) -> bool:
    circle.circle_intersects(c1, c2)

# Rectangle-rectangle collision
fn collision_rect_rect(r1: ((f64, f64), f64, f64), r2: ((f64, f64), f64, f64)) -> bool:
    circle.rect_intersects(r1, r2)

# Circle-rectangle collision
fn collision_circle_rect(circ: ((f64, f64), f64), rect: ((f64, f64), f64, f64)) -> bool:
    circle.circle_rect_intersects(circ, rect)

# Point-circle collision
fn collision_point_circle(p: (f64, f64), circ: ((f64, f64), f64)) -> bool:
    circle.circle_contains_point(circ, p)

# Point-rectangle collision
fn collision_point_rect(p: (f64, f64), rect: ((f64, f64), f64, f64)) -> bool:
    circle.rect_contains_point(rect, p)

# Point-triangle collision
fn collision_point_triangle(p: (f64, f64), tri: ((f64, f64), (f64, f64), (f64, f64))) -> bool:
    circle.triangle_contains_point(tri, p)

# Line segment intersection test
fn collision_line_line(l1: ((f64, f64), (f64, f64)), l2: ((f64, f64), (f64, f64))) -> bool:
    line.line_segment_intersects(l1, l2)

# Circle-line collision
fn collision_circle_line(circ: ((f64, f64), f64), ln: ((f64, f64), (f64, f64))) -> bool:
    val center = circ.0
    val radius = circ.1
    val closest = line.line_closest_point(ln, center)
    val dist = point.point_distance(center, closest)
    dist <= radius

# ============================================================================
# Transformation Operations
# ============================================================================

# Transform a point: translate, rotate, scale
fn transform_point(p: (f64, f64), translation: (f64, f64), rotation: f64, scale: f64) -> (f64, f64):
    var result = p
    result = point.point_scale(result, scale)
    result = point.point_rotate(result, rotation)
    result = point.point_translate(result, translation)
    result

# Transform multiple points
fn transform_points(points: [(f64, f64)], translation: (f64, f64), rotation: f64, scale: f64) -> [(f64, f64)]:
    var result = []
    var i = 0
    while i < points.length():
        val p = points[i]
        val transformed = transform_point(p, translation, rotation, scale)
        result.push(transformed)
        i = i + 1
    result

# Create a 2D transformation matrix (as 6 values: a, b, c, d, e, f)
fn transform_matrix_create(translation: (f64, f64), rotation: f64, scale: (f64, f64)) -> (f64, f64, f64, f64, f64, f64):
    val cos_r = math.cos(rotation)
    val sin_r = math.sin(rotation)
    val sx = scale.0
    val sy = scale.1
    val tx = translation.0
    val ty = translation.1

    val a = cos_r * sx
    val b = sin_r * sx
    val c = 0.0 - sin_r * sy
    val d = cos_r * sy
    val e = tx
    val f = ty

    (a, b, c, d, e, f)

# Apply a transformation matrix to a point
fn transform_matrix_apply(matrix: (f64, f64, f64, f64, f64, f64), p: (f64, f64)) -> (f64, f64):
    val a = matrix.0
    val b = matrix.1
    val c = matrix.2
    val d = matrix.3
    val e = matrix.4
    val f = matrix.5

    val x = a * p.0 + c * p.1 + e
    val y = b * p.0 + d * p.1 + f
    (x, y)

# Compose two transformation matrices
fn transform_matrix_compose(m1: (f64, f64, f64, f64, f64, f64), m2: (f64, f64, f64, f64, f64, f64)) -> (f64, f64, f64, f64, f64, f64):
    val a1 = m1.0
    val b1 = m1.1
    val c1 = m1.2
    val d1 = m1.3
    val e1 = m1.4
    val f1 = m1.5

    val a2 = m2.0
    val b2 = m2.1
    val c2 = m2.2
    val d2 = m2.3
    val e2 = m2.4
    val f2 = m2.5

    val a = a1 * a2 + c1 * b2
    val b = b1 * a2 + d1 * b2
    val c = a1 * c2 + c1 * d2
    val d = b1 * c2 + d1 * d2
    val e = a1 * e2 + c1 * f2 + e1
    val f = b1 * e2 + d1 * f2 + f1

    (a, b, c, d, e, f)

# Reflect a 2D point across the X axis
fn transform_reflect_x(p: (f64, f64)) -> (f64, f64):
    val nx = p.0
    val ny = 0.0 - p.1
    (nx, ny)

# Reflect a 2D point across the Y axis
fn transform_reflect_y(p: (f64, f64)) -> (f64, f64):
    val nx = 0.0 - p.0
    val ny = p.1
    (nx, ny)

# Reflect a 2D point across the origin
fn transform_reflect_origin(p: (f64, f64)) -> (f64, f64):
    val nx = 0.0 - p.0
    val ny = 0.0 - p.1
    (nx, ny)

# Reflect a 2D point across a line defined by two points
fn transform_reflect_across_line(p: (f64, f64), ln: ((f64, f64), (f64, f64))) -> (f64, f64):
    val p1 = ln.0
    val p2 = ln.1
    val line_vec = point.vector_from_points(p1, p2)
    val normalized = point.vector_normalize(line_vec)
    val point_vec = point.vector_from_points(p1, p)
    val dot = point.vector_dot(point_vec, normalized)
    val projection = point.vector_multiply(normalized, dot)
    val proj_point_x = p1.0 + projection.0
    val proj_point_y = p1.1 + projection.1
    val proj_point = (proj_point_x, proj_point_y)
    val reflected_x = 2.0 * proj_point.0 - p.0
    val reflected_y = 2.0 * proj_point.1 - p.1
    (reflected_x, reflected_y)

# Scale a 2D point from a given center point
fn transform_scale_from_center(p: (f64, f64), center: (f64, f64), sx: f64, sy: f64) -> (f64, f64):
    val translated = point.point_translate(p, (0.0 - center.0, 0.0 - center.1))
    val scaled = point.point_scale_xy(translated, sx, sy)
    point.point_translate(scaled, center)

# Rotate and translate a 2D point
fn transform_rotate_translate(p: (f64, f64), angle: f64, translation: (f64, f64)) -> (f64, f64):
    val rotated = point.point_rotate(p, angle)
    point.point_translate(rotated, translation)

# ============================================================================
# Bounding Box Operations
# ============================================================================

# Calculate the bounding box of a set of points
fn bounding_box(points: [(f64, f64)]) -> ((f64, f64), f64, f64)?:
    val len = points.length()
    if len == 0:
        nil
    else:
        var min_x = points[0].0
        var max_x = points[0].0
        var min_y = points[0].1
        var max_y = points[0].1

        var i = 1
        while i < len:
            val p = points[i]
            min_x = math.min(min_x, p.0)
            max_x = math.max(max_x, p.0)
            min_y = math.min(min_y, p.1)
            max_y = math.max(max_y, p.1)
            i = i + 1

        ((min_x, min_y), max_x - min_x, max_y - min_y)

# Create a bounding box that encompasses two bounding boxes (union)
fn bbox_union(b1: ((f64, f64), f64, f64), b2: ((f64, f64), f64, f64)) -> ((f64, f64), f64, f64):
    val pos1 = b1.0
    val w1 = b1.1
    val h1 = b1.2
    val pos2 = b2.0
    val w2 = b2.1
    val h2 = b2.2
    val min_x = math.min(pos1.0, pos2.0)
    val min_y = math.min(pos1.1, pos2.1)
    val max_x = math.max(pos1.0 + w1, pos2.0 + w2)
    val max_y = math.max(pos1.1 + h1, pos2.1 + h2)
    ((min_x, min_y), max_x - min_x, max_y - min_y)

# Expand a bounding box by a margin on all sides
fn bbox_expand(bbox: ((f64, f64), f64, f64), margin: f64) -> ((f64, f64), f64, f64):
    val pos = bbox.0
    val w = bbox.1
    val h = bbox.2
    val new_x = pos.0 - margin
    val new_y = pos.1 - margin
    val new_w = w + 2.0 * margin
    val new_h = h + 2.0 * margin
    ((new_x, new_y), new_w, new_h)

# Check if a bounding box contains a point
fn bbox_contains_point(bbox: ((f64, f64), f64, f64), p: (f64, f64)) -> bool:
    circle.rect_contains_point(bbox, p)

# Get the area of a bounding box
fn bbox_area(bbox: ((f64, f64), f64, f64)) -> f64:
    circle.rect_area(bbox)

# Get the center of a bounding box
fn bbox_center(bbox: ((f64, f64), f64, f64)) -> (f64, f64):
    circle.rect_center(bbox)

# ============================================================================
# Miscellaneous Utilities
# ============================================================================

# Linear interpolation between two points
fn lerp_point(p1: (f64, f64), p2: (f64, f64), t: f64) -> (f64, f64):
    val x = p1.0 + (p2.0 - p1.0) * t
    val y = p1.1 + (p2.1 - p1.1) * t
    (x, y)

# Clamp a point to be within a rectangle
fn clamp_to_rect(p: (f64, f64), rect: ((f64, f64), f64, f64)) -> (f64, f64):
    val pos = rect.0
    val w = rect.1
    val h = rect.2

    val x = math.max(pos.0, math.min(p.0, pos.0 + w))
    val y = math.max(pos.1, math.min(p.1, pos.1 + h))
    (x, y)

# Calculate signed distance from a point to a line
fn distance_point_to_line(p: (f64, f64), ln: ((f64, f64), (f64, f64))) -> f64:
    val p1 = ln.0
    val p2 = ln.1
    val line_vec = point.vector_from_points(p1, p2)
    val point_vec = point.vector_from_points(p1, p)
    val cross = point.vector_cross(line_vec, point_vec)
    val line_len = point.vector_magnitude(line_vec)
    if math.abs(line_len) < types.EPSILON:
        0.0
    else:
        cross / line_len

# Calculate angle from p1 to p2 relative to positive x-axis
fn angle_between_points(p1: (f64, f64), p2: (f64, f64)) -> f64:
    val v = point.vector_from_points(p1, p2)
    point.vector_angle(v)

# Convert degrees to radians
fn degrees_to_radians(degrees: f64) -> f64:
    degrees * math.pi() / 180.0

# Convert radians to degrees
fn radians_to_degrees(radians: f64) -> f64:
    radians * 180.0 / math.pi()

# Check if three 2D points are collinear
fn collinear_2d(p1: (f64, f64), p2: (f64, f64), p3: (f64, f64)) -> bool:
    val v1 = point.vector_from_points(p1, p2)
    val v2 = point.vector_from_points(p1, p3)
    val cross = point.vector_cross(v1, v2)
    math.abs(cross) < types.EPSILON

# Check if four 3D points are coplanar
fn coplanar_3d(p1: (f64, f64, f64), p2: (f64, f64, f64), p3: (f64, f64, f64), p4: (f64, f64, f64)) -> bool:
    val v1 = point.vector3d_from_points(p1, p2)
    val v2 = point.vector3d_from_points(p1, p3)
    val v3 = point.vector3d_from_points(p1, p4)
    val normal = point.vector3d_cross(v1, v2)
    val dot = point.vector3d_dot(normal, v3)
    math.abs(dot) < types.EPSILON

# Normalize an angle to the range [0, 2*PI)
fn angle_normalize(angle: f64) -> f64:
    val pi = math.pi()
    val two_pi = 2.0 * pi
    var result = angle
    while result < 0.0:
        result = result + two_pi
    while result >= two_pi:
        result = result - two_pi
    result

# Calculate the signed angle difference (shortest rotation from a1 to a2)
fn angle_difference(a1: f64, a2: f64) -> f64:
    val pi = math.pi()
    val diff = angle_normalize(a2 - a1)
    if diff > pi:
        diff - 2.0 * pi
    else:
        diff

# Linear interpolation between two values
fn lerp(a: f64, b: f64, t: f64) -> f64:
    a + (b - a) * t

# Linear interpolation between two 3D points
fn lerp_point3d(p1: (f64, f64, f64), p2: (f64, f64, f64), t: f64) -> (f64, f64, f64):
    val x = lerp(p1.0, p2.0, t)
    val y = lerp(p1.1, p2.1, t)
    val z = lerp(p1.2, p2.2, t)
    (x, y, z)

# Clamp a value between min and max
