# Point Operations - 2D and 3D
#
# All 2D points are represented as tuples: (x, y)
# All 3D points are represented as tuples: (x, y, z)
# All angles are in radians unless otherwise specified

import "std/math" as math
import "std/geometry/types" as types

# ============================================================================
# 2D Point Operations
# ============================================================================

# Create a point at the given coordinates
# Example: point_create(3.0, 4.0) -> (3.0, 4.0)
fn point_create(x: f64, y: f64) -> (f64, f64):
    (x, y)

# Get the x coordinate of a point
fn point_x(p: (f64, f64)) -> f64:
    p.0

# Get the y coordinate of a point
fn point_y(p: (f64, f64)) -> f64:
    p.1

# Calculate the Euclidean distance between two points
# Example: point_distance((0.0, 0.0), (3.0, 4.0)) -> 5.0
fn point_distance(p1: (f64, f64), p2: (f64, f64)) -> f64:
    val dx = p2.0 - p1.0
    val dy = p2.1 - p1.1
    math.sqrt(dx * dx + dy * dy)

# Calculate the squared distance between two points (faster, no sqrt)
# Useful for comparisons where actual distance isn't needed
fn point_distance_squared(p1: (f64, f64), p2: (f64, f64)) -> f64:
    val dx = p2.0 - p1.0
    val dy = p2.1 - p1.1
    dx * dx + dy * dy

# Calculate the midpoint between two points
# Example: point_midpoint((0.0, 0.0), (4.0, 6.0)) -> (2.0, 3.0)
fn point_midpoint(p1: (f64, f64), p2: (f64, f64)) -> (f64, f64):
    ((p1.0 + p2.0) / 2.0, (p1.1 + p2.1) / 2.0)

# Rotate a point around the origin by the given angle (radians)
# Example: point_rotate((1.0, 0.0), PI/2) -> (0.0, 1.0)
fn point_rotate(p: (f64, f64), angle: f64) -> (f64, f64):
    val cos_a = math.cos(angle)
    val sin_a = math.sin(angle)
    val x = p.0 * cos_a - p.1 * sin_a
    val y = p.0 * sin_a + p.1 * cos_a
    (x, y)

# Rotate a point around a given center by the given angle (radians)
fn point_rotate_around(p: (f64, f64), center: (f64, f64), angle: f64) -> (f64, f64):
    val translated = (p.0 - center.0, p.1 - center.1)
    val rotated = point_rotate(translated, angle)
    (rotated.0 + center.0, rotated.1 + center.1)

# Translate a point by the given offset
# Example: point_translate((1.0, 2.0), (3.0, 4.0)) -> (4.0, 6.0)
fn point_translate(p: (f64, f64), offset: (f64, f64)) -> (f64, f64):
    (p.0 + offset.0, p.1 + offset.1)

# Scale a point by the given factor from the origin
# Example: point_scale((2.0, 3.0), 2.0) -> (4.0, 6.0)
fn point_scale(p: (f64, f64), factor: f64) -> (f64, f64):
    (p.0 * factor, p.1 * factor)

# Scale a point by different factors for x and y
fn point_scale_xy(p: (f64, f64), sx: f64, sy: f64) -> (f64, f64):
    (p.0 * sx, p.1 * sy)

# Check if two points are approximately equal (within EPSILON)
fn point_equal(p1: (f64, f64), p2: (f64, f64)) -> bool:
    val dx = math.abs(p1.0 - p2.0)
    val dy = math.abs(p1.1 - p2.1)
    dx < types.EPSILON and dy < types.EPSILON

# ============================================================================
# 3D Point Operations
# ============================================================================

# Create a 3D point at the given coordinates
fn point3d_create(x: f64, y: f64, z: f64) -> (f64, f64, f64):
    (x, y, z)

# Get the x coordinate of a 3D point
fn point3d_x(p: (f64, f64, f64)) -> f64:
    p.0

# Get the y coordinate of a 3D point
fn point3d_y(p: (f64, f64, f64)) -> f64:
    p.1

# Get the z coordinate of a 3D point
fn point3d_z(p: (f64, f64, f64)) -> f64:
    p.2

# Calculate the Euclidean distance between two 3D points
fn point3d_distance(p1: (f64, f64, f64), p2: (f64, f64, f64)) -> f64:
    val dx = p2.0 - p1.0
    val dy = p2.1 - p1.1
    val dz = p2.2 - p1.2
    val sum = dx * dx + dy * dy + dz * dz
    math.sqrt(sum)

# Calculate the squared distance between two 3D points
fn point3d_distance_squared(p1: (f64, f64, f64), p2: (f64, f64, f64)) -> f64:
    val dx = p2.0 - p1.0
    val dy = p2.1 - p1.1
    val dz = p2.2 - p1.2
    dx * dx + dy * dy + dz * dz

# Calculate the midpoint between two 3D points
fn point3d_midpoint(p1: (f64, f64, f64), p2: (f64, f64, f64)) -> (f64, f64, f64):
    val mx = (p1.0 + p2.0) / 2.0
    val my = (p1.1 + p2.1) / 2.0
    val mz = (p1.2 + p2.2) / 2.0
    (mx, my, mz)

# Check if two 3D points are approximately equal
fn point3d_equal(p1: (f64, f64, f64), p2: (f64, f64, f64)) -> bool:
    val dx = math.abs(p1.0 - p2.0)
    val dy = math.abs(p1.1 - p2.1)
    val dz = math.abs(p1.2 - p2.2)
    val check_x = dx < types.EPSILON
    val check_y = dy < types.EPSILON
    val check_z = dz < types.EPSILON
    check_x and check_y and check_z

# Translate a 3D point by the given offset
fn point3d_translate(p: (f64, f64, f64), offset: (f64, f64, f64)) -> (f64, f64, f64):
    val nx = p.0 + offset.0
    val ny = p.1 + offset.1
    val nz = p.2 + offset.2
    (nx, ny, nz)

# Scale a 3D point by the given factor from the origin
fn point3d_scale(p: (f64, f64, f64), factor: f64) -> (f64, f64, f64):
    val nx = p.0 * factor
    val ny = p.1 * factor
    val nz = p.2 * factor
    (nx, ny, nz)

# Scale a 3D point by different factors for x, y, and z
fn point3d_scale_xyz(p: (f64, f64, f64), sx: f64, sy: f64, sz: f64) -> (f64, f64, f64):
    val nx = p.0 * sx
    val ny = p.1 * sy
    val nz = p.2 * sz
    (nx, ny, nz)

# Create a vector from two points (from p1 to p2)
# Example: vector_from_points((1.0, 1.0), (4.0, 5.0)) -> (3.0, 4.0)
fn vector_from_points(p1: (f64, f64), p2: (f64, f64)) -> (f64, f64):
    (p2.0 - p1.0, p2.1 - p1.1)

# Add two vectors
# Example: vector_add((1.0, 2.0), (3.0, 4.0)) -> (4.0, 6.0)
fn vector_add(v1: (f64, f64), v2: (f64, f64)) -> (f64, f64):
    (v1.0 + v2.0, v1.1 + v2.1)

# Subtract two vectors (v1 - v2)
# Example: vector_subtract((5.0, 7.0), (2.0, 3.0)) -> (3.0, 4.0)
fn vector_subtract(v1: (f64, f64), v2: (f64, f64)) -> (f64, f64):
    (v1.0 - v2.0, v1.1 - v2.1)

# Multiply a vector by a scalar
fn vector_multiply(v: (f64, f64), scalar: f64) -> (f64, f64):
    (v.0 * scalar, v.1 * scalar)

# Calculate the dot product of two vectors
# Example: vector_dot((1.0, 0.0), (0.0, 1.0)) -> 0.0
fn vector_dot(v1: (f64, f64), v2: (f64, f64)) -> f64:
    v1.0 * v2.0 + v1.1 * v2.1

# Calculate the cross product (z-component) of two 2D vectors
# Returns positive if v2 is counterclockwise from v1, negative if clockwise
# Example: vector_cross((1.0, 0.0), (0.0, 1.0)) -> 1.0
fn vector_cross(v1: (f64, f64), v2: (f64, f64)) -> f64:
    v1.0 * v2.1 - v1.1 * v2.0

# Calculate the magnitude (length) of a vector
# Example: vector_magnitude((3.0, 4.0)) -> 5.0
fn vector_magnitude(v: (f64, f64)) -> f64:
    math.sqrt(v.0 * v.0 + v.1 * v.1)

# Calculate the squared magnitude of a vector (faster)
fn vector_magnitude_squared(v: (f64, f64)) -> f64:
    v.0 * v.0 + v.1 * v.1

# Normalize a vector (make it unit length)
# Returns (0.0, 0.0) if the vector has zero length
# Example: vector_normalize((3.0, 4.0)) -> (0.6, 0.8)
fn vector_normalize(v: (f64, f64)) -> (f64, f64):
    val mag = vector_magnitude(v)
    if math.abs(mag) < types.EPSILON:
        (0.0, 0.0)
    else:
        (v.0 / mag, v.1 / mag)

# Calculate the angle of a vector from the positive x-axis (radians)
# Example: vector_angle((1.0, 1.0)) -> PI/4
fn vector_angle(v: (f64, f64)) -> f64:
    math.atan2(v.1, v.0)

# Calculate the angle between two vectors (radians)
fn vector_angle_between(v1: (f64, f64), v2: (f64, f64)) -> f64:
    val dot = vector_dot(v1, v2)
    val mag1 = vector_magnitude(v1)
    val mag2 = vector_magnitude(v2)
    val denom = mag1 * mag2
    if math.abs(denom) < types.EPSILON:
        0.0
    else:
        math.acos(dot / denom)

# Rotate a vector by 90 degrees counterclockwise
fn vector_perpendicular(v: (f64, f64)) -> (f64, f64):
    (0.0 - v.1, v.0)

# Project vector v1 onto vector v2
fn vector_project(v1: (f64, f64), v2: (f64, f64)) -> (f64, f64):
    val dot = vector_dot(v1, v2)
    val mag2_sq = vector_magnitude_squared(v2)
    if math.abs(mag2_sq) < types.EPSILON:
        (0.0, 0.0)
    else:
        val scalar = dot / mag2_sq
        vector_multiply(v2, scalar)

# Reflect a vector across a normal
fn vector_reflect(v: (f64, f64), normal: (f64, f64)) -> (f64, f64):
    val dot = vector_dot(v, normal)
    val scaled = vector_multiply(normal, 2.0 * dot)
    vector_subtract(v, scaled)

# Create a 3D vector from two points (from p1 to p2)
fn vector3d_from_points(p1: (f64, f64, f64), p2: (f64, f64, f64)) -> (f64, f64, f64):
    val vx = p2.0 - p1.0
    val vy = p2.1 - p1.1
    val vz = p2.2 - p1.2
    (vx, vy, vz)

# Add two 3D vectors
fn vector3d_add(v1: (f64, f64, f64), v2: (f64, f64, f64)) -> (f64, f64, f64):
    val rx = v1.0 + v2.0
    val ry = v1.1 + v2.1
    val rz = v1.2 + v2.2
    (rx, ry, rz)

# Subtract two 3D vectors (v1 - v2)
fn vector3d_subtract(v1: (f64, f64, f64), v2: (f64, f64, f64)) -> (f64, f64, f64):
    val rx = v1.0 - v2.0
    val ry = v1.1 - v2.1
    val rz = v1.2 - v2.2
    (rx, ry, rz)

# Multiply a 3D vector by a scalar
fn vector3d_multiply(v: (f64, f64, f64), scalar: f64) -> (f64, f64, f64):
    val sx = v.0 * scalar
    val sy = v.1 * scalar
    val sz = v.2 * scalar
    (sx, sy, sz)

# Calculate the dot product of two 3D vectors
fn vector3d_dot(v1: (f64, f64, f64), v2: (f64, f64, f64)) -> f64:
    v1.0 * v2.0 + v1.1 * v2.1 + v1.2 * v2.2

# Calculate the cross product of two 3D vectors
fn vector3d_cross(v1: (f64, f64, f64), v2: (f64, f64, f64)) -> (f64, f64, f64):
    val rx = v1.1 * v2.2 - v1.2 * v2.1
    val ry = v1.2 * v2.0 - v1.0 * v2.2
    val rz = v1.0 * v2.1 - v1.1 * v2.0
    (rx, ry, rz)

# Calculate the magnitude (length) of a 3D vector
fn vector3d_magnitude(v: (f64, f64, f64)) -> f64:
    val sum = v.0 * v.0 + v.1 * v.1 + v.2 * v.2
    math.sqrt(sum)

# Calculate the squared magnitude of a 3D vector
fn vector3d_magnitude_squared(v: (f64, f64, f64)) -> f64:
    v.0 * v.0 + v.1 * v.1 + v.2 * v.2

# Normalize a 3D vector (make it unit length)
fn vector3d_normalize(v: (f64, f64, f64)) -> (f64, f64, f64):
    val mag = vector3d_magnitude(v)
    if math.abs(mag) < types.EPSILON:
        (0.0, 0.0, 0.0)
    else:
        val nx = v.0 / mag
        val ny = v.1 / mag
        val nz = v.2 / mag
        (nx, ny, nz)

# Calculate the angle between two 3D vectors (radians)
fn vector3d_angle_between(v1: (f64, f64, f64), v2: (f64, f64, f64)) -> f64:
    val dot = vector3d_dot(v1, v2)
    val mag1 = vector3d_magnitude(v1)
    val mag2 = vector3d_magnitude(v2)
    val denom = mag1 * mag2
    if math.abs(denom) < types.EPSILON:
        0.0
    else:
        val ratio = dot / denom
        math.acos(ratio)

# Project 3D vector v1 onto vector v2
fn vector3d_project(v1: (f64, f64, f64), v2: (f64, f64, f64)) -> (f64, f64, f64):
    val dot = vector3d_dot(v1, v2)
    val mag2_sq = vector3d_magnitude_squared(v2)
    if math.abs(mag2_sq) < types.EPSILON:
        (0.0, 0.0, 0.0)
    else:
        val scalar = dot / mag2_sq
        vector3d_multiply(v2, scalar)

# Reflect a 3D vector across a normal
fn vector3d_reflect(v: (f64, f64, f64), normal: (f64, f64, f64)) -> (f64, f64, f64):
    val dot = vector3d_dot(v, normal)
    val scaled = vector3d_multiply(normal, 2.0 * dot)
    vector3d_subtract(v, scaled)
