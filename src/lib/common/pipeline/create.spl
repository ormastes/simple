# Pipeline Creation and Composition
#
# Functions for creating, composing, and chaining pipelines.

# ============================================================================
# Exports
# ============================================================================

export add_step, add_steps, compose_pipelines, chain_pipelines

# ============================================================================
# Pipeline Building
# ============================================================================

fn add_step(pipeline, step_fn):
    """Add a transformation step to the pipeline.

    Returns a new pipeline with the step added.

    Example:
        var p = create_pipeline()
        p = add_step(p, \x: x * 2)
    """
    val new_steps = pipeline["steps"] + [step_fn]
    val new_metadata = pipeline["metadata"]
    new_metadata["count"] = new_steps.len()
    { steps: new_steps, metadata: new_metadata }

fn add_steps(pipeline, step_fns):
    """Add multiple transformation steps to the pipeline.

    Args:
        pipeline: The pipeline to modify
        step_fns: Array of functions to add

    Example:
        p = add_steps(p, [\x: x * 2, \x: x + 1])
    """
    var result = pipeline
    for fn_step in step_fns:
        result = add_step(result, fn_step)
    result

# ============================================================================
# Pipeline Composition
# ============================================================================

fn compose_pipelines(pipeline1, pipeline2):
    """Compose two pipelines into one (pipeline2 after pipeline1).

    The output of pipeline1 becomes the input of pipeline2.

    Example:
        val p1 = pipeline_from_functions([\x: x * 2])
        val p2 = pipeline_from_functions([\x: x + 1])
        val composed = compose_pipelines(p1, p2)
    """
    val steps1 = pipeline1["steps"]
    val steps2 = pipeline2["steps"]
    val combined = steps1 + steps2
    {
        steps: combined,
        metadata: {
            created: "composed",
            version: 1,
            count: combined.len(),
            from: [pipeline1["metadata"], pipeline2["metadata"]]
        }
    }

fn chain_pipelines(pipelines):
    """Chain multiple pipelines into a single pipeline.

    Args:
        pipelines: Array of pipeline objects

    Example:
        val chained = chain_pipelines([p1, p2, p3])
    """
    if pipelines.len() == 0:
        return create_pipeline()

    var result = pipelines[0]
    var i = 1
    while i < pipelines.len():
        result = compose_pipelines(result, pipelines[i])
        i = i + 1
    result
