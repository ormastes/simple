# Priority Queue Operations
#
# Functions for priority queue management

# Remove and return item with highest priority
fn pqueue_extract_max(pqueue):
    if pqueue.items.len() == 0:
        return nil
    var max_idx = 0
    var max_priority = pqueue.items[0].0
    var i = 1
    while i < pqueue.items.len():
        val current_priority = pqueue.items[i].0
        if current_priority > max_priority:
            max_priority = current_priority
            max_idx = i
        i = i + 1
    val item = pqueue.items[max_idx]
    var new_items = []
    var idx = 0
    while idx < pqueue.items.len():
        if idx != max_idx:
            new_items.push(pqueue.items[idx])
        idx = idx + 1
    pqueue.items = new_items
    Some(item)

# Remove and return item with lowest priority
fn pqueue_extract_min(pqueue):
    if pqueue.items.len() == 0:
        return nil
    var min_idx = 0
    var min_priority = pqueue.items[0].0
    var i = 1
    while i < pqueue.items.len():
        val current_priority = pqueue.items[i].0
        if current_priority < min_priority:
            min_priority = current_priority
            min_idx = i
        i = i + 1
    val item = pqueue.items[min_idx]
    var new_items = []
    var idx = 0
    while idx < pqueue.items.len():
        if idx != min_idx:
            new_items.push(pqueue.items[idx])
        idx = idx + 1
    pqueue.items = new_items
    Some(item)

# View item with highest priority without removing it
fn pqueue_peek_max(pqueue):
    if pqueue.items.len() == 0:
        return nil
    var max_idx = 0
    var max_priority = pqueue.items[0].0
    var i = 1
    while i < pqueue.items.len():
        val current_priority = pqueue.items[i].0
        if current_priority > max_priority:
            max_priority = current_priority
            max_idx = i
        i = i + 1
    Some(pqueue.items[max_idx])

# View item with lowest priority without removing it
fn pqueue_peek_min(pqueue):
    if pqueue.items.len() == 0:
        return nil
    var min_idx = 0
    var min_priority = pqueue.items[0].0
    var i = 1
    while i < pqueue.items.len():
        val current_priority = pqueue.items[i].0
        if current_priority < min_priority:
            min_priority = current_priority
            min_idx = i
        i = i + 1
    Some(pqueue.items[min_idx])

# Convert priority queue to sorted array
fn pqueue_sorted_array(pqueue, descending):
    var sorted = []
    for item in pqueue.items:
        sorted.push(item)
    var n = sorted.len()
    var swapped = true
    while swapped:
        swapped = false
        var i = 1
        while i < n:
            var should_swap = false
            if descending:
                should_swap = sorted[i-1].0 < sorted[i].0
            else:
                should_swap = sorted[i-1].0 > sorted[i].0
            if should_swap:
                val temp = sorted[i-1]
                sorted[i-1] = sorted[i]
                sorted[i] = temp
                swapped = true
            i = i + 1
        n = n - 1
    sorted

export pqueue_extract_max
export pqueue_extract_min
export pqueue_peek_max
export pqueue_peek_min
export pqueue_sorted_array
