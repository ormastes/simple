# Queue Utility Functions
#
# Common utility functions for all queue types

# Check if queue is empty
fn queue_is_empty(queue):
    queue.items.len() == 0

# Check if stack is empty
fn stack_is_empty(stack):
    stack.items.len() == 0

# Check if deque is empty
fn deque_is_empty(deque):
    deque.items.len() == 0

# Check if priority queue is empty
fn pqueue_is_empty(pqueue):
    pqueue.items.len() == 0

# Check if circular buffer is empty
fn cbuffer_is_empty(cbuffer):
    not cbuffer.full and cbuffer.head == cbuffer.tail

# Check if circular buffer is full
fn cbuffer_is_full(cbuffer):
    cbuffer.full

# Get number of items in queue
fn queue_size(queue):
    queue.items.len()

# Get number of items in stack
fn stack_size(stack):
    stack.items.len()

# Get number of items in deque
fn deque_size(deque):
    deque.items.len()

# Get number of items in priority queue
fn pqueue_size(pqueue):
    pqueue.items.len()

# Get current number of items in buffer
fn cbuffer_size(cbuffer):
    if cbuffer.full:
        return cbuffer.capacity
    if cbuffer.tail >= cbuffer.head:
        cbuffer.tail - cbuffer.head
    else:
        cbuffer.capacity - (cbuffer.head - cbuffer.tail)

# Get total capacity of buffer
fn cbuffer_capacity(cbuffer):
    cbuffer.capacity

# Remove all items from queue
fn queue_clear(queue):
    queue.items = []

# Remove all items from stack
fn stack_clear(stack):
    stack.items = []

# Remove all items from deque
fn deque_clear(deque):
    deque.items = []

# Remove all items from priority queue
fn pqueue_clear(pqueue):
    pqueue.items = []

# Remove all items from buffer
fn cbuffer_clear(cbuffer):
    cbuffer.items = []
    cbuffer.head = 0
    cbuffer.tail = 0
    cbuffer.full = false

# Check if queue contains item
fn queue_contains(queue, item):
    for elem in queue.items:
        if elem == item:
            return true
    false

# Check if stack contains item
fn stack_contains(stack, item):
    for elem in stack.items:
        if elem == item:
            return true
    false

# Create new queue with items matching predicate
fn queue_filter(queue, predicate):
    var items = []
    for item in queue.items:
        if predicate(item):
            items.push(item)
    (items: items, )

# Create new stack with items matching predicate
fn stack_filter(stack, predicate):
    var items = []
    for item in stack.items:
        if predicate(item):
            items.push(item)
    (items: items, )

# Create new queue by applying function to each item
fn queue_map(queue, f):
    var items = []
    for item in queue.items:
        items.push(f(item))
    (items: items, )

# Create new stack by applying function to each item
fn stack_map(stack, f):
    var items = []
    for item in stack.items:
        items.push(f(item))
    (items: items, )

# Create new queue with items in reverse order
fn queue_reverse(queue):
    var items = []
    var i = queue.items.len() - 1
    while i >= 0:
        items.push(queue.items[i])
        i = i - 1
    (items: items, )

# Create new stack with items in reverse order
fn stack_reverse(stack):
    var items = []
    var i = stack.items.len() - 1
    while i >= 0:
        items.push(stack.items[i])
        i = i - 1
    (items: items, )

export queue_is_empty
export stack_is_empty
export deque_is_empty
export pqueue_is_empty
export cbuffer_is_empty
export cbuffer_is_full
export queue_size
export stack_size
export deque_size
export pqueue_size
export cbuffer_size
export cbuffer_capacity
export queue_clear
export stack_clear
export deque_clear
export pqueue_clear
export cbuffer_clear
export queue_contains
export stack_contains
export queue_filter
export stack_filter
export queue_map
export stack_map
export queue_reverse
export stack_reverse
