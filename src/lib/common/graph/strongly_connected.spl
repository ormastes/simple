# Strongly Connected Components
#
# Purpose: Algorithms for finding strongly connected components in directed graphs
#
# Contains:
# - Kosaraju's algorithm for SCCs
# - Graph reversal
# - Connectivity checking

# Import modules
mod graph.types
mod graph.traversal

# ============================================================================
# Connectivity Algorithms
# ============================================================================

# Find connected components (for undirected graphs)
# Returns list of components (each component is a list of vertices)
fn graph_connected_components(graph: tuple) -> list:
    var visited = {}
    var components = []
    var num_vertices = graph.2

    var i = 0
    while i < num_vertices:
        var is_visited = visited.get(i)
        if is_visited == nil:
            var component = graph_dfs(graph, i)
            components = components.append(component)
            var j = 0
            while j < component.len():
                visited = visited.set(component.get(j), true)
                j = j + 1
        i = i + 1

    components

# Check if graph is connected (for undirected graphs)
fn graph_is_connected(graph: tuple) -> bool:
    var num_vertices = graph.2
    if num_vertices == 0:
        return true

    var visited = graph_dfs(graph, 0)
    visited.len() == num_vertices

# Strongly connected components using Kosaraju's algorithm (for directed graphs)
# Returns list of SCCs (each SCC is a list of vertices)
fn graph_strongly_connected_components(graph: tuple) -> list:
    var num_vertices = graph.2

    # First DFS to get finish times
    var visited = {}
    var stack = []

    var i = 0
    while i < num_vertices:
        var is_visited = visited.get(i)
        if is_visited == nil:
            var orders = graph_dfs_with_order(graph, i)
            var post_order = orders.1
            var j = 0
            while j < post_order.len():
                var vertex = post_order.get(j)
                var already_visited = visited.get(vertex)
                if already_visited == nil:
                    stack = stack.append(vertex)
                    visited = visited.set(vertex, true)
                j = j + 1
        i = i + 1

    # Reverse the graph
    var reversed_graph = graph_reverse(graph)

    # Second DFS on reversed graph in stack order
    var visited2 = {}
    var sccs = []

    var k = stack.len() - 1
    while k >= 0:
        var vertex = stack.get(k)
        var is_visited2 = visited2.get(vertex)
        if is_visited2 == nil:
            var scc = graph_dfs(reversed_graph, vertex)
            sccs = sccs.append(scc)
            var m = 0
            while m < scc.len():
                visited2 = visited2.set(scc.get(m), true)
                m = m + 1
        k = k - 1

    sccs

# Reverse a directed graph
fn graph_reverse(graph: tuple) -> tuple:
    var directed = graph.0
    var weighted = graph.1
    var num_vertices = graph.2
    var edges = graph.3

    var reversed = graph_with_vertices(directed, weighted, num_vertices)

    var i = 0
    while i < edges.len():
        var edge = edges.get(i)
        var from = edge.0
        var to = edge.1
        var weight = edge.2
        reversed = graph_add_edge(reversed, to, from, weight)
        i = i + 1

    reversed

export *
