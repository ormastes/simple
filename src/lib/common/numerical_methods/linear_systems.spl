# Linear System Solvers
#
# Purpose: Methods for solving systems of linear equations Ax = b
#
# Contains:
# - Direct methods (Gaussian elimination, LU decomposition)
# - Iterative methods (Jacobi, Gauss-Seidel)
# - Triangular system solvers (forward/backward substitution)
# - Matrix factorizations (Cholesky, QR)
# - Matrix norms (vector/matrix, various p-norms)

# ============================================================================
# Direct Solvers
# ============================================================================

fn nm_gauss_elimination(a: [[f64]], b: [f64]) -> [f64]:
    """Solve linear system Ax = b using Gaussian elimination.

    Forward elimination followed by back substitution.
    Returns empty array if system is singular.

    Example:
        nm_gauss_elimination([[2.0, 1.0], [1.0, 3.0]], [5.0, 6.0])
    """
    val n = a.len()
    if n == 0 or b.len() != n:
        return []

    val NM_EPSILON = 1e-14

    var aug = []
    var i = 0
    while i < n:
        var row = []
        var j = 0
        while j < n:
            row.push(a[i][j])
            j = j + 1
        row.push(b[i])
        aug.push(row)
        i = i + 1

    i = 0
    while i < n:
        var max_row = i
        var j = i + 1
        while j < n:
            var abs_max = aug[max_row][i]
            if abs_max < 0.0:
                abs_max = -abs_max
            var abs_curr = aug[j][i]
            if abs_curr < 0.0:
                abs_curr = -abs_curr
            if abs_curr > abs_max:
                max_row = j
            j = j + 1

        if max_row != i:
            val temp_row = aug[i]
            aug[i] = aug[max_row]
            aug[max_row] = temp_row

        val pivot = aug[i][i]
        var abs_pivot = pivot
        if abs_pivot < 0.0:
            abs_pivot = -abs_pivot
        if abs_pivot < NM_EPSILON:
            return []

        j = i + 1
        while j < n:
            val factor = aug[j][i] / pivot
            var k = i
            while k <= n:
                aug[j][k] = aug[j][k] - factor * aug[i][k]
                k = k + 1
            j = j + 1

        i = i + 1

    var x = []
    i = 0
    while i < n:
        x.push(0.0)
        i = i + 1

    i = n - 1
    while i >= 0:
        var sum = aug[i][n]
        var j = i + 1
        while j < n:
            sum = sum - aug[i][j] * x[j]
            j = j + 1
        x[i] = sum / aug[i][i]
        i = i - 1

    x

fn nm_lu_decomposition(a: [[f64]]) -> [[f64]]:
    """Perform LU decomposition of matrix A.

    Returns combined L and U matrix (L below diagonal, U on and above).
    Returns empty if decomposition fails.

    Example:
        nm_lu_decomposition([[4.0, 3.0], [6.0, 3.0]])
    """
    val n = a.len()
    if n == 0:
        return []

    val NM_EPSILON = 1e-14

    var lu = []
    var i = 0
    while i < n:
        var row = []
        var j = 0
        while j < n:
            row.push(a[i][j])
            j = j + 1
        lu.push(row)
        i = i + 1

    var k = 0
    while k < n:
        var abs_pivot = lu[k][k]
        if abs_pivot < 0.0:
            abs_pivot = -abs_pivot
        if abs_pivot < NM_EPSILON:
            return []

        i = k + 1
        while i < n:
            lu[i][k] = lu[i][k] / lu[k][k]
            var j = k + 1
            while j < n:
                lu[i][j] = lu[i][j] - lu[i][k] * lu[k][j]
                j = j + 1
            i = i + 1

        k = k + 1

    lu

# ============================================================================
# Iterative Solvers
# ============================================================================

fn nm_jacobi_iteration(a: [[f64]], b: [f64], x0: [f64], tolerance: f64, max_iter: i64) -> [f64]:
    """Solve linear system using Jacobi iteration.

    Iterative method for diagonally dominant matrices.
    Converges slowly but simple and parallelizable.

    Example:
        nm_jacobi_iteration([[4.0, 1.0], [1.0, 3.0]], [5.0, 6.0], [0.0, 0.0], 1e-6, 100)
    """
    val n = a.len()
    if n == 0 or b.len() != n or x0.len() != n:
        return []

    # Local convergence check
    fn nm_is_converged_local(current: f64, previous: f64, tol: f64) -> bool:
        var diff = current - previous
        if diff < 0.0:
            diff = -diff
        diff < tol

    var x = []
    var i = 0
    while i < n:
        x.push(x0[i])
        i = i + 1

    var iterations = 0

    while iterations < max_iter:
        var x_new = []
        i = 0
        while i < n:
            x_new.push(0.0)
            i = i + 1

        i = 0
        while i < n:
            var sum = b[i]
            var j = 0
            while j < n:
                if i != j:
                    sum = sum - a[i][j] * x[j]
                j = j + 1
            x_new[i] = sum / a[i][i]
            i = i + 1

        var converged = true
        i = 0
        while i < n:
            if not nm_is_converged_local(x_new[i], x[i], tolerance):
                converged = false
            i = i + 1

        x = x_new

        if converged:
            return x

        iterations = iterations + 1

    x

fn nm_gauss_seidel(a: [[f64]], b: [f64], x0: [f64], tolerance: f64, max_iter: i64) -> [f64]:
    """Solve linear system using Gauss-Seidel iteration.

    Iterative method using most recent values.
    Typically converges faster than Jacobi.

    Example:
        nm_gauss_seidel([[4.0, 1.0], [1.0, 3.0]], [5.0, 6.0], [0.0, 0.0], 1e-6, 100)
    """
    val n = a.len()
    if n == 0 or b.len() != n or x0.len() != n:
        return []

    # Local convergence check
    fn nm_is_converged_local(current: f64, previous: f64, tol: f64) -> bool:
        var diff = current - previous
        if diff < 0.0:
            diff = -diff
        diff < tol

    var x = []
    var i = 0
    while i < n:
        x.push(x0[i])
        i = i + 1

    var iterations = 0

    while iterations < max_iter:
        var x_old = []
        i = 0
        while i < n:
            x_old.push(x[i])
            i = i + 1

        i = 0
        while i < n:
            var sum = b[i]
            var j = 0
            while j < n:
                if i != j:
                    sum = sum - a[i][j] * x[j]
                j = j + 1
            x[i] = sum / a[i][i]
            i = i + 1

        var converged = true
        i = 0
        while i < n:
            if not nm_is_converged_local(x[i], x_old[i], tolerance):
                converged = false
            i = i + 1

        if converged:
            return x

        iterations = iterations + 1

    x

# ============================================================================
# Triangular System Solvers
# ============================================================================

fn nm_forward_substitution(L: [[f64]], b: [f64]) -> [f64]:
    """Solve lower triangular system Lx = b.

    Used in LU decomposition.

    Example:
        nm_forward_substitution([[2.0, 0.0], [3.0, 1.0]], [4.0, 5.0])
    """
    val n = L.len()
    if n == 0 or b.len() != n:
        return []

    var x = []
    var i = 0
    while i < n:
        x.push(0.0)
        i = i + 1

    i = 0
    while i < n:
        var sum = b[i]
        var j = 0
        while j < i:
            sum = sum - L[i][j] * x[j]
            j = j + 1
        x[i] = sum / L[i][i]
        i = i + 1

    x

fn nm_backward_substitution(U: [[f64]], b: [f64]) -> [f64]:
    """Solve upper triangular system Ux = b.

    Used in LU decomposition and Gaussian elimination.

    Example:
        nm_backward_substitution([[1.0, 2.0], [0.0, 3.0]], [5.0, 6.0])
    """
    val n = U.len()
    if n == 0 or b.len() != n:
        return []

    var x = []
    var i = 0
    while i < n:
        x.push(0.0)
        i = i + 1

    i = n - 1
    while i >= 0:
        var sum = b[i]
        var j = i + 1
        while j < n:
            sum = sum - U[i][j] * x[j]
            j = j + 1
        x[i] = sum / U[i][i]
        i = i - 1

    x

# ============================================================================
# Matrix Factorizations
# ============================================================================

fn nm_cholesky_decomposition(a: [[f64]]) -> [[f64]]:
    """Perform Cholesky decomposition A = L L^T.

    Only works for symmetric positive-definite matrices.
    Returns empty if matrix is not positive-definite.

    Example:
        nm_cholesky_decomposition([[4.0, 2.0], [2.0, 3.0]])
    """
    val n = a.len()
    if n == 0:
        return []

    val NM_SQRT_EPSILON = 1e-7

    # Local sqrt function
    fn nm_sqrt_newton_local(x: f64, tol: f64) -> f64:
        if x < 0.0:
            return 0.0
        if x == 0.0:
            return 0.0

        var y = x / 2.0
        var iter = 0

        while iter < 100:
            val y_new = (y + x / y) / 2.0
            var diff = y_new - y
            if diff < 0.0:
                diff = -diff
            if diff < tol:
                return y_new
            y = y_new
            iter = iter + 1

        y

    var L = []
    var i = 0
    while i < n:
        var row = []
        var j = 0
        while j < n:
            row.push(0.0)
            j = j + 1
        L.push(row)
        i = i + 1

    i = 0
    while i < n:
        var j = 0
        while j <= i:
            var sum = 0.0
            var k = 0
            while k < j:
                sum = sum + L[i][k] * L[j][k]
                k = k + 1

            if i == j:
                val value = a[i][i] - sum
                if value <= 0.0:
                    return []
                L[i][j] = nm_sqrt_newton_local(value, NM_SQRT_EPSILON)
            else:
                if L[j][j] == 0.0:
                    return []
                L[i][j] = (a[i][j] - sum) / L[j][j]

            j = j + 1
        i = i + 1

    L

fn nm_qr_gram_schmidt(a: [[f64]]) -> [[f64]]:
    """Perform QR decomposition using Gram-Schmidt.

    Returns combined Q and R in single matrix structure.
    Q is orthogonal, R is upper triangular.

    Example:
        nm_qr_gram_schmidt([[1.0, 1.0], [1.0, 0.0], [0.0, 1.0]])
    """
    val m = a.len()
    if m == 0:
        return []
    val n = a[0].len()

    val NM_EPSILON = 1e-14
    val NM_SQRT_EPSILON = 1e-7

    # Local sqrt function
    fn nm_sqrt_newton_local(x: f64, tol: f64) -> f64:
        if x < 0.0:
            return 0.0
        if x == 0.0:
            return 0.0

        var y = x / 2.0
        var iter = 0

        while iter < 100:
            val y_new = (y + x / y) / 2.0
            var diff = y_new - y
            if diff < 0.0:
                diff = -diff
            if diff < tol:
                return y_new
            y = y_new
            iter = iter + 1

        y

    var Q = []
    var i = 0
    while i < m:
        var row = []
        var j = 0
        while j < n:
            row.push(a[i][j])
            j = j + 1
        Q.push(row)
        i = i + 1

    var R = []
    i = 0
    while i < n:
        var row = []
        var j = 0
        while j < n:
            row.push(0.0)
            j = j + 1
        R.push(row)
        i = i + 1

    var col = 0
    while col < n:
        var k = 0
        while k < col:
            var dot = 0.0
            var row = 0
            while row < m:
                dot = dot + Q[row][col] * Q[row][k]
                row = row + 1
            R[k][col] = dot

            row = 0
            while row < m:
                Q[row][col] = Q[row][col] - R[k][col] * Q[row][k]
                row = row + 1
            k = k + 1

        var norm = 0.0
        var row = 0
        while row < m:
            norm = norm + Q[row][col] * Q[row][col]
            row = row + 1
        norm = nm_sqrt_newton_local(norm, NM_SQRT_EPSILON)

        R[col][col] = norm

        if norm > NM_EPSILON:
            row = 0
            while row < m:
                Q[row][col] = Q[row][col] / norm
                row = row + 1

        col = col + 1

    R

export *
