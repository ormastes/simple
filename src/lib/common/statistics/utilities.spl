# statistics/utilities.spl - Basic utility functions for statistical computations

import math from "std/math"
import types from "./types"

# ============================================================================
# BASIC UTILITIES
# ============================================================================

fn sum(data: List<f64>) -> f64:
    """Calculate the sum of all values in the array."""
    if data.length() == 0:
        return 0.0

    var total = 0.0
    for val in data:
        total = total + val
    total

fn product(data: List<f64>) -> f64:
    """Calculate the product of all values in the array."""
    if data.length() == 0:
        return 1.0

    var prod = 1.0
    for val in data:
        prod = prod * val
    prod

fn count(data: List<f64>) -> i64:
    """Count the number of elements."""
    data.length()

fn count_non_zero(data: List<f64>) -> i64:
    """Count non-zero elements."""
    var cnt = 0
    for val in data:
        if math.abs(val) > types.EPSILON:
            cnt = cnt + 1
    cnt

fn cumsum(data: List<f64>) -> List<f64>:
    """Calculate cumulative sum."""
    var result = []
    var running_sum = 0.0

    for val in data:
        running_sum = running_sum + val
        result.push(running_sum)

    result

fn cumprod(data: List<f64>) -> List<f64>:
    """Calculate cumulative product."""
    var result = []
    var running_prod = 1.0

    for val in data:
        running_prod = running_prod * val
        result.push(running_prod)

    result

fn diff(data: List<f64>) -> List<f64>:
    """Calculate differences between consecutive elements."""
    if data.length() < 2:
        return []

    var result = []
    var i = 1
    while i < data.length():
        val d = data[i] - data[i - 1]
        result.push(d)
        i = i + 1

    result

fn pct_change(data: List<f64>) -> List<f64>:
    """Calculate percentage change between consecutive elements."""
    if data.length() < 2:
        return []

    var result = []
    var i = 1
    while i < data.length():
        if math.abs(data[i - 1]) > types.EPSILON:
            val change = (data[i] - data[i - 1]) / data[i - 1]
            result.push(change)
        else:
            result.push(0.0)
        i = i + 1

    result

fn clip(data: List<f64>, min_val: f64, max_val: f64) -> List<f64>:
    """Clip values to range [min_val, max_val]."""
    var result = []

    for val in data:
        if val < min_val:
            result.push(min_val)
        else:
            if val > max_val:
                result.push(max_val)
            else:
                result.push(val)

    result

fn interpolate_linear(x: f64, x0: f64, y0: f64, x1: f64, y1: f64) -> f64:
    """Linear interpolation between two points."""
    if math.abs(x1 - x0) < types.EPSILON:
        return y0

    y0 + (x - x0) * (y1 - y0) / (x1 - x0)

fn sample_with_replacement(data: List<f64>, size: i64, seed: i64) -> List<f64>:
    """Simple sampling with replacement (pseudo-random)."""
    var result = []
    var rng = seed

    var i = 0
    while i < size:
        rng = (rng * 1103515245 + 12345) % 2147483648
        val idx = (rng % data.length())
        result.push(data[idx])
        i = i + 1

    result

fn factorial(n: i64) -> f64:
    """Calculate factorial (returns f64 to handle large values)."""
    if n < 0:
        return 0.0

    if n == 0 or n == 1:
        return 1.0

    var result = 1.0
    var i = 2
    while i <= n:
        result = result * i
        i = i + 1

    result

fn binomial_coefficient(n: i64, k: i64) -> f64:
    """Calculate binomial coefficient C(n, k)."""
    if k < 0 or k > n:
        return 0.0

    if k == 0 or k == n:
        return 1.0

    var result = 1.0
    var i = 0
    while i < k:
        result = result * (n - i) / (i + 1)
        i = i + 1

    result

fn rank_data(data: List<f64>) -> List<f64>:
    """Assign ranks to data (average rank for ties)."""
    val n = data.length()
    if n == 0:
        return []

    var ranks = []
    var i = 0
    while i < n:
        ranks.push(0.0)
        i = i + 1

    i = 0
    while i < n:
        var rank = 1.0
        var j = 0
        while j < n:
            if data[j] < data[i]:
                rank = rank + 1.0
            j = j + 1
        ranks[i] = rank
        i = i + 1

    ranks

fn frequency_table(data: List<f64>) -> List<List<f64>>:
    """Create frequency table (returns [[value, count], ...])."""
    if data.length() == 0:
        return []

    var unique_vals = []
    var counts = []

    for val in data:
        var found = false
        var idx = 0

        var i = 0
        while i < unique_vals.length():
            if math.abs(unique_vals[i] - val) < types.EPSILON:
                found = true
                idx = i
                break
            i = i + 1

        if found:
            counts[idx] = counts[idx] + 1.0
        else:
            unique_vals.push(val)
            counts.push(1.0)

    var result = []
    var i = 0
    while i < unique_vals.length():
        result.push([unique_vals[i], counts[i]])
        i = i + 1

    result

fn histogram_bins(data: List<f64>, num_bins: i64) -> Option<List<f64>>:
    """Calculate histogram bin counts."""
    if data.length() == 0 or num_bins <= 0:
        return nil

    val min_opt = min_value(data)
    val max_opt = max_value(data)

    if min_opt == nil or max_opt == nil:
        return nil

    val min_v = min_opt
    val max_v = max_opt
    val range_v = max_v - min_v

    if range_v < types.EPSILON:
        var bins = []
        var i = 0
        while i < num_bins:
            bins.push(0.0)
            i = i + 1
        bins[0] = data.length()
        return Some(bins)

    val bin_width = range_v / num_bins

    var bins = []
    var i = 0
    while i < num_bins:
        bins.push(0.0)
        i = i + 1

    for val in data:
        var bin_idx = math.floor((val - min_v) / bin_width)
        if bin_idx >= num_bins:
            bin_idx = num_bins - 1
        bins[bin_idx] = bins[bin_idx] + 1.0

    Some(bins)

fn relative_frequency(data: List<f64>) -> List<List<f64>>:
    """Calculate relative frequency table (proportions)."""
    val freq = frequency_table(data)
    val n = data.length()

    if n == 0:
        return []

    var result = []
    for entry in freq:
        val value = entry[0]
        val count = entry[1]
        result.push([value, count / n])

    result

fn min_value(data: List<f64>) -> Option<f64>:
    """Find minimum value."""
    if data.length() == 0:
        return nil

    var min_val = data[0]
    for val in data:
        if val < min_val:
            min_val = val

    Some(min_val)

fn max_value(data: List<f64>) -> Option<f64>:
    """Find maximum value."""
    if data.length() == 0:
        return nil

    var max_val = data[0]
    for val in data:
        if val > max_val:
            max_val = val

    Some(max_val)

fn entropy(probabilities: List<f64>) -> Option<f64>:
    """Calculate Shannon entropy."""
    if probabilities.length() == 0:
        return nil

    var ent = 0.0
    for p in probabilities:
        if p < 0.0 or p > 1.0:
            return nil
        if p > types.EPSILON:
            ent = ent - (p * math.log(p) / math.log(2.0))

    Some(ent)

fn gini_impurity(probabilities: List<f64>) -> Option<f64>:
    """Calculate Gini impurity."""
    if probabilities.length() == 0:
        return nil

    var gini = 1.0
    for p in probabilities:
        if p < 0.0 or p > 1.0:
            return nil
        gini = gini - (p * p)

    Some(gini)

fn mean_squared_error(actual: List<f64>, predicted: List<f64>) -> Option<f64>:
    """Calculate mean squared error."""
    if actual.length() != predicted.length() or actual.length() == 0:
        return nil

    var sum_sq = 0.0
    var i = 0
    while i < actual.length():
        val err = actual[i] - predicted[i]
        sum_sq = sum_sq + (err * err)
        i = i + 1

    Some(sum_sq / actual.length())

fn root_mean_squared_error(actual: List<f64>, predicted: List<f64>) -> Option<f64>:
    """Calculate root mean squared error."""
    val mse_opt = mean_squared_error(actual, predicted)
    if mse_opt == nil:
        return nil

    Some(math.sqrt(mse_opt))

fn mean_absolute_error(actual: List<f64>, predicted: List<f64>) -> Option<f64>:
    """Calculate mean absolute error."""
    if actual.length() != predicted.length() or actual.length() == 0:
        return nil

    var sum_abs = 0.0
    var i = 0
    while i < actual.length():
        sum_abs = sum_abs + math.abs(actual[i] - predicted[i])
        i = i + 1

    Some(sum_abs / actual.length())

fn mean_absolute_percentage_error(actual: List<f64>, predicted: List<f64>) -> Option<f64>:
    """Calculate mean absolute percentage error."""
    if actual.length() != predicted.length() or actual.length() == 0:
        return nil

    var sum_pct = 0.0
    var i = 0
    while i < actual.length():
        if math.abs(actual[i]) < types.EPSILON:
            return nil
        sum_pct = sum_pct + math.abs((actual[i] - predicted[i]) / actual[i])
        i = i + 1

    Some(100.0 * sum_pct / actual.length())
