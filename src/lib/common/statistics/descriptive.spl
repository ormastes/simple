# statistics/descriptive.spl - Descriptive statistics functions

import math from "std/math"
import array from "std/array"
import types from "./types"
import utilities from "./utilities"

# ============================================================================
# DESCRIPTIVE STATISTICS
# ============================================================================

fn mean(data: List<f64>) -> Option<f64>:
    """Calculate arithmetic mean (average)."""
    if data.length() == 0:
        return nil

    val total = utilities.sum(data)
    val n = data.length()
    Some(total / n)

fn geometric_mean(data: List<f64>) -> Option<f64>:
    """Calculate geometric mean."""
    if data.length() == 0:
        return nil

    var log_sum = 0.0
    for val in data:
        if val <= 0.0:
            return nil
        log_sum = log_sum + math.log(val)

    val result = math.exp(log_sum / data.length())
    Some(result)

fn harmonic_mean(data: List<f64>) -> Option<f64>:
    """Calculate harmonic mean."""
    if data.length() == 0:
        return nil

    var recip_sum = 0.0
    for val in data:
        if math.abs(val) < types.EPSILON:
            return nil
        recip_sum = recip_sum + (1.0 / val)

    val result = data.length() / recip_sum
    Some(result)

fn median(data: List<f64>) -> Option<f64>:
    """Calculate median (50th percentile)."""
    if data.length() == 0:
        return nil

    val sorted = array.sort(data)
    val n = sorted.length()
    val mid = n / 2

    if n % 2 == 0:
        val result = (sorted[mid - 1] + sorted[mid]) / 2.0
        Some(result)
    else:
        Some(sorted[mid])

fn mode(data: List<f64>) -> Option<f64>:
    """Calculate mode (most frequent value)."""
    if data.length() == 0:
        return nil

    var freq_map = {}
    var max_freq = 0
    var mode_val = data[0]

    for val in data:
        val key = val
        var current_freq = 0

        for v in data:
            if math.abs(v - key) < types.EPSILON:
                current_freq = current_freq + 1

        if current_freq > max_freq:
            max_freq = current_freq
            mode_val = val

    Some(mode_val)

fn range_value(data: List<f64>) -> Option<f64>:
    """Calculate range (max - min)."""
    if data.length() == 0:
        return nil

    val min_opt = utilities.min_value(data)
    val max_opt = utilities.max_value(data)

    if min_opt and max_opt:
        Some(max_opt - min_opt)
    else:
        nil

fn quantile(data: List<f64>, q: f64) -> Option<f64>:
    """Calculate quantile (0.0 to 1.0)."""
    if data.length() == 0:
        return nil

    if q < 0.0 or q > 1.0:
        return nil

    val sorted = array.sort(data)
    val n = sorted.length()
    val pos = q * (n - 1)
    val lower = math.floor(pos)
    val upper = math.ceil(pos)

    if lower == upper:
        return Some(sorted[lower])

    val weight = pos - lower
    val result = sorted[lower] * (1.0 - weight) + sorted[upper] * weight
    Some(result)

fn percentile(data: List<f64>, p: f64) -> Option<f64>:
    """Calculate percentile (0 to 100)."""
    quantile(data, p / 100.0)

fn quartile_1(data: List<f64>) -> Option<f64>:
    """Calculate first quartile (Q1, 25th percentile)."""
    quantile(data, 0.25)

fn quartile_2(data: List<f64>) -> Option<f64>:
    """Calculate second quartile (Q2, 50th percentile, median)."""
    median(data)

fn quartile_3(data: List<f64>) -> Option<f64>:
    """Calculate third quartile (Q3, 75th percentile)."""
    quantile(data, 0.75)

fn iqr(data: List<f64>) -> Option<f64>:
    """Calculate interquartile range (Q3 - Q1)."""
    val q1 = quartile_1(data)
    val q3 = quartile_3(data)

    if q1 and q3:
        Some(q3 - q1)
    else:
        nil

fn variance(data: List<f64>) -> Option<f64>:
    """Calculate population variance."""
    if data.length() == 0:
        return nil

    val mean_opt = mean(data)
    if mean_opt == nil:
        return nil

    val m = mean_opt
    var sum_sq = 0.0

    for val in data:
        val diff_val = val - m
        sum_sq = sum_sq + (diff_val * diff_val)

    Some(sum_sq / data.length())

fn variance_sample(data: List<f64>) -> Option<f64>:
    """Calculate sample variance (Bessel's correction)."""
    if data.length() < 2:
        return nil

    val mean_opt = mean(data)
    if mean_opt == nil:
        return nil

    val m = mean_opt
    var sum_sq = 0.0

    for val in data:
        val diff_val = val - m
        sum_sq = sum_sq + (diff_val * diff_val)

    Some(sum_sq / (data.length() - 1))

fn stddev(data: List<f64>) -> Option<f64>:
    """Calculate population standard deviation."""
    val var_opt = variance(data)
    if var_opt == nil:
        return nil

    Some(math.sqrt(var_opt))

fn stddev_sample(data: List<f64>) -> Option<f64>:
    """Calculate sample standard deviation."""
    val var_opt = variance_sample(data)
    if var_opt == nil:
        return nil

    Some(math.sqrt(var_opt))

fn mad(data: List<f64>) -> Option<f64>:
    """Calculate mean absolute deviation."""
    if data.length() == 0:
        return nil

    val mean_opt = mean(data)
    if mean_opt == nil:
        return nil

    val m = mean_opt
    var sum_abs = 0.0

    for val in data:
        sum_abs = sum_abs + math.abs(val - m)

    Some(sum_abs / data.length())

fn median_absolute_deviation(data: List<f64>) -> Option<f64>:
    """Calculate median absolute deviation (MAD)."""
    if data.length() == 0:
        return nil

    val med_opt = median(data)
    if med_opt == nil:
        return nil

    val m = med_opt
    var deviations = []

    for val in data:
        deviations.push(math.abs(val - m))

    median(deviations)

fn coefficient_of_variation(data: List<f64>) -> Option<f64>:
    """Calculate coefficient of variation (CV = stddev / mean)."""
    val mean_opt = mean(data)
    val std_opt = stddev(data)

    if mean_opt == nil or std_opt == nil:
        return nil

    if math.abs(mean_opt) < types.EPSILON:
        return nil

    Some(std_opt / math.abs(mean_opt))

fn standard_error(data: List<f64>) -> Option<f64>:
    """Calculate standard error of the mean."""
    val std_opt = stddev_sample(data)
    if std_opt == nil:
        return nil

    val n = data.length()
    if n == 0:
        return nil

    Some(std_opt / math.sqrt(n))

fn skewness(data: List<f64>) -> Option<f64>:
    """Calculate skewness (Fisher-Pearson coefficient)."""
    if data.length() < 3:
        return nil

    val mean_opt = mean(data)
    val std_opt = stddev(data)

    if mean_opt == nil or std_opt == nil:
        return nil

    if std_opt < types.EPSILON:
        return nil

    val m = mean_opt
    val s = std_opt
    var sum_cubed = 0.0

    for val in data:
        val z = (val - m) / s
        sum_cubed = sum_cubed + (z * z * z)

    Some(sum_cubed / data.length())

fn kurtosis(data: List<f64>) -> Option<f64>:
    """Calculate excess kurtosis."""
    if data.length() < 4:
        return nil

    val mean_opt = mean(data)
    val std_opt = stddev(data)

    if mean_opt == nil or std_opt == nil:
        return nil

    if std_opt < types.EPSILON:
        return nil

    val m = mean_opt
    val s = std_opt
    var sum_fourth = 0.0

    for val in data:
        val z = (val - m) / s
        sum_fourth = sum_fourth + (z * z * z * z)

    val kurt = sum_fourth / data.length()
    Some(kurt - 3.0)

fn trimmed_mean(data: List<f64>, trim_pct: f64) -> Option<f64>:
    """Calculate trimmed mean (removing percentage from both ends)."""
    if data.length() == 0:
        return nil

    if trim_pct < 0.0 or trim_pct >= 50.0:
        return nil

    val sorted = array.sort(data)
    val n = sorted.length()
    val trim_count = math.floor(n * trim_pct / 100.0)

    var sum_val = 0.0
    var count_val = 0

    var i = trim_count
    while i < n - trim_count:
        sum_val = sum_val + sorted[i]
        count_val = count_val + 1
        i = i + 1

    if count_val == 0:
        return nil

    Some(sum_val / count_val)

fn moment(data: List<f64>, order: i64) -> Option<f64>:
    """Calculate n-th moment about the mean."""
    if data.length() == 0 or order < 1:
        return nil

    val mean_opt = mean(data)
    if mean_opt == nil:
        return nil

    val m = mean_opt
    var sum_val = 0.0

    for val in data:
        sum_val = sum_val + math.pow(val - m, order)

    Some(sum_val / data.length())

fn weighted_mean(values: List<f64>, weights: List<f64>) -> Option<f64>:
    """Calculate weighted mean."""
    if values.length() != weights.length() or values.length() == 0:
        return nil

    var sum_val = 0.0
    var sum_weight = 0.0

    var i = 0
    while i < values.length():
        sum_val = sum_val + values[i] * weights[i]
        sum_weight = sum_weight + weights[i]
        i = i + 1

    if math.abs(sum_weight) < types.EPSILON:
        return nil

    Some(sum_val / sum_weight)

fn weighted_variance(values: List<f64>, weights: List<f64>) -> Option<f64>:
    """Calculate weighted variance."""
    val wmean_opt = weighted_mean(values, weights)
    if wmean_opt == nil:
        return nil

    val wm = wmean_opt

    var sum_sq = 0.0
    var sum_weight = 0.0

    var i = 0
    while i < values.length():
        val diff_val = values[i] - wm
        sum_sq = sum_sq + weights[i] * diff_val * diff_val
        sum_weight = sum_weight + weights[i]
        i = i + 1

    if math.abs(sum_weight) < types.EPSILON:
        return nil

    Some(sum_sq / sum_weight)

fn winsorize(data: List<f64>, lower_pct: f64, upper_pct: f64) -> Option<List<f64>>:
    """Winsorize data by replacing extreme values with percentiles."""
    if lower_pct < 0.0 or upper_pct > 100.0 or lower_pct >= upper_pct:
        return nil

    val lower_val_opt = percentile(data, lower_pct)
    val upper_val_opt = percentile(data, upper_pct)

    if lower_val_opt == nil or upper_val_opt == nil:
        return nil

    val result = utilities.clip(data, lower_val_opt, upper_val_opt)
    Some(result)

fn remove_outliers(data: List<f64>, num_stddev: f64) -> Option<List<f64>>:
    """Remove outliers beyond num_stddev standard deviations from mean."""
    val mean_opt = mean(data)
    val std_opt = stddev(data)

    if mean_opt == nil or std_opt == nil:
        return nil

    val m = mean_opt
    val s = std_opt
    val threshold = num_stddev * s

    var result = []
    for val in data:
        if math.abs(val - m) <= threshold:
            result.push(val)

    Some(result)

fn detect_outliers_iqr(data: List<f64>, multiplier: f64) -> Option<List<bool>>:
    """Detect outliers using IQR method (returns boolean mask)."""
    val q1_opt = quartile_1(data)
    val q3_opt = quartile_3(data)

    if q1_opt == nil or q3_opt == nil:
        return nil

    val q1 = q1_opt
    val q3 = q3_opt
    val iqr_val = q3 - q1
    val lower = q1 - multiplier * iqr_val
    val upper = q3 + multiplier * iqr_val

    var result = []
    for val in data:
        val is_outlier = val < lower or val > upper
        result.push(is_outlier)

    Some(result)

fn expanding_mean(data: List<f64>) -> Option<List<f64>>:
    """Calculate expanding (cumulative) mean."""
    if data.length() == 0:
        return nil

    var result = []
    var sum_val = 0.0

    var i = 0
    while i < data.length():
        sum_val = sum_val + data[i]
        result.push(sum_val / (i + 1))
        i = i + 1

    Some(result)

fn expanding_stddev(data: List<f64>) -> Option<List<f64>>:
    """Calculate expanding standard deviation."""
    if data.length() < 2:
        return nil

    var result = []

    var i = 2
    while i <= data.length():
        var window = []
        var j = 0
        while j < i:
            window.push(data[j])
            j = j + 1

        val std_opt = stddev(window)
        if std_opt == nil:
            return nil

        result.push(std_opt)
        i = i + 1

    Some(result)

fn moving_average(data: List<f64>, window: i64) -> Option<List<f64>>:
    """Calculate simple moving average."""
    if window <= 0 or window > data.length():
        return nil

    var result = []
    var i = 0

    while i <= data.length() - window:
        var sum_val = 0.0
        var j = 0
        while j < window:
            sum_val = sum_val + data[i + j]
            j = j + 1

        result.push(sum_val / window)
        i = i + 1

    Some(result)

fn exponential_moving_average(data: List<f64>, alpha: f64) -> Option<List<f64>>:
    """Calculate exponential moving average."""
    if alpha <= 0.0 or alpha > 1.0:
        return nil

    if data.length() == 0:
        return nil

    var result = []
    var ema = data[0]
    result.push(ema)

    var i = 1
    while i < data.length():
        ema = alpha * data[i] + (1.0 - alpha) * ema
        result.push(ema)
        i = i + 1

    Some(result)

fn weighted_moving_average(data: List<f64>, weights: List<f64>) -> Option<List<f64>>:
    """Calculate weighted moving average."""
    if weights.length() == 0 or weights.length() > data.length():
        return nil

    val weight_sum = utilities.sum(weights)
    if math.abs(weight_sum) < types.EPSILON:
        return nil

    val window = weights.length()
    var result = []
    var i = 0

    while i <= data.length() - window:
        var weighted_sum = 0.0
        var j = 0
        while j < window:
            weighted_sum = weighted_sum + data[i + j] * weights[j]
            j = j + 1

        result.push(weighted_sum / weight_sum)
        i = i + 1

    Some(result)

fn moving_stddev(data: List<f64>, window: i64) -> Option<List<f64>>:
    """Calculate moving standard deviation."""
    if window <= 0 or window > data.length():
        return nil

    var result = []
    var i = 0

    while i <= data.length() - window:
        var window_data = []
        var j = 0
        while j < window:
            window_data.push(data[i + j])
            j = j + 1

        val std_opt = stddev(window_data)
        if std_opt == nil:
            return nil

        result.push(std_opt)
        i = i + 1

    Some(result)

fn moving_min(data: List<f64>, window: i64) -> Option<List<f64>>:
    """Calculate moving minimum."""
    if window <= 0 or window > data.length():
        return nil

    var result = []
    var i = 0

    while i <= data.length() - window:
        var min_val = data[i]
        var j = 1
        while j < window:
            if data[i + j] < min_val:
                min_val = data[i + j]
            j = j + 1

        result.push(min_val)
        i = i + 1

    Some(result)

fn moving_max(data: List<f64>, window: i64) -> Option<List<f64>>:
    """Calculate moving maximum."""
    if window <= 0 or window > data.length():
        return nil

    var result = []
    var i = 0

    while i <= data.length() - window:
        var max_val = data[i]
        var j = 1
        while j < window:
            if data[i + j] > max_val:
                max_val = data[i + j]
            j = j + 1

        result.push(max_val)
        i = i + 1

    Some(result)

fn rolling_sum(data: List<f64>, window: i64) -> Option<List<f64>>:
    """Calculate rolling sum."""
    if window <= 0 or window > data.length():
        return nil

    var result = []
    var i = 0

    while i <= data.length() - window:
        var sum_val = 0.0
        var j = 0
        while j < window:
            sum_val = sum_val + data[i + j]
            j = j + 1
        result.push(sum_val)
        i = i + 1

    Some(result)
