# Standard Library — Computation Expression Builder Protocol
#
# @tag:api
# @tag:stdlib
# @tag:experimental
#
# Base protocol for computation expression (CE) builders.
# Inspired by F# computation expressions.
#
# A CE builder implements:
#   - NAME_ce_bind(value, continuation) → chains monadic value into continuation
#   - NAME_ce_return(value)             → lifts a value into the CE context
#   - NAME_ce_zero()                    → empty/failed value for this CE
#   - NAME_ce_yield(value)              → yield for sequence CEs (optional)
#
# Usage pattern (desugared by compiler from `ce result:` blocks):
#   ce result:
#       bind x = fetch()    →  result_ce_bind(fetch(), fn(x): ...)
#       bind y = compute(x) →  result_ce_bind(compute(x), fn(y): ...)
#       Ok(y)               →  result_ce_return(Ok(y))
#
# Available builders:
#   result_ce  — short-circuit on nil (error propagation)
#   option_ce  — short-circuit on nil (None propagation)
#   seq_ce     — collect values via yield

# CE builder name constants (used by compiler desugaring)
val CE_BUILDER_RESULT = "result_ce"   # Result monad
val CE_BUILDER_OPTION = "option_ce"   # Option monad
val CE_BUILDER_SEQ = "seq_ce"         # Sequence / generator

# Validate that a named CE builder is registered.
# Returns true if the builder name is known.
fn ce_builder_known(name: text) -> bool:
    if name == CE_BUILDER_RESULT: return true
    if name == CE_BUILDER_OPTION: return true
    if name == CE_BUILDER_SEQ: return true
    false

# Get the bind function name for a given builder.
fn ce_bind_fn_name(builder: text) -> text:
    "{builder}_bind"

# Get the return function name for a given builder.
fn ce_return_fn_name(builder: text) -> text:
    "{builder}_return"

# Get the zero function name for a given builder.
fn ce_zero_fn_name(builder: text) -> text:
    "{builder}_zero"

export CE_BUILDER_RESULT, CE_BUILDER_OPTION, CE_BUILDER_SEQ
export ce_builder_known, ce_bind_fn_name, ce_return_fn_name, ce_zero_fn_name
