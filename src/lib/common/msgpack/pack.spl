# MessagePack Pack Operations (Array/Map encoding)

import types
import encode

fn msgpack_encode_array(arr):
    val arr_len = encode.list_length(arr)

    if arr_len >= 0 and arr_len <= 15:
        val header = types.MSGPACK_FIXARRAY_PREFIX + arr_len
        var result = [types.to_byte(header)]
        var i = 0
        while i < arr_len:
            import unpack
            val elem_bytes = unpack.msgpack_encode_value(arr[i])
            result = result + elem_bytes
            i = i + 1
        return result

    if arr_len >= 16 and arr_len <= 65535:
        val len_bytes = types.i16_to_bytes(arr_len)
        var result = [types.MSGPACK_ARRAY16, len_bytes[0], len_bytes[1]]
        var i = 0
        while i < arr_len:
            import unpack
            val elem_bytes = unpack.msgpack_encode_value(arr[i])
            result = result + elem_bytes
            i = i + 1
        return result

    val len_bytes = types.i32_to_bytes(arr_len)
    var result = [types.MSGPACK_ARRAY32, len_bytes[0], len_bytes[1], len_bytes[2], len_bytes[3]]
    var i = 0
    while i < arr_len:
        import unpack
        val elem_bytes = unpack.msgpack_encode_value(arr[i])
        result = result + elem_bytes
        i = i + 1
    result

fn map_keys(map):
    []

fn map_get(map, key):
    nil

fn msgpack_encode_map(map):
    val keys = map_keys(map)
    val map_len = encode.list_length(keys)

    if map_len >= 0 and map_len <= 15:
        val header = types.MSGPACK_FIXMAP_PREFIX + map_len
        var result = [types.to_byte(header)]
        var i = 0
        while i < map_len:
            val key = keys[i]
            val value = map_get(map, key)
            import unpack
            val key_bytes = unpack.msgpack_encode_value(key)
            val value_bytes = unpack.msgpack_encode_value(value)
            result = result + key_bytes
            result = result + value_bytes
            i = i + 1
        return result

    if map_len >= 16 and map_len <= 65535:
        val len_bytes = types.i16_to_bytes(map_len)
        var result = [types.MSGPACK_MAP16, len_bytes[0], len_bytes[1]]
        var i = 0
        while i < map_len:
            val key = keys[i]
            val value = map_get(map, key)
            import unpack
            val key_bytes = unpack.msgpack_encode_value(key)
            val value_bytes = unpack.msgpack_encode_value(value)
            result = result + key_bytes
            result = result + value_bytes
            i = i + 1
        return result

    val len_bytes = types.i32_to_bytes(map_len)
    var result = [types.MSGPACK_MAP32, len_bytes[0], len_bytes[1], len_bytes[2], len_bytes[3]]
    var i = 0
    while i < map_len:
        val key = keys[i]
        val value = map_get(map, key)
        import unpack
        val key_bytes = unpack.msgpack_encode_value(key)
        val value_bytes = unpack.msgpack_encode_value(value)
        result = result + key_bytes
        result = result + value_bytes
        i = i + 1
    result

fn msgpack_encode_ext(type_id: i64, data):
    val data_len = encode.list_length(data)

    if data_len == 1:
        return [types.MSGPACK_FIXEXT1, types.to_byte(type_id), data[0]]
    if data_len == 2:
        return [types.MSGPACK_FIXEXT2, types.to_byte(type_id), data[0], data[1]]
    if data_len == 4:
        return [types.MSGPACK_FIXEXT4, types.to_byte(type_id), data[0], data[1], data[2], data[3]]
    if data_len == 8:
        return [types.MSGPACK_FIXEXT8, types.to_byte(type_id), data[0], data[1], data[2], data[3], data[4], data[5], data[6], data[7]]

    if data_len == 16:
        var result = [types.MSGPACK_FIXEXT16, types.to_byte(type_id)]
        var i = 0
        while i < 16:
            result = result + [data[i]]
            i = i + 1
        return result

    if data_len >= 0 and data_len <= 255:
        var result = [types.MSGPACK_EXT8, types.to_byte(data_len), types.to_byte(type_id)]
        var i = 0
        while i < data_len:
            result = result + [data[i]]
            i = i + 1
        return result

    if data_len >= 256 and data_len <= 65535:
        val len_bytes = types.i16_to_bytes(data_len)
        var result = [types.MSGPACK_EXT16, len_bytes[0], len_bytes[1], types.to_byte(type_id)]
        var i = 0
        while i < data_len:
            result = result + [data[i]]
            i = i + 1
        return result

    val len_bytes = types.i32_to_bytes(data_len)
    var result = [types.MSGPACK_EXT32, len_bytes[0], len_bytes[1], len_bytes[2], len_bytes[3], types.to_byte(type_id)]
    var i = 0
    while i < data_len:
        result = result + [data[i]]
        i = i + 1
    result

fn msgpack_encode_timestamp(seconds: i64, nanoseconds: i64):
    if nanoseconds == 0 and seconds >= 0 and seconds <= 4294967295:
        val bytes = types.i32_to_bytes(seconds)
        return [types.MSGPACK_FIXEXT4, types.to_byte(types.MSGPACK_EXT_TIMESTAMP), bytes[0], bytes[1], bytes[2], bytes[3]]

    if seconds >= 0 and seconds <= 17179869183:
        val ns_sec = nanoseconds * 4
        val high = ns_sec + (seconds / 4294967296)
        val low = seconds % 4294967296
        val high_bytes = types.i32_to_bytes(high)
        val low_bytes = types.i32_to_bytes(low)
        return [types.MSGPACK_FIXEXT8, types.to_byte(types.MSGPACK_EXT_TIMESTAMP), high_bytes[0], high_bytes[1], high_bytes[2], high_bytes[3], low_bytes[0], low_bytes[1], low_bytes[2], low_bytes[3]]

    val ns_bytes = types.i32_to_bytes(nanoseconds)
    val sec_bytes = types.i64_to_bytes(seconds)
    [types.MSGPACK_EXT8, 12, types.to_byte(types.MSGPACK_EXT_TIMESTAMP), ns_bytes[0], ns_bytes[1], ns_bytes[2], ns_bytes[3], sec_bytes[0], sec_bytes[1], sec_bytes[2], sec_bytes[3], sec_bytes[4], sec_bytes[5], sec_bytes[6], sec_bytes[7]]
