# Set Utilities Module
#
# Comprehensive set data structure implementation for Simple.
# Sets are collections of unique elements with efficient membership testing.
#
# Implementation Strategy:
# - Uses dictionary-backed sets for O(1) membership testing
# - Supports conversion to/from arrays and lists
# - Pure Simple implementation - no generics at runtime
# - Works with any hashable type (strings, numbers, etc.)
#
# Categories (this file):
# - Creation: set_new, set_from_array, set_from_list
# - Basic ops: set_add, set_remove, set_contains, set_size, set_is_empty, set_clear
# - Set algebra: set_union, set_intersection, set_difference, set_symmetric_difference
# - Predicates: set_is_subset, set_is_superset, set_is_disjoint, set_equals
# - Transformations: set_map, set_filter, set_partition
# - Conversion: set_to_array, set_to_list, set_to_sorted_array
# - Multi-element: set_add_all, set_remove_all, set_retain_all
#
# Advanced/iteration/utility operations are in set_utils_advanced.spl
#
# Set representation: Dictionary where keys are elements (as strings) and values are the original elements.
# This allows O(1) lookup while preserving the original values.

# ============================================================================
# Type Helpers - Convert values to hashable keys
# ============================================================================

fn _to_key(value) -> text:
    """Convert value to string key for hashing.
    Works around runtime limitations by using string representation."""
    "{value}"

fn _from_key(key: text, original):
    """Extract original value. For simple types, use the original passed value."""
    original

# ============================================================================
# Set Creation
# ============================================================================

fn set_new():
    """Create a new empty set.

    Returns a dictionary representing the set.

    Example:
        val s = set_new()
        set_is_empty(s)  # true
    """
    {}

fn set_from_array(arr):
    """Create a set from an array, removing duplicates.

    Example:
        set_from_array([1, 2, 2, 3, 1])  # Set containing {1, 2, 3}
    """
    var s = {}
    for item in arr:
        val key = "{item}"
        s[key] = item
    s

fn set_from_list(list):
    """Create a set from a list, removing duplicates.

    Example:
        set_from_list([1, 2, 2, 3])  # Set containing {1, 2, 3}
    """
    set_from_array(list)

fn set_of(items):
    """Create a set from variable number of items (passed as array).

    Example:
        set_of([1, 2, 3])  # Set containing {1, 2, 3}
    """
    set_from_array(items)

# ============================================================================
# Basic Set Operations
# ============================================================================

fn set_add(s, item):
    """Add an element to the set. Returns new set.
    If element already exists, returns the original set unchanged.

    Example:
        var s = set_new()
        s = set_add(s, 42)
        set_contains(s, 42)  # true
    """
    val key = _to_key(item)
    if s.contains_key(key):
        return s
    var result = {}
    for k in s.keys():
        result[k] = s[k]
    result[key] = item
    result

fn set_remove(s, item):
    """Remove an element from the set. Returns new set.
    If element doesn't exist, returns the original set unchanged.

    Example:
        var s = set_from_array([1, 2, 3])
        s = set_remove(s, 2)
        set_contains(s, 2)  # false
    """
    val key = _to_key(item)
    if not s.contains_key(key):
        return s
    var result = {}
    for k in s.keys():
        if k != key:
            result[k] = s[k]
    result

fn set_contains(s, item) -> bool:
    """Check if element is in the set.

    Example:
        val s = set_from_array([1, 2, 3])
        set_contains(s, 2)  # true
        set_contains(s, 5)  # false
    """
    val key = _to_key(item)
    s.contains_key(key)

fn set_size(s) -> i64:
    """Get the number of elements in the set.

    Example:
        val s = set_from_array([1, 2, 3])
        set_size(s)  # 3
    """
    s.keys().len()

fn set_is_empty(s) -> bool:
    """Check if set is empty.

    Example:
        set_is_empty(set_new())  # true
    """
    s.keys().len() == 0

fn set_clear(s):
    """Remove all elements from the set. Returns empty set.

    Example:
        var s = set_from_array([1, 2, 3])
        s = set_clear(s)
        set_is_empty(s)  # true
    """
    {}

# ============================================================================
# Set Algebra Operations
# ============================================================================

fn set_union(a, b):
    """Union of two sets - all elements from both sets.

    Example:
        val a = set_from_array([1, 2, 3])
        val b = set_from_array([3, 4, 5])
        val u = set_union(a, b)  # {1, 2, 3, 4, 5}
    """
    var result = {}
    for k in a.keys():
        result[k] = a[k]
    for k in b.keys():
        result[k] = b[k]
    result

fn set_intersection(a, b):
    """Intersection of two sets - elements present in both.

    Example:
        val a = set_from_array([1, 2, 3])
        val b = set_from_array([2, 3, 4])
        val i = set_intersection(a, b)  # {2, 3}
    """
    var result = {}
    for k in a.keys():
        if b.contains_key(k):
            result[k] = a[k]
    result

fn set_difference(a, b):
    """Difference of two sets - elements in A but not in B.

    Example:
        val a = set_from_array([1, 2, 3])
        val b = set_from_array([2, 3, 4])
        val d = set_difference(a, b)  # {1}
    """
    var result = {}
    for k in a.keys():
        if not b.contains_key(k):
            result[k] = a[k]
    result

fn set_symmetric_difference(a, b):
    """Symmetric difference - elements in A or B but not in both.

    Example:
        val a = set_from_array([1, 2, 3])
        val b = set_from_array([2, 3, 4])
        val sd = set_symmetric_difference(a, b)  # {1, 4}
    """
    var result = {}
    for k in a.keys():
        if not b.contains_key(k):
            result[k] = a[k]
    for k in b.keys():
        if not a.contains_key(k):
            result[k] = b[k]
    result

# ============================================================================
# Set Predicates
# ============================================================================

fn set_is_subset(a, b) -> bool:
    """Check if A is a subset of B (all elements of A are in B).

    Example:
        val a = set_from_array([1, 2])
        val b = set_from_array([1, 2, 3])
        set_is_subset(a, b)  # true
    """
    for k in a.keys():
        if not b.contains_key(k):
            return false
    true

fn set_is_superset(a, b) -> bool:
    """Check if A is a superset of B (all elements of B are in A).

    Example:
        val a = set_from_array([1, 2, 3])
        val b = set_from_array([1, 2])
        set_is_superset(a, b)  # true
    """
    set_is_subset(b, a)

fn set_is_disjoint(a, b) -> bool:
    """Check if two sets have no elements in common.

    Example:
        val a = set_from_array([1, 2])
        val b = set_from_array([3, 4])
        set_is_disjoint(a, b)  # true
    """
    for k in a.keys():
        if b.contains_key(k):
            return false
    true

fn set_equals(a, b) -> bool:
    """Check if two sets are equal (same elements).

    Example:
        val a = set_from_array([1, 2, 3])
        val b = set_from_array([3, 2, 1])
        set_equals(a, b)  # true
    """
    if set_size(a) != set_size(b):
        return false
    set_is_subset(a, b)

# ============================================================================
# Set Transformations
# ============================================================================

fn set_map(s, mapper):
    """Map a function over all elements, creating a new set.

    Example:
        val s = set_from_array([1, 2, 3])
        val doubled = set_map(s, \x: x * 2)  # {2, 4, 6}
    """
    var result = {}
    for k in s.keys():
        val mapped = mapper(s[k])
        val mk = "{mapped}"
        result[mk] = mapped
    result

fn set_filter(s, predicate):
    """Filter set elements by predicate, creating a new set.

    Example:
        val s = set_from_array([1, 2, 3, 4, 5])
        val evens = set_filter(s, \x: x % 2 == 0)  # {2, 4}
    """
    var result = {}
    for k in s.keys():
        if predicate(s[k]):
            result[k] = s[k]
    result

fn set_partition(s, predicate):
    """Partition set into two sets based on predicate.
    Returns tuple (matching_set, non_matching_set).

    Example:
        val s = set_from_array([1, 2, 3, 4, 5])
        val parts = set_partition(s, \x: x % 2 == 0)
        # parts[0] = {2, 4}, parts[1] = {1, 3, 5}
    """
    var matching = {}
    var non_matching = {}
    for k in s.keys():
        if predicate(s[k]):
            matching[k] = s[k]
        else:
            non_matching[k] = s[k]
    (matching, non_matching)

# ============================================================================
# Set Conversion
# ============================================================================

fn set_to_array(s):
    """Convert set to array. Order is not guaranteed.

    Example:
        val s = set_from_array([3, 1, 2])
        val arr = set_to_array(s)  # [1, 2, 3] or any order
    """
    var result = []
    for k in s.keys():
        result = result.push(s[k])
    result

fn set_to_list(s):
    """Convert set to list. Order is not guaranteed.

    Example:
        val s = set_from_array([3, 1, 2])
        val list = set_to_list(s)
    """
    set_to_array(s)

fn set_to_sorted_array(s):
    """Convert set to sorted array.
    Uses built-in sort() which works for comparable types.

    Example:
        val s = set_from_array([3, 1, 2])
        val arr = set_to_sorted_array(s)  # [1, 2, 3]
    """
    var arr = set_to_array(s)
    arr.sort()
    arr

# ============================================================================
# Multi-element Operations
# ============================================================================

fn set_add_all(s, items):
    """Add multiple elements to the set. Returns new set.

    Example:
        var s = set_new()
        s = set_add_all(s, [1, 2, 3])
        set_size(s)  # 3
    """
    var result = {}
    for k in s.keys():
        result[k] = s[k]
    for item in items:
        val key = "{item}"
        result[key] = item
    result

fn set_remove_all(s, items):
    """Remove multiple elements from the set. Returns new set.

    Example:
        var s = set_from_array([1, 2, 3, 4, 5])
        s = set_remove_all(s, [2, 4])
        # s now contains {1, 3, 5}
    """
    # Build a lookup set of keys to remove
    var to_remove = {}
    for item in items:
        val key = "{item}"
        to_remove[key] = true
    # Copy only keys not in the removal set
    var result = {}
    for k in s.keys():
        if not to_remove.contains_key(k):
            result[k] = s[k]
    result

fn set_retain_all(s, items):
    """Retain only the specified elements. Returns new set.
    Equivalent to intersection with items.

    Example:
        var s = set_from_array([1, 2, 3, 4, 5])
        s = set_retain_all(s, [2, 3, 6])
        # s now contains {2, 3}
    """
    # Build a lookup set of keys to retain
    var to_retain = {}
    for item in items:
        val key = "{item}"
        to_retain[key] = true
    # Copy only keys present in the retain set
    var result = {}
    for k in s.keys():
        if to_retain.contains_key(k):
            result[k] = s[k]
    result

# Re-export advanced operations from set_utils_advanced.spl
use lib.set_utils_advanced.{*}
