# Test ReportNL#NL# Reports for test execution results, failures, and summaries.NL# Provides structured test diagnostics with timing and failure details.NLNLimport ..levelNLimport ..locationNLimport ..reportNLuse std.text.{NL}NLNLexport TestReport, TestResult, TestStatus, TestFailure, TestSuite, TestSummaryNLNL# ANSI escape helperNLfn esc_char() -> text:NL    val code: u8 = 27NL    "{code as char}"NLNL# =============================================================================NL# TestStatus: Possible states of a testNL# =============================================================================NLNLenum TestStatus:NL    Passed          # Test passedNL    Failed          # Test failed (assertion)NL    Error           # Test error (exception/panic)NL    Skipped         # Test skippedNL    Timeout         # Test timed outNL    Pending         # Test not yet implementedNLNLimpl TestStatus:NL    fn name() -> text:NL        match self:NL            case TestStatus.Passed: "passed"NL            case TestStatus.Failed: "failed"NL            case TestStatus.Error: "error"NL            case TestStatus.Skipped: "skipped"NL            case TestStatus.Timeout: "timeout"NL            case TestStatus.Pending: "pending"NLNL    fn symbol() -> text:NL        match self:NL            case TestStatus.Passed: "."NL            case TestStatus.Failed: "F"NL            case TestStatus.Error: "E"NL            case TestStatus.Skipped: "S"NL            case TestStatus.Timeout: "T"NL            case TestStatus.Pending: "P"NLNL    fn color() -> text:NL        val e = esc_char()NL        match self:NL            case TestStatus.Passed: "{e}[32m"NL            case TestStatus.Failed: "{e}[31m"NL            case TestStatus.Error: "{e}[31m"NL            case TestStatus.Skipped: "{e}[33m"NL            case TestStatus.Timeout: "{e}[35m"NL            case TestStatus.Pending: "{e}[36m"NLNL    fn is_success() -> bool:NL        self == TestStatus.PassedNLNL    fn is_failure() -> bool:NL        match self:NL            case TestStatus.Failed: trueNL            case TestStatus.Error: trueNL            case TestStatus.Timeout: trueNL            case _: falseNLNL    fn is_skipped() -> bool:NL        match self:NL            case TestStatus.Skipped: trueNL            case TestStatus.Pending: trueNL            case _: falseNLNL# =============================================================================NL# TestFailure: Details about a test failureNL# =============================================================================NLNLstruct TestFailure:NL    message: text               # Failure messageNL    expected: text?             # Expected value (for assertions)NL    actual: text?               # Actual value (for assertions)NL    location: SourceLocation?   # Where the failure occurredNL    diff: text?                 # Diff output (for text comparisons)NL    stack_trace: [text]         # Stack traceNLNLimpl TestFailure:NL    # Create a simple failureNL    static fn message_only(message: text) -> TestFailure:NL        TestFailure(NL            message: message,NL            expected: nil,NL            actual: nil,NL            location: nil,NL            diff: nil,NL            stack_trace: []NL        )NLNL    # Create an assertion failureNL    static fn assertion(expected: text, actual: text, message: text) -> TestFailure:NL        TestFailure(NL            message: message,NL            expected: Some(expected),NL            actual: Some(actual),NL            location: nil,NL            diff: nil,NL            stack_trace: []NL        )NLNL    # Create a failure with locationNL    static fn at(message: text, location: SourceLocation) -> TestFailure:NL        TestFailure(NL            message: message,NL            expected: nil,NL            actual: nil,NL            location: Some(location),NL            diff: nil,NL            stack_trace: []NL        )NLNL    fn with_location(location: SourceLocation) -> TestFailure:NL        TestFailure(NL            message: self.message,NL            expected: self.expected,NL            actual: self.actual,NL            location: Some(location),NL            diff: self.diff,NL            stack_trace: self.stack_traceNL        )NLNL    fn with_diff(diff: text) -> TestFailure:NL        TestFailure(NL            message: self.message,NL            expected: self.expected,NL            actual: self.actual,NL            location: self.location,NL            diff: Some(diff),NL            stack_trace: self.stack_traceNL        )NLNL    fn with_stack(trace: [text]) -> TestFailure:NL        TestFailure(NL            message: self.message,NL            expected: self.expected,NL            actual: self.actual,NL            location: self.location,NL            diff: self.diff,NL            stack_trace: traceNL        )NLNL    fn has_values() -> bool:NL        self.expected.? and self.actual.?NLNL    fn format(use_color: bool) -> text:NL        val e = esc_char()NL        val red = if use_color: "{e}[31m" else: ""NL        val green = if use_color: "{e}[32m" else: ""NL        val gray = if use_color: "{e}[90m" else: ""NL        val reset = if use_color: "{e}[0m" else: ""NLNL        var output = "{red}{self.message}{reset}"NLNL        if self.location.?:NL            output = output + "\n  at {self.location.unwrap().format_short()}"NLNL        if self.has_values():NL            output = output + "\n  {green}Expected:{reset} {self.expected.unwrap()}"NL            output = output + "\n  {red}Actual:{reset}   {self.actual.unwrap()}"NLNL        if self.diff.?:NL            output = output + "\n  {gray}Diff:{reset}\n{self.diff.unwrap()}"NLNL        if not self.stack_trace.is_empty():NL            output = output + "\n  {gray}Stack trace:{reset}"NL            for frame in self.stack_trace:NL                output = output + "\n    {frame}"NLNL        outputNLNL# =============================================================================NL# TestResult: Result of a single testNL# =============================================================================NLNLclass TestResult:NL    name: text                  # Test nameNL    status: TestStatusNL    duration_ms: i64            # Duration in millisecondsNL    failure: TestFailure?       # Failure details (if failed)NL    output: text?               # Captured stdout/stderrNL    file: text?                 # Test fileNL    line: i64                   # Line number (0 if unknown)NL    tags: [text]                # Test tagsNLNLimpl TestResult:NL    # Create a passed testNL    static fn passed(name: text, duration_ms: i64) -> TestResult:NL        TestResult(NL            name: name,NL            status: TestStatus.Passed,NL            duration_ms: duration_ms,NL            failure: nil,NL            output: nil,NL            file: nil,NL            line: 0,NL            tags: []NL        )NLNL    # Create a failed testNL    static fn failed(name: text, failure: TestFailure, duration_ms: i64) -> TestResult:NL        TestResult(NL            name: name,NL            status: TestStatus.Failed,NL            duration_ms: duration_ms,NL            failure: Some(failure),NL            output: nil,NL            file: nil,NL            line: 0,NL            tags: []NL        )NLNL    # Create an error testNL    static fn error(name: text, message: text, duration_ms: i64) -> TestResult:NL        TestResult(NL            name: name,NL            status: TestStatus.Error,NL            duration_ms: duration_ms,NL            failure: Some(TestFailure.message_only(message)),NL            output: nil,NL            file: nil,NL            line: 0,NL            tags: []NL        )NLNL    # Create a skipped testNL    static fn skipped(name: text, reason: text?) -> TestResult:NL        var result = TestResult(NL            name: name,NL            status: TestStatus.Skipped,NL            duration_ms: 0,NL            failure: nil,NL            output: nil,NL            file: nil,NL            line: 0,NL            tags: []NL        )NL        if reason.?:NL            result.failure = Some(TestFailure.message_only(reason.unwrap()))NL        resultNLNL    # Create a timeout testNL    static fn timeout(name: text, duration_ms: i64) -> TestResult:NL        TestResult(NL            name: name,NL            status: TestStatus.Timeout,NL            duration_ms: duration_ms,NL            failure: Some(TestFailure.message_only("Test timed out after {duration_ms}ms")),NL            output: nil,NL            file: nil,NL            line: 0,NL            tags: []NL        )NLNL    # Create a pending testNL    static fn pending(name: text) -> TestResult:NL        TestResult(NL            name: name,NL            status: TestStatus.Pending,NL            duration_ms: 0,NL            failure: nil,NL            output: nil,NL            file: nil,NL            line: 0,NL            tags: []NL        )NLNL    # ==========================================================================NL    # Builder methodsNL    # ==========================================================================NLNL    fn in_file(file: text, line: i64) -> TestResult:NL        TestResult(NL            name: self.name,NL            status: self.status,NL            duration_ms: self.duration_ms,NL            failure: self.failure,NL            output: self.output,NL            file: Some(file),NL            line: line,NL            tags: self.tagsNL        )NLNL    fn with_output(output: text) -> TestResult:NL        TestResult(NL            name: self.name,NL            status: self.status,NL            duration_ms: self.duration_ms,NL            failure: self.failure,NL            output: Some(output),NL            file: self.file,NL            line: self.line,NL            tags: self.tagsNL        )NLNL    fn with_tags(tags: [text]) -> TestResult:NL        TestResult(NL            name: self.name,NL            status: self.status,NL            duration_ms: self.duration_ms,NL            failure: self.failure,NL            output: self.output,NL            file: self.file,NL            line: self.line,NL            tags: tagsNL        )NLNL    # ==========================================================================NL    # AccessorsNL    # ==========================================================================NLNL    fn is_success() -> bool:NL        self.status.is_success()NLNL    fn is_failure() -> bool:NL        self.status.is_failure()NLNL    fn is_skipped() -> bool:NL        self.status.is_skipped()NLNL    fn has_output() -> bool:NL        self.output.? and not self.output.unwrap().is_empty()NLNL    fn location() -> SourceLocation?:NL        if self.file.?:NL            Some(SourceLocation.at(self.file.unwrap(), self.line, 1))NL        else:NL            nilNLNL    # ==========================================================================NL    # Conversion to ReportNL    # ==========================================================================NLNL    fn to_report() -> Report:NL        val level = if self.is_failure():NL            ReportLevel.ErrorNL        elif self.is_skipped():NL            ReportLevel.WarningNL        else:NL            ReportLevel.InfoNLNL        var msg = "{self.status.name()}: {self.name}"NL        if self.duration_ms > 0:NL            msg = msg + " ({self.duration_ms}ms)"NLNL        var report = match level:NL            case ReportLevel.Error: Report.error(msg)NL            case ReportLevel.Warning: Report.warning(msg)NL            case _: Report.info(msg)NLNL        report = report.with_kind(ReportKind.TestFailure).with_source("test")NLNL        if self.file.?:NL            report = report.at(self.file.unwrap(), self.line, 1)NLNL        if self.failure.?:NL            val fail = self.failure.unwrap()NL            report = report.with_note(fail.message)NL            if fail.expected.?:NL                report = report.with_note("expected: {fail.expected.unwrap()}")NL            if fail.actual.?:NL                report = report.with_note("actual: {fail.actual.unwrap()}")NLNL        reportNLNL    # ==========================================================================NL    # FormattingNL    # ==========================================================================NLNL    fn format(use_color: bool) -> text:NL        val e = esc_char()NL        val status_color = if use_color: self.status.color() else: ""NL        val reset = if use_color: "{e}[0m" else: ""NL        val bold = if use_color: "{e}[1m" else: ""NLNL        var output = "{status_color}{self.status.symbol()}{reset} {bold}{self.name}{reset}"NLNL        if self.duration_ms > 0:NL            output = output + " ({self.duration_ms}ms)"NLNL        if self.file.?:NL            output = output + "\n  {self.file.unwrap()}:{self.line}"NLNL        if self.failure.? and self.is_failure():NL            output = output + "\n" + self.failure.unwrap().format(use_color)NLNL        outputNLNL    fn format_short() -> text:NL        "{self.status.symbol()} {self.name}"NLNL# =============================================================================NL# TestSuite: Collection of test results for a file/moduleNL# =============================================================================NLNLclass TestSuite:NL    name: text                  # Suite name (usually file path)NL    results: [TestResult]NL    duration_ms: i64NL    setup_failure: TestFailure? # Failure during setupNLNLimpl TestSuite:NL    static fn named(name: text) -> TestSuite:NL        TestSuite(NL            name: name,NL            results: [],NL            duration_ms: 0,NL            setup_failure: nilNL        )NLNL    me add(result: TestResult):NL        self.results.push(result)NLNL    me set_duration(duration_ms: i64):NL        self.duration_ms = duration_msNLNL    me set_setup_failure(failure: TestFailure):NL        self.setup_failure = Some(failure)NLNL    fn count() -> i64:NL        self.results.len()NLNL    fn passed_count() -> i64:NL        self.results.filter(\r: r.status == TestStatus.Passed).len()NLNL    fn failed_count() -> i64:NL        self.results.filter(\r: r.is_failure()).len()NLNL    fn skipped_count() -> i64:NL        self.results.filter(\r: r.is_skipped()).len()NLNL    fn has_failures() -> bool:NL        self.setup_failure.? or self.results.any(\r: r.is_failure())NLNL    fn all_passed() -> bool:NL        self.setup_failure == nil and self.results.all(\r: r.is_success())NLNL    fn failures() -> [TestResult]:NL        self.results.filter(\r: r.is_failure())NLNL    fn format(use_color: bool) -> text:NL        val e = esc_char()NL        val bold = if use_color: "{e}[1m" else: ""NL        val reset = if use_color: "{e}[0m" else: ""NLNL        var output = "{bold}{self.name}{reset}\n"NLNL        if self.setup_failure.?:NL            output = output + "  Setup failed: " + self.setup_failure.unwrap().format(use_color) + "\n"NLNL        for result in self.results:NL            output = output + "  " + result.format(use_color) + "\n"NLNL        outputNLNL# =============================================================================NL# TestSummary: Summary of all test resultsNL# =============================================================================NLNLclass TestSummary:NL    suites: [TestSuite]NL    total_tests: i64NL    passed: i64NL    failed: i64NL    errors: i64NL    skipped: i64NL    timeout: i64NL    pending: i64NL    duration_ms: i64NLNLimpl TestSummary:NL    static fn empty() -> TestSummary:NL        TestSummary(NL            suites: [],NL            total_tests: 0,NL            passed: 0,NL            failed: 0,NL            errors: 0,NL            skipped: 0,NL            timeout: 0,NL            pending: 0,NL            duration_ms: 0NL        )NLNL    me add_suite(suite: TestSuite):NL        self.suites.push(suite)NL        self.duration_ms = self.duration_ms + suite.duration_msNLNL        for result in suite.results:NL            self.total_tests = self.total_tests + 1NL            match result.status:NL                case TestStatus.Passed: self.passed = self.passed + 1NL                case TestStatus.Failed: self.failed = self.failed + 1NL                case TestStatus.Error: self.errors = self.errors + 1NL                case TestStatus.Skipped: self.skipped = self.skipped + 1NL                case TestStatus.Timeout: self.timeout = self.timeout + 1NL                case TestStatus.Pending: self.pending = self.pending + 1NLNL    fn has_failures() -> bool:NL        self.failed > 0 or self.errors > 0 or self.timeout > 0NLNL    fn all_passed() -> bool:NL        self.failed == 0 and self.errors == 0 and self.timeout == 0NLNL    fn failure_count() -> i64:NL        self.failed + self.errors + self.timeoutNLNL    fn all_failures() -> [TestResult]:NL        var failures: [TestResult] = []NL        for suite in self.suites:NL            for result in suite.failures():NL                failures.push(result)NL        failuresNLNL    fn to_report() -> Report:NL        val level = if self.has_failures():NL            ReportLevel.ErrorNL        else:NL            ReportLevel.InfoNLNL        val msg = "{self.passed}/{self.total_tests} tests passed"NLNL        var report = match level:NL            case ReportLevel.Error: Report.error(msg)NL            case _: Report.info(msg)NLNL        report = report.with_source("test")NLNL        if self.failed > 0:NL            report = report.with_note("{self.failed} failed")NL        if self.errors > 0:NL            report = report.with_note("{self.errors} errors")NL        if self.timeout > 0:NL            report = report.with_note("{self.timeout} timed out")NL        if self.skipped > 0:NL            report = report.with_note("{self.skipped} skipped")NLNL        reportNLNL    fn format(use_color: bool) -> text:NL        val e = esc_char()NL        val bold = if use_color: "{e}[1m" else: ""NL        val green = if use_color: "{e}[32m" else: ""NL        val red = if use_color: "{e}[31m" else: ""NL        val yellow = if use_color: "{e}[33m" else: ""NL        val reset = if use_color: "{e}[0m" else: ""NLNL        var output = ""NLNL        # Show failures firstNL        if self.has_failures():NL            output = output + "{bold}Failures:{reset}\n"NL            for failure in self.all_failures():NL                output = output + failure.format(use_color) + "\n\n"NLNL        # Summary lineNL        output = output + "{bold}Test Summary:{reset}\n"NLNL        val status_color = if self.all_passed(): green else: redNL        output = output + "  {status_color}{self.passed}/{self.total_tests} passed{reset}"NLNL        if self.failed > 0:NL            output = output + ", {red}{self.failed} failed{reset}"NL        if self.errors > 0:NL            output = output + ", {red}{self.errors} errors{reset}"NL        if self.timeout > 0:NL            output = output + ", {yellow}{self.timeout} timeout{reset}"NL        if self.skipped > 0:NL            output = output + ", {yellow}{self.skipped} skipped{reset}"NL        if self.pending > 0:NL            output = output + ", {self.pending} pending"NLNL        output = output + "\n  Duration: {self.duration_ms}ms\n"NLNL        outputNLNL    fn format_progress() -> text:NL        var symbols = ""NL        for suite in self.suites:NL            for result in suite.results:NL                symbols = symbols + result.status.symbol()NL        symbolsNLNL# =============================================================================NL# TestReport: Unified test report (alias for convenience)NL# =============================================================================NLNLclass TestReport:NL    summary: TestSummaryNLNLimpl TestReport:NL    static fn from_summary(summary: TestSummary) -> TestReport:NL        TestReport(summary: summary)NLNL    fn has_failures() -> bool:NL        self.summary.has_failures()NLNL    fn all_passed() -> bool:NL        self.summary.all_passed()NLNL    fn to_report() -> Report:NL        self.summary.to_report()NLNL    fn format(use_color: bool) -> text:NL        self.summary.format(use_color)NL