# Memory ReportsNL#NL# Reports for memory-related issues: leaks, GC events, allocation failures.NL# Provides structured memory diagnostics for debugging and monitoring.NLNLimport ..levelNLimport ..locationNLimport ..reportNLuse std.text.{NL}NLNLexport MemoryReport, MemoryEvent, MemoryEventKind, LeakInfo, GCStatsNLNL# ANSI escape helperNLfn esc_char() -> text:NL    val code: u8 = 27NL    "{code as char}"NLNL# =============================================================================NL# MemoryEventKind: Types of memory eventsNL# =============================================================================NLNLenum MemoryEventKind:NL    Allocation          # Memory allocatedNL    Deallocation        # Memory freedNL    GCStart             # GC cycle startedNL    GCEnd               # GC cycle completedNL    GCPause             # GC pause (stop-the-world)NL    LeakDetected        # Memory leak detectedNL    AllocationFailure   # Allocation failedNL    HeapGrowth          # Heap expandedNL    HeapShrink          # Heap contractedNLNLimpl MemoryEventKind:NL    fn name() -> text:NL        match self:NL            case MemoryEventKind.Allocation: "allocation"NL            case MemoryEventKind.Deallocation: "deallocation"NL            case MemoryEventKind.GCStart: "gc_start"NL            case MemoryEventKind.GCEnd: "gc_end"NL            case MemoryEventKind.GCPause: "gc_pause"NL            case MemoryEventKind.LeakDetected: "leak"NL            case MemoryEventKind.AllocationFailure: "alloc_fail"NL            case MemoryEventKind.HeapGrowth: "heap_grow"NL            case MemoryEventKind.HeapShrink: "heap_shrink"NLNL    fn is_gc_event() -> bool:NL        match self:NL            case MemoryEventKind.GCStart: trueNL            case MemoryEventKind.GCEnd: trueNL            case MemoryEventKind.GCPause: trueNL            case _: falseNLNL    fn is_error() -> bool:NL        match self:NL            case MemoryEventKind.LeakDetected: trueNL            case MemoryEventKind.AllocationFailure: trueNL            case _: falseNLNL# =============================================================================NL# LeakInfo: Information about a detected memory leakNL# =============================================================================NLNLstruct LeakInfo:NL    address: i64                # Memory addressNL    size: i64                   # Size in bytesNL    type_name: text?            # Type of leaked object (if known)NL    allocation_location: SourceLocation?  # Where it was allocatedNL    allocation_time: i64        # When it was allocated (timestamp)NL    stack_trace: [text]         # Allocation stack trace (function names)NLNLimpl LeakInfo:NL    static fn at_address(address: i64, size: i64) -> LeakInfo:NL        LeakInfo(NL            address: address,NL            size: size,NL            type_name: nil,NL            allocation_location: nil,NL            allocation_time: 0,NL            stack_trace: []NL        )NLNL    fn with_type(type_name: text) -> LeakInfo:NL        LeakInfo(NL            address: self.address,NL            size: self.size,NL            type_name: Some(type_name),NL            allocation_location: self.allocation_location,NL            allocation_time: self.allocation_time,NL            stack_trace: self.stack_traceNL        )NLNL    fn with_location(location: SourceLocation) -> LeakInfo:NL        LeakInfo(NL            address: self.address,NL            size: self.size,NL            type_name: self.type_name,NL            allocation_location: Some(location),NL            allocation_time: self.allocation_time,NL            stack_trace: self.stack_traceNL        )NLNL    fn with_stack(trace: [text]) -> LeakInfo:NL        LeakInfo(NL            address: self.address,NL            size: self.size,NL            type_name: self.type_name,NL            allocation_location: self.allocation_location,NL            allocation_time: self.allocation_time,NL            stack_trace: traceNL        )NLNL    fn format(use_color: bool) -> text:NL        val e = esc_char()NL        val yellow = if use_color: "{e}[33m" else: ""NL        val gray = if use_color: "{e}[90m" else: ""NL        val reset = if use_color: "{e}[0m" else: ""NLNL        var output = "{yellow}Leak:{reset} {self.format_size(self.size)} at 0x{self.address:x}"NLNL        if self.type_name.?:NL            output = output + " ({self.type_name.unwrap()})"NLNL        if self.allocation_location.?:NL            output = output + "\n  allocated at {self.allocation_location.unwrap().format_short()}"NLNL        if not self.stack_trace.is_empty():NL            output = output + "\n  {gray}allocation trace:{reset}"NL            for frame in self.stack_trace:NL                output = output + "\n    {frame}"NLNL        outputNLNL    fn format_size(bytes: i64) -> text:NL        if bytes < 1024:NL            "{bytes} B"NL        elif bytes < 1024 * 1024:NL            "{bytes / 1024} KB"NL        elif bytes < 1024 * 1024 * 1024:NL            "{bytes / (1024 * 1024)} MB"NL        else:NL            "{bytes / (1024 * 1024 * 1024)} GB"NLNL# =============================================================================NL# GCStats: Garbage collection statisticsNL# =============================================================================NLNLstruct GCStats:NL    cycle_number: i64           # GC cycle numberNL    duration_ms: i64            # Duration in millisecondsNL    pause_time_ms: i64          # Total pause timeNL    objects_scanned: i64        # Objects scannedNL    objects_collected: i64      # Objects collectedNL    bytes_freed: i64            # Bytes freedNL    heap_before: i64            # Heap size before GCNL    heap_after: i64             # Heap size after GCNLNLimpl GCStats:NL    static fn empty() -> GCStats:NL        GCStats(NL            cycle_number: 0,NL            duration_ms: 0,NL            pause_time_ms: 0,NL            objects_scanned: 0,NL            objects_collected: 0,NL            bytes_freed: 0,NL            heap_before: 0,NL            heap_after: 0NL        )NLNL    fn collection_rate() -> f64:NL        if self.objects_scanned == 0:NL            0.0NL        else:NL            (self.objects_collected as f64) / (self.objects_scanned as f64) * 100.0NLNL    fn compression_ratio() -> f64:NL        if self.heap_before == 0:NL            0.0NL        else:NL            (self.heap_after as f64) / (self.heap_before as f64) * 100.0NLNL    fn format(use_color: bool) -> text:NL        val e = esc_char()NL        val cyan = if use_color: "{e}[36m" else: ""NL        val green = if use_color: "{e}[32m" else: ""NL        val gray = if use_color: "{e}[90m" else: ""NL        val reset = if use_color: "{e}[0m" else: ""NLNL        var output = "{cyan}GC Cycle #{self.cycle_number}{reset}\n"NL        output = output + "  Duration: {self.duration_ms}ms (pause: {self.pause_time_ms}ms)\n"NL        output = output + "  Objects: {self.objects_collected}/{self.objects_scanned} collected"NL        output = output + " ({green}{self.collection_rate():.1}%{reset})\n"NL        output = output + "  Freed: {self.format_size(self.bytes_freed)}\n"NL        output = output + "  Heap: {self.format_size(self.heap_before)} -> {self.format_size(self.heap_after)}"NL        output = output + " ({self.compression_ratio():.1}%)"NL        outputNLNL    fn format_size(bytes: i64) -> text:NL        if bytes < 1024:NL            "{bytes} B"NL        elif bytes < 1024 * 1024:NL            "{bytes / 1024} KB"NL        elif bytes < 1024 * 1024 * 1024:NL            "{bytes / (1024 * 1024)} MB"NL        else:NL            "{bytes / (1024 * 1024 * 1024)} GB"NLNL# =============================================================================NL# MemoryEvent: Single memory eventNL# =============================================================================NLNLstruct MemoryEvent:NL    kind: MemoryEventKindNL    timestamp: i64NL    address: i64?               # Memory address (for alloc/dealloc)NL    size: i64?                  # Size in bytesNL    message: text?              # Optional messageNL    location: SourceLocation?   # Source locationNLNLimpl MemoryEvent:NL    static fn allocation(address: i64, size: i64) -> MemoryEvent:NL        MemoryEvent(NL            kind: MemoryEventKind.Allocation,NL            timestamp: 0,NL            address: Some(address),NL            size: Some(size),NL            message: nil,NL            location: nilNL        )NLNL    static fn deallocation(address: i64, size: i64) -> MemoryEvent:NL        MemoryEvent(NL            kind: MemoryEventKind.Deallocation,NL            timestamp: 0,NL            address: Some(address),NL            size: Some(size),NL            message: nil,NL            location: nilNL        )NLNL    static fn gc_start(cycle: i64) -> MemoryEvent:NL        MemoryEvent(NL            kind: MemoryEventKind.GCStart,NL            timestamp: 0,NL            address: nil,NL            size: nil,NL            message: Some("GC cycle {cycle} started"),NL            location: nilNL        )NLNL    static fn gc_end(cycle: i64, duration_ms: i64) -> MemoryEvent:NL        MemoryEvent(NL            kind: MemoryEventKind.GCEnd,NL            timestamp: 0,NL            address: nil,NL            size: nil,NL            message: Some("GC cycle {cycle} completed in {duration_ms}ms"),NL            location: nilNL        )NLNL    static fn leak(address: i64, size: i64) -> MemoryEvent:NL        MemoryEvent(NL            kind: MemoryEventKind.LeakDetected,NL            timestamp: 0,NL            address: Some(address),NL            size: Some(size),NL            message: nil,NL            location: nilNL        )NLNL    fn at(file: text, line: i64, column: i64) -> MemoryEvent:NL        MemoryEvent(NL            kind: self.kind,NL            timestamp: self.timestamp,NL            address: self.address,NL            size: self.size,NL            message: self.message,NL            location: Some(SourceLocation.at(file, line, column))NL        )NLNL    fn to_report() -> Report:NL        val level = if self.kind.is_error():NL            ReportLevel.ErrorNL        elif self.kind.is_gc_event():NL            ReportLevel.DebugNL        else:NL            ReportLevel.InfoNLNL        var msg = self.message ?? self.kind.name()NL        if self.size.?:NL            msg = msg + " ({self.format_size(self.size.unwrap())})"NLNL        var report = match level:NL            case ReportLevel.Error: Report.error(msg)NL            case ReportLevel.Debug: Report.debug(msg)NL            case _: Report.info(msg)NLNL        report = report.with_kind(ReportKind.MemoryError).with_source("memory")NLNL        if self.location.?:NL            report = report.with_location(self.location.unwrap())NLNL        reportNLNL    fn format_size(bytes: i64) -> text:NL        if bytes < 1024:NL            "{bytes} B"NL        elif bytes < 1024 * 1024:NL            "{bytes / 1024} KB"NL        else:NL            "{bytes / (1024 * 1024)} MB"NLNL# =============================================================================NL# MemoryReport: Comprehensive memory diagnostic reportNL# =============================================================================NLNLclass MemoryReport:NL    events: [MemoryEvent]NL    leaks: [LeakInfo]NL    gc_stats: [GCStats]NL    total_allocated: i64NL    total_freed: i64NL    peak_usage: i64NL    current_usage: i64NLNLimpl MemoryReport:NL    static fn empty() -> MemoryReport:NL        MemoryReport(NL            events: [],NL            leaks: [],NL            gc_stats: [],NL            total_allocated: 0,NL            total_freed: 0,NL            peak_usage: 0,NL            current_usage: 0NL        )NLNL    me add_event(event: MemoryEvent):NL        self.events.push(event)NLNL    me add_leak(leak: LeakInfo):NL        self.leaks.push(leak)NLNL    me add_gc_stats(stats: GCStats):NL        self.gc_stats.push(stats)NLNL    me record_allocation(size: i64):NL        self.total_allocated = self.total_allocated + sizeNL        self.current_usage = self.current_usage + sizeNL        if self.current_usage > self.peak_usage:NL            self.peak_usage = self.current_usageNLNL    me record_deallocation(size: i64):NL        self.total_freed = self.total_freed + sizeNL        self.current_usage = self.current_usage - sizeNLNL    # ==========================================================================NL    # AccessorsNL    # ==========================================================================NLNL    fn has_leaks() -> bool:NL        not self.leaks.is_empty()NLNL    fn leak_count() -> i64:NL        self.leaks.len()NLNL    fn total_leaked_bytes() -> i64:NL        var total = 0NL        for leak in self.leaks:NL            total = total + leak.sizeNL        totalNLNL    fn gc_cycle_count() -> i64:NL        self.gc_stats.len()NLNL    fn total_gc_time_ms() -> i64:NL        var total = 0NL        for stats in self.gc_stats:NL            total = total + stats.duration_msNL        totalNLNL    # ==========================================================================NL    # Conversion to ReportNL    # ==========================================================================NLNL    fn to_report() -> Report:NL        val level = if self.has_leaks():NL            ReportLevel.WarningNL        else:NL            ReportLevel.InfoNLNL        var msg = "Memory report: "NL        msg = msg + "{self.format_size(self.current_usage)} in use, "NL        msg = msg + "{self.format_size(self.peak_usage)} peak"NLNL        if self.has_leaks():NL            msg = msg + ", {self.leak_count()} leak(s) ({self.format_size(self.total_leaked_bytes())})"NLNL        var report = match level:NL            case ReportLevel.Warning: Report.warning(msg)NL            case _: Report.info(msg)NLNL        report = report.with_kind(ReportKind.MemoryError).with_source("memory")NLNL        report = report.with_note("Total allocated: {self.format_size(self.total_allocated)}")NL        report = report.with_note("Total freed: {self.format_size(self.total_freed)}")NLNL        if self.gc_cycle_count() > 0:NL            report = report.with_note("GC cycles: {self.gc_cycle_count()} ({self.total_gc_time_ms()}ms total)")NLNL        reportNLNL    # ==========================================================================NL    # FormattingNL    # ==========================================================================NLNL    fn format(use_color: bool) -> text:NL        val e = esc_char()NL        val bold = if use_color: "{e}[1m" else: ""NL        val cyan = if use_color: "{e}[36m" else: ""NL        val yellow = if use_color: "{e}[33m" else: ""NL        val green = if use_color: "{e}[32m" else: ""NL        val reset = if use_color: "{e}[0m" else: ""NLNL        var output = "{bold}Memory Report{reset}\n"NL        output = output + "═══════════════════════════════════════\n"NLNL        # SummaryNL        output = output + "\n{cyan}Summary:{reset}\n"NL        output = output + "  Current usage: {self.format_size(self.current_usage)}\n"NL        output = output + "  Peak usage: {self.format_size(self.peak_usage)}\n"NL        output = output + "  Total allocated: {self.format_size(self.total_allocated)}\n"NL        output = output + "  Total freed: {self.format_size(self.total_freed)}\n"NLNL        # LeaksNL        if self.has_leaks():NL            output = output + "\n{yellow}Detected Leaks ({self.leak_count()}):{reset}\n"NL            for leak in self.leaks:NL                output = output + "  " + leak.format(use_color) + "\n"NLNL        # GC StatsNL        if not self.gc_stats.is_empty():NL            output = output + "\n{green}GC Statistics:{reset}\n"NL            output = output + "  Cycles: {self.gc_cycle_count()}\n"NL            output = output + "  Total time: {self.total_gc_time_ms()}ms\n"NLNL            # Show last GC cycle detailsNL            val last_gc = self.gc_stats[self.gc_stats.len() - 1]NL            output = output + "\n  Last cycle:\n"NL            output = output + "    Objects collected: {last_gc.objects_collected}\n"NL            output = output + "    Bytes freed: {self.format_size(last_gc.bytes_freed)}\n"NLNL        outputNLNL    fn format_size(bytes: i64) -> text:NL        if bytes < 1024:NL            "{bytes} B"NL        elif bytes < 1024 * 1024:NL            "{bytes / 1024} KB"NL        elif bytes < 1024 * 1024 * 1024:NL            "{bytes / (1024 * 1024)} MB"NL        else:NL            "{bytes / (1024 * 1024 * 1024)} GB"NL