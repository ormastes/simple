# Functional Programming Library
#
# Consolidated functional programming utilities for Simple.
# Array operations delegated to array.spl for consistency.

# Import from array.spl
use std.array.{
    array_take_while, array_drop_while, array_find,
    array_any, array_all, array_count, array_repeat
}

# Import split modules
use std.common.option_helpers.*
use std.common.result_helpers.*

#
# This module consolidates:
# - Core functional primitives (identity, constant, apply)
# - Function composition and piping
# - Higher-order array functions (map, filter, fold, scan)
# - Iteration and generation utilities
# - Predicates and combinators
# - Option type helpers (from option_helpers.spl)
# - Result type helpers (from result_helpers.spl)
# - Memoization
#
# Note: Runtime limitations:
# - Closures can read but not modify outer variables
# - Generic functions not available at runtime
#
# Total Functions: 83

# ============================================================================
# Section 1: Core Functional Primitives
# ============================================================================

fn identity(x):
    """Identity function - returns its argument unchanged.

    Useful as default function or placeholder.

    Example:
        identity(42)  # 42
    """
    x

fn constant(value):
    """Create a function that always returns the same value.

    Note: Returns a function that takes one argument.

    Example:
        val always_42 = constant(42)
        always_42(1)  # 42
        always_42(2)  # 42
    """
    \x: value

fn apply(f, x):
    """Apply function f to value x.

    Explicit function application.

    Example:
        apply(\x: x * 2, 5)  # 10
    """
    f(x)

# ============================================================================
# Section 2: Function Composition
# ============================================================================

fn pipe_two(x, f, g):
    """Pipe value through two functions: g(f(x)).

    Example:
        pipe_two(5, \x: x * 2, \x: x + 1)  # 11
    """
    g(f(x))

fn pipe_three(x, f, g, h):
    """Pipe value through three functions: h(g(f(x))).

    Example:
        pipe_three(5, \x: x * 2, \x: x + 1, \x: x * 10)  # 110
    """
    h(g(f(x)))

fn compose_two(f, g):
    """Compose two functions: returns \x: g(f(x)).

    Example:
        val double_then_inc = compose_two(\x: x * 2, \x: x + 1)
        double_then_inc(5)  # 11
    """
    \x: g(f(x))

# ============================================================================
# Section 3: Higher-Order Array Functions
# ============================================================================

fn map_with_index(arr, f):
    """Map with index: f receives (element, index).

    Example:
        map_with_index([10,20,30], \x, i: x + i)
        # [10, 21, 32]
    """
    var result = []
    var i = 0
    while i < arr.len():
        result.push(f(arr[i], i))
        i = i + 1
    result

fn filter_with_index(arr, predicate):
    """Filter with index: predicate receives (element, index).

    Example:
        filter_with_index([10,20,30,40], \x, i: i % 2 == 0)
        # [10, 30]
    """
    var result = []
    var i = 0
    while i < arr.len():
        if predicate(arr[i], i):
            result.push(arr[i])
        i = i + 1
    result

fn fold_left(arr, initial, f):
    """Left fold (reduce): f(accumulator, element).

    Example:
        fold_left([1,2,3,4], 0, \acc, x: acc + x)  # 10
    """
    var acc = initial
    for item in arr:
        acc = f(acc, item)
    acc

fn fold_right(arr, initial, f):
    """Right fold: f(element, accumulator).

    Processes array from right to left.

    Example:
        fold_right([1,2,3], 0, \x, acc: x - acc)
        # 1 - (2 - (3 - 0)) = 2
    """
    var acc = initial
    var i = arr.len() - 1
    while i >= 0:
        acc = f(arr[i], acc)
        i = i - 1
    acc

fn scan_left(arr, initial, f):
    """Scan (cumulative fold): returns all intermediate results.

    Example:
        scan_left([1,2,3], 0, \acc, x: acc + x)
        # [0, 1, 3, 6]
    """
    var result = [initial]
    var acc = initial
    for item in arr:
        acc = f(acc, item)
        result.push(acc)
    result

fn zip_with(arr1, arr2, f):
    """Zip two arrays with a combining function.

    Example:
        zip_with([1,2,3], [4,5,6], \a, b: a + b)
        # [5, 7, 9]
    """
    var result = []
    var len = arr1.len()
    if arr2.len() < len:
        len = arr2.len()

    var i = 0
    while i < len:
        result.push(f(arr1[i], arr2[i]))
        i = i + 1

    result

fn unzip_pairs(arr):
    """Unzip array of pairs into two arrays.

    Example:
        unzip_pairs([(1,2), (3,4), (5,6)])
        # ([1,3,5], [2,4,6])
    """
    var first = []
    var second = []

    for (a, b) in arr:
        first.push(a)
        second.push(b)

    (first, second)

# ============================================================================
# Section 4: Predicates and Combinators
# ============================================================================

fn all_predicate(arr, predicate):
    """Check if predicate is true for all elements. Delegates to array_all."""
    array_all(arr, predicate)

fn any_predicate(arr, predicate):
    """Check if predicate is true for any element. Delegates to array_any."""
    array_any(arr, predicate)

fn none_predicate(arr, predicate):
    """Check if predicate is false for all elements.

    Example:
        none_predicate([1,3,5], \x: x % 2 == 0)  # true
    """
    for item in arr:
        if predicate(item):
            return false
    true

fn count_where(arr, predicate):
    """Count elements matching predicate. Delegates to array_count."""
    array_count(arr, predicate)

# ============================================================================
# Section 5: Iteration Helpers
# ============================================================================

fn times(n: i64, f: fn(i64)):
    """Execute function n times with index as argument.

    Example:
        times(3, \i: print("Iteration {i}"))
    """
    var i = 0
    while i < n:
        f(i)
        i = i + 1

fn repeat_value(n: i64, value) -> []:
    """Create array with value repeated n times. Delegates to array_repeat."""
    array_repeat(value, n)

fn iterate(f, initial, n: i64):
    """Apply function repeatedly, collecting results.

    Returns array: [initial, f(initial), f(f(initial)), ...]

    Example:
        iterate(\x: x * 2, 1, 4)  # [1, 2, 4, 8]
    """
    var result = [initial]
    var current = initial
    var i = 1
    while i < n:
        current = f(current)
        result.push(current)
        i = i + 1
    result

fn until_predicate(f, predicate, initial, max_iterations: i64):
    """Apply function repeatedly until predicate is true.

    Returns array of intermediate values.
    Stops at max_iterations to prevent infinite loops.

    Example:
        until_predicate(\x: x + 1, \x: x > 5, 0, 100)
        # [0, 1, 2, 3, 4, 5, 6]
    """
    var result = [initial]
    var current = initial
    var i = 0

    while not predicate(current) and i < max_iterations:
        current = f(current)
        result.push(current)
        i = i + 1

    result

# ============================================================================
# Section 6: Array Utilities
# ============================================================================

fn take_while(arr, predicate):
    """Take elements while predicate is true. Delegates to array_take_while."""
    array_take_while(arr, predicate)

fn drop_while(arr, predicate):
    """Drop elements while predicate is true. Delegates to array_drop_while."""
    array_drop_while(arr, predicate)

fn find_first(arr, predicate):
    """Find first element matching predicate. Delegates to array_find.

    Returns element or nil (Note: array_find returns element directly, not wrapped in Some).
    """
    array_find(arr, predicate)

fn find_last(arr, predicate):
    """Find last element matching predicate.

    Returns Some(element) or nil.

    Example:
        find_last([1,2,3,4,3,2], \x: x > 2)  # Some(3)
    """
    var result = nil
    for item in arr:
        if predicate(item):
            result = Some(item)
    result

# ============================================================================
# Section 7: Array Generation
# ============================================================================

fn generate(n: i64, f: fn(i64)):
    """Generate array by applying function to indices.

    Example:
        generate(5, \i: i * i)  # [0, 1, 4, 9, 16]
    """
    var result = []
    var i = 0
    while i < n:
        result.push(f(i))
        i = i + 1
    result

fn range_step(start: i64, end: i64, step: i64) -> [i64]:
    """Generate range with custom step.

    Example:
        range_step(0, 10, 2)  # [0, 2, 4, 6, 8]
    """
    var result = []
    var i = start
    if step > 0:
        while i < end:
            result.push(i)
            i = i + step
    elif step < 0:
        while i > end:
            result.push(i)
            i = i + step
    result

# ============================================================================
# Section 8: Simple Memoization
# ============================================================================

fn memoize_simple(f: fn(i64) -> i64, max_cache: i64):
    """Simple memoization for i64 -> i64 functions.

    Returns a new function that caches results.
    Cache is a simple array of (input, output) pairs.
    Limited to max_cache entries.

    Note: This is a simplified version due to runtime limitations.

    Example:
        val fib = \n: if n <= 1: n else: fib(n-1) + fib(n-2)
        val memo_fib = memoize_simple(fib, 100)
        # (In practice, this won't work perfectly due to closure issues)
    """
    var cache = []

    fn memoized(x: i64) -> i64:
        # Check cache
        for (input, output) in cache:
            if input == x:
                return output

        # Compute and cache
        val result = f(x)

        if cache.len() < max_cache:
            cache.push((x, result))

        result

    memoized

export *
