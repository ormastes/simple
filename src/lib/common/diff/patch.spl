# Patch Generation and Application Module
# Create and apply patches to text

import diff.types
import diff.utilities

fn create_patch_from_diff(changes: list, file1: text, file2: text) -> tuple:
    # Create a patch from a diff
    val hunks = create_hunks(changes, 3)
    create_patch(file1, file2, hunks)

fn apply_patch(text: text, patch: tuple) -> text:
    # Apply a patch to text
    val lines = split_lines(text)
    val hunks = patch.hunks

    var offset = 0
    var i = 0
    while i < hunks.length():
        val hunk = hunks.get(i)
        val result_tuple = apply_hunk(lines, hunk, offset)
        val new_lines = result_tuple.lines
        offset = result_tuple.offset

        # Update lines reference
        lines.clear()
        var j = 0
        while j < new_lines.length():
            lines.append(new_lines.get(j))
            j = j + 1

        i = i + 1

    join_lines(lines)

fn apply_hunk(lines: list, hunk: tuple, offset: i64) -> tuple:
    # Apply a single hunk to lines
    val start = hunk.old_start + offset
    val changes = hunk.changes

    val new_lines = []
    var line_idx = 0

    # Copy lines before hunk
    while line_idx < start:
        new_lines.append(lines.get(line_idx))
        line_idx = line_idx + 1

    # Apply changes
    var change_offset = 0
    var i = 0
    while i < changes.length():
        val change = changes.get(i)
        val op = change.op

        if op == "equal":
            new_lines.append(change.content)
            line_idx = line_idx + 1
        else:
            if op == "delete":
                line_idx = line_idx + 1
                change_offset = change_offset - 1
            else:
                if op == "add":
                    new_lines.append(change.content)
                    change_offset = change_offset + 1
                else:
                    if op == "change":
                        new_lines.append(change.new_content)
                        line_idx = line_idx + 1

        i = i + 1

    # Copy remaining lines
    while line_idx < lines.length():
        new_lines.append(lines.get(line_idx))
        line_idx = line_idx + 1

    (lines: new_lines, offset: offset + change_offset)

# ============================================================================
# THREE-WAY MERGE
# ============================================================================

fn merge_three_way(base: text, left: text, right: text) -> tuple:
    # Perform three-way merge
    val base_lines = split_lines(base)
    val left_lines = split_lines(left)
    val right_lines = split_lines(right)

    val left_diff = myers_diff(base_lines, left_lines)
    val right_diff = myers_diff(base_lines, right_lines)

    val merged = merge_diffs(base_lines, left_diff, right_diff)
    merged

fn merge_diffs(base: list, left_diff: list, right_diff: list) -> tuple:
    # Merge two diffs against a common base
    val merged_lines = []
    val conflicts = []

    var base_idx = 0
    var left_idx = 0
    var right_idx = 0

    while base_idx < base.length() or left_idx < left_diff.length() or right_idx < right_diff.length():
        # Get current changes
        val left_change = if left_idx < left_diff.length(): left_diff.get(left_idx) else: nil
        val right_change = if right_idx < right_diff.length(): right_diff.get(right_idx) else: nil

        # Check if both changed the same line
        val both_changed = left_change != nil and right_change != nil

        if both_changed:
            val left_op = left_change.op
            val right_op = right_change.op

            val both_not_equal = left_op != "equal" and right_op != "equal"

            if both_not_equal:
                # Conflict
                conflicts.append((base_line: base_idx, left_change: left_change, right_change: right_change))
                merged_lines.append("<<<<<<< LEFT")
                merged_lines.append(left_change.content)
                merged_lines.append("=======")
                merged_lines.append(right_change.content)
                merged_lines.append(">>>>>>> RIGHT")

                left_idx = left_idx + 1
                right_idx = right_idx + 1
                base_idx = base_idx + 1
            else:
                # One or both are equal, take the changed one
                if left_op == "equal":
                    merged_lines.append(right_change.content)
                    right_idx = right_idx + 1
                else:
                    merged_lines.append(left_change.content)
                    left_idx = left_idx + 1

                base_idx = base_idx + 1
        else:
            # Only one side changed (or neither)
            if left_change != nil:
                merged_lines.append(left_change.content)
                left_idx = left_idx + 1
            else:
                if right_change != nil:
                    merged_lines.append(right_change.content)
                    right_idx = right_idx + 1
                else:
                    # Neither changed, copy from base
                    if base_idx < base.length():
                        merged_lines.append(base.get(base_idx))
                    base_idx = base_idx + 1

    val merged_text = join_lines(merged_lines)
    (merged: merged_text, conflicts: conflicts, has_conflicts: conflicts.length() > 0)

fn detect_conflicts(merge_result: tuple) -> list:
    # Extract conflict information from merge result
    merge_result.conflicts

# ============================================================================
# CHUNKING AND CONTEXT
# ============================================================================

fn create_hunks(changes: list, context_lines: i64) -> list:
    # Group changes into hunks with context
    val hunks = []
    var current_changes = []
    var old_start = -1
    var new_start = -1
    var old_count = 0
    var new_count = 0
    var context_before = 0

    var i = 0
    while i < changes.length():
        val change = changes.get(i)
        val op = change.op

        if op == "equal":
            if current_changes.length() == 0:
                # Before any changes, skip or save as context
                context_before = context_before + 1
            else:
                # After changes, might be context or new hunk
                current_changes.append(change)
                old_count = old_count + 1
                new_count = new_count + 1
                context_before = 0
        else:
            # Start new hunk if needed
            if current_changes.length() == 0:
                if op == "delete":
                    old_start = change.old_line
                    new_start = change.new_line
                else:
                    old_start = change.old_line
                    new_start = change.new_line
                old_count = 0
                new_count = 0

            current_changes.append(change)

            if op == "delete":
                old_count = old_count + 1
            else:
                if op == "add":
                    new_count = new_count + 1
                else:
                    if op == "change":
                        old_count = old_count + 1
                        new_count = new_count + 1

            context_before = 0

        i = i + 1

    # Add last hunk
    if current_changes.length() > 0:
        hunks.append(create_hunk(current_changes, old_start, old_count, new_start, new_count))

    hunks

fn chunk_diff(changes: list, context_lines: i64) -> list:
    # Split diff into chunks with context
    create_hunks(changes, context_lines)

fn expand_context(hunk: tuple, additional_lines: i64) -> tuple:
    # Expand context of a hunk
    val old_start = hunk.old_start - additional_lines
    val new_start = hunk.new_start - additional_lines
    val old_count = hunk.old_count + (2 * additional_lines)
    val new_count = hunk.new_count + (2 * additional_lines)

    create_hunk(hunk.changes, old_start, old_count, new_start, new_count)

fn minimize_context(hunk: tuple) -> tuple:
    # Minimize context in hunk (remove leading/trailing equal lines)
    val changes = hunk.changes
    var start = 0
    var end = changes.length()

    # Find first non-equal
    while start < changes.length():
        val change = changes.get(start)
        if change.op != "equal":
            start = changes.length()
        else:
            start = start + 1

    # Find last non-equal
    while end > 0:
        val change = changes.get(end - 1)
        if change.op != "equal":
            end = 0
        else:
            end = end - 1

    # Extract minimized changes
    val min_changes = slice_list(changes, start, end)

    create_hunk(min_changes, hunk.old_start + start, end - start,
                hunk.new_start + start, end - start)

# Import dependencies
import diff.myers
