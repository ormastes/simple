# Myers Diff Algorithm Module
# O(ND) difference algorithm for optimal edit scripts

import diff.types

fn myers_diff(seq1: list, seq2: list) -> list:
    # Myers O(ND) difference algorithm - finds shortest edit script
    val n = seq1.length()
    val m = seq2.length()
    val max_d = n + m

    # V array stores furthest reaching paths
    val v = []
    var i = 0
    while i <= 2 * max_d + 1:
        v.append(0)
        i = i + 1

    val offset = max_d

    # Iterate through edit distances
    var d = 0
    while d <= max_d:
        var k = -d
        while k <= d:
            # Determine if we go down or right
            val k_offset = k + offset
            val left_offset = k - 1 + offset
            val right_offset = k + 1 + offset

            var x = 0
            if k == -d:
                x = v.get(right_offset)
            else:
                val cond1 = k == d
                if cond1:
                    x = v.get(left_offset) + 1
                else:
                    val left_val = v.get(left_offset)
                    val right_val = v.get(right_offset)
                    if left_val > right_val:
                        x = left_val + 1
                    else:
                        x = right_val

            var y = x - k

            # Follow diagonal
            while x < n and y < m and seq1.get(x) == seq2.get(y):
                x = x + 1
                y = y + 1

            v.set(k_offset, x)

            # Check if we reached the end
            if x >= n and y >= m:
                # Backtrack to construct diff
                return myers_backtrack(seq1, seq2, v, offset, d)

            k = k + 2
        d = d + 1

    # Fallback: return simple diff
    simple_diff(seq1, seq2)

fn myers_backtrack(seq1: list, seq2: list, v: list, offset: i64, d: i64) -> list:
    # Backtrack through Myers algorithm to construct diff
    val changes = []
    var x = seq1.length()
    var y = seq2.length()

    var curr_d = d
    while curr_d > 0 or x > 0 or y > 0:
        val k = x - y
        val k_offset = k + offset

        # Determine direction we came from
        var prev_k = k
        if curr_d == 0:
            if x > 0 and y > 0:
                changes.append(create_equal(seq1.get(x - 1), x - 1, y - 1))
                x = x - 1
                y = y - 1
            else:
                if x > 0:
                    changes.append(create_delete(seq1.get(x - 1), x - 1))
                    x = x - 1
                if y > 0:
                    changes.append(create_add(seq2.get(y - 1), y - 1))
                    y = y - 1
        else:
            val left_offset = k - 1 + offset
            val right_offset = k + 1 + offset

            # Check which direction we came from
            var came_from_left = false
            if k == -curr_d:
                came_from_left = false
            else:
                val cond1 = k == curr_d
                if cond1:
                    came_from_left = true
                else:
                    val left_val = v.get(left_offset)
                    val right_val = v.get(right_offset)
                    came_from_left = left_val > right_val

            if came_from_left:
                prev_k = k - 1
                if x > 0:
                    changes.append(create_delete(seq1.get(x - 1), x - 1))
                    x = x - 1
            else:
                prev_k = k + 1
                if y > 0:
                    changes.append(create_add(seq2.get(y - 1), y - 1))
                    y = y - 1

            curr_d = curr_d - 1

        # Follow diagonal backwards
        while x > 0 and y > 0 and seq1.get(x - 1) == seq2.get(y - 1):
            changes.append(create_equal(seq1.get(x - 1), x - 1, y - 1))
            x = x - 1
            y = y - 1

    changes.reverse()
    changes

# ============================================================================
# SIMPLE DIFF (Fallback using LCS)
# ============================================================================

fn simple_diff(seq1: list, seq2: list) -> list:
    # Simple diff using LCS
    val lcs_seq = lcs(seq1, seq2)
    val changes = []

    var i = 0
    var j = 0
    var k = 0

    while i < seq1.length() or j < seq2.length():
        if k < lcs_seq.length():
            val lcs_item = lcs_seq.get(k)

            # Check if current items match LCS
            val i_matches = i < seq1.length() and seq1.get(i) == lcs_item
            val j_matches = j < seq2.length() and seq2.get(j) == lcs_item

            if i_matches and j_matches:
                changes.append(create_equal(seq1.get(i), i, j))
                i = i + 1
                j = j + 1
                k = k + 1
            else:
                if i < seq1.length() and not i_matches:
                    changes.append(create_delete(seq1.get(i), i))
                    i = i + 1
                if j < seq2.length() and not j_matches:
                    changes.append(create_add(seq2.get(j), j))
                    j = j + 1
        else:
            # Past LCS, add remaining items
            if i < seq1.length():
                changes.append(create_delete(seq1.get(i), i))
                i = i + 1
            if j < seq2.length():
                changes.append(create_add(seq2.get(j), j))
                j = j + 1

    changes

# Import LCS from lcs module
import diff.lcs
