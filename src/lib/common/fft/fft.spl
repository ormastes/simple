# FFT Main Algorithm Module
# Fast Fourier Transform implementations (Radix-2 and Bluestein)

# ============================================================================
# Cooley-Tukey Radix-2 FFT
# ============================================================================

fn fft_radix2(data: [(f64, f64)]) -> [(f64, f64)]:
    val n = array_len(data)
    if n <= 1:
        data
    else:
        if not is_power_of_2(n):
            # Fall back to DFT for non-power-of-2
            dft(data)
        else:
            # Bit reversal permutation
            var x = bit_reversal_permutation(data)

            # Iterative FFT
            var size = 2
            while size <= n:
                val half_size = size / 2
                val twiddles = compute_twiddle_factors(size, false)

                var i = 0
                while i < n:
                    var k = 0
                    while k < half_size:
                        val idx1 = i + k
                        val idx2 = i + k + half_size
                        val t = complex_mul(array_get(twiddles, k), array_get(x, idx2))
                        val u = array_get(x, idx1)
                        val new1 = complex_add(u, t)
                        val new2 = complex_sub(u, t)
                        x = array_set(x, idx1, new1)
                        x = array_set(x, idx2, new2)
                        k = k + 1
                    i = i + size
                size = size * 2
            x

fn ifft_radix2(data: [(f64, f64)]) -> [(f64, f64)]:
    val n = array_len(data)
    if n <= 1:
        data
    else:
        if not is_power_of_2(n):
            # Fall back to IDFT for non-power-of-2
            idft(data)
        else:
            # Conjugate input
            var conjugated = []
            var i = 0
            while i < n:
                val c = complex_conjugate(array_get(data, i))
                conjugated = array_push(conjugated, c)
                i = i + 1

            # Apply FFT
            val fft_result = fft_radix2(conjugated)

            # Conjugate and scale output
            var result = []
            i = 0
            while i < n:
                val c = complex_conjugate(array_get(fft_result, i))
                val scaled = complex_scale(c, 1.0 / n as f64)
                result = array_push(result, scaled)
                i = i + 1
            result

# ============================================================================
# Bluestein's Algorithm (for any size)
# ============================================================================

fn bluestein_chirp(n: i64, k: i64, inverse: bool) -> (f64, f64):
    val sign = if inverse: 1.0 else: -1.0
    val angle = sign * math_pi() * k as f64 * k as f64 / n as f64
    complex_exp(angle)

fn bluestein_fft(data: [(f64, f64)]) -> [(f64, f64)]:
    val n = array_len(data)
    val m = next_power_of_2(2 * n - 1)

    # Compute chirp values and modulate input
    var a = []
    var i = 0
    while i < m:
        if i < n:
            val chirp = bluestein_chirp(n, i, false)
            val sample = array_get(data, i)
            val modulated = complex_mul(sample, complex_conjugate(chirp))
            a = array_push(a, modulated)
        else:
            a = array_push(a, (0.0, 0.0))
        i = i + 1

    # Compute chirp convolution kernel
    var b = []
    i = 0
    while i < m:
        if i < n:
            val chirp = bluestein_chirp(n, i, false)
            b = array_push(b, chirp)
        else:
            if i >= m - n + 1:
                val chirp = bluestein_chirp(n, m - i, false)
                b = array_push(b, chirp)
            else:
                b = array_push(b, (0.0, 0.0))
        i = i + 1

    # Convolve using FFT
    val fft_a = fft_radix2(a)
    val fft_b = fft_radix2(b)

    var product = []
    i = 0
    while i < m:
        val p = complex_mul(array_get(fft_a, i), array_get(fft_b, i))
        product = array_push(product, p)
        i = i + 1

    val convolution = ifft_radix2(product)

    # Demodulate output
    var result = []
    i = 0
    while i < n:
        val chirp = bluestein_chirp(n, i, false)
        val sample = array_get(convolution, i)
        val demodulated = complex_mul(sample, complex_conjugate(chirp))
        result = array_push(result, demodulated)
        i = i + 1
    result

fn bluestein_ifft(data: [(f64, f64)]) -> [(f64, f64)]:
    val n = array_len(data)

    # Conjugate input
    var conjugated = []
    var i = 0
    while i < n:
        val c = complex_conjugate(array_get(data, i))
        conjugated = array_push(conjugated, c)
        i = i + 1

    # Apply Bluestein FFT
    val fft_result = bluestein_fft(conjugated)

    # Conjugate and scale output
    var result = []
    i = 0
    while i < n:
        val c = complex_conjugate(array_get(fft_result, i))
        val scaled = complex_scale(c, 1.0 / n as f64)
        result = array_push(result, scaled)
        i = i + 1
    result

# ============================================================================
# Adaptive FFT (chooses best algorithm)
# ============================================================================

fn fft(data: [(f64, f64)]) -> [(f64, f64)]:
    val n = array_len(data)
    if n <= 1:
        data
    else:
        if is_power_of_2(n):
            fft_radix2(data)
        else:
            if n < 32:
                dft(data)
            else:
                bluestein_fft(data)

fn ifft(data: [(f64, f64)]) -> [(f64, f64)]:
    val n = array_len(data)
    if n <= 1:
        data
    else:
        if is_power_of_2(n):
            ifft_radix2(data)
        else:
            if n < 32:
                idft(data)
            else:
                bluestein_ifft(data)

# ============================================================================
# Real FFT (RFFT)
# ============================================================================

fn rfft(real_data: [f64]) -> [(f64, f64)]:
    val n = array_len(real_data)
    var complex_data = []
    var i = 0
    while i < n:
        val r = array_get(real_data, i)
        complex_data = array_push(complex_data, (r, 0.0))
        i = i + 1
    fft(complex_data)

fn irfft(complex_data: [(f64, f64)]) -> [f64]:
    val result = ifft(complex_data)
    var real_data = []
    var i = 0
    val n = array_len(result)
    while i < n:
        val c = array_get(result, i)
        real_data = array_push(real_data, c.0)
        i = i + 1
    real_data

# ============================================================================
# 2D FFT
# ============================================================================

fn fft2d(data: [[(f64, f64)]]) -> [[(f64, f64)]]:
    val rows = array_len(data)
    if rows == 0:
        []
    else:
        val cols = array_len(array_get(data, 0))

        # FFT on rows
        var row_fft = []
        var i = 0
        while i < rows:
            val row = array_get(data, i)
            val transformed = fft(row)
            row_fft = array_push(row_fft, transformed)
            i = i + 1

        # Transpose
        var transposed = []
        var j = 0
        while j < cols:
            var col = []
            i = 0
            while i < rows:
                val row = array_get(row_fft, i)
                val elem = array_get(row, j)
                col = array_push(col, elem)
                i = i + 1
            transposed = array_push(transposed, col)
            j = j + 1

        # FFT on columns (transposed rows)
        var col_fft = []
        i = 0
        while i < cols:
            val col = array_get(transposed, i)
            val transformed = fft(col)
            col_fft = array_push(col_fft, transformed)
            i = i + 1

        # Transpose back
        var result = []
        i = 0
        while i < rows:
            var row = []
            j = 0
            while j < cols:
                val col = array_get(col_fft, j)
                val elem = array_get(col, i)
                row = array_push(row, elem)
                j = j + 1
            result = array_push(result, row)
            i = i + 1
        result

fn ifft2d(data: [[(f64, f64)]]) -> [[(f64, f64)]]:
    val rows = array_len(data)
    if rows == 0:
        []
    else:
        val cols = array_len(array_get(data, 0))

        # IFFT on rows
        var row_ifft = []
        var i = 0
        while i < rows:
            val row = array_get(data, i)
            val transformed = ifft(row)
            row_ifft = array_push(row_ifft, transformed)
            i = i + 1

        # Transpose
        var transposed = []
        var j = 0
        while j < cols:
            var col = []
            i = 0
            while i < rows:
                val row = array_get(row_ifft, i)
                val elem = array_get(row, j)
                col = array_push(col, elem)
                i = i + 1
            transposed = array_push(transposed, col)
            j = j + 1

        # IFFT on columns (transposed rows)
        var col_ifft = []
        i = 0
        while i < cols:
            val col = array_get(transposed, i)
            val transformed = ifft(col)
            col_ifft = array_push(col_ifft, transformed)
            i = i + 1

        # Transpose back
        var result = []
        i = 0
        while i < rows:
            var row = []
            j = 0
            while j < cols:
                val col = array_get(col_ifft, j)
                val elem = array_get(col, i)
                row = array_push(row, elem)
                j = j + 1
            result = array_push(result, row)
            i = i + 1
        result
