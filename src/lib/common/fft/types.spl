# FFT Types Module
# Complex number operations and type definitions

# ============================================================================
# Complex Number Operations
# ============================================================================

# Complex number represented as (real, imag) tuple
fn complex_new(real: f64, imag: f64) -> (f64, f64):
    (real, imag)

fn complex_add(a: (f64, f64), b: (f64, f64)) -> (f64, f64):
    val a_real = a.0
    val a_imag = a.1
    val b_real = b.0
    val b_imag = b.1
    (a_real + b_real, a_imag + b_imag)

fn complex_sub(a: (f64, f64), b: (f64, f64)) -> (f64, f64):
    val a_real = a.0
    val a_imag = a.1
    val b_real = b.0
    val b_imag = b.1
    (a_real - b_real, a_imag - b_imag)

fn complex_mul(a: (f64, f64), b: (f64, f64)) -> (f64, f64):
    val a_real = a.0
    val a_imag = a.1
    val b_real = b.0
    val b_imag = b.1
    val real = a_real * b_real - a_imag * b_imag
    val imag = a_real * b_imag + a_imag * b_real
    (real, imag)

fn complex_div(a: (f64, f64), b: (f64, f64)) -> (f64, f64):
    val a_real = a.0
    val a_imag = a.1
    val b_real = b.0
    val b_imag = b.1
    val denom = b_real * b_real + b_imag * b_imag
    val real = (a_real * b_real + a_imag * b_imag) / denom
    val imag = (a_imag * b_real - a_real * b_imag) / denom
    (real, imag)

fn complex_conjugate(c: (f64, f64)) -> (f64, f64):
    val real = c.0
    val imag = c.1
    (real, -imag)

fn complex_magnitude(c: (f64, f64)) -> f64:
    val real = c.0
    val imag = c.1
    math_sqrt(real * real + imag * imag)

fn complex_magnitude_squared(c: (f64, f64)) -> f64:
    val real = c.0
    val imag = c.1
    real * real + imag * imag

fn complex_phase(c: (f64, f64)) -> f64:
    val real = c.0
    val imag = c.1
    math_atan2(imag, real)

fn complex_exp(theta: f64) -> (f64, f64):
    # e^(i*theta) = cos(theta) + i*sin(theta)
    val real = math_cos(theta)
    val imag = math_sin(theta)
    (real, imag)

fn complex_scale(c: (f64, f64), s: f64) -> (f64, f64):
    val real = c.0
    val imag = c.1
    (real * s, imag * s)

fn complex_negate(c: (f64, f64)) -> (f64, f64):
    val real = c.0
    val imag = c.1
    (-real, -imag)

fn complex_real(c: (f64, f64)) -> f64:
    c.0

fn complex_imag(c: (f64, f64)) -> f64:
    c.1
