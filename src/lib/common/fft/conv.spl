# FFT Convolution Module
# Convolution and correlation using FFT

# ============================================================================
# Convolution and Correlation
# ============================================================================

fn convolve_fft(signal1: [f64], signal2: [f64]) -> [f64]:
    val n1 = array_len(signal1)
    val n2 = array_len(signal2)
    val n = next_power_of_2(n1 + n2 - 1)

    # Zero pad both signals
    var padded1 = []
    var i = 0
    while i < n:
        if i < n1:
            val r = array_get(signal1, i)
            padded1 = array_push(padded1, (r, 0.0))
        else:
            padded1 = array_push(padded1, (0.0, 0.0))
        i = i + 1

    var padded2 = []
    i = 0
    while i < n:
        if i < n2:
            val r = array_get(signal2, i)
            padded2 = array_push(padded2, (r, 0.0))
        else:
            padded2 = array_push(padded2, (0.0, 0.0))
        i = i + 1

    # FFT both signals
    val fft1 = fft(padded1)
    val fft2 = fft(padded2)

    # Multiply in frequency domain
    var product = []
    i = 0
    while i < n:
        val p = complex_mul(array_get(fft1, i), array_get(fft2, i))
        product = array_push(product, p)
        i = i + 1

    # IFFT to get convolution
    val conv_complex = ifft(product)

    # Extract real part
    var result = []
    i = 0
    while i < n1 + n2 - 1:
        val c = array_get(conv_complex, i)
        result = array_push(result, c.0)
        i = i + 1
    result

fn correlate_fft(signal1: [f64], signal2: [f64]) -> [f64]:
    val n1 = array_len(signal1)
    val n2 = array_len(signal2)
    val n = next_power_of_2(n1 + n2 - 1)

    # Zero pad both signals
    var padded1 = []
    var i = 0
    while i < n:
        if i < n1:
            val r = array_get(signal1, i)
            padded1 = array_push(padded1, (r, 0.0))
        else:
            padded1 = array_push(padded1, (0.0, 0.0))
        i = i + 1

    var padded2 = []
    i = 0
    while i < n:
        if i < n2:
            val r = array_get(signal2, i)
            padded2 = array_push(padded2, (r, 0.0))
        else:
            padded2 = array_push(padded2, (0.0, 0.0))
        i = i + 1

    # FFT both signals
    val fft1 = fft(padded1)
    val fft2 = fft(padded2)

    # Multiply first by conjugate of second
    var product = []
    i = 0
    while i < n:
        val f1 = array_get(fft1, i)
        val f2_conj = complex_conjugate(array_get(fft2, i))
        val p = complex_mul(f1, f2_conj)
        product = array_push(product, p)
        i = i + 1

    # IFFT to get correlation
    val corr_complex = ifft(product)

    # Extract real part
    var result = []
    i = 0
    while i < n1 + n2 - 1:
        val c = array_get(corr_complex, i)
        result = array_push(result, c.0)
        i = i + 1
    result

# ============================================================================
# Frequency Domain Filtering
# ============================================================================

fn lowpass_filter_fft(signal: [f64], cutoff_bin: i64) -> [f64]:
    val complex_signal = real_to_complex(signal)
    val fft_result = fft(complex_signal)
    val n = array_len(fft_result)

    # Zero out high frequencies
    var filtered = []
    var i = 0
    while i < n:
        if i <= cutoff_bin or i >= n - cutoff_bin:
            filtered = array_push(filtered, array_get(fft_result, i))
        else:
            filtered = array_push(filtered, (0.0, 0.0))
        i = i + 1

    val ifft_result = ifft(filtered)
    complex_to_real(ifft_result)

fn highpass_filter_fft(signal: [f64], cutoff_bin: i64) -> [f64]:
    val complex_signal = real_to_complex(signal)
    val fft_result = fft(complex_signal)
    val n = array_len(fft_result)

    # Zero out low frequencies
    var filtered = []
    var i = 0
    while i < n:
        if i > cutoff_bin and i < n - cutoff_bin:
            filtered = array_push(filtered, array_get(fft_result, i))
        else:
            filtered = array_push(filtered, (0.0, 0.0))
        i = i + 1

    val ifft_result = ifft(filtered)
    complex_to_real(ifft_result)

fn bandpass_filter_fft(signal: [f64], low_bin: i64, high_bin: i64) -> [f64]:
    val complex_signal = real_to_complex(signal)
    val fft_result = fft(complex_signal)
    val n = array_len(fft_result)

    # Zero out frequencies outside band
    var filtered = []
    var i = 0
    while i < n:
        val in_low_band = i >= low_bin and i <= high_bin
        val in_high_band = i >= n - high_bin and i <= n - low_bin
        if in_low_band or in_high_band:
            filtered = array_push(filtered, array_get(fft_result, i))
        else:
            filtered = array_push(filtered, (0.0, 0.0))
        i = i + 1

    val ifft_result = ifft(filtered)
    complex_to_real(ifft_result)
