# B-Tree Types and Data Structures
#
# Purpose: Core B-tree data structures and property accessors
#
# Contains:
# - Node and tree creation functions
# - Property getters and setters (immutable updates)
# - Node capacity checking functions
# - List helper functions

# ============================================================================
# Data Structures (Tuple-based)
# ============================================================================

# BTreeNode: Represents a node in the B-tree
# Structure: (keys: list, children: list, is_leaf: bool, n: i64, t: i64)
# - keys: List of keys stored in this node (sorted)
# - children: List of child nodes (for internal nodes)
# - is_leaf: True if this is a leaf node
# - n: Current number of keys in this node
# - t: Minimum degree (tree parameter)

# BTree: Represents the complete B-tree
# Structure: (root: node, t: i64, height: i64)
# - root: Root node of the tree
# - t: Minimum degree
# - height: Height of the tree

# ============================================================================
# Node Creation Functions
# ============================================================================

# Create an empty B-tree node
# Parameters:
#   t: Minimum degree
#   is_leaf: True if this should be a leaf node
# Returns: New node tuple (keys, children, is_leaf, n, t)
fn create_node(t, is_leaf):
    val keys = []
    val children = []
    val n = 0
    (keys, children, is_leaf, n, t)

# Create an empty root node
fn create_empty_node(t):
    create_node(t, true)

# Create a new B-tree with minimum degree t
# Parameters:
#   t: Minimum degree (must be >= 2)
# Returns: New B-tree tuple (root, t, height)
fn create_btree(t):
    val root = create_empty_node(t)
    val height = 0
    (root, t, height)

# ============================================================================
# Node Property Functions
# ============================================================================

# Get keys from a node
fn node_keys(node):
    val keys = node.0
    keys

# Get children from a node
fn node_children(node):
    val children = node.1
    children

# Check if node is a leaf
fn node_is_leaf(node):
    val is_leaf = node.2
    is_leaf

# Get number of keys in node
fn node_n(node):
    val n = node.3
    n

# Get minimum degree from node
fn node_t(node):
    val t = node.4
    t

# Set keys in a node (returns new node)
fn node_set_keys(node, keys):
    val children = node_children(node)
    val is_leaf = node_is_leaf(node)
    val n = node_n(node)
    val t = node_t(node)
    (keys, children, is_leaf, n, t)

# Set children in a node (returns new node)
fn node_set_children(node, children):
    val keys = node_keys(node)
    val is_leaf = node_is_leaf(node)
    val n = node_n(node)
    val t = node_t(node)
    (keys, children, is_leaf, n, t)

# Set n (key count) in a node (returns new node)
fn node_set_n(node, new_n):
    val keys = node_keys(node)
    val children = node_children(node)
    val is_leaf = node_is_leaf(node)
    val t = node_t(node)
    (keys, children, is_leaf, new_n, t)

# Set is_leaf flag in a node (returns new node)
fn node_set_is_leaf(node, new_is_leaf):
    val keys = node_keys(node)
    val children = node_children(node)
    val n = node_n(node)
    val t = node_t(node)
    (keys, children, new_is_leaf, n, t)

# ============================================================================
# Tree Property Functions
# ============================================================================

# Get root from tree
fn tree_root(tree):
    val root = tree.0
    root

# Get minimum degree from tree
fn tree_t(tree):
    val t = tree.1
    t

# Get height from tree
fn tree_height(tree):
    val height = tree.2
    height

# Set root in tree (returns new tree)
fn tree_set_root(tree, root):
    val t = tree_t(tree)
    val height = tree_height(tree)
    (root, t, height)

# Set height in tree (returns new tree)
fn tree_set_height(tree, height):
    val root = tree_root(tree)
    val t = tree_t(tree)
    (root, t, height)

# ============================================================================
# Node Capacity Functions
# ============================================================================

# Check if a node is full (has 2t-1 keys)
# A full node must be split before insertion
fn is_full(node):
    val n = node_n(node)
    val t = node_t(node)
    val max_keys = (2 * t) - 1
    n == max_keys

# Check if a node has minimum keys (t-1)
fn is_minimal(node):
    val n = node_n(node)
    val t = node_t(node)
    val min_keys = t - 1
    n == min_keys

# Check if a node can donate a key (has > t-1 keys)
fn can_donate(node):
    val n = node_n(node)
    val t = node_t(node)
    val min_keys = t - 1
    n > min_keys

# Get maximum number of keys for a node
fn max_keys(t):
    (2 * t) - 1

# Get minimum number of keys for a non-root node
fn min_keys(t):
    t - 1

# Get maximum number of children for a node
fn max_children(t):
    2 * t

# Get minimum number of children for a non-root internal node
fn min_children(t):
    t

# ============================================================================
# List Helper Functions
# ============================================================================

# Append element to list
fn list_append(lst, elem):
    var result = []
    val len = list_length(lst)
    for i in 0..len:
        val item = lst.i
        result = result + [item]
    result = result + [elem]
    result

# Concatenate two lists
fn list_concat(lst1, lst2):
    var result = lst1
    val len = list_length(lst2)
    for i in 0..len:
        val item = lst2.i
        result = result + [item]
    result

# Get length of list
fn list_length(lst):
    var count = 0
    for item in lst:
        count = count + 1
    count

export *
