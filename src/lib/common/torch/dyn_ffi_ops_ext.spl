# Torch Dynamic FFI â€” Extended Operations
#
# Extended dyn_torch_* functions split from dyn_ffi_ops.spl.
# Contains: fixed-dimension tensor creation (zeros/ones/randn/rand/empty/full),
#           fixed-dimension shape ops (reshape/view/permute), fixed-count cat/stack,
#           shape query, NN ops with fixed arrays, trigonometric functions,
#           integer tensor creation, tensor serialization, and safetensors loading.
#
# See dyn_ffi_ops.spl for core operations (library info, arithmetic, activations,
# autograd, reductions returning f64, loss functions, f64-input ops).
# See dyn_ffi.spl for infrastructure (call helpers, extern decls, constants).

use std.common.torch.dyn_ffi.{
    spl_f64_to_bits,
    spl_str_ptr,
    rt_cstring_to_text,
    _call0,
    _call1,
    _call2,
    _call3,
    _call_n
}

# ============================================================================
# P2: Fixed-dimension Tensor Creation
# ============================================================================

# --- zeros ---
fn dyn_torch_tensor_zeros_1d(d0: i64) -> i64:
    _call1("rt_torch_tensor_zeros_1d", d0)
fn dyn_torch_tensor_zeros_2d(d0: i64, d1: i64) -> i64:
    _call2("rt_torch_tensor_zeros_2d", d0, d1)
fn dyn_torch_tensor_zeros_3d(d0: i64, d1: i64, d2: i64) -> i64:
    _call3("rt_torch_tensor_zeros_3d", d0, d1, d2)
fn dyn_torch_tensor_zeros_4d(d0: i64, d1: i64, d2: i64, d3: i64) -> i64:
    _call_n("rt_torch_tensor_zeros_4d", [d0, d1, d2, d3])

# --- ones ---
fn dyn_torch_tensor_ones_1d(d0: i64) -> i64:
    _call1("rt_torch_tensor_ones_1d", d0)
fn dyn_torch_tensor_ones_2d(d0: i64, d1: i64) -> i64:
    _call2("rt_torch_tensor_ones_2d", d0, d1)
fn dyn_torch_tensor_ones_3d(d0: i64, d1: i64, d2: i64) -> i64:
    _call3("rt_torch_tensor_ones_3d", d0, d1, d2)
fn dyn_torch_tensor_ones_4d(d0: i64, d1: i64, d2: i64, d3: i64) -> i64:
    _call_n("rt_torch_tensor_ones_4d", [d0, d1, d2, d3])

# --- randn ---
fn dyn_torch_tensor_randn_1d(d0: i64) -> i64:
    _call1("rt_torch_tensor_randn_1d", d0)
fn dyn_torch_tensor_randn_2d(d0: i64, d1: i64) -> i64:
    _call2("rt_torch_tensor_randn_2d", d0, d1)
fn dyn_torch_tensor_randn_3d(d0: i64, d1: i64, d2: i64) -> i64:
    _call3("rt_torch_tensor_randn_3d", d0, d1, d2)
fn dyn_torch_tensor_randn_4d(d0: i64, d1: i64, d2: i64, d3: i64) -> i64:
    _call_n("rt_torch_tensor_randn_4d", [d0, d1, d2, d3])

# --- rand ---
fn dyn_torch_tensor_rand_1d(d0: i64) -> i64:
    _call1("rt_torch_tensor_rand_1d", d0)
fn dyn_torch_tensor_rand_2d(d0: i64, d1: i64) -> i64:
    _call2("rt_torch_tensor_rand_2d", d0, d1)
fn dyn_torch_tensor_rand_3d(d0: i64, d1: i64, d2: i64) -> i64:
    _call3("rt_torch_tensor_rand_3d", d0, d1, d2)
fn dyn_torch_tensor_rand_4d(d0: i64, d1: i64, d2: i64, d3: i64) -> i64:
    _call_n("rt_torch_tensor_rand_4d", [d0, d1, d2, d3])

# --- empty ---
fn dyn_torch_tensor_empty_1d(d0: i64) -> i64:
    _call1("rt_torch_tensor_empty_1d", d0)
fn dyn_torch_tensor_empty_2d(d0: i64, d1: i64) -> i64:
    _call2("rt_torch_tensor_empty_2d", d0, d1)
fn dyn_torch_tensor_empty_3d(d0: i64, d1: i64, d2: i64) -> i64:
    _call3("rt_torch_tensor_empty_3d", d0, d1, d2)
fn dyn_torch_tensor_empty_4d(d0: i64, d1: i64, d2: i64, d3: i64) -> i64:
    _call_n("rt_torch_tensor_empty_4d", [d0, d1, d2, d3])

# --- full (value is f64, bit-cast via spl_f64_to_bits) ---
fn dyn_torch_tensor_full_1d(d0: i64, value: f64) -> i64:
    _call2("rt_torch_tensor_full_1d", d0, spl_f64_to_bits(value))
fn dyn_torch_tensor_full_2d(d0: i64, d1: i64, value: f64) -> i64:
    _call3("rt_torch_tensor_full_2d", d0, d1, spl_f64_to_bits(value))
fn dyn_torch_tensor_full_3d(d0: i64, d1: i64, d2: i64, value: f64) -> i64:
    _call_n("rt_torch_tensor_full_3d", [d0, d1, d2, spl_f64_to_bits(value)])
fn dyn_torch_tensor_full_4d(d0: i64, d1: i64, d2: i64, d3: i64, value: f64) -> i64:
    _call_n("rt_torch_tensor_full_4d", [d0, d1, d2, d3, spl_f64_to_bits(value)])

# ============================================================================
# P2: Fixed-dimension Shape Operations
# ============================================================================

# --- reshape ---
fn dyn_torch_tensor_reshape_1d(handle: i64, d0: i64) -> i64:
    _call2("rt_torch_torchtensor_reshape_1d", handle, d0)
fn dyn_torch_tensor_reshape_2d(handle: i64, d0: i64, d1: i64) -> i64:
    _call3("rt_torch_torchtensor_reshape_2d", handle, d0, d1)
fn dyn_torch_tensor_reshape_3d(handle: i64, d0: i64, d1: i64, d2: i64) -> i64:
    _call_n("rt_torch_torchtensor_reshape_3d", [handle, d0, d1, d2])
fn dyn_torch_tensor_reshape_4d(handle: i64, d0: i64, d1: i64, d2: i64, d3: i64) -> i64:
    _call_n("rt_torch_torchtensor_reshape_4d", [handle, d0, d1, d2, d3])

# --- view ---
fn dyn_torch_tensor_view_1d(handle: i64, d0: i64) -> i64:
    _call2("rt_torch_torchtensor_view_1d", handle, d0)
fn dyn_torch_tensor_view_2d(handle: i64, d0: i64, d1: i64) -> i64:
    _call3("rt_torch_torchtensor_view_2d", handle, d0, d1)
fn dyn_torch_tensor_view_3d(handle: i64, d0: i64, d1: i64, d2: i64) -> i64:
    _call_n("rt_torch_torchtensor_view_3d", [handle, d0, d1, d2])
fn dyn_torch_tensor_view_4d(handle: i64, d0: i64, d1: i64, d2: i64, d3: i64) -> i64:
    _call_n("rt_torch_torchtensor_view_4d", [handle, d0, d1, d2, d3])

# --- permute ---
fn dyn_torch_tensor_permute_2d(handle: i64, d0: i64, d1: i64) -> i64:
    _call3("rt_torch_torchtensor_permute_2d", handle, d0, d1)
fn dyn_torch_tensor_permute_3d(handle: i64, d0: i64, d1: i64, d2: i64) -> i64:
    _call_n("rt_torch_torchtensor_permute_3d", [handle, d0, d1, d2])
fn dyn_torch_tensor_permute_4d(handle: i64, d0: i64, d1: i64, d2: i64, d3: i64) -> i64:
    _call_n("rt_torch_torchtensor_permute_4d", [handle, d0, d1, d2, d3])

# ============================================================================
# P2: Fixed-count Cat/Stack
# ============================================================================

# --- cat (concatenate tensors along dimension) ---
fn dyn_torch_tensor_cat_2(t0: i64, t1: i64, dim: i64) -> i64:
    _call3("rt_torch_torchtensor_cat_2", t0, t1, dim)
fn dyn_torch_tensor_cat_3(t0: i64, t1: i64, t2: i64, dim: i64) -> i64:
    _call_n("rt_torch_torchtensor_cat_3", [t0, t1, t2, dim])
fn dyn_torch_tensor_cat_4(t0: i64, t1: i64, t2: i64, t3: i64, dim: i64) -> i64:
    _call_n("rt_torch_torchtensor_cat_4", [t0, t1, t2, t3, dim])

# --- stack (stack tensors along new dimension) ---
fn dyn_torch_tensor_stack_2(t0: i64, t1: i64, dim: i64) -> i64:
    _call3("rt_torch_torchtensor_stack_2", t0, t1, dim)
fn dyn_torch_tensor_stack_3(t0: i64, t1: i64, t2: i64, dim: i64) -> i64:
    _call_n("rt_torch_torchtensor_stack_3", [t0, t1, t2, dim])
fn dyn_torch_tensor_stack_4(t0: i64, t1: i64, t2: i64, t3: i64, dim: i64) -> i64:
    _call_n("rt_torch_torchtensor_stack_4", [t0, t1, t2, t3, dim])

# ============================================================================
# P2: Shape Query
# ============================================================================

# Get the size of a specific dimension (returns -1 if dim_idx out of range)
fn dyn_torch_tensor_shape_dim(handle: i64, dim_idx: i64) -> i64:
    _call2("rt_torch_torchtensor_shape_dim", handle, dim_idx)

# ============================================================================
# P2: NN Operations with fixed arrays + f64 bit-cast
# ============================================================================

# Batch normalization (all scalar: momentum and eps are f64 bit-cast)
fn dyn_torch_nn_batch_norm(input: i64, running_mean: i64, running_var: i64, weight: i64, bias: i64, training: bool, momentum: f64, eps: f64) -> i64:
    var t = 0
    if training:
        t = 1
    _call_n("rt_torch_nn_batch_norm_bits", [input, running_mean, running_var, weight, bias, t, spl_f64_to_bits(momentum), spl_f64_to_bits(eps)])

# Layer normalization (1D normalized shape + f64 eps)
fn dyn_torch_nn_layer_norm_1d(input: i64, norm_d0: i64, weight: i64, bias: i64, eps: f64) -> i64:
    _call_n("rt_torch_nn_layer_norm_1d", [input, norm_d0, weight, bias, spl_f64_to_bits(eps)])

# Layer normalization (2D normalized shape + f64 eps)
fn dyn_torch_nn_layer_norm_2d(input: i64, norm_d0: i64, norm_d1: i64, weight: i64, bias: i64, eps: f64) -> i64:
    _call_n("rt_torch_nn_layer_norm_2d", [input, norm_d0, norm_d1, weight, bias, spl_f64_to_bits(eps)])

# Conv2d with explicit stride/padding/dilation (2D each)
fn dyn_torch_nn_conv2d(input: i64, weight: i64, bias: i64, stride_h: i64, stride_w: i64, pad_h: i64, pad_w: i64, dil_h: i64, dil_w: i64, groups: i64) -> i64:
    _call_n("rt_torch_nn_conv2d_simple", [input, weight, bias, stride_h, stride_w, pad_h, pad_w, dil_h, dil_w, groups])

# Max pooling 2D (kernel_size, stride, padding as h,w pairs)
fn dyn_torch_nn_max_pool2d(input: i64, kh: i64, kw: i64, sh: i64, sw: i64, ph: i64, pw: i64) -> i64:
    _call_n("rt_torch_nn_max_pool2d_simple", [input, kh, kw, sh, sw, ph, pw])

# Average pooling 2D (kernel_size, stride, padding as h,w pairs)
fn dyn_torch_nn_avg_pool2d(input: i64, kh: i64, kw: i64, sh: i64, sw: i64, ph: i64, pw: i64) -> i64:
    _call_n("rt_torch_nn_avg_pool2d_simple", [input, kh, kw, sh, sw, ph, pw])

# ============================================================================
# Trigonometric Functions (Group 1)
# ============================================================================

# Element-wise sine
fn dyn_torch_tensor_sin(handle: i64) -> i64:
    _call1("rt_torch_torchtensor_sin", handle)

# Element-wise cosine
fn dyn_torch_tensor_cos(handle: i64) -> i64:
    _call1("rt_torch_torchtensor_cos", handle)

# Element-wise tangent
fn dyn_torch_tensor_tan(handle: i64) -> i64:
    _call1("rt_torch_torchtensor_tan", handle)

# Element-wise arc sine
fn dyn_torch_tensor_asin(handle: i64) -> i64:
    _call1("rt_torch_torchtensor_asin", handle)

# Element-wise arc cosine
fn dyn_torch_tensor_acos(handle: i64) -> i64:
    _call1("rt_torch_torchtensor_acos", handle)

# Element-wise atan2(y, x)
fn dyn_torch_tensor_atan2(handle: i64, other: i64) -> i64:
    _call2("rt_torch_torchtensor_atan2", handle, other)

# ============================================================================
# Integer Tensor Creation (Group 2)
# ============================================================================

# Create int64 arange tensor
fn dyn_torch_tensor_arange_int(start: i64, end_val: i64, step: i64) -> i64:
    _call3("rt_torch_tensor_arange_int", start, end_val, step)

# Create int64 zeros (1D)
fn dyn_torch_tensor_zeros_int_1d(d0: i64) -> i64:
    _call1("rt_torch_tensor_zeros_int_1d", d0)

# Create int64 zeros (2D)
fn dyn_torch_tensor_zeros_int_2d(d0: i64, d1: i64) -> i64:
    _call2("rt_torch_tensor_zeros_int_2d", d0, d1)

# Create int64 ones (1D)
fn dyn_torch_tensor_ones_int_1d(d0: i64) -> i64:
    _call1("rt_torch_tensor_ones_int_1d", d0)

# Create int64 ones (2D)
fn dyn_torch_tensor_ones_int_2d(d0: i64, d1: i64) -> i64:
    _call2("rt_torch_tensor_ones_int_2d", d0, d1)

# Create int64 full (1D)
fn dyn_torch_tensor_full_int_1d(d0: i64, value: i64) -> i64:
    _call2("rt_torch_tensor_full_int_1d", d0, value)

# Create int64 full (2D)
fn dyn_torch_tensor_full_int_2d(d0: i64, d1: i64, value: i64) -> i64:
    _call3("rt_torch_tensor_full_int_2d", d0, d1, value)

# Cast tensor to float64
fn dyn_torch_tensor_to_float(handle: i64) -> i64:
    _call1("rt_torch_torchtensor_to_float", handle)

# Cast tensor to int64
fn dyn_torch_tensor_to_int(handle: i64) -> i64:
    _call1("rt_torch_torchtensor_to_int", handle)

# Cast tensor to float32
fn dyn_torch_tensor_to_float32(handle: i64) -> i64:
    _call1("rt_torch_torchtensor_to_float32", handle)

# ============================================================================
# Tensor Serialization (Group 3)
# ============================================================================

# Save tensor to file (path via string pointer)
fn dyn_torch_tensor_save(handle: i64, path: text):
    _call2("rt_torch_tensor_save_dyn", handle, spl_str_ptr(path))

# Load tensor from file (path via string pointer)
fn dyn_torch_tensor_load(path: text) -> i64:
    _call1("rt_torch_tensor_load_dyn", spl_str_ptr(path))

# ============================================================================
# Safetensors Loading (Group 4)
# ============================================================================

# Open safetensors file
fn dyn_torch_safetensors_open(path: text) -> i64:
    _call1("rt_torch_safetensors_open_dyn", spl_str_ptr(path))

# Close safetensors file
fn dyn_torch_safetensors_close(handle: i64):
    _call1("rt_torch_safetensors_close_dyn", handle)

# Get number of tensors
fn dyn_torch_safetensors_num_tensors(handle: i64) -> i64:
    _call1("rt_torch_safetensors_num_tensors_dyn", handle)

# List tensor names (newline-delimited)
fn dyn_torch_safetensors_list_names(handle: i64) -> text:
    val ptr = _call1("rt_torch_safetensors_list_names_dyn", handle)
    rt_cstring_to_text(ptr)

# Get tensor by name
fn dyn_torch_safetensors_get_tensor(sf_handle: i64, name: text) -> i64:
    _call2("rt_torch_safetensors_get_tensor_dyn", sf_handle, spl_str_ptr(name))

# ============================================================================
# Exports
# ============================================================================

# P2: tensor creation (fixed-dim)
export dyn_torch_tensor_zeros_1d, dyn_torch_tensor_zeros_2d
export dyn_torch_tensor_zeros_3d, dyn_torch_tensor_zeros_4d
export dyn_torch_tensor_ones_1d, dyn_torch_tensor_ones_2d
export dyn_torch_tensor_ones_3d, dyn_torch_tensor_ones_4d
export dyn_torch_tensor_randn_1d, dyn_torch_tensor_randn_2d
export dyn_torch_tensor_randn_3d, dyn_torch_tensor_randn_4d
export dyn_torch_tensor_rand_1d, dyn_torch_tensor_rand_2d
export dyn_torch_tensor_rand_3d, dyn_torch_tensor_rand_4d
export dyn_torch_tensor_empty_1d, dyn_torch_tensor_empty_2d
export dyn_torch_tensor_empty_3d, dyn_torch_tensor_empty_4d
export dyn_torch_tensor_full_1d, dyn_torch_tensor_full_2d
export dyn_torch_tensor_full_3d, dyn_torch_tensor_full_4d
# P2: shape ops (fixed-dim)
export dyn_torch_tensor_reshape_1d, dyn_torch_tensor_reshape_2d
export dyn_torch_tensor_reshape_3d, dyn_torch_tensor_reshape_4d
export dyn_torch_tensor_view_1d, dyn_torch_tensor_view_2d
export dyn_torch_tensor_view_3d, dyn_torch_tensor_view_4d
export dyn_torch_tensor_permute_2d, dyn_torch_tensor_permute_3d, dyn_torch_tensor_permute_4d
# P2: cat/stack (fixed count)
export dyn_torch_tensor_cat_2, dyn_torch_tensor_cat_3, dyn_torch_tensor_cat_4
export dyn_torch_tensor_stack_2, dyn_torch_tensor_stack_3, dyn_torch_tensor_stack_4
# P2: shape query
export dyn_torch_tensor_shape_dim
# P2: NN ops (fixed arrays)
export dyn_torch_nn_batch_norm
export dyn_torch_nn_layer_norm_1d, dyn_torch_nn_layer_norm_2d
export dyn_torch_nn_conv2d, dyn_torch_nn_max_pool2d, dyn_torch_nn_avg_pool2d
# Trigonometric functions (Group 1)
export dyn_torch_tensor_sin, dyn_torch_tensor_cos, dyn_torch_tensor_tan
export dyn_torch_tensor_asin, dyn_torch_tensor_acos, dyn_torch_tensor_atan2
# Integer tensor creation (Group 2)
export dyn_torch_tensor_arange_int
export dyn_torch_tensor_zeros_int_1d, dyn_torch_tensor_zeros_int_2d
export dyn_torch_tensor_ones_int_1d, dyn_torch_tensor_ones_int_2d
export dyn_torch_tensor_full_int_1d, dyn_torch_tensor_full_int_2d
export dyn_torch_tensor_to_float, dyn_torch_tensor_to_int, dyn_torch_tensor_to_float32
# Tensor serialization (Group 3)
export dyn_torch_tensor_save, dyn_torch_tensor_load
# Safetensors loading (Group 4)
export dyn_torch_safetensors_open, dyn_torch_safetensors_close
export dyn_torch_safetensors_num_tensors, dyn_torch_safetensors_list_names
export dyn_torch_safetensors_get_tensor
