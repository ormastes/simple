# Map Utility Functions

fn map_merge(map1, map2):
    """Merge two maps. Values from map2 override map1 for duplicate keys.

    Example:
        val m1 = map_put(map_create(), "x", 1)
        val m2 = map_put(map_create(), "y", 2)
        val m3 = map_merge(m1, m2)
        map_size(m3)  # 2
    """
    var result = map1
    var i = 0
    while i < map2.len():
        val entry = map2[i]
        result = map_put(result, entry[0], entry[1])
        i = i + 1
    result

fn map_merge_with(map1, map2, merge_fn):
    """Merge two maps using function to resolve conflicts.

    merge_fn receives (key, value1, value2) and returns merged value.

    Example:
        val m1 = map_put(map_create(), "x", 1)
        val m2 = map_put(map_create(), "x", 2)
        val m3 = map_merge_with(m1, m2, \k, v1, v2: v1 + v2)
        map_get(m3, "x")  # 3
    """
    var result = map1
    var i = 0
    while i < map2.len():
        val entry = map2[i]
        val key = entry[0]
        val value2 = entry[1]

        val existing = map_get(map1, key)
        if existing == nil:
            result = map_put(result, key, value2)
        else:
            val merged = merge_fn(key, existing, value2)
            result = map_put(result, key, merged)
        i = i + 1
    result

fn map_merge_all(maps):
    """Merge multiple maps. Later maps override earlier ones.

    Example:
        val m1 = map_put(map_create(), "x", 1)
        val m2 = map_put(map_create(), "y", 2)
        val m3 = map_merge_all([m1, m2])
        map_size(m3)  # 2
    """
    var result = map_create()
    var i = 0
    while i < maps.len():
        result = map_merge(result, maps[i])
        i = i + 1
    result

fn map_difference(map1, map2):
    """Get entries in map1 whose keys are not in map2.

    Example:
        val m1 = map_put(map_put(map_create(), "x", 1), "y", 2)
        val m2 = map_put(map_create(), "y", 3)
        val m3 = map_difference(m1, m2)
        map_size(m3)  # 1
        map_get(m3, "x")  # 1
    """
    var result = []
    var i = 0
    while i < map1.len():
        val entry = map1[i]
        if not map_contains_key(map2, entry[0]):
            result.push(entry)
        i = i + 1
    result

fn map_intersection(map1, map2):
    """Get entries whose keys exist in both maps. Uses values from map1.

    Example:
        val m1 = map_put(map_put(map_create(), "x", 1), "y", 2)
        val m2 = map_put(map_create(), "y", 3)
        val m3 = map_intersection(m1, m2)
        map_size(m3)  # 1
        map_get(m3, "y")  # 2
    """
    var result = []
    var i = 0
    while i < map1.len():
        val entry = map1[i]
        if map_contains_key(map2, entry[0]):
            result.push(entry)
        i = i + 1
    result

fn map_symmetric_difference(map1, map2):
    """Get entries whose keys exist in exactly one map.

    Example:
        val m1 = map_put(map_put(map_create(), "x", 1), "y", 2)
        val m2 = map_put(map_put(map_create(), "y", 3), "z", 4)
        val m3 = map_symmetric_difference(m1, m2)
        map_size(m3)  # 2 (x and z)
    """
    val diff1 = map_difference(map1, map2)
    val diff2 = map_difference(map2, map1)
    map_merge(diff1, diff2)

fn map_group_by(items, key_fn):
    """Group items by key function. Returns map of key -> [items].

    Example:
        val items = [("Alice", 25), ("Bob", 30), ("Charlie", 25)]
        val m = map_group_by(items, \item: "{item[1]}")
        map_get(m, "25")  # [("Alice", 25), ("Charlie", 25)]
    """
    var result = map_create()
    var i = 0
    while i < items.len():
        val item = items[i]
        val key = key_fn(item)

        val existing = map_get(result, key)
        if existing == nil:
            result = map_put(result, key, [item])
        else:
            var new_group = existing
            new_group.push(item)
            result = map_put(result, key, new_group)
        i = i + 1
    result

fn map_count_by(items, key_fn):
    """Count items by key function. Returns map of key -> count.

    Example:
        val items = ["a", "b", "a", "c", "a"]
        val m = map_count_by(items, \x: x)
        map_get(m, "a")  # 3
    """
    var result = map_create()
    var i = 0
    while i < items.len():
        val item = items[i]
        val key = key_fn(item)

        val existing = map_get(result, key)
        val count = if existing == nil: 1 else: existing + 1
        result = map_put(result, key, count)
        i = i + 1
    result

fn map_invert(map):
    """Invert map (swap keys and values). Values become keys as strings.

    Warning: If multiple keys have same value, last one wins.

    Example:
        val m = map_put(map_create(), "x", 1)
        val m2 = map_invert(m)
        map_get(m2, "1")  # "x"
    """
    var result = map_create()
    var i = 0
    while i < map.len():
        val entry = map[i]
        val new_key = "{entry[1]}"
        val new_value = entry[0]
        result = map_put(result, new_key, new_value)
        i = i + 1
    result

fn map_flatten(map):
    """Flatten nested map structure (one level only).

    If values are maps, merges them into parent with combined keys.
    Uses "parent.child" key format.

    Example:
        val inner = map_put(map_create(), "b", 2)
        val outer = map_put(map_create(), "a", inner)
        val flat = map_flatten(outer)
        # Not applicable for non-map values
    """
    var result = map_create()
    var i = 0
    while i < map.len():
        val entry = map[i]
        val key = entry[0]
        val value = entry[1]

        result = map_put(result, key, value)
        i = i + 1
    result

fn map_equals(map1, map2) -> bool:
    """Check if two maps are equal (same keys and values).

    Example:
        val m1 = map_put(map_create(), "x", 1)
        val m2 = map_put(map_create(), "x", 1)
        map_equals(m1, m2)  # true
    """
    if map_size(map1) != map_size(map2):
        return false

    var i = 0
    while i < map1.len():
        val entry = map1[i]
        val key = entry[0]
        val value1 = entry[1]
        val value2 = map_get(map2, key)

        if value2 == nil:
            return false
        if value1 != value2:
            return false
        i = i + 1

    true

fn map_rename_keys(map, key_map):
    """Rename keys according to key mapping.

    key_map is a map of old_key -> new_key.

    Example:
        val m = map_put(map_create(), "x", 1)
        val key_mapping = map_put(map_create(), "x", "y")
        val m2 = map_rename_keys(m, key_mapping)
        map_get(m2, "y")  # 1
    """
    var result = map_create()
    var i = 0
    while i < map.len():
        val entry = map[i]
        val old_key = entry[0]
        val value = entry[1]

        val new_key = map_get(key_map, old_key)
        val final_key = if new_key == nil: old_key else: new_key

        result = map_put(result, final_key, value)
        i = i + 1
    result

fn map_to_string(map) -> text:
    """Convert map to string representation.

    Example:
        val m = map_put(map_create(), "x", 1)
        map_to_string(m)  # "{x: 1}"
    """
    if map_is_empty(map):
        return "{}"

    var parts = []
    var i = 0
    while i < map.len():
        val entry = map[i]
        parts.push("{entry[0]}: {entry[1]}")
        i = i + 1

    "{" + parts.join(", ") + "}"
