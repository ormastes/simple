# Bloom Filter Add Operations

from "std/bloom_filter/types" import set_bit
from "std/bloom_filter/utilities" import multi_hash

# ============================================================================
# STANDARD BLOOM FILTER
# ============================================================================

# Add an item to the Bloom filter
fn bf_add(filter: tuple, item: text) -> nil:
    val size = filter[1]
    val num_hashes = filter[2]
    val bits = filter[3]

    val indices = multi_hash(item, num_hashes, size)
    for i in 0..indices.length():
        val index = indices[i]
        set_bit(bits, index)

    filter[4] = filter[4] + 1
    nil

# ============================================================================
# COUNTING BLOOM FILTER
# ============================================================================

# Add an item to the counting filter
fn cf_add(filter: tuple, item: text) -> nil:
    val size = filter[1]
    val num_hashes = filter[2]
    val counters = filter[3]

    val indices = multi_hash(item, num_hashes, size)
    for i in 0..indices.length():
        val index = indices[i]
        val current = counters[index]
        if current < 255:  # 8-bit counter max
            counters[index] = current + 1

    filter[4] = filter[4] + 1
    nil

# Remove an item from the counting filter
fn cf_remove(filter: tuple, item: text) -> bool:
    val size = filter[1]
    val num_hashes = filter[2]
    val counters = filter[3]

    # First check if item exists
    val indices = multi_hash(item, num_hashes, size)
    for i in 0..indices.length():
        val index = indices[i]
        if counters[index] == 0:
            return false  # Item not in filter

    # Decrement counters
    for i in 0..indices.length():
        val index = indices[i]
        counters[index] = counters[index] - 1

    filter[4] = filter[4] - 1
    true

# ============================================================================
# SCALABLE BLOOM FILTER
# ============================================================================

# Add item to scalable filter (creates new filter if needed)
fn sf_add(filter: tuple, item: text) -> nil:
    val initial_capacity = filter[1]
    val base_error_rate = filter[2]
    val growth_factor = filter[3]
    val filters = filter[4]
    val total_items = filter[5]

    # Check if item already exists
    for i in 0..filters.length():
        val sub_filter = filters[i]
        if bf_contains(sub_filter, item):
            return nil  # Already exists

    # Find a filter with capacity or create new one
    if filters.length() == 0:
        # Create first filter
        val new_filter = create_bloom_filter(initial_capacity, base_error_rate)
        filters.append(new_filter)

    val last_filter = filters[filters.length() - 1]
    val last_count = bf_count(last_filter)
    val last_capacity = initial_capacity * (growth_factor ** (filters.length() - 1))

    if last_count >= last_capacity:
        # Create new filter with larger capacity and tighter error rate
        val new_capacity = last_capacity * growth_factor
        val new_error_rate = base_error_rate / filters.length().to_f64()
        val new_filter = create_bloom_filter(new_capacity, new_error_rate)
        filters.append(new_filter)
        bf_add(new_filter, item)
    else:
        bf_add(last_filter, item)

    filter[5] = total_items + 1
    nil

# ============================================================================
# CUCKOO FILTER
# ============================================================================

from "std/bloom_filter/utilities" import fingerprint, fnv1a_hash, hash_combine

# Get alternate bucket index for cuckoo hashing
fn cuckoo_alt_index(index: i64, fp: i64, bucket_count: i64) -> i64:
    val hash_fp = hash_combine(index, fp)
    (index ^ hash_fp) % bucket_count

# Find fingerprint in bucket
fn find_in_bucket(bucket: List, fp: i64) -> bool:
    for i in 0..bucket.length():
        if bucket[i] == fp:
            return true
    false

# Check if bucket has empty slot
fn has_empty_slot(bucket: List) -> bool:
    for i in 0..bucket.length():
        if bucket[i] == 0:
            return true
    false

# Insert fingerprint into bucket
fn insert_in_bucket(bucket: List, fp: i64) -> bool:
    for i in 0..bucket.length():
        if bucket[i] == 0:
            bucket[i] = fp
            return true
    false

# Add item to cuckoo filter
fn cuckoo_add(filter: tuple, item: text) -> bool:
    val bucket_count = filter[1]
    val fingerprint_size = filter[3]
    val buckets = filter[4]

    val fp = fingerprint(item, fingerprint_size)
    val h1 = fnv1a_hash(item) % bucket_count
    val h2 = cuckoo_alt_index(h1, fp, bucket_count)

    val bucket1 = buckets[h1]
    val bucket2 = buckets[h2]

    # Check if already exists
    if find_in_bucket(bucket1, fp) or find_in_bucket(bucket2, fp):
        return true  # Already exists

    # Try to insert in first bucket
    if insert_in_bucket(bucket1, fp):
        filter[5] = filter[5] + 1
        return true

    # Try to insert in second bucket
    if insert_in_bucket(bucket2, fp):
        filter[5] = filter[5] + 1
        return true

    # Need to relocate items (simplified: just fail for now)
    # Full implementation would do cuckoo relocation
    false

# Delete item from cuckoo filter
fn cuckoo_delete(filter: tuple, item: text) -> bool:
    val bucket_count = filter[1]
    val fingerprint_size = filter[3]
    val buckets = filter[4]

    val fp = fingerprint(item, fingerprint_size)
    val h1 = fnv1a_hash(item) % bucket_count
    val h2 = cuckoo_alt_index(h1, fp, bucket_count)

    val bucket1 = buckets[h1]
    val bucket2 = buckets[h2]

    # Try to delete from first bucket
    for i in 0..bucket1.length():
        if bucket1[i] == fp:
            bucket1[i] = 0
            filter[5] = filter[5] - 1
            return true

    # Try to delete from second bucket
    for i in 0..bucket2.length():
        if bucket2[i] == fp:
            bucket2[i] = 0
            filter[5] = filter[5] - 1
            return true

    false
