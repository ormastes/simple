# Bloom Filter Merge and Set Operations

from "std/bloom_filter/types" import create_bloom_filter_struct, create_bit_array, get_bit, set_bit

# ============================================================================
# SET OPERATIONS
# ============================================================================

# Union of two Bloom filters (OR operation on bit arrays)
# Filters must have same size and hash count
fn bf_union(f1: tuple, f2: tuple) -> tuple:
    val size1 = f1[1]
    val size2 = f2[1]
    val num_hashes1 = f1[2]
    val num_hashes2 = f2[2]

    if size1 != size2:
        return nil  # Cannot union filters of different sizes
    if num_hashes1 != num_hashes2:
        return nil  # Cannot union filters with different hash counts

    val bits1 = f1[3]
    val bits2 = f2[3]
    val result_bits = create_bit_array(size1)

    # OR all bits
    for i in 0..size1:
        if get_bit(bits1, i) or get_bit(bits2, i):
            set_bit(result_bits, i)

    val item_count = f1[4] + f2[4]  # Approximate
    create_bloom_filter_struct(size1, num_hashes1, result_bits, item_count)

# Intersection of two Bloom filters (AND operation on bit arrays)
fn bf_intersection(f1: tuple, f2: tuple) -> tuple:
    val size1 = f1[1]
    val size2 = f2[1]
    val num_hashes1 = f1[2]
    val num_hashes2 = f2[2]

    if size1 != size2:
        return nil
    if num_hashes1 != num_hashes2:
        return nil

    val bits1 = f1[3]
    val bits2 = f2[3]
    val result_bits = create_bit_array(size1)

    # AND all bits
    for i in 0..size1:
        if get_bit(bits1, i) and get_bit(bits2, i):
            set_bit(result_bits, i)

    val item_count = 0  # Unknown, would need to recount
    create_bloom_filter_struct(size1, num_hashes1, result_bits, item_count)

# Check if filter f1 is a subset of f2 (all bits in f1 are set in f2)
fn bf_is_subset(f1: tuple, f2: tuple) -> bool:
    val size1 = f1[1]
    val size2 = f2[1]

    if size1 != size2:
        return false

    val bits1 = f1[3]
    val bits2 = f2[3]

    for i in 0..size1:
        if get_bit(bits1, i) and not get_bit(bits2, i):
            return false
    true

# Clone a filter (create a copy)
fn clone_filter(filter: tuple) -> tuple:
    val filter_type = filter[0]
    if filter_type == "bloom":
        val size = filter[1]
        val num_hashes = filter[2]
        val bits = filter[3]
        val item_count = filter[4]

        val new_bits = create_bit_array(size)
        for i in 0..size:
            if get_bit(bits, i):
                set_bit(new_bits, i)

        create_bloom_filter_struct(size, num_hashes, new_bits, item_count)
    else:
        nil

# Merge multiple filters into one (union)
fn merge_filters(filters: List) -> tuple:
    if filters.length() == 0:
        return nil

    var result = clone_filter(filters[0])
    for i in 1..filters.length():
        val temp = bf_union(result, filters[i])
        result = temp
    result
