# K-d Tree Nearest Neighbor Search
# Single and k-nearest neighbor queries with multiple distance metrics

import kd_tree.types

# ============================================================================
# Nearest Neighbor Search
# ============================================================================

fn kdtree_nearest_neighbor_recursive(node, target: List<i64>, best_point: List<i64>, best_dist: i64, metric: i64) -> List:
    # Recursively find nearest neighbor
    # Returns [best_point, best_dist]
    if node == nil:
        return [best_point, best_dist]

    val node_point = kdnode_get_point(node)
    val dist = point_distance(node_point, target, metric)

    var current_best_point = best_point
    var current_best_dist = best_dist

    if best_point.length() == 0:
        current_best_point = node_point
        current_best_dist = dist
    else:
        if dist < current_best_dist:
            current_best_point = node_point
            current_best_dist = dist

    val dim = kdnode_get_dim(node)
    val pivot = kdnode_get_value(node)
    val coord = target.get(dim)

    var first_child = nil
    var second_child = nil

    if coord < pivot:
        first_child = kdnode_get_left(node)
        second_child = kdnode_get_right(node)
    else:
        first_child = kdnode_get_right(node)
        second_child = kdnode_get_left(node)

    val result1 = kdtree_nearest_neighbor_recursive(first_child, target, current_best_point, current_best_dist, metric)
    current_best_point = result1.get(0)
    current_best_dist = result1.get(1)

    val diff = coord - pivot
    val abs_diff = if diff < 0: -diff else: diff
    val axis_dist = abs_diff * abs_diff

    if axis_dist < current_best_dist:
        val result2 = kdtree_nearest_neighbor_recursive(second_child, target, current_best_point, current_best_dist, metric)
        current_best_point = result2.get(0)
        current_best_dist = result2.get(1)

    [current_best_point, current_best_dist]

fn kdtree_nearest_neighbor(node, target: List<i64>, metric: i64) -> List<i64>:
    # Find nearest neighbor to target point
    # metric: 0=Euclidean (squared), 1=Manhattan, 2=Chebyshev
    if node == nil:
        return []

    val result = kdtree_nearest_neighbor_recursive(node, target, [], 999999999, metric)
    result.get(0)

fn kdtree_nearest_neighbor_euclidean(node, target: List<i64>) -> List<i64>:
    # Find nearest neighbor using Euclidean distance
    kdtree_nearest_neighbor(node, target, 0)

fn kdtree_nearest_neighbor_manhattan(node, target: List<i64>) -> List<i64>:
    # Find nearest neighbor using Manhattan distance
    kdtree_nearest_neighbor(node, target, 1)

fn kdtree_nearest_neighbor_chebyshev(node, target: List<i64>) -> List<i64>:
    # Find nearest neighbor using Chebyshev distance
    kdtree_nearest_neighbor(node, target, 2)

# ============================================================================
# K-Nearest Neighbors Search
# ============================================================================

fn heap_insert(heap: List, point: List<i64>, dist: i64, k: i64):
    # Insert into max-heap (keep k nearest)
    var item = [point, dist]
    heap.push(item)

    if heap.length() <= k:
        return

    var max_idx = 0
    var max_dist = 0
    var i = 0
    while i < heap.length():
        val item = heap.get(i)
        val d = item.get(1)
        if d > max_dist:
            max_dist = d
            max_idx = i
        i = i + 1

    heap.remove(max_idx)

fn heap_max_dist(heap: List) -> i64:
    # Get maximum distance in heap
    if heap.length() == 0:
        return 999999999

    var max_dist = 0
    var i = 0
    while i < heap.length():
        val item = heap.get(i)
        val d = item.get(1)
        if d > max_dist:
            max_dist = d
        i = i + 1
    max_dist

fn kdtree_k_nearest_recursive(node, target: List<i64>, heap: List, k: i64, metric: i64):
    # Recursively find k nearest neighbors
    if node == nil:
        return

    val node_point = kdnode_get_point(node)
    val dist = point_distance(node_point, target, metric)

    heap_insert(heap, node_point, dist, k)

    val dim = kdnode_get_dim(node)
    val pivot = kdnode_get_value(node)
    val coord = target.get(dim)

    var first_child = nil
    var second_child = nil

    if coord < pivot:
        first_child = kdnode_get_left(node)
        second_child = kdnode_get_right(node)
    else:
        first_child = kdnode_get_right(node)
        second_child = kdnode_get_left(node)

    kdtree_k_nearest_recursive(first_child, target, heap, k, metric)

    val diff = coord - pivot
    val abs_diff = if diff < 0: -diff else: diff
    val axis_dist = abs_diff * abs_diff
    val max_dist = heap_max_dist(heap)

    val heap_full = if heap.length() < k: 0 else: 1
    if heap_full == 0:
        kdtree_k_nearest_recursive(second_child, target, heap, k, metric)
    else:
        if axis_dist < max_dist:
            kdtree_k_nearest_recursive(second_child, target, heap, k, metric)

fn kdtree_k_nearest_neighbors(node, target: List<i64>, k: i64, metric: i64) -> List<List<i64>>:
    # Find k nearest neighbors to target point
    # metric: 0=Euclidean (squared), 1=Manhattan, 2=Chebyshev
    if node == nil:
        return []

    var heap = []
    kdtree_k_nearest_recursive(node, target, heap, k, metric)

    var result = []
    var i = 0
    while i < heap.length():
        val item = heap.get(i)
        val point = item.get(0)
        result.push(point)
        i = i + 1

    result
