# Log Format - Compressed Formatting with String Interning
#
# Provides format helpers that leverage the string intern table
# for minimal-bandwidth log output on embedded systems.
# Level prefix handles are pre-registered at init time.
#
# Usage:
#   log_format_init()
#   val msg = log_format(LOG_INFO, "Boot complete")
#   log_buffer_push(LOG_INFO, handle)
#   log_buffer_flush()

export log_format, log_format_h, log_format_init
export log_buffer_push, log_buffer_flush, log_buffer_count
export H_TRACE, H_DEBUG, H_INFO, H_WARN, H_ERROR, H_FATAL

# ============================================================================
# Level Prefix Handles (Compile-Time Interned)
# ============================================================================

val H_TRACE: i32 = 1    # "[TRACE] "
val H_DEBUG: i32 = 2    # "[DEBUG] "
val H_INFO: i32  = 3    # "[INFO]  "
val H_WARN: i32  = 4    # "[WARN]  "
val H_ERROR: i32 = 5    # "[ERROR] "
val H_FATAL: i32 = 6    # "[FATAL] "

# ============================================================================
# Format Functions
# ============================================================================

fn log_format_init():
    """Register level prefix strings with the intern table.

    Call once at startup before using handle-based logging.
    In interpreter mode, this is a no-op (handles are constants).
    In compiled mode, registers strings with StringInternTable.
    """
    # Stub â€” in compiled mode, would call intern_table.add() for each prefix
    0

fn log_format(level: i32, msg: text) -> text:
    """Format a log message with level prefix.

    Returns: "[LEVEL] message"
    """
    val prefix = log_level_prefix(level)
    "{prefix}{msg}"

fn log_format_h(level: i32, handle: i32) -> text:
    """Format using interned handles for both level and message.

    In compiled mode, this produces a compact binary encoding.
    In interpreter mode, returns a placeholder string.
    """
    val prefix = log_level_prefix(level)
    "{prefix}[h:{handle}]"

fn log_level_prefix(level: i32) -> text:
    """Return the bracketed prefix for a log level."""
    if level == 0: return "[TRACE] "
    if level == 1: return "[DEBUG] "
    if level == 2: return "[INFO]  "
    if level == 3: return "[WARN]  "
    if level == 4: return "[ERROR] "
    if level == 5: return "[FATAL] "
    "[?????] "

# ============================================================================
# Ring Buffer for Deferred Log Output
# ============================================================================

val LOG_BUFFER_CAPACITY: i32 = 64

var g_log_buf_levels: [i32] = []
var g_log_buf_handles: [i32] = []
var g_log_buf_head: i32 = 0
var g_log_buf_tail: i32 = 0
var g_log_buf_count: i32 = 0
var g_log_buf_initialized: bool = false

fn log_buffer_ensure_init():
    """Lazily initialize the log buffer arrays."""
    if g_log_buf_initialized:
        return
    var i = 0
    while i < LOG_BUFFER_CAPACITY:
        g_log_buf_levels.push(0)
        g_log_buf_handles.push(0)
        i = i + 1
    g_log_buf_initialized = true

fn log_buffer_push(level: i32, handle: i32) -> bool:
    """Buffer a log entry for deferred output. Returns false if buffer full."""
    log_buffer_ensure_init()
    if g_log_buf_count >= LOG_BUFFER_CAPACITY:
        return false
    val mask = LOG_BUFFER_CAPACITY - 1
    g_log_buf_levels[g_log_buf_tail] = level
    g_log_buf_handles[g_log_buf_tail] = handle
    g_log_buf_tail = (g_log_buf_tail + 1) & mask
    g_log_buf_count = g_log_buf_count + 1
    true

fn log_buffer_flush():
    """Flush all buffered log entries to active targets."""
    log_buffer_ensure_init()
    while g_log_buf_count > 0:
        val mask = LOG_BUFFER_CAPACITY - 1
        val level = g_log_buf_levels[g_log_buf_head]
        val handle = g_log_buf_handles[g_log_buf_head]
        g_log_buf_head = (g_log_buf_head + 1) & mask
        g_log_buf_count = g_log_buf_count - 1
        # Dispatch the buffered entry
        val msg = log_format_h(level, handle)
        print msg

fn log_buffer_count() -> i32:
    """Return number of entries in the log buffer."""
    g_log_buf_count
