# Reference-Counted Binaries and Shared Heap
#
# Provides RefcBinary, BinaryRef, SharedHeap for memory management.

use types.{BinaryId, Offset, Length, RefCount, ByteSize, Capacity, Count}

val SMALL_BINARY_THRESHOLD = 64

# --- CopyStrategy ---

fn copy_strategy(size: i64) -> text:
    if size < SMALL_BINARY_THRESHOLD:
        return "DeepCopy"
    "ShareRef"

fn CopyStrategy__DeepCopy__should_share(size: i64) -> bool:
    false

fn CopyStrategy__ShareRef__should_share(size: i64) -> bool:
    true

fn CopyStrategy__Hybrid__should_share(size: i64) -> bool:
    size >= SMALL_BINARY_THRESHOLD

# --- BinaryRef ---

class BinaryRef:
    id: BinaryId
    offset: Offset
    length: Length

    fn size() -> i64:
        self.length.value

    fn is_small() -> bool:
        self.length.value < SMALL_BINARY_THRESHOLD

    fn eq(other: BinaryRef) -> bool:
        self.id.value == other.id.value

    fn fmt() -> text:
        "BinaryRef(id={self.id.value}, offset={self.offset.value}, length={self.length.value})"

fn BinaryRef__new(id: i64, offset: i64, length: i64) -> BinaryRef:
    BinaryRef(id: BinaryId(value: id), offset: Offset(value: offset), length: Length(value: length))

# --- RefcBinary ---

class RefcBinary:
    id: BinaryId
    refcount: RefCount
    length: Length
    capacity: Capacity
    is_sub_binary: bool
    parent_id: BinaryId
    has_parent: bool
    is_pinned: bool

    me incref() -> i64:
        self.refcount = RefCount(value: self.refcount.value + 1)
        self.refcount.value

    me decref() -> i64:
        self.refcount = RefCount(value: self.refcount.value - 1)
        self.refcount.value

    fn can_collect() -> bool:
        val zero_refs = self.refcount.value <= 0
        val not_pinned = not self.is_pinned
        zero_refs and not_pinned

    me pin():
        self.is_pinned = true

    me unpin():
        self.is_pinned = false

    fn total_size() -> i64:
        64 + self.capacity.value

    fn to_ref(offset: i64) -> BinaryRef:
        BinaryRef(id: self.id, offset: Offset(value: offset), length: self.length)

fn RefcBinary__new(id: i64, length: i64, capacity: i64) -> RefcBinary:
    RefcBinary(
        id: BinaryId(value: id),
        refcount: RefCount(value: 1),
        length: Length(value: length),
        capacity: Capacity(value: capacity),
        is_sub_binary: false,
        parent_id: BinaryId(value: 0),
        has_parent: false,
        is_pinned: false
    )

fn RefcBinary__sub_binary(id: i64, parent: i64, offset: i64, length: i64, capacity: i64) -> RefcBinary:
    RefcBinary(
        id: BinaryId(value: id),
        refcount: RefCount(value: 1),
        length: Length(value: length),
        capacity: Capacity(value: capacity),
        is_sub_binary: true,
        parent_id: BinaryId(value: parent),
        has_parent: true,
        is_pinned: false
    )

# --- SharedHeapConfig ---

class SharedHeapConfig:
    initial_size: ByteSize
    max_size: ByteSize
    grow_factor: f64
    gc_threshold: f64
    defrag_threshold: f64

fn SharedHeapConfig__default() -> SharedHeapConfig:
    SharedHeapConfig(
        initial_size: ByteSize(value: 64 * 1024 * 1024),
        max_size: ByteSize(value: 512 * 1024 * 1024),
        grow_factor: 1.5,
        gc_threshold: 0.8,
        defrag_threshold: 0.3
    )

fn SharedHeapConfig__small() -> SharedHeapConfig:
    SharedHeapConfig(
        initial_size: ByteSize(value: 1024 * 1024),
        max_size: ByteSize(value: 16 * 1024 * 1024),
        grow_factor: 1.5,
        gc_threshold: 0.8,
        defrag_threshold: 0.3
    )

fn SharedHeapConfig__large() -> SharedHeapConfig:
    SharedHeapConfig(
        initial_size: ByteSize(value: 256 * 1024 * 1024),
        max_size: ByteSize(value: 2 * 1024 * 1024 * 1024),
        grow_factor: 1.5,
        gc_threshold: 0.8,
        defrag_threshold: 0.3
    )

# --- SharedHeapStats ---

class SharedHeapStats:
    binary_count: Count
    sub_binary_count: Count
    used_size: ByteSize
    total_allocations: Count
    total_incref: Count
    total_decref: Count
    peak_usage: ByteSize
    pinned_count: Count
    defrag_count: Count
    initial_size: ByteSize

    fn utilization() -> f64:
        if self.initial_size.value == 0:
            return 0.0
        self.used_size.value * 100.0 / self.initial_size.value

    fn fragmentation() -> f64:
        0.0

fn SharedHeapStats__new() -> SharedHeapStats:
    SharedHeapStats(
        binary_count: Count(value: 0),
        sub_binary_count: Count(value: 0),
        used_size: ByteSize(value: 0),
        total_allocations: Count(value: 0),
        total_incref: Count(value: 0),
        total_decref: Count(value: 0),
        peak_usage: ByteSize(value: 0),
        pinned_count: Count(value: 0),
        defrag_count: Count(value: 0),
        initial_size: ByteSize(value: 0)
    )

# --- AllocResult ---

class AllocResult:
    tag: text
    ref_val: BinaryRef

    fn is_success() -> bool:
        self.tag == "Success"

    fn unwrap() -> BinaryRef:
        self.ref_val

    fn ref_option():
        if self.tag == "Success":
            return self.ref_val
        nil

    fn fmt() -> text:
        if self.tag == "Success":
            return "Success({self.ref_val.fmt()})"
        self.tag

fn AllocResult__Success(ref_val: BinaryRef) -> AllocResult:
    AllocResult(tag: "Success", ref_val: ref_val)

fn AllocResult__OutOfMemory() -> AllocResult:
    AllocResult(tag: "OutOfMemory", ref_val: BinaryRef__new(-1, 0, 0))

fn AllocResult__TooLarge() -> AllocResult:
    AllocResult(tag: "TooLarge", ref_val: BinaryRef__new(-1, 0, 0))

fn AllocResult__InvalidSize() -> AllocResult:
    AllocResult(tag: "InvalidSize", ref_val: BinaryRef__new(-1, 0, 0))

fn AllocResult__InvalidRange() -> AllocResult:
    AllocResult(tag: "InvalidRange", ref_val: BinaryRef__new(-1, 0, 0))

fn AllocResult__ParentNotFound() -> AllocResult:
    AllocResult(tag: "ParentNotFound", ref_val: BinaryRef__new(-1, 0, 0))

# --- SharedHeap ---

class SharedHeap:
    config: SharedHeapConfig
    binary_ids: [i64]
    binary_refcounts: [i64]
    binary_lengths: [i64]
    binary_capacities: [i64]
    binary_is_sub: [bool]
    binary_parent_ids: [i64]
    binary_is_pinned: [bool]
    next_id: i64
    stat_used_size: ByteSize
    stat_total_allocs: Count
    stat_total_incref: Count
    stat_total_decref: Count
    stat_peak_usage: ByteSize
    stat_sub_count: Count
    stat_pinned_count: Count
    stat_defrag_count: Count

    me allocate(process_id: i64, size: i64) -> AllocResult:
        if size <= 0:
            return AllocResult__InvalidSize()
        if size > 1024 * 1024 * 1024:
            return AllocResult__TooLarge()
        val total = self.stat_used_size.value + size
        if total > self.config.max_size.value:
            return AllocResult__OutOfMemory()
        val id = self.next_id
        self.next_id = self.next_id + 1
        self.binary_ids.push(id)
        self.binary_refcounts.push(1)
        self.binary_lengths.push(size)
        self.binary_capacities.push(size)
        self.binary_is_sub.push(false)
        self.binary_parent_ids.push(-1)
        self.binary_is_pinned.push(false)
        self.stat_used_size = ByteSize(value: self.stat_used_size.value + size)
        self.stat_total_allocs = Count(value: self.stat_total_allocs.value + 1)
        if self.stat_used_size.value > self.stat_peak_usage.value:
            self.stat_peak_usage = self.stat_used_size
        val ref_val = BinaryRef__new(id, 0, size)
        AllocResult__Success(ref_val)

    me allocate_sub_binary(parent_id: i64, offset: i64, length: i64) -> AllocResult:
        # Find parent
        var parent_idx = -1
        var pi = 0
        for bid in self.binary_ids:
            if bid == parent_id:
                parent_idx = pi
            pi = pi + 1
        if parent_idx == -1:
            return AllocResult__ParentNotFound()
        val parent_len = self.binary_lengths[parent_idx]
        val range_end = offset + length
        if range_end > parent_len:
            return AllocResult__InvalidRange()
        val id = self.next_id
        self.next_id = self.next_id + 1
        self.binary_ids.push(id)
        self.binary_refcounts.push(1)
        self.binary_lengths.push(length)
        self.binary_capacities.push(0)
        self.binary_is_sub.push(true)
        self.binary_parent_ids.push(parent_id)
        self.binary_is_pinned.push(false)
        self.stat_sub_count = Count(value: self.stat_sub_count.value + 1)
        self.stat_total_allocs = Count(value: self.stat_total_allocs.value + 1)
        val ref_val = BinaryRef__new(id, offset, length)
        AllocResult__Success(ref_val)

    me incref(id: i64) -> bool:
        var idx = 0
        for bid in self.binary_ids:
            if bid == id:
                self.binary_refcounts[idx] = self.binary_refcounts[idx] + 1
                self.stat_total_incref = Count(value: self.stat_total_incref.value + 1)
                return true
            idx = idx + 1
        false

    me decref(id: i64) -> bool:
        var idx = 0
        for bid in self.binary_ids:
            if bid == id:
                self.binary_refcounts[idx] = self.binary_refcounts[idx] - 1
                self.stat_total_decref = Count(value: self.stat_total_decref.value + 1)
                if self.binary_refcounts[idx] <= 0:
                    val not_pinned = not self.binary_is_pinned[idx]
                    if not_pinned:
                        self.remove_at(idx)
                return true
            idx = idx + 1
        false

    me remove_at(idx: i64):
        val size = self.binary_lengths[idx]
        val is_sub = self.binary_is_sub[idx]
        self.binary_ids.remove(idx)
        self.binary_refcounts.remove(idx)
        self.binary_lengths.remove(idx)
        self.binary_capacities.remove(idx)
        self.binary_is_sub.remove(idx)
        self.binary_parent_ids.remove(idx)
        self.binary_is_pinned.remove(idx)
        if not is_sub:
            self.stat_used_size = ByteSize(value: self.stat_used_size.value - size)
        else:
            self.stat_sub_count = Count(value: self.stat_sub_count.value - 1)

    fn get(id: i64):
        var idx = 0
        for bid in self.binary_ids:
            if bid == id:
                return RefcBinary(
                    id: BinaryId(value: bid),
                    refcount: RefCount(value: self.binary_refcounts[idx]),
                    length: Length(value: self.binary_lengths[idx]),
                    capacity: Capacity(value: self.binary_capacities[idx]),
                    is_sub_binary: self.binary_is_sub[idx],
                    parent_id: BinaryId(value: self.binary_parent_ids[idx]),
                    has_parent: self.binary_is_sub[idx],
                    is_pinned: self.binary_is_pinned[idx]
                )
            idx = idx + 1
        nil

    fn get_ref(id: i64):
        var idx = 0
        for bid in self.binary_ids:
            if bid == id:
                return BinaryRef__new(bid, 0, self.binary_lengths[idx])
            idx = idx + 1
        nil

    fn contains(id: i64) -> bool:
        for bid in self.binary_ids:
            if bid == id:
                return true
        false

    me pin(id: i64) -> bool:
        var idx = 0
        for bid in self.binary_ids:
            if bid == id:
                self.binary_is_pinned[idx] = true
                self.stat_pinned_count = Count(value: self.stat_pinned_count.value + 1)
                return true
            idx = idx + 1
        false

    me unpin(id: i64) -> bool:
        var idx = 0
        for bid in self.binary_ids:
            if bid == id:
                self.binary_is_pinned[idx] = false
                self.stat_pinned_count = Count(value: self.stat_pinned_count.value - 1)
                return true
            idx = idx + 1
        false

    me collect_garbage() -> i64:
        var reclaimed = 0
        var idx = 0
        var to_remove = []
        for bid in self.binary_ids:
            val rc = self.binary_refcounts[idx]
            val pinned = self.binary_is_pinned[idx]
            val collectible = rc <= 0 and not pinned
            if collectible:
                to_remove.push(idx)
                val is_sub = self.binary_is_sub[idx]
                if not is_sub:
                    reclaimed = reclaimed + self.binary_lengths[idx]
            idx = idx + 1
        # Remove in reverse order to keep indices valid
        var ri = to_remove.len() - 1
        for _ in to_remove:
            self.remove_at(to_remove[ri])
            ri = ri - 1
        reclaimed

    me defragment():
        self.stat_defrag_count = Count(value: self.stat_defrag_count.value + 1)

    fn binary_count() -> i64:
        self.binary_ids.len()

    fn get_stats() -> SharedHeapStats:
        SharedHeapStats(
            binary_count: Count(value: self.binary_ids.len()),
            sub_binary_count: self.stat_sub_count,
            used_size: self.stat_used_size,
            total_allocations: self.stat_total_allocs,
            total_incref: self.stat_total_incref,
            total_decref: self.stat_total_decref,
            peak_usage: self.stat_peak_usage,
            pinned_count: self.stat_pinned_count,
            defrag_count: self.stat_defrag_count,
            initial_size: self.config.initial_size
        )

fn SharedHeap__new(config: SharedHeapConfig) -> SharedHeap:
    SharedHeap(
        config: config,
        binary_ids: [],
        binary_refcounts: [],
        binary_lengths: [],
        binary_capacities: [],
        binary_is_sub: [],
        binary_parent_ids: [],
        binary_is_pinned: [],
        next_id: 0,
        stat_used_size: ByteSize(value: 0),
        stat_total_allocs: Count(value: 0),
        stat_total_incref: Count(value: 0),
        stat_total_decref: Count(value: 0),
        stat_peak_usage: ByteSize(value: 0),
        stat_sub_count: Count(value: 0),
        stat_pinned_count: Count(value: 0),
        stat_defrag_count: Count(value: 0)
    )

export SMALL_BINARY_THRESHOLD, copy_strategy
export CopyStrategy__DeepCopy__should_share, CopyStrategy__ShareRef__should_share, CopyStrategy__Hybrid__should_share
export BinaryRef, BinaryRef__new
export RefcBinary, RefcBinary__new, RefcBinary__sub_binary
export SharedHeapConfig, SharedHeapConfig__default, SharedHeapConfig__small, SharedHeapConfig__large
export SharedHeapStats, SharedHeapStats__new
export AllocResult, AllocResult__Success, AllocResult__OutOfMemory, AllocResult__TooLarge
export AllocResult__InvalidSize, AllocResult__InvalidRange, AllocResult__ParentNotFound
export SharedHeap, SharedHeap__new
