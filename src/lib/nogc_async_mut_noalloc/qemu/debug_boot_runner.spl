# Debug-Enabled QEMU Boot Runner
#
# Extends boot test infrastructure with GDB remote debugging support.
# Features:
# - Automatic GDB attach on crash
# - Stack trace extraction
# - Register dump on failure
# - Breakpoint management
# - Single-step debugging support

use std.qemu.{QemuArch, QemuConfig, QemuInstance}
use std.qemu.boot_runner.{BootTestConfig, BootTestResult, BootTestRunner}
use app.debug.remote.protocol.gdb_mi.{GdbMiClient}
use app.debug.remote.protocol.gdb_mi_parser.{GdbMiParser, parse_hex_value}
use app.debug.remote.types.{DebugConfig, Architecture}
use app.io.{shell, ProcessResult}

export DebugBootConfig, DebugBootRunner, DebugInfo, StackFrame, StopInfo
export run_debug_boot_test, format_debug_info, analyze_crash, parse_hex_value_u64

# ===========================================================================
# Debug Boot Configuration
# ===========================================================================

class DebugBootConfig:
    """Configuration for debug-enabled boot tests."""
    base_config: BootTestConfig
    gdb_enabled: bool
    gdb_port: i32
    auto_attach_on_crash: bool
    breakpoints: [u64]        # Breakpoints to set before running
    single_step: bool         # Enable single-stepping

fn DebugBootConfig__new(arch: QemuArch, kernel: text) -> DebugBootConfig:
    DebugBootConfig(
        base_config: BootTestConfig__new(arch, kernel),
        gdb_enabled: false,
        gdb_port: 1234,  # Default GDB port
        auto_attach_on_crash: true,
        breakpoints: [],
        single_step: false
    )


impl DebugBootConfig:
    me enable_debug():
        self.gdb_enabled = true
    me set_gdb_port(port: i32):
        self.gdb_port = port
    me add_breakpoint(addr: u64):
        self.breakpoints.push(addr)
    me enable_single_step():
        self.single_step = true
    me disable_auto_attach():
        self.auto_attach_on_crash = false
# ===========================================================================
# Debug Information
# ===========================================================================

class DebugInfo:
    """Debug information extracted from crash."""
    registers: Dict<text, u64>    # Register values
    stack_trace: [StackFrame]     # Call stack
    fault_address: u64            # Faulting instruction
    fault_reason: text            # Crash reason
    available: bool               # Debug info was extracted

fn DebugInfo__unavailable() -> DebugInfo:
    DebugInfo(
        registers: {},
        stack_trace: [],
        fault_address: 0,
        fault_reason: "Debug info not available",
        available: false
    )

fn DebugInfo__from_gdb(regs: Dict<text, u64>, trace: [StackFrame], pc: u64, reason: text) -> DebugInfo:
    DebugInfo(
        registers: regs,
        stack_trace: trace,
        fault_address: pc,
        fault_reason: reason,
        available: true
    )

# Stack frame information
class StackFrame:
    """Single frame in call stack."""
    frame_num: i32
    address: u64
    function: text
    file: text
    line: i32

impl StackFrame:
    fn to_string() -> text:
        if self.file.len() > 0:
            "#{self.frame_num} 0x{self.address:x} in {self.function} at {self.file}:{self.line}"
        else:
            "#{self.frame_num} 0x{self.address:x} in {self.function}"
# ===========================================================================
# Debug Boot Runner
# ===========================================================================

class DebugBootRunner:
    """Boot test runner with GDB integration."""
    config: DebugBootConfig
    gdb_client: GdbMiClient?
    qemu_instance: QemuInstance?

fn DebugBootRunner__new(config: DebugBootConfig) -> DebugBootRunner:
    DebugBootRunner(
        config: config,
        gdb_client: nil,
        qemu_instance: nil
    )


impl DebugBootRunner:
    fn run() -> (BootTestResult, DebugInfo):
        """Run boot test with optional GDB debugging."""

        if self.config.gdb_enabled:
            self.run_with_debug()
        else:
            # Standard boot test without debug
            val runner = BootTestRunner__new(self.config.base_config)
            val result = runner.run()
            (result, DebugInfo__unavailable())
    fn run_with_debug() -> (BootTestResult, DebugInfo):
        """Run boot test with GDB attached."""

        # Build QEMU config with GDB stub
        var qemu_config = QemuConfig__for_remote_debug(
            self.config.base_config.arch,
            self.config.base_config.kernel_path,
            self.config.gdb_port
        )

        # Override with boot test settings
        qemu_config.timeout_ms = self.config.base_config.timeout_ms
        if self.config.base_config.machine.?:
            qemu_config.machine = self.config.base_config.machine.unwrap()

        # Start QEMU with GDB stub
        val start_result = QemuInstance__start(qemu_config)
        if not start_result.is_ok():
            val err_msg = start_result.err.unwrap()
            val result = BootTestResult__failure("Failed to start QEMU: {err_msg}", "", -1)
            return (result, DebugInfo__unavailable())

        self.qemu_instance = Some(start_result.ok.unwrap())

        # Connect GDB
        val gdb_result = self.connect_gdb()
        if not gdb_result.is_ok():
            val err_msg = gdb_result.err.unwrap()
            self.cleanup()
            val result = BootTestResult__failure("Failed to connect GDB: {err_msg}", "", -1)
            return (result, DebugInfo__unavailable())

        self.gdb_client = Some(gdb_result.ok.unwrap())

        # Set breakpoints if configured
        for bp_addr in self.config.breakpoints:
            self.set_breakpoint(bp_addr)

        # Continue execution
        val continue_result = self.continue_execution()

        # Cleanup
        self.cleanup()

        continue_result
    fn connect_gdb() -> Result<GdbMiClient, text>:
        """Connect GDB to QEMU stub."""

        # Find appropriate GDB for architecture
        val gdb_path = self.find_gdb()
        if gdb_path.len() == 0:
            return Err("GDB not found for architecture {self.config.base_config.arch}")

        # Build debug config for GDB MI client
        val debug_config = DebugConfig(
            host: "localhost",
            port: self.config.gdb_port,
            target: arch_to_debug_arch(self.config.base_config.arch),
            program: self.config.base_config.kernel_path,
            options: {}
        )

        # Create GDB MI client
        val client_result = GdbMiClient.connect(debug_config)

        client_result
    fn find_gdb() -> text:
        """Find appropriate GDB for target architecture."""
        val candidates = match self.config.base_config.arch:
            case QemuArch.RiscV32 | QemuArch.RiscV64:
                ["riscv32-unknown-elf-gdb", "riscv64-unknown-elf-gdb", "gdb-multiarch", "gdb"]
            case QemuArch.ARM32 | QemuArch.ARM64:
                ["arm-none-eabi-gdb", "aarch64-linux-gnu-gdb", "gdb-multiarch", "gdb"]
            case QemuArch.X86 | QemuArch.X86_64:
                ["gdb-multiarch", "gdb"]
            case _:
                ["gdb"]

        for candidate in candidates:
            val check = shell("which {candidate} 2>/dev/null")
            if check.exit_code == 0:
                return check.stdout.trim()

        ""
    fn set_breakpoint(addr: u64) -> Result<(), text>:
        """Set breakpoint at given address."""
        if not self.gdb_client.?:
            return Err("GDB not connected")

        val gdb = self.gdb_client.unwrap()
        val bp_result = gdb.set_breakpoint_at_addr(addr)

        if bp_result.is_ok():
            Ok(())
        else:
            Err("Failed to set breakpoint at 0x{addr:x}: {bp_result.err.unwrap()}")
    fn continue_execution() -> (BootTestResult, DebugInfo):
        """Continue execution and wait for halt or crash."""
        if not self.gdb_client.?:
            val result = BootTestResult__failure("GDB not connected", "", -1)
            return (result, DebugInfo__unavailable())

        val gdb = self.gdb_client.unwrap()

        # Continue execution using GDB MI exec-continue
        val cont_result = gdb.resume()
        if not cont_result.is_ok():
            val err_msg = cont_result.err.unwrap()
            val result = BootTestResult__failure("Failed to continue: {err_msg}", "", -1)
            return (result, DebugInfo__unavailable())

        # Wait for stop event
        val stop_result = self.wait_for_stop()

        stop_result
    fn wait_for_stop() -> (BootTestResult, DebugInfo):
        """Wait for program to stop (breakpoint, crash, or exit)."""
        if not self.gdb_client.?:
            val result = BootTestResult__failure("GDB not connected", "", -1)
            return (result, DebugInfo__unavailable())

        val gdb = self.gdb_client.unwrap()

        # Check stop reason
        val info_result = self.get_stop_info()
        if not info_result.is_ok():
            val result = BootTestResult__failure("Failed to get stop info", "", -1)
            return (result, DebugInfo__unavailable())

        val stop_info = info_result.ok.unwrap()

        # Extract debug information
        val debug_info = self.extract_debug_info()

        # Determine test result based on stop reason
        val result = match stop_info.reason:
            case "exited-normally":
                BootTestResult__success("", 0)
            case "breakpoint-hit":
                BootTestResult__success("Breakpoint hit at 0x{stop_info.address:x}", 0)
            case "signal-received":
                BootTestResult__crash("", -1)
            case _:
                BootTestResult__failure("Unexpected stop: {stop_info.reason}", "", -1)

        (result, debug_info)
    fn get_stop_info() -> Result<StopInfo, text>:
        """Get information about why execution stopped."""
        if not self.gdb_client.?:
            return Err("GDB not connected")

        val gdb = self.gdb_client.unwrap()

        # Query thread info to determine stop reason
        val thread_result = gdb.send_command("thread-info")
        if not thread_result.is_ok():
            return Err("Failed to query thread info: {thread_result.err.unwrap()}")

        val data = thread_result.ok.unwrap()
        val threads_raw = data.get("threads") ?? "[]"
        val threads = GdbMiParser.parse_tuple_list(threads_raw)

        var reason = "unknown"
        var address: u64 = 0
        var signal = ""

        # Parse the first thread's stop reason
        if threads.len() > 0:
            val thread = threads[0]

            # Extract the frame to get address
            val frame_raw = thread.get("frame") ?? "{}"
            val frame = GdbMiParser.parse_key_values(frame_raw)
            val addr_str = frame.get("addr") ?? "0x0"
            address = parse_hex_value(addr_str)

            # Extract stop reason from thread state
            val state = thread.get("state") ?? ""
            val stop_reason = thread.get("reason") ?? ""

            if stop_reason.len() > 0:
                reason = stop_reason
            elif state == "stopped":
                reason = "stopped"

            # Extract signal name if present
            val sig_name = thread.get("signal-name") ?? ""
            if sig_name.len() > 0:
                signal = sig_name
                if reason == "unknown" or reason == "stopped":
                    reason = "signal-received"

        Ok(StopInfo(reason: reason, address: address, signal: signal))
    fn extract_debug_info() -> DebugInfo:
        """Extract registers and stack trace from stopped program."""
        if not self.gdb_client.?:
            return DebugInfo__unavailable()

        val gdb = self.gdb_client.unwrap()

        # Get registers
        val registers = self.read_registers()

        # Get stack trace
        val stack_trace = self.read_stack_trace()

        # Get program counter
        val pc = registers.get("pc") ?? 0

        DebugInfo__from_gdb(
            registers,
            stack_trace,
            pc,
            "Execution stopped"
        )
    fn read_registers() -> Dict<text, u64>:
        """Read all general-purpose registers."""
        var registers: Dict<text, u64> = {}

        if not self.gdb_client.?:
            return registers

        val gdb = self.gdb_client.unwrap()

        # Use GDB MI to read all register names and values
        # read_all_registers returns Dict<text, i64> with parsed numeric values
        val all_regs_result = gdb.read_all_registers()
        if not all_regs_result.is_ok():
            return registers

        val all_regs = all_regs_result.ok.unwrap()

        # Filter to architecture-relevant registers
        match self.config.base_config.arch:
            case QemuArch.RiscV32 | QemuArch.RiscV64:
                # RISC-V general-purpose registers x0-x31 and pc
                for i in 0..32:
                    val reg_name = "x{i}"
                    val value = all_regs.get(reg_name)
                    if value != nil:
                        registers[reg_name] = value
                # Also map pc
                val pc_val = all_regs.get("pc")
                if pc_val != nil:
                    registers["pc"] = pc_val

            case QemuArch.ARM32:
                # ARM32 registers r0-r15, cpsr
                for i in 0..16:
                    val reg_name = "r{i}"
                    val value = all_regs.get(reg_name)
                    if value != nil:
                        registers[reg_name] = value
                # Map pc (r15 is PC on ARM32)
                val pc_val = all_regs.get("pc")
                if pc_val != nil:
                    registers["pc"] = pc_val

            case QemuArch.ARM64:
                # AArch64 registers x0-x30, sp, pc
                for i in 0..31:
                    val reg_name = "x{i}"
                    val value = all_regs.get(reg_name)
                    if value != nil:
                        registers[reg_name] = value
                val sp_val = all_regs.get("sp")
                if sp_val != nil:
                    registers["sp"] = sp_val
                val pc_val = all_regs.get("pc")
                if pc_val != nil:
                    registers["pc"] = pc_val

            case QemuArch.X86:
                # x86 32-bit registers
                val x86_names = ["eax", "ebx", "ecx", "edx", "esi", "edi", "ebp", "esp", "eip", "eflags"]
                for reg_name in x86_names:
                    val value = all_regs.get(reg_name)
                    if value != nil:
                        registers[reg_name] = value
                # Map pc alias
                val eip_val = registers.get("eip")
                if eip_val != nil:
                    registers["pc"] = eip_val

            case QemuArch.X86_64:
                # x86_64 registers
                val x64_names = ["rax", "rbx", "rcx", "rdx", "rsi", "rdi", "rbp", "rsp", "rip",
                                 "r8", "r9", "r10", "r11", "r12", "r13", "r14", "r15", "rflags"]
                for reg_name in x64_names:
                    val value = all_regs.get(reg_name)
                    if value != nil:
                        registers[reg_name] = value
                # Map pc alias
                val rip_val = registers.get("rip")
                if rip_val != nil:
                    registers["pc"] = rip_val

        registers
    fn read_stack_trace() -> [StackFrame]:
        """Read call stack backtrace."""
        var frames: [StackFrame] = []

        if not self.gdb_client.?:
            return frames

        val gdb = self.gdb_client.unwrap()

        # Use GDB MI stack-list-frames to get backtrace with addresses
        val bt_result = gdb.send_command("stack-list-frames")
        if not bt_result.is_ok():
            return frames

        val data = bt_result.ok.unwrap()
        val frames_raw = data.get("stack") ?? "[]"
        val tuples = GdbMiParser.parse_tuple_list(frames_raw)

        for t in tuples:
            val level = (t.get("level") ?? "0").parse_int() ?? 0
            val addr_str = t.get("addr") ?? "0x0"
            val addr = parse_hex_value(addr_str)
            val func = t.get("func") ?? "??"
            val file = t.get("fullname") ?? t.get("file") ?? ""
            val line = (t.get("line") ?? "0").parse_int() ?? 0

            val frame = StackFrame(
                frame_num: level,
                address: addr,
                function: func,
                file: file,
                line: line
            )
            frames.push(frame)

        frames
    fn cleanup():
        """Clean up GDB and QEMU processes."""
        if self.gdb_client.?:
            var gdb = self.gdb_client.unwrap()
            gdb.disconnect()
            self.gdb_client = nil

        if self.qemu_instance.?:
            var qemu = self.qemu_instance.unwrap()
            qemu.stop()
            self.qemu_instance = nil
# Stop information
class StopInfo:
    """Information about why execution stopped."""
    reason: text      # "exited-normally", "breakpoint-hit", "signal-received"
    address: u64      # Address where stopped
    signal: text      # Signal name if signal-received

# ===========================================================================
# Convenience API
# ===========================================================================

# Run debug boot test with automatic crash analysis
fn run_debug_boot_test(arch: QemuArch, kernel: text, expected: text) -> (BootTestResult, DebugInfo):
    """Run boot test with GDB debugging enabled."""
    var config = DebugBootConfig__new(arch, kernel)
    config.base_config.expect_output(expected)
    config.enable_debug()

    val runner = DebugBootRunner__new(config)
    runner.run()

# ===========================================================================
# Architecture Mapping Helper
# ===========================================================================

# Map QemuArch to remote.types.Architecture for DebugConfig
fn arch_to_debug_arch(arch: QemuArch) -> Architecture:
    match arch:
        case QemuArch.RiscV32: Architecture.RiscV32
        case QemuArch.RiscV64: Architecture.RiscV64
        case QemuArch.ARM32: Architecture.Arm32
        case QemuArch.ARM64: Architecture.Arm64
        case QemuArch.X86: Architecture.X86
        case QemuArch.X86_64: Architecture.X86_64

# ===========================================================================
# Hex Parsing Helper
# ===========================================================================

# Parse a hex string to u64 (convenience wrapper)
fn parse_hex_value_u64(s: text) -> u64:
    var clean = s
    if s.starts_with("0x") or s.starts_with("0X"):
        clean = s.slice(2, s.len())
    var result: u64 = 0
    for i in 0..clean.len():
        val ch = clean.char_at(i)
        var digit: u64 = 0
        if ch >= 48 and ch <= 57:
            digit = ch - 48
        elif ch >= 97 and ch <= 102:
            digit = ch - 97 + 10
        elif ch >= 65 and ch <= 70:
            digit = ch - 65 + 10
        result = result * 16 + digit
    result

# ===========================================================================
# Crash Analysis Utilities
# ===========================================================================

# Format debug info for display
fn format_debug_info(info: DebugInfo) -> text:
    """Format debug information as human-readable text."""
    if not info.available:
        return "Debug information not available"

    var output = ""

    # Fault information
    output = output + "Fault Address: 0x{info.fault_address:x}\n"
    output = output + "Fault Reason: {info.fault_reason}\n\n"

    # Registers
    output = output + "Registers:\n"
    for reg_name in info.registers.keys():
        val value = info.registers[reg_name]
        output = output + "  {reg_name}: 0x{value:x}\n"

    # Stack trace
    if info.stack_trace.len() > 0:
        output = output + "\nStack Trace:\n"
        for frame in info.stack_trace:
            output = output + "  {frame.to_string()}\n"

    output

# Analyze crash and suggest fixes
fn analyze_crash(info: DebugInfo) -> text:
    """Analyze crash and provide suggestions."""
    if not info.available:
        return "Cannot analyze: debug info unavailable"

    var suggestions = ""

    # Check for common crash patterns
    # Null pointer dereference
    if info.fault_address < 0x1000:
        suggestions = suggestions + "- Possible null pointer dereference\n"

    # Stack overflow (depends on architecture)
    # ...

    # Unaligned access
    if info.fault_address % 4 != 0:
        suggestions = suggestions + "- Possible unaligned memory access\n"

    if suggestions.len() == 0:
        suggestions = "No specific suggestions available"

    suggestions
