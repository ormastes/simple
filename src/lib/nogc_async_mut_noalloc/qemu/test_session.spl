# QEMU Test Session Manager
# Manages QEMU instances with lifecycle control for test runners
# Provides automatic reset/reload between tests for context isolation

use std.qemu.mod.{QemuInstance, QemuConfig, QemuArch, interpret_exit_code}
use std.execution.mod.{TestExecutor, ExecutionConfig, ExecutionResult}
use std.nogc_sync_mut.dap.adapter.gdb_mi.GdbMiAdapter
use std.nogc_sync_mut.dap.adapter.mod.AdapterConfig
use app.io.{shell, ProcessResult}

# QEMU test session with lifecycle management
class QemuTestSession:
    arch: QemuArch
    binary_path: text
    gdb_port: i32

    # QEMU instance
    qemu: Option<QemuInstance>

    # Test executor with GDB adapter
    executor: Option<TestExecutor>

    # Session state
    test_count: i32
    running: bool

    # Configuration
    auto_reset: bool             # Reset between tests
    auto_reload: bool            # Reload binary between tests
    timeout_ms: i64

fn QemuTestSession__create(arch: QemuArch, binary_path: text) -> QemuTestSession:
    QemuTestSession(
        arch: arch,
        binary_path: binary_path,
        gdb_port: 1234,  # Default GDB port
        qemu: nil,
        executor: nil,
        test_count: 0,
        running: false,
        auto_reset: true,
        auto_reload: true,
        timeout_ms: 30000
    )


impl QemuTestSession:
    fn with_gdb_port(port: i32) -> QemuTestSession:
        QemuTestSession(
            arch: self.arch,
            binary_path: self.binary_path,
            gdb_port: port,
            qemu: self.qemu,
            executor: self.executor,
            test_count: self.test_count,
            running: self.running,
            auto_reset: self.auto_reset,
            auto_reload: self.auto_reload,
            timeout_ms: self.timeout_ms
        )
    fn with_auto_reset(enabled: bool) -> QemuTestSession:
        QemuTestSession(
            arch: self.arch,
            binary_path: self.binary_path,
            gdb_port: self.gdb_port,
            qemu: self.qemu,
            executor: self.executor,
            test_count: self.test_count,
            running: self.running,
            auto_reset: enabled,
            auto_reload: self.auto_reload,
            timeout_ms: self.timeout_ms
        )
    me start() -> Result<text, text>:
        if self.running:
            return Err("session already running")

        # Create QEMU config with GDB enabled
        val qemu_config = QemuConfig__for_remote_debug(
            self.arch,
            self.binary_path,
            self.gdb_port
        )

        # Start QEMU instance
        val instance = QemuInstance__start(qemu_config)?
        self.qemu = Some(instance)

        # Wait for GDB stub to be ready
        shell("sleep 1")

        # Create execution config
        val exec_config = ExecutionConfig__qemu_riscv32(
            self.binary_path,
            self.gdb_port
        )

        # Create test executor
        val executor = TestExecutor__create(exec_config)?
        self.executor = Some(executor)

        self.running = true
        Ok("QEMU session started on port {self.gdb_port}")
    me stop():
        match self.executor:
            Some(executor):
                executor.cleanup()
            nil:
                pass

        match self.qemu:
            Some(instance):
                instance.stop()
            nil:
                pass

        self.running = false
        self.executor = nil
        self.qemu = nil
    me reset() -> Result<text, text>:
        if not self.running:
            return Err("session not running")

        match self.executor:
            Some(executor):
                executor.reset()?
            nil:
                return Err("no executor available")

        self.test_count = self.test_count + 1
        Ok("session reset for test #{self.test_count}")
    me reload() -> Result<text, text>:
        if not self.running:
            return Err("session not running")

        # Stop QEMU
        self.stop()

        # Wait a bit
        shell("sleep 0.5")

        # Restart with same config
        self.start()
    fn run_test(test_fn: fn() -> Result<text, text>) -> Result<ExecutionResult, text>:
        if not self.running:
            return Err("session not running")

        # Auto-reset before test if configured
        if self.auto_reset and self.test_count > 0:
            self.reset()?

        # Run test function
        val test_result = match test_fn():
            Ok(msg):
                ExecutionResult__ok(msg, 0)
            Err(e):
                ExecutionResult__failure(e, 1)

        # Auto-reload after test if configured
        if self.auto_reload:
            self.reload()?

        Ok(test_result)
    fn execute() -> Result<ExecutionResult, text>:
        if not self.running:
            return Err("session not running")

        match self.executor:
            Some(executor):
                executor.execute()
            nil:
                Err("no executor available")
    fn is_running() -> bool:
        match self.qemu:
            Some(instance): instance.is_running()
            nil: false
# Multi-test session runner
# Manages a single QEMU instance for multiple tests
class QemuMultiTestRunner:
    session: QemuTestSession
    tests: [fn() -> Result<text, text>]
    results: [ExecutionResult]

fn QemuMultiTestRunner__create(arch: QemuArch, binary_path: text) -> QemuMultiTestRunner:
    QemuMultiTestRunner(
        session: QemuTestSession__create(arch, binary_path),
        tests: [],
        results: []
    )


impl QemuMultiTestRunner:
    me add_test(test_fn: fn() -> Result<text, text>):
        self.tests.push(test_fn)
    me run_all() -> Result<[ExecutionResult], text>:
        # Start session
        self.session.start()?

        # Run each test
        for test_fn in self.tests:
            val result = self.session.run_test(test_fn)?
            self.results.push(result)

        # Stop session
        self.session.stop()

        Ok(self.results)
    fn get_results() -> [ExecutionResult]:
        self.results
    fn passed_count() -> i32:
        var count = 0
        for result in self.results:
            if result.success:
                count = count + 1
        count
    fn failed_count() -> i32:
        var count = 0
        for result in self.results:
            if not result.success:
                count = count + 1
        count
# Example usage:
#
# val session = QemuTestSession.create(QemuArch.RiscV32, "test.elf")
#     .with_gdb_port(1234)
#     .with_auto_reset(true)
#
# session.start()
#
# # Test 1
# session.run_test(\: test_basic_boot())
#
# # Test 2 (auto-reset between tests)
# session.run_test(\: test_memory_access())
#
# session.stop()
