# Fixed Map - Linear-Probe Hash Map with Fixed Capacity
#
# Open-addressing hash map using linear probing.
# Fixed capacity, no heap growth. Operations are O(1) average.
#
# Usage:
#   val map = FixedMap.new(32)
#   map.put(42, 100)
#   val v = map.get(42)

export FixedMapEntry, FixedMap

# ============================================================================
# FixedMapEntry - Key-Value Slot
# ============================================================================

class FixedMapEntry:
    """Entry in a fixed-capacity hash map.

    occupied=false means the slot is free for insertion.
    """
    key: i64
    value: i64
    occupied: bool

# ============================================================================
# FixedMap - Open-Addressing Hash Map
# ============================================================================

class FixedMap:
    """Fixed-capacity hash map with linear probing.

    Keys and values are i64. Uses a simple hash function
    suitable for integer keys. Load factor should stay below 75%
    for good performance.
    """
    entries: [FixedMapEntry]
    count: i32
    capacity: i32

    static fn new(capacity: i32) -> FixedMap:
        """Create a new hash map with the given capacity."""
        var entries: [FixedMapEntry] = []
        var i = 0
        while i < capacity:
            entries.push(FixedMapEntry(key: 0, value: 0, occupied: false))
            i = i + 1
        FixedMap(entries: entries, count: 0, capacity: capacity)

    fn hash_index(key: i64) -> i32:
        """Compute hash index for key. Simple multiplicative hash."""
        # Knuth multiplicative hash (golden ratio constant)
        var h = key * 2654435761
        if h < 0:
            h = 0 - h
        h % self.capacity

    me put(key: i64, value: i64) -> bool:
        """Insert or update key-value pair. Returns false if map is full."""
        var idx = self.hash_index(key)
        var probes = 0
        while probes < self.capacity:
            if not self.entries[idx].occupied:
                # Empty slot — insert
                self.entries[idx].key = key
                self.entries[idx].value = value
                self.entries[idx].occupied = true
                self.count = self.count + 1
                return true
            if self.entries[idx].key == key:
                # Key exists — update
                self.entries[idx].value = value
                return true
            # Linear probe
            idx = (idx + 1) % self.capacity
            probes = probes + 1
        false

    fn get(key: i64) -> i64:
        """Get value for key. Returns 0 if not found."""
        var idx = self.hash_index(key)
        var probes = 0
        while probes < self.capacity:
            if not self.entries[idx].occupied:
                return 0
            if self.entries[idx].key == key:
                return self.entries[idx].value
            idx = (idx + 1) % self.capacity
            probes = probes + 1
        0

    fn contains(key: i64) -> bool:
        """Check if key exists in map."""
        var idx = self.hash_index(key)
        var probes = 0
        while probes < self.capacity:
            if not self.entries[idx].occupied:
                return false
            if self.entries[idx].key == key:
                return true
            idx = (idx + 1) % self.capacity
            probes = probes + 1
        false

    me remove(key: i64) -> bool:
        """Remove key from map. Returns false if not found.

        Uses backward-shift deletion to maintain probe chains.
        """
        var idx = self.hash_index(key)
        var probes = 0
        while probes < self.capacity:
            if not self.entries[idx].occupied:
                return false
            if self.entries[idx].key == key:
                # Found — remove and fix probe chain
                self.entries[idx].occupied = false
                self.entries[idx].key = 0
                self.entries[idx].value = 0
                self.count = self.count - 1
                # Backward-shift: rehash subsequent entries
                var next_idx = (idx + 1) % self.capacity
                while self.entries[next_idx].occupied:
                    val ideal = self.hash_index(self.entries[next_idx].key)
                    # Check if next_idx is displaced from its ideal position
                    # past the gap we just created
                    if (next_idx > idx and (ideal <= idx or ideal > next_idx)) or (next_idx < idx and ideal <= idx and ideal > next_idx):
                        self.entries[idx] = FixedMapEntry(
                            key: self.entries[next_idx].key,
                            value: self.entries[next_idx].value,
                            occupied: true
                        )
                        self.entries[next_idx].occupied = false
                        self.entries[next_idx].key = 0
                        self.entries[next_idx].value = 0
                        idx = next_idx
                    next_idx = (next_idx + 1) % self.capacity
                return true
            idx = (idx + 1) % self.capacity
            probes = probes + 1
        false

    fn is_empty() -> bool:
        """Check if map has no entries."""
        self.count == 0

    fn is_full() -> bool:
        """Check if map is at capacity."""
        self.count >= self.capacity

    fn size() -> i32:
        """Return number of entries."""
        self.count
