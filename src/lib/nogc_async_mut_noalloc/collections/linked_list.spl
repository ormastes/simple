# Pool-Allocated Linked List - Doubly-Linked List with Fixed Node Pool
#
# Nodes are allocated from a pre-sized pool. No heap growth.
# Pool exhaustion returns false on insert operations.
# Index-based links (i32) instead of pointers for safety.
#
# Usage:
#   val list = PoolLinkedList.new(32)
#   list.push_back(10)
#   list.push_front(5)
#   val v = list.pop_front()

export ListNode, PoolLinkedList

# ============================================================================
# ListNode - Doubly-Linked Node
# ============================================================================

class ListNode:
    """Node in a pool-allocated linked list.

    Uses indices into the pool array instead of pointers.
    -1 means no link (null sentinel).
    """
    value: i64
    next: i32      # Index into pool, -1 = end
    prev: i32      # Index into pool, -1 = none

# ============================================================================
# PoolLinkedList - Fixed-Capacity Doubly-Linked List
# ============================================================================

class PoolLinkedList:
    """Doubly-linked list backed by a fixed-size node pool.

    All operations are O(1). Pool exhaustion is signaled by
    returning false from push operations.
    """
    nodes: [ListNode]
    head: i32           # Index of first node, -1 = empty
    tail: i32           # Index of last node, -1 = empty
    free_head: i32      # Head of free list
    len: i32
    capacity: i32

    static fn new(capacity: i32) -> PoolLinkedList:
        """Create a new linked list with a fixed node pool.

        Pre-allocates all nodes and chains them into a free list.
        """
        var nodes: [ListNode] = []
        var i = 0
        while i < capacity:
            # Chain free list: each node points to next
            val next_free = if i < capacity - 1: i + 1 else: -1
            nodes.push(ListNode(value: 0, next: next_free, prev: -1))
            i = i + 1
        PoolLinkedList(
            nodes: nodes,
            head: -1,
            tail: -1,
            free_head: 0,
            len: 0,
            capacity: capacity
        )

    me alloc_node() -> i32:
        """Allocate a node from the free list. Returns -1 if pool exhausted."""
        if self.free_head == -1:
            return -1
        val idx = self.free_head
        self.free_head = self.nodes[idx].next
        self.nodes[idx].next = -1
        self.nodes[idx].prev = -1
        idx

    me free_node(idx: i32):
        """Return a node to the free list."""
        self.nodes[idx].value = 0
        self.nodes[idx].next = self.free_head
        self.nodes[idx].prev = -1
        self.free_head = idx

    me push_front(value: i64) -> bool:
        """Insert value at the front. Returns false if pool exhausted."""
        val idx = self.alloc_node()
        if idx == -1:
            return false
        self.nodes[idx].value = value
        self.nodes[idx].next = self.head
        self.nodes[idx].prev = -1
        if self.head != -1:
            self.nodes[self.head].prev = idx
        self.head = idx
        if self.tail == -1:
            self.tail = idx
        self.len = self.len + 1
        true

    me push_back(value: i64) -> bool:
        """Insert value at the back. Returns false if pool exhausted."""
        val idx = self.alloc_node()
        if idx == -1:
            return false
        self.nodes[idx].value = value
        self.nodes[idx].next = -1
        self.nodes[idx].prev = self.tail
        if self.tail != -1:
            self.nodes[self.tail].next = idx
        self.tail = idx
        if self.head == -1:
            self.head = idx
        self.len = self.len + 1
        true

    me pop_front() -> i64:
        """Remove and return front value. Returns -1 if empty."""
        if self.head == -1:
            return -1
        val idx = self.head
        val value = self.nodes[idx].value
        self.head = self.nodes[idx].next
        if self.head != -1:
            self.nodes[self.head].prev = -1
        else:
            self.tail = -1
        self.free_node(idx)
        self.len = self.len - 1
        value

    me pop_back() -> i64:
        """Remove and return back value. Returns -1 if empty."""
        if self.tail == -1:
            return -1
        val idx = self.tail
        val value = self.nodes[idx].value
        self.tail = self.nodes[idx].prev
        if self.tail != -1:
            self.nodes[self.tail].next = -1
        else:
            self.head = -1
        self.free_node(idx)
        self.len = self.len - 1
        value

    fn peek_front() -> i64:
        """Return front value without removing. Returns -1 if empty."""
        if self.head == -1:
            return -1
        self.nodes[self.head].value

    fn peek_back() -> i64:
        """Return back value without removing. Returns -1 if empty."""
        if self.tail == -1:
            return -1
        self.nodes[self.tail].value

    me remove_at(idx: i32):
        """Remove node at pool index. Caller must ensure idx is valid."""
        val prev_idx = self.nodes[idx].prev
        val next_idx = self.nodes[idx].next
        if prev_idx != -1:
            self.nodes[prev_idx].next = next_idx
        else:
            self.head = next_idx
        if next_idx != -1:
            self.nodes[next_idx].prev = prev_idx
        else:
            self.tail = prev_idx
        self.free_node(idx)
        self.len = self.len - 1

    fn is_empty() -> bool:
        """Check if list has no elements."""
        self.len == 0

    fn is_full() -> bool:
        """Check if node pool is exhausted."""
        self.free_head == -1

    fn size() -> i32:
        """Return number of elements."""
        self.len

    fn contains(value: i64) -> bool:
        """Check if value exists in list. O(n) scan."""
        var cur = self.head
        while cur != -1:
            if self.nodes[cur].value == value:
                return true
            cur = self.nodes[cur].next
        false
