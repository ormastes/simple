# Ring Buffer - Circular FIFO Queue
#
# Power-of-2 sized buffer for fast modulo via bitwise AND.
# Fixed capacity, no heap allocation. Wraps around when full.
#
# Usage:
#   val buf = RingBuffer.new(16)   # Must be power of 2
#   buf.enqueue(42)
#   val v = buf.dequeue()

export RingBuffer
export ring_buffer_16, ring_buffer_32, ring_buffer_64, ring_buffer_128

# ============================================================================
# RingBuffer - Circular FIFO Queue
# ============================================================================

class RingBuffer:
    """Circular buffer with power-of-2 capacity.

    Uses bitwise AND for fast index wrapping.
    Enqueue returns false when full; dequeue returns -1 when empty.
    """
    data: [i64]
    head: i32          # Read position
    tail: i32          # Write position
    mask: i32          # capacity - 1 (for fast modulo)
    count: i32
    capacity: i32

    static fn new(capacity: i32) -> RingBuffer:
        """Create a ring buffer. Capacity must be a power of 2.

        If capacity is not a power of 2, it is rounded up to the next one.
        """
        val actual_cap = next_power_of_2(capacity)
        var data: [i64] = []
        var i = 0
        while i < actual_cap:
            data.push(0)
            i = i + 1
        RingBuffer(
            data: data,
            head: 0,
            tail: 0,
            mask: actual_cap - 1,
            count: 0,
            capacity: actual_cap
        )

    me enqueue(value: i64) -> bool:
        """Add value to back of queue. Returns false if full."""
        if self.count >= self.capacity:
            return false
        self.data[self.tail] = value
        self.tail = (self.tail + 1) & self.mask
        self.count = self.count + 1
        true

    me dequeue() -> i64:
        """Remove and return value from front. Returns -1 if empty."""
        if self.count == 0:
            return -1
        val value = self.data[self.head]
        self.head = (self.head + 1) & self.mask
        self.count = self.count - 1
        value

    fn peek() -> i64:
        """Return front value without removing. Returns -1 if empty."""
        if self.count == 0:
            return -1
        self.data[self.head]

    fn is_empty() -> bool:
        """Check if buffer has no elements."""
        self.count == 0

    fn is_full() -> bool:
        """Check if buffer is at capacity."""
        self.count >= self.capacity

    fn available() -> i32:
        """Return number of free slots."""
        self.capacity - self.count

    fn size() -> i32:
        """Return number of elements in buffer."""
        self.count

    me clear():
        """Remove all elements."""
        self.head = 0
        self.tail = 0
        self.count = 0

# ============================================================================
# Helper - Next Power of 2
# ============================================================================

fn next_power_of_2(n: i32) -> i32:
    """Round up to the next power of 2. Returns n if already a power of 2."""
    if n <= 1:
        return 1
    var v = n - 1
    v = v | (v >> 1)
    v = v | (v >> 2)
    v = v | (v >> 4)
    v = v | (v >> 8)
    v = v | (v >> 16)
    v + 1

# ============================================================================
# Factory Functions
# ============================================================================

fn ring_buffer_16() -> RingBuffer:
    """Create a RingBuffer with capacity 16."""
    RingBuffer.new(16)

fn ring_buffer_32() -> RingBuffer:
    """Create a RingBuffer with capacity 32."""
    RingBuffer.new(32)

fn ring_buffer_64() -> RingBuffer:
    """Create a RingBuffer with capacity 64."""
    RingBuffer.new(64)

fn ring_buffer_128() -> RingBuffer:
    """Create a RingBuffer with capacity 128."""
    RingBuffer.new(128)
