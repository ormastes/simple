# Fixed Stack - LIFO Stack with Fixed Capacity
#
# Bounded-capacity stack. Push returns false when full.
# No heap allocation beyond initial capacity.
#
# Usage:
#   val stack = FixedStack.new(16)
#   stack.push(42)
#   val v = stack.pop()

export FixedStack

# ============================================================================
# FixedStack - LIFO Stack
# ============================================================================

class FixedStack:
    """Fixed-capacity LIFO stack.

    All operations are O(1). Push returns false when full;
    pop returns -1 when empty.
    """
    items: [i64]
    top: i32           # Index of next free slot (= current size)
    capacity: i32

    static fn new(capacity: i32) -> FixedStack:
        """Create a new stack with the given capacity."""
        FixedStack(items: [], top: 0, capacity: capacity)

    me push(value: i64) -> bool:
        """Push value onto stack. Returns false if full."""
        if self.top >= self.capacity:
            return false
        self.items.push(value)
        self.top = self.top + 1
        true

    me pop() -> i64:
        """Pop and return top value. Returns -1 if empty."""
        if self.top == 0:
            return -1
        self.top = self.top - 1
        val value = self.items[self.top]
        value

    fn peek() -> i64:
        """Return top value without removing. Returns -1 if empty."""
        if self.top == 0:
            return -1
        self.items[self.top - 1]

    fn is_empty() -> bool:
        """Check if stack has no elements."""
        self.top == 0

    fn is_full() -> bool:
        """Check if stack is at capacity."""
        self.top >= self.capacity

    fn depth() -> i32:
        """Return number of elements on stack."""
        self.top

    me clear():
        """Remove all elements."""
        self.items = []
        self.top = 0
