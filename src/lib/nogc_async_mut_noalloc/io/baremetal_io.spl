# Baremetal I/O - Sync I/O Classes with AsyncRead/AsyncWrite Method Parity
#
# Bridges baremetal sync I/O and host async trait signatures.
# Same method names as AsyncRead/AsyncWrite for API parity,
# but synchronous (no Future wrapper).
#
# Usage:
#   val writer = SemihostWriter(fd: 1, transport: TRANSPORT_WRITEC)
#   writer.write_text("Hello, baremetal!")
#   writer.flush()

export SemihostReader, SemihostWriter, UartWriter

# ============================================================================
# SemihostReader - Read from host via semihosting
# ============================================================================

class SemihostReader:
    """Synchronous reader using semihosting SYS_READ.

    Method signatures mirror AsyncRead for API parity.
    """
    fd: i32
    is_closed: bool

    static fn new(fd: i32) -> SemihostReader:
        SemihostReader(fd: fd, is_closed: false)

    fn read(size: i64) -> [i32]:
        """Read up to size bytes from the semihost fd.

        Returns array of byte values (i32 for compatibility).
        In interpreter mode, returns empty array.
        """
        # Stub: semihost SYS_READ requires buffer address + length
        # In interpreter mode, return empty
        var result: [i32] = []
        result

    fn read_line() -> text:
        """Read a line from the semihost fd.

        In interpreter mode, returns empty string.
        """
        ""

    me close():
        """Close the semihost fd."""
        if not self.is_closed:
            # In compiled mode: semi_host_call(SYS_CLOSE, self.fd, 0)
            self.is_closed = true

    fn is_open() -> bool:
        """Check if the reader is still open."""
        not self.is_closed

# ============================================================================
# SemihostWriter - Write to host via semihosting
# ============================================================================

class SemihostWriter:
    """Synchronous writer using semihosting transport strategies.

    Dispatches writes through the semihost transport layer
    (WRITEC/WRITE0/WRITE). Method signatures mirror AsyncWrite.
    """
    fd: i32
    transport: i32
    is_closed: bool

    static fn new(fd: i32, transport: i32) -> SemihostWriter:
        SemihostWriter(fd: fd, transport: transport, is_closed: false)

    fn write(data: [i32]) -> i64:
        """Write byte array via semihosting.

        Uses the configured transport strategy.
        Returns number of bytes written.
        In interpreter mode, prints representation.
        """
        val count = data.len()
        # In compiled baremetal mode:
        #   semihost_send_bytes(data_addr, count)
        # In interpreter mode, print byte count
        print "[semihost write: {count} bytes]"
        count

    fn write_text(s: text):
        """Write text string via semihosting.

        In interpreter mode, falls back to print.
        In compiled mode, dispatches through transport.
        """
        # In compiled baremetal mode:
        #   semihost_send_bytes(s_addr, s_len)
        print s

    fn flush():
        """Flush output. No-op for semihosting (unbuffered)."""
        0 + 0

    me close():
        """Close the semihost fd."""
        if not self.is_closed:
            self.is_closed = true

    fn is_open() -> bool:
        """Check if the writer is still open."""
        not self.is_closed

# ============================================================================
# UartWriter - Write to UART registers
# ============================================================================

class UartWriter:
    """Synchronous writer for memory-mapped UART.

    Writes bytes directly to UART data register.
    Requires mem_write_u8 for actual hardware access.
    Method signatures mirror AsyncWrite.
    """
    base_addr: i64
    is_closed: bool

    static fn new(base_addr: i64) -> UartWriter:
        UartWriter(base_addr: base_addr, is_closed: false)

    fn write(data: [i32]) -> i64:
        """Write bytes to UART data register.

        In interpreter mode, prints representation.
        In compiled mode, writes each byte to base_addr+0 (THR).
        """
        val count = data.len()
        # In compiled baremetal mode:
        #   for each byte: mem_write_u8(self.base_addr, byte)
        print "[uart write: {count} bytes]"
        count

    fn write_text(s: text):
        """Write text string to UART.

        In interpreter mode, falls back to print.
        """
        print s

    fn flush():
        """Wait for UART transmit buffer to drain.

        In compiled mode: poll UART LSR register bit 5 (THRE).
        In interpreter mode: no-op.
        """
        0 + 0

    me close():
        """Close the UART writer."""
        if not self.is_closed:
            self.is_closed = true

    fn is_open() -> bool:
        """Check if the writer is still open."""
        not self.is_closed
