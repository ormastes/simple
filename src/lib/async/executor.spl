# Executor - Single-Threaded Task Executor
#
# Runs async tasks cooperatively on a single thread.

use std.async.task.{Task, TaskState}
use std.async.poll.{Poll}
use std.async.ffi.{future_poll_any}

class Executor:
    """Single-threaded async task executor.

    Runs tasks cooperatively on a single thread.
    Tasks yield when waiting for I/O or other futures.

    Example:
        val executor = Executor.new()

        # Spawn tasks
        executor.spawn(Task.new(\: async_task1()))
        executor.spawn(Task.new(\: async_task2()))

        # Run until all tasks complete
        executor.run()
    """
    tasks: [Task]           # Task queue
    ready_queue: [usize]    # IDs of ready tasks
    running: bool           # Executor running flag

    static fn new() -> Executor:
        """Create new executor."""
        Executor(
            tasks: [],
            ready_queue: [],
            running: false
        )

    me spawn(task: Task):
        """Spawn task for execution.

        Args:
            task: Task to spawn

        Task added to ready queue.
        """
        val task_id = task.id
        self.tasks.push(task)
        self.ready_queue.push(task_id)

    me run():
        """Run executor until all tasks complete.

        Blocks until no tasks remain.
        """
        self.running = true

        while self.running and self.tasks.len() > 0:
            self.run_iteration()

        self.running = false

    me run_iteration():
        """Run one executor iteration.

        Polls all ready tasks once.
        """
        if self.ready_queue.len() == 0:
            return

        # Get next ready task
        val task_id = self.ready_queue[0]
        self.ready_queue = self.ready_queue[1:]

        # Find task
        var task_found = false
        var task_index = 0
        for i in 0..self.tasks.len():
            if self.tasks[i].id == task_id:
                task_found = true
                task_index = i
                break

        if not task_found:
            return

        var task = self.tasks[task_index]

        # Poll task
        task.state = TaskState.Running
        val poll_result = future_poll_any(task.future)

        match poll_result:
            case Poll.Ready(_):
                # Task completed
                task.state = TaskState.Completed
                # Remove from tasks
                self.tasks = self.tasks[0:task_index] + self.tasks[task_index + 1:]

            case Poll.Pending:
                # Task still pending
                task.state = TaskState.Suspended
                # Re-add to ready queue
                self.ready_queue.push(task_id)

        self.tasks[task_index] = task

    me shutdown():
        """Shutdown executor.

        Stops after current iteration.
        """
        self.running = false

    fn task_count() -> usize:
        """Get number of active tasks."""
        self.tasks.len()

    fn is_running() -> bool:
        """Check if executor is running."""
        self.running

export Executor
