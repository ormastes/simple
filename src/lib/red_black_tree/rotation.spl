# Red-Black Tree Rotation Operations
#
# Tree rotation operations for maintaining balance.

from .types import tree_root, set_tree_root, tree_nil
from .types import node_right, node_left, node_parent
from .types import set_node_right, set_node_left, set_node_parent
from .types import is_nil_node

# ============================================================================
# TREE ROTATIONS
# ============================================================================

# Left rotation around node x
#     x                y
#    / \              / \
#   a   y     =>     x   c
#      / \          / \
#     b   c        a   b
fn rotate_left(tree, x):
    val nil_sentinel = tree_nil(tree)
    val y = node_right(x)
    val b = node_left(y)

    # Turn y's left subtree into x's right subtree
    var new_x = set_node_right(x, b)

    # Update b's parent if it's not NIL
    var new_b = b
    if is_nil_node(b, nil_sentinel) == false:
        new_b = set_node_parent(b, new_x)

    # Link x's parent to y
    val x_parent = node_parent(x)
    var new_y = set_node_parent(y, x_parent)

    var new_root = tree_root(tree)
    if is_nil_node(x_parent, nil_sentinel):
        # x was root
        new_root = new_y
    else:
        val parent_left = node_left(x_parent)
        if parent_left == x:
            # x was left child
            var new_parent = set_node_left(x_parent, new_y)
            ()
        else:
            # x was right child
            var new_parent = set_node_right(x_parent, new_y)
            ()

    # Put x on y's left
    new_y = set_node_left(new_y, new_x)
    new_x = set_node_parent(new_x, new_y)

    var result_tree = set_tree_root(tree, new_root)
    (result_tree, new_x, new_y)

# Right rotation around node y
#       y              x
#      / \            / \
#     x   c    =>    a   y
#    / \                / \
#   a   b              b   c
fn rotate_right(tree, y):
    val nil_sentinel = tree_nil(tree)
    val x = node_left(y)
    val b = node_right(x)

    # Turn x's right subtree into y's left subtree
    var new_y = set_node_left(y, b)

    # Update b's parent if it's not NIL
    var new_b = b
    if is_nil_node(b, nil_sentinel) == false:
        new_b = set_node_parent(b, new_y)

    # Link y's parent to x
    val y_parent = node_parent(y)
    var new_x = set_node_parent(x, y_parent)

    var new_root = tree_root(tree)
    if is_nil_node(y_parent, nil_sentinel):
        # y was root
        new_root = new_x
    else:
        val parent_left = node_left(y_parent)
        if parent_left == y:
            # y was left child
            var new_parent = set_node_left(y_parent, new_x)
            ()
        else:
            # y was right child
            var new_parent = set_node_right(y_parent, new_x)
            ()

    # Put y on x's right
    new_x = set_node_right(new_x, new_y)
    new_y = set_node_parent(new_y, new_x)

    var result_tree = set_tree_root(tree, new_root)
    (result_tree, new_x, new_y)
