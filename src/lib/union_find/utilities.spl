# Union-Find Utility Functions

fn uf_reset(uf):
    """Reset Union-Find to initial state (all elements separate).

    Example:
        val uf2 = uf_reset(uf)  # Back to all separate sets
    """
    val (parent, _, _, _) = uf
    val n = parent.len()
    uf_create(n)

fn uf_compress_all(uf):
    """Apply path compression to all elements.

    Forces all elements to point directly to their root for optimal
    subsequent operations. Useful after many union operations.

    Example:
        val uf2 = uf_compress_all(uf)
    """
    val (parent, rank, size, count) = uf

    var i = 0
    while i < parent.len():
        uf_find(uf, i)  # Side effect: compresses path
        i = i + 1

    uf

fn connected_components_uf(edges, n):
    """Find connected components in undirected graph using Union-Find.

    edges: array of (u, v) tuples representing undirected edges
    n: number of nodes (0 to n-1)

    Returns (uf, components) where components is array of arrays.

    Example:
        val edges = [(0, 1), (1, 2), (3, 4)]
        val (uf, comps) = connected_components_uf(edges, 5)
        # comps = [[0, 1, 2], [3, 4]]
    """
    var uf = uf_create(n)

    for (u, v) in edges:
        uf = uf_union(uf, u, v)

    val components = uf_all_sets(uf)
    (uf, components)

fn count_components(edges, n):
    """Count number of connected components.

    Example:
        count_components([(0, 1), (2, 3)], 4)  # 2 components
    """
    val (uf, _) = connected_components_uf(edges, n)
    uf_count_sets(uf)

fn is_tree_check(edges, n):
    """Check if undirected graph is a tree.

    A tree has exactly n-1 edges and is connected (one component).

    Example:
        is_tree_check([(0, 1), (1, 2)], 3)  # true
        is_tree_check([(0, 1), (1, 2), (2, 0)], 3)  # false (has cycle)
    """
    # Tree must have exactly n-1 edges
    if edges.len() != n - 1:
        return false

    # Tree must be connected (one component)
    val num_components = count_components(edges, n)
    num_components == 1

fn detect_cycle_edges(edges, n):
    """Detect cycle edges in undirected graph.

    Returns array of edges that create cycles when added.
    An edge creates a cycle if both endpoints are already connected.

    Example:
        val cycle_edges = detect_cycle_edges([(0, 1), (1, 2), (2, 0)], 3)
        # cycle_edges = [(2, 0)]  # This edge creates the cycle
    """
    var uf = uf_create(n)
    var cycle_edges = []

    for edge in edges:
        val (u, v) = edge

        if uf_connected(uf, u, v):
            # Edge creates a cycle
            cycle_edges.push(edge)
        else:
            uf = uf_union(uf, u, v)

    cycle_edges

fn has_cycle(edges, n):
    """Check if undirected graph has a cycle.

    Example:
        has_cycle([(0, 1), (1, 2), (2, 0)], 3)  # true
        has_cycle([(0, 1), (1, 2)], 3)  # false
    """
    val cycle_edges = detect_cycle_edges(edges, n)
    cycle_edges.len() > 0

fn kruskal_mst(edges, n):
    """Find Minimum Spanning Tree using Kruskal's algorithm.

    edges: array of (u, v, weight) tuples
    n: number of nodes (0 to n-1)

    Returns array of edges in MST, or nil if graph is not connected.

    Example:
        val edges = [(0, 1, 4), (1, 2, 8), (0, 2, 7)]
        val mst = kruskal_mst(edges, 3)  # [(0, 1, 4), (0, 2, 7)]
    """
    # Sort edges by weight (simple bubble sort)
    var sorted_edges = edges
    var changed = true
    while changed:
        changed = false
        var i = 0
        while i < sorted_edges.len() - 1:
            val (_, _, w1) = sorted_edges[i]
            val (_, _, w2) = sorted_edges[i + 1]
            if w1 > w2:
                val temp = sorted_edges[i]
                sorted_edges[i] = sorted_edges[i + 1]
                sorted_edges[i + 1] = temp
                changed = true
            i = i + 1

    var uf = uf_create(n)
    var mst_edges = []

    for edge in sorted_edges:
        val (u, v, weight) = edge

        # Add edge if it doesn't create a cycle
        if not uf_connected(uf, u, v):
            mst_edges.push(edge)
            uf = uf_union(uf, u, v)

            # MST complete when we have n-1 edges
            if mst_edges.len() == n - 1:
                break

    # Check if graph is connected
    if mst_edges.len() != n - 1:
        return nil

    mst_edges

fn kruskal_mst_cost(edges, n):
    """Calculate total cost of MST.

    Returns total weight of MST, or nil if graph is not connected.

    Example:
        kruskal_mst_cost([(0, 1, 4), (1, 2, 8), (0, 2, 7)], 3)  # 11
    """
    val mst = kruskal_mst(edges, n)

    if not mst.?:
        return nil

    var total = 0
    for (_, _, weight) in mst:
        total = total + weight

    total

fn kruskal_forest(edges, n):
    """Find Minimum Spanning Forest (MST for each component).

    Similar to kruskal_mst but works on disconnected graphs.
    Returns array of edges forming the forest.

    Example:
        val edges = [(0, 1, 4), (3, 4, 5)]
        kruskal_forest(edges, 5)  # [(0, 1, 4), (3, 4, 5)]
    """
    # Sort edges by weight
    var sorted_edges = edges
    var changed = true
    while changed:
        changed = false
        var i = 0
        while i < sorted_edges.len() - 1:
            val (_, _, w1) = sorted_edges[i]
            val (_, _, w2) = sorted_edges[i + 1]
            if w1 > w2:
                val temp = sorted_edges[i]
                sorted_edges[i] = sorted_edges[i + 1]
                sorted_edges[i + 1] = temp
                changed = true
            i = i + 1

    var uf = uf_create(n)
    var forest_edges = []

    for edge in sorted_edges:
        val (u, v, weight) = edge

        if not uf_connected(uf, u, v):
            forest_edges.push(edge)
            uf = uf_union(uf, u, v)

    forest_edges

fn uf_print_structure(uf):
    """Print Union-Find structure for debugging.

    Shows parent array, ranks, sizes, and component count.

    Example:
        uf_print_structure(uf)
    """
    val (parent, rank, size, count) = uf

    print "Union-Find Structure:"
    print "  Elements: {parent.len()}"
    print "  Components: {count}"
    print "  Parent: {parent}"
    print "  Rank: {rank}"
    print "  Size: {size}"
    print ""

fn uf_print_sets(uf):
    """Print all disjoint sets.

    Example:
        uf_print_sets(uf)
        # Output:
        # Set 0: [0, 1, 2]
        # Set 1: [3, 4]
    """
    val sets = uf_all_sets(uf)

    print "Disjoint Sets:"
    var i = 0
    for s in sets:
        print "  Set {i}: {s}"
        i = i + 1
    print ""
