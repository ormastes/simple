# Union-Find Query Operations

fn uf_connected(uf, x, y):
    """Check if x and y are in the same set.

    Example:
        uf_connected(uf, 0, 1)  # true if in same set
    """
    uf_find(uf, x) == uf_find(uf, y)

fn uf_same_set(uf, x, y):
    """Alias for uf_connected.

    Example:
        uf_same_set(uf, 2, 3)
    """
    uf_connected(uf, x, y)

fn uf_count_sets(uf):
    """Get number of disjoint sets.

    Example:
        val num_sets = uf_count_sets(uf)  # 3 means 3 separate components
    """
    val (_, _, _, count) = uf
    count

fn uf_set_size(uf, x):
    """Get size of set containing x.

    Example:
        val sz = uf_set_size(uf, 0)  # Size of component containing 0
    """
    val (_, _, size, _) = uf
    val root = uf_find(uf, x)
    size[root]

fn uf_representatives(uf):
    """Get array of representative (root) elements from each set.

    Returns array of root elements, one per disjoint set.

    Example:
        uf_representatives(uf)  # [0, 3, 5] means 3 sets with roots 0, 3, 5
    """
    val (parent, _, _, _) = uf
    var roots = []

    var i = 0
    while i < parent.len():
        val root = uf_find(uf, i)

        # Check if root already in list
        var found = false
        for r in roots:
            if r == root:
                found = true
                break

        if not found:
            roots.push(root)

        i = i + 1

    roots

fn uf_all_sets(uf):
    """Get all sets as array of arrays.

    Returns array where each element is an array of elements in one set.

    Example:
        uf_all_sets(uf)  # [[0, 1, 2], [3, 4], [5]]
    """
    val (parent, _, _, _) = uf

    # Build map from root to elements
    var sets_map = []

    var i = 0
    while i < parent.len():
        val root = uf_find(uf, i)

        # Find or create set for this root
        var found_idx = -1
        var j = 0
        while j < sets_map.len():
            val (r, _) = sets_map[j]
            if r == root:
                found_idx = j
                break
            j = j + 1

        if found_idx == -1:
            # Create new set
            sets_map.push((root, [i]))
        else:
            # Add to existing set
            val (r, elements) = sets_map[found_idx]
            elements.push(i)
            sets_map[found_idx] = (r, elements)

        i = i + 1

    # Extract just the element arrays
    var result = []
    for (_, elements) in sets_map:
        result.push(elements)

    result

fn uf_elements_in_set(uf, x):
    """Get all elements in the same set as x.

    Example:
        uf_elements_in_set(uf, 0)  # [0, 1, 2] if 0, 1, 2 are connected
    """
    val (parent, _, _, _) = uf
    val root = uf_find(uf, x)

    var elements = []
    var i = 0
    while i < parent.len():
        if uf_find(uf, i) == root:
            elements.push(i)
        i = i + 1

    elements

fn uf_set_sizes(uf):
    """Get array of sizes for all disjoint sets.

    Returns array of set sizes (one per set).

    Example:
        uf_set_sizes(uf)  # [3, 2, 1] means sets of size 3, 2, and 1
    """
    val roots = uf_representatives(uf)
    var sizes = []

    for root in roots:
        sizes.push(uf_set_size(uf, root))

    sizes

fn uf_largest_set_size(uf):
    """Get size of largest set.

    Example:
        uf_largest_set_size(uf)  # 5 if largest component has 5 elements
    """
    val sizes = uf_set_sizes(uf)

    if sizes.len() == 0:
        return 0

    var max_size = sizes[0]
    for sz in sizes:
        if sz > max_size:
            max_size = sz

    max_size

fn uf_smallest_set_size(uf):
    """Get size of smallest set.

    Example:
        uf_smallest_set_size(uf)  # 1 if smallest component has 1 element
    """
    val sizes = uf_set_sizes(uf)

    if sizes.len() == 0:
        return 0

    var min_size = sizes[0]
    for sz in sizes:
        if sz < min_size:
            min_size = sz

    min_size

fn uf_is_fully_connected(uf):
    """Check if all elements are in single set.

    Example:
        uf_is_fully_connected(uf)  # true if only one component
    """
    uf_count_sets(uf) == 1

fn uf_is_fully_disconnected(uf):
    """Check if all elements are in separate sets.

    Example:
        uf_is_fully_disconnected(uf)  # true if no unions performed
    """
    val (parent, _, _, _) = uf
    uf_count_sets(uf) == parent.len()

fn are_all_connected(uf, elements):
    """Check if all elements are in the same set.

    Example:
        are_all_connected(uf, [0, 1, 2])  # true if all in same component
    """
    if elements.len() <= 1:
        return true

    val first_root = uf_find(uf, elements[0])

    var i = 1
    while i < elements.len():
        if uf_find(uf, elements[i]) != first_root:
            return false
        i = i + 1

    true

fn partition_by_sets(uf, elements):
    """Partition elements into groups by their sets.

    Returns array of arrays, where each inner array contains elements
    from the same set.

    Example:
        partition_by_sets(uf, [0, 1, 2, 3, 4])
        # [[0, 2], [1, 3, 4]] if 0,2 are connected and 1,3,4 are connected
    """
    var groups = []

    for elem in elements:
        val root = uf_find(uf, elem)

        # Find or create group for this root
        var found_idx = -1
        var i = 0
        while i < groups.len():
            val (group_root, _) = groups[i]
            if group_root == root:
                found_idx = i
                break
            i = i + 1

        if found_idx == -1:
            groups.push((root, [elem]))
        else:
            val (r, group_elems) = groups[found_idx]
            group_elems.push(elem)
            groups[found_idx] = (r, group_elems)

    # Extract just element arrays
    var result = []
    for (_, group_elems) in groups:
        result.push(group_elems)

    result

fn uf_connected_all(uf, pairs):
    """Check if all pairs are connected.

    Returns true only if every (x, y) pair is in the same set.

    Example:
        uf_connected_all(uf, [(0, 1), (1, 2)])  # true if 0,1,2 all connected
    """
    for (x, y) in pairs:
        if not uf_connected(uf, x, y):
            return false
    true

fn uf_connected_any(uf, pairs):
    """Check if any pair is connected.

    Returns true if at least one (x, y) pair is in the same set.

    Example:
        uf_connected_any(uf, [(0, 1), (2, 3)])  # true if either pair connected
    """
    for (x, y) in pairs:
        if uf_connected(uf, x, y):
            return true
    false

fn uf_weight_diff(uf, x, y):
    """Get weight difference between x and y if in same set.

    Returns weight[y] - weight[x], or nil if not connected.

    Example:
        uf_weight_diff(wuf, 0, 1)  # 5 if union_weighted(0, 1, 5) was called
    """
    if not uf_connected(uf, x, y):
        return nil

    val (_, _, _, weight, _) = uf
    weight[y] - weight[x]

fn uf_statistics(uf):
    """Get comprehensive statistics about Union-Find structure.

    Returns tuple:
    (num_sets, total_elements, avg_set_size, max_set_size, min_set_size)

    Example:
        val (sets, elems, avg, max, min) = uf_statistics(uf)
    """
    val (parent, _, _, _) = uf
    val num_sets = uf_count_sets(uf)
    val total_elements = parent.len()
    val sizes = uf_set_sizes(uf)

    var max_size = 0
    var min_size = 0
    var sum_size = 0

    if sizes.len() > 0:
        max_size = sizes[0]
        min_size = sizes[0]

        for sz in sizes:
            sum_size = sum_size + sz
            if sz > max_size:
                max_size = sz
            if sz < min_size:
                min_size = sz

    val avg_size = if num_sets > 0: sum_size / num_sets else: 0

    (num_sets, total_elements, avg_size, max_size, min_size)
