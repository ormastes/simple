# Standard Library — Process Monitor and Link
#
# @tag:api
# @tag:stdlib
#
# Process monitoring and linking for actor-style concurrency.
# monitor() creates a one-way watch: you get notified when the monitored
# process dies. link() creates a bidirectional connection: if either dies,
# the other gets an exit signal.
#
# DownEvent: notification sent to monitor when monitored process exits.
# LinkExitEvent: notification sent when a linked process exits.
#
# Runtime FFI stubs: actual inter-process signaling requires runtime support.
# These stubs provide the data types and API contract for compiled mode.
#
# Usage:
#   val ref = monitor(worker_pid)
#   link(partner_pid)

# Exit reason constants
val EXIT_NORMAL = "normal"      # clean exit
val EXIT_KILLED = "killed"      # forcefully killed
val EXIT_CRASHED = "crashed"    # unhandled error
val EXIT_TIMEOUT = "timeout"    # timed out

# DownEvent: sent to a monitoring process when the monitored process exits.
struct DownEvent:
    monitor_ref: i64   # the ref returned by monitor()
    pid: i64           # pid of the process that exited
    reason: text       # EXIT_NORMAL, EXIT_KILLED, EXIT_CRASHED, or custom text

# LinkExitEvent: sent to a linked process when its partner exits abnormally.
struct LinkExitEvent:
    pid: i64     # pid of the process that exited
    reason: text # exit reason

# Monitor a process. Returns a monitor reference id.
# When the monitored process exits, a DownEvent is delivered to the caller's mailbox.
# Stub: returns 0 (actual runtime process management required for real dispatch).
fn monitor(pid: i64) -> i64:
    0

# Demonitor — cancel an active monitor.
# Stub: no-op until runtime process management is available.
fn demonitor(monitor_ref: i64):
    pass_do_nothing

# Link to another process (bidirectional).
# If either process exits abnormally, the other receives a LinkExitEvent.
# Stub: no-op until runtime process management is available.
fn link(pid: i64):
    pass_do_nothing

# Unlink from a process.
fn unlink(pid: i64):
    pass_do_nothing

# Create a DownEvent with the given fields.
fn down_event(monitor_ref: i64, pid: i64, reason: text) -> DownEvent:
    DownEvent(monitor_ref: monitor_ref, pid: pid, reason: reason)

# Create a LinkExitEvent with the given fields.
fn link_exit_event(pid: i64, reason: text) -> LinkExitEvent:
    LinkExitEvent(pid: pid, reason: reason)

# Check if a DownEvent represents a normal (clean) exit.
fn down_is_normal(evt: DownEvent) -> bool:
    evt.reason == EXIT_NORMAL

export EXIT_NORMAL, EXIT_KILLED, EXIT_CRASHED, EXIT_TIMEOUT
export DownEvent, LinkExitEvent
export monitor, demonitor, link, unlink
export down_event, link_exit_event, down_is_normal
