# Base64 Utilities Module
#
# Low-level utility functions for character, byte, and bit operations

use string.{char_from_code}
use base64::types::{BASE64_ALPHABET, PADDING_CHAR}

# ============================================================================
# CHARACTER AND BYTE UTILITIES
# ============================================================================

# Get the character code for a single character
fn char_code(c: text) -> i64:
    if c == "":
        return 0
    var result = c.char_code_at(0)
    return result

# Create a character from a character code

fn is_whitespace_char(c: text) -> bool:
    var result = false
    if c == " ": result = true
    if c == "\n": result = true
    if c == "\r": result = true
    if c == "\t": result = true
    result

# Check if character is valid Base64
fn is_base64_char(c: text) -> bool:
    var alphabet = BASE64_ALPHABET
    var i = 0
    var found = false
    while i < 64:
        val alphabet_char = text_char_at(alphabet, i)
        if c == alphabet_char:
            found = true
            return found
        i = i + 1
    found

# Get character at position in text
fn text_char_at(s: text, pos: i64) -> text:
    var slen = s.length()
    if pos < 0:
        return ""
    if pos >= slen:
        return ""
    var result = s.substring(pos, pos + 1)
    return result

# Get text length
fn text_length(s: text) -> i64:
    s.length()

# Get substring
fn text_substring(s: text, start: i64, end: i64) -> text:
    var slen = s.length()
    var real_start = start
    var real_end = end
    if real_start < 0:
        real_start = 0
    if real_end > slen:
        real_end = slen
    if real_start >= real_end:
        return ""
    var result = s.substring(real_start, real_end)
    return result

# Helper for substring
fn text_substring_helper(s: text, skip_first: i64) -> text:
    if s == "":
        return ""
    if skip_first == 0:
        # Return first character using string slicing
        var result = s.substring(0, 1)
        return result
    else:
        # Return everything after first character
        var slen = s.length()
        if slen <= 1:
            return ""
        var result = s.substring(1, slen)
        return result

# Concatenate two texts
fn text_concat(a: text, b: text) -> text:
    "{a}{b}"

# ============================================================================
# BYTE AND BIT OPERATIONS
# ============================================================================

# Convert byte to 8-bit binary string
fn byte_to_bits(b: i64) -> text:
    var result = ""
    var value = b
    var i = 0
    while i < 8:
        var bit = value % 2
        if bit == 0:
            result = text_concat("0", result)
        else:
            result = text_concat("1", result)
        value = value / 2
        i = i + 1
    result

# Convert 8-bit binary string to byte
fn bits_to_byte(bits: text) -> i64:
    var result = 0
    var i = 0
    while i < 8:
        var bit_char = text_char_at(bits, i)
        result = result * 2
        if bit_char == "1":
            result = result + 1
        i = i + 1
    result

# Convert text to list of byte values
fn text_to_bytes(s: text) -> list:
    var result = []
    var i = 0
    var len = s.length()
    while i < len:
        var code = s.char_code_at(i)
        result.push(code)
        i = i + 1
    result

# Convert list of byte values to text
fn bytes_to_text(bytes: list) -> text:
    var result = ""
    var i = 0
    var len = bytes.len()
    while i < len:
        var byte_val = bytes[i]
        var c = char_from_code(byte_val)
        result = result + c
        i = i + 1
    result

# List helper functions
fn list_append(lst: list, item: i64) -> list:
    var new_list = []
    var i = 0
    var len = lst.len()
    while i < len:
        new_list.push(lst[i])
        i = i + 1
    new_list.push(item)
    new_list

fn list_get(lst: list, index: i64) -> i64:
    if index < 0:
        return 0
    var len = lst.len()
    if index >= len:
        return 0
    lst[index]

fn list_length(lst: list) -> i64:
    lst.len()

# ============================================================================
# BASE64 CHARACTER MAPPING
# ============================================================================

# Convert character to Base64 index (0-63)
fn char_to_base64_index(c: text, alphabet: text) -> i64:
    var i = 0
    while i < 64:
        val alphabet_char = text_char_at(alphabet, i)
        if c == alphabet_char:
            return i
        i = i + 1
    -1  # Invalid character

# Convert Base64 index to character
fn base64_index_to_char(index: i64, alphabet: text) -> text:
    if index < 0:
        return ""
    if index >= 64:
        return ""
    text_char_at(alphabet, index)

# ============================================================================
# PADDING UTILITIES
# ============================================================================

# Calculate padding needed for given length
fn calculate_padding(length: i64) -> i64:
    var remainder = length % 4
    if remainder == 0:
        return 0
    4 - remainder

# Add padding to encoded string
fn add_padding(encoded: text) -> text:
    var padding_needed = calculate_padding(text_length(encoded))
    var result = encoded
    var i = 0
    while i < padding_needed:
        result = text_concat(result, PADDING_CHAR)
        i = i + 1
    result

# Remove padding from encoded string
fn remove_padding(encoded: text) -> text:
    var result = encoded
    var len = text_length(result)
    while len > 0:
        var last_char = text_char_at(result, len - 1)
        if last_char == PADDING_CHAR:
            result = text_substring(result, 0, len - 1)
            len = len - 1
        else:
            return result
    result

# Count padding characters
fn count_padding(encoded: text) -> i64:
    var count = 0
    var len = text_length(encoded)
    var i = len - 1
    while i >= 0:
        var c = text_char_at(encoded, i)
        if c == PADDING_CHAR:
            count = count + 1
        else:
            return count
        i = i - 1
    count

# ============================================================================
# SIZE ESTIMATION
# ============================================================================

# Estimate encoded size for Base64
fn estimate_encoded_size(input_length: i64) -> i64:
    var base_size = (input_length * 4) / 3
    var remainder = input_length % 3
    if remainder != 0:
        base_size = base_size + 4 - remainder
    base_size

# Estimate decoded size for Base64
fn estimate_decoded_size(encoded_length: i64) -> i64:
    var padding = count_padding("")  # Would need actual string
    var effective_length = encoded_length - padding
    (effective_length * 3) / 4

# ============================================================================
# WHITESPACE AND TEXT HELPERS
# ============================================================================

# Strip whitespace from encoded data
fn strip_whitespace(encoded: text) -> text:
    var result = ""
    var i = 0
    var len = text_length(encoded)

    while i < len:
        var c = text_char_at(encoded, i)
        var is_ws = is_whitespace_char(c)
        if not is_ws:
            result = text_concat(result, c)
        i = i + 1

    result

# Find character index in alphabet
fn find_char_in_alphabet(c: text, alphabet: text) -> i64:
    var i = 0
    var len = text_length(alphabet)
    while i < len:
        var alphabet_c = text_char_at(alphabet, i)
        if c == alphabet_c:
            return i
        i = i + 1
    -1

# ============================================================================
# INTEGER CONVERSION UTILITIES
# ============================================================================

# Convert integer to text
fn int_to_text(n: i64) -> text:
    if n == 0: return "0"
    var result = ""
    var value = n
    var is_negative = false
    if value < 0:
        is_negative = true
        value = 0 - value
    while value > 0:
        var digit = value % 10
        var digit_char = char_from_code(48 + digit)
        result = text_concat(digit_char, result)
        value = value / 10
    if is_negative:
        result = text_concat("-", result)
    result

# Convert text to integer
fn text_to_int(s: text) -> i64:
    var result = 0
    var i = 0
    var len = text_length(s)
    var is_negative = false

    if len > 0:
        var first = text_char_at(s, 0)
        if first == "-":
            is_negative = true
            i = 1

    while i < len:
        var c = text_char_at(s, i)
        var code = char_code(c)
        var digit = code - 48
        result = (result * 10) + digit
        i = i + 1

    if is_negative:
        result = 0 - result
    result

# ============================================================================
# SECURITY UTILITIES
# ============================================================================

# Constant-time string comparison (prevents timing attacks)
fn compare_constant_time(s1: text, s2: text) -> bool:
    var len1 = text_length(s1)
    var len2 = text_length(s2)
    var result = 0

    # Always compare full length to avoid timing leaks
    var max_len = len1
    if len2 > max_len:
        max_len = len2

    # Length difference contributes to result
    if len1 != len2:
        result = result + 1

    var i = 0
    while i < max_len:
        var c1 = ""
        var c2 = ""
        if i < len1:
            c1 = text_char_at(s1, i)
        if i < len2:
            c2 = text_char_at(s2, i)
        if c1 != c2:
            result = result + 1
        i = i + 1

    result == 0

# ============================================================================
# MULTILINE/CHUNKING UTILITIES
# ============================================================================

# Wrap encoded data at specified width
fn encode_multiline(encoded: text, width: i64) -> text:
    var result = ""
    var i = 0
    var len = text_length(encoded)

    while i < len:
        var end = i + width
        if end > len:
            end = len
        var chunk = text_substring(encoded, i, end)
        result = text_concat(result, chunk)
        if end < len:
            result = text_concat(result, "\n")
        i = end

    result
