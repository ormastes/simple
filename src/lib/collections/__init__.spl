# Collections Module
# @tag:api
#
# Advanced collection data structures.
# Provides persistent and concurrent collections with structural sharing.
#
# This module implements immutable, efficient data structures inspired by
# Clojure and Haskell. They use structural sharing to minimize copying,
# making immutable updates O(log n) instead of O(n). Ideal for functional
# programming, concurrent algorithms, and compiler symbol tables.
#
# Public API:
#   - use lib.collections.{LazySeq, PersistentDict, PersistentVec}
#   - use lib.collections.{Trie, RRBTree, ImmutableSet}
#
# Example: Persistent vector (efficient immutable array)
#
#     use lib.collections.{PersistentVec}
#
#     # Create persistent vector from array
#     val vec1 = PersistentVec.from_array([1, 2, 3, 4, 5])
#
#     # Add element (returns new vector, original unchanged)
#     val vec2 = vec1.push(6)
#     # vec1 = [1, 2, 3, 4, 5]  (unchanged)
#     # vec2 = [1, 2, 3, 4, 5, 6]
#
#     # Update element (O(log n) with structural sharing)
#     val vec3 = vec2.set(2, 99)
#     # vec2 = [1, 2, 3, 4, 5, 6]  (unchanged)
#     # vec3 = [1, 2, 99, 4, 5, 6]
#
#     # Access element (O(log n))
#     val elem = vec3.get(2)  # 99
#
#     # Convert back to array
#     val arr = vec3.to_array()  # [1, 2, 99, 4, 5, 6]
#
# Example: Persistent dictionary (immutable hash map)
#
#     use lib.collections.{PersistentDict}
#
#     # Create empty dictionary
#     val dict1 = PersistentDict.empty()
#
#     # Add entries (returns new dict each time)
#     val dict2 = dict1.insert("name", "Alice")
#     val dict3 = dict2.insert("age", "30")
#     val dict4 = dict3.insert("city", "Seattle")
#
#     # Lookup (O(log n))
#     val name = dict4.get("name")  # Some("Alice")
#     val missing = dict4.get("country")  # nil
#
#     # Remove entry
#     val dict5 = dict4.remove("age")
#     # dict4 still has "age", dict5 does not
#
#     # Iteration over entries
#     for (key, value) in dict5.entries():
#         print "{key}: {value}"
#
# Example: Lazy sequences (infinite sequences with memoization)
#
#     use lib.collections.{LazySeq}
#
#     # Create lazy infinite sequence: 0, 1, 2, 3, ...
#     val naturals = LazySeq.from_fn(\n: n)
#
#     # Map is lazy (not computed until forced)
#     val squares = naturals.map(\n: n * n)
#
#     # Take first 5 elements (only these are computed)
#     val first_five = squares.take(5).to_array()
#     # [0, 1, 4, 9, 16]
#
#     # Filter is also lazy
#     val evens = naturals.filter(\n: n % 2 == 0)
#     val first_five_evens = evens.take(5).to_array()
#     # [0, 2, 4, 6, 8]
#
# Example: Trie (prefix tree for string keys)
#
#     use lib.collections.{Trie}
#
#     # Create empty trie
#     val trie = Trie.empty()
#
#     # Insert words with values
#     val t1 = trie.insert("cat", 1)
#     val t2 = t1.insert("car", 2)
#     val t3 = t2.insert("card", 3)
#     val t4 = t3.insert("dog", 4)
#
#     # Lookup by exact key
#     val cat_val = t4.get("cat")  # Some(1)
#
#     # Find all keys with prefix
#     val c_words = t4.keys_with_prefix("ca")
#     # ["cat", "car", "card"]

# All submodules are automatically available.
