# Lazy Sequences
#
# Provides lazy/infinite sequences with functional operations.
# Backed by thunk-based lazy evaluation.

class LazySeq:
    head_val: i64
    has_head: bool
    tail_thunk: fn()
    has_tail: bool

    fn is_empty() -> bool:
        not self.has_head

    fn head():
        if self.has_head:
            return self.head_val
        nil

    fn tail() -> LazySeq:
        if not self.has_tail:
            return LazySeq__empty()
        self.tail_thunk()

    fn nth(n: i64):
        var current = self
        var i = 0
        for _ in 0..n:
            if current.is_empty():
                return nil
            current = current.tail()
            i = i + 1
        current.head()

    fn map(f: fn()) -> LazySeq:
        if self.is_empty():
            return LazySeq__empty()
        val h = f(self.head_val)
        val rest = self
        LazySeq(
            head_val: h,
            has_head: true,
            tail_thunk: fn():
                rest.tail().map(f)
            ,
            has_tail: true
        )

    fn filter(pred: fn()) -> LazySeq:
        var current = self
        # Safety limit to prevent infinite loops on unbounded sequences
        for _ in 0..1000000:
            if current.is_empty():
                return LazySeq__empty()
            if pred(current.head_val):
                val h = current.head_val
                val rest = current
                return LazySeq(
                    head_val: h,
                    has_head: true,
                    tail_thunk: fn():
                        rest.tail().filter(pred)
                    ,
                    has_tail: true
                )
            current = current.tail()
        LazySeq__empty()

    fn take(n: i64) -> LazySeq:
        if n <= 0:
            return LazySeq__empty()
        if self.is_empty():
            return LazySeq__empty()
        val h = self.head_val
        val rest = self
        val remaining = n - 1
        LazySeq(
            head_val: h,
            has_head: true,
            tail_thunk: fn():
                rest.tail().take(remaining)
            ,
            has_tail: true
        )

    fn drop(n: i64) -> LazySeq:
        var current = self
        for _ in 0..n:
            if current.is_empty():
                return LazySeq__empty()
            current = current.tail()
        current

    fn take_while(pred: fn()) -> LazySeq:
        if self.is_empty():
            return LazySeq__empty()
        if not pred(self.head_val):
            return LazySeq__empty()
        val h = self.head_val
        val rest = self
        LazySeq(
            head_val: h,
            has_head: true,
            tail_thunk: fn():
                rest.tail().take_while(pred)
            ,
            has_tail: true
        )

    fn drop_while(pred: fn()) -> LazySeq:
        var current = self
        # Safety limit to prevent infinite loops on unbounded sequences
        for _ in 0..1000000:
            if current.is_empty():
                return LazySeq__empty()
            if not pred(current.head_val):
                return current
            current = current.tail()
        LazySeq__empty()

    fn concat(other: LazySeq) -> LazySeq:
        if self.is_empty():
            return other
        val h = self.head_val
        val rest = self
        LazySeq(
            head_val: h,
            has_head: true,
            tail_thunk: fn():
                rest.tail().concat(other)
            ,
            has_tail: true
        )

    fn flat_map(f: fn()) -> LazySeq:
        if self.is_empty():
            return LazySeq__empty()
        val inner = f(self.head_val)
        val rest = self
        inner.concat(LazySeq(
            head_val: 0,
            has_head: false,
            tail_thunk: fn():
                rest.tail().flat_map(f)
            ,
            has_tail: true
        ))

    fn zip(other: LazySeq) -> LazySeq:
        if self.is_empty():
            return LazySeq__empty()
        if other.is_empty():
            return LazySeq__empty()
        val pair = [self.head_val, other.head()]
        val rest_self = self
        val rest_other = other
        LazySeq(
            head_val: pair,
            has_head: true,
            tail_thunk: fn():
                rest_self.tail().zip(rest_other.tail())
            ,
            has_tail: true
        )

    fn interleave(other: LazySeq) -> LazySeq:
        if self.is_empty():
            return other
        val h = self.head_val
        val rest = self
        LazySeq(
            head_val: h,
            has_head: true,
            tail_thunk: fn():
                other.interleave(rest.tail())
            ,
            has_tail: true
        )

    fn to_array():
        var result = []
        var current = self
        # Safety limit to prevent infinite loops on unbounded sequences
        for _ in 0..1000000:
            if current.is_empty():
                return result
            result.push(current.head_val)
            current = current.tail()
        result

    fn to_array_n(n: i64):
        self.take(n).to_array()

    fn fold(init, f: fn()):
        var acc = init
        var current = self
        # Safety limit to prevent infinite loops on unbounded sequences
        for _ in 0..1000000:
            if current.is_empty():
                return acc
            acc = f(acc, current.head_val)
            current = current.tail()
        acc

    fn reduce(f: fn()):
        if self.is_empty():
            return nil
        self.tail().fold(self.head_val, f)

    fn find(pred: fn()):
        var current = self
        # Safety limit to prevent infinite loops on unbounded sequences
        for _ in 0..1000000:
            if current.is_empty():
                return nil
            if pred(current.head_val):
                return current.head_val
            current = current.tail()
        nil

    fn any(pred: fn()) -> bool:
        var current = self
        # Safety limit to prevent infinite loops on unbounded sequences
        for _ in 0..1000000:
            if current.is_empty():
                return false
            if pred(current.head_val):
                return true
            current = current.tail()
        false

    fn all(pred: fn()) -> bool:
        var current = self
        # Safety limit to prevent infinite loops on unbounded sequences
        for _ in 0..1000000:
            if current.is_empty():
                return true
            if not pred(current.head_val):
                return false
            current = current.tail()
        true

    fn count() -> i64:
        var n = 0
        var current = self
        # Safety limit to prevent infinite loops on unbounded sequences
        for _ in 0..1000000:
            if current.is_empty():
                return n
            n = n + 1
            current = current.tail()
        n

    fn contains(element) -> bool:
        self.any(fn(x): x == element)

    fn zip_with_index() -> LazySeq:
        self.zip(naturals())

fn LazySeq__empty() -> LazySeq:
    LazySeq(head_val: 0, has_head: false, tail_thunk: fn(): LazySeq__empty(), has_tail: false)

fn LazySeq__single(v) -> LazySeq:
    LazySeq(head_val: v, has_head: true, tail_thunk: fn(): LazySeq__empty(), has_tail: true)

fn LazySeq__cons(h, tail: LazySeq) -> LazySeq:
    LazySeq(head_val: h, has_head: true, tail_thunk: fn(): tail, has_tail: true)

fn LazySeq__from_array(arr) -> LazySeq:
    if arr.len() == 0:
        return LazySeq__empty()
    val h = arr[0]
    var rest = []
    var i = 1
    for _ in arr:
        if i < arr.len():
            rest.push(arr[i])
        i = i + 1
    LazySeq(head_val: h, has_head: true, tail_thunk: fn(): LazySeq__from_array(rest), has_tail: true)

fn LazySeq__iterate(seed, f: fn()) -> LazySeq:
    LazySeq(
        head_val: seed,
        has_head: true,
        tail_thunk: fn():
            LazySeq__iterate(f(seed), f)
        ,
        has_tail: true
    )

fn LazySeq__unfold(seed, f: fn()) -> LazySeq:
    val result = f(seed)
    if result == nil:
        return LazySeq__empty()
    if not result.?:
        return LazySeq__empty()
    val pair = result
    val item = pair[0]
    val next_seed = pair[1]
    LazySeq(
        head_val: item,
        has_head: true,
        tail_thunk: fn():
            LazySeq__unfold(next_seed, f)
        ,
        has_tail: true
    )

fn LazySeq__generate(f: fn()) -> LazySeq:
    fn gen_from(idx: i64) -> LazySeq:
        val result = f(idx)
        if result == nil:
            return LazySeq__empty()
        if not result.?:
            return LazySeq__empty()
        LazySeq(
            head_val: result,
            has_head: true,
            tail_thunk: fn():
                gen_from(idx + 1)
            ,
            has_tail: true
        )
    gen_from(0)

fn LazySeq__repeat_val(v) -> LazySeq:
    LazySeq(head_val: v, has_head: true, tail_thunk: fn(): LazySeq__repeat_val(v), has_tail: true)

fn LazySeq__repeat_n(v, n: i64) -> LazySeq:
    if n <= 0:
        return LazySeq__empty()
    val remaining = n - 1
    LazySeq(head_val: v, has_head: true, tail_thunk: fn(): LazySeq__repeat_n(v, remaining), has_tail: true)

# --- Standard Sequences ---

fn naturals() -> LazySeq:
    LazySeq__iterate(0, fn(x): x + 1)

fn naturals_from(start: i64) -> LazySeq:
    LazySeq__iterate(start, fn(x): x + 1)

fn fibonacci() -> LazySeq:
    fn fib_from(a: i64, b: i64) -> LazySeq:
        LazySeq(
            head_val: a,
            has_head: true,
            tail_thunk: fn():
                fib_from(b, a + b)
            ,
            has_tail: true
        )
    fib_from(0, 1)

fn is_prime_check(n: i64) -> bool:
    if n < 2:
        return false
    if n == 2:
        return true
    if n % 2 == 0:
        return false
    var i = 3
    for _ in 0..n:
        if i * i > n:
            return true
        if n % i == 0:
            return false
        i = i + 2
    true

fn primes() -> LazySeq:
    LazySeq__iterate(2, fn(x): x + 1).filter(fn(n): is_prime_check(n))

fn repeat_seq(v) -> LazySeq:
    LazySeq__repeat_val(v)

fn cycle(arr) -> LazySeq:
    if arr.len() == 0:
        return LazySeq__empty()
    fn cycle_from(idx: i64) -> LazySeq:
        val actual_idx = idx % arr.len()
        LazySeq(
            head_val: arr[actual_idx],
            has_head: true,
            tail_thunk: fn():
                cycle_from(idx + 1)
            ,
            has_tail: true
        )
    cycle_from(0)

fn range_lazy(start: i64, end_val: i64) -> LazySeq:
    if start >= end_val:
        return LazySeq__empty()
    LazySeq(
        head_val: start,
        has_head: true,
        tail_thunk: fn():
            range_lazy(start + 1, end_val)
        ,
        has_tail: true
    )

fn range_step(start: i64, end_val: i64, step: i64) -> LazySeq:
    if step > 0:
        if start >= end_val:
            return LazySeq__empty()
    else:
        if start <= end_val:
            return LazySeq__empty()
    LazySeq(
        head_val: start,
        has_head: true,
        tail_thunk: fn():
            range_step(start + step, end_val, step)
        ,
        has_tail: true
    )

# --- SeqIterator ---

class SeqIterator:
    current: LazySeq

    fn has_next() -> bool:
        not self.current.is_empty()

    me next():
        if self.current.is_empty():
            return nil
        val h = self.current.head_val
        self.current = self.current.tail()
        h

fn SeqIterator__new(seq: LazySeq) -> SeqIterator:
    SeqIterator(current: seq)

export LazySeq, LazySeq__empty, LazySeq__single, LazySeq__cons, LazySeq__from_array
export LazySeq__iterate, LazySeq__unfold, LazySeq__generate
export LazySeq__repeat_val, LazySeq__repeat_n
export SeqIterator, SeqIterator__new
export naturals, naturals_from, fibonacci, primes, repeat_seq, cycle, range_lazy, range_step
