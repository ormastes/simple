# Pure Simple String Utilities
# Advanced string manipulation without FFI

export split_lines, trim, trim_start, trim_end
export starts_with, ends_with, contains
export replace_all, join_lines
export to_upper, to_lower, to_upper_char, to_lower_char
export pad_left, pad_right, center
export count_occurrences, reverse_string
export char_to_code, code_to_char

# Split text into lines
fn split_lines(text: text) -> [text]:
    text.split("\n")

# Trim whitespace from both ends
fn trim(text: text) -> text:
    trim_end(trim_start(text))

# Trim whitespace from start
fn trim_start(text: text) -> text:
    var result = text
    while result.starts_with(" ") or result.starts_with("\t") or result.starts_with("\n"):
        result = result[1:]
    result

# Trim whitespace from end
fn trim_end(text: text) -> text:
    var result = text
    while result.ends_with(" ") or result.ends_with("\t") or result.ends_with("\n"):
        result = result[:-1]
    result

# Check if string starts with prefix
fn starts_with(text: text, prefix: text) -> bool:
    if prefix.len() > text.len():
        false
    else:
        text[0:prefix.len()] == prefix

# Check if string ends with suffix
fn ends_with(text: text, suffix: text) -> bool:
    if suffix.len() > text.len():
        false
    else:
        text[text.len() - suffix.len():] == suffix

# Check if string contains substring
fn contains(text: text, substring: text) -> bool:
    # Simple search
    var i = 0
    while i <= text.len() - substring.len():
        if text[i:i + substring.len()] == substring:
            return true
        i = i + 1
    false

# Replace all occurrences
fn replace_all(text: text, old: text, new: text) -> text:
    var result = ""
    var i = 0
    while i < text.len():
        if i <= text.len() - old.len() and text[i:i + old.len()] == old:
            result = result + new
            i = i + old.len()
        else:
            result = result + text[i:i + 1]
            i = i + 1
    result

# Join lines with separator
fn join_lines(lines: [text], separator: text) -> text:
    var result = ""
    var i = 0
    while i < lines.len():
        result = result + lines[i]
        if i < lines.len() - 1:
            result = result + separator
        i = i + 1
    result

# Convert to uppercase (ASCII only)
fn to_upper(text: text) -> text:
    var result = ""
    var i = 0
    while i < text.len():
        val ch = text[i:i + 1]
        # REAL IMPLEMENTATION: Use char code conversion
        result = result + to_upper_char(ch)
        i = i + 1
    result

# Convert to lowercase (ASCII only)
fn to_lower(text: text) -> text:
    var result = ""
    var i = 0
    while i < text.len():
        val ch = text[i:i + 1]
        # REAL IMPLEMENTATION: Use char code conversion
        result = result + to_lower_char(ch)
        i = i + 1
    result

# Pad string on left
fn pad_left(text: text, width: i64, pad_char: text) -> text:
    var result = text
    while result.len() < width:
        result = pad_char + result
    result

# Pad string on right
fn pad_right(text: text, width: i64, pad_char: text) -> text:
    var result = text
    while result.len() < width:
        result = result + pad_char
    result

# Center string
fn center(text: text, width: i64, pad_char: text) -> text:
    if text.len() >= width:
        text
    else:
        val total_padding = width - text.len()
        val left_padding = total_padding / 2
        val right_padding = total_padding - left_padding
        var result = text
        var i = 0
        while i < left_padding:
            result = pad_char + result
            i = i + 1
        i = 0
        while i < right_padding:
            result = result + pad_char
            i = i + 1
        result

# Count occurrences of substring
fn count_occurrences(text: text, substring: text) -> i64:
    var count = 0
    var i = 0
    while i <= text.len() - substring.len():
        if text[i:i + substring.len()] == substring:
            count = count + 1
            i = i + substring.len()
        else:
            i = i + 1
    count

# Reverse string
fn reverse_string(text: text) -> text:
    var result = ""
    var i = text.len() - 1
    while i >= 0:
        result = result + text[i:i + 1]
        i = i - 1
    result

# ============================================================================
# Character Code Conversion (ASCII)
# ============================================================================

# Convert character to ASCII code
fn char_to_code(ch: text) -> i64:
    # REAL IMPLEMENTATION: Full ASCII table for lowercase letters
    if ch == "a": 97
    elif ch == "b": 98
    elif ch == "c": 99
    elif ch == "d": 100
    elif ch == "e": 101
    elif ch == "f": 102
    elif ch == "g": 103
    elif ch == "h": 104
    elif ch == "i": 105
    elif ch == "j": 106
    elif ch == "k": 107
    elif ch == "l": 108
    elif ch == "m": 109
    elif ch == "n": 110
    elif ch == "o": 111
    elif ch == "p": 112
    elif ch == "q": 113
    elif ch == "r": 114
    elif ch == "s": 115
    elif ch == "t": 116
    elif ch == "u": 117
    elif ch == "v": 118
    elif ch == "w": 119
    elif ch == "x": 120
    elif ch == "y": 121
    elif ch == "z": 122
    # Uppercase letters
    elif ch == "A": 65
    elif ch == "B": 66
    elif ch == "C": 67
    elif ch == "D": 68
    elif ch == "E": 69
    elif ch == "F": 70
    elif ch == "G": 71
    elif ch == "H": 72
    elif ch == "I": 73
    elif ch == "J": 74
    elif ch == "K": 75
    elif ch == "L": 76
    elif ch == "M": 77
    elif ch == "N": 78
    elif ch == "O": 79
    elif ch == "P": 80
    elif ch == "Q": 81
    elif ch == "R": 82
    elif ch == "S": 83
    elif ch == "T": 84
    elif ch == "U": 85
    elif ch == "V": 86
    elif ch == "W": 87
    elif ch == "X": 88
    elif ch == "Y": 89
    elif ch == "Z": 90
    else: 0  # Unknown character

# Convert ASCII code to character
fn code_to_char(code: i64) -> text:
    # REAL IMPLEMENTATION: Full ASCII table (reverse mapping)
    if code == 97: "a"
    elif code == 98: "b"
    elif code == 99: "c"
    elif code == 100: "d"
    elif code == 101: "e"
    elif code == 102: "f"
    elif code == 103: "g"
    elif code == 104: "h"
    elif code == 105: "i"
    elif code == 106: "j"
    elif code == 107: "k"
    elif code == 108: "l"
    elif code == 109: "m"
    elif code == 110: "n"
    elif code == 111: "o"
    elif code == 112: "p"
    elif code == 113: "q"
    elif code == 114: "r"
    elif code == 115: "s"
    elif code == 116: "t"
    elif code == 117: "u"
    elif code == 118: "v"
    elif code == 119: "w"
    elif code == 120: "x"
    elif code == 121: "y"
    elif code == 122: "z"
    # Uppercase
    elif code == 65: "A"
    elif code == 66: "B"
    elif code == 67: "C"
    elif code == 68: "D"
    elif code == 69: "E"
    elif code == 70: "F"
    elif code == 71: "G"
    elif code == 72: "H"
    elif code == 73: "I"
    elif code == 74: "J"
    elif code == 75: "K"
    elif code == 76: "L"
    elif code == 77: "M"
    elif code == 78: "N"
    elif code == 79: "O"
    elif code == 80: "P"
    elif code == 81: "Q"
    elif code == 82: "R"
    elif code == 83: "S"
    elif code == 84: "T"
    elif code == 85: "U"
    elif code == 86: "V"
    elif code == 87: "W"
    elif code == 88: "X"
    elif code == 89: "Y"
    elif code == 90: "Z"
    else: "?"  # Unknown code

# Convert single character to uppercase
fn to_upper_char(ch: text) -> text:
    # REAL IMPLEMENTATION: Use char code arithmetic
    val code = char_to_code(ch)
    if code >= 97 and code <= 122:  # lowercase a-z
        code_to_char(code - 32)  # Convert to uppercase (A-Z)
    else:
        ch  # Not lowercase, return as-is

# Convert single character to lowercase
fn to_lower_char(ch: text) -> text:
    # REAL IMPLEMENTATION: Use char code arithmetic
    val code = char_to_code(ch)
    if code >= 65 and code <= 90:  # uppercase A-Z
        code_to_char(code + 32)  # Convert to lowercase (a-z)
    else:
        ch  # Not uppercase, return as-is
