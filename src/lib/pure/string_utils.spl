# Pure Simple String Utilities
# Advanced string manipulation without FFI

export split_lines, trim, trim_start, trim_end
export starts_with, ends_with, contains
export replace_all, join_lines
export to_upper, to_lower
export pad_left, pad_right, center
export count_occurrences, reverse_string

# Split text into lines
fn split_lines(text: text) -> [text]:
    text.split("\n")

# Trim whitespace from both ends
fn trim(text: text) -> text:
    trim_end(trim_start(text))

# Trim whitespace from start
fn trim_start(text: text) -> text:
    var result = text
    while result.starts_with(" ") or result.starts_with("\t") or result.starts_with("\n"):
        result = result[1:]
    result

# Trim whitespace from end
fn trim_end(text: text) -> text:
    var result = text
    while result.ends_with(" ") or result.ends_with("\t") or result.ends_with("\n"):
        result = result[:-1]
    result

# Check if string starts with prefix
fn starts_with(text: text, prefix: text) -> bool:
    if prefix.len() > text.len():
        false
    else:
        text[0:prefix.len()] == prefix

# Check if string ends with suffix
fn ends_with(text: text, suffix: text) -> bool:
    if suffix.len() > text.len():
        false
    else:
        text[text.len() - suffix.len():] == suffix

# Check if string contains substring
fn contains(text: text, substring: text) -> bool:
    # Simple search
    var i = 0
    while i <= text.len() - substring.len():
        if text[i:i + substring.len()] == substring:
            return true
        i = i + 1
    false

# Replace all occurrences
fn replace_all(text: text, old: text, new: text) -> text:
    var result = ""
    var i = 0
    while i < text.len():
        if i <= text.len() - old.len() and text[i:i + old.len()] == old:
            result = result + new
            i = i + old.len()
        else:
            result = result + text[i:i + 1]
            i = i + 1
    result

# Join lines with separator
fn join_lines(lines: [text], separator: text) -> text:
    var result = ""
    var i = 0
    while i < lines.len():
        result = result + lines[i]
        if i < lines.len() - 1:
            result = result + separator
        i = i + 1
    result

# Convert to uppercase (ASCII only)
fn to_upper(text: text) -> text:
    var result = ""
    var i = 0
    while i < text.len():
        val ch = text[i:i + 1]
        # ASCII lowercase is 97-122, uppercase is 65-90
        if ch >= "a" and ch <= "z":
            # Convert to uppercase (subtract 32)
            result = result + ch  # TODO: Implement char code conversion
        else:
            result = result + ch
        i = i + 1
    result

# Convert to lowercase (ASCII only)
fn to_lower(text: text) -> text:
    var result = ""
    var i = 0
    while i < text.len():
        val ch = text[i:i + 1]
        if ch >= "A" and ch <= "Z":
            result = result + ch  # TODO: Implement char code conversion
        else:
            result = result + ch
        i = i + 1
    result

# Pad string on left
fn pad_left(text: text, width: i64, pad_char: text) -> text:
    var result = text
    while result.len() < width:
        result = pad_char + result
    result

# Pad string on right
fn pad_right(text: text, width: i64, pad_char: text) -> text:
    var result = text
    while result.len() < width:
        result = result + pad_char
    result

# Center string
fn center(text: text, width: i64, pad_char: text) -> text:
    if text.len() >= width:
        text
    else:
        val total_padding = width - text.len()
        val left_padding = total_padding / 2
        val right_padding = total_padding - left_padding
        var result = text
        var i = 0
        while i < left_padding:
            result = pad_char + result
            i = i + 1
        i = 0
        while i < right_padding:
            result = result + pad_char
            i = i + 1
        result

# Count occurrences of substring
fn count_occurrences(text: text, substring: text) -> i64:
    var count = 0
    var i = 0
    while i <= text.len() - substring.len():
        if text[i:i + substring.len()] == substring:
            count = count + 1
            i = i + substring.len()
        else:
            i = i + 1
    count

# Reverse string
fn reverse_string(text: text) -> text:
    var result = ""
    var i = text.len() - 1
    while i >= 0:
        result = result + text[i:i + 1]
        i = i - 1
    result
