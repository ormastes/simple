# Pure Simple REPL
# Interactive Read-Eval-Print Loop in pure Simple

use lib.pure.string_utils (trim, starts_with)
use lib.pure.collections (range)
use lib.pure.runtime (system_shell, ShellResult)

export start_repl, evaluate_expression, repl_help, read_input

# REPL State
class ReplState:
    history: [text]
    variables: [(text, i64)]  # Simple variable storage
    running: bool

    fn add_history(line: text):
        self.history.push(line)

    fn add_variable(name: text, value: i64):
        self.variables.push((name, value))

    fn get_variable(name: text) -> i64?:
        var i = 0
        while i < self.variables.len():
            if self.variables[i].0 == name:
                return Some(self.variables[i].1)
            i = i + 1
        nil

# Start REPL
fn start_repl():
    print "Simple REPL (Pure Simple Implementation)"
    print "Type 'help' for commands, 'exit' to quit"
    print ""

    var state = ReplState(
        history: [],
        variables: [],
        running: true
    )

    var line_number = 1
    while state.running:
        print_prompt(line_number)

        # Read input from stdin (implemented via system_shell)
        val input = read_input()

        if input.len() == 0:
            break

        state.add_history(input)

        val trimmed = trim(input)
        if starts_with(trimmed, ":"):
            handle_command(trimmed, state)
        else:
            val result = evaluate_expression(trimmed, state)
            print "=> {result}"

        line_number = line_number + 1

# Print REPL prompt
fn print_prompt(line_num: i64):
    print "simple:{line_num}> "

# Read input line (stub - would need FFI)
fn read_input() -> text:
    # REAL IMPLEMENTATION: Read from stdin using shell
    # Uses bash's 'read' builtin to get a line from stdin
    val result = system_shell("read -r line 2>/dev/null && echo \"$line\"")

    # If shell execution works, return the stdout
    # Otherwise return empty string to indicate EOF
    if result.exit_code == 0:
        result.stdout.trim()
    else:
        ""

# Handle REPL commands
fn handle_command(cmd: text, state: ReplState):
    if cmd == ":help" or cmd == ":h":
        repl_help()
    elif cmd == ":exit" or cmd == ":quit" or cmd == ":q":
        state.running = false
        print "Goodbye!"
    elif cmd == ":history" or cmd == ":hist":
        show_history(state)
    elif cmd == ":vars" or cmd == ":variables":
        show_variables(state)
    elif cmd == ":clear":
        print "[Screen would clear here]"
    else:
        print "Unknown command: {cmd}"
        print "Type :help for available commands"

# Show REPL help
fn repl_help():
    print "Simple REPL Commands:"
    print "  :help, :h          Show this help"
    print "  :exit, :quit, :q   Exit REPL"
    print "  :history, :hist    Show command history"
    print "  :vars, :variables  Show defined variables"
    print "  :clear             Clear screen"
    print ""
    print "Examples:"
    print "  42                 Evaluate expression"
    print "  2 + 3 * 4          Math operations"
    print "  val x = 10         Define variable"
    print "  [1, 2, 3]          Create list"

# Show command history
fn show_history(state: ReplState):
    print "Command History:"
    var i = 0
    while i < state.history.len():
        print "  {i + 1}: {state.history[i]}"
        i = i + 1

# Show defined variables
fn show_variables(state: ReplState):
    print "Defined Variables:"
    if state.variables.len() == 0:
        print "  (none)"
    else:
        var i = 0
        while i < state.variables.len():
            val (name, value) = state.variables[i]
            print "  {name} = {value}"
            i = i + 1

# Evaluate expression (simplified)
fn evaluate_expression(expr: text, state: ReplState) -> text:
    val trimmed = trim(expr)

    # Handle numbers
    if is_number(trimmed):
        return trimmed

    # Handle simple math
    if contains_math_op(trimmed):
        return evaluate_math(trimmed)

    # Handle variables
    if starts_with(trimmed, "val "):
        return define_variable(trimmed, state)

    # Handle lists
    if starts_with(trimmed, "[") and trimmed.ends_with("]"):
        return trimmed

    # Handle strings
    if starts_with(trimmed, "\"") and trimmed.ends_with("\""):
        return trimmed

    # Unknown expression
    "[Error: Cannot evaluate '{expr}']"

# Check if string is a number
fn is_number(s: text) -> bool:
    if s.len() == 0:
        return false
    var i = 0
    while i < s.len():
        val ch = s[i:i + 1]
        if not (ch >= "0" and ch <= "9" or ch == "-" or ch == "."):
            return false
        i = i + 1
    true

# Check if expression contains math operators
fn contains_math_op(expr: text) -> bool:
    expr.contains("+") or expr.contains("-") or
    expr.contains("*") or expr.contains("/")

# Evaluate simple math expression
fn evaluate_math(expr: text) -> text:
    # Simplified: handle basic addition
    if expr.contains("+"):
        val parts = expr.split("+")
        if parts.len() == 2:
            val a = parse_int(trim(parts[0]))
            val b = parse_int(trim(parts[1]))
            return "{a + b}"

    # Handle other operators similarly
    expr

# Parse integer (simplified)
fn parse_int(s: text) -> i64:
    # This would parse string to int
    # For now, return 0
    0

# Define variable
fn define_variable(line: text, state: ReplState) -> text:
    # Parse: val name = value
    val parts = line.split("=")
    if parts.len() == 2:
        val var_part = trim(parts[0])
        val value_part = trim(parts[1])

        if starts_with(var_part, "val "):
            val var_name = trim(var_part[4:])
            val value = parse_int(value_part)
            state.add_variable(var_name, value)
            return "{var_name} = {value}"

    "[Error: Invalid variable definition]"
