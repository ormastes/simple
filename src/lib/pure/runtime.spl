# Pure Simple Runtime
# 100% Simple implementation - no FFI dependencies
# Replaces all extern fn with pure Simple code

export RuntimeValue, GcHandle, RefCount
export alloc, dealloc, gc_collect, gc_stats
export print_impl, eprintln_impl, panic_impl
export system_shell, system_exit

# ============================================================================
# Memory Management (Pure Simple Reference Counting)
# ============================================================================

class RefCount:
    count: i64

class GcHandle:
    id: i64
    refcount: RefCount

struct RuntimeValue:
    data: text
    type_tag: i64

# Global allocator state
class Allocator:
    objects: [(i64, RuntimeValue)]
    next_id: i64
    total_allocated: i64
    total_freed: i64

fn alloc(value: RuntimeValue) -> GcHandle:
    # Simplified - just return a handle with ID
    # In full implementation, would track in allocator
    GcHandle(id: 1, refcount: RefCount(count: 1))

fn dealloc(handle: GcHandle):
    # Simplified - just mark as deallocated
    # In full implementation, would remove from allocator
    ()

fn gc_collect() -> i64:
    # Simple mark-and-sweep (stub - returns 0 freed)
    0

fn gc_stats() -> (i64, i64, i64):
    # Return dummy stats for now
    # In full implementation, would query allocator
    (0, 0, 0)

# ============================================================================
# I/O Operations (Pure Simple via shell)
# ============================================================================

fn print_impl(text: text):
    # Use echo command
    val _ = system_shell("echo '{text}'")
    ()

fn eprintln_impl(text: text):
    # Use echo to stderr
    val _ = system_shell("echo '{text}' >&2")
    ()

fn panic_impl(message: text):
    eprintln_impl("PANIC: {message}")
    system_exit(1)

# ============================================================================
# System Operations (Pure Simple via shell)
# ============================================================================

struct ShellResult:
    stdout: text
    stderr: text
    exit_code: i64

fn system_shell(command: text) -> ShellResult:
    # This is a placeholder - actual implementation would use
    # the runtime's built-in shell execution
    # For now, return empty result
    ShellResult(
        stdout: "",
        stderr: "",
        exit_code: 0
    )

fn system_exit(code: i64):
    # Exit with code
    # Actual implementation would use runtime's exit
    ()

# ============================================================================
# String Operations (Pure Simple)
# ============================================================================

fn string_concat(a: text, b: text) -> text:
    a + b

fn string_length(s: text) -> i64:
    s.len()

fn string_substring(s: text, start: i64, end: i64) -> text:
    s[start:end]

fn string_to_int(s: text) -> i64:
    # Simple string to int conversion
    var result = 0
    var i = 0
    var negative = false

    if s.len() > 0 and s[0:1] == "-":
        negative = true
        i = 1

    while i < s.len():
        val ch = s[i:i + 1]
        if ch >= "0" and ch <= "9":
            val digit = char_to_digit(ch)
            result = result * 10 + digit
        i = i + 1

    if negative:
        -result
    else:
        result

fn char_to_digit(ch: text) -> i64:
    # Convert single digit char to int
    if ch == "0": 0
    elif ch == "1": 1
    elif ch == "2": 2
    elif ch == "3": 3
    elif ch == "4": 4
    elif ch == "5": 5
    elif ch == "6": 6
    elif ch == "7": 7
    elif ch == "8": 8
    elif ch == "9": 9
    else: 0

# ============================================================================
# List Operations (Pure Simple)
# ============================================================================

fn list_length<T>(list: [T]) -> i64:
    list.len()

fn list_get<T>(list: [T], index: i64) -> T:
    list[index]

fn list_push<T>(list: [T], item: T) -> [T]:
    var new_list = list
    new_list.push(item)
    new_list

fn list_slice<T>(list: [T], start: i64, end: i64) -> [T]:
    list[start:end]

# ============================================================================
# Math Operations (Pure Simple)
# ============================================================================

fn math_abs(x: i64) -> i64:
    if x < 0: -x else: x

fn math_min(a: i64, b: i64) -> i64:
    if a < b: a else: b

fn math_max(a: i64, b: i64) -> i64:
    if a > b: a else: b

fn math_pow(base: i64, exp: i64) -> i64:
    var result = 1
    var i = 0
    while i < exp:
        result = result * base
        i = i + 1
    result

# ============================================================================
# File Operations (Pure Simple via shell)
# ============================================================================

fn file_exists(path: text) -> bool:
    val result = system_shell("test -f '{path}'")
    result.exit_code == 0

fn file_read(path: text) -> text:
    val result = system_shell("cat '{path}'")
    result.stdout

fn file_write(path: text, content: text) -> bool:
    val result = system_shell("echo '{content}' > '{path}'")
    result.exit_code == 0

fn file_append(path: text, content: text) -> bool:
    val result = system_shell("echo '{content}' >> '{path}'")
    result.exit_code == 0

fn file_delete(path: text) -> bool:
    val result = system_shell("rm '{path}'")
    result.exit_code == 0

# ============================================================================
# Directory Operations (Pure Simple via shell)
# ============================================================================

fn dir_create(path: text) -> bool:
    val result = system_shell("mkdir -p '{path}'")
    result.exit_code == 0

fn dir_exists(path: text) -> bool:
    val result = system_shell("test -d '{path}'")
    result.exit_code == 0

fn dir_list(path: text) -> [text]:
    val result = system_shell("ls '{path}'")
    if result.exit_code == 0:
        result.stdout.split("\n")
    else:
        []

fn dir_remove(path: text) -> bool:
    val result = system_shell("rm -rf '{path}'")
    result.exit_code == 0

# ============================================================================
# Process Operations (Pure Simple via shell)
# ============================================================================

fn process_run(cmd: text, args: [text]) -> ShellResult:
    val args_str = join_args(args)
    system_shell("{cmd} {args_str}")

fn join_args(args: [text]) -> text:
    var result = ""
    var i = 0
    while i < args.len():
        if i > 0:
            result = result + " "
        result = result + "'" + args[i] + "'"
        i = i + 1
    result

fn process_exit(code: i64):
    system_exit(code)

# ============================================================================
# Time Operations (Pure Simple via shell)
# ============================================================================

fn time_now_unix() -> i64:
    val result = system_shell("date +%s")
    string_to_int(result.stdout.trim())

fn time_now_ms() -> i64:
    time_now_unix() * 1000

# ============================================================================
# Environment Operations (Pure Simple via shell)
# ============================================================================

fn env_get(key: text) -> text:
    val result = system_shell("echo ${key}")
    result.stdout.trim()

fn env_set(key: text, value: text) -> bool:
    val result = system_shell("export {key}='{value}'")
    result.exit_code == 0

fn cwd() -> text:
    val result = system_shell("pwd")
    result.stdout.trim()

fn home() -> text:
    env_get("HOME")
