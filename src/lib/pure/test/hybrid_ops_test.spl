# Hybrid Tensor Operations Test
# Tests automatic selection between Pure Simple and FFI

# ============================================================================
# Inline tensor_ops_hybrid.spl for testing
# ============================================================================

class PureTensor<T>:
    data: [T]
    shape: [i64]
    strides: [i64]

    fn numel() -> i64:
        var total = 1
        for dim in self.shape:
            total = total * dim
        total

    static fn from_data(data: [T], shape: [i64]) -> PureTensor<T>:
        PureTensor(data: data, shape: shape, strides: compute_strides(shape))

    fn get(indices: [i64]) -> T:
        var offset = 0
        var i = 0
        while i < indices.len():
            offset = offset + indices[i] * self.strides[i]
            i = i + 1
        self.data[offset]

fn compute_strides(shape: [i64]) -> [i64]:
    var strides: [i64] = []
    var stride = 1
    var i = shape.len() - 1
    while i >= 0:
        strides.insert(0, stride)
        stride = stride * shape[i]
        i = i - 1
    strides

enum AccelMode:
    PureSimple
    PyTorchFFI
    Auto

var current_mode = AccelMode.PureSimple
var ffi_available = false

fn set_acceleration(mode: AccelMode):
    current_mode = mode

fn set_ffi_available(available: bool):
    ffi_available = available

fn should_use_ffi(op: text, numel: i64) -> bool:
    match current_mode:
        case PureSimple:
            return false
        case PyTorchFFI:
            return ffi_available
        case Auto:
            if not ffi_available:
                return false
            val threshold = if op == "matmul": 1_000_000 else: 10_000_000
            return numel > threshold

# Pure implementations
fn add_pure(a: PureTensor<f64>, b: PureTensor<f64>) -> PureTensor<f64>:
    var result_data: [f64] = []
    var i = 0
    while i < a.data.len():
        result_data.push(a.data[i] + b.data[i])
        i = i + 1
    PureTensor.from_data(result_data, a.shape)

fn matmul_pure(a: PureTensor<f64>, b: PureTensor<f64>) -> PureTensor<f64>:
    val M = a.shape[0]
    val K = a.shape[1]
    val N = b.shape[1]
    var result_data: [f64] = []
    var i = 0
    while i < M:
        var j = 0
        while j < N:
            var sum = 0.0
            var k = 0
            while k < K:
                sum = sum + a.get([i, k]) * b.get([k, j])
                k = k + 1
            result_data.push(sum)
            j = j + 1
        i = i + 1
    PureTensor.from_data(result_data, [M, N])

# Hybrid implementations
fn add(a: PureTensor<f64>, b: PureTensor<f64>) -> PureTensor<f64>:
    val numel = a.numel()
    if should_use_ffi("add", numel):
        # In real implementation, would call FFI here
        add_pure(a, b)  # Fallback for this test
    else:
        add_pure(a, b)

fn matmul(a: PureTensor<f64>, b: PureTensor<f64>) -> PureTensor<f64>:
    val numel = a.numel() * b.numel()
    if should_use_ffi("matmul", numel):
        # In real implementation, would call FFI here
        matmul_pure(a, b)  # Fallback for this test
    else:
        matmul_pure(a, b)

# ============================================================================
# Test Helper
# ============================================================================

var test_count = 0
var pass_count = 0

fn test(name: text, condition: bool):
    test_count = test_count + 1
    if condition:
        pass_count = pass_count + 1
        print "✅ {name}"
    else:
        print "❌ {name}"

# ============================================================================
# Tests
# ============================================================================

print "Hybrid Tensor Operations Test"
print "============================="
print ""

# Test 1: PureSimple mode always uses Pure Simple
print "Test Group: PureSimple Mode"
set_acceleration(AccelMode.PureSimple)
set_ffi_available(false)

val a = PureTensor.from_data([1.0, 2.0, 3.0, 4.0], [2, 2])
val b = PureTensor.from_data([5.0, 6.0, 7.0, 8.0], [2, 2])
val c = add(a, b)
test("add works in PureSimple mode", c.data[0] == 6.0 and c.data[3] == 12.0)

val d = matmul(a, b)
test("matmul works in PureSimple mode", d.data[0] == 19.0 and d.data[3] == 50.0)
print ""

# Test 2: Auto mode respects thresholds
print "Test Group: Auto Mode Thresholds"
set_acceleration(AccelMode.Auto)
set_ffi_available(false)  # FFI not available, should use Pure Simple

val small_a = PureTensor.from_data([1.0, 2.0], [1, 2])
val small_b = PureTensor.from_data([3.0, 4.0], [2, 1])
val small_c = matmul(small_a, small_b)
test("Small matmul uses Pure Simple (below threshold)", small_c.data[0] == 11.0)

# Simulate large matrix (don't actually compute - too slow)
val large_numel = 2_000_000  # 1414×1414 ≈ 2M elements
val would_use_ffi = should_use_ffi("matmul", large_numel)
test("Large matmul would use FFI if available", would_use_ffi)
print ""

# Test 3: Correctness of operations
print "Test Group: Operation Correctness"
set_acceleration(AccelMode.PureSimple)

val x = PureTensor.from_data([1.0, 2.0, 3.0, 4.0], [2, 2])
val y = PureTensor.from_data([2.0, 0.0, 0.0, 2.0], [2, 2])

val sum = add(x, y)
test("add: [1,2,3,4] + [2,0,0,2] = [3,2,3,6]",
     sum.data[0] == 3.0 and sum.data[1] == 2.0 and 
     sum.data[2] == 3.0 and sum.data[3] == 6.0)

val prod = matmul(x, y)
# x @ y = [[1,2],[3,4]] @ [[2,0],[0,2]] = [[2,4],[6,8]]
test("matmul: result shape is [2,2]", prod.shape[0] == 2 and prod.shape[1] == 2)
test("matmul: [0,0] = 2.0", prod.data[0] == 2.0)
test("matmul: [0,1] = 4.0", prod.data[1] == 4.0)
test("matmul: [1,0] = 6.0", prod.data[2] == 6.0)
test("matmul: [1,1] = 8.0", prod.data[3] == 8.0)
print ""

# Test 4: FFI availability check
print "Test Group: FFI Availability"
set_ffi_available(false)
test("FFI can be disabled", not should_use_ffi("matmul", 10_000_000))

set_ffi_available(true)
set_acceleration(AccelMode.Auto)
test("FFI can be enabled (Auto mode)", should_use_ffi("matmul", 10_000_000))

set_acceleration(AccelMode.PureSimple)
test("PureSimple mode ignores FFI availability", not should_use_ffi("matmul", 10_000_000))
print ""

# Summary
print "============================="
print "Test Summary:"
print "  Total:  {test_count}"
print "  Passed: {pass_count}"
print ""

if pass_count == test_count:
    print "✅ All tests passed!"
    print ""
    print "Hybrid Operations Status:"
    print "  ✅ PureSimple mode works"
    print "  ✅ Auto mode respects thresholds"
    print "  ✅ Operations are correct"
    print "  ✅ FFI availability check works"
    print "  ✅ Ready for PyTorch FFI integration"
else:
    print "❌ Some tests failed"
