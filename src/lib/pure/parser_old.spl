# Pure Simple Parser
# Recursive descent parser for Simple language

use lib.pure.lexer (Token, TokenKind, lex_source)
use lib.pure.ast (Expr, Stmt, Pattern, TypeExpr, Module, BinOp, UnaryOp, Literal)

export parse, parse_expr, parse_stmt, ParseError

# Parser state
class Parser:
    tokens: [Token]
    current: i64

    fn is_at_end() -> bool:
        if self.current >= self.tokens.len():
            true
        else:
            match self.tokens[self.current].kind:
                case TokenKind.Eof: true
                case _: false

    fn peek() -> Token:
        if self.current < self.tokens.len():
            self.tokens[self.current]
        else:
            self.tokens[self.tokens.len() - 1]

    fn previous() -> Token:
        if self.current > 0:
            self.tokens[self.current - 1]
        else:
            self.tokens[0]

    me advance() -> Token:
        if not self.is_at_end():
            self.current = self.current + 1
        self.previous()

    fn check(kind: text) -> bool:
        if self.is_at_end():
            false
        else:
            match self.peek().kind:
                case TokenKind.Keyword(k): k == kind
                case TokenKind.Operator(o): o == kind
                case _: false

    me consume_keyword(keyword: text) -> bool:
        if self.check(keyword):
            self.advance()
            true
        else:
            false

    me consume_operator(op: text) -> bool:
        if self.check(op):
            self.advance()
            true
        else:
            false

# Parse error
struct ParseError:
    message: text
    line: i64
    column: i64

# Parse source into AST
fn parse(source: text) -> Result<Module, ParseError>:
    val tokens = lex_source(source)
    var parser = Parser(tokens: tokens, current: 0)

    var statements: [Stmt] = []
    while not parser.is_at_end():
        match parse_statement(parser):
            case Ok(stmt):
                statements.push(stmt)
            case Err(e):
                return Err(e)

    Ok(Module(statements: statements))

# Parse statement
fn parse_statement(parser: Parser) -> Result<Stmt, ParseError>:
    # Skip newlines
    while match_token(parser, TokenKind.Newline):
        ()

    # Function definition
    if parser.check("fn"):
        return parse_function(parser)

    # Variable declaration
    if parser.check("val") or parser.check("var"):
        return parse_let(parser)

    # Struct definition
    if parser.check("struct"):
        return parse_struct(parser)

    # Enum definition
    if parser.check("enum"):
        return parse_enum(parser)

    # Return statement
    if parser.check("return"):
        return parse_return(parser)

    # While loop
    if parser.check("while"):
        return parse_while(parser)

    # For loop
    if parser.check("for"):
        return parse_for(parser)

    # Expression statement
    match parse_expression(parser):
        case Ok(expr):
            Ok(Stmt.Expr(expr))
        case Err(e):
            Err(e)

# Parse function definition
fn parse_function(parser: Parser) -> Result<Stmt, ParseError>:
    parser.consume_keyword("fn")

    # Function name
    val name = match parser.peek().kind:
        case TokenKind.Identifier(n):
            parser.advance()
            n
        case _:
            return Err(ParseError(
                message: "Expected function name",
                line: parser.peek().line,
                column: parser.peek().column
            ))

    # Parameters
    parser.consume_operator("(")
    var params: [text] = []

    while not parser.check(")"):
        match parser.peek().kind:
            case TokenKind.Identifier(p):
                parser.advance()
                params.push(p)
                if not parser.check(")"):
                    parser.consume_operator(",")
            case _:
                break

    parser.consume_operator(")")

    # Return type (optional)
    var return_type: TypeExpr? = nil
    if parser.consume_operator("->"):
        match parse_type(parser):
            case Ok(t):
                return_type = Some(t)
            case Err(e):
                return Err(e)

    # Body
    parser.consume_operator(":")
    match parse_block(parser):
        case Ok(body):
            Ok(Stmt.Function(name, params, return_type, body))
        case Err(e):
            Err(e)

# Parse let/var statement
fn parse_let(parser: Parser) -> Result<Stmt, ParseError>:
    val is_val = parser.consume_keyword("val")
    if not is_val:
        parser.consume_keyword("var")

    # Variable name
    val name = match parser.peek().kind:
        case TokenKind.Identifier(n):
            parser.advance()
            n
        case _:
            return Err(ParseError(
                message: "Expected variable name",
                line: parser.peek().line,
                column: parser.peek().column
            ))

    # Type annotation (optional)
    var type_expr: TypeExpr? = nil
    if parser.consume_operator(":"):
        match parse_type(parser):
            case Ok(t):
                type_expr = Some(t)
            case Err(e):
                return Err(e)

    # Initializer
    parser.consume_operator("=")
    match parse_expression(parser):
        case Ok(expr):
            Ok(Stmt.Let(name, type_expr, expr))
        case Err(e):
            Err(e)

# Parse struct definition
fn parse_struct(parser: Parser) -> Result<Stmt, ParseError>:
    parser.consume_keyword("struct")

    val name = match parser.peek().kind:
        case TokenKind.Identifier(n):
            parser.advance()
            n
        case _:
            return Err(ParseError(
                message: "Expected struct name",
                line: parser.peek().line,
                column: parser.peek().column
            ))

    parser.consume_operator(":")

    var fields: [(text, TypeExpr)] = []
    # Parse fields (simplified)

    Ok(Stmt.Struct(name, fields))

# Parse enum definition
fn parse_enum(parser: Parser) -> Result<Stmt, ParseError>:
    parser.consume_keyword("enum")

    val name = match parser.peek().kind:
        case TokenKind.Identifier(n):
            parser.advance()
            n
        case _:
            return Err(ParseError(
                message: "Expected enum name",
                line: parser.peek().line,
                column: parser.peek().column
            ))

    parser.consume_operator(":")

    var variants: [(text, [TypeExpr])] = []
    # Parse variants (simplified)

    Ok(Stmt.Enum(name, variants))

# Parse return statement
fn parse_return(parser: Parser) -> Result<Stmt, ParseError>:
    parser.consume_keyword("return")

    if parser.check("\n") or parser.is_at_end():
        Ok(Stmt.Return(nil))
    else:
        match parse_expression(parser):
            case Ok(expr):
                Ok(Stmt.Return(Some(expr)))
            case Err(e):
                Err(e)

# Parse while loop
fn parse_while(parser: Parser) -> Result<Stmt, ParseError>:
    parser.consume_keyword("while")

    match parse_expression(parser):
        case Ok(cond):
            parser.consume_operator(":")
            match parse_block(parser):
                case Ok(body):
                    Ok(Stmt.While(cond, body))
                case Err(e):
                    Err(e)
        case Err(e):
            Err(e)

# Parse for loop
fn parse_for(parser: Parser) -> Result<Stmt, ParseError>:
    parser.consume_keyword("for")

    val var_name = match parser.peek().kind:
        case TokenKind.Identifier(n):
            parser.advance()
            n
        case _:
            return Err(ParseError(
                message: "Expected loop variable",
                line: parser.peek().line,
                column: parser.peek().column
            ))

    parser.consume_keyword("in")

    match parse_expression(parser):
        case Ok(iter):
            parser.consume_operator(":")
            match parse_block(parser):
                case Ok(body):
                    Ok(Stmt.For(var_name, iter, body))
                case Err(e):
                    Err(e)
        case Err(e):
            Err(e)

# Parse block with indentation
fn parse_block(parser: Parser) -> Result<[Stmt], ParseError>:
    var statements: [Stmt] = []

    # Expect newline after colon
    while match_token(parser, TokenKind.Newline):
        ()

    # Expect indent
    if not match_token(parser, TokenKind.Indent):
        # Single-line block (inline)
        match parse_statement(parser):
            case Ok(stmt):
                statements.push(stmt)
                return Ok(statements)
            case Err(e):
                return Err(e)

    # Multi-line block: parse until dedent
    while not match_token(parser, TokenKind.Dedent) and not parser.is_at_end():
        # Skip empty lines
        if match_token(parser, TokenKind.Newline):
            ()
        else:
            match parse_statement(parser):
                case Ok(stmt):
                    statements.push(stmt)
                case Err(e):
                    return Err(e)

    Ok(statements)

# Parse expression - entry point
fn parse_expression(parser: Parser) -> Result<Expr, ParseError>:
    parse_pipeline(parser)

# Parse pipeline operators (|> >> << ~> //)
fn parse_pipeline(parser: Parser) -> Result<Expr, ParseError>:
    match parse_coalesce(parser):
        case Ok(left):
            var current = left
            while parser.check("|>") or parser.check(">>") or parser.check("<<") or parser.check("~>") or parser.check("//"):
                val op_token = parser.advance()
                val op = match op_token.kind:
                    case TokenKind.Operator("|>"): BinOp.Pipe
                    case TokenKind.Operator(">>"): BinOp.ComposeForward
                    case TokenKind.Operator("<<"): BinOp.ComposeBackward
                    case TokenKind.Operator("~>"): BinOp.LayerConnect
                    case TokenKind.Operator("//"): BinOp.Parallel
                    case _: BinOp.Pipe
                match parse_coalesce(parser):
                    case Ok(right):
                        current = Expr.Binary(op, current, right)
                    case Err(e):
                        return Err(e)
            Ok(current)
        case Err(e):
            Err(e)

# Parse coalesce operator (??)
fn parse_coalesce(parser: Parser) -> Result<Expr, ParseError>:
    match parse_logical_or(parser):
        case Ok(left):
            var current = left
            while parser.check("??"):
                parser.advance()
                match parse_logical_or(parser):
                    case Ok(right):
                        current = Expr.Binary(BinOp.Coalesce, current, right)
                    case Err(e):
                        return Err(e)
            Ok(current)
        case Err(e):
            Err(e)

# Parse logical OR (||)
fn parse_logical_or(parser: Parser) -> Result<Expr, ParseError>:
    match parse_logical_and(parser):
        case Ok(left):
            var current = left
            while parser.check("||"):
                parser.advance()
                match parse_logical_and(parser):
                    case Ok(right):
                        current = Expr.Binary(BinOp.Or, current, right)
                    case Err(e):
                        return Err(e)
            Ok(current)
        case Err(e):
            Err(e)

# Parse logical AND (&&)
fn parse_logical_and(parser: Parser) -> Result<Expr, ParseError>:
    match parse_equality(parser):
        case Ok(left):
            var current = left
            while parser.check("&&"):
                parser.advance()
                match parse_equality(parser):
                    case Ok(right):
                        current = Expr.Binary(BinOp.And, current, right)
                    case Err(e):
                        return Err(e)
            Ok(current)
        case Err(e):
            Err(e)

# Parse equality (== !=)
fn parse_equality(parser: Parser) -> Result<Expr, ParseError>:
    match parse_comparison(parser):
        case Ok(left):
            var current = left
            while parser.check("==") or parser.check("!="):
                val op_token = parser.advance()
                val op = match op_token.kind:
                    case TokenKind.Operator("=="): BinOp.Eq
                    case TokenKind.Operator("!="): BinOp.NotEq
                    case _: BinOp.Eq
                match parse_comparison(parser):
                    case Ok(right):
                        current = Expr.Binary(op, current, right)
                    case Err(e):
                        return Err(e)
            Ok(current)
        case Err(e):
            Err(e)

# Parse comparison (< > <= >=)
fn parse_comparison(parser: Parser) -> Result<Expr, ParseError>:
    match parse_bitwise_or(parser):
        case Ok(left):
            var current = left
            while parser.check("<") or parser.check(">") or parser.check("<=") or parser.check(">="):
                val op_token = parser.advance()
                val op = match op_token.kind:
                    case TokenKind.Operator("<"): BinOp.Lt
                    case TokenKind.Operator(">"): BinOp.Gt
                    case TokenKind.Operator("<="): BinOp.LtEq
                    case TokenKind.Operator(">="): BinOp.GtEq
                    case _: BinOp.Lt
                match parse_bitwise_or(parser):
                    case Ok(right):
                        current = Expr.Binary(op, current, right)
                    case Err(e):
                        return Err(e)
            Ok(current)
        case Err(e):
            Err(e)

# Parse bitwise OR (|)
fn parse_bitwise_or(parser: Parser) -> Result<Expr, ParseError>:
    match parse_bitwise_xor(parser):
        case Ok(left):
            var current = left
            while parser.check("|"):
                parser.advance()
                match parse_bitwise_xor(parser):
                    case Ok(right):
                        current = Expr.Binary(BinOp.BitOr, current, right)
                    case Err(e):
                        return Err(e)
            Ok(current)
        case Err(e):
            Err(e)

# Parse bitwise XOR (^)
fn parse_bitwise_xor(parser: Parser) -> Result<Expr, ParseError>:
    match parse_bitwise_and(parser):
        case Ok(left):
            var current = left
            while parser.check("^"):
                parser.advance()
                match parse_bitwise_and(parser):
                    case Ok(right):
                        current = Expr.Binary(BinOp.BitXor, current, right)
                    case Err(e):
                        return Err(e)
            Ok(current)
        case Err(e):
            Err(e)

# Parse bitwise AND (&)
fn parse_bitwise_and(parser: Parser) -> Result<Expr, ParseError>:
    match parse_shift(parser):
        case Ok(left):
            var current = left
            while parser.check("&"):
                parser.advance()
                match parse_shift(parser):
                    case Ok(right):
                        current = Expr.Binary(BinOp.BitAnd, current, right)
                    case Err(e):
                        return Err(e)
            Ok(current)
        case Err(e):
            Err(e)

# Parse bit shift (<< >>)
fn parse_shift(parser: Parser) -> Result<Expr, ParseError>:
    match parse_addition(parser):
        case Ok(left):
            var current = left
            # Note: Need to check for << and >> before checking < and >
            # This is handled by lexer returning two-char operators first
            while parser.check("<<") or parser.check(">>"):
                val op_token = parser.advance()
                val op = match op_token.kind:
                    case TokenKind.Operator("<<"): BinOp.BitShl
                    case TokenKind.Operator(">>"): BinOp.BitShr
                    case _: BinOp.BitShl
                match parse_addition(parser):
                    case Ok(right):
                        current = Expr.Binary(op, current, right)
                    case Err(e):
                        return Err(e)
            Ok(current)
        case Err(e):
            Err(e)

# Parse addition (+ -)
fn parse_addition(parser: Parser) -> Result<Expr, ParseError>:
    match parse_multiplication(parser):
        case Ok(left):
            var current = left
            while parser.check("+") or parser.check("-"):
                val op_token = parser.advance()
                val op = match op_token.kind:
                    case TokenKind.Operator("+"): BinOp.Add
                    case TokenKind.Operator("-"): BinOp.Sub
                    case _: BinOp.Add
                match parse_multiplication(parser):
                    case Ok(right):
                        current = Expr.Binary(op, current, right)
                    case Err(e):
                        return Err(e)
            Ok(current)
        case Err(e):
            Err(e)

# Parse multiplication (* / %)
fn parse_multiplication(parser: Parser) -> Result<Expr, ParseError>:
    match parse_power(parser):
        case Ok(left):
            var current = left
            while parser.check("*") or parser.check("/") or parser.check("%"):
                val op_token = parser.advance()
                val op = match op_token.kind:
                    case TokenKind.Operator("*"): BinOp.Mul
                    case TokenKind.Operator("/"): BinOp.Div
                    case TokenKind.Operator("%"): BinOp.Mod
                    case _: BinOp.Mul
                match parse_power(parser):
                    case Ok(right):
                        current = Expr.Binary(op, current, right)
                    case Err(e):
                        return Err(e)
            Ok(current)
        case Err(e):
            Err(e)

# Parse power (**)
fn parse_power(parser: Parser) -> Result<Expr, ParseError>:
    match parse_unary(parser):
        case Ok(left):
            # Power is right-associative
            if parser.check("**"):
                parser.advance()
                match parse_power(parser):
                    case Ok(right):
                        Ok(Expr.Binary(BinOp.Pow, left, right))
                    case Err(e):
                        Err(e)
            else:
                Ok(left)
        case Err(e):
            Err(e)

# Parse unary (- ! ~)
fn parse_unary(parser: Parser) -> Result<Expr, ParseError>:
    if parser.check("-") or parser.check("!") or parser.check("~"):
        val op_token = parser.advance()
        val op = match op_token.kind:
            case TokenKind.Operator("-"): UnaryOp.Neg
            case TokenKind.Operator("!"): UnaryOp.Not
            case TokenKind.Operator("~"): UnaryOp.Not  # BitNot, using Not for now
            case _: UnaryOp.Neg

        match parse_unary(parser):
            case Ok(right):
                Ok(Expr.Unary(op, right))
            case Err(e):
                Err(e)
    else:
        parse_postfix(parser)

# Parse postfix expressions (field, method, index, slice, call)
fn parse_postfix(parser: Parser) -> Result<Expr, ParseError>:
    match parse_primary(parser):
        case Ok(expr):
            parse_postfix_loop(parser, expr)
        case Err(e):
            Err(e)

# Loop to handle chained postfix operations
fn parse_postfix_loop(parser: Parser, expr: Expr) -> Result<Expr, ParseError>:
    var current = expr

    while true:
        # Field access or method call: expr.field or expr.method(args)
        if parser.check("."):
            parser.advance()
            match parser.peek().kind:
                case TokenKind.Identifier(name):
                    parser.advance()
                    # Check if it's a method call
                    if parser.check("("):
                        parser.advance()
                        match parse_call_args(parser):
                            case Ok(args):
                                parser.consume_operator(")")
                                current = Expr.Method(current, name, args)
                            case Err(e):
                                return Err(e)
                    else:
                        current = Expr.Field(current, name)
                case _:
                    return Err(ParseError(
                        message: "Expected field or method name after '.'",
                        line: parser.peek().line,
                        column: parser.peek().column
                    ))

        # Indexing or slicing: expr[idx] or expr[start:end:step]
        elif parser.check("["):
            parser.advance()
            match parse_index_or_slice(parser, current):
                case Ok(indexed):
                    current = indexed
                case Err(e):
                    return Err(e)

        # Function call: expr(args)
        elif parser.check("("):
            parser.advance()
            match parse_call_args(parser):
                case Ok(args):
                    parser.consume_operator(")")
                    current = Expr.Call(current, args)
                case Err(e):
                    return Err(e)
        else:
            break

    Ok(current)

# Parse call arguments
fn parse_call_args(parser: Parser) -> Result<[Expr], ParseError>:
    var args: [Expr] = []

    # Handle empty argument list
    if parser.check(")"):
        return Ok(args)

    # Parse arguments
    while true:
        match parse_expression(parser):
            case Ok(arg):
                args.push(arg)
            case Err(e):
                return Err(e)

        # Check for end or comma
        if parser.check(")"):
            break
        elif parser.check(","):
            parser.advance()
            # Allow trailing comma
            if parser.check(")"):
                break
        else:
            return Err(ParseError(
                message: "Expected ',' or ')' in argument list",
                line: parser.peek().line,
                column: parser.peek().column
            ))

    Ok(args)

# Parse index or slice operation
fn parse_index_or_slice(parser: Parser, expr: Expr) -> Result<Expr, ParseError>:
    # Check if it's a slice or index
    var start: Expr? = nil
    var end: Expr? = nil
    var step: Expr? = nil

    # Parse start (optional if starts with :)
    if not parser.check(":"):
        match parse_expression(parser):
            case Ok(s):
                start = Some(s)
            case Err(e):
                return Err(e)

    # If no colon, it's simple indexing
    if parser.check("]"):
        parser.advance()
        match start:
            case Some(idx):
                return Ok(Expr.Index(expr, idx))
            case nil:
                return Err(ParseError(
                    message: "Empty index expression",
                    line: parser.peek().line,
                    column: parser.peek().column
                ))

    # It's a slice: parse end and step
    if parser.consume_operator(":"):
        # Parse end (optional)
        if not parser.check(":") and not parser.check("]"):
            match parse_expression(parser):
                case Ok(e):
                    end = Some(e)
                case Err(err):
                    return Err(err)

        # Parse step (optional)
        if parser.consume_operator(":"):
            if not parser.check("]"):
                match parse_expression(parser):
                    case Ok(s):
                        step = Some(s)
                    case Err(err):
                        return Err(err)

    parser.consume_operator("]")
    Ok(Expr.Slice(expr, start, end, step))

# Parse primary expression
fn parse_primary(parser: Parser) -> Result<Expr, ParseError>:
    val token = parser.peek()

    match token.kind:
        case TokenKind.Number(n):
            parser.advance()
            # Try to parse as int (simplified - should parse the actual number)
            Ok(Expr.Literal(Literal.Int(42)))

        case TokenKind.String(s):
            parser.advance()
            Ok(Expr.Literal(Literal.String(s)))

        case TokenKind.Keyword("true"):
            parser.advance()
            Ok(Expr.Literal(Literal.Bool(true)))

        case TokenKind.Keyword("false"):
            parser.advance()
            Ok(Expr.Literal(Literal.Bool(false)))

        case TokenKind.Identifier(name):
            parser.advance()
            Ok(Expr.Identifier(name))

        case TokenKind.Operator("("):
            parser.advance()
            match parse_expression(parser):
                case Ok(expr):
                    parser.consume_operator(")")
                    Ok(expr)
                case Err(e):
                    Err(e)

        case TokenKind.Operator("["):
            # Array literal
            parser.advance()
            var elements: [Expr] = []
            # Handle empty array
            if parser.check("]"):
                parser.advance()
                return Ok(Expr.List(elements))
            # Parse elements
            while true:
                match parse_expression(parser):
                    case Ok(elem):
                        elements.push(elem)
                    case Err(e):
                        return Err(e)
                # Check for end or comma
                if parser.check("]"):
                    parser.advance()
                    break
                elif parser.check(","):
                    parser.advance()
                    # Allow trailing comma
                    if parser.check("]"):
                        parser.advance()
                        break
                else:
                    # Unexpected token
                    return Err(ParseError(
                        message: "Expected ',' or ']' in array literal",
                        line: parser.peek().line,
                        column: parser.peek().column
                    ))
            Ok(Expr.List(elements))

        case _:
            Err(ParseError(
                message: "Expected expression",
                line: token.line,
                column: token.column
            ))

# Parse type expression
fn parse_type(parser: Parser) -> Result<TypeExpr, ParseError>:
    match parser.peek().kind:
        case TokenKind.Identifier(name):
            parser.advance()
            Ok(TypeExpr.Named(name))
        case _:
            Err(ParseError(
                message: "Expected type",
                line: parser.peek().line,
                column: parser.peek().column
            ))

# Match token kind
fn match_token(parser: Parser, kind: TokenKind) -> bool:
    if parser.is_at_end():
        false
    else:
        match parser.peek().kind:
            case k:
                if k == kind:
                    parser.advance()
                    true
                else:
                    false

# Export parse_expr for standalone expression parsing
fn parse_expr(source: text) -> Result<Expr, ParseError>:
    val tokens = lex_source(source)
    var parser = Parser(tokens: tokens, current: 0)
    parse_expression(parser)

# Export parse_stmt for standalone statement parsing
fn parse_stmt(source: text) -> Result<Stmt, ParseError>:
    val tokens = lex_source(source)
    var parser = Parser(tokens: tokens, current: 0)
    parse_statement(parser)
