# Polynomial Operations
#
# Purpose: Polynomial evaluation, arithmetic, and manipulation
#
# Contains:
# - Horner's method for efficient evaluation
# - Polynomial derivatives
# - Polynomial arithmetic (addition, multiplication)

fn nm_horner_eval(coeffs: [f64], x: f64) -> f64:
    """Evaluate polynomial using Horner's method.

    Coefficients are from highest to lowest degree.
    P(x) = a_n*x^n + a_(n-1)*x^(n-1) + ... + a_1*x + a_0

    Example:
        nm_horner_eval([1.0, -2.0, 1.0], 3.0)  # 1*3^2 - 2*3 + 1 = 4
    """
    if coeffs.len() == 0:
        return 0.0

    var result = coeffs[0]
    var i = 1
    while i < coeffs.len():
        result = result * x + coeffs[i]
        i = i + 1
    result

fn nm_polynomial_derivative(coeffs: [f64]) -> [f64]:
    """Calculate derivative of polynomial.

    Example:
        nm_polynomial_derivative([3.0, 2.0, 1.0])  # x^2+2x+3 -> [6.0, 2.0]
    """
    if coeffs.len() <= 1:
        return [0.0]

    var result = []
    var i = 0
    val n = coeffs.len() - 1
    while i < n:
        val power = n - i
        val coeff = coeffs[i] * power
        result.push(coeff)
        i = i + 1
    result

fn nm_polynomial_add(a: [f64], b: [f64]) -> [f64]:
    """Add two polynomials.

    Example:
        nm_polynomial_add([1.0, 2.0], [3.0, 4.0])  # [4.0, 6.0]
    """
    val max_len = if a.len() > b.len(): a.len() else: b.len()
    var result = []
    var i = 0

    while i < max_len:
        val a_val = if i < a.len(): a[i] else: 0.0
        val b_val = if i < b.len(): b[i] else: 0.0
        result.push(a_val + b_val)
        i = i + 1
    result

fn nm_polynomial_multiply(a: [f64], b: [f64]) -> [f64]:
    """Multiply two polynomials.

    Example:
        nm_polynomial_multiply([1.0, 1.0], [1.0, -1.0])  # (x+1)(x-1) = x^2-1
    """
    if a.len() == 0 or b.len() == 0:
        return [0.0]

    val result_len = a.len() + b.len() - 1
    var result = []
    var k = 0
    while k < result_len:
        result.push(0.0)
        k = k + 1

    var i = 0
    while i < a.len():
        var j = 0
        while j < b.len():
            result[i + j] = result[i + j] + a[i] * b[j]
            j = j + 1
        i = i + 1
    result

export *
