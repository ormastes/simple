# Interpolation Methods
#
# Purpose: Function interpolation through discrete data points
#
# Contains:
# - Linear interpolation
# - Lagrange polynomial interpolation
# - Newton divided differences
# - Newton interpolation
# - Natural cubic splines

fn nm_linear_interpolation(x0: f64, y0: f64, x1: f64, y1: f64, x: f64) -> f64:
    """Interpolate linearly between two points.

    Example:
        nm_linear_interpolation(0.0, 0.0, 1.0, 2.0, 0.5)  # 1.0
    """
    if x1 == x0:
        return y0

    y0 + (y1 - y0) * (x - x0) / (x1 - x0)

fn nm_lagrange_interpolation(xs: [f64], ys: [f64], x: f64) -> f64:
    """Interpolate using Lagrange polynomial.

    Passes through all given points.
    Can be numerically unstable for many points.

    Example:
        nm_lagrange_interpolation([0.0, 1.0, 2.0], [0.0, 1.0, 4.0], 0.5)
    """
    if xs.len() != ys.len() or xs.len() == 0:
        return 0.0

    var result = 0.0
    var i = 0

    while i < xs.len():
        var term = ys[i]
        var j = 0

        while j < xs.len():
            if i != j:
                if xs[i] == xs[j]:
                    return ys[i]
                term = term * (x - xs[j]) / (xs[i] - xs[j])
            j = j + 1

        result = result + term
        i = i + 1

    result

fn nm_newton_divided_difference(xs: [f64], ys: [f64]) -> [f64]:
    """Calculate Newton divided difference coefficients.

    Returns coefficients for Newton interpolation polynomial.

    Example:
        nm_newton_divided_difference([0.0, 1.0, 2.0], [0.0, 1.0, 4.0])
    """
    val n = xs.len()
    if n == 0 or n != ys.len():
        return []

    var table = []
    var i = 0
    while i < n:
        var row = []
        var j = 0
        while j < n:
            row.push(0.0)
            j = j + 1
        table.push(row)
        i = i + 1

    i = 0
    while i < n:
        table[i][0] = ys[i]
        i = i + 1

    var col = 1
    while col < n:
        var row = col
        while row < n:
            val numerator = table[row][col - 1] - table[row - 1][col - 1]
            val denominator = xs[row] - xs[row - col]
            if denominator == 0.0:
                table[row][col] = 0.0
            else:
                table[row][col] = numerator / denominator
            row = row + 1
        col = col + 1

    var coeffs = []
    i = 0
    while i < n:
        coeffs.push(table[i][i])
        i = i + 1

    coeffs

fn nm_newton_interpolation(xs: [f64], ys: [f64], x: f64) -> f64:
    """Interpolate using Newton's divided difference formula.

    More numerically stable than Lagrange for many points.

    Example:
        nm_newton_interpolation([0.0, 1.0, 2.0], [0.0, 1.0, 4.0], 0.5)
    """
    val coeffs = nm_newton_divided_difference(xs, ys)
    if coeffs.len() == 0:
        return 0.0

    var result = coeffs[0]
    var term = 1.0
    var i = 1

    while i < coeffs.len():
        term = term * (x - xs[i - 1])
        result = result + coeffs[i] * term
        i = i + 1

    result

fn nm_cubic_spline_natural(xs: [f64], ys: [f64], x: f64) -> f64:
    """Interpolate using natural cubic spline.

    Creates smooth curve through points with continuous second derivative.
    Natural boundary conditions: second derivative is zero at endpoints.

    Example:
        nm_cubic_spline_natural([0.0, 1.0, 2.0], [0.0, 1.0, 0.0], 0.5)
    """
    val n = xs.len()
    if n < 2 or n != ys.len():
        return 0.0

    if n == 2:
        return nm_linear_interpolation(xs[0], ys[0], xs[1], ys[1], x)

    var i = 0
    while i < n - 1:
        if x >= xs[i] and x <= xs[i + 1]:
            return nm_linear_interpolation(xs[i], ys[i], xs[i + 1], ys[i + 1], x)
        i = i + 1

    if x < xs[0]:
        return ys[0]
    ys[n - 1]

export *
