# Feature Database - Domain-specific extension of SdnDatabase
#
# ⚠️ IMPORTANT: This is the ONLY way to update feature_db.sdn
# ⚠️ Do NOT edit doc/feature/feature_db.sdn manually
# ⚠️ All feature database operations MUST go through this module
#
# Provides feature tracking with multi-mode support (Pure, Hybrid, LLVM).
#
# NOTE: Test runner currently uses custom implementation in:
#   src/app/test_runner_new/feature_db.spl (TO BE MIGRATED)
# Future: Test runner should use this unified library instead.

use lib.database.mod.{SdnDatabase, SdnTable, SdnRow}
use lib.database.query.{QueryBuilder, CompareOp}
use lib.database.feature_utils.{sort_features_by_id, find_duplicate_ids, mark_orphaned_features}
use app.io.{rt_timestamp_now}

# ============================================================================
# Enums
# ============================================================================

enum FeatureStatus:
    Done
    InProgress
    Planned
    Failed
    Blocked

enum FeatureMode:
    Pure
    Hybrid
    LLVM

# ============================================================================
# Structs
# ============================================================================

struct Feature:
    id: text
    category: text
    name: text
    description: text
    spec_file: text
    pure_status: FeatureStatus
    hybrid_status: FeatureStatus
    llvm_status: FeatureStatus
    created_at: text
    updated_at: text
    valid: bool

struct CategoryStats:
    category: text
    total: i64
    done: i64
    in_progress: i64
    planned: i64
    failed: i64

# ============================================================================
# Helper Functions
# ============================================================================

fn load_feature_database(path: text) -> FeatureDatabase?:
    val db = SdnDatabase.load(path)?
    Some(FeatureDatabase(db: db))

fn create_feature_database(path: text) -> FeatureDatabase:
    val db = SdnDatabase.new(path)

    # Create features table
    val features_table = SdnTable.new("features", [
        "id",
        "category",
        "name",
        "description",
        "spec_file",
        "pure_status",
        "hybrid_status",
        "llvm_status",
        "created_at",
        "updated_at",
        "valid"
    ])
    db.set_table("features", features_table)

    FeatureDatabase(db: db)

# ============================================================================
# FeatureDatabase
# ============================================================================

class FeatureDatabase:
    db: SdnDatabase

    # Convert feature to SDN row
    fn feature_to_row(feature: Feature) -> SdnRow:
        val row = SdnRow.empty()
        row.set("id", feature.id)
        row.set("category", feature.category)
        row.set("name", feature.name)
        row.set("description", feature.description)
        row.set("spec_file", feature.spec_file)
        row.set("pure_status", status_to_string(feature.pure_status))
        row.set("hybrid_status", status_to_string(feature.hybrid_status))
        row.set("llvm_status", status_to_string(feature.llvm_status))
        row.set("created_at", feature.created_at)
        row.set("updated_at", feature.updated_at)
        val valid_str = if feature.valid: "true" else: "false"
        row.set("valid", valid_str)
        row

    # Add feature
    me add_feature(feature: Feature) -> bool:
        self.db.add_row_to_table("features", feature_to_row(feature))

    # Update feature
    me update_feature(id: text, feature: Feature) -> bool:
        var features_table_opt = self.db.get_table_mut("features")
        if not features_table_opt.?:
            return false

        var features_table = features_table_opt?
        features_table.mark_deleted(id)
        features_table.add_row(feature_to_row(feature))
        self.db.set_table("features", features_table)
        true

    # Get feature
    fn get_feature(id: text) -> Feature?:
        val features_table = self.db.get_table("features")?
        val row = features_table.get_row(id)?

        Some(Feature(
            id: id,
            category: row.get("category")?,
            name: row.get("name")?,
            description: row.get("description")?,
            spec_file: row.get("spec_file")?,
            pure_status: parse_status(row.get("pure_status")?),
            hybrid_status: parse_status(row.get("hybrid_status")?),
            llvm_status: parse_status(row.get("llvm_status")?),
            created_at: row.get("created_at")?,
            updated_at: row.get("updated_at")?,
            valid: row.get_bool("valid")?
        ))

    # Get all features
    fn all_features() -> [Feature]:
        val features_table = self.db.get_table("features")?
        var result = []

        for row in features_table.valid_rows():
            val id = row.get("id")?
            val feature = self.get_feature(id)?
            result.push(feature)

        result

    # Get features by category
    fn features_by_category(category: text) -> [Feature]:
        val features = self.all_features()
        features.filter(\f: f.category == category)

    # Get features by status (any mode)
    fn features_by_status(status: FeatureStatus) -> [Feature]:
        val features = self.all_features()
        val status_str = status_to_string(status)
        features.filter(\f: status_to_string(f.pure_status) == status_str or status_to_string(f.hybrid_status) == status_str or status_to_string(f.llvm_status) == status_str)

    # Get incomplete features (any mode not done)
    fn incomplete_features() -> [Feature]:
        val features = self.all_features()
        features.filter(\f: f.pure_status != FeatureStatus.Done or f.hybrid_status != FeatureStatus.Done or f.llvm_status != FeatureStatus.Done)

    # Get features by mode status
    fn features_by_mode_status(mode: FeatureMode, status: FeatureStatus) -> [Feature]:
        val features = self.all_features()
        val status_str = status_to_string(status)

        match mode:
            case FeatureMode.Pure:
                features.filter(\f: status_to_string(f.pure_status) == status_str)
            case FeatureMode.Hybrid:
                features.filter(\f: status_to_string(f.hybrid_status) == status_str)
            case FeatureMode.LLVM:
                features.filter(\f: status_to_string(f.llvm_status) == status_str)

    # Get all categories
    fn all_categories() -> [text]:
        val features = self.all_features()
        var categories = []

        for feature in features:
            if not categories.contains(feature.category):
                categories.push(feature.category)

        categories

    # Get category statistics
    fn category_stats(category: text) -> CategoryStats:
        val features = self.features_by_category(category)
        val total = features.len()

        # Count by status (using pure mode as primary)
        val done = features.filter(\f: f.pure_status == FeatureStatus.Done).len()
        val in_progress = features.filter(\f: f.pure_status == FeatureStatus.InProgress).len()
        val planned = features.filter(\f: f.pure_status == FeatureStatus.Planned).len()
        val failed = features.filter(\f: f.pure_status == FeatureStatus.Failed).len()

        CategoryStats(
            category: category,
            total: total,
            done: done,
            in_progress: in_progress,
            planned: planned,
            failed: failed
        )

    # ========================================================================
    # Utility Methods (from feature_utils)
    # ========================================================================

    # Sort features by ID using semantic comparison
    fn sorted_features() -> [Feature]:
        val features = self.all_features()
        sort_features_by_id(features)

    # Find duplicate feature IDs
    fn find_duplicates() -> [text]:
        val features = self.all_features()
        find_duplicate_ids(features)

    # Mark features as invalid if their spec files don't exist
    me mark_orphaned(known_spec_files: [text]):
        val features = self.all_features()
        val updated = mark_orphaned_features(features, known_spec_files)

        # Update all features with new valid status
        for feature in updated:
            if not feature.valid:
                # Mark as invalid in database
                self.update_feature(feature.id, feature)

    # Update feature status by ID (convenience method)
    me update_feature_status(id: text, status: FeatureStatus) -> bool:
        val feature_opt = self.get_feature(id)
        if not feature_opt.?:
            return false

        var feature = feature_opt?
        # Update pure status as primary
        feature.pure_status = status
        feature.updated_at = rt_timestamp_now().to_string()

        self.update_feature(id, feature)

    # Count features by status (any mode)
    fn count_by_status(status: FeatureStatus) -> i64:
        val features = self.features_by_status(status)
        features.len()

    # Save database
    me save() -> bool:
        self.db.save()

# ============================================================================
# Helper Functions
# ============================================================================

fn status_to_string(status: FeatureStatus) -> text:
    match status:
        FeatureStatus.Done: "done"
        FeatureStatus.InProgress: "in_progress"
        FeatureStatus.Planned: "planned"
        FeatureStatus.Failed: "failed"
        FeatureStatus.Blocked: "blocked"

fn parse_status(s: text) -> FeatureStatus:
    match s:
        "done": FeatureStatus.Done
        "in_progress": FeatureStatus.InProgress
        "planned": FeatureStatus.Planned
        "failed": FeatureStatus.Failed
        "blocked": FeatureStatus.Blocked
        _: FeatureStatus.Planned

fn mode_to_string(mode: FeatureMode) -> text:
    match mode:
        FeatureMode.Pure: "pure"
        FeatureMode.Hybrid: "hybrid"
        FeatureMode.LLVM: "llvm"

# ============================================================================
# Exports
# ============================================================================

export FeatureStatus, FeatureMode
export Feature, CategoryStats
export FeatureDatabase
export load_feature_database, create_feature_database
export status_to_string, parse_status, mode_to_string
