# Feature Database - Domain-specific extension of SdnDatabase
#
# ⚠️ IMPORTANT: This is the ONLY way to update feature_db.sdn
# ⚠️ Do NOT edit doc/feature/feature_db.sdn manually
# ⚠️ All feature database operations MUST go through this module
#
# Provides feature tracking with multi-mode support (Pure, Hybrid, LLVM).
#
# NOTE: Test runner currently uses custom implementation in:
#   src/app/test_runner_new/feature_db.spl (TO BE MIGRATED)
# Future: Test runner should use this unified library instead.

use std.database.core
use std.database.query
use std.database.feature_utils
use std.database.checker.{DbIssue, check_duplicate_ids, check_valid_column,
    check_empty_required, check_file_refs, check_enum_values}
use app.io

# ============================================================================
# Enums
# ============================================================================

enum FeatureStatus:
    Done
    InProgress
    Planned
    Failed
    Blocked

enum FeatureMode:
    Pure
    Hybrid
    LLVM

# ============================================================================
# Structs
# ============================================================================

struct Feature:
    id: text
    category: text
    name: text
    description: text
    spec_file: text
    pure_status: FeatureStatus
    hybrid_status: FeatureStatus
    llvm_status: FeatureStatus
    created_at: text
    updated_at: text
    valid: bool

struct CategoryStats:
    category: text
    total: i64
    done: i64
    in_progress: i64
    planned: i64
    failed: i64

# ============================================================================
# Helper Functions
# ============================================================================

fn load_feature_database(path: text) -> FeatureDatabase?:
    val db = SdnDatabase.load(path)?
    Some(FeatureDatabase(db: db))

fn create_feature_database(path: text) -> FeatureDatabase:
    val db = SdnDatabase.new(path)

    # Create features table
    val features_table = SdnTable.new("features", [
        "id",
        "category",
        "name",
        "description",
        "spec",
        "status",
        "created_at",
        "updated_at",
        "valid"
    ])
    db.set_table("features", features_table)

    FeatureDatabase(db: db)

# ============================================================================
# Conversion Functions
# ============================================================================

fn feature_to_row(feature: Feature) -> SdnRow:
    """Convert Feature to SdnRow for database storage.

    This is the standalone function version that can be called from outside
    the FeatureDatabase class. Tests and external code should use this.
    """
    val row = SdnRow.empty()
    row.set("id", feature.id)
    row.set("category", feature.category)
    row.set("name", feature.name)
    row.set("description", feature.description)
    row.set("spec", feature.spec_file)
    row.set("status", status_to_string(feature.pure_status))
    row.set("created_at", feature.created_at)
    row.set("updated_at", feature.updated_at)
    val valid_str = if feature.valid: "true" else: "false"
    row.set("valid", valid_str)
    row

# ============================================================================
# FeatureDatabase
# ============================================================================

class FeatureDatabase:
    db: SdnDatabase

    # Convert feature to SDN row (delegates to standalone function)
    fn feature_to_row(feature: Feature) -> SdnRow:
        feature_to_row(feature)

    # Add feature
    me add_feature(feature: Feature) -> bool:
        self.db.add_row_to_table("features", feature_to_row(feature))

    # Update feature
    me update_feature(id: text, feature: Feature) -> bool:
        var features_table_opt = self.db.get_table_mut("features")
        if not features_table_opt.?:
            return false

        var features_table = features_table_opt.unwrap()
        features_table.mark_deleted(id)
        features_table.add_row(feature_to_row(feature))
        self.db.set_table("features", features_table)
        true

    # Get feature
    fn get_feature(id: text) -> Feature?:
        val features_table_opt = self.db.get_table("features")
        if not features_table_opt.?:
            return nil
        val features_table = features_table_opt.unwrap()
        val row_opt = features_table.get_row(id)
        if not row_opt.?:
            return nil
        val row = row_opt.unwrap()

        val category = row.get("category") ?? ""
        val name = row.get("name") ?? ""
        val description = row.get("description") ?? ""
        # Support both column names: "spec" (SDN actual) and "spec_file" (legacy)
        val spec_file = row.get("spec") ?? row.get("spec_file") ?? ""
        # Support both schemas: single "status" column or per-mode columns
        val status_str = row.get("status") ?? "planned"
        val pure_status_str = row.get("pure_status") ?? status_str
        val hybrid_status_str = row.get("hybrid_status") ?? status_str
        val llvm_status_str = row.get("llvm_status") ?? status_str
        val created_at = row.get("created_at") ?? ""
        val updated_at = row.get("updated_at") ?? ""
        val valid_opt = row.get("valid")
        val valid = if valid_opt.?: valid_opt.unwrap() == "true" else: true

        Some(Feature(
            id: id,
            category: category,
            name: name,
            description: description,
            spec_file: spec_file,
            pure_status: parse_status(pure_status_str),
            hybrid_status: parse_status(hybrid_status_str),
            llvm_status: parse_status(llvm_status_str),
            created_at: created_at,
            updated_at: updated_at,
            valid: valid
        ))

    # Get all features
    fn all_features() -> [Feature]:
        val features_table_opt = self.db.get_table("features")
        if not features_table_opt.?:
            return []
        val features_table = features_table_opt.unwrap()
        var result = []

        for row in features_table.valid_rows():
            val id_opt = row.get("id")
            if not id_opt.?:
                continue
            val id = id_opt.unwrap()
            val feature_opt = self.get_feature(id)
            if not feature_opt.?:
                continue
            val feature = feature_opt.unwrap()
            result.push(feature)

        result

    # Get features by category
    fn features_by_category(category: text) -> [Feature]:
        val features = self.all_features()
        features.filter(\f: f.category == category)

    # Get features by status (any mode)
    fn features_by_status(status: FeatureStatus) -> [Feature]:
        val features = self.all_features()
        val status_str = status_to_string(status)
        features.filter(\f: status_to_string(f.pure_status) == status_str or status_to_string(f.hybrid_status) == status_str or status_to_string(f.llvm_status) == status_str)

    # Get incomplete features (any mode not done)
    fn incomplete_features() -> [Feature]:
        val features = self.all_features()
        features.filter(\f: f.pure_status != FeatureStatus.Done or f.hybrid_status != FeatureStatus.Done or f.llvm_status != FeatureStatus.Done)

    # Get features by mode status
    fn features_by_mode_status(mode: FeatureMode, status: FeatureStatus) -> [Feature]:
        val features = self.all_features()
        val status_str = status_to_string(status)

        if mode == FeatureMode.Pure:
            features.filter(\f: status_to_string(f.pure_status) == status_str)
        elif mode == FeatureMode.Hybrid:
            features.filter(\f: status_to_string(f.hybrid_status) == status_str)
        elif mode == FeatureMode.LLVM:
            features.filter(\f: status_to_string(f.llvm_status) == status_str)
        else:
            []

    # Get all categories
    fn all_categories() -> [text]:
        val features = self.all_features()
        var categories = []

        for feature in features:
            if not categories.contains(feature.category):
                categories.push(feature.category)

        categories

    # Get category statistics
    fn category_stats(category: text) -> CategoryStats:
        val features = self.features_by_category(category)
        val total = features.len()

        # Single pass counting by status (using pure mode as primary)
        var done = 0
        var in_progress = 0
        var planned = 0
        var failed = 0
        for f in features:
            if f.pure_status == FeatureStatus.Done:
                done = done + 1
            elif f.pure_status == FeatureStatus.InProgress:
                in_progress = in_progress + 1
            elif f.pure_status == FeatureStatus.Planned:
                planned = planned + 1
            elif f.pure_status == FeatureStatus.Failed:
                failed = failed + 1

        CategoryStats(
            category: category,
            total: total,
            done: done,
            in_progress: in_progress,
            planned: planned,
            failed: failed
        )

    # ========================================================================
    # Utility Methods (from feature_utils)
    # ========================================================================

    # Sort features by ID using semantic comparison
    fn sorted_features() -> [Feature]:
        val features = self.all_features()
        sort_features_by_id(features)

    # Find duplicate feature IDs
    fn find_duplicates() -> [text]:
        val features = self.all_features()
        find_duplicate_ids(features)

    # Mark features as invalid if their spec files don't exist
    me mark_orphaned(known_spec_files: [text]):
        val features = self.all_features()
        val updated = mark_orphaned_features(features, known_spec_files)

        # Update all features with new valid status
        for feature in updated:
            if not feature.valid:
                # Mark as invalid in database
                self.update_feature(feature.id, feature)

    # Update feature status by ID (convenience method)
    me update_feature_status(id: text, status: FeatureStatus) -> bool:
        val feature_opt = self.get_feature(id)
        if not feature_opt.?:
            return false
        val old = feature_opt.unwrap()

        # Create new Feature with updated status (struct fields are immutable)
        val updated = Feature(
            id: old.id,
            category: old.category,
            name: old.name,
            description: old.description,
            spec_file: old.spec_file,
            pure_status: status,
            hybrid_status: status,
            llvm_status: status,
            created_at: old.created_at,
            updated_at: old.updated_at,
            valid: old.valid
        )
        self.update_feature(id, updated)

    # Count features by status (any mode)
    fn count_by_status(status: FeatureStatus) -> i64:
        val features = self.features_by_status(status)
        features.len()

    # Save database
    me save() -> bool:
        self.db.save()

    # Unified validation returning DbIssue list
    fn validate() -> [DbIssue]:
        var issues: [DbIssue] = []
        val db_name = "feature"

        val table_opt = self.db.get_table("features")
        if not table_opt.?:
            issues.push(DbIssue(
                db_name: db_name,
                severity: "error",
                issue_type: "missing_table",
                message: "Expected 'features' table not found in feature database",
                auto_fixable: false
            ))
            return issues

        val table = table_opt.unwrap()

        # Duplicate ID check
        val dup_issues = check_duplicate_ids(table, "id", db_name)
        for issue in dup_issues:
            issues.push(issue)

        # Valid column check
        val valid_issues = check_valid_column(table, db_name)
        for issue in valid_issues:
            issues.push(issue)

        # Status values check
        val valid_statuses = ["done", "complete", "in_progress", "planned", "failed", "blocked"]
        val status_issues = check_enum_values(table, "status", valid_statuses, db_name)
        for issue in status_issues:
            issues.push(issue)

        # Empty required fields
        val empty_name = check_empty_required(table, "name", db_name)
        for issue in empty_name:
            issues.push(issue)

        val empty_cat = check_empty_required(table, "category", db_name)
        for issue in empty_cat:
            issues.push(issue)

        val empty_id = check_empty_required(table, "id", db_name)
        for issue in empty_id:
            issues.push(issue)

        # Spec file references exist
        val file_issues = check_file_refs(table, "spec", db_name)
        for issue in file_issues:
            issues.push(issue)

        # Use existing find_duplicates for cross-check
        val dups = self.find_duplicates()
        for dup in dups:
            issues.push(DbIssue(
                db_name: db_name,
                severity: "warning",
                issue_type: "feature_duplicate",
                message: "Duplicate feature ID detected: {dup}",
                auto_fixable: true
            ))

        issues

# ============================================================================
# Helper Functions
# ============================================================================

fn status_to_string(status: FeatureStatus) -> text:
    match status:
        FeatureStatus.Done: "done"
        FeatureStatus.InProgress: "in_progress"
        FeatureStatus.Planned: "planned"
        FeatureStatus.Failed: "failed"
        FeatureStatus.Blocked: "blocked"

fn parse_status(s: text) -> FeatureStatus:
    match s:
        "done": FeatureStatus.Done
        "complete": FeatureStatus.Done
        "in_progress": FeatureStatus.InProgress
        "planned": FeatureStatus.Planned
        "failed": FeatureStatus.Failed
        "blocked": FeatureStatus.Blocked
        _: FeatureStatus.Planned

fn mode_to_string(mode: FeatureMode) -> text:
    match mode:
        FeatureMode.Pure: "pure"
        FeatureMode.Hybrid: "hybrid"
        FeatureMode.LLVM: "llvm"

# ============================================================================
# Exports
# ============================================================================

export FeatureStatus, FeatureMode
export Feature, CategoryStats
export FeatureDatabase
export load_feature_database, create_feature_database
export status_to_string, parse_status, mode_to_string
export feature_to_row
