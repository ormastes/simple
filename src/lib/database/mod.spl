# Database Systems Module
# @tag:api
#
# Provides BugDB, TestDB, and FeatureDB for tracking compiler metadata.
# All database operations use atomic file I/O with locking to prevent race
# conditions and data corruption.
#
# This module consists of three specialized databases built on a shared
# SDN (Simple Data Notation) foundation:
#
# 1. **BugDatabase** - Track compiler bugs with severity/status metadata
# 2. **TestDatabase** - Track test execution results and performance
# 3. **FeatureDatabase** - Track feature implementation across compilation modes
#
# All databases use SDN format for human-readable, version-control-friendly
# storage. The core infrastructure provides:
# - **StringInterner** - Deduplication of repeated strings (20-40% space savings)
# - **SdnTable/SdnRow** - In-memory table representation with field access
# - **QueryBuilder** - Fluent query API with filtering, sorting, limiting
# - **Atomic operations** - File locking prevents concurrent write conflicts
#
# Database Schema Design:
# - Each database has a primary table (bugs, tests, features)
# - Rows use string keys (no integer IDs for human readability)
# - Soft deletion via `valid=false` flag (never hard delete)
# - All timestamps in ISO 8601 format (YYYY-MM-DD HH:MM:SS)
#
# Atomic File Operations:
# - Read: `atomic_read(path)` - Shared lock, multiple readers allowed
# - Write: `atomic_write(path, content)` - Exclusive lock, atomic rename
# - All saves go through atomic_write to prevent partial writes
#
# Query Patterns:
# - Filter: Equality, comparison, string contains/starts_with/ends_with
# - Sort: Any field, ascending or descending
# - Limit: Take first N results
# - Chaining: `.filter_by(...).order_by(...).take(10).execute()`
#
# WARNING: Direct File Editing Forbidden
# - NEVER manually edit .sdn database files
# - NEVER use `file_write()` directly on database paths
# - ALWAYS use the database API (add, update, save methods)
# - Race conditions WILL corrupt data if you bypass atomic operations
#
# Example: Bug Database - Track compiler defects with severity/status
#
#     use lib.database.bug.{create_bug_database, Bug, BugSeverity, BugStatus}
#     use app.io.{rt_timestamp_now}
#
#     # Create new database or load existing
#     val db = create_bug_database("doc/bug/bug_db.sdn")
#
#     # Create bug records
#     val bug1 = Bug(
#         id: "BUG-001",
#         title: "Parser crashes on nested generics",
#         severity: BugSeverity.P0,
#         status: BugStatus.Open,
#         description: ["Fails with 'expected >' at generic type parameter"],
#         file: "src/compiler/parser.spl",
#         line: 234,
#         reproducible_by: "test/unit/parser_nested_generics_spec.spl",
#         fix_strategy: [],
#         investigation_log: [],
#         created_at: rt_timestamp_now(),
#         updated_at: rt_timestamp_now(),
#         valid: true
#     )
#
#     val bug2 = Bug(
#         id: "BUG-002",
#         title: "Slow lexer on large files",
#         severity: BugSeverity.P2,
#         status: BugStatus.Investigating,
#         description: ["10MB file takes 30 seconds to tokenize"],
#         file: "src/compiler/lexer.spl",
#         line: 567,
#         reproducible_by: "test/perf/lexer_large_file_spec.spl",
#         fix_strategy: [],
#         investigation_log: [],
#         created_at: rt_timestamp_now(),
#         updated_at: rt_timestamp_now(),
#         valid: true
#     )
#
#     # Add bugs to database
#     db.add_bug(bug1)
#     db.add_bug(bug2)
#
#     # Query by severity (returns Bug structs)
#     val critical = db.query_by_severity(BugSeverity.P0)
#     print "Critical bugs: {critical.len()}"
#     # Output: Critical bugs: 1
#
#     # Query by status
#     val open_bugs = db.query_by_status(BugStatus.Open)
#     for bug in open_bugs:
#         print "{bug.id}: {bug.title}"
#     # Output: BUG-001: Parser crashes on nested generics
#
#     # Save atomically (exclusive file lock)
#     db.save()
#
# Example: Test Database - Track test execution and flakiness
#
#     use lib.database.test.{create_test_database, TestResult, TestStatus, RunStatus}
#     use app.io.{rt_timestamp_now}
#
#     val db = create_test_database("doc/test/test_db.sdn")
#
#     # Start a test run
#     val run_id = db.start_run()
#
#     # Record test results with timing
#     val result1 = TestResult(
#         test_name: "test/unit/parser_spec.spl",
#         status: TestStatus.Passed,
#         duration_ms: 125,
#         error_message: "",
#         timestamp: rt_timestamp_now()
#     )
#     val result2 = TestResult(
#         test_name: "test/unit/lexer_spec.spl",
#         status: TestStatus.Failed,
#         duration_ms: 89,
#         error_message: "Expected 5 tokens, got 3",
#         timestamp: rt_timestamp_now()
#     )
#     val result3 = TestResult(
#         test_name: "test/unit/type_checker_spec.spl",
#         status: TestStatus.Passed,
#         duration_ms: 234,
#         error_message: "",
#         timestamp: rt_timestamp_now()
#     )
#
#     db.add_result(run_id, result1)
#     db.add_result(run_id, result2)
#     db.add_result(run_id, result3)
#
#     # End test run
#     db.end_run(run_id, RunStatus.Completed)
#
#     # Save results
#     db.save()
#
# Example: Feature Database - Track implementation across compilation modes
#
#     use lib.database.feature.{create_feature_database, Feature, FeatureStatus, FeatureMode}
#     use app.io.{rt_timestamp_now}
#
#     val db = create_feature_database("doc/feature/feature_db.sdn")
#
#     # Create feature record with per-mode status
#     val feature = Feature(
#         id: "generics",
#         category: "std/generic",
#         name: "Generic type parameters",
#         description: "Generic type parameters <T>",
#         spec_file: "test/unit/generics_spec.spl",
#         pure_status: FeatureStatus.Done,
#         hybrid_status: FeatureStatus.InProgress,
#         llvm_status: FeatureStatus.Planned,
#         created_at: rt_timestamp_now(),
#         updated_at: rt_timestamp_now(),
#         valid: true
#     )
#
#     # Add feature to database
#     db.add_feature(feature)
#
#     # Update specific mode status
#     db.update_feature("generics", Feature(
#         id: "generics",
#         category: "std/generic",
#         name: "Generic type parameters",
#         description: "Generic type parameters <T>",
#         spec_file: "test/unit/generics_spec.spl",
#         pure_status: FeatureStatus.Done,
#         hybrid_status: FeatureStatus.Done,
#         llvm_status: FeatureStatus.InProgress,
#         created_at: rt_timestamp_now(),
#         updated_at: rt_timestamp_now(),
#         valid: true
#     ))
#
#     # Save database
#     db.save()
#
# Example: Query Builder - Advanced filtering and sorting
#
#     use lib.database.bug.{load_bug_database}
#     use lib.database.query.{QueryBuilder, CompareOp}
#
#     val db_opt = load_bug_database("doc/bug/bug_db.sdn")
#     if not db_opt.?:
#         print "Failed to load database"
#         return
#
#     val db = db_opt.unwrap()
#     val table_opt = db.db.get_table("bugs")
#     if not table_opt.?:
#         print "Bugs table not found"
#         return
#
#     val table = table_opt.unwrap()
#
#     # Build complex query: High severity, open bugs, sorted by ID
#     var query = QueryBuilder.for_table(table)
#     query.filter_by("severity", CompareOp.Eq, "P0")
#     query.filter_by("status", CompareOp.Eq, "Open")
#     query.order_by("id", desc: false)
#     query.take(10)
#
#     # Execute and process results
#     val results = query.execute()
#     for row in results:
#         val id = row.get("id") ?? "unknown"
#         val title = row.get("title") ?? "no title"
#         print "{id}: {title}"
#
# Example: Database Lifecycle - Create, load, update, save
#
#     use lib.database.bug.{create_bug_database, load_bug_database}
#     use lib.database.bug.{Bug, BugSeverity, BugStatus}
#     use app.io.{rt_timestamp_now}
#
#     # Create new database (empty file)
#     val db1 = create_bug_database("bugs.sdn")
#
#     val bug = Bug(
#         id: "BUG-001",
#         title: "First bug",
#         severity: BugSeverity.P1,
#         status: BugStatus.Open,
#         description: ["This is the first bug"],
#         file: "src/compiler/parser.spl",
#         line: 100,
#         reproducible_by: "test/unit/parser_spec.spl",
#         fix_strategy: [],
#         investigation_log: [],
#         created_at: rt_timestamp_now(),
#         updated_at: rt_timestamp_now(),
#         valid: true
#     )
#
#     db1.add_bug(bug)
#     db1.save()  # Atomic write with file lock
#
#     # Load existing database (reads file)
#     val db2_opt = load_bug_database("bugs.sdn")
#     if db2_opt.?:
#         val db2 = db2_opt.unwrap()
#         val bug_opt = db2.get_bug("BUG-001")
#         if bug_opt.?:
#             val loaded_bug = bug_opt.unwrap()
#             print loaded_bug.title
#             # Output: First bug
#
#         # Save again (no changes, but demonstrates API)
#         db2.save()  # Atomic write (exclusive lock prevents conflicts)
#
# Atomic Operations Details:
# - `atomic_read(path)` acquires shared lock (multiple readers OK)
# - `atomic_write(path, content)` uses write-rename pattern:
#   1. Write to temporary file (path.tmp)
#   2. Acquire exclusive lock on final path
#   3. Atomic rename (tmp -> final)
#   4. Release lock
# - Prevents partial writes from crashes/signals
# - Prevents concurrent write conflicts (one writer wins)
#
# String Interning:
# - Repeated strings stored once (e.g., "Open" appears 100 times = 1 copy)
# - 20-40% space savings on typical databases
# - Transparent to callers (intern/unintern automatic)
#
# See Also:
# - `src/lib/database/bug.spl` - Bug database implementation
# - `src/lib/database/test.spl` - Test database implementation
# - `src/lib/database/feature.spl` - Feature database implementation
# - `src/lib/database/core.spl` - SDN table infrastructure
# - `src/lib/database/query.spl` - Query builder patterns
# - `src/lib/database/atomic.spl` - Atomic file operations
# - `.claude/skills/database.md` - Database usage guide

# ============================================================================
# Re-export Public API
# @tag:api
#
# Note: This module serves as the main entry point for the database subsystem.
# All types and functions are already exported by their respective modules
# (bug.spl, test.spl, feature.spl, core.spl, query.spl, atomic.spl, stats.spl).
#
# Clients should import directly from submodules:
#   use lib.database.bug.{BugDatabase, create_bug_database}
#   use lib.database.test.{TestDatabase, create_test_database}
#   use lib.database.feature.{FeatureDatabase, create_feature_database}
#
# Or use the top-level lib re-exports:
#   use lib.{BugDatabase, TestDatabase, FeatureDatabase}
#
# This file provides comprehensive documentation and examples but does not
# re-export symbols (Simple modules auto-expose all public symbols from
# submodules when imported).
# ============================================================================
