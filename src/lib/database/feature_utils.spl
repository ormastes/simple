# Minimal feature utility helpers to satisfy bootstrap/native builds.
# Provides stable symbols used by FeatureDatabase without pulling in the full legacy implementation.

use std.database.feature.{Feature}

fn compare_feature_id(a: Feature, b: Feature) -> i64:
    if a.id == b.id:
        0
    elif a.id < b.id:
        -1
    else:
        1

fn sort_features_by_id(features: [Feature]) -> [Feature]:
    # Simple insertion sort for determinism
    var result = features
    var i = 1
    while i < result.len():
        val key = result[i]
        var j = i
        while j > 0 and compare_feature_id(result[j - 1], key) > 0:
            result[j] = result[j - 1]
            j = j - 1
        result[j] = key
        i = i + 1
    result

fn find_duplicate_ids(features: [Feature]) -> [Feature]:
    var seen: Dict<text, bool> = {}
    var dups: [Feature] = []
    for feature in features:
        if seen.contains_key(feature.id):
            dups.push(feature)
        else:
            seen[feature.id] = true
    dups

fn mark_orphaned_features(features: [Feature], valid_ids: [text]) -> [Feature]:
    var keep: [Feature] = []
    var ids: Dict<text, bool> = {}
    for id in valid_ids:
        ids[id] = true
    for feature in features:
        if ids.contains_key(feature.id):
            keep.push(feature)
    keep

export compare_feature_id, sort_features_by_id, find_duplicate_ids, mark_orphaned_features
