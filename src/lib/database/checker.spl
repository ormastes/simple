# Database Checker - Shared validation and fix infrastructure
#
# Provides generic SDN validation checks and auto-fix functions
# reusable by all databases (BugDB, TestDB, FeatureDB, TodoDB).
#
# Usage:
#   use lib.database.checker.{DbIssue, check_duplicate_ids, fix_remove_duplicates}
#
#   val issues = check_duplicate_ids(table, "id")
#   val fix_result = fix_remove_duplicates(table, "id")

use lib.database.core.{SdnDatabase, SdnTable, SdnRow}

# Direct extern declarations for bootstrap runtime compatibility
extern fn rt_file_exists(path: text) -> bool
fn file_exists(path: text) -> bool:
    rt_file_exists(path)

# ============================================================================
# Data Structures
# ============================================================================

struct DbIssue:
    db_name: text        # "bug", "feature", "todo", etc.
    severity: text       # "error", "warning", "info"
    issue_type: text     # "missing_field", "invalid_ref", "stale_data", etc.
    message: text
    auto_fixable: bool

struct DbCheckReport:
    db_name: text
    issues: [DbIssue]
    checked_at: text

struct DbFixResult:
    db_name: text
    fixed: [text]        # descriptions of what was fixed
    skipped: [text]      # descriptions of what couldn't be fixed

# ============================================================================
# Generic SDN Validation Checks
# ============================================================================

# Check if an SDN file can be loaded and parsed
fn check_sdn_parse(path: text, db_name: text) -> [DbIssue]:
    var issues: [DbIssue] = []

    if not file_exists(path):
        issues.push(DbIssue(
            db_name: db_name,
            severity: "error",
            issue_type: "file_missing",
            message: "Database file not found: {path}",
            auto_fixable: false
        ))

    issues

# Check that all required columns are present in a table
fn check_required_fields(table: SdnTable, required_cols: [text], db_name: text) -> [DbIssue]:
    var issues: [DbIssue] = []

    for col in required_cols:
        if not table.columns.contains(col):
            issues.push(DbIssue(
                db_name: db_name,
                severity: "error",
                issue_type: "missing_column",
                message: "Table '{table.name}' missing required column: {col}",
                auto_fixable: false
            ))

    issues

# Check for rows with empty required fields
fn check_empty_required(table: SdnTable, col: text, db_name: text) -> [DbIssue]:
    var issues: [DbIssue] = []
    var row_idx = 0

    for row in table.valid_rows():
        val value = row.get(col) ?? ""
        if value == "":
            val id = row.get("id") ?? "row_{row_idx}"
            issues.push(DbIssue(
                db_name: db_name,
                severity: "warning",
                issue_type: "empty_required",
                message: "Table '{table.name}' row '{id}': empty required field '{col}'",
                auto_fixable: false
            ))
        row_idx = row_idx + 1

    issues

# Check for duplicate primary keys
fn check_duplicate_ids(table: SdnTable, id_col: text, db_name: text) -> [DbIssue]:
    var issues: [DbIssue] = []
    var seen: Dict<text, i64> = {}

    for row in table.valid_rows():
        val id = row.get(id_col) ?? ""
        if id == "":
            continue

        if seen.contains_key(id):
            val count = seen[id] + 1
            seen[id] = count
            issues.push(DbIssue(
                db_name: db_name,
                severity: "error",
                issue_type: "duplicate_id",
                message: "Table '{table.name}': duplicate {id_col} '{id}' (occurrence {count})",
                auto_fixable: true
            ))
        else:
            seen[id] = 1

    issues

# Check that valid column has proper boolean values
fn check_valid_column(table: SdnTable, db_name: text) -> [DbIssue]:
    var issues: [DbIssue] = []
    var row_idx = 0

    for row in table.rows:
        val valid_opt = row.get("valid")
        if valid_opt.?:
            val valid_str = valid_opt.unwrap()
            if valid_str != "true" and valid_str != "false":
                val id = row.get("id") ?? "row_{row_idx}"
                issues.push(DbIssue(
                    db_name: db_name,
                    severity: "warning",
                    issue_type: "invalid_valid",
                    message: "Table '{table.name}' row '{id}': invalid valid value '{valid_str}' (expected true/false)",
                    auto_fixable: true
                ))
        row_idx = row_idx + 1

    issues

# Check that foreign key references are valid
fn check_orphan_refs(table: SdnTable, ref_col: text, target_table: SdnTable, target_id_col: text, db_name: text) -> [DbIssue]:
    var issues: [DbIssue] = []

    # Build set of valid target IDs
    var valid_ids: Dict<text, bool> = {}
    for row in target_table.valid_rows():
        val id = row.get(target_id_col) ?? ""
        if id != "":
            valid_ids[id] = true

    # Check each reference
    for row in table.valid_rows():
        val ref_val = row.get(ref_col) ?? ""
        if ref_val == "":
            continue

        if not valid_ids.contains_key(ref_val):
            val id = row.get("id") ?? row.get(ref_col) ?? "unknown"
            issues.push(DbIssue(
                db_name: db_name,
                severity: "warning",
                issue_type: "orphan_ref",
                message: "Table '{table.name}': '{ref_col}' references '{ref_val}' which doesn't exist in '{target_table.name}'",
                auto_fixable: false
            ))

    issues

# Check that a file reference column points to existing files
fn check_file_refs(table: SdnTable, col: text, db_name: text) -> [DbIssue]:
    var issues: [DbIssue] = []

    for row in table.valid_rows():
        val file_path = row.get(col) ?? ""
        if file_path == "":
            continue

        if not file_exists(file_path):
            val id = row.get("id") ?? "unknown"
            issues.push(DbIssue(
                db_name: db_name,
                severity: "info",
                issue_type: "file_not_found",
                message: "Table '{table.name}' row '{id}': referenced file not found: {file_path}",
                auto_fixable: false
            ))

    issues

# Check string interner IDs are in range
fn check_interner_bounds(db: SdnDatabase, db_name: text) -> [DbIssue]:
    var issues: [DbIssue] = []
    val max_id = db.interner.next_id.value

    # Check all interned string references are in bounds
    for (id, value) in db.interner.id_to_str:
        if id < 0 or id >= max_id:
            issues.push(DbIssue(
                db_name: db_name,
                severity: "error",
                issue_type: "interner_oob",
                message: "String interner: ID {id} out of bounds (max: {max_id})",
                auto_fixable: false
            ))

    issues

# Check that a column value is one of an allowed set
fn check_enum_values(table: SdnTable, col: text, allowed: [text], db_name: text) -> [DbIssue]:
    var issues: [DbIssue] = []

    for row in table.valid_rows():
        val value = row.get(col) ?? ""
        if value == "":
            continue

        if not allowed.contains(value):
            val id = row.get("id") ?? "unknown"
            issues.push(DbIssue(
                db_name: db_name,
                severity: "warning",
                issue_type: "invalid_enum",
                message: "Table '{table.name}' row '{id}': invalid {col} value '{value}' (expected one of: {allowed.join(\", \")})",
                auto_fixable: false
            ))

    issues

# ============================================================================
# Generic Fix Functions
# ============================================================================

# Remove duplicate rows by primary key (keep first, soft-delete rest)
fn fix_remove_duplicates(table: SdnTable, id_col: text) -> [text]:
    var fixed: [text] = []
    var seen: Dict<text, bool> = {}

    var i = 0
    while i < table.rows.len():
        val row = table.rows[i]
        val valid_opt = row.get("valid")
        val is_valid = if valid_opt.?: valid_opt.unwrap() != "false" else: true

        if is_valid:
            val id = row.get(id_col) ?? ""
            if id != "" and seen.contains_key(id):
                table.mark_deleted(id)
                fixed.push("Soft-deleted duplicate {id_col}='{id}' in table '{table.name}'")
            elif id != "":
                seen[id] = true
        i = i + 1

    fixed

# Fix invalid valid column values (set to "true")
fn fix_invalid_valid_col(table: SdnTable) -> [text]:
    var fixed: [text] = []
    var i = 0

    while i < table.rows.len():
        var row = table.rows[i]
        val valid_opt = row.get("valid")
        if valid_opt.?:
            val valid_str = valid_opt.unwrap()
            if valid_str != "true" and valid_str != "false":
                row.set("valid", "true")
                table.rows[i] = row
                val id = row.get("id") ?? "row_{i}"
                fixed.push("Set valid='true' for row '{id}' in table '{table.name}' (was '{valid_str}')")
        i = i + 1

    fixed

# Fix stale "running" entries by marking them as "crashed"
fn fix_stale_running(table: SdnTable, status_col: text) -> [text]:
    var fixed: [text] = []
    var i = 0

    while i < table.rows.len():
        var row = table.rows[i]
        val status = row.get(status_col) ?? ""

        if status == "running":
            row.set(status_col, "crashed")
            table.rows[i] = row
            val id = row.get("id") ?? row.get("run_id") ?? "row_{i}"
            fixed.push("Marked stale running entry '{id}' as crashed in table '{table.name}'")
        i = i + 1

    fixed

# Trim whitespace from all text fields
fn fix_trim_fields(table: SdnTable) -> [text]:
    var fixed: [text] = []
    var i = 0

    while i < table.rows.len():
        var row = table.rows[i]
        var row_changed = false

        for col in table.columns:
            val value = row.get(col) ?? ""
            val trimmed = value.trim()
            if trimmed != value:
                row.set(col, trimmed)
                row_changed = true

        if row_changed:
            table.rows[i] = row
            val id = row.get("id") ?? "row_{i}"
            fixed.push("Trimmed whitespace in row '{id}' in table '{table.name}'")
        i = i + 1

    fixed

# ============================================================================
# Utility Functions
# ============================================================================

# Count issues by severity
fn count_by_severity(issues: [DbIssue], severity: text) -> i64:
    var count = 0
    for issue in issues:
        if issue.severity == severity:
            count = count + 1
    count

# Filter issues to only auto-fixable ones
fn fixable_issues(issues: [DbIssue]) -> [DbIssue]:
    issues.filter(\i: i.auto_fixable)

# Format a DbIssue as a human-readable string
fn format_issue(issue: DbIssue) -> text:
    val fix_tag = if issue.auto_fixable: " [auto-fixable]" else: ""
    "[{issue.severity}] [{issue.db_name}] {issue.issue_type}: {issue.message}{fix_tag}"

# ============================================================================
# Exports
# ============================================================================

export DbIssue, DbCheckReport, DbFixResult
export check_sdn_parse, check_required_fields, check_empty_required
export check_duplicate_ids, check_valid_column, check_orphan_refs
export check_file_refs, check_interner_bounds, check_enum_values
export fix_remove_duplicates, fix_invalid_valid_col, fix_stale_running, fix_trim_fields
export count_by_severity, fixable_issues, format_issue
