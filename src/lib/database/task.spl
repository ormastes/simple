# Task Database - Read/validate wrapper for task_db.sdn
#
# The task system currently writes directly via file_write(),
# bypassing the shared database library. This module provides
# read-only access and validation for check-dbs/fix-dbs commands.
#
# NOTE: Write path migration is out of scope. This module only
# reads and validates existing task_db.sdn files.
#
# Usage:
#   use lib.database.task.{TaskDatabase, load_task_database}
#   val db = load_task_database("doc/task/task_db.sdn")

use lib.database.core.{SdnDatabase, SdnTable, SdnRow}
use lib.database.checker.{DbIssue, check_duplicate_ids, check_valid_column,
    check_required_fields, check_empty_required, check_enum_values}

# ============================================================================
# Structs
# ============================================================================

struct TaskEntry:
    id: text
    category: text
    name: text
    description: text
    priority: text
    status: text
    valid: bool

# ============================================================================
# Helper Functions
# ============================================================================

fn load_task_database(path: text) -> TaskDatabase?:
    val db = SdnDatabase.load(path)?
    Some(TaskDatabase(db: db))

# ============================================================================
# TaskDatabase
# ============================================================================

class TaskDatabase:
    db: SdnDatabase

    # Get all valid task entries
    fn all_tasks() -> [TaskEntry]:
        val table_opt = self.db.get_table("tasks")
        if not table_opt.?:
            return []

        val table = table_opt.unwrap()
        var result: [TaskEntry] = []

        for row in table.valid_rows():
            val id = row.get("id") ?? ""
            val category = row.get("category") ?? ""
            val name = row.get("name") ?? ""
            val description = row.get("description") ?? ""
            val priority = row.get("priority") ?? ""
            val status = row.get("status") ?? ""
            val valid_opt = row.get("valid")
            val valid = if valid_opt.?: valid_opt.unwrap() == "true" else: true

            result.push(TaskEntry(
                id: id,
                category: category,
                name: name,
                description: description,
                priority: priority,
                status: status,
                valid: valid
            ))

        result

    # Validate the task database
    fn validate() -> [DbIssue]:
        var issues: [DbIssue] = []
        val db_name = "task"

        val table_opt = self.db.get_table("tasks")
        if not table_opt.?:
            issues.push(DbIssue(
                db_name: db_name,
                severity: "error",
                issue_type: "missing_table",
                message: "Expected 'tasks' table not found in task database",
                auto_fixable: false
            ))
            return issues

        val table = table_opt.unwrap()

        # Check required columns
        val required = ["id", "category", "name", "priority", "status", "valid"]
        val col_issues = check_required_fields(table, required, db_name)
        for issue in col_issues:
            issues.push(issue)

        # Check for duplicate IDs
        val dup_issues = check_duplicate_ids(table, "id", db_name)
        for issue in dup_issues:
            issues.push(issue)

        # Check valid column values
        val valid_issues = check_valid_column(table, db_name)
        for issue in valid_issues:
            issues.push(issue)

        # Check required fields are not empty
        val empty_name = check_empty_required(table, "name", db_name)
        for issue in empty_name:
            issues.push(issue)

        val empty_cat = check_empty_required(table, "category", db_name)
        for issue in empty_cat:
            issues.push(issue)

        # Check priority values
        val valid_priorities = ["high", "medium", "low"]
        val pri_issues = check_enum_values(table, "priority", valid_priorities, db_name)
        for issue in pri_issues:
            issues.push(issue)

        # Check status values
        val valid_statuses = ["planned", "in_progress", "complete", "blocked"]
        val status_issues = check_enum_values(table, "status", valid_statuses, db_name)
        for issue in status_issues:
            issues.push(issue)

        # Warn about direct file_write bypass
        issues.push(DbIssue(
            db_name: db_name,
            severity: "info",
            issue_type: "bypass_warning",
            message: "TaskDB uses direct file_write() â€” not managed by shared database library",
            auto_fixable: false
        ))

        issues

# ============================================================================
# Exports
# ============================================================================

export TaskDatabase, TaskEntry
export load_task_database
