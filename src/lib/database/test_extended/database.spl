# Test Database Extended - Main Class
#
# Extended TestDatabase with complete feature set

use lib.database.core.{SdnDatabase, SdnTable, SdnRow, StringInterner}
use lib.database.stats.{Stats, stats_from_values, is_flaky, update_baseline, is_significant_change}
use lib.database.test_extended.stubs.{rt_timestamp_now, rt_getpid, hostname}
use lib.database.test_extended.types.{
    FileRecord, SuiteRecord, TestRecord, CounterRecord,
    TimingSummary, TimingRun, ChangeEvent, RunRecord, TestInfo
}

class TestDatabaseExtended:
    db: SdnDatabase
    interner: StringInterner
    next_file_id: i64
    next_suite_id: i64
    next_test_id: i64
    next_timing_run_id: i64
    next_change_id: i64

    # Create extended database with all tables
    static fn create(path: text) -> TestDatabaseExtended:
        var db = SdnDatabase.new(path)

        # Table 1: strings
        val strings_table = SdnTable.new("strings", ["id", "value"])
        db.set_table("strings", strings_table)

        # Table 2: files
        val files_table = SdnTable.new("files", ["file_id", "path_str"])
        db.set_table("files", files_table)

        # Table 3: suites
        val suites_table = SdnTable.new("suites", ["suite_id", "file_id", "name_str"])
        db.set_table("suites", suites_table)

        # Table 4: tests
        val tests_table = SdnTable.new("tests", [
            "test_id", "suite_id", "name_str", "category_str",
            "status_str", "tags_str", "description_str", "valid"
        ])
        db.set_table("tests", tests_table)

        # Table 5: counters
        val counters_table = SdnTable.new("counters", [
            "test_id", "total_runs", "passed", "failed", "crashed",
            "timed_out", "flaky_count", "consecutive_passes"
        ])
        db.set_table("counters", counters_table)

        # Table 6: timing
        val timing_table = SdnTable.new("timing", [
            "test_id", "mean", "p50", "p90", "p95", "p99", "iqr",
            "has_baseline", "baseline_p50", "baseline_updated_at", "last_10_runs"
        ])
        db.set_table("timing", timing_table)

        # Table 7: timing_runs
        val timing_runs_table = SdnTable.new("timing_runs", [
            "timing_run_id", "test_id", "duration_ms", "run_id", "timestamp"
        ])
        db.set_table("timing_runs", timing_runs_table)

        # Table 8: changes
        val changes_table = SdnTable.new("changes", [
            "change_id", "test_id", "timestamp", "event_type",
            "from_status", "to_status", "description"
        ])
        db.set_table("changes", changes_table)

        # Also add test_runs table (from base implementation)
        val runs_table = SdnTable.new("test_runs", [
            "run_id", "start_time", "end_time", "pid", "hostname",
            "status", "test_count", "passed", "failed", "crashed", "timed_out", "valid"
        ])
        db.set_table("test_runs", runs_table)

        TestDatabaseExtended(
            db: db,
            interner: StringInterner.empty(),
            next_file_id: 0,
            next_suite_id: 0,
            next_test_id: 0,
            next_timing_run_id: 0,
            next_change_id: 0
        )

    # Save database
    me save() -> bool:
        # First, save string interner to strings table
        var strings_table = self.db.get_table_mut("strings")?
        strings_table.clear()
        for (id, value) in self.interner.all_strings():
            val row = SdnRow.empty()
            row.set("id", "{id}")
            row.set("value", value)
            strings_table.add_row(row)
        self.db.set_table("strings", strings_table)

        # Save database
        self.db.save()

export TestDatabaseExtended
