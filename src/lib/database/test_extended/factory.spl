# Test Database Extended - Factory Functions
#
# Functions for creating and loading TestDatabaseExtended instances

use lib.database.core.{SdnDatabase, SdnTable, SdnRow, StringInterner}
use app.io.{file_exists}
use lib.database.test_extended.database.{TestDatabaseExtended}

fn create_test_database_extended(path: text) -> TestDatabaseExtended:
    TestDatabaseExtended.create(path)

fn load_test_database_extended(path: text) -> TestDatabaseExtended?:
    val db_opt = SdnDatabase.load(path)
    if not db_opt.?:
        return nil

    var db = db_opt?
    var interner = StringInterner.empty()

    # Load strings table to rebuild interner
    val strings_table_opt = db.get_table("strings")
    if strings_table_opt.?:
        val strings_table = strings_table_opt?
        for row in strings_table.valid_rows():
            # BUG-044: Use ?? instead of ? to avoid "try: early return"
            val id_str = row.get("id") ?? ""
            val value = row.get("value") ?? ""
            if id_str != "" and value != "":
                val id = id_str.parse_i32() ?? 0
                if id > 0:
                    interner.str_to_id[value] = id
                    interner.id_to_str[id] = value
                    if id >= interner.next_id:
                        interner.next_id = id + 1

    Some(TestDatabaseExtended(
        db: db,
        interner: interner,
        next_file_id: 0,
        next_suite_id: 0,
        next_test_id: 0,
        next_timing_run_id: 0,
        next_change_id: 0
    ))

fn migrate_from_dual_file(
    stable_path: text,
    volatile_path: text,
    target_path: text
) -> bool:
    # Load stable database (files, suites, tests)
    val stable_db_opt = SdnDatabase.load(stable_path)
    if not stable_db_opt.?:
        return false

    # Load volatile database (counters, timing, runs)
    val volatile_db_opt = SdnDatabase.load(volatile_path)
    if not volatile_db_opt.?:
        return false

    # Create new unified database
    var target_db = create_test_database_extended(target_path)

    # Migrate stable data (strings, files, suites, tests)
    val stable_db = stable_db_opt?

    # Copy strings table
    val strings_opt = stable_db.get_table("strings")
    if strings_opt.?:
        target_db.db.set_table("strings", strings_opt?)

    # Copy files table
    val files_opt = stable_db.get_table("files")
    if files_opt.?:
        target_db.db.set_table("files", files_opt?)

    # Copy suites table
    val suites_opt = stable_db.get_table("suites")
    if suites_opt.?:
        target_db.db.set_table("suites", suites_opt?)

    # Copy tests table
    val tests_opt = stable_db.get_table("tests")
    if tests_opt.?:
        target_db.db.set_table("tests", tests_opt?)

    # Migrate volatile data (counters, timing, timing_runs, changes, test_runs)
    val volatile_db = volatile_db_opt?

    # Copy counters table
    val counters_opt = volatile_db.get_table("counters")
    if counters_opt.?:
        target_db.db.set_table("counters", counters_opt?)

    # Copy timing table
    val timing_opt = volatile_db.get_table("timing")
    if timing_opt.?:
        target_db.db.set_table("timing", timing_opt?)

    # Copy timing_runs table
    val timing_runs_opt = volatile_db.get_table("timing_runs")
    if timing_runs_opt.?:
        target_db.db.set_table("timing_runs", timing_runs_opt?)

    # Copy changes table
    val changes_opt = volatile_db.get_table("changes")
    if changes_opt.?:
        target_db.db.set_table("changes", changes_opt?)

    # Copy test_runs table
    val test_runs_opt = volatile_db.get_table("test_runs")
    if test_runs_opt.?:
        target_db.db.set_table("test_runs", test_runs_opt?)

    # Rebuild StringInterner from strings table
    val strings_table_opt = target_db.db.get_table("strings")
    if strings_table_opt.?:
        val strings_table = strings_table_opt?
        for row in strings_table.valid_rows():
            # BUG-044: Use ?? instead of ? to avoid "try: early return"
            val id_str = row.get("id") ?? ""
            val value = row.get("value") ?? ""
            if id_str != "" and value != "":
                val id = id_str.parse_i32() ?? 0
                if id > 0:
                    target_db.interner.str_to_id[value] = id
                    target_db.interner.id_to_str[id] = value
                    if id >= target_db.interner.next_id:
                        target_db.interner.next_id = id + 1

    # Save unified database
    target_db.save()

fn load_with_migration(base_path: text) -> TestDatabaseExtended?:
    # Try loading unified file first
    val unified_path = "{base_path}.sdn"
    if file_exists(unified_path):
        return load_test_database_extended(unified_path)

    # Check if old dual-file format exists
    val stable_path = "{base_path}_stable.sdn"
    val volatile_path = "{base_path}_runs.sdn"

    if file_exists(stable_path) and file_exists(volatile_path):
        # Migrate from dual-file to single-file
        val success = migrate_from_dual_file(stable_path, volatile_path, unified_path)
        if not success:
            return None

        # Load the migrated database
        return load_test_database_extended(unified_path)

    # No database found
    nil

export create_test_database_extended, load_test_database_extended
export migrate_from_dual_file, load_with_migration
