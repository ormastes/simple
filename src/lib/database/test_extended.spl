# Test Database Extended - Full Implementation
#
# Extended TestDatabase with complete feature set:
# - 8 tables (strings, files, suites, tests, counters, timing, timing_runs, changes)
# - StringInterner integration
# - Statistical analysis
# - Flaky test detection
# - Run management
#
# This extends the basic test.spl implementation.

use lib.database.mod.{SdnDatabase, SdnTable, SdnRow}
use lib.database.stats.{Stats, is_flaky, update_baseline, is_significant_change}
use app.io.{rt_timestamp_now, rt_getpid, hostname}

# ============================================================================
# StringInterner (for string deduplication)
# ============================================================================

class StringInterner:
    next_id: i64
    str_to_id: Dict<text, i64>
    id_to_str: Dict<i64, text>

    static fn empty() -> StringInterner:
        StringInterner(
            next_id: 0,
            str_to_id: {},
            id_to_str: {}
        )

    # Get or create string ID
    me intern(s: text) -> i64:
        if self.str_to_id.contains_key(s):
            return self.str_to_id[s]

        val id = self.next_id
        self.str_to_id[s] = id
        self.id_to_str[id] = s
        self.next_id = self.next_id + 1
        id

    # Get string by ID
    fn get(id: i64) -> text?:
        self.id_to_str.get(id)

    # Get all strings for serialization
    fn all_strings() -> [(i64, text)]:
        var result: [(i64, text)] = []
        for id in self.id_to_str.keys():
            val str_opt = self.id_to_str.get(id)
            if str_opt.?:
                result.push((id, str_opt?))
        result

# ============================================================================
# Extended Structs
# ============================================================================

struct FileRecord:
    file_id: i64
    path_str: i64  # String ID

struct SuiteRecord:
    suite_id: i64
    file_id: i64
    name_str: i64  # String ID

struct TestRecord:
    test_id: i64
    suite_id: i64
    name_str: i64      # String ID
    category_str: i64   # String ID
    status_str: i64     # String ID
    tags_str: i64       # String ID
    description_str: i64  # String ID
    valid: bool

struct CounterRecord:
    test_id: i64
    total_runs: i64
    passed: i64
    failed: i64
    crashed: i64
    timed_out: i64
    flaky_count: i64
    consecutive_passes: i64

struct TimingSummary:
    test_id: i64
    mean: f64
    p50: f64
    p90: f64
    p95: f64
    p99: f64
    iqr: f64
    has_baseline: bool
    baseline_p50: f64
    baseline_updated_at: text
    last_10_runs: text  # JSON array of recent timings

struct TimingRun:
    timing_run_id: i64
    test_id: i64
    duration_ms: f64
    run_id: text
    timestamp: text

struct ChangeEvent:
    change_id: i64
    test_id: i64
    timestamp: text
    event_type: text  # "status_change", "became_flaky", "baseline_update"
    from_status: text
    to_status: text
    description: text

# ============================================================================
# Extended TestDatabase
# ============================================================================

class TestDatabaseExtended:
    db: SdnDatabase
    interner: StringInterner
    next_file_id: i64
    next_suite_id: i64
    next_test_id: i64
    next_timing_run_id: i64
    next_change_id: i64

    # Create extended database with all tables
    static fn create(path: text) -> TestDatabaseExtended:
        var db = SdnDatabase.new(path)

        # Table 1: strings
        val strings_table = SdnTable.new("strings", ["id", "value"])
        db.set_table("strings", strings_table)

        # Table 2: files
        val files_table = SdnTable.new("files", ["file_id", "path_str"])
        db.set_table("files", files_table)

        # Table 3: suites
        val suites_table = SdnTable.new("suites", ["suite_id", "file_id", "name_str"])
        db.set_table("suites", suites_table)

        # Table 4: tests
        val tests_table = SdnTable.new("tests", [
            "test_id", "suite_id", "name_str", "category_str",
            "status_str", "tags_str", "description_str", "valid"
        ])
        db.set_table("tests", tests_table)

        # Table 5: counters
        val counters_table = SdnTable.new("counters", [
            "test_id", "total_runs", "passed", "failed", "crashed",
            "timed_out", "flaky_count", "consecutive_passes"
        ])
        db.set_table("counters", counters_table)

        # Table 6: timing
        val timing_table = SdnTable.new("timing", [
            "test_id", "mean", "p50", "p90", "p95", "p99", "iqr",
            "has_baseline", "baseline_p50", "baseline_updated_at", "last_10_runs"
        ])
        db.set_table("timing", timing_table)

        # Table 7: timing_runs
        val timing_runs_table = SdnTable.new("timing_runs", [
            "timing_run_id", "test_id", "duration_ms", "run_id", "timestamp"
        ])
        db.set_table("timing_runs", timing_runs_table)

        # Table 8: changes
        val changes_table = SdnTable.new("changes", [
            "change_id", "test_id", "timestamp", "event_type",
            "from_status", "to_status", "description"
        ])
        db.set_table("changes", changes_table)

        # Also add test_runs table (from base implementation)
        val runs_table = SdnTable.new("test_runs", [
            "run_id", "start_time", "end_time", "pid", "hostname",
            "status", "test_count", "passed", "failed", "crashed", "timed_out", "valid"
        ])
        db.set_table("test_runs", runs_table)

        TestDatabaseExtended(
            db: db,
            interner: StringInterner.empty(),
            next_file_id: 0,
            next_suite_id: 0,
            next_test_id: 0,
            next_timing_run_id: 0,
            next_change_id: 0
        )

    # ========================================================================
    # Core Helper Methods
    # ========================================================================

    # Get or create file record
    me get_or_create_file(path: text) -> i64:
        val path_id = self.interner.intern(path)

        # Check if file exists
        val files_table = self.db.get_table("files")?
        for row in files_table.rows:
            val row_path_str = row.get_i64("path_str")?
            if row_path_str == path_id:
                return row.get_i64("file_id")?

        # Create new file
        val file_id = self.next_file_id
        self.next_file_id = self.next_file_id + 1

        var files_table_mut = self.db.get_table_mut("files")?
        val row = SdnRow.empty()
        row.set("file_id", "{file_id}")
        row.set("path_str", "{path_id}")
        files_table_mut.add_row(row)
        self.db.set_table("files", files_table_mut)

        file_id

    # Get or create suite record
    me get_or_create_suite(file_path: text, suite_name: text) -> i64:
        val file_id = self.get_or_create_file(file_path)
        val name_id = self.interner.intern(suite_name)

        # Check if suite exists
        val suites_table = self.db.get_table("suites")?
        for row in suites_table.rows:
            val row_file_id = row.get_i64("file_id")?
            val row_name_str = row.get_i64("name_str")?
            if row_file_id == file_id and row_name_str == name_id:
                return row.get_i64("suite_id")?

        # Create new suite
        val suite_id = self.next_suite_id
        self.next_suite_id = self.next_suite_id + 1

        var suites_table_mut = self.db.get_table_mut("suites")?
        val row = SdnRow.empty()
        row.set("suite_id", "{suite_id}")
        row.set("file_id", "{file_id}")
        row.set("name_str", "{name_id}")
        suites_table_mut.add_row(row)
        self.db.set_table("suites", suites_table_mut)

        suite_id

    # Get or create test record
    me get_or_create_test(suite_id: i64, test_name: text) -> i64:
        val name_id = self.interner.intern(test_name)

        # Check if test exists
        val tests_table = self.db.get_table("tests")?
        for row in tests_table.rows:
            val row_suite_id = row.get_i64("suite_id")?
            val row_name_str = row.get_i64("name_str")?
            if row_suite_id == suite_id and row_name_str == name_id:
                return row.get_i64("test_id")?

        # Create new test
        val test_id = self.next_test_id
        self.next_test_id = self.next_test_id + 1

        var tests_table_mut = self.db.get_table_mut("tests")?
        val row = SdnRow.empty()
        row.set("test_id", "{test_id}")
        row.set("suite_id", "{suite_id}")
        row.set("name_str", "{name_id}")
        row.set("category_str", "0")  # Default category
        row.set("status_str", "{self.interner.intern("unknown")}")
        row.set("tags_str", "0")
        row.set("description_str", "0")
        row.set("valid", "true")
        tests_table_mut.add_row(row)
        self.db.set_table("tests", tests_table_mut)

        test_id

    # Save database
    me save() -> bool:
        # First, save string interner to strings table
        var strings_table = self.db.get_table_mut("strings")?
        strings_table.clear()
        for (id, value) in self.interner.all_strings():
            val row = SdnRow.empty()
            row.set("id", "{id}")
            row.set("value", value)
            strings_table.add_row(row)
        self.db.set_table("strings", strings_table)

        # Save database
        self.db.save()

export StringInterner
export FileRecord, SuiteRecord, TestRecord, CounterRecord
export TimingSummary, TimingRun, ChangeEvent
export TestDatabaseExtended
