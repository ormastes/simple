# Bug Database - Domain-specific extension of mod.SdnDatabase
#
# ⚠️ IMPORTANT: This is the ONLY way to update bug_db.sdn
# ⚠️ Do NOT edit doc/bug/bug_db.sdn manually
# ⚠️ All bug database operations MUST go through this module
#
# Provides high-level bug management with validation and statistics.
#
# CORRECT USAGE:
#   use lib.database.bug (create_bug_database)
#   var bugdb = create_bug_database("doc/bug/bug_db.sdn")
#   bugdb.add_bug(Bug(...))
#   bugdb.save()  // Atomic operation
#
# For MCP integration, see: src/app/mcp/bugdb_resource.spl

use lib.database.mod
use lib.database.query
use app.io

# Exports
export load_bug_database, create_bug_database
export BugDatabase, Bug, BugSeverity, BugStatus, BugStats
export severity_to_string, status_to_string, parse_severity, parse_status
export bug_to_row

# ============================================================================
# Enums
# ============================================================================

enum BugSeverity:
    P0          # Critical - blocks release
    P1          # High - must fix soon
    P2          # Medium - should fix
    P3          # Low - nice to fix
    Important   # Not a bug, but important item

enum BugStatus:
    Open            # Just reported
    Investigating   # Looking into it
    Confirmed       # Reproduced and understood
    Fixed           # Code fixed
    Closed          # Verified fixed
    Wontfix         # Won't be fixed

# ============================================================================
# Bug Struct
# ============================================================================

struct Bug:
    id: text
    severity: BugSeverity
    status: BugStatus
    title: text
    description: [text]
    file: text
    line: i64
    reproducible_by: text
    fix_strategy: [text]
    investigation_log: [text]
    created_at: text
    updated_at: text
    valid: bool

# ============================================================================
# BugStats
# ============================================================================

struct BugStats:
    total: i64
    open: i64
    fixed: i64
    p0: i64
    p1: i64
    important: i64
    health: text  # "good" | "attention" | "critical"

# ============================================================================
# BugDatabase
# ============================================================================

# Helper functions for creating Bug Databases

fn load_bug_database(path: text) -> BugDatabase?:
    val db = mod.SdnDatabase.load(path)?
    Some(BugDatabase(db: db))

fn create_bug_database(path: text) -> BugDatabase:
        val db = mod.SdnDatabase.new(path)

        # Create bugs table
        val bugs_table = mod.SdnTable.new("bugs", [
            "id",
            "severity",
            "status",
            "title",
            "file",
            "line",
            "reproducible_by",
            "created_at",
            "updated_at",
            "valid"
        ])
        db.set_table("bugs", bugs_table)

        # Create description table (multiline)
        val desc_table = mod.SdnTable.new("bug_descriptions", [
            "bug_id",
            "line_num",
            "content"
        ])
        db.set_table("bug_descriptions", desc_table)

        # Create fix_strategy table (multiline)
        val fix_table = mod.SdnTable.new("bug_fix_strategies", [
            "bug_id",
            "line_num",
            "content"
        ])
        db.set_table("bug_fix_strategies", fix_table)

        # Create investigation_log table (multiline)
        val log_table = mod.SdnTable.new("bug_investigation_logs", [
            "bug_id",
            "line_num",
            "content"
        ])
        db.set_table("bug_investigation_logs", log_table)

        BugDatabase(db: db)

class BugDatabase:
    db: mod.SdnDatabase

    # Convert bug to SDN row
    fn bug_to_row(bug: Bug) -> mod.SdnRow:
        val row = mod.SdnRow.empty()
        row.set("id", bug.id)
        row.set("severity", severity_to_string(bug.severity))
        row.set("status", status_to_string(bug.status))
        row.set("title", bug.title)
        row.set("file", bug.file)
        row.set("line", "{bug.line}")
        row.set("reproducible_by", bug.reproducible_by)
        row.set("created_at", bug.created_at)
        row.set("updated_at", bug.updated_at)
        val valid_str = if bug.valid: "true" else: "false"
        row.set("valid", valid_str)
        row

    # Add new bug
    me add_bug(bug: Bug) -> bool:
        if not self.db.add_row_to_table("bugs", bug_to_row(bug)):
            return false

        # Add multiline fields
        self.add_multiline_field("bug_descriptions", bug.id, bug.description)
        self.add_multiline_field("bug_fix_strategies", bug.id, bug.fix_strategy)
        self.add_multiline_field("bug_investigation_logs", bug.id, bug.investigation_log)

        true

    # Helper to add multiline field
    me add_multiline_field(table_name: text, bug_id: text, lines: [text]):
        var table_opt = self.db.get_table_mut(table_name)
        if not table_opt.?:
            return

        var table = table_opt?
        for (i, line) in lines.enumerate():
            val row = mod.SdnRow.empty()
            row.set("bug_id", bug_id)
            row.set("line_num", "{i}")
            row.set("content", line)
            table.add_row(row)

        # Put table back into database
        self.db.set_table(table_name, table)

    # Get bug by ID
    fn get_bug(id: text) -> Bug?:
        val bugs_table = self.db.get_table("bugs")?
        val row = bugs_table.get_row(id)?

        # Parse main fields
        val severity = parse_severity(row.get("severity")?)
        val status = parse_status(row.get("status")?)

        # Get multiline fields
        val description = self.get_multiline_field("bug_descriptions", id)
        val fix_strategy = self.get_multiline_field("bug_fix_strategies", id)
        val investigation_log = self.get_multiline_field("bug_investigation_logs", id)

        Some(Bug(
            id: id,
            severity: severity,
            status: status,
            title: row.get("title")?,
            description: description,
            file: row.get("file")?,
            line: row.get_i64("line")?,
            reproducible_by: row.get("reproducible_by")?,
            fix_strategy: fix_strategy,
            investigation_log: investigation_log,
            created_at: row.get("created_at")?,
            updated_at: row.get("updated_at")?,
            valid: row.get_bool("valid")?
        ))

    # Helper to get multiline field
    fn get_multiline_field(table_name: text, bug_id: text) -> [text]:
        val table = self.db.get_table(table_name)?
        var lines = []

        for row in table.rows:
            if row.get("bug_id")? == bug_id:
                val content = row.get("content")?
                lines.push(content)

        lines

    # Get all bugs
    fn all_bugs() -> [Bug]:
        val bugs_table = self.db.get_table("bugs")?
        var result = []

        for row in bugs_table.valid_rows():
            val id = row.get("id")?
            val bug = self.get_bug(id)?
            result.push(bug)

        result

    # Get bugs by status
    fn bugs_by_status(status: BugStatus) -> [Bug]:
        val status_str = status_to_string(status)
        val bugs = self.all_bugs()
        bugs.filter(\b: status_to_string(b.status) == status_str)

    # Get bugs by severity
    fn bugs_by_severity(severity: BugSeverity) -> [Bug]:
        val severity_str = severity_to_string(severity)
        val bugs = self.all_bugs()
        bugs.filter(\b: severity_to_string(b.severity) == severity_str)

    # Get critical bugs (P0 + P1)
    fn critical_bugs() -> [Bug]:
        val bugs = self.all_bugs()
        bugs.filter(\b: b.severity == BugSeverity.P0 or b.severity == BugSeverity.P1)

    # Get open bugs (Open + Investigating + Confirmed)
    fn open_bugs() -> [Bug]:
        val bugs = self.all_bugs()
        bugs.filter(\b: b.status == BugStatus.Open or b.status == BugStatus.Investigating or b.status == BugStatus.Confirmed)

    # Update bug
    me update_bug(id: text, bug: Bug) -> bool:
        # Mark old bug as invalid
        val bugs_table = self.db.get_table("bugs")?
        bugs_table.mark_deleted(id)

        # Add updated bug
        self.add_bug(bug)

    # Save to disk
    me save() -> bool:
        self.db.save()

    # Statistics
    fn stats() -> BugStats:
        val bugs = self.all_bugs()
        val total = bugs.len()

        val open = bugs.filter(\b: b.status == BugStatus.Open or b.status == BugStatus.Investigating or b.status == BugStatus.Confirmed).len()
        val fixed = bugs.filter(\b: b.status == BugStatus.Fixed or b.status == BugStatus.Closed).len()
        val p0 = bugs.filter(\b: b.severity == BugSeverity.P0).len()
        val p1 = bugs.filter(\b: b.severity == BugSeverity.P1).len()
        val important = bugs.filter(\b: b.severity == BugSeverity.Important).len()

        val health = if p0 > 0:
            "critical"
        elif p1 > 3:
            "attention"
        else:
            "good"

        BugStats(
            total: total,
            open: open,
            fixed: fixed,
            p0: p0,
            p1: p1,
            important: important,
            health: health
        )

    # Validation
    fn validate_test_links() -> [text]:
        var errors = []
        val bugs = self.all_bugs()

        for bug in bugs:
            if not bug.reproducible_by.?:
                errors.push("Bug {bug.id}: missing test case link")

        errors

    fn validate_fix_strategy() -> [text]:
        var errors = []
        val bugs = self.all_bugs()

        for bug in bugs:
            val is_critical = bug.severity == BugSeverity.P0 or bug.severity == BugSeverity.P1
            if is_critical and not bug.fix_strategy.?:
                errors.push("Bug {bug.id}: critical bug missing fix strategy")

        errors

# ============================================================================
# Helper Functions
# ============================================================================

fn severity_to_string(severity: BugSeverity) -> text:
    match severity:
        BugSeverity.P0: "P0"
        BugSeverity.P1: "P1"
        BugSeverity.P2: "P2"
        BugSeverity.P3: "P3"
        BugSeverity.Important: "Important"

fn parse_severity(s: text) -> BugSeverity:
    match s:
        "P0": BugSeverity.P0
        "P1": BugSeverity.P1
        "P2": BugSeverity.P2
        "P3": BugSeverity.P3
        "Important": BugSeverity.Important
        _: BugSeverity.P3

fn status_to_string(status: BugStatus) -> text:
    match status:
        BugStatus.Open: "Open"
        BugStatus.Investigating: "Investigating"
        BugStatus.Confirmed: "Confirmed"
        BugStatus.Fixed: "Fixed"
        BugStatus.Closed: "Closed"
        BugStatus.Wontfix: "Wontfix"

fn parse_status(s: text) -> BugStatus:
    match s:
        "Open": BugStatus.Open
        "Investigating": BugStatus.Investigating
        "Confirmed": BugStatus.Confirmed
        "Fixed": BugStatus.Fixed
        "Closed": BugStatus.Closed
        "Wontfix": BugStatus.Wontfix
        _: BugStatus.Open

# ============================================================================
# Standalone bug_to_row function (for external use)
# ============================================================================

fn bug_to_row(bug: Bug) -> mod.SdnRow:
    """Convert Bug to mod.SdnRow for database storage.

    This is the standalone function version that can be called from outside
    the BugDatabase class. Tests and external code should use this.
    """
    val row = mod.SdnRow.empty()
    row.set("id", bug.id)
    row.set("severity", severity_to_string(bug.severity))
    row.set("status", status_to_string(bug.status))
    row.set("title", bug.title)
    row.set("file", bug.file)
    row.set("line", "{bug.line}")
    row.set("reproducible_by", bug.reproducible_by)
    row.set("created_at", bug.created_at)
    row.set("updated_at", bug.updated_at)
    val valid_str = if bug.valid: "true" else: "false"
    row.set("valid", valid_str)
    row
