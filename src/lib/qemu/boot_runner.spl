# QEMU Boot Test Runner
#
# High-level API for testing bare-metal boot code across architectures.
# Extends lib/qemu with boot-specific patterns:
# - Serial output capture and parsing
# - Boot success detection
# - Timeout and crash handling
# - Architecture-specific test helpers

use lib.qemu.{QemuArch, QemuConfig, QemuInstance, ExitCodeResult, interpret_exit_code}
use app.io.{shell, ProcessResult}

export BootTestConfig, BootTestResult, BootTestRunner
export run_boot_test, is_qemu_available, is_gdb_available

# ===========================================================================
# Boot Test Configuration
# ===========================================================================

class BootTestConfig:
    """Configuration for bare-metal boot tests."""
    arch: QemuArch
    kernel_path: text         # ELF binary to boot
    expected_output: text     # Expected serial output (substring match)
    timeout_ms: i64           # Timeout in milliseconds
    machine: text?            # Optional: override default machine
    extra_args: [text]        # Optional: extra QEMU args

fn BootTestConfig__new(arch: QemuArch, kernel: text) -> BootTestConfig:
    BootTestConfig(
        arch: arch,
        kernel_path: kernel,
        expected_output: "",
        timeout_ms: 10000,  # 10 seconds default
        machine: nil,
        extra_args: []
    )


impl BootTestConfig:
    me expect_output(pattern: text):
        self.expected_output = pattern
    me set_timeout(ms: i64):
        self.timeout_ms = ms
    me set_machine(machine_type: text):
        self.machine = Some(machine_type)
    me add_args(args: [text]):
        self.extra_args = self.extra_args.merge(args)
# ===========================================================================
# Boot Test Result
# ===========================================================================

class BootTestResult:
    """Result of a boot test run."""
    success: bool
    output: text              # Captured serial output
    exit_code: i32            # QEMU exit code
    message: text             # Result message
    duration_ms: i64          # Test duration

fn BootTestResult__success(output: text, duration: i64) -> BootTestResult:
    BootTestResult(
        success: true,
        output: output,
        exit_code: 0,
        message: "Boot test passed",
        duration_ms: duration
    )

fn BootTestResult__failure(msg: text, output: text, exit_code: i32) -> BootTestResult:
    BootTestResult(
        success: false,
        output: output,
        exit_code: exit_code,
        message: msg,
        duration_ms: 0
    )

fn BootTestResult__timeout(output: text, timeout_ms: i64) -> BootTestResult:
    BootTestResult(
        success: false,
        output: output,
        exit_code: 124,
        message: "Boot test timed out after {timeout_ms}ms",
        duration_ms: timeout_ms
    )

fn BootTestResult__crash(output: text, exit_code: i32) -> BootTestResult:
    BootTestResult(
        success: false,
        output: output,
        exit_code: exit_code,
        message: "Kernel crashed (exit code {exit_code})",
        duration_ms: 0
    )

# ===========================================================================
# Boot Test Runner
# ===========================================================================

class BootTestRunner:
    """Runs boot tests with serial output capture."""
    config: BootTestConfig
    output_file: text         # Temporary file for serial output

fn BootTestRunner__new(config: BootTestConfig) -> BootTestRunner:
    # Create temporary file for serial output
    val timestamp = get_timestamp_ms()
    val output_file = "/tmp/qemu_boot_test_{timestamp}.log"

    BootTestRunner(
        config: config,
        output_file: output_file
    )


impl BootTestRunner:
    fn run() -> BootTestResult:
        val start_time = get_timestamp_ms()

        # Build QEMU config
        var qemu_config = QemuConfig__for_test_runner(
            self.config.arch,
            self.config.kernel_path
        )

        # Override machine if specified
        if self.config.machine.?:
            qemu_config.machine = self.config.machine.unwrap()

        # Set timeout
        qemu_config.timeout_ms = self.config.timeout_ms

        # Redirect serial to file for capture
        qemu_config.serial_stdio = false
        qemu_config.serial_file = self.output_file
        qemu_config.extra_args = self.config.extra_args

        # Start QEMU
        val start_result = QemuInstance__start(qemu_config)
        if start_result.err.?:
            return BootTestResult__failure(
                "Failed to start QEMU: {start_result.err.unwrap()}",
                "",
                -1
            )

        var instance = start_result.ok.unwrap()

        # Wait for QEMU to exit with timeout
        val wait_result = instance.wait_exit(self.config.timeout_ms)

        # Read captured output
        val output = self.read_output_file()

        # Calculate duration
        val end_time = get_timestamp_ms()
        val duration = end_time - start_time

        # Cleanup
        instance.stop()
        self.cleanup_output_file()

        # Check result
        if wait_result.err.?:
            # Timeout
            return BootTestResult__timeout(output, self.config.timeout_ms)

        val exit_code = wait_result.ok.unwrap()

        # Interpret exit code
        val exit_result = interpret_exit_code(exit_code, qemu_config.debug_exit)

        if not exit_result.success:
            return BootTestResult__crash(output, exit_code)

        # Check expected output
        if self.config.expected_output.len() > 0:
            if not output.contains(self.config.expected_output):
                return BootTestResult__failure(
                    "Expected output not found: '{self.config.expected_output}'",
                    output,
                    exit_code
                )

        # Success
        BootTestResult__success(output, duration)
    fn read_output_file() -> text:
        val read_result = shell("cat {self.output_file} 2>/dev/null")
        if read_result.exit_code == 0:
            read_result.stdout
        else:
            ""
    fn cleanup_output_file():
        shell("rm -f {self.output_file} 2>/dev/null")
# ===========================================================================
# Convenience API
# ===========================================================================

# Run a simple boot test with expected output
fn run_boot_test(arch: QemuArch, kernel: text, expected: text) -> BootTestResult:
    var config = BootTestConfig__new(arch, kernel)
    config.expect_output(expected)

    val runner = BootTestRunner__new(config)
    runner.run()

# ===========================================================================
# Architecture-Specific Helpers
# ===========================================================================

# x86 boot test with VGA output expectation
fn run_x86_boot_test(kernel: text, expected_vga: text) -> BootTestResult:
    var config = BootTestConfig__new(QemuArch.X86, kernel)
    config.expect_output(expected_vga)
    config.set_timeout(5000)  # 5 seconds

    # Enable ISA debug-exit device for clean shutdown
    config.add_args(["-device", "isa-debug-exit,iobase=0xf4,iosize=0x04"])

    val runner = BootTestRunner__new(config)
    runner.run()

# ARM Cortex-M boot test
fn run_arm_cortex_m_boot_test(kernel: text, expected_serial: text) -> BootTestResult:
    var config = BootTestConfig__new(QemuArch.ARM32, kernel)
    config.set_machine("lm3s6965evb")  # Cortex-M3
    config.expect_output(expected_serial)
    config.set_timeout(5000)

    val runner = BootTestRunner__new(config)
    runner.run()

# ARM Cortex-A boot test (different machine)
fn run_arm_cortex_a_boot_test(kernel: text, expected_serial: text) -> BootTestResult:
    var config = BootTestConfig__new(QemuArch.ARM32, kernel)
    config.set_machine("virt")  # ARM virt machine (Cortex-A)
    config.expect_output(expected_serial)
    config.set_timeout(5000)

    val runner = BootTestRunner__new(config)
    runner.run()

# RISC-V 32 boot test
fn run_riscv32_boot_test(kernel: text, expected_uart: text) -> BootTestResult:
    var config = BootTestConfig__new(QemuArch.RiscV32, kernel)
    config.expect_output(expected_uart)
    config.set_timeout(5000)

    val runner = BootTestRunner__new(config)
    runner.run()

# RISC-V 64 boot test
fn run_riscv64_boot_test(kernel: text, expected_uart: text) -> BootTestResult:
    var config = BootTestConfig__new(QemuArch.RiscV64, kernel)
    config.expect_output(expected_uart)
    config.set_timeout(5000)

    val runner = BootTestRunner__new(config)
    runner.run()

# ===========================================================================
# Utility Functions
# ===========================================================================

# Get current timestamp in milliseconds
fn get_timestamp_ms() -> i64:
    # Use shell to get nanosecond timestamp and convert to ms
    val result = shell("date +%s%3N")
    if result.exit_code == 0:
        parse_i64(result.stdout.trim())
    else:
        0

fn parse_i64(s: text) -> i64:
    var result: i64 = 0
    var negative = false

    var chars = s.trim()
    if chars.starts_with("-"):
        negative = true
        chars = chars[1:]

    for c in chars:
        if c >= '0' and c <= '9':
            result = result * 10 + (c as i64 - 48)
        else:
            break

    if negative: -result else: result

# ===========================================================================
# QEMU Availability Check
# ===========================================================================

fn is_qemu_available() -> bool:
    """Check if QEMU is installed and available on the system."""
    # Try to run qemu-system-x86_64 --version
    val result = shell("which qemu-system-x86_64 > /dev/null 2>&1")
    result.exit_code == 0

fn is_gdb_available() -> bool:
    """Check if GDB is installed and available on the system."""
    val result = shell("which gdb > /dev/null 2>&1")
    result.exit_code == 0
