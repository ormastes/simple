# Per-Actor Heap Isolation
#
# Provides ActorHeap with generational GC support.

use types.{ByteSize, Count, Offset}

class HeapConfig:
    initial_size: ByteSize
    max_size: ByteSize
    gc_enabled: bool
    generational: bool
    pretenure_threshold: i64

fn HeapConfig__default() -> HeapConfig:
    HeapConfig(
        initial_size: ByteSize(value: 2048),
        max_size: ByteSize(value: 16777216),
        gc_enabled: true,
        generational: true,
        pretenure_threshold: 5
    )

fn HeapConfig__small() -> HeapConfig:
    HeapConfig(
        initial_size: ByteSize(value: 512),
        max_size: ByteSize(value: 4096),
        gc_enabled: true,
        generational: true,
        pretenure_threshold: 3
    )

fn HeapConfig__large() -> HeapConfig:
    HeapConfig(
        initial_size: ByteSize(value: 65536),
        max_size: ByteSize(value: 67108864),
        gc_enabled: true,
        generational: true,
        pretenure_threshold: 10
    )

fn HeapConfig__no_gc(size: i64) -> HeapConfig:
    HeapConfig(
        initial_size: ByteSize(value: size),
        max_size: ByteSize(value: size),
        gc_enabled: false,
        generational: false,
        pretenure_threshold: 0
    )

# --- HeapRegion ---

class HeapRegion:
    used: ByteSize
    capacity: ByteSize

fn HeapRegion__new(capacity: ByteSize) -> HeapRegion:
    HeapRegion(used: ByteSize(value: 0), capacity: capacity)

# --- HeapStats ---

class HeapStats:
    used_bytes: ByteSize
    allocated_bytes: ByteSize
    object_count: Count
    gc_count: Count
    peak_used_bytes: ByteSize
    young_gen_size: ByteSize
    old_gen_size: ByteSize

    fn fmt() -> text:
        "HeapStats(used={self.used_bytes.value}, objects={self.object_count.value}, gc={self.gc_count.value})"

fn HeapStats__new() -> HeapStats:
    HeapStats(
        used_bytes: ByteSize(value: 0),
        allocated_bytes: ByteSize(value: 0),
        object_count: Count(value: 0),
        gc_count: Count(value: 0),
        peak_used_bytes: ByteSize(value: 0),
        young_gen_size: ByteSize(value: 0),
        old_gen_size: ByteSize(value: 0)
    )

# --- AllocStatus enum ---

enum AllocStatus:
    Success
    Failure

# --- AllocationResult ---

class AllocationResult:
    tag: AllocStatus
    offset: Offset

    fn is_success() -> bool:
        self.tag == AllocStatus.Success

fn AllocationResult__success(offset: i64) -> AllocationResult:
    AllocationResult(tag: AllocStatus.Success, offset: Offset(value: offset))

fn AllocationResult__failure() -> AllocationResult:
    AllocationResult(tag: AllocStatus.Failure, offset: Offset(value: -1))

# --- ActorHeap ---

class ActorHeap:
    config: HeapConfig
    young_generation: HeapRegion
    old_generation_used: ByteSize
    old_generation_cap: ByteSize
    has_old_generation: bool
    used_bytes: ByteSize
    allocated_bytes: ByteSize
    object_count: Count
    gc_count: Count
    peak_used_bytes: ByteSize

    me allocate(size: i64) -> AllocationResult:
        val new_used = self.used_bytes.value + size
        if self.config.max_size.value > 0:
            if new_used > self.config.max_size.value:
                return AllocationResult__failure()
        val offset = self.used_bytes.value
        self.used_bytes = ByteSize(value: new_used)
        self.allocated_bytes = ByteSize(value: self.allocated_bytes.value + size)
        self.object_count = Count(value: self.object_count.value + 1)
        self.young_generation.used = ByteSize(value: self.young_generation.used.value + size)
        if self.used_bytes.value > self.peak_used_bytes.value:
            self.peak_used_bytes = self.used_bytes
        AllocationResult__success(offset)

    me collect_garbage():
        if not self.config.gc_enabled:
            return ()
        self.gc_count = Count(value: self.gc_count.value + 1)

    me collect_young_generation():
        if not self.config.gc_enabled:
            return ()
        self.gc_count = Count(value: self.gc_count.value + 1)

    fn usage_percent() -> i64:
        if self.config.initial_size.value == 0:
            return 0
        self.used_bytes.value * 100 / self.config.initial_size.value

    fn is_healthy() -> bool:
        self.usage_percent() < 95

    fn get_stats() -> HeapStats:
        HeapStats(
            used_bytes: self.used_bytes,
            allocated_bytes: self.allocated_bytes,
            object_count: self.object_count,
            gc_count: self.gc_count,
            peak_used_bytes: self.peak_used_bytes,
            young_gen_size: self.young_generation.used,
            old_gen_size: self.old_generation_used
        )

    fn fmt() -> text:
        "ActorHeap(used={self.used_bytes.value}, objects={self.object_count.value})"

fn ActorHeap__new(config: HeapConfig) -> ActorHeap:
    val has_old = config.generational
    ActorHeap(
        config: config,
        young_generation: HeapRegion__new(config.initial_size),
        old_generation_used: ByteSize(value: 0),
        old_generation_cap: config.initial_size,
        has_old_generation: has_old,
        used_bytes: ByteSize(value: 0),
        allocated_bytes: ByteSize(value: 0),
        object_count: Count(value: 0),
        gc_count: Count(value: 0),
        peak_used_bytes: ByteSize(value: 0)
    )

export AllocStatus
export HeapConfig, HeapConfig__default, HeapConfig__small, HeapConfig__large, HeapConfig__no_gc
export HeapRegion, HeapRegion__new
export HeapStats, HeapStats__new
export AllocationResult, AllocationResult__success, AllocationResult__failure
export ActorHeap, ActorHeap__new
