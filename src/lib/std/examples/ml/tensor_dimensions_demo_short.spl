# Tensor Dimension Inference - Standalone Demo
# This demonstrates the core concepts without module imports

print("============================================================")
print("  TENSOR DIMENSION INFERENCE - STANDALONE DEMO")
print("============================================================")
print("")

# ============================================================================
# Dimension Types
# ============================================================================

enum Dim:
    Literal(value: i32)
    Named(name: text, lo: i32, hi: i32)
    Unknown

print("Example 1: Dimension Types")
print("------------------------------------------------------------")

val d1 = Dim.Literal(value: 64)
print("Exact dimension: {d1}")

val d2 = Dim.Named(name: "batch", lo: 1, hi: 64)
print("Named dimension with range: {d2}")

val d3 = Dim.Unknown
print("Dynamic dimension: {d3}")

print("")

# ============================================================================
# Dimension Unification
# ============================================================================

print("Example 2: Dimension Unification")
print("------------------------------------------------------------")

fn can_unify_dims(d1: Dim, d2: Dim) -> bool:
    match (d1, d2):
        case (Dim::Literal(v1), Dim.Literal(v2)):
            return v1 == v2
        case (Dim::Named(n1, _, _), Dim.Named(n2, _, _)):
            return n1 == n2
        case (Dim::Unknown, _):
            return true
        case (_, Dim.Unknown):
            return true
        case _:
            return false

val lit1 = Dim.Literal(value: 10)
val lit2 = Dim.Literal(value: 10)
val lit3 = Dim.Literal(value: 20)

print("Can unify Literal(10) with Literal(10)? {can_unify_dims(d1=lit1, d2=lit2)}")
print("Can unify Literal(10) with Literal(20)? {can_unify_dims(d1=lit1, d2=lit3)}")

val named1 = Dim.Named(name: "batch", lo: 1, hi: 64)
val unknown_dim = Dim.Unknown

print("Can unify Named('batch') with Unknown? {can_unify_dims(d1=named1, d2=unknown_dim)}")

print("")

# ============================================================================
# Shape Representation
# ============================================================================

struct TensorShape:
    dims: List<Dim>

fn dim_to_string(d: Dim) -> text:
    match d:
        case Dim::Literal(v):
            return "{v}"
        case Dim::Named(n, lo, hi):
            return "{n}:{lo}..{hi}"
        case Dim::Unknown:
            return "*"

fn shape_to_string(shape: TensorShape) -> text:
    if shape.dims.len() == 0:
        return "[]"
    if shape.dims.len() == 1:
        return "[" + dim_to_string(shape.dims[0]) + "]"
    if shape.dims.len() == 2:
        return "[" + dim_to_string(shape.dims[0]) + ", " + dim_to_string(shape.dims[1]) + "]"
    if shape.dims.len() == 3:
        return "[" + dim_to_string(shape.dims[0]) + ", " + dim_to_string(shape.dims[1]) + ", " + dim_to_string(shape.dims[2]) + "]"
    return "[...]"  # For higher dimensions

print("Example 3: Tensor Shapes")
print("------------------------------------------------------------")

val input_shape = TensorShape(dims: [
    Dim.Named(name: "batch", lo: 1, hi: 64),
    Dim.Literal(value: 784)
])

print("Input shape (MNIST): {shape_to_string(input_shape)}")

val weight_shape = TensorShape(dims: [
    Dim.Literal(value: 784),
    Dim.Literal(value: 10)
])

print("Weight shape: {shape_to_string(weight_shape)}")

print("")

# ============================================================================
# Matrix Multiplication Shape Inference
# ============================================================================

print("Example 4: Matrix Multiplication Shape Inference")
print("------------------------------------------------------------")

enum ShapeResult:
    Ok(shape: TensorShape)
    Error(message: text)

fn infer_matmul_shape(left: TensorShape, right: TensorShape) -> ShapeResult:
    # Check rank
    if left.dims.len() != 2 or right.dims.len() != 2:
        return ShapeResult.Error(message: "Matmul requires 2D tensors")

    val m = left.dims[0]
    val k1 = left.dims[1]
    val k2 = right.dims[0]
    val n = right.dims[1]

    # Check K dimensions match
    if not can_unify_dims(d1=k1, d2=k2):
        return ShapeResult.Error(message: "K dimensions don't match")

    # Result is [M, N]
    return ShapeResult.Ok(shape: TensorShape(dims: [m, n]))

# Test: [batch:1..64, 784] @ [784, 10] -> [batch:1..64, 10]
val result = infer_matmul_shape(left=input_shape, right=weight_shape)

match result:
    case ShapeResult.Ok(shape):
        print("✓ Matmul inference successful!")
        print("  Input:  {shape_to_string(input_shape)}")
        print("  Weight: {shape_to_string(weight_shape)}")
        print("  Output: {shape_to_string(shape)}")
    case ShapeResult.Error(msg):
        print("✗ Matmul inference failed: {msg}")

print("")

print("")
print("============================================================")
print("  DEMO COMPLETE")
print("============================================================")
print("Successfully demonstrated:")
print("  ✓ Dimension types (Literal, Named, Unknown)")
print("  ✓ Dimension unification")
print("  ✓ Shape representation")
print("  ✓ Matrix multiplication shape inference")
