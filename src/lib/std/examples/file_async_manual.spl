# Manual Control Example - Async File Loading with Work Overlap
#
# Demonstrates async file loading using the unified io.fs API.
# Note: For advanced async handle control, use File::open_read with staging.

use io.fs as fs
use std.io

async fn main():
    # Start loading the file asynchronously (mmap)
    val mmap_future = fs.open_mmap("large_file.dat"_filepath)

    # Do other work while file loads in background
    io.println("File loading in background...")
    val config = load_config()
    io.println("Config loaded")

    # Wait for file to be ready
    io.println("Waiting for file to finish loading...")
    async with await mmap_future? as mmap:
        process_file(mmap.as_bytes())

    # Alternative: Use File with staging for more control
    val file = await File::open_read("large_file.dat"_filepath)?
    # File auto-stages on open, but you can control staging mode
    await file.stage_mmap()?  # Explicit mmap staging

    val buffer = Bytes::with_capacity(4096)
    val n = await file.read(&mut buffer)?
    process_file(&buffer.slice(0, n))

fn load_config() -> Config:
    # Simulate some work
    return Config { timeout: 30 }

fn process_file(data: &[u8]):
    io.println("Processing {data.len()} bytes")

struct Config:
    timeout: i32
