# Grammar Testing Framework
# Systematic testing for tree-sitter grammars

use parser.treesitter.{TreeSitterParser, Tree, Node, Span}

# Test case for grammar testing
class GrammarTestCase:
    name: text
    language: text
    source: text
    expected_kind: text            # Expected root node kind
    expected_structure: Option<TreeStructure>  # Optional tree structure assertion
    should_error: bool               # Expect parse errors?

    fn new(
        name: text,
        language: text,
        source: text,
        expected_kind: text
    ) -> GrammarTestCase:
        GrammarTestCase(
            name: name,
            language: language,
            source: source,
            expected_kind: expected_kind,
            expected_structure: None,
            should_error: false
        )

    me with_structure(structure: TreeStructure) -> GrammarTestCase:
        self.expected_structure = Some(structure)
        self

    me expect_error() -> GrammarTestCase:
        self.should_error = true
        self

# Tree structure for assertions
class TreeStructure:
    kind: text
    children: List<TreeStructure>
    fields: Dict<text, TreeStructure>

    fn new(kind: text) -> TreeStructure:
        TreeStructure(
            kind: kind,
            children: [],
            fields: {}
        )

    me with_child(child: TreeStructure) -> TreeStructure:
        self.children.push(child)
        self

    me with_field(name: text, child: TreeStructure) -> TreeStructure:
        self.fields[name] = child
        self

# Test result
class GrammarTestResult:
    test_name: text
    passed: bool
    error_message: Option<text>
    parse_time_ms: f32

    fn new(
        test_name: text,
        passed: bool,
        error_message: Option<text>,
        parse_time_ms: f32
    ) -> GrammarTestResult:
        GrammarTestResult(
            test_name: test_name,
            passed: passed,
            error_message: error_message,
            parse_time_ms: parse_time_ms
        )

    fn success(test_name: text, parse_time_ms: f32) -> GrammarTestResult:
        GrammarTestResult.new(test_name, true, None, parse_time_ms)

    fn failure(test_name: text, message: text, parse_time_ms: f32) -> GrammarTestResult:
        GrammarTestResult.new(test_name, false, Some(message), parse_time_ms)

    fn print_summary():
        if self.passed:
            print("✅ {self.test_name} ({self.parse_time_ms:.2f}ms)")
        else:
            print("❌ {self.test_name}")
            match self.error_message:
                case Some(msg):
                    print("   Error: {msg}")
                case None:
                    ()

# Test suite
class GrammarTestSuite:
    name: text
    tests: List<GrammarTestCase>

    fn new(name: text) -> GrammarTestSuite:
        GrammarTestSuite(
            name: name,
            tests: []
        )

    me add_test(test: GrammarTestCase):
        self.tests.push(test)

    fn run() -> GrammarTestSuiteResult:
        print("\n=== {self.name} ===\n")

        var results: List<GrammarTestResult> = []
        var passed_count = 0
        var failed_count = 0

        for test in self.tests:
            val result = run_test(test)
            result.print_summary()

            if result.passed:
                passed_count = passed_count + 1
            else:
                failed_count = failed_count + 1

            results.push(result)

        print("\n{passed_count} passed, {failed_count} failed\n")

        GrammarTestSuiteResult(
            suite_name: self.name,
            results: results,
            passed_count: passed_count,
            failed_count: failed_count
        )

# Test suite result
class GrammarTestSuiteResult:
    suite_name: text
    results: List<GrammarTestResult>
    passed_count: i32
    failed_count: i32

    fn all_passed() -> bool:
        self.failed_count == 0

    fn print_summary():
        val total = self.passed_count + self.failed_count
        val pass_rate = (self.passed_count * 100) / total

        print("\n=== {self.suite_name} Summary ===")
        print("Total: {total} tests")
        print("Passed: {self.passed_count} ({pass_rate}%)")
        print("Failed: {self.failed_count}")

        if self.all_passed():
            print("✅ All tests passed!")
        else:
            print("❌ Some tests failed")

# Run a single test
fn run_test(test: GrammarTestCase) -> GrammarTestResult:
    # Create parser
    val parser = match TreeSitterParser.new(test.language):
        case Ok(p): p
        case Err(e):
            return GrammarTestResult.failure(
                test.name,
                "Failed to create parser: {e}",
                0.0
            )

    # Parse source
    val start_time = sys.time.now_ms()
    val tree = match parser.parse(test.source):
        case Ok(t): t
        case Err(e):
            val parse_time = sys.time.now_ms() - start_time
            if test.should_error:
                # Expected to fail
                return GrammarTestResult.success(test.name, parse_time)
            else:
                return GrammarTestResult.failure(
                    test.name,
                    "Parse failed: {e}",
                    parse_time
                )
    val parse_time = sys.time.now_ms() - start_time

    # Check if error was expected
    if test.should_error and not tree.root_node.has_error:
        return GrammarTestResult.failure(
            test.name,
            "Expected parse error but parsing succeeded",
            parse_time
        )

    # Check root node kind
    if tree.root_node.kind != test.expected_kind:
        return GrammarTestResult.failure(
            test.name,
            "Expected root kind '{test.expected_kind}', got '{tree.root_node.kind}'",
            parse_time
        )

    # Check tree structure if provided
    match test.expected_structure:
        case Some(structure):
            match check_tree_structure(tree.root_node, structure, tree):
                case Ok(_):
                    return GrammarTestResult.success(test.name, parse_time)
                case Err(e):
                    return GrammarTestResult.failure(test.name, e, parse_time)
        case None:
            return GrammarTestResult.success(test.name, parse_time)

# Check tree structure matches expected
fn check_tree_structure(node: Node, expected: TreeStructure, tree: Tree) -> Result<Nil, text>:
    # Check node kind
    if node.kind != expected.kind:
        return Err("Expected node kind '{expected.kind}', got '{node.kind}'")

    # Check children count
    if node.children.len() != expected.children.len():
        return Err("Expected {expected.children.len()} children, got {node.children.len()}")

    # Check each child
    for i in 0..expected.children.len():
        val child_id = node.children[i]
        val child = tree.get_node(child_id)?
        val expected_child = expected.children[i]

        check_tree_structure(child, expected_child, tree)?

    # Check fields
    for field_name in expected.fields.keys():
        match node.fields.get(field_name):
            case None:
                return Err("Missing field '{field_name}'")
            case Some(field_id):
                val field_node = tree.get_node(field_id)?
                val expected_field = expected.fields[field_name]
                check_tree_structure(field_node, expected_field, tree)?

    Ok(nil)

# Grammar test builder (fluent API)
class GrammarTestBuilder:
    tests: List<GrammarTestCase>

    static fn new() -> GrammarTestBuilder:
        GrammarTestBuilder(tests: [])

    me test(name: text,
        language: text,
        source: text,
        expected_kind: text
    ) -> GrammarTestBuilder:
        self.tests.push(GrammarTestCase.new(name, language, source, expected_kind))
        self

    me test_with_structure(name: text,
        language: text,
        source: text,
        structure: TreeStructure
    ) -> GrammarTestBuilder:
        val test = GrammarTestCase.new(name, language, source, structure.kind)
            .with_structure(structure)
        self.tests.push(test)
        self

    me test_error(name: text,
        language: text,
        source: text
    ) -> GrammarTestBuilder:
        val test = GrammarTestCase.new(name, language, source, "source_file")
            .expect_error()
        self.tests.push(test)
        self

    fn build() -> GrammarTestSuite:
        val suite = GrammarTestSuite.new("Grammar Tests")
        for test in self.tests:
            suite.add_test(test)
        suite

# Snapshot testing support
class GrammarSnapshot:
    name: text
    source: text
    tree_repr: text  # Tree representation

    fn new(name: text, source: text, tree_repr: text) -> GrammarSnapshot:
        GrammarSnapshot(
            name: name,
            source: source,
            tree_repr: tree_repr
        )

    fn from_parse(name: text, source: text, language: text) -> Result<GrammarSnapshot, text>:
        val parser = TreeSitterParser.new(language)?
        val tree = parser.parse(source)?

        val tree_repr = tree_to_string(tree.root_node, tree, 0)

        Ok(GrammarSnapshot.new(name, source, tree_repr))

    fn verify(language: text) -> Result<bool, text>:
        # Re-parse and compare
        val parser = TreeSitterParser.new(language)?
        val tree = parser.parse(self.source)?

        val current_repr = tree_to_string(tree.root_node, tree, 0)

        Ok(current_repr == self.tree_repr)

# Convert tree to string representation
fn tree_to_string(node: Node, tree: Tree, indent: i32) -> text:
    val indent_str = "  ".repeat(indent)
    var result = "{indent_str}{node.kind}"

    # Add span info
    result = result + " [{node.span.start_line}:{node.span.start_column}-{node.span.end_line}:{node.span.end_column}]"

    # Add children
    if node.children.len() > 0:
        result = result + "\n"
        for child_id in node.children:
            match tree.get_node(child_id):
                case Ok(child):
                    result = result + tree_to_string(child, tree, indent + 1) + "\n"
                case Err(_):
                    ()

    result

# Corpus testing (multiple test files)
class GrammarCorpus:
    name: text
    language: text
    test_files: List<CorpusTestFile>

    fn new(name: text, language: text) -> GrammarCorpus:
        GrammarCorpus(
            name: name,
            language: language,
            test_files: []
        )

    me add_file(file: CorpusTestFile):
        self.test_files.push(file)

    fn run() -> GrammarCorpusResult:
        print("\n=== {self.name} Corpus ===\n")

        var results: List<CorpusFileResult> = []
        var total_passed = 0
        var total_failed = 0

        for test_file in self.test_files:
            val result = run_corpus_file(test_file, self.language)

            if result.all_passed:
                total_passed = total_passed + 1
            else:
                total_failed = total_failed + 1

            results.push(result)

        print("\n{total_passed} files passed, {total_failed} files failed\n")

        GrammarCorpusResult(
            corpus_name: self.name,
            results: results,
            passed_count: total_passed,
            failed_count: total_failed
        )

# Corpus test file
class CorpusTestFile:
    path: text
    source: text
    expected_no_errors: bool

    fn new(path: text, source: text) -> CorpusTestFile:
        CorpusTestFile(
            path: path,
            source: source,
            expected_no_errors: true
        )

    me allow_errors() -> CorpusTestFile:
        self.expected_no_errors = false
        self

# Corpus file result
class CorpusFileResult:
    file_path: text
    all_passed: bool
    error_count: i32
    parse_time_ms: f32

    fn print_summary():
        if self.all_passed:
            print("✅ {self.file_path} ({self.parse_time_ms:.2f}ms)")
        else:
            print("❌ {self.file_path} - {self.error_count} errors")

# Corpus result
class GrammarCorpusResult:
    corpus_name: text
    results: List<CorpusFileResult>
    passed_count: i32
    failed_count: i32

    fn print_summary():
        print("\n=== {self.corpus_name} Summary ===")
        print("Files: {self.passed_count + self.failed_count}")
        print("Passed: {self.passed_count}")
        print("Failed: {self.failed_count}")

# Run corpus file test
fn run_corpus_file(file: CorpusTestFile, language: text) -> CorpusFileResult:
    val parser = match TreeSitterParser.new(language):
        case Ok(p): p
        case Err(e):
            return CorpusFileResult(
                file_path: file.path,
                all_passed: false,
                error_count: 1,
                parse_time_ms: 0.0
            )

    val start_time = sys.time.now_ms()
    val tree = match parser.parse(file.source):
        case Ok(t): t
        case Err(e):
            val parse_time = sys.time.now_ms() - start_time
            return CorpusFileResult(
                file_path: file.path,
                all_passed: false,
                error_count: 1,
                parse_time_ms: parse_time
            )
    val parse_time = sys.time.now_ms() - start_time

    # Count errors
    val error_count = count_errors(tree.root_node, tree)

    val all_passed = if file.expected_no_errors:
        error_count == 0
    else:
        true

    CorpusFileResult(
        file_path: file.path,
        all_passed: all_passed,
        error_count: error_count,
        parse_time_ms: parse_time
    )

# Count ERROR nodes in tree
fn count_errors(node: Node, tree: Tree) -> i32:
    var count = 0

    if node.kind == "ERROR":
        count = count + 1

    for child_id in node.children:
        match tree.get_node(child_id):
            case Ok(child):
                count = count + count_errors(child, tree)
            case Err(_):
                ()

    count
