# Grammar Types
#
# Type rules: named, generic, function, tuple, array, dict, option, result.

use parser.treesitter.{Grammar}
use tokens.{
    TokenKind, token, ref, seq, choice, optional, field, repeat, repeat1,
    # Keywords
    Fn, Iso, Ref, Mut, Dyn,
    # Operators
    Lt, Gt, LParen, RParen, LBracket, RBracket, LBrace, RBrace,
    Comma, Colon, Arrow, Question, Exclamation, Plus, Pipe, Underscore
}

export add_type_rules

# Add all type rules to grammar
fn add_type_rules(grammar: Grammar):
    # Types
    grammar.add_rule("type", choice([
        ref("capability_type"),   # iso T, ref T, mut T
        ref("dyn_type"),          # dyn Trait
        ref("unit_type"),         # value_unit (e.g., 42_km)
        ref("union_type"),        # T | U | V
        ref("named_type"),
        ref("generic_type"),      # Type<T, U>
        ref("function_type"),
        ref("tuple_type"),
        ref("array_type"),
        ref("dict_type"),
        ref("option_type"),       # T?
        ref("result_type")        # T!
    ]))

    # Capability type: iso T, ref T, mut T
    grammar.add_rule("capability_type", seq([
        field("capability", choice([token(Iso), token(Ref), token(Mut)])),
        field("type", ref("type"))
    ]))

    # Dynamic trait object: dyn Trait
    grammar.add_rule("dyn_type", seq([
        token(Dyn),
        field("trait", ref("type_identifier"))
    ]))

    # Unit type: value_unit (e.g., 42_km, "127.0.0.1"_ip)
    grammar.add_rule("unit_type", seq([
        field("base", ref("type_identifier")),
        token(Underscore),
        field("unit", ref("identifier"))
    ]))

    # Union type: T | U | V
    grammar.add_rule("union_type", seq([
        field("first", ref("type")),
        repeat1(seq([token(Pipe), field("variant", ref("type"))]))
    ]))

    # Named type
    grammar.add_rule("named_type", ref("type_identifier"))

    # Generic type: Type<T, U> (angle brackets)
    grammar.add_rule("generic_type", seq([
        field("name", ref("type_identifier")),
        token(Lt),
        ref("type_list"),
        token(Gt)
    ]))

    # Type list
    grammar.add_rule("type_list", seq([
        ref("type"),
        repeat(seq([token(Comma), ref("type")])),
        optional(token(Comma))
    ]))

    # Function type
    grammar.add_rule("function_type", seq([
        token(Fn),
        token(LParen),
        optional(ref("type_list")),
        token(RParen),
        token(Arrow),
        ref("type")
    ]))

    # Tuple type
    grammar.add_rule("tuple_type", seq([
        token(LParen),
        ref("type"),
        token(Comma),
        optional(ref("type_list")),
        token(RParen)
    ]))

    # Array type
    grammar.add_rule("array_type", seq([
        token(LBracket),
        ref("type"),
        token(RBracket)
    ]))

    # Dict type
    grammar.add_rule("dict_type", seq([
        token(LBrace),
        field("key", ref("type")),
        token(Colon),
        field("value", ref("type")),
        token(RBrace)
    ]))

    # Option type (sugar for Option<T>)
    grammar.add_rule("option_type", seq([
        ref("type"),
        token(Question)
    ]))

    # Result type (sugar for Result<T, E>)
    grammar.add_rule("result_type", seq([
        ref("type"),
        token(Exclamation)
    ]))

    # Type parameters
    grammar.add_rule("type_parameters", seq([
        token(Lt),
        ref("type_parameter_list"),
        token(Gt)
    ]))

    # Type parameter list
    grammar.add_rule("type_parameter_list", seq([
        ref("type_parameter"),
        repeat(seq([token(Comma), ref("type_parameter")])),
        optional(token(Comma))
    ]))

    # Type parameter
    grammar.add_rule("type_parameter", seq([
        field("name", ref("type_identifier")),
        optional(seq([
            token(Colon),
            ref("trait_bounds")
        ]))
    ]))

    # Trait bounds
    grammar.add_rule("trait_bounds", seq([
        ref("type_identifier"),
        repeat(seq([token(Plus), ref("type_identifier")]))
    ]))

    # Field list (for struct/enum variants)
    grammar.add_rule("field_list", seq([
        ref("field_def"),
        repeat(seq([token(Comma), ref("field_def")])),
        optional(token(Comma))
    ]))

    # Identifiers
    grammar.add_rule("identifier", token(Identifier))
    grammar.add_rule("type_identifier", token(TypeIdentifier))
