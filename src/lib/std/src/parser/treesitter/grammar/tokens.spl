# Token Kinds and Grammar Helper Functions
#
# Token types and helper functions for grammar construction.

use simple_grammar.{GrammarRule as Rule}

export TokenKind
export token, ref, seq, choice, optional, repeat, repeat1, field, prec_left, prec_right

# ============================================================================
# Helper Functions for Grammar Construction
# ============================================================================

fn token(kind: TokenKind) -> Rule:
    Rule.Token(kind)

fn ref(name: text) -> Rule:
    Rule.Ref(name)

fn seq(rules: List<Rule>) -> Rule:
    Rule.Seq(rules)

fn choice(rules: List<Rule>) -> Rule:
    Rule.Choice(rules)

fn optional(rule: Rule) -> Rule:
    Rule.Optional(rule)

fn repeat(rule: Rule) -> Rule:
    Rule.Repeat(rule)

fn repeat1(rule: Rule) -> Rule:
    Rule.Repeat1(rule)

fn field(name: text, rule: Rule) -> Rule:
    Rule.Field(name, rule)

fn prec_left(precedence: i32, rule: Rule) -> Rule:
    Rule.PrecLeft(precedence, rule)

fn prec_right(precedence: i32, rule: Rule) -> Rule:
    Rule.PrecRight(precedence, rule)

# ============================================================================
# Token Kinds
# ============================================================================

enum TokenKind:
    # Keywords - Core
    Fn, Me,
    Let, Mut,  # Legacy: use Val/Var instead
    Val, Var,  # Scala-style variables
    Return, If, Elif, Else, Match, Case,
    For, In, While, Loop, Break, Continue,
    Class, Struct, Enum, Trait, Impl,
    Import, As, From,
    True, False, Nil,
    And, Or, Not,
    Then,  # For if-expressions

    # Keywords - Module System
    Mod, Use, Export, Common, Auto, Crate,

    # Keywords - Memory & Type System
    Union, Mixin, Extends,
    Move, Const, Static, Type, Unit, Extern,
    Iso, Ref, Dyn, Repr,
    Self_, Super, New,
    Pub, Priv,
    Context, With, Ghost,

    # Keywords - Concurrency
    Actor, Spawn, Go, Yield, Async, Await, Sync,

    # Keywords - Suspension (async-by-default)
    IfSuspend, WhileSuspend, ForSuspend,
    AndSuspend, OrSuspend,

    # Keywords - GPU/SIMD
    Macro, Bang, Vec, Shared, Gpu, Bounds,

    # Keywords - AOP & Unified Predicates
    On, Bind, Forbid, Allow, Mock,

    # Keywords - Contracts & Verification
    Out, OutErr, Where,
    Requires, Ensures, Invariant, Old, Result, Decreases,
    Forall, Exists,
    Assert, Assume, Admit, Calc,

    # Keywords - BDD/Testing (Gherkin DSL)
    Feature, Scenario, Outline, Examples,
    Given, When, AndThen,
    To, NotTo,  # Infix assertions

    # Keywords - Special
    HandlePool, Grid, Tensor, Slice, Flat, Default,

    # Operators - Arithmetic
    Plus, Minus, Star, Slash, Percent, DoubleStar, DoubleSlash,

    # Operators - Comparison
    Eq, DoubleEq, NotEq,
    Lt, Gt, LtEq, GtEq,

    # Operators - Assignment
    Assign,
    PlusAssign, MinusAssign, StarAssign, SlashAssign,
    TildeAssign, TildePlusAssign, TildeMinusAssign, TildeStarAssign, TildeSlashAssign,

    # Operators - Bitwise
    Pipe, Ampersand, Caret, Tilde,
    LtLt, GtGt,  # ShiftLeft, ShiftRight
    DoublePipe, DoubleAmp,

    # Operators - Special
    Dot, Comma, Colon, DoubleColon, Semicolon,
    Arrow, FatArrow, ChannelArrow,
    DoubleDot, DoubleDotEq, Ellipsis,
    Question, Exclamation,
    At, Hash, Dollar, Backslash,
    Underscore,

    # Delimiters
    LParen, RParen,
    LBracket, RBracket,
    LBrace, RBrace,
    Newline, Indent, Dedent,

    # Literals
    Integer,
    Float,
    TypedInteger,  # 42i32, 100u64
    TypedFloat,  # 3.14f64
    text,
    RawString,  # 'raw string'
    Symbol,  # :symbol
    TypedString,  # "text"_suffix
    TypedRawString,  # 'text'_suffix
    FStringStart, FStringText, FStringEnd, FStringFormatSpec,

    # Identifiers
    Identifier, TypeIdentifier,

    # Special Tokens
    CustomBlock,  # m{...}, sh{...}, sql{...}, etc.
    Pointcut,  # pc{...}
    DocComment,  # /** ... */ or ##
    Error,
    Eof

impl TokenKind:
    fn is_keyword() -> bool:
        """Check if this is any keyword token.
        Returns: true for all keyword variants
        Example: TokenKind.Fn.is_keyword()  # → true
        """
        match self:
            # Core keywords
            case Fn: true
            case Me: true
            case Let: true
            case Mut: true
            case Val: true
            case Var: true
            case Return: true
            case If: true
            case Elif: true
            case Else: true
            case Match: true
            case Case: true
            case For: true
            case In: true
            case While: true
            case Loop: true
            case Break: true
            case Continue: true
            case Class: true
            case Struct: true
            case Enum: true
            case Trait: true
            case Impl: true
            case Import: true
            case As: true
            case From: true
            case True: true
            case False: true
            case Nil: true
            case And: true
            case Or: true
            case Not: true
            case Then: true
            # Module system
            case Mod: true
            case Use: true
            case Export: true
            case Common: true
            case Auto: true
            case Crate: true
            # Type system & memory
            case Union: true
            case Mixin: true
            case Extends: true
            case Move: true
            case Const: true
            case Static: true
            case Type: true
            case Unit: true
            case Extern: true
            case Iso: true
            case Ref: true
            case Dyn: true
            case Repr: true
            case Self_: true
            case Super: true
            case New: true
            case Pub: true
            case Priv: true
            case Context: true
            case With: true
            case Ghost: true
            # Concurrency
            case Actor: true
            case Spawn: true
            case Go: true
            case Yield: true
            case Async: true
            case Await: true
            case Sync: true
            # Suspension
            case IfSuspend: true
            case WhileSuspend: true
            case ForSuspend: true
            case AndSuspend: true
            case OrSuspend: true
            # GPU/SIMD
            case Macro: true
            case Bang: true
            case Vec: true
            case Shared: true
            case Gpu: true
            case Bounds: true
            # AOP
            case On: true
            case Bind: true
            case Forbid: true
            case Allow: true
            case Mock: true
            # Contracts
            case Out: true
            case OutErr: true
            case Where: true
            case Requires: true
            case Ensures: true
            case Invariant: true
            case Old: true
            case Result: true
            case Decreases: true
            case Forall: true
            case Exists: true
            case Assert: true
            case Assume: true
            case Admit: true
            case Calc: true
            # BDD
            case Feature: true
            case Scenario: true
            case Outline: true
            case Examples: true
            case Given: true
            case When: true
            case AndThen: true
            case To: true
            case NotTo: true
            # Special
            case HandlePool: true
            case Grid: true
            case Tensor: true
            case Slice: true
            case Flat: true
            case Default: true
            case _: false

    fn is_operator() -> bool:
        """Check if this is an operator token.
        Returns: true for operator variants
        Example: TokenKind.Plus.is_operator()  # → true
        """
        match self:
            # Arithmetic
            case Plus: true
            case Minus: true
            case Star: true
            case Slash: true
            case Percent: true
            case DoubleStar: true
            case DoubleSlash: true
            # Comparison
            case Eq: true
            case DoubleEq: true
            case NotEq: true
            case Lt: true
            case Gt: true
            case LtEq: true
            case GtEq: true
            # Assignment
            case Assign: true
            case PlusAssign: true
            case MinusAssign: true
            case StarAssign: true
            case SlashAssign: true
            case TildeAssign: true
            case TildePlusAssign: true
            case TildeMinusAssign: true
            case TildeStarAssign: true
            case TildeSlashAssign: true
            # Bitwise
            case Pipe: true
            case Ampersand: true
            case Caret: true
            case Tilde: true
            case LtLt: true
            case GtGt: true
            case DoublePipe: true
            case DoubleAmp: true
            # Special
            case Dot: true
            case Comma: true
            case Colon: true
            case DoubleColon: true
            case Semicolon: true
            case Arrow: true
            case FatArrow: true
            case ChannelArrow: true
            case DoubleDot: true
            case DoubleDotEq: true
            case Ellipsis: true
            case Question: true
            case Exclamation: true
            case At: true
            case Hash: true
            case Dollar: true
            case Backslash: true
            case Underscore: true
            case _: false

    fn is_delimiter() -> bool:
        """Check if this is a delimiter token.
        Returns: true for delimiter variants
        Example: TokenKind.LParen.is_delimiter()  # → true
        """
        match self:
            case LParen: true
            case RParen: true
            case LBracket: true
            case RBracket: true
            case LBrace: true
            case RBrace: true
            case Newline: true
            case Indent: true
            case Dedent: true
            case _: false

    fn is_literal() -> bool:
        """Check if this is a literal token.
        Returns: true for literal variants
        Example: TokenKind.Integer.is_literal()  # → true
        """
        match self:
            case Integer: true
            case Float: true
            case TypedInteger: true
            case TypedFloat: true
            case text: true
            case RawString: true
            case Symbol: true
            case TypedString: true
            case TypedRawString: true
            case FStringStart: true
            case FStringText: true
            case FStringEnd: true
            case FStringFormatSpec: true
            case _: false

    fn is_identifier() -> bool:
        """Check if this is an identifier token.
        Returns: true for Identifier or TypeIdentifier
        Example: TokenKind.Identifier.is_identifier()  # → true
        """
        match self:
            case Identifier: true
            case TypeIdentifier: true
            case _: false

    fn is_control_flow() -> bool:
        """Check if this is a control flow keyword.
        Returns: true for control flow keywords
        Example: TokenKind.If.is_control_flow()  # → true
        """
        match self:
            case If: true
            case Elif: true
            case Else: true
            case Match: true
            case Case: true
            case For: true
            case While: true
            case Loop: true
            case Break: true
            case Continue: true
            case Return: true
            case _: false

    fn is_declaration() -> bool:
        """Check if this is a declaration keyword.
        Returns: true for declaration keywords
        Example: TokenKind.Fn.is_declaration()  # → true
        """
        match self:
            case Fn: true
            case Me: true
            case Let: true
            case Mut: true
            case Val: true
            case Var: true
            case Const: true
            case Static: true
            case Type: true
            case Unit: true
            case Class: true
            case Struct: true
            case Enum: true
            case Union: true
            case Trait: true
            case Impl: true
            case Mixin: true
            case Actor: true
            case Extern: true
            case Mod: true
            case HandlePool: true
            case _: false

    fn is_comparison() -> bool:
        """Check if this is a comparison operator.
        Returns: true for comparison operators
        Example: TokenKind.Lt.is_comparison()  # → true
        """
        match self:
            case DoubleEq: true
            case NotEq: true
            case Lt: true
            case Gt: true
            case LtEq: true
            case GtEq: true
            case _: false

    fn is_arithmetic() -> bool:
        """Check if this is an arithmetic operator.
        Returns: true for arithmetic operators
        Example: TokenKind.Plus.is_arithmetic()  # → true
        """
        match self:
            case Plus: true
            case Minus: true
            case Star: true
            case Slash: true
            case Percent: true
            case DoubleStar: true
            case _: false

    fn is_bitwise() -> bool:
        """Check if this is a bitwise operator.
        Returns: true for bitwise operators
        Example: TokenKind.Pipe.is_bitwise()  # → true
        """
        match self:
            case Pipe: true
            case Ampersand: true
            case Caret: true
            case Tilde: true
            case LtLt: true
            case GtGt: true
            case _: false

    fn is_logical() -> bool:
        """Check if this is a logical operator.
        Returns: true for logical operators
        Example: TokenKind.And.is_logical()  # → true
        """
        match self:
            case And: true
            case Or: true
            case Not: true
            case _: false

    fn is_bracket() -> bool:
        """Check if this is a bracket delimiter.
        Returns: true for bracket pairs
        Example: TokenKind.LBracket.is_bracket()  # → true
        """
        match self:
            case LParen: true
            case RParen: true
            case LBracket: true
            case RBracket: true
            case LBrace: true
            case RBrace: true
            case _: false

    fn is_whitespace() -> bool:
        """Check if this is whitespace/indentation token.
        Returns: true for Newline, Indent, Dedent
        Example: TokenKind.Indent.is_whitespace()  # → true
        """
        match self:
            case Newline: true
            case Indent: true
            case Dedent: true
            case _: false

    fn is_fstring_part() -> bool:
        """Check if this is part of f-string literal.
        Returns: true for f-string components
        Example: TokenKind.FStringText.is_fstring_part()  # → true
        """
        match self:
            case FStringStart: true
            case FStringText: true
            case FStringEnd: true
            case FStringFormatSpec: true
            case _: false

    fn to_string() -> text:
        """Convert TokenKind to string representation.
        Returns: lowercase symbolic name
        Example: TokenKind.DoubleEq.to_string()  # → "=="
        """
        match self:
            # Core keywords
            case Fn: "fn"
            case Me: "me"
            case Let: "let"
            case Mut: "mut"
            case Val: "val"
            case Var: "var"
            case Return: "return"
            case If: "if"
            case Elif: "elif"
            case Else: "else"
            case Match: "match"
            case Case: "case"
            case For: "for"
            case In: "in"
            case While: "while"
            case Loop: "loop"
            case Break: "break"
            case Continue: "continue"
            case Class: "class"
            case Struct: "struct"
            case Enum: "enum"
            case Trait: "trait"
            case Impl: "impl"
            case Import: "import"
            case As: "as"
            case From: "from"
            case True: "true"
            case False: "false"
            case Nil: "nil"
            case And: "and"
            case Or: "or"
            case Not: "not"
            case Then: "then"
            # Module system
            case Mod: "mod"
            case Use: "use"
            case Export: "export"
            case Common: "common"
            case Auto: "auto"
            case Crate: "crate"
            # Type system & memory
            case Union: "union"
            case Mixin: "mixin"
            case Extends: "extends"
            case Move: "move"
            case Const: "const"
            case Static: "static"
            case Type: "type"
            case Unit: "unit"
            case Extern: "extern"
            case Iso: "iso"
            case Ref: "ref"
            case Dyn: "dyn"
            case Repr: "repr"
            case Self_: "self"
            case Super: "super"
            case New: "new"
            case Pub: "pub"
            case Priv: "priv"
            case Context: "context"
            case With: "with"
            case Ghost: "ghost"
            # Concurrency
            case Actor: "actor"
            case Spawn: "spawn"
            case Go: "go"
            case Yield: "yield"
            case Async: "async"
            case Await: "await"
            case Sync: "sync"
            # Suspension
            case IfSuspend: "if~"
            case WhileSuspend: "while~"
            case ForSuspend: "for~"
            case AndSuspend: "and~"
            case OrSuspend: "or~"
            # GPU/SIMD
            case Macro: "macro"
            case Bang: "!"
            case Vec: "vec"
            case Shared: "shared"
            case Gpu: "gpu"
            case Bounds: "bounds"
            # AOP
            case On: "on"
            case Bind: "bind"
            case Forbid: "forbid"
            case Allow: "allow"
            case Mock: "mock"
            # Contracts
            case Out: "out"
            case OutErr: "out_err"
            case Where: "where"
            case Requires: "requires"
            case Ensures: "ensures"
            case Invariant: "invariant"
            case Old: "old"
            case Result: "result"
            case Decreases: "decreases"
            case Forall: "forall"
            case Exists: "exists"
            case Assert: "assert"
            case Assume: "assume"
            case Admit: "admit"
            case Calc: "calc"
            # BDD
            case Feature: "feature"
            case Scenario: "scenario"
            case Outline: "outline"
            case Examples: "examples"
            case Given: "given"
            case When: "when"
            case AndThen: "and_then"
            case To: "to"
            case NotTo: "not_to"
            # Special
            case HandlePool: "handle_pool"
            case Grid: "grid"
            case Tensor: "tensor"
            case Slice: "slice"
            case Flat: "flat"
            case Default: "default"
            # Arithmetic operators
            case Plus: "+"
            case Minus: "-"
            case Star: "*"
            case Slash: "/"
            case Percent: "%"
            case DoubleStar: "**"
            case DoubleSlash: "//"
            # Comparison operators
            case Eq: "=="
            case DoubleEq: "=="
            case NotEq: "!="
            case Lt: "<"
            case Gt: ">"
            case LtEq: "<="
            case GtEq: ">="
            # Assignment operators
            case Assign: "="
            case PlusAssign: "+="
            case MinusAssign: "-="
            case StarAssign: "*="
            case SlashAssign: "/="
            case TildeAssign: "~="
            case TildePlusAssign: "~+="
            case TildeMinusAssign: "~-="
            case TildeStarAssign: "~*="
            case TildeSlashAssign: "~/="
            # Bitwise operators
            case Pipe: "|"
            case Ampersand: "&"
            case Caret: "^"
            case Tilde: "~"
            case LtLt: "<<"
            case GtGt: ">>"
            case DoublePipe: "||"
            case DoubleAmp: "&&"
            # Special operators
            case Dot: "."
            case Comma: ","
            case Colon: ":"
            case DoubleColon: "."
            case Semicolon: ";"
            case Arrow: "->"
            case FatArrow: "=>"
            case ChannelArrow: "<-"
            case DoubleDot: ".."
            case DoubleDotEq: "..="
            case Ellipsis: "..."
            case Question: "?"
            case Exclamation: "!"
            case At: "@"
            case Hash: "#"
            case Dollar: "$"
            case Backslash: "\\"
            case Underscore: "_"
            # Delimiters
            case LParen: "("
            case RParen: ")"
            case LBracket: "["
            case RBracket: "]"
            case LBrace: "{"
            case RBrace: "}"
            case Newline: "\\n"
            case Indent: "<indent>"
            case Dedent: "<dedent>"
            # Literals
            case Integer: "<integer>"
            case Float: "<float>"
            case TypedInteger: "<typed_integer>"
            case TypedFloat: "<typed_float>"
            case text: "<string>"
            case RawString: "<raw_string>"
            case Symbol: "<symbol>"
            case TypedString: "<typed_string>"
            case TypedRawString: "<typed_raw_string>"
            case FStringStart: "<fstring_start>"
            case FStringText: "<fstring_text>"
            case FStringEnd: "<fstring_end>"
            case FStringFormatSpec: "<fstring_fmt>"
            # Identifiers
            case Identifier: "<identifier>"
            case TypeIdentifier: "<type_id>"
            # Special tokens
            case CustomBlock: "<custom_block>"
            case Pointcut: "<pointcut>"
            case DocComment: "<doc_comment>"
            case Error: "<error>"
            case Eof: "<eof>"

    fn description() -> text:
        """Get human-readable description of the token kind.
        Returns: descriptive explanation
        Example: TokenKind.Fn.description()  # → "Function declaration keyword"
        """
        match self:
            # Core keywords
            case Fn: "Function declaration keyword"
            case Me: "Mutable method keyword"
            case Let: "Variable binding keyword (legacy)"
            case Mut: "Mutable modifier keyword (legacy)"
            case Val: "Immutable variable keyword (Scala-style)"
            case Var: "Mutable variable keyword (Scala-style)"
            case Return: "Return statement keyword"
            case If: "Conditional if keyword"
            case Elif: "Conditional elif keyword"
            case Else: "Conditional else keyword"
            case Match: "Pattern match keyword"
            case Case: "Match case keyword"
            case For: "For loop keyword"
            case In: "In operator keyword"
            case While: "While loop keyword"
            case Loop: "Infinite loop keyword"
            case Break: "Break statement keyword"
            case Continue: "Continue statement keyword"
            case Class: "Class declaration keyword"
            case Struct: "Struct declaration keyword"
            case Enum: "Enum declaration keyword"
            case Trait: "Trait declaration keyword"
            case Impl: "Implementation block keyword"
            case Import: "Import statement keyword"
            case As: "Alias as keyword"
            case From: "From import keyword"
            case True: "Boolean true literal"
            case False: "Boolean false literal"
            case Nil: "Null/nil literal"
            case And: "Logical and operator"
            case Or: "Logical or operator"
            case Not: "Logical not operator"
            case Then: "Then keyword for expressions"
            # Module system
            case Mod: "Module declaration keyword"
            case Use: "Use/import keyword"
            case Export: "Export/re-export keyword"
            case Common: "Common prelude keyword"
            case Auto: "Auto import keyword"
            case Crate: "Crate root keyword"
            # Type system & memory
            case Union: "Union type keyword"
            case Mixin: "Mixin declaration keyword"
            case Extends: "Class inheritance keyword"
            case Move: "Move semantics keyword"
            case Const: "Compile-time constant keyword"
            case Static: "Static variable/method keyword"
            case Type: "Type alias keyword"
            case Unit: "Unit type keyword"
            case Extern: "External function keyword"
            case Iso: "Isolated reference capability"
            case Ref: "Reference capability"
            case Dyn: "Dynamic trait object keyword"
            case Repr: "Representation constraint keyword"
            case Self_: "Self reference keyword"
            case Super: "Super reference keyword"
            case New: "Constructor keyword"
            case Pub: "Public visibility keyword"
            case Priv: "Private visibility keyword"
            case Context: "Context manager keyword"
            case With: "With context keyword"
            case Ghost: "Verification-only code keyword"
            # Concurrency
            case Actor: "Actor declaration keyword"
            case Spawn: "Spawn thread keyword"
            case Go: "Go-style spawn keyword"
            case Yield: "Yield control keyword"
            case Async: "Async function keyword"
            case Await: "Await suspension keyword"
            case Sync: "Synchronous keyword"
            # Suspension
            case IfSuspend: "Suspension if keyword"
            case WhileSuspend: "Suspension while keyword"
            case ForSuspend: "Suspension for keyword"
            case AndSuspend: "Suspension and operator"
            case OrSuspend: "Suspension or operator"
            # GPU/SIMD
            case Macro: "Macro keyword"
            case Bang: "Macro invocation operator"
            case Vec: "SIMD vector keyword"
            case Shared: "GPU shared memory keyword"
            case Gpu: "GPU intrinsics keyword"
            case Bounds: "Kernel bounds keyword"
            # AOP
            case On: "AOP advice keyword"
            case Bind: "Dependency injection keyword"
            case Forbid: "Architecture rule forbid keyword"
            case Allow: "Architecture rule allow keyword"
            case Mock: "Mock declaration keyword"
            # Contracts
            case Out: "Postcondition block keyword"
            case OutErr: "Error postcondition keyword"
            case Where: "Refinement predicate keyword"
            case Requires: "Precondition keyword (legacy)"
            case Ensures: "Postcondition keyword (legacy)"
            case Invariant: "Invariant keyword"
            case Old: "Old value keyword"
            case Result: "Result value keyword"
            case Decreases: "Termination measure keyword"
            case Forall: "Universal quantifier keyword"
            case Exists: "Existential quantifier keyword"
            case Assert: "Assertion keyword"
            case Assume: "Assumption keyword"
            case Admit: "Admit proof keyword"
            case Calc: "Calculational proof keyword"
            # BDD
            case Feature: "BDD feature keyword"
            case Scenario: "BDD scenario keyword"
            case Outline: "BDD scenario outline keyword"
            case Examples: "BDD examples keyword"
            case Given: "BDD given step keyword"
            case When: "BDD when step keyword"
            case AndThen: "BDD and_then step keyword"
            case To: "Infix assertion keyword"
            case NotTo: "Negative infix assertion keyword"
            # Special
            case HandlePool: "Handle pool declaration keyword"
            case Grid: "2D matrix literal keyword"
            case Tensor: "N-D tensor literal keyword"
            case Slice: "Tensor slice keyword"
            case Flat: "Sparse tensor mode keyword"
            case Default: "Default value keyword"
            # Arithmetic operators
            case Plus: "Addition operator"
            case Minus: "Subtraction operator"
            case Star: "Multiplication operator"
            case Slash: "Division operator"
            case Percent: "Modulo operator"
            case DoubleStar: "Exponentiation operator"
            case DoubleSlash: "Floor division operator"
            # Comparison operators
            case Eq: "Equality comparison"
            case DoubleEq: "Equality comparison"
            case NotEq: "Inequality comparison"
            case Lt: "Less-than comparison"
            case Gt: "Greater-than comparison"
            case LtEq: "Less-or-equal comparison"
            case GtEq: "Greater-or-equal comparison"
            # Assignment operators
            case Assign: "Assignment operator"
            case PlusAssign: "Add-assign operator"
            case MinusAssign: "Subtract-assign operator"
            case StarAssign: "Multiply-assign operator"
            case SlashAssign: "Divide-assign operator"
            case TildeAssign: "Suspension assignment operator"
            case TildePlusAssign: "Suspension add-assign operator"
            case TildeMinusAssign: "Suspension subtract-assign operator"
            case TildeStarAssign: "Suspension multiply-assign operator"
            case TildeSlashAssign: "Suspension divide-assign operator"
            # Bitwise operators
            case Pipe: "Bitwise OR operator"
            case Ampersand: "Bitwise AND operator"
            case Caret: "Bitwise XOR operator"
            case Tilde: "Bitwise NOT operator"
            case LtLt: "Left shift operator"
            case GtGt: "Right shift operator"
            case DoublePipe: "Logical OR operator"
            case DoubleAmp: "Logical AND operator"
            # Special operators
            case Dot: "Member access operator"
            case Comma: "Comma separator"
            case Colon: "Colon separator"
            case DoubleColon: "Static method call operator"
            case Semicolon: "Statement terminator"
            case Arrow: "Function return type arrow"
            case FatArrow: "Fat arrow operator"
            case ChannelArrow: "Channel receive operator"
            case DoubleDot: "Exclusive range operator"
            case DoubleDotEq: "Inclusive range operator"
            case Ellipsis: "Ellipsis operator"
            case Question: "Optional type operator"
            case Exclamation: "Unwrap/assertion operator"
            case At: "Attribute marker"
            case Hash: "Hash symbol"
            case Dollar: "String interpolation marker"
            case Backslash: "Lambda parameter marker"
            case Underscore: "Wildcard pattern"
            # Delimiters
            case LParen: "Left parenthesis"
            case RParen: "Right parenthesis"
            case LBracket: "Left bracket"
            case RBracket: "Right bracket"
            case LBrace: "Left brace"
            case RBrace: "Right brace"
            case Newline: "Newline character"
            case Indent: "Indentation increase"
            case Dedent: "Indentation decrease"
            # Literals
            case Integer: "Integer literal"
            case Float: "Float literal"
            case TypedInteger: "Typed integer literal (e.g., 42i32)"
            case TypedFloat: "Typed float literal (e.g., 3.14f64)"
            case text: "String literal"
            case RawString: "Raw string literal (no escapes)"
            case Symbol: "Symbol literal (:symbol)"
            case TypedString: "Typed string literal with suffix"
            case TypedRawString: "Typed raw string literal with suffix"
            case FStringStart: "F-string start delimiter"
            case FStringText: "F-string text content"
            case FStringEnd: "F-string end delimiter"
            case FStringFormatSpec: "F-string format specifier"
            # Identifiers
            case Identifier: "Variable/function identifier"
            case TypeIdentifier: "Type name identifier"
            # Special tokens
            case CustomBlock: "Custom DSL block (m{}, sh{}, sql{}, etc.)"
            case Pointcut: "AOP pointcut expression pc{...}"
            case DocComment: "Documentation comment"
            case Error: "Error token"
            case Eof: "End of file"

    fn summary() -> text:
        """Get comprehensive summary of the token kind.
        Returns: summary with token, description, and category
        Example: TokenKind.Plus.summary()
                # → "TokenKind: + (Addition operator, operator, arithmetic)"
        """
        val name = self.to_string()
        val desc = self.description()
        var cats = []

        if self.is_keyword():
            cats.push("keyword")
        if self.is_operator():
            cats.push("operator")
        if self.is_delimiter():
            cats.push("delimiter")
        if self.is_literal():
            cats.push("literal")
        if self.is_identifier():
            cats.push("identifier")
        if self.is_control_flow():
            cats.push("control flow")
        if self.is_declaration():
            cats.push("declaration")
        if self.is_comparison():
            cats.push("comparison")
        if self.is_arithmetic():
            cats.push("arithmetic")
        if self.is_bitwise():
            cats.push("bitwise")
        if self.is_logical():
            cats.push("logical")

        val cats_str = if cats.len() > 0:
            ", " + cats.join(", ")
        else:
            ""

        "TokenKind: {name} ({desc}{cats_str})"
