# Error Recovery System - Simple Implementation
# Phase 1: Enhanced Error Messages with Context

## Contextual Error Types

class ContextualSyntaxError:
    """
    Enhanced error with context, suggestions, and help text.

    Example:
        ContextualSyntaxError(
            context: "function arguments",
            message: "expected comma before argument 'b'",
            span: Span(line: 5, column: 20),
            suggestion: "Insert comma before 'b'",
            help: "Use: func(a: 1, b: 2)"
        )
    """

    context: text                    # Where error occurred
    message: text                    # What went wrong
    span: Span                       # Location in source
    suggestion: Option<text>         # How to fix (optional)
    help: Option<text>               # Additional guidance (optional)

    fn format(source: text, use_color: bool) -> text:
        """Format error message with source context."""
        val lines = source.split("\n")
        val error_line = lines[self.span.line - 1] if self.span.line <= lines.len() else ""

        val output = []

        # Error header
        if use_color:
            output.push("\x1b[1;31merror[E0013]:\x1b[0m {self.context}: {self.message}")
        else:
            output.push("error[E0013]: {self.context}: {self.message}")

        # Source location
        output.push("  --> line {self.span.line}:{self.span.column}")
        output.push("   |")
        output.push("{self.span.line:3} | {error_line}")

        # Caret pointing to error
        val spaces = " " * (self.span.column - 1)
        output.push("   | {spaces}^")

        # Suggestion
        if self.suggestion.?:
            output.push("")
            if use_color:
                output.push("\x1b[1;36mSuggestion:\x1b[0m {self.suggestion.unwrap()}")
            else:
                output.push("Suggestion: {self.suggestion.unwrap()}")

        # Help text
        if self.help.?:
            output.push("")
            if use_color:
                output.push("\x1b[1;33mHelp:\x1b[0m {self.help.unwrap()}")
            else:
                output.push("Help: {self.help.unwrap()}")

        output.join("\n")


## Common Mistake Types

enum CommonMistake:
    """Common programming mistakes from other languages."""

    # Missing punctuation
    MissingCommaInArgs              # func(a: 1 b: 2)
    MissingCommaInDict              # {a: 1 b: 2}
    MissingCommaInStruct            # Point(x: 1 y: 2)
    MissingColonBeforeBlock         # fn foo() \n
    MissingColonInDict              # {key value}

    # Indentation issues
    MissingIndentAfterColon         # fn foo(): \n return
    WrongIndentLevel                # Inconsistent indentation

    # Python-style
    PythonDef                       # def instead of fn
    PythonSelf                      # self. instead of implicit self
    PythonNone                      # None instead of nil
    PythonTrue                      # True instead of true
    PythonFalse                     # False instead of false
    PythonElif                      # elif is correct (not else if)

    # Rust-style
    RustLetMut                      # let mut instead of var
    RustFnMut                       # fn(&mut self) instead of me fn()
    RustLifetime                    # 'a lifetime syntax not supported
    RustMacro                       # macro! syntax
    RustTurbofish                   # ::<T> instead of <T>

    # Java/C++ style
    JavaPublicClass                 # public class instead of pub class
    JavaVoid                        # void instead of no return type
    JavaNew                         # new Type() instead of Type {}
    JavaThis                        # this instead of self
    CppTemplate                     # template<T> instead of <T>
    CppNamespace                    # namespace instead of mod

    # TypeScript/JavaScript
    TsFunction                      # function instead of fn
    TsConst                         # const instead of val
    TsLet                           # let instead of val (warn if immutable)
    TsInterface                     # interface instead of trait
    TsArrowFunction                 # => in function definition

    # C-style
    CSemicolon                      # unnecessary semicolons
    CTypeFirst                      # int x instead of val x: i32

    # Generic mistakes
    MissingColon                    # Missing : before type/block
    WrongBrackets                   # [] instead of <> for generics
    ExplicitSelf                    # (self) parameter when implicit
    VerboseReturnType               # -> Type when type inference works
    SemicolonAfterBlock             # }; instead of }

    fn message() -> text:
        """Get detailed error message for this mistake."""
        match self:
            MissingCommaInArgs:
                "Missing comma between function arguments.\n\
                 \n\
                 Wrong:  func(a: 1 b: 2)\n\
                 Right:  func(a: 1, b: 2)"

            MissingCommaInDict:
                "Missing comma between dict entries.\n\
                 \n\
                 Wrong:  {a: 1 b: 2}\n\
                 Right:  {a: 1, b: 2}"

            MissingCommaInStruct:
                "Missing comma between struct fields.\n\
                 \n\
                 Wrong:  Point(x: 1 y: 2)\n\
                 Right:  Point(x: 1, y: 2)"

            MissingColonBeforeBlock:
                "Missing colon before function or block body.\n\
                 \n\
                 Wrong:  fn foo()\n\
                 Right:  fn foo():"

            MissingColonInDict:
                "Missing colon in dict entry.\n\
                 \n\
                 Wrong:  {key value}\n\
                 Right:  {key: value}"

            MissingIndentAfterColon:
                "Missing indentation after colon.\n\
                 \n\
                 Wrong:  fn foo():\n\
                 return 42\n\
                 Right:  fn foo():\n\
                     return 42"

            WrongIndentLevel:
                "Inconsistent indentation level.\n\
                 \n\
                 Use consistent indentation (4 spaces or tabs)."

            PythonDef:
                "Use 'fn' to define functions in Simple, not 'def'.\n\
                 \n\
                 Python:  def add(a, b):\n\
                 Simple:  fn add(a, b):"

            PythonNone:
                "Use 'nil' instead of 'None' in Simple.\n\
                 \n\
                 Python:  return None\n\
                 Simple:  return nil"

            RustLetMut:
                "Use 'var' for mutable variables, 'val' for immutable.\n\
                 \n\
                 Rust:    let mut x = 5;\n\
                 Simple:  var x = 5     # mutable\n\
                          val y = 10    # immutable"

            PythonSelf:
                "In Simple, 'self' is implicit in methods. Don't write 'self.'.\n\
                 \n\
                 Python:  self.x = value\n\
                 Simple:  x = value     # self is implicit in methods"

            PythonTrue:
                "Use lowercase 'true' instead of 'True'.\n\
                 \n\
                 Python:  if True:\n\
                 Simple:  if true:"

            PythonFalse:
                "Use lowercase 'false' instead of 'False'.\n\
                 \n\
                 Python:  if False:\n\
                 Simple:  if false:"

            PythonElif:
                "'elif' is the correct syntax in Simple (not 'else if').\n\
                 \n\
                 Python:  elif x > 0:\n\
                 Simple:  elif x > 0:  # elif is built-in"

            RustFnMut:
                "Use 'me' keyword for mutable methods, 'self' is implicit.\n\
                 \n\
                 Rust:    fn update(&mut self) {}\n\
                 Simple:  me update():  # 'me' keyword, self implicit"

            RustLifetime:
                "Simple doesn't use Rust-style lifetime annotations.\n\
                 Reference capabilities (mut/iso) handle memory safety instead."

            RustMacro:
                "Simple uses '@' for macros, not '!'.\n\
                 \n\
                 Rust:    println!(\"hello\");\n\
                 Simple:  @println(\"hello\")"

            RustTurbofish:
                "Use <T> syntax directly, not ::<T>.\n\
                 \n\
                 Rust:    vec.collect::<Vec<_>>()\n\
                 Simple:  vec.collect<Vec<T>>()"

            JavaPublicClass:
                "Use 'pub class' or 'pub struct' in Simple.\n\
                 \n\
                 Java:    public class Point {}\n\
                 Simple:  pub class Point:  # or 'pub struct Point:'"

            JavaVoid:
                "Omit return type for void functions in Simple.\n\
                 \n\
                 Java:    void print(String s) {}\n\
                 Simple:  fn print(s: String):  # no return type"

            JavaNew:
                "Use direct construction instead of 'new'.\n\
                 \n\
                 Java:    Point p = new Point(1, 2);\n\
                 Simple:  val p = Point(x: 1, y: 2)"

            JavaThis:
                "Use 'self' instead of 'this' (and it's implicit in methods).\n\
                 \n\
                 Java:    this.x = value;\n\
                 Simple:  x = value  # self is implicit"

            CppTemplate:
                "Generic parameters come after the name in Simple.\n\
                 \n\
                 C++:     template<typename T> class Vec {};\n\
                 Simple:  struct Vec<T>:"

            CppNamespace:
                "Use 'mod' for modules instead of 'namespace'.\n\
                 \n\
                 C++:     namespace math {}\n\
                 Simple:  mod math:"

            TsFunction:
                "Use 'fn' to define functions in Simple.\n\
                 \n\
                 TypeScript:  function add(a, b) {}\n\
                 Simple:      fn add(a, b):"

            TsConst:
                "Use 'val' for immutable variables in Simple.\n\
                 \n\
                 TypeScript:  const x = 5;\n\
                 Simple:      val x = 5"

            TsLet:
                "Use 'val' for immutable or 'var' for mutable variables.\n\
                 \n\
                 TypeScript:  let x = 5;  // could be reassigned\n\
                 Simple:      val x = 5   // immutable (preferred)\n\
                              var y = 5   // mutable"

            TsInterface:
                "Use 'trait' instead of 'interface' in Simple.\n\
                 \n\
                 TypeScript:  interface Named {}\n\
                 Simple:      trait Named:"

            TsArrowFunction:
                "Use ':' for function bodies, '=>' is for lambdas.\n\
                 \n\
                 TypeScript:  const add = (a, b) => a + b;\n\
                 Simple:      val add = \\a, b: a + b  # lambda uses backslash"

            CSemicolon:
                "Semicolons are optional in Simple (only needed for same-line statements).\n\
                 \n\
                 C:       int x = 5;\n\
                 Simple:  val x = 5  # no semicolon needed"

            CTypeFirst:
                "Type comes after the variable name in Simple.\n\
                 \n\
                 C:       int x = 5;\n\
                 Simple:  val x: i32 = 5  # type after name\n\
                          val x = 5       # or use type inference"

            MissingColon:
                "Function and block definitions require ':' before the body.\n\
                 \n\
                 Missing: fn foo()\n\
                 Correct: fn foo():"

            WrongBrackets:
                "Use angle brackets <> for generic types (not square brackets).\n\
                 \n\
                 Old:     List[T]\n\
                 New:     List<T>  # industry standard"

            ExplicitSelf:
                "The 'self' parameter is implicit in methods. Don't write it.\n\
                 \n\
                 Explicit:  fn get_x(self) -> i32:  # redundant\n\
                 Implicit:  fn get_x() -> i32:      # self is automatic"

            VerboseReturnType:
                "Return type can be inferred. Only specify when needed for clarity.\n\
                 \n\
                 Verbose:  fn add(a: i32, b: i32) -> i32: a + b\n\
                 Concise:  fn add(a: i32, b: i32): a + b  # return type inferred"

            SemicolonAfterBlock:
                "Don't use semicolons after block closures.\n\
                 \n\
                 Wrong:  if x > 0: { ... };\n\
                 Right:  if x > 0: { ... }"

    fn suggestion() -> text:
        """Get fix suggestion for this mistake."""
        match self:
            MissingCommaInArgs: "Insert comma between arguments"
            MissingCommaInDict: "Insert comma between dict entries"
            MissingCommaInStruct: "Insert comma between struct fields"
            MissingColonBeforeBlock: "Add ':' before the function body"
            MissingColonInDict: "Insert colon after the key"
            MissingIndentAfterColon: "Add indentation after colon"
            WrongIndentLevel: "Fix indentation level"
            PythonDef: "Replace 'def' with 'fn'"
            PythonSelf: "Remove 'self.' prefix (self is implicit)"
            PythonNone: "Replace 'None' with 'nil'"
            PythonTrue: "Replace 'True' with 'true'"
            PythonFalse: "Replace 'False' with 'false'"
            PythonElif: "'elif' is correct - use it instead of 'else if'"
            RustLetMut: "Use 'var' instead of 'let mut'"
            RustFnMut: "Use 'me' keyword instead of '&mut self' parameter"
            RustLifetime: "Remove lifetime annotations, use capabilities"
            RustMacro: "Use '@' for macros instead of '!'"
            RustTurbofish: "Use <T> instead of ::<T>"
            JavaPublicClass: "Use 'pub class' or 'pub struct'"
            JavaVoid: "Omit the return type (-> Type) for void functions"
            JavaNew: "Use direct construction: Type(field: value)"
            JavaThis: "Use 'self' (which is implicit in methods)"
            CppTemplate: "Use generic syntax: struct Name<T>"
            CppNamespace: "Use 'mod' instead of 'namespace'"
            TsFunction: "Replace 'function' with 'fn'"
            TsConst: "Replace 'const' with 'val'"
            TsLet: "Use 'val' (immutable) or 'var' (mutable)"
            TsInterface: "Replace 'interface' with 'trait'"
            TsArrowFunction: "Use ':' for function bodies, '=>' for lambdas"
            CSemicolon: "Remove unnecessary semicolons"
            CTypeFirst: "Use 'val' or 'var' with type after name"
            MissingColon: "Add ':' before the function body"
            WrongBrackets: "Use <> instead of [] for generics"
            ExplicitSelf: "Remove the 'self' parameter (it's implicit)"
            VerboseReturnType: "Consider omitting return type (type inference works)"
            SemicolonAfterBlock: "Remove semicolon after block"


## Error Detection Helpers

fn detect_missing_comma_in_args(current_token: Token, next_token: Token) -> bool:
    """
    Detect missing comma between named arguments.

    Pattern: identifier followed by colon/equals (next argument starts)
    Example: func(a: 1 b: 2) where current=b, next=:
    """
    current_token.is_identifier() and
        (next_token.kind == TokenKind.Colon or next_token.kind == TokenKind.Assign)


fn detect_missing_comma_in_dict(current_token: Token, next_token: Token, prev_token: Token) -> bool:
    """
    Detect missing comma between dict entries.

    Pattern: After value, found identifier followed by colon
    Example: {a: 1 b: 2} where prev=1, current=b, next=:
    """
    prev_token.kind != TokenKind.Comma and
        current_token.is_identifier() and
        next_token.kind == TokenKind.Colon


fn detect_missing_colon_before_block(current_token: Token) -> bool:
    """
    Detect missing colon before block body.

    Pattern: After function signature, found newline/indent without colon
    Example: fn foo()\n where current=Newline
    """
    current_token.kind == TokenKind.Newline or
        current_token.kind == TokenKind.Indent


fn detect_common_mistake(current: Token, previous: Token, next: Option<Token>) -> Option<CommonMistake>:
    """
    Unified detector for common mistakes (matches Rust implementation).

    Checks token sequences to detect mistakes from other languages.
    Returns the detected mistake type or None.
    """

    # Check for Python-style 'def'
    if current.lexeme == "def" and current.is_identifier():
        return Some(CommonMistake.PythonDef)

    # Check for 'None' (Python) - but skip in valid Simple contexts
    if current.lexeme == "None" and current.is_identifier():
        # Skip if after 'case' (pattern matching)
        if previous.kind == TokenKind.Case:
            return None
        # Skip if after 'return' - could be Option::None variant
        if previous.kind == TokenKind.Return:
            return None
        # Skip if after '=' - could be assigning None enum variant
        if previous.kind == TokenKind.Assign:
            return None
        return Some(CommonMistake.PythonNone)

    # Check for 'True' or 'False' (Python/Java)
    if current.lexeme == "True" and current.is_identifier():
        return Some(CommonMistake.PythonTrue)
    if current.lexeme == "False" and current.is_identifier():
        return Some(CommonMistake.PythonFalse)

    # Check for 'let mut' (Rust)
    if previous.kind == TokenKind.Let and current.lexeme == "mut" and current.is_identifier():
        return Some(CommonMistake.RustLetMut)

    # Check for 'new' keyword (Java/C++) - but NOT when used as method name
    if current.kind == TokenKind.New:
        # Skip if after dot (method call), fn keyword, ::, comma, lparen, etc.
        val skip_tokens = [
            TokenKind.Dot,
            TokenKind.Fn,
            TokenKind.DoubleColon,
            TokenKind.Comma,
            TokenKind.LParen,
            TokenKind.Val,
            TokenKind.Var
        ]
        if not skip_tokens.contains(previous.kind):
            return Some(CommonMistake.JavaNew)

    # Check for 'this' (Java/JavaScript)
    if current.lexeme == "this" and current.is_identifier():
        return Some(CommonMistake.JavaThis)

    # Check for 'function' (JavaScript/TypeScript)
    if current.lexeme == "function" and current.is_identifier():
        return Some(CommonMistake.TsFunction)

    # Check for 'const' (TypeScript/JavaScript)
    if current.lexeme == "const" and current.is_identifier():
        return Some(CommonMistake.TsConst)

    # Check for 'interface' (TypeScript/Java)
    if current.lexeme == "interface" and current.is_identifier():
        return Some(CommonMistake.TsInterface)

    # Check for 'namespace' (C++)
    if current.lexeme == "namespace" and current.is_identifier():
        return Some(CommonMistake.CppNamespace)

    # Check for 'template' (C++)
    if current.lexeme == "template" and current.is_identifier():
        return Some(CommonMistake.CppTemplate)

    # Check for 'let' without 'mut' (TypeScript/JavaScript)
    if current.kind == TokenKind.Let:
        if next.?:
            val next_token = next.unwrap()
            if next_token.lexeme != "mut":
                return Some(CommonMistake.TsLet)
        else:
            return Some(CommonMistake.TsLet)

    # Check for Python-style explicit self.x
    if current.kind == TokenKind.Self_ and previous.kind != TokenKind.Fn and previous.kind != TokenKind.Me:
        if next.?:
            val next_token = next.unwrap()
            if next_token.kind == TokenKind.Dot:
                return Some(CommonMistake.PythonSelf)

    # Check for TypeScript arrow function: ) =>
    if current.kind == TokenKind.FatArrow and previous.kind == TokenKind.RParen:
        return Some(CommonMistake.TsArrowFunction)

    # Check for wrong brackets in generics: identifier[
    if current.kind == TokenKind.LBracket and previous.is_identifier():
        if next.?:
            val next_token = next.unwrap()
            # Check if next token looks like a type (capitalized identifier)
            if next_token.is_identifier():
                # Check if first char is uppercase (simplified type check)
                if next_token.lexeme.len() > 0:
                    val first_char = next_token.lexeme[0]
                    if first_char >= 'A' and first_char <= 'Z':
                        return Some(CommonMistake.WrongBrackets)

    # Check for Rust turbofish: ::<
    if current.kind == TokenKind.Lt and previous.kind == TokenKind.DoubleColon:
        return Some(CommonMistake.RustTurbofish)

    # Check for Rust macro syntax: identifier!
    if current.lexeme == "!" and current.kind == TokenKind.Not and previous.is_identifier():
        return Some(CommonMistake.RustMacro)

    None


## Fix Suggestion System (Phase 2 foundation)

class FixSuggestion:
    """
    Suggested fix with confidence score.

    Example:
        FixSuggestion(
            description: "Insert missing comma",
            span: Span(line: 5, column: 15),
            replacement: ", ",
            confidence: Confidence.High
        )
    """

    description: text           # What this fix does
    span: Span                  # Where to apply
    replacement: text           # Text to insert/replace
    confidence: Confidence      # How confident we are

    fn generate_diff(source: text) -> text:
        """Generate unified diff showing before/after."""
        val lines = source.split("\n")
        val line_index = self.span.line - 1

        if line_index >= lines.len():
            return "Error: line out of bounds"

        val original_line = lines[line_index]
        val col = self.span.column - 1

        # Insert replacement at column
        val fixed_line = original_line[:col] + self.replacement + original_line[col:]

        # Format as unified diff
        val diff = []
        diff.push("--- before")
        diff.push("+++ after")
        diff.push("@@ -{self.span.line},1 +{self.span.line},1 @@")
        diff.push("-{original_line}")
        diff.push("+{fixed_line}")
        diff.join("\n")


enum Confidence:
    """Confidence level for automatic fix suggestions."""
    High        # 95%+ certain - safe for auto-fix
    Medium      # 70-95% certain - ask user
    Low         # <70% certain - show only


class FixSuggestions:
    """Collection of fix suggestions for an error."""

    error_message: text
    error_span: Span
    fixes: [FixSuggestion]

    fn best_fix() -> Option<FixSuggestion>:
        """Get the highest confidence fix."""
        if not self.fixes.?:
            return None

        # Find fix with highest confidence
        var best = self.fixes[0]
        for fix in self.fixes[1:]:
            if fix.confidence == Confidence.High and best.confidence != Confidence.High:
                best = fix

        Some(best)


## Span Type (simplified)

class Span:
    """Location in source code."""
    line: i32
    column: i32
    start: i32 = 0
    end: i32 = 0


## Token Type (simplified)

class Token:
    """Token with kind and lexeme."""
    kind: TokenKind
    lexeme: text
    span: Span

    fn is_identifier() -> bool:
        match self.kind:
            TokenKind.Identifier: true
            _: false


enum TokenKind:
    """Token types."""
    Identifier
    Colon
    Comma
    Assign
    Newline
    Indent
    Dedent
    LParen
    RParen
    LBrace
    RBrace
    LBracket
    RBracket
    Fn
    Val
    Var
    Let
    Me
    Self_
    Case
    Return
    Dot
    DoubleColon
    Lt
    Not
    FatArrow
    New
    # ... more token types


## Error Builder Pattern

class ErrorBuilder:
    """Builder for constructing contextual errors."""

    context_: text = ""
    message_: text = ""
    span_: Span = Span(line: 0, column: 0)
    suggestion_: Option<text> = None
    help_: Option<text> = None

    fn context(ctx: text) -> Self:
        self.context_ = ctx
        self

    fn message(msg: text) -> Self:
        self.message_ = msg
        self

    fn at_span(span: Span) -> Self:
        self.span_ = span
        self

    fn suggest(sugg: text) -> Self:
        self.suggestion_ = Some(sugg)
        self

    fn help_text(help: text) -> Self:
        self.help_ = Some(help)
        self

    fn build() -> ContextualSyntaxError:
        ContextualSyntaxError(
            context: self.context_,
            message: self.message_,
            span: self.span_,
            suggestion: self.suggestion_,
            help: self.help_
        )


## Export public API

export ContextualSyntaxError
export CommonMistake
export FixSuggestion
export FixSuggestions
export Confidence
export ErrorBuilder
export Span
export Token
export TokenKind

# Detection functions
export detect_missing_comma_in_args
export detect_missing_comma_in_dict
export detect_missing_colon_before_block
export detect_common_mistake
