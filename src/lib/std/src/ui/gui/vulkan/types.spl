# Vulkan Types - Supporting types and FFI declarations
#
# All shared types and FFI bindings for Vulkan async renderer.

use ui.element.*
use ui.attrs.*

pub use Frame, FrameData, BoxConstraints, LayoutResult, Rect
pub use DrawList, Vertex, DrawCall, PipelineType, VertexBuilder
pub use Buffer, Image, DirtyRegion, GpuSubmitResult
pub use VkSubmitInfo, VkPresentInfo, SwapchainError, LayoutCache

# ============================================================================
# FFI Declarations
# ============================================================================

extern fn vulkan_create_window(title_ptr: *const u8, title_len: u64, width: u32, height: u32) -> i64
extern fn vulkan_poll_event_async(window: i64, timeout_ms: u64) -> Future<Result<Option<Event>, text>>

# ============================================================================
# Frame Types
# ============================================================================

struct Frame:
    image_index: u32
    buffer_index: usize
    command_buffer: i64

struct FrameData:
    command_buffer: i64
    fence: i64
    image_available: i64
    render_finished: i64

# ============================================================================
# Layout Types
# ============================================================================

struct BoxConstraints:
    min_width: u32
    min_height: u32
    max_width: u32
    max_height: u32

impl BoxConstraints:
    fn new(min_w: u32, min_h: u32, max_w: u32, max_h: u32) -> BoxConstraints:
        return BoxConstraints {
            min_width: min_w,
            min_height: min_h,
            max_width: max_w,
            max_height: max_h
        }

struct LayoutResult:
    bounds: Dict<u64, Rect>    # NodeId -> Rect

impl LayoutResult:
    static fn default() -> LayoutResult:
        return LayoutResult { bounds: Dict.new() }

    fn get_bounds(node_id: NodeId) -> Rect:
        match self.bounds.get(&node_id.value()):
            case Some(rect): return rect
            case None: return Rect.zero()

struct Rect:
    x: f32
    y: f32
    width: f32
    height: f32

impl Rect:
    fn zero() -> Rect:
        return Rect { x: 0.0, y: 0.0, width: 0.0, height: 0.0 }

struct DirtyRegion:
    bounds: Rect

struct LayoutCache:
    entries: Dict<u64, CachedLayout>
    max_size: usize

impl LayoutCache:
    static fn new() -> LayoutCache:
        return LayoutCache {
            entries: Dict.new(),
            max_size: 1000
        }

    fn get(id: u64) -> Option<CachedLayout>:
        return self.entries.get(&id).cloned()

    fn set(id: u64, constraints: BoxConstraints, result: LayoutResult):
        # Evict oldest entries if cache is full
        if self.entries.len() >= self.max_size:
            self.evict_oldest()

        self.entries.set(id, CachedLayout {
            constraints: constraints,
            result: result
        })

    fn invalidate(id: u64):
        self.entries.remove(&id)

    fn clear():
        self.entries.clear()

    fn evict_oldest():
        # Simple eviction: remove first entry
        if val Some(key) = self.entries.keys().next():
            self.entries.remove(key)

struct CachedLayout:
    constraints: BoxConstraints
    result: LayoutResult

# ============================================================================
# Draw Types
# ============================================================================

struct DrawList:
    vertices: Array<Vertex>
    indices: Array<u32>
    draw_calls: Array<DrawCall>

impl DrawList:
    static fn new() -> DrawList:
        return DrawList {
            vertices: [],
            indices: [],
            draw_calls: []
        }

    fn clear():
        self.vertices.clear()
        self.indices.clear()
        self.draw_calls.clear()

struct Vertex:
    position: (f32, f32)
    uv: (f32, f32)
    color: u32

struct DrawCall:
    pipeline_type: PipelineType
    vertex_offset: u32
    vertex_count: u32
    index_offset: u32
    index_count: u32
    texture_id: Option<u64>
    scissor: Option<Rect>

enum PipelineType:
    SolidColor
    RoundedRect
    Text
    Textured
    Gradient
    Shadow

impl PipelineType:
    # =========================================================================
    # Helper Methods
    # =========================================================================

    fn to_string() -> text:
        """Convert pipeline type to string.

        Returns:
            Type name
        """
        match self:
            case SolidColor: "SolidColor"
            case RoundedRect: "RoundedRect"
            case Text: "Text"
            case Textured: "Textured"
            case Gradient: "Gradient"
            case Shadow: "Shadow"

    fn is_solid_color() -> bool:
        """Check if this is SolidColor pipeline."""
        match self:
            case SolidColor: true
            case _: false

    fn is_rounded_rect() -> bool:
        """Check if this is RoundedRect pipeline."""
        match self:
            case RoundedRect: true
            case _: false

    fn is_text() -> bool:
        """Check if this is Text pipeline."""
        match self:
            case Text: true
            case _: false

    fn is_textured() -> bool:
        """Check if this is Textured pipeline."""
        match self:
            case Textured: true
            case _: false

    fn is_gradient() -> bool:
        """Check if this is Gradient pipeline."""
        match self:
            case Gradient: true
            case _: false

    fn is_shadow() -> bool:
        """Check if this is Shadow pipeline."""
        match self:
            case Shadow: true
            case _: false

    fn requires_texture() -> bool:
        """Check if pipeline requires texture binding.

        Returns:
            true for Textured or Text
        """
        match self:
            case Textured: true
            case Text: true
            case _: false

    fn supports_alpha() -> bool:
        """Check if pipeline supports alpha blending.

        Returns:
            true for most types except Shadow
        """
        match self:
            case Shadow: false
            case _: true

    fn summary() -> text:
        """Get summary of pipeline type.

        Returns:
            Human-readable summary

        Example:
            PipelineType.Text.summary()
            # → "PipelineType: Text (requires texture, supports alpha)"
        """
        val name = self.to_string()
        val texture = if self.requires_texture(): "requires texture" else: "no texture"
        val alpha = if self.supports_alpha(): "supports alpha" else: "no alpha"
        return "PipelineType: {name} ({texture}, {alpha})"

struct VertexBuilder:
    vertices: Array<Vertex>
    indices: Array<u32>

impl VertexBuilder:
    static fn new() -> VertexBuilder:
        return VertexBuilder { vertices: [], indices: [] }

    fn clear():
        self.vertices.clear()
        self.indices.clear()

# ============================================================================
# GPU Types
# ============================================================================

struct Buffer:
    handle: i64                # VkBuffer
    allocation: i64            # VmaAllocation
    size: u64

struct Image:
    handle: i64                # VkImage
    view: i64                  # VkImageView
    allocation: i64            # VmaAllocation
    width: u32
    height: u32
    format: u32

struct GpuSubmitResult:
    success: bool

struct VkSubmitInfo:
    wait_semaphores: Array<i64>
    wait_stages: Array<u32>
    command_buffers: Array<i64>
    signal_semaphores: Array<i64>
    fence: i64

struct VkPresentInfo:
    wait_semaphores: Array<i64>
    swapchains: Array<i64>
    image_indices: Array<u32>

enum SwapchainError:
    OutOfDate
    DeviceLost

impl SwapchainError:
    # =========================================================================
    # Helper Methods
    # =========================================================================

    fn is_out_of_date() -> bool:
        """Check if swapchain is out of date.

        Returns:
            true for OutOfDate

        Example:
            SwapchainError.OutOfDate.is_out_of_date()  # → true
        """
        match self:
            case OutOfDate: true
            case _: false

    fn is_device_lost() -> bool:
        """Check if device was lost.

        Returns:
            true for DeviceLost

        Example:
            SwapchainError.DeviceLost.is_device_lost()  # → true
        """
        match self:
            case DeviceLost: true
            case _: false

    fn is_recoverable() -> bool:
        """Check if error is recoverable.

        Returns:
            true for OutOfDate (can recreate swapchain)

        Example:
            SwapchainError.OutOfDate.is_recoverable()  # → true
            SwapchainError.DeviceLost.is_recoverable()  # → false
        """
        match self:
            case OutOfDate: true
            case DeviceLost: false

    fn to_string() -> text:
        """Convert error to string.

        Returns:
            Error name
        """
        match self:
            case OutOfDate: "OutOfDate"
            case DeviceLost: "DeviceLost"

    fn description() -> text:
        """Get error description.

        Returns:
            Human-readable description
        """
        match self:
            case OutOfDate: "Swapchain is out of date (window resized or display changed)"
            case DeviceLost: "GPU device was lost"

    fn summary() -> text:
        """Get summary of swapchain error.

        Returns:
            Human-readable summary

        Example:
            SwapchainError.OutOfDate.summary()
            # → "SwapchainError: OutOfDate (Swapchain is out of date, recoverable)"
        """
        val name = self.to_string()
        val desc = self.description()
        val recoverable = if self.is_recoverable(): "recoverable" else: "fatal"
        return "SwapchainError: {name} ({desc}, {recoverable})"

    fn requires_recreation() -> bool:
        """Check if error requires swapchain recreation.

        Returns:
            true for OutOfDate

        Example:
            SwapchainError.OutOfDate.requires_recreation()  # → true
        """
        match self:
            case OutOfDate: true
            case _: false

    fn is_fatal() -> bool:
        """Check if error is fatal.

        Returns:
            true for DeviceLost

        Example:
            SwapchainError.DeviceLost.is_fatal()  # → true
        """
        match self:
            case DeviceLost: true
            case _: false

    fn to_string() -> text:
        """Convert error to string.

        Returns:
            Error name

        Example:
            SwapchainError.OutOfDate.to_string()  # → "out_of_date"
        """
        match self:
            case OutOfDate: "out_of_date"
            case DeviceLost: "device_lost"

    fn description() -> text:
        """Get detailed error description.

        Returns:
            Human-readable description

        Example:
            SwapchainError.OutOfDate.description()
            # → "Swapchain is out of date and must be recreated"
        """
        match self:
            case OutOfDate: "Swapchain is out of date and must be recreated"
            case DeviceLost: "Vulkan device was lost (fatal error)"

    fn summary() -> text:
        """Get summary of error.

        Returns:
            Summary string

        Example:
            SwapchainError.OutOfDate.summary()
            # → "SwapchainError: out_of_date (recoverable)"
        """
        val name = self.to_string()
        val recoverable = if self.is_recoverable(): "recoverable" else: "fatal"
        return "SwapchainError: {name} ({recoverable})"
