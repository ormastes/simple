# Vulkan Frame Management - Phase 2 Implementation
#
# Frame context for render loop with automatic resource management.
# Supports while-with context manager pattern for ergonomic rendering.

use core.*
use ui.gui.vulkan_types.*
use ui.gui.vulkan_buffers.*
use ui.gui.vulkan_commands.*
use ui.gui.vulkan_pipeline.*

# =============================================================================
# Frame Context - Manages one frame of rendering
# =============================================================================

pub struct Frame:
    # Core resources
    device: VulkanDevice
    swapchain: Swapchain
    render_pass: RenderPass
    command_buffer: CommandBuffer
    framebuffer: Framebuffer

    # Synchronization
    image_available_semaphore: VkSemaphore
    render_finished_semaphore: VkSemaphore
    in_flight_fence: VkFence

    # Current frame state
    image_index: u32
    width: u32
    height: u32
    is_active: bool

impl Frame:
    # Begin frame - acquires swapchain image
    fn begin(
        device: &VulkanDevice,
        swapchain: &Swapchain,
        render_pass: &RenderPass,
        command_buffer: &mut CommandBuffer,
        framebuffers: &Array<Framebuffer>,
        sync: &FrameSync
    ) -> Result<Frame, text>:
        # Wait for previous frame to finish
        await device.wait_for_fence_async(sync.fence)
        device.reset_fence(sync.fence)?

        # Acquire next swapchain image
        val image_index = await swapchain.acquire_next_image_async(sync.image_available)?

        # Begin command buffer
        command_buffer.begin()?

        val frame = Frame {
            device: device.clone(),
            swapchain: swapchain.clone(),
            render_pass: render_pass.clone(),
            command_buffer: command_buffer.clone(),
            framebuffer: framebuffers[image_index].clone(),
            image_available_semaphore: sync.image_available,
            render_finished_semaphore: sync.render_finished,
            in_flight_fence: sync.fence,
            image_index: image_index,
            width: swapchain.extent.width,
            height: swapchain.extent.height,
            is_active: true,
        }

        Ok(frame)

    # Clear the frame with a color
    pub fn clear(&mut self, color: [f32; 4]) -> Result<(), text>:
        if !self.is_active:
            return Err("Frame not active")

        # Begin render pass (clears automatically)
        self.command_buffer.begin_render_pass(
            &self.render_pass,
            self.framebuffer.framebuffer,
            self.width,
            self.height,
            color
        )

    # Bind pipeline for drawing
    pub fn bind(&mut self, pipeline: &GraphicsPipeline) -> Result<(), text>:
        if !self.is_active:
            return Err("Frame not active")

        self.command_buffer.bind_pipeline(pipeline)?

        # Set viewport and scissor to full screen by default
        self.command_buffer.set_viewport(
            0.0,
            0.0,
            self.width as f32,
            self.height as f32
        )?

        self.command_buffer.set_scissor(
            0,
            0,
            self.width,
            self.height
        )

    # Draw vertices
    pub fn draw(&mut self, vertex_buffer: &VertexBuffer, vertex_count: u32) -> Result<(), text>:
        if !self.is_active:
            return Err("Frame not active")

        self.command_buffer.bind_vertex_buffer(vertex_buffer)?
        self.command_buffer.draw(vertex_count, 1, 0, 0)

    # Draw with custom parameters
    pub fn draw_instanced(
        &mut self,
        vertex_buffer: &VertexBuffer,
        vertex_count: u32,
        instance_count: u32,
        first_vertex: u32,
        first_instance: u32
    ) -> Result<(), text>:
        if !self.is_active:
            return Err("Frame not active")

        self.command_buffer.bind_vertex_buffer(vertex_buffer)?
        self.command_buffer.draw(vertex_count, instance_count, first_vertex, first_instance)

    # Draw indexed vertices
    pub fn draw_indexed(
        &mut self,
        vertex_buffer: &VertexBuffer,
        index_buffer: &IndexBuffer,
        index_count: u32
    ) -> Result<(), text>:
        if !self.is_active:
            return Err("Frame not active")

        self.command_buffer.bind_vertex_buffer(vertex_buffer)?
        self.command_buffer.bind_index_buffer(index_buffer)?
        self.command_buffer.draw_indexed(index_count, 1, 0, 0, 0)

    # Draw indexed with custom parameters
    pub fn draw_indexed_instanced(
        &mut self,
        vertex_buffer: &VertexBuffer,
        index_buffer: &IndexBuffer,
        index_count: u32,
        instance_count: u32,
        first_index: u32,
        vertex_offset: i32,
        first_instance: u32
    ) -> Result<(), text>:
        if !self.is_active:
            return Err("Frame not active")

        self.command_buffer.bind_vertex_buffer(vertex_buffer)?
        self.command_buffer.bind_index_buffer(index_buffer)?
        self.command_buffer.draw_indexed(
            index_count,
            instance_count,
            first_index,
            vertex_offset,
            first_instance
        )

    # End frame - submits to queue and presents
    async fn end(&mut self) -> Result<(), text>:
        if !self.is_active:
            return Err("Frame already ended")

        # End render pass
        self.command_buffer.end_render_pass()?

        # End command buffer
        self.command_buffer.end()?

        # Submit to graphics queue
        val submission = CommandSubmission.new(&self.device)
        await submission.submit_async(
            self.device.graphics_queue,
            &self.command_buffer,
            &[self.image_available_semaphore],
            &[self.render_finished_semaphore],
            self.in_flight_fence
        )?

        # Present to screen
        val present_info = VkPresentInfo {
            wait_semaphores: [self.render_finished_semaphore],
            swapchain: self.swapchain.swapchain,
            image_index: self.image_index,
        }

        await self.device.queue_present_async(present_info)?

        self.is_active = false
        Ok(())

    pub fn get_width(self) -> u32:
        """Get frame width in pixels.

        Returns:
            Width in pixels

        Example:
            val frame = render_loop.next_frame().await?
            val w = frame.get_width()
        """
        self.width

    pub fn get_height(self) -> u32:
        """Get frame height in pixels.

        Returns:
            Height in pixels

        Example:
            val frame = render_loop.next_frame().await?
            val h = frame.get_height()
        """
        self.height

    pub fn get_image_index(self) -> u32:
        """Get swapchain image index.

        Returns:
            Image index

        Example:
            val frame = render_loop.next_frame().await?
            val idx = frame.get_image_index()
        """
        self.image_index

    pub fn is_frame_active(self) -> bool:
        """Check if frame is active (between begin and end).

        Returns:
            True if active

        Example:
            val frame = render_loop.next_frame().await?
            assert(frame.is_frame_active())
        """
        self.is_active

    pub fn aspect_ratio(self) -> f64:
        """Calculate frame aspect ratio.

        Returns:
            Width / height ratio

        Example:
            val frame = render_loop.next_frame().await?
            val ratio = frame.aspect_ratio()
        """
        (self.width as f64) / (self.height as f64)

    pub fn is_landscape(self) -> bool:
        """Check if frame is landscape orientation.

        Returns:
            True if width > height

        Example:
            val frame = render_loop.next_frame().await?
            assert(frame.is_landscape())
        """
        self.width > self.height

    pub fn is_portrait(self) -> bool:
        """Check if frame is portrait orientation.

        Returns:
            True if height > width

        Example:
            val frame = render_loop.next_frame().await?
            if frame.is_portrait():
                print("Portrait frame")
        """
        self.height > self.width

    pub fn area(self) -> u64:
        """Get frame area in pixels.

        Returns:
            Total pixel area

        Example:
            val frame = render_loop.next_frame().await?
            val pixels = frame.area()
        """
        (self.width as u64) * (self.height as u64)

    pub fn summary(self) -> text:
        """Get frame summary.

        Returns:
            Human-readable summary

        Example:
            val frame = render_loop.next_frame().await?
            print(frame.summary())
        """
        val state = if self.is_active: "active" else: "ended"
        return "Frame: {self.width}x{self.height}, image {self.image_index} ({state})"

# =============================================================================
# Frame Sync - Synchronization primitives for frame rendering
# =============================================================================

pub struct FrameSync:
    image_available: VkSemaphore
    render_finished: VkSemaphore
    fence: VkFence

impl FrameSync:
    pub fn new(device: &VulkanDevice) -> Result<FrameSync, text>:
        val image_available = device.create_semaphore()?
        val render_finished = device.create_semaphore()?
        val fence = device.create_fence(signaled: true)?  # Start signaled

        Ok(FrameSync {
            image_available: image_available,
            render_finished: render_finished,
            fence: fence,
        })

    pub async fn destroy(&self, device: &VulkanDevice):
        await device.destroy_semaphore_async(self.image_available)
        await device.destroy_semaphore_async(self.render_finished)
        await device.destroy_fence_async(self.fence)

    pub fn get_image_available(self) -> VkSemaphore:
        """Get image available semaphore.

        Returns:
            Semaphore handle

        Example:
            val sync = FrameSync.new(&device)?
            val sem = sync.get_image_available()
        """
        self.image_available

    pub fn get_render_finished(self) -> VkSemaphore:
        """Get render finished semaphore.

        Returns:
            Semaphore handle

        Example:
            val sync = FrameSync.new(&device)?
            val sem = sync.get_render_finished()
        """
        self.render_finished

    pub fn get_fence(self) -> VkFence:
        """Get in-flight fence.

        Returns:
            Fence handle

        Example:
            val sync = FrameSync.new(&device)?
            val fence = sync.get_fence()
        """
        self.fence

    pub fn is_valid(self) -> bool:
        """Check if all sync objects are valid.

        Returns:
            True if all handles are non-zero

        Example:
            val sync = FrameSync.new(&device)?
            assert(sync.is_valid())
        """
        self.image_available != 0 and self.render_finished != 0 and self.fence != 0

    pub fn summary(self) -> text:
        """Get frame sync summary.

        Returns:
            Human-readable summary

        Example:
            val sync = FrameSync.new(&device)?
            print(sync.summary())
        """
        return "FrameSync: image_avail={self.image_available}, render_done={self.render_finished}, fence={self.fence}"

# =============================================================================
# Render Loop - High-level rendering context
# =============================================================================

pub struct RenderLoop:
    device: VulkanDevice
    swapchain: Swapchain
    render_pass: RenderPass
    command_pool: CommandPool
    command_buffers: Array<CommandBuffer>
    framebuffers: Array<Framebuffer>
    frame_sync: Array<FrameSync>  # One per frame in flight
    current_frame: usize
    max_frames_in_flight: usize
    window_open: bool

impl RenderLoop:
    # Create render loop with triple buffering
    pub fn new(
        device: &VulkanDevice,
        swapchain: &Swapchain,
        render_pass: &RenderPass
    ) -> Result<RenderLoop, text>:
        val max_frames = 2  # Double buffering (can be 3 for triple)

        # Create command pool
        val command_pool = CommandPool.new(device, device.graphics_family)?

        # Create command buffers (one per frame in flight)
        var command_buffers: Array<CommandBuffer> = []
        for _ in 0..max_frames:
            command_buffers.push(command_pool.allocate()?)

        # Create framebuffers (one per swapchain image)
        var framebuffers: Array<Framebuffer> = []
        for image_view in &swapchain.image_views:
            val framebuffer = Framebuffer.new(
                device,
                render_pass,
                &[*image_view],
                swapchain.extent.width,
                swapchain.extent.height
            )?
            framebuffers.push(framebuffer)

        # Create synchronization primitives (one set per frame in flight)
        var frame_sync: Array<FrameSync> = []
        for _ in 0..max_frames:
            frame_sync.push(FrameSync.new(device)?)

        Ok(RenderLoop {
            device: device.clone(),
            swapchain: swapchain.clone(),
            render_pass: render_pass.clone(),
            command_pool: command_pool,
            command_buffers: command_buffers,
            framebuffers: framebuffers,
            frame_sync: frame_sync,
            current_frame: 0,
            max_frames_in_flight: max_frames,
            window_open: true,
        })

    # Get next frame (for while-with loop)
    pub async fn next_frame(&mut self) -> Option<Frame>:
        if !self.window_open:
            return None

        # Get current frame resources
        val sync = &self.frame_sync[self.current_frame]
        val cmd = &mut self.command_buffers[self.current_frame]

        # Try to begin frame
        val frame = match Frame.begin(
            &self.device,
            &self.swapchain,
            &self.render_pass,
            cmd,
            &self.framebuffers,
            sync
        ):
            case Ok(f): f
            case Err(e):
                # Window closed or error
                self.window_open = false
                return None

        # Advance to next frame
        self.current_frame = (self.current_frame + 1) % self.max_frames_in_flight

        Some(frame)

    # Wait for all rendering to finish
    pub async fn wait_idle(&self):
        await self.device.wait_idle_async()

    # Cleanup
    pub async fn destroy(&mut self):
        await self.wait_idle()

        for sync in &self.frame_sync:
            await sync.destroy(&self.device)

        for framebuffer in &self.framebuffers:
            await framebuffer.destroy()

        await self.command_pool.destroy()

    pub fn get_current_frame(self) -> usize:
        """Get current frame index.

        Returns:
            Frame index (0 to max_frames_in_flight-1)

        Example:
            val loop = RenderLoop.new(&device, &swapchain, &rp)?
            val idx = loop.get_current_frame()
        """
        self.current_frame

    pub fn get_max_frames(self) -> usize:
        """Get maximum frames in flight.

        Returns:
            Max frames in flight (usually 2 or 3)

        Example:
            val loop = RenderLoop.new(&device, &swapchain, &rp)?
            assert(loop.get_max_frames() == 2)
        """
        self.max_frames_in_flight

    pub fn framebuffer_count(self) -> usize:
        """Get number of framebuffers.

        Returns:
            Number of framebuffers (matches swapchain images)

        Example:
            val loop = RenderLoop.new(&device, &swapchain, &rp)?
            val count = loop.framebuffer_count()
        """
        self.framebuffers.len()

    pub fn is_window_open(self) -> bool:
        """Check if render window is still open.

        Returns:
            True if window is open

        Example:
            val loop = RenderLoop.new(&device, &swapchain, &rp)?
            assert(loop.is_window_open())
        """
        self.window_open

    pub fn is_double_buffered(self) -> bool:
        """Check if using double buffering.

        Returns:
            True if max frames is 2

        Example:
            val loop = RenderLoop.new(&device, &swapchain, &rp)?
            if loop.is_double_buffered():
                print("Double buffering enabled")
        """
        self.max_frames_in_flight == 2

    pub fn is_triple_buffered(self) -> bool:
        """Check if using triple buffering.

        Returns:
            True if max frames is 3

        Example:
            val loop = RenderLoop.new(&device, &swapchain, &rp)?
            if loop.is_triple_buffered():
                print("Triple buffering enabled")
        """
        self.max_frames_in_flight == 3

    pub fn summary(self) -> text:
        """Get render loop summary.

        Returns:
            Human-readable summary

        Example:
            val loop = RenderLoop.new(&device, &swapchain, &rp)?
            print(loop.summary())
        """
        val buffering = if self.is_double_buffered(): "double" else if self.is_triple_buffered(): "triple" else: "{self.max_frames_in_flight}x"
        val state = if self.window_open: "open" else: "closed"
        return "RenderLoop: {buffering} buffering, {self.framebuffers.len()} framebuffers, window {state}"

# =============================================================================
# Context Manager Protocol - For while-with loop
# =============================================================================

impl Frame:
    # Context manager enter
    pub fn enter(&mut self) -> &mut Frame:
        self

    # Context manager exit (automatic cleanup)
    pub async fn exit(&mut self, exception: Option<text>):
        if self.is_active:
            # End frame and present
            match await self.end():
                case Ok(_): pass
                case Err(e):
                    # Log error but don't propagate (cleanup must succeed)
                    println("Warning: Frame end failed: {e}")

impl RenderLoop:
    # Support for: while with render_loop.frame() as frame:
    pub async fn frame(&mut self) -> Option<Frame>:
        await self.next_frame()

# =============================================================================
# Supporting Types
# =============================================================================

pub struct VkPresentInfo:
    wait_semaphores: Array<VkSemaphore>
    swapchain: VkSwapchainKHR
    image_index: u32

impl VkPresentInfo:
    pub fn get_image_index(self) -> u32:
        """Get swapchain image index.

        Returns:
            Image index

        Example:
            val info = VkPresentInfo { wait_semaphores: [], swapchain: sc, image_index: 0 }
            assert(info.get_image_index() == 0)
        """
        self.image_index

    pub fn get_swapchain(self) -> VkSwapchainKHR:
        """Get swapchain handle.

        Returns:
            Swapchain handle

        Example:
            val info = VkPresentInfo { wait_semaphores: [], swapchain: sc, image_index: 0 }
            val handle = info.get_swapchain()
        """
        self.swapchain

    pub fn semaphore_count(self) -> usize:
        """Get number of wait semaphores.

        Returns:
            Semaphore count

        Example:
            val info = VkPresentInfo { wait_semaphores: [s1, s2], swapchain: sc, image_index: 0 }
            assert(info.semaphore_count() == 2)
        """
        self.wait_semaphores.len()

    pub fn has_semaphores(self) -> bool:
        """Check if has wait semaphores.

        Returns:
            True if any semaphores present

        Example:
            val info = VkPresentInfo { wait_semaphores: [s1], swapchain: sc, image_index: 0 }
            assert(info.has_semaphores())
        """
        self.wait_semaphores.len() > 0

    pub fn is_valid(self) -> bool:
        """Check if present info is valid.

        Returns:
            True if swapchain handle is non-zero

        Example:
            val info = VkPresentInfo { wait_semaphores: [], swapchain: sc, image_index: 0 }
            assert(info.is_valid())
        """
        self.swapchain != 0

    pub fn summary(self) -> text:
        """Get present info summary.

        Returns:
            Human-readable summary

        Example:
            val info = VkPresentInfo { wait_semaphores: [s1], swapchain: sc, image_index: 0 }
            print(info.summary())
        """
        return "VkPresentInfo: swapchain={self.swapchain}, image={self.image_index}, {self.semaphore_count()} semaphores"

# Add to VulkanDevice (extend existing impl)
impl VulkanDevice:
    pub fn create_semaphore(&self) -> Result<VkSemaphore, text>:
        vulkan_create_semaphore(self.device)

    pub fn create_fence(&self, signaled: bool) -> Result<VkFence, text>:
        vulkan_create_fence(self.device, signaled)

    pub fn reset_fence(&self, fence: VkFence) -> Result<(), text>:
        vulkan_reset_fence(self.device, fence)

    pub async fn destroy_semaphore_async(&self, semaphore: VkSemaphore):
        await vulkan_destroy_semaphore_async(self.device, semaphore)

    pub async fn destroy_fence_async(&self, fence: VkFence):
        await vulkan_destroy_fence_async(self.device, fence)

    pub async fn queue_present_async(&self, present_info: VkPresentInfo) -> Result<(), text>:
        await vulkan_queue_present_async(
            self.present_queue,
            &present_info.wait_semaphores,
            present_info.swapchain,
            present_info.image_index
        )

# =============================================================================
# FFI Declarations
# =============================================================================

extern fn vulkan_create_semaphore(device: VkDevice) -> Result<VkSemaphore, text>
extern fn vulkan_create_fence(device: VkDevice, signaled: bool) -> Result<VkFence, text>
extern fn vulkan_reset_fence(device: VkDevice, fence: VkFence) -> Result<(), text>
extern fn vulkan_destroy_semaphore_async(device: VkDevice, semaphore: VkSemaphore) -> Future<Result<(), text>>
extern fn vulkan_destroy_fence_async(device: VkDevice, fence: VkFence) -> Future<Result<(), text>>
extern fn vulkan_queue_present_async(queue: VkQueue, wait_semaphores: &Array<VkSemaphore>, swapchain: VkSwapchainKHR, image_index: u32) -> Future<Result<(), text>>
