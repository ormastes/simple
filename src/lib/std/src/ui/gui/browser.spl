# Browser Renderer - WebAssembly DOM Backend
#
# Renders UI elements directly to the browser DOM using async JavaScript interop.
# Demonstrates that the same Element/PatchSet API works across different backends.
#
# Key Features:
#   - Direct DOM manipulation via WASM bindings
#   - Event handling through DOM events
#   - Async rendering with requestAnimationFrame
#   - CSS styling integration
#   - Zero dependencies (pure DOM API)

use core.*
use concurrency.*
use ui.element.*
use ui.attrs.*
use ui.patchset.*
use ui.renderer.*

# =============================================================================
# Browser Async Renderer (DOM-based)
# =============================================================================

pub struct BrowserRenderer:
    # Root DOM element
    root_element_id: text

    # Element tracking
    dom_node_map: Dict<u64, DomNodeHandle>  # NodeId -> DOM element
    event_handlers: Dict<u64, EventListenerInfo>  # handler_id -> listener info for cleanup

    # Event queue for poll_event/read_event
    event_queue: Array<Event>

    # State
    initialized: bool
    window_width: u32
    window_height: u32

    # Current tree (for diffing)
    current_tree: Option<ElementTree>

impl BrowserRenderer:
    # =========================================================================
    # Helper Methods
    # =========================================================================

    pub fn is_initialized(self) -> bool:
        """Check if renderer is initialized."""
        self.initialized

    pub fn has_dom_nodes(self) -> bool:
        """Check if any DOM nodes are tracked."""
        self.dom_node_map.len() > 0

    pub fn has_event_handlers(self) -> bool:
        """Check if any event handlers are registered."""
        self.event_handlers.len() > 0

    pub fn has_current_tree(self) -> bool:
        """Check if current tree exists (for diffing)."""
        match self.current_tree:
            case Some(_): true
            case None: false

    pub fn dom_node_count(self) -> usize:
        """Get number of tracked DOM nodes."""
        self.dom_node_map.len()

    pub fn event_handler_count(self) -> usize:
        """Get number of registered event handlers."""
        self.event_handlers.len()

    pub fn width(self) -> u32:
        """Get window width."""
        self.window_width

    pub fn height(self) -> u32:
        """Get window height."""
        self.window_height

    pub fn aspect_ratio(self) -> f64:
        """Calculate window aspect ratio."""
        if self.window_height > 0:
            (self.window_width as f64) / (self.window_height as f64)
        else:
            0.0

    pub fn is_landscape(self) -> bool:
        """Check if window is landscape orientation."""
        self.window_width > self.window_height

    pub fn is_portrait(self) -> bool:
        """Check if window is portrait orientation."""
        self.window_height > self.window_width

    pub fn is_square(self) -> bool:
        """Check if window is square."""
        self.window_width == self.window_height

    pub fn summary(self) -> text:
        """Get summary of browser renderer state."""
        val status = if self.initialized: "initialized" else: "uninitialized"
        return "BrowserRenderer: root='{self.root_element_id}', {self.window_width}x{self.window_height} ({status}), {self.dom_node_count()} DOM nodes, {self.event_handler_count()} handlers"

    # =========================================================================
    # Constructor
    # =========================================================================

    # Create a new browser renderer
    pub fn new(root_element_id: &str) -> Result<BrowserRenderer, RenderError>:
        return Ok(BrowserRenderer {
            root_element_id: root_element_id.to_string(),
            dom_node_map: Dict.new(),
            event_handlers: Dict.new(),
            event_queue: Array.new(),
            initialized: false,
            window_width: 0,
            window_height: 0,
            current_tree: None
        })

# =============================================================================
# Async RenderBackend Implementation
# =============================================================================

impl RenderBackend for BrowserRenderer:
    async fn init(self) -> Future<Result<(), RenderError>>:
        if self.initialized:
            return Future.ready(Err(RenderError.AlreadyInitialized))

        # Get root element from DOM
        val root_exists = await browser_element_exists(&self.root_element_id)
        if not root_exists:
            return Future.ready(Err(RenderError.IoError(
                "Root element '#{self.root_element_id}' not found in DOM"
            )))

        # Get initial window dimensions
        val (width, height) = await browser_get_window_size()
        self.window_width = width
        self.window_height = height

        # Set up resize listener
        await browser_add_resize_listener(|w, h| {
            self.window_width = w
            self.window_height = h
            # Push resize event to queue
            self.push_event(Event.Resize { width: w as u16, height: h as u16 })
        })

        self.initialized = true
        return Future.ready(Ok(()))

    async fn shutdown(self) -> Future<Result<(), RenderError>>:
        if not self.initialized:
            return Future.ready(Err(RenderError.NotInitialized))

        # Remove event listeners before clearing DOM
        for (_, listener_info) in &self.event_handlers:
            await browser_remove_event_listener(listener_info.dom_handle, &listener_info.event_name)

        # Remove resize listener
        await browser_remove_resize_listener()

        # Clear DOM
        await browser_clear_element(&self.root_element_id)

        self.dom_node_map.clear()
        self.event_handlers.clear()
        self.initialized = false

        return Future.ready(Ok(()))

    fn dimensions() -> (u16, u16):
        return (self.window_width as u16, self.window_height as u16)

    # Render element tree to DOM
    async fn render(self, tree: &ElementTree) -> Future<Result<(), RenderError>>:
        if not self.initialized:
            return Future.ready(Err(RenderError.NotInitialized))

        # Check if we have a previous tree for diffing
        match &self.current_tree:
            case Some(old_tree):
                # Incremental update via patches
                val patches = diff(old_tree.root(), tree.root())
                await self.apply_patches_internal(&patches)
            case None:
                # Initial render - build entire DOM tree
                await self.render_initial(tree)

        # Store current tree for next diff
        self.current_tree = Some(tree.clone())

        return Future.ready(Ok(()))

    # Apply patches incrementally
    async fn apply_patches(self, patches: &PatchSet) -> Future<Result<(), RenderError>>:
        if not self.initialized:
            return Future.ready(Err(RenderError.NotInitialized))

        await self.apply_patches_internal(patches)

        return Future.ready(Ok(()))

    async fn clear(self) -> Future<Result<(), RenderError>>:
        if not self.initialized:
            return Future.ready(Err(RenderError.NotInitialized))

        # Clear root element in DOM
        await browser_clear_element(&self.root_element_id)
        self.dom_node_map.clear()
        self.current_tree = None

        return Future.ready(Ok(()))

    async fn flush(self) -> Future<Result<(), RenderError>>:
        # Browser automatically flushes on requestAnimationFrame
        # Nothing to do here
        return Future.ready(Ok(()))

    # Poll DOM events
    async fn poll_event(self, timeout_ms: u64) -> Future<Result<Option<Event>, RenderError>>:
        if not self.initialized:
            return Future.ready(Err(RenderError.NotInitialized))

        # Check if there's already an event in the queue
        if self.event_queue.len() > 0:
            val event = self.event_queue.remove(0)
            return Future.ready(Ok(Some(event)))

        # Wait for events with timeout using browser's event loop
        val start_time = browser_get_time_ms()
        loop:
            # Process any pending browser events
            await browser_process_events()

            # Check queue again after processing
            if self.event_queue.len() > 0:
                val event = self.event_queue.remove(0)
                return Future.ready(Ok(Some(event)))

            # Check timeout
            val elapsed = browser_get_time_ms() - start_time
            if elapsed >= timeout_ms:
                return Future.ready(Ok(None))

            # Yield to event loop briefly
            await sleep_async(10)

    async fn read_event(self) -> Future<Result<Event, RenderError>>:
        # Block until event arrives
        loop:
            match await self.poll_event(1000):
                case Ok(Some(event)): return Future.ready(Ok(event))
                case Ok(None): pass
                case Err(e): return Future.ready(Err(e))

# =============================================================================
# Internal Implementation
# =============================================================================

impl BrowserRenderer:
    # Initial render - build entire DOM tree
    async fn render_initial(self, tree: &ElementTree) -> Future<()>:
        # Clear root
        await browser_clear_element(&self.root_element_id)

        # Render root element and children
        val root_dom = await self.render_element_to_dom(tree.root(), None)

        # Append to root container
        await browser_append_child(&self.root_element_id, root_dom)

        return Future.ready(())

    # Render single element to DOM node
    async fn render_element_to_dom(self, elem: &Element, parent_handle: Option<DomNodeHandle>)
        -> Future<DomNodeHandle>:
        # Create DOM element
        val tag_name = elem.kind.tag_name()
        val dom_handle = await browser_create_element(tag_name)

        # Store mapping
        self.dom_node_map.set(elem.id.value(), dom_handle)

        # Set ID attribute
        await browser_set_attribute(dom_handle, "id", &"sui-{elem.id.value()}")

        # Set data attribute for tracking
        await browser_set_attribute(dom_handle, "data-sui-id", &elem.id.value().to_string())

        # Set key if present
        if val Some(key) = &elem.key:
            await browser_set_attribute(dom_handle, "data-key", key)

        # Set classes
        if not elem.classes.is_empty():
            await browser_set_attribute(dom_handle, "class", &elem.classes.join(" "))

        # Set attributes
        for (name, value) in &elem.attrs:
            await browser_set_attribute(dom_handle, name, value)

        # Set inline styles
        if not elem.styles.is_empty():
            val style_str = elem.styles.iter()
                .map(|(k, v)| "{k}: {v}")
                .join("; ")
            await browser_set_attribute(dom_handle, "style", &style_str)

        # Set text content
        if val Some(text) = &elem.text:
            await browser_set_text_content(dom_handle, text)

        # Set tab index
        if val Some(idx) = elem.tab_index:
            await browser_set_attribute(dom_handle, "tabindex", &idx.to_string())

        # Add event listeners
        for (event_name, handler_id) in &elem.events:
            await self.add_event_listener(dom_handle, elem.id, event_name, handler_id)

        # Render children
        for child in &elem.children:
            val child_dom = await self.render_element_to_dom(child, Some(dom_handle))
            await browser_append_child_handle(dom_handle, child_dom)

        return Future.ready(dom_handle)

    # Apply patch set to DOM
    async fn apply_patches_internal(self, patches: &PatchSet) -> Future<()>:
        for patch in patches.iter():
            match patch:
                case PatchOp.SetText { node_id, text }:
                    if val Some(handle) = self.dom_node_map.get(&node_id.value()):
                        await browser_set_text_content(handle, &text)

                case PatchOp.SetAttr { node_id, name, value }:
                    if val Some(handle) = self.dom_node_map.get(&node_id.value()):
                        await browser_set_attribute(handle, &name, &value)

                case PatchOp.RemoveAttr { node_id, name }:
                    if val Some(handle) = self.dom_node_map.get(&node_id.value()):
                        await browser_remove_attribute(handle, &name)

                case PatchOp.AddClass { node_id, class }:
                    if val Some(handle) = self.dom_node_map.get(&node_id.value()):
                        await browser_add_class(handle, &class)

                case PatchOp.RemoveClass { node_id, class }:
                    if val Some(handle) = self.dom_node_map.get(&node_id.value()):
                        await browser_remove_class(handle, &class)

                case PatchOp.SetStyle { node_id, property, value }:
                    if val Some(handle) = self.dom_node_map.get(&node_id.value()):
                        await browser_set_style(handle, &property, &value)

                case PatchOp.RemoveStyle { node_id, property }:
                    if val Some(handle) = self.dom_node_map.get(&node_id.value()):
                        await browser_remove_style(handle, &property)

                case PatchOp.InsertChild { parent_id, index, element }:
                    if val Some(parent_handle) = self.dom_node_map.get(&parent_id.value()):
                        val child_dom = await self.render_element_to_dom(&element, Some(parent_handle))
                        await browser_insert_child_at(parent_handle, child_dom, index)

                case PatchOp.RemoveChild { parent_id, child_id }:
                    if val Some(child_handle) = self.dom_node_map.get(&child_id.value()):
                        await browser_remove_child(child_handle)
                        self.dom_node_map.remove(&child_id.value())

                case PatchOp.ReplaceSubtree { node_id, element }:
                    if val Some(old_handle) = self.dom_node_map.get(&node_id.value()):
                        val new_handle = await self.render_element_to_dom(&element, None)
                        await browser_replace_node(old_handle, new_handle)
                        self.dom_node_map.remove(&node_id.value())

                case PatchOp.SetFocus { node_id }:
                    if val Some(handle) = self.dom_node_map.get(&node_id.value()):
                        await browser_focus_element(handle)

                case PatchOp.ClearFocus { node_id }:
                    if val Some(handle) = self.dom_node_map.get(&node_id.value()):
                        await browser_blur_element(handle)

                case _:
                    # Other patch operations
                    pass

        return Future.ready(())

    # Add event listener to DOM element
    async fn add_event_listener(self, dom_handle: DomNodeHandle, node_id: NodeId,
                                 event_name: &str, handler_id: u64) -> Future<()>:
        # Create callback that converts DOM event to UI Event
        val renderer = self
        val callback = |dom_event: DomEvent| {
            val ui_event = renderer.convert_dom_event(dom_event)
            renderer.dispatch_event(node_id, handler_id, ui_event)
        }

        # Register with DOM
        await browser_add_event_listener(dom_handle, event_name, callback)

        # Store listener info for cleanup
        self.event_handlers.set(handler_id, EventListenerInfo {
            dom_handle: dom_handle,
            event_name: event_name.to_string(),
            callback: callback
        })

        return Future.ready(())

    fn convert_dom_event(dom_event: DomEvent) -> Event:
        val modifiers = KeyModifiers {
            shift: dom_event.shift_key,
            ctrl: dom_event.ctrl_key,
            alt: dom_event.alt_key
        }

        match dom_event.event_type:
            # Keyboard events
            case "keydown" | "keyup" | "keypress":
                return Event.Key(KeyEvent {
                    code: parse_key_code(dom_event.key),
                    modifiers: modifiers
                })

            # Mouse click events
            case "click" | "mousedown" | "mouseup" | "dblclick":
                return Event.Mouse(MouseEvent {
                    kind: parse_mouse_event_kind(dom_event.event_type),
                    column: dom_event.client_x as u16,
                    row: dom_event.client_y as u16,
                    modifiers: modifiers
                })

            # Mouse movement events
            case "mousemove" | "mouseenter" | "mouseleave" | "mouseover" | "mouseout":
                return Event.Mouse(MouseEvent {
                    kind: MouseEventKind.Moved,
                    column: dom_event.client_x as u16,
                    row: dom_event.client_y as u16,
                    modifiers: modifiers
                })

            # Scroll/wheel events
            case "wheel" | "scroll":
                return Event.Mouse(MouseEvent {
                    kind: MouseEventKind.ScrollDown,  # Direction determined by delta
                    column: dom_event.client_x as u16,
                    row: dom_event.client_y as u16,
                    modifiers: modifiers
                })

            # Window/document events
            case "resize":
                return Event.Resize {
                    width: dom_event.width as u16,
                    height: dom_event.height as u16
                }

            # Focus events - mapped to FocusGained/FocusLost
            case "focus" | "focusin":
                return Event.FocusGained

            case "blur" | "focusout":
                return Event.FocusLost

            # Default fallback
            case _:
                return Event.Key(KeyEvent { code: KeyCode.Null, modifiers: KeyModifiers.none() })

    fn dispatch_event(node_id: NodeId, handler_id: u64, event: Event):
        # Push event to queue for poll_event/read_event
        self.push_event(event.clone())

        # Dispatch to global event bus if available for application-level handling
        if val Some(bus) = get_global_event_bus():
            bus.dispatch(EventMessage {
                source_node: node_id,
                handler_id: handler_id,
                event: event
            })

    # Push an event to the queue for poll_event/read_event
    pub fn push_event(&mut self, event: Event):
        self.event_queue.push(event)

    # Clear all pending events from the queue
    pub fn clear_events(&mut self):
        self.event_queue.clear()

    # Check if there are pending events
    pub fn has_pending_events(self) -> bool:
        self.event_queue.len() > 0

    # Get number of pending events
    pub fn pending_event_count(self) -> usize:
        self.event_queue.len()

# =============================================================================
# Browser DOM API (WASM FFI)
# =============================================================================

# DOM node handle (opaque pointer to JavaScript object)
type DomNodeHandle = i64

struct DomEvent:
    event_type: text
    key: text
    shift_key: bool
    ctrl_key: bool
    alt_key: bool
    client_x: i32
    client_y: i32
    width: u32
    height: u32

impl DomEvent:
    # =========================================================================
    # Helper Methods
    # =========================================================================

    pub fn is_keyboard_event(self) -> bool:
        """Check if this is a keyboard event."""
        self.event_type == "keydown" or self.event_type == "keyup" or self.event_type == "keypress"

    pub fn is_mouse_event(self) -> bool:
        """Check if this is a mouse event."""
        self.event_type == "click" or self.event_type == "mousedown" or self.event_type == "mouseup" or self.event_type == "mousemove"

    pub fn is_resize_event(self) -> bool:
        """Check if this is a resize event."""
        self.event_type == "resize"

    pub fn is_click_event(self) -> bool:
        """Check if this is a click event."""
        self.event_type == "click"

    pub fn has_modifiers(self) -> bool:
        """Check if any modifier keys are pressed."""
        self.shift_key or self.ctrl_key or self.alt_key

    pub fn has_shift(self) -> bool:
        """Check if Shift key is pressed."""
        self.shift_key

    pub fn has_ctrl(self) -> bool:
        """Check if Ctrl key is pressed."""
        self.ctrl_key

    pub fn has_alt(self) -> bool:
        """Check if Alt key is pressed."""
        self.alt_key

    pub fn mouse_position(self) -> (i32, i32):
        """Get mouse position as tuple."""
        (self.client_x, self.client_y)

    pub fn window_size(self) -> (u32, u32):
        """Get window size as tuple."""
        (self.width, self.height)

    pub fn summary(self) -> text:
        """Get summary of DOM event."""
        val modifiers = []
        if self.shift_key: modifiers.push("Shift")
        if self.ctrl_key: modifiers.push("Ctrl")
        if self.alt_key: modifiers.push("Alt")
        val mod_str = if modifiers.len() > 0: " + " + modifiers.join("+") else: ""
        return "DomEvent: {self.event_type}{mod_str}, pos=({self.client_x}, {self.client_y})"

type EventCallback = fn(DomEvent) -> ()

# Tracks registered event listener info for cleanup
struct EventListenerInfo:
    dom_handle: DomNodeHandle
    event_name: text
    callback: EventCallback

# Event message for event bus dispatching
struct EventMessage:
    source_node: NodeId
    handler_id: u64
    event: Event

# Global event bus for application-level event handling
struct EventBus:
    handlers: Dict<u64, fn(EventMessage) -> ()>

impl EventBus:
    fn dispatch(self, msg: EventMessage):
        if val Some(handler) = self.handlers.get(&msg.handler_id):
            handler(msg)

# Global event bus singleton
static mut GLOBAL_EVENT_BUS: Option<EventBus> = None

fn get_global_event_bus() -> Option<&mut EventBus>:
    unsafe:
        return GLOBAL_EVENT_BUS.as_mut()

fn init_global_event_bus():
    unsafe:
        GLOBAL_EVENT_BUS = Some(EventBus {
            handlers: Dict.new()
        })

fn register_event_handler(handler_id: u64, handler: fn(EventMessage) -> ()):
    unsafe:
        if val Some(bus) = GLOBAL_EVENT_BUS.as_mut():
            bus.handlers.set(handler_id, handler)

# Browser API functions (implemented via WASM imports)
# These would be implemented in JavaScript and imported

# Element queries
extern async fn browser_element_exists(id: &str) -> Future<bool>
extern async fn browser_get_window_size() -> Future<(u32, u32)>

# Element creation and manipulation
extern async fn browser_create_element(tag_name: &str) -> Future<DomNodeHandle>
extern async fn browser_clear_element(id: &str) -> Future<()>
extern async fn browser_append_child(parent_id: &str, child_handle: DomNodeHandle) -> Future<()>
extern async fn browser_append_child_handle(parent_handle: DomNodeHandle, child_handle: DomNodeHandle) -> Future<()>
extern async fn browser_insert_child_at(parent_handle: DomNodeHandle, child_handle: DomNodeHandle, index: u64) -> Future<()>
extern async fn browser_remove_child(child_handle: DomNodeHandle) -> Future<()>
extern async fn browser_replace_node(old_handle: DomNodeHandle, new_handle: DomNodeHandle) -> Future<()>

# Attributes and properties
extern async fn browser_set_attribute(handle: DomNodeHandle, name: &str, value: &str) -> Future<()>
extern async fn browser_remove_attribute(handle: DomNodeHandle, name: &str) -> Future<()>
extern async fn browser_set_text_content(handle: DomNodeHandle, text: &str) -> Future<()>

# Classes
extern async fn browser_add_class(handle: DomNodeHandle, class: &str) -> Future<()>
extern async fn browser_remove_class(handle: DomNodeHandle, class: &str) -> Future<()>

# Styles
extern async fn browser_set_style(handle: DomNodeHandle, property: &str, value: &str) -> Future<()>
extern async fn browser_remove_style(handle: DomNodeHandle, property: &str) -> Future<()>

# Focus
extern async fn browser_focus_element(handle: DomNodeHandle) -> Future<()>
extern async fn browser_blur_element(handle: DomNodeHandle) -> Future<()>

# Events
extern async fn browser_add_event_listener(handle: DomNodeHandle, event_name: &str, callback: EventCallback) -> Future<()>
extern async fn browser_remove_event_listener(handle: DomNodeHandle, event_name: &str) -> Future<()>
extern async fn browser_add_resize_listener(callback: fn(u32, u32) -> ()) -> Future<()>
extern async fn browser_remove_resize_listener() -> Future<()>

# Timing and event loop
extern fn browser_get_time_ms() -> u64
extern async fn browser_process_events() -> Future<()>

# Utilities
fn parse_key_code(key: &str) -> KeyCode:
    match key:
        # Navigation keys
        case "Enter": return KeyCode.Enter
        case "Escape": return KeyCode.Escape
        case "Backspace": return KeyCode.Backspace
        case "Tab": return KeyCode.Tab
        case "ArrowUp": return KeyCode.Up
        case "ArrowDown": return KeyCode.Down
        case "ArrowLeft": return KeyCode.Left
        case "ArrowRight": return KeyCode.Right

        # Editing keys
        case "Delete": return KeyCode.Delete
        case "Insert": return KeyCode.Insert
        case "Home": return KeyCode.Home
        case "End": return KeyCode.End
        case "PageUp": return KeyCode.PageUp
        case "PageDown": return KeyCode.PageDown

        # Function keys
        case "F1": return KeyCode.F(1)
        case "F2": return KeyCode.F(2)
        case "F3": return KeyCode.F(3)
        case "F4": return KeyCode.F(4)
        case "F5": return KeyCode.F(5)
        case "F6": return KeyCode.F(6)
        case "F7": return KeyCode.F(7)
        case "F8": return KeyCode.F(8)
        case "F9": return KeyCode.F(9)
        case "F10": return KeyCode.F(10)
        case "F11": return KeyCode.F(11)
        case "F12": return KeyCode.F(12)

        # Whitespace
        case " ": return KeyCode.Char(' ')

        # Single character keys
        case _:
            if key.len() == 1:
                return KeyCode.Char(key.chars().next().unwrap())
            return KeyCode.Null

fn parse_mouse_event_kind(event_type: &str) -> MouseEventKind:
    match event_type:
        case "mousedown": return MouseEventKind.Down(MouseButton.Left)
        case "mouseup": return MouseEventKind.Up(MouseButton.Left)
        case "click": return MouseEventKind.Down(MouseButton.Left)
        case "dblclick": return MouseEventKind.Down(MouseButton.Left)  # Double-click
        case "contextmenu": return MouseEventKind.Down(MouseButton.Right)
        case _: return MouseEventKind.Moved
