# SUI - Simple UI Framework
#
# Declarative UI framework inspired by SwiftUI and React. Provides a reactive,
# state-driven approach to building user interfaces with clean, composable syntax.
#
# Key Features:
#   - Declarative syntax using function call syntax
#   - Reactive state management with automatic re-rendering
#   - Built-in layout system (flexbox-style)
#   - Composable widgets
#   - Theme support
#   - Multiple backend support (Vulkan, HTML, Native)
#   - Hot reload support
#
# Architecture:
#   ┌─────────────────────────────────────┐
#   │         Application Code            │
#   │  (SUI declarative views)            │
#   └─────────────────────────────────────┘
#                │
#                ▼
#   ┌─────────────────────────────────────┐
#   │          SUI Runtime                │
#   │  • State management                 │
#   │  • Change detection                 │
#   │  • Layout calculation               │
#   └─────────────────────────────────────┘
#                │
#       ┌────────┴────────┐
#       ▼                 ▼
#   ┌─────────┐    ┌──────────────┐
#   │ Element │    │ RenderBackend│
#   │  Tree   │    │ (Vulkan/Web) │
#   └─────────┘    └──────────────┘
#
# Usage:
#   import ui.sui.*
#
#   struct CounterApp:
#       count: State[i32]
#
#   impl View for CounterApp:
#       fn body(self) -> Element:
#           return VStack([
#               Text("Count: {self.count.get()}"),
#               Button("Increment", on_click: || {
#                   self.count.set(self.count.get() + 1)
#               }),
#               Button("Decrement", on_click: || {
#                   self.count.set(self.count.get() - 1)
#               })
#           ])
#
#   async fn main():
#       val app = SUIApp.new(
#           title: "Counter",
#           width: 400,
#           height: 300,
#           backend: :vulkan
#       )
#       app.run(CounterApp { count: State.new(0) })

use core.*
use concurrency.*
use ui.element.*
use ui.renderer.*

# =============================================================================
# State Management
# =============================================================================

# Reactive state container
pub struct State<T>:
    value: T
    listeners: Array<fn(T)>

impl<T> State<T>:
    # Create new state with initial value
    pub fn new(initial: T) -> State<T>:
        return State {
            value: initial,
            listeners: Array.new()
        }

    # Get current value
    pub fn get(self) -> T:
        return self.value

    # Set value and notify listeners
    pub fn set(self, new_value: T):
        self.value = new_value
        for listener in &self.listeners:
            listener(new_value)

    # Subscribe to value changes
    pub fn subscribe(self, listener: fn(T)):
        self.listeners.push(listener)

    # Map state to new state
    pub fn map<U>(self, f: fn(T) -> U) -> State<U>:
        val mapped = State.new(f(self.value))
        self.subscribe(|v| mapped.set(f(v)))
        return mapped

# Computed state (derived from other states)
pub struct Computed<T>:
    compute: fn() -> T
    cache: Option<T>

impl<T> Computed<T>:
    pub fn new(compute: fn() -> T) -> Computed<T>:
        return Computed {
            compute: compute,
            cache: None
        }

    pub fn get(self) -> T:
        if val Some(cached) = &self.cache:
            return cached.clone()
        val value = (self.compute)()
        self.cache = Some(value.clone())
        return value

    pub fn invalidate(self):
        self.cache = None

# =============================================================================
# View Protocol
# =============================================================================

# View trait - all SUI components implement this
pub trait View:
    fn body() -> Element

# =============================================================================
# Layout Containers
# =============================================================================

# Vertical stack
pub fn VStack(children: Array<Element>) -> Element:
    return div([("class", "vstack")], children)

# Horizontal stack
pub fn HStack(children: Array<Element>) -> Element:
    return div([("class", "hstack")], children)

# Z-stack (overlapping layers)
pub fn ZStack(children: Array<Element>) -> Element:
    return div([("class", "zstack")], children)

# Spacer (flexible space)
pub fn Spacer() -> Element:
    return div([("class", "spacer")], [])

# Padding modifier
pub fn Padding(child: Element, amount: f32) -> Element:
    return div([("style", "padding: {amount}px")], [child])

# Frame modifier (explicit size)
pub fn Frame(child: Element, width: Option<f32>, height: Option<f32>) -> Element:
    var style = text.new()
    if val Some(w) = width:
        style.push_str("width: {w}px; ")
    if val Some(h) = height:
        style.push_str("height: {h}px; ")
    return div([("style", style)], [child])

# =============================================================================
# Built-in Widgets
# =============================================================================

# Text widget
pub fn Text(content: &str) -> Element:
    return span([], [content])

# Styled text
pub fn Text_styled(content: &str, font_size: f32, color: &str) -> Element:
    return span([
        ("style", "font-size: {font_size}px; color: {color};")
    ], [content])

# Button widget
pub fn Button(label: &str, on_click: fn()) -> Element:
    return button([("on_click", on_click)], [label])

# TextField widget
pub struct TextField:
    placeholder: text
    value: State<text>
    on_change: fn(text)

pub fn TextField_new(
    placeholder: &str,
    value: State<text>,
    on_change: fn(text)
) -> TextField:
    return TextField {
        placeholder: placeholder.to_string(),
        value: value,
        on_change: on_change
    }

impl View for TextField:
    fn body() -> Element:
        return input([
            ("placeholder", self.placeholder),
            ("value", self.value.get()),
            ("on_input", |new_val| {
                self.value.set(new_val)
                (self.on_change)(new_val)
            })
        ], [])

# Toggle switch
pub struct Toggle:
    is_on: State[bool]
    label: text
    on_change: fn(bool)

pub fn Toggle_new(label: &str, is_on: State[bool], on_change: fn(bool)) -> Toggle:
    return Toggle {
        label: label.to_string(),
        is_on: is_on,
        on_change: on_change
    }

impl View for Toggle:
    fn body() -> Element:
        return HStack(<
            Text(&self.label),
            div([
                ("class", if self.is_on.get() { "toggle-on" } else { "toggle-off" }),
                ("on_click", || {
                    val new_val = !self.is_on.get()
                    self.is_on.set(new_val)
                    (self.on_change)(new_val)
                })
            ], [])
        >)

# List widget
pub fn List<T>(items: Array<T>, item_builder: fn(T) -> Element) -> Element:
    var children: Array<Element> = []
    for item in items:
        children.push(item_builder(item))
    return VStack(children)

# Image widget
pub fn Image(src: &str, width: f32, height: f32) -> Element:
    return img([
        ("src", src),
        ("width", "{width}"),
        ("height", "{height}")
    ], [])

# =============================================================================
# Modifiers
# =============================================================================

# Background color modifier
pub fn background(elem: Element, color: &str) -> Element:
    elem.styles.insert("background-color", color)
    return elem

# Foreground color modifier
pub fn foreground(elem: Element, color: &str) -> Element:
    elem.styles.insert("color", color)
    return elem

# Font size modifier
pub fn font_size(elem: Element, size: f32) -> Element:
    elem.styles.insert("font-size", "{size}px")
    return elem

# Font weight modifier
pub fn bold(elem: Element) -> Element:
    elem.classes.push("bold")
    return elem

# Corner radius modifier
pub fn corner_radius(elem: Element, radius: f32) -> Element:
    elem.styles.insert("border-radius", "{radius}px")
    return elem

# Shadow modifier
pub fn shadow(elem: Element, radius: f32, opacity: f32) -> Element:
    elem.styles.insert("box-shadow", "0 0 {radius}px rgba(0,0,0,{opacity})")
    return elem

# =============================================================================
# SUI Application
# =============================================================================

pub struct SUIApp:
    title: text
    width: u32
    height: u32
    backend_type: BackendType
    renderer: Option<Box<RenderBackend>>
    root_view: Option<Box<View>>
    state_version: u64  # For change detection

pub enum BackendType:
    Vulkan
    Html
    Native

impl BackendType:
    pub fn to_string(self) -> text:
        """Convert backend type to string."""
        match self:
            case Vulkan: "Vulkan"
            case Html: "Html"
            case Native: "Native"

    pub fn description(self) -> text:
        """Get backend type description."""
        match self:
            case Vulkan: "Vulkan GPU-accelerated rendering backend"
            case Html: "HTML/CSS web-based rendering backend"
            case Native: "Native platform rendering backend"

    pub fn is_vulkan(self) -> bool:
        """Check if backend type is Vulkan."""
        match self:
            case Vulkan: true
            case _: false

    pub fn is_html(self) -> bool:
        """Check if backend type is Html."""
        match self:
            case Html: true
            case _: false

    pub fn is_native(self) -> bool:
        """Check if backend type is Native."""
        match self:
            case Native: true
            case _: false

    pub fn is_gpu_accelerated(self) -> bool:
        """Check if backend uses GPU acceleration."""
        match self:
            case Vulkan: true
            case _: false

    pub fn is_web_backend(self) -> bool:
        """Check if backend is web-based."""
        match self:
            case Html: true
            case _: false

    pub fn is_desktop_backend(self) -> bool:
        """Check if backend is desktop-based."""
        match self:
            case Vulkan: true
            case Native: true
            case _: false

    pub fn requires_gpu(self) -> bool:
        """Check if backend requires dedicated GPU."""
        match self:
            case Vulkan: true
            case _: false

    pub fn summary(self) -> text:
        """Get backend type summary."""
        val name = self.to_string()
        val desc = self.description()
        var props = []
        if self.is_gpu_accelerated():
            props.push("GPU-accelerated")
        if self.is_web_backend():
            props.push("web")
        if self.is_desktop_backend():
            props.push("desktop")
        if self.requires_gpu():
            props.push("requires-GPU")
        if props.len() > 0:
            val props_str = ", ".join(props)
            return "BackendType: {name} ({desc}, {props_str})"
        else:
            return "BackendType: {name} ({desc})"

impl SUIApp:
    # Create new SUI application
    pub fn new(title: &str, width: u32, height: u32, backend: BackendType) -> SUIApp:
        return SUIApp {
            title: title.to_string(),
            width: width,
            height: height,
            backend_type: backend,
            renderer: None,
            root_view: None,
            state_version: 0
        }

    # Initialize the application
    pub async fn init(self) -> Result<(), RenderError>:
        # Create renderer based on backend type
        val renderer: Box<RenderBackend> = match self.backend_type:
            case BackendType.Vulkan:
                # Will be created by sui_vulkan.spl
                return Err(RenderError.IoError(
                    "Vulkan backend requires sui_vulkan module"
                ))
            case BackendType.Html:
                Box.new(HtmlRenderer.new()?)
            case BackendType.Native:
                Box.new(NativeRenderer.new(self.width, self.height)?)

        # Initialize renderer
        await renderer.init()

        self.renderer = Some(renderer)
        return Ok(())

    # Set root view
    pub fn set_root<V: View>(self, view: V):
        self.root_view = Some(Box.new(view))

    # Run the application event loop
    pub async fn run<V: View>(self, root_view: V):
        self.set_root(root_view)

        # Initialize
        await self.init()?

        # Main event loop
        loop:
            # Render current view
            if val Some(view) = &self.root_view:
                val elem_tree = view.body()
                await self.renderer.as_ref().unwrap().render(&elem_tree)?
            }

            # Handle events
            if val Some(renderer) = &self.renderer:
                match renderer.poll_event(16):
                    case Some(Event.CloseRequested):
                        break
                    case Some(event):
                        # Handle event
                        self.handle_event(event)
                    case None:
                        pass
            }

            # Sleep briefly
            await Future.delay(16)  # ~60 FPS

        # Shutdown
        await self.renderer.as_ref().unwrap().shutdown()

    # Handle UI events
    fn handle_event(event: Event):
        # Dispatch to appropriate view component
        # (In full implementation, would route to specific element handlers)
        match event:
            case Event.Key(key_event):
                # Handle keyboard input
                pass
            case Event.Mouse(mouse_event):
                # Handle mouse input
                pass
            case _:
                pass

# =============================================================================
# Example Views
# =============================================================================

# Example: Counter app
#
# struct CounterApp:
#     count: State[i32]
#
# impl View for CounterApp:
#     fn body(self) -> Element:
#         return VStack([
#             Text("Count: {self.count.get()}")
#                 |> font_size(24.0)
#                 |> bold(),
#             HStack([
#                 Button("-", on_click: || self.count.set(self.count.get() - 1)),
#                 Spacer(),
#                 Button("+", on_click: || self.count.set(self.count.get() + 1))
#             ]),
#         ])
#         |> Padding(20.0)
#         |> background("#f0f0f0")
#         |> corner_radius(8.0)
#
# async fn main():
#     val app = SUIApp.new("Counter", 400, 300, BackendType.Vulkan)
#     await app.run(CounterApp { count: State.new(0) })

# Example: Todo list app
#
# struct TodoItem:
#     id: u64
#     text: text
#     completed: bool
#
# struct TodoApp:
#     todos: State<Array<TodoItem>>
#     input: State<text>
#
# impl View for TodoApp:
#     fn body(self) -> Element:
#         return VStack([
#             # Title
#             Text("Todo List")
#                 |> font_size(32.0)
#                 |> bold(),
#
#             # Input field
#             HStack([
#                 TextField_new(
#                     "Enter todo...",
#                     self.input,
#                     |_| {}
#                 ).body(),
#                 Button("Add", on_click: || self.add_todo())
#             ]),
#
#             # Todo list
#             List(self.todos.get(), |todo| {
#                 HStack([
#                     Toggle_new(
#                         &todo.text,
#                         State.new(todo.completed),
#                         |completed| {
#                             # Update todo
#                         }
#                     ).body(),
#                     Spacer(),
#                     Button("Delete", on_click: || {
#                         # Delete todo
#                     })
#                 ])
#             })
#         ])
#         |> Padding(20.0)
#
# impl TodoApp:
#     fn add_todo(self):
#         val text = self.input.get()
#         if text.is_empty():
#             return
#
#         var todos = self.todos.get()
#         todos.push(TodoItem {
#             id: todos.len() as u64,
#             text: text,
#             completed: false
#         })
#         self.todos.set(todos)
#         self.input.set(text.new())
