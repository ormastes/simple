# Ratatui FFI Bindings for Simple TUI Framework
#
# Provides Simple language bindings to the Ratatui terminal UI framework.
# Ratatui is a modern, thread-safe (Send + Sync) terminal UI library.
#
# Architecture:
#   Simple Apps → Simple TUI → Ratatui FFI (this file) → Rust Ratatui → Crossterm → Terminal
#
# Features:
#   - Thread-safe terminal management
#   - Multi-line text buffer editing
#   - Immediate-mode rendering
#   - Cross-platform event handling
#
# References:
#   - Rust FFI: src/runtime/src/value/ratatui_tui.rs
#   - Spec: doc/spec/tui.md

import units.time::Milliseconds

# ============================================================================
# Type Definitions
# ============================================================================

## Opaque handle to a Ratatui terminal
pub type TerminalHandle = u64

## Opaque handle to a text buffer
pub type TextBufferHandle = u64

## Event type enumeration
pub enum EventType:
    Key
    Mouse
    Resize

impl EventType:
    pub fn is_key(self) -> bool:
        """Check if this is a Key event.
        Returns: true for Key
        Example: EventType.Key.is_key()  # → true
        """
        match self:
            case Key: true
            case _: false

    pub fn is_mouse(self) -> bool:
        """Check if this is a Mouse event.
        Returns: true for Mouse
        Example: EventType.Mouse.is_mouse()  # → true
        """
        match self:
            case Mouse: true
            case _: false

    pub fn is_resize(self) -> bool:
        """Check if this is a Resize event.
        Returns: true for Resize
        Example: EventType.Resize.is_resize()  # → true
        """
        match self:
            case Resize: true
            case _: false

    pub fn is_input_event(self) -> bool:
        """Check if this is an input event (key or mouse).
        Returns: true for Key or Mouse
        Example: EventType.Key.is_input_event()  # → true
        """
        match self:
            case Key: true
            case Mouse: true
            case Resize: false

    pub fn to_string(self) -> text:
        """Convert EventType to string representation.
        Returns: lowercase event name
        Example: EventType.Key.to_string()  # → "key"
        """
        match self:
            case Key: "key"
            case Mouse: "mouse"
            case Resize: "resize"

    pub fn description(self) -> text:
        """Get human-readable description of the event type.
        Returns: descriptive explanation
        Example: EventType.Resize.description()  # → "Terminal resize event"
        """
        match self:
            case Key: "Keyboard event"
            case Mouse: "Mouse event"
            case Resize: "Terminal resize event"

    pub fn summary(self) -> text:
        """Get comprehensive summary of the event type.
        Returns: summary with name, description, and category
        Example: EventType.Key.summary()
                # → "EventType: key (Keyboard event, input event)"
        """
        val name = self.to_string()
        val desc = self.description()
        val category = if self.is_input_event():
            ", input event"
        else:
            ", terminal event"

        "EventType: {name} ({desc}{category})"

## Terminal event structure
##
## Represents a keyboard, mouse, or resize event from the terminal.
## Maps to the C struct TuiEvent from ratatui_tui.rs.
pub struct TuiEvent:
    pub event_type: u32    # EventType value
    pub key_code: u32      # ASCII or special key code
    pub key_mods: u32      # Modifier flags (Shift=1, Ctrl=2, Alt=4)
    pub char_value: u32    # Unicode character (if printable)

# ============================================================================
# FFI Declarations
# ============================================================================

# Ratatui FFI functions declared here after type definitions
extern fn ratatui_terminal_new() -> u64
extern fn ratatui_terminal_cleanup(terminal: u64)
extern fn ratatui_terminal_clear(terminal: u64)
extern fn ratatui_textbuffer_new() -> u64
extern fn ratatui_textbuffer_insert_char(buffer: u64, code: u32)
extern fn ratatui_textbuffer_backspace(buffer: u64)
extern fn ratatui_textbuffer_newline(buffer: u64)
extern fn ratatui_textbuffer_get_text(buffer: u64, buf_ptr: *u8, buf_len: usize) -> usize
extern fn ratatui_textbuffer_set_text(buffer: u64, text_ptr: *u8, text_len: usize)
extern fn ratatui_render_textbuffer(terminal: u64, buffer: u64, prompt_ptr: *u8, prompt_len: usize)
extern fn ratatui_read_event_timeout(timeout_ms: u64) -> TuiEvent
extern fn ratatui_object_destroy(handle: u64)

# ============================================================================
# Key Code Constants
# ============================================================================

## Standard ASCII key codes
pub const KEY_ENTER: u32 = 13
pub const KEY_BACKSPACE: u32 = 8
pub const KEY_TAB: u32 = 9
pub const KEY_ESCAPE: u32 = 27
pub const KEY_DELETE: u32 = 127

## Arrow keys
pub const KEY_UP: u32 = 0x2001
pub const KEY_DOWN: u32 = 0x2002
pub const KEY_LEFT: u32 = 0x2003
pub const KEY_RIGHT: u32 = 0x2004

## Function keys
pub const KEY_F1: u32 = 0x1001
pub const KEY_F2: u32 = 0x1002
pub const KEY_F3: u32 = 0x1003
pub const KEY_F4: u32 = 0x1004
pub const KEY_F5: u32 = 0x1005
pub const KEY_F6: u32 = 0x1006
pub const KEY_F7: u32 = 0x1007
pub const KEY_F8: u32 = 0x1008
pub const KEY_F9: u32 = 0x1009
pub const KEY_F10: u32 = 0x100A
pub const KEY_F11: u32 = 0x100B
pub const KEY_F12: u32 = 0x100C

## Modifier flags (bit flags, can be combined with bitwise OR)
pub const MOD_SHIFT: u32 = 1
pub const MOD_CTRL: u32 = 2
pub const MOD_ALT: u32 = 4

# ============================================================================
# Terminal Management
# ============================================================================

## Create a new terminal instance
##
## Enables raw mode and enters alternate screen.
## Returns a handle to the terminal, or 0 on failure.
##
## Example:
##   val term = terminal_new()
##   if term == 0:
##       panic("Failed to create terminal")
pub fn terminal_new() -> TerminalHandle:
    return ratatui_terminal_new()

## Cleanup and restore terminal state
##
## Leaves alternate screen and disables raw mode.
## Should be called before program exit.
##
## Example:
##   terminal_cleanup(term)
pub fn terminal_cleanup(terminal: TerminalHandle):
    ratatui_terminal_cleanup(terminal)

## Clear the terminal screen
##
## Example:
##   terminal_clear(term)
pub fn terminal_clear(terminal: TerminalHandle):
    ratatui_terminal_clear(terminal)

# ============================================================================
# Text Buffer Operations
# ============================================================================

## Create a new empty text buffer
##
## Returns a handle to the buffer, or 0 on failure.
##
## Example:
##   val buffer = textbuffer_new()
pub fn textbuffer_new() -> TextBufferHandle:
    return ratatui_textbuffer_new()

## Insert a character at the current cursor position
##
## The cursor advances after insertion.
##
## Example:
##   textbuffer_insert_char(buffer, 'H')
pub fn textbuffer_insert_char(buffer: TextBufferHandle, ch: char):
    # Convert char to u32 code point
    val code = ord(ch)
    ratatui_textbuffer_insert_char(buffer, code)

## Delete the character before the cursor (backspace)
##
## If cursor is at start of line and not on first line, joins with previous line.
##
## Example:
##   textbuffer_backspace(buffer)
pub fn textbuffer_backspace(buffer: TextBufferHandle):
    ratatui_textbuffer_backspace(buffer)

## Insert a newline at the cursor position
##
## Splits the current line and moves cursor to next line.
##
## Example:
##   textbuffer_newline(buffer)
pub fn textbuffer_newline(buffer: TextBufferHandle):
    ratatui_textbuffer_newline(buffer)

## Get the full text content of the buffer
##
## Returns all lines joined with '\n'.
##
## Example:
##   val text = textbuffer_get_text(buffer)
##   print(text)
pub fn textbuffer_get_text(buffer: TextBufferHandle) -> text:
    # Allocate buffer for text (8KB max)
    var buf = alloc[u8](8192)
    val len = ratatui_textbuffer_get_text(buffer, buf.as_mut_ptr(), buf.len())

    # Convert to string
    return text.from_utf8(&buf[0..len]).unwrap()

## Set the full text content of the buffer
##
## Replaces all lines and resets cursor to (0, 0).
##
## Example:
##   textbuffer_set_text(buffer, "Hello\nWorld")
pub fn textbuffer_set_text(buffer: TextBufferHandle, text: &str):
    ratatui_textbuffer_set_text(buffer, text.as_ptr(), text.len())

# ============================================================================
# Rendering
# ============================================================================

## Render text buffer to terminal with prompt
##
## Uses immediate-mode rendering - redraws entire UI.
## Sets cursor position based on prompt length and buffer cursor.
##
## Example:
##   render_textbuffer(term, buffer, ">>> ")
pub fn render_textbuffer(terminal: TerminalHandle, buffer: TextBufferHandle, prompt: &str):
    ratatui_render_textbuffer(terminal, buffer, prompt.as_ptr(), prompt.len())

# ============================================================================
# Event Handling
# ============================================================================

## Read a terminal event with timeout
##
## Polls for keyboard, mouse, or resize events.
## Returns immediately if event available, otherwise waits up to timeout_ms.
##
## Returns:
##   TuiEvent with event_type=0 if timeout, otherwise populated event
##
## Example:
##   val event = read_event(100_ms)  # 100ms timeout
##   if event.event_type == EventType::Key:
##       if event.key_code == KEY_ENTER:
##           print("Enter pressed!")
pub fn read_event(timeout_ms: Milliseconds) -> TuiEvent:
    # FFI returns TuiEvent struct by value
    val timeout_val = timeout_ms.value()
    return ratatui_read_event_timeout(timeout_val)

# ============================================================================
# Lifecycle Management
# ============================================================================

## Destroy a Ratatui object by handle
##
## Removes object from handle registry. The Arc<Mutex<>> wrapper
## will be dropped automatically when the last reference is released.
##
## Example:
##   object_destroy(buffer)
pub fn object_destroy(handle: u64):
    ratatui_object_destroy(handle)

# ============================================================================
# Helper Functions
# ============================================================================

## Check if a key code is printable ASCII
##
## Example:
##   if is_printable(event.key_code):
##       textbuffer_insert_char(buffer, chr(event.char_value))
pub fn is_printable(key_code: u32) -> bool:
    return key_code >= 32 and key_code <= 126

## Check if event has modifier flag
##
## Example:
##   if has_modifier(event.key_mods, MOD_CTRL):
##       # Handle Ctrl+key
pub fn has_modifier(mods: u32, flag: u32) -> bool:
    return (mods & flag) != 0

## Convert TuiEvent to printable character if possible
##
## Returns Some(char) if event is a printable character key, None otherwise.
##
## Example:
##   match event_to_char(event):
##       case Some(ch):
##           textbuffer_insert_char(buffer, ch)
##       case None:
##           # Not a printable character
pub fn event_to_char(event: TuiEvent) -> Option<char>:
    if event.event_type == EventType::Key and is_printable(event.key_code):
        return Some(chr(event.char_value))
    else:
        return None

# ============================================================================
# Example Usage
# ============================================================================

# Example: Simple event loop
#
# use ui.tui.backend.ratatui.*
#
# fn main():
#     val term = terminal_new()
#     val buffer = textbuffer_new()
#
#     var running = true
#     while running:
#         # Render current state
#         render_textbuffer(term, buffer, ">>> ")
#
#         # Poll for events (100ms timeout)
#         val event = read_event(100)
#
#         # Handle event
#         if event.event_type == EventType::Key:
#             if event.key_code == KEY_ESCAPE:
#                 running = false
#             else if event.key_code == KEY_ENTER:
#                 val text = textbuffer_get_text(buffer)
#                 print("Submitted: " + text)
#                 textbuffer_set_text(buffer, "")
#             else if event.key_code == KEY_BACKSPACE:
#                 textbuffer_backspace(buffer)
#             else if is_printable(event.key_code):
#                 textbuffer_insert_char(buffer, chr(event.char_value))
#
#     # Cleanup
#     object_destroy(buffer)
#     terminal_cleanup(term)
