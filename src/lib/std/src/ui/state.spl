# State - Reactive State Management
#
# Provides reactive state containers that trigger UI updates when modified.
# Based on: doc/research/ui_framework_unified.md

use core.*

# Reactive state container
pub struct State<T>:
    value: T
    subscribers: Array<fn(T)>
    id: u64

impl<T> State<T>:
    # Create a new state with initial value
    pub fn new(initial: T) -> State<T>:
        return State {
            value: initial,
            subscribers: [],
            id: 0  # Would be generated in real implementation
        }

    # Get the current value
    pub fn get(self) -> &T:
        return &self.value

    # Set a new value and notify subscribers
    pub fn set(mut self, new_value: T):
        self.value = new_value
        self.notify()

    # Update value using a function
    pub fn update(mut self, updater: fn(&mut T)):
        updater(&mut self.value)
        self.notify()

    # Subscribe to state changes
    pub fn subscribe(mut self, handler: fn(T)):
        self.subscribers.push(handler)

    # Unsubscribe from state changes (by index)
    pub fn unsubscribe(mut self, index: usize):
        if index < self.subscribers.len():
            self.subscribers.remove(index)

    # Notify all subscribers of state change
    fn notify():
        for subscriber in &self.subscribers:
            subscriber(self.value.clone())

    # =========================================================================
    # Helper Methods
    # =========================================================================

    pub fn has_subscribers(self) -> bool:
        """Check if state has any subscribers.

        Returns:
            true if subscribers exist

        Example:
            state.has_subscribers()  # → true
        """
        return not self.subscribers.is_empty()

    pub fn subscriber_count(self) -> u64:
        """Get number of subscribers.

        Returns:
            Count of subscribers

        Example:
            state.subscriber_count()  # → 3
        """
        return self.subscribers.len()

    pub fn get_id(self) -> u64:
        """Get state ID.

        Returns:
            State ID number

        Example:
            state.get_id()  # → 42
        """
        return self.id

    pub fn summary(self) -> text:
        """Get state summary.

        Returns:
            Human-readable summary

        Example:
            state.summary()  # → "State: id=42, subscribers=3"
        """
        val count = self.subscriber_count()
        return "State: id={self.id}, subscribers={count}"

# Computed state - derived from other state
pub struct Computed<T>:
    compute_fn: fn() -> T
    value: Option<T>
    dependencies: Array<u64>  # IDs of dependent states

impl<T> Computed<T>:
    # Create a new computed state
    pub fn new(compute_fn: fn() -> T) -> Computed<T>:
        return Computed {
            compute_fn: compute_fn,
            value: None,
            dependencies: []
        }

    # Get the computed value (lazy evaluation)
    pub fn get(mut self) -> &T:
        if self.value.is_none():
            self.value = Some((self.compute_fn)())
        return self.value.as_ref().unwrap()

    # Invalidate cached value (called when dependencies change)
    pub fn invalidate(mut self):
        self.value = None

    # Add a dependency
    pub fn add_dependency(mut self, state_id: u64):
        if not self.dependencies.contains(&state_id):
            self.dependencies.push(state_id)

    # =========================================================================
    # Helper Methods
    # =========================================================================

    pub fn has_value(self) -> bool:
        """Check if value is cached.

        Returns:
            true if value is computed and cached

        Example:
            computed.has_value()  # → false
        """
        return self.value.is_some()

    pub fn is_dirty(self) -> bool:
        """Check if value needs recomputation.

        Returns:
            true if value is None (dirty)

        Example:
            computed.is_dirty()  # → true
        """
        return self.value.is_none()

    pub fn has_dependencies(self) -> bool:
        """Check if has dependencies.

        Returns:
            true if dependencies exist

        Example:
            computed.has_dependencies()  # → true
        """
        return not self.dependencies.is_empty()

    pub fn dependency_count(self) -> u64:
        """Get number of dependencies.

        Returns:
            Count of dependencies

        Example:
            computed.dependency_count()  # → 2
        """
        return self.dependencies.len()

    pub fn summary(self) -> text:
        """Get computed state summary.

        Returns:
            Human-readable summary

        Example:
            computed.summary()  # → "Computed: deps=2, cached=false"
        """
        val deps = self.dependency_count()
        val cached = self.has_value()
        return "Computed: deps={deps}, cached={cached}"

# Signal - lightweight reactive primitive
pub struct Signal<T>:
    value: T
    version: u64

impl<T> Signal<T>:
    # Create a new signal
    pub fn new(initial: T) -> Signal<T>:
        return Signal {
            value: initial,
            version: 0
        }

    # Get the current value
    pub fn get(self) -> &T:
        return &self.value

    # Set a new value
    pub fn set(mut self, new_value: T):
        self.value = new_value
        self.version = self.version + 1

    # Get the current version (for change tracking)
    pub fn version(self) -> u64:
        return self.version

    # =========================================================================
    # Helper Methods
    # =========================================================================

    pub fn has_changed(self) -> bool:
        """Check if signal has been modified.

        Returns:
            true if version > 0

        Example:
            signal.has_changed()  # → false
        """
        return self.version > 0

    pub fn is_initial(self) -> bool:
        """Check if signal is in initial state.

        Returns:
            true if never set (version == 0)

        Example:
            signal.is_initial()  # → true
        """
        return self.version == 0

    pub fn get_version(self) -> u64:
        """Get version number (alias for version()).

        Returns:
            Version number

        Example:
            signal.get_version()  # → 0
        """
        return self.version()

    pub fn summary(self) -> text:
        """Get signal summary.

        Returns:
            Human-readable summary

        Example:
            signal.summary()  # → "Signal: version=0"
        """
        return "Signal: version={self.version}"

# Effect - side effect that runs when dependencies change
pub struct Effect:
    effect_fn: fn()
    dependencies: Array<u64>
    last_run: u64

impl Effect:
    # Create a new effect
    pub fn new(effect_fn: fn()) -> Effect:
        return Effect {
            effect_fn: effect_fn,
            dependencies: [],
            last_run: 0
        }

    # Run the effect
    pub fn run(mut self):
        (self.effect_fn)()
        self.last_run = self.last_run + 1

    # Add a dependency
    pub fn add_dependency(mut self, state_id: u64):
        if not self.dependencies.contains(&state_id):
            self.dependencies.push(state_id)

    # =========================================================================
    # Helper Methods
    # =========================================================================

    pub fn has_dependencies(self) -> bool:
        """Check if has dependencies.

        Returns:
            true if dependencies exist

        Example:
            effect.has_dependencies()  # → false
        """
        return not self.dependencies.is_empty()

    pub fn dependency_count(self) -> u64:
        """Get number of dependencies.

        Returns:
            Count of dependencies

        Example:
            effect.dependency_count()  # → 2
        """
        return self.dependencies.len()

    pub fn run_count(self) -> u64:
        """Get how many times effect has run.

        Returns:
            Run count

        Example:
            effect.run_count()  # → 5
        """
        return self.last_run

    pub fn has_run(self) -> bool:
        """Check if effect has run at least once.

        Returns:
            true if run at least once

        Example:
            effect.has_run()  # → false
        """
        return self.last_run > 0

    pub fn summary(self) -> text:
        """Get effect summary.

        Returns:
            Human-readable summary

        Example:
            effect.summary()  # → "Effect: deps=2, runs=5"
        """
        val deps = self.dependency_count()
        val runs = self.run_count()
        return "Effect: deps={deps}, runs={runs}"

# StateStore - centralized state management
pub struct StateStore:
    states: Dict<text, Box<dyn Any>>
    effects: Array<Effect>
    next_id: u64

impl StateStore:
    # Create a new state store
    pub fn new() -> StateStore:
        return StateStore {
            states: Dict.new(),
            effects: [],
            next_id: 0
        }

    # Register a state with a key
    pub fn register<T>(mut self, key: &str, state: State<T>):
        self.states.insert(key.to_string(), Box.new(state))

    # Get a state by key
    pub fn get<T>(self, key: &str) -> Option<&State<T>>:
        match self.states.get(key):
            case Some(boxed):
                # Would need proper type casting in real implementation
                return None  # Placeholder
            case None:
                return None

    # Register an effect
    pub fn add_effect(mut self, effect: Effect):
        self.effects.push(effect)

    # Run all effects
    pub fn run_effects(mut self):
        for effect in &mut self.effects:
            effect.run()

    # Allocate a unique ID
    pub fn alloc_id(mut self) -> u64:
        val id = self.next_id
        self.next_id = self.next_id + 1
        return id

    # =========================================================================
    # Helper Methods
    # =========================================================================

    pub fn has_states(self) -> bool:
        """Check if any states are registered.

        Returns:
            true if states exist

        Example:
            store.has_states()  # → true
        """
        return not self.states.is_empty()

    pub fn state_count(self) -> u64:
        """Get number of registered states.

        Returns:
            Count of states

        Example:
            store.state_count()  # → 5
        """
        return self.states.len()

    pub fn has_effects(self) -> bool:
        """Check if any effects are registered.

        Returns:
            true if effects exist

        Example:
            store.has_effects()  # → true
        """
        return not self.effects.is_empty()

    pub fn effect_count(self) -> u64:
        """Get number of registered effects.

        Returns:
            Count of effects

        Example:
            store.effect_count()  # → 3
        """
        return self.effects.len()

    pub fn summary(self) -> text:
        """Get state store summary.

        Returns:
            Human-readable summary

        Example:
            store.summary()  # → "StateStore: states=5, effects=3"
        """
        val states = self.state_count()
        val effects = self.effect_count()
        return "StateStore: states={states}, effects={effects}"

# Ref - mutable reference to DOM element
pub struct Ref<T>:
    value: Option<T>

impl<T> Ref<T>:
    # Create a new empty ref
    pub fn new() -> Ref<T>:
        return Ref { value: None }

    # Get the current value
    pub fn get(self) -> Option<&T>:
        return self.value.as_ref()

    # Set the value
    pub fn set(mut self, value: T):
        self.value = Some(value)

    # Clear the value
    pub fn clear(mut self):
        self.value = None

    # =========================================================================
    # Helper Methods
    # =========================================================================

    pub fn has_value(self) -> bool:
        """Check if ref has a value.

        Returns:
            true if value is set

        Example:
            ref.has_value()  # → false
        """
        return self.value.is_some()

    pub fn is_empty(self) -> bool:
        """Check if ref is empty.

        Returns:
            true if value is None

        Example:
            ref.is_empty()  # → true
        """
        return self.value.is_none()

    pub fn summary(self) -> text:
        """Get ref summary.

        Returns:
            Human-readable summary

        Example:
            ref.summary()  # → "Ref: set=false"
        """
        val set = self.has_value()
        return "Ref: set={set}"

# Context - shared data across widget tree
pub struct Context<T>:
    value: T
    key: text

impl<T> Context<T>:
    # Create a new context
    pub fn new(key: &str, value: T) -> Context<T>:
        return Context {
            value: value,
            key: key.to_string()
        }

    # Get the context value
    pub fn get(self) -> &T:
        return &self.value

    # Update the context value
    pub fn set(mut self, value: T):
        self.value = value

    # =========================================================================
    # Helper Methods
    # =========================================================================

    pub fn get_key(self) -> &text:
        """Get context key.

        Returns:
            Context key string

        Example:
            context.get_key()  # → "theme"
        """
        return &self.key

    pub fn summary(self) -> text:
        """Get context summary.

        Returns:
            Human-readable summary

        Example:
            context.summary()  # → "Context: key='theme'"
        """
        return "Context: key='{self.key}'"

# ContextProvider - provides context to children
pub struct ContextProvider<T>:
    context: Context<T>
    children: Array<Box<Widget>>

impl<T> ContextProvider<T>:
    # Create a new context provider
    pub fn new(context: Context<T>) -> ContextProvider<T>:
        return ContextProvider {
            context: context,
            children: []
        }

    # Add a child widget
    pub fn child(mut self, widget: impl Widget) -> ContextProvider<T>:
        self.children.push(Box.new(widget))
        return self

    # =========================================================================
    # Helper Methods
    # =========================================================================

    pub fn has_children(self) -> bool:
        """Check if has any child widgets.

        Returns:
            true if children exist

        Example:
            provider.has_children()  # → false
        """
        return not self.children.is_empty()

    pub fn child_count(self) -> u64:
        """Get number of child widgets.

        Returns:
            Count of children

        Example:
            provider.child_count()  # → 2
        """
        return self.children.len()

    pub fn summary(self) -> text:
        """Get context provider summary.

        Returns:
            Human-readable summary

        Example:
            provider.summary()  # → "ContextProvider: children=2"
        """
        val count = self.child_count()
        return "ContextProvider: children={count}"

# Hooks - functional state management utilities

# useState - create a state hook
pub fn use_state<T>(initial: T) -> State<T>:
    return State.new(initial)

# useComputed - create a computed value
pub fn use_computed<T>(compute_fn: fn() -> T) -> Computed<T>:
    return Computed.new(compute_fn)

# useEffect - create a side effect
pub fn use_effect(effect_fn: fn()) -> Effect:
    val effect = Effect.new(effect_fn)
    effect.run()  # Run immediately on creation
    return effect

# useRef - create a mutable reference
pub fn use_ref<T>() -> Ref<T>:
    return Ref.new()

# useContext - access context value
pub fn use_context<T>(key: &str) -> Option<&T>:
    # Would need actual context lookup in real implementation
    return None

# Example usage:
#
# val count = use_state(0)
# val doubled = use_computed(|| count.get() * 2)
#
# use_effect(||:
#     print("Count changed to: {count.get()}")
# )
#
# Button.new("Increment")
#     .on_click(|| count.set(count.get() + 1))
