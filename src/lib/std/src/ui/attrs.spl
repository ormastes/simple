# Attrs - UI Attribute and Styling Types
#
# This module defines attribute and styling types that are shared
# between TUI and GUI renderers. Styles are translated to the
# appropriate representation for each platform.

use core.*

# Layout direction for flex containers
pub enum FlexDirection:
    Row
    RowReverse
    Column
    ColumnReverse

impl FlexDirection:
    # =========================================================================
    # Helper Methods
    # =========================================================================

    pub fn to_string(self) -> text:
        """Convert flex direction to string.

        Returns:
            Direction name

        Example:
            FlexDirection.Row.to_string()  # → "row"
        """
        match self:
            case Row: "row"
            case RowReverse: "row-reverse"
            case Column: "column"
            case ColumnReverse: "column-reverse"

    pub fn description(self) -> text:
        """Get flex direction description.

        Returns:
            Human-readable description

        Example:
            FlexDirection.Row.description()  # → "Horizontal left-to-right layout"
        """
        match self:
            case Row: "Horizontal left-to-right layout"
            case RowReverse: "Horizontal right-to-left layout"
            case Column: "Vertical top-to-bottom layout"
            case ColumnReverse: "Vertical bottom-to-top layout"

    pub fn is_horizontal(self) -> bool:
        """Check if horizontal direction.

        Returns:
            true for Row or RowReverse

        Example:
            FlexDirection.Row.is_horizontal()  # → true
        """
        match self:
            case Row | RowReverse => true
            case _ => false

    pub fn is_vertical(self) -> bool:
        """Check if vertical direction.

        Returns:
            true for Column or ColumnReverse

        Example:
            FlexDirection.Column.is_vertical()  # → true
        """
        return not self.is_horizontal()

    pub fn is_reversed(self) -> bool:
        """Check if reversed direction.

        Returns:
            true for RowReverse or ColumnReverse

        Example:
            FlexDirection.RowReverse.is_reversed()  # → true
        """
        match self:
            case RowReverse | ColumnReverse => true
            case _ => false

    pub fn is_row(self) -> bool:
        """Check if Row variant."""
        match self:
            case Row => true
            case _ => false

    pub fn is_row_reverse(self) -> bool:
        """Check if RowReverse variant."""
        match self:
            case RowReverse => true
            case _ => false

    pub fn is_column(self) -> bool:
        """Check if Column variant."""
        match self:
            case Column => true
            case _ => false

    pub fn is_column_reverse(self) -> bool:
        """Check if ColumnReverse variant."""
        match self:
            case ColumnReverse => true
            case _ => false

    pub fn summary(self) -> text:
        """Get flex direction summary.

        Returns:
            Human-readable summary

        Example:
            FlexDirection.Row.summary()
            # → "FlexDirection: row (Horizontal left-to-right layout, not reversed)"
        """
        val name = self.to_string()
        val desc = self.description()
        val reversed = if self.is_reversed(): "reversed" else: "not reversed"
        return "FlexDirection: {name} ({desc}, {reversed})"

# Flex alignment on main axis
pub enum JustifyContent:
    Start
    End
    Center
    SpaceBetween
    SpaceAround
    SpaceEvenly

impl JustifyContent:
    # =========================================================================
    # Helper Methods
    # =========================================================================

    pub fn to_string(self) -> text:
        """Convert justify content to string.

        Returns:
            Variant name

        Example:
            JustifyContent.Center.to_string()  # → "center"
        """
        match self:
            case Start: "start"
            case End: "end"
            case Center: "center"
            case SpaceBetween: "space-between"
            case SpaceAround: "space-around"
            case SpaceEvenly: "space-evenly"

    pub fn is_start(self) -> bool:
        """Check if start alignment.

        Returns:
            true for Start variant

        Example:
            JustifyContent.Start.is_start()  # → true
        """
        match self:
            case Start: True
            case _: False

    pub fn is_end(self) -> bool:
        """Check if end alignment.

        Returns:
            true for End variant

        Example:
            JustifyContent.End.is_end()  # → true
        """
        match self:
            case End: True
            case _: False

    pub fn is_center(self) -> bool:
        """Check if center alignment.

        Returns:
            true for Center variant

        Example:
            JustifyContent.Center.is_center()  # → true
        """
        match self:
            case Center: True
            case _: False

    pub fn is_spaced(self) -> bool:
        """Check if uses spacing distribution.

        Returns:
            true for SpaceBetween/SpaceAround/SpaceEvenly

        Example:
            JustifyContent.SpaceBetween.is_spaced()  # → true
        """
        match self:
            case SpaceBetween: True
            case SpaceAround: True
            case SpaceEvenly: True
            case _: False

    pub fn distributes_space(self) -> bool:
        """Check if distributes space between items.

        Returns:
            true if not Start/End

        Example:
            JustifyContent.Center.distributes_space()  # → true
        """
        match self:
            case Start: False
            case End: False
            case _: True

    fn description() -> text:
        """Get justify content description.

        Returns:
            Human-readable description

        Example:
            JustifyContent.Center.description()
            # → "Center items along main axis"
        """
        match self:
            case Start: "Align items to start of main axis"
            case End: "Align items to end of main axis"
            case Center: "Center items along main axis"
            case SpaceBetween: "Distribute items with space between them"
            case SpaceAround: "Distribute items with space around them"
            case SpaceEvenly: "Distribute items with even spacing"

    pub fn summary(self) -> text:
        """Get justify content summary.

        Returns:
            Human-readable summary

        Example:
            JustifyContent.Center.summary()  # → "JustifyContent: center"
        """
        val name = self.to_string()
        return "JustifyContent: {name}"

# Flex alignment on cross axis
pub enum AlignItems:
    Start
    End
    Center
    Stretch
    Baseline

impl AlignItems:
    # =========================================================================
    # Helper Methods
    # =========================================================================

    pub fn to_string(self) -> text:
        """Convert align items to string.

        Returns:
            Variant name

        Example:
            AlignItems.Center.to_string()  # → "center"
        """
        match self:
            case Start: "start"
            case End: "end"
            case Center: "center"
            case Stretch: "stretch"
            case Baseline: "baseline"

    fn description() -> text:
        """Get align items description.

        Returns:
            Human-readable description

        Example:
            AlignItems.Stretch.description()
            # → "Stretch items to fill cross axis"
        """
        match self:
            case Start: "Align items to start of cross axis"
            case End: "Align items to end of cross axis"
            case Center: "Center items on cross axis"
            case Stretch: "Stretch items to fill cross axis"
            case Baseline: "Align items by text baseline"

    pub fn is_start(self) -> bool:
        """Check if start alignment.

        Returns:
            true for Start variant

        Example:
            AlignItems.Start.is_start()  # → true
        """
        match self:
            case Start: True
            case _: False

    pub fn is_end(self) -> bool:
        """Check if end alignment.

        Returns:
            true for End variant

        Example:
            AlignItems.End.is_end()  # → true
        """
        match self:
            case End: True
            case _: False

    pub fn is_center(self) -> bool:
        """Check if center alignment.

        Returns:
            true for Center variant

        Example:
            AlignItems.Center.is_center()  # → true
        """
        match self:
            case Center: True
            case _: False

    pub fn is_stretch(self) -> bool:
        """Check if stretch alignment.

        Returns:
            true for Stretch variant

        Example:
            AlignItems.Stretch.is_stretch()  # → true
        """
        match self:
            case Stretch: True
            case _: False

    pub fn is_baseline(self) -> bool:
        """Check if baseline alignment.

        Returns:
            true for Baseline variant

        Example:
            AlignItems.Baseline.is_baseline()  # → true
        """
        match self:
            case Baseline: True
            case _: False

    pub fn summary(self) -> text:
        """Get align items summary.

        Returns:
            Human-readable summary

        Example:
            AlignItems.Center.summary()  # → "AlignItems: center"
        """
        val name = self.to_string()
        return "AlignItems: {name}"

# Text alignment
pub enum TextAlign:
    Left
    Center
    Right
    Justify

impl TextAlign:
    # =========================================================================
    # Helper Methods
    # =========================================================================

    pub fn to_string(self) -> text:
        """Convert text align to string.

        Returns:
            Variant name

        Example:
            TextAlign.Center.to_string()  # → "center"
        """
        match self:
            case Left: "left"
            case Center: "center"
            case Right: "right"
            case Justify: "justify"

    fn description() -> text:
        """Get text align description.

        Returns:
            Human-readable description

        Example:
            TextAlign.Justify.description()
            # → "Justify text (stretch lines to fill width)"
        """
        match self:
            case Left: "Align text to left edge"
            case Center: "Center text horizontally"
            case Right: "Align text to right edge"
            case Justify: "Justify text (stretch lines to fill width)"

    pub fn is_left(self) -> bool:
        """Check if left alignment.

        Returns:
            true for Left variant

        Example:
            TextAlign.Left.is_left()  # → true
        """
        match self:
            case Left: True
            case _: False

    pub fn is_center(self) -> bool:
        """Check if center alignment.

        Returns:
            true for Center variant

        Example:
            TextAlign.Center.is_center()  # → true
        """
        match self:
            case Center: True
            case _: False

    pub fn is_right(self) -> bool:
        """Check if right alignment.

        Returns:
            true for Right variant

        Example:
            TextAlign.Right.is_right()  # → true
        """
        match self:
            case Right: True
            case _: False

    pub fn is_justify(self) -> bool:
        """Check if justify alignment.

        Returns:
            true for Justify variant

        Example:
            TextAlign.Justify.is_justify()  # → true
        """
        match self:
            case Justify: True
            case _: False

    pub fn summary(self) -> text:
        """Get text align summary.

        Returns:
            Human-readable summary

        Example:
            TextAlign.Center.summary()  # → "TextAlign: center"
        """
        val name = self.to_string()
        return "TextAlign: {name}"

# Vertical alignment
pub enum VerticalAlign:
    Top
    Middle
    Bottom

impl VerticalAlign:
    # =========================================================================
    # Helper Methods
    # =========================================================================

    pub fn to_string(self) -> text:
        """Convert vertical align to string.

        Returns:
            Variant name

        Example:
            VerticalAlign.Middle.to_string()  # → "middle"
        """
        match self:
            case Top: "top"
            case Middle: "middle"
            case Bottom: "bottom"

    fn description() -> text:
        """Get vertical align description.

        Returns:
            Human-readable description

        Example:
            VerticalAlign.Middle.description()
            # → "Align to vertical middle"
        """
        match self:
            case Top: "Align to top edge"
            case Middle: "Align to vertical middle"
            case Bottom: "Align to bottom edge"

    pub fn is_top(self) -> bool:
        """Check if top alignment.

        Returns:
            true for Top variant

        Example:
            VerticalAlign.Top.is_top()  # → true
        """
        match self:
            case Top: True
            case _: False

    pub fn is_middle(self) -> bool:
        """Check if middle alignment.

        Returns:
            true for Middle variant

        Example:
            VerticalAlign.Middle.is_middle()  # → true
        """
        match self:
            case Middle: True
            case _: False

    pub fn is_bottom(self) -> bool:
        """Check if bottom alignment.

        Returns:
            true for Bottom variant

        Example:
            VerticalAlign.Bottom.is_bottom()  # → true
        """
        match self:
            case Bottom: True
            case _: False

    pub fn summary(self) -> text:
        """Get vertical align summary.

        Returns:
            Human-readable summary

        Example:
            VerticalAlign.Middle.summary()  # → "VerticalAlign: middle"
        """
        val name = self.to_string()
        return "VerticalAlign: {name}"

# Border style (for Box elements)
pub enum BorderStyle:
    None
    Solid
    Dashed
    Dotted
    Double
    Rounded  # TUI: rounded box-drawing corners

impl BorderStyle:
    # =========================================================================
    # Helper Methods
    # =========================================================================

    pub fn to_string(self) -> text:
        """Convert border style to string.

        Returns:
            Style name

        Example:
            BorderStyle.Solid.to_string()  # → "solid"
        """
        match self:
            case None: "none"
            case Solid: "solid"
            case Dashed: "dashed"
            case Dotted: "dotted"
            case Double: "double"
            case Rounded: "rounded"

    pub fn description(self) -> text:
        """Get border style description.

        Returns:
            Human-readable description

        Example:
            BorderStyle.Rounded.description()  # → "Rounded corners (TUI box-drawing)"
        """
        match self:
            case None: "No border"
            case Solid: "Solid line border"
            case Dashed: "Dashed line border"
            case Dotted: "Dotted line border"
            case Double: "Double line border"
            case Rounded: "Rounded corners (TUI box-drawing)"

    pub fn is_visible(self) -> bool:
        """Check if border should be rendered.

        Returns:
            false for None, true otherwise

        Example:
            BorderStyle.Solid.is_visible()  # → true
        """
        return self != BorderStyle.None

    pub fn is_none(self) -> bool:
        """Check if None variant."""
        match self:
            case None => true
            case _ => false

    pub fn is_solid(self) -> bool:
        """Check if Solid variant."""
        match self:
            case Solid => true
            case _ => false

    pub fn is_dashed(self) -> bool:
        """Check if Dashed variant."""
        match self:
            case Dashed => true
            case _ => false

    pub fn is_dotted(self) -> bool:
        """Check if Dotted variant."""
        match self:
            case Dotted => true
            case _ => false

    pub fn is_double(self) -> bool:
        """Check if Double variant."""
        match self:
            case Double => true
            case _ => false

    pub fn is_rounded(self) -> bool:
        """Check if Rounded variant."""
        match self:
            case Rounded => true
            case _ => false

    pub fn summary(self) -> text:
        """Get border style summary.

        Returns:
            Human-readable summary

        Example:
            BorderStyle.Rounded.summary()
            # → "BorderStyle: rounded (Rounded corners (TUI box-drawing), visible)"
        """
        val name = self.to_string()
        val desc = self.description()
        val visible = if self.is_visible(): "visible" else: "hidden"
        return "BorderStyle: {name} ({desc}, {visible})"

# Color representation (platform-agnostic)
pub enum Color:
    # Named colors (ANSI-compatible)
    Black
    Red
    Green
    Yellow
    Blue
    Magenta
    Cyan
    White
    BrightBlack
    BrightRed
    BrightGreen
    BrightYellow
    BrightBlue
    BrightMagenta
    BrightCyan
    BrightWhite
    # RGB color (24-bit)
    Rgb(u8, u8, u8)
    # ANSI 256-color palette
    Ansi256(u8)
    # Default/inherit color
    Default

impl Color:
    # Create RGB color
    pub fn rgb(r: u8, g: u8, b: u8) -> Color:
        return Color.Rgb(r, g, b)

    # Create from hex value (0xRRGGBB)
    pub fn hex(value: u32) -> Color:
        val r = ((value >> 16) & 0xFF) as u8
        val g = ((value >> 8) & 0xFF) as u8
        val b = (value & 0xFF) as u8
        return Color.Rgb(r, g, b)

    # Convert to RGBA u32 (for FFI)
    pub fn to_rgba(self) -> u32:
        match self:
            case Black => 0x000000
            case Red => 0xCC0000
            case Green => 0x00CC00
            case Yellow => 0xCCCC00
            case Blue => 0x0000CC
            case Magenta => 0xCC00CC
            case Cyan => 0x00CCCC
            case White => 0xCCCCCC
            case BrightBlack => 0x555555
            case BrightRed => 0xFF5555
            case BrightGreen => 0x55FF55
            case BrightYellow => 0xFFFF55
            case BrightBlue => 0x5555FF
            case BrightMagenta => 0xFF55FF
            case BrightCyan => 0x55FFFF
            case BrightWhite => 0xFFFFFF
            case Rgb(r, g, b) => ((r as u32) << 16) | ((g as u32) << 8) | (b as u32)
            case Ansi256(n) => ansi256_to_rgb(n)
            case Default => 0

    # =========================================================================
    # Helper Methods
    # =========================================================================

    pub fn to_string(self) -> text:
        """Convert color to string.

        Returns:
            Color name or RGB/ANSI representation

        Example:
            Color.Red.to_string()  # → "red"
            Color.Rgb(255, 128, 0).to_string()  # → "rgb(255, 128, 0)"
        """
        match self:
            case Black: "black"
            case Red: "red"
            case Green: "green"
            case Yellow: "yellow"
            case Blue: "blue"
            case Magenta: "magenta"
            case Cyan: "cyan"
            case White: "white"
            case BrightBlack: "bright-black"
            case BrightRed: "bright-red"
            case BrightGreen: "bright-green"
            case BrightYellow: "bright-yellow"
            case BrightBlue: "bright-blue"
            case BrightMagenta: "bright-magenta"
            case BrightCyan: "bright-cyan"
            case BrightWhite: "bright-white"
            case Rgb(r, g, b): "rgb({r}, {g}, {b})"
            case Ansi256(n): "ansi256({n})"
            case Default: "default"

    fn description() -> text:
        """Get color description.

        Returns:
            Human-readable description

        Example:
            Color.BrightRed.description()
            # → "Bright red (ANSI standard color)"
        """
        match self:
            case Black: "Black (ANSI standard color)"
            case Red: "Red (ANSI standard color)"
            case Green: "Green (ANSI standard color)"
            case Yellow: "Yellow (ANSI standard color)"
            case Blue: "Blue (ANSI standard color)"
            case Magenta: "Magenta (ANSI standard color)"
            case Cyan: "Cyan (ANSI standard color)"
            case White: "White (ANSI standard color)"
            case BrightBlack: "Bright black (ANSI bright variant)"
            case BrightRed: "Bright red (ANSI bright variant)"
            case BrightGreen: "Bright green (ANSI bright variant)"
            case BrightYellow: "Bright yellow (ANSI bright variant)"
            case BrightBlue: "Bright blue (ANSI bright variant)"
            case BrightMagenta: "Bright magenta (ANSI bright variant)"
            case BrightCyan: "Bright cyan (ANSI bright variant)"
            case BrightWhite: "Bright white (ANSI bright variant)"
            case Rgb(r, g, b): "Custom RGB color ({r}, {g}, {b})"
            case Ansi256(n): "ANSI 256-color palette index {n}"
            case Default: "Default/inherited color"

    pub fn is_named(self) -> bool:
        """Check if this is a named ANSI color.

        Returns:
            true for standard named colors

        Example:
            Color.Red.is_named()  # → true
            Color.Rgb(255, 0, 0).is_named()  # → false
        """
        match self:
            case Black | Red | Green | Yellow | Blue | Magenta | Cyan | White: true
            case BrightBlack | BrightRed | BrightGreen | BrightYellow: true
            case BrightBlue | BrightMagenta | BrightCyan | BrightWhite: true
            case _: false

    pub fn is_bright(self) -> bool:
        """Check if this is a bright color variant.

        Returns:
            true for Bright* variants

        Example:
            Color.BrightRed.is_bright()  # → true
        """
        match self:
            case BrightBlack | BrightRed | BrightGreen | BrightYellow: true
            case BrightBlue | BrightMagenta | BrightCyan | BrightWhite: true
            case _: false

    pub fn is_rgb(self) -> bool:
        """Check if this is RGB color.

        Returns:
            true for Rgb variant

        Example:
            Color.Rgb(255, 0, 0).is_rgb()  # → true
        """
        match self:
            case Rgb(_, _, _): true
            case _: false

    pub fn is_ansi256(self) -> bool:
        """Check if this is ANSI 256-color.

        Returns:
            true for Ansi256 variant

        Example:
            Color.Ansi256(42).is_ansi256()  # → true
        """
        match self:
            case Ansi256(_): true
            case _: false

    pub fn is_default(self) -> bool:
        """Check if this is default/inherit color.

        Returns:
            true for Default variant

        Example:
            Color.Default.is_default()  # → true
        """
        match self:
            case Default: true
            case _: false

    pub fn get_rgb(self) -> Option<(u8, u8, u8)>:
        """Get RGB components if this is RGB color.

        Returns:
            RGB tuple or None

        Example:
            Color.Rgb(255, 128, 0).get_rgb()  # → Some((255, 128, 0))
        """
        match self:
            case Rgb(r, g, b): Some((r, g, b))
            case _: None

    pub fn summary(self) -> text:
        """Get color summary.

        Returns:
            Human-readable summary

        Example:
            Color.BrightRed.summary()  # → "Color: bright-red (named, bright)"
            Color.Rgb(255, 0, 0).summary()  # → "Color: rgb(255, 0, 0) (custom RGB)"
        """
        val name = self.to_string()
        var props = []

        if self.is_named():
            props.push("named")
        if self.is_bright():
            props.push("bright")
        if self.is_rgb():
            props.push("custom RGB")
        if self.is_ansi256():
            props.push("ANSI 256-color")
        if self.is_default():
            props.push("default/inherit")

        if props.is_empty():
            return "Color: {name}"
        else:
            val props_str = props.join(", ")
            return "Color: {name} ({props_str})"

# Convert ANSI 256-color index to RGB
fn ansi256_to_rgb(n: u8) -> u32:
    # Standard colors 0-15
    if n < 16:
        val colors: [u32; 16] = [
            0x000000, 0xCC0000, 0x00CC00, 0xCCCC00,
            0x0000CC, 0xCC00CC, 0x00CCCC, 0xCCCCCC,
            0x555555, 0xFF5555, 0x55FF55, 0xFFFF55,
            0x5555FF, 0xFF55FF, 0x55FFFF, 0xFFFFFF
        ]
        return colors[n as u64]
    # 216-color cube (16-231)
    if n < 232:
        val idx = n - 16
        val r = ((idx / 36) % 6) * 51
        val g = ((idx / 6) % 6) * 51
        val b = (idx % 6) * 51
        return ((r as u32) << 16) | ((g as u32) << 8) | (b as u32)
    # Grayscale (232-255)
    val gray = ((n - 232) * 10 + 8) as u32
    return (gray << 16) | (gray << 8) | gray

# Text style flags
pub struct TextStyle:
    bold: bool
    dim: bool
    italic: bool
    underline: bool
    blink: bool
    reverse: bool
    hidden: bool
    strikethrough: bool

impl TextStyle:
    # Create default (no styling)
    pub fn new() -> TextStyle:
        return TextStyle {
            bold: false,
            dim: false,
            italic: false,
            underline: false,
            blink: false,
            reverse: false,
            hidden: false,
            strikethrough: false
        }

    # Builder methods
    pub fn bold(self) -> TextStyle:
        self.bold = true
        return self

    pub fn dim(self) -> TextStyle:
        self.dim = true
        return self

    pub fn italic(self) -> TextStyle:
        self.italic = true
        return self

    pub fn underline(self) -> TextStyle:
        self.underline = true
        return self

    pub fn blink(self) -> TextStyle:
        self.blink = true
        return self

    pub fn reverse(self) -> TextStyle:
        self.reverse = true
        return self

    pub fn hidden(self) -> TextStyle:
        self.hidden = true
        return self

    pub fn strikethrough(self) -> TextStyle:
        self.strikethrough = true
        return self

    # Convert to FFI flags byte
    pub fn to_flags(self) -> u8:
        var flags: u8 = 0
        if self.bold: flags = flags | 1
        if self.dim: flags = flags | 2
        if self.italic: flags = flags | 4
        if self.underline: flags = flags | 8
        if self.blink: flags = flags | 16
        if self.reverse: flags = flags | 32
        if self.hidden: flags = flags | 64
        if self.strikethrough: flags = flags | 128
        return flags

# Complete style specification
pub struct Style:
    # Colors
    fg: Option<Color>
    bg: Option<Color>
    # Text styling
    text_style: TextStyle
    # Border
    border_style: BorderStyle
    border_color: Option<Color>
    # Layout
    width: Option<u16>
    height: Option<u16>
    min_width: Option<u16>
    min_height: Option<u16>
    max_width: Option<u16>
    max_height: Option<u16>
    # Padding (top, right, bottom, left)
    padding: (u16, u16, u16, u16)
    # Margin (top, right, bottom, left)
    margin: (u16, u16, u16, u16)
    # Flex layout
    flex_direction: Option<FlexDirection>
    justify_content: Option<JustifyContent>
    align_items: Option<AlignItems>
    flex_grow: f32
    flex_shrink: f32
    # Text
    text_align: Option<TextAlign>
    vertical_align: Option<VerticalAlign>

impl Style:
    # Create default style
    pub fn new() -> Style:
        return Style {
            fg: None,
            bg: None,
            text_style: TextStyle.new(),
            border_style: BorderStyle.None,
            border_color: None,
            width: None,
            height: None,
            min_width: None,
            min_height: None,
            max_width: None,
            max_height: None,
            padding: (0, 0, 0, 0),
            margin: (0, 0, 0, 0),
            flex_direction: None,
            justify_content: None,
            align_items: None,
            flex_grow: 0.0,
            flex_shrink: 1.0,
            text_align: None,
            vertical_align: None
        }

    # Builder: set foreground color
    pub fn fg(self, color: Color) -> Style:
        self.fg = Some(color)
        return self

    # Builder: set background color
    pub fn bg(self, color: Color) -> Style:
        self.bg = Some(color)
        return self

    # Builder: set text style
    pub fn bold(self) -> Style:
        self.text_style = self.text_style.bold()
        return self

    pub fn dim(self) -> Style:
        self.text_style = self.text_style.dim()
        return self

    pub fn italic(self) -> Style:
        self.text_style = self.text_style.italic()
        return self

    pub fn underline(self) -> Style:
        self.text_style = self.text_style.underline()
        return self

    # Builder: set border
    pub fn border(self, style: BorderStyle) -> Style:
        self.border_style = style
        return self

    pub fn border_color(self, color: Color) -> Style:
        self.border_color = Some(color)
        return self

    # Builder: set dimensions
    pub fn width(self, w: u16) -> Style:
        self.width = Some(w)
        return self

    pub fn height(self, h: u16) -> Style:
        self.height = Some(h)
        return self

    pub fn size(self, w: u16, h: u16) -> Style:
        self.width = Some(w)
        self.height = Some(h)
        return self

    # Builder: set padding (all sides)
    pub fn padding_all(self, p: u16) -> Style:
        self.padding = (p, p, p, p)
        return self

    # Builder: set padding (vertical, horizontal)
    pub fn padding_vh(self, v: u16, h: u16) -> Style:
        self.padding = (v, h, v, h)
        return self

    # Builder: set padding (top, right, bottom, left)
    pub fn padding_trbl(self, t: u16, r: u16, b: u16, l: u16) -> Style:
        self.padding = (t, r, b, l)
        return self

    # Builder: set margin (all sides)
    pub fn margin_all(self, m: u16) -> Style:
        self.margin = (m, m, m, m)
        return self

    # Builder: set flex direction
    pub fn flex_row(self) -> Style:
        self.flex_direction = Some(FlexDirection.Row)
        return self

    pub fn flex_column(self) -> Style:
        self.flex_direction = Some(FlexDirection.Column)
        return self

    # Builder: set flex grow
    pub fn grow(self, factor: f32) -> Style:
        self.flex_grow = factor
        return self

    # Builder: set text alignment
    pub fn text_left(self) -> Style:
        self.text_align = Some(TextAlign.Left)
        return self

    pub fn text_center(self) -> Style:
        self.text_align = Some(TextAlign.Center)
        return self

    pub fn text_right(self) -> Style:
        self.text_align = Some(TextAlign.Right)
        return self

    # Merge another style (other takes precedence)
    pub fn merge(self, other: &Style) -> Style:
        if other.fg.is_some(): self.fg = other.fg
        if other.bg.is_some(): self.bg = other.bg
        if other.border_style != BorderStyle.None:
            self.border_style = other.border_style
        if other.border_color.is_some(): self.border_color = other.border_color
        if other.width.is_some(): self.width = other.width
        if other.height.is_some(): self.height = other.height
        if other.flex_direction.is_some(): self.flex_direction = other.flex_direction
        if other.text_align.is_some(): self.text_align = other.text_align
        return self
