# Authentication & Authorization for LMS
# Supports API keys, OAuth tokens, and role-based access control

import sys
import error

# Authentication method
pub enum AuthMethod:
    ApiKey(text)           # API key authentication
    BearerToken(text)      # OAuth/JWT bearer token
    Basic(text, text)    # Basic auth (username, password)
    None                     # No authentication

impl AuthMethod:
    pub fn to_string(self) -> text:
        """Convert auth method to string."""
        match self:
            case ApiKey(_): "api-key"
            case BearerToken(_): "bearer-token"
            case Basic(_, _): "basic"
            case None: "none"

    pub fn description(self) -> text:
        """Get auth method description."""
        match self:
            case ApiKey(_): "API key authentication"
            case BearerToken(_): "OAuth/JWT bearer token"
            case Basic(_, _): "HTTP Basic authentication (username/password)"
            case None: "No authentication"

    pub fn is_api_key(self) -> bool:
        """Check if method is ApiKey."""
        match self:
            case ApiKey(_): true
            case _: false

    pub fn is_bearer_token(self) -> bool:
        """Check if method is BearerToken."""
        match self:
            case BearerToken(_): true
            case _: false

    pub fn is_basic(self) -> bool:
        """Check if method is Basic."""
        match self:
            case Basic(_, _): true
            case _: false

    pub fn is_none(self) -> bool:
        """Check if method is None (no auth)."""
        match self:
            case None: true
            case _: false

    pub fn is_authenticated(self) -> bool:
        """Check if method provides authentication."""
        match self:
            case None: false
            case _: true

    pub fn is_token_based(self) -> bool:
        """Check if method is token-based (ApiKey or BearerToken)."""
        match self:
            case ApiKey(_): true
            case BearerToken(_): true
            case _: false

    pub fn summary(self) -> text:
        """Get auth method summary."""
        val name = self.to_string()
        val desc = self.description()
        val status = if self.is_authenticated(): "authenticated" else: "unauthenticated"
        return "AuthMethod: {name} ({desc}, {status})"

# Permission levels
pub enum Permission:
    Read                     # Read-only access
    Write                    # Read and write access
    Execute                  # Can execute tools and commands
    Admin                    # Full administrative access

impl Permission:
    pub fn to_string(self) -> text:
        """Convert permission to string."""
        match self:
            case Read: "read"
            case Write: "write"
            case Execute: "execute"
            case Admin: "admin"

    pub fn description(self) -> text:
        """Get permission description."""
        match self:
            case Read: "Read-only access"
            case Write: "Read and write access"
            case Execute: "Can execute tools and commands"
            case Admin: "Full administrative access"

    pub fn is_read(self) -> bool:
        """Check if permission is Read."""
        match self:
            case Read: true
            case _: false

    pub fn is_write(self) -> bool:
        """Check if permission is Write."""
        match self:
            case Write: true
            case _: false

    pub fn is_execute(self) -> bool:
        """Check if permission is Execute."""
        match self:
            case Execute: true
            case _: false

    pub fn is_admin(self) -> bool:
        """Check if permission is Admin."""
        match self:
            case Admin: true
            case _: false

    pub fn allows_read(self) -> bool:
        """Check if permission allows reading."""
        match self:
            case Read: true
            case Write: true
            case Execute: true
            case Admin: true

    pub fn allows_write(self) -> bool:
        """Check if permission allows writing."""
        match self:
            case Write: true
            case Execute: true
            case Admin: true
            case _: false

    pub fn allows_execute(self) -> bool:
        """Check if permission allows execution."""
        match self:
            case Execute: true
            case Admin: true
            case _: false

    pub fn is_privileged(self) -> bool:
        """Check if this is a privileged permission (Execute or Admin)."""
        match self:
            case Execute: true
            case Admin: true
            case _: false

    pub fn summary(self) -> text:
        """Get permission summary."""
        val name = self.to_string()
        val desc = self.description()
        val level = if self.is_admin():
            "highest"
        elif self.is_privileged():
            "privileged"
        elif self.allows_write():
            "elevated"
        else:
            "basic"
        return "Permission: {name} ({desc}, {level})"

# User role
pub class Role:
    name: text
    permissions: Set<Permission>
    description: text

    pub fn new(name: text, permissions: Set<Permission>, description: text) -> Role:
        Role {
            name: name,
            permissions: permissions,
            description: description
        }

    pub fn has_permission(self, permission: Permission) -> bool:
        self.permissions.contains(permission)

# Authenticated user
pub class User:
    id: text
    username: text
    roles: List<Role>
    auth_method: AuthMethod
    created_at: i32
    last_access: i32

    pub fn new(id: text, username: text, auth_method: AuthMethod) -> User:
        val now = sys.time.now_ms()
        User {
            id: id,
            username: username,
            roles: [],
            auth_method: auth_method,
            created_at: now,
            last_access: now
        }

    pub fn add_role(mut self, role: Role):
        self.roles.push(role)

    pub fn has_permission(self, permission: Permission) -> bool:
        for role in self.roles:
            if role.has_permission(permission):
                return true
        false

    pub fn touch(mut self):
        self.last_access = sys.time.now_ms()

# API key record
pub class ApiKey:
    key: text
    user_id: text
    description: text
    created_at: i32
    expires_at: Option<i32>
    last_used: Option<i32>
    revoked: bool

    pub fn new(key: text, user_id: text, description: text, ttl_ms: Option<i32>) -> ApiKey:
        val now = sys.time.now_ms()
        val expires = match ttl_ms:
            Some(ttl) ->
                Some(now + ttl)
            None ->
                None

        ApiKey {
            key: key,
            user_id: user_id,
            description: description,
            created_at: now,
            expires_at: expires,
            last_used: None,
            revoked: false
        }

    pub fn is_valid(self) -> bool:
        if self.revoked:
            return false

        match self.expires_at:
            Some(expires) ->
                val now = sys.time.now_ms()
                now < expires
            None ->
                true

    pub fn mark_used(mut self):
        self.last_used = Some(sys.time.now_ms())

    pub fn revoke(mut self):
        self.revoked = true

# Authentication manager
pub class AuthManager:
    users: Dict<text, User>            # user_id -> User
    api_keys: Dict<text, ApiKey>       # key -> ApiKey
    roles: Dict<text, Role>            # role_name -> Role
    enabled: bool

    pub fn new(enabled: bool) -> AuthManager:
        var manager = AuthManager {
            users: {},
            api_keys: {},
            roles: {},
            enabled: enabled
        }

        # Create default roles
        manager.create_default_roles()
        manager

    # Create default role definitions
    me create_default_roles():
        # Read-only role
        var read_perms = Set.new()
        read_perms.insert(Permission.Read)
        self.roles["reader"] = Role.new(
            "reader",
            read_perms,
            "Read-only access to workspace"
        )

        # Developer role
        var dev_perms = Set.new()
        dev_perms.insert(Permission.Read)
        dev_perms.insert(Permission.Write)
        dev_perms.insert(Permission.Execute)
        self.roles["developer"] = Role.new(
            "developer",
            dev_perms,
            "Full development access"
        )

        # Admin role
        var admin_perms = Set.new()
        admin_perms.insert(Permission.Read)
        admin_perms.insert(Permission.Write)
        admin_perms.insert(Permission.Execute)
        admin_perms.insert(Permission.Admin)
        self.roles["admin"] = Role.new(
            "admin",
            admin_perms,
            "Full administrative access"
        )

    # Authenticate a request
    pub fn authenticate(mut self, auth_header: Option<text>) -> Result<User, error.LmsError>:
        # If auth is disabled, return default admin user
        if not self.enabled:
            return Ok(self.get_default_user())

        # Parse authentication header
        val auth_method = match auth_header:
            Some(header) ->
                self.parse_auth_header(header)?
            None ->
                return Err(error.LmsError.PermissionDenied("Missing authentication"))

        # Authenticate based on method
        match auth_method:
            AuthMethod.ApiKey(key) ->
                self.authenticate_api_key(key)
            AuthMethod.BearerToken(token) ->
                self.authenticate_bearer_token(token)
            AuthMethod.Basic(username, password) ->
                self.authenticate_basic(username, password)
            AuthMethod.None ->
                Err(error.LmsError.PermissionDenied("Authentication required"))

    # Parse Authorization header
    fn parse_auth_header(header: text) -> Result<AuthMethod, error.LmsError>:
        if header.starts_with("Bearer "):
            val token = header.substring(7, header.len())
            Ok(AuthMethod.BearerToken(token))
        else if header.starts_with("ApiKey "):
            val key = header.substring(7, header.len())
            Ok(AuthMethod.ApiKey(key))
        else if header.starts_with("Basic "):
            val credentials = header.substring(6, header.len())
            # In real implementation, would decode base64
            # For now, expect "username:password"
            val parts = credentials.split(":")
            if parts.len() >= 2:
                Ok(AuthMethod.Basic(parts[0], parts[1]))
            else:
                Err(error.LmsError.InvalidParams("Invalid Basic auth format"))
        else:
            Err(error.LmsError.InvalidParams("Unknown authentication method"))

    # Authenticate with API key
    me authenticate_api_key(key: text) -> Result<User, error.LmsError>:
        match self.api_keys.get_mut(key):
            Some(api_key) ->
                if not api_key.is_valid():
                    return Err(error.LmsError.PermissionDenied("API key expired or revoked"))

                api_key.mark_used()

                match self.users.get_mut(api_key.user_id):
                    Some(user) ->
                        user.touch()
                        Ok(user)
                    None ->
                        Err(error.LmsError.InternalError("User not found for API key"))
            None ->
                Err(error.LmsError.PermissionDenied("Invalid API key"))

    # Authenticate with bearer token (OAuth/JWT)
    fn authenticate_bearer_token(token: text) -> Result<User, error.LmsError>:
        # In real implementation, would validate JWT signature and claims
        # For now, treat as simple token lookup
        Err(error.LmsError.InternalError("Bearer token authentication not yet implemented"))

    # Authenticate with username/password
    fn authenticate_basic(username: text, password: text) -> Result<User, error.LmsError>:
        # In real implementation, would check password hash
        Err(error.LmsError.InternalError("Basic authentication not yet implemented"))

    # Get default user for non-authenticated mode
    fn get_default_user() -> User:
        var user = User.new("default", "default", AuthMethod.None)
        match self.roles.get("admin"):
            Some(admin_role) ->
                user.add_role(admin_role)
            None ->
                pass
        user

    # Create a new API key
    pub fn create_api_key(mut self, user_id: text, description: text, ttl_ms: Option<i32>) -> Result<text, error.LmsError>:
        # Verify user exists
        if not self.users.contains_key(user_id):
            return Err(error.LmsError.InvalidParams("User not found: {user_id}"))

        # Generate API key
        val key = self.generate_api_key()

        # Store API key
        self.api_keys[key] = ApiKey.new(key, user_id, description, ttl_ms)

        Ok(key)

    # Revoke an API key
    pub fn revoke_api_key(mut self, key: text) -> Result<Nil, error.LmsError>:
        match self.api_keys.get_mut(key):
            Some(api_key) ->
                api_key.revoke()
                Ok(nil)
            None ->
                Err(error.LmsError.InvalidParams("API key not found: {key}"))

    # Create a new user
    pub fn create_user(mut self, username: text, role_names: List<text>) -> Result<text, error.LmsError>:
        # Generate user ID
        val user_id = self.generate_user_id()

        # Create user
        var user = User.new(user_id, username, AuthMethod.None)

        # Assign roles
        for role_name in role_names:
            match self.roles.get(role_name):
                Some(role) ->
                    user.add_role(role)
                None ->
                    return Err(error.LmsError.InvalidParams("Role not found: {role_name}"))

        # Store user
        self.users[user_id] = user

        Ok(user_id)

    # Check if user has permission
    pub fn check_permission(self, user: User, permission: Permission) -> Result<Nil, error.LmsError>:
        if user.has_permission(permission):
            Ok(nil)
        else:
            Err(error.LmsError.PermissionDenied("Missing permission: {permission}"))

    # Generate a random API key
    fn generate_api_key() -> text:
        # In real implementation, would use crypto-secure random
        val timestamp = sys.time.now_ms()
        val random = sys.random.random_int()
        "lms_{timestamp}_{random}"

    # Generate a unique user ID
    fn generate_user_id() -> text:
        val timestamp = sys.time.now_ms()
        val random = sys.random.random_int()
        "user_{timestamp}_{random}"

# Authorization guard for method handlers
pub fn require_permission(user: User, permission: Permission) -> Result<Nil, error.LmsError>:
    if not user.has_permission(permission):
        Err(error.LmsError.PermissionDenied("Requires {permission} permission"))
    else:
        Ok(nil)
