# Multi-file Workspace Handling for LMS
# Tracks file changes, dependencies, and provides workspace-wide operations

import sys
import protocol
import session
import units.lms.DocumentVersion
import units.time.Milliseconds
import units.size.ByteCount

# File status enumeration
pub enum FileStatus:
    Clean           # File unchanged since last sync
    Modified        # File has local changes
    Deleted         # File marked for deletion
    Added           # New file added to workspace

impl FileStatus:
    pub fn to_string(self) -> text:
        """Convert file status to string."""
        match self:
            case Clean: "clean"
            case Modified: "modified"
            case Deleted: "deleted"
            case Added: "added"

    pub fn description(self) -> text:
        """Get file status description."""
        match self:
            case Clean: "File unchanged since last sync"
            case Modified: "File has local changes"
            case Deleted: "File marked for deletion"
            case Added: "New file added to workspace"

    pub fn is_clean(self) -> bool:
        """Check if status is Clean."""
        match self:
            case Clean: true
            case _: false

    pub fn is_modified(self) -> bool:
        """Check if status is Modified."""
        match self:
            case Modified: true
            case _: false

    pub fn is_deleted(self) -> bool:
        """Check if status is Deleted."""
        match self:
            case Deleted: true
            case _: false

    pub fn is_added(self) -> bool:
        """Check if status is Added."""
        match self:
            case Added: true
            case _: false

    pub fn is_dirty(self) -> bool:
        """Check if file has uncommitted changes."""
        match self:
            case Clean: false
            case _: true

    pub fn is_pending_delete(self) -> bool:
        """Check if file is marked for deletion."""
        return self.is_deleted()

    pub fn summary(self) -> text:
        """Get file status summary."""
        val name = self.to_string()
        val desc = self.description()
        val state = if self.is_dirty(): "dirty" else: "clean"
        return "FileStatus: {name} ({desc}, {state})"

# File metadata
pub class FileMetadata:
    uri: text
    version: DocumentVersion
    status: FileStatus
    content_hash: text        # SHA-256 hash for change detection
    last_modified: Milliseconds
    size: ByteCount
    language: Option<text>    # Detected language (e.g., "simple", "rust")

    pub fn new(uri: text, version: DocumentVersion, content: text) -> FileMetadata:
        val now_i32 = sys.time.now_ms()
        val now_ms = Milliseconds.from_i32(now_i32)
        val size_i32 = content.len()
        val size_bytes = ByteCount.from_i64(size_i32 as i64)
        FileMetadata {
            uri: uri,
            version: version,
            status: FileStatus.Clean,
            content_hash: compute_hash(content),
            last_modified: now_ms,
            size: size_bytes,
            language: detect_language(uri)
        }

    pub fn update(mut self, new_content: text, new_version: DocumentVersion):
        val new_hash = compute_hash(new_content)
        if new_hash != self.content_hash:
            self.status = FileStatus.Modified
            self.content_hash = new_hash
            self.version = new_version
            val now_i32 = sys.time.now_ms()
            self.last_modified = Milliseconds.from_i32(now_i32)
            val size_i32 = new_content.len()
            self.size = ByteCount.from_i64(size_i32 as i64)

    pub fn mark_deleted(mut self):
        self.status = FileStatus.Deleted
        val now_i32 = sys.time.now_ms()
        self.last_modified = Milliseconds.from_i32(now_i32)

# Workspace manager for multi-file tracking
pub class WorkspaceManager:
    root: text
    files: Dict<text, FileMetadata>      # uri -> metadata
    content_cache: Dict<text, text>    # uri -> content
    dependencies: Dict<text, List<text>>  # uri -> list of dependent uris
    dirty_files: Set<text>               # uris with unsaved changes

    pub fn new(root: text) -> WorkspaceManager:
        WorkspaceManager {
            root: root,
            files: {},
            content_cache: {},
            dependencies: {},
            dirty_files: Set.new()
        }

    # Add or update a file in the workspace
    pub fn add_file(mut self, uri: text, content: text, version: DocumentVersion):
        # Create or update metadata
        match self.files.get(uri):
            Some(existing) ->
                existing.update(content, version)
            None ->
                self.files[uri] = FileMetadata.new(uri, version, content)

        # Cache content
        self.content_cache[uri] = content

        # Mark as dirty if modified
        val metadata = self.files[uri]
        match metadata.status:
            FileStatus.Modified ->
                self.dirty_files.insert(uri)
            FileStatus.Added ->
                self.dirty_files.insert(uri)
            _ ->
                pass

    # Remove a file from the workspace
    pub fn remove_file(mut self, uri: text):
        match self.files.get_mut(uri):
            Some(metadata) ->
                metadata.mark_deleted()
                self.dirty_files.insert(uri)
            None ->
                pass

    # Get file content from cache
    pub fn get_content(self, uri: text) -> Option<text>:
        self.content_cache.get(uri)

    # Get file metadata
    pub fn get_metadata(self, uri: text) -> Option<FileMetadata>:
        self.files.get(uri)

    # Get all files in workspace
    pub fn get_all_files(self) -> List<text>:
        var result = []
        for (uri, metadata) in self.files:
            match metadata.status:
                FileStatus.Deleted ->
                    pass  # Skip deleted files
                _ ->
                    result.push(uri)
        result

    # Get modified files since last sync
    pub fn get_dirty_files(self) -> List<text>:
        self.dirty_files.to_list()

    # Mark all files as clean (after successful sync)
    pub fn mark_all_clean(mut self):
        for (uri, metadata) in self.files:
            match metadata.status:
                FileStatus.Modified ->
                    metadata.status = FileStatus.Clean
                FileStatus.Added ->
                    metadata.status = FileStatus.Clean
                FileStatus.Deleted ->
                    # Remove deleted files completely
                    self.files.remove(uri)
                    self.content_cache.remove(uri)
                _ ->
                    pass

        self.dirty_files.clear()

    # Track dependencies between files
    pub fn add_dependency(mut self, uri: text, depends_on: text):
        match self.dependencies.get_mut(uri):
            Some(deps) ->
                if not deps.contains(depends_on):
                    deps.push(depends_on)
            None ->
                self.dependencies[uri] = [depends_on]

    # Get files that depend on a given file
    pub fn get_dependents(self, uri: text) -> List<text>:
        var result = []
        for (dependent_uri, deps) in self.dependencies:
            if deps.contains(uri):
                result.push(dependent_uri)
        result

    # Get transitive closure of files affected by a change
    pub fn get_affected_files(self, uri: text) -> Set<text>:
        var affected = Set.new()
        var to_process = [uri]

        while to_process.len() > 0:
            val current = to_process.pop()
            if affected.contains(current):
                continue

            affected.insert(current)

            # Add all dependents to processing queue
            val dependents = self.get_dependents(current)
            for dependent in dependents:
                if not affected.contains(dependent):
                    to_process.push(dependent)

        affected

    # Get workspace statistics
    pub fn get_stats(self) -> Dict:
        var total = 0
        var modified = 0
        var added = 0
        var deleted = 0

        for (uri, metadata) in self.files:
            total = total + 1
            match metadata.status:
                FileStatus.Modified ->
                    modified = modified + 1
                FileStatus.Added ->
                    added = added + 1
                FileStatus.Deleted ->
                    deleted = deleted + 1
                _ ->
                    pass

        {
            "total_files": total,
            "modified": modified,
            "added": added,
            "deleted": deleted,
            "dirty": self.dirty_files.len()
        }

# Compute SHA-256 hash of content
fn compute_hash(content: text) -> text:
    # Simplified hash - in real implementation would use crypto library
    var hash = 0
    for ch in content.chars():
        hash = (hash * 31 + ch.to_int()) % 1000000007
    hash.to_string()

# Detect language from file extension
fn detect_language(uri: text) -> Option<text>:
    if uri.ends_with(".spl"):
        Some("simple")
    else if uri.ends_with(".rs"):
        Some("rust")
    else if uri.ends_with(".py"):
        Some("python")
    else if uri.ends_with(".js"):
        Some("javascript")
    else if uri.ends_with(".ts"):
        Some("typescript")
    else:
        None
