# Language Model Server (MCP) Main Server

use transport
use protocol
use error
use session
use workspace
use incremental
use auth

# Server states
pub enum ServerState:
    Uninitialized
    Initialized
    ShuttingDown

impl ServerState:
    pub fn to_string(self) -> text:
        """Convert server state to string."""
        match self:
            case Uninitialized: "uninitialized"
            case Initialized: "initialized"
            case ShuttingDown: "shutting-down"

    pub fn description(self) -> text:
        """Get server state description."""
        match self:
            case Uninitialized: "Server not yet initialized"
            case Initialized: "Server initialized and running"
            case ShuttingDown: "Server shutting down"

    pub fn is_uninitialized(self) -> bool:
        """Check if state is Uninitialized."""
        match self:
            case Uninitialized: true
            case _: false

    pub fn is_initialized(self) -> bool:
        """Check if state is Initialized."""
        match self:
            case Initialized: true
            case _: false

    pub fn is_shutting_down(self) -> bool:
        """Check if state is ShuttingDown."""
        match self:
            case ShuttingDown: true
            case _: false

    pub fn is_running(self) -> bool:
        """Check if server is running (initialized and not shutting down)."""
        return self.is_initialized()

    pub fn can_accept_requests(self) -> bool:
        """Check if server can accept requests."""
        return self.is_initialized()

    pub fn summary(self) -> text:
        """Get server state summary."""
        val name = self.to_string()
        val desc = self.description()
        val status = if self.can_accept_requests(): "ready" else: "not ready"
        return "ServerState: {name} ({desc}, {status})"

# Main server class
pub class LmsServer:
    state: ServerState
    session: session.Session
    capabilities: protocol.ServerCapabilities
    tool_registry: Dict<text, protocol.Tool>
    resource_cache: Dict<text, text>  # URI -> content
    workspace_manager: Option<workspace.WorkspaceManager>  # Multi-file workspace
    incremental_manager: Option<incremental.IncrementalUpdateManager>  # Incremental updates
    auth_manager: auth.AuthManager  # Authentication & authorization
    current_user: Option<auth.User>  # Currently authenticated user

    # Create a new server instance
    pub fn new() -> LmsServer:
        LmsServer {
            state: ServerState.Uninitialized,
            session: session.Session.new(),
            capabilities: create_default_capabilities(),
            tool_registry: create_default_tools(),
            resource_cache: {},
            workspace_manager: None,
            incremental_manager: None,
            auth_manager: auth.AuthManager.new(false),  # Auth disabled by default
            current_user: None
        }

    # Create a new server instance with authentication enabled
    pub fn new_with_auth() -> LmsServer:
        var server = LmsServer.new()
        server.auth_manager = auth.AuthManager.new(true)
        server

    # Main server loop
    pub fn run(mut self) -> Result<Nil, text>:
        transport.log_debug("LMS Server starting...")

        loop:
            # Read JSON-RPC message from stdin
            match transport.read_message():
                Err(e) ->
                    # Check for EOF (client disconnected)
                    if e.contains("EOF") or e.contains("end of file"):
                        transport.log_debug("Client disconnected (EOF)")
                        break
                    transport.log_error("Transport error: {e}")
                    continue

                Ok(message) ->
                    # Update session activity
                    self.session.touch()

                    # Handle message and send response if needed
                    match self.handle_message(message):
                        Ok(response_opt) ->
                            match response_opt:
                                Some(response) ->
                                    match transport.write_message(response):
                                        Ok(_) ->
                                            pass
                                        Err(e) ->
                                            transport.log_error("Failed to write response: {e}")
                                None ->
                                    pass  # No response needed (notification)
                        Err(e) ->
                            transport.log_error("Handler error: {e}")

        transport.log_debug("LMS Server stopped")
        Ok(nil)

    # Handle incoming message
    me fn handle_message(message: Dict) -> Result<Option<Dict>, text>:
        # Check if message has an ID (request) or not (notification)
        val has_id = message.contains_key("id")

        # Get method name
        val method = match message.get("method"):
            Some(m) ->
                match m:
                    text(s) ->
                        s
                    _ ->
                        return Err("Method must be a string")
            None ->
                return Err("Missing 'method' field")

        transport.log_debug("Received method: {method}")

        if has_id:
            # Request - needs response
            self.handle_request(message)
        else:
            # Notification - no response
            self.handle_notification(message)
            Ok(None)

    # Handle request (expects response)
    me fn handle_request(request: Dict) -> Result<Option<Dict>, text>:
        val id = match request.get("id"):
            Some(id_val) ->
                match id_val:
                    i32(i) ->
                        i
                    _ ->
                        return Ok(Some(error.error_response(0, error.LmsError.InvalidRequest("ID must be an integer"))))
            None ->
                return Ok(Some(error.error_response(0, error.LmsError.InvalidRequest("Missing 'id' field"))))

        val method = request.get("method")?.as_string()?

        # Dispatch to handler
        val result = match method:
            "initialize" ->
                self.handle_initialize(request)
            "shutdown" ->
                self.handle_shutdown(request)
            "tools/list" ->
                self.handle_tools_list(request)
            "tools/call" ->
                self.handle_tool_call(request)
            "resources/list" ->
                self.handle_resources_list(request)
            "resources/read" ->
                self.handle_resource_read(request)
            _ ->
                Err(error.LmsError.MethodNotFound(method))

        # Build response
        match result:
            Ok(value) ->
                Ok(Some(error.success_response(id, value)))
            Err(err) ->
                Ok(Some(error.error_response(id, err)))

    # Handle notification (no response)
    me fn handle_notification(notification: Dict) -> Result<Nil, text>:
        val method = notification.get("method")?.as_string()?

        match method:
            "exit" ->
                transport.log_debug("Received exit notification")
                # Exit will happen when stdin closes
            "initialized" ->
                transport.log_debug("Client confirmed initialization")
            _ ->
                transport.log_debug("Ignoring unknown notification: {method}")

        Ok(nil)

    # Handler stubs (will be implemented in handlers/ modules)

    me fn handle_initialize(request: Dict) -> Result<Dict, error.LmsError>:
        # Check already initialized
        match self.state:
            ServerState.Initialized ->
                return Err(error.LmsError.AlreadyInitialized)
            _ ->
                pass

        # Parse params
        val params = match request.get("params"):
            Some(p) ->
                match p:
                    Dict(d) ->
                        d
                    _ ->
                        return Err(error.LmsError.InvalidParams("Params must be an object"))
            None ->
                return Err(error.LmsError.InvalidParams("Missing 'params' field"))

        # Get protocol version
        val protocol_version = match params.get("protocolVersion"):
            Some(v) ->
                match v:
                    text(s) ->
                        s
                    _ ->
                        return Err(error.LmsError.InvalidParams("protocolVersion must be a string"))
            None ->
                return Err(error.LmsError.InvalidParams("Missing 'protocolVersion'"))

        # Validate protocol version
        if protocol_version != "2024-11-05":
            return Err(error.LmsError.ProtocolError("Unsupported protocol version: {protocol_version}"))

        # Get client info if provided
        match params.get("clientInfo"):
            Some(info) ->
                match info:
                    Dict(info_dict) ->
                        val name = info_dict.get("name")?.as_string()?
                        val version = info_dict.get("version")?.as_string()?
                        self.session.set_client_info(protocol.ClientInfo { name, version })
                    _ ->
                        pass
            None ->
                pass

        # Update state
        self.state = ServerState.Initialized

        # Build response
        val server_info = protocol.ServerInfo {
            name: "simple-lms",
            version: "0.1.0"
        }

        Ok(protocol.create_initialize_response(server_info, self.capabilities))

    me fn handle_shutdown(request: Dict) -> Result<Dict, error.LmsError>:
        self.state = ServerState.ShuttingDown
        Ok({})  # Empty result

    me fn handle_tools_list(request: Dict) -> Result<Dict, error.LmsError>:
        # Check initialized
        match self.state:
            ServerState.Uninitialized ->
                return Err(error.LmsError.NotInitialized)
            _ ->
                pass

        # Build tools list
        var tools = []
        for (name, tool) in self.tool_registry:
            tools.push(protocol.tool_to_dict(tool))

        Ok({ "tools": tools })

    me fn handle_tool_call(request: Dict) -> Result<Dict, error.LmsError>:
        # Check initialized
        match self.state:
            ServerState.Uninitialized ->
                return Err(error.LmsError.NotInitialized)
            _ ->
                pass

        # Parse params
        val params = match request.get("params"):
            Some(p) ->
                match p:
                    Dict(d) ->
                        d
                    _ ->
                        return Err(error.LmsError.InvalidParams("Params must be an object"))
            None ->
                return Err(error.LmsError.InvalidParams("Missing 'params'"))

        # Get tool name
        val tool_name = match params.get("name"):
            Some(n) ->
                match n:
                    text(s) ->
                        s
                    _ ->
                        return Err(error.LmsError.InvalidParams("Tool name must be a string"))
            None ->
                return Err(error.LmsError.InvalidParams("Missing 'name'"))

        # Get arguments (optional)
        val arguments = match params.get("arguments"):
            Some(a) ->
                match a:
                    Dict(d) ->
                        Some(d)
                    _ ->
                        None
            None ->
                None

        # Execute tool
        self.execute_tool(tool_name, arguments)

    me fn handle_resources_list(request: Dict) -> Result<Dict, error.LmsError>:
        # Check initialized
        match self.state:
            ServerState.Uninitialized ->
                return Err(error.LmsError.NotInitialized)
            _ ->
                pass

        # Return empty list for now
        Ok({ "resources": [] })

    me fn handle_resource_read(request: Dict) -> Result<Dict, error.LmsError>:
        # Check initialized
        match self.state:
            ServerState.Uninitialized ->
                return Err(error.LmsError.NotInitialized)
            _ ->
                pass

        # Extract uri from request params
        val params = match request.get("params"):
            Some(p) -> p
            None -> return Err(error.LmsError.InvalidParams("Missing params"))

        val uri = match params.get("uri"):
            Some(text(u)) -> u
            Some(_) -> return Err(error.LmsError.InvalidParams("uri must be a string"))
            None -> return Err(error.LmsError.InvalidParams("Missing uri parameter"))

        # Check cache first
        if self.resource_cache.contains_key(uri):
            val cached_content = self.resource_cache.get(uri).unwrap()
            return Ok({
                "contents": [{
                    "uri": uri,
                    "mimeType": "text/plain",
                    "text": cached_content
                }]
            })

        # Handle different URI schemes
        if uri.starts_with("file://"):
            # Read local file
            val path = uri.substring(7, uri.len())  # Remove "file://"
            val content = read_file_content(path)
            match content:
                Some(text) ->
                    # Cache the content
                    self.resource_cache[uri] = text
                    return Ok({
                        "contents": [{
                            "uri": uri,
                            "mimeType": guess_mime_type(path),
                            "text": text
                        }]
                    })
                None ->
                    return Err(error.LmsError.ResourceNotFound("File not found: {path}"))
        else:
            # Unknown URI scheme
            return Err(error.LmsError.InvalidParams("Unsupported URI scheme: {uri}"))

    # Execute a tool
    me fn execute_tool(tool_name: text, arguments: Option<Dict>) -> Result<Dict, error.LmsError>:
        match tool_name:
            "read_file" ->
                self.tool_read_file(arguments)
            "list_directory" ->
                self.tool_list_directory(arguments)
            _ ->
                Err(error.LmsError.MethodNotFound("Unknown tool: {tool_name}"))

    # Tool: read_file
    me fn tool_read_file(arguments: Option<Dict>) -> Result<Dict, error.LmsError>:
        val args = match arguments:
            Some(a) ->
                a
            None ->
                return Err(error.LmsError.InvalidParams("Missing arguments for read_file"))

        val path = match args.get("path"):
            Some(p) ->
                match p:
                    text(s) ->
                        s
                    _ ->
                        return Err(error.LmsError.InvalidParams("path must be a string"))
            None ->
                return Err(error.LmsError.InvalidParams("Missing 'path' argument"))

        # Read file
        match sys.fs.read_file(path):
            Ok(content) ->
                Ok({
                    "content": [
                        {
                            "type": "text",
                            "text": content
                        }
                    ]
                })
            Err(e) ->
                if e.contains("not found"):
                    Err(error.LmsError.FileNotFound(path))
                else if e.contains("permission"):
                    Err(error.LmsError.PermissionDenied(path))
                else:
                    Err(error.LmsError.InternalError("Failed to read file: {e}"))

    # Tool: list_directory
    me fn tool_list_directory(arguments: Option<Dict>) -> Result<Dict, error.LmsError>:
        val args = match arguments:
            Some(a) ->
                a
            None ->
                return Err(error.LmsError.InvalidParams("Missing arguments for list_directory"))

        val path = match args.get("path"):
            Some(p) ->
                match p:
                    text(s) ->
                        s
                    _ ->
                        return Err(error.LmsError.InvalidParams("path must be a string"))
            None ->
                return Err(error.LmsError.InvalidParams("Missing 'path' argument"))

        # List directory
        match sys.fs.list_directory(path):
            Ok(entries) ->
                val entries_text = entries.join("\n")
                Ok({
                    "content": [
                        {
                            "type": "text",
                            "text": entries_text
                        }
                    ]
                })
            Err(e) ->
                Err(error.LmsError.InternalError("Failed to list directory: {e}"))

# Create default server capabilities
static fn create_default_capabilities() -> protocol.ServerCapabilities:
    protocol.ServerCapabilities {
        tools: Some(protocol.ToolsCapability {
            list_changed: Some(false)
        }),
        resources: Some(protocol.ResourcesCapability {
            subscribe: Some(false),
            list_changed: Some(false)
        }),
        prompts: None
    }

# Create default tool registry
static fn create_default_tools() -> Dict<text, protocol.Tool>:
    var tools = {}

    # read_file tool
    tools["read_file"] = protocol.Tool {
        name: "read_file",
        description: "Read the contents of a file",
        input_schema: {
            "type": "object",
            "properties": {
                "path": {
                    "type": "string",
                    "description": "Path to the file to read"
                }
            },
            "required": ["path"]
        }
    }

    # list_directory tool
    tools["list_directory"] = protocol.Tool {
        name: "list_directory",
        description: "List contents of a directory",
        input_schema: {
            "type": "object",
            "properties": {
                "path": {
                    "type": "string",
                    "description": "Path to the directory to list"
                }
            },
            "required": ["path"]
        }
    }

    tools


# Helper: Read file content
fn read_file_content(path: text) -> Option<text>:
    """Read file content as text.

    Args:
        path: File path

    Returns:
        File content or None if not readable
    """
    @extern("runtime", "rt_file_read_text")
    fn _rt_file_read_text(path_ptr: &u8, path_len: u64) -> text

    @extern("runtime", "rt_file_exists")
    fn _rt_file_exists(path_ptr: &u8, path_len: u64) -> bool

    # Check if file exists
    if not _rt_file_exists(path.ptr(), path.len()):
        return None

    # Read content
    val content = _rt_file_read_text(path.ptr(), path.len())
    if content.is_empty():
        return Some("")  # Empty file is valid

    Some(content)


# Helper: Guess MIME type from file path
fn guess_mime_type(path: text) -> text:
    """Guess MIME type from file extension.

    Args:
        path: File path

    Returns:
        MIME type string
    """
    if path.ends_with(".spl"):
        return "text/x-simple"
    elif path.ends_with(".json"):
        return "application/json"
    elif path.ends_with(".md"):
        return "text/markdown"
    elif path.ends_with(".py"):
        return "text/x-python"
    elif path.ends_with(".rs"):
        return "text/x-rust"
    elif path.ends_with(".js"):
        return "text/javascript"
    elif path.ends_with(".ts"):
        return "text/typescript"
    elif path.ends_with(".html"):
        return "text/html"
    elif path.ends_with(".css"):
        return "text/css"
    elif path.ends_with(".xml"):
        return "application/xml"
    elif path.ends_with(".yaml") or path.ends_with(".yml"):
        return "application/yaml"
    elif path.ends_with(".toml"):
        return "application/toml"
    else:
        return "text/plain"
