# File System API - Async file operations (Immutable Variant)
# Functional programming style - all operations return new values
# Uses persistent data structures with structural sharing

use units.file.*
use units.size.*
use units.time.*
use host.common.io.*  # Imports error, types, fs_types, fs_ffi
use core.traits.*

# Immutable directory entries collection
# Uses persistent list for functional iteration
struct DirEntries:
    entries: List<DirEntry>

impl DirEntries:
    fn new(entries: Array<DirEntry>) -> DirEntries:
        DirEntries { entries: List.from_array(entries) }

    # Functional iteration - returns (entry, remaining)
    fn next() -> Option<(DirEntry, DirEntries)>:
        match self.entries.head():
            case Some(entry):
                match self.entries.tail():
                    case Some(rest): return Some((entry, DirEntries { entries: rest }))
                    case None: return Some((entry, DirEntries { entries: List.empty() }))
            case None: return None

    fn is_empty() -> bool:
        self.entries.is_empty()

    fn len() -> u64:
        self.entries.len()

    # Functional transformations - returns new DirEntries (immutable)
    fn filtered(pred: fn(DirEntry) -> bool) -> DirEntries:
        DirEntries { entries: self.entries.filtered(pred) }

    fn map<U>(self, f: fn(DirEntry) -> U) -> List<U>:
        self.entries.map(f)

    fn find(pred: fn(DirEntry) -> bool) -> Option<DirEntry>:
        self.entries.find(pred)

    # =========================================================================
    # Helper Methods
    # =========================================================================

    fn count() -> u64:
        """Get number of entries (alias for len).

        Returns:
            Entry count

        Example:
            entries.count()  # → 10
        """
        return self.len()

    fn has_entries() -> bool:
        """Check if directory has entries (not empty).

        Returns:
            true if entries exist

        Example:
            entries.has_entries()  # → true
        """
        return not self.is_empty()

    fn to_array() -> Array<DirEntry>:
        """Convert to array.

        Returns:
            Array of directory entries

        Example:
            entries.to_array()
        """
        return self.entries.to_array()

    fn filter_files() -> DirEntries:
        """Filter to only file entries.

        Returns:
            New DirEntries with only files

        Example:
            entries.filter_files()
        """
        return self.filtered(|e| e.is_file())

    fn filter_dirs() -> DirEntries:
        """Filter to only directory entries.

        Returns:
            New DirEntries with only directories

        Example:
            entries.filter_dirs()
        """
        return self.filtered(|e| e.is_dir())

    fn summary() -> text:
        """Get directory entries summary.

        Returns:
            Human-readable summary

        Example:
            entries.summary()
            # → "DirEntries: 10 items"
        """
        val count = self.count()
        return "DirEntries: {count} items"

# ===============================
# File System Operations (Pure Functions)
# ===============================

# Read entire file as bytes
pub async fn read(path: FilePath) -> Result<Bytes, IoError>:
    return native_fs_read(path)

# Read entire file as text (UTF-8)
pub async fn read_text(path: FilePath) -> Result<Text, IoError>:
    val bytes = await read(path)?
    match bytes.to_utf8():
        case Ok(s): return Ok(s_text)
        case Err(_): return Err(IoError::InvalidData)

# Write bytes to file (creates or overwrites)
pub async fn write(path: FilePath, data: Bytes) -> Result<ByteCount, IoError>:
    return native_fs_write(path, &data)

# Write text to file (UTF-8)
pub async fn write_text(path: FilePath, text: Text) -> Result<ByteCount, IoError>:
    val bytes = (text as str).to_bytes()
    return await write(path, bytes)

# Append bytes to file
pub async fn append(path: FilePath, data: Bytes) -> Result<ByteCount, IoError>:
    return native_fs_append(path, &data)

# Append text to file
pub async fn append_text(path: FilePath, text: Text) -> Result<ByteCount, IoError>:
    val bytes = (text as str).to_bytes()
    return await append(path, bytes)

# ===============================
# Directory Operations
# ===============================

# Create directory
pub async fn create_dir(path: DirPath) -> Result<(), IoError>:
    return native_fs_create_dir(path, false)

# Create directory and all parent directories
pub async fn create_dir_all(path: DirPath) -> Result<(), IoError>:
    return native_fs_create_dir(path, true)

# Remove file
pub async fn remove(path: FilePath) -> Result<(), IoError>:
    return native_fs_remove_file(path)

# Remove empty directory
pub async fn remove_dir(path: DirPath) -> Result<(), IoError>:
    return native_fs_remove_dir(path, false)

# Remove directory and all contents
pub async fn remove_dir_all(path: DirPath) -> Result<(), IoError>:
    return native_fs_remove_dir(path, true)

# Rename file or directory
pub async fn rename(src: FilePath, dst: FilePath) -> Result<(), IoError>:
    return native_fs_rename(src, dst)

# Copy file
pub async fn copy(src: FilePath, dst: FilePath) -> Result<ByteCount, IoError>:
    return native_fs_copy(src, dst)

# ===============================
# Metadata Operations
# ===============================

# Check if path exists
pub async fn exist(path: FilePath) -> bool:
    match native_fs_metadata(path):
        case Ok(_): return true
        case Err(_): return false

# Get file metadata
pub async fn metadata(path: FilePath) -> Result<FileMetadata, IoError>:
    return native_fs_metadata(path)

# List directory contents (returns immutable DirEntries)
pub async fn read_dir(path: DirPath) -> Result<DirEntries, IoError>:
    val native_entries = native_fs_read_dir(path)?
    return Ok(DirEntries::new(native_entries.entries))

# ===============================
# Immutable File Handle
# ===============================

# Immutable file handle for streaming operations
# Each operation returns a new FileReader/FileWriter state
struct FileReader:
    handle: i64
    path: FilePath
    position: ByteCount

impl FileReader:
    # Open file for reading
    pub async fn open(path: FilePath) -> Result<FileReader, IoError>:
        val handle = native_fs_open(path, OpenMode::Read)?
        return Ok(FileReader { handle: handle, path: path, position: 0_bytes })

    # Read and return (bytes_read, new_reader_state)
    pub async fn read(self, max_bytes: ByteCount) -> Result<(Bytes, FileReader), IoError>:
        val buf = Bytes::with_capacity(max_bytes as u64)
        val n = native_file_read(self.handle, &buf)?
        val new_pos = self.position + n
        return Ok((buf, FileReader { handle: self.handle, path: self.path, position: new_pos }))

    # Read all remaining bytes
    pub async fn read_all(self) -> Result<Bytes, IoError>:
        var result = Bytes::empty()
        var reader = self
        loop:
            val (chunk, next) = await reader.read(8192_bytes)?
            if chunk.is_empty():
                break
            result = result.append(chunk)
            reader = next
        return Ok(result)

    fn position() -> ByteCount:
        self.position

    # Seek and return new reader state
    pub async fn seek(self, pos: SeekFrom) -> Result<FileReader, IoError>:
        val new_pos = native_file_seek(self.handle, pos)?
        return Ok(FileReader { handle: self.handle, path: self.path, position: new_pos })

    # Close (consumes reader)
    pub async fn close(self) -> Result<(), IoError>:
        return native_file_close(self.handle)

    # =========================================================================
    # Helper Methods
    # =========================================================================

    fn get_handle() -> i64:
        """Get file handle.

        Returns:
            File handle identifier

        Example:
            reader.get_handle()  # → 42
        """
        return self.handle

    fn get_path() -> FilePath:
        """Get file path.

        Returns:
            Path to the file

        Example:
            reader.get_path()
        """
        return self.path

    fn get_position() -> ByteCount:
        """Get current position (alias for position).

        Returns:
            Current read position

        Example:
            reader.get_position()  # → 1024_bytes
        """
        return self.position()

    fn has_read() -> bool:
        """Check if any bytes have been read.

        Returns:
            true if position > 0

        Example:
            reader.has_read()  # → true
        """
        return self.position > 0_bytes

    fn at_start() -> bool:
        """Check if reader is at start of file.

        Returns:
            true if position is 0

        Example:
            reader.at_start()  # → false
        """
        return self.position == 0_bytes

    fn summary() -> text:
        """Get file reader summary.

        Returns:
            Human-readable summary

        Example:
            reader.summary()
            # → "FileReader: path.txt, position=1024 bytes"
        """
        val path_str = self.path.to_string()
        val pos = self.position
        return "FileReader: {path_str}, position={pos}"

struct FileWriter:
    handle: i64
    path: FilePath
    bytes_written: ByteCount

impl FileWriter:
    # Open file for writing
    pub async fn open(path: FilePath) -> Result<FileWriter, IoError>:
        val handle = native_fs_open(path, OpenMode::Write)?
        return Ok(FileWriter { handle: handle, path: path, bytes_written: 0_bytes })

    # Create new file
    pub async fn create(path: FilePath) -> Result<FileWriter, IoError>:
        val handle = native_fs_open(path, OpenMode::Create)?
        return Ok(FileWriter { handle: handle, path: path, bytes_written: 0_bytes })

    # Write and return new writer state
    pub async fn write(self, data: Bytes) -> Result<FileWriter, IoError>:
        val n = native_file_write(self.handle, &data)?
        return Ok(FileWriter {
            handle: self.handle,
            path: self.path,
            bytes_written: self.bytes_written + n
        })

    fn bytes_written() -> ByteCount:
        self.bytes_written

    # Flush and return new state
    pub async fn flush(self) -> Result<FileWriter, IoError>:
        native_file_flush(self.handle)?
        return Ok(self)

    # Sync to disk and return new state
    pub async fn sync(self) -> Result<FileWriter, IoError>:
        native_file_sync(self.handle)?
        return Ok(self)

    # Close (consumes writer)
    pub async fn close(self) -> Result<(), IoError>:
        return native_file_close(self.handle)

    # =========================================================================
    # Helper Methods
    # =========================================================================

    fn get_handle() -> i64:
        """Get file handle.

        Returns:
            File handle identifier

        Example:
            writer.get_handle()  # → 42
        """
        return self.handle

    fn get_path() -> FilePath:
        """Get file path.

        Returns:
            Path to the file

        Example:
            writer.get_path()
        """
        return self.path

    fn get_bytes_written() -> ByteCount:
        """Get bytes written (alias for bytes_written).

        Returns:
            Total bytes written

        Example:
            writer.get_bytes_written()  # → 2048_bytes
        """
        return self.bytes_written()

    fn has_written() -> bool:
        """Check if any bytes have been written.

        Returns:
            true if bytes_written > 0

        Example:
            writer.has_written()  # → true
        """
        return self.bytes_written > 0_bytes

    fn is_fresh() -> bool:
        """Check if writer hasn't written anything yet.

        Returns:
            true if bytes_written == 0

        Example:
            writer.is_fresh()  # → false
        """
        return self.bytes_written == 0_bytes

    fn summary() -> text:
        """Get file writer summary.

        Returns:
            Human-readable summary

        Example:
            writer.summary()
            # → "FileWriter: output.txt, written=2048 bytes"
        """
        val path_str = self.path.to_string()
        val written = self.bytes_written
        return "FileWriter: {path_str}, written={written}"

# ===============================
# Functional File Operations
# ===============================

# Process file line by line with a pure function
pub async fn process_lines<U>(
    path: FilePath,
    init: U,
    f: fn(U, Text) -> U
) -> Result<U, IoError>:
    val text = await read_text(path)?
    val lines = (text as str).lines()
    return Ok(lines.fold(init, |acc, line| f(acc, line_text)))

# Transform file contents
pub async fn transform(
    src: FilePath,
    dst: FilePath,
    f: fn(Bytes) -> Bytes
) -> Result<ByteCount, IoError>:
    val data = await read(src)?
    val transformed = f(data)
    return await write(dst, transformed)

# Transform text file
pub async fn transform_text(
    src: FilePath,
    dst: FilePath,
    f: fn(Text) -> Text
) -> Result<ByteCount, IoError>:
    val text = await read_text(src)?
    val transformed = f(text)
    return await write_text(dst, transformed)

# Native function declarations imported from host.common.io.fs_ffi
