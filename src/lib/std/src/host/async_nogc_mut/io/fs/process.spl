# Process Management with Staged Files
#
# Mold-inspired process spawning with pre-staged file mappings.

use units.file.*
use host.common.io.*

pub use spawn_worker_with_staging, spawn_workers_with_staging, stage

use file.File

# ===============================
# Process Spawning with Staging
# ===============================

# Spawn worker process with pre-staged files (mold-style)
#
# This pre-stages files in the parent process, then spawns a child
# that inherits the memory mappings for zero-copy access.
pub async fn spawn_worker_with_staging(
    files: Array<FilePath>,
    mode: StageMode,
    worker_fn: fn() -> i64
) -> Result<ProcessHandle, IoError>:
    # Stage all files in parent process with SHARED mapping
    var staged_handles: Array<i64> = []
    for path in files:
        val file = await File.open_read(path)?

        match mode:
            case StageMode.MmapShared:
                await file.stage_mmap_shared()?
            case StageMode.Mmap:
                # Upgrade to shared for cross-process use
                await file.stage_mmap_shared()?
            case _:
                # Only mmap modes work for cross-process
                return Err(IoError.InvalidArgument)

        # Keep file open so mapping stays alive
        if val Some(state) = file.stage_state:
            staged_handles.push(state.mmap_ptr)

    # Spawn child process - inherits all mmap regions
    val pid = native_spawn_worker(worker_fn)?

    return Ok(ProcessHandle {
        pid: pid,
        staged_files: files
    })

# Spawn multiple workers with same staged files (parallel compilation)
pub async fn spawn_workers_with_staging(
    files: Array<FilePath>,
    mode: StageMode,
    num_workers: u64,
    worker_fn: fn() -> i64
) -> Result<Array<ProcessHandle>, IoError>:
    # Stage all files ONCE in parent
    for path in files:
        val file = await File.open_read(path)?
        await file.stage_mmap_shared()?

    # Spawn N workers - all share the same mappings
    var workers: Array<ProcessHandle> = []
    for i in range(num_workers):
        val pid = native_spawn_worker(worker_fn)?
        workers.push(ProcessHandle {
            pid: pid,
            staged_files: files.clone()
        })

    return Ok(workers)

# ===============================
# Module-Level Stage Function
# ===============================

# Stage multiple files with same strategy (module-level function)
pub async fn stage(mode: StageMode, ...files: FilePath) -> Result<(), IoError>:
    for path in files:
        val file = await File.open_read(path)?

        match mode:
            case StageMode.None:
                file.unstage()
            case StageMode.Mmap:
                await file.stage_mmap()?
            case StageMode.MmapShared:
                await file.stage_mmap_shared()?
            case StageMode.Prefetch:
                await file.stage_prefetch()?
            case StageMode.Adaptive:
                await file.stage_auto()?

    return Ok(())
