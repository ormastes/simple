# File Handle Operations
#
# File struct with staging support for mold-inspired optimizations.

use units.file.*
use units.size.*
use host.common.io.*
use core.resource.AsyncResource
use core.leak_tracked.LeakTracked

export File

import ops.exist

# ===============================
# File Handle
# ===============================

# File handle for streaming operations with staging support
struct File with LeakTracked:
    handle: i64
    path: FilePath
    mode: OpenMode
    stage_state: Option<StageState>  # Staging state

impl File:
    # Open file with mode (auto-staging enabled by default)
    pub async fn open(path: FilePath, mode: OpenMode) -> Result<File, IoError>:
        # Resolve relative paths to absolute paths
        val resolved_path = native_path_resolve(path)?

        # Check file existence for read/write modes
        if mode == OpenMode::Read or mode == OpenMode::Write:
            val file_exists = await exist(resolved_path)
            if not file_exists and mode == OpenMode::Read:
                return Err(IoError::NotFound)

        # Open file handle
        val handle = native_fs_open(resolved_path, mode)?
        var file = File {
            handle: handle,
            path: resolved_path,
            mode: mode,
            stage_state: nil
        }

        # Auto-stage on read mode for performance
        # This is async but we await completion before returning
        if mode == OpenMode::Read:
            await file.stage_auto()?

        # Start leak tracking
        file._start_tracking("File.open(\"{resolved_path}\")")

        return Ok(file)

    # Read convenience methods
    pub async fn open_read(path: FilePath) -> Result<File, IoError>:
        return File::open(path, OpenMode::Read)

    pub async fn open_write(path: FilePath) -> Result<File, IoError>:
        return File::open(path, OpenMode::Write)

    pub async fn create(path: FilePath) -> Result<File, IoError>:
        return File::open(path, OpenMode::Create)

    # Wait for staging to complete if in progress
    async fn wait_for_staging(self):
        if val Some(state) = self.stage_state:
            while state.status == StagingStatus::Staging:
                await async_yield()

    # Read up to `buf.len()` bytes (optimized with staging)
    pub async fn read(self, buf: &mut Bytes) -> Result<ByteCount, IoError>:
        await self.wait_for_staging()
        if val Some(state) = self.stage_state:
            match state.mode:
                case StageMode::Mmap:
                    val pos_result = await self.position()?
                    val pos = pos_result as u64
                    val to_read = buf.len().min(state.mmap_size - pos)
                    if to_read > 0:
                        native_mmap_read(state.mmap_ptr, pos, buf, to_read)
                        await self.seek(SeekFrom::Current(to_read as i64))?
                    return Ok(to_read_bytes)

                case StageMode::MmapShared:
                    val pos_result = await self.position()?
                    val pos = pos_result as u64
                    val to_read = buf.len().min(state.mmap_size - pos)
                    if to_read > 0:
                        native_mmap_read(state.mmap_ptr, pos, buf, to_read)
                        await self.seek(SeekFrom::Current(to_read as i64))?
                    return Ok(to_read_bytes)

                case StageMode::Prefetch:
                    if val Some(prefetch) = state.prefetch_buf:
                        val pos_result = await self.position()?
                        val pos = pos_result as u64
                        val to_read = buf.len().min(prefetch.len() - pos)
                        if to_read > 0:
                            buf.copy_from(&prefetch.slice(pos, pos + to_read), 0, to_read)
                            await self.seek(SeekFrom::Current(to_read as i64))?
                        return Ok(to_read_bytes)

                case _:
                    pass

        return native_file_read(self.handle, buf)

    # Read exact number of bytes
    pub async fn read_exact(self, buf: &mut Bytes) -> Result<(), IoError>:
        var read_total: u64 = 0
        val target = buf.len()
        while read_total < target:
            val remaining = target - read_total
            val slice = buf.slice_mut(read_total, target)
            val n = await self.read(&mut slice)?
            if (n as u64) == 0:
                return Err(IoError::UnexpectedEof)
            read_total = read_total + (n as u64)
        return Ok(())

    # Write bytes
    pub async fn write(self, data: &Bytes) -> Result<ByteCount, IoError>:
        await self.wait_for_staging()
        return native_file_write(self.handle, data)

    # Write all bytes
    pub async fn write_all(self, data: &Bytes) -> Result<(), IoError>:
        var written: u64 = 0
        val total = data.len()
        while written < total:
            val slice = data.slice(written, total)
            val n = await self.write(&slice)?
            written = written + (n as u64)
        return Ok(())

    # Flush buffers
    pub async fn flush(self) -> Result<(), IoError>:
        return native_file_flush(self.handle)

    # Seek position
    pub async fn seek(self, pos: SeekFrom) -> Result<ByteCount, IoError>:
        await self.wait_for_staging()
        return native_file_seek(self.handle, pos)

    # Get current position
    pub async fn position(self) -> Result<ByteCount, IoError>:
        return self.seek(SeekFrom::Current(0))

    # Get file size
    pub async fn size(self) -> Result<ByteCount, IoError>:
        val current = await self.position()?
        val end = await self.seek(SeekFrom::End(0))?
        await self.seek(SeekFrom::Start(current as u64))?
        return Ok(end)

    # Sync to disk
    pub async fn sync_all(self) -> Result<(), IoError>:
        return native_file_sync(self.handle)

    # Close file
    pub async fn close(self) -> Result<(), IoError>:
        # Stop leak tracking
        self._stop_tracking()

        if val Some(state) = self.stage_state:
            if state.mode == StageMode::Mmap and state.mmap_ptr != 0:
                native_mmap_unmap(state.mmap_ptr, state.mmap_size)
        return native_file_close(self.handle)

    # ===============================
    # Staging API - Mold-inspired optimizations
    # ===============================

    # Auto-stage file based on size (adaptive strategy)
    pub async fn stage_auto(self) -> Result<(), IoError>:
        self.stage_state = Some(StageState {
            mode: StageMode::Adaptive,
            status: StagingStatus::Staging,
            mmap_ptr: 0,
            mmap_size: 0,
            is_shared: false,
            prefetch_buf: nil,
            staged_files: Array<FilePath>::new()
        })

        val size = await self.size()?
        val size_u64 = size as u64

        if size_u64 > 1_048_576:  # 1MB threshold
            return self.stage_mmap()
        elif size_u64 > 0:
            return self.stage_prefetch()
        else:
            if val Some(state) = self.stage_state:
                state.status = StagingStatus::Staged
            return Ok(())

    # Stage with varargs - stage multiple files with same strategy
    pub async fn stage(self, mode: StageMode, ...files: FilePath) -> Result<(), IoError>:
        self.stage_state = Some(StageState {
            mode: mode,
            status: StagingStatus::Staging,
            mmap_ptr: 0,
            mmap_size: 0,
            is_shared: false,
            prefetch_buf: nil,
            staged_files: Array<FilePath>::new()
        })

        match mode:
            case StageMode::None:
                self.unstage()
            case StageMode::Mmap:
                await self.stage_mmap()?
            case StageMode::MmapShared:
                await self.stage_mmap_shared()?
            case StageMode::Prefetch:
                await self.stage_prefetch()?
            case StageMode::Adaptive:
                await self.stage_auto()?

        var file_paths = Array<FilePath>::new()
        for path in files:
            file_paths.push(path)

        if val Some(state) = self.stage_state:
            state.staged_files = file_paths

        for path in files:
            val related = await File::open(path, self.mode)?
            match mode:
                case StageMode::Mmap:
                    await related.stage_mmap()?
                case StageMode::MmapShared:
                    await related.stage_mmap_shared()?
                case StageMode::Prefetch:
                    await related.stage_prefetch()?
                case StageMode::Adaptive:
                    await related.stage_auto()?
                case StageMode::None:
                    related.unstage()
            await related.close()?

        if val Some(state) = self.stage_state:
            state.status = StagingStatus::Staged

        return Ok(())

    # Memory-map the file for fast random access (process-private)
    pub async fn stage_mmap(self) -> Result<(), IoError>:
        self.stage_state = Some(StageState {
            mode: StageMode::Mmap,
            status: StagingStatus::Staging,
            mmap_ptr: 0,
            mmap_size: 0,
            is_shared: false,
            prefetch_buf: nil,
            staged_files: Array<FilePath>::new()
        })

        val size = await self.size()?
        val size_u64 = size as u64

        if size_u64 == 0:
            if val Some(state) = self.stage_state:
                state.status = StagingStatus::Staged
            return Ok(())

        val mmap_ptr = native_mmap_create(self.handle, size_u64)?

        self.stage_state = Some(StageState {
            mode: StageMode::Mmap,
            status: StagingStatus::Staged,
            mmap_ptr: mmap_ptr,
            mmap_size: size_u64,
            is_shared: false,
            prefetch_buf: nil,
            staged_files: Array<FilePath>::new()
        })

        return Ok(())

    # Memory-map the file for fast random access (SHARED across processes)
    pub async fn stage_mmap_shared(self) -> Result<(), IoError>:
        self.stage_state = Some(StageState {
            mode: StageMode::MmapShared,
            status: StagingStatus::Staging,
            mmap_ptr: 0,
            mmap_size: 0,
            is_shared: true,
            prefetch_buf: nil,
            staged_files: Array<FilePath>::new()
        })

        val size = await self.size()?
        val size_u64 = size as u64

        if size_u64 == 0:
            if val Some(state) = self.stage_state:
                state.status = StagingStatus::Staged
            return Ok(())

        val mmap_ptr = native_mmap_create_shared(self.handle, size_u64)?

        self.stage_state = Some(StageState {
            mode: StageMode::MmapShared,
            status: StagingStatus::Staged,
            mmap_ptr: mmap_ptr,
            mmap_size: size_u64,
            is_shared: true,
            prefetch_buf: nil,
            staged_files: Array<FilePath>::new()
        })

        return Ok(())

    # Prefetch entire file into memory
    pub async fn stage_prefetch(self) -> Result<(), IoError>:
        self.stage_state = Some(StageState {
            mode: StageMode::Prefetch,
            status: StagingStatus::Staging,
            mmap_ptr: 0,
            mmap_size: 0,
            is_shared: false,
            prefetch_buf: nil,
            staged_files: Array<FilePath>::new()
        })

        val size = await self.size()?
        val size_u64 = size as u64

        if size_u64 == 0:
            if val Some(state) = self.stage_state:
                state.status = StagingStatus::Staged
            return Ok(())

        await self.seek(SeekFrom::Start(0))?
        var buffer = Bytes::with_capacity(size_u64)
        await self.read_exact(&mut buffer)?
        await self.seek(SeekFrom::Start(0))?

        self.stage_state = Some(StageState {
            mode: StageMode::Prefetch,
            status: StagingStatus::Staged,
            mmap_ptr: 0,
            mmap_size: 0,
            is_shared: false,
            prefetch_buf: Some(buffer),
            staged_files: Array<FilePath>::new()
        })

        native_fadvise_sequential(self.handle)

        return Ok(())

    # Remove staging (fallback to normal I/O)
    pub fn unstage(self):
        unstage_cleanup(self.stage_state)
        self.stage_state = nil

    # Check if file is staged
    pub fn is_staged(self) -> bool:
        return is_staged(self.stage_state)

    # Get staging mode
    pub fn get_stage_mode(self) -> StageMode:
        return get_stage_mode(self.stage_state)

    # ===============================
    # Synchronous Operations
    # ===============================

    # Open file (sync, blocking)
    pub fn open_sync(path: FilePath, mode: OpenMode) -> Result<File, IoError>:
        # Resolve relative paths to absolute paths
        val resolved_path = native_path_resolve(path)?

        # Check file existence for read mode
        if mode == OpenMode::Read:
            if not native_file_exists_sync(resolved_path):
                return Err(IoError::NotFound)

        # Open file handle
        val handle = native_fs_open(resolved_path, mode)?
        var file = File {
            handle: handle,
            path: resolved_path,
            mode: mode,
            stage_state: nil
        }

        # Start leak tracking
        file._start_tracking("File.open_sync(\"{resolved_path}\")")

        return Ok(file)

    # Read convenience methods (sync)
    pub fn open_read_sync(path: FilePath) -> Result<File, IoError>:
        return File::open_sync(path, OpenMode::Read)

    pub fn open_write_sync(path: FilePath) -> Result<File, IoError>:
        return File::open_sync(path, OpenMode::Write)

    pub fn create_sync(path: FilePath) -> Result<File, IoError>:
        return File::open_sync(path, OpenMode::Create)

    # Read bytes (sync)
    pub fn read_sync(self, buf: &mut Bytes) -> Result<ByteCount, IoError>:
        return read_sync_with_staging(self.handle, buf, self.stage_state)

    # Read exact bytes (sync)
    pub fn read_exact_sync(self, buf: &mut Bytes) -> Result<(), IoError>:
        var read_total: u64 = 0
        val target = buf.len()
        while read_total < target:
            val slice = buf.slice_mut(read_total, target)
            val n = self.read_sync(&mut slice)?
            if (n as u64) == 0:
                return Err(IoError::UnexpectedEof)
            read_total = read_total + (n as u64)
        return Ok(())

    # Write bytes (sync)
    pub fn write_sync(self, data: &Bytes) -> Result<ByteCount, IoError>:
        return native_file_write_sync(self.handle, data)

    # Write all bytes (sync)
    pub fn write_all_sync(self, data: &Bytes) -> Result<(), IoError>:
        return write_all_sync_impl(self.handle, data)

    # Flush buffers (sync)
    pub fn flush_sync(self) -> Result<(), IoError>:
        return native_file_flush_sync(self.handle)

    # Seek position (sync)
    pub fn seek_sync(self, pos: SeekFrom) -> Result<ByteCount, IoError>:
        return native_file_seek_sync(self.handle, pos)

    # Get current position (sync)
    pub fn position_sync(self) -> Result<ByteCount, IoError>:
        return self.seek_sync(SeekFrom::Current(0))

    # Get file size (sync)
    pub fn size_sync(self) -> Result<ByteCount, IoError>:
        val current = self.position_sync()?
        val end = self.seek_sync(SeekFrom::End(0))?
        self.seek_sync(SeekFrom::Start(current as u64))?
        return Ok(end)

    # Sync to disk (sync)
    pub fn sync_all_sync(self) -> Result<(), IoError>:
        return native_file_sync_sync(self.handle)

    # Close file (sync)
    pub fn close_sync(self) -> Result<(), IoError>:
        # Stop leak tracking
        self._stop_tracking()
        return close_sync_with_staging(self.handle, self.stage_state)

    # ===============================
    # Positioned I/O (pread/pwrite)
    # ===============================

    # Read at offset without changing file position (thread-safe)
    pub fn pread(self, buf: &mut Bytes, offset: u64) -> Result<ByteCount, IoError>:
        return pread_with_staging(self.handle, buf, offset, self.stage_state)

    # Write at offset without changing file position (thread-safe)
    pub fn pwrite(self, data: &Bytes, offset: u64) -> Result<ByteCount, IoError>:
        return pwrite_impl(self.handle, data, offset)

    # ===============================
    # Sync Staging with Preload
    # ===============================

    # Stage file with mmap preload (sync, for use before parallel processing)
    pub fn stage_mmap_sync(self) -> Result<(), IoError>:
        val size = self.size_sync()?
        self.stage_state = Some(stage_mmap_sync_impl(self.handle, size as u64)?)
        return Ok(())

    # Stage file with shared mmap (sync, for multi-process access)
    pub fn stage_mmap_shared_sync(self) -> Result<(), IoError>:
        val size = self.size_sync()?
        self.stage_state = Some(stage_mmap_shared_sync_impl(self.handle, size as u64)?)
        return Ok(())

    # Stage file by prefetching entire content (sync)
    pub fn stage_prefetch_sync(self) -> Result<(), IoError>:
        val size = self.size_sync()?
        val size_u64 = size as u64

        if size_u64 == 0:
            self.stage_state = Some(create_empty_staged_state(StageMode::Prefetch, false))
            return Ok(())

        self.seek_sync(SeekFrom::Start(0))?
        var buffer = Bytes::with_capacity(size_u64)
        self.read_exact_sync(&mut buffer)?
        self.seek_sync(SeekFrom::Start(0))?

        self.stage_state = Some(create_staged_prefetch_state(buffer))
        native_fadvise_sequential(self.handle)
        return Ok(())

# ===============================
# Resource Trait Implementation
# ===============================

impl AsyncResource for File:
    async fn close():
        # Stop leak tracking
        self._stop_tracking()
        val _ = native_file_close(self.handle)

    fn is_open() -> bool:
        self.handle != -1

    fn resource_name() -> text:
        "File({self.path})"
