# Common Terminal Types
# Shared across all host variants (async_nogc_mut, async_gc_immut, etc.)

use core.traits.*

export TermSize, CursorPos, TermError, KeyEvent, KeyCode, KeyModifiers

# Terminal size
pub struct TermSize:
    rows: u16
    cols: u16

impl TermSize:
    pub fn new(rows: u16, cols: u16) -> TermSize:
        TermSize { rows: rows, cols: cols }

    pub fn rows(self) -> u16:
        self.rows

    pub fn cols(self) -> u16:
        self.cols

    pub fn area(self) -> u32:
        (self.rows as u32) * (self.cols as u32)

    pub fn is_empty(self) -> bool:
        """Check if terminal has zero size.

        Returns:
            True if rows or cols is 0
        """
        self.rows == 0 or self.cols == 0

    pub fn is_small(self) -> bool:
        """Check if terminal is small.

        Returns:
            True if less than 80x24
        """
        self.cols < 80 or self.rows < 24

    pub fn is_large(self) -> bool:
        """Check if terminal is large.

        Returns:
            True if at least 120x40
        """
        self.cols >= 120 and self.rows >= 40

    pub fn is_square(self) -> bool:
        """Check if terminal is roughly square.

        Returns:
            True if aspect ratio is close to 1:1
        """
        val ratio = (self.cols as f32) / (self.rows as f32)
        ratio >= 0.9 and ratio <= 1.1

    pub fn is_landscape(self) -> bool:
        """Check if terminal is landscape orientation.

        Returns:
            True if wider than tall
        """
        self.cols > self.rows

    pub fn is_portrait(self) -> bool:
        """Check if terminal is portrait orientation.

        Returns:
            True if taller than wide
        """
        self.rows > self.cols

    pub fn summary(self) -> text:
        """Get terminal size summary.

        Returns:
            Human-readable summary
        """
        val area = self.area()
        val orientation = if self.is_landscape(): "landscape" else if self.is_portrait(): "portrait" else: "square"
        return "TermSize: {self.cols}x{self.rows} ({area} cells, {orientation})"

impl Display for TermSize:
    fn fmt() -> str:
        "{self.cols}x{self.rows}"

impl Eq for TermSize:
    fn eq(other: &Self) -> bool:
        self.rows == other.rows and self.cols == other.cols

# Cursor position
pub struct CursorPos:
    row: u16
    col: u16

impl CursorPos:
    pub fn new(row: u16, col: u16) -> CursorPos:
        CursorPos { row: row, col: col }

    pub fn row(self) -> u16:
        self.row

    pub fn col(self) -> u16:
        self.col

    pub fn is_origin(self) -> bool:
        """Check if cursor is at origin (0, 0).

        Returns:
            True if at top-left corner
        """
        self.row == 0 and self.col == 0

    pub fn is_same_row(self, other: &CursorPos) -> bool:
        """Check if on same row as another position.

        Args:
            other: Position to compare

        Returns:
            True if same row
        """
        self.row == other.row

    pub fn is_same_col(self, other: &CursorPos) -> bool:
        """Check if on same column as another position.

        Args:
            other: Position to compare

        Returns:
            True if same column
        """
        self.col == other.col

    pub fn distance_to(self, other: &CursorPos) -> u32:
        """Calculate Manhattan distance to another position.

        Args:
            other: Target position

        Returns:
            Distance in cells
        """
        val row_diff = if self.row > other.row:
            self.row - other.row
        else:
            other.row - self.row

        val col_diff = if self.col > other.col:
            self.col - other.col
        else:
            other.col - self.col

        (row_diff as u32) + (col_diff as u32)

    pub fn summary(self) -> text:
        """Get cursor position summary.

        Returns:
            Human-readable summary
        """
        if self.is_origin():
            return "CursorPos: ({self.row}, {self.col}) at origin"
        return "CursorPos: ({self.row}, {self.col})"

impl Display for CursorPos:
    fn fmt() -> str:
        "({self.row}, {self.col})"

impl Eq for CursorPos:
    fn eq(other: &Self) -> bool:
        self.row == other.row and self.col == other.col

# Terminal error type
pub enum TermError:
    Io(i32)
    NotTty
    InvalidResponse
    Eof
    Timeout
    Interrupted
    Unknown

impl TermError:
    pub fn from_code(code: i32) -> TermError:
        match code:
            case -1: TermError.Eof
            case -2: TermError.NotTty
            case -3: TermError.Timeout
            case -4: TermError.Interrupted
            case _: TermError.Io(code)

    pub fn message(self) -> str:
        match self:
            case Io(code): "I/O error: {code}"
            case NotTty: "not a tty"
            case InvalidResponse: "invalid terminal response"
            case Eof: "end of file"
            case Timeout: "operation timed out"
            case Interrupted: "operation interrupted"
            case Unknown: "unknown error"

    pub fn to_string(self) -> str:
        """Convert error to string.

        Returns:
            Error name

        Example:
            TermError.Timeout.to_string()  # → "timeout"
        """
        match self:
            case Io(_): "io"
            case NotTty: "not-tty"
            case InvalidResponse: "invalid-response"
            case Eof: "eof"
            case Timeout: "timeout"
            case Interrupted: "interrupted"
            case Unknown: "unknown"

    pub fn description(self) -> str:
        """Get error description.

        Returns:
            Human-readable description
        """
        self.message()

    pub fn is_io(self) -> bool:
        """Check if this is an I/O error.

        Returns:
            True for I/O errors
        """
        match self:
            case Io(_): true
            case _: false

    pub fn is_timeout(self) -> bool:
        """Check if this is a timeout error.

        Returns:
            True for timeout errors
        """
        match self:
            case Timeout: true
            case _: false

    pub fn is_recoverable(self) -> bool:
        """Check if error might be recoverable.

        Returns:
            True if retry might succeed
        """
        match self:
            case Io(_): true
            case NotTty: false
            case InvalidResponse: true
            case Eof: false
            case Timeout: true
            case Interrupted: true
            case Unknown: false

    pub fn is_fatal(self) -> bool:
        """Check if error is fatal.

        Returns:
            True for unrecoverable errors
        """
        not self.is_recoverable()

    pub fn summary(self) -> str:
        """Get error summary.

        Returns:
            Human-readable summary

        Example:
            TermError.Timeout.summary()
            # → "TermError: timeout (operation timed out, recoverable)"
        """
        val name = self.to_string()
        val msg = self.message()
        val status = if self.is_recoverable(): "recoverable" else: "fatal"
        return "TermError: {name} ({msg}, {status})"

impl Display for TermError:
    fn fmt() -> str:
        self.message()

impl Error for TermError

# Key event
pub struct KeyEvent:
    code: KeyCode
    modifiers: KeyModifiers

impl KeyEvent:
    pub fn new(code: KeyCode, modifiers: KeyModifiers) -> KeyEvent:
        KeyEvent { code: code, modifiers: modifiers }

    pub fn has_modifiers(self) -> bool:
        """Check if event has any modifiers.

        Returns:
            True if shift/ctrl/alt pressed
        """
        self.modifiers.has_shift() or
        self.modifiers.has_ctrl() or
        self.modifiers.has_alt()

    pub fn is_modified(self) -> bool:
        """Check if key is modified.

        Returns:
            True if has modifiers
        """
        self.has_modifiers()

    pub fn is_plain(self) -> bool:
        """Check if key is unmodified.

        Returns:
            True if no modifiers
        """
        not self.has_modifiers()

    pub fn is_control_char(self) -> bool:
        """Check if this is a control character.

        Returns:
            True if Ctrl+key
        """
        self.modifiers.has_ctrl()

    pub fn summary(self) -> text:
        """Get key event summary.

        Returns:
            Human-readable summary
        """
        var parts: Array<text> = []
        if self.modifiers.has_ctrl():
            parts.push("Ctrl")
        if self.modifiers.has_alt():
            parts.push("Alt")
        if self.modifiers.has_shift():
            parts.push("Shift")

        val code_str = self.code.to_string()
        parts.push(code_str)

        return "KeyEvent: {parts.join('+')}"

# Key codes
pub enum KeyCode:
    Char(char)
    Enter
    Escape
    Backspace
    Tab
    Delete
    Insert
    Home
    End
    PageUp
    PageDown
    Up
    Down
    Left
    Right
    F(u8)
    Null

impl KeyCode:
    pub fn to_string(self) -> str:
        """Convert key code to string.

        Returns:
            Key name

        Example:
            KeyCode.Enter.to_string()  # → "enter"
        """
        match self:
            case Char(c): "char-{c}"
            case Enter: "enter"
            case Escape: "escape"
            case Backspace: "backspace"
            case Tab: "tab"
            case Delete: "delete"
            case Insert: "insert"
            case Home: "home"
            case End: "end"
            case PageUp: "page-up"
            case PageDown: "page-down"
            case Up: "up"
            case Down: "down"
            case Left: "left"
            case Right: "right"
            case F(n): "f{n}"
            case Null: "null"

    pub fn is_char(self) -> bool:
        """Check if this is a character key.

        Returns:
            True for Char variant
        """
        match self:
            case Char(_): true
            case _: false

    pub fn is_navigation(self) -> bool:
        """Check if this is a navigation key.

        Returns:
            True for arrow/home/end/page keys
        """
        match self:
            case Up: true
            case Down: true
            case Left: true
            case Right: true
            case Home: true
            case End: true
            case PageUp: true
            case PageDown: true
            case _: false

    pub fn is_function(self) -> bool:
        """Check if this is a function key.

        Returns:
            True for F1-F12
        """
        match self:
            case F(_): true
            case _: false

    pub fn is_control(self) -> bool:
        """Check if this is a control key.

        Returns:
            True for Enter/Escape/Tab/etc
        """
        match self:
            case Enter: true
            case Escape: true
            case Backspace: true
            case Tab: true
            case Delete: true
            case Insert: true
            case _: false

    pub fn is_arrow(self) -> bool:
        """Check if this is an arrow key.

        Returns:
            True for Up/Down/Left/Right
        """
        match self:
            case Up: true
            case Down: true
            case Left: true
            case Right: true
            case _: false

    pub fn description(self) -> str:
        """Get key code description.

        Returns:
            Human-readable description

        Example:
            KeyCode.Enter.description()  # → "Enter key"
        """
        match self:
            case Char(c): "Character key: {c}"
            case Enter: "Enter key"
            case Escape: "Escape key"
            case Backspace: "Backspace key"
            case Tab: "Tab key"
            case Delete: "Delete key"
            case Insert: "Insert key"
            case Home: "Home key (beginning)"
            case End: "End key (end)"
            case PageUp: "Page Up key"
            case PageDown: "Page Down key"
            case Up: "Up arrow key"
            case Down: "Down arrow key"
            case Left: "Left arrow key"
            case Right: "Right arrow key"
            case F(n): "Function key F{n}"
            case Null: "Null key"

    pub fn summary(self) -> str:
        """Get key code summary.

        Returns:
            Human-readable summary

        Example:
            KeyCode.Up.summary()
            # → "KeyCode: up (Up arrow key, navigation)"
        """
        val name = self.to_string()
        val desc = self.description()
        var props = []
        if self.is_char():
            props.push("character")
        if self.is_navigation():
            props.push("navigation")
        if self.is_function():
            props.push("function")
        if self.is_control():
            props.push("control")
        if self.is_arrow():
            props.push("arrow")
        val props_str = if props.len() > 0: ", {props.join(', ')}" else: ""
        return "KeyCode: {name} ({desc}{props_str})"

impl Display for KeyCode:
    fn fmt() -> str:
        match self:
            case Char(c): "'{c}'"
            case Enter: "Enter"
            case Escape: "Escape"
            case Backspace: "Backspace"
            case Tab: "Tab"
            case Delete: "Delete"
            case Insert: "Insert"
            case Home: "Home"
            case End: "End"
            case PageUp: "PageUp"
            case PageDown: "PageDown"
            case Up: "Up"
            case Down: "Down"
            case Left: "Left"
            case Right: "Right"
            case F(n): "F{n}"
            case Null: "Null"

# Key modifiers
pub struct KeyModifiers:
    shift: bool
    ctrl: bool
    alt: bool

impl KeyModifiers:
    pub fn none() -> KeyModifiers:
        KeyModifiers { shift: false, ctrl: false, alt: false }

    pub fn shift() -> KeyModifiers:
        KeyModifiers { shift: true, ctrl: false, alt: false }

    pub fn ctrl() -> KeyModifiers:
        KeyModifiers { shift: false, ctrl: true, alt: false }

    pub fn alt() -> KeyModifiers:
        KeyModifiers { shift: false, ctrl: false, alt: true }

    pub fn has_shift(self) -> bool:
        self.shift

    pub fn has_ctrl(self) -> bool:
        self.ctrl

    pub fn has_alt(self) -> bool:
        self.alt

    pub fn has_any(self) -> bool:
        """Check if any modifiers are pressed.

        Returns:
            True if shift/ctrl/alt
        """
        self.shift or self.ctrl or self.alt

    pub fn count(self) -> u8:
        """Count number of active modifiers.

        Returns:
            Number of modifiers pressed
        """
        var c: u8 = 0
        if self.shift:
            c = c + 1
        if self.ctrl:
            c = c + 1
        if self.alt:
            c = c + 1
        return c

    pub fn summary(self) -> text:
        """Get modifiers summary.

        Returns:
            Human-readable summary
        """
        if not self.has_any():
            return "KeyModifiers: none"

        var mods: Array<text> = []
        if self.ctrl:
            mods.push("Ctrl")
        if self.alt:
            mods.push("Alt")
        if self.shift:
            mods.push("Shift")

        return "KeyModifiers: {mods.join('+')}"

impl Default for KeyModifiers:
    static fn default() -> Self:
        KeyModifiers.none()

impl Eq for KeyModifiers:
    fn eq(other: &Self) -> bool:
        self.shift == other.shift and self.ctrl == other.ctrl and self.alt == other.alt
