# Common File System FFI Declarations
# Shared across all host variants

use units.file.*
use units.size.*
use host.common.io.types.*
use host.common.io.error.IoError
use host.common.io.fs_types.*

pub use native_path_resolve, async_yield
pub use native_fs_read, native_fs_write, native_fs_append
pub use native_fs_create_dir, native_fs_remove_file, native_fs_remove_dir
pub use native_fs_rename, native_fs_copy, native_fs_metadata, native_fs_read_dir
pub use native_fs_open, native_file_read, native_file_write, native_file_flush
pub use native_file_seek, native_file_sync, native_file_close, native_file_get_size
pub use native_mmap_create, native_mmap_create_shared, native_mmap_read, native_mmap_unmap
pub use native_fadvise_sequential, native_fadvise_random, native_fadvise_willneed, native_fadvise_dontneed
pub use native_sendfile, native_copy_file_range
pub use native_spawn_worker
pub use native_madvise, native_msync, native_file_exists_sync
pub use native_file_read_sync, native_file_write_sync, native_file_flush_sync
pub use native_file_seek_sync, native_file_sync_sync, native_fs_read_sync, native_fs_write_sync
pub use native_fs_metadata_sync, native_file_pread, native_file_pwrite

# Path resolution
extern fn native_path_resolve(path: FilePath) -> Result<FilePath, IoError>

# Async primitives
extern fn async_yield()

# Standard file system operations
extern fn native_fs_read(path: FilePath) -> Result<Bytes, IoError>
extern fn native_fs_write(path: FilePath, data: &Bytes) -> Result<ByteCount, IoError>
extern fn native_fs_append(path: FilePath, data: &Bytes) -> Result<ByteCount, IoError>
extern fn native_fs_create_dir(path: DirPath, recursive: bool) -> Result<(), IoError>
extern fn native_fs_remove_file(path: FilePath) -> Result<(), IoError>
extern fn native_fs_remove_dir(path: DirPath, recursive: bool) -> Result<(), IoError>
extern fn native_fs_rename(src: FilePath, dst: FilePath) -> Result<(), IoError>
extern fn native_fs_copy(src: FilePath, dst: FilePath) -> Result<ByteCount, IoError>
extern fn native_fs_metadata(path: FilePath) -> Result<FileMetadata, IoError>
extern fn native_fs_read_dir(path: DirPath) -> Result<DirEntries, IoError>

# File handle operations
extern fn native_fs_open(path: FilePath, mode: OpenMode) -> Result<i64, IoError>
extern fn native_file_read(handle: i64, buf: &mut Bytes) -> Result<ByteCount, IoError>
extern fn native_file_write(handle: i64, data: &Bytes) -> Result<ByteCount, IoError>
extern fn native_file_flush(handle: i64) -> Result<(), IoError>
extern fn native_file_seek(handle: i64, pos: SeekFrom) -> Result<ByteCount, IoError>
extern fn native_file_sync(handle: i64) -> Result<(), IoError>
extern fn native_file_close(handle: i64) -> Result<(), IoError>
extern fn native_file_get_size(fd: i64) -> Result<u64, IoError>
extern fn native_file_exists_sync(path: FilePath) -> bool

# Memory-mapped file operations
extern fn native_mmap_create(handle: i64, size: u64) -> Result<i64, IoError>
extern fn native_mmap_create_shared(handle: i64, size: u64) -> Result<i64, IoError>
extern fn native_mmap_read(ptr: i64, offset: u64, buf: &mut Bytes, len: u64)
extern fn native_mmap_unmap(ptr: i64, size: u64)
extern fn native_madvise(addr: *u8, length: usize, advice: MmapAdvice) -> Result<(), IoError>
extern fn native_msync(addr: *u8, length: usize, flags: i32) -> Result<(), IoError>

# File I/O hints and optimizations
extern fn native_fadvise_sequential(handle: i64)     # Hint for sequential access
extern fn native_fadvise_random(handle: i64)         # Hint for random access
extern fn native_fadvise_willneed(handle: i64)       # Prefetch hint
extern fn native_fadvise_dontneed(handle: i64)       # Cache eviction hint

# Zero-copy operations
extern fn native_sendfile(out_fd: i64, in_fd: i64, offset: u64, count: u64) -> Result<ByteCount, IoError>
extern fn native_copy_file_range(in_fd: i64, out_fd: i64, len: u64) -> Result<ByteCount, IoError>

# Process management with staged files
extern fn native_spawn_worker(worker_fn: fn() -> i64) -> Result<i64, IoError>

# ===============================
# Synchronous File Operations
# ===============================

# Sync file handle operations (blocking)
extern fn native_file_read_sync(handle: i64, buf: &mut Bytes) -> Result<ByteCount, IoError>
extern fn native_file_write_sync(handle: i64, data: &Bytes) -> Result<ByteCount, IoError>
extern fn native_file_flush_sync(handle: i64) -> Result<(), IoError>
extern fn native_file_seek_sync(handle: i64, pos: SeekFrom) -> Result<ByteCount, IoError>
extern fn native_file_sync_sync(handle: i64) -> Result<(), IoError>

# Sync high-level file system operations
extern fn native_fs_read_sync(path: FilePath) -> Result<Bytes, IoError>
extern fn native_fs_write_sync(path: FilePath, data: &Bytes) -> Result<ByteCount, IoError>
extern fn native_fs_metadata_sync(path: FilePath) -> Result<FileMetadata, IoError>

# Positioned read/write (pread/pwrite - thread-safe, no seek)
extern fn native_file_pread(handle: i64, buf: &mut Bytes, offset: u64) -> Result<ByteCount, IoError>
extern fn native_file_pwrite(handle: i64, data: &Bytes, offset: u64) -> Result<ByteCount, IoError>

# Directory entries type (used by variants)
pub struct DirEntries:
    entries: Array<DirEntry>
    index: u64

impl DirEntries:
    pub fn next(self) -> Option<DirEntry>:
        if self.index >= self.entries.len():
            return None
        val entry = self.entries[self.index]
        self.index = self.index + 1
        return Some(entry)

impl Iterator for DirEntries:
    type Item = DirEntry
    fn next() -> Option<Self.Item>:
        if self.index >= self.entries.len() as u64:
            return None
        val entry = self.entries[self.index as usize]
        self.index = self.index + 1
        return Some(entry)
