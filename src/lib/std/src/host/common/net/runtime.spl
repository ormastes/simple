# Monoio async runtime management for Simple language
# Provides thread-per-core async runtime based on io_uring
# Feature: #1750 (Simple Language Runtime API)

import core.result

# External runtime functions
extern fn monoio_runtime_init() -> i64
extern fn monoio_runtime_init_global() -> i64
extern fn monoio_runtime_shutdown() -> i64
extern fn monoio_runtime_shutdown_global() -> i64
extern fn monoio_spawn_local(task_fn: any) -> i64
extern fn monoio_block_on(future: any) -> i64
extern fn monoio_get_num_cores() -> i64
extern fn monoio_configure_entries(entries: i64) -> i64
extern fn monoio_get_stats() -> any
extern fn monoio_reset_stats() -> i64

# Runtime handle for managing monoio runtime lifecycle
pub struct Runtime:
    is_global: bool
    num_cores: i64

    # Create a new thread-local runtime
    pub fn new() -> Result<Runtime, text>:
        val result = monoio_runtime_init()
        if result < 0:
            return Err("Failed to initialize monoio runtime")

        val cores = monoio_get_num_cores()

        return Ok(Runtime {
            is_global: false,
            num_cores: cores
        })

    # Create a new global runtime for multi-threaded scenarios
    pub fn new_global() -> Result<Runtime, text>:
        val result = monoio_runtime_init_global()
        if result < 0:
            return Err("Failed to initialize global monoio runtime")

        val cores = monoio_get_num_cores()

        return Ok(Runtime {
            is_global: true,
            num_cores: cores
        })

    # Get number of available CPU cores
    pub fn num_cores(self) -> i64:
        return self.num_cores

    # Configure io_uring ring size (number of entries)
    pub fn configure_entries(entries: i64) -> Result<(), text>:
        val result = monoio_configure_entries(entries)
        if result < 0:
            return Err("Failed to configure io_uring entries")
        return Ok(())

    # Shutdown the runtime
    pub fn shutdown(self):
        if self.is_global:
            monoio_runtime_shutdown_global()
        else:
            monoio_runtime_shutdown()

    # Get runtime statistics
    pub fn stats(self) -> any:
        return monoio_get_stats()

    # Reset runtime statistics
    pub fn reset_stats(self) -> Result<(), text>:
        val result = monoio_reset_stats()
        if result < 0:
            return Err("Failed to reset stats")
        return Ok(())

# Initialize the async runtime (convenience function)
# Creates a thread-local runtime
pub fn init_runtime() -> Result<Runtime, text>:
    return Runtime::new()

# Initialize global async runtime for multi-threaded use
pub fn init_global_runtime() -> Result<Runtime, text>:
    return Runtime::new_global()

# Shutdown the async runtime
pub fn shutdown_runtime(runtime: Runtime):
    runtime.shutdown()

# Spawn a task on the current thread's runtime
# Feature #1751: Task spawning from Simple
#
# Note: This is currently a stub. Full implementation requires FFI bridge
# between Simple closures and Rust Futures, which is not yet available.
# Individual network operations (TCP/UDP) handle their own async execution
# internally using per-operation runtime creation.
#
# Returns: Task handle ID (0 = stub, positive = task ID when implemented)
pub fn spawn<T>(task: async fn() -> T) -> i64:
    # Stub - RuntimeValue to Future conversion not yet implemented
    # When implemented, this will:
    # 1. Extract closure from task
    # 2. Create async block that invokes the closure
    # 3. Spawn on thread-local monoio runtime via spawn_local()
    # 4. Return JoinHandle ID for later await
    return monoio_spawn_local(task)

# Block current thread and run runtime until future completes
# Feature #1752: Blocking execution from Simple
#
# Note: This is currently a stub. Full implementation requires FFI bridge
# between Simple closures and Rust Futures. For now, use the individual
# network operation functions (tcp_connect, tcp_send, etc.) which handle
# async execution internally.
#
# Returns: Default value (stub behavior)
pub fn block_on<T>(future: async fn() -> T) -> T:
    # Stub - Direct future execution not yet supported
    # When implemented, this will:
    # 1. Extract closure from future
    # 2. Create Rust Future wrapper
    # 3. Execute via monoio runtime's block_on
    # 4. Extract and return result as T
    val _ = monoio_block_on(future)
    # Return default value for stub behavior
    # Callers should use TCP/UDP functions directly for actual async I/O

# Get number of CPU cores available for thread-per-core setup
pub fn get_num_cores() -> i64:
    return monoio_get_num_cores()

# Example usage:
#
# # Initialize runtime
# val runtime = init_runtime()?
#
# # Configure ring size (optional)
# Runtime::configure_entries(256)?
#
# # NOTE: spawn() and block_on() are stubs pending async FFI support.
# # For actual async I/O, use the network functions directly:
# #   - tcp_connect, tcp_send, tcp_recv, tcp_close
# #   - udp_bind, udp_send_to, udp_recv_from, udp_close
# # These functions handle async execution internally.
#
# # Example TCP client:
# # val socket_id = tcp_connect("127.0.0.1", 8080)?
# # tcp_send(socket_id, "Hello")?
# # val response = tcp_recv(socket_id, 1024)?
# # tcp_close(socket_id)
#
# # Shutdown when done
# shutdown_runtime(runtime)
