# HTTP Client - Async HTTP/HTTPS client

use units.net.*
use units.url.*
use units.size.*
use units.time.*
use host.common.io.error.IoError
use host.common.net.types.HttpMethod
use host.common.net.types.StatusCode
use host.common.net.types.HeaderName
use host.common.net.types.HeaderValue
use host.common.net.types.HttpError

# HTTP headers collection
struct Headers:
    entries: Array<(HeaderName, HeaderValue)>

impl Headers:
    static fn new() -> Headers:
        return Headers { entries: [] }

    fn get(name: HeaderName) -> Option<HeaderValue>:
        val lower_name = (name as str).to_lower()
        for (n, v) in self.entries:
            if (n as str) == lower_name:
                return Some(v)
        return None

    fn set(name: HeaderName, value: HeaderValue):
        val lower_name = (name as str).to_lower()_header
        # Remove existing
        self.entries = self.entries.filter(|(n, _)| (n as str) != (lower_name as str))
        self.entries.push((lower_name, value))

    fn append(name: HeaderName, value: HeaderValue):
        val lower_name = (name as str).to_lower()_header
        self.entries.push((lower_name, value))

    fn remove(name: HeaderName):
        val lower_name = (name as str).to_lower()
        self.entries = self.entries.filter(|(n, _)| (n as str) != lower_name)

    fn contains(name: HeaderName) -> bool:
        return self.get(name).is_some()

    fn iter() -> Array<(HeaderName, HeaderValue)>:
        return self.entries

# HTTP request builder
pub struct HttpRequest:
    method: HttpMethod
    url: HttpUrl
    headers: Headers
    body: Option<Bytes>
    timeout: Option<Duration>
    follow_redirects: bool
    max_redirects: u32

impl HttpRequest:
    fn new(method: HttpMethod, url: HttpUrl) -> HttpRequest:
        return HttpRequest {
            method: method,
            url: url,
            headers: Headers::new(),
            body: None,
            timeout: None,
            follow_redirects: true,
            max_redirects: 10
        }

    # Convenience constructors
    @pure
    pub fn get(url: HttpUrl) -> HttpRequest:
        return HttpRequest::new(HttpMethod::Get, url)

    @pure
    pub fn post(url: HttpUrl) -> HttpRequest:
        return HttpRequest::new(HttpMethod::Post, url)

    @pure
    pub fn put(url: HttpUrl) -> HttpRequest:
        return HttpRequest::new(HttpMethod::Put, url)

    @pure
    pub fn delete(url: HttpUrl) -> HttpRequest:
        return HttpRequest::new(HttpMethod::Delete, url)

    @pure
    pub fn patch(url: HttpUrl) -> HttpRequest:
        return HttpRequest::new(HttpMethod::Patch, url)

    @pure
    pub fn head(url: HttpUrl) -> HttpRequest:
        return HttpRequest::new(HttpMethod::Head, url)

    # Builder methods
    @pure
    pub fn header(self, name: HeaderName, value: HeaderValue) -> HttpRequest:
        self.headers.set(name, value)
        return self

    @pure
    pub fn body(self, data: Bytes) -> HttpRequest:
        self.body = Some(data)
        return self

    @pure
    pub fn json_body(self, data: &Bytes) -> HttpRequest:
        self.headers.set(HeaderName::content_type(), HeaderValue::json())
        self.body = Some(data.clone())
        return self

    @pure
    pub fn form_body(self, params: Array<(str, str)>) -> HttpRequest:
        self.headers.set(HeaderName::content_type(), HeaderValue::form())
        var body = ""
        var first = true
        for (k, v) in params:
            if not first:
                body = body + "&"
            body = body + k.url_encode() + "=" + v.url_encode()
            first = false
        self.body = Some(body.to_bytes())
        return self

    @pure
    pub fn timeout(self, duration: Duration) -> HttpRequest:
        self.timeout = Some(duration)
        return self

    @pure
    pub fn no_follow_redirects(self) -> HttpRequest:
        self.follow_redirects = false
        return self

    @pure
    pub fn max_redirects(self, n: u32) -> HttpRequest:
        self.max_redirects = n
        return self

    @pure
    pub fn bearer_auth(self, token: str) -> HttpRequest:
        self.headers.set(HeaderName::authorization(), "Bearer {token}"_hval)
        return self

    @pure
    pub fn basic_auth(self, username: str, password: str) -> HttpRequest:
        val credentials = "{username}:{password}".to_base64()
        self.headers.set(HeaderName::authorization(), "Basic {credentials}"_hval)
        return self

# HTTP response
pub struct HttpResponse:
    status: StatusCode
    headers: Headers
    body_data: Bytes
    url: HttpUrl

impl HttpResponse:
    @pure
    pub fn status(self) -> StatusCode:
        return self.status

    @pure
    pub fn header(self, name: HeaderName) -> Option<HeaderValue>:
        return self.headers.get(name)

    @pure
    pub fn headers(self) -> Headers:
        return self.headers

    @pure
    pub fn body(self) -> &Bytes:
        return &self.body_data

    @pure
    pub fn text(self) -> Result<Text, HttpError>:
        match self.body_data.to_utf8():
            case Ok(s): return Ok(s_text)
            case Err(_): return Err(HttpError::InvalidResponse)

    @pure
    pub fn json<T: Deserialize>(self) -> Result<T, JsonError>:
        return json::parse(self.body_data)

    @pure
    pub fn url(self) -> HttpUrl:
        return self.url

    @pure
    pub fn content_length(self) -> Option<ByteCount>:
        match self.headers.get(HeaderName::content_length()):
            case Some(v):
                match (v as str).parse_u64():
                    case Ok(n): return Some(n_bytes)
                    case Err(_): return None
            case None:
                return None

    @pure
    pub fn content_type(self) -> Option<HeaderValue>:
        return self.headers.get(HeaderName::content_type())

    @pure
    pub fn is_success(self) -> bool:
        return self.status.is_success()

    @pure
    pub fn is_redirect(self) -> bool:
        return self.status.is_redirect()

# HTTP client
pub struct HttpClient:
    default_timeout: Option<Duration>
    default_headers: Headers
    follow_redirects: bool
    max_redirects: u32

impl HttpClient:
    @pure
    pub fn new() -> HttpClient:
        return HttpClient {
            default_timeout: None,
            default_headers: Headers::new(),
            follow_redirects: true,
            max_redirects: 10
        }

    @pure
    pub fn with_timeout(timeout: Duration) -> HttpClient:
        var client = HttpClient::new()
        client.default_timeout = Some(timeout)
        return client

    @pure
    pub fn set_default_header(self, name: HeaderName, value: HeaderValue) -> HttpClient:
        self.default_headers.set(name, value)
        return self

    @pure
    pub fn set_user_agent(self, agent: str) -> HttpClient:
        self.default_headers.set(HeaderName::user_agent(), agent_hval)
        return self

    # Send request
    @net
    pub async fn send(self, request: HttpRequest) -> Result<HttpResponse, HttpError>:
        # Merge default headers
        for (name, value) in self.default_headers.iter():
            if not request.headers.contains(name):
                request.headers.set(name, value)

        # Use default timeout if not set
        val timeout = request.timeout.or(self.default_timeout)

        return native_http_send(request, timeout)

    # Convenience methods
    @net
    pub async fn get(self, url: HttpUrl) -> Result<HttpResponse, HttpError>:
        return self.send(HttpRequest::get(url))

    @net
    pub async fn post(self, url: HttpUrl, body: Bytes) -> Result<HttpResponse, HttpError>:
        return self.send(HttpRequest::post(url).body(body))

    @net
    pub async fn post_json(self, url: HttpUrl, body: &Bytes) -> Result<HttpResponse, HttpError>:
        return self.send(HttpRequest::post(url).json_body(body))

    @net
    pub async fn put(self, url: HttpUrl, body: Bytes) -> Result<HttpResponse, HttpError>:
        return self.send(HttpRequest::put(url).body(body))

    @net
    pub async fn delete(self, url: HttpUrl) -> Result<HttpResponse, HttpError>:
        return self.send(HttpRequest::delete(url))

# Global convenience functions
@net
pub async fn get(url: HttpUrl) -> Result<HttpResponse, HttpError>:
    return HttpClient::new().get(url)

@net
pub async fn post(url: HttpUrl, body: Bytes) -> Result<HttpResponse, HttpError>:
    return HttpClient::new().post(url, body)

# Native function declarations
extern fn native_http_send(request: HttpRequest, timeout: Option<Duration>) -> Result<HttpResponse, HttpError>
