# Command Line Arguments - Argument parsing and access
#
# Provides access to command line arguments passed to the program.

# FFI for argument access
extern fn rt_args_count() -> i32
extern fn rt_args_get(index: i32) -> text
extern fn rt_args_all() -> List<text>

# Get the number of command line arguments (including program name)
fn count() -> i32:
    return rt_args_count()

# Get a specific argument by index (0 = program name)
fn get(index: i32) -> Option<text>:
    if index < 0 or index >= rt_args_count():
        return Option.none()
    return Option.some(rt_args_get(index))

# Get all arguments as a list
fn all() -> List<text>:
    return rt_args_all()

# Get the program name (first argument)
fn program_name() -> text:
    if rt_args_count() > 0:
        return rt_args_get(0)
    return ""

# Get arguments without the program name
fn args() -> List<text>:
    val all_args = rt_args_all()
    if all_args.len() <= 1:
        return []
    return all_args[1:]

# Check if an argument is present
fn has(name: text) -> bool:
    for arg in rt_args_all():
        if arg == name:
            return true
    return false

# Find the value following a flag (e.g., --output file.txt)
fn get_flag_value(flag: text) -> Option<text>:
    val all_args = rt_args_all()
    for i in 0..(all_args.len() - 1):
        if all_args[i] == flag:
            return Option.some(all_args[i + 1])
    return Option.none()

# Parse positional arguments (skip flags starting with -)
fn positional() -> List<text>:
    var result: List<text> = []
    var skip_next = false
    for arg in args():
        if skip_next:
            skip_next = false
            continue
        if arg.starts_with("-"):
            # If it's a flag that takes a value, skip next
            if arg.starts_with("--") or arg.len() == 2:
                skip_next = true
            continue
        result.push(arg)
    return result

pub use count, get, all, program_name, args, has, get_flag_value, positional
