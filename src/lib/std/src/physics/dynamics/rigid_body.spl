# Physics Dynamics - Rigid Body
#
# Rigid body with mass, velocity, forces, rotation, and damping.

pub use RigidBody

use ..core as core
use ml.torch as torch


# ============================================================================
# Rigid Body
# ============================================================================

class RigidBody:
    """Rigid body with mass, velocity, forces, rotation, and damping.

    Attributes:
        mass: Body mass (0 = infinite mass, static)
        position: Position vector (geometric center)
        velocity: Linear velocity
        acceleration: Linear acceleration
        force: Accumulated force
        radius: Collision radius (simple sphere for now)
        rotation: Orientation quaternion
        angular_velocity: Angular velocity vector (axis * angular_speed)
        angular_acceleration: Angular acceleration
        torque: Accumulated torque
        inertia: Moment of inertia (scalar for sphere: I = 2/5 * m * r^2)
        linear_damping: Linear velocity damping coefficient (0-1)
        angular_damping: Angular velocity damping coefficient (0-1)
        center_of_mass_offset: Offset from position to center of mass in local space
        is_awake: Whether body is active (false = sleeping for optimization)
        sleep_threshold: Velocity magnitude squared below which body can sleep
        sleep_timer: Time body has been below sleep threshold

    Example:
        ```simple
        val body = RigidBody(
            mass=1.0,
            position=Vector3(0, 10, 0),
            velocity=Vector3(0, 0, 0)
        )

        body.add_force(Vector3(0, -9.81, 0))  # Apply gravity
        body.integrate(0.016)  # Step physics

        print("Position: {body.position}")
        print("Velocity: {body.velocity}")
        ```
    """
    mass: f64
    position: core.Vector3
    velocity: core.Vector3
    acceleration: core.Vector3
    force: core.Vector3
    radius: f64
    rotation: core.Quaternion
    angular_velocity: core.Vector3
    angular_acceleration: core.Vector3
    torque: core.Vector3
    inertia: f64
    linear_damping: f64
    angular_damping: f64
    center_of_mass_offset: core.Vector3
    is_awake: bool
    sleep_threshold: f64
    sleep_timer: f64

    fn __init__(mass: f64,
        position: core.Vector3? = None,
        velocity: core.Vector3? = None,
        radius: f64 = 0.5,
        rotation: core.Quaternion? = None,
        angular_velocity: core.Vector3? = None,
        linear_damping: f64 = 0.01,
        angular_damping: f64 = 0.01,
        center_of_mass_offset: core.Vector3? = None
    ):
        """Initialize rigid body.

        Args:
            mass: Body mass (0 for static/infinite mass)
            position: Initial position (geometric center, default: origin)
            velocity: Initial velocity (default: zero)
            radius: Collision radius (default: 0.5)
            rotation: Initial orientation (default: identity)
            angular_velocity: Initial angular velocity (default: zero)
            linear_damping: Linear velocity damping (default: 0.01, range: 0-1)
            angular_damping: Angular velocity damping (default: 0.01, range: 0-1)
            center_of_mass_offset: Offset from position to COM in local space (default: zero)
        """
        self.mass = mass
        self.position = position ?? core.Vector3(0.0, 0.0, 0.0)
        self.velocity = velocity ?? core.Vector3(0.0, 0.0, 0.0)
        self.acceleration = core.Vector3(0.0, 0.0, 0.0)
        self.force = core.Vector3(0.0, 0.0, 0.0)
        self.radius = radius

        # Rotation properties
        self.rotation = rotation ?? core.Quaternion.identity()
        self.angular_velocity = angular_velocity ?? core.Vector3(0.0, 0.0, 0.0)
        self.angular_acceleration = core.Vector3(0.0, 0.0, 0.0)
        self.torque = core.Vector3(0.0, 0.0, 0.0)

        # Damping (energy loss over time)
        self.linear_damping = linear_damping
        self.angular_damping = angular_damping

        # Center of mass offset
        self.center_of_mass_offset = center_of_mass_offset ?? core.Vector3(0.0, 0.0, 0.0)

        # Sleep/wake system for optimization
        self.is_awake = true  # Start awake
        self.sleep_threshold = 0.01  # Velocity squared threshold (0.1 m/s)
        self.sleep_timer = 0.0

        # Moment of inertia for sphere: I = (2/5) * m * r^2
        if mass > 0:
            self.inertia = 0.4 * mass * radius * radius
        else:
            self.inertia = 0.0  # Static body

    fn add_force(f: core.Vector3):
        """Add force to body.

        Args:
            f: Force vector to add
        """
        self.force = self.force.add(f)

    fn get_center_of_mass() -> core.Vector3:
        """Get world-space center of mass.

        Returns:
            World-space position of center of mass

        Example:
            ```simple
            # Hammer with heavy head
            val hammer = RigidBody(
                mass=2.0,
                position=core.Vector3(0, 0, 0),
                center_of_mass_offset=core.Vector3(0, 0.3, 0)  # COM shifted toward head
            )

            val com = hammer.get_center_of_mass()
            # COM is at (0, 0.3, 0) if rotation is identity
            ```
        """
        # Transform local COM offset to world space using rotation
        val world_offset = self.rotation.rotate_vector(self.center_of_mass_offset)
        return self.position.add(world_offset)

    fn add_force_at_point(f: core.Vector3, point: core.Vector3):
        """Add force at a specific point (generates torque).

        Args:
            f: Force vector
            point: Point of application in world space

        Example:
            ```simple
            # Apply force to tip of hammer (generates large torque)
            val hammer = RigidBody(
                mass=2.0,
                position=core.Vector3(0, 0, 0),
                center_of_mass_offset=core.Vector3(0, 0.3, 0)  # Heavy head
            )

            # Hit at the tip (far from COM)
            val tip = core.Vector3(0, 0.8, 0)
            hammer.add_force_at_point(core.Vector3(10, 0, 0), tip)
            # Generates large torque due to long lever arm from COM
            ```
        """
        # Add linear force
        self.force = self.force.add(f)

        # Calculate torque: τ = r × F
        # Use center of mass, not geometric center, for physically accurate rotation
        val com = self.get_center_of_mass()
        val r = point.sub(com)  # Vector from COM to point
        val torque = r.cross(f)
        self.add_torque(torque)

    fn add_torque(t: core.Vector3):
        """Add torque to body.

        Args:
            t: Torque vector to add
        """
        self.torque = self.torque.add(t)

    fn clear_forces():
        """Clear accumulated forces and torques."""
        self.force = core.Vector3(0.0, 0.0, 0.0)
        self.torque = core.Vector3(0.0, 0.0, 0.0)

    fn sleep():
        """Put body to sleep (disable physics updates).

        Sleeping bodies don't participate in physics simulation until woken.
        Used for optimization - stationary objects don't need updating.

        Example:
            ```simple
            # Manually put resting objects to sleep
            if body.velocity.magnitude() < 0.01:
                body.sleep()
            ```
        """
        self.is_awake = false
        self.velocity = core.Vector3(0.0, 0.0, 0.0)
        self.angular_velocity = core.Vector3(0.0, 0.0, 0.0)
        self.force = core.Vector3(0.0, 0.0, 0.0)
        self.torque = core.Vector3(0.0, 0.0, 0.0)
        self.sleep_timer = 0.0

    fn wake():
        """Wake body from sleep (enable physics updates).

        Bodies should be woken when:
        - Force is applied
        - Collision occurs
        - External influence detected

        Example:
            ```simple
            # Wake object when player touches it
            if player_nearby:
                object.wake()
                object.add_force(push_force)
            ```
        """
        if not self.is_awake:
            self.is_awake = true
            self.sleep_timer = 0.0

    fn can_sleep() -> bool:
        """Check if body can be put to sleep.

        Returns:
            True if body is nearly stationary and can sleep

        Example:
            ```simple
            # Check if body has been stationary for 0.5 seconds
            if body.can_sleep() and body.sleep_timer > 0.5:
                body.sleep()
            ```
        """
        val velocity_sq = self.velocity.dot(self.velocity)
        val angular_velocity_sq = self.angular_velocity.dot(self.angular_velocity)

        return velocity_sq < self.sleep_threshold and angular_velocity_sq < self.sleep_threshold

    fn integrate(dt: f64):
        """Integrate physics using semi-implicit Euler with sleep/wake optimization.

        Semi-implicit Euler is more stable than explicit Euler:
        1. v = v + a * dt
        2. x = x + v * dt
        3. ω = ω + α * dt
        4. q = q + (ω * q) * dt / 2

        Automatically handles sleep/wake:
        - Skips sleeping bodies for performance
        - Tracks stationary time and auto-sleeps after 0.5 seconds
        - Wakes body if force is applied

        Args:
            dt: Time step in seconds
        """
        if self.mass <= 0:
            # Static body (infinite mass), don't integrate
            return

        # Skip sleeping bodies for optimization
        if not self.is_awake:
            return

        # Wake up if external force is applied
        val force_mag_sq = self.force.dot(self.force)
        val torque_mag_sq = self.torque.dot(self.torque)
        if force_mag_sq > 0.001 or torque_mag_sq > 0.001:
            self.wake()  # Ensure awake if forces present

        # Linear motion
        # Acceleration = Force / Mass (Newton's second law)
        self.acceleration = self.force.scale(1.0 / self.mass)

        # Update velocity: v = v + a * dt
        self.velocity = self.velocity.add(self.acceleration.scale(dt))

        # Apply linear damping: v = v * (1 - damping)^dt
        # Approximation: v ≈ v * (1 - damping * dt) for small dt
        val damping_factor = 1.0 - (self.linear_damping * dt)
        if damping_factor > 0:
            self.velocity = self.velocity.scale(damping_factor)

        # Update position: x = x + v * dt
        self.position = self.position.add(self.velocity.scale(dt))

        # Angular motion (if inertia > 0)
        if self.inertia > 0:
            # Angular acceleration: α = τ / I
            self.angular_acceleration = self.torque.scale(1.0 / self.inertia)

            # Update angular velocity: ω = ω + α * dt
            self.angular_velocity = self.angular_velocity.add(
                self.angular_acceleration.scale(dt)
            )

            # Apply angular damping: ω = ω * (1 - damping)^dt
            val angular_damping_factor = 1.0 - (self.angular_damping * dt)
            if angular_damping_factor > 0:
                self.angular_velocity = self.angular_velocity.scale(angular_damping_factor)

            # Update rotation quaternion
            # dq/dt = (1/2) * ω * q
            # q(t+dt) = q(t) + dq/dt * dt
            if self.angular_velocity.magnitude() > 0:
                val w_quat = core.Quaternion(
                    0.0,
                    self.angular_velocity.x,
                    self.angular_velocity.y,
                    self.angular_velocity.z
                )

                # Quaternion derivative: dq = 0.5 * w_quat * q
                val dq_w = 0.5 * (
                    -w_quat.x * self.rotation.x -
                    w_quat.y * self.rotation.y -
                    w_quat.z * self.rotation.z
                )
                val dq_x = 0.5 * (
                    w_quat.x * self.rotation.w +
                    w_quat.z * self.rotation.y -
                    w_quat.y * self.rotation.z
                )
                val dq_y = 0.5 * (
                    w_quat.y * self.rotation.w -
                    w_quat.z * self.rotation.x +
                    w_quat.x * self.rotation.z
                )
                val dq_z = 0.5 * (
                    w_quat.z * self.rotation.w +
                    w_quat.y * self.rotation.x -
                    w_quat.x * self.rotation.y
                )

                # Integrate quaternion
                self.rotation = core.Quaternion(
                    self.rotation.w + dq_w * dt,
                    self.rotation.x + dq_x * dt,
                    self.rotation.y + dq_y * dt,
                    self.rotation.z + dq_z * dt
                )

                # Normalize quaternion to prevent drift
                self.rotation = self.rotation.normalize()

        # Sleep detection for optimization
        if self.can_sleep():
            # Body is nearly stationary, increment timer
            self.sleep_timer = self.sleep_timer + dt

            # Auto-sleep after 0.5 seconds of being stationary
            if self.sleep_timer > 0.5:
                self.sleep()
        else:
            # Body is moving, reset timer
            self.sleep_timer = 0.0

        # Clear forces for next frame
        self.clear_forces()

    fn integrate_verlet(dt: f64, prev_position: core.Vector3):
        """Integrate using Verlet integration.

        Verlet is more stable and energy-conserving than Euler.
        x(t+dt) = 2*x(t) - x(t-dt) + a(t)*dt^2

        Args:
            dt: Time step
            prev_position: Position from previous frame
        """
        if self.mass <= 0:
            return

        # Acceleration = Force / Mass
        self.acceleration = self.force.scale(1.0 / self.mass)

        # Save current position
        val current_pos = self.position

        # Verlet integration
        val dt2 = dt * dt
        val pos_delta = self.position.sub(prev_position)
        val accel_delta = self.acceleration.scale(dt2)
        self.position = self.position.add(pos_delta).add(accel_delta)

        # Estimate velocity for next frame
        self.velocity = self.position.sub(current_pos).scale(1.0 / dt)

        # Clear forces
        self.clear_forces()

    fn apply_impulse(impulse: core.Vector3):
        """Apply instantaneous impulse (change in momentum).

        Args:
            impulse: Impulse vector (kg*m/s)
        """
        if self.mass > 0:
            self.velocity = self.velocity.add(impulse.scale(1.0 / self.mass))

    fn kinetic_energy() -> f64:
        """Calculate kinetic energy.

        KE = 0.5 * m * v^2

        Returns:
            Kinetic energy in Joules
        """
        if self.mass <= 0:
            return 0.0

        val v_squared = self.velocity.dot(self.velocity)
        return 0.5 * self.mass * v_squared

    fn potential_energy(gravity: core.Vector3) -> f64:
        """Calculate gravitational potential energy.

        PE = m * g * h

        Args:
            gravity: Gravitational acceleration vector

        Returns:
            Potential energy in Joules
        """
        if self.mass <= 0:
            return 0.0

        # Height is position dot gravity direction
        val g_mag = gravity.magnitude()
        if g_mag == 0:
            return 0.0

        val g_dir = gravity.normalize()
        val height = -self.position.dot(g_dir)  # Negative because gravity points down

        return self.mass * g_mag * height

    fn to_device(device: torch.Device) -> RigidBodyGPU:
        """Transfer body data to GPU device.

        Converts position, velocity, force, rotation data to GPU tensors
        for batch physics processing.

        Args:
            device: Target device (CPU or CUDA)

        Returns:
            GPU-backed rigid body representation

        Example:
            ```simple
            val gpu_body = body.to_device(torch.Device.cuda(0))
            # Process on GPU
            gpu_body.integrate_batch(dt, bodies)
            ```
        """
        # Convert position to tensor [x, y, z]
        val pos_tensor = torch.tensor(
            [self.position.x, self.position.y, self.position.z],
            dtype=torch.float32,
            device=device
        )

        # Convert velocity to tensor [vx, vy, vz]
        val vel_tensor = torch.tensor(
            [self.velocity.x, self.velocity.y, self.velocity.z],
            dtype=torch.float32,
            device=device
        )

        # Convert force to tensor [fx, fy, fz]
        val force_tensor = torch.tensor(
            [self.force.x, self.force.y, self.force.z],
            dtype=torch.float32,
            device=device
        )

        # Convert rotation quaternion to tensor [w, x, y, z]
        val rot_tensor = torch.tensor(
            [self.rotation.w, self.rotation.x, self.rotation.y, self.rotation.z],
            dtype=torch.float32,
            device=device
        )

        # Convert angular velocity to tensor [wx, wy, wz]
        val ang_vel_tensor = torch.tensor(
            [self.angular_velocity.x, self.angular_velocity.y, self.angular_velocity.z],
            dtype=torch.float32,
            device=device
        )

        return RigidBodyGPU {
            position: pos_tensor,
            velocity: vel_tensor,
            force: force_tensor,
            rotation: rot_tensor,
            angular_velocity: ang_vel_tensor,
            mass: self.mass,
            inertia: self.inertia,
            linear_damping: self.linear_damping,
            angular_damping: self.angular_damping,
            device: device
        }


# GPU-backed rigid body representation for batch processing
class RigidBodyGPU:
    """GPU tensor representation of rigid body for batch processing.

    Stores body state as GPU tensors for efficient parallel physics.
    """
    position: torch.Tensor       # [3] float32
    velocity: torch.Tensor       # [3] float32
    force: torch.Tensor          # [3] float32
    rotation: torch.Tensor       # [4] float32 (quaternion)
    angular_velocity: torch.Tensor  # [3] float32
    mass: f64
    inertia: f64
    linear_damping: f64
    angular_damping: f64
    device: torch.Device

    fn to_cpu(self) -> RigidBody:
        """Transfer back to CPU.

        Returns:
            CPU-backed RigidBody
        """
        val pos_cpu = self.position.cpu().tolist()
        val vel_cpu = self.velocity.cpu().tolist()
        val rot_cpu = self.rotation.cpu().tolist()
        val ang_vel_cpu = self.angular_velocity.cpu().tolist()

        return RigidBody(
            mass=self.mass,
            position=core.Vector3(pos_cpu[0], pos_cpu[1], pos_cpu[2]),
            velocity=core.Vector3(vel_cpu[0], vel_cpu[1], vel_cpu[2]),
            rotation=core.Quaternion(rot_cpu[0], rot_cpu[1], rot_cpu[2], rot_cpu[3]),
            angular_velocity=core.Vector3(ang_vel_cpu[0], ang_vel_cpu[1], ang_vel_cpu[2]),
            linear_damping=self.linear_damping,
            angular_damping=self.angular_damping
        )

    fn integrate_gpu(self, dt: f64):
        """Integrate physics on GPU.

        Args:
            dt: Time step
        """
        if self.mass <= 0:
            return

        # Acceleration = Force / Mass
        val inv_mass = 1.0 / self.mass
        val acceleration = self.force * inv_mass

        # Update velocity: v = v + a * dt
        self.velocity = self.velocity + acceleration * dt

        # Apply damping
        val damping = 1.0 - (self.linear_damping * dt)
        self.velocity = self.velocity * damping

        # Update position: x = x + v * dt
        self.position = self.position + self.velocity * dt

        # Clear force
        self.force = torch.zeros(3, device=self.device)

    fn is_static() -> bool:
        """Check if body is static (infinite mass).

        Returns:
            True if body is static
        """
        return self.mass <= 0
