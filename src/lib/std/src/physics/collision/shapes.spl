# Physics Collision Shapes - Collision Shape Definitions
#
# Collision shape classes and enum for representing geometric shapes used in
# collision detection and response.
#
# ## Classes
# - `Capsule`: Cylinder with hemispherical ends for character controllers
# - `SphereShape`: Sphere shape for collision detection
# - `BoxShape`: Axis-aligned or oriented box shape for collision detection
#
# ## Enums
# - `Shape`: Unified collision shape representation (Sphere, Box, Capsule)
#
# ## Example
# ```simple
# import physics.collision.shapes as shapes
# import physics.core as core
#
# # Character controller capsule
# val capsule = shapes.Capsule(
#     start=core.Vector3(0, 0, 0),
#     end=core.Vector3(0, 2, 0),
#     radius=0.5
# )
#
# # Sphere shape
# val sphere = shapes.SphereShape(
#     position=core.Vector3(1, 1, 1),
#     radius=0.5
# )
#
# # Box shape
# val box = shapes.BoxShape(
#     center=core.Vector3(0, 0, 0),
#     halfsize=core.Vector3(0.5, 1.0, 0.5)
# )
#
# # Shape enum variant
# val shape_variant: shapes.Shape = shapes.Shape::Sphere(radius=0.5)
# ```

export Capsule, Shape, SphereShape, BoxShape

import ..core as core


# ============================================================================
# Capsule - Character Controller Shape
# ============================================================================

class Capsule:
    """Capsule collision shape (cylinder with hemispherical ends).

    Commonly used for character controllers in games due to smooth collision response.
    Represented by a line segment (central axis) and radius.

    Attributes:
        start: Start point of central axis
        end: End point of central axis
        radius: Radius of capsule

    Example:
        ```simple
        # Character controller capsule (height 2, radius 0.5)
        val capsule = Capsule(
            start=core.Vector3(0, 0, 0),
            end=core.Vector3(0, 2, 0),
            radius=0.5
        )

        # Test collision with sphere
        if Detector::capsule_sphere(capsule, sphere_pos, sphere_radius):
            print("Character hit obstacle!")
        ```
    """
    start: core.Vector3
    end: core.Vector3
    radius: f64
    fn __init__(start: core.Vector3, end: core.Vector3, radius: f64):
        """Initialize capsule.

        Args:
            start: Start point of central axis
            end: End point of central axis
            radius: Radius
        """
        self.start = start
        self.end = end
        self.radius = radius

    static fn from_center_height(center: core.Vector3, height: f64, radius: f64, axis: core.Vector3 = core.Vector3(0, 1, 0)) -> Capsule:
        """Create capsule from center, height, and radius.

        Args:
            center: Center point
            height: Total height (including hemispherical ends)
            radius: Radius
            axis: Up axis (default: Y-axis)

        Returns:
            Capsule
        """
        val half_height = (height - 2.0 * radius) * 0.5
        val offset = axis.normalize().scale(half_height)
        return Capsule(
            center.sub(offset),
            center.add(offset),
            radius
        )

    fn center() -> core.Vector3:
        """Get center point of capsule.

        Returns:
            Center point
        """
        return core.Vector3(
            (self.start.x + self.end.x) * 0.5,
            (self.start.y + self.end.y) * 0.5,
            (self.start.z + self.end.z) * 0.5
        )

    fn height() -> f64:
        """Get total height of capsule (including hemispherical ends).

        Returns:
            Total height
        """
        val axis_length = self.start.distance(self.end)
        return axis_length + 2.0 * self.radius

    fn closest_point_on_axis(point: core.Vector3) -> core.Vector3:
        """Find closest point on central axis to given point.

        Args:
            point: Query point

        Returns:
            Closest point on line segment (start to end)
        """
        val axis = self.end.sub(self.start)
        val axis_length_sq = axis.dot(axis)

        if axis_length_sq < 0.0001:  # Degenerate case: start == end
            return self.start

        val t = (point.sub(self.start).dot(axis) / axis_length_sq).max(0.0).min(1.0)
        return self.start.add(axis.scale(t))


# ============================================================================
# Shape - Collision Shapes Enum
# ============================================================================

enum Shape:
    """Collision shape variants."""
    Sphere(radius: f64)
    Box(half_extents: core.Vector3)
    Capsule(radius: f64, height: f64)

impl Shape:
    # =========================================================================
    # Helper Methods
    # =========================================================================
    fn to_string() -> text:
        """Convert shape to string.

        Returns:
            Shape type name

        Example:
            Shape::Sphere(1.0).to_string()  # → "sphere"
        """
        match self:
            case Sphere(_): "sphere"
            case Box(_): "box"
            case Capsule(_, _): "capsule"

    fn description() -> text:
        """Get shape description.

        Returns:
            Human-readable description

        Example:
            Shape::Sphere(5.0).description()
            # → "Sphere with radius 5.0"
        """
        match self:
            case Sphere(r): "Sphere with radius {r}"
            case Box(extents): "Box with half extents {extents}"
            case Capsule(r, h): "Capsule with radius {r} and height {h}"

    fn is_sphere() -> bool:
        """Check if shape is Sphere.

        Returns:
            true for Sphere variant

        Example:
            Shape::Sphere(1.0).is_sphere()  # → true
        """
        match self:
            case Sphere(_): true
            case _: false

    fn is_box() -> bool:
        """Check if shape is Box.

        Returns:
            true for Box variant

        Example:
            Shape::Box(extents).is_box()  # → true
        """
        match self:
            case Box(_): true
            case _: false

    fn is_capsule() -> bool:
        """Check if shape is Capsule.

        Returns:
            true for Capsule variant

        Example:
            Shape::Capsule(1.0, 2.0).is_capsule()  # → true
        """
        match self:
            case Capsule(_, _): true
            case _: false

    fn is_convex() -> bool:
        """Check if shape is convex.

        Returns:
            true (all supported shapes are convex)

        Example:
            Shape::Sphere(1.0).is_convex()  # → true
        """
        return true

    fn get_radius() -> Option<f64>:
        """Get radius if shape has one.

        Returns:
            Radius for Sphere or Capsule, None for Box

        Example:
            Shape::Sphere(5.0).get_radius()  # → Some(5.0)
            Shape::Box(extents).get_radius()  # → None
        """
        match self:
            case Sphere(r): Some(r)
            case Capsule(r, _): Some(r)
            case _: None

    fn summary() -> text:
        """Get shape summary.

        Returns:
            Human-readable summary

        Example:
            Shape::Sphere(5.0).summary()
            # → "Shape: sphere (Sphere with radius 5.0, convex)"
        """
        val name = self.to_string()
        val desc = self.description()
        return "Shape: {name} ({desc}, convex)"


# ============================================================================
# SphereShape - Sphere Collision Shape
# ============================================================================

class SphereShape:
    """Sphere shape for collision detection.

    Attributes:
        position: Center position
        radius: Sphere radius
    """
    position: core.Vector3
    radius: f64
    fn __init__(position: core.Vector3, radius: f64):
        """Initialize sphere shape.

        Args:
            position: Center position
            radius: Sphere radius
        """
        self.position = position
        self.radius = radius


# ============================================================================
# BoxShape - Box Collision Shape
# ============================================================================

class BoxShape:
    """Box shape for collision detection.

    Attributes:
        center: Center position
        halfsize: Half extents
        rotation: Optional rotation quaternion
    """
    center: core.Vector3
    halfsize: core.Vector3
    rotation: core.Quaternion
    fn __init__(center: core.Vector3, halfsize: core.Vector3, rotation: core.Quaternion = core.Quaternion::identity()):
        """Initialize box shape.

        Args:
            center: Center position
            halfsize: Half extents (half width/height/depth)
            rotation: Optional rotation (default: identity)
        """
        self.center = center
        self.halfsize = halfsize
        self.rotation = rotation
