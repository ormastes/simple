# Physics Collision - Continuous Collision Detection (CCD)
#
# Continuous collision detection for preventing tunneling of fast-moving objects.
# Uses conservative advancement and binary search to find time-of-impact (TOI).
#
# ## Classes
# - `ContinuousCollisionQuery`: Query for CCD with shapes and velocities
# - `CCDResult`: Result containing TOI and contact information
#
# ## Functions
# - `continuous_collision_detection`: Perform CCD using conservative advancement
#
# ## Example
# ```simple
# import physics.collision as collision
# import physics.core as core
#
# # Fast-moving sphere that would tunnel through without CCD
# val sphere1 = collision.SphereShape(core.Vector3(0.0, 0.0, 0.0), 1.0)
# val sphere2 = collision.SphereShape(core.Vector3(10.0, 0.0, 0.0), 1.0)
# val velocity = core.Vector3(20.0, 0.0, 0.0)  # Very fast!
#
# val query = collision.ContinuousCollisionQuery(
#     sphere1, sphere2,
#     velocity, core.Vector3(0.0, 0.0, 0.0)
# )
#
# val result = collision.continuous_collision_detection(query)
# if result.has_collision:
#     print("Collision at t={result.time_of_impact}")
#     print("Contact point: {result.contact_point}")
#     print("Contact normal: {result.contact_normal}")
# ```
#
# ## Algorithm
# Uses conservative advancement with binary search over time interval [0, 1].
# Accuracy controlled by tolerance (1e-4). Maximum 32 iterations for convergence.

import ..core as core
import .gjk.{SphereShape, gjk_test}
# ============================================================================
# Continuous Collision Detection (CCD)
# ============================================================================

class ContinuousCollisionQuery:
    """Query for continuous collision detection (time-of-impact).

    Finds the earliest time when two moving shapes collide during a time step.
    Critical for preventing tunneling of fast-moving objects.

    Attributes:
        shape1: First shape
        shape2: Second shape
        velocity1: Linear velocity of shape1
        velocity2: Linear velocity of shape2
        angular_velocity1: Angular velocity of shape1 (optional)
        angular_velocity2: Angular velocity of shape2 (optional)
    """
    shape1: any
    shape2: any
    velocity1: core.Vector3
    velocity2: core.Vector3
    angular_velocity1: core.Vector3
    angular_velocity2: core.Vector3
    fn __init__(shape1: any,
        shape2: any,
        velocity1: core.Vector3,
        velocity2: core.Vector3,
        angular_velocity1: core.Vector3 = None,
        angular_velocity2: core.Vector3 = None
    ):
        self.shape1 = shape1
        self.shape2 = shape2
        self.velocity1 = velocity1
        self.velocity2 = velocity2
        self.angular_velocity1 = angular_velocity1 if angular_velocity1 is not None else core.Vector3(0.0, 0.0, 0.0)
        self.angular_velocity2 = angular_velocity2 if angular_velocity2 is not None else core.Vector3(0.0, 0.0, 0.0)


class CCDResult:
    """Result of continuous collision detection.

    Attributes:
        has_collision: Whether collision occurs during time step
        time_of_impact: Time [0, 1] when collision first occurs
        contact_point: Point of contact at TOI
        contact_normal: Normal at contact point
    """
    has_collision: bool
    time_of_impact: f64
    contact_point: core.Vector3
    contact_normal: core.Vector3
    fn __init__(has_collision: bool,
        time_of_impact: f64 = 0.0,
        contact_point: core.Vector3 = None,
        contact_normal: core.Vector3 = None
    ):
        self.has_collision = has_collision
        self.time_of_impact = time_of_impact
        self.contact_point = contact_point if contact_point is not None else core.Vector3(0.0, 0.0, 0.0)
        self.contact_normal = contact_normal if contact_normal is not None else core.Vector3(0.0, 1.0, 0.0)


fn continuous_collision_detection(query: ContinuousCollisionQuery) -> CCDResult:
    """Perform continuous collision detection using conservative advancement.

    Args:
        query: CCD query with shapes and velocities

    Returns:
        CCD result with time of impact

    Example:
        ```simple
        val sphere1 = SphereShape(core.Vector3(0.0, 0.0, 0.0), 1.0)
        val sphere2 = SphereShape(core.Vector3(10.0, 0.0, 0.0), 1.0)
        val velocity = core.Vector3(20.0, 0.0, 0.0)  # Fast moving!

        val query = ContinuousCollisionQuery(
            sphere1, sphere2,
            velocity, core.Vector3(0.0, 0.0, 0.0)
        )

        val result = continuous_collision_detection(query)
        if result.has_collision:
            print("Collision at t={result.time_of_impact}")
        ```

    Note:
        Uses binary search over time interval [0, 1] to find TOI.
        Accuracy controlled by tolerance (1e-4).
    """
    # Conservative advancement algorithm
    val max_iterations = 32
    val tolerance = 1e-4

    var t_min = 0.0
    var t_max = 1.0

    # Binary search for time of impact
    for _ in range(max_iterations):
        val t_mid = (t_min + t_max) * 0.5

        # Advance shapes to time t_mid
        val pos1 = query.shape1.position.add(query.velocity1.scale(t_mid))
        val pos2 = query.shape2.position.add(query.velocity2.scale(t_mid))

        # Create temporary shapes at mid-time
        val shape1_mid = SphereShape(pos1, query.shape1.radius)
        val shape2_mid = SphereShape(pos2, query.shape2.radius)

        # Check collision at this time
        val colliding = gjk_test(shape1_mid, shape2_mid)

        if colliding:
            t_max = t_mid  # Collision occurs before t_mid
        else:
            t_min = t_mid  # Collision occurs after t_mid

        # Check convergence
        if t_max - t_min < tolerance:
            break

    val toi = t_min

    # If collision found, compute contact details
    if toi < 1.0 - tolerance:
        val final_pos1 = query.shape1.position.add(query.velocity1.scale(toi))
        val final_pos2 = query.shape2.position.add(query.velocity2.scale(toi))

        val contact_normal = final_pos2.sub(final_pos1).normalize()
        val contact_point = final_pos1.add(contact_normal.scale(query.shape1.radius))

        return CCDResult(true, toi, contact_point, contact_normal)
    else:
        return CCDResult(false, 1.0, None, None)
