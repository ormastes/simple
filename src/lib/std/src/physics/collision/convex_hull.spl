# Convex Hull Generation - QuickHull Algorithm

pub use ConvexHull

use ..core as core

class ConvexHull:
    """3D Convex Hull - smallest convex shape containing a set of points.

    Uses QuickHull algorithm for efficient convex hull generation.
    """
    vertices: [core.Vector3]
    faces: [[i64]]
    normals: [core.Vector3]
    fn __init__(vertices: [core.Vector3], faces: [[i64]], normals: [core.Vector3]):
        """Initialize convex hull."""
        self.vertices = vertices
        self.faces = faces
        self.normals = normals

    static fn from_points(points: [core.Vector3]) -> ConvexHull:
        """Generate convex hull from point cloud using QuickHull algorithm."""
        if points.len() < 4:
            return ConvexHull._build_degenerate_hull(points)

        val extremal = ConvexHull._find_extremal_points(points)
        if extremal.len() < 4:
            return ConvexHull._build_degenerate_hull(points)

        val hull_vertices = [
            points[extremal[0]], points[extremal[1]],
            points[extremal[2]], points[extremal[3]]
        ]

        val hull_faces = [[0, 1, 2], [0, 2, 3], [0, 3, 1], [1, 3, 2]]

        val hull_normals = []
        for face in hull_faces:
            val v0 = hull_vertices[face[0]]
            val v1 = hull_vertices[face[1]]
            val v2 = hull_vertices[face[2]]
            val normal = ConvexHull._compute_face_normal(v0, v1, v2)
            hull_normals.append(normal)

        val remaining_points = []
        for i in range(points.len()):
            if i not in extremal:
                remaining_points.append(i)

        var changed = true
        while changed and remaining_points.len() > 0:
            changed = false

            val furthest_point = -1
            val furthest_face = -1
            val max_distance = 0.0

            for point_idx in remaining_points:
                val point = points[point_idx]
                for face_idx in range(hull_faces.len()):
                    val face = hull_faces[face_idx]
                    val v0 = hull_vertices[face[0]]
                    val normal = hull_normals[face_idx]
                    val distance = point.sub(v0).dot(normal)
                    if distance > max_distance:
                        max_distance = distance
                        furthest_point = point_idx
                        furthest_face = face_idx

            if furthest_point >= 0 and max_distance > 0.001:
                changed = true
                val new_vertex_idx = hull_vertices.len() as i64
                hull_vertices.append(points[furthest_point])

                val visible_faces = ConvexHull._find_visible_faces(
                    hull_vertices, hull_faces, hull_normals, points[furthest_point]
                )
                val horizon_edges = ConvexHull._get_horizon_edges(hull_faces, visible_faces)

                val new_faces = []
                val new_normals = []
                for i in range(hull_faces.len()):
                    if i not in visible_faces:
                        new_faces.append(hull_faces[i])
                        new_normals.append(hull_normals[i])

                for edge in horizon_edges:
                    val new_face = [edge[0], edge[1], new_vertex_idx]
                    new_faces.append(new_face)
                    val v0 = hull_vertices[edge[0]]
                    val v1 = hull_vertices[edge[1]]
                    val v2 = hull_vertices[new_vertex_idx]
                    val normal = ConvexHull._compute_face_normal(v0, v1, v2)
                    new_normals.append(normal)

                hull_faces = new_faces
                hull_normals = new_normals
                remaining_points.remove(furthest_point)

        return ConvexHull(hull_vertices, hull_faces, hull_normals)

    static fn _find_extremal_points(points: [core.Vector3]) -> [i64]:
        """Find 4 extremal points to form initial tetrahedron."""
        if points.len() == 0:
            return []

        var min_x = 0
        var max_x = 0
        var min_y = 0
        var max_y = 0
        var min_z = 0
        var max_z = 0

        for i in range(1, points.len()):
            if points[i].x < points[min_x].x: min_x = i
            if points[i].x > points[max_x].x: max_x = i
            if points[i].y < points[min_y].y: min_y = i
            if points[i].y > points[max_y].y: max_y = i
            if points[i].z < points[min_z].z: min_z = i
            if points[i].z > points[max_z].z: max_z = i

        val dx = points[max_x].x - points[min_x].x
        val dy = points[max_y].y - points[min_y].y
        val dz = points[max_z].z - points[min_z].z

        if dx >= dy and dx >= dz:
            return [min_x, max_x, min_y, max_y]
        elif dy >= dz:
            return [min_y, max_y, min_z, max_z]
        else:
            return [min_z, max_z, min_x, max_x]

    static fn _compute_face_normal(v0: core.Vector3, v1: core.Vector3, v2: core.Vector3) -> core.Vector3:
        """Compute outward-facing normal for a triangular face."""
        val edge1 = v1.sub(v0)
        val edge2 = v2.sub(v0)
        val normal = edge1.cross(edge2)
        return normal.normalize()

    static fn _find_visible_faces(
        vertices: [core.Vector3],
        faces: [[i64]],
        normals: [core.Vector3],
        point: core.Vector3
    ) -> [i64]:
        """Find all faces visible from a point."""
        val visible = []
        for i in range(faces.len()):
            val face = faces[i]
            val v0 = vertices[face[0]]
            val normal = normals[i]
            val distance = point.sub(v0).dot(normal)
            if distance > 0.001:
                visible.append(i)
        return visible

    static fn _get_horizon_edges(faces: [[i64]], visible_faces: [i64]) -> [[i64]]:
        """Get horizon edges between visible and non-visible faces."""
        val edges = []
        val visible_set = {}
        for idx in visible_faces:
            visible_set[idx] = true

        for face_idx in visible_faces:
            val face = faces[face_idx]
            val edge_pairs = [[face[0], face[1]], [face[1], face[2]], [face[2], face[0]]]
            for edge in edge_pairs:
                val is_horizon = ConvexHull._is_horizon_edge(edge, faces, visible_set)
                if is_horizon:
                    edges.append(edge)
        return edges

    static fn _is_horizon_edge(edge: [i64], faces: [[i64]], visible_set: {i64: bool}) -> bool:
        """Check if an edge is on the horizon."""
        val visible_count = 0
        val total_count = 0

        for i in range(faces.len()):
            val face = faces[i]
            val has_edge = (
                (face[0] == edge[0] and face[1] == edge[1]) or
                (face[1] == edge[0] and face[2] == edge[1]) or
                (face[2] == edge[0] and face[0] == edge[1]) or
                (face[0] == edge[1] and face[1] == edge[0]) or
                (face[1] == edge[1] and face[2] == edge[0]) or
                (face[2] == edge[1] and face[0] == edge[0])
            )
            if has_edge:
                total_count += 1
                if i in visible_set:
                    visible_count += 1

        return visible_count > 0 and visible_count < total_count

    static fn _build_degenerate_hull(points: [core.Vector3]) -> ConvexHull:
        """Build degenerate hull for < 4 points."""
        if points.len() == 0:
            return ConvexHull([], [], [])
        if points.len() == 1:
            return ConvexHull([points[0]], [], [])
        if points.len() == 2:
            val midpoint = points[0].add(points[1]).scale(0.5)
            return ConvexHull([points[0], points[1], midpoint], [[0, 1, 2]], [core.Vector3(0.0, 0.0, 0.0)])

        val v0 = points[0]
        val v1 = points[1]
        val v2 = points[2]
        val normal = ConvexHull._compute_face_normal(v0, v1, v2)
        return ConvexHull([v0, v1, v2], [[0, 1, 2]], [normal])
