# Physics Collision - Contact Information and Resolution
#
# Contact information from collision detection and impulse-based collision response.
#
# ## Classes
# - `Contact`: Collision contact information
# - `ContactResolver`: Impulse-based collision response with friction and restitution
#
# ## Example
# ```simple
# import physics.collision as collision
# import physics.dynamics as dynamics
# import physics.core as core
#
# # Create contact information
# val contact = collision.Contact(
#     point=core.Vector3(0.5, 0, 0),
#     normal=core.Vector3(1, 0, 0),
#     penetration=0.1,
#     body1_index=0,
#     body2_index=1
# )
#
# # Resolve collision with material properties
# val body1 = dynamics.RigidBody(mass=1.0, position=core.Vector3(0, 0, 0))
# val body2 = dynamics.RigidBody(mass=1.0, position=core.Vector3(1, 0, 0))
# val rubber = collision.Material::rubber()
# val metal = collision.Material::metal()
# collision.ContactResolver::resolve_contact(body1, body2, contact, rubber, metal)
# ```

export Contact, ContactResolver

use ..core as core
use ..dynamics as dynamics
use .materials.{Material}
# ============================================================================
# Contact - Collision Contact Information
# ============================================================================

class Contact:
    """Contact information from a collision.

    Attributes:
        point: Contact point in world space
        normal: Contact normal (from body1 to body2)
        penetration: Penetration depth
        body1_index: Index of first body
        body2_index: Index of second body
    """
    point: core.Vector3
    normal: core.Vector3
    penetration: f64
    body1_index: i32
    body2_index: i32
    fn __init__(point: core.Vector3,
        normal: core.Vector3,
        penetration: f64,
        body1_index: i32,
        body2_index: i32
    ):
        """Initialize contact.

        Args:
            point: Contact point
            normal: Contact normal
            penetration: Penetration depth
            body1_index: First body index
            body2_index: Second body index
        """
        self.point = point
        self.normal = normal
        self.penetration = penetration
        self.body1_index = body1_index
        self.body2_index = body2_index


# ============================================================================
# ContactResolver - Collision Response
# ============================================================================

class ContactResolver:
    """Resolves collisions with friction and restitution."""

    static fn resolve_contact(
        body1: dynamics.RigidBody,
        body2: dynamics.RigidBody,
        contact: Contact,
        material1: Material,
        material2: Material
    ):
        """Resolve a collision contact between two bodies.

        Applies impulse-based collision response with friction and restitution.

        Args:
            body1: First rigid body
            body2: Second rigid body
            contact: Contact information
            material1: Material of first body
            material2: Material of second body
        """
        # Skip if both bodies are static
        if body1.is_static() and body2.is_static():
            return

        # Calculate relative velocity at contact point
        val rel_velocity = body2.velocity.sub(body1.velocity)
        val velocity_along_normal = rel_velocity.dot(contact.normal)

        # Don't resolve if bodies are separating
        if velocity_along_normal > 0:
            return

        # Calculate combined restitution (min for more realistic behavior)
        val restitution = material1.restitution.min(material2.restitution)

        # Calculate impulse magnitude
        val inv_mass1 = 0.0 if body1.is_static() else 1.0 / body1.mass
        val inv_mass2 = 0.0 if body2.is_static() else 1.0 / body2.mass
        val inv_mass_sum = inv_mass1 + inv_mass2

        if inv_mass_sum == 0:
            return

        val impulse_magnitude = -(1.0 + restitution) * velocity_along_normal / inv_mass_sum

        # Apply normal impulse
        val impulse = contact.normal.scale(impulse_magnitude)
        body1.apply_impulse(impulse.scale(-1.0))
        body2.apply_impulse(impulse)

        # Calculate friction
        val friction = (material1.friction + material2.friction) * 0.5

        # Get tangent direction (perpendicular to normal)
        val tangent_velocity = rel_velocity.sub(
            contact.normal.scale(velocity_along_normal)
        )
        val tangent_magnitude = tangent_velocity.magnitude()

        if tangent_magnitude > 0.0001:
            val tangent = tangent_velocity.scale(1.0 / tangent_magnitude)

            # Friction impulse (Coulomb friction)
            val friction_magnitude = -tangent_velocity.magnitude() / inv_mass_sum
            val max_friction = impulse_magnitude.abs() * friction

            # Clamp friction to Coulomb limit
            if friction_magnitude.abs() > max_friction:
                friction_magnitude = max_friction * friction_magnitude.sign()

            val friction_impulse = tangent.scale(friction_magnitude)
            body1.apply_impulse(friction_impulse.scale(-1.0))
            body2.apply_impulse(friction_impulse)

        # Position correction to resolve penetration
        val correction_percent = 0.8  # How much to correct (0.2-0.8 typical)
        val slop = 0.01  # Penetration allowance (prevent jitter)

        if contact.penetration > slop:
            val correction = contact.normal.scale(
                (contact.penetration - slop) / inv_mass_sum * correction_percent
            )
            if not body1.is_static():
                body1.position = body1.position.sub(correction.scale(inv_mass1))
            if not body2.is_static():
                body2.position = body2.position.add(correction.scale(inv_mass2))
