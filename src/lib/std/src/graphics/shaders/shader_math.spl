# Shader Math - Common mathematical helper functions for shaders
#
# Provides basic math operations and vector utilities used across
# all shader implementations (PBR, IBL, postprocessing, etc.)

use graphics.math.*

# =============================================================================
# Scalar Math Functions
# =============================================================================

pub fn max(a: f32, b: f32) -> f32:
    return if a > b: a else: b

pub fn min(a: f32, b: f32) -> f32:
    return if a < b: a else: b

pub fn clamp(value: f32, min_val: f32, max_val: f32) -> f32:
    if value < min_val:
        return min_val
    if value > max_val:
        return max_val
    return value

pub fn abs(x: f32) -> f32:
    return if x < 0.0: -x else: x

pub fn saturate(x: f32) -> f32:
    return clamp(x, 0.0, 1.0)

# Placeholder implementations - would use native math library
pub fn pow(base: f32, exp: f32) -> f32:
    # Would use math library
    extern fn native_pow(base: f32, exp: f32) -> f32
    return native_pow(base, exp)

pub fn sqrt(x: f32) -> f32:
    extern fn native_sqrt(x: f32) -> f32
    return native_sqrt(x)

pub fn sin(x: f32) -> f32:
    extern fn native_sin(x: f32) -> f32
    return native_sin(x)

pub fn cos(x: f32) -> f32:
    extern fn native_cos(x: f32) -> f32
    return native_cos(x)

pub fn tan(x: f32) -> f32:
    extern fn native_tan(x: f32) -> f32
    return native_tan(x)

pub fn acos(x: f32) -> f32:
    extern fn native_acos(x: f32) -> f32
    return native_acos(x)

pub fn atan2(y: f32, x: f32) -> f32:
    extern fn native_atan2(y: f32, x: f32) -> f32
    return native_atan2(y, x)

pub fn floor(x: f32) -> f32:
    extern fn native_floor(x: f32) -> f32
    return native_floor(x)

pub fn ceil(x: f32) -> f32:
    extern fn native_ceil(x: f32) -> f32
    return native_ceil(x)

pub fn fract(x: f32) -> f32:
    return x - floor(x)

pub fn lerp(a: f32, b: f32, t: f32) -> f32:
    return a * (1.0 - t) + b * t

# =============================================================================
# Vector Math Functions
# =============================================================================

pub fn dot(a: Vec3, b: Vec3) -> f32:
    return a.x * b.x + a.y * b.y + a.z * b.z

pub fn lerp_vec3(a: Vec3, b: Vec3, t: f32) -> Vec3:
    return a * (1.0 - t) + b * t

pub fn lerp_vec4(a: Vec4, b: Vec4, t: f32) -> Vec4:
    return a * (1.0 - t) + b * t

pub fn max_vec3(a: Vec3, b: Vec3) -> Vec3:
    return Vec3::new(
        max(a.x, b.x),
        max(a.y, b.y),
        max(a.z, b.z)
    )

pub fn min_vec3(a: Vec3, b: Vec3) -> Vec3:
    return Vec3::new(
        min(a.x, b.x),
        min(a.y, b.y),
        min(a.z, b.z)
    )

pub fn clamp_vec3(v: Vec3, min_val: f32, max_val: f32) -> Vec3:
    return Vec3::new(
        clamp(v.x, min_val, max_val),
        clamp(v.y, min_val, max_val),
        clamp(v.z, min_val, max_val)
    )

pub fn saturate_vec3(v: Vec3) -> Vec3:
    return clamp_vec3(v, 0.0, 1.0)

pub fn abs_vec3(v: Vec3) -> Vec3:
    return Vec3::new(abs(v.x), abs(v.y), abs(v.z))

pub fn pow_vec3(v: Vec3, exp: Vec3) -> Vec3:
    return Vec3::new(
        pow(v.x, exp.x),
        pow(v.y, exp.y),
        pow(v.z, exp.z)
    )

pub fn sqrt_vec3(v: Vec3) -> Vec3:
    return Vec3::new(sqrt(v.x), sqrt(v.y), sqrt(v.z))

pub fn reflect(I: Vec3, N: Vec3) -> Vec3:
    return I - N * 2.0 * dot(I, N)

pub fn refract(I: Vec3, N: Vec3, eta: f32) -> Vec3:
    val cos_i = -dot(N, I)
    val sin_t2 = eta * eta * (1.0 - cos_i * cos_i)
    if sin_t2 > 1.0:
        return Vec3::zero()  # Total internal reflection
    val cos_t = sqrt(1.0 - sin_t2)
    return I * eta + N * (eta * cos_i - cos_t)

# =============================================================================
# Color/Gamma Functions
# =============================================================================

use graphics.shaders.shader_constants.{GAMMA, INV_GAMMA}

pub fn linear_to_srgb(color: Vec3) -> Vec3:
    return pow_vec3(color, Vec3::new(INV_GAMMA, INV_GAMMA, INV_GAMMA))

pub fn srgb_to_linear(color: Vec3) -> Vec3:
    return pow_vec3(color, Vec3::new(GAMMA, GAMMA, GAMMA))

# Reinhard tone mapping
pub fn tone_map_reinhard(color: Vec3) -> Vec3:
    return color / (color + Vec3::one())

# ACES tone mapping (approximation)
pub fn tone_map_aces(color: Vec3) -> Vec3:
    val a = 2.51
    val b = 0.03
    val c = 2.43
    val d = 0.59
    val e = 0.14
    return saturate_vec3((color * (color * a + b)) / (color * (color * c + d) + e))
