# Shader Math - Common mathematical helper functions for shaders
#
# Provides basic math operations and vector utilities used across
# all shader implementations (PBR, IBL, postprocessing, etc.)

use graphics.math.*

# =============================================================================
# Scalar Math Functions
# =============================================================================

pub fn max(left: f32, right: f32) -> f32:
    return if left > right: left else: right

pub fn min(left: f32, right: f32) -> f32:
    return if left < right: left else: right

pub fn clamp(value: f32, min_val: f32, max_val: f32) -> f32:
    if value < min_val:
        return min_val
    if value > max_val:
        return max_val
    return value

pub fn abs(x: f32) -> f32:
    return if x < 0.0: -x else: x

pub fn saturate(x: f32) -> f32:
    return clamp(value=x, min_val=0.0, max_val=1.0)

# Placeholder implementations - would use native math library
pub fn pow(base: f32, exp: f32) -> f32:
    # Would use math library
    extern fn native_pow(base: f32, exp: f32) -> f32
    return native_pow(base=base, exp=exp)

pub fn sqrt(x: f32) -> f32:
    extern fn native_sqrt(x: f32) -> f32
    return native_sqrt(x)

pub fn sin(x: f32) -> f32:
    extern fn native_sin(x: f32) -> f32
    return native_sin(x)

pub fn cos(x: f32) -> f32:
    extern fn native_cos(x: f32) -> f32
    return native_cos(x)

pub fn tan(x: f32) -> f32:
    extern fn native_tan(x: f32) -> f32
    return native_tan(x)

pub fn acos(x: f32) -> f32:
    extern fn native_acos(x: f32) -> f32
    return native_acos(x)

pub fn atan2(y: f32, x: f32) -> f32:
    extern fn native_atan2(y: f32, x: f32) -> f32
    return native_atan2(y=y, x=x)

pub fn floor(x: f32) -> f32:
    extern fn native_floor(x: f32) -> f32
    return native_floor(x)

pub fn ceil(x: f32) -> f32:
    extern fn native_ceil(x: f32) -> f32
    return native_ceil(x)

pub fn fract(x: f32) -> f32:
    return x - floor(x)

pub fn lerp(start: f32, end: f32, t: f32) -> f32:
    return start * (1.0 - t) + end * t

# =============================================================================
# Vector Math Functions
# =============================================================================

pub fn dot(left: Vec3, right: Vec3) -> f32:
    return left.x * right.x + left.y * right.y + left.z * right.z

pub fn lerp_vec3(start: Vec3, end: Vec3, t: f32) -> Vec3:
    return start * (1.0 - t) + end * t

pub fn lerp_vec4(start: Vec4, end: Vec4, t: f32) -> Vec4:
    return start * (1.0 - t) + end * t

pub fn max_vec3(left: Vec3, right: Vec3) -> Vec3:
    return Vec3.new(
        max(left=left.x, right=right.x),
        max(left=left.y, right=right.y),
        max(left=left.z, right=right.z)
    )

pub fn min_vec3(left: Vec3, right: Vec3) -> Vec3:
    return Vec3.new(
        min(left=left.x, right=right.x),
        min(left=left.y, right=right.y),
        min(left=left.z, right=right.z)
    )

pub fn clamp_vec3(v: Vec3, min_val: f32, max_val: f32) -> Vec3:
    return Vec3.new(
        clamp(value=v.x, min_val=min_val, max_val=max_val),
        clamp(value=v.y, min_val=min_val, max_val=max_val),
        clamp(value=v.z, min_val=min_val, max_val=max_val)
    )

pub fn saturate_vec3(v: Vec3) -> Vec3:
    return clamp_vec3(v, min_val=0.0, max_val=1.0)

pub fn abs_vec3(v: Vec3) -> Vec3:
    return Vec3.new(abs(v.x), abs(v.y), abs(v.z))

pub fn pow_vec3(v: Vec3, exp: Vec3) -> Vec3:
    return Vec3.new(
        pow(base=v.x, exp=exp.x),
        pow(base=v.y, exp=exp.y),
        pow(base=v.z, exp=exp.z)
    )

pub fn sqrt_vec3(v: Vec3) -> Vec3:
    return Vec3.new(sqrt(v.x), sqrt(v.y), sqrt(v.z))

pub fn reflect(I: Vec3, N: Vec3) -> Vec3:
    return I - N * 2.0 * dot(left=I, right=N)

pub fn refract(I: Vec3, N: Vec3, eta: f32) -> Vec3:
    val cos_i = -dot(left=N, right=I)
    val sin_t2 = eta * eta * (1.0 - cos_i * cos_i)
    if sin_t2 > 1.0:
        return Vec3.zero()  # Total internal reflection
    val cos_t = sqrt(1.0 - sin_t2)
    return I * eta + N * (eta * cos_i - cos_t)

# =============================================================================
# Color/Gamma Functions
# =============================================================================

use graphics.shaders.shader_constants.{GAMMA, INV_GAMMA}

pub fn linear_to_srgb(color: Vec3) -> Vec3:
    return pow_vec3(v=color, exp=Vec3.new(INV_GAMMA, INV_GAMMA, INV_GAMMA))

pub fn srgb_to_linear(color: Vec3) -> Vec3:
    return pow_vec3(v=color, exp=Vec3.new(GAMMA, GAMMA, GAMMA))

# Reinhard tone mapping
pub fn tone_map_reinhard(color: Vec3) -> Vec3:
    return color / (color + Vec3.one())

# ACES tone mapping (approximation)
pub fn tone_map_aces(color: Vec3) -> Vec3:
    val a = 2.51
    val b = 0.03
    val c = 2.43
    val d = 0.59
    val e = 0.14
    return saturate_vec3((color * (color * a + b)) / (color * (color * c + d) + e))
