# PBR Shaders - Physically Based Rendering
#
# Implements Cook-Torrance BRDF with metallic-roughness workflow.
# Provides vertex and fragment shaders for realistic material rendering.
#
# Based on: doc/spec/graphics_3d.md (Part 4.2: PBR Material)

use core.*
use graphics.math.*
use graphics.scene.*

# Import shared shader utilities
use graphics.shaders.shader_constants.{PI}
use graphics.shaders.shader_math.*
use graphics.shaders.pbr_common.*

# =============================================================================
# PBR Vertex Shader Input
# =============================================================================

pub struct PBRVertexInput:
    position: Vec3      # Vertex position (object space)
    normal: Vec3        # Vertex normal (object space)
    tangent: Vec4       # Tangent + bitangent sign
    tex_coord: Vec2     # UV coordinates
    color: Vec4         # Vertex color

# =============================================================================
# PBR Vertex Shader Output / Fragment Shader Input
# =============================================================================

pub struct PBRVaryings:
    position_world: Vec3    # Position in world space
    normal_world: Vec3      # Normal in world space
    tangent_world: Vec3     # Tangent in world space
    bitangent_world: Vec3   # Bitangent in world space
    tex_coord: Vec2         # UV coordinates
    color: Vec4             # Vertex color
    view_dir: Vec3          # Direction to camera

# =============================================================================
# PBR Uniforms
# =============================================================================

pub struct PBRMaterialUniforms:
    # Base properties
    albedo_color: Vec3
    metallic: f32
    roughness: f32
    ao: f32  # Ambient occlusion
    emissive: Vec3

    # Texture flags
    use_albedo_map: bool
    use_metallic_roughness_map: bool
    use_normal_map: bool
    use_ao_map: bool
    use_emissive_map: bool

# Re-export PBRLightingUniforms from pbr_common
export graphics.shaders.pbr_common.PBRLightingUniforms

pub struct PBRCameraUniforms:
    view_matrix: Mat4
    projection_matrix: Mat4
    view_position: Vec3

# =============================================================================
# PBR Vertex Shader
# =============================================================================

#[vertex_shader]
pub fn pbr_vertex_shader(
    input: PBRVertexInput,
    model_matrix: Mat4,
    normal_matrix: Mat3,
    camera: PBRCameraUniforms
) -> PBRVaryings:
    # Transform position to world space
    val world_pos = model_matrix.transform_point(input.position)

    # Transform normal to world space
    val world_normal = normal_matrix.transform_vector(input.normal).normalize()

    # Transform tangent to world space
    val world_tangent = normal_matrix.transform_vector(input.tangent.xyz()).normalize()

    # Compute bitangent (re-orthogonalize)
    val bitangent_sign = input.tangent.w
    val world_bitangent = world_normal.cross(world_tangent) * bitangent_sign

    # Compute view direction
    val view_dir = (camera.view_position - world_pos).normalize()

    # Output varyings
    return PBRVaryings {position_world: world_pos, normal_world: world_normal, tangent_world: world_tangent, bitangent_world: world_bitangent, tex_coord: input.tex_coord, color: input.color, view_dir: view_dir}

# =============================================================================
# PBR Fragment Shader
# =============================================================================

#[fragment_shader]
pub fn pbr_fragment_shader(
    varyings: PBRVaryings,
    material: PBRMaterialUniforms,
    lighting: PBRLightingUniforms
) -> Vec4:
    # Sample textures
    val albedo = if material.use_albedo_map:
        sample_texture_2d(albedo_map, varyings.tex_coord).rgb() * material.albedo_color
    else:
        material.albedo_color

    val metallic = if material.use_metallic_roughness_map:
        sample_texture_2d(metallic_roughness_map, varyings.tex_coord).b
    else:
        material.metallic

    val roughness = if material.use_metallic_roughness_map:
        sample_texture_2d(metallic_roughness_map, varyings.tex_coord).g
    else:
        material.roughness

    val ao = if material.use_ao_map:
        sample_texture_2d(ao_map, varyings.tex_coord).r
    else:
        material.ao

    val emissive = if material.use_emissive_map:
        sample_texture_2d(emissive_map, varyings.tex_coord).rgb() * material.emissive
    else:
        material.emissive

    # Get normal from normal map or vertex normal
    val N = if material.use_normal_map:
        val normal_sample = sample_texture_2d(normal_map, varyings.tex_coord).rgb()
        val normal_tangent = normal_sample * 2.0 - Vec3.one()

        # TBN matrix
        val T = varyings.tangent_world.normalize()
        val B = varyings.bitangent_world.normalize()
        val N = varyings.normal_world.normalize()

        # Transform normal from tangent space to world space
        (T * normal_tangent.x + B * normal_tangent.y + N * normal_tangent.z).normalize()
    else:
        varyings.normal_world.normalize()

    val V = varyings.view_dir.normalize()

    # Calculate reflectance at normal incidence
    val F0 = calculate_f0(albedo, metallic)

    # Accumulate lighting
    var Lo = Vec3.zero()

    # Directional light
    Lo = Lo + calculate_directional_light(N, V, albedo, metallic, roughness, F0, lighting)

    # Point lights
    for i in 0..lighting.point_light_count:
        Lo = Lo + calculate_point_light(
            varyings.position_world,
            N,
            V,
            albedo,
            metallic,
            roughness,
            F0,
            lighting.point_light_positions[i],
            lighting.point_light_colors[i],
            lighting.point_light_intensities[i],
            lighting.point_light_ranges[i]
        )

    # Ambient lighting (simplified IBL)
    val F = fresnel_schlick_roughness(max(dot(N, V), 0.0), F0, roughness)
    val kS = F
    var kD = Vec3.one() - kS
    kD = kD * (1.0 - metallic)

    val ambient = kD * albedo * lighting.ambient_color * lighting.ambient_intensity * ao

    # Final color
    var color = ambient + Lo + emissive

    # HDR tone mapping (Reinhard)
    color = tone_map_reinhard(color)

    # Gamma correction
    color = linear_to_srgb(color)

    return Vec4.from_vec3(color, 1.0)

# =============================================================================
# Texture Sampling (placeholders for actual implementations)
# =============================================================================

extern fn sample_texture_2d(texture_id: u64, uv: Vec2) -> Vec4
extern fn albedo_map() -> u64
extern fn metallic_roughness_map() -> u64
extern fn normal_map() -> u64
extern fn ao_map() -> u64
extern fn emissive_map() -> u64
