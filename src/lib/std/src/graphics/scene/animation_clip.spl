# Animation Clip - Keyframe animation data
#
# Animation clips with position, rotation, and scale keyframes.

pub use AnimationClip, AnimationChannel, PositionKey, RotationKey, ScaleKey

use graphics.math.*
use animation_utils.*

# =============================================================================
# Animation Clip - Keyframe animation data
# =============================================================================

pub struct AnimationClip:
    name: text
    duration: f32                     # Total duration in seconds
    channels: Array<AnimationChannel> # Per-joint animation channels

pub struct AnimationChannel:
    joint_index: i32                  # Target joint
    position_keys: Array<PositionKey>
    rotation_keys: Array<RotationKey>
    scale_keys: Array<ScaleKey>

pub struct PositionKey:
    time: f32
    value: Vec3

pub struct RotationKey:
    time: f32
    value: Quat

pub struct ScaleKey:
    time: f32
    value: Vec3

impl AnimationClip:
    pub fn new(name: text, duration: f32) -> AnimationClip:
        return AnimationClip {
            name: name,
            duration: duration,
            channels: Array.new()
        }

    # Add animation channel
    pub fn add_channel(mut self, channel: AnimationChannel):
        self.channels.push(channel)

    # Sample animation at specific time
    pub fn sample(self, time: f32) -> Array<Transform>:
        var transforms = Array<Transform>.new()

        for channel in self.channels:
            val transform = channel.sample(time)
            transforms.push(transform)

        return transforms

# =============================================================================
# Animation Channel Sampling
# =============================================================================

impl AnimationChannel:
    pub fn new(joint_index: i32) -> AnimationChannel:
        return AnimationChannel {
            joint_index: joint_index,
            position_keys: Array.new(),
            rotation_keys: Array.new(),
            scale_keys: Array.new()
        }

    # Sample channel at specific time
    pub fn sample(self, time: f32) -> Transform:
        val position = self.sample_position(time)
        val rotation = self.sample_rotation(time)
        val scale = self.sample_scale(time)

        return Transform.new(position, rotation, scale)

    # Sample position with linear interpolation
    fn sample_position(time: f32) -> Vec3:
        if self.position_keys.is_empty():
            return Vec3.zero()

        if self.position_keys.len() == 1:
            return self.position_keys[0].value

        # Find keyframe pair
        val (key0, key1, t) = find_keyframe_pair_position(&self.position_keys, time)

        # Linear interpolation
        return lerp_vec3(key0.value, key1.value, t)

    # Sample rotation with spherical interpolation
    fn sample_rotation(time: f32) -> Quat:
        if self.rotation_keys.is_empty():
            return Quat.identity()

        if self.rotation_keys.len() == 1:
            return self.rotation_keys[0].value

        # Find keyframe pair
        val (key0, key1, t) = find_keyframe_pair_rotation(&self.rotation_keys, time)

        # Spherical linear interpolation (SLERP)
        return slerp_quat(key0.value, key1.value, t)

    # Sample scale with linear interpolation
    fn sample_scale(time: f32) -> Vec3:
        if self.scale_keys.is_empty():
            return Vec3.new(1.0, 1.0, 1.0)

        if self.scale_keys.len() == 1:
            return self.scale_keys[0].value

        # Find keyframe pair
        val (key0, key1, t) = find_keyframe_pair_scale(&self.scale_keys, time)

        # Linear interpolation
        return lerp_vec3(key0.value, key1.value, t)
