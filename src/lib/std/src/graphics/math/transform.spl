# Transform - TRS (Translation-Rotation-Scale) composition
#
# Provides Transform type for 3D object transformations.
# Combines position (translation), rotation (quaternion), and scale.
# Caches transformation matrix for efficiency.
#
# Based on: doc/plans/floating-booping-coral.md (3D Graphics Library)

use core.*
use graphics.math.vector.*
use graphics.math.matrix.*
use graphics.math.quaternion.*

# =============================================================================
# Transform - 3D object transformation
# =============================================================================

pub struct Transform:
    position: Vec3
    rotation: Quaternion
    scale: Vec3
    matrix_cache: Option<Mat4>  # Cached TRS matrix

impl Transform:
    # Constructors
    pub fn new(position: Vec3, rotation: Quaternion, scale: Vec3) -> Transform:
        return Transform {
            position: position,
            rotation: rotation,
            scale: scale,
            matrix_cache: None
        }

    pub fn identity() -> Transform:
        return Transform {
            position: Vec3::zero(),
            rotation: Quaternion::identity(),
            scale: Vec3::one(),
            matrix_cache: None
        }

    pub fn at_position(position: Vec3) -> Transform:
        return Transform {
            position: position,
            rotation: Quaternion::identity(),
            scale: Vec3::one(),
            matrix_cache: None
        }

    # Component access
    pub fn get_position(self) -> Vec3:
        return self.position

    pub fn get_rotation(self) -> Quaternion:
        return self.rotation

    pub fn get_scale(self) -> Vec3:
        return self.scale

    pub fn set_position(mut self, position: Vec3):
        self.position = position
        self.matrix_cache = None

    pub fn set_rotation(mut self, rotation: Quaternion):
        self.rotation = rotation
        self.matrix_cache = None

    pub fn set_scale(mut self, scale: Vec3):
        self.scale = scale
        self.matrix_cache = None

    # Matrix computation (cached)
    pub fn to_matrix(mut self) -> Mat4:
        if self.matrix_cache.is_some():
            return self.matrix_cache.unwrap()

        # TRS composition: Translation * Rotation * Scale
        val t = Mat4::translation_vec3(self.position)
        val r = self.rotation.to_matrix()
        val s = Mat4::scaling_vec3(self.scale)

        val matrix = t * r * s
        self.matrix_cache = Some(matrix)
        return matrix

    # Transformation operations
    pub fn translate(mut self, offset: Vec3) -> Transform:
        self.position = self.position + offset
        self.matrix_cache = None
        return self

    pub fn rotate(mut self, rotation: Quaternion) -> Transform:
        self.rotation = rotation * self.rotation
        self.matrix_cache = None
        return self

    pub fn rotate_axis(mut self, axis: Vec3, angle: f32) -> Transform:
        val q = Quaternion::from_axis_angle(axis, angle)
        return self.rotate(q)

    pub fn rotate_euler(mut self, pitch: f32, yaw: f32, roll: f32) -> Transform:
        val q = Quaternion::from_euler(pitch, yaw, roll)
        return self.rotate(q)

    pub fn scale_by(mut self, factor: Vec3) -> Transform:
        self.scale = Vec3::new(
            self.scale.x * factor.x,
            self.scale.y * factor.y,
            self.scale.z * factor.z
        )
        self.matrix_cache = None
        return self

    pub fn scale_uniform(mut self, factor: f32) -> Transform:
        return self.scale_by(Vec3::new(factor, factor, factor))

    # Direction vectors (local axes)
    pub fn forward(self) -> Vec3:
        # Forward is negative Z in right-handed coordinate system
        return self.rotation.rotate_vector_direct(Vec3::new(0.0, 0.0, -1.0))

    pub fn right(self) -> Vec3:
        # Right is positive X
        return self.rotation.rotate_vector_direct(Vec3::new(1.0, 0.0, 0.0))

    pub fn up(self) -> Vec3:
        # Up is positive Y
        return self.rotation.rotate_vector_direct(Vec3::new(0.0, 1.0, 0.0))

    # Transform points and vectors
    pub fn transform_point(self, point: Vec3) -> Vec3:
        # Apply scale, then rotation, then translation
        val scaled = Vec3::new(
            point.x * self.scale.x,
            point.y * self.scale.y,
            point.z * self.scale.z
        )
        val rotated = self.rotation.rotate_vector_direct(scaled)
        return rotated + self.position

    pub fn transform_vector(self, vector: Vec3) -> Vec3:
        # Apply scale and rotation, but not translation
        val scaled = Vec3::new(
            vector.x * self.scale.x,
            vector.y * self.scale.y,
            vector.z * self.scale.z
        )
        return self.rotation.rotate_vector_direct(scaled)

    pub fn inverse_transform_point(self, point: Vec3) -> Vec3:
        # Reverse: translation, rotation, scale
        val translated = point - self.position
        val rotated = self.rotation.inverse().rotate_vector_direct(translated)
        return Vec3::new(
            rotated.x / self.scale.x,
            rotated.y / self.scale.y,
            rotated.z / self.scale.z
        )

    pub fn inverse_transform_vector(self, vector: Vec3) -> Vec3:
        # Reverse: rotation, scale
        val rotated = self.rotation.inverse().rotate_vector_direct(vector)
        return Vec3::new(
            rotated.x / self.scale.x,
            rotated.y / self.scale.y,
            rotated.z / self.scale.z
        )

    # Interpolation
    pub fn lerp(self, other: Transform, t: f32) -> Transform:
        return Transform {
            position: self.position.lerp(other.position, t),
            rotation: self.rotation.slerp(other.rotation, t),
            scale: self.scale.lerp(other.scale, t),
            matrix_cache: None
        }

    # Look-at (point transform toward target)
    pub fn look_at(mut self, target: Vec3, up: Vec3) -> Transform:
        val forward = (target - self.position).normalize()
        val right = forward.cross(up).normalize()
        val new_up = right.cross(forward)

        # Construct rotation matrix and convert to quaternion
        val rotation_matrix = Mat4::new(
            right.x, new_up.x, -forward.x, 0.0,
            right.y, new_up.y, -forward.y, 0.0,
            right.z, new_up.z, -forward.z, 0.0,
            0.0, 0.0, 0.0, 1.0
        )

        self.rotation = Quaternion::from_matrix(rotation_matrix)
        self.matrix_cache = None
        return self

    # Combine transforms (multiply)
    pub fn combine(self, other: Transform) -> Transform:
        # Apply other transform to this transform
        val new_position = self.transform_point(other.position)
        val new_rotation = self.rotation * other.rotation
        val new_scale = Vec3::new(
            self.scale.x * other.scale.x,
            self.scale.y * other.scale.y,
            self.scale.z * other.scale.z
        )

        return Transform {
            position: new_position,
            rotation: new_rotation,
            scale: new_scale,
            matrix_cache: None
        }

    # Inverse transform
    pub fn inverse(self) -> Transform:
        val inv_rotation = self.rotation.inverse()
        val inv_scale = Vec3::new(
            1.0 / self.scale.x,
            1.0 / self.scale.y,
            1.0 / self.scale.z
        )
        val inv_position = inv_rotation.rotate_vector_direct(
            Vec3::new(
                -self.position.x * inv_scale.x,
                -self.position.y * inv_scale.y,
                -self.position.z * inv_scale.z
            )
        )

        return Transform {
            position: inv_position,
            rotation: inv_rotation,
            scale: inv_scale,
            matrix_cache: None
        }

    # =========================================================================
    # Helper Methods
    # =========================================================================

    pub fn is_identity(self) -> bool:
        """Check if transform is identity (no transformation)."""
        return self.position.is_zero() and
               self.rotation.is_identity() and
               self.scale.x == 1.0 and self.scale.y == 1.0 and self.scale.z == 1.0

    pub fn is_uniform_scale(self) -> bool:
        """Check if all scale components are equal."""
        return abs(self.scale.x - self.scale.y) < 0.0001 and
               abs(self.scale.y - self.scale.z) < 0.0001

    pub fn is_non_uniform_scale(self) -> bool:
        """Check if scale is non-uniform (different components)."""
        return not self.is_uniform_scale()

    pub fn has_translation(self) -> bool:
        """Check if transform has non-zero translation."""
        return not self.position.is_zero()

    pub fn has_rotation(self) -> bool:
        """Check if transform has non-identity rotation."""
        return not self.rotation.is_identity()

    pub fn has_scale(self) -> bool:
        """Check if transform has non-unit scale."""
        return abs(self.scale.x - 1.0) > 0.0001 or
               abs(self.scale.y - 1.0) > 0.0001 or
               abs(self.scale.z - 1.0) > 0.0001

    pub fn is_finite(self) -> bool:
        """Check if all components are finite (not NaN or infinity)."""
        return self.position.is_finite() and
               self.rotation.is_finite() and
               self.scale.is_finite()

    pub fn has_nan(self) -> bool:
        """Check if any component is NaN."""
        return self.position.has_nan() or
               self.rotation.has_nan() or
               self.scale.has_nan()

    pub fn has_negative_scale(self) -> bool:
        """Check if any scale component is negative."""
        return self.scale.x < 0.0 or self.scale.y < 0.0 or self.scale.z < 0.0

    pub fn has_zero_scale(self) -> bool:
        """Check if any scale component is zero."""
        return abs(self.scale.x) < 0.0001 or
               abs(self.scale.y) < 0.0001 or
               abs(self.scale.z) < 0.0001

    pub fn is_cached(self) -> bool:
        """Check if transformation matrix is cached."""
        match self.matrix_cache:
            case Some(_):
                return true
            case None:
                return false

    pub fn get_uniform_scale(self) -> f32:
        """Get uniform scale value (average if non-uniform).

        Returns:
            Average of scale components
        """
        return (self.scale.x + self.scale.y + self.scale.z) / 3.0

    pub fn get_max_scale(self) -> f32:
        """Get maximum scale component."""
        return max(max(self.scale.x, self.scale.y), self.scale.z)

    pub fn get_min_scale(self) -> f32:
        """Get minimum scale component."""
        return min(min(self.scale.x, self.scale.y), self.scale.z)

    pub fn summary(self) -> text:
        """Get summary of transform.

        Returns:
            Human-readable summary

        Example:
            Transform::identity().summary()
            # â†’ "Transform: pos: (0.000, 0.000, 0.000), rot: 0.000 rad, scale: (1.000, 1.000, 1.000) [identity, cached]"
        """
        val pos = self.position
        val angle = self.rotation.angle()
        val scale = self.scale

        val id = if self.is_identity(): ", identity" else: ""
        val uniform = if self.has_scale() and self.is_uniform_scale(): ", uniform scale" else: ""
        val cached = if self.is_cached(): ", cached" else: ""

        return "Transform: pos: ({pos.x:.3}, {pos.y:.3}, {pos.z:.3}), rot: {angle:.3} rad, scale: ({scale.x:.3}, {scale.y:.3}, {scale.z:.3}){id}{uniform}{cached}"
