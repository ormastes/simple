# VectorOps - Shared vector math operations
#
# This module provides a VectorOps trait and helper implementations
# for common vector operations across Vec2, Vec3, Vec4, and Quaternion.
#
# Eliminates duplication of methods like is_zero, is_finite, lerp, etc.

use core.*

# =============================================================================
# VectorOps Trait
# =============================================================================

trait VectorOps:
    """Trait for vector types with common operations.

    Provides a unified interface for predicates, extrema, and interpolation.
    Types implementing this trait can use the helper functions in this module.
    """

    # Required: Get number of components
    fn dimension() -> usize

    # Required: Get component by index (0-indexed)
    fn component(index: usize) -> f32

    # Required: Set component by index
    fn with_component(index: usize, value: f32) -> Self

    # Required: Get zero vector
    fn zero_vector() -> Self

    # Required: Get length squared (dot with self)
    fn length_squared() -> f32

# =============================================================================
# Predicate Helpers
# =============================================================================

@pure
pub fn is_zero_impl<V: VectorOps>(v: &V) -> bool:
    """Check if vector is exactly zero.

    Example:
        >>> is_zero_impl(&Vec3.zero())
        true
    """
    for i in 0..v.dimension():
        if v.component(i) != 0.0:
            return false
    true

@pure
pub fn is_near_zero_impl<V: VectorOps>(v: &V, epsilon: f32) -> bool:
    """Check if vector is near zero within epsilon.

    Example:
        >>> is_near_zero_impl(&Vec3.new(0.0001, 0.0, 0.0), 0.001)
        true
    """
    for i in 0..v.dimension():
        if abs(v.component(i)) >= epsilon:
            return false
    true

@pure
pub fn is_unit_impl<V: VectorOps>(v: &V) -> bool:
    """Check if vector is unit length (normalized).

    Returns true if length² is within 0.0001 of 1.0.

    Example:
        >>> is_unit_impl(&Vec3.new(1.0, 0.0, 0.0))
        true
    """
    val len_sq = v.length_squared()
    abs(len_sq - 1.0) < 0.0001

@pure
pub fn is_finite_impl<V: VectorOps>(v: &V) -> bool:
    """Check if all components are finite (not NaN or infinity).

    Example:
        >>> is_finite_impl(&Vec3.new(1.0, 2.0, 3.0))
        true
    """
    for i in 0..v.dimension():
        if not is_finite(v.component(i)):
            return false
    true

@pure
pub fn has_nan_impl<V: VectorOps>(v: &V) -> bool:
    """Check if any component is NaN.

    Example:
        >>> has_nan_impl(&Vec3.new(1.0, f32.nan(), 0.0))
        true
    """
    for i in 0..v.dimension():
        if is_nan(v.component(i)):
            return true
    false

# =============================================================================
# Component Extrema Helpers
# =============================================================================

@pure
pub fn component_min_impl<V: VectorOps>(v: &V) -> f32:
    """Get minimum component value.

    Example:
        >>> component_min_impl(&Vec3.new(1.0, -2.0, 3.0))
        -2.0
    """
    if v.dimension() == 0:
        return 0.0
    var result = v.component(0)
    for i in 1..v.dimension():
        val c = v.component(i)
        if c < result:
            result = c
    result

@pure
pub fn component_max_impl<V: VectorOps>(v: &V) -> f32:
    """Get maximum component value.

    Example:
        >>> component_max_impl(&Vec3.new(1.0, -2.0, 3.0))
        3.0
    """
    if v.dimension() == 0:
        return 0.0
    var result = v.component(0)
    for i in 1..v.dimension():
        val c = v.component(i)
        if c > result:
            result = c
    result

@pure
pub fn component_sum_impl<V: VectorOps>(v: &V) -> f32:
    """Get sum of all components.

    Example:
        >>> component_sum_impl(&Vec3.new(1.0, 2.0, 3.0))
        6.0
    """
    var sum: f32 = 0.0
    for i in 0..v.dimension():
        sum = sum + v.component(i)
    sum

@pure
pub fn component_product_impl<V: VectorOps>(v: &V) -> f32:
    """Get product of all components.

    Example:
        >>> component_product_impl(&Vec3.new(2.0, 3.0, 4.0))
        24.0
    """
    if v.dimension() == 0:
        return 0.0
    var product = v.component(0)
    for i in 1..v.dimension():
        product = product * v.component(i)
    product

# =============================================================================
# Component-wise Binary Operations
# =============================================================================

@pure
pub fn abs_impl<V: VectorOps>(v: &V) -> V:
    """Get vector with absolute value of each component.

    Example:
        >>> abs_impl(&Vec3.new(-1.0, 2.0, -3.0))
        Vec3.new(1.0, 2.0, 3.0)
    """
    var result = V.zero_vector()
    for i in 0..v.dimension():
        result = result.with_component(i, abs(v.component(i)))
    result

@pure
pub fn min_componentwise_impl<V: VectorOps>(a: &V, b: &V) -> V:
    """Get component-wise minimum.

    Example:
        >>> min_componentwise_impl(&Vec3.new(1.0, 5.0, 3.0), &Vec3.new(2.0, 3.0, 4.0))
        Vec3.new(1.0, 3.0, 3.0)
    """
    var result = V.zero_vector()
    for i in 0..a.dimension():
        result = result.with_component(i, min(a.component(i), b.component(i)))
    result

@pure
pub fn max_componentwise_impl<V: VectorOps>(a: &V, b: &V) -> V:
    """Get component-wise maximum.

    Example:
        >>> max_componentwise_impl(&Vec3.new(1.0, 5.0, 3.0), &Vec3.new(2.0, 3.0, 4.0))
        Vec3.new(2.0, 5.0, 4.0)
    """
    var result = V.zero_vector()
    for i in 0..a.dimension():
        result = result.with_component(i, max(a.component(i), b.component(i)))
    result

@pure
pub fn clamp_componentwise_impl<V: VectorOps>(v: &V, min_val: &V, max_val: &V) -> V:
    """Clamp each component between min and max.

    Example:
        >>> clamp_componentwise_impl(&Vec3.new(-1.0, 5.0, 2.0),
        >>>                          &Vec3.new(0.0, 0.0, 0.0),
        >>>                          &Vec3.new(1.0, 1.0, 1.0))
        Vec3.new(0.0, 1.0, 1.0)
    """
    var result = V.zero_vector()
    for i in 0..v.dimension():
        result = result.with_component(
            i,
            clamp(v.component(i), min_val.component(i), max_val.component(i))
        )
    result

# =============================================================================
# Interpolation Helpers
# =============================================================================

@pure
pub fn lerp_impl<V: VectorOps>(a: &V, b: &V, t: f32) -> V:
    """Linear interpolation between two vectors.

    Args:
        a: Start vector (t=0)
        b: End vector (t=1)
        t: Interpolation factor (0.0 to 1.0)

    Returns:
        Interpolated vector

    Example:
        >>> lerp_impl(&Vec3.zero(), &Vec3.new(10.0, 0.0, 0.0), 0.5)
        Vec3.new(5.0, 0.0, 0.0)
    """
    var result = V.zero_vector()
    for i in 0..a.dimension():
        val start = a.component(i)
        val end = b.component(i)
        result = result.with_component(i, start + (end - start) * t)
    result

@pure
pub fn smoothstep_impl<V: VectorOps>(a: &V, b: &V, t: f32) -> V:
    """Smooth interpolation using Hermite polynomial.

    Provides smoother transitions than linear interpolation.

    Args:
        a: Start vector (t=0)
        b: End vector (t=1)
        t: Interpolation factor (0.0 to 1.0)

    Returns:
        Smoothly interpolated vector
    """
    val clamped_t = clamp(t, 0.0, 1.0)
    val smooth_t = clamped_t * clamped_t * (3.0 - 2.0 * clamped_t)
    lerp_impl(a, b, smooth_t)

@pure
pub fn smootherstep_impl<V: VectorOps>(a: &V, b: &V, t: f32) -> V:
    """Even smoother interpolation using 5th degree polynomial.

    Provides C2 continuous transitions (zero first and second derivatives at endpoints).

    Args:
        a: Start vector (t=0)
        b: End vector (t=1)
        t: Interpolation factor (0.0 to 1.0)

    Returns:
        Very smoothly interpolated vector
    """
    val clamped_t = clamp(t, 0.0, 1.0)
    val smoother_t = clamped_t * clamped_t * clamped_t * (clamped_t * (clamped_t * 6.0 - 15.0) + 10.0)
    lerp_impl(a, b, smoother_t)

# =============================================================================
# Vector Math Helpers
# =============================================================================

@pure
pub fn length_impl<V: VectorOps>(v: &V) -> f32:
    """Get vector length (magnitude).

    Example:
        >>> length_impl(&Vec3.new(3.0, 4.0, 0.0))
        5.0
    """
    sqrt(v.length_squared())

@pure
pub fn distance_impl<V: VectorOps + Sub<Output=V>>(a: &V, b: &V) -> f32:
    """Get distance between two vectors.

    Example:
        >>> distance_impl(&Vec3.zero(), &Vec3.new(3.0, 4.0, 0.0))
        5.0
    """
    val diff = *b - *a
    length_impl(&diff)

@pure
pub fn normalize_impl<V: VectorOps>(v: &V) -> V:
    """Normalize vector to unit length.

    Returns a default unit vector if length is too small.

    Example:
        >>> normalize_impl(&Vec3.new(3.0, 0.0, 0.0))
        Vec3.new(1.0, 0.0, 0.0)
    """
    val len = length_impl(v)
    if len < 0.0001:
        # Return first unit basis vector
        var result = V.zero_vector()
        if v.dimension() > 0:
            result = result.with_component(0, 1.0)
        return result

    var result = V.zero_vector()
    for i in 0..v.dimension():
        result = result.with_component(i, v.component(i) / len)
    result

@pure
pub fn dot_impl<V: VectorOps>(a: &V, b: &V) -> f32:
    """Compute dot product of two vectors.

    Example:
        >>> dot_impl(&Vec3.new(1.0, 2.0, 3.0), &Vec3.new(4.0, 5.0, 6.0))
        32.0
    """
    var sum: f32 = 0.0
    for i in 0..a.dimension():
        sum = sum + a.component(i) * b.component(i)
    sum

@pure
pub fn angle_between_impl<V: VectorOps>(a: &V, b: &V) -> f32:
    """Get angle between two vectors in radians.

    Example:
        >>> angle_between_impl(&Vec3.unit_x(), &Vec3.unit_y())
        1.5708  # π/2
    """
    val dot = dot_impl(a, b)
    val lens = length_impl(a) * length_impl(b)
    if lens < 0.0001:
        return 0.0
    acos(clamp(dot / lens, -1.0, 1.0))

# =============================================================================
# Projection Helpers
# =============================================================================

@pure
pub fn project_onto_impl<V: VectorOps + Mul<f32, Output=V>>(v: &V, onto: &V) -> V:
    """Project vector onto another vector.

    Example:
        >>> project_onto_impl(&Vec3.new(3.0, 4.0, 0.0), &Vec3.unit_x())
        Vec3.new(3.0, 0.0, 0.0)
    """
    val onto_len_sq = onto.length_squared()
    if onto_len_sq < 0.0001:
        return V.zero_vector()
    val scale = dot_impl(v, onto) / onto_len_sq
    *onto * scale

@pure
pub fn reject_from_impl<V: VectorOps + Sub<Output=V> + Mul<f32, Output=V>>(v: &V, from: &V) -> V:
    """Get rejection of vector from another (perpendicular component).

    Example:
        >>> reject_from_impl(&Vec3.new(3.0, 4.0, 0.0), &Vec3.unit_x())
        Vec3.new(0.0, 4.0, 0.0)
    """
    *v - project_onto_impl(v, from)

# =============================================================================
# Formatting Helpers
# =============================================================================

@pure
pub fn format_components_impl<V: VectorOps>(v: &V, precision: i32) -> text:
    """Format vector components with given precision.

    Example:
        >>> format_components_impl(&Vec3.new(1.5, 2.5, 3.5), 2)
        "(1.50, 2.50, 3.50)"
    """
    var parts: List<text> = List.new()
    for i in 0..v.dimension():
        parts.push("{v.component(i):.{precision}}")
    "(" + parts.join(", ") + ")"

@pure
pub fn summary_impl<V: VectorOps>(v: &V, type_name: text) -> text:
    """Generate summary string for vector.

    Example:
        >>> summary_impl(&Vec3.new(1.0, 0.0, 0.0), "Vec3")
        "Vec3: (1.000, 0.000, 0.000), length: 1.000, unit"
    """
    val len = length_impl(v)
    val components = format_components_impl(v, 3)
    var suffix = ""
    if is_unit_impl(v):
        suffix = ", unit"
    if is_zero_impl(v):
        suffix = suffix + " [zero]"
    "{type_name}: {components}, length: {len:.3}{suffix}"
