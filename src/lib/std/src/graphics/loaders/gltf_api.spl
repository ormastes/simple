# glTF API - Loader class and public API
use core.*
use graphics.math.*
use graphics.scene.*

# =============================================================================
# glTF Loader
# =============================================================================

pub struct GltfLoader:
    file: GltfFile
    base_path: text         # Directory of .gltf file for resolving URIs

# =============================================================================
# Public API
# =============================================================================

impl GltfLoader:
    # Load glTF file from path (.gltf or .glb)
    pub fn load_file(path: text) -> Result<Scene, text>:
        # Read file contents
        val contents = match file_read_bytes(path):
            case Ok(data):
                data
            case Err(err):
                return Err("Failed to read glTF file: " + err)

        # Determine file type
        val is_glb = path.ends_with(".glb")

        # Get base path for relative URIs
        val base_path = path_get_directory(path)

        # Parse glTF
        var loader = if is_glb:
            GltfLoader.parse_glb(contents, base_path)?
        else:
            GltfLoader.parse_gltf(text.from_bytes(contents), base_path)?

        # Load binary buffers
        loader.load_buffers()?

        # Convert to scene
        return loader.to_scene()

    # Parse .gltf (JSON) file
    fn parse_gltf(json_str: text, base_path: text) -> Result<GltfLoader, text>:
        # Parse JSON
        val json = json_parse(json_str)
            .ok_or("Failed to parse glTF JSON")?

        # Parse glTF structure
        val file = GltfLoader.parse_json(json)?

        return Ok(GltfLoader {
            file: file,
            base_path: base_path
        })

    # Parse .glb (binary) file
    fn parse_glb(data: Array<u8>, base_path: text) -> Result<GltfLoader, text>:
        # GLB header: magic (4 bytes), version (4), length (4)
        if data.len() < 12:
            return Err("GLB file too short")

        val magic = read_u32_le(&data, 0)
        if magic != 0x46546C67:  # "glTF" in little-endian
            return Err("Invalid GLB magic number")

        val version = read_u32_le(&data, 4)
        if version != 2:
            return Err("Unsupported GLB version: " + version.to_string())

        # Read chunks
        var offset = 12
        var json_str = ""
        var bin_data = Array<u8>.new()

        while offset < data.len():
            if offset + 8 > data.len():
                break

            val chunk_length = read_u32_le(&data, offset) as i32
            val chunk_type = read_u32_le(&data, offset + 4)
            offset = offset + 8

            if offset + chunk_length > data.len():
                return Err("GLB chunk exceeds file length")

            if chunk_type == 0x4E4F534A:  # "JSON"
                json_str = text.from_bytes(data.slice(offset, offset + chunk_length))
            else if chunk_type == 0x004E4942:  # "BIN\0"
                bin_data = data.slice(offset, offset + chunk_length)

            offset = offset + chunk_length

        if json_str.is_empty():
            return Err("GLB file missing JSON chunk")

        # Parse JSON
        var loader = GltfLoader.parse_gltf(json_str, base_path)?

        # Store binary data in first buffer
        if not bin_data.is_empty() and loader.file.buffers.len() > 0:
            loader.file.buffers[0].data = bin_data

        return Ok(loader)

