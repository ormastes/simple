# Image Loader - PNG/JPG texture loading
#
# Loads textures from image files.
# Supports PNG (lossless) and JPG (lossy) formats.
# Handles pixel format conversion and mipmap generation.
# Creates Texture2D objects ready for GPU upload.
#
# Based on: doc/plans/floating-booping-coral.md (Phase 5)

use core.*
use graphics.math.*
use graphics.render.*

# =============================================================================
# Image Loader
# =============================================================================

pub struct ImageLoader:
    # Static utility - no instance data
    _dummy: u8

pub enum ImageFormat:
    PNG
    JPG
    Unknown

impl ImageFormat:
    pub fn is_png(self) -> bool:
        """Check if this is PNG format.
        Returns: true for PNG
        Example: ImageFormat::PNG.is_png()  # → true
        """
        match self:
            case ImageFormat::PNG: true
            case _: false

    pub fn is_jpg(self) -> bool:
        """Check if this is JPG format.
        Returns: true for JPG
        Example: ImageFormat::JPG.is_jpg()  # → true
        """
        match self:
            case ImageFormat::JPG: true
            case _: false

    pub fn is_unknown(self) -> bool:
        """Check if this is Unknown format.
        Returns: true for Unknown
        Example: ImageFormat::Unknown.is_unknown()  # → true
        """
        match self:
            case ImageFormat::Unknown: true
            case _: false

    pub fn is_supported(self) -> bool:
        """Check if format is supported for loading.
        Returns: true for PNG or JPG
        Example: ImageFormat::PNG.is_supported()  # → true
        """
        match self:
            case ImageFormat::PNG: true
            case ImageFormat::JPG: true
            case ImageFormat::Unknown: false

    pub fn supports_transparency(self) -> bool:
        """Check if format supports alpha channel transparency.
        Returns: true for PNG
        Example: ImageFormat::PNG.supports_transparency()  # → true
        """
        match self:
            case ImageFormat::PNG: true
            case _: false

    pub fn to_string(self) -> text:
        """Convert ImageFormat to string representation.
        Returns: lowercase format name
        Example: ImageFormat::PNG.to_string()  # → "png"
        """
        match self:
            case ImageFormat::PNG: "png"
            case ImageFormat::JPG: "jpg"
            case ImageFormat::Unknown: "unknown"

    pub fn description(self) -> text:
        """Get human-readable description of the image format.
        Returns: descriptive explanation
        Example: ImageFormat::PNG.description()
                # → "PNG: Portable Network Graphics with lossless compression"
        """
        match self:
            case ImageFormat::PNG: "PNG: Portable Network Graphics with lossless compression"
            case ImageFormat::JPG: "JPEG: Joint Photographic Experts Group with lossy compression"
            case ImageFormat::Unknown: "Unknown or unsupported image format"

    pub fn summary(self) -> text:
        """Get comprehensive summary of the image format.
        Returns: summary with format name, description, and properties
        Example: ImageFormat::PNG.summary()
                # → "ImageFormat: png (PNG: Portable Network Graphics with lossless compression, supported, transparent)"
        """
        val name = self.to_string()
        val desc = self.description()
        var props = []

        if self.is_supported():
            props.push("supported")
        else:
            props.push("unsupported")

        if self.supports_transparency():
            props.push("transparent")

        val props_str = props.join(", ")
        "ImageFormat: {name} ({desc}, {props_str})"

pub struct ImageData:
    width: u32
    height: u32
    format: PixelFormat
    pixels: Array<u8>   # Raw pixel data (RGBA8 or RGB8)

pub enum PixelFormat:
    RGB8       # 3 bytes per pixel
    RGBA8      # 4 bytes per pixel
    R8         # 1 byte per pixel (grayscale)

impl PixelFormat:
    pub fn is_rgb8(self) -> bool:
        """Check if this is RGB8 format.
        Returns: true for RGB8
        Example: PixelFormat::RGB8.is_rgb8()  # → true
        """
        match self:
            case PixelFormat::RGB8: true
            case _: false

    pub fn is_rgba8(self) -> bool:
        """Check if this is RGBA8 format.
        Returns: true for RGBA8
        Example: PixelFormat::RGBA8.is_rgba8()  # → true
        """
        match self:
            case PixelFormat::RGBA8: true
            case _: false

    pub fn is_r8(self) -> bool:
        """Check if this is R8 format.
        Returns: true for R8
        Example: PixelFormat::R8.is_r8()  # → true
        """
        match self:
            case PixelFormat::R8: true
            case _: false

    pub fn has_alpha(self) -> bool:
        """Check if format has alpha channel.
        Returns: true for RGBA8
        Example: PixelFormat::RGBA8.has_alpha()  # → true
        """
        match self:
            case PixelFormat::RGBA8: true
            case _: false

    pub fn is_color(self) -> bool:
        """Check if format is color (not grayscale).
        Returns: true for RGB8 or RGBA8
        Example: PixelFormat::RGB8.is_color()  # → true
        """
        match self:
            case PixelFormat::RGB8: true
            case PixelFormat::RGBA8: true
            case PixelFormat::R8: false

    pub fn is_grayscale(self) -> bool:
        """Check if format is grayscale.
        Returns: true for R8
        Example: PixelFormat::R8.is_grayscale()  # → true
        """
        match self:
            case PixelFormat::R8: true
            case _: false

    pub fn bytes_per_pixel(self) -> u32:
        """Get number of bytes per pixel.
        Returns: bytes per pixel (1, 3, or 4)
        Example: PixelFormat::RGBA8.bytes_per_pixel()  # → 4
        """
        match self:
            case PixelFormat::RGB8: 3
            case PixelFormat::RGBA8: 4
            case PixelFormat::R8: 1

    pub fn channel_count(self) -> u32:
        """Get number of color channels.
        Returns: channel count (1, 3, or 4)
        Example: PixelFormat::RGB8.channel_count()  # → 3
        """
        match self:
            case PixelFormat::RGB8: 3
            case PixelFormat::RGBA8: 4
            case PixelFormat::R8: 1

    pub fn to_string(self) -> text:
        """Convert PixelFormat to string representation.
        Returns: format name
        Example: PixelFormat::RGBA8.to_string()  # → "RGBA8"
        """
        match self:
            case PixelFormat::RGB8: "RGB8"
            case PixelFormat::RGBA8: "RGBA8"
            case PixelFormat::R8: "R8"

    pub fn description(self) -> text:
        """Get human-readable description of the pixel format.
        Returns: descriptive explanation
        Example: PixelFormat::RGBA8.description()
                # → "RGBA8: 4 bytes per pixel with alpha channel"
        """
        match self:
            case PixelFormat::RGB8: "RGB8: 3 bytes per pixel color"
            case PixelFormat::RGBA8: "RGBA8: 4 bytes per pixel with alpha channel"
            case PixelFormat::R8: "R8: 1 byte per pixel grayscale"

    pub fn summary(self) -> text:
        """Get comprehensive summary of the pixel format.
        Returns: summary with format name, description, and properties
        Example: PixelFormat::RGBA8.summary()
                # → "PixelFormat: RGBA8 (RGBA8: 4 bytes per pixel with alpha channel, 4 channels, color, has alpha)"
        """
        val name = self.to_string()
        val desc = self.description()
        val channels = self.channel_count()
        var props = []

        props.push("{channels} channels")

        if self.is_color():
            props.push("color")
        elif self.is_grayscale():
            props.push("grayscale")

        if self.has_alpha():
            props.push("has alpha")

        val props_str = props.join(", ")
        "PixelFormat: {name} ({desc}, {props_str})"

# =============================================================================
# Public API
# =============================================================================

impl ImageLoader:
    # Load image from file
    pub fn load_file(path: text) -> Result<ImageData, text>:
        # Detect format from extension
        val format = ImageLoader::detect_format(path)

        # Read file as bytes
        val bytes = match file_read_bytes(path):
            case Ok(data):
                data
            case Err(err):
                return Err("Failed to read image file: " + err)

        # Decode based on format
        return match format:
            case ImageFormat::PNG:
                ImageLoader::decode_png(bytes)
            case ImageFormat::JPG:
                ImageLoader::decode_jpg(bytes)
            case ImageFormat::Unknown:
                Err("Unknown image format for file: " + path)

    # Load image and create texture
    pub fn load_texture(path: text, generate_mipmaps: bool) -> Result<Texture2D, text>:
        val image_data = ImageLoader::load_file(path)?

        # Convert to texture format
        val texture_format = match image_data.format:
            case PixelFormat::RGB8:
                TextureFormat::RGB8
            case PixelFormat::RGBA8:
                TextureFormat::RGBA8
            case PixelFormat::R8:
                TextureFormat::R8

        # Calculate mip levels
        val mip_levels = if generate_mipmaps:
            ImageLoader::calculate_mip_levels(image_data.width, image_data.height)
        else:
            1

        # Create texture
        val texture = Texture2D::new(
            image_data.width,
            image_data.height,
            texture_format,
            mip_levels
        )

        # Upload pixel data
        texture.upload_data(image_data.pixels)

        # Generate mipmaps if requested
        if generate_mipmaps:
            texture.generate_mipmaps()

        return Ok(texture)

# =============================================================================
# Format Detection
# =============================================================================

impl ImageLoader:
    fn detect_format(path: text) -> ImageFormat:
        val lower_path = path.to_lowercase()

        if lower_path.ends_with(".png"):
            return ImageFormat::PNG
        else if lower_path.ends_with(".jpg") or lower_path.ends_with(".jpeg"):
            return ImageFormat::JPG
        else:
            return ImageFormat::Unknown

    fn calculate_mip_levels(width: u32, height: u32) -> u32:
        val max_dimension = max_u32(width, height)
        var levels = 1_u32

        var size = max_dimension
        while size > 1:
            size = size / 2
            levels = levels + 1

        return levels

# =============================================================================
# PNG Decoding
# =============================================================================

impl ImageLoader:
    fn decode_png(bytes: Array<u8>) -> Result<ImageData, text>:
        # Verify PNG signature (8 bytes: 137 80 78 71 13 10 26 10)
        if bytes.len() < 8:
            return Err("File too small to be PNG")

        if bytes[0] != 137 or bytes[1] != 80 or bytes[2] != 78 or bytes[3] != 71:
            return Err("Invalid PNG signature")

        # Decode PNG using FFI (delegates to Rust/C library)
        val result = png_decode(bytes)

        return match result:
            case Ok(decoded):
                Ok(decoded)
            case Err(err):
                Err("PNG decoding failed: " + err)

# =============================================================================
# JPG Decoding
# =============================================================================

impl ImageLoader:
    fn decode_jpg(bytes: Array<u8>) -> Result<ImageData, text>:
        # Verify JPG signature (2 bytes: FF D8)
        if bytes.len() < 2:
            return Err("File too small to be JPG")

        if bytes[0] != 0xFF or bytes[1] != 0xD8:
            return Err("Invalid JPG signature")

        # Decode JPG using FFI (delegates to Rust/C library)
        val result = jpg_decode(bytes)

        return match result:
            case Ok(decoded):
                Ok(decoded)
            case Err(err):
                Err("JPG decoding failed: " + err)

# =============================================================================
# Image Data Manipulation
# =============================================================================

impl ImageData:
    # Convert RGB8 to RGBA8 (add alpha channel)
    pub fn to_rgba8(self) -> ImageData:
        if self.format == PixelFormat::RGBA8:
            return self  # Already RGBA8

        if self.format != PixelFormat::RGB8:
            # Cannot convert non-RGB to RGBA
            return self

        val pixel_count = (self.width * self.height) as usize
        var rgba_pixels = Array<u8>::with_capacity(pixel_count * 4)

        # Convert RGB to RGBA (add alpha = 255)
        for i in 0..pixel_count:
            val rgb_offset = i * 3
            rgba_pixels.push(self.pixels[rgb_offset])      # R
            rgba_pixels.push(self.pixels[rgb_offset + 1])  # G
            rgba_pixels.push(self.pixels[rgb_offset + 2])  # B
            rgba_pixels.push(255)                          # A (opaque)

        return ImageData {
            width: self.width,
            height: self.height,
            format: PixelFormat::RGBA8,
            pixels: rgba_pixels
        }

    # Flip vertically (OpenGL convention: origin bottom-left)
    pub fn flip_vertical(mut self) -> ImageData:
        val bytes_per_pixel = match self.format:
            case PixelFormat::RGB8: 3
            case PixelFormat::RGBA8: 4
            case PixelFormat::R8: 1

        val row_size = (self.width as usize) * bytes_per_pixel
        var flipped = Array<u8>::with_capacity(self.pixels.len())

        # Copy rows in reverse order
        for y in 0..self.height:
            val src_row = ((self.height - 1 - y) as usize) * row_size
            val src_end = src_row + row_size

            for i in src_row..src_end:
                flipped.push(self.pixels[i])

        self.pixels = flipped
        return self

    # Get pixel color at (x, y)
    pub fn get_pixel(self, x: u32, y: u32) -> Color:
        if x >= self.width or y >= self.height:
            return Color::from_rgb(0.0, 0.0, 0.0)  # Out of bounds

        val bytes_per_pixel = match self.format:
            case PixelFormat::RGB8: 3
            case PixelFormat::RGBA8: 4
            case PixelFormat::R8: 1

        val index = ((y * self.width + x) as usize) * bytes_per_pixel

        return match self.format:
            case PixelFormat::RGB8:
                val r = self.pixels[index] as f32 / 255.0
                val g = self.pixels[index + 1] as f32 / 255.0
                val b = self.pixels[index + 2] as f32 / 255.0
                Color::from_rgb(r, g, b)

            case PixelFormat::RGBA8:
                val r = self.pixels[index] as f32 / 255.0
                val g = self.pixels[index + 1] as f32 / 255.0
                val b = self.pixels[index + 2] as f32 / 255.0
                val a = self.pixels[index + 3] as f32 / 255.0
                Color::from_rgba(r, g, b, a)

            case PixelFormat::R8:
                val gray = self.pixels[index] as f32 / 255.0
                Color::from_rgb(gray, gray, gray)

# =============================================================================
# Helper Functions
# =============================================================================

fn max_u32(a: u32, b: u32) -> u32:
    if a > b:
        return a
    return b

# =============================================================================
# File I/O and Image Decoding (FFI - to be implemented in runtime)
# =============================================================================

# Read file as bytes
extern fn file_read_bytes(path: text) -> Result<Array<u8>, text>

# Decode PNG image (delegates to image crate in Rust)
extern fn png_decode(bytes: Array<u8>) -> Result<ImageData, text>

# Decode JPG image (delegates to image crate in Rust)
extern fn jpg_decode(bytes: Array<u8>) -> Result<ImageData, text>
