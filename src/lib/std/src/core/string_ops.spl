# text Operations - Internal helpers, mutation, search, transform
use core.traits.*
use core.collections.*

# ============================================
# Internal helpers
# ============================================

impl text:
    fn reserve(additional: usize):
        val required = self.len + additional
        if required <= self.cap:
            return

        var new_cap = if self.cap == 0: 16 else: self.cap * 2
        while new_cap < required:
            new_cap = new_cap * 2

        val new_data = alloc[u8](new_cap)
        if self.data != nil:
            danger:
                copy_mem(new_data, self.data, self.len)
                dealloc(self.data)
        self.data = new_data
        self.cap = new_cap

    fn push_byte(b: u8):
        self.reserve(1)
        danger:
            self.data.offset(self.len as isize).write(b)
        self.len = self.len + 1

# ============================================
# Len trait (byte length)
# ============================================

impl Len for text:
    fn len() -> usize:
        self.len

# ============================================
# text-specific size methods
# ============================================

impl text:
    # Number of Unicode characters
    @pure
    fn char_count() -> usize:
        var count: usize = 0
        var i: usize = 0
        while i < self.len:
            danger:
                val b = self.data.offset(i as isize).read()
                if b < 0x80:
                    i = i + 1
                else if b < 0xE0:
                    i = i + 2
                else if b < 0xF0:
                    i = i + 3
                else:
                    i = i + 4
            count = count + 1
        count

    # Byte length (same as len())
    @pure
    fn byte_len() -> usize:
        self.len

# ============================================
# Iterable trait (iterates over chars)
# ============================================

impl Iterable<char> for text:
    type Iter = StringCharIter

    fn iter() -> Self::Iter:
        StringCharIter { string: self, byte_index: 0 }

    fn into_iter() -> Self::Iter:
        self.iter()

# ============================================
# Collection trait
# ============================================

impl Collection<char> for text

# ============================================
# Sequence trait (character access)
# ============================================

impl Sequence<char> for text:
    fn get(idx: usize) -> Option<char>:
        # Get character at character index (not byte index)
        var char_idx: usize = 0
        var byte_idx: usize = 0
        while byte_idx < self.len:
            if char_idx == idx:
                return Some(self.char_at_byte(byte_idx))
            byte_idx = byte_idx + self.char_width_at(byte_idx)
            char_idx = char_idx + 1
    nil

    fn slice(start: usize, end: usize) -> Slice<u8>:
        # Slice by byte indices
        if start > end or end > self.len:
            Slice::empty()
        else:
            danger:
                Slice::new(self.data.offset(start as isize), end - start)

# ============================================
# ImmutSequence trait (strings are immutable-style)
# ============================================

impl ImmutSequence<char> for text:
    type Output = text

    fn with_index(idx: usize, value: char) -> Option<Self::Output>:
        # Replace character at index
        var new_str = text::new()
        var char_idx: usize = 0
        for c in self.iter():
            if char_idx == idx:
                new_str.push(value)
            else:
                new_str.push(c)
            char_idx = char_idx + 1
        if char_idx <= idx:
    nil
        else:
            Some(new_str)

    fn sorted() -> Self::Output:
        # Sort characters
        var chars = List<char>::new()
        for c in self.iter():
            chars.push(c)
        chars.sort()
        var result = text::new()
        for c in chars:
            result.push(c)
        result

    fn reversed() -> Self::Output:
        var chars = List<char>::new()
        for c in self.iter():
            chars.push(c)
        chars.reverse()
        var result = text::new()
        for c in chars:
            result.push(c)
        result

    fn filtered(predicate: fn(&char) -> bool) -> Self::Output:
        var result = text::new()
        for c in self.iter():
            if predicate(&c):
                result.push(c)
        result

    fn mapped<U>(self, f: fn(char) -> U) -> List<U>:
        var result = List::new()
        for c in self.iter():
            result.push(f(c))
        result

    fn appended(item: char) -> Self::Output:
        var result = self.clone()
        result.push(item)
        result

    fn prepended(item: char) -> Self::Output:
        var result = text::new()
        result.push(item)
        result.push_str(self.as_str())
        result

    fn taken(n: usize) -> Self::Output:
        var result = text::new()
        var count: usize = 0
        for c in self.iter():
            if count >= n:
                break
            result.push(c)
            count = count + 1
        result

    fn dropped(n: usize) -> Self::Output:
        var result = text::new()
        var count: usize = 0
        for c in self.iter():
            if count >= n:
                result.push(c)
            count = count + 1
        result

    fn taken_while(predicate: fn(&char) -> bool) -> Self::Output:
        var result = text::new()
        for c in self.iter():
            if not predicate(&c):
                break
            result.push(c)
        result

    fn dropped_while(predicate: fn(&char) -> bool) -> Self::Output:
        var result = text::new()
        var dropping = true
        for c in self.iter():
            if dropping and predicate(&c):
                continue
            dropping = false
            result.push(c)
        result

# ============================================
# Sliceable trait (byte slices)
# ============================================

impl Sliceable<u8> for text:
    fn as_slice() -> Slice<u8>:
        danger:
            Slice::new(self.data, self.len)

# ============================================
# text mutation methods
# ============================================

impl text:
    # Push single character
    fn push(c: char):
        val width = c.len_utf8()
        self.reserve(width)
        danger:
            c.encode_utf8_to(self.data.offset(self.len as isize))
        self.len = self.len + width

    # Push string slice
    fn push_str(s: &str):
        self.reserve(s.len())
        danger:
            copy_mem(self.data.offset(self.len as isize), s.as_ptr(), s.len())
        self.len = self.len + s.len()

    # Pop last character
    fn pop() -> Option<char>:
        if self.len == 0:
            return nil
        # Find start of last character
        var i = self.len - 1
        danger:
            while i > 0 and (self.data.offset(i as isize).read() & 0xC0) == 0x80:
                i = i - 1
        val c = self.char_at_byte(i)
        self.len = i
        Some(c)

    # Clear string
    fn clear():
        self.len = 0

    # Truncate to byte length
    fn truncate(new_len: usize):
        if new_len < self.len:
            self.len = new_len

# ============================================
# text search methods
# ============================================

impl text:
    @pure
    fn contains(needle: &str) -> bool:
        self.find_str(needle).is_some()

    @pure
    fn starts_with(prefix: &str) -> bool:
        if prefix.len() > self.len:
            return false
        danger:
            for i in 0..prefix.len():
                if self.data.offset(i as isize).read() != prefix.as_ptr().offset(i as isize).read():
                    return false
        true

    @pure
    fn ends_with(suffix: &str) -> bool:
        if suffix.len() > self.len:
            return false
        val offset = self.len - suffix.len()
        danger:
            for i in 0..suffix.len():
                if self.data.offset((offset + i) as isize).read() != suffix.as_ptr().offset(i as isize).read():
                    return false
        true

    @pure
    fn find_str(needle: &str) -> Option<usize>:
        if needle.len() > self.len or needle.is_empty():
            return nil
        val end = self.len - needle.len() + 1
        for i in 0..end:
            var found = true
            danger:
                for j in 0..needle.len():
                    if self.data.offset((i + j) as isize).read() != needle.as_ptr().offset(j as isize).read():
                        found = false
                        break
            if found:
                return Some(i)
    nil

# ============================================
# text transformation methods (return new)
# ============================================

impl text:
    @pure
    fn trimmed() -> text:
        var start: usize = 0
        var end = self.len
        danger:
            while start < end and is_whitespace(self.data.offset(start as isize).read()):
                start = start + 1
            while end > start and is_whitespace(self.data.offset((end - 1) as isize).read()):
                end = end - 1
        self.substring(start, end)

    @pure
    fn trim_start() -> text:
        var start: usize = 0
        danger:
            while start < self.len and is_whitespace(self.data.offset(start as isize).read()):
                start = start + 1
        self.substring(start, self.len)

    @pure
    fn trim_end() -> text:
        var end = self.len
        danger:
            while end > 0 and is_whitespace(self.data.offset((end - 1) as isize).read()):
                end = end - 1
        self.substring(0, end)

    @pure
    fn uppercased() -> text:
        var result = text::with_capacity(self.len)
        danger:
            for i in 0..self.len:
                val b = self.data.offset(i as isize).read()
                if b >= 'a' as u8 and b <= 'z' as u8:
                    result.push_byte(b - 32)
                else:
                    result.push_byte(b)
        result

    @pure
    fn lowercased() -> text:
        var result = text::with_capacity(self.len)
        danger:
            for i in 0..self.len:
                val b = self.data.offset(i as isize).read()
                if b >= 'A' as u8 and b <= 'Z' as u8:
                    result.push_byte(b + 32)
                else:
                    result.push_byte(b)
        result

    @pure
    fn replaced(old: &str, new: &str) -> text:
        if old.is_empty():
            return self.clone()
        var result = text::new()
        var i: usize = 0
        while i < self.len:
            match self.find_str_from(old, i):
                case Some(pos):
                    result.push_str(self.substring(i, pos).as_str())
                    result.push_str(new)
                    i = pos + old.len()
                case nil:
                    result.push_str(self.substring(i, self.len).as_str())
                    break
        result

    @pure
    fn substring(start: usize, end: usize) -> text:
        if start >= end or start >= self.len:
            return text::new()
        val actual_end = if end > self.len: self.len else: end
        val len = actual_end - start
        var result = text::with_capacity(len)
        danger:
            copy_mem(result.data, self.data.offset(start as isize), len)
        result.len = len
        result

# ============================================
# text split methods
# ============================================

impl text:
    @pure
    fn split(sep: &str) -> List<text>:
        var result = List::new()
        if sep.is_empty():
            # Split into characters
            for c in self.iter():
                var s = text::new()
                s.push(c)
                result.push(s)
            return result

        var start: usize = 0
        while start < self.len:
            match self.find_str_from(sep, start):
                case Some(pos):
                    result.push(self.substring(start, pos))
                    start = pos + sep.len()
                case nil:
                    result.push(self.substring(start, self.len))
                    break
        result

    @pure
    fn split_once(sep: &str) -> Option<(text, text)>:
        match self.find_str(sep):
            case Some(pos):
                Some((self.substring(0, pos), self.substring(pos + sep.len(), self.len)))
            case nil:
    nil

    @pure
    fn lines() -> List<text>:
        self.split("\n")

# ============================================
# Internal helper methods
# ============================================

impl text:
    @pure
    fn char_at_byte(byte_idx: usize) -> char:
        danger:
            val b0 = self.data.offset(byte_idx as isize).read()
            if b0 < 0x80:
                return b0 as char
            else if b0 < 0xE0:
                val b1 = self.data.offset((byte_idx + 1) as isize).read()
                return (((b0 & 0x1F) as u32 << 6) | ((b1 & 0x3F) as u32)) as char
            else if b0 < 0xF0:
                val b1 = self.data.offset((byte_idx + 1) as isize).read()
                val b2 = self.data.offset((byte_idx + 2) as isize).read()
                return (((b0 & 0x0F) as u32 << 12) | ((b1 & 0x3F) as u32 << 6) | ((b2 & 0x3F) as u32)) as char
            else:
                val b1 = self.data.offset((byte_idx + 1) as isize).read()
                val b2 = self.data.offset((byte_idx + 2) as isize).read()
                val b3 = self.data.offset((byte_idx + 3) as isize).read()
                return (((b0 & 0x07) as u32 << 18) | ((b1 & 0x3F) as u32 << 12) | ((b2 & 0x3F) as u32 << 6) | ((b3 & 0x3F) as u32)) as char

    @pure
    fn char_width_at(byte_idx: usize) -> usize:
        danger:
            val b = self.data.offset(byte_idx as isize).read()
            if b < 0x80: 1
            else if b < 0xE0: 2
            else if b < 0xF0: 3
            else: 4

    @pure
    fn find_str_from(needle: &str, start: usize) -> Option<usize>:
        if needle.len() > self.len - start or needle.is_empty():
            return nil
        val end = self.len - needle.len() + 1
        for i in start..end:
            var found = true
            danger:
                for j in 0..needle.len():
                    if self.data.offset((i + j) as isize).read() != needle.as_ptr().offset(j as isize).read():
                        found = false
                        break
            if found:
                return Some(i)
    nil

    @pure
    fn as_str() -> &str:
        danger:
            &*(self.data as *str)

    @pure
    fn as_bytes() -> Slice<u8>:
        danger:
            Slice::new(self.data, self.len)

# ============================================
# Additional string methods
# ============================================

impl text:
    # Extract substring with start position and length
    # Unlike substring(start, end), this takes a length parameter
    @pure
    fn substr(start: usize, length: usize) -> text:
        self.substring(start, start + length)

    # Find all occurrences of needle in string
    # Returns list of byte indices where needle starts
    @pure
    fn find_all(needle: &str) -> List<usize>:
        var result = List<usize>::new()
        if needle.is_empty() or needle.len() > self.len:
            return result
        var pos: usize = 0
        while pos < self.len:
            match self.find_str_from(needle, pos):
                case Some(idx):
                    result.push(idx)
                    pos = idx + 1
                case nil:
                    break
        result

    # Capitalize first letter, lowercase the rest
    @pure
    fn capitalize() -> text:
        if self.len == 0:
            return text::new()
        var result = text::with_capacity(self.len)
        var first = true
        for c in self.iter():
            if first:
                # Uppercase first character
                if c >= 'a' and c <= 'z':
                    result.push((c as u8 - 32) as char)
                else:
                    result.push(c)
                first = false
            else:
                # Lowercase rest
                if c >= 'A' and c <= 'Z':
                    result.push((c as u8 + 32) as char)
                else:
                    result.push(c)
        result

    # Join a list of strings with self as delimiter
    @pure
    fn join(parts: List<text>) -> text:
        if parts.is_empty():
            return text::new()
        var result = text::new()
        var first = true
        for part in parts:
            if not first:
                result.push_str(self.as_str())
            result.push_str(part.as_str())
            first = false
        result

    # Replace only the first occurrence of old with new
    @pure
    fn replace_first(old: &str, new: &str) -> text:
        if old.is_empty():
            return self.clone()
        match self.find_str(old):
            case Some(pos):
                var result = text::new()
                result.push_str(self.substring(0, pos).as_str())
                result.push_str(new)
                result.push_str(self.substring(pos + old.len(), self.len).as_str())
                result
            case nil:
                self.clone()

# ============================================
# Method aliases for compatibility
# ============================================

impl text:
    # Alias for trimmed() - removes leading and trailing whitespace
    @pure
    fn trim() -> text:
        self.trimmed()

    # Alias for trimmed() - Ruby/Python style
    @pure
    fn strip() -> text:
        self.trimmed()

    # Primary Ruby-style method for uppercase
    @pure
    fn upper() -> text:
        self.uppercased()

    # Primary Ruby-style method for lowercase
    @pure
    fn lower() -> text:
        self.lowercased()

    # Deprecated: use upper() instead
    @deprecated("use upper() instead")
    @pure
    fn to_upper() -> text:
        self.uppercased()

    # Deprecated: use lower() instead
    @deprecated("use lower() instead")
    @pure
    fn to_lower() -> text:
        self.lowercased()

    # Deprecated: use lower() instead
    @deprecated("use lower() instead")
    @pure
    fn to_lowercase() -> text:
        self.lowercased()

    # Deprecated: use upper() instead
    @deprecated("use upper() instead")
    @pure
    fn to_uppercase() -> text:
        self.uppercased()

    # Alias for find_str() - returns Option<usize>
    @pure
    fn find(needle: &str) -> Option<usize>:
        self.find_str(needle)

    # Alias for replaced() - replaces all occurrences
    @pure
    fn replace(old: &str, new: &str) -> text:
        self.replaced(old, new)

    # Alias for char_at_byte() - get character at index
    @pure
    fn char_at(idx: usize) -> text:
        if idx >= self.char_count():
            return text::new()
        var char_idx: usize = 0
        var byte_idx: usize = 0
        while byte_idx < self.len:
            if char_idx == idx:
                val c = self.char_at_byte(byte_idx)
                var result = text::new()
                result.push(c)
                return result
            byte_idx = byte_idx + self.char_width_at(byte_idx)
            char_idx = char_idx + 1
        text::new()

# ============================================
# Ruby-style Iteration Methods
# ============================================

impl text:
    fn each(f: fn(char)):
        """Execute closure for each character.

        Args:
            f: Closure to execute with each character

        Example:
            "hello".each(|c| print(c))
        """
        for c in self.iter():
            f(c)

    fn each_with_index(f: fn(usize, char)):
        """Execute closure for each character with its index.

        Args:
            f: Closure to execute with index and character

        Example:
            "hello".each_with_index(|i, c| print("{i}: {c}"))
        """
        var idx: usize = 0
        for c in self.iter():
            f(idx, c)
            idx = idx + 1

    @deprecated("Use each() instead")
    fn chars() -> List<char>:
        """Get list of characters in the string.

        Returns:
            List containing all characters

        Example:
            val chars = "hello".chars()  # ['h', 'e', 'l', 'l', 'o']

        Note: Deprecated - prefer using each() for iteration.
        """
        var result = List<char>::new()
        for c in self.iter():
            result.push(c)
        result

    fn each_byte(f: fn(u8)):
        """Execute closure for each byte.

        Args:
            f: Closure to execute with each byte

        Example:
            "hello".each_byte(|b| print(b))
        """
        for i in 0..self.len:
            danger:
                val b = self.data.offset(i as isize).read()
                f(b)

    fn each_line(f: fn(text)):
        """Execute closure for each line.

        Args:
            f: Closure to execute with each line

        Example:
            multiline_str.each_line(|line| print(line))
        """
        val lines = self.lines()
        for line in lines:
            f(line)

