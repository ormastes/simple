# Iterator - Iterator trait and utilities
#
# Provides the core Iterator trait and common iterator adapters.

# Core iterator trait
trait Iterator<T>:
    # Get the next element, or None if exhausted
    fn next() -> Option<T>

    # Size hint: (lower bound, optional upper bound)
    fn size_hint() -> (i64, Option<i64>):
        return (0, Option.none())

    # Consume iterator and count elements
    fn count() -> i64:
        var n: i64 = 0
        while self.next().is_some():
            n = n + 1
        return n

    # Get the last element
    fn last() -> Option<T>:
        var result: Option<T> = Option.none()
        for item in self:
            result = Option.some(item)
        return result

    # Get the nth element (0-indexed)
    fn nth(n: i64) -> Option<T>:
        for i in 0..n:
            if self.next().is_none():
                return Option.none()
        return self.next()

    # Skip first n elements
    fn skip(n: i64) -> SkipIterator<T>:
        return SkipIterator(inner: self, remaining: n)

    # Take first n elements
    fn take(n: i64) -> TakeIterator<T>:
        return TakeIterator(inner: self, remaining: n)

    # Filter elements by predicate
    fn filter(pred: fn(T) -> bool) -> FilterIterator<T>:
        return FilterIterator(inner: self, predicate: pred)

    # Transform elements
    fn map<U>(f: fn(T) -> U) -> MapIterator<T, U>:
        return MapIterator(inner: self, transform: f)

    # Collect into a list
    fn collect() -> List<T>:
        var result: List<T> = []
        for item in self:
            result.push(item)
        return result

    # Check if any element matches predicate
    fn any(pred: fn(T) -> bool) -> bool:
        for item in self:
            if pred(item):
                return true
        return false

    # Check if all elements match predicate
    fn all(pred: fn(T) -> bool) -> bool:
        for item in self:
            if not pred(item):
                return false
        return true

    # Find first element matching predicate
    fn find(pred: fn(T) -> bool) -> Option<T>:
        for item in self:
            if pred(item):
                return Option.some(item)
        return Option.none()

    # Fold/reduce with initial value
    fn fold<U>(init: U, f: fn(U, T) -> U) -> U:
        var acc = init
        for item in self:
            acc = f(acc, item)
        return acc

# Skip iterator adapter
struct SkipIterator<T>:
    inner: Iterator<T>
    remaining: i64

impl SkipIterator<T>: Iterator<T>:
    fn next() -> Option<T>:
        while self.remaining > 0:
            self.inner.next()
            self.remaining = self.remaining - 1
        return self.inner.next()

# Take iterator adapter
struct TakeIterator<T>:
    inner: Iterator<T>
    remaining: i64

impl TakeIterator<T>: Iterator<T>:
    fn next() -> Option<T>:
        if self.remaining <= 0:
            return Option.none()
        self.remaining = self.remaining - 1
        return self.inner.next()

# Filter iterator adapter
struct FilterIterator<T>:
    inner: Iterator<T>
    predicate: fn(T) -> bool

impl FilterIterator<T>: Iterator<T>:
    fn next() -> Option<T>:
        while true:
            match self.inner.next():
                Option.Some(item):
                    if self.predicate(item):
                        return Option.some(item)
                nil:
                    return Option.none()

# Map iterator adapter
struct MapIterator<T, U>:
    inner: Iterator<T>
    transform: fn(T) -> U

impl MapIterator<T, U>: Iterator<U>:
    fn next() -> Option<U>:
        match self.inner.next():
            Option.Some(item):
                return Option.some(self.transform(item))
            nil:
                return Option.none()

# Range iterator
struct RangeIterator:
    current: i64
    end: i64
    step: i64

    static fn new(start: i64, end: i64) -> RangeIterator:
        return RangeIterator(current: start, end: end, step: 1)

    static fn with_step(start: i64, end: i64, step: i64) -> RangeIterator:
        return RangeIterator(current: start, end: end, step: step)

impl RangeIterator: Iterator<i64>:
    fn next() -> Option<i64>:
        if self.current >= self.end:
            return Option.none()
        val value = self.current
        self.current = self.current + self.step
        return Option.some(value)

    fn size_hint() -> (i64, Option<i64>):
        val remaining = (self.end - self.current) / self.step
        return (remaining, Option.some(remaining))

# Utility functions
fn range(end: i64) -> RangeIterator:
    return RangeIterator.new(0, end)

fn range_from(start: i64, end: i64) -> RangeIterator:
    return RangeIterator.new(start, end)

fn range_step(start: i64, end: i64, step: i64) -> RangeIterator:
    return RangeIterator.with_step(start, end, step)

pub use Iterator, SkipIterator, TakeIterator, FilterIterator, MapIterator
pub use RangeIterator, range, range_from, range_step
