# Collection Traits - Shared interfaces for List, Array, Slice, text
# Enables generic programming over sequential containers
# Similar to C#'s IList<T>, ICollection<T>, IEnumerable<T>

use core.traits.*
use core.sorting.*
use core.math.*
use core.list.*

# ============================================
# Index Error Type
# ============================================

enum IndexError:
    OutOfBounds(index: usize, len: usize)

impl IndexError:
    @pure
    fn message() -> str:
        match self:
            case OutOfBounds(i, l): "index {i} out of bounds (len={l})"

    # =========================================================================
    # Helper Methods
    # =========================================================================

    @pure
    pub fn to_string() -> text:
        """Convert error to string.

        Returns:
            Error name
        """
        "OutOfBounds"

    @pure
    pub fn description() -> text:
        """Get detailed error description.

        Returns:
            Human-readable description
        """
        self.message()

    @pure
    pub fn get_index() -> usize:
        """Get the index that was out of bounds.

        Returns:
            Index value
        """
        match self:
            case OutOfBounds(i, _): i

    @pure
    pub fn get_length() -> usize:
        """Get the collection length.

        Returns:
            Length value
        """
        match self:
            case OutOfBounds(_, l): l

    @pure
    pub fn is_negative_index() -> bool:
        """Check if index is conceptually negative (wraps).

        Returns:
            True if index >= length (likely wrap-around)
        """
        match self:
            case OutOfBounds(i, l): i >= l

    @pure
    pub fn distance_from_end() -> usize:
        """Get distance from end of collection.

        Returns:
            How many elements past the end
        """
        match self:
            case OutOfBounds(i, l):
                if i >= l:
                    i - l + 1
                else:
                    0

    @pure
    pub fn summary() -> text:
        """Get summary of index error.

        Returns:
            Human-readable summary

        Example:
            IndexError.OutOfBounds(10, 5).summary()
            # â†’ "IndexError: index 10 out of bounds (length 5, 6 past end)"
        """
        match self:
            case OutOfBounds(i, l):
                val dist = self.distance_from_end()
                if dist > 0:
                    "IndexError: index {i} out of bounds (length {l}, {dist} past end)"
                else:
                    "IndexError: index {i} out of bounds (length {l})"

impl Display for IndexError:
    fn fmt() -> str:
        self.message()

# Implement Error trait for IndexError
# (Parser now supports empty impl blocks as of 2026-01-18, but this trait has required methods)
impl Error for IndexError:
    fn message() -> str:
        match self:
            case OutOfBounds(idx, len):
                if len == 0:
                    "IndexError: index {idx} out of bounds (empty collection)"
                elif idx >= len:
                    val dist = idx - len + 1
                    "IndexError: index {idx} out of bounds (length {len}, {dist} past end)"
                else:
                    "IndexError: index {idx} out of bounds (length {len})"

# ============================================
# Iterable - Base iteration trait
# ============================================

trait Iterable<T>:
    # Associated type for the iterator
    type Iter: Iterator

    # Note: iter() is deprecated - use each() instead for cleaner iteration
    fn iter() -> Self.Iter

    fn into_iter() -> Self.Iter

    # Ruby-style iteration - preferred over iter()
    fn each(f: fn(T))

    fn each_with_index(f: fn(usize, T))

# ============================================
# Collection - Sized container with containment check
# ============================================

# Collection inherits from Iterable and Len
trait Collection<T>: Iterable<T> + Len:
    fn contains(item: &T) -> bool where T: Eq

    fn count_matching(predicate: fn(&T) -> bool) -> usize

# ============================================
# Sequence - Indexed read access
# ============================================

# Note: trait inheritance with generics (trait A<T>: B<T>) not yet supported
# trait Sequence<T>: Collection<T>:  # ERROR
trait Sequence<T>:  # Should inherit: Collection<T>
    # Safe indexed access - returns None if out of bounds
    fn get(idx: usize) -> Option<T>

    # First element
    fn first() -> Option<T>
    # Last element
    fn last() -> Option<T>
    # Find first element matching predicate
    fn find(predicate: fn(&T) -> bool) -> Option<T>
    # Find index of first matching element
    fn find_index(predicate: fn(&T) -> bool) -> Option<usize>
    # Find position of item (alias for find_index with equality)
    fn position(item: &T) -> Option<usize> where T: Eq
    # Get slice of range
    fn slice(start: usize, end: usize) -> Slice<T>

    # Get slice from start to end
    fn slice_from(start: usize) -> Slice<T>
    # Get slice from 0 to end
    fn slice_to(end: usize) -> Slice<T>
    # Iterate with index
    fn enumerate() -> Enumerate<Self.Iter>
    # Check if all elements match predicate
    fn all(predicate: fn(&T) -> bool) -> bool
    # Check if any element matches predicate
    fn any(predicate: fn(&T) -> bool) -> bool
    # Fold/reduce from left
    fn fold<U>(self, init: U, f: fn(U, T) -> U) -> U
    # Sum elements (requires Add with Output=T and Default)
    fn sum() -> T where T: Add<Output=T> + Default
    # Product of elements (requires Mul with Output=T and Default)
    fn product() -> T where T: Mul<Output=T> + Default
    # Maximum element
    fn max() -> Option<T> where T: Ord
    # Minimum element
    fn min() -> Option<T> where T: Ord
    # ============================================
    # Statistics Methods
    # ============================================

    # Arithmetic mean (average)
    fn mean() -> f32 where T: Add + Default
    # Population variance
    fn variance() -> f32 where T: Add + Default
    # Sample variance (Bessel's correction)
    fn sample_variance() -> f32 where T: Add + Default
    # Population standard deviation
    fn std() -> f32 where T: Add + Default
    # Sample standard deviation
    fn sample_std() -> f32 where T: Add + Default
    # Median
    fn median() -> f32 where T: Ord + Clone
    # Quantile (0.0 to 1.0)
    fn quantile(p: f32) -> f32 where T: Ord + Clone
    # Range (max - min)
    fn range() -> f32 where T: Ord
    # Interquartile range
    fn iqr() -> f32 where T: Ord + Clone
# ============================================
# MutSequence - Mutable indexed access
# ============================================

# Note: trait inheritance with generics (trait A<T>: B<T>) not yet supported
# trait MutSequence<T>: Sequence<T>:  # ERROR
trait MutSequence<T>:  # Should inherit: Sequence<T>
    # Mutable reference access
    fn get_mut(idx: usize) -> Option<&mut T>

    # Set value at index, returns error if out of bounds
    fn set(idx: usize, value: T) -> Result<(), IndexError>

    # Swap two elements
    fn swap(i: usize, j: usize) -> Result<(), IndexError>
    # Fill all elements with value
    fn fill(value: T) where T: Clone
    # Fill with values from function
    fn fill_with(f: fn(usize) -> T)
    # In-place sort (requires Ord)
    fn sort() where T: Ord
    fn sort_with(algo: SortAlgorithm) where T: Ord
    # In-place reverse
    fn reverse()
    # Retain only elements matching predicate
    fn retain(predicate: fn(&T) -> bool)

    # Get mutable slice
    fn as_mut_slice() -> MutSlice<T>

# ============================================
# ImmutSequence - Functional update operations (return new)
# ============================================

# Note: trait inheritance with generics (trait A<T>: B<T>) not yet supported
# trait ImmutSequence<T>: Sequence<T>:  # ERROR
trait ImmutSequence<T>:  # Should inherit: Sequence<T>
    type Output: Sequence<T>

    # Return new sequence with updated index
    fn with_index(idx: usize, value: T) -> Option<Self.Output>

    # Return new sorted sequence
    fn sorted() -> Self.Output where T: Ord

    # Return new reversed sequence
    fn reversed() -> Self.Output

    # Return new filtered sequence (elements matching predicate)
    fn filtered(predicate: fn(&T) -> bool) -> Self.Output

    # Return new mapped sequence
    fn mapped<U>(self, f: fn(T) -> U) -> Self.Output

    # Return new sequence with element appended
    fn appended(item: T) -> Self.Output

    # Return new sequence with element prepended
    fn prepended(item: T) -> Self.Output

    # Take first n elements
    fn taken(n: usize) -> Self.Output

    # Drop first n elements
    fn dropped(n: usize) -> Self.Output

    # Take while predicate is true
    fn taken_while(predicate: fn(&T) -> bool) -> Self.Output

    # Drop while predicate is true
    fn dropped_while(predicate: fn(&T) -> bool) -> Self.Output

# ============================================
# Growable - Can add/remove elements dynamically
# ============================================

# Note: trait inheritance with generics (trait A<T>: B<T>) not yet supported
# trait Growable<T>: MutSequence<T>:  # ERROR
trait Growable<T>:  # Should inherit: MutSequence<T>
    # Add element to end
    fn push(item: T)

    # Remove and return last element
    fn pop() -> Option<T>

    # Add element to front
    fn push_front(item: T)

    # Remove and return first element
    fn pop_front() -> Option<T>

    # Insert element at index
    fn insert(idx: usize, item: T) -> Result<(), IndexError>

    # Remove element at index
    fn remove(idx: usize) -> Option<T>

    # Remove all elements
    fn clear()

    # Extend with elements from iterator
    fn extend<I: IntoIterator<Item=T>>(self, iter: I)
    # Append all elements from another collection
    fn append<C: Sequence<T>>(self, other: C) where T: Clone
    # Truncate to length
    fn truncate(len: usize)
    # Resize to length, filling with value if needed
    fn resize(new_len: usize, value: T) where T: Clone
# ============================================
# Sliceable - Can create slice views
# ============================================

trait Sliceable<T>:
    fn as_slice() -> Slice<T>

# ============================================
# MutSliceable - Can create mutable slice views
# ============================================

# Note: trait inheritance with generics (trait A<T>: B<T>) not yet supported
# trait MutSliceable<T>: Sliceable<T>:  # ERROR
trait MutSliceable<T>:  # Should inherit: Sliceable<T>
    fn as_mut_slice() -> MutSlice<T>

# ============================================
# Enumerate Iterator Wrapper
# ============================================

struct Enumerate<I>:
    iter: I
    index: usize

impl Enumerate<I>:
    fn new(iter: I) -> Enumerate<I>:
        Enumerate { iter: iter, index: 0 }

impl Iterator for Enumerate<I> where I: Iterator:
    type Item = (usize, I.Item)

    fn next() -> Option<Self.Item>:
        match self.iter.next():
            case Some(item):
                val idx = self.index
                self.index = self.index + 1
                Some((idx, item))
            case None:
                None

# ============================================
# Slice Type - Borrowed view into a sequence
# ============================================

struct Slice<T>:
    ptr: *T
    len: usize

impl Slice<T>:
    @pure
    fn new(ptr: *T, len: usize) -> Slice<T>:
        Slice { ptr: ptr, len: len }

    @pure
    fn empty() -> Slice<T>:
        Slice { ptr: nil, len: 0 }

impl Len for Slice<T>:
    fn len() -> usize:
        self.len

impl Iterable<T> for Slice<T>:
    type Iter = SliceIter<T>

    fn iter() -> Self.Iter:
        SliceIter { slice: self, index: 0 }

    fn into_iter() -> Self.Iter:
        self.iter()


impl Sequence<T> for Slice<T>:
    fn get(idx: usize) -> Option<T>:
        if idx < self.len:
            danger:
                Some(self.ptr.offset(idx as isize).read())
        else:
            None

    fn slice(start: usize, end: usize) -> Slice<T>:
        if start > end or end > self.len:
            Slice.empty()
        else:
            danger:
                Slice.new(self.ptr.offset(start as isize), end - start)

impl Sliceable<T> for Slice<T>:
    fn as_slice() -> Slice<T>:
        self

# Slice iterator
struct SliceIter<T>:
    slice: Slice<T>
    index: usize

impl Iterator for SliceIter<T>:
    type Item = T

    fn next() -> Option<Self.Item>:
        if self.index < self.slice.len:
            val item = self.slice.get(self.index).expect("valid index")
            self.index = self.index + 1
            Some(item)
        else:
            None

impl ExactSizeIterator for SliceIter<T>:
    fn len() -> usize:
        self.slice.len - self.index

# ============================================
# MutSlice Type - Mutable borrowed view
# ============================================

struct MutSlice<T>:
    ptr: *mut T
    len: usize

impl MutSlice<T>:
    @pure
    fn new(ptr: *mut T, len: usize) -> MutSlice<T>:
        MutSlice { ptr: ptr, len: len }

impl Len for MutSlice<T>:
    fn len() -> usize:
        self.len

impl Iterable<T> for MutSlice<T>:
    type Iter = MutSliceIter<T>

    fn iter() -> Self.Iter:
        MutSliceIter { slice: self, index: 0 }

    fn into_iter() -> Self.Iter:
        self.iter()


impl Sequence<T> for MutSlice<T>:
    fn get(idx: usize) -> Option<T>:
        if idx < self.len:
            danger:
                Some(self.ptr.offset(idx as isize).read())
        else:
            None

    fn slice(start: usize, end: usize) -> Slice<T>:
        if start > end or end > self.len:
            Slice.empty()
        else:
            danger:
                Slice.new(self.ptr.offset(start as isize) as *T, end - start)

impl MutSequence<T> for MutSlice<T>:
    fn get_mut(idx: usize) -> Option<&mut T>:
        if idx < self.len:
            danger:
                Some(&mut *self.ptr.offset(idx as isize))
        else:
            None

    fn set(idx: usize, value: T) -> Result<(), IndexError>:
        if idx >= self.len:
            return Err(IndexError.OutOfBounds(idx, self.len))
        danger:
            self.ptr.offset(idx as isize).write(value)
        Ok(())

    fn sort() where T: Ord:
        sort_default(self)

    fn sort_with(algo: SortAlgorithm) where T: Ord:
        sort_with_algorithm(self, algo)

    fn retain(predicate: fn(&T) -> bool):
        # MutSlice cannot change size, this is a no-op placeholder
        ()

    fn as_mut_slice() -> MutSlice<T>:
        self

impl Sliceable<T> for MutSlice<T>:
    fn as_slice() -> Slice<T>:
        danger:
            Slice.new(self.ptr as *T, self.len)

impl MutSliceable<T> for MutSlice<T>:
    fn as_mut_slice() -> MutSlice<T>:
        self

# MutSlice iterator
struct MutSliceIter<T>:
    slice: MutSlice<T>
    index: usize

impl Iterator for MutSliceIter<T>:
    type Item = T

    fn next() -> Option<Self.Item>:
        if self.index < self.slice.len:
            val item = self.slice.get(self.index).expect("valid index")
            self.index = self.index + 1
            Some(item)
        else:
            None
