# List<T> - Dynamic growable sequence
# Syntax: [] creates a List
# Implements all collection traits including Growable

use core.traits.*
use core.collections.*
use core.sorting.*

# ============================================
# List Type Definition
# ============================================

struct List<T>:
    data: *T
    len: usize
    cap: usize

# ============================================
# Constructors
# ============================================

impl List<T>:
    # Create empty list
    static fn new() -> List<T>:
        List { data: nil, len: 0, cap: 0 }

    # Create with pre-allocated capacity
    static fn with_capacity(cap: usize) -> List<T>:
        if cap == 0:
            return List::new()
        val data = alloc<T>(cap)
        List { data: data, len: 0, cap: cap }

    # Create from variadic arguments
    static fn of(items: T...) -> List<T>:
        var list = List::with_capacity(items.len())
        for item in items:
            list.push(item)
        return list

    # Create filled with value
    static fn filled(value: T, count: usize) -> List<T> where T: Clone:
        var list = List::with_capacity(count)
        for _ in 0..count:
            list.push(value.clone())
        return list

    # Create filled with function
    static fn filled_with(f: fn(usize) -> T, count: usize) -> List<T>:
        var list = List::with_capacity(count)
        for i in 0..count:
            list.push(f(i))
        return list

    # Create from iterator
    static fn from_iter<I: Iterator<Item=T>>(iter: I) -> List<T>:
        var list = List::new()
        for item in iter:
            list.push(item)
        return list

    # Create from slice - Slice<T> parameter type now supported
    static fn from_slice(slice: Slice<T>) -> List<T> where T: Clone:
        var list = List::with_capacity(slice.len())
        for item in slice:
            list.push(item.clone())
        return list

# ============================================
# Internal helpers
# ============================================

impl List<T>:
    # Ensure capacity for at least `additional` more elements
    fn reserve(additional: usize):
        val required = self.len + additional
        if required <= self.cap:
            return

        # Grow by doubling or to required, whichever is larger
        var new_cap = if self.cap == 0: 4 else: self.cap * 2
        while new_cap < required:
            new_cap = new_cap * 2

        val new_data = alloc<T>(new_cap)
        if self.data != nil:
            danger:
                copy_mem(new_data, self.data, self.len)
                dealloc(self.data)
        self.data = new_data
        self.cap = new_cap

    fn shrink_to_fit():
        if self.len == self.cap:
            return
        if self.len == 0:
            if self.data != nil:
                danger:
                    dealloc(self.data)
            self.data = nil
            self.cap = 0
            return

        val new_data = alloc<T>(self.len)
        danger:
            copy_mem(new_data, self.data, self.len)
            dealloc(self.data)
        self.data = new_data
        self.cap = self.len

# ============================================
# Capacity trait
# ============================================

impl Capacity for List<T>:
    fn capacity() -> usize:
        self.cap

    fn is_full() -> bool:
        false  # List can always grow

# ============================================
# Len trait
# ============================================

impl Len for List<T>:
    fn len() -> usize:
        self.len

# ============================================
# Iterable trait
# ============================================

impl Iterable<T> for List<T>:
    type Iter = ListIter<T>

    @deprecated("Use each() instead")
    fn iter() -> Self::Iter:
        ListIter { list: self, index: 0 }

    fn into_iter() -> Self::Iter:
        ListIter { list: self, index: 0 }

    fn each(f: fn(T)):
        """Execute closure for each element.

        Args:
            f: Closure to execute with each element

        Example:
            list.each(|x| print(x))
        """
        for item in self.into_iter():
            f(item)

    fn each_with_index(f: fn(usize, T)):
        """Execute closure for each element with its index.

        Args:
            f: Closure to execute with index and element

        Example:
            list.each_with_index(|i, x| print("{i}: {x}"))
        """
        var idx: usize = 0
        for item in self.into_iter():
            f(idx, item)
            idx = idx + 1

# ============================================
# Collection trait - implemented via Sequence
# ============================================
# Note: List<T> implements Collection<T> automatically through
# its Sequence<T> implementation. No explicit impl needed.

# ============================================
# Sequence trait
# ============================================

impl Sequence<T> for List<T>:
    fn get(idx: usize) -> Option<T>:
        if idx < self.len:
            danger:
                Some(self.data.offset(idx as isize).read())
        else:
            None

    fn slice(start: usize, end: usize) -> Slice<T>:
        if start > end or end > self.len:
            Slice::empty()
        else:
            danger:
                Slice::new(self.data.offset(start as isize), end - start)

# ============================================
# MutSequence trait
# ============================================

impl MutSequence<T> for List<T>:
    fn get_mut(idx: usize) -> Option<&mut T>:
        if idx < self.len:
            danger:
                Some(&mut *self.data.offset(idx as isize))
        else:
            None

    fn set(idx: usize, value: T) -> Result<(), IndexError>:
        if idx >= self.len:
            return Err(IndexError::OutOfBounds(idx, self.len))
        danger:
            self.data.offset(idx as isize).write(value)
        Ok(())

    fn sort() where T: Ord:
        """Sort list using default algorithm (PDQSort)."""
        sort_default(self.as_mut_slice())

    fn sort_with(algo: SortAlgorithm) where T: Ord:
        """Sort list using specified algorithm.

        Args:
            algo: Sorting algorithm to use

        Example:
            list.sort_with(SortAlgorithm::TimSort)
        """
        sort_with_algorithm(self.as_mut_slice(), algo)

    fn retain(predicate: fn(&T) -> bool):
        var write: usize = 0
        for read in 0..self.len:
            val item = self.get(read).expect("valid")
            if predicate(&item):
                if write != read:
                    self.set(write, item).expect("valid")
                write = write + 1
        self.len = write

    fn as_mut_slice() -> MutSlice<T>:
        MutSlice::new(self.data, self.len)

# ============================================
# ImmutSequence trait
# ============================================

impl ImmutSequence<T> for List<T> where T: Clone:
    type Output = List<T>

    fn with_index(idx: usize, value: T) -> Option<Self::Output>:
        if idx >= self.len:
            return None
        var new_list = self.clone()
        new_list.set(idx, value).expect("valid")
        Some(new_list)

    fn sorted() -> Self::Output where T: Ord:
        var new_list = self.clone()
        new_list.sort()
        new_list

    fn reversed() -> Self::Output:
        var new_list = self.clone()
        new_list.reverse()
        new_list

    fn filtered(predicate: fn(&T) -> bool) -> Self::Output:
        var new_list = List::new()
        for item in self.iter():
            if predicate(&item):
                new_list.push(item.clone())
        new_list

    fn mapped<U>(self, f: fn(T) -> U) -> List<U>:
        var new_list = List::with_capacity(self.len)
        for item in self.iter():
            new_list.push(f(item.clone()))
        new_list

    fn appended(item: T) -> Self::Output:
        var new_list = self.clone()
        new_list.push(item)
        new_list

    fn prepended(item: T) -> Self::Output:
        var new_list = self.clone()
        new_list.push_front(item)
        new_list

    fn taken(n: usize) -> Self::Output:
        var new_list = List::new()
        for (i, item) in self.enumerate():
            if i >= n:
                break
            new_list.push(item.clone())
        new_list

    fn dropped(n: usize) -> Self::Output:
        var new_list = List::new()
        for (i, item) in self.enumerate():
            if i >= n:
                new_list.push(item.clone())
        new_list

    fn taken_while(predicate: fn(&T) -> bool) -> Self::Output:
        var new_list = List::new()
        for item in self.iter():
            if not predicate(&item):
                break
            new_list.push(item.clone())
        new_list

    fn dropped_while(predicate: fn(&T) -> bool) -> Self::Output:
        var new_list = List::new()
        var dropping = true
        for item in self.iter():
            if dropping and predicate(&item):
                continue
            dropping = false
            new_list.push(item.clone())
        new_list

# ============================================
# Growable trait
# ============================================

impl Growable<T> for List<T>:
    fn push(item: T):
        self.reserve(1)
        danger:
            self.data.offset(self.len as isize).write(item)
        self.len = self.len + 1

    fn pop() -> Option<T>:
        if self.len == 0:
            return None
        self.len = self.len - 1
        danger:
            Some(self.data.offset(self.len as isize).read())

    fn push_front(item: T):
        self.reserve(1)
        # Shift all elements right
        if self.len > 0:
            danger:
                var i = self.len
                while i > 0:
                    val src = self.data.offset((i - 1) as isize)
                    val dst = self.data.offset(i as isize)
                    dst.write(src.read())
                    i = i - 1
        danger:
            self.data.write(item)
        self.len = self.len + 1

    fn pop_front() -> Option<T>:
        if self.len == 0:
            return None
        danger:
            val item = self.data.read()
            # Shift all elements left
            for i in 0..(self.len - 1):
                val src = self.data.offset((i + 1) as isize)
                val dst = self.data.offset(i as isize)
                dst.write(src.read())
            self.len = self.len - 1
            Some(item)

    fn insert(idx: usize, item: T) -> Result<(), IndexError>:
        if idx > self.len:
            return Err(IndexError::OutOfBounds(idx, self.len))
        self.reserve(1)
        # Shift elements right from idx
        danger:
            var i = self.len
            while i > idx:
                val src = self.data.offset((i - 1) as isize)
                val dst = self.data.offset(i as isize)
                dst.write(src.read())
                i = i - 1
            self.data.offset(idx as isize).write(item)
        self.len = self.len + 1
        Ok(())

    fn remove(idx: usize) -> Option<T>:
        if idx >= self.len:
            return None
        danger:
            val item = self.data.offset(idx as isize).read()
            # Shift elements left
            for i in idx..(self.len - 1):
                val src = self.data.offset((i + 1) as isize)
                val dst = self.data.offset(i as isize)
                dst.write(src.read())
            self.len = self.len - 1
            Some(item)

    fn clear():
        # Drop all elements if T has Drop
        self.len = 0

# ============================================
# Sliceable trait
# ============================================

impl Sliceable<T> for List<T>:
    fn as_slice() -> Slice<T>:
        Slice::new(self.data, self.len)

impl MutSliceable<T> for List<T>:
    fn as_mut_slice() -> MutSlice<T>:
        MutSlice::new(self.data, self.len)

# ============================================
# Standard trait implementations
# ============================================

impl Clone for List<T> where T: Clone:
    fn clone() -> Self:
        var new_list = List::with_capacity(self.len)
        for item in self.iter():
            new_list.push(item.clone())
        new_list

impl Default for List<T>:
    static fn default() -> Self:
        List::new()

impl Eq for List<T> where T: Eq:
    fn eq(other: &Self) -> bool:
        if self.len != other.len:
            return false
        for i in 0..self.len:
            val a = self.get(i).expect("valid")
            val b = other.get(i).expect("valid")
            if not a.eq(&b):
                return false
        true

impl Hash for List<T> where T: Hash:
    fn hash() -> u64:
        var h: u64 = 0
        for item in self.iter():
            h = h * 31 + item.hash()
        h

impl Display for List<T> where T: Display:
    fn fmt() -> str:
        var s = "["
        for (i, item) in self.enumerate():
            if i > 0:
                s = s + ", "
            s = s + item.fmt()
        s + "]"

impl Index<usize> for List<T>:
    type Output = T

    fn index(idx: usize) -> &Self::Output:
        if idx >= self.len:
            panic("index {idx} out of bounds (len={self.len})")
        danger:
            &*self.data.offset(idx as isize)

impl IndexMut<usize> for List<T>:
    fn index_mut(idx: usize) -> &mut Self::Output:
        if idx >= self.len:
            panic("index {idx} out of bounds (len={self.len})")
        danger:
            &mut *self.data.offset(idx as isize)

impl FromIterator<T> for List<T>:
    fn from_iter<I: Iterator<Item=T>>(iter: I) -> Self:
        List::from_iter(iter)

impl IntoIterator for List<T>:
    type Item = T
    type IntoIter = ListIter<T>
    fn into_iter() -> Self::IntoIter:
        self.iter()

impl Drop for List<T>:
    fn drop():
        if self.data != nil:
            danger:
                dealloc(self.data)

# ============================================
# List Iterator
# ============================================

struct ListIter<T>:
    list: List<T>
    index: usize

impl Iterator for ListIter<T>:
    type Item = T

    fn next() -> Option<Self::Item>:
        if self.index < self.list.len:
            val item = self.list.get(self.index).expect("valid")
            self.index = self.index + 1
            Some(item)
        else:
            None

impl ExactSizeIterator for ListIter<T>:
    fn len() -> usize:
        self.list.len - self.index

impl DoubleEndedIterator for ListIter<T>:
    fn next_back() -> Option<Self::Item>:
        if self.index < self.list.len:
            val idx = self.list.len - 1
            val item = self.list.get(idx).expect("valid")
            # Shrink effective length (can't modify list, but we track via index math)
            Some(item)
        else:
            None

# ============================================
# Convenience methods (Ruby/Python inspired)
# ============================================

impl List<T>:
    # Ruby-style select (alias for filtered)
    fn select(predicate: fn(&T) -> bool) -> List<T> where T: Clone:
        self.filtered(predicate)

    # Ruby-style reject (opposite of filter)
    fn reject(predicate: fn(&T) -> bool) -> List<T> where T: Clone:
        self.filtered(|x| not predicate(x))

    # Ruby-style partition
    fn partition(predicate: fn(&T) -> bool) -> (List<T>, List<T>) where T: Clone:
        var yes = List::new()
        var no = List::new()
        for item in self.iter():
            if predicate(&item):
                yes.push(item.clone())
            else:
                no.push(item.clone())
        (yes, no)

    # Note: compact() is implemented in a separate impl block for List<Option<T>>
    # See the "Methods for Option Lists" section below

    # Ruby-style flatten (one level)
    fn flatten<U>(self) -> List<U> where T: Iterable<U>, U: Clone:
        var result = List::new()
        for inner in self.iter():
            for item in inner.iter():
                result.push(item.clone())
        result

    # Python-style chunks
    fn chunks(size: usize) -> List<List<T>> where T: Clone:
        var result = List::new()
        var chunk = List::new()
        for item in self.iter():
            chunk.push(item.clone())
            if chunk.len() == size:
                result.push(chunk)
                chunk = List::new()
        if not chunk.is_empty():
            result.push(chunk)
        result

    # Sliding windows
    fn windows(size: usize) -> List<List<T>> where T: Clone:
        if size == 0 or size > self.len:
            return List::new()
        var result = List::new()
        for i in 0..(self.len - size + 1):
            var window = List::new()
            for j in 0..size:
                window.push(self.get(i + j).expect("valid").clone())
            result.push(window)
        result

    # Dedup consecutive duplicates
    fn dedup() where T: Eq:
        if self.len < 2:
            return
        var write: usize = 1
        for read in 1..self.len:
            val curr = self.get(read).expect("valid")
            val prev = self.get(write - 1).expect("valid")
            if not curr.eq(&prev):
                if write != read:
                    self.set(write, curr).expect("valid")
                write = write + 1
        self.len = write

    # Join elements into string
    fn join(sep: str) -> text where T: Display:
        var s = text::new()
        for (i, item) in self.enumerate():
            if i > 0:
                s.push_str(sep)
            s.push_str(item.fmt())
        s

    # Map with index
    fn map_with_index<U>(self, f: fn(usize, T) -> U) -> List<U> where T: Clone:
        var result = List::with_capacity(self.len)
        for (i, item) in self.enumerate():
            result.push(f(i, item.clone()))
        result

    # Ruby-style tap (execute function, return self)
    fn tap(f: fn(&List<T>)) -> List<T>:
        f(&self)
        self

    # Ruby-style then (transform self)
    fn then<U>(self, f: fn(List<T>) -> U) -> U:
        f(self)

# ============================================
# Methods for Option Lists
# ============================================

impl<T> List<Option<T>>:
    # Methods specifically for lists of optional values

    fn compact() -> List<T>:
        """Remove None values and unwrap Some values.

        Returns:
            New list containing only the unwrapped Some values

        Example:
            val items = [Some(1), None, Some(2), None, Some(3)]
            val compacted = items.compact()
            # Result: [1, 2, 3]
        """
        var result: List<T> = List::new()
        for item in self.iter():
            match item:
                case Some(v):
                    result.push(v)
                case None:
                    pass  # Skip None values
        return result

# ============================================
# Type aliases
# ============================================

# Common list sizes (for documentation, lists are always dynamic)
type IntList = List<i64>
type FloatList = List<f64>
type StringList = List<text>
