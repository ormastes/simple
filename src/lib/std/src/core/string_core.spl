# text Core - Type definition and constructors
use core.traits.*
use core.collections.*

use core.traits.*
use core.collections.*

# ============================================
# text Type Definition
# ============================================

struct text:
    data: *u8
    len: usize       # Byte length
    cap: usize

# ============================================
# text Error Types
# ============================================

enum Utf8Error:
    InvalidByte(position: usize, byte: u8)
    UnexpectedEnd

impl Display for Utf8Error:
    fn fmt() -> str:
        match self:
            case InvalidByte(pos, b): "invalid UTF-8 byte {b} at position {pos}"
            case UnexpectedEnd: "unexpected end of UTF-8 sequence"

impl Utf8Error:
    # =========================================================================
    # Helper Methods
    # =========================================================================

    @pure
    pub fn to_string(self) -> text:
        """Convert error to string.

        Returns:
            Error name
        """
        match self:
            case InvalidByte(_, _): "InvalidByte"
            case UnexpectedEnd: "UnexpectedEnd"

    @pure
    pub fn description(self) -> text:
        """Get detailed error description.

        Returns:
            Human-readable description
        """
        match self:
            case InvalidByte(pos, byte): "Invalid UTF-8 byte 0x{byte:02X} at position {pos}"
            case UnexpectedEnd: "Unexpected end of UTF-8 sequence"

    @pure
    pub fn is_invalid_byte(self) -> bool:
        """Check if this is an InvalidByte error.

        Returns:
            True for InvalidByte variant
        """
        match self:
            case InvalidByte(_, _): true
            case _: false

    @pure
    pub fn is_unexpected_end(self) -> bool:
        """Check if this is an UnexpectedEnd error.

        Returns:
            True for UnexpectedEnd variant
        """
        match self:
            case UnexpectedEnd: true
            case _: false

    @pure
    pub fn get_position(self) -> Option<usize>:
        """Get error position if available.

        Returns:
            Position for InvalidByte, None otherwise
        """
        match self:
            case InvalidByte(pos, _): Some(pos)
            case _: nil

    @pure
    pub fn get_byte(self) -> Option<u8>:
        """Get invalid byte if available.

        Returns:
            Byte value for InvalidByte, None otherwise
        """
        match self:
            case InvalidByte(_, byte): Some(byte)
            case _: nil

    @pure
    pub fn summary(self) -> text:
        """Get summary of UTF-8 error.

        Returns:
            Human-readable summary

        Example:
            Utf8Error.InvalidByte(5, 0xFF).summary()
            # â†’ "Utf8Error: InvalidByte at position 5 (byte 0xFF)"
        """
        match self:
            case InvalidByte(pos, byte):
                "Utf8Error: InvalidByte at position {pos} (byte 0x{byte:02X})"
            case UnexpectedEnd:
                "Utf8Error: UnexpectedEnd (truncated sequence)"

impl Error for Utf8Error:

# ============================================
# Constructors
# ============================================

impl text:
    # Create empty string
    @pure
    static fn new() -> text:
        text { data: nil, len: 0, cap: 0 }

    # Create with pre-allocated capacity
    @pure
    fn with_capacity(cap: usize) -> text:
        if cap == 0:
            return text.new()
        val data = alloc[u8](cap)
        text { data: data, len: 0, cap: cap }

    # Create from string literal (already UTF-8)
    @pure
    fn from(s: &str) -> text:
        if s.len() == 0:
            return text.new()
        val len = s.len()
        val data = alloc[u8](len)
        danger:
            copy_mem(data, s.as_ptr(), len)
        text { data: data, len: len, cap: len }

    # Create from UTF-8 bytes (may fail)
    @pure
    fn from_utf8(bytes: Slice<u8>) -> Result<text, Utf8Error>:
        # Validate UTF-8
        var i: usize = 0
        while i < bytes.len():
            val b = bytes.get(i).expect("valid")
            if b < 0x80:
                # ASCII
                i = i + 1
            else if b < 0xC0:
                return Err(Utf8Error.InvalidByte(i, b))
            else if b < 0xE0:
                # 2-byte sequence
                if i + 1 >= bytes.len():
                    return Err(Utf8Error.UnexpectedEnd)
                i = i + 2
            else if b < 0xF0:
                # 3-byte sequence
                if i + 2 >= bytes.len():
                    return Err(Utf8Error.UnexpectedEnd)
                i = i + 3
            else if b < 0xF8:
                # 4-byte sequence
                if i + 3 >= bytes.len():
                    return Err(Utf8Error.UnexpectedEnd)
                i = i + 4
            else:
                return Err(Utf8Error.InvalidByte(i, b))

        # Valid UTF-8, copy bytes
        val data = alloc[u8](bytes.len())
        danger:
            for j in 0..bytes.len():
                data.offset(j as isize).write(bytes.get(j).expect("valid"))
        Ok(text { data: data, len: bytes.len(), cap: bytes.len() })

    # Create from UTF-8 bytes, replacing invalid sequences
    @pure
    fn from_utf8_lossy(bytes: Slice<u8>) -> text:
        match text.from_utf8(bytes):
            case Ok(s): s
            case Err(_):
                # Fallback: copy valid ASCII, replace invalid with ?
                var result = text.with_capacity(bytes.len())
                for i in 0..bytes.len():
                    val b = bytes.get(i).expect("valid")
                    if b < 0x80:
                        result.push_byte(b)
                    else:
                        result.push_byte('?' as u8)
                result

    # Create filled with character
    @pure
    fn filled(c: char, count: usize) -> text:
        var s = text.with_capacity(count * 4)  # Max 4 bytes per char
        for _ in 0..count:
            s.push(c)
        s

