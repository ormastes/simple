# JSON - JSON parsing and serialization
# Simple JSON support for data interchange

# JSON value type
pub enum JsonValue:
    Null
    bool(bool)
    Number(f64)
    Integer(i64)
    text(text)
    Array(List<JsonValue>)
    Object(Dict<text, JsonValue>)

impl JsonValue:
    # =========================================================================
    # Helper Methods
    # =========================================================================

    pub fn to_string() -> text:
        """Convert JSON value type to string."""
        match self:
            case Null: return "Null"
            case bool(_): return "bool"
            case Number(_): return "Number"
            case Integer(_): return "Integer"
            case text(_): return "text"
            case Array(_): return "Array"
            case Object(_): return "Object"

    pub fn description() -> text:
        """Get detailed description of JSON value."""
        match self:
            case Null: return "Null value"
            case bool(b): return "Boolean: {b}"
            case Number(n): return "Number: {n}"
            case Integer(i): return "Integer: {i}"
            case text(s): return "text: \"{s}\""
            case Array(arr): return "Array with {arr.len()} items"
            case Object(obj): return "Object with {obj.len()} fields"

    pub fn is_null() -> bool:
        """Check if this is a Null value."""
        match self:
            case Null: true
            case _: false

    pub fn is_bool() -> bool:
        """Check if this is a Boolean value."""
        match self:
            case bool(_): true
            case _: false

    pub fn is_number() -> bool:
        """Check if this is a Number (f64) value."""
        match self:
            case Number(_): true
            case _: false

    pub fn is_integer() -> bool:
        """Check if this is an Integer (i64) value."""
        match self:
            case Integer(_): true
            case _: false

    pub fn is_string() -> bool:
        """Check if this is a text value."""
        match self:
            case text(_): true
            case _: false

    pub fn is_array() -> bool:
        """Check if this is an Array value."""
        match self:
            case Array(_): true
            case _: false

    pub fn is_object() -> bool:
        """Check if this is an Object value."""
        match self:
            case Object(_): true
            case _: false

    pub fn is_primitive() -> bool:
        """Check if this is a primitive value (not array or object)."""
        match self:
            case Array(_): false
            case Object(_): false
            case _: true

    pub fn is_collection() -> bool:
        """Check if this is a collection (array or object)."""
        match self:
            case Array(_): true
            case Object(_): true
            case _: false

    pub fn is_numeric() -> bool:
        """Check if this is a numeric value (number or integer)."""
        match self:
            case Number(_): true
            case Integer(_): true
            case _: false

    pub fn is_truthy() -> bool:
        """Check if value is truthy (non-null, non-false, non-zero, non-empty)."""
        match self:
            case Null: false
            case bool(b): b
            case Number(n): n != 0.0
            case Integer(i): i != 0
            case text(s): s.len() > 0
            case Array(arr): arr.len() > 0
            case Object(obj): obj.len() > 0

    pub fn summary() -> text:
        """Get summary of JSON value.

        Returns:
            Human-readable summary with type and value info

        Example:
            JsonValue::text("hello").summary()
            # → "JsonValue: text (text: \"hello\", primitive)"
        """
        val name = self.to_string()
        val desc = self.description()
        var props = []

        if self.is_primitive():
            props.push("primitive")
        elif self.is_collection():
            props.push("collection")

        if self.is_numeric():
            props.push("numeric")
        elif self.is_string():
            props.push("text")

        if props.len() > 0:
            val props_str = props.join(", ")
            "JsonValue: {name} ({desc}, {props_str})"
        else:
            "JsonValue: {name} ({desc})"

# Helper: check if a character is a digit
fn is_digit(ch: text) -> bool:
    if ch.len() == 0:
        return false
    val code = ch.ord()
    return code >= 48 and code <= 57  # '0' is 48, '9' is 57

# JSON Parser state
class JsonParser:
    input: text
    pos: i64
    len: i64

    fn new(input: text) -> JsonParser:
        return JsonParser { input: input, pos: 0, len: input.len() }

    fn peek() -> Option<text>:
        if self.pos >= self.len:
            return nil
        return Some(self.input.char_at(self.pos))

    fn advance() -> Option<text>:
        if self.pos >= self.len:
            return nil
        val ch = self.input.char_at(self.pos)
        self.pos = self.pos + 1
        return Some(ch)

    fn skip_whitespace():
        while self.pos < self.len:
            val ch = self.input.char_at(self.pos)
            if ch == " " or ch == "\t" or ch == "\n" or ch == "\r":
                self.pos = self.pos + 1
            else:
                break

    # =========================================================================
    # Helper Methods
    # =========================================================================

    fn is_at_end() -> bool:
        """Check if parser has reached end of input.

        Returns:
            true if no more characters to parse

        Example:
            val parser = JsonParser.new("{}")
            parser.is_at_end()  # → false
            parser.pos = parser.len
            parser.is_at_end()  # → true
        """
        return self.pos >= self.len

    fn remaining() -> i64:
        """Get number of remaining characters.

        Returns:
            Characters left to parse

        Example:
            val parser = JsonParser.new("hello")
            parser.remaining()  # → 5
            parser.advance()
            parser.remaining()  # → 4
        """
        return self.len - self.pos

    fn get_position() -> i64:
        """Get current position in input.

        Returns:
            Current character index

        Example:
            val parser = JsonParser.new("test")
            parser.get_position()  # → 0
            parser.advance()
            parser.get_position()  # → 1
        """
        return self.pos

    fn get_length() -> i64:
        """Get total input length.

        Returns:
            Total number of characters

        Example:
            val parser = JsonParser.new("hello")
            parser.get_length()  # → 5
        """
        return self.len

    fn reset():
        """Reset parser to beginning of input.

        Example:
            val parser = JsonParser.new("{}")
            parser.advance()
            parser.reset()
            parser.get_position()  # → 0
        """
        self.pos = 0

    fn summary() -> text:
        """Get summary of parser state.

        Returns:
            Human-readable summary

        Example:
            parser.summary()
            # → "JsonParser: pos=0/5, remaining=5"
        """
        val pos = self.pos
        val len = self.len
        val remaining = self.remaining()
        return "JsonParser: pos={pos}/{len}, remaining={remaining}"

    fn parse_value() -> Result<JsonValue, text>:
        self.skip_whitespace()

        val ch_opt = self.peek()
        if ch_opt.is_none():
            return Err("Unexpected end of input")

        val ch = ch_opt.unwrap()

        if ch == "\"":
            return self.parse_string()
        elif ch == '{':
            return self.parse_object()
        elif ch == "[":
            return self.parse_array()
        elif ch == "t":
            return self.parse_true()
        elif ch == "f":
            return self.parse_false()
        elif ch == "n":
            return self.parse_null()
        elif ch == "-" or is_digit(ch):
            return self.parse_number()
        else:
            return Err("Unexpected character: " + ch)

    fn parse_string() -> Result<JsonValue, text>:
        self.advance()  # Skip opening quote

        var result = ""
        while self.pos < self.len:
            val ch_opt = self.advance()
            val ch = ch_opt.unwrap()

            if ch == "\"":
                return Ok(JsonValue.text(result))
            elif ch == "\\":
                # Escape sequence
                if self.pos >= self.len:
                    return Err("Unexpected end of string")

                val esc_opt = self.advance()
                val esc = esc_opt.unwrap()
                if esc == "\"":
                    result = result + "\""
                elif esc == "\\":
                    result = result + "\\"
                elif esc == "/":
                    result = result + "/"
                elif esc == "n":
                    result = result + "\n"
                elif esc == "r":
                    result = result + "\r"
                elif esc == "t":
                    result = result + "\t"
                elif esc == "b":
                    # Backspace - use placeholder since \b not supported
                    result = result + ""
                elif esc == "f":
                    # Form feed - use placeholder since \f not supported
                    result = result + ""
                elif esc == "u":
                    # Unicode escape - skip 4 hex digits for now
                    for _ in 0..4:
                        if self.pos < self.len:
                            self.advance()
                    result = result + "?"  # Placeholder
                else:
                    result = result + esc
            else:
                result = result + ch

        return Err("Unterminated string")

    fn parse_object() -> Result<JsonValue, text>:
        self.advance()  # Skip {
        self.skip_whitespace()

        var obj = {}

        if self.peek() == Some('}'):
            self.advance()
            return Ok(JsonValue.Object(obj))

        while true:
            self.skip_whitespace()

            # Parse key
            if self.peek() != Some("\""):
                return Err("Expected string key in object")

            val key_result = self.parse_string()
            if key_result.is_err():
                return key_result

            val key = ""
            match key_result.unwrap():
                case JsonValue.text(s):
                    val key = s
                case _:
                    return Err("Key must be string")

            self.skip_whitespace()

            # Expect colon
            if self.peek() != Some(":"):
                return Err("Expected ':' after object key")
            self.advance()

            # Parse value
            val value_result = self.parse_value()
            if value_result.is_err():
                return value_result

            obj.set(key, value_result.unwrap())

            self.skip_whitespace()

            val ch_opt = self.peek()
            if ch_opt == Some('}'):
                self.advance()
                return Ok(JsonValue.Object(obj))
            elif ch_opt == Some(","):
                self.advance()
            else:
                return Err('Expected comma or closing brace in object')

    fn parse_array() -> Result<JsonValue, text>:
        self.advance()  # Skip [
        self.skip_whitespace()

        var arr = []

        if self.peek() == Some("]"):
            self.advance()
            return Ok(JsonValue.Array(arr))

        while true:
            val value_result = self.parse_value()
            if value_result.is_err():
                return value_result

            arr.append(value_result.unwrap())

            self.skip_whitespace()

            val ch_opt = self.peek()
            if ch_opt == Some("]"):
                self.advance()
                return Ok(JsonValue.Array(arr))
            elif ch_opt == Some(","):
                self.advance()
            else:
                return Err("Expected ',' or ']' in array")

    fn parse_true() -> Result<JsonValue, text>:
        if self.input.substring(self.pos, self.pos + 4) == "true":
            self.pos = self.pos + 4
            return Ok(JsonValue.bool(true))
        return Err("Expected 'true'")

    fn parse_false() -> Result<JsonValue, text>:
        if self.input.substring(self.pos, self.pos + 5) == "false":
            self.pos = self.pos + 5
            return Ok(JsonValue.bool(false))
        return Err("Expected 'false'")

    fn parse_null() -> Result<JsonValue, text>:
        if self.input.substring(self.pos, self.pos + 4) == "null":
            self.pos = self.pos + 4
            return Ok(JsonValue.Null)
        return Err("Expected 'null'")

    fn parse_number() -> Result<JsonValue, text>:
        val start = self.pos
        var has_dot = false
        var has_exp = false

        # Optional negative sign
        if self.peek() == Some("-"):
            self.advance()

        # Integer part
        while self.pos < self.len:
            val ch = self.input.char_at(self.pos)
            if is_digit(ch):
                self.advance()
            elif ch == "." and not has_dot:
                has_dot = true
                self.advance()
            elif (ch == "e" or ch == "E") and not has_exp:
                has_exp = true
                self.advance()
                # Optional sign after exponent
                if self.peek() == Some("+") or self.peek() == Some("-"):
                    self.advance()
            else:
                break

        val num_str = self.input.substring(start, self.pos)

        if has_dot or has_exp:
            # Parse as f32
            val value = parse_float(num_str)
            return Ok(JsonValue.Number(value))
        else:
            # Parse as integer
            val value = parse_int(num_str)
            return Ok(JsonValue.Integer(value))

# Helper function to parse integer
fn parse_int(s: text) -> i64:
    var result = 0
    val negative = false
    val start = 0

    if s.len() > 0 and s.char_at(0) == "-":
        val negative = true
        val start = 1

    for i in start..s.len():
        val ch = s.char_at(i)
        if is_digit(ch):
            val digit = ch.ord() - 48  # 48 is ord('0')
            result = result * 10 + digit

    if negative:
        return -result
    return result

# Helper function to parse f32
fn parse_float(s: text) -> f64:
    var result = 0.0
    val negative = false
    val pos = 0

    # Check for negative sign
    if s.len() > 0 and s.char_at(0) == "-":
        val negative = true
        val pos = 1

    # Parse integer part
    val int_part = 0.0
    while pos < s.len():
        val ch = s.char_at(pos)
        if is_digit(ch):
            val digit = (ch.ord() - 48) as f64
            val int_part = int_part * 10.0 + digit
            val pos = pos + 1
        else:
            break

    val result = int_part

    # Parse decimal part if present
    if pos < s.len() and s.char_at(pos) == ".":
        val pos = pos + 1
        val decimal_part = 0.0
        val decimal_places = 0.0

        while pos < s.len():
            val ch = s.char_at(pos)
            if is_digit(ch):
                val digit = (ch.ord() - 48) as f64
                val decimal_part = decimal_part * 10.0 + digit
                val decimal_places = decimal_places + 1.0
                val pos = pos + 1
            else:
                break

        if decimal_places > 0.0:
            val divisor = 1.0
            for _ in 0..(decimal_places as i64):
                val divisor = divisor * 10.0
            result = result + (decimal_part / divisor)

    # Parse exponent if present
    if pos < s.len():
        val ch = s.char_at(pos)
        if ch == "e" or ch == "E":
            val pos = pos + 1
            val exp_negative = false

            if pos < s.len():
                val sign_ch = s.char_at(pos)
                if sign_ch == "-":
                    val exp_negative = true
                    val pos = pos + 1
                elif sign_ch == "+":
                    val pos = pos + 1

            val exponent = 0
            while pos < s.len():
                val ch = s.char_at(pos)
                if is_digit(ch):
                    val digit = ch.ord() - 48
                    val exponent = exponent * 10 + digit
                    val pos = pos + 1
                else:
                    break

            # Apply exponent
            if exponent > 0:
                val multiplier = 1.0
                for _ in 0..exponent:
                    val multiplier = multiplier * 10.0

                if exp_negative:
                    result = result / multiplier
                else:
                    result = result * multiplier

    if negative:
        return -result
    return result

# Parse JSON string into a value
pub fn parse(input: text) -> Result<JsonValue, text>:
    val parser = JsonParser.new(input)
    return parser.parse_value()

# Escape string for JSON output
fn escape_string(s: text) -> text:
    var result = ""
    for i in 0..s.len():
        val ch = s.char_at(i)
        if ch == "\"":
            result = result + "\\\""
        elif ch == "\\":
            result = result + "\\\\"
        elif ch == "\n":
            result = result + "\\n"
        elif ch == "\r":
            result = result + "\\r"
        elif ch == "\t":
            result = result + "\\t"
        else:
            result = result + ch
    return result

# Serialize JSON value to string
pub fn stringify(value: JsonValue) -> text:
    match value:
        case JsonValue.Null:
            return "null"
        case JsonValue.bool(b):
            if b:
                return "true"
            else:
                return "false"
        case JsonValue.Number(n):
            return n.to_string()
        case JsonValue.Integer(i):
            return i.to_string()
        case JsonValue.text(s):
            return "\"" + escape_string(s) + "\""
        case JsonValue.Array(arr):
            var parts = []
            for item in arr:
                parts.append(stringify(item))
            return "[" + parts.join(", ") + "]"
        case JsonValue.Object(obj):
            var parts = []
            for key in obj.keys():
                val value = obj.get(key)
                parts.append("\"" + escape_string(key) + "\": " + stringify(value))
            return '{' + parts.join(", ") + '}'

# Pretty print JSON with indentation
pub fn stringify_pretty(value: JsonValue, indent: i64) -> text:
    return stringify_indent(value, indent=indent, level=0)

fn stringify_indent(value: JsonValue, indent: i64, level: i64) -> text:
    val spaces = " ".repeat(indent * level)
    val next_spaces = " ".repeat(indent * (level + 1))

    match value:
        case JsonValue.Null:
            return "null"
        case JsonValue.bool(b):
            if b:
                return "true"
            else:
                return "false"
        case JsonValue.Number(n):
            return n.to_string()
        case JsonValue.Integer(i):
            return i.to_string()
        case JsonValue.text(s):
            return "\"" + escape_string(s) + "\""
        case JsonValue.Array(arr):
            if arr.len() == 0:
                return "[]"
            var parts = []
            for item in arr:
                parts.append(next_spaces + stringify_indent(item, indent=indent, level=level + 1))
            return "[\n" + parts.join(",\n") + "\n" + spaces + "]"
        case JsonValue.Object(obj):
            val keys = obj.keys()
            if keys.len() == 0:
                return '{}'
            var parts = []
            for key in keys:
                val value = obj.get(key)
                parts.append(next_spaces + "\"" + escape_string(key) + "\": " + stringify_indent(value, indent=indent, level=level + 1))
            return '{\n' + parts.join(",\n") + "\n" + spaces + '}'

# Parse JSON string into a Dict (convenience function)
pub fn parse_object(input: text) -> Result<Dict<text, JsonValue>, text>:
    match parse(input):
        case Ok(JsonValue.Object(obj)):
            Ok(obj)
        case Ok(_):
            Err("JSON value is not an object")
        case Err(e):
            Err(e)

# Helper to get string from JsonValue
pub fn get_string(value: JsonValue) -> Option<text>:
    match value:
        case JsonValue.text(s):
            return Some(s)
        case _:
            return nil

# Helper to get integer from JsonValue
pub fn get_int(value: JsonValue) -> Option<i64>:
    match value:
        case JsonValue.Integer(i):
            return Some(i)
        case JsonValue.Number(n):
            return Some(n as i64)
        case _:
            return nil

# Helper to get object from JsonValue
pub fn get_object(value: JsonValue) -> Option<Dict<text, JsonValue> >:
    match value:
        case JsonValue.Object(obj):
            return Some(obj)
        case _:
            return nil

# Helper to get array from JsonValue
pub fn get_array(value: JsonValue) -> Option<List<JsonValue> >:
    match value:
        case JsonValue.Array(arr):
            return Some(arr)
        case _:
            return nil

# Builder for creating JSON objects
pub class JsonBuilder:
    obj: Dict<text, JsonValue>

    # =========================================================================
    # Helper Methods
    # =========================================================================

    pub fn is_empty() -> bool:
        """Check if builder has no fields."""
        return self.obj.len() == 0

    pub fn has_fields() -> bool:
        """Check if builder has any fields."""
        return self.obj.len() > 0

    pub fn field_count() -> usize:
        """Get number of fields."""
        return self.obj.len()

    pub fn has_field(key: text) -> bool:
        """Check if field exists."""
        return self.obj.has_key(key)

    pub fn get_field(key: text) -> Option<JsonValue>:
        """Get field value."""
        if self.obj.has_key(key):
            return Some(self.obj.get(key))
        return nil

    pub fn remove_field(key: text) -> JsonBuilder:
        """Remove a field."""
        self.obj = self.obj.remove(key)
        return self

    pub fn clear() -> JsonBuilder:
        """Clear all fields."""
        self.obj = {}
        return self

    pub fn keys() -> List<text>:
        """Get list of all field keys."""
        return self.obj.keys()

    pub fn summary() -> text:
        """Get summary of JSON builder state."""
        return "JsonBuilder: {self.field_count()} fields"

    # =========================================================================
    # Constructor
    # =========================================================================

    pub fn new() -> JsonBuilder:
        return JsonBuilder { obj: {} }

    pub fn set_string(key: text, value: text) -> JsonBuilder:
        self.obj = self.obj.set(key, JsonValue.text(value))
        return self

    pub fn set_int(key: text, value: i64) -> JsonBuilder:
        self.obj = self.obj.set(key, JsonValue.Integer(value))
        return self

    pub fn set_bool(key: text, value: bool) -> JsonBuilder:
        self.obj = self.obj.set(key, JsonValue.bool(value))
        return self

    pub fn set_null(key: text) -> JsonBuilder:
        self.obj = self.obj.set(key, JsonValue.Null)
        return self

    pub fn set_object(key: text, value: Dict<text, JsonValue>) -> JsonBuilder:
        self.obj = self.obj.set(key, JsonValue.Object(value))
        return self

    pub fn set_array(key: text, value: List<JsonValue>) -> JsonBuilder:
        self.obj = self.obj.set(key, JsonValue.Array(value))
        return self

    pub fn set(key: text, value: JsonValue) -> JsonBuilder:
        self.obj = self.obj.set(key, value)
        return self

    pub fn build() -> JsonValue:
        return JsonValue.Object(self.obj)

    pub fn to_string() -> text:
        return stringify(self.build())
