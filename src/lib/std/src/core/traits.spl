# Core Traits - Fundamental type behaviors
# These traits define common operations for types

# Default trait - types with a default value
# Note: default() is a method without self parameter (acts like a constructor)
trait Default:
    fn default() -> Self

# Clone trait - deep copy
trait Clone:
    fn clone() -> Self

# Copy trait - bitwise copy (marker trait)
# Trait inheritance supported: trait Copy: Clone:
# Types implementing Copy should also implement Clone
# For now, Copy trait is commented out - use Clone instead
# trait Copy:
#     fn clone() -> Self

# Eq trait - equality comparison
trait Eq:
    fn eq(other: &Self) -> bool

    fn ne(other: &Self) -> bool:
        return not self.eq(other)

# Ord trait - total ordering
# Trait inheritance supported: trait Ord: Eq:
trait Ord:
    # Required method (types should also implement Eq)
    fn cmp(other: &Self) -> Ordering

    fn lt(other: &Self) -> bool:
        return self.cmp(other) == Ordering::Less

    fn le(other: &Self) -> bool:
        return self.cmp(other) != Ordering::Greater

    fn gt(other: &Self) -> bool:
        return self.cmp(other) == Ordering::Greater

    fn ge(other: &Self) -> bool:
        return self.cmp(other) != Ordering::Less

    fn max(other: Self) -> Self:
        if self.ge(&other):
            return self
        return other

    fn min(other: Self) -> Self:
        if self.le(&other):
            return self
        return other

    fn clamp(min: Self, max: Self) -> Self:
        if self.lt(&min):
            return min
        if self.gt(&max):
            return max
        return self

# Number trait - unified interface for numeric types (Int, Float)
trait Number:
    # Constructors for numeric constants
    fn zero() -> Self
    fn one() -> Self

    # Absolute value
    fn abs() -> Self

    # Predicates
    fn is_zero() -> bool
    fn is_positive() -> bool
    fn is_negative() -> bool

    # Conversions
    fn to_f64() -> f64
    fn to_i64() -> i64

    # Sign as -1, 0, or 1
    fn signum() -> Self

# Ordering enum for comparisons
enum Ordering:
    Less
    Equal
    Greater

impl Ordering:
    fn is_less() -> bool:
        return self == Ordering::Less

    fn is_equal() -> bool:
        return self == Ordering::Equal

    fn is_greater() -> bool:
        return self == Ordering::Greater

    fn reverse() -> Ordering:
        match self:
            case Ordering::Less: return Ordering::Greater
            case Ordering::Equal: return Ordering::Equal
            case Ordering::Greater: return Ordering::Less

    fn to_string() -> text:
        """Convert Ordering to string representation.
        Returns: lowercase ordering name
        Example: Ordering::Less.to_string()  # → "less"
        """
        match self:
            case Ordering::Less: "less"
            case Ordering::Equal: "equal"
            case Ordering::Greater: "greater"

    fn description() -> text:
        """Get human-readable description of the ordering.
        Returns: descriptive explanation
        Example: Ordering::Greater.description()  # → "Greater than comparison result"
        """
        match self:
            case Ordering::Less: "Less than comparison result"
            case Ordering::Equal: "Equal comparison result"
            case Ordering::Greater: "Greater than comparison result"

    fn summary() -> text:
        """Get comprehensive summary of the ordering.
        Returns: summary with ordering value and description
        Example: Ordering::Less.summary()
                # → "Ordering: less (Less than comparison result)"
        """
        val name = self.to_string()
        val desc = self.description()
        "Ordering: {name} ({desc})"

# Hash trait - for hashable types
trait Hash:
    fn hash() -> u64

# Display trait - human-readable string representation
trait Display:
    fn fmt() -> str

# Debug trait - debug string representation
trait Debug:
    fn debug_fmt() -> str

# From/Into traits - type conversions
trait From<T>:
    fn from(value: T) -> Self

trait Into<T>:
    fn into() -> T

# Note: Default blanket impl requires where clause with generic constraint
# impl Into<T> for Self where Self: From<T>:
#     fn into() -> T:
#         return T::from(self)

# TryFrom/TryInto - fallible conversions
trait TryFrom<T>:
    type Error
    fn try_from(value: T) -> Result<Self, Self::Error>

trait TryInto<T>:
    type Error
    fn try_into() -> Result<T, Self::Error>

# Iterator trait - Self::Item syntax now supported (fixed 2026-01-18)
trait Iterator:
    type Item
    fn next() -> Option<Self::Item>

    fn count() -> u64:
        var n: u64 = 0
        while self.next().is_some():
            n = n + 1
        return n

    fn last() -> Option<Self::Item>:
        var last = None
        loop:
            match self.next():
                case Some(v): last = Some(v)
                case None: break
        return last

    fn nth(n: u64) -> Option<Self::Item>:
        for _ in 0..n:
            self.next()
        return self.next()

    fn collect<C: FromIterator<Self::Item>>(self) -> C:
        return C::from_iter(self)

# FromIterator trait - create collections from iterators
trait FromIterator<T>:
    fn from_iter<I: Iterator<Item=T>>(iter: I) -> Self

# IntoIterator trait - convert to iterator
trait IntoIterator:
    type Item
    type IntoIter: Iterator  # Bounds with generics (Iterator<Item=Self::Item>) not yet supported
    fn into_iter() -> Self::IntoIter

# Add trait - addition operator
trait Add<Rhs = Self>:
    type Output
    fn add(rhs: Rhs) -> Self::Output

# Sub trait - subtraction operator
trait Sub<Rhs = Self>:
    type Output
    fn sub(rhs: Rhs) -> Self::Output

# Mul trait - multiplication operator
trait Mul<Rhs = Self>:
    type Output
    fn mul(rhs: Rhs) -> Self::Output

# Div trait - division operator
trait Div<Rhs = Self>:
    type Output
    fn div(rhs: Rhs) -> Self::Output

# Neg trait - negation operator
trait Neg:
    type Output
    fn neg() -> Self::Output

# Not trait - logical not operator
trait Not:
    type Output
    fn not() -> Self::Output

# Index trait - indexing operator
trait Index<Idx>:
    type Output
    fn index(idx: Idx) -> &Self::Output

# IndexMut trait - mutable indexing
# Note: trait inheritance with generics (trait A<T>: B<T>) not yet supported
trait IndexMut<Idx>:  # Should inherit: Index<Idx>
    fn index_mut(idx: Idx) -> &mut Self::Output

# Deref trait - dereference
trait Deref:
    type Target
    fn deref() -> &Self::Target

# DerefMut trait - mutable dereference
# Trait inheritance supported: trait DerefMut: Deref:
trait DerefMut:
    type Target
    fn deref_mut() -> &mut Self::Target

# Drop trait - destructor
trait Drop:
    fn drop()

# Sized trait - types with known size at compile time (marker)
# Marker trait - has no methods, just indicates the type has a known size
trait Sized:
    # Marker trait - no methods required
    fn is_sized() -> bool:
        true

# ============================================
# I/O Traits
# ============================================

# SeekFrom - position for seeking
enum SeekFrom:
    Start(u64)
    End(i64)
    Current(i64)

impl SeekFrom:
    fn start(pos: u64) -> SeekFrom:
        SeekFrom::Start(pos)

    fn end(pos: i64) -> SeekFrom:
        SeekFrom::End(pos)

    fn current(pos: i64) -> SeekFrom:
        SeekFrom::Current(pos)

    fn is_start() -> bool:
        """Check if this is Start seek position.
        Returns: true for Start
        Example: SeekFrom::Start(0).is_start()  # → true
        """
        match self:
            case SeekFrom::Start(_): true
            case _: false

    fn is_end() -> bool:
        """Check if this is End seek position.
        Returns: true for End
        Example: SeekFrom::End(-10).is_end()  # → true
        """
        match self:
            case SeekFrom::End(_): true
            case _: false

    fn is_current() -> bool:
        """Check if this is Current seek position.
        Returns: true for Current
        Example: SeekFrom::Current(5).is_current()  # → true
        """
        match self:
            case SeekFrom::Current(_): true
            case _: false

    fn is_absolute() -> bool:
        """Check if seek position is absolute (Start or End).
        Returns: true for Start or End
        Example: SeekFrom::Start(0).is_absolute()  # → true
        """
        match self:
            case SeekFrom::Start(_): true
            case SeekFrom::End(_): true
            case SeekFrom::Current(_): false

    fn is_relative() -> bool:
        """Check if seek position is relative (Current).
        Returns: true for Current
        Example: SeekFrom::Current(5).is_relative()  # → true
        """
        match self:
            case SeekFrom::Current(_): true
            case _: false

    fn get_offset() -> i64:
        """Get the offset value (converting u64 to i64 for Start).
        Returns: offset as i64
        Example: SeekFrom::Current(-5).get_offset()  # → -5
        """
        match self:
            case SeekFrom::Start(pos): pos as i64
            case SeekFrom::End(pos): pos
            case SeekFrom::Current(pos): pos

    fn to_string() -> text:
        """Convert SeekFrom to string representation.
        Returns: string with seek position
        Example: SeekFrom::Start(10).to_string()  # → "start(10)"
        """
        match self:
            case SeekFrom::Start(pos): "start({pos})"
            case SeekFrom::End(pos): "end({pos})"
            case SeekFrom::Current(pos): "current({pos})"

    fn description() -> text:
        """Get human-readable description of the seek position.
        Returns: descriptive explanation
        Example: SeekFrom::End(-10).description()
                # → "Seek from end of stream with offset -10"
        """
        return match self:
            case SeekFrom::Start(pos): "Seek from start of stream to position {pos}"
            case SeekFrom::End(pos): "Seek from end of stream with offset {pos}"
            case SeekFrom::Current(pos): "Seek from current position with offset {pos}"

    fn summary() -> text:
        """Get comprehensive summary of the seek position.
        Returns: summary with position, description, and type
        Example: SeekFrom::Current(5).summary()
                # → "SeekFrom: current(5) (Seek from current position with offset 5, relative)"
        """
        val str_repr = self.to_string()
        val desc = self.description()
        var seek_type = "relative"
        if self.is_absolute():
            seek_type = "absolute"

        "SeekFrom: {str_repr} ({desc}, {seek_type})"

# Read trait - for types that can be read from
trait Read:
    fn read(buf: &mut Slice<u8>) -> Result<usize, IoError>

    fn read_exact(buf: &mut Slice<u8>) -> Result<(), IoError>:
        var offset: usize = 0
        while offset < buf.len():
            val remaining = buf.slice_from(offset)
            match self.read(&mut remaining):
                case Ok(0): return Err(IoError::UnexpectedEof)
                case Ok(n): offset = offset + n
                case Err(e): return Err(e)
        Ok(())

    fn read_to_end(buf: &mut Array<u8>) -> Result<usize, IoError>:
        var total: usize = 0
        var chunk: Array<u8> = Array.with_capacity(4096)
        loop:
            match self.read(&mut chunk):
                case Ok(0): return Ok(total)
                case Ok(count):
                    val chunk_slice = chunk.slice(0, count)
                    buf.extend_from_slice(&chunk_slice)
                    total = total + count
                case Err(e): return Err(e)

    fn read_to_string(s: &mut text) -> Result<usize, IoError>:
        var buf = Array::new()
        val n = self.read_to_end(&mut buf)?
        match text::from_utf8(buf):
            case Ok(str):
                s.push_str(&str)
                Ok(n)
            case Err(_): Err(IoError::InvalidData)

# Write trait - for types that can be written to
trait Write:
    fn write(buf: &Slice<u8>) -> Result<usize, IoError>
    fn flush() -> Result<(), IoError>

    fn write_all(buf: &Slice<u8>) -> Result<(), IoError>:
        var offset: usize = 0
        while offset < buf.len():
            val remaining = buf.slice_from(offset)
            match self.write(&remaining):
                case Ok(0): return Err(IoError::WriteZero)
                case Ok(n): offset = offset + n
                case Err(e): return Err(e)
        Ok(())

    fn write_fmt(args: str) -> Result<(), IoError>:
        self.write_all(args.as_bytes())

# Seek trait - for types that support seeking
trait Seek:
    fn seek(pos: SeekFrom) -> Result<u64, IoError>

    fn rewind() -> Result<(), IoError>:
        # Use Simple lambda syntax: \_: to ignore parameter
        self.seek(SeekFrom::Start(0)).map(\_: ())

    fn stream_position() -> Result<u64, IoError>:
        self.seek(SeekFrom::Current(0))

    fn stream_len() -> Result<u64, IoError>:
        val old_pos = self.stream_position()?
        val len = self.seek(SeekFrom::End(0))?
        if old_pos != len:
            self.seek(SeekFrom::Start(old_pos))?
        Ok(len)

# BufRead trait - for buffered reading
# Trait inheritance supported: trait BufRead: Read:
trait BufRead:
    fn fill_buf() -> Result<Slice<u8>, IoError>
    fn consume(amt: usize)

    fn read_until(byte: u8, buf: &mut Array<u8>) -> Result<usize, IoError>:
        var read: usize = 0
        loop:
            val available = self.fill_buf()?
            if available.is_empty():
                return Ok(read)

            match available.iter().position(\b: b == byte):
                case Some(i):
                    val slice_to_i = available.slice(0, i + 1)
                    buf.extend_from_slice(&slice_to_i)
                    self.consume(i + 1)
                    return Ok(read + i + 1)
                case nil:
                    buf.extend_from_slice(available)
                    val len = available.len()
                    self.consume(len)
                    read = read + len

    fn read_line(buf: &mut text) -> Result<usize, IoError>:
        var bytes = Array::new()
        val newline_byte: u8 = 10
        val n = self.read_until(newline_byte, &mut bytes)?
        match text::from_utf8(bytes):
            case Ok(s):
                buf.push_str(&s)
                Ok(n)
            case Err(_): Err(IoError::InvalidData)

# ============================================
# Collection Traits
# ============================================

# Len trait - for types with a length
trait Len:
    fn len() -> usize

    fn is_empty() -> bool:
        self.len() == 0

# Extend trait - extend collection with items
trait Extend<A>:
    fn extend<I: IntoIterator<Item=A>>(self, iter: I)

# AsSlice trait - view as slice
trait AsSlice<T>:
    fn as_slice() -> Slice<T>

# AsMutSlice trait - view as mutable slice
# Note: trait inheritance with generics (trait A<T>: B<T>) not yet supported
trait AsMutSlice<T>:  # Should inherit: AsSlice<T>
    fn as_mut_slice() -> MutSlice<T>

# Clear trait - clear contents
trait Clear:
    fn clear()

# Capacity trait - for types with capacity
trait Capacity:
    fn capacity() -> usize

    fn is_full() -> bool:
        false  # Default: no limit

# Reserve trait - for types that can reserve capacity
trait Reserve:
    fn reserve(additional: usize)
    fn shrink_to_fit()

# ============================================
# Conversion Traits
# ============================================

# AsRef trait - cheap reference conversion
trait AsRef<T>:
    fn as_ref() -> &T

# AsMut trait - cheap mutable reference conversion
trait AsMut<T>:
    fn as_mut() -> &mut T

# Borrow trait - borrowing
trait Borrow<Borrowed>:
    fn borrow() -> &Borrowed

# BorrowMut trait - mutable borrowing
# Note: trait inheritance with generics (trait A<T>: B<T>) not yet supported
trait BorrowMut<Borrowed>:  # Should inherit: Borrow<Borrowed>
    fn borrow_mut() -> &mut Borrowed

# ToOwned trait - create owned copy
trait ToOwned:
    type Owned
    fn to_owned() -> Self::Owned

# ToString trait - convert to string
trait ToString:
    fn to_string() -> text

# Default impl: Display types can be converted to string
impl ToString for T where T: Display:
    fn to_string() -> text:
        self.fmt()

# FromStr trait - parse from string
trait FromStr:
    type Err
    fn from_str(s: &str) -> Result<Self, Self::Err>

# ============================================
# Error Trait
# ============================================

# Error trait - base error trait
# Trait inheritance supported: trait Error: Display:
trait Error:
    fn source() -> Option<&dyn Error>:
        None

    fn description() -> str:
        self.fmt()

# ============================================
# Iterator Enhancement Traits
# ============================================

# DoubleEndedIterator - can iterate from both ends
# Trait inheritance supported: trait X: Iterator:
trait DoubleEndedIterator:
    fn next_back() -> Option<Self::Item>

    fn rev() -> Rev<Self>:
        Rev::new(self)

    fn rfind(predicate: fn(&Self::Item) -> bool) -> Option<Self::Item>:
        loop:
            match self.next_back():
                case Some(item):
                    if predicate(&item):
                        return Some(item)
                case None:
                    return None

# ExactSizeIterator - knows its exact length
# Trait inheritance supported: trait X: Iterator:
trait ExactSizeIterator:
    fn len() -> usize

    fn is_empty() -> bool:
        self.len() == 0

# FusedIterator - returns None forever after first None (marker)
# Trait inheritance supported: trait X: Iterator:
# Marker trait - types implementing this guarantee next() returns None forever after first None
# trait FusedIterator:
#     # No methods - pure marker trait

# ============================================
# Marker Traits
# ============================================

# Send trait - safe to send between threads (marker)
# Note: Renamed from Send to avoid keyword conflicts
trait Sendable:
    fn is_sendable() -> bool:
        true

# Sync trait - safe to share between threads (marker)
# Note: Renamed from Sync to avoid keyword conflicts
trait Shareable:
    fn is_shareable() -> bool:
        true

# Unpin trait - safe to move after pinning (marker)
trait Unpinnable:
    fn is_unpinnable() -> bool:
        true

# ============================================
# Function Traits
# ============================================

# Fn trait - callable by shared reference
trait Fn<Args, Output>:
    fn call(args: Args) -> Output

# FnMut trait - callable by mutable reference
# Note: trait inheritance with generics (trait A<T>: B<T>) not yet supported
trait FnMut<Args, Output>:  # Should inherit: Fn<Args, Output>
    fn call_mut(args: Args) -> Output

# FnOnce trait - callable by value (consuming)
trait FnOnce<Args, Output>:
    fn call_once(args: Args) -> Output

# ============================================
# Reverse Iterator Wrapper
# ============================================

struct Rev<I>:
    iter: I

impl Rev<I> where I: DoubleEndedIterator:
    fn new(iter: I) -> Rev<I>:
        Rev { iter: iter }

impl Iterator for Rev<I> where I: DoubleEndedIterator:
    type Item = I::Item

    fn next() -> Option<Self::Item>:
        self.iter.next_back()

impl DoubleEndedIterator for Rev<I> where I: DoubleEndedIterator:
    fn next_back() -> Option<Self::Item>:
        self.iter.next()
