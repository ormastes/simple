# Context Manager Module
# Provides the ContextManager trait for resource management with `with` statements
#
# Feature #1092: ContextManager trait

use core.sync.Mutex

# Context manager protocol for use with `with` statements.
# Implementers must define __enter__ and __exit__ methods.
trait ContextManager:
    # Enter the context. Returns the resource to be bound to the `as` variable.
    fn __enter__():
        nil

    # Exit the context. Returns true to suppress exceptions, false to propagate.
    fn __exit__(exc_type, exc_value, traceback):
        nil


# Example Context Managers

struct Timer:
    name: text
    start_time: f64

    fn new(name: text) -> Timer:
        return Timer(
            name: name,
            start_time: 0.0
        )

    fn __enter__():
        self.start_time = time_now()
        return self

    fn __exit__(exc_type, exc_value, traceback):
        elapsed = time_now() - self.start_time
        print("{self.name} took {elapsed}s")
        return false  # Don't suppress exceptions

    # =========================================================================
    # Helper Methods
    # =========================================================================

    fn is_running() -> bool:
        """Check if timer has been started (has non-zero start time).

        Returns:
            true if timer has started

        Example:
            timer = Timer("test")
            timer.is_running()  # → false
            timer.__enter__()
            timer.is_running()  # → true
        """
        return self.start_time != 0

    fn get_elapsed() -> f64:
        """Get current elapsed time since start.

        Returns:
            Elapsed time in seconds, or 0 if not started

        Example:
            timer = Timer("test")
            timer.__enter__()
            # ... wait ...
            elapsed = timer.get_elapsed()  # → time since start
        """
        if not self.is_running():
            return 0.0
        return time_now() - self.start_time

    fn get_name() -> text:
        """Get timer name.

        Returns:
            Timer name string

        Example:
            timer = Timer("operation")
            timer.get_name()  # → "operation"
        """
        return self.name

    fn summary() -> text:
        """Get summary of timer.

        Returns:
            Human-readable summary

        Example:
            timer.summary()
            # → "Timer 'operation': running, 1.23s elapsed"
            # → "Timer 'operation': not started"
        """
        val name = self.name
        if not self.is_running():
            return "Timer '{name}': not started"
        val elapsed = self.get_elapsed()
        return "Timer '{name}': running, {elapsed}s elapsed"


struct Lock:
    _mutex: Mutex
    _guard: Option<Any>

    fn new() -> Lock:
        return Lock(
            _mutex: Mutex(0),
            _guard: nil
        )

    fn __enter__():
        self.acquire()
        return self

    fn __exit__(exc_type, exc_value, traceback):
        self.release()
        return false

    fn acquire():
        # Acquire the mutex lock - blocks until available
        self._guard = self._mutex.lock()

    fn release():
        # Release is automatic when guard goes out of scope
        # But we can explicitly drop it here
        self._guard = nil

    # =========================================================================
    # Helper Methods
    # =========================================================================

    fn is_locked() -> bool:
        """Check if lock is currently held.

        Returns:
            true if lock is held (guard is not None)

        Example:
            lock = Lock()
            lock.is_locked()  # → false
            lock.acquire()
            lock.is_locked()  # → true
            lock.release()
            lock.is_locked()  # → false
        """
        return self._guard.is_some()

    fn is_unlocked() -> bool:
        """Check if lock is not held.

        Returns:
            true if lock is not held

        Example:
            lock = Lock()
            lock.is_unlocked()  # → true
            lock.acquire()
            lock.is_unlocked()  # → false
        """
        return self._guard.is_none()

    fn summary() -> text:
        """Get summary of lock.

        Returns:
            Human-readable summary

        Example:
            lock.summary()
            # → "Lock: locked" or "Lock: unlocked"
        """
        val status = if self.is_locked(): "locked" else: "unlocked"
        return "Lock: {status}"


struct TransactionContext:
    committed: bool
    rolled_back: bool

    fn new() -> TransactionContext:
        return TransactionContext(
            committed: false,
            rolled_back: false
        )

    fn __enter__():
        self.begin()
        return self

    fn __exit__(exc_type, exc_value, traceback):
        if exc_type or self.rolled_back:
            self.rollback()
        else:
            self.commit()
        return false

    fn begin():
        print("[TX] Transaction started")

    fn commit():
        if not self.rolled_back:
            self.committed = true
            print("[TX] Transaction committed")

    fn rollback():
        self.rolled_back = true
        print("[TX] Transaction rolled back")

    # =========================================================================
    # Helper Methods
    # =========================================================================

    fn is_committed() -> bool:
        """Check if transaction has been committed.

        Returns:
            true if transaction was committed

        Example:
            tx = TransactionContext()
            tx.is_committed()  # → false
            tx.commit()
            tx.is_committed()  # → true
        """
        return self.committed

    fn is_rolled_back() -> bool:
        """Check if transaction has been rolled back.

        Returns:
            true if transaction was rolled back

        Example:
            tx = TransactionContext()
            tx.is_rolled_back()  # → false
            tx.rollback()
            tx.is_rolled_back()  # → true
        """
        return self.rolled_back

    fn is_pending() -> bool:
        """Check if transaction is pending (neither committed nor rolled back).

        Returns:
            true if transaction is still pending

        Example:
            tx = TransactionContext()
            tx.is_pending()  # → true
            tx.commit()
            tx.is_pending()  # → false
        """
        return not self.committed and not self.rolled_back

    fn is_completed() -> bool:
        """Check if transaction is completed (either committed or rolled back).

        Returns:
            true if transaction is done

        Example:
            tx = TransactionContext()
            tx.is_completed()  # → false
            tx.commit()
            tx.is_completed()  # → true
        """
        return self.committed or self.rolled_back

    fn summary() -> text:
        """Get summary of transaction.

        Returns:
            Human-readable summary

        Example:
            tx.summary()
            # → "Transaction: pending"
            # → "Transaction: committed"
            # → "Transaction: rolled back"
        """
        if self.is_committed():
            return "Transaction: committed"
        elif self.is_rolled_back():
            return "Transaction: rolled back"
        else:
            return "Transaction: pending"


# Helper function to create context managers from callables
# TODO: Implement when class-inside-function syntax is supported
# fn contextmanager(enter_fn, exit_fn) -> requires class syntax

# Utility context managers
# TODO: Implement when varargs (*args) syntax is supported
# fn suppress(*exception_types) -> requires varargs syntax


# Exports
pub use ContextManager
pub use Timer
pub use Lock
pub use TransactionContext
