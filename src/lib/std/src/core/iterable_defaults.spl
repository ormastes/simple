# Iterable Defaults - Shared implementations for collection methods
#
# This module provides default implementations for common iteration methods
# that collections can delegate to, reducing code duplication.
#
# Usage:
#   impl Sequence<T> for MyCollection<T>:
#       fn all(predicate: fn(&T) -> bool) -> bool:
#           iterable_defaults.all_impl(self, predicate)

use core.list.*

# ============================================
# Predicate Methods
# ============================================

@pure
pub fn all_impl<T, I: Iterable<T>>(collection: &I, predicate: fn(&T) -> bool) -> bool:
    """Check if all elements match predicate.

    Returns true for empty collections.

    Args:
        collection: The collection to check
        predicate: Function to test each element

    Returns:
        True if all elements match, false otherwise

    Example:
        >>> all_impl(&[2, 4, 6], |x| x % 2 == 0)
        true
    """
    collection.each(|item|:
        if not predicate(&item):
            return false
    )
    true

@pure
pub fn any_impl<T, I: Iterable<T>>(collection: &I, predicate: fn(&T) -> bool) -> bool:
    """Check if any element matches predicate.

    Returns false for empty collections.

    Args:
        collection: The collection to check
        predicate: Function to test each element

    Returns:
        True if any element matches, false otherwise

    Example:
        >>> any_impl(&[1, 2, 3], |x| x > 2)
        true
    """
    collection.each(|item|:
        if predicate(&item):
            return true
    )
    false

@pure
pub fn find_impl<T, I: Iterable<T>>(collection: &I, predicate: fn(&T) -> bool) -> Option<T> where T: Clone:
    """Find first element matching predicate.

    Args:
        collection: The collection to search
        predicate: Function to test each element

    Returns:
        Some(element) if found, None otherwise

    Example:
        >>> find_impl(&[1, 2, 3, 4], |x| x > 2)
        Some(3)
    """
    collection.each(|item|:
        if predicate(&item):
            return Some(item.clone())
    )
    nil

@pure
pub fn find_index_impl<T, I: Iterable<T>>(collection: &I, predicate: fn(&T) -> bool) -> Option<usize>:
    """Find index of first element matching predicate.

    Args:
        collection: The collection to search
        predicate: Function to test each element

    Returns:
        Some(index) if found, None otherwise

    Example:
        >>> find_index_impl(&[1, 2, 3, 4], |x| x > 2)
        Some(2)
    """
    var idx: usize = 0
    collection.each(|item|:
        if predicate(&item):
            return Some(idx)
        idx = idx + 1
    )
    nil

@pure
pub fn count_matching_impl<T, I: Iterable<T>>(collection: &I, predicate: fn(&T) -> bool) -> usize:
    """Count elements matching predicate.

    Args:
        collection: The collection to count
        predicate: Function to test each element

    Returns:
        Number of matching elements

    Example:
        >>> count_matching_impl(&[1, 2, 3, 4, 5], |x| x % 2 == 0)
        2
    """
    var count: usize = 0
    collection.each(|item|:
        if predicate(&item):
            count = count + 1
    )
    count

# ============================================
# Reduction Methods
# ============================================

@pure
pub fn fold_impl<T, U, I: Iterable<T>>(collection: &I, init: U, f: fn(U, T) -> U) -> U where T: Clone:
    """Left fold over collection.

    Applies function to accumulator and each element in order.

    Args:
        collection: The collection to fold
        init: Initial accumulator value
        f: Function taking (accumulator, element) -> new accumulator

    Returns:
        Final accumulator value

    Example:
        >>> fold_impl(&[1, 2, 3, 4], 0, |acc, x| acc + x)
        10
    """
    var acc = init
    collection.each(|item|:
        acc = f(acc, item.clone())
    )
    acc

@pure
pub fn reduce_impl<T, I: Iterable<T>>(collection: &I, f: fn(T, T) -> T) -> Option<T> where T: Clone:
    """Reduce collection using first element as initial value.

    Args:
        collection: The collection to reduce
        f: Function taking (accumulator, element) -> new accumulator

    Returns:
        Some(result) if collection non-empty, None otherwise

    Example:
        >>> reduce_impl(&[1, 2, 3, 4], |a, b| a + b)
        Some(10)
    """
    var first: Option<T> = nil
    var acc: Option<T> = nil

    collection.each(|item|:
        match acc:
            case nil:
                acc = Some(item.clone())
            case Some(a):
                acc = Some(f(a, item.clone()))
    )
    acc

@pure
pub fn sum_impl<T, I: Iterable<T>>(collection: &I) -> T where T: Add<Output=T> + Default + Clone:
    """Sum all elements.

    Args:
        collection: The collection to sum

    Returns:
        Sum of all elements (Default.default() for empty)

    Example:
        >>> sum_impl(&[1, 2, 3, 4])
        10
    """
    fold_impl(collection, T.default(), |acc, x| acc + x)

@pure
pub fn product_impl<T, I: Iterable<T>>(collection: &I) -> T where T: Mul<Output=T> + Default + Clone:
    """Multiply all elements.

    Args:
        collection: The collection to multiply

    Returns:
        Product of all elements

    Example:
        >>> product_impl(&[1, 2, 3, 4])
        24
    """
    var has_any = false
    var acc = T.default()

    collection.each(|item|:
        if not has_any:
            acc = item.clone()
            has_any = true
        else:
            acc = acc * item.clone()
    )
    acc

# ============================================
# Extrema Methods
# ============================================

@pure
pub fn max_impl<T, I: Iterable<T>>(collection: &I) -> Option<T> where T: Ord + Clone:
    """Find maximum element.

    Args:
        collection: The collection to search

    Returns:
        Some(max) if non-empty, None otherwise

    Example:
        >>> max_impl(&[3, 1, 4, 1, 5])
        Some(5)
    """
    var result: Option<T> = nil
    collection.each(|item|:
        match result:
            case nil:
                result = Some(item.clone())
            case Some(current):
                if item > current:
                    result = Some(item.clone())
    )
    result

@pure
pub fn min_impl<T, I: Iterable<T>>(collection: &I) -> Option<T> where T: Ord + Clone:
    """Find minimum element.

    Args:
        collection: The collection to search

    Returns:
        Some(min) if non-empty, None otherwise

    Example:
        >>> min_impl(&[3, 1, 4, 1, 5])
        Some(1)
    """
    var result: Option<T> = nil
    collection.each(|item|:
        match result:
            case nil:
                result = Some(item.clone())
            case Some(current):
                if item < current:
                    result = Some(item.clone())
    )
    result

# ============================================
# First/Last Methods
# ============================================

@pure
pub fn first_impl<T, I: Iterable<T>>(collection: &I) -> Option<T> where T: Clone:
    """Get first element.

    Args:
        collection: The collection

    Returns:
        Some(first) if non-empty, None otherwise
    """
    var result: Option<T> = nil
    collection.each(|item|:
        if result.is_none():
            result = Some(item.clone())
            return
    )
    result

@pure
pub fn last_impl<T, I: Iterable<T>>(collection: &I) -> Option<T> where T: Clone:
    """Get last element.

    Args:
        collection: The collection

    Returns:
        Some(last) if non-empty, None otherwise
    """
    var result: Option<T> = nil
    collection.each(|item|:
        result = Some(item.clone())
    )
    result

# ============================================
# Collection Building Methods
# ============================================

@pure
pub fn filter_impl<T, I: Iterable<T>>(collection: &I, predicate: fn(&T) -> bool) -> List<T> where T: Clone:
    """Filter elements matching predicate into a new List.

    Args:
        collection: The collection to filter
        predicate: Function to test each element

    Returns:
        New list with matching elements

    Example:
        >>> filter_impl(&[1, 2, 3, 4, 5], |x| x % 2 == 0)
        [2, 4]
    """
    var result = List.new()
    collection.each(|item|:
        if predicate(&item):
            result.push(item.clone())
    )
    result

@pure
pub fn map_impl<T, U, I: Iterable<T>>(collection: &I, f: fn(T) -> U) -> List<U> where T: Clone:
    """Map function over elements into a new List.

    Args:
        collection: The collection to map
        f: Function to apply to each element

    Returns:
        New list with transformed elements

    Example:
        >>> map_impl(&[1, 2, 3], |x| x * 2)
        [2, 4, 6]
    """
    var result = List.new()
    collection.each(|item|:
        result.push(f(item.clone()))
    )
    result

@pure
pub fn flat_map_impl<T, U, I: Iterable<T>, J: Iterable<U>>(collection: &I, f: fn(T) -> J) -> List<U> where T: Clone, U: Clone:
    """Flat map function over elements into a new List.

    Args:
        collection: The collection to flat map
        f: Function returning iterable for each element

    Returns:
        New list with flattened transformed elements

    Example:
        >>> flat_map_impl(&[1, 2, 3], |x| [x, x])
        [1, 1, 2, 2, 3, 3]
    """
    var result = List.new()
    collection.each(|item|:
        val inner = f(item.clone())
        inner.each(|inner_item|:
            result.push(inner_item.clone())
        )
    )
    result

# ============================================
# Partitioning Methods
# ============================================

@pure
pub fn partition_impl<T, I: Iterable<T>>(collection: &I, predicate: fn(&T) -> bool) -> (List<T>, List<T>) where T: Clone:
    """Partition elements into two lists based on predicate.

    Args:
        collection: The collection to partition
        predicate: Function to test each element

    Returns:
        Tuple of (matching, non-matching) lists

    Example:
        >>> partition_impl(&[1, 2, 3, 4, 5], |x| x % 2 == 0)
        ([2, 4], [1, 3, 5])
    """
    var matching = List.new()
    var non_matching = List.new()
    collection.each(|item|:
        if predicate(&item):
            matching.push(item.clone())
        else:
            non_matching.push(item.clone())
    )
    (matching, non_matching)

@pure
pub fn take_impl<T, I: Iterable<T>>(collection: &I, n: usize) -> List<T> where T: Clone:
    """Take first n elements.

    Args:
        collection: The collection
        n: Number of elements to take

    Returns:
        New list with first n elements
    """
    var result = List.new()
    var count: usize = 0
    collection.each(|item|:
        if count >= n:
            return
        result.push(item.clone())
        count = count + 1
    )
    result

@pure
pub fn drop_impl<T, I: Iterable<T>>(collection: &I, n: usize) -> List<T> where T: Clone:
    """Drop first n elements.

    Args:
        collection: The collection
        n: Number of elements to drop

    Returns:
        New list with remaining elements
    """
    var result = List.new()
    var count: usize = 0
    collection.each(|item|:
        if count >= n:
            result.push(item.clone())
        count = count + 1
    )
    result

@pure
pub fn take_while_impl<T, I: Iterable<T>>(collection: &I, predicate: fn(&T) -> bool) -> List<T> where T: Clone:
    """Take elements while predicate is true.

    Args:
        collection: The collection
        predicate: Function to test each element

    Returns:
        New list with prefix of matching elements
    """
    var result = List.new()
    var done = false
    collection.each(|item|:
        if done:
            return
        if predicate(&item):
            result.push(item.clone())
        else:
            done = true
    )
    result

@pure
pub fn drop_while_impl<T, I: Iterable<T>>(collection: &I, predicate: fn(&T) -> bool) -> List<T> where T: Clone:
    """Drop elements while predicate is true.

    Args:
        collection: The collection
        predicate: Function to test each element

    Returns:
        New list with remaining elements
    """
    var result = List.new()
    var dropping = true
    collection.each(|item|:
        if dropping and predicate(&item):
            # Still dropping
            ()
        else:
            dropping = false
            result.push(item.clone())
    )
    result

# ============================================
# Zip and Combine Methods
# ============================================

@pure
pub fn zip_impl<T, U, I: Iterable<T>, J: Iterable<U>>(a: &I, b: &J) -> List<(T, U)> where T: Clone, U: Clone:
    """Zip two collections together.

    Stops when either collection is exhausted.

    Args:
        a: First collection
        b: Second collection

    Returns:
        New list of tuples

    Example:
        >>> zip_impl(&[1, 2, 3], &['a', 'b', 'c'])
        [(1, 'a'), (2, 'b'), (3, 'c')]
    """
    var result = List.new()
    var b_items = List.new()
    b.each(|item|:
        b_items.push(item.clone())
    )
    var b_idx: usize = 0
    a.each(|a_item|:
        if b_idx < b_items.len():
            result.push((a_item.clone(), b_items.get(b_idx).unwrap()))
            b_idx = b_idx + 1
    )
    result

@pure
pub fn enumerate_impl<T, I: Iterable<T>>(collection: &I) -> List<(usize, T)> where T: Clone:
    """Enumerate elements with indices.

    Args:
        collection: The collection

    Returns:
        New list of (index, element) tuples

    Example:
        >>> enumerate_impl(&['a', 'b', 'c'])
        [(0, 'a'), (1, 'b'), (2, 'c')]
    """
    var result = List.new()
    var idx: usize = 0
    collection.each(|item|:
        result.push((idx, item.clone()))
        idx = idx + 1
    )
    result

# ============================================
# Grouping Methods
# ============================================

@pure
pub fn group_by_impl<T, K, I: Iterable<T>>(collection: &I, key_fn: fn(&T) -> K) -> Dict<K, List<T>> where T: Clone, K: Eq + Hash:
    """Group elements by key function.

    Args:
        collection: The collection to group
        key_fn: Function to compute key for each element

    Returns:
        Dict mapping keys to lists of elements

    Example:
        >>> group_by_impl(&[1, 2, 3, 4, 5], |x| x % 2)
        {0: [2, 4], 1: [1, 3, 5]}
    """
    var result: Dict<K, List<T>> = Dict.new()
    collection.each(|item|:
        val key = key_fn(&item)
        match result.get(&key):
            case Some(list):
                list.push(item.clone())
            case nil:
                var new_list = List.new()
                new_list.push(item.clone())
                result.set(key, new_list)
    )
    result

@pure
pub fn chunk_impl<T, I: Iterable<T>>(collection: &I, size: usize) -> List<List<T>> where T: Clone:
    """Split into chunks of given size.

    Last chunk may be smaller than size.

    Args:
        collection: The collection to chunk
        size: Maximum size of each chunk

    Returns:
        List of chunks

    Example:
        >>> chunk_impl(&[1, 2, 3, 4, 5], 2)
        [[1, 2], [3, 4], [5]]
    """
    if size == 0:
        return List.new()

    var result = List.new()
    var current_chunk = List.new()
    var count: usize = 0

    collection.each(|item|:
        current_chunk.push(item.clone())
        count = count + 1
        if count == size:
            result.push(current_chunk)
            current_chunk = List.new()
            count = 0
    )

    if current_chunk.len() > 0:
        result.push(current_chunk)

    result
