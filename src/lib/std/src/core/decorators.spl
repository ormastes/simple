# Core Decorators Module
# Provides built-in decorators for function enhancement
#
# Features:
# - @cached: Memoization decorator for pure functions
# - @logged: Automatic logging decorator
# - @deprecated: Deprecation warning decorator
# - @timeout: Execution timeout decorator

# Cached Decorator (#1069)
#
# Memoizes function results based on arguments.
# Usage:
#   @cached
#   fn fibonacci(n: i64) -> i64:
#       if n <= 1: return n
#       return fibonacci(n-1) + fibonacci(n-2)
#
# Implementation: Uses a Dict to cache results by argument hash

class CachedFunction:
    """Wrapper that caches function results"""

    fn __init__(func):
        self.func = func
        self.cache = {}
        self.hits = 0
        self.misses = 0

    fn __call__(args...):
        """Call the function with caching"""
        # Create cache key from arguments
        # For now, use simple string representation
        cache_key = str(args)

        if cache_key in self.cache:
            self.hits = self.hits + 1
            return self.cache[cache_key]

        # Cache miss - call original function
        self.misses = self.misses + 1
        result = self.func(args...)
        self.cache[cache_key] = result
        return result

    fn clear_cache():
        """Clear the memoization cache"""
        self.cache = {}
        self.hits = 0
        self.misses = 0

    fn cache_info():
        """Return cache statistics"""
        return {
            "hits": self.hits,
            "misses": self.misses,
            "size": len(self.cache)
        }

fn cached(func):
    """
    Decorator that caches function results based on arguments.

    Example:
        @cached
        fn expensive_computation(x: i64) -> i64:
            # ... expensive work ...
            return x * x

    The decorated function will cache results for each unique
    set of arguments, returning cached values on subsequent calls.
    """
    return CachedFunction(func)


# Logged Decorator (#1070)
#
# Automatically logs function calls and returns

class LoggedFunction:
    """Wrapper that logs function calls"""

    fn __init__(func):
        self.func = func
        self.name = str(func)  # Function name

    fn __call__(args...):
        """Call function with logging"""
        print("[LOG] Calling {self.name} with args: {args}")
        result = self.func(args...)
        print("[LOG] {self.name} returned: {result}")
        return result

fn logged(func):
    """
    Decorator that logs function calls and return values.

    Example:
        @logged
        fn calculate(x: i64, y: i64) -> i64:
            return x + y

    Output:
        [LOG] Calling calculate with args: (10, 20)
        [LOG] calculate returned: 30
    """
    return LoggedFunction(func)


# Deprecated Decorator (#1071)
#
# Warns when deprecated functions are called

class DeprecatedFunction:
    """Wrapper that warns about deprecated functions"""

    fn __init__(func, message):
        self.func = func
        self.message = message
        self.name = str(func)
        self.warned = false

    fn __call__(args...):
        """Call function with deprecation warning"""
        if not self.warned:
            if self.message:
                print("[DEPRECATED] {self.name}: {self.message}")
            else:
                print("[DEPRECATED] {self.name} is deprecated")
            self.warned = true
        return self.func(args...)

fn deprecated(message = nil):
    """
    Decorator that marks functions as deprecated.

    Example:
        @deprecated("Use new_function() instead")
        fn old_function(x: i64) -> i64:
            return x * 2

    The first call will print a deprecation warning.
    """
    fn decorator(func):
        return DeprecatedFunction(func, message)
    return decorator


# Timeout Decorator (#1072)
#
# Enforces execution time limits using isolated threads

import concurrency.threads.{rt_thread_sleep, rt_thread_spawn_isolated, ThreadHandle}

# Result type for timeout execution
enum TimeoutResult:
    Success(value: Any)
    TimedOut

impl TimeoutResult:
    fn is_success() -> bool:
        match self:
            case Success(_): true
            case _: false

    fn is_timed_out() -> bool:
        match self:
            case TimedOut: true
            case _: false

    fn unwrap() -> Any:
        match self:
            case Success(v): v
            case TimedOut: panic("Called unwrap on TimedOut result")

    fn unwrap_or(default: Any) -> Any:
        match self:
            case Success(v): v
            case TimedOut: default

class TimeoutFunction:
    """Wrapper that enforces execution timeout using threads"""

    fn __init__(func, seconds):
        self.func = func
        self.timeout_seconds = seconds

    fn __call__(args...):
        """Call function with timeout enforcement.

        Spawns the function in an isolated thread and polls for completion.
        If the function doesn't complete within the timeout, returns None.

        Note: The spawned thread may continue running after timeout.
        """
        # Spawn function in isolated thread
        val handle = rt_thread_spawn_isolated(self.func, args)
        val thread = ThreadHandle(_handle: handle)

        # Calculate timeout in milliseconds
        val timeout_ms = (self.timeout_seconds * 1000) as i64
        val poll_interval_ms: i64 = 10  # Check every 10ms
        var elapsed_ms: i64 = 0

        # Poll for completion
        while elapsed_ms < timeout_ms:
            if thread.is_done():
                return thread.join()

            rt_thread_sleep(poll_interval_ms)
            elapsed_ms = elapsed_ms + poll_interval_ms

        # Timeout reached - function did not complete in time
        print("[TIMEOUT] Function exceeded {self.timeout_seconds}s timeout")
        return nil

    fn call_with_result(args...) -> TimeoutResult:
        """Call function and return TimeoutResult instead of nil on timeout."""
        val handle = rt_thread_spawn_isolated(self.func, args)
        val thread = ThreadHandle(_handle: handle)

        val timeout_ms = (self.timeout_seconds * 1000) as i64
        val poll_interval_ms: i64 = 10
        var elapsed_ms: i64 = 0

        while elapsed_ms < timeout_ms:
            if thread.is_done():
                return TimeoutResult.Success(thread.join())

            rt_thread_sleep(poll_interval_ms)
            elapsed_ms = elapsed_ms + poll_interval_ms

        return TimeoutResult.TimedOut

fn timeout(seconds):
    """
    Decorator that enforces execution timeout.

    Example:
        @timeout(5)
        fn slow_function():
            # ... work ...
            pass

        # Returns nil if function takes longer than 5 seconds
        result = slow_function()

        # Or use call_with_result for explicit timeout handling:
        @timeout(5)
        fn compute(x: i64) -> i64:
            return x * x

        match compute.call_with_result(10):
            case TimeoutResult.Success(v):
                print("Got result: {v}")
            case TimeoutResult.TimedOut:
                print("Function timed out")
    """
    fn decorator(func):
        return TimeoutFunction(func, seconds)
    return decorator
