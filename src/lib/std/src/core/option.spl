# Option Type - Represents optional values
# Core type for handling nullable values safely

enum Option<T>:
    Some(T)
    None

impl Option<T>:
    # Check if option has a value
    @pure
    fn is_some() -> bool:
        match self:
            case Some(_): return true
            case None: return false

    @pure
    fn is_none() -> bool:
        return not self.is_some()

    # Unwrap with panic on None - prefer expect() for better error messages
    @pure
    fn unwrap() -> T:
        match self:
            case Some(v): return v
            case None: panic("called unwrap on None")

    # Unwrap with custom panic message - preferred over unwrap()
    @pure
    fn expect(msg: str) -> T:
        match self:
            case Some(v): return v
            case None: panic(msg)

    # Unwrap with default value
    @pure
    fn unwrap_or(default_value: T) -> T:
        match self:
            case Some(v): return v
            case None: return default_value

    # Unwrap with lazy default
    @pure
    fn unwrap_or_else(f: fn() -> T) -> T:
        match self:
            case Some(v): return v
            case None: return f()

    # Map the inner value
    @pure
    fn map<U>(self, f: fn(T) -> U) -> Option<U>:
        match self:
            case Some(v): return Some(f(v))
            case None: return None

    # Flat map (also known as and_then in Rust, but 'and' is a keyword in Simple)
    @pure
    fn flat_map<U>(self, f: fn(T) -> Option<U>) -> Option<U>:
        match self:
            case Some(v): return f(v)
            case None: return None

    # Filter - returns new Option (immutable operation)
    @pure
    fn filtered(predicate: fn(&T) -> bool) -> Option<T>:
        match self:
            case Some(v):
                if predicate(&v):
                    return Some(v)
                return None
            case None:
                return None

    # Or combinator
    @pure
    fn or(other: Option<T>) -> Option<T>:
        match self:
            case Some(_): return self
            case None: return other

    # Or with lazy evaluation
    @pure
    fn or_else(f: fn() -> Option<T>) -> Option<T>:
        match self:
            case Some(_): return self
            case None: return f()

    # Get reference to inner value
    @pure
    fn as_ref() -> Option<&T>:
        match self:
            case Some(v): return Some(&v)
            case None: return None

    # Convert to Result
    @pure
    fn ok_or<E>(self, err: E) -> Result<T, E>:
        match self:
            case Some(v): return Ok(v)
            case None: return Err(err)

    @pure
    fn ok_or_else<E>(self, f: fn() -> E) -> Result<T, E>:
        match self:
            case Some(v): return Ok(v)
            case None: return Err(f())

    # Take value, leaving None
    fn take() -> Option<T>:
        val result = self
        self = None
        return result

    # Replace value (renamed from 'replace' due to parser issue)
    fn set_value(value: T) -> Option<T>:
        val previous = self
        self = Some(value)
        return previous

    # Zip with another option - tuple types in generics now supported
    fn zip<U>(other: Option<U>) -> Option<(T, U)>:
        match (self, other):
            case (Some(a), Some(b)): return Some((a, b))
            case _: return None

    # Flatten nested option
    # Note: self type annotation removed due to parser issue with nested generics
    @pure
    fn flatten() -> Option<T>:
        match self:
            case Some(inner): return inner
            case None: return None

    # Convert to array (0 or 1 elements)
    @pure
    fn to_array() -> Array<T>:
        match self:
            case Some(v): return [v]
            case None: return []

    # =========================================================================
    # Helper Methods
    # =========================================================================

    @pure
    fn get() -> &T:
        """Get reference to inner value, panic if None.

        Returns:
            Reference to contained value

        Example:
            opt = Some(42)
            opt.get()  # → &42
            None.get()  # → panic!

        Note:
            Prefer expect() for better error messages
        """
        match self:
            case Some(v): return &v
            case None: panic("called get() on None")

    @pure
    fn get_or(default_ref: &T) -> &T:
        """Get reference to inner value or default reference.

        Returns:
            Reference to value if Some, else default reference

        Example:
            Some(42).get_or(&0)  # → &42
            None.get_or(&0)      # → &0
        """
        match self:
            case Some(v): return &v
            case None: return default_ref

    @pure
    fn contains(value: &T) -> bool:
        """Check if option contains specific value.

        Returns:
            true if Some(value) matches

        Example:
            Some(42).contains(&42)  # → true
            Some(42).contains(&43)  # → false
            None.contains(&42)      # → false
        """
        match self:
            case Some(v): return &v == value
            case None: return false

    @pure
    fn exclusive_or(other: Option<T>) -> Option<T>:
        """Exclusive or - returns Some if exactly one option is Some.

        Returns:
            Some if exactly one is Some, None if both or neither

        Example:
            Some(1).exclusive_or(None)      # → Some(1)
            None.exclusive_or(Some(2))      # → Some(2)
            Some(1).exclusive_or(Some(2))   # → None
            None.exclusive_or(None)         # → None
        """
        match (self, other):
            case (Some(a), None): return Some(a)
            case (None, Some(b)): return Some(b)
            case _: return None

    @pure
    fn cloned() -> Option<T>:
        """Clone inner value if Some (requires T: Clone).

        Returns:
            Option with cloned value

        Example:
            opt = Some(vec![1, 2, 3])
            cloned = opt.cloned()  # → Some(vec![1, 2, 3])
        """
        match self:
            case Some(v): return Some(v.clone())
            case None: return None

    @pure
    fn copied() -> Option<T>:
        """Copy inner value if Some (requires T: Copy).

        Returns:
            Option with copied value

        Example:
            opt = Some(42)
            copied = opt.copied()  # → Some(42)
        """
        match self:
            case Some(v): return Some(v)  # Copy happens implicitly
            case None: return None

    @pure
    fn summary() -> text:
        """Get summary of option.

        Returns:
            Human-readable summary

        Example:
            Some(42).summary()  # → "Some(42)"
            None.summary()      # → "None"
        """
        match self:
            case Some(v):
                return "Some({v})"
            case None:
                return "None"

# Helper functions
@pure
fn some<T>(value: T) -> Option<T>:
    return Some(value)

@pure
fn none<T>() -> Option<T>:
    return None
