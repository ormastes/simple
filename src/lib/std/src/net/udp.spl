# UDP networking for Simple language using monoio
# Provides async UDP socket capabilities
# Feature: #1754 (Simple Language UDP API)

import core.result
import core.option
import net.{NetError, error_from_code}
import units.size.ByteCount

# External UDP functions
extern fn monoio_udp_bind(addr: text) -> i64
extern fn monoio_udp_connect(socket_handle: i64, addr: text) -> i64
extern fn monoio_udp_send_to(socket_handle: i64, buffer: any, addr: text) -> i64
extern fn monoio_udp_recv_from(socket_handle: i64, buffer: any, max_len: i64) -> Option<(i64, text)>
extern fn monoio_udp_send(socket_handle: i64, buffer: any) -> i64
extern fn monoio_udp_recv(socket_handle: i64, buffer: any, max_len: i64) -> i64
extern fn monoio_udp_close(socket_handle: i64) -> i64
extern fn monoio_udp_local_addr(socket_handle: i64) -> Option<text>
extern fn monoio_udp_set_broadcast(socket_handle: i64, broadcast: i64) -> i64
extern fn monoio_udp_set_multicast_ttl(socket_handle: i64, ttl: i64) -> i64
extern fn monoio_udp_join_multicast(socket_handle: i64, multicast_addr: text, interface_addr: text) -> i64
extern fn monoio_udp_leave_multicast(socket_handle: i64, multicast_addr: text, interface_addr: text) -> i64

# UDP socket for sending and receiving datagrams
pub struct UdpSocket:
    handle: i64
    local_addr: Option<text>
    is_connected: bool

    # Bind a UDP socket to an address
    # Feature #1745: UDP socket implementation
    #
    # Example:
    #   val socket = await UdpSocket.bind("0.0.0.0:0")?  # Bind to any port
    pub async fn bind(addr: text) -> Result<UdpSocket, NetError>:
        val handle = monoio_udp_bind(addr)
        if handle < 0:
            return Err(error_from_code(handle))

        val local = monoio_udp_local_addr(handle)

        return Ok(UdpSocket {
            handle: handle,
            local_addr: local,
            is_connected: false
        })

    # Send data to a specific address
    # Feature #1746: UDP send operations
    #
    # Returns number of bytes sent
    #
    # Example:
    #   val data = "Hello, UDP!".as_bytes()
    #   val n = await socket.send_to(data, "127.0.0.1:8080")?
    pub async fn send_to(self, buffer: any, addr: text) -> Result<ByteCount, NetError>:
        val n = monoio_udp_send_to(self.handle, buffer, addr)
        if n < 0:
            return Err(error_from_code(n))
        val bytes_sent = ByteCount.from_i64(n)
        return Ok(bytes_sent)

    # Receive data from any sender
    # Feature #1747: UDP receive operations
    #
    # Returns (bytes_received, sender_address)
    #
    # Example:
    #   var buffer = Bytes.with_capacity(1024_bytes)
    #   val (n, peer) = await socket.recv_from(&mut buffer, 1024_bytes)?
    pub async fn recv_from(self, buffer: &mut any, max_len: ByteCount) -> Result<(ByteCount, text), NetError>:
        val max_len_i64 = max_len.value() as i64
        val result = monoio_udp_recv_from(self.handle, buffer, max_len_i64)

        match result:
            case Some((n, addr)):
                if n < 0:
                    return Err(error_from_code(n))
                val bytes_received = ByteCount.from_i64(n)
                return Ok((bytes_received, addr))
            case None:
                return Err(NetError.IoError("recv_from failed"))

    # Connect the socket to a specific peer
    # After connecting, can use send() and recv() instead of send_to() and recv_from()
    # Feature #1748: UDP connected sockets
    #
    # Example:
    #   await socket.connect("127.0.0.1:8080")?
    #   await socket.send(data)?  # Now can use send() directly
    pub async fn connect(self, addr: text) -> Result<(), NetError>:
        val result = monoio_udp_connect(self.handle, addr)
        if result < 0:
            return Err(error_from_code(result))

        self.is_connected = true
        return Ok(())

    # Send data to connected peer
    # Socket must be connected first via connect()
    #
    # Example:
    #   await socket.connect("127.0.0.1:8080")?
    #   val n = await socket.send(data)?
    pub async fn send(self, buffer: any) -> Result<ByteCount, NetError>:
        if not self.is_connected:
            return Err(NetError.NotConnected)

        val n = monoio_udp_send(self.handle, buffer)
        if n < 0:
            return Err(error_from_code(n))
        val bytes_sent = ByteCount.from_i64(n)
        return Ok(bytes_sent)

    # Receive data from connected peer
    # Socket must be connected first via connect()
    #
    # Example:
    #   await socket.connect("127.0.0.1:8080")?
    #   val n = await socket.recv(&mut buffer, 1024_bytes)?
    pub async fn recv(self, buffer: &mut any, max_len: ByteCount) -> Result<ByteCount, NetError>:
        if not self.is_connected:
            return Err(NetError.NotConnected)

        val max_len_i64 = max_len.value() as i64
        val n = monoio_udp_recv(self.handle, buffer, max_len_i64)
        if n < 0:
            return Err(error_from_code(n))
        val bytes_received = ByteCount.from_i64(n)
        return Ok(bytes_received)

    # Get local address the socket is bound to
    pub fn local_addr(self) -> Option<text>:
        return self.local_addr

    # Check if socket is connected to a peer
    pub fn is_connected(self) -> bool:
        return self.is_connected

    # Close the socket
    # Feature #1749: UDP socket management
    pub fn close(self) -> Result<(), NetError>:
        val result = monoio_udp_close(self.handle)
        if result < 0:
            return Err(error_from_code(result))
        return Ok(())

    # Set broadcast option
    # When enabled, allows sending to broadcast addresses
    # Feature #1749: UDP socket management
    #
    # Example:
    #   socket.set_broadcast(true)?
    #   await socket.send_to(data, "255.255.255.255:8080")?
    pub fn set_broadcast(self, enabled: bool) -> Result<(), NetError>:
        val value = if enabled: 1 else: 0
        val result = monoio_udp_set_broadcast(self.handle, value)
        if result < 0:
            return Err(error_from_code(result))
        return Ok(())

    # Set multicast TTL (time-to-live)
    # Controls how many routers multicast packets can traverse
    #
    # Example:
    #   socket.set_multicast_ttl(32)?  # TTL of 32 hops
    pub fn set_multicast_ttl(self, ttl: i64) -> Result<(), NetError>:
        if ttl < 0 or ttl > 255:
            return Err(NetError.IoError("TTL must be 0-255"))

        val result = monoio_udp_set_multicast_ttl(self.handle, ttl)
        if result < 0:
            return Err(error_from_code(result))
        return Ok(())

    # Join a multicast group
    # After joining, will receive packets sent to the multicast address
    #
    # Example:
    #   # Join multicast group 239.255.0.1 on interface 0.0.0.0 (any)
    #   socket.join_multicast("239.255.0.1", "0.0.0.0")?
    pub fn join_multicast(self, multicast_addr: text, interface_addr: text) -> Result<(), NetError>:
        val result = monoio_udp_join_multicast(self.handle, multicast_addr, interface_addr)
        if result < 0:
            return Err(error_from_code(result))
        return Ok(())

    # Leave a multicast group
    # Stops receiving packets sent to the multicast address
    #
    # Example:
    #   socket.leave_multicast("239.255.0.1", "0.0.0.0")?
    pub fn leave_multicast(self, multicast_addr: text, interface_addr: text) -> Result<(), NetError>:
        val result = monoio_udp_leave_multicast(self.handle, multicast_addr, interface_addr)
        if result < 0:
            return Err(error_from_code(result))
        return Ok(())

    # Check if socket has local address
    pub fn has_local_addr(self) -> bool:
        """Check if local address is available.

        Returns:
            True if local_addr is Some

        Example:
            if socket.has_local_addr():
                print("Bound to: " + socket.local_addr().unwrap())
        """
        match self.local_addr:
            case Some(_):
                return true
            case None:
                return false

    # Check if socket has valid handle
    pub fn is_valid(self) -> bool:
        """Check if socket handle is valid.

        Returns:
            True if handle is valid (non-negative)
        """
        return self.handle >= 0

    # Get socket summary
    pub fn summary(self) -> text:
        """Get socket summary.

        Returns:
            Human-readable summary

        Example:
            socket.summary()
            # → "UdpSocket: 0.0.0.0:8080 (connected)"
            # → "UdpSocket: 0.0.0.0:8080 (unconnected)"
        """
        val local_str = match self.local_addr:
            case Some(addr):
                addr
            case None:
                "(unbound)"

        val status = if self.is_connected:
            "(connected)"
        else:
            "(unconnected)"

        return "UdpSocket: " + local_str + " " + status

# Common multicast addresses for reference:
# - 224.0.0.0 - 224.0.0.255: Local network control
# - 224.0.1.0 - 238.255.255.255: Internetwork control
# - 239.0.0.0 - 239.255.255.255: Organization-local scope
