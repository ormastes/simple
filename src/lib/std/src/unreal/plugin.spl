# Unreal Plugin Structure
#
# Generates .uplugin manifest files for Unreal Engine plugins
#
# Features:
# - Plugin descriptor generation
# - Module configuration
# - Dependency management
# - Version management
#
# Based on: https://docs.unrealengine.com/5.4/en-US/plugins-in-unreal-engine/

import sys.io
import sys.json

mod plugin

# PluginType
# Type of Unreal plugin
pub enum PluginType:
    Runtime = 0         # Runtime plugin (game code)
    Editor = 1          # Editor-only plugin
    Developer = 2       # Developer tools
    ThirdParty = 3      # Third-party library

impl PluginType:
    # =========================================================================
    # Helper Methods
    # =========================================================================

    pub fn is_runtime(self) -> bool:
        """Check if plugin type is Runtime.

        Returns:
            true for Runtime

        Example:
            PluginType.Runtime.is_runtime()  # → true
        """
        return self == PluginType.Runtime

    pub fn is_editor(self) -> bool:
        """Check if plugin type is Editor.

        Returns:
            true for Editor

        Example:
            PluginType.Editor.is_editor()  # → true
        """
        return self == PluginType.Editor

    pub fn is_developer(self) -> bool:
        """Check if plugin type is Developer.

        Returns:
            true for Developer

        Example:
            PluginType.Developer.is_developer()  # → true
        """
        return self == PluginType.Developer

    pub fn is_third_party(self) -> bool:
        """Check if plugin type is ThirdParty.

        Returns:
            true for ThirdParty

        Example:
            PluginType.ThirdParty.is_third_party()  # → true
        """
        return self == PluginType.ThirdParty

    pub fn is_game_plugin(self) -> bool:
        """Check if plugin is for game runtime.

        Returns:
            true for Runtime

        Example:
            PluginType.Runtime.is_game_plugin()  # → true
        """
        return self == PluginType.Runtime

    pub fn is_editor_only(self) -> bool:
        """Check if plugin is editor-only.

        Returns:
            true for Editor or Developer

        Example:
            PluginType.Editor.is_editor_only()  # → true
        """
        return self == PluginType.Editor or self == PluginType.Developer

    pub fn to_string(self) -> text:
        """Convert plugin type to string.

        Returns:
            Plugin type name

        Example:
            PluginType.Runtime.to_string()  # → "Runtime"
        """
        if self == PluginType.Runtime:
            return "Runtime"
        elif self == PluginType.Editor:
            return "Editor"
        elif self == PluginType.Developer:
            return "Developer"
        else:
            return "ThirdParty"

    pub fn description(self) -> text:
        """Get plugin type description.

        Returns:
            Human-readable description

        Example:
            PluginType.Runtime.description()
            # → "Runtime plugin (game code)"
        """
        if self == PluginType.Runtime:
            return "Runtime plugin (game code)"
        elif self == PluginType.Editor:
            return "Editor-only plugin"
        elif self == PluginType.Developer:
            return "Developer tools plugin"
        else:
            return "Third-party library plugin"

    pub fn summary(self) -> text:
        """Get plugin type summary.

        Returns:
            Human-readable summary

        Example:
            PluginType.Runtime.summary()
            # → "PluginType: Runtime (Runtime plugin (game code), game plugin)"
        """
        val name = self.to_string()
        val desc = self.description()
        val category = if self.is_game_plugin():
            "game plugin"
        elif self.is_editor_only():
            "editor-only"
        else:
            "third-party"
        return "PluginType: {name} ({desc}, {category})"


# ModuleDescriptor
# Describes a module within a plugin
pub struct ModuleDescriptor:
    name: text
    module_type: text
    loading_phase: text

impl ModuleDescriptor:
    pub fn new(name: text) -> ModuleDescriptor:
        return ModuleDescriptor(
            name: name,
            module_type: "Runtime",
            loading_phase: "Default",
        )

    pub fn module_type(mut self, module_type: text) -> ModuleDescriptor:
        self.module_type = module_type
        return self

    pub fn loading_phase(mut self, phase: text) -> ModuleDescriptor:
        self.loading_phase = phase
        return self

    # Convert to JSON object
    pub fn to_json(self) -> JsonObject:
        var obj = JsonObject.new()
        obj.set("Name", JsonValue.text(self.name))
        obj.set("Type", JsonValue.text(self.module_type))
        obj.set("LoadingPhase", JsonValue.text(self.loading_phase))
        return obj


# PluginDependency
# Describes a dependency on another plugin
pub struct PluginDependency:
    name: text
    enabled: bool
    optional: bool

impl PluginDependency:
    pub fn new(name: text) -> PluginDependency:
        return PluginDependency(
            name: name,
            enabled: true,
            optional: false,
        )

    pub fn optional(mut self) -> PluginDependency:
        self.optional = true
        return self

    pub fn disabled(mut self) -> PluginDependency:
        self.enabled = false
        return self

    # Convert to JSON object
    pub fn to_json(self) -> JsonObject:
        var obj = JsonObject.new()
        obj.set("Name", JsonValue.text(self.name))
        obj.set("Enabled", JsonValue.bool(self.enabled))
        if self.optional:
            obj.set("Optional", JsonValue.bool(true))
        return obj


# PluginDescriptor
# Complete .uplugin file descriptor
pub struct PluginDescriptor:
    file_version: i32
    version: i32
    version_name: text
    friendly_name: text
    description: text
    category: text
    created_by: text
    created_by_url: text
    documentation_url: text
    marketplace_url: text
    support_url: text
    can_contain_content: bool
    is_beta_version: bool
    is_experimental_version: bool
    modules: Vec<ModuleDescriptor>
    plugins: Vec<PluginDependency>

impl PluginDescriptor:
    # Create new plugin descriptor
    pub fn new(friendly_name: text, description: text) -> PluginDescriptor:
        return PluginDescriptor(
            file_version: 3,
            version: 1,
            version_name: "1.0",
            friendly_name: friendly_name,
            description: description,
            category: "Other",
            created_by: "",
            created_by_url: "",
            documentation_url: "",
            marketplace_url: "",
            support_url: "",
            can_contain_content: false,
            is_beta_version: false,
            is_experimental_version: false,
            modules: [],
            plugins: [],
        )

    # Set version
    pub fn version(mut self, version: i32, version_name: text) -> PluginDescriptor:
        self.version = version
        self.version_name = version_name
        return self

    # Set category
    pub fn category(mut self, category: text) -> PluginDescriptor:
        self.category = category
        return self

    # Set created by
    pub fn created_by(mut self, name: text, url: text) -> PluginDescriptor:
        self.created_by = name
        self.created_by_url = url
        return self

    # Set documentation URL
    pub fn documentation_url(mut self, url: text) -> PluginDescriptor:
        self.documentation_url = url
        return self

    # Enable content
    pub fn can_contain_content(mut self) -> PluginDescriptor:
        self.can_contain_content = true
        return self

    # Mark as beta
    pub fn beta(mut self) -> PluginDescriptor:
        self.is_beta_version = true
        return self

    # Mark as experimental
    pub fn experimental(mut self) -> PluginDescriptor:
        self.is_experimental_version = true
        return self

    # Add module
    pub fn add_module(mut self, module: ModuleDescriptor) -> PluginDescriptor:
        self.modules.push(module)
        return self

    # Add dependency
    pub fn add_dependency(mut self, dependency: PluginDependency) -> PluginDescriptor:
        self.plugins.push(dependency)
        return self

    # Generate JSON string
    pub fn generate(self) -> text:
        var root = JsonObject.new()

        # Basic metadata
        root.set("FileVersion", JsonValue.i32(self.file_version))
        root.set("Version", JsonValue.i32(self.version))
        root.set("VersionName", JsonValue.text(self.version_name))
        root.set("FriendlyName", JsonValue.text(self.friendly_name))
        root.set("Description", JsonValue.text(self.description))
        root.set("Category", JsonValue.text(self.category))

        # Optional fields
        if self.created_by != "":
            root.set("CreatedBy", JsonValue.text(self.created_by))
        if self.created_by_url != "":
            root.set("CreatedByURL", JsonValue.text(self.created_by_url))
        if self.documentation_url != "":
            root.set("DocsURL", JsonValue.text(self.documentation_url))
        if self.marketplace_url != "":
            root.set("MarketplaceURL", JsonValue.text(self.marketplace_url))
        if self.support_url != "":
            root.set("SupportURL", JsonValue.text(self.support_url))

        # Flags
        root.set("CanContainContent", JsonValue.bool(self.can_contain_content))
        root.set("IsBetaVersion", JsonValue.bool(self.is_beta_version))
        root.set("IsExperimentalVersion", JsonValue.bool(self.is_experimental_version))

        # Modules array
        if self.modules.len() > 0:
            var modules_array = JsonArray.new()
            for module in self.modules:
                modules_array.push(JsonValue.Object(module.to_json()))
            root.set("Modules", JsonValue.Array(modules_array))

        # Plugins array (dependencies)
        if self.plugins.len() > 0:
            var plugins_array = JsonArray.new()
            for plugin in self.plugins:
                plugins_array.push(JsonValue.Object(plugin.to_json()))
            root.set("Plugins", JsonValue.Array(plugins_array))

        return json.stringify(JsonValue.Object(root), indent: 2)

    # Write to file
    pub fn write_to_file(self, output_path: text) -> bool:
        val content = self.generate()
        return io.write_file(output_path, content)


# Plugin categories
pub const CATEGORY_BLUEPRINT: text = "Blueprints"
pub const CATEGORY_CONTENT: text = "Content"
pub const CATEGORY_DEVELOPER: text = "Developer"
pub const CATEGORY_EDITOR: text = "Editor"
pub const CATEGORY_GAMEPLAY: text = "Gameplay"
pub const CATEGORY_RENDERING: text = "Rendering"
pub const CATEGORY_SCRIPTING: text = "Scripting"
pub const CATEGORY_TOOL: text = "Tool"


# Preset generators

# Generate a basic runtime plugin
pub fn generate_runtime_plugin(name: text, description: text) -> text:
    val module = ModuleDescriptor.new(name)
        .module_type("Runtime")
        .loading_phase("Default")

    return PluginDescriptor.new(name, description)
        .category(CATEGORY_GAMEPLAY)
        .add_module(module)
        .generate()

# Generate an editor plugin
pub fn generate_editor_plugin(name: text, description: text) -> text:
    val module = ModuleDescriptor.new(name)
        .module_type("Editor")
        .loading_phase("Default")

    return PluginDescriptor.new(name, description)
        .category(CATEGORY_EDITOR)
        .add_module(module)
        .generate()

# Generate a content plugin
pub fn generate_content_plugin(name: text, description: text) -> text:
    return PluginDescriptor.new(name, description)
        .category(CATEGORY_CONTENT)
        .can_contain_content()
        .generate()

# Generate a Simple language plugin
pub fn generate_simple_plugin(name: text) -> text:
    val runtime_module = ModuleDescriptor.new(name)
        .module_type("Runtime")

    val editor_module = ModuleDescriptor.new(name + "Editor")
        .module_type("Editor")

    return PluginDescriptor.new(name, "Simple Language Integration Plugin")
        .category(CATEGORY_SCRIPTING)
        .created_by("Simple Language Project", "https://simple-lang.org")
        .add_module(runtime_module)
        .add_module(editor_module)
        .experimental()
        .generate()


# Placeholder JSON types (to be replaced with actual JSON library)

pub struct JsonObject:
    fields: Vec<(text, JsonValue)>

impl JsonObject:
    pub fn new() -> JsonObject:
        return JsonObject(fields: [])

    pub fn set(mut self, key: text, value: JsonValue):
        self.fields.push((key, value))

pub struct JsonArray:
    items: Vec<JsonValue>

impl JsonArray:
    pub fn new() -> JsonArray:
        return JsonArray(items: [])

    pub fn push(mut self, value: JsonValue):
        self.items.push(value)

pub enum JsonValue:
    text(text)
    i32(i32)
    bool(bool)
    Object(JsonObject)
    Array(JsonArray)

impl JsonValue:
    # =========================================================================
    # Helper Methods
    # =========================================================================

    pub fn is_string(self) -> bool:
        """Check if value is a string.

        Returns:
            true for text variant

        Example:
            JsonValue.text("hello").is_string()  # → true
        """
        match self:
            case text(_): true
            case _: false

    pub fn is_int(self) -> bool:
        """Check if value is an integer.

        Returns:
            true for i32 variant

        Example:
            JsonValue.i32(42).is_int()  # → true
        """
        match self:
            case i32(_): true
            case _: false

    pub fn is_bool(self) -> bool:
        """Check if value is a boolean.

        Returns:
            true for bool variant

        Example:
            JsonValue.bool(true).is_bool()  # → true
        """
        match self:
            case bool(_): true
            case _: false

    pub fn is_object(self) -> bool:
        """Check if value is an object.

        Returns:
            true for Object variant

        Example:
            JsonValue.Object(obj).is_object()  # → true
        """
        match self:
            case Object(_): true
            case _: false

    pub fn is_array(self) -> bool:
        """Check if value is an array.

        Returns:
            true for Array variant

        Example:
            JsonValue.Array(arr).is_array()  # → true
        """
        match self:
            case Array(_): true
            case _: false

    pub fn is_primitive(self) -> bool:
        """Check if value is a primitive type.

        Returns:
            true for text, i32, or bool

        Example:
            JsonValue.text("test").is_primitive()  # → true
            JsonValue.Object(obj).is_primitive()  # → false
        """
        match self:
            case text(_): true
            case i32(_): true
            case bool(_): true
            case _: false

    pub fn is_composite(self) -> bool:
        """Check if value is a composite type.

        Returns:
            true for Object or Array

        Example:
            JsonValue.Array(arr).is_composite()  # → true
        """
        match self:
            case Object(_): true
            case Array(_): true
            case _: false

    pub fn to_string(self) -> text:
        """Convert JSON value type to string.

        Returns:
            Type name

        Example:
            JsonValue.i32(42).to_string()  # → "i32"
        """
        match self:
            case text(_): "string"
            case i32(_): "i32"
            case bool(_): "bool"
            case Object(_): "object"
            case Array(_): "array"

    pub fn description(self) -> text:
        """Get JSON value type description.

        Returns:
            Human-readable description

        Example:
            JsonValue.Object(obj).description()
            # → "JSON object"
        """
        match self:
            case text(_): "JSON string"
            case i32(_): "JSON integer"
            case bool(_): "JSON boolean"
            case Object(_): "JSON object"
            case Array(_): "JSON array"

    pub fn summary(self) -> text:
        """Get JSON value summary.

        Returns:
            Human-readable summary

        Example:
            JsonValue.Array(arr).summary()
            # → "JsonValue: array (JSON array, composite)"
        """
        val type_name = self.to_string()
        val desc = self.description()
        val category = if self.is_primitive():
            "primitive"
        else:
            "composite"
        return "JsonValue: {type_name} ({desc}, {category})"
