# Unreal UActorComponent Wrapper
#
# Type-safe wrapper for Unreal Engine's UActorComponent base class
#
# Features:
# - Component lifecycle (OnRegister, BeginPlay, Tick, EndPlay)
# - Transform manipulation (relative and world space)
# - Component attachment
# - Activation state management
# - Replication support
#
# Based on: https://docs.unrealengine.org/5.4/en-US/API/Runtime/Engine/Components/UActorComponent/

import sys.ffi

mod component

# ComponentPtr
# Opaque pointer to Unreal UActorComponent instance
pub struct ComponentPtr:
    ptr: ffi.VoidPtr

impl ComponentPtr:
    pub fn from_ptr(ptr: ffi.VoidPtr) -> ComponentPtr:
        return ComponentPtr(ptr: ptr)

    pub fn as_ptr(self) -> ffi.VoidPtr:
        return self.ptr

    pub fn is_valid(self) -> bool:
        return self.ptr != ffi.null_ptr()


# UActorComponent
# Base class for all actor components
pub struct UActorComponent:
    component_ptr: ComponentPtr

impl UActorComponent:
    # Create from existing component pointer
    pub fn from_ptr(ptr: ffi.VoidPtr) -> UActorComponent:
        return UActorComponent(component_ptr: ComponentPtr.from_ptr(ptr))

    # Get raw pointer
    pub fn as_ptr(self) -> ffi.VoidPtr:
        return self.component_ptr.as_ptr()

    # Check if component is valid
    pub fn is_valid(self) -> bool:
        return self.component_ptr.is_valid()

    # === Lifecycle Methods ===

    # Activate component
    pub fn activate(mut self, reset: bool = false):
        unreal_component_activate(self.as_ptr(), reset)

    # Deactivate component
    pub fn deactivate(mut self):
        unreal_component_deactivate(self.as_ptr())

    # Check if component is active
    pub fn is_active(self) -> bool:
        return unreal_component_is_active(self.as_ptr())

    # Destroy component
    pub fn destroy_component(mut self):
        unreal_component_destroy(self.as_ptr())

    # === Tick Methods ===

    # Set component tick enabled
    pub fn set_component_tick_enabled(mut self, enabled: bool):
        unreal_component_set_tick_enabled(self.as_ptr(), enabled)

    # Check if component tick is enabled
    pub fn is_component_tick_enabled(self) -> bool:
        return unreal_component_is_tick_enabled(self.as_ptr())

    # Set tick interval
    pub fn set_component_tick_interval(mut self, interval: f32):
        unreal_component_set_tick_interval(self.as_ptr(), interval)

    # === Owner Methods ===

    # Get owner actor
    pub fn get_owner(self) -> ffi.VoidPtr:
        return unreal_component_get_owner(self.as_ptr())

    # Get component name
    pub fn get_name(self) -> text:
        val name_ptr = unreal_component_get_name(self.as_ptr())
        val name = ffi.string_from_ptr(name_ptr)
        ffi.free_string(name_ptr)
        return name

    # === Networking Methods ===

    # Set replicates
    pub fn set_is_replicated(mut self, replicates: bool):
        unreal_component_set_is_replicated(self.as_ptr(), replicates)

    # Check if component replicates
    pub fn is_replicated(self) -> bool:
        return unreal_component_is_replicated(self.as_ptr())


# USceneComponent
# Scene component with transform
pub struct USceneComponent:
    base: UActorComponent

impl USceneComponent:
    pub fn from_ptr(ptr: ffi.VoidPtr) -> USceneComponent:
        return USceneComponent(base: UActorComponent.from_ptr(ptr))

    pub fn as_ptr(self) -> ffi.VoidPtr:
        return self.base.as_ptr()

    pub fn as_component(self) -> UActorComponent:
        return self.base

    # === Transform Methods (Relative) ===

    # Get relative location
    pub fn get_relative_location(self) -> (f64, f64, f64):
        val x = ffi.alloc_f64()
        val y = ffi.alloc_f64()
        val z = ffi.alloc_f64()
        unreal_scene_component_get_relative_location(self.as_ptr(), x, y, z)
        val result = (ffi.read_f64(x), ffi.read_f64(y), ffi.read_f64(z))
        ffi.free(x)
        ffi.free(y)
        ffi.free(z)
        return result

    # Set relative location
    pub fn set_relative_location(mut self, x: f64, y: f64, z: f64):
        unreal_scene_component_set_relative_location(self.as_ptr(), x, y, z)

    # Get relative rotation
    pub fn get_relative_rotation(self) -> (f64, f64, f64):
        val pitch = ffi.alloc_f64()
        val yaw = ffi.alloc_f64()
        val roll = ffi.alloc_f64()
        unreal_scene_component_get_relative_rotation(self.as_ptr(), pitch, yaw, roll)
        val result = (ffi.read_f64(pitch), ffi.read_f64(yaw), ffi.read_f64(roll))
        ffi.free(pitch)
        ffi.free(yaw)
        ffi.free(roll)
        return result

    # Set relative rotation
    pub fn set_relative_rotation(mut self, pitch: f64, yaw: f64, roll: f64):
        unreal_scene_component_set_relative_rotation(self.as_ptr(), pitch, yaw, roll)

    # Get relative scale
    pub fn get_relative_scale(self) -> (f64, f64, f64):
        val x = ffi.alloc_f64()
        val y = ffi.alloc_f64()
        val z = ffi.alloc_f64()
        unreal_scene_component_get_relative_scale(self.as_ptr(), x, y, z)
        val result = (ffi.read_f64(x), ffi.read_f64(y), ffi.read_f64(z))
        ffi.free(x)
        ffi.free(y)
        ffi.free(z)
        return result

    # Set relative scale
    pub fn set_relative_scale(mut self, x: f64, y: f64, z: f64):
        unreal_scene_component_set_relative_scale(self.as_ptr(), x, y, z)

    # === Transform Methods (World) ===

    # Get world location
    pub fn get_world_location(self) -> (f64, f64, f64):
        val x = ffi.alloc_f64()
        val y = ffi.alloc_f64()
        val z = ffi.alloc_f64()
        unreal_scene_component_get_world_location(self.as_ptr(), x, y, z)
        val result = (ffi.read_f64(x), ffi.read_f64(y), ffi.read_f64(z))
        ffi.free(x)
        ffi.free(y)
        ffi.free(z)
        return result

    # Set world location
    pub fn set_world_location(mut self, x: f64, y: f64, z: f64):
        unreal_scene_component_set_world_location(self.as_ptr(), x, y, z)

    # Get world rotation
    pub fn get_world_rotation(self) -> (f64, f64, f64):
        val pitch = ffi.alloc_f64()
        val yaw = ffi.alloc_f64()
        val roll = ffi.alloc_f64()
        unreal_scene_component_get_world_rotation(self.as_ptr(), pitch, yaw, roll)
        val result = (ffi.read_f64(pitch), ffi.read_f64(yaw), ffi.read_f64(roll))
        ffi.free(pitch)
        ffi.free(yaw)
        ffi.free(roll)
        return result

    # Set world rotation
    pub fn set_world_rotation(mut self, pitch: f64, yaw: f64, roll: f64):
        unreal_scene_component_set_world_rotation(self.as_ptr(), pitch, yaw, roll)

    # === Attachment Methods ===

    # Attach to component
    pub fn attach_to_component(mut self, parent: USceneComponent, socket_name: text = ""):
        unreal_scene_component_attach_to(self.as_ptr(), parent.as_ptr(), socket_name)

    # Detach from parent
    pub fn detach_from_component(mut self):
        unreal_scene_component_detach(self.as_ptr())

    # Get parent component
    pub fn get_attach_parent(self) -> Option<USceneComponent>:
        val parent_ptr = unreal_scene_component_get_attach_parent(self.as_ptr())
        if parent_ptr == ffi.null_ptr():
            return None
        else:
            return Some(USceneComponent.from_ptr(parent_ptr))

    # === Visibility Methods ===

    # Set visibility
    pub fn set_visibility(mut self, visible: bool, propagate: bool = false):
        unreal_scene_component_set_visibility(self.as_ptr(), visible, propagate)

    # Check if visible
    pub fn is_visible(self) -> bool:
        return unreal_scene_component_is_visible(self.as_ptr())


# FFI function declarations (to be implemented in Rust/C++)

extern "C":
    # UActorComponent
    fn unreal_component_activate(component: ffi.VoidPtr, reset: bool)
    fn unreal_component_deactivate(component: ffi.VoidPtr)
    fn unreal_component_is_active(component: ffi.VoidPtr) -> bool
    fn unreal_component_destroy(component: ffi.VoidPtr)

    fn unreal_component_set_tick_enabled(component: ffi.VoidPtr, enabled: bool)
    fn unreal_component_is_tick_enabled(component: ffi.VoidPtr) -> bool
    fn unreal_component_set_tick_interval(component: ffi.VoidPtr, interval: f32)

    fn unreal_component_get_owner(component: ffi.VoidPtr) -> ffi.VoidPtr
    fn unreal_component_get_name(component: ffi.VoidPtr) -> ffi.VoidPtr

    fn unreal_component_set_is_replicated(component: ffi.VoidPtr, replicates: bool)
    fn unreal_component_is_replicated(component: ffi.VoidPtr) -> bool

    # USceneComponent - Relative transforms
    fn unreal_scene_component_get_relative_location(component: ffi.VoidPtr, x: ffi.VoidPtr, y: ffi.VoidPtr, z: ffi.VoidPtr)
    fn unreal_scene_component_set_relative_location(component: ffi.VoidPtr, x: f64, y: f64, z: f64)
    fn unreal_scene_component_get_relative_rotation(component: ffi.VoidPtr, pitch: ffi.VoidPtr, yaw: ffi.VoidPtr, roll: ffi.VoidPtr)
    fn unreal_scene_component_set_relative_rotation(component: ffi.VoidPtr, pitch: f64, yaw: f64, roll: f64)
    fn unreal_scene_component_get_relative_scale(component: ffi.VoidPtr, x: ffi.VoidPtr, y: ffi.VoidPtr, z: ffi.VoidPtr)
    fn unreal_scene_component_set_relative_scale(component: ffi.VoidPtr, x: f64, y: f64, z: f64)

    # USceneComponent - World transforms
    fn unreal_scene_component_get_world_location(component: ffi.VoidPtr, x: ffi.VoidPtr, y: ffi.VoidPtr, z: ffi.VoidPtr)
    fn unreal_scene_component_set_world_location(component: ffi.VoidPtr, x: f64, y: f64, z: f64)
    fn unreal_scene_component_get_world_rotation(component: ffi.VoidPtr, pitch: ffi.VoidPtr, yaw: ffi.VoidPtr, roll: ffi.VoidPtr)
    fn unreal_scene_component_set_world_rotation(component: ffi.VoidPtr, pitch: f64, yaw: f64, roll: f64)

    # USceneComponent - Attachment
    fn unreal_scene_component_attach_to(component: ffi.VoidPtr, parent: ffi.VoidPtr, socket_name: text)
    fn unreal_scene_component_detach(component: ffi.VoidPtr)
    fn unreal_scene_component_get_attach_parent(component: ffi.VoidPtr) -> ffi.VoidPtr

    # USceneComponent - Visibility
    fn unreal_scene_component_set_visibility(component: ffi.VoidPtr, visible: bool, propagate: bool)
    fn unreal_scene_component_is_visible(component: ffi.VoidPtr) -> bool
