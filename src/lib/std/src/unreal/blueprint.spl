# Unreal Blueprint Integration
#
# Runtime support for Blueprint-Simple interop
#
# Features:
# - Call Simple functions from Blueprint
# - Call Blueprint functions from Simple
# - Property synchronization (UPROPERTY)
# - Event dispatching and handling
# - Blueprint implementable events
#
# Based on: https://docs.unrealengine.org/5.4/en-US/blueprints-visual-scripting-in-unreal-engine/

import sys.ffi
import unreal.actor

mod blueprint

# PropertyValue
# Runtime value for Blueprint properties
pub enum PropertyValue:
    bool(bool)
    i32(i32)
    f32(f32)
    text(text)
    Object(ffi.VoidPtr)
    Vector(f64, f64, f64)
    Rotator(f64, f64, f64)

impl PropertyValue:
    # Extract bool value
    pub fn as_bool(self) -> bool:
        if self is PropertyValue.bool(value):
            return value
        else:
            return false

    # Extract i32 value
    pub fn as_int(self) -> i32:
        if self is PropertyValue.i32(value):
            return value
        else:
            return 0

    # Extract f32 value
    pub fn as_float(self) -> f32:
        if self is PropertyValue.f32(value):
            return value
        else:
            return 0.0

    # Extract string value
    pub fn as_string(self) -> text:
        if self is PropertyValue.text(value):
            return value
        else:
            return ""

    # Extract object pointer
    pub fn as_object(self) -> ffi.VoidPtr:
        if self is PropertyValue.Object(ptr):
            return ptr
        else:
            return ffi.null_ptr()

    # =========================================================================
    # Helper Methods
    # =========================================================================

    pub fn to_string(self) -> text:
        """Convert property value type to string.

        Returns:
            Type name

        Example:
            PropertyValue.bool(true).to_string()  # → "bool"
        """
        if self is PropertyValue.bool(_):
            return "bool"
        elif self is PropertyValue.i32(_):
            return "i32"
        elif self is PropertyValue.f32(_):
            return "f32"
        elif self is PropertyValue.text(_):
            return "string"
        elif self is PropertyValue.Object(_):
            return "object"
        elif self is PropertyValue.Vector(_, _, _):
            return "vector"
        else:
            return "rotator"

    pub fn description(self) -> text:
        """Get property value description.

        Returns:
            Human-readable description with value

        Example:
            PropertyValue.bool(true).description()  # → "Boolean: true"
        """
        if self is PropertyValue.bool(value):
            return "Boolean: {value}"
        elif self is PropertyValue.i32(value):
            return "Integer: {value}"
        elif self is PropertyValue.f32(value):
            return "f32: {value}"
        elif self is PropertyValue.text(value):
            return "text: \"{value}\""
        elif self is PropertyValue.Object(ptr):
            return "Object pointer"
        elif self is PropertyValue.Vector(x, y, z):
            return "Vector: ({x}, {y}, {z})"
        else:  # Rotator
            if self is PropertyValue.Rotator(pitch, yaw, roll):
                return "Rotator: (pitch={pitch}, yaw={yaw}, roll={roll})"
            else:
                return "Rotator"

    pub fn is_bool(self) -> bool:
        """Check if value is bool.

        Returns:
            True if bool variant
        """
        return self is PropertyValue.bool(_)

    pub fn is_int(self) -> bool:
        """Check if value is i32.

        Returns:
            True if i32 variant
        """
        return self is PropertyValue.i32(_)

    pub fn is_float(self) -> bool:
        """Check if value is f32.

        Returns:
            True if f32 variant
        """
        return self is PropertyValue.f32(_)

    pub fn is_string(self) -> bool:
        """Check if value is text.

        Returns:
            True if text variant
        """
        return self is PropertyValue.text(_)

    pub fn is_object(self) -> bool:
        """Check if value is Object.

        Returns:
            True if Object variant
        """
        return self is PropertyValue.Object(_)

    pub fn is_vector(self) -> bool:
        """Check if value is Vector.

        Returns:
            True if Vector variant
        """
        return self is PropertyValue.Vector(_, _, _)

    pub fn is_rotator(self) -> bool:
        """Check if value is Rotator.

        Returns:
            True if Rotator variant
        """
        return self is PropertyValue.Rotator(_, _, _)

    pub fn is_numeric(self) -> bool:
        """Check if value is numeric (i32 or f32).

        Returns:
            True if i32 or f32

        Example:
            PropertyValue.i32(42).is_numeric()  # → true
        """
        return self.is_int() or self.is_float()

    pub fn is_spatial(self) -> bool:
        """Check if value is spatial type (Vector or Rotator).

        Returns:
            True if Vector or Rotator

        Example:
            PropertyValue.Vector(1.0, 2.0, 3.0).is_spatial()  # → true
        """
        return self.is_vector() or self.is_rotator()

    pub fn is_primitive(self) -> bool:
        """Check if value is primitive type (bool, i32, f32, text).

        Returns:
            True if primitive type

        Example:
            PropertyValue.bool(true).is_primitive()  # → true
            PropertyValue.Object(ptr).is_primitive()  # → false
        """
        return self.is_bool() or self.is_int() or self.is_float() or self.is_string()

    pub fn summary(self) -> text:
        """Get property value summary.

        Returns:
            Human-readable summary

        Example:
            PropertyValue.i32(42).summary()
            # → "PropertyValue: i32 (Integer: 42, numeric, primitive)"
        """
        val type_name = self.to_string()
        val desc = self.description()
        var props = []

        if self.is_numeric():
            props.push("numeric")
        if self.is_spatial():
            props.push("spatial")
        if self.is_primitive():
            props.push("primitive")

        if props.len() > 0:
            val props_str = ", ".join(props)
            return "PropertyValue: {type_name} ({desc}, {props_str})"
        else:
            return "PropertyValue: {type_name} ({desc})"


# BlueprintFunctionCall
# Represents a call to a Blueprint function
pub struct BlueprintFunctionCall:
    object_ptr: ffi.VoidPtr
    function_name: text
    parameters: Vec<PropertyValue>

impl BlueprintFunctionCall:
    # Create new function call
    pub fn new(object_ptr: ffi.VoidPtr, function_name: text) -> BlueprintFunctionCall:
        return BlueprintFunctionCall(
            object_ptr: object_ptr,
            function_name: function_name,
            parameters: [],
        )

    # Add boolean parameter
    pub fn with_bool(mut self, value: bool) -> BlueprintFunctionCall:
        self.parameters.push(PropertyValue.bool(value))
        return self

    # Add integer parameter
    pub fn with_int(mut self, value: i32) -> BlueprintFunctionCall:
        self.parameters.push(PropertyValue.i32(value))
        return self

    # Add f32 parameter
    pub fn with_float(mut self, value: f32) -> BlueprintFunctionCall:
        self.parameters.push(PropertyValue.f32(value))
        return self

    # Add string parameter
    pub fn with_string(mut self, value: text) -> BlueprintFunctionCall:
        self.parameters.push(PropertyValue.text(value))
        return self

    # Add object parameter
    pub fn with_object(mut self, value: ffi.VoidPtr) -> BlueprintFunctionCall:
        self.parameters.push(PropertyValue.Object(value))
        return self

    # Execute the function call
    pub fn execute(self) -> PropertyValue:
        # Marshal parameters to FFI
        val param_count = self.parameters.len()
        val param_types = ffi.alloc_array_i32(param_count)
        val param_values = ffi.alloc_array_ptr(param_count)

        for i in 0..param_count:
            val param = self.parameters[i]

            # Set parameter type and value based on variant
            if param is PropertyValue.bool(value):
                ffi.write_array_i32(param_types, i, 0)  # Type: bool
                val bool_ptr = ffi.alloc_bool()
                ffi.write_bool(bool_ptr, value)
                ffi.write_array_ptr(param_values, i, bool_ptr)
            elif param is PropertyValue.i32(value):
                ffi.write_array_i32(param_types, i, 1)  # Type: i32
                val int_ptr = ffi.alloc_i32()
                ffi.write_i32(int_ptr, value)
                ffi.write_array_ptr(param_values, i, int_ptr)
            elif param is PropertyValue.f32(value):
                ffi.write_array_i32(param_types, i, 2)  # Type: f32
                val float_ptr = ffi.alloc_f32()
                ffi.write_f32(float_ptr, value)
                ffi.write_array_ptr(param_values, i, float_ptr)
            elif param is PropertyValue.text(value):
                ffi.write_array_i32(param_types, i, 3)  # Type: text
                val str_ptr = ffi.string_to_ptr(value)
                ffi.write_array_ptr(param_values, i, str_ptr)
            elif param is PropertyValue.Object(ptr):
                ffi.write_array_i32(param_types, i, 4)  # Type: Object
                ffi.write_array_ptr(param_values, i, ptr)

        # Call the Blueprint function via FFI
        val result_type = ffi.alloc_i32()
        val result_value = ffi.alloc_ptr()

        unreal_blueprint_call_function(
            self.object_ptr,
            self.function_name,
            param_count as i32,
            param_types,
            param_values,
            result_type,
            result_value
        )

        # Parse result
        val ret_type = ffi.read_i32(result_type)
        val ret_val = ffi.read_ptr(result_value)

        val result = if ret_type == 0:
            PropertyValue.bool(ffi.read_bool(ret_val))
        elif ret_type == 1:
            PropertyValue.i32(ffi.read_i32(ret_val))
        elif ret_type == 2:
            PropertyValue.f32(ffi.read_f32(ret_val))
        elif ret_type == 3:
            PropertyValue.text(ffi.string_from_ptr(ret_val))
        elif ret_type == 4:
            PropertyValue.Object(ret_val)
        else:
            PropertyValue.bool(false)

        # Cleanup
        for i in 0..param_count:
            val param_ptr = ffi.read_array_ptr(param_values, i)
            ffi.free(param_ptr)

        ffi.free(param_types)
        ffi.free(param_values)
        ffi.free(result_type)
        ffi.free(result_value)

        return result


# BlueprintProperty
# Access Blueprint properties from Simple
pub struct BlueprintProperty:
    object_ptr: ffi.VoidPtr
    property_name: text

impl BlueprintProperty:
    pub fn new(object_ptr: ffi.VoidPtr, property_name: text) -> BlueprintProperty:
        return BlueprintProperty(
            object_ptr: object_ptr,
            property_name: property_name,
        )

    # Get property value
    pub fn get(self) -> PropertyValue:
        val value_type = ffi.alloc_i32()
        val value_ptr = ffi.alloc_ptr()

        unreal_blueprint_get_property(
            self.object_ptr,
            self.property_name,
            value_type,
            value_ptr
        )

        val prop_type = ffi.read_i32(value_type)
        val prop_val = ffi.read_ptr(value_ptr)

        val result = if prop_type == 0:
            PropertyValue.bool(ffi.read_bool(prop_val))
        elif prop_type == 1:
            PropertyValue.i32(ffi.read_i32(prop_val))
        elif prop_type == 2:
            PropertyValue.f32(ffi.read_f32(prop_val))
        elif prop_type == 3:
            PropertyValue.text(ffi.string_from_ptr(prop_val))
        elif prop_type == 4:
            PropertyValue.Object(prop_val)
        else:
            PropertyValue.bool(false)

        ffi.free(value_type)
        ffi.free(value_ptr)

        return result

    # Set property value
    pub fn set(mut self, value: PropertyValue):
        val value_type: i32
        val value_ptr: ffi.VoidPtr

        if value is PropertyValue.bool(v):
            value_type = 0
            val bool_ptr = ffi.alloc_bool()
            ffi.write_bool(bool_ptr, v)
            value_ptr = bool_ptr
        elif value is PropertyValue.i32(v):
            value_type = 1
            val int_ptr = ffi.alloc_i32()
            ffi.write_i32(int_ptr, v)
            value_ptr = int_ptr
        elif value is PropertyValue.f32(v):
            value_type = 2
            val float_ptr = ffi.alloc_f32()
            ffi.write_f32(float_ptr, v)
            value_ptr = float_ptr
        elif value is PropertyValue.text(v):
            value_type = 3
            value_ptr = ffi.string_to_ptr(v)
        elif value is PropertyValue.Object(ptr):
            value_type = 4
            value_ptr = ptr
        else:
            value_type = 0
            value_ptr = ffi.null_ptr()

        unreal_blueprint_set_property(
            self.object_ptr,
            self.property_name,
            value_type,
            value_ptr
        )

        ffi.free(value_ptr)


# BlueprintEvent
# Dispatch events to Blueprint
pub struct BlueprintEvent:
    dispatcher_ptr: ffi.VoidPtr

impl BlueprintEvent:
    pub fn new(object_ptr: ffi.VoidPtr, event_name: text) -> BlueprintEvent:
        val dispatcher_ptr = unreal_blueprint_get_event_dispatcher(object_ptr, event_name)
        return BlueprintEvent(dispatcher_ptr: dispatcher_ptr)

    # Broadcast event with no parameters
    pub fn broadcast(self):
        unreal_blueprint_broadcast_event(self.dispatcher_ptr, 0, ffi.null_ptr(), ffi.null_ptr())

    # Broadcast event with parameters
    pub fn broadcast_with_params(self, params: Vec<PropertyValue>):
        val param_count = params.len()
        val param_types = ffi.alloc_array_i32(param_count)
        val param_values = ffi.alloc_array_ptr(param_count)

        for i in 0..param_count:
            val param = params[i]

            if param is PropertyValue.bool(value):
                ffi.write_array_i32(param_types, i, 0)
                val bool_ptr = ffi.alloc_bool()
                ffi.write_bool(bool_ptr, value)
                ffi.write_array_ptr(param_values, i, bool_ptr)
            elif param is PropertyValue.i32(value):
                ffi.write_array_i32(param_types, i, 1)
                val int_ptr = ffi.alloc_i32()
                ffi.write_i32(int_ptr, value)
                ffi.write_array_ptr(param_values, i, int_ptr)
            elif param is PropertyValue.f32(value):
                ffi.write_array_i32(param_types, i, 2)
                val float_ptr = ffi.alloc_f32()
                ffi.write_f32(float_ptr, value)
                ffi.write_array_ptr(param_values, i, float_ptr)
            elif param is PropertyValue.text(value):
                ffi.write_array_i32(param_types, i, 3)
                val str_ptr = ffi.string_to_ptr(value)
                ffi.write_array_ptr(param_values, i, str_ptr)
            elif param is PropertyValue.Object(ptr):
                ffi.write_array_i32(param_types, i, 4)
                ffi.write_array_ptr(param_values, i, ptr)

        unreal_blueprint_broadcast_event(self.dispatcher_ptr, param_count as i32, param_types, param_values)

        # Cleanup
        for i in 0..param_count:
            val param_ptr = ffi.read_array_ptr(param_values, i)
            ffi.free(param_ptr)

        ffi.free(param_types)
        ffi.free(param_values)


# Helper functions

# Call Blueprint function on actor
pub fn call_blueprint_function(actor: actor.AActor, function_name: text) -> PropertyValue:
    return BlueprintFunctionCall.new(actor.as_ptr(), function_name).execute()

# Get Blueprint property from actor
pub fn get_blueprint_property(actor: actor.AActor, property_name: text) -> PropertyValue:
    return BlueprintProperty.new(actor.as_ptr(), property_name).get()

# Set Blueprint property on actor
pub fn set_blueprint_property(actor: actor.AActor, property_name: text, value: PropertyValue):
    BlueprintProperty.new(actor.as_ptr(), property_name).set(value)


# FFI function declarations

extern "C":
    fn unreal_blueprint_call_function(
        object: ffi.VoidPtr,
        function_name: text,
        param_count: i32,
        param_types: ffi.VoidPtr,
        param_values: ffi.VoidPtr,
        result_type: ffi.VoidPtr,
        result_value: ffi.VoidPtr
    )

    fn unreal_blueprint_get_property(
        object: ffi.VoidPtr,
        property_name: text,
        value_type: ffi.VoidPtr,
        value_ptr: ffi.VoidPtr
    )

    fn unreal_blueprint_set_property(
        object: ffi.VoidPtr,
        property_name: text,
        value_type: i32,
        value_ptr: ffi.VoidPtr
    )

    fn unreal_blueprint_get_event_dispatcher(
        object: ffi.VoidPtr,
        event_name: text
    ) -> ffi.VoidPtr

    fn unreal_blueprint_broadcast_event(
        dispatcher: ffi.VoidPtr,
        param_count: i32,
        param_types: ffi.VoidPtr,
        param_values: ffi.VoidPtr
    )
