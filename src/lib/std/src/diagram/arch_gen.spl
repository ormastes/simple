# Architecture Diagram Generator
# Generates Mermaid architecture diagrams showing only architectural entities
#
# Architectural entities:
# - Entities tagged with @architectural annotation
# - Packages (modules) are architectural by default
# - Can be filtered to specific architectural layers
#
# Output format: Mermaid flowchart TD syntax

import core.{Option, List, Set, Dict, text}
import recorder.{CallEvent, CallEventRecorder, CallType}
import filter.{DiagramFilter}
import config.{DiagramConfig}

# Architectural layer classification
enum ArchLayer:
    Presentation  # UI, API controllers
    Application   # Use cases, services
    Domain        # Business logic, entities
    Infrastructure  # Database, external services
    Unknown       # Not classified

impl ArchLayer:
    # =========================================================================
    # Helper Methods
    # =========================================================================

    fn is_presentation() -> bool:
        """Check if this is Presentation layer.

        Returns:
            true for Presentation

        Example:
            ArchLayer::Presentation.is_presentation()  # → true
        """
        match self:
            case Presentation: true
            case _: false

    fn is_application() -> bool:
        """Check if this is Application layer.

        Returns:
            true for Application

        Example:
            ArchLayer::Application.is_application()  # → true
        """
        match self:
            case Application: true
            case _: false

    fn is_domain() -> bool:
        """Check if this is Domain layer.

        Returns:
            true for Domain

        Example:
            ArchLayer::Domain.is_domain()  # → true
        """
        match self:
            case Domain: true
            case _: false

    fn is_infrastructure() -> bool:
        """Check if this is Infrastructure layer.

        Returns:
            true for Infrastructure

        Example:
            ArchLayer::Infrastructure.is_infrastructure()  # → true
        """
        match self:
            case Infrastructure: true
            case _: false

    fn is_unknown() -> bool:
        """Check if this is Unknown layer.

        Returns:
            true for Unknown

        Example:
            ArchLayer::Unknown.is_unknown()  # → true
        """
        match self:
            case Unknown: true
            case _: false

    fn is_business_logic() -> bool:
        """Check if layer contains business logic.

        Returns:
            true for Domain and Application

        Example:
            ArchLayer::Domain.is_business_logic()  # → true
            ArchLayer::Infrastructure.is_business_logic()  # → false
        """
        match self:
            case Domain: true
            case Application: true
            case _: false

    fn is_external_facing() -> bool:
        """Check if layer interfaces with external systems.

        Returns:
            true for Presentation and Infrastructure

        Example:
            ArchLayer::Presentation.is_external_facing()  # → true
            ArchLayer::Domain.is_external_facing()  # → false
        """
        match self:
            case Presentation: true
            case Infrastructure: true
            case _: false

    fn is_core() -> bool:
        """Check if this is core/business layer.

        Returns:
            true for Domain

        Example:
            ArchLayer::Domain.is_core()  # → true
        """
        match self:
            case Domain: true
            case _: false

    fn layer_number() -> i32:
        """Get layer number in clean architecture ordering.

        Returns:
            Layer number (1=Domain, 2=Application, 3=Presentation/Infrastructure, -1=Unknown)

        Example:
            ArchLayer::Domain.layer_number()  # → 1
            ArchLayer::Presentation.layer_number()  # → 3
        """
        match self:
            case Domain: 1
            case Application: 2
            case Presentation: 3
            case Infrastructure: 3
            case Unknown: -1

    fn to_string() -> text:
        """Convert layer to string.

        Returns:
            Layer name

        Example:
            ArchLayer::Application.to_string()  # → "application"
        """
        match self:
            case Presentation: "presentation"
            case Application: "application"
            case Domain: "domain"
            case Infrastructure: "infrastructure"
            case Unknown: "unknown"

    fn description() -> text:
        """Get layer description.

        Returns:
            Human-readable description

        Example:
            ArchLayer::Domain.description()
            # → "Business logic, entities"
        """
        match self:
            case Presentation: "UI, API controllers"
            case Application: "Use cases, services"
            case Domain: "Business logic, entities"
            case Infrastructure: "Database, external services"
            case Unknown: "Not classified"

    fn summary() -> text:
        """Get summary of architectural layer.

        Returns:
            Human-readable summary

        Example:
            ArchLayer::Domain.summary()
            # → "ArchLayer: domain (core business logic, layer 1)"
        """
        val name = self.to_string()
        val layer_num = self.layer_number()
        val category = if self.is_core():
                           "core business logic"
                       else if self.is_business_logic():
                           "business logic"
                       else if self.is_external_facing():
                           "external interface"
                       else:
                           "not classified"
        return if layer_num >= 0:
            "ArchLayer: {name} ({category}, layer {layer_num})"
        else:
            "ArchLayer: {name} ({category})"

# Architectural entity info
struct ArchEntity:
    name: text
    entity_type: text      # package, class, module
    layer: ArchLayer
    dependencies: Set<text>
    is_package: bool

    fn new(name: text) -> ArchEntity:
        return ArchEntity {
            name: name,
            entity_type: "class",
            layer: ArchLayer.Unknown,
            dependencies: Set.new(),
            is_package: false,
        }

    var fn as_package() -> ArchEntity:
        self.is_package = true
        self.entity_type = "package"
        return self

    var fn with_layer(layer: ArchLayer) -> ArchEntity:
        self.layer = layer
        return self

    var fn add_dependency(dep: text) -> void:
        self.dependencies.insert(dep)

# Architecture diagram generator
class ArchDiagramGenerator:
    events: List<CallEvent>
    filter: DiagramFilter
    config: DiagramConfig
    entities: Dict<text, ArchEntity>
    architectural_set: Set<text>
    output: text

    fn new(config: DiagramConfig) -> ArchDiagramGenerator:
        return ArchDiagramGenerator {
            events: [],
            filter: config.filter,
            config: config,
            entities: Dict.new(),
            architectural_set: Set.new(),
            output: "",
        }

    # Generate diagram from recorder
    var fn generate(recorder: CallEventRecorder) -> text:
        self.events = recorder.get_events()
        self.architectural_set = recorder.get_architectural_entities()

        return self.generate_from_events(self.events)

    # Generate diagram from event list
    var fn generate_from_events(events: List<CallEvent>) -> text:
        # Filter events if filter is configured
        val filtered = if self.filter.is_empty():
            events
        else:
            self.filter.filter_events(events)

        # Extract architectural entities
        self.extract_entities(filtered)
        self.extract_dependencies(filtered)

        # Generate output
        self.output = ""
        self.emit_header()
        self.emit_subgraphs()
        self.emit_dependencies()
        self.emit_footer()

        return self.output

    # Check if an entity is architectural
    fn is_architectural(name: text) -> bool:
        # Explicitly marked as architectural
        if self.architectural_set.contains(name):
            return true

        # Packages are architectural by default (names ending with module path)
        if name.contains(".") or name.contains("::"):
            return true

        # Class names that look like packages (all lowercase with underscores)
        if name == name.lower() and name.contains("_"):
            return true

        return false

    # Get package name from entity name
    fn get_package(name: text) -> Option<text>:
        # Extract package from qualified name
        if name.contains("."):
            val parts = name.split(".")
            if parts.len() > 1:
                return Some(parts[0])
        if name.contains("::"):
            val parts = name.split("::")
            if parts.len() > 1:
                return Some(parts[0])
        return None

    # Extract architectural entities from events
    var fn extract_entities(events: List<CallEvent>) -> void:
        self.entities = Dict.new()

        for event in events:
            if event.is_return:
                continue

            # Check caller
            val caller = event.get_caller_participant()
            if self.is_architectural(caller):
                if not self.entities.contains(caller):
                    val entity = ArchEntity.new(caller)
                    self.entities.insert(caller, entity)

            # Check callee
            val callee = event.get_callee_participant()
            if self.is_architectural(callee):
                if not self.entities.contains(callee):
                    val entity = ArchEntity.new(callee)
                    self.entities.insert(callee, entity)

            # Also add packages
            match self.get_package(caller):
                case Some(pkg):
                    if not self.entities.contains(pkg):
                        val entity = ArchEntity.new(pkg).as_package()
                        self.entities.insert(pkg, entity)
                case None:
                    pass

            match self.get_package(callee):
                case Some(pkg):
                    if not self.entities.contains(pkg):
                        val entity = ArchEntity.new(pkg).as_package()
                        self.entities.insert(pkg, entity)
                case None:
                    pass

    # Extract dependencies between architectural entities
    var fn extract_dependencies(events: List<CallEvent>) -> void:
        for event in events:
            if event.is_return:
                continue

            val caller = event.get_caller_participant()
            val callee = event.get_callee_participant()

            # Only track dependencies between architectural entities
            if not self.is_architectural(caller) or not self.is_architectural(callee):
                continue

            if caller == callee:
                continue

            match self.entities.get(caller):
                case Some(entity):
                    var updated = entity
                    updated.add_dependency(callee)
                    self.entities.insert(caller, updated)
                case None:
                    pass

            # Also track package-level dependencies
            match (self.get_package(caller), self.get_package(callee)):
                case (Some(from_pkg), Some(to_pkg)):
                    if from_pkg != to_pkg:
                        match self.entities.get(from_pkg):
                            case Some(entity):
                                var updated = entity
                                updated.add_dependency(to_pkg)
                                self.entities.insert(from_pkg, updated)
                            case None:
                                pass
                case _:
                    pass

    # Emit diagram header
    var fn emit_header() -> void:
        self.output = self.output + "```mermaid\n"
        self.output = self.output + "flowchart TD\n"

    # Emit subgraphs for packages
    var fn emit_subgraphs() -> void:
        # Group entities by package
        val packages: Dict<text, List<text>> = Dict.new()

        for (name, entity) in self.entities:
            if entity.is_package:
                continue

            match self.get_package(name):
                case Some(pkg):
                    match packages.get(pkg):
                        case Some(members):
                            var updated = members
                            updated.push(name)
                            packages.insert(pkg, updated)
                        case None:
                            packages.insert(pkg, [name])
                case None:
                    # Standalone entity
                    match packages.get("_standalone"):
                        case Some(members):
                            var updated = members
                            updated.push(name)
                            packages.insert("_standalone", updated)
                        case None:
                            packages.insert("_standalone", [name])

        # Emit subgraphs
        for (pkg_name, members) in packages:
            if pkg_name == "_standalone":
                # Emit standalone entities without subgraph
                for member in members:
                    val safe_id = sanitize_id(member)
                    self.output = self.output + "    ${safe_id}[${member}]\n"
            else:
                self.output = self.output + "    subgraph ${pkg_name}[\"${pkg_name}\"]\n"
                for member in members:
                    val safe_id = sanitize_id(member)
                    val short_name = member.split(".").last().unwrap_or(member)
                    self.output = self.output + "        ${safe_id}[${short_name}]\n"
                self.output = self.output + "    end\n"

        self.output = self.output + "\n"

    # Emit dependencies
    var fn emit_dependencies() -> void:
        val seen: Set<text> = Set.new()

        for (name, entity) in self.entities:
            for dep in entity.dependencies:
                val key = "${name}->${dep}"
                if seen.contains(key):
                    continue
                seen.insert(key)

                val from_id = sanitize_id(name)
                val to_id = sanitize_id(dep)
                self.output = self.output + "    ${from_id} --> ${to_id}\n"

    # Emit footer
    var fn emit_footer() -> void:
        self.output = self.output + "```\n"

# Sanitize name for Mermaid ID (remove special chars)
fn sanitize_id(name: text) -> text:
    val result = ""
    for c in name.chars():
        if c.is_alphanumeric() or c == '_':
            result = result + c
        else:
            result = result + "_"
    return result

# Generate architecture diagram from recorder
fn generate_arch_diagram(recorder: CallEventRecorder, config: DiagramConfig) -> text:
    val gen = ArchDiagramGenerator.new(config)
    return gen.generate(recorder)

# Generate architecture diagram from events
fn generate_arch_from_events(events: List<CallEvent>, config: DiagramConfig) -> text:
    val gen = ArchDiagramGenerator.new(config)
    return gen.generate_from_events(events)

# Simple generation with defaults
fn to_mermaid_arch(recorder: CallEventRecorder) -> text:
    val config = DiagramConfig.new().with_architecture()
    return generate_arch_diagram(recorder, config)

# Exports
export ArchEntity, ArchLayer, ArchDiagramGenerator
export generate_arch_diagram, generate_arch_from_events, to_mermaid_arch, sanitize_id
