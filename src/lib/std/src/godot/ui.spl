# Godot UI System
#
# Type-safe wrappers for Godot's UI system
#
# Features:
# - Control base class (UI foundation)
# - Common UI widgets (Button, Label, TextEdit, etc.)
# - Layout containers (VBox, HBox, Grid, etc.)
# - Theme system
#
# Based on: https://docs.godotengine.org/en/stable/classes/class_control.html

import godot.ffi
import godot.variant
import godot.node
import godot.resource
import godot.signal

mod ui

# Control Base Class
# Foundation for all UI elements
pub struct Control extends godot.node.Node:

impl Control:
    # Create from Godot object pointer
    pub fn from_ptr(ptr: ffi.GDExtensionObjectPtr) -> Control:
        return Control(base: godot.node.Node.from_ptr(ptr))

    # Set position
    pub fn set_position(mut self, x: f32, y: f32):
        val obj = self.base.as_object()
        val pos_var = variant.Variant.from_vector2(x as f64, y as f64)
        obj.call1("set_position", pos_var)

    # Get position
    pub fn get_position(self) -> (f32, f32):
        val obj = self.base.as_object()
        val result = obj.call0("get_position")
        val (x, y) = result.as_vector2()
        return (x as f32, y as f32)

    # Set size
    pub fn set_size(mut self, width: f32, height: f32):
        val obj = self.base.as_object()
        val size_var = variant.Variant.from_vector2(width as f64, height as f64)
        obj.call1("set_size", size_var)

    # Get size
    pub fn get_size(self) -> (f32, f32):
        val obj = self.base.as_object()
        val result = obj.call0("get_size")
        return (0.0, 0.0)  # Placeholder

    # Set minimum size
    pub fn set_custom_minimum_size(mut self, width: f32, height: f32):
        val obj = self.base.as_object()
        val size_var = variant.Variant.from_vector2(width as f64, height as f64)
        obj.call1("set_custom_minimum_size", size_var)

    # Set anchors (for responsive layout)
    pub fn set_anchor(mut self, side: Side, anchor: f32):
        val obj = self.base.as_object()
        val side_var = variant.Variant.from_int(side as i64)
        val anchor_var = variant.Variant.from_float(anchor as f64)
        obj.call2("set_anchor", side_var, anchor_var)

    # Set all anchors at once
    pub fn set_anchors_preset(mut self, preset: LayoutPreset):
        val obj = self.base.as_object()
        val preset_var = variant.Variant.from_int(preset as i64)
        obj.call1("set_anchors_preset", preset_var)

    # Set visibility
    pub fn set_visible(mut self, visible: bool):
        val obj = self.base.as_object()
        val vis_var = variant.Variant.from_bool(visible)
        obj.call1("set_visible", vis_var)

    # Check visibility
    pub fn is_visible(self) -> bool:
        val obj = self.base.as_object()
        val result = obj.call0("is_visible")
        return result.as_bool()

    # Set modulate (tint color)
    pub fn set_modulate(mut self, r: f32, g: f32, b: f32, a: f32):
        val obj = self.base.as_object()
        val color_var = variant.Variant.from_color(r, g, b, a)
        obj.call1("set_modulate", color_var)

    # Grab focus
    pub fn grab_focus(mut self):
        val obj = self.base.as_object()
        obj.call0("grab_focus")

    # Check if has focus
    pub fn has_focus(self) -> bool:
        val obj = self.base.as_object()
        val result = obj.call0("has_focus")
        return result.as_bool()


# Button Widget
pub struct Button extends Control:

impl Button:
    pub fn from_ptr(ptr: ffi.GDExtensionObjectPtr) -> Button:
        return Button(base: Control.from_ptr(ptr))

    # Set button text
    pub fn set_text(mut self, text: text):
        val obj = self.base.base.as_object()
        val text_var = variant.Variant.from_string(text)
        obj.call1("set_text", text_var)

    # Get button text
    pub fn get_text(self) -> text:
        val obj = self.base.base.as_object()
        val result = obj.call0("get_text")
        return result.as_string()

    # Set icon
    pub fn set_icon(mut self, texture: resource.Resource):
        val obj = self.base.base.as_object()
        val icon_var = variant.Variant.from_object(texture.as_object())
        obj.call1("set_icon", icon_var)

    # Set disabled state
    pub fn set_disabled(mut self, disabled: bool):
        val obj = self.base.base.as_object()
        val dis_var = variant.Variant.from_bool(disabled)
        obj.call1("set_disabled", dis_var)

    # Check if disabled
    pub fn is_disabled(self) -> bool:
        val obj = self.base.base.as_object()
        val result = obj.call0("is_disabled")
        return result.as_bool()

    # Check if pressed (toggle mode)
    pub fn is_pressed(self) -> bool:
        val obj = self.base.base.as_object()
        val result = obj.call0("is_pressed")
        return result.as_bool()

    # Set toggle mode
    pub fn set_toggle_mode(mut self, enabled: bool):
        val obj = self.base.base.as_object()
        val toggle_var = variant.Variant.from_bool(enabled)
        obj.call1("set_toggle_mode", toggle_var)

    # Connect pressed signal
    pub fn on_pressed(mut self, callback: fn()):
        # Signal connection requires runtime callback registration
        # Store callback and connect via Godot signal system
        val obj = self.base.base.as_object()
        val signal_name = variant.StringName.new("pressed")
        # Signal connection deferred to Godot runtime callback system
        # Requires P4: Full callback registration infrastructure
        pass


# Label Widget
pub struct Label extends Control:

impl Label:
    pub fn from_ptr(ptr: ffi.GDExtensionObjectPtr) -> Label:
        return Label(base: Control.from_ptr(ptr))

    # Set label text
    pub fn set_text(mut self, text: text):
        val obj = self.base.base.as_object()
        val text_var = variant.Variant.from_string(text)
        obj.call1("set_text", text_var)

    # Get label text
    pub fn get_text(self) -> text:
        val obj = self.base.base.as_object()
        val result = obj.call0("get_text")
        return result.as_string()

    # Set horizontal alignment
    pub fn set_horizontal_alignment(mut self, alignment: HorizontalAlignment):
        val obj = self.base.base.as_object()
        val align_var = variant.Variant.from_int(alignment as i64)
        obj.call1("set_horizontal_alignment", align_var)

    # Set vertical alignment
    pub fn set_vertical_alignment(mut self, alignment: VerticalAlignment):
        val obj = self.base.base.as_object()
        val align_var = variant.Variant.from_int(alignment as i64)
        obj.call1("set_vertical_alignment", align_var)

    # Set autowrap
    pub fn set_autowrap_mode(mut self, mode: AutowrapMode):
        val obj = self.base.base.as_object()
        val mode_var = variant.Variant.from_int(mode as i64)
        obj.call1("set_autowrap_mode", mode_var)


# TextEdit Widget
pub struct TextEdit extends Control:

impl TextEdit:
    pub fn from_ptr(ptr: ffi.GDExtensionObjectPtr) -> TextEdit:
        return TextEdit(base: Control.from_ptr(ptr))

    # Set text
    pub fn set_text(mut self, text: text):
        val obj = self.base.base.as_object()
        val text_var = variant.Variant.from_string(text)
        obj.call1("set_text", text_var)

    # Get text
    pub fn get_text(self) -> text:
        val obj = self.base.base.as_object()
        val result = obj.call0("get_text")
        return result.as_string()

    # Set editable
    pub fn set_editable(mut self, enabled: bool):
        val obj = self.base.base.as_object()
        val edit_var = variant.Variant.from_bool(enabled)
        obj.call1("set_editable", edit_var)

    # Set placeholder
    pub fn set_placeholder(mut self, text: text):
        val obj = self.base.base.as_object()
        val text_var = variant.Variant.from_string(text)
        obj.call1("set_placeholder", text_var)

    # Clear text
    pub fn clear(mut self):
        val obj = self.base.base.as_object()
        obj.call0("clear")


# VBoxContainer (Vertical Layout)
pub struct VBoxContainer extends Control:

impl VBoxContainer:
    pub fn from_ptr(ptr: ffi.GDExtensionObjectPtr) -> VBoxContainer:
        return VBoxContainer(base: Control.from_ptr(ptr))

    # Set separation between children
    pub fn add_theme_constant_override(mut self, name: text, value: i32):
        val obj = self.base.base.as_object()
        val name_var = variant.Variant.from_string(name)
        val val_var = variant.Variant.from_int(value as i64)
        obj.call2("add_theme_constant_override", name_var, val_var)


# HBoxContainer (Horizontal Layout)
pub struct HBoxContainer extends Control:

impl HBoxContainer:
    pub fn from_ptr(ptr: ffi.GDExtensionObjectPtr) -> HBoxContainer:
        return HBoxContainer(base: Control.from_ptr(ptr))

    # Set separation between children
    pub fn add_theme_constant_override(mut self, name: text, value: i32):
        val obj = self.base.base.as_object()
        val name_var = variant.Variant.from_string(name)
        val val_var = variant.Variant.from_int(value as i64)
        obj.call2("add_theme_constant_override", name_var, val_var)


# GridContainer (Grid Layout)
pub struct GridContainer extends Control:

impl GridContainer:
    pub fn from_ptr(ptr: ffi.GDExtensionObjectPtr) -> GridContainer:
        return GridContainer(base: Control.from_ptr(ptr))

    # Set number of columns
    pub fn set_columns(mut self, columns: i32):
        val obj = self.base.base.as_object()
        val col_var = variant.Variant.from_int(columns as i64)
        obj.call1("set_columns", col_var)


# Enums

pub enum Side:
    Left = 0
    Top = 1
    Right = 2
    Bottom = 3

impl Side:
    pub fn to_string(self) -> text:
        """Convert side to string."""
        match self:
            case Left: "left"
            case Top: "top"
            case Right: "right"
            case Bottom: "bottom"

    pub fn description(self) -> text:
        """Get side description."""
        match self:
            case Left: "Left side"
            case Top: "Top side"
            case Right: "Right side"
            case Bottom: "bottom side"

    pub fn is_horizontal(self) -> bool:
        """Check if side is horizontal (left or right)."""
        match self:
            case Left: true
            case Right: true
            case _: false

    pub fn is_vertical(self) -> bool:
        """Check if side is vertical (top or bottom)."""
        match self:
            case Top: true
            case Bottom: true
            case _: false

    pub fn is_left(self) -> bool:
        """Check if side is Left."""
        match self:
            case Left: true
            case _: false

    pub fn is_top(self) -> bool:
        """Check if side is Top."""
        match self:
            case Top: true
            case _: false

    pub fn is_right(self) -> bool:
        """Check if side is Right."""
        match self:
            case Right: true
            case _: false

    pub fn is_bottom(self) -> bool:
        """Check if side is Bottom."""
        match self:
            case Bottom: true
            case _: false

    pub fn summary(self) -> text:
        """Get side summary."""
        val name = self.to_string()
        val desc = self.description()
        var props = []
        if self.is_horizontal():
            props.push("horizontal")
        if self.is_vertical():
            props.push("vertical")
        val props_str = ", ".join(props)
        return "Side: {name} ({desc}, {props_str})"

pub enum LayoutPreset:
    TopLeft = 0
    TopRight = 1
    BottomLeft = 2
    BottomRight = 3
    CenterLeft = 4
    CenterTop = 5
    CenterRight = 6
    CenterBottom = 7
    Center = 8
    LeftWide = 9
    TopWide = 10
    RightWide = 11
    BottomWide = 12
    VCenterWide = 13
    HCenterWide = 14
    FullRect = 15

impl LayoutPreset:
    pub fn to_string(self) -> text:
        """Convert layout preset to string."""
        match self:
            case TopLeft: "top-left"
            case TopRight: "top-right"
            case BottomLeft: "bottom-left"
            case BottomRight: "bottom-right"
            case CenterLeft: "center-left"
            case CenterTop: "center-top"
            case CenterRight: "center-right"
            case CenterBottom: "center-bottom"
            case Center: "center"
            case LeftWide: "left-wide"
            case TopWide: "top-wide"
            case RightWide: "right-wide"
            case BottomWide: "bottom-wide"
            case VCenterWide: "vcenter-wide"
            case HCenterWide: "hcenter-wide"
            case FullRect: "full-rect"

    pub fn description(self) -> text:
        """Get layout preset description."""
        match self:
            case TopLeft: "Anchor to top-left corner"
            case TopRight: "Anchor to top-right corner"
            case BottomLeft: "Anchor to bottom-left corner"
            case BottomRight: "Anchor to bottom-right corner"
            case CenterLeft: "Center vertically, anchor left"
            case CenterTop: "Center horizontally, anchor top"
            case CenterRight: "Center vertically, anchor right"
            case CenterBottom: "Center horizontally, anchor bottom"
            case Center: "Center both horizontally and vertically"
            case LeftWide: "Stretch vertically, anchor left"
            case TopWide: "Stretch horizontally, anchor top"
            case RightWide: "Stretch vertically, anchor right"
            case BottomWide: "Stretch horizontally, anchor bottom"
            case VCenterWide: "Stretch horizontally, center vertically"
            case HCenterWide: "Stretch vertically, center horizontally"
            case FullRect: "Fill entire parent rectangle"

    pub fn is_corner(self) -> bool:
        """Check if preset is a corner layout."""
        match self:
            case TopLeft: true
            case TopRight: true
            case BottomLeft: true
            case BottomRight: true
            case _: false

    pub fn is_centered(self) -> bool:
        """Check if preset involves centering."""
        match self:
            case CenterLeft: true
            case CenterTop: true
            case CenterRight: true
            case CenterBottom: true
            case Center: true
            case VCenterWide: true
            case HCenterWide: true
            case _: false

    pub fn is_wide(self) -> bool:
        """Check if preset stretches to fill space."""
        match self:
            case LeftWide: true
            case TopWide: true
            case RightWide: true
            case BottomWide: true
            case VCenterWide: true
            case HCenterWide: true
            case FullRect: true
            case _: false

    pub fn summary(self) -> text:
        """Get layout preset summary."""
        val name = self.to_string()
        val desc = self.description()
        var props = []
        if self.is_corner():
            props.push("corner")
        if self.is_centered():
            props.push("centered")
        if self.is_wide():
            props.push("wide")
        if props.len() > 0:
            val props_str = ", ".join(props)
            return "LayoutPreset: {name} ({desc}, {props_str})"
        else:
            return "LayoutPreset: {name} ({desc})"

pub enum HorizontalAlignment:
    Left = 0
    Center = 1
    Right = 2
    Fill = 3

impl HorizontalAlignment:
    pub fn to_string(self) -> text:
        """Convert horizontal alignment to string."""
        match self:
            case Left: "left"
            case Center: "center"
            case Right: "right"
            case Fill: "fill"

    pub fn description(self) -> text:
        """Get horizontal alignment description."""
        match self:
            case Left: "Align to left edge"
            case Center: "Center horizontally"
            case Right: "Align to right edge"
            case Fill: "Fill horizontal space"

    pub fn is_left(self) -> bool:
        """Check if alignment is Left."""
        match self:
            case Left: true
            case _: false

    pub fn is_center(self) -> bool:
        """Check if alignment is Center."""
        match self:
            case Center: true
            case _: false

    pub fn is_right(self) -> bool:
        """Check if alignment is Right."""
        match self:
            case Right: true
            case _: false

    pub fn is_fill(self) -> bool:
        """Check if alignment is Fill."""
        match self:
            case Fill: true
            case _: false

    pub fn summary(self) -> text:
        """Get horizontal alignment summary."""
        val name = self.to_string()
        val desc = self.description()
        return "HorizontalAlignment: {name} ({desc})"

pub enum VerticalAlignment:
    Top = 0
    Center = 1
    Bottom = 2
    Fill = 3

impl VerticalAlignment:
    pub fn to_string(self) -> text:
        """Convert vertical alignment to string."""
        match self:
            case Top: "top"
            case Center: "center"
            case Bottom: "bottom"
            case Fill: "fill"

    pub fn description(self) -> text:
        """Get vertical alignment description."""
        match self:
            case Top: "Align to top edge"
            case Center: "Center vertically"
            case Bottom: "Align to bottom edge"
            case Fill: "Fill vertical space"

    pub fn is_top(self) -> bool:
        """Check if alignment is Top."""
        match self:
            case Top: true
            case _: false

    pub fn is_center(self) -> bool:
        """Check if alignment is Center."""
        match self:
            case Center: true
            case _: false

    pub fn is_bottom(self) -> bool:
        """Check if alignment is Bottom."""
        match self:
            case Bottom: true
            case _: false

    pub fn is_fill(self) -> bool:
        """Check if alignment is Fill."""
        match self:
            case Fill: true
            case _: false

    pub fn summary(self) -> text:
        """Get vertical alignment summary."""
        val name = self.to_string()
        val desc = self.description()
        return "VerticalAlignment: {name} ({desc})"

pub enum AutowrapMode:
    Off = 0
    Arbitrary = 1
    Word = 2
    WordSmart = 3

impl AutowrapMode:
    pub fn to_string(self) -> text:
        """Convert autowrap mode to string."""
        match self:
            case Off: "off"
            case Arbitrary: "arbitrary"
            case Word: "word"
            case WordSmart: "word-smart"

    pub fn description(self) -> text:
        """Get autowrap mode description."""
        match self:
            case Off: "No automatic text wrapping"
            case Arbitrary: "Wrap at any character"
            case Word: "Wrap at word boundaries"
            case WordSmart: "Smart word wrapping with hyphenation"

    pub fn is_enabled(self) -> bool:
        """Check if autowrap is enabled."""
        match self:
            case Off: false
            case _: true

    pub fn is_off(self) -> bool:
        """Check if autowrap mode is Off."""
        match self:
            case Off: true
            case _: false

    pub fn is_arbitrary(self) -> bool:
        """Check if autowrap mode is Arbitrary."""
        match self:
            case Arbitrary: true
            case _: false

    pub fn is_word(self) -> bool:
        """Check if autowrap mode is Word."""
        match self:
            case Word: true
            case _: false

    pub fn is_word_smart(self) -> bool:
        """Check if autowrap mode is WordSmart."""
        match self:
            case WordSmart: true
            case _: false

    pub fn is_word_aware(self) -> bool:
        """Check if mode respects word boundaries."""
        match self:
            case Word: true
            case WordSmart: true
            case _: false

    pub fn summary(self) -> text:
        """Get autowrap mode summary."""
        val name = self.to_string()
        val desc = self.description()
        var props = []
        if self.is_enabled():
            props.push("enabled")
        if self.is_word_aware():
            props.push("word-aware")
        if props.len() > 0:
            val props_str = ", ".join(props)
            return "AutowrapMode: {name} ({desc}, {props_str})"
        else:
            return "AutowrapMode: {name} ({desc})"


# UI Builder Helper
pub struct UIBuilder:
    root_type: text
    children: Array<UIElement>

impl UIBuilder:
    pub fn new(root_type: text) -> UIBuilder:
        return UIBuilder(root_type: root_type, children: [])

    pub fn button(mut self, text: text) -> UIBuilder:
        val element = UIElement(element_type: "Button", text: Some(text), children: [])
        self.children.push(element)
        return self

    pub fn label(mut self, text: text) -> UIBuilder:
        val element = UIElement(element_type: "Label", text: Some(text), children: [])
        self.children.push(element)
        return self

struct UIElement:
    element_type: text
    text: Option<text>
    children: Array<UIElement>

struct Array<T>:
    items: Vec<T>

impl<T> Array<T>:
    pub fn push(mut self, item: T):
        pass
