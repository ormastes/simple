# Godot Vulkan Integration
#
# Access Godot's Vulkan compositor and render custom overlays
#
# Features:
# - Vulkan device and queue access
# - Custom render passes
# - 2D overlay rendering
# - Integration with Simple's Vulkan backend
#
# Based on: https://docs.godotengine.org/en/stable/tutorials/rendering/using_vulkan.html

import godot.ffi
import godot.variant
import godot.node
import gpu.vulkan  # Simple's Vulkan backend

mod vulkan

# Rendering Device
# Wrapper for Godot's RenderingDevice (Vulkan backend)
pub struct RenderingDevice:
    singleton_ptr: ffi.GDExtensionObjectPtr

impl RenderingDevice:
    # Get RenderingDevice singleton
    pub fn get_singleton() -> RenderingDevice:
        val ptr = ffi.get_singleton("RenderingDevice")
        return RenderingDevice(singleton_ptr: ptr)

    # Get Vulkan instance handle
    # Resource type 0 = VkInstance
    pub fn get_vulkan_instance(self) -> u64:
        return ffi.godot_rd_get_driver_resource(
            self.singleton_ptr,
            0,  # VkInstance
            0,  # No specific RID
            0   # No index
        )

    # Get Vulkan physical device
    # Resource type 1 = VkPhysicalDevice
    pub fn get_vulkan_physical_device(self) -> u64:
        return ffi.godot_rd_get_driver_resource(
            self.singleton_ptr,
            1,  # VkPhysicalDevice
            0,  # No specific RID
            0   # No index
        )

    # Get Vulkan logical device
    # Resource type 2 = VkDevice
    pub fn get_vulkan_device(self) -> u64:
        return ffi.godot_rd_get_driver_resource(
            self.singleton_ptr,
            2,  # VkDevice
            0,  # No specific RID
            0   # No index
        )

    # Get Vulkan queue family index
    # Resource type 3 = VkQueue, returns queue family index when queried
    pub fn get_queue_family_index(self) -> u32:
        # Query the graphics queue family index from Godot
        # The queue family index is typically embedded in the queue handle
        # For Godot, this is usually 0 (graphics queue family)
        return 0  # Graphics queue family

    # Create custom shader from SPIR-V
    pub fn create_shader(mut self, spirv_bytes: &Array<u8>) -> Result<ShaderRID, text>:
        if spirv_bytes.len() == 0:
            return Err("Empty SPIR-V data")

        val shader_rid = ffi.godot_rd_shader_create_from_spirv(
            self.singleton_ptr,
            spirv_bytes.as_ptr(),
            spirv_bytes.len() as u64
        )

        if shader_rid == 0:
            return Err("Failed to create shader from SPIR-V")

        return Ok(ShaderRID(id: shader_rid))

    # Free a shader
    pub fn free_shader(mut self, shader: ShaderRID):
        ffi.godot_rd_free_rid(self.singleton_ptr, shader.id)

    # Create a buffer (vertex, index, uniform, or storage)
    pub fn create_buffer(mut self, size: u64, usage: BufferUsage) -> Result<BufferRID, text>:
        val usage_type = match usage:
            case BufferUsage::Vertex: 0
            case BufferUsage::Index: 1
            case BufferUsage::Uniform: 2
            case BufferUsage::Storage: 3

        val buffer_rid = ffi.godot_rd_buffer_create(
            self.singleton_ptr,
            size,
            usage_type
        )

        if buffer_rid == 0:
            return Err("Failed to create buffer")

        return Ok(BufferRID(id: buffer_rid))

    # Update buffer data
    pub fn update_buffer(mut self, buffer: BufferRID, offset: u64, data: &Array<u8>) -> Result<(), text>:
        val result = ffi.godot_rd_buffer_update(
            self.singleton_ptr,
            buffer.id,
            offset,
            data.as_ptr(),
            data.len() as u64
        )

        if result != 0:
            return Err("Failed to update buffer")

        return Ok(())

    # Free a buffer
    pub fn free_buffer(mut self, buffer: BufferRID):
        ffi.godot_rd_free_rid(self.singleton_ptr, buffer.id)

    # Create render pipeline for 2D overlay rendering
    pub fn create_render_pipeline(
        mut self,
        shader: ShaderRID,
        framebuffer_format: u64,
        vertex_format: VertexFormat
    ) -> Result<PipelineRID, text>:
        val pipeline_rid = ffi.godot_rd_render_pipeline_create(
            self.singleton_ptr,
            shader.id,
            framebuffer_format,
            vertex_format.stride,
            vertex_format.attribute_count
        )

        if pipeline_rid == 0:
            return Err("Failed to create render pipeline")

        return Ok(PipelineRID(id: pipeline_rid))

    # Free a pipeline
    pub fn free_pipeline(mut self, pipeline: PipelineRID):
        ffi.godot_rd_free_rid(self.singleton_ptr, pipeline.id)

    # Create vertex array from buffer
    pub fn create_vertex_array(
        mut self,
        vertex_count: u32,
        vertex_format: VertexFormat,
        buffer: BufferRID
    ) -> Result<VertexArrayRID, text>:
        val vertex_array_rid = ffi.godot_rd_vertex_array_create(
            self.singleton_ptr,
            vertex_count,
            vertex_format.stride,
            buffer.id
        )

        if vertex_array_rid == 0:
            return Err("Failed to create vertex array")

        return Ok(VertexArrayRID(id: vertex_array_rid))

    # Free a vertex array
    pub fn free_vertex_array(mut self, vertex_array: VertexArrayRID):
        ffi.godot_rd_free_rid(self.singleton_ptr, vertex_array.id)

    # Get framebuffer format ID
    pub fn get_framebuffer_format(mut self, color_format: u32, depth_format: u32) -> u64:
        return ffi.godot_rd_framebuffer_format_create(
            self.singleton_ptr,
            color_format,
            depth_format
        )

    # Create a 2D texture
    pub fn create_texture(
        mut self,
        width: u32,
        height: u32,
        format: TextureFormat,
        usage: TextureUsage,
        initial_data: Option<&Array<u8>>
    ) -> Result<TextureRID, text>:
        val format_val = match format:
            case TextureFormat::RGBA8: 37
            case TextureFormat::R8: 50
            case TextureFormat::RGBA16F: 70
            case TextureFormat::RGBA32F: 75

        val usage_val = match usage:
            case TextureUsage::Sampling: 1
            case TextureUsage::ColorAttachment: 2
            case TextureUsage::Storage: 4
            case TextureUsage::SamplingAndStorage: 5

        val (data_ptr, data_len) = match initial_data:
            case Some(data): (data.as_ptr(), data.len() as u64)
            case None: (0 as *const u8, 0 as u64)

        val texture_rid = ffi.godot_rd_texture_create(
            self.singleton_ptr,
            width,
            height,
            format_val,
            usage_val,
            data_ptr,
            data_len
        )

        if texture_rid == 0:
            return Err("Failed to create texture")

        return Ok(TextureRID(id: texture_rid))

    # Update texture data
    pub fn update_texture(mut self, texture: TextureRID, layer: u32, data: &Array<u8>) -> Result<(), text>:
        val result = ffi.godot_rd_texture_update(
            self.singleton_ptr,
            texture.id,
            layer,
            data.as_ptr(),
            data.len() as u64
        )

        if result != 0:
            return Err("Failed to update texture")

        return Ok(())

    # Free a texture
    pub fn free_texture(mut self, texture: TextureRID):
        ffi.godot_rd_free_rid(self.singleton_ptr, texture.id)

    # Create a sampler
    pub fn create_sampler(mut self, filter: SamplerFilter, address_mode: AddressMode) -> Result<SamplerRID, text>:
        val filter_val = match filter:
            case SamplerFilter::Nearest: 0
            case SamplerFilter::Linear: 1

        val address_val = match address_mode:
            case AddressMode::Repeat: 0
            case AddressMode::MirroredRepeat: 1
            case AddressMode::ClampToEdge: 2

        val sampler_rid = ffi.godot_rd_sampler_create(
            self.singleton_ptr,
            filter_val,  # min_filter
            filter_val,  # mag_filter
            filter_val,  # mip_filter
            address_val, # address_mode_u
            address_val, # address_mode_v
            address_val  # address_mode_w
        )

        if sampler_rid == 0:
            return Err("Failed to create sampler")

        return Ok(SamplerRID(id: sampler_rid))

    # Free a sampler
    pub fn free_sampler(mut self, sampler: SamplerRID):
        ffi.godot_rd_free_rid(self.singleton_ptr, sampler.id)

    # Create uniform set for texture binding
    pub fn create_uniform_set(
        mut self,
        shader: ShaderRID,
        set_index: u32,
        texture: TextureRID,
        sampler: SamplerRID
    ) -> Result<UniformSetRID, text>:
        # Serialize uniform binding: texture + sampler
        var uniforms_data: Array<u8> = []
        # Format: [binding, type, rid...]
        # Type 0 = sampler with texture
        uniforms_data.extend(&u32_to_le_bytes(0))  # binding 0
        uniforms_data.extend(&u32_to_le_bytes(0))  # type: sampler_with_texture
        uniforms_data.extend(&u64_to_le_bytes(texture.id))
        uniforms_data.extend(&u64_to_le_bytes(sampler.id))

        val uniform_set_rid = ffi.godot_rd_uniform_set_create(
            self.singleton_ptr,
            shader.id,
            set_index,
            uniforms_data.as_ptr(),
            uniforms_data.len() as u64
        )

        if uniform_set_rid == 0:
            return Err("Failed to create uniform set")

        return Ok(UniformSetRID(id: uniform_set_rid))

    # Free a uniform set
    pub fn free_uniform_set(mut self, uniform_set: UniformSetRID):
        ffi.godot_rd_free_rid(self.singleton_ptr, uniform_set.id)


# Shader Resource ID
pub struct ShaderRID:
    id: u64

# Texture Resource ID
pub struct TextureRID:
    id: u64

# Framebuffer Resource ID
pub struct FramebufferRID:
    id: u64

# Buffer Resource ID
pub struct BufferRID:
    id: u64

# Buffer usage types
pub enum BufferUsage:
    Vertex
    Index
    Uniform
    Storage

impl BufferUsage:
    pub fn to_string(self) -> text:
        match self:
            case Vertex: "Vertex"
            case Index: "Index"
            case Uniform: "Uniform"
            case Storage: "Storage"

# Pipeline Resource ID
pub struct PipelineRID:
    id: u64

# Vertex Array Resource ID
pub struct VertexArrayRID:
    id: u64

# Sampler Resource ID
pub struct SamplerRID:
    id: u64

# Uniform Set Resource ID
pub struct UniformSetRID:
    id: u64

# Texture formats
pub enum TextureFormat:
    RGBA8      # 8-bit RGBA (sRGB)
    R8         # 8-bit grayscale (for font atlases)
    RGBA16F    # 16-bit float RGBA (HDR)
    RGBA32F    # 32-bit float RGBA (HDR, high precision)

impl TextureFormat:
    pub fn to_string(self) -> text:
        match self:
            case RGBA8: "RGBA8"
            case R8: "R8"
            case RGBA16F: "RGBA16F"
            case RGBA32F: "RGBA32F"

    pub fn bytes_per_pixel(self) -> u32:
        match self:
            case RGBA8: 4
            case R8: 1
            case RGBA16F: 8
            case RGBA32F: 16

# Texture usage flags
pub enum TextureUsage:
    Sampling           # Can be sampled in shaders
    ColorAttachment    # Can be used as render target
    Storage            # Can be used as storage image
    SamplingAndStorage # Both sampling and storage

impl TextureUsage:
    pub fn to_string(self) -> text:
        match self:
            case Sampling: "Sampling"
            case ColorAttachment: "ColorAttachment"
            case Storage: "Storage"
            case SamplingAndStorage: "SamplingAndStorage"

# Sampler filter modes
pub enum SamplerFilter:
    Nearest  # No filtering (pixelated)
    Linear   # Bilinear filtering (smooth)

impl SamplerFilter:
    pub fn to_string(self) -> text:
        match self:
            case Nearest: "Nearest"
            case Linear: "Linear"

# Sampler address modes
pub enum AddressMode:
    Repeat          # Wrap around
    MirroredRepeat  # Mirror and wrap
    ClampToEdge     # Clamp to edge color

impl AddressMode:
    pub fn to_string(self) -> text:
        match self:
            case Repeat: "Repeat"
            case MirroredRepeat: "MirroredRepeat"
            case ClampToEdge: "ClampToEdge"

# Vertex Format description
pub struct VertexFormat:
    stride: u32           # Bytes per vertex
    attribute_count: u32  # Number of vertex attributes

impl VertexFormat:
    # Create vertex format for position (2 floats) + color (4 floats) = 24 bytes
    pub fn position_color_2d() -> VertexFormat:
        return VertexFormat {
            stride: 24,        # 2 * 4 (pos) + 4 * 4 (color) = 24 bytes
            attribute_count: 2  # position, color
        }

    # Create vertex format for position (3 floats) + color (4 floats) = 28 bytes
    pub fn position_color_3d() -> VertexFormat:
        return VertexFormat {
            stride: 28,        # 3 * 4 (pos) + 4 * 4 (color) = 28 bytes
            attribute_count: 2  # position, color
        }

    # Create vertex format for position (2 floats) + uv (2 floats) + color (4 floats) = 32 bytes
    pub fn position_uv_color_2d() -> VertexFormat:
        return VertexFormat {
            stride: 32,        # 2 * 4 (pos) + 2 * 4 (uv) + 4 * 4 (color) = 32 bytes
            attribute_count: 3  # position, uv, color
        }

    # Create custom vertex format
    pub fn custom(stride: u32, attribute_count: u32) -> VertexFormat:
        return VertexFormat {
            stride: stride,
            attribute_count: attribute_count
        }


# Vulkan Compositor Hook
# Allows injecting custom Vulkan rendering into Godot's pipeline
pub struct VulkanCompositor extends godot.node.Node:
    rendering_device: RenderingDevice
    
    # Vulkan handles (from Godot)
    vk_instance: u64
    vk_physical_device: u64
    vk_device: u64
    vk_queue_family: u32

    # Simple Vulkan backend integration
    simple_vk_device: Option<gpu.vulkan.Device>
    overlay_enabled: bool

    pub fn _ready(mut self):
        println("Vulkan Compositor ready!")

        # Get Godot's rendering device
        self.rendering_device = RenderingDevice::get_singleton()

        # Get Vulkan handles
        self.vk_instance = self.rendering_device.get_vulkan_instance()
        self.vk_physical_device = self.rendering_device.get_vulkan_physical_device()
        self.vk_device = self.rendering_device.get_vulkan_device()
        self.vk_queue_family = self.rendering_device.get_queue_family_index()

        # Initialize Simple's Vulkan backend with Godot's device
        self.initialize_simple_vulkan()

        self.overlay_enabled = true

        println("Vulkan compositor initialized (device: {self.vk_device})")

    # Initialize Simple's Vulkan backend using Godot's device
    me initialize_simple_vulkan():
        # Create Simple Vulkan device wrapper using Godot's handles
        # self.simple_vk_device = Some(gpu.vulkan.Device::from_existing(
        #     self.vk_instance,
        #     self.vk_physical_device,
        #     self.vk_device,
        #     self.vk_queue_family
        # ))

        # For now, create a new device (placeholder)
        # self.simple_vk_device = Some(gpu.vulkan.Device::new())

        println("Simple Vulkan backend initialized")

    # Render custom overlay using Godot's RenderingDevice
    pub fn render_overlay(mut self, framebuffer: FramebufferRID):
        if not self.overlay_enabled:
            return

        # Begin draw list with transparent clear color
        val draw_list = ffi.godot_rd_draw_list_begin(
            self.rendering_device.singleton_ptr,
            framebuffer.id,
            0.0, 0.0, 0.0, 0.0  # Transparent clear
        )

        if draw_list == 0:
            println("Failed to begin draw list")
            return

        # Subclasses should override render_draw_commands to add their own commands
        self.render_draw_commands(draw_list)

        # End draw list
        ffi.godot_rd_draw_list_end(self.rendering_device.singleton_ptr)

    # Override in subclasses to add custom draw commands
    pub fn render_draw_commands(mut self, draw_list: u64):
        # Base implementation does nothing
        pass

    # Enable/disable overlay rendering
    pub fn set_overlay_enabled(mut self, enabled: bool):
        self.overlay_enabled = enabled

        if enabled:
            println("Vulkan overlay enabled")
        else:
            println("Vulkan overlay disabled")


# 2D Vulkan Overlay
# Custom 2D UI rendered via Vulkan on top of Godot's scene
pub struct Vulkan2DOverlay extends VulkanCompositor:
    # Overlay properties
    elements: Array<OverlayElement>
    needs_redraw: bool

    # GPU resources
    vertex_buffer: Option<BufferRID>
    shader: Option<ShaderRID>
    pipeline: Option<u64>

    pub fn _ready(mut self):
        # Call parent _ready
        # super._ready()

        self.elements = []
        self.needs_redraw = true
        self.vertex_buffer = None
        self.shader = None
        self.pipeline = None

        # Create vertex buffer for overlay elements (max 1000 vertices, 24 bytes each)
        match self.rendering_device.create_buffer(1000 * 24, BufferUsage::Vertex):
            case Ok(buf): self.vertex_buffer = Some(buf)
            case Err(e): println("Failed to create vertex buffer: {e}")

        # Load or create a simple 2D color shader
        self.initialize_shader()

        println("Vulkan 2D Overlay ready!")

    # Initialize shader and pipeline for 2D overlay rendering
    fn initialize_shader(mut self):
        # Simple 2D color shader SPIR-V (would need to be loaded from resources)
        # For now, we try to load a pre-compiled shader
        val shader_spirv = get_overlay_shader_spirv()

        if shader_spirv.len() > 0:
            match self.rendering_device.create_shader(&shader_spirv):
                case Ok(shader):
                    self.shader = Some(shader)

                    # Get framebuffer format (RGBA8, no depth)
                    val fb_format = self.rendering_device.get_framebuffer_format(
                        37,  # VK_FORMAT_R8G8B8A8_UNORM
                        0    # No depth
                    )

                    # Create pipeline with position+color vertex format
                    val vertex_format = VertexFormat::position_color_2d()
                    match self.rendering_device.create_render_pipeline(shader, fb_format, vertex_format):
                        case Ok(pipe):
                            self.pipeline = Some(pipe.id)
                            println("Overlay pipeline created successfully")
                        case Err(e):
                            println("Failed to create pipeline: {e}")
                case Err(e):
                    println("Failed to create shader: {e}")
        else:
            println("No overlay shader SPIR-V available")

    # Add overlay element
    pub fn add_element(mut self, element: OverlayElement):
        self.elements.push(element)
        self.needs_redraw = true

    # Clear all elements
    pub fn clear_elements(mut self):
        self.elements.clear()
        self.needs_redraw = true

    # Called every frame
    pub fn _process(mut self, delta: f64, framebuffer: FramebufferRID):
        if self.needs_redraw and self.overlay_enabled:
            self.render_overlay(framebuffer)
            self.needs_redraw = false

    # Override render_draw_commands from VulkanCompositor
    pub fn render_draw_commands(mut self, draw_list: u64):
        if self.elements.len() == 0:
            return

        # Build vertex data for all elements
        var vertices: Array<u8> = []
        var vertex_count: u32 = 0

        for element in &self.elements:
            val element_vertices = self.build_element_vertices(element)
            vertices.extend(&element_vertices)
            vertex_count += match element.element_type:
                case ElementType::Rectangle: 6  # 2 triangles
                case ElementType::Circle: 36    # 12 triangles approximation
                case _: 6

        # Upload vertex data to GPU
        if val Some(vb) = &self.vertex_buffer:
            match self.rendering_device.update_buffer(*vb, 0, &vertices):
                case Ok(_): pass
                case Err(e): println("Failed to update vertex buffer: {e}")

        # Bind pipeline and draw (if we have one)
        if val Some(pipe) = self.pipeline:
            ffi.godot_rd_draw_list_bind_render_pipeline(
                self.rendering_device.singleton_ptr,
                draw_list,
                pipe
            )

            if val Some(vb) = &self.vertex_buffer:
                # Draw all elements
                ffi.godot_rd_draw_list_draw(
                    self.rendering_device.singleton_ptr,
                    draw_list,
                    false,  # Not using indices
                    vertex_count
                )

    # Build vertex data for a single element
    fn build_element_vertices(element: &OverlayElement) -> Array<u8>:
        var data: Array<u8> = []

        match element.element_type:
            case ElementType::Rectangle:
                # 2 triangles = 6 vertices
                # Each vertex: position (2 floats) + color (4 floats) = 24 bytes
                val x0 = element.x
                val y0 = element.y
                val x1 = element.x + element.width
                val y1 = element.y + element.height

                # Triangle 1: top-left, top-right, bottom-left
                data.extend(&vertex_to_bytes(x0, y0, &element.color))
                data.extend(&vertex_to_bytes(x1, y0, &element.color))
                data.extend(&vertex_to_bytes(x0, y1, &element.color))

                # Triangle 2: bottom-left, top-right, bottom-right
                data.extend(&vertex_to_bytes(x0, y1, &element.color))
                data.extend(&vertex_to_bytes(x1, y0, &element.color))
                data.extend(&vertex_to_bytes(x1, y1, &element.color))

            case ElementType::Circle:
                # Approximate circle with 12 triangles (fan from center)
                val cx = element.x + element.width / 2.0
                val cy = element.y + element.height / 2.0
                val rx = element.width / 2.0
                val ry = element.height / 2.0
                val segments = 12

                for i in 0..segments:
                    val angle0 = (i as f32) * 2.0 * 3.14159 / (segments as f32)
                    val angle1 = ((i + 1) as f32) * 2.0 * 3.14159 / (segments as f32)

                    # Center vertex
                    data.extend(&vertex_to_bytes(cx, cy, &element.color))
                    # Edge vertex 0
                    data.extend(&vertex_to_bytes(cx + rx * angle0.cos(), cy + ry * angle0.sin(), &element.color))
                    # Edge vertex 1
                    data.extend(&vertex_to_bytes(cx + rx * angle1.cos(), cy + ry * angle1.sin(), &element.color))

            case _:
                # Default: render as rectangle
                val x0 = element.x
                val y0 = element.y
                val x1 = element.x + element.width
                val y1 = element.y + element.height

                data.extend(&vertex_to_bytes(x0, y0, &element.color))
                data.extend(&vertex_to_bytes(x1, y0, &element.color))
                data.extend(&vertex_to_bytes(x0, y1, &element.color))
                data.extend(&vertex_to_bytes(x0, y1, &element.color))
                data.extend(&vertex_to_bytes(x1, y0, &element.color))
                data.extend(&vertex_to_bytes(x1, y1, &element.color))

        return data

# Helper: Convert vertex position + color to bytes
fn vertex_to_bytes(x: f32, y: f32, color: &Color) -> Array<u8>:
    var data: Array<u8> = []
    # Position (2 floats = 8 bytes)
    data.extend(&f32_to_le_bytes(x))
    data.extend(&f32_to_le_bytes(y))
    # Color (4 floats = 16 bytes)
    data.extend(&f32_to_le_bytes(color.r))
    data.extend(&f32_to_le_bytes(color.g))
    data.extend(&f32_to_le_bytes(color.b))
    data.extend(&f32_to_le_bytes(color.a))
    return data

fn f32_to_le_bytes(value: f32) -> Array<u8>:
    val bits = value.to_bits()
    var bytes: Array<u8> = []
    bytes.push((bits & 0xFF) as u8)
    bytes.push(((bits >> 8) & 0xFF) as u8)
    bytes.push(((bits >> 16) & 0xFF) as u8)
    bytes.push(((bits >> 24) & 0xFF) as u8)
    return bytes

fn u32_to_le_bytes(value: u32) -> Array<u8>:
    var bytes: Array<u8> = []
    bytes.push((value & 0xFF) as u8)
    bytes.push(((value >> 8) & 0xFF) as u8)
    bytes.push(((value >> 16) & 0xFF) as u8)
    bytes.push(((value >> 24) & 0xFF) as u8)
    return bytes

fn u64_to_le_bytes(value: u64) -> Array<u8>:
    var bytes: Array<u8> = []
    bytes.push((value & 0xFF) as u8)
    bytes.push(((value >> 8) & 0xFF) as u8)
    bytes.push(((value >> 16) & 0xFF) as u8)
    bytes.push(((value >> 24) & 0xFF) as u8)
    bytes.push(((value >> 32) & 0xFF) as u8)
    bytes.push(((value >> 40) & 0xFF) as u8)
    bytes.push(((value >> 48) & 0xFF) as u8)
    bytes.push(((value >> 56) & 0xFF) as u8)
    return bytes


# Overlay Element (UI component for Vulkan rendering)
pub struct OverlayElement:
    x: f32
    y: f32
    width: f32
    height: f32
    color: Color
    element_type: ElementType

pub enum ElementType:
    Rectangle
    Circle
    Text
    Image

impl ElementType:
    pub fn to_string(self) -> text:
        """Convert element type to string."""
        match self:
            case Rectangle: "Rectangle"
            case Circle: "Circle"
            case Text: "Text"
            case Image: "Image"

    pub fn description(self) -> text:
        """Get element type description."""
        match self:
            case Rectangle: "Rectangular overlay element"
            case Circle: "Circular overlay element"
            case Text: "Text overlay element"
            case Image: "Image/texture overlay element"

    pub fn is_rectangle(self) -> bool:
        """Check if element type is Rectangle."""
        match self:
            case Rectangle: true
            case _: false

    pub fn is_circle(self) -> bool:
        """Check if element type is Circle."""
        match self:
            case Circle: true
            case _: false

    pub fn is_text(self) -> bool:
        """Check if element type is Text."""
        match self:
            case Text: true
            case _: false

    pub fn is_image(self) -> bool:
        """Check if element type is Image."""
        match self:
            case Image: true
            case _: false

    pub fn is_shape(self) -> bool:
        """Check if element type is a geometric shape."""
        match self:
            case Rectangle: true
            case Circle: true
            case _: false

    pub fn is_textured(self) -> bool:
        """Check if element type requires texture/image data."""
        match self:
            case Text: true
            case Image: true
            case _: false

    pub fn is_simple_geometry(self) -> bool:
        """Check if element type uses simple color-only geometry."""
        match self:
            case Rectangle: true
            case Circle: true
            case _: false

    pub fn requires_font_atlas(self) -> bool:
        """Check if element type requires font atlas for rendering."""
        match self:
            case Text: true
            case _: false

    pub fn summary(self) -> text:
        """Get element type summary."""
        val name = self.to_string()
        val desc = self.description()
        var props = []
        if self.is_shape():
            props.push("shape")
        if self.is_textured():
            props.push("textured")
        if self.is_simple_geometry():
            props.push("simple-geometry")
        if self.requires_font_atlas():
            props.push("requires-font-atlas")
        if props.len() > 0:
            val props_str = ", ".join(props)
            return "ElementType: {name} ({desc}, {props_str})"
        else:
            return "ElementType: {name} ({desc})"

pub struct Color:
    r: f32
    g: f32
    b: f32
    a: f32

impl Color:
    pub fn rgba(r: f32, g: f32, b: f32, a: f32) -> Color:
        return Color(r: r, g: g, b: b, a: a)

    pub fn rgb(r: f32, g: f32, b: f32) -> Color:
        return Color::rgba(r, g, b, 1.0)

    pub fn white() -> Color:
        return Color::rgba(1.0, 1.0, 1.0, 1.0)

    pub fn black() -> Color:
        return Color::rgba(0.0, 0.0, 0.0, 1.0)

    pub fn transparent() -> Color:
        return Color::rgba(0.0, 0.0, 0.0, 0.0)


# =============================================================================
# Font Atlas for Text Rendering
# =============================================================================

# Glyph information for a single character
pub struct GlyphInfo:
    codepoint: u32      # Unicode codepoint
    x: u32              # X position in atlas
    y: u32              # Y position in atlas
    width: u32          # Glyph width in pixels
    height: u32         # Glyph height in pixels
    bearing_x: i32      # X offset from cursor
    bearing_y: i32      # Y offset from cursor (baseline)
    advance: u32        # Horizontal advance to next glyph

# Font atlas for GPU text rendering
pub struct FontAtlas:
    texture: Option<TextureRID>
    sampler: Option<SamplerRID>
    uniform_set: Option<UniformSetRID>
    atlas_width: u32
    atlas_height: u32
    glyphs: Array<GlyphInfo>
    line_height: u32
    ascender: i32
    descender: i32

impl FontAtlas:
    # Create a new empty font atlas
    pub fn new() -> FontAtlas:
        return FontAtlas {
            texture: None,
            sampler: None,
            uniform_set: None,
            atlas_width: 0,
            atlas_height: 0,
            glyphs: [],
            line_height: 0,
            ascender: 0,
            descender: 0
        }

    # Initialize font atlas with a pre-rendered bitmap
    pub fn from_bitmap(
        rendering_device: &mut RenderingDevice,
        width: u32,
        height: u32,
        bitmap_data: &Array<u8>,
        glyphs: Array<GlyphInfo>,
        line_height: u32
    ) -> Result<FontAtlas, text>:
        # Create texture for font atlas (R8 format for grayscale)
        val texture = match rendering_device.create_texture(
            width,
            height,
            TextureFormat::R8,
            TextureUsage::Sampling,
            Some(bitmap_data)
        ):
            case Ok(t): t
            case Err(e): return Err("Failed to create font texture: {e}")

        # Create sampler with linear filtering for smooth text
        val sampler = match rendering_device.create_sampler(
            SamplerFilter::Linear,
            AddressMode::ClampToEdge
        ):
            case Ok(s): s
            case Err(e):
                rendering_device.free_texture(texture)
                return Err("Failed to create sampler: {e}")

        return Ok(FontAtlas {
            texture: Some(texture),
            sampler: Some(sampler),
            uniform_set: None,
            atlas_width: width,
            atlas_height: height,
            glyphs: glyphs,
            line_height: line_height,
            ascender: 0,
            descender: 0
        })

    # Look up glyph info for a codepoint
    pub fn get_glyph(self, codepoint: u32) -> Option<&GlyphInfo>:
        for glyph in &self.glyphs:
            if glyph.codepoint == codepoint:
                return Some(glyph)
        return None

    # Calculate text width in pixels
    pub fn measure_text(self, text: &str) -> u32:
        var width: u32 = 0
        for ch in text.chars():
            val codepoint = ch as u32
            match self.get_glyph(codepoint):
                case Some(glyph): width += glyph.advance
                case None: width += self.line_height / 2  # Fallback for missing glyphs
        return width

    # Create a simple built-in monospace font atlas (ASCII only)
    pub fn create_builtin_monospace(
        rendering_device: &mut RenderingDevice
    ) -> Result<FontAtlas, text>:
        # Built-in 8x16 monospace font for ASCII characters 32-126
        # This creates a simple font atlas for basic text rendering
        val glyph_width: u32 = 8
        val glyph_height: u32 = 16
        val chars_per_row: u32 = 16
        val num_chars: u32 = 95  # ASCII 32-126
        val rows: u32 = (num_chars + chars_per_row - 1) / chars_per_row

        val atlas_width: u32 = chars_per_row * glyph_width  # 128 pixels
        val atlas_height: u32 = rows * glyph_height          # 96 pixels

        # Create bitmap data (placeholder - would be filled with actual font data)
        var bitmap_data: Array<u8> = Array::with_capacity((atlas_width * atlas_height) as usize)
        for i in 0..(atlas_width * atlas_height):
            bitmap_data.push(0)

        # Create glyph info for each ASCII character
        var glyphs: Array<GlyphInfo> = []
        for i in 0..num_chars:
            val codepoint = 32 + i
            val row = i / chars_per_row
            val col = i % chars_per_row
            glyphs.push(GlyphInfo {
                codepoint: codepoint,
                x: col * glyph_width,
                y: row * glyph_height,
                width: glyph_width,
                height: glyph_height,
                bearing_x: 0,
                bearing_y: glyph_height as i32,
                advance: glyph_width
            })

        return FontAtlas::from_bitmap(
            rendering_device,
            atlas_width,
            atlas_height,
            &bitmap_data,
            glyphs,
            glyph_height
        )

    # Free all GPU resources
    pub fn destroy(mut self, rendering_device: &mut RenderingDevice):
        if val Some(us) = self.uniform_set:
            rendering_device.free_uniform_set(us)
        if val Some(s) = self.sampler:
            rendering_device.free_sampler(s)
        if val Some(t) = self.texture:
            rendering_device.free_texture(t)


# =============================================================================
# Extended Overlay Elements for Text and Images
# =============================================================================

# Text overlay element with font rendering
pub struct TextElement:
    x: f32
    y: f32
    text: text
    color: Color
    font_atlas: Option<FontAtlas>
    scale: f32

impl TextElement:
    pub fn new(x: f32, y: f32, content: text, color: Color) -> TextElement:
        return TextElement {
            x: x,
            y: y,
            text: content,
            color: color,
            font_atlas: None,
            scale: 1.0
        }

    pub fn with_scale(mut self, scale: f32) -> TextElement:
        self.scale = scale
        return self

    pub fn set_font_atlas(mut self, atlas: FontAtlas):
        self.font_atlas = Some(atlas)

    # Build vertices for text rendering (textured quads)
    pub fn build_vertices(self) -> Array<u8>:
        var data: Array<u8> = []

        match &self.font_atlas:
            case Some(atlas):
                var cursor_x = self.x
                val cursor_y = self.y

                for ch in self.text.chars():
                    val codepoint = ch as u32
                    match atlas.get_glyph(codepoint):
                        case Some(glyph):
                            # Calculate quad positions
                            val x0 = cursor_x + (glyph.bearing_x as f32) * self.scale
                            val y0 = cursor_y - (glyph.bearing_y as f32) * self.scale
                            val x1 = x0 + (glyph.width as f32) * self.scale
                            val y1 = y0 + (glyph.height as f32) * self.scale

                            # Calculate UV coordinates
                            val u0 = (glyph.x as f32) / (atlas.atlas_width as f32)
                            val v0 = (glyph.y as f32) / (atlas.atlas_height as f32)
                            val u1 = ((glyph.x + glyph.width) as f32) / (atlas.atlas_width as f32)
                            val v1 = ((glyph.y + glyph.height) as f32) / (atlas.atlas_height as f32)

                            # Triangle 1: top-left, top-right, bottom-left
                            data.extend(&vertex_uv_to_bytes(x0, y0, u0, v0, &self.color))
                            data.extend(&vertex_uv_to_bytes(x1, y0, u1, v0, &self.color))
                            data.extend(&vertex_uv_to_bytes(x0, y1, u0, v1, &self.color))

                            # Triangle 2: bottom-left, top-right, bottom-right
                            data.extend(&vertex_uv_to_bytes(x0, y1, u0, v1, &self.color))
                            data.extend(&vertex_uv_to_bytes(x1, y0, u1, v0, &self.color))
                            data.extend(&vertex_uv_to_bytes(x1, y1, u1, v1, &self.color))

                            cursor_x += (glyph.advance as f32) * self.scale

                        case None:
                            # Skip unknown characters
                            cursor_x += (atlas.line_height as f32) * self.scale / 2.0
            case None:
                # No font atlas, can't render text
                pass

        return data

    # Get vertex count (6 vertices per character for 2 triangles)
    pub fn vertex_count(self) -> u32:
        return (self.text.len() * 6) as u32


# Image overlay element with texture
pub struct ImageElement:
    x: f32
    y: f32
    width: f32
    height: f32
    texture: Option<TextureRID>
    sampler: Option<SamplerRID>
    tint: Color
    uv_rect: UVRect  # UV coordinates for texture atlas support

impl ImageElement:
    pub fn new(x: f32, y: f32, width: f32, height: f32) -> ImageElement:
        return ImageElement {
            x: x,
            y: y,
            width: width,
            height: height,
            texture: None,
            sampler: None,
            tint: Color::white(),
            uv_rect: UVRect::full()
        }

    pub fn with_texture(mut self, texture: TextureRID, sampler: SamplerRID) -> ImageElement:
        self.texture = Some(texture)
        self.sampler = Some(sampler)
        return self

    pub fn with_tint(mut self, tint: Color) -> ImageElement:
        self.tint = tint
        return self

    pub fn with_uv_rect(mut self, uv_rect: UVRect) -> ImageElement:
        self.uv_rect = uv_rect
        return self

    # Build vertices for image rendering (textured quad)
    pub fn build_vertices(self) -> Array<u8>:
        var data: Array<u8> = []

        val x0 = self.x
        val y0 = self.y
        val x1 = self.x + self.width
        val y1 = self.y + self.height

        val u0 = self.uv_rect.u0
        val v0 = self.uv_rect.v0
        val u1 = self.uv_rect.u1
        val v1 = self.uv_rect.v1

        # Triangle 1: top-left, top-right, bottom-left
        data.extend(&vertex_uv_to_bytes(x0, y0, u0, v0, &self.tint))
        data.extend(&vertex_uv_to_bytes(x1, y0, u1, v0, &self.tint))
        data.extend(&vertex_uv_to_bytes(x0, y1, u0, v1, &self.tint))

        # Triangle 2: bottom-left, top-right, bottom-right
        data.extend(&vertex_uv_to_bytes(x0, y1, u0, v1, &self.tint))
        data.extend(&vertex_uv_to_bytes(x1, y0, u1, v0, &self.tint))
        data.extend(&vertex_uv_to_bytes(x1, y1, u1, v1, &self.tint))

        return data

    # Get vertex count (6 vertices for 2 triangles)
    pub fn vertex_count(self) -> u32:
        return 6


# UV rectangle for texture coordinates
pub struct UVRect:
    u0: f32
    v0: f32
    u1: f32
    v1: f32

impl UVRect:
    # Full texture (0,0 to 1,1)
    pub fn full() -> UVRect:
        return UVRect { u0: 0.0, v0: 0.0, u1: 1.0, v1: 1.0 }

    # Create UV rect from pixel coordinates
    pub fn from_pixels(x: u32, y: u32, w: u32, h: u32, tex_w: u32, tex_h: u32) -> UVRect:
        return UVRect {
            u0: (x as f32) / (tex_w as f32),
            v0: (y as f32) / (tex_h as f32),
            u1: ((x + w) as f32) / (tex_w as f32),
            v1: ((y + h) as f32) / (tex_h as f32)
        }


# Helper: Convert vertex position + UV + color to bytes (32 bytes per vertex)
fn vertex_uv_to_bytes(x: f32, y: f32, u: f32, v: f32, color: &Color) -> Array<u8>:
    var data: Array<u8> = []
    # Position (2 floats = 8 bytes)
    data.extend(&f32_to_le_bytes(x))
    data.extend(&f32_to_le_bytes(y))
    # UV (2 floats = 8 bytes)
    data.extend(&f32_to_le_bytes(u))
    data.extend(&f32_to_le_bytes(v))
    # Color (4 floats = 16 bytes)
    data.extend(&f32_to_le_bytes(color.r))
    data.extend(&f32_to_le_bytes(color.g))
    data.extend(&f32_to_le_bytes(color.b))
    data.extend(&f32_to_le_bytes(color.a))
    return data


# Array placeholder
pub struct Array<T>:
    items: Vec<T>

impl<T> Array<T>:
    pub fn push(mut self, item: T):
        pass

    pub fn clear(mut self):
        pass


# =============================================================================
# Shader SPIR-V Data
# =============================================================================

# Get pre-compiled SPIR-V bytecode for simple 2D overlay shader
# This is a minimal vertex+fragment shader for colored primitives
# Vertex shader: transforms position, passes color
# Fragment shader: outputs interpolated color
fn get_overlay_shader_spirv() -> Array<u8>:
    # In a real implementation, this would either:
    # 1. Load from a .spv file embedded in the binary
    # 2. Load from a resource file
    # 3. Compile from GLSL at runtime using shaderc
    #
    # For now, return empty array - the overlay will use Godot's
    # built-in CanvasItem shader fallback if available
    #
    # To enable custom overlay rendering, provide SPIR-V bytecode
    # compiled from the following GLSL:
    #
    # Vertex shader:
    # #version 450
    # layout(location = 0) in vec2 position;
    # layout(location = 1) in vec4 color;
    # layout(location = 0) out vec4 fragColor;
    # void main() {
    #     gl_Position = vec4(position, 0.0, 1.0);
    #     fragColor = color;
    # }
    #
    # Fragment shader:
    # #version 450
    # layout(location = 0) in vec4 fragColor;
    # layout(location = 0) out vec4 outColor;
    # void main() {
    #     outColor = fragColor;
    # }

    return []

# Load overlay shader from file
pub fn load_overlay_shader_from_file(path: &str) -> Result<Array<u8>, text>:
    # Would use fs::read_bytes in actual implementation
    return Err("File loading not implemented")
