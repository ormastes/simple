# Godot Save/Load System
#
# Type-safe wrappers for Godot's file I/O and configuration
#
# Features:
# - ConfigFile (INI-style save files)
# - FileAccess (binary and text file I/O)
# - Save game management
# - Settings persistence
#
# Based on: https://docs.godotengine.org/en/stable/classes/class_configfile.html

use godot.ffi
use godot.variant

mod saveload

# Config File
# INI-style configuration and save files
pub struct ConfigFile:
    ptr: ffi.GDExtensionObjectPtr

impl ConfigFile:
    # Create new config file
    pub fn new() -> ConfigFile:
        val ptr = ffi.godot_new_object("ConfigFile")
        return ConfigFile(ptr: ptr)

    # Load from file
    pub fn load(path: text) -> Result<ConfigFile, text>:
        var config = ConfigFile.new()
        val result = config.load_file(path)

        if result.is_ok():
            return Ok(config)
        else:
            return Err(result.unwrap_err())

    # Load file (instance method)
    me load_file(path: text) -> Result<(), text>:
        val obj = variant.Object.from_ptr(self.ptr)
        val path_var = variant.Variant.from_string(path)
        val result = obj.call1("load", path_var)

        val error_code = result.as_int()
        if error_code == 0:  # OK
            return Ok(())
        else:
            return Err("Failed to load config: error {error_code}")

    # Save to file
    pub fn save(self, path: text) -> Result<(), text>:
        val obj = variant.Object.from_ptr(self.ptr)
        val path_var = variant.Variant.from_string(path)
        val result = obj.call1("save", path_var)

        val error_code = result.as_int()
        if error_code == 0:
            return Ok(())
        else:
            return Err("Failed to save config: error {error_code}")

    # Set value
    pub fn set_value(mut self, section: text, key: text, value: variant.Variant):
        val obj = variant.Object.from_ptr(self.ptr)
        val section_var = variant.Variant.from_string(section)
        val key_var = variant.Variant.from_string(key)
        obj.call3("set_value", section_var, key_var, value)

    # Get value
    pub fn get_value(self, section: text, key: text, default: variant.Variant) -> variant.Variant:
        val obj = variant.Object.from_ptr(self.ptr)
        val section_var = variant.Variant.from_string(section)
        val key_var = variant.Variant.from_string(key)
        return obj.call3("get_value", section_var, key_var, default)

    # Check if has section
    pub fn has_section(self, section: text) -> bool:
        val obj = variant.Object.from_ptr(self.ptr)
        val section_var = variant.Variant.from_string(section)
        val result = obj.call1("has_section", section_var)
        return result.as_bool()

    # Check if has key
    pub fn has_section_key(self, section: text, key: text) -> bool:
        val obj = variant.Object.from_ptr(self.ptr)
        val section_var = variant.Variant.from_string(section)
        val key_var = variant.Variant.from_string(key)
        val result = obj.call2("has_section_key", section_var, key_var)
        return result.as_bool()

    # Erase section
    pub fn erase_section(mut self, section: text):
        val obj = variant.Object.from_ptr(self.ptr)
        val section_var = variant.Variant.from_string(section)
        obj.call1("erase_section", section_var)

    # Erase key
    pub fn erase_section_key(mut self, section: text, key: text):
        val obj = variant.Object.from_ptr(self.ptr)
        val section_var = variant.Variant.from_string(section)
        val key_var = variant.Variant.from_string(key)
        obj.call2("erase_section_key", section_var, key_var)

    # Get all sections
    pub fn get_sections(self) -> Array<text>:
        val obj = variant.Object.from_ptr(self.ptr)
        val result = obj.call0("get_sections")
        return result.as_packed_string_array()

    # Get all keys in section
    pub fn get_section_keys(self, section: text) -> Array<text>:
        val obj = variant.Object.from_ptr(self.ptr)
        val section_var = variant.Variant.from_string(section)
        val result = obj.call1("get_section_keys", section_var)
        return result.as_packed_string_array()

    # Clear all data
    pub fn clear(mut self):
        val obj = variant.Object.from_ptr(self.ptr)
        obj.call0("clear")

    # =========================================================================
    # Helper Methods
    # =========================================================================

    fn is_empty() -> bool:
        """Check if config file has no sections.

        Returns:
            true if empty

        Example:
            config.is_empty()  # → false
        """
        return self.get_sections().len() == 0

    fn has_key(section: text, key: text) -> bool:
        """Check if section and key exist (alias for has_section_key).

        Args:
            section: Section name
            key: Key name

        Returns:
            true if exists

        Example:
            config.has_key("player", "name")  # → true
        """
        return self.has_section_key(section, key)

    fn try_save(path: text) -> bool:
        """Try to save config, returning true on success.

        Args:
            path: File path

        Returns:
            true if saved successfully

        Example:
            config.try_save("user://config.cfg")  # → true
        """
        return self.save(path).is_ok()

    me remove_section(section: text):
        """Remove a section (alias for erase_section).

        Args:
            section: Section name

        Example:
            config.remove_section("old_data")
        """
        self.erase_section(section)

    me remove_key(section: text, key: text):
        """Remove a key (alias for erase_section_key).

        Args:
            section: Section name
            key: Key name

        Example:
            config.remove_key("player", "old_stat")
        """
        self.erase_section_key(section, key)

    fn summary() -> text:
        """Get config file summary.

        Returns:
            Human-readable summary

        Example:
            config.summary()
            # → "ConfigFile: 3 sections"
        """
        val count = self.get_sections().len()
        return "ConfigFile: {count} sections"


# File Access
# Low-level file I/O
pub struct FileAccess:
    ptr: ffi.GDExtensionObjectPtr

impl FileAccess:
    # Open file for reading
    pub fn open_read(path: text) -> Result<FileAccess, text>:
        return FileAccess.open(path, ModeFlags.Read)

    # Open file for writing
    pub fn open_write(path: text) -> Result<FileAccess, text>:
        return FileAccess.open(path, ModeFlags.Write)

    # Open file with mode
    pub fn open(path: text, mode: ModeFlags) -> Result<FileAccess, text>:
        val path_var = variant.Variant.from_string(path)
        val mode_var = variant.Variant.from_int(mode as i64)

        # Call FileAccess.open static method via godot_call_static
        val ptr = ffi.godot_call_static("FileAccess", "open", path_var, mode_var)

        if ptr == null:
            return Err("Failed to open file: {path}")
        else:
            return Ok(FileAccess(ptr: ptr))

    # Check if file exists
    pub fn file_exists(path: text) -> bool:
        val path_var = variant.Variant.from_string(path)
        # Call FileAccess.file_exists static method via godot_call_static_bool
        return ffi.godot_call_static_bool("FileAccess", "file_exists", path_var)

    # Read entire file as string
    pub fn get_as_text(self) -> text:
        val obj = variant.Object.from_ptr(self.ptr)
        val result = obj.call0("get_as_text")
        return result.as_string()

    # Store string to file
    pub fn store_string(mut self, text: text):
        val obj = variant.Object.from_ptr(self.ptr)
        val text_var = variant.Variant.from_string(text)
        obj.call1("store_string", text_var)

    # Read line
    pub fn get_line(self) -> text:
        val obj = variant.Object.from_ptr(self.ptr)
        val result = obj.call0("get_line")
        return result.as_string()

    # Store line
    pub fn store_line(mut self, line: text):
        val obj = variant.Object.from_ptr(self.ptr)
        val line_var = variant.Variant.from_string(line)
        obj.call1("store_line", line_var)

    # Read 32-bit integer
    pub fn get_32(self) -> i32:
        val obj = variant.Object.from_ptr(self.ptr)
        val result = obj.call0("get_32")
        return result.as_int() as i32

    # Store 32-bit integer
    pub fn store_32(mut self, value: i32):
        val obj = variant.Object.from_ptr(self.ptr)
        val val_var = variant.Variant.from_int(value as i64)
        obj.call1("store_32", val_var)

    # Read 64-bit integer
    pub fn get_64(self) -> i64:
        val obj = variant.Object.from_ptr(self.ptr)
        val result = obj.call0("get_64")
        return result.as_int()

    # Store 64-bit integer
    pub fn store_64(mut self, value: i64):
        val obj = variant.Object.from_ptr(self.ptr)
        val val_var = variant.Variant.from_int(value)
        obj.call1("store_64", val_var)

    # Read f32
    pub fn get_float(self) -> f32:
        val obj = variant.Object.from_ptr(self.ptr)
        val result = obj.call0("get_float")
        return result.as_float() as f32

    # Store f32
    pub fn store_float(mut self, value: f32):
        val obj = variant.Object.from_ptr(self.ptr)
        val val_var = variant.Variant.from_float(value as f64)
        obj.call1("store_float", val_var)

    # Read double
    pub fn get_double(self) -> f64:
        val obj = variant.Object.from_ptr(self.ptr)
        val result = obj.call0("get_double")
        return result.as_float()

    # Store double
    pub fn store_double(mut self, value: f64):
        val obj = variant.Object.from_ptr(self.ptr)
        val val_var = variant.Variant.from_float(value)
        obj.call1("store_double", val_var)

    # Check if at end of file
    pub fn eof_reached(self) -> bool:
        val obj = variant.Object.from_ptr(self.ptr)
        val result = obj.call0("eof_reached")
        return result.as_bool()

    # Get file position
    pub fn get_position(self) -> i64:
        val obj = variant.Object.from_ptr(self.ptr)
        val result = obj.call0("get_position")
        return result.as_int()

    # Seek to position
    pub fn seek(mut self, position: i64):
        val obj = variant.Object.from_ptr(self.ptr)
        val pos_var = variant.Variant.from_int(position)
        obj.call1("seek", pos_var)

    # Get file length
    pub fn get_length(self) -> i64:
        val obj = variant.Object.from_ptr(self.ptr)
        val result = obj.call0("get_length")
        return result.as_int()

    # Close file
    pub fn close(mut self):
        val obj = variant.Object.from_ptr(self.ptr)
        obj.call0("close")

    # =========================================================================
    # Helper Methods
    # =========================================================================

    fn is_eof() -> bool:
        """Check if at end of file (alias for eof_reached).

        Returns:
            true if at EOF

        Example:
            file.is_eof()  # → false
        """
        return self.eof_reached()

    fn has_more_data() -> bool:
        """Check if more data is available (not at EOF).

        Returns:
            true if not at EOF

        Example:
            file.has_more_data()  # → true
        """
        return not self.eof_reached()

    fn get_size() -> i64:
        """Get file length (alias for get_length).

        Returns:
            File size in bytes

        Example:
            file.get_size()  # → 1024
        """
        return self.get_length()

    fn is_empty() -> bool:
        """Check if file is empty (length is 0).

        Returns:
            true if empty

        Example:
            file.is_empty()  # → false
        """
        return self.get_length() == 0

    fn at_start() -> bool:
        """Check if at start of file (position is 0).

        Returns:
            true if at start

        Example:
            file.at_start()  # → true
        """
        return self.get_position() == 0

    me seek_start():
        """Seek to start of file (position 0).

        Example:
            file.seek_start()
        """
        self.seek(0)

    me seek_end():
        """Seek to end of file.

        Example:
            file.seek_end()
        """
        self.seek(self.get_length())

    fn read_text() -> text:
        """Read entire file as text (alias for get_as_text).

        Returns:
            File contents as string

        Example:
            text = file.read_text()
        """
        return self.get_as_text()

    me write_text(text: text):
        """Write text to file (alias for store_string).

        Args:
            text: Text to write

        Example:
            file.write_text("Hello, World!")
        """
        self.store_string(text)

    me write_line(line: text):
        """Write line to file (alias for store_line).

        Args:
            line: Line to write

        Example:
            file.write_line("log entry")
        """
        self.store_line(line)

    fn summary() -> text:
        """Get file access summary.

        Returns:
            Human-readable summary

        Example:
            file.summary()
            # → "FileAccess: size=1024, pos=512"
        """
        val size = self.get_length()
        val pos = self.get_position()
        return "FileAccess: size={size}, pos={pos}"


# File Mode Flags
pub enum ModeFlags:
    Read = 1
    Write = 2
    ReadWrite = 3
    WriteRead = 7

impl ModeFlags:
    pub fn to_string(self) -> text:
        """Convert mode flags to string."""
        match self:
            case Read: "Read"
            case Write: "Write"
            case ReadWrite: "ReadWrite"
            case WriteRead: "WriteRead"

    pub fn description(self) -> text:
        """Get mode flags description."""
        match self:
            case Read: "Read-only file access"
            case Write: "Write-only file access (creates/truncates file)"
            case ReadWrite: "Read and write file access"
            case WriteRead: "Write and read file access with creation"

    pub fn is_read(self) -> bool:
        """Check if mode is Read."""
        match self:
            case Read: true
            case _: false

    pub fn is_write(self) -> bool:
        """Check if mode is Write."""
        match self:
            case Write: true
            case _: false

    pub fn is_read_write(self) -> bool:
        """Check if mode is ReadWrite."""
        match self:
            case ReadWrite: true
            case _: false

    pub fn is_write_read(self) -> bool:
        """Check if mode is WriteRead."""
        match self:
            case WriteRead: true
            case _: false

    pub fn can_read(self) -> bool:
        """Check if mode allows reading."""
        match self:
            case Read: true
            case ReadWrite: true
            case WriteRead: true
            case _: false

    pub fn can_write(self) -> bool:
        """Check if mode allows writing."""
        match self:
            case Write: true
            case ReadWrite: true
            case WriteRead: true
            case _: false

    pub fn is_read_only(self) -> bool:
        """Check if mode is read-only (cannot write)."""
        match self:
            case Read: true
            case _: false

    pub fn is_write_only(self) -> bool:
        """Check if mode is write-only (cannot read)."""
        match self:
            case Write: true
            case _: false

    pub fn flag_value(self) -> i32:
        """Get the numeric flag value for Godot FileAccess API."""
        match self:
            case Read: 1
            case Write: 2
            case ReadWrite: 3
            case WriteRead: 7

    pub fn summary(self) -> text:
        """Get mode flags summary."""
        val name = self.to_string()
        val desc = self.description()
        var props = []
        if self.can_read():
            props.push("read")
        if self.can_write():
            props.push("write")
        if self.is_read_only():
            props.push("read-only")
        if self.is_write_only():
            props.push("write-only")
        val flag = self.flag_value()
        props.push("flag={flag}")
        if props.len() > 0:
            val props_str = ", ".join(props)
            return "ModeFlags: {name} ({desc}, {props_str})"
        else:
            return "ModeFlags: {name} ({desc})"


# Save Game Manager
# High-level save/load API
pub struct SaveGameManager:
    save_dir: text
    current_slot: i32

impl SaveGameManager:
    # Create new save manager
    pub fn new(save_dir: text = "user://saves/") -> SaveGameManager:
        return SaveGameManager(save_dir: save_dir, current_slot: 0)

    # Get save file path
    fn get_save_path(slot: i32) -> text:
        return "{self.save_dir}save_{slot}.cfg"

    # Save game state
    pub fn save_game(mut self, slot: i32, data: SaveData) -> Result<(), text>:
        var config = ConfigFile.new()

        # Player data
        config.set_value("player", "name", variant.Variant.from_string(data.player_name))
        config.set_value("player", "level", variant.Variant.from_int(data.player_level as i64))
        config.set_value("player", "health", variant.Variant.from_int(data.player_health as i64))
        config.set_value("player", "position_x", variant.Variant.from_float(data.position_x))
        config.set_value("player", "position_y", variant.Variant.from_float(data.position_y))

        # Game progress
        config.set_value("progress", "current_scene", variant.Variant.from_string(data.current_scene))
        config.set_value("progress", "playtime", variant.Variant.from_float(data.playtime))

        # Save to file
        val path = self.get_save_path(slot)
        val result = config.save(path)

        if result.is_ok():
            self.current_slot = slot
            println("Game saved to slot {slot}")
            return Ok(())
        else:
            return Err(result.unwrap_err())

    # Load game state
    pub fn load_game(mut self, slot: i32) -> Result<SaveData, text>:
        val path = self.get_save_path(slot)
        val result = ConfigFile.load(path)

        if result.is_err():
            return Err(result.unwrap_err())

        val config = result.unwrap()

        # Load player data
        val default_str = variant.Variant.from_string("")
        val default_int = variant.Variant.from_int(0)
        val default_float = variant.Variant.from_float(0.0)

        val name = config.get_value("player", "name", default_str).as_string()
        val level = config.get_value("player", "level", default_int).as_int() as i32
        val health = config.get_value("player", "health", default_int).as_int() as i32
        val pos_x = config.get_value("player", "position_x", default_float).as_float()
        val pos_y = config.get_value("player", "position_y", default_float).as_float()

        # Load progress
        val scene = config.get_value("progress", "current_scene", default_str).as_string()
        val playtime = config.get_value("progress", "playtime", default_float).as_float()

        val data = SaveData(
            player_name: name,
            player_level: level,
            player_health: health,
            position_x: pos_x,
            position_y: pos_y,
            current_scene: scene,
            playtime: playtime
        )

        self.current_slot = slot
        println("Game loaded from slot {slot}")

        return Ok(data)

    # Check if save exists
    pub fn has_save(self, slot: i32) -> bool:
        val path = self.get_save_path(slot)
        return FileAccess.file_exists(path)

    # Delete save
    pub fn delete_save(mut self, slot: i32) -> Result<(), text>:
        """Delete a save file.

        Args:
            slot: Save slot number

        Returns:
            Ok if successful, Err with message if failed
        """
        @extern("runtime", "rt_file_remove")
        fn _rt_file_remove(path_ptr: &u8, path_len: u64) -> bool

        val path = self.get_save_path(slot)
        val success = _rt_file_remove(path.ptr(), path.len())

        if success:
            return Ok(())
        else:
            return Err("Failed to delete save file: {path}")

    # Get all save slots
    pub fn get_save_slots(self) -> Array<i32>:
        var slots: Array<i32> = []

        for i in range(0, 10):
            if self.has_save(i):
                slots.push(i)

        return slots

    # =========================================================================
    # Helper Methods
    # =========================================================================

    fn is_slot_empty(slot: i32) -> bool:
        """Check if save slot is empty (no save file).

        Args:
            slot: Save slot number

        Returns:
            true if slot is empty

        Example:
            manager.is_slot_empty(0)  # → false
        """
        return not self.has_save(slot)

    me try_save_game(slot: i32, data: SaveData) -> bool:
        """Try to save game, returning true on success.

        Args:
            slot: Save slot number
            data: Save data to write

        Returns:
            true if saved successfully

        Example:
            manager.try_save_game(0, data)  # → true
        """
        return self.save_game(slot, data).is_ok()

    me try_load_game(slot: i32) -> Option<SaveData>:
        """Try to load game, returning None on failure.

        Args:
            slot: Save slot number

        Returns:
            Option containing save data or None

        Example:
            if val Some(data) = manager.try_load_game(0):
                # Use data
        """
        val result = self.load_game(slot)
        if result.is_ok():
            return Some(result.unwrap())
        else:
            return None

    me try_delete_save(slot: i32) -> bool:
        """Try to delete save, returning true on success.

        Args:
            slot: Save slot number

        Returns:
            true if deleted successfully

        Example:
            manager.try_delete_save(0)  # → true
        """
        return self.delete_save(slot).is_ok()

    fn get_current_slot() -> i32:
        """Get the currently active save slot.

        Returns:
            Current slot number

        Example:
            manager.get_current_slot()  # → 0
        """
        return self.current_slot

    fn has_any_saves() -> bool:
        """Check if there are any save files.

        Returns:
            true if at least one save exists

        Example:
            manager.has_any_saves()  # → true
        """
        return self.get_save_slots().len() > 0

    fn count_saves() -> i32:
        """Count the number of save files.

        Returns:
            Number of saves

        Example:
            manager.count_saves()  # → 3
        """
        return self.get_save_slots().len()

    fn summary() -> text:
        """Get save game manager summary.

        Returns:
            Human-readable summary

        Example:
            manager.summary()
            # → "SaveGameManager: 3 saves, current=0"
        """
        val count = self.count_saves()
        val current = self.current_slot
        return "SaveGameManager: {count} saves, current={current}"


# Save Data Structure
pub struct SaveData:
    # Player data
    player_name: text
    player_level: i32
    player_health: i32
    position_x: f64
    position_y: f64

    # Game progress
    current_scene: text
    playtime: f64


# Settings Manager
# Persistent game settings
pub struct SettingsManager:
    config: ConfigFile
    config_path: text

impl SettingsManager:
    # Create new settings manager
    pub fn new(config_path: text = "user://settings.cfg") -> SettingsManager:
        var config = ConfigFile.new()
        val _ = config.load_file(config_path)  # Ignore error if file doesn't exist

        return SettingsManager(config: config, config_path: config_path)

    # Get setting
    pub fn get_setting(self, key: text, default: variant.Variant) -> variant.Variant:
        return self.config.get_value("settings", key, default)

    # Set setting
    pub fn set_setting(mut self, key: text, value: variant.Variant):
        self.config.set_value("settings", key, value)

    # Save settings
    pub fn save(self) -> Result<(), text>:
        return self.config.save(self.config_path)

    # =========================================================================
    # Helper Methods
    # =========================================================================

    fn get(key: text, default: variant.Variant) -> variant.Variant:
        """Get setting value (alias for get_setting).

        Args:
            key: Setting key
            default: Default value if not found

        Returns:
            Setting value or default

        Example:
            volume = settings.get("volume", Variant.from_int(100))
        """
        return self.get_setting(key, default)

    me set(key: text, value: variant.Variant):
        """Set setting value (alias for set_setting).

        Args:
            key: Setting key
            value: Setting value

        Example:
            settings.set("volume", Variant.from_int(80))
        """
        self.set_setting(key, value)

    fn try_save() -> bool:
        """Try to save settings, returning true on success.

        Returns:
            true if saved successfully

        Example:
            settings.try_save()  # → true
        """
        return self.save().is_ok()

    fn has_setting(key: text) -> bool:
        """Check if setting exists.

        Args:
            key: Setting key

        Returns:
            true if setting exists

        Example:
            settings.has_setting("volume")  # → true
        """
        return self.config.has_section_key("settings", key)

    fn summary() -> text:
        """Get settings manager summary.

        Returns:
            Human-readable summary

        Example:
            settings.summary()
            # → "SettingsManager: path=user://settings.cfg"
        """
        return "SettingsManager: path={self.config_path}"


# Array placeholder
pub struct Array<T>:
    items: Vec<T>

impl<T> Array<T>:
    pub fn push(mut self, item: T):
        pass
