# Godot 3D Physics System
#
# Type-safe wrappers for Godot's 3D physics engine
#
# Features:
# - RigidBody3D (dynamic physics)
# - StaticBody3D (static colliders)
# - CharacterBody3D (kinematic control)
# - CollisionShape3D (shape definitions)
# - Area3D (trigger zones)
# - PhysicsServer3D (low-level physics API)
#
# Based on: https://docs.godotengine.org/en/stable/classes/class_rigidbody3d.html

import godot.ffi
import godot.variant
import godot.node3d

mod physics3d

# RigidBody3D
# Dynamic physics body with forces and collisions
pub struct RigidBody3D extends godot.node3d.Node3D:

impl RigidBody3D:
    # Create from Godot object pointer
    pub fn from_ptr(ptr: ffi.GDExtensionObjectPtr) -> RigidBody3D:
        return RigidBody3D(base: godot.node3d.Node3D.from_ptr(ptr))

    # Get linear velocity
    pub fn get_linear_velocity(self) -> (f64, f64, f64):
        val obj = self.base.as_node().as_object()
        val result = obj.call0("get_linear_velocity")
        return result.as_vector3()

    # Set linear velocity
    pub fn set_linear_velocity(mut self, x: f64, y: f64, z: f64):
        val obj = self.base.as_node().as_object()
        val vel_var = variant.Variant.from_vector3(x, y, z)
        obj.call1("set_linear_velocity", vel_var)

    # Get angular velocity
    pub fn get_angular_velocity(self) -> (f64, f64, f64):
        val obj = self.base.as_node().as_object()
        val result = obj.call0("get_angular_velocity")
        return (0.0, 0.0, 0.0)  # Placeholder

    # Set angular velocity
    pub fn set_angular_velocity(mut self, x: f64, y: f64, z: f64):
        val obj = self.base.as_node().as_object()
        val vel_var = variant.Variant.from_vector3(x, y, z)
        obj.call1("set_angular_velocity", vel_var)

    # Apply central impulse (instant velocity change)
    pub fn apply_central_impulse(mut self, x: f64, y: f64, z: f64):
        val obj = self.base.as_node().as_object()
        val impulse_var = variant.Variant.from_vector3(x, y, z)
        obj.call1("apply_central_impulse", impulse_var)

    # Apply impulse at position
    pub fn apply_impulse(mut self, impulse_x: f64, impulse_y: f64, impulse_z: f64, position_x: f64, position_y: f64, position_z: f64):
        val obj = self.base.as_node().as_object()
        val impulse_var = variant.Variant.from_vector3(impulse_x, impulse_y, impulse_z)
        val position_var = variant.Variant.from_vector3(position_x, position_y, position_z)
        obj.call2("apply_impulse", impulse_var, position_var)

    # Apply torque impulse (rotational)
    pub fn apply_torque_impulse(mut self, torque_x: f64, torque_y: f64, torque_z: f64):
        val obj = self.base.as_node().as_object()
        val torque_var = variant.Variant.from_vector3(torque_x, torque_y, torque_z)
        obj.call1("apply_torque_impulse", torque_var)

    # Apply central force (continuous)
    pub fn apply_central_force(mut self, x: f64, y: f64, z: f64):
        val obj = self.base.as_node().as_object()
        val force_var = variant.Variant.from_vector3(x, y, z)
        obj.call1("apply_central_force", force_var)

    # Apply force at position
    pub fn apply_force(mut self, force_x: f64, force_y: f64, force_z: f64, position_x: f64, position_y: f64, position_z: f64):
        val obj = self.base.as_node().as_object()
        val force_var = variant.Variant.from_vector3(force_x, force_y, force_z)
        val position_var = variant.Variant.from_vector3(position_x, position_y, position_z)
        obj.call2("apply_force", force_var, position_var)

    # Apply torque
    pub fn apply_torque(mut self, torque_x: f64, torque_y: f64, torque_z: f64):
        val obj = self.base.as_node().as_object()
        val torque_var = variant.Variant.from_vector3(torque_x, torque_y, torque_z)
        obj.call1("apply_torque", torque_var)

    # Set mass
    pub fn set_mass(mut self, mass: f64):
        val obj = self.base.as_node().as_object()
        val mass_var = variant.Variant.from_float(mass)
        obj.call1("set_mass", mass_var)

    # Get mass
    pub fn get_mass(self) -> f64:
        val obj = self.base.as_node().as_object()
        val result = obj.call0("get_mass")
        return result.as_float()

    # Set gravity scale
    pub fn set_gravity_scale(mut self, scale: f64):
        val obj = self.base.as_node().as_object()
        val scale_var = variant.Variant.from_float(scale)
        obj.call1("set_gravity_scale", scale_var)

    # Set continuous collision detection
    pub fn set_continuous_cd(mut self, enabled: bool):
        val obj = self.base.as_node().as_object()
        val cd_var = variant.Variant.from_bool(enabled)
        obj.call1("set_continuous_cd", cd_var)

    # Set whether body can sleep
    pub fn set_can_sleep(mut self, enabled: bool):
        val obj = self.base.as_node().as_object()
        val sleep_var = variant.Variant.from_bool(enabled)
        obj.call1("set_can_sleep", sleep_var)

    # Check if sleeping
    pub fn is_sleeping(self) -> bool:
        val obj = self.base.as_node().as_object()
        val result = obj.call0("is_sleeping")
        return result.as_bool()

    # Set freeze mode
    pub fn set_freeze_enabled(mut self, enabled: bool):
        val obj = self.base.as_node().as_object()
        val freeze_var = variant.Variant.from_bool(enabled)
        obj.call1("set_freeze_enabled", freeze_var)

    # Set lock axes (prevent movement/rotation on specific axes)
    pub fn set_axis_lock(mut self, axis: BodyAxis, lock: bool):
        val obj = self.base.as_node().as_object()
        val axis_var = variant.Variant.from_int(axis as i64)
        val lock_var = variant.Variant.from_bool(lock)
        obj.call2("set_axis_lock", axis_var, lock_var)

    # =========================================================================
    # Helper Methods
    # =========================================================================

    pub fn is_awake(self) -> bool:
        """Check if body is awake (not sleeping).

        Returns:
            true if not sleeping

        Example:
            body.is_awake()  # → true
        """
        return not self.is_sleeping()

    pub fn enable_continuous_cd(mut self):
        """Enable continuous collision detection.

        Example:
            body.enable_continuous_cd()
        """
        self.set_continuous_cd(true)

    pub fn disable_continuous_cd(mut self):
        """Disable continuous collision detection.

        Example:
            body.disable_continuous_cd()
        """
        self.set_continuous_cd(false)

    pub fn allow_sleeping(mut self):
        """Allow body to sleep when at rest.

        Example:
            body.allow_sleeping()
        """
        self.set_can_sleep(true)

    pub fn prevent_sleeping(mut self):
        """Prevent body from sleeping.

        Example:
            body.prevent_sleeping()
        """
        self.set_can_sleep(false)

    pub fn freeze(mut self):
        """Freeze the body (stop all physics).

        Example:
            body.freeze()
        """
        self.set_freeze_enabled(true)

    pub fn unfreeze(mut self):
        """Unfreeze the body (resume physics).

        Example:
            body.unfreeze()
        """
        self.set_freeze_enabled(false)

    pub fn lock_axis(mut self, axis: BodyAxis):
        """Lock a specific axis (prevent movement/rotation).

        Args:
            axis: The axis to lock

        Example:
            body.lock_axis(BodyAxis.LinearY)
        """
        self.set_axis_lock(axis, true)

    pub fn unlock_axis(mut self, axis: BodyAxis):
        """Unlock a specific axis (allow movement/rotation).

        Args:
            axis: The axis to unlock

        Example:
            body.unlock_axis(BodyAxis.LinearY)
        """
        self.set_axis_lock(axis, false)

    pub fn summary(self) -> text:
        """Get rigid body 3D summary.

        Returns:
            Human-readable summary

        Example:
            body.summary()
            # → "RigidBody3D: mass=10.0, awake"
        """
        val mass = self.get_mass()
        val state = if self.is_sleeping() { "sleeping" } else { "awake" }
        return "RigidBody3D: mass={mass}, {state}"


# StaticBody3D
# Static collider (doesn't move)
pub struct StaticBody3D extends godot.node3d.Node3D:

impl StaticBody3D:
    pub fn from_ptr(ptr: ffi.GDExtensionObjectPtr) -> StaticBody3D:
        return StaticBody3D(base: godot.node3d.Node3D.from_ptr(ptr))

    # Set constant linear velocity (for moving platforms)
    pub fn set_constant_linear_velocity(mut self, x: f64, y: f64, z: f64):
        val obj = self.base.as_node().as_object()
        val vel_var = variant.Variant.from_vector3(x, y, z)
        obj.call1("set_constant_linear_velocity", vel_var)

    # Set constant angular velocity (for rotating platforms)
    pub fn set_constant_angular_velocity(mut self, x: f64, y: f64, z: f64):
        val obj = self.base.as_node().as_object()
        val vel_var = variant.Variant.from_vector3(x, y, z)
        obj.call1("set_constant_angular_velocity", vel_var)


# CharacterBody3D
# Kinematic body for player/NPC control
pub struct CharacterBody3D extends godot.node3d.Node3D:

impl CharacterBody3D:
    pub fn from_ptr(ptr: ffi.GDExtensionObjectPtr) -> CharacterBody3D:
        return CharacterBody3D(base: godot.node3d.Node3D.from_ptr(ptr))

    # Set velocity
    pub fn set_velocity(mut self, x: f64, y: f64, z: f64):
        val obj = self.base.as_node().as_object()
        val vel_var = variant.Variant.from_vector3(x, y, z)
        obj.call1("set_velocity", vel_var)

    # Get velocity
    pub fn get_velocity(self) -> (f64, f64, f64):
        val obj = self.base.as_node().as_object()
        val result = obj.call0("get_velocity")
        return (0.0, 0.0, 0.0)  # Placeholder

    # Move and slide (kinematic movement with collision)
    pub fn move_and_slide(mut self):
        val obj = self.base.as_node().as_object()
        obj.call0("move_and_slide")

    # Check if on floor
    pub fn is_on_floor(self) -> bool:
        val obj = self.base.as_node().as_object()
        val result = obj.call0("is_on_floor")
        return result.as_bool()

    # Check if on ceiling
    pub fn is_on_ceiling(self) -> bool:
        val obj = self.base.as_node().as_object()
        val result = obj.call0("is_on_ceiling")
        return result.as_bool()

    # Check if on wall
    pub fn is_on_wall(self) -> bool:
        val obj = self.base.as_node().as_object()
        val result = obj.call0("is_on_wall")
        return result.as_bool()

    # Get floor normal
    pub fn get_floor_normal(self) -> (f64, f64, f64):
        val obj = self.base.as_node().as_object()
        val result = obj.call0("get_floor_normal")
        return (0.0, 1.0, 0.0)  # Placeholder

    # Get wall normal
    pub fn get_wall_normal(self) -> (f64, f64, f64):
        val obj = self.base.as_node().as_object()
        val result = obj.call0("get_wall_normal")
        return (0.0, 0.0, 0.0)  # Placeholder

    # Set up direction (for slope detection)
    pub fn set_up_direction(mut self, x: f64, y: f64, z: f64):
        val obj = self.base.as_node().as_object()
        val dir_var = variant.Variant.from_vector3(x, y, z)
        obj.call1("set_up_direction", dir_var)

    # Set floor max angle (in radians)
    pub fn set_floor_max_angle(mut self, angle: f64):
        val obj = self.base.as_node().as_object()
        val angle_var = variant.Variant.from_float(angle)
        obj.call1("set_floor_max_angle", angle_var)

    # Set floor snap length
    pub fn set_floor_snap_length(mut self, length: f64):
        val obj = self.base.as_node().as_object()
        val len_var = variant.Variant.from_float(length)
        obj.call1("set_floor_snap_length", len_var)

    # Get slide collision count
    pub fn get_slide_collision_count(self) -> i32:
        val obj = self.base.as_node().as_object()
        val result = obj.call0("get_slide_collision_count")
        return result.as_int() as i32

    # =========================================================================
    # Helper Methods
    # =========================================================================

    pub fn is_grounded(self) -> bool:
        """Check if body is on floor (alias for is_on_floor).

        Returns:
            true if on floor

        Example:
            body.is_grounded()  # → true
        """
        return self.is_on_floor()

    pub fn is_in_air(self) -> bool:
        """Check if body is in air (not on floor).

        Returns:
            true if not on floor

        Example:
            body.is_in_air()  # → false
        """
        return not self.is_on_floor()

    pub fn has_collisions(self) -> bool:
        """Check if body has any slide collisions.

        Returns:
            true if collision count > 0

        Example:
            body.has_collisions()  # → true
        """
        return self.get_slide_collision_count() > 0

    pub fn summary(self) -> text:
        """Get character body 3D summary.

        Returns:
            Human-readable summary

        Example:
            body.summary()
            # → "CharacterBody3D: grounded, 2 collisions"
        """
        val ground = if self.is_grounded() { "grounded" } else { "in air" }
        val collisions = self.get_slide_collision_count()
        return "CharacterBody3D: {ground}, {collisions} collisions"


# Area3D
# Trigger zone without physics
pub struct Area3D extends godot.node3d.Node3D:

impl Area3D:
    pub fn from_ptr(ptr: ffi.GDExtensionObjectPtr) -> Area3D:
        return Area3D(base: godot.node3d.Node3D.from_ptr(ptr))

    # Set monitoring (detect overlaps)
    pub fn set_monitoring(mut self, enable: bool):
        val obj = self.base.as_node().as_object()
        val mon_var = variant.Variant.from_bool(enable)
        obj.call1("set_monitoring", mon_var)

    # Set monitorable (can be detected)
    pub fn set_monitorable(mut self, enable: bool):
        val obj = self.base.as_node().as_object()
        val mon_var = variant.Variant.from_bool(enable)
        obj.call1("set_monitorable", mon_var)

    # Get overlapping bodies
    pub fn get_overlapping_bodies(self) -> Array<RigidBody3D>:
        val obj = self.base.as_node().as_object()
        val result = obj.call0("get_overlapping_bodies")
        # Returns TypedArray<Node3D> - parsing Node arrays requires P3 work
        # For now return empty, full typed array parsing requires P3 work
        return []

    # Get overlapping areas
    pub fn get_overlapping_areas(self) -> Array<Area3D>:
        val obj = self.base.as_node().as_object()
        val result = obj.call0("get_overlapping_areas")
        return []  # Placeholder

    # Check if overlaps body
    pub fn overlaps_body(self, body: RigidBody3D) -> bool:
        val obj = self.base.as_node().as_object()
        val body_var = variant.Variant.from_object(body.base.as_node().as_object())
        val result = obj.call1("overlaps_body", body_var)
        return result.as_bool()

    # Set gravity (area-specific gravity)
    pub fn set_gravity(mut self, gravity: f64):
        val obj = self.base.as_node().as_object()
        val grav_var = variant.Variant.from_float(gravity)
        obj.call1("set_gravity", grav_var)

    # Set gravity direction
    pub fn set_gravity_direction(mut self, x: f64, y: f64, z: f64):
        val obj = self.base.as_node().as_object()
        val dir_var = variant.Variant.from_vector3(x, y, z)
        obj.call1("set_gravity_direction", dir_var)

    # =========================================================================
    # Helper Methods
    # =========================================================================

    pub fn enable_monitoring(mut self):
        """Enable monitoring (detect overlaps).

        Example:
            area.enable_monitoring()
        """
        self.set_monitoring(true)

    pub fn disable_monitoring(mut self):
        """Disable monitoring (stop detecting overlaps).

        Example:
            area.disable_monitoring()
        """
        self.set_monitoring(false)

    pub fn enable_monitorable(mut self):
        """Make area monitorable (can be detected).

        Example:
            area.enable_monitorable()
        """
        self.set_monitorable(true)

    pub fn disable_monitorable(mut self):
        """Make area non-monitorable (cannot be detected).

        Example:
            area.disable_monitorable()
        """
        self.set_monitorable(false)

    pub fn has_overlapping_bodies(self) -> bool:
        """Check if area has any overlapping bodies.

        Returns:
            true if has overlapping bodies

        Example:
            area.has_overlapping_bodies()  # → true
        """
        return self.get_overlapping_bodies().len() > 0

    pub fn has_overlapping_areas(self) -> bool:
        """Check if area has any overlapping areas.

        Returns:
            true if has overlapping areas

        Example:
            area.has_overlapping_areas()  # → false
        """
        return self.get_overlapping_areas().len() > 0

    pub fn is_empty(self) -> bool:
        """Check if area has no overlapping bodies or areas.

        Returns:
            true if no overlaps

        Example:
            area.is_empty()  # → false
        """
        return not self.has_overlapping_bodies() and not self.has_overlapping_areas()

    pub fn summary(self) -> text:
        """Get area 3D summary.

        Returns:
            Human-readable summary

        Example:
            area.summary()
            # → "Area3D: 3 bodies, 1 area"
        """
        val bodies = self.get_overlapping_bodies().len()
        val areas = self.get_overlapping_areas().len()
        return "Area3D: {bodies} bodies, {areas} areas"


# CollisionShape3D
# Shape definition for physics bodies
pub struct CollisionShape3D extends godot.node3d.Node3D:

impl CollisionShape3D:
    pub fn from_ptr(ptr: ffi.GDExtensionObjectPtr) -> CollisionShape3D:
        return CollisionShape3D(base: godot.node3d.Node3D.from_ptr(ptr))

    # Set shape resource
    pub fn set_shape(mut self, shape: Shape3D):
        val obj = self.base.as_node().as_object()
        val shape_var = variant.Variant.from_object(shape.resource.as_object())
        obj.call1("set_shape", shape_var)

    # Set disabled
    pub fn set_disabled(mut self, disabled: bool):
        val obj = self.base.as_node().as_object()
        val dis_var = variant.Variant.from_bool(disabled)
        obj.call1("set_disabled", dis_var)

    # =========================================================================
    # Helper Methods
    # =========================================================================

    pub fn enable(mut self):
        """Enable collision shape.

        Example:
            shape.enable()
        """
        self.set_disabled(false)

    pub fn disable(mut self):
        """Disable collision shape.

        Example:
            shape.disable()
        """
        self.set_disabled(true)

    pub fn summary(self) -> text:
        """Get collision shape 3D summary.

        Returns:
            Human-readable summary

        Example:
            shape.summary()
            # → "CollisionShape3D: enabled"
        """
        return "CollisionShape3D: enabled"


# Shape3D Resource
pub struct Shape3D:
    resource: godot.resource.Resource

impl Shape3D:
    pub fn from_resource(res: godot.resource.Resource) -> Shape3D:
        return Shape3D(resource: res)


# Physics Server 3D
# Low-level physics API
pub struct PhysicsServer3D:
    singleton_ptr: ffi.GDExtensionObjectPtr

impl PhysicsServer3D:
    # Get singleton
    pub fn get_singleton() -> PhysicsServer3D:
        val ptr = ffi.godot_get_singleton("PhysicsServer3D")
        return PhysicsServer3D(singleton_ptr: ptr)

    # Set active (enable/disable physics)
    pub fn set_active(mut self, active: bool):
        val obj = variant.Object.from_ptr(self.singleton_ptr)
        val active_var = variant.Variant.from_bool(active)
        obj.call1("set_active", active_var)

    # Step simulation manually
    pub fn step(mut self, delta: f64):
        val obj = variant.Object.from_ptr(self.singleton_ptr)
        val delta_var = variant.Variant.from_float(delta)
        obj.call1("step", delta_var)

    # Flush queries (process collision detection)
    pub fn flush_queries(mut self):
        val obj = variant.Object.from_ptr(self.singleton_ptr)
        obj.call0("flush_queries")

    # =========================================================================
    # Helper Methods
    # =========================================================================

    pub fn enable(mut self):
        """Enable physics simulation.

        Example:
            server.enable()
        """
        self.set_active(true)

    pub fn disable(mut self):
        """Disable physics simulation.

        Example:
            server.disable()
        """
        self.set_active(false)

    pub fn summary(self) -> text:
        """Get physics server 3D summary.

        Returns:
            Human-readable summary

        Example:
            server.summary()
            # → "PhysicsServer3D: active"
        """
        return "PhysicsServer3D: active"


# Enums

pub enum BodyAxis:
    LinearX = 1
    LinearY = 2
    LinearZ = 4
    AngularX = 8
    AngularY = 16
    AngularZ = 32

impl BodyAxis:
    pub fn to_string(self) -> text:
        """Convert body axis to string."""
        match self:
            case LinearX: "LinearX"
            case LinearY: "LinearY"
            case LinearZ: "LinearZ"
            case AngularX: "AngularX"
            case AngularY: "AngularY"
            case AngularZ: "AngularZ"

    pub fn description(self) -> text:
        """Get body axis description."""
        match self:
            case LinearX: "Linear movement on X axis"
            case LinearY: "Linear movement on Y axis"
            case LinearZ: "Linear movement on Z axis"
            case AngularX: "Rotation around X axis"
            case AngularY: "Rotation around Y axis"
            case AngularZ: "Rotation around Z axis"

    pub fn is_linear_x(self) -> bool:
        """Check if axis is LinearX."""
        match self:
            case LinearX: true
            case _: false

    pub fn is_linear_y(self) -> bool:
        """Check if axis is LinearY."""
        match self:
            case LinearY: true
            case _: false

    pub fn is_linear_z(self) -> bool:
        """Check if axis is LinearZ."""
        match self:
            case LinearZ: true
            case _: false

    pub fn is_angular_x(self) -> bool:
        """Check if axis is AngularX."""
        match self:
            case AngularX: true
            case _: false

    pub fn is_angular_y(self) -> bool:
        """Check if axis is AngularY."""
        match self:
            case AngularY: true
            case _: false

    pub fn is_angular_z(self) -> bool:
        """Check if axis is AngularZ."""
        match self:
            case AngularZ: true
            case _: false

    pub fn is_linear(self) -> bool:
        """Check if axis is linear (translational movement)."""
        match self:
            case LinearX: true
            case LinearY: true
            case LinearZ: true
            case _: false

    pub fn is_angular(self) -> bool:
        """Check if axis is angular (rotational movement)."""
        match self:
            case AngularX: true
            case AngularY: true
            case AngularZ: true
            case _: false

    pub fn is_x_axis(self) -> bool:
        """Check if axis is X (linear or angular)."""
        match self:
            case LinearX: true
            case AngularX: true
            case _: false

    pub fn is_y_axis(self) -> bool:
        """Check if axis is Y (linear or angular)."""
        match self:
            case LinearY: true
            case AngularY: true
            case _: false

    pub fn is_z_axis(self) -> bool:
        """Check if axis is Z (linear or angular)."""
        match self:
            case LinearZ: true
            case AngularZ: true
            case _: false

    pub fn bitmask_value(self) -> i32:
        """Get the bitmask value for this axis.

        These values are used by Godot's physics system to lock specific axes.
        Multiple axes can be combined using bitwise OR.
        """
        match self:
            case LinearX: 1
            case LinearY: 2
            case LinearZ: 4
            case AngularX: 8
            case AngularY: 16
            case AngularZ: 32

    pub fn summary(self) -> text:
        """Get body axis summary."""
        val name = self.to_string()
        val desc = self.description()
        val bitmask = self.bitmask_value()
        var props = []
        if self.is_linear():
            props.push("linear")
        if self.is_angular():
            props.push("angular")
        props.push("bitmask={bitmask}")
        if props.len() > 0:
            val props_str = ", ".join(props)
            return "BodyAxis: {name} ({desc}, {props_str})"
        else:
            return "BodyAxis: {name} ({desc})"


# Array placeholder
pub struct Array<T>:
    items: Vec<T>
