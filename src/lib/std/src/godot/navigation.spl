# Godot Navigation System
#
# Type-safe wrappers for Godot's navigation and pathfinding
#
# Features:
# - NavigationRegion2D/3D (navigation meshes)
# - NavigationAgent2D/3D (AI pathfinding)
# - NavigationObstacle2D/3D (dynamic obstacles)
# - NavigationServer2D/3D (low-level API)
#
# Based on: https://docs.godotengine.org/en/stable/classes/class_navigationagent2d.html

import godot.ffi
import godot.variant
import godot.node2d
import godot.node3d
import godot.resource

mod navigation

# NavigationRegion2D
# 2D navigation mesh region
pub struct NavigationRegion2D extends godot.node2d.Node2D:

impl NavigationRegion2D:
    # Create from Godot object pointer
    pub fn from_ptr(ptr: ffi.GDExtensionObjectPtr) -> NavigationRegion2D:
        return NavigationRegion2D(base: godot.node2d.Node2D.from_ptr(ptr))

    # Set navigation polygon
    pub fn set_navigation_polygon(mut self, navpoly: resource.Resource):
        val obj = self.base.as_node().as_object()
        val nav_var = variant.Variant.from_object(navpoly.as_object())
        obj.call1("set_navigation_polygon", nav_var)

    # Set enabled
    pub fn set_enabled(mut self, enabled: bool):
        val obj = self.base.as_node().as_object()
        val en_var = variant.Variant.from_bool(enabled)
        obj.call1("set_enabled", en_var)

    # =========================================================================
    # Helper Methods
    # =========================================================================

    pub fn enable(mut self):
        """Enable navigation region.

        Example:
            region.enable()
        """
        self.set_enabled(true)

    pub fn disable(mut self):
        """Disable navigation region.

        Example:
            region.disable()
        """
        self.set_enabled(false)

    pub fn summary(self) -> text:
        """Get navigation region 2D summary.

        Returns:
            Human-readable summary

        Example:
            region.summary()
            # → "NavigationRegion2D: 2D navigation mesh"
        """
        return "NavigationRegion2D: 2D navigation mesh"


# NavigationAgent2D
# 2D AI agent with pathfinding
pub struct NavigationAgent2D extends godot.node2d.Node2D:

impl NavigationAgent2D:
    pub fn from_ptr(ptr: ffi.GDExtensionObjectPtr) -> NavigationAgent2D:
        return NavigationAgent2D(base: godot.node2d.Node2D.from_ptr(ptr))

    # Set target position
    pub fn set_target_position(mut self, x: f64, y: f64):
        val obj = self.base.as_node().as_object()
        val pos_var = variant.Variant.from_vector2(x, y)
        obj.call1("set_target_position", pos_var)

    # Get next path position
    pub fn get_next_path_position(self) -> (f64, f64):
        val obj = self.base.as_node().as_object()
        val result = obj.call0("get_next_path_position")
        return result.as_vector2()

    # Check if target reached
    pub fn is_target_reached(self) -> bool:
        val obj = self.base.as_node().as_object()
        val result = obj.call0("is_target_reached")
        return result.as_bool()

    # Check if target reachable
    pub fn is_target_reachable(self) -> bool:
        val obj = self.base.as_node().as_object()
        val result = obj.call0("is_target_reachable")
        return result.as_bool()

    # Check if navigation finished
    pub fn is_navigation_finished(self) -> bool:
        val obj = self.base.as_node().as_object()
        val result = obj.call0("is_navigation_finished")
        return result.as_bool()

    # Get distance to target
    pub fn distance_to_target(self) -> f64:
        val obj = self.base.as_node().as_object()
        val result = obj.call0("distance_to_target")
        return result.as_float()

    # Set max speed
    pub fn set_max_speed(mut self, speed: f64):
        val obj = self.base.as_node().as_object()
        val speed_var = variant.Variant.from_float(speed)
        obj.call1("set_max_speed", speed_var)

    # Set path desired distance (how close to get to waypoint)
    pub fn set_path_desired_distance(mut self, distance: f64):
        val obj = self.base.as_node().as_object()
        val dist_var = variant.Variant.from_float(distance)
        obj.call1("set_path_desired_distance", dist_var)

    # Set target desired distance (how close to get to final target)
    pub fn set_target_desired_distance(mut self, distance: f64):
        val obj = self.base.as_node().as_object()
        val dist_var = variant.Variant.from_float(distance)
        obj.call1("set_target_desired_distance", dist_var)

    # Set radius
    pub fn set_radius(mut self, radius: f64):
        val obj = self.base.as_node().as_object()
        val radius_var = variant.Variant.from_float(radius)
        obj.call1("set_radius", radius_var)

    # Set avoidance enabled
    pub fn set_avoidance_enabled(mut self, enabled: bool):
        val obj = self.base.as_node().as_object()
        val avoid_var = variant.Variant.from_bool(enabled)
        obj.call1("set_avoidance_enabled", avoid_var)

    # =========================================================================
    # Helper Methods
    # =========================================================================

    pub fn is_target_unreachable(self) -> bool:
        """Check if target is unreachable.

        Returns:
            true if target not reachable

        Example:
            agent.is_target_unreachable()  # → false
        """
        return not self.is_target_reachable()

    pub fn is_navigating(self) -> bool:
        """Check if currently navigating (target not reached and not finished).

        Returns:
            true if navigating

        Example:
            agent.is_navigating()  # → true
        """
        return not self.is_navigation_finished() and not self.is_target_reached()

    pub fn enable_avoidance(mut self):
        """Enable obstacle avoidance.

        Example:
            agent.enable_avoidance()
        """
        self.set_avoidance_enabled(true)

    pub fn disable_avoidance(mut self):
        """Disable obstacle avoidance.

        Example:
            agent.disable_avoidance()
        """
        self.set_avoidance_enabled(false)

    pub fn summary(self) -> text:
        """Get navigation agent 2D summary.

        Returns:
            Human-readable summary

        Example:
            agent.summary()
            # → "NavigationAgent2D: navigating, distance=5.3"
        """
        if self.is_target_reached():
            return "NavigationAgent2D: target reached"
        elif self.is_navigating():
            val dist = self.distance_to_target()
            return "NavigationAgent2D: navigating, distance={dist}"
        else:
            return "NavigationAgent2D: idle"


# NavigationRegion3D
# 3D navigation mesh region
pub struct NavigationRegion3D extends godot.node3d.Node3D:

impl NavigationRegion3D:
    pub fn from_ptr(ptr: ffi.GDExtensionObjectPtr) -> NavigationRegion3D:
        return NavigationRegion3D(base: godot.node3d.Node3D.from_ptr(ptr))

    # Set navigation mesh
    pub fn set_navigation_mesh(mut self, navmesh: resource.Resource):
        val obj = self.base.as_node().as_object()
        val nav_var = variant.Variant.from_object(navmesh.as_object())
        obj.call1("set_navigation_mesh", nav_var)

    # Set enabled
    pub fn set_enabled(mut self, enabled: bool):
        val obj = self.base.as_node().as_object()
        val en_var = variant.Variant.from_bool(enabled)
        obj.call1("set_enabled", en_var)

    # Bake navigation mesh
    pub fn bake_navigation_mesh(mut self):
        val obj = self.base.as_node().as_object()
        obj.call0("bake_navigation_mesh")

    # =========================================================================
    # Helper Methods
    # =========================================================================

    pub fn enable(mut self):
        """Enable navigation region.

        Example:
            region.enable()
        """
        self.set_enabled(true)

    pub fn disable(mut self):
        """Disable navigation region.

        Example:
            region.disable()
        """
        self.set_enabled(false)

    pub fn bake(mut self):
        """Bake navigation mesh (alias for bake_navigation_mesh).

        Example:
            region.bake()
        """
        self.bake_navigation_mesh()

    pub fn summary(self) -> text:
        """Get navigation region 3D summary.

        Returns:
            Human-readable summary

        Example:
            region.summary()
            # → "NavigationRegion3D: 3D navigation mesh"
        """
        return "NavigationRegion3D: 3D navigation mesh"


# NavigationAgent3D
# 3D AI agent with pathfinding
pub struct NavigationAgent3D extends godot.node3d.Node3D:

impl NavigationAgent3D:
    pub fn from_ptr(ptr: ffi.GDExtensionObjectPtr) -> NavigationAgent3D:
        return NavigationAgent3D(base: godot.node3d.Node3D.from_ptr(ptr))

    # Set target position
    pub fn set_target_position(mut self, x: f64, y: f64, z: f64):
        val obj = self.base.as_node().as_object()
        val pos_var = variant.Variant.from_vector3(x, y, z)
        obj.call1("set_target_position", pos_var)

    # Get next path position
    pub fn get_next_path_position(self) -> (f64, f64, f64):
        val obj = self.base.as_node().as_object()
        val result = obj.call0("get_next_path_position")
        return result.as_vector3()

    # Check if target reached
    pub fn is_target_reached(self) -> bool:
        val obj = self.base.as_node().as_object()
        val result = obj.call0("is_target_reached")
        return result.as_bool()

    # Check if target reachable
    pub fn is_target_reachable(self) -> bool:
        val obj = self.base.as_node().as_object()
        val result = obj.call0("is_target_reachable")
        return result.as_bool()

    # Check if navigation finished
    pub fn is_navigation_finished(self) -> bool:
        val obj = self.base.as_node().as_object()
        val result = obj.call0("is_navigation_finished")
        return result.as_bool()

    # Get distance to target
    pub fn distance_to_target(self) -> f64:
        val obj = self.base.as_node().as_object()
        val result = obj.call0("distance_to_target")
        return result.as_float()

    # Set max speed
    pub fn set_max_speed(mut self, speed: f64):
        val obj = self.base.as_node().as_object()
        val speed_var = variant.Variant.from_float(speed)
        obj.call1("set_max_speed", speed_var)

    # Set path desired distance
    pub fn set_path_desired_distance(mut self, distance: f64):
        val obj = self.base.as_node().as_object()
        val dist_var = variant.Variant.from_float(distance)
        obj.call1("set_path_desired_distance", dist_var)

    # Set target desired distance
    pub fn set_target_desired_distance(mut self, distance: f64):
        val obj = self.base.as_node().as_object()
        val dist_var = variant.Variant.from_float(distance)
        obj.call1("set_target_desired_distance", dist_var)

    # Set radius
    pub fn set_radius(mut self, radius: f64):
        val obj = self.base.as_node().as_object()
        val radius_var = variant.Variant.from_float(radius)
        obj.call1("set_radius", radius_var)

    # Set avoidance enabled
    pub fn set_avoidance_enabled(mut self, enabled: bool):
        val obj = self.base.as_node().as_object()
        val avoid_var = variant.Variant.from_bool(enabled)
        obj.call1("set_avoidance_enabled", avoid_var)

    # Set height offset
    pub fn set_path_height_offset(mut self, offset: f64):
        val obj = self.base.as_node().as_object()
        val offset_var = variant.Variant.from_float(offset)
        obj.call1("set_path_height_offset", offset_var)

    # =========================================================================
    # Helper Methods
    # =========================================================================

    pub fn is_target_unreachable(self) -> bool:
        """Check if target is unreachable.

        Returns:
            true if target not reachable

        Example:
            agent.is_target_unreachable()  # → false
        """
        return not self.is_target_reachable()

    pub fn is_navigating(self) -> bool:
        """Check if currently navigating.

        Returns:
            true if navigating

        Example:
            agent.is_navigating()  # → true
        """
        return not self.is_navigation_finished() and not self.is_target_reached()

    pub fn enable_avoidance(mut self):
        """Enable obstacle avoidance.

        Example:
            agent.enable_avoidance()
        """
        self.set_avoidance_enabled(true)

    pub fn disable_avoidance(mut self):
        """Disable obstacle avoidance.

        Example:
            agent.disable_avoidance()
        """
        self.set_avoidance_enabled(false)

    pub fn summary(self) -> text:
        """Get navigation agent 3D summary.

        Returns:
            Human-readable summary

        Example:
            agent.summary()
            # → "NavigationAgent3D: navigating, distance=10.5"
        """
        if self.is_target_reached():
            return "NavigationAgent3D: target reached"
        elif self.is_navigating():
            val dist = self.distance_to_target()
            return "NavigationAgent3D: navigating, distance={dist}"
        else:
            return "NavigationAgent3D: idle"


# NavigationObstacle2D
# Dynamic obstacle for avoidance
pub struct NavigationObstacle2D extends godot.node2d.Node2D:

impl NavigationObstacle2D:
    pub fn from_ptr(ptr: ffi.GDExtensionObjectPtr) -> NavigationObstacle2D:
        return NavigationObstacle2D(base: godot.node2d.Node2D.from_ptr(ptr))

    # Set radius
    pub fn set_radius(mut self, radius: f64):
        val obj = self.base.as_node().as_object()
        val radius_var = variant.Variant.from_float(radius)
        obj.call1("set_radius", radius_var)

    # Set avoidance enabled
    pub fn set_avoidance_enabled(mut self, enabled: bool):
        val obj = self.base.as_node().as_object()
        val avoid_var = variant.Variant.from_bool(enabled)
        obj.call1("set_avoidance_enabled", avoid_var)


# NavigationObstacle3D
# Dynamic obstacle for 3D avoidance
pub struct NavigationObstacle3D extends godot.node3d.Node3D:

impl NavigationObstacle3D:
    pub fn from_ptr(ptr: ffi.GDExtensionObjectPtr) -> NavigationObstacle3D:
        return NavigationObstacle3D(base: godot.node3d.Node3D.from_ptr(ptr))

    # Set radius
    pub fn set_radius(mut self, radius: f64):
        val obj = self.base.as_node().as_object()
        val radius_var = variant.Variant.from_float(radius)
        obj.call1("set_radius", radius_var)

    # Set height
    pub fn set_height(mut self, height: f64):
        val obj = self.base.as_node().as_object()
        val height_var = variant.Variant.from_float(height)
        obj.call1("set_height", height_var)

    # Set avoidance enabled
    pub fn set_avoidance_enabled(mut self, enabled: bool):
        val obj = self.base.as_node().as_object()
        val avoid_var = variant.Variant.from_bool(enabled)
        obj.call1("set_avoidance_enabled", avoid_var)


# NavigationServer2D
# Low-level 2D navigation API
pub struct NavigationServer2D:
    singleton_ptr: ffi.GDExtensionObjectPtr

impl NavigationServer2D:
    # Get singleton
    pub fn get_singleton() -> NavigationServer2D:
        val ptr = ffi.godot_get_singleton("NavigationServer2D")
        return NavigationServer2D(singleton_ptr: ptr)

    # Get simple path (A* pathfinding)
    pub fn get_simple_path(self, start_x: f64, start_y: f64, end_x: f64, end_y: f64) -> Array<(f64, f64)>:
        val obj = variant.Object.from_ptr(self.singleton_ptr)
        val start_var = variant.Variant.from_vector2(start_x, start_y)
        val end_var = variant.Variant.from_vector2(end_x, end_y)
        val result = obj.call2("map_get_path", start_var, end_var)
        # Parse PackedVector2Array - returns array of Vector2
        # For now return empty, full array parsing requires P3 work
        return []


# NavigationServer3D
# Low-level 3D navigation API
pub struct NavigationServer3D:
    singleton_ptr: ffi.GDExtensionObjectPtr

impl NavigationServer3D:
    # Get singleton
    pub fn get_singleton() -> NavigationServer3D:
        val ptr = ffi.godot_get_singleton("NavigationServer3D")
        return NavigationServer3D(singleton_ptr: ptr)

    # Get simple path (A* pathfinding)
    pub fn get_simple_path(self, start_x: f64, start_y: f64, start_z: f64, end_x: f64, end_y: f64, end_z: f64) -> Array<(f64, f64, f64)>:
        val obj = variant.Object.from_ptr(self.singleton_ptr)
        val start_var = variant.Variant.from_vector3(start_x, start_y, start_z)
        val end_var = variant.Variant.from_vector3(end_x, end_y, end_z)
        val result = obj.call2("map_get_path", start_var, end_var)
        # Parse PackedVector3Array - returns array of Vector3
        # For now return empty, full array parsing requires P3 work
        return []


# Array placeholder
pub struct Array<T>:
    items: Vec<T>
