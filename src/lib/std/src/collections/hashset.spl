# High-performance HashSet using Rust std::collections::HashSet
#
# Provides O(1) average-case operations for set membership and operations.
# Use this for fast deduplication and set operations on large collections.
#
# Example:
#   val set = HashSet.new()
#   set.insert(1)
#   set.insert(2)
#   set.insert(1)  # Duplicate, not inserted
#   val len = set.len()  # Returns 2

struct HashSet:
    handle: any  # RuntimeValue handle to Rust HashSet

impl HashSet:
    # Create a new empty HashSet
    static fn new() -> HashSet:
        val handle = __rt_hashset_new()
        HashSet(handle)

    # Insert a value
    # Returns true if the value was newly inserted, false if it already existed
    me insert(value: any) -> bool:
        __rt_hashset_insert(self.handle, value)

    # Check if a value exists
    fn contains(value: any) -> bool:
        __rt_hashset_contains(self.handle, value)

    # Remove a value
    # Returns true if the value was present
    me remove(value: any) -> bool:
        __rt_hashset_remove(self.handle, value)

    # Get the number of elements
    fn len() -> i64:
        __rt_hashset_len(self.handle)

    # Check if the set is empty
    fn is_empty() -> bool:
        self.len() == 0

    # Clear all elements
    me clear():
        __rt_hashset_clear(self.handle)

    # Get all elements as an array
    fn to_array() -> [any]:
        __rt_hashset_to_array(self.handle)

    # Union of two sets (returns new set with all elements from both)
    fn union(other: HashSet) -> HashSet:
        val handle = __rt_hashset_union(self.handle, other.handle)
        HashSet(handle)

    # Intersection of two sets (returns new set with common elements)
    fn intersection(other: HashSet) -> HashSet:
        val handle = __rt_hashset_intersection(self.handle, other.handle)
        HashSet(handle)

    # Difference of two sets (returns new set with elements in this but not other)
    fn difference(other: HashSet) -> HashSet:
        val handle = __rt_hashset_difference(self.handle, other.handle)
        HashSet(handle)

    # Symmetric difference (returns new set with elements in either but not both)
    fn symmetric_difference(other: HashSet) -> HashSet:
        val handle = __rt_hashset_symmetric_difference(self.handle, other.handle)
        HashSet(handle)

    # Check if this set is a subset of another
    fn is_subset(other: HashSet) -> bool:
        __rt_hashset_is_subset(self.handle, other.handle)

    # Check if this set is a superset of another
    fn is_superset(other: HashSet) -> bool:
        __rt_hashset_is_superset(self.handle, other.handle)

    # Iterate over elements
    fn each(f: fn(any) -> void):
        val elements = self.to_array()
        for element in elements:
            f(element)

    # Map over elements (returns new HashSet)
    fn map(f: fn(any) -> any) -> HashSet:
        val result = HashSet.new()
        val elements = self.to_array()
        for element in elements:
            result.insert(f(element))
        result

    # Filter elements (returns new HashSet)
    fn filter(predicate: fn(any) -> bool) -> HashSet:
        val result = HashSet.new()
        val elements = self.to_array()
        for element in elements:
            if predicate(element):
                result.insert(element)
        result

# FFI declarations
extern fn __rt_hashset_new() -> any
extern fn __rt_hashset_insert(handle: any, value: any) -> bool
extern fn __rt_hashset_contains(handle: any, value: any) -> bool
extern fn __rt_hashset_remove(handle: any, value: any) -> bool
extern fn __rt_hashset_len(handle: any) -> i64
extern fn __rt_hashset_clear(handle: any) -> bool
extern fn __rt_hashset_to_array(handle: any) -> [any]
extern fn __rt_hashset_union(handle1: any, handle2: any) -> any
extern fn __rt_hashset_intersection(handle1: any, handle2: any) -> any
extern fn __rt_hashset_difference(handle1: any, handle2: any) -> any
extern fn __rt_hashset_symmetric_difference(handle1: any, handle2: any) -> any
extern fn __rt_hashset_is_subset(handle1: any, handle2: any) -> bool
extern fn __rt_hashset_is_superset(handle1: any, handle2: any) -> bool
