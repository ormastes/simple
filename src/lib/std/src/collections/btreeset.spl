# Ordered set using Rust std::collections::BTreeSet
#
# Provides O(log n) operations with deterministic iteration order.
# Elements are kept sorted, making this ideal for ordered iteration and range queries.
#
# Example:
#   val set = BTreeSet.new()
#   set.insert(3)
#   set.insert(1)
#   set.insert(2)
#   val elements = set.to_array()  # Returns [1, 2, 3] in sorted order

struct BTreeSet:
    handle: any  # RuntimeValue handle to Rust BTreeSet

impl BTreeSet:
    # Create a new empty BTreeSet
    static fn new() -> BTreeSet:
        val handle = __rt_btreeset_new()
        BTreeSet(handle)

    # Insert a value
    # Returns true if the value was newly inserted, false if it already existed
    me insert(value: any) -> bool:
        __rt_btreeset_insert(self.handle, value)

    # Check if a value exists
    fn contains(value: any) -> bool:
        __rt_btreeset_contains(self.handle, value)

    # Remove a value
    # Returns true if the value was present
    me remove(value: any) -> bool:
        __rt_btreeset_remove(self.handle, value)

    # Get the number of elements
    fn len() -> i64:
        __rt_btreeset_len(self.handle)

    # Check if the set is empty
    fn is_empty() -> bool:
        self.len() == 0

    # Clear all elements
    me clear():
        __rt_btreeset_clear(self.handle)

    # Get all elements as an array (in sorted order)
    fn to_array() -> [any]:
        __rt_btreeset_to_array(self.handle)

    # Get the first (smallest) element
    fn first() -> any:
        __rt_btreeset_first(self.handle)

    # Get the last (largest) element
    fn last() -> any:
        __rt_btreeset_last(self.handle)

    # Union of two sets (returns new set with all elements from both)
    fn union(other: BTreeSet) -> BTreeSet:
        val handle = __rt_btreeset_union(self.handle, other.handle)
        BTreeSet(handle)

    # Intersection of two sets (returns new set with common elements)
    fn intersection(other: BTreeSet) -> BTreeSet:
        val handle = __rt_btreeset_intersection(self.handle, other.handle)
        BTreeSet(handle)

    # Difference of two sets (returns new set with elements in this but not other)
    fn difference(other: BTreeSet) -> BTreeSet:
        val handle = __rt_btreeset_difference(self.handle, other.handle)
        BTreeSet(handle)

    # Symmetric difference (returns new set with elements in either but not both)
    fn symmetric_difference(other: BTreeSet) -> BTreeSet:
        val handle = __rt_btreeset_symmetric_difference(self.handle, other.handle)
        BTreeSet(handle)

    # Check if this set is a subset of another
    fn is_subset(other: BTreeSet) -> bool:
        __rt_btreeset_is_subset(self.handle, other.handle)

    # Check if this set is a superset of another
    fn is_superset(other: BTreeSet) -> bool:
        __rt_btreeset_is_superset(self.handle, other.handle)

    # Iterate over elements (in sorted order)
    fn each(f: fn(any) -> void):
        val elements = self.to_array()
        for element in elements:
            f(element)

    # Map over elements (returns new BTreeSet)
    fn map(f: fn(any) -> any) -> BTreeSet:
        val result = BTreeSet.new()
        val elements = self.to_array()
        for element in elements:
            result.insert(f(element))
        result

    # Filter elements (returns new BTreeSet)
    fn filter(predicate: fn(any) -> bool) -> BTreeSet:
        val result = BTreeSet.new()
        val elements = self.to_array()
        for element in elements:
            if predicate(element):
                result.insert(element)
        result

# FFI declarations
extern fn __rt_btreeset_new() -> any
extern fn __rt_btreeset_insert(handle: any, value: any) -> bool
extern fn __rt_btreeset_contains(handle: any, value: any) -> bool
extern fn __rt_btreeset_remove(handle: any, value: any) -> bool
extern fn __rt_btreeset_len(handle: any) -> i64
extern fn __rt_btreeset_clear(handle: any) -> bool
extern fn __rt_btreeset_to_array(handle: any) -> [any]
extern fn __rt_btreeset_first(handle: any) -> any
extern fn __rt_btreeset_last(handle: any) -> any
extern fn __rt_btreeset_union(handle1: any, handle2: any) -> any
extern fn __rt_btreeset_intersection(handle1: any, handle2: any) -> any
extern fn __rt_btreeset_difference(handle1: any, handle2: any) -> any
extern fn __rt_btreeset_symmetric_difference(handle1: any, handle2: any) -> any
extern fn __rt_btreeset_is_subset(handle1: any, handle2: any) -> bool
extern fn __rt_btreeset_is_superset(handle1: any, handle2: any) -> bool
