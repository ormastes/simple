# High-performance HashMap using Rust std::collections::HashMap
#
# Provides O(1) average-case lookup, insert, and delete operations.
# Use this instead of Dict for better performance with large collections.
#
# Example:
#   val map = HashMap.new()
#   map.insert("key", "value")
#   val result = map.get("key")  # Returns "value"

struct HashMap:
    handle: any  # RuntimeValue handle to Rust HashMap

impl HashMap:
    # Create a new empty HashMap
    static fn new() -> HashMap:
        val handle = __rt_hashmap_new()
        HashMap(handle)

    # Insert a key-value pair
    # Returns true if the key was newly inserted, false if it already existed
    me insert(key: any, value: any) -> bool:
        __rt_hashmap_insert(self.handle, key, value)

    # Get a value by key
    # Returns the value if found, nil otherwise
    fn get(key: any) -> any:
        __rt_hashmap_get(self.handle, key)

    # Check if a key exists
    fn contains_key(key: any) -> bool:
        __rt_hashmap_contains_key(self.handle, key)

    # Remove a key-value pair
    # Returns the value if found, nil otherwise
    me remove(key: any) -> any:
        __rt_hashmap_remove(self.handle, key)

    # Get the number of entries
    fn len() -> i64:
        __rt_hashmap_len(self.handle)

    # Check if the map is empty
    fn is_empty() -> bool:
        self.len() == 0

    # Clear all entries
    me clear():
        __rt_hashmap_clear(self.handle)

    # Get all keys as an array
    fn keys() -> [any]:
        __rt_hashmap_keys(self.handle)

    # Get all values as an array
    fn values() -> [any]:
        __rt_hashmap_values(self.handle)

    # Get all entries as an array of [key, value] pairs
    fn entries() -> [[any]]:
        __rt_hashmap_entries(self.handle)

    # Iterate over key-value pairs
    fn each(f: fn(any, any) -> void):
        val entries = self.entries()
        for entry in entries:
            if entry.len() == 2:
                f(entry[0], entry[1])

    # Map over values (returns new HashMap with same keys)
    fn map_values(f: fn(any) -> any) -> HashMap:
        val result = HashMap.new()
        val entries = self.entries()
        for entry in entries:
            if entry.len() == 2:
                result.insert(entry[0], f(entry[1]))
        result

    # Filter entries (returns new HashMap)
    fn filter(predicate: fn(any, any) -> bool) -> HashMap:
        val result = HashMap.new()
        val entries = self.entries()
        for entry in entries:
            if entry.len() == 2:
                if predicate(entry[0], entry[1]):
                    result.insert(entry[0], entry[1])
        result

# FFI declarations
extern fn __rt_hashmap_new() -> any
extern fn __rt_hashmap_insert(handle: any, key: any, value: any) -> bool
extern fn __rt_hashmap_get(handle: any, key: any) -> any
extern fn __rt_hashmap_contains_key(handle: any, key: any) -> bool
extern fn __rt_hashmap_remove(handle: any, key: any) -> any
extern fn __rt_hashmap_len(handle: any) -> i64
extern fn __rt_hashmap_clear(handle: any) -> bool
extern fn __rt_hashmap_keys(handle: any) -> [any]
extern fn __rt_hashmap_values(handle: any) -> [any]
extern fn __rt_hashmap_entries(handle: any) -> [[any]]
