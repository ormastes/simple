# Common Shader Abstraction
#
# Engine-agnostic shader interface
# Works with both Godot Shaders and Unreal Materials
#
# Features:
# - Shader compilation
# - Uniform/parameter binding
# - Vertex and fragment shaders
# - Compute shaders
# - Cross-engine shader translation

use sys.ffi

mod shader

# ShaderStage
# Shader pipeline stages
pub enum ShaderStage:
    Vertex = 0
    Fragment = 1
    Geometry = 2
    Compute = 3
    TessellationControl = 4
    TessellationEvaluation = 5

impl ShaderStage:
    pub fn to_string(self) -> text:
        if self == ShaderStage.Vertex:
            return "Vertex"
        elif self == ShaderStage.Fragment:
            return "Fragment"
        elif self == ShaderStage.Geometry:
            return "Geometry"
        elif self == ShaderStage.Compute:
            return "Compute"
        elif self == ShaderStage.TessellationControl:
            return "TessellationControl"
        else:
            return "TessellationEvaluation"

    # =========================================================================
    # Helper Methods
    # =========================================================================

    pub fn description(self) -> text:
        """Get shader stage description.

        Returns:
            Human-readable description

        Example:
            ShaderStage.Vertex.description()
            # → "Vertex processing stage (transforms vertices)"
        """
        if self == ShaderStage.Vertex:
            return "Vertex processing stage (transforms vertices)"
        elif self == ShaderStage.Fragment:
            return "Fragment/pixel processing stage (colors pixels)"
        elif self == ShaderStage.Geometry:
            return "Geometry processing stage (generates primitives)"
        elif self == ShaderStage.Compute:
            return "Compute stage (general-purpose GPU compute)"
        elif self == ShaderStage.TessellationControl:
            return "Tessellation control stage (controls subdivision)"
        else:
            return "Tessellation evaluation stage (evaluates subdivided geometry)"

    pub fn is_vertex(self) -> bool:
        """Check if stage is Vertex.

        Returns:
            True if Vertex
        """
        return self == ShaderStage.Vertex

    pub fn is_fragment(self) -> bool:
        """Check if stage is Fragment.

        Returns:
            True if Fragment
        """
        return self == ShaderStage.Fragment

    pub fn is_geometry(self) -> bool:
        """Check if stage is Geometry.

        Returns:
            True if Geometry
        """
        return self == ShaderStage.Geometry

    pub fn is_compute(self) -> bool:
        """Check if stage is Compute.

        Returns:
            True if Compute
        """
        return self == ShaderStage.Compute

    pub fn is_tessellation_control(self) -> bool:
        """Check if stage is TessellationControl.

        Returns:
            True if TessellationControl
        """
        return self == ShaderStage.TessellationControl

    pub fn is_tessellation_evaluation(self) -> bool:
        """Check if stage is TessellationEvaluation.

        Returns:
            True if TessellationEvaluation
        """
        return self == ShaderStage.TessellationEvaluation

    pub fn is_graphics_stage(self) -> bool:
        """Check if stage is part of graphics pipeline.

        Returns:
            True for all stages except Compute

        Example:
            ShaderStage.Vertex.is_graphics_stage()  # → true
            ShaderStage.Compute.is_graphics_stage()  # → false
        """
        return self != ShaderStage.Compute

    pub fn is_tessellation_stage(self) -> bool:
        """Check if stage is tessellation-related.

        Returns:
            True for TessellationControl or TessellationEvaluation

        Example:
            ShaderStage.TessellationControl.is_tessellation_stage()  # → true
        """
        return self == ShaderStage.TessellationControl or self == ShaderStage.TessellationEvaluation

    pub fn is_rasterization_stage(self) -> bool:
        """Check if stage runs during rasterization.

        Returns:
            True for Vertex, Geometry, or Fragment

        Example:
            ShaderStage.Fragment.is_rasterization_stage()  # → true
        """
        return self == ShaderStage.Vertex or self == ShaderStage.Geometry or self == ShaderStage.Fragment

    pub fn summary(self) -> text:
        """Get shader stage summary.

        Returns:
            Human-readable summary

        Example:
            ShaderStage.Vertex.summary()
            # → "ShaderStage: Vertex (Vertex processing stage (transforms vertices), graphics, rasterization)"
        """
        val name = self.to_string()
        val desc = self.description()
        var props = []

        if self.is_graphics_stage():
            props.push("graphics")
        if self.is_compute():
            props.push("compute")
        if self.is_tessellation_stage():
            props.push("tessellation")
        if self.is_rasterization_stage():
            props.push("rasterization")

        if props.len() > 0:
            val props_str = ", ".join(props)
            return "ShaderStage: {name} ({desc}, {props_str})"
        else:
            return "ShaderStage: {name} ({desc})"


# ShaderUniform
# Shader uniform/parameter
pub struct ShaderUniform:
    name: text
    uniform_type: text  # "f32", "vec2", "vec3", "vec4", "mat4", "sampler2D", etc.
    default_value: ffi.VoidPtr

impl ShaderUniform:
    pub fn new(name: text, uniform_type: text) -> ShaderUniform:
        return ShaderUniform(
            name: name,
            uniform_type: uniform_type,
            default_value: ffi.null_ptr(),
        )

    pub fn get_name(self) -> text:
        return self.name

    pub fn get_type(self) -> text:
        return self.uniform_type

    # =========================================================================
    # Helper Methods
    # =========================================================================

    pub fn has_name(self) -> bool:
        """Check if uniform has non-empty name.

        Returns:
            true if name is not empty

        Example:
            uniform.has_name()  # → true
        """
        return self.name.len() > 0

    pub fn has_default_value(self) -> bool:
        """Check if uniform has default value set.

        Returns:
            true if default_value is not null

        Example:
            uniform.has_default_value()  # → false
        """
        return not ffi.is_null_ptr(self.default_value)

    pub fn is_scalar(self) -> bool:
        """Check if uniform type is scalar.

        Returns:
            true if type is f32 or i32

        Example:
            uniform.is_scalar()  # → true for "f32"
        """
        return self.uniform_type == "f32" or self.uniform_type == "i32"

    pub fn is_vector(self) -> bool:
        """Check if uniform type is vector.

        Returns:
            true if type is vec2/vec3/vec4

        Example:
            uniform.is_vector()  # → true for "vec3"
        """
        return self.uniform_type == "vec2" or self.uniform_type == "vec3" or self.uniform_type == "vec4"

    pub fn is_matrix(self) -> bool:
        """Check if uniform type is matrix.

        Returns:
            true if type is mat3/mat4

        Example:
            uniform.is_matrix()  # → true for "mat4"
        """
        return self.uniform_type == "mat3" or self.uniform_type == "mat4"

    pub fn is_texture(self) -> bool:
        """Check if uniform type is texture sampler.

        Returns:
            true if type contains "sampler"

        Example:
            uniform.is_texture()  # → true for "sampler2D"
        """
        return self.uniform_type.contains("sampler")

    pub fn summary(self) -> text:
        """Get shader uniform summary.

        Returns:
            Human-readable summary

        Example:
            uniform.summary()
            # → "ShaderUniform: 'mvp' (mat4, matrix)"
        """
        var props = []

        if self.is_scalar():
            props.push("scalar")
        if self.is_vector():
            props.push("vector")
        if self.is_matrix():
            props.push("matrix")
        if self.is_texture():
            props.push("texture")

        if props.len() > 0:
            val props_str = ", ".join(props)
            return "ShaderUniform: '{self.name}' ({self.uniform_type}, {props_str})"
        else:
            return "ShaderUniform: '{self.name}' ({self.uniform_type})"


# Shader trait
# Common interface for all shaders
pub trait Shader:
    # Compilation
    me compile() -> bool
    fn is_compiled() -> bool
    fn get_compile_errors() -> Vec<text>

    # Source code
    fn get_source(stage: ShaderStage) -> text
    me set_source(stage: ShaderStage, source: text)

    # Uniforms
    fn get_uniforms() -> Vec<ShaderUniform>
    fn has_uniform(name: text) -> bool
    me set_uniform_float(name: text, value: f32)
    me set_uniform_vec2(name: text, x: f32, y: f32)
    me set_uniform_vec3(name: text, x: f32, y: f32, z: f32)
    me set_uniform_vec4(name: text, x: f32, y: f32, z: f32, w: f32)
    me set_uniform_texture(name: text, texture_ptr: ffi.VoidPtr)


# GodotShaderAdapter
# Adapts Godot Shader to Shader trait
pub struct GodotShaderAdapter:
    shader_ptr: ffi.VoidPtr
    compiled: bool

impl GodotShaderAdapter:
    pub fn new(shader_ptr: ffi.VoidPtr) -> GodotShaderAdapter:
        return GodotShaderAdapter(
            shader_ptr: shader_ptr,
            compiled: false,
        )

    # =========================================================================
    # Helper Methods
    # =========================================================================

    pub fn has_shader(self) -> bool:
        """Check if has valid shader pointer.

        Returns:
            true if pointer is not null

        Example:
            adapter.has_shader()  # → true
        """
        return not ffi.is_null_ptr(self.shader_ptr)

    pub fn get_compiled_status(self) -> bool:
        """Get compiled status (alias for is_compiled).

        Returns:
            true if compiled

        Example:
            adapter.get_compiled_status()  # → false
        """
        return self.compiled

    pub fn summary(self) -> text:
        """Get Godot shader adapter summary.

        Returns:
            Human-readable summary

        Example:
            adapter.summary()
            # → "GodotShaderAdapter: compiled, has shader"
        """
        val compiled_str = if self.compiled { "compiled" } else { "not compiled" }
        val shader_str = if self.has_shader() { "has shader" } else { "no shader" }
        return "GodotShaderAdapter: {compiled_str}, {shader_str}"

impl Shader for GodotShaderAdapter:
    me compile() -> bool:
        val result = godot_shader_compile(self.shader_ptr)
        self.compiled = result
        return result

    fn is_compiled() -> bool:
        return self.compiled

    fn get_compile_errors() -> Vec<text>:
        val count_ptr = ffi.alloc_i32()
        val errors_ptr = godot_shader_get_errors(self.shader_ptr, count_ptr)
        val count = ffi.read_i32(count_ptr)

        var errors = Vec.new()
        for i in 0..count:
            val error_ptr = ffi.read_array_ptr(errors_ptr, i)
            errors.push(ffi.string_from_ptr(error_ptr))

        ffi.free(count_ptr)
        ffi.free(errors_ptr)

        return errors

    fn get_source(stage: ShaderStage) -> text:
        val source_ptr = godot_shader_get_source(self.shader_ptr, stage.to_string())
        return ffi.string_from_ptr(source_ptr)

    me set_source(stage: ShaderStage, source: text):
        godot_shader_set_source(self.shader_ptr, stage.to_string(), source)

    fn get_uniforms() -> Vec<ShaderUniform>:
        # Stub - would enumerate uniforms
        return []

    fn has_uniform(name: text) -> bool:
        return godot_shader_has_uniform(self.shader_ptr, name)

    me set_uniform_float(name: text, value: f32):
        godot_shader_set_uniform_float(self.shader_ptr, name, value)

    me set_uniform_vec2(name: text, x: f32, y: f32):
        godot_shader_set_uniform_vec2(self.shader_ptr, name, x, y)

    me set_uniform_vec3(name: text, x: f32, y: f32, z: f32):
        godot_shader_set_uniform_vec3(self.shader_ptr, name, x, y, z)

    me set_uniform_vec4(name: text, x: f32, y: f32, z: f32, w: f32):
        godot_shader_set_uniform_vec4(self.shader_ptr, name, x, y, z, w)

    me set_uniform_texture(name: text, texture_ptr: ffi.VoidPtr):
        godot_shader_set_uniform_texture(self.shader_ptr, name, texture_ptr)


# UnrealShaderAdapter
# Adapts Unreal Material (shader) to Shader trait
pub struct UnrealShaderAdapter:
    material_ptr: ffi.VoidPtr
    compiled: bool

impl UnrealShaderAdapter:
    pub fn new(material_ptr: ffi.VoidPtr) -> UnrealShaderAdapter:
        return UnrealShaderAdapter(
            material_ptr: material_ptr,
            compiled: true,  # Unreal materials are pre-compiled
        )

    # =========================================================================
    # Helper Methods
    # =========================================================================

    pub fn has_material(self) -> bool:
        """Check if has valid material pointer.

        Returns:
            true if pointer is not null

        Example:
            adapter.has_material()  # → true
        """
        return not ffi.is_null_ptr(self.material_ptr)

    pub fn get_compiled_status(self) -> bool:
        """Get compiled status (always true for Unreal).

        Returns:
            true (Unreal materials are pre-compiled)

        Example:
            adapter.get_compiled_status()  # → true
        """
        return self.compiled

    pub fn summary(self) -> text:
        """Get Unreal shader adapter summary.

        Returns:
            Human-readable summary

        Example:
            adapter.summary()
            # → "UnrealShaderAdapter: pre-compiled, has material"
        """
        val compiled_str = if self.compiled { "pre-compiled" } else { "not compiled" }
        val material_str = if self.has_material() { "has material" } else { "no material" }
        return "UnrealShaderAdapter: {compiled_str}, {material_str}"

impl Shader for UnrealShaderAdapter:
    me compile() -> bool:
        # Unreal materials compile at cook time
        return true

    fn is_compiled() -> bool:
        return self.compiled

    fn get_compile_errors() -> Vec<text>:
        return []

    fn get_source(stage: ShaderStage) -> text:
        # Unreal materials don't expose source directly
        return ""

    me set_source(stage: ShaderStage, source: text):
        # Cannot set source on Unreal materials
        pass

    fn get_uniforms() -> Vec<ShaderUniform>:
        return []

    fn has_uniform(name: text) -> bool:
        return unreal_material_has_parameter(self.material_ptr, name)

    me set_uniform_float(name: text, value: f32):
        unreal_material_set_scalar_parameter(self.material_ptr, name, value)

    me set_uniform_vec2(name: text, x: f32, y: f32):
        # Unreal doesn't have vec2, store as vec3
        unreal_material_set_vector_parameter(self.material_ptr, name, x, y, 0.0, 0.0)

    me set_uniform_vec3(name: text, x: f32, y: f32, z: f32):
        unreal_material_set_vector_parameter(self.material_ptr, name, x, y, z, 0.0)

    me set_uniform_vec4(name: text, x: f32, y: f32, z: f32, w: f32):
        unreal_material_set_vector_parameter(self.material_ptr, name, x, y, z, w)

    me set_uniform_texture(name: text, texture_ptr: ffi.VoidPtr):
        unreal_material_set_texture_parameter(self.material_ptr, name, texture_ptr)


# ShaderBuilder
# Fluent API for building shaders
pub struct ShaderBuilder:
    vertex_source: text
    fragment_source: text
    uniforms: Vec<ShaderUniform>

impl ShaderBuilder:
    pub fn new() -> ShaderBuilder:
        return ShaderBuilder(
            vertex_source: "",
            fragment_source: "",
            uniforms: [],
        )

    # =========================================================================
    # Helper Methods
    # =========================================================================

    pub fn has_vertex_source(self) -> bool:
        """Check if vertex source is set.

        Returns:
            true if vertex_source is not empty

        Example:
            builder.has_vertex_source()  # → false
        """
        return self.vertex_source.len() > 0

    pub fn has_fragment_source(self) -> bool:
        """Check if fragment source is set.

        Returns:
            true if fragment_source is not empty

        Example:
            builder.has_fragment_source()  # → false
        """
        return self.fragment_source.len() > 0

    pub fn has_uniforms(self) -> bool:
        """Check if any uniforms are added.

        Returns:
            true if uniforms list is not empty

        Example:
            builder.has_uniforms()  # → false
        """
        return self.uniforms.len() > 0

    pub fn uniform_count(self) -> usize:
        """Get number of uniforms.

        Returns:
            Uniform count

        Example:
            builder.uniform_count()  # → 0
        """
        return self.uniforms.len()

    pub fn is_complete(self) -> bool:
        """Check if builder has both vertex and fragment shaders.

        Returns:
            true if has both sources

        Example:
            builder.is_complete()  # → false
        """
        return self.has_vertex_source() and self.has_fragment_source()

    pub fn summary(self) -> text:
        """Get shader builder summary.

        Returns:
            Human-readable summary

        Example:
            builder.summary()
            # → "ShaderBuilder: vertex set, fragment set, 2 uniforms, complete"
        """
        val vertex_str = if self.has_vertex_source() { "vertex set" } else { "no vertex" }
        val fragment_str = if self.has_fragment_source() { "fragment set" } else { "no fragment" }
        val uniform_count = self.uniform_count()
        val complete_str = if self.is_complete() { ", complete" } else { ", incomplete" }
        return "ShaderBuilder: {vertex_str}, {fragment_str}, {uniform_count} uniforms{complete_str}"

    pub fn vertex(mut self, source: text) -> ShaderBuilder:
        self.vertex_source = source
        return self

    pub fn fragment(mut self, source: text) -> ShaderBuilder:
        self.fragment_source = source
        return self

    pub fn uniform(mut self, uniform: ShaderUniform) -> ShaderBuilder:
        self.uniforms.push(uniform)
        return self

    # Build for Godot
    pub fn build_godot(self) -> GodotShaderAdapter:
        val shader_ptr = godot_shader_create()
        val shader = GodotShaderAdapter.new(shader_ptr)

        if self.vertex_source != "":
            shader.set_source(ShaderStage.Vertex, self.vertex_source)

        if self.fragment_source != "":
            shader.set_source(ShaderStage.Fragment, self.fragment_source)

        return shader

    # Build for Unreal
    pub fn build_unreal(self) -> UnrealShaderAdapter:
        val material_ptr = unreal_material_create_dynamic()
        val shader = UnrealShaderAdapter.new(material_ptr)

        return shader


# Shader utility functions

# Create simple color shader
pub fn create_color_shader(r: f32, g: f32, b: f32, a: f32, engine: text) -> Shader:
    val vertex_src = """
    #version 330
    in vec3 position;
    uniform mat4 mvp;
    void main() {
        gl_Position = mvp * vec4(position, 1.0);
    }
    """

    val fragment_src = """
    #version 330
    uniform vec4 color;
    out vec4 fragColor;
    void main() {
        fragColor = color;
    }
    """

    var shader = ShaderBuilder.new()
        .vertex(vertex_src)
        .fragment(fragment_src)
        .uniform(ShaderUniform.new("mvp", "mat4"))
        .uniform(ShaderUniform.new("color", "vec4"))

    if engine == "godot":
        val godot_shader = shader.build_godot()
        godot_shader.set_uniform_vec4("color", r, g, b, a)
        return godot_shader
    else:
        val unreal_shader = shader.build_unreal()
        unreal_shader.set_uniform_vec4("color", r, g, b, a)
        return unreal_shader


# FFI declarations for Godot shaders
extern "C":
    fn godot_shader_create() -> ffi.VoidPtr
    fn godot_shader_compile(shader: ffi.VoidPtr) -> bool
    fn godot_shader_get_errors(shader: ffi.VoidPtr, count: ffi.VoidPtr) -> ffi.VoidPtr
    fn godot_shader_get_source(shader: ffi.VoidPtr, stage: text) -> ffi.VoidPtr
    fn godot_shader_set_source(shader: ffi.VoidPtr, stage: text, source: text)
    fn godot_shader_has_uniform(shader: ffi.VoidPtr, name: text) -> bool
    fn godot_shader_set_uniform_float(shader: ffi.VoidPtr, name: text, value: f32)
    fn godot_shader_set_uniform_vec2(shader: ffi.VoidPtr, name: text, x: f32, y: f32)
    fn godot_shader_set_uniform_vec3(shader: ffi.VoidPtr, name: text, x: f32, y: f32, z: f32)
    fn godot_shader_set_uniform_vec4(shader: ffi.VoidPtr, name: text, x: f32, y: f32, z: f32, w: f32)
    fn godot_shader_set_uniform_texture(shader: ffi.VoidPtr, name: text, texture: ffi.VoidPtr)

# FFI declarations for Unreal materials (shaders)
extern "C":
    fn unreal_material_create_dynamic() -> ffi.VoidPtr
    fn unreal_material_has_parameter(material: ffi.VoidPtr, name: text) -> bool
    fn unreal_material_set_scalar_parameter(material: ffi.VoidPtr, name: text, value: f32)
    fn unreal_material_set_vector_parameter(material: ffi.VoidPtr, name: text, x: f32, y: f32, z: f32, w: f32)
    fn unreal_material_set_texture_parameter(material: ffi.VoidPtr, name: text, texture: ffi.VoidPtr)


# Example usage:
#
# # Create shader using builder
# var shader = ShaderBuilder.new()
#     .vertex(vertex_source)
#     .fragment(fragment_source)
#     .uniform(ShaderUniform.new("time", "f32"))
#     .uniform(ShaderUniform.new("color", "vec4"))
#     .build_godot()
#
# # Compile and use
# if shader.compile():
#     shader.set_uniform_float("time", 1.0)
#     shader.set_uniform_vec4("color", 1.0, 0.0, 0.0, 1.0)
# else:
#     val errors = shader.get_compile_errors()
#     for error in errors:
#         print(error)
#
# # Create simple color shader
# val color_shader = create_color_shader(1.0, 0.5, 0.0, 1.0, "godot")
