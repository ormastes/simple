# Common Asset Loading Abstraction
#
# Engine-agnostic asset management interface
# Works with both Godot ResourceLoader and Unreal AssetManager
#
# Features:
# - Asset loading and unloading
# - Asset caching and reference counting
# - Async asset loading
# - Resource management
# - Type-safe asset handles

use sys.ffi

mod assets

# AssetType
# Common asset type identifiers
pub enum AssetType:
    Texture = 0
    Mesh = 1
    Material = 2
    Audio = 3
    Script = 4
    Scene = 5
    Unknown = 6

impl AssetType:
    pub fn to_string(self) -> text:
        if self == AssetType.Texture:
            return "Texture"
        elif self == AssetType.Mesh:
            return "Mesh"
        elif self == AssetType.Material:
            return "Material"
        elif self == AssetType.Audio:
            return "Audio"
        elif self == AssetType.Script:
            return "Script"
        elif self == AssetType.Scene:
            return "Scene"
        else:
            return "Unknown"

    # =========================================================================
    # Helper Methods
    # =========================================================================

    pub fn description(self) -> text:
        """Get asset type description.

        Returns:
            Human-readable description

        Example:
            AssetType.Texture.description()  # → "2D/3D texture image"
        """
        match self:
            case Texture: "2D/3D texture image"
            case Mesh: "3D mesh geometry"
            case Material: "Material/shader definition"
            case Audio: "Sound/music audio file"
            case Script: "Game logic script"
            case Scene: "Scene hierarchy"
            case Unknown: "Unknown asset type"

    pub fn is_texture(self) -> bool:
        """Check if asset type is Texture."""
        match self:
            case Texture: true
            case _: false

    pub fn is_mesh(self) -> bool:
        """Check if asset type is Mesh."""
        match self:
            case Mesh: true
            case _: false

    pub fn is_material(self) -> bool:
        """Check if asset type is Material."""
        match self:
            case Material: true
            case _: false

    pub fn is_audio(self) -> bool:
        """Check if asset type is Audio."""
        match self:
            case Audio: true
            case _: false

    pub fn is_script(self) -> bool:
        """Check if asset type is Script."""
        match self:
            case Script: true
            case _: false

    pub fn is_scene(self) -> bool:
        """Check if asset type is Scene."""
        match self:
            case Scene: true
            case _: false

    pub fn is_visual(self) -> bool:
        """Check if asset is visual (texture, mesh, material, scene).

        Returns:
            true for visual asset types

        Example:
            AssetType.Texture.is_visual()  # → true
        """
        match self:
            case Texture | Mesh | Material | Scene: true
            case _: false

    pub fn is_binary(self) -> bool:
        """Check if asset is typically binary data.

        Returns:
            true for texture, mesh, audio

        Example:
            AssetType.Audio.is_binary()  # → true
        """
        match self:
            case Texture | Mesh | Audio: true
            case _: false

    pub fn summary(self) -> text:
        """Get asset type summary.

        Returns:
            Human-readable summary

        Example:
            AssetType.Mesh.summary()
            # → "AssetType: Mesh (3D mesh geometry, visual, binary)"
        """
        val name = self.to_string()
        val desc = self.description()
        var props = []

        if self.is_visual():
            props.push("visual")
        if self.is_binary():
            props.push("binary")

        if props.is_empty():
            return "AssetType: {name} ({desc})"
        else:
            val props_str = props.join(", ")
            return "AssetType: {name} ({desc}, {props_str})"


# AssetHandle
# Type-safe handle to a loaded asset
pub struct AssetHandle:
    asset_ptr: ffi.VoidPtr
    asset_type: AssetType
    path: text

impl AssetHandle:
    pub fn new(asset_ptr: ffi.VoidPtr, asset_type: AssetType, path: text) -> AssetHandle:
        return AssetHandle(
            asset_ptr: asset_ptr,
            asset_type: asset_type,
            path: path,
        )

    pub fn get_ptr(self) -> ffi.VoidPtr:
        return self.asset_ptr

    pub fn get_type(self) -> AssetType:
        return self.asset_type

    pub fn get_path(self) -> text:
        return self.path

    pub fn is_valid(self) -> bool:
        return not ffi.is_null_ptr(self.asset_ptr)

    # =========================================================================
    # Helper Methods
    # =========================================================================

    pub fn has_path(self) -> bool:
        """Check if handle has non-empty path.

        Returns:
            true if path is not empty

        Example:
            handle.has_path()  # → true
        """
        return self.path.len() > 0

    pub fn is_texture(self) -> bool:
        """Check if asset type is texture.

        Returns:
            true if AssetType.Texture

        Example:
            handle.is_texture()  # → true
        """
        return self.asset_type == AssetType.Texture

    pub fn is_mesh(self) -> bool:
        """Check if asset type is mesh.

        Returns:
            true if AssetType.Mesh

        Example:
            handle.is_mesh()  # → false
        """
        return self.asset_type == AssetType.Mesh

    pub fn is_audio(self) -> bool:
        """Check if asset type is audio.

        Returns:
            true if AssetType.Audio

        Example:
            handle.is_audio()  # → false
        """
        return self.asset_type == AssetType.Audio

    pub fn summary(self) -> text:
        """Get asset handle summary.

        Returns:
            Human-readable summary

        Example:
            handle.summary()
            # → "AssetHandle: Texture 'res://textures/player.png' (valid)"
        """
        val type_name = self.asset_type.to_string()
        val status = if self.is_valid() { "valid" } else { "invalid" }
        return "AssetHandle: {type_name} '{self.path}' ({status})"


# AssetLoader trait
# Common interface for asset loading
pub trait AssetLoader:
    # Synchronous loading
    me load_asset(path: text, asset_type: AssetType) -> Option<AssetHandle>
    me unload_asset(handle: AssetHandle)
    fn is_asset_loaded(path: text) -> bool

    # Async loading
    me load_asset_async(path: text, asset_type: AssetType) -> i32  # Returns request ID
    fn is_load_complete(request_id: i32) -> bool
    me get_loaded_asset(request_id: i32) -> Option<AssetHandle>

    # Asset queries
    fn get_asset_size(path: text) -> i32
    fn asset_exists(path: text) -> bool


# GodotAssetLoaderAdapter
# Adapts Godot ResourceLoader to AssetLoader trait
pub struct GodotAssetLoaderAdapter:
    loader_ptr: ffi.VoidPtr
    loaded_assets: [AssetHandle]

impl GodotAssetLoaderAdapter:
    pub fn get_instance() -> GodotAssetLoaderAdapter:
        val ptr = godot_resource_loader_get_singleton()
        return GodotAssetLoaderAdapter(
            loader_ptr: ptr,
            loaded_assets: [],
        )

    # =========================================================================
    # Helper Methods
    # =========================================================================

    pub fn has_loader(self) -> bool:
        """Check if has valid loader pointer.

        Returns:
            true if pointer is not null

        Example:
            adapter.has_loader()  # → true
        """
        return not ffi.is_null_ptr(self.loader_ptr)

    pub fn loaded_count(self) -> usize:
        """Get number of loaded assets.

        Returns:
            Loaded asset count

        Example:
            adapter.loaded_count()  # → 3
        """
        return self.loaded_assets.len()

    pub fn has_loaded_assets(self) -> bool:
        """Check if has any loaded assets.

        Returns:
            true if loaded_assets is not empty

        Example:
            adapter.has_loaded_assets()  # → true
        """
        return self.loaded_assets.len() > 0

    pub fn summary(self) -> text:
        """Get Godot asset loader summary.

        Returns:
            Human-readable summary

        Example:
            adapter.summary()
            # → "GodotAssetLoaderAdapter: 3 loaded assets"
        """
        val count = self.loaded_count()
        return "GodotAssetLoaderAdapter: {count} loaded assets"

impl AssetLoader for GodotAssetLoaderAdapter:
    me load_asset(path: text, asset_type: AssetType) -> Option<AssetHandle>:
        val asset_ptr = godot_resource_loader_load(self.loader_ptr, path)
        if ffi.is_null_ptr(asset_ptr):
            return None
        else:
            val handle = AssetHandle.new(asset_ptr, asset_type, path)
            self.loaded_assets.push(handle)
            return Some(handle)

    me unload_asset(handle: AssetHandle):
        # Remove from loaded assets
        var new_assets = Vec.new()
        for asset in self.loaded_assets:
            if asset.get_path() != handle.get_path():
                new_assets.push(asset)
        self.loaded_assets = new_assets

        # Unload resource
        godot_resource_loader_unload(self.loader_ptr, handle.get_path())

    fn is_asset_loaded(path: text) -> bool:
        return godot_resource_loader_has_cached(self.loader_ptr, path)

    me load_asset_async(path: text, asset_type: AssetType) -> i32:
        return godot_resource_loader_load_threaded_request(self.loader_ptr, path)

    fn is_load_complete(request_id: i32) -> bool:
        # Godot uses path-based async loading
        return true

    me get_loaded_asset(request_id: i32) -> Option<AssetHandle>:
        return None

    fn get_asset_size(path: text) -> i32:
        # Godot doesn't expose size directly
        return 0

    fn asset_exists(path: text) -> bool:
        return godot_resource_loader_exists(self.loader_ptr, path)


# UnrealAssetLoaderAdapter
# Adapts Unreal AssetManager to AssetLoader trait
pub struct UnrealAssetLoaderAdapter:
    manager_ptr: ffi.VoidPtr
    loaded_assets: [AssetHandle]

impl UnrealAssetLoaderAdapter:
    pub fn get_instance() -> UnrealAssetLoaderAdapter:
        val ptr = unreal_asset_manager_get()
        return UnrealAssetLoaderAdapter(
            manager_ptr: ptr,
            loaded_assets: [],
        )

    # =========================================================================
    # Helper Methods
    # =========================================================================

    pub fn has_manager(self) -> bool:
        """Check if has valid asset manager pointer.

        Returns:
            true if pointer is not null

        Example:
            adapter.has_manager()  # → true
        """
        return not ffi.is_null_ptr(self.manager_ptr)

    pub fn loaded_count(self) -> usize:
        """Get number of loaded assets.

        Returns:
            Loaded asset count

        Example:
            adapter.loaded_count()  # → 3
        """
        return self.loaded_assets.len()

    pub fn has_loaded_assets(self) -> bool:
        """Check if has any loaded assets.

        Returns:
            true if loaded_assets is not empty

        Example:
            adapter.has_loaded_assets()  # → true
        """
        return self.loaded_assets.len() > 0

    pub fn summary(self) -> text:
        """Get Unreal asset loader summary.

        Returns:
            Human-readable summary

        Example:
            adapter.summary()
            # → "UnrealAssetLoaderAdapter: 3 loaded assets"
        """
        val count = self.loaded_count()
        return "UnrealAssetLoaderAdapter: {count} loaded assets"

impl AssetLoader for UnrealAssetLoaderAdapter:
    me load_asset(path: text, asset_type: AssetType) -> Option<AssetHandle>:
        val asset_ptr = unreal_asset_manager_load_synchronous(self.manager_ptr, path)
        if ffi.is_null_ptr(asset_ptr):
            return None
        else:
            val handle = AssetHandle.new(asset_ptr, asset_type, path)
            self.loaded_assets.push(handle)
            return Some(handle)

    me unload_asset(handle: AssetHandle):
        # Remove from loaded assets
        var new_assets = Vec.new()
        for asset in self.loaded_assets:
            if asset.get_path() != handle.get_path():
                new_assets.push(asset)
        self.loaded_assets = new_assets

        # Unreal uses GC for unloading
        unreal_asset_manager_unload(self.manager_ptr, handle.get_path())

    fn is_asset_loaded(path: text) -> bool:
        return unreal_asset_manager_is_loaded(self.manager_ptr, path)

    me load_asset_async(path: text, asset_type: AssetType) -> i32:
        return unreal_asset_manager_load_async(self.manager_ptr, path)

    fn is_load_complete(request_id: i32) -> bool:
        return unreal_asset_manager_is_load_complete(self.manager_ptr, request_id)

    me get_loaded_asset(request_id: i32) -> Option<AssetHandle>:
        val asset_ptr = unreal_asset_manager_get_loaded_asset(self.manager_ptr, request_id)
        if ffi.is_null_ptr(asset_ptr):
            return None
        else:
            return Some(AssetHandle.new(asset_ptr, AssetType.Unknown, ""))

    fn get_asset_size(path: text) -> i32:
        return unreal_asset_manager_get_asset_size(self.manager_ptr, path)

    fn asset_exists(path: text) -> bool:
        return unreal_asset_manager_does_exist(self.manager_ptr, path)


# Utility functions

# Get Godot asset loader
pub fn get_godot_loader() -> GodotAssetLoaderAdapter:
    return GodotAssetLoaderAdapter.get_instance()

# Get Unreal asset loader
pub fn get_unreal_loader() -> UnrealAssetLoaderAdapter:
    return UnrealAssetLoaderAdapter.get_instance()


# FFI declarations for Godot
extern "C":
    fn godot_resource_loader_get_singleton() -> ffi.VoidPtr
    fn godot_resource_loader_load(loader: ffi.VoidPtr, path: text) -> ffi.VoidPtr
    fn godot_resource_loader_unload(loader: ffi.VoidPtr, path: text)
    fn godot_resource_loader_has_cached(loader: ffi.VoidPtr, path: text) -> bool
    fn godot_resource_loader_load_threaded_request(loader: ffi.VoidPtr, path: text) -> i32
    fn godot_resource_loader_exists(loader: ffi.VoidPtr, path: text) -> bool

# FFI declarations for Unreal
extern "C":
    fn unreal_asset_manager_get() -> ffi.VoidPtr
    fn unreal_asset_manager_load_synchronous(manager: ffi.VoidPtr, path: text) -> ffi.VoidPtr
    fn unreal_asset_manager_unload(manager: ffi.VoidPtr, path: text)
    fn unreal_asset_manager_is_loaded(manager: ffi.VoidPtr, path: text) -> bool
    fn unreal_asset_manager_load_async(manager: ffi.VoidPtr, path: text) -> i32
    fn unreal_asset_manager_is_load_complete(manager: ffi.VoidPtr, request_id: i32) -> bool
    fn unreal_asset_manager_get_loaded_asset(manager: ffi.VoidPtr, request_id: i32) -> ffi.VoidPtr
    fn unreal_asset_manager_get_asset_size(manager: ffi.VoidPtr, path: text) -> i32
    fn unreal_asset_manager_does_exist(manager: ffi.VoidPtr, path: text) -> bool


# Example usage:
#
# # Load assets synchronously
# var loader = get_godot_loader()
# val texture = loader.load_asset("res://textures/player.png", AssetType.Texture)
#
# if texture.is_some():
#     val handle = texture.unwrap()
#     print("Loaded texture: " + handle.get_path())
#
# # Load assets asynchronously
# val request_id = loader.load_asset_async("res://models/enemy.glb", AssetType.Mesh)
#
# # Check load status
# if loader.is_load_complete(request_id):
#     val asset = loader.get_loaded_asset(request_id)
#     if asset.is_some():
#         print("Asset loaded!")
