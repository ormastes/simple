# Effect System for Async Safety in Game Engines
#
# Leverages Simple's effect system to track and enforce async safety
# for game logic that interacts with engine APIs
#
# Features:
# - Effect tracking for engine operations
# - Async-safe game logic composition
# - Effect isolation boundaries
# - Engine API safety guarantees
# - Cross-engine effect compatibility

import sys.ffi

mod effects

# GameEffect
# Effect types for game engine operations
pub effect GameEffect:
    # Rendering effects (may block on GPU)
    RenderEffect(text)         # Render operation name

    # Physics effects (synchronized with physics step)
    PhysicsEffect(text)        # Physics operation name

    # Audio effects (may block on audio thread)
    AudioEffect(text)          # Audio operation name

    # IO effects (asset loading, file access)
    IOEffect(text)             # IO operation name

    # Engine sync effects (must run on main thread)
    EngineSyncEffect(text)     # Sync operation name


# EffectContext
# Tracks active effects in current execution context
pub struct EffectContext:
    active_effects: Vec<GameEffect>
    async_safe: bool

impl EffectContext:
    pub fn new() -> EffectContext:
        return EffectContext(
            active_effects: [],
            async_safe: true,
        )

    # Check if specific effect is active
    pub fn has_effect(self, effect_name: text) -> bool:
        for effect in self.active_effects:
            if effect is GameEffect.RenderEffect(name) and name == effect_name:
                return true
            elif effect is GameEffect.PhysicsEffect(name) and name == effect_name:
                return true
            elif effect is GameEffect.AudioEffect(name) and name == effect_name:
                return true
            elif effect is GameEffect.IOEffect(name) and name == effect_name:
                return true
            elif effect is GameEffect.EngineSyncEffect(name) and name == effect_name:
                return true
        return false

    # Add effect to context
    pub fn add_effect(mut self, effect: GameEffect):
        self.active_effects.push(effect)
        # Mark as not async-safe if adding sync effect
        if effect is GameEffect.EngineSyncEffect(_):
            self.async_safe = false

    # Remove effect from context
    pub fn remove_effect(mut self, effect_name: text):
        var new_effects = Vec.new()
        for effect in self.active_effects:
            val should_keep = if effect is GameEffect.RenderEffect(name):
                name != effect_name
            elif effect is GameEffect.PhysicsEffect(name):
                name != effect_name
            elif effect is GameEffect.AudioEffect(name):
                name != effect_name
            elif effect is GameEffect.IOEffect(name):
                name != effect_name
            elif effect is GameEffect.EngineSyncEffect(name):
                name != effect_name
            else:
                true

            if should_keep:
                new_effects.push(effect)

        self.active_effects = new_effects

    # Check if context is async-safe
    pub fn is_async_safe(self) -> bool:
        return self.async_safe

    # Get all active effects
    pub fn get_active_effects(self) -> Vec<GameEffect>:
        return self.active_effects

    # =========================================================================
    # Helper Methods
    # =========================================================================

    pub fn effect_count(self) -> usize:
        """Get number of active effects.

        Returns:
            Effect count

        Example:
            ctx.effect_count()  # → 3
        """
        return self.active_effects.len()

    pub fn has_effects(self) -> bool:
        """Check if context has any active effects.

        Returns:
            true if has effects

        Example:
            ctx.has_effects()  # → true
        """
        return self.active_effects.len() > 0

    pub fn is_empty(self) -> bool:
        """Check if context has no effects.

        Returns:
            true if empty

        Example:
            ctx.is_empty()  # → false
        """
        return self.active_effects.len() == 0

    pub fn summary(self) -> text:
        """Get effect context summary.

        Returns:
            Human-readable summary

        Example:
            ctx.summary()
            # → "EffectContext: 3 effects, async_safe=false"
        """
        val count = self.effect_count()
        val safe_str = if self.async_safe { "async_safe=true" } else { "async_safe=false" }
        return "EffectContext: {count} effects, {safe_str}"


# EffectfulOperation
# Wraps an operation with effect tracking
pub struct EffectfulOperation:
    operation_name: text
    effect: GameEffect
    context: EffectContext

impl EffectfulOperation:
    pub fn new(operation_name: text, effect: GameEffect) -> EffectfulOperation:
        var context = EffectContext.new()
        context.add_effect(effect)

        return EffectfulOperation(
            operation_name: operation_name,
            effect: effect,
            context: context,
        )

    # Execute operation with effect tracking
    pub fn execute(self, operation: fn() -> ()):
        # Effect is already tracked in context
        operation()

    # Check if operation is async-safe
    pub fn is_async_safe(self) -> bool:
        return self.context.is_async_safe()

    # =========================================================================
    # Helper Methods
    # =========================================================================

    pub fn get_operation_name(self) -> text:
        """Get operation name.

        Returns:
            Operation name

        Example:
            op.get_operation_name()  # → "draw_sprite"
        """
        return self.operation_name

    pub fn get_effect(self) -> GameEffect:
        """Get effect for this operation.

        Returns:
            Game effect

        Example:
            val effect = op.get_effect()
        """
        return self.effect

    pub fn get_context(self) -> EffectContext:
        """Get effect context.

        Returns:
            Effect context

        Example:
            val ctx = op.get_context()
        """
        return self.context

    pub fn summary(self) -> text:
        """Get operation summary.

        Returns:
            Human-readable summary

        Example:
            op.summary()
            # → "EffectfulOperation: 'draw_sprite' (async_safe=true)"
        """
        val safe_str = if self.is_async_safe() { "async_safe=true" } else { "async_safe=false" }
        return "EffectfulOperation: '{self.operation_name}' ({safe_str})"


# AsyncSafeGuard
# Guards async-unsafe operations
pub struct AsyncSafeGuard:
    allowed_effects: Vec<text>

impl AsyncSafeGuard:
    pub fn new() -> AsyncSafeGuard:
        return AsyncSafeGuard(allowed_effects: [])

    # Allow specific effect
    pub fn allow_effect(mut self, effect_name: text):
        self.allowed_effects.push(effect_name)

    # Check if effect is allowed
    pub fn is_effect_allowed(self, effect_name: text) -> bool:
        for allowed in self.allowed_effects:
            if allowed == effect_name:
                return true
        return false

    # Verify context against guard
    pub fn verify_context(self, context: EffectContext) -> bool:
        # All effects in context must be in allowed list
        for effect in context.get_active_effects():
            val effect_name = if effect is GameEffect.RenderEffect(name):
                name
            elif effect is GameEffect.PhysicsEffect(name):
                name
            elif effect is GameEffect.AudioEffect(name):
                name
            elif effect is GameEffect.IOEffect(name):
                name
            elif effect is GameEffect.EngineSyncEffect(name):
                name
            else:
                ""

            if not self.is_effect_allowed(effect_name):
                return false

        return true

    # =========================================================================
    # Helper Methods
    # =========================================================================

    pub fn allowed_count(self) -> usize:
        """Get number of allowed effects.

        Returns:
            Allowed effect count

        Example:
            guard.allowed_count()  # → 2
        """
        return self.allowed_effects.len()

    pub fn has_allowed_effects(self) -> bool:
        """Check if guard has any allowed effects.

        Returns:
            true if has allowed effects

        Example:
            guard.has_allowed_effects()  # → true
        """
        return self.allowed_effects.len() > 0

    pub fn is_permissive(self) -> bool:
        """Check if guard allows all effects (empty list means allow all).

        Returns:
            true if empty (permissive)

        Example:
            guard.is_permissive()  # → false
        """
        return self.allowed_effects.len() == 0

    pub fn summary(self) -> text:
        """Get async safe guard summary.

        Returns:
            Human-readable summary

        Example:
            guard.summary()
            # → "AsyncSafeGuard: 2 allowed effects"
        """
        val count = self.allowed_count()
        return "AsyncSafeGuard: {count} allowed effects"


# Effect combinators

# Run operation with render effect
pub fn with_render_effect(operation_name: text, operation: fn() -> ()):
    val op = EffectfulOperation.new(operation_name, GameEffect.RenderEffect(operation_name))
    op.execute(operation)

# Run operation with physics effect
pub fn with_physics_effect(operation_name: text, operation: fn() -> ()):
    val op = EffectfulOperation.new(operation_name, GameEffect.PhysicsEffect(operation_name))
    op.execute(operation)

# Run operation with audio effect
pub fn with_audio_effect(operation_name: text, operation: fn() -> ()):
    val op = EffectfulOperation.new(operation_name, GameEffect.AudioEffect(operation_name))
    op.execute(operation)

# Run operation with IO effect
pub fn with_io_effect(operation_name: text, operation: fn() -> ()):
    val op = EffectfulOperation.new(operation_name, GameEffect.IOEffect(operation_name))
    op.execute(operation)

# Run operation with engine sync effect (main thread only)
pub fn with_engine_sync_effect(operation_name: text, operation: fn() -> ()):
    val op = EffectfulOperation.new(operation_name, GameEffect.EngineSyncEffect(operation_name))
    if not op.is_async_safe():
        # Must run on main thread
        queue_on_main_thread(operation)
    else:
        op.execute(operation)


# Engine integration

# Queue operation on engine main thread
fn queue_on_main_thread(operation: fn() -> ()):
    # This would use engine-specific main thread queue
    # For now, execute directly (in real impl, would defer)
    operation()


# Example usage:
#
# # Async-safe rendering operation
# with_render_effect("draw_sprite", fn():
#     # This is tracked as RenderEffect
#     draw_sprite_to_screen(sprite_id)
# )
#
# # Physics operation (synchronized with physics step)
# with_physics_effect("apply_force", fn():
#     # This is tracked as PhysicsEffect
#     rigidbody.apply_force(10.0, 0.0, 0.0)
# )
#
# # Engine sync operation (must run on main thread)
# with_engine_sync_effect("spawn_actor", fn():
#     # This is tracked as EngineSyncEffect
#     # Will be queued on main thread automatically
#     val actor = spawn_actor_in_world(world_ptr)
# )
#
# # Create async-safe guard
# var guard = AsyncSafeGuard.new()
# guard.allow_effect("draw_sprite")
# guard.allow_effect("play_sound")
#
# # Verify operation is async-safe
# val context = EffectContext.new()
# context.add_effect(GameEffect.RenderEffect("draw_sprite"))
#
# if guard.verify_context(context):
#     print("Operation is async-safe!")
# else:
#     print("Operation has disallowed effects!")
