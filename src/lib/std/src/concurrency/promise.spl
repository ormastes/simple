/**
Promise Type for Async-by-Default Semantics

Promise<T> represents a value that will be available in the future.
This is the return type of all async functions in the async-by-default model.

Key Concepts:
- `sync fn foo() -> T` returns T directly
- `fn bar() -> T` returns Promise<T> (async by default)
- Use `await` to extract T from Promise<T>

States:
- Pending: Computation not yet complete
- Resolved: Successfully completed with value
- Rejected: Failed with error

Basic Usage:
```sdoctest
>>> val p = Promise.resolved(42)
>>> await p
42
```

Creating Promises:
```sdoctest
>>> val p = Promise.new(\resolve, reject: resolve(100))
>>> await p
100
```

Chaining:
```sdoctest
>>> val p1 = Promise.resolved(10)
>>> val p2 = p1.then(\x: x * 2)
>>> await p2
20
```

Error Handling:
```sdoctest
>>> val p = Promise.rejected("error")
>>> match await p:
...     case Ok(v): v
...     case Err(e): "caught: " + e
'caught: error'
```

Thread Safety:
- Promise state transitions are protected: once settled, state cannot change
- For concurrent access, use promises with isolated threads (spawn_isolated)
- Each thread gets its own promise copy via deep-copy semantics
- For shared promises across threads, use channels for communication

Note: Simple language uses Result<T, E> for error handling, not exceptions.
*/

/// Promise state enum
enum PromiseState:
    Pending
    Resolved(value)
    Rejected(error)

impl PromiseState:
    # =========================================================================
    # Helper Methods
    # =========================================================================

    fn to_string() -> text:
        """Convert state to string."""
        match self:
            case Pending: return "Pending"
            case Resolved(_): return "Resolved"
            case Rejected(_): return "Rejected"

    fn description() -> text:
        """Get detailed state description."""
        match self:
            case Pending: return "Promise is pending"
            case Resolved(v): return "Promise resolved with value"
            case Rejected(e): return "Promise rejected with error"

    fn is_pending() -> bool:
        """Check if this is Pending state."""
        match self:
            case Pending: true
            case _: false

    fn is_resolved() -> bool:
        """Check if this is Resolved state."""
        match self:
            case Resolved(_): true
            case _: false

    fn is_rejected() -> bool:
        """Check if this is Rejected state."""
        match self:
            case Rejected(_): true
            case _: false

    fn is_settled() -> bool:
        """Check if this is settled (resolved or rejected)."""
        match self:
            case Pending: false
            case _: true

    fn summary() -> text:
        """Get summary of promise state.

        Returns:
            Human-readable summary

        Example:
            PromiseState::Pending.summary()
            # → "PromiseState: Pending (not settled)"
            PromiseState::Resolved(42).summary()
            # → "PromiseState: Resolved (settled with value)"
        """
        match self:
            case Pending:
                return "PromiseState: Pending (not settled)"
            case Resolved(_):
                return "PromiseState: Resolved (settled with value)"
            case Rejected(_):
                return "PromiseState: Rejected (settled with error)"

# Promise<T> - Represents an asynchronous computation that will produce T
#
# This is the core type for async-by-default semantics.
# All non-sync functions return Promise<T> instead of T.
class Promise<T>:
    state: PromiseState
    callbacks: List  # List of (resolve_fn, reject_fn) pairs

    # =========================================================================
    # Helper Methods
    # =========================================================================

    fn is_pending() -> bool:
        """Check if promise is pending."""
        return self.state.is_pending()

    fn is_resolved() -> bool:
        """Check if promise is resolved."""
        return self.state.is_resolved()

    fn is_rejected() -> bool:
        """Check if promise is rejected."""
        return self.state.is_rejected()

    fn is_settled() -> bool:
        """Check if promise is settled (resolved or rejected)."""
        return self.state.is_settled()

    fn has_callbacks() -> bool:
        """Check if promise has pending callbacks."""
        return self.callbacks.len() > 0

    fn callback_count() -> i32:
        """Get number of pending callbacks."""
        return self.callbacks.len()

    fn get_state() -> PromiseState:
        """Get current state."""
        return self.state

    fn summary() -> text:
        """Get summary of promise state."""
        val state_str = self.state.to_string()
        val cb_count = self.callback_count()
        return "Promise<T>: {state_str}, {cb_count} callbacks"

    fn get_value(self):
        """Get the resolved value, or nil if not resolved."""
        match self.state:
            case Resolved(v): return v
            case _: return nil

    fn get_error(self):
        """Get the rejection error, or nil if not rejected."""
        match self.state:
            case Rejected(e): return e
            case _: return nil

    # =========================================================================
    # Constructor
    # =========================================================================

    # Create a new pending promise
    # The executor function receives resolve and reject callbacks:
    # - Call resolve(value) to fulfill the promise
    # - Call reject(error) to reject the promise
    fn new(executor) -> Promise<T>:
        var promise = Promise {
            state: PromiseState.Pending,
            callbacks: []
        }

        # Define resolve callback
        fn resolve(value):
            if promise.state is PromiseState.Pending:
                promise.state = PromiseState.Resolved(value)
                # Execute all pending callbacks
                for (on_resolve, on_reject) in promise.callbacks:
                    on_resolve(value)

        # Define reject callback
        fn reject(error):
            if promise.state is PromiseState.Pending:
                promise.state = PromiseState.Rejected(error)
                # Execute all pending callbacks
                for (on_resolve, on_reject) in promise.callbacks:
                    on_reject(error)

        # Execute the executor function
        # Note: Simple language does not support exceptions
        # Executor is responsible for calling resolve() or reject()
        executor(resolve, reject)

        return promise

    # Create an already-resolved promise
    fn resolved(v: T) -> Promise<T>:
        return Promise {
            state: PromiseState.Resolved(v),
            callbacks: []
        }

    # Create an already-rejected promise
    fn rejected(err) -> Promise<T>:
        return Promise {
            state: PromiseState.Rejected(err),
            callbacks: []
        }

    # Create a pending promise (for internal use in simplified implementations)
    fn pending() -> Promise<T>:
        return Promise {
            state: PromiseState.Pending,
            callbacks: []
        }

    # Chain a transformation function
    # Returns a new promise that applies the function to the resolved value.
    fn then<U>(self, on_resolve) -> Promise<U>:
        if self.state.is_resolved():
            match self.state:
                case PromiseState.Resolved(v):
                    # Execute callback
                    # Note: Simple language does not support exceptions
                    # Callback should return Result<U, E> if it can fail
                    val result = on_resolve(v)
                    return Promise.resolved(result)
                case _:
                    return Promise.rejected("unreachable")
        elif self.state.is_rejected():
            match self.state:
                case PromiseState.Rejected(e):
                    return Promise.rejected(e)
                case _:
                    return Promise.rejected("unreachable")
        else:
            # Pending - register callback and return a new promise
            var result_promise = Promise.pending()

            # Create callback that will resolve/reject the result promise
            fn resolve_callback(value):
                val transformed = on_resolve(value)
                result_promise.state = PromiseState.Resolved(transformed)

            fn reject_callback(error):
                result_promise.state = PromiseState.Rejected(error)

            # Register the callbacks
            self.callbacks.append((resolve_callback, reject_callback))

            return result_promise

    # Catch errors from a rejected promise
    fn catch<U>(self, on_reject) -> Promise<U>:
        if self.state.is_resolved():
            match self.state:
                case PromiseState.Resolved(v):
                    return Promise.resolved(v)
                case _:
                    return Promise.rejected("unreachable")
        elif self.state.is_rejected():
            match self.state:
                case PromiseState.Rejected(e):
                    # Execute error handler
                    val result = on_reject(e)
                    return Promise.resolved(result)
                case _:
                    return Promise.rejected("unreachable")
        else:
            # Pending - register callback and return a new promise
            var result_promise = Promise.pending()

            # Create callbacks for catch - on resolve, just pass through
            fn resolve_callback(value):
                result_promise.state = PromiseState.Resolved(value)

            fn reject_callback(error):
                val recovered = on_reject(error)
                result_promise.state = PromiseState.Resolved(recovered)

            # Register the callbacks
            self.callbacks.append((resolve_callback, reject_callback))

            return result_promise

    # Finally - always executes regardless of state
    # The callback receives nil as a dummy argument since Simple doesn't support no-arg lambdas easily
    fn finally<U>(self, on_finally) -> Promise<T>:
        # Execute callback with nil as dummy value
        on_finally(nil)
        # Return original promise state
        return self

    # Map a function over the promise value
    # Similar to then(), but specifically for transformations.
    fn map<U>(self, transform) -> Promise<U>:
        return self.then(transform)

    # Flat map - chain promises together
    # Use when the transform function returns another Promise.
    fn flat_map<U>(self, transform) -> Promise<U>:
        # Simplified implementation for interpreter compatibility
        if self.state.is_resolved():
            match self.state:
                case PromiseState.Resolved(v):
                    return transform(v)
                case _:
                    return Promise.rejected("unreachable")
        elif self.state.is_rejected():
            match self.state:
                case PromiseState.Rejected(e):
                    return Promise.rejected(e)
                case _:
                    return Promise.rejected("unreachable")
        else:
            return Promise.pending()

# Wait for all promises to complete
# Returns a promise that resolves to a list of all results.
# If any promise rejects, the returned promise rejects immediately.
fn all<T>(promises: List<Promise<T>>) -> Promise<List<T>>:
    # Simplified implementation for interpreter compatibility
    if promises.is_empty:
        return Promise.resolved([])

    var results = []
    for p in promises:
        if p.state.is_rejected():
            match p.state:
                case PromiseState.Rejected(e):
                    return Promise.rejected(e)
                case _:
                    pass
        elif p.state.is_resolved():
            match p.state:
                case PromiseState.Resolved(v):
                    results.append(v)
                case _:
                    pass
        else:
            # Has pending promise - return pending
            return Promise.pending()
    return Promise.resolved(results)

# Race multiple promises
# Returns a promise that resolves or rejects with the first settled promise.
fn race<T>(promises: List<Promise<T>>) -> Promise<T>:
    # Simplified implementation for interpreter compatibility
    if promises.is_empty:
        return Promise.rejected("race: empty list")

    # Return first settled promise
    for p in promises:
        if p.state.is_settled():
            return p
    # All pending - return pending
    return Promise.pending()

# Wait for all promises, even if some reject
# Returns a promise that resolves to a list of results,
# where each result is either Ok(value) or Err(error).
fn all_settled<T>(promises: List<Promise<T>>) -> Promise<List<Result<T>>>:
    # Simplified implementation for interpreter compatibility
    if promises.is_empty:
        return Promise.resolved([])

    var results = []
    for p in promises:
        if p.state.is_resolved():
            match p.state:
                case PromiseState.Resolved(v):
                    results.append(Ok(v))
                case _:
                    pass
        elif p.state.is_rejected():
            match p.state:
                case PromiseState.Rejected(e):
                    results.append(Err(e))
                case _:
                    pass
        else:
            # Has pending promise - return pending
            return Promise.pending()
    return Promise.resolved(results)

# Create a promise that resolves after a delay
fn delay<T>(milliseconds: i32, v: T) -> Promise<T>:
    """Create a promise that resolves after a specified delay.

    Uses thread-based sleeping to implement the delay.

    Args:
        milliseconds: Delay in milliseconds
        v: Value to resolve with after delay

    Returns:
        Promise that resolves with v after delay
    """
    return Promise.new(\resolve, reject:
        # TODO[stdlib][P3]: Implement actual delay with thread sleep
        # For now, just resolve immediately
        resolve(v)
    )

# Helper functions for easy Promise creation (Python-style)
fn make_resolved_promise<T>(v: T) -> Promise<T>:
    """Create a resolved promise (helper for generic type inference)."""
    return Promise {
        state: PromiseState.Resolved(v),
        callbacks: []
    }

fn make_rejected_promise<T>(err) -> Promise<T>:
    """Create a rejected promise (helper for generic type inference)."""
    return Promise {
        state: PromiseState.Rejected(err),
        callbacks: []
    }

# Export Promise types and helpers
export PromiseState
export Promise
export make_resolved_promise
export make_rejected_promise
export all
export race
export all_settled
export delay
