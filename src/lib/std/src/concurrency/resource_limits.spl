# Resource Limits for Thread Execution
# Provides resource constraints for safe concurrent execution
# Thread-safe: immutable configuration, applied at thread spawn time

class ResourceLimits:
    cpu_time_seconds: Option<i64>
    memory_bytes: Option<i64>
    file_descriptors: Option<i64>
    thread_count: Option<i64>

impl ResourceLimits:
    # =========================================================================
    # Factory Methods
    # =========================================================================

    fn new() -> ResourceLimits:
        """Create unlimited resource limits."""
        return ResourceLimits {
            cpu_time_seconds: None,
            memory_bytes: None,
            file_descriptors: None,
            thread_count: None
        }

    fn default_test_limits() -> ResourceLimits:
        """Create default limits suitable for most tests.

        - CPU: 300 seconds (5 minutes)
        - Memory: 1 GB
        - File descriptors: 256
        - Threads: unlimited
        """
        return ResourceLimits {
            cpu_time_seconds: Some(300),
            memory_bytes: Some(1073741824),  # 1 GB
            file_descriptors: Some(256),
            thread_count: None
        }

    fn strict() -> ResourceLimits:
        """Create strict limits for resource-intensive tests.

        - CPU: 10 seconds
        - Memory: 128 MB
        - File descriptors: 16
        - Threads: 4
        """
        return ResourceLimits {
            cpu_time_seconds: Some(10),
            memory_bytes: Some(134217728),  # 128 MB
            file_descriptors: Some(16),
            thread_count: Some(4)
        }

    # =========================================================================
    # Builder Methods (return new instance for thread-safety)
    # =========================================================================

    fn with_cpu_time(seconds: i64) -> ResourceLimits:
        """Set CPU time limit in seconds."""
        return ResourceLimits {
            cpu_time_seconds: Some(seconds),
            memory_bytes: self.memory_bytes,
            file_descriptors: self.file_descriptors,
            thread_count: self.thread_count
        }

    fn with_memory_mb(megabytes: i64) -> ResourceLimits:
        """Set memory limit in megabytes."""
        val bytes = megabytes * 1024 * 1024
        return ResourceLimits {
            cpu_time_seconds: self.cpu_time_seconds,
            memory_bytes: Some(bytes),
            file_descriptors: self.file_descriptors,
            thread_count: self.thread_count
        }

    fn with_memory_bytes(bytes: i64) -> ResourceLimits:
        """Set memory limit in bytes."""
        return ResourceLimits {
            cpu_time_seconds: self.cpu_time_seconds,
            memory_bytes: Some(bytes),
            file_descriptors: self.file_descriptors,
            thread_count: self.thread_count
        }

    fn with_file_descriptors(count: i64) -> ResourceLimits:
        """Set file descriptor limit."""
        return ResourceLimits {
            cpu_time_seconds: self.cpu_time_seconds,
            memory_bytes: self.memory_bytes,
            file_descriptors: Some(count),
            thread_count: self.thread_count
        }

    fn with_threads(count: i64) -> ResourceLimits:
        """Set thread count limit."""
        return ResourceLimits {
            cpu_time_seconds: self.cpu_time_seconds,
            memory_bytes: self.memory_bytes,
            file_descriptors: self.file_descriptors,
            thread_count: Some(count)
        }

    # =========================================================================
    # Query Methods
    # =========================================================================

    fn has_limits() -> bool:
        """Check if any limits are set."""
        if self.cpu_time_seconds.is_some():
            return true
        if self.memory_bytes.is_some():
            return true
        if self.file_descriptors.is_some():
            return true
        if self.thread_count.is_some():
            return true
        return false

    fn summary() -> text:
        """Get human-readable summary of limits."""
        if not self.has_limits():
            return "ResourceLimits(unlimited)"

        var parts = []

        match self.cpu_time_seconds:
            case Some(secs):
                parts.append("cpu={secs}s")
            case None:
                pass

        match self.memory_bytes:
            case Some(bytes):
                val mb = bytes / (1024 * 1024)
                parts.append("mem={mb}MB")
            case None:
                pass

        match self.file_descriptors:
            case Some(count):
                parts.append("fd={count}")
            case None:
                pass

        match self.thread_count:
            case Some(count):
                parts.append("threads={count}")
            case None:
                pass

        val limits_str = parts.join(", ")
        return "ResourceLimits({limits_str})"

# ============================================================================
# LimitViolation - Types of resource limit violations
# ============================================================================

enum LimitViolation:
    CpuTimeExceeded(seconds: i64)
    MemoryExceeded(bytes: i64)
    FileDescriptorExceeded(count: i64)
    ThreadLimitExceeded(count: i64)
    Unknown(message: text)

impl LimitViolation:
    fn is_cpu_time() -> bool:
        """Check if this is a CPU time violation."""
        match self:
            case CpuTimeExceeded(_): true
            case _: false

    fn is_memory() -> bool:
        """Check if this is a memory violation."""
        match self:
            case MemoryExceeded(_): true
            case _: false

    fn is_fd() -> bool:
        """Check if this is a file descriptor violation."""
        match self:
            case FileDescriptorExceeded(_): true
            case _: false

    fn is_thread() -> bool:
        """Check if this is a thread limit violation."""
        match self:
            case ThreadLimitExceeded(_): true
            case _: false

    fn is_unknown() -> bool:
        """Check if this is an unknown violation."""
        match self:
            case Unknown(_): true
            case _: false

    fn message() -> text:
        """Get human-readable message for the violation."""
        match self:
            case CpuTimeExceeded(secs):
                return "CPU time exceeded: {secs} seconds"
            case MemoryExceeded(bytes):
                val mb = bytes / (1024 * 1024)
                return "Memory exceeded: {mb} MB ({bytes} bytes)"
            case FileDescriptorExceeded(count):
                return "File descriptor limit exceeded: {count}"
            case ThreadLimitExceeded(count):
                return "Thread limit exceeded: {count}"
            case Unknown(msg):
                return "Unknown violation: {msg}"

    fn summary() -> text:
        """Get summary of the violation."""
        return self.message()

# ============================================================================
# LimitedResult - Result type for resource-limited execution
# ============================================================================

enum LimitedResult<T>:
    Success(value: T)
    Killed(violation: LimitViolation)
    Error(message: text)

impl LimitedResult:
    fn is_success() -> bool:
        """Check if this is a success result."""
        match self:
            case Success(_): true
            case _: false

    fn is_killed() -> bool:
        """Check if this is a killed result."""
        match self:
            case Killed(_): true
            case _: false

    fn is_error() -> bool:
        """Check if this is an error result."""
        match self:
            case Error(_): true
            case _: false

    fn value() -> Option<T>:
        """Get the success value if present."""
        match self:
            case Success(v): Some(v)
            case _: None

    fn violation() -> Option<LimitViolation>:
        """Get the violation if present."""
        match self:
            case Killed(v): Some(v)
            case _: None

    fn error_message() -> Option<text>:
        """Get the error message if present."""
        match self:
            case Error(msg): Some(msg)
            case _: None

    fn unwrap() -> T:
        """Unwrap the success value (panics on error/killed)."""
        match self:
            case Success(v): v
            case Killed(v):
                # TODO[stdlib][P2]: Implement panic mechanism
                # For now, return nil (unsafe but interpreter-compatible)
                return nil
            case Error(msg):
                # TODO[stdlib][P2]: Implement panic mechanism
                return nil

    fn summary() -> text:
        """Get summary of the result."""
        match self:
            case Success(_):
                return "LimitedResult: Success"
            case Killed(v):
                return "LimitedResult: Killed ({v.summary()})"
            case Error(msg):
                return "LimitedResult: Error ({msg})"

# ============================================================================
# Module-Level Constructor Functions (for interpreter compatibility)
# ============================================================================

fn new_resource_limits() -> ResourceLimits:
    """Create unlimited resource limits."""
    return ResourceLimits {
        cpu_time_seconds: None,
        memory_bytes: None,
        file_descriptors: None,
        thread_count: None
    }

fn default_test_limits() -> ResourceLimits:
    """Create default limits suitable for most tests."""
    return ResourceLimits {
        cpu_time_seconds: Some(300),
        memory_bytes: Some(1073741824),  # 1 GB
        file_descriptors: Some(256),
        thread_count: None
    }

fn strict_limits() -> ResourceLimits:
    """Create strict limits for resource-intensive tests."""
    return ResourceLimits {
        cpu_time_seconds: Some(10),
        memory_bytes: Some(134217728),  # 128 MB
        file_descriptors: Some(16),
        thread_count: Some(4)
    }

export ResourceLimits
export LimitViolation
export LimitedResult
export new_resource_limits
export default_test_limits
export strict_limits
