/**
Isolated Threads

Isolated threads provide safe parallel execution without shared mutable state.
Communication between threads is only possible through channels.

Core Principles:
1. No shared mutable state - Cannot access mutable globals
2. Copy or const only - Data must be copied or const
3. Channel-only communication - Use channels for inter-thread communication
4. Global const access - Can read global constants

Basic Usage:
```sdoctest
>>> val data = [1, 2, 3]
>>> val ch = Channel.new()
>>> val handle = spawn_isolated(data, ch) \copied_data, chan:
...     chan.send(copied_data.sum())
>>> ch.recv()
6
```
*/

# FFI declarations for isolated thread operations
extern fn rt_thread_spawn_isolated(closure_ptr: i64, data: Any) -> i64
extern fn rt_thread_spawn_isolated2(closure_ptr: i64, data1: Any, data2: Any) -> i64
extern fn rt_thread_join(handle: i64) -> Any
extern fn rt_thread_is_done(handle: i64) -> i64
extern fn rt_thread_id(handle: i64) -> i64
extern fn rt_thread_free(handle: i64)
extern fn rt_thread_available_parallelism() -> i64
extern fn rt_thread_sleep(millis: i64)
extern fn rt_thread_yield()

# FFI declarations for resource-limited thread operations
extern fn rt_thread_spawn_limited(closure_ptr: i64, data: Any, cpu: i64, mem: i64, fd: i64, threads: i64) -> i64
extern fn rt_thread_spawn_limited2(closure_ptr: i64, data1: Any, data2: Any, cpu: i64, mem: i64, fd: i64, threads: i64) -> i64
extern fn rt_thread_join_limited(handle: i64) -> Any
extern fn rt_thread_was_killed(handle: i64) -> i64
extern fn rt_thread_get_violation_type(handle: i64) -> i64
extern fn rt_thread_get_violation_value(handle: i64) -> i64
extern fn rt_thread_is_done_limited(handle: i64) -> i64
extern fn rt_thread_id_limited(handle: i64) -> i64
extern fn rt_thread_free_limited(handle: i64)

# Import ResourceLimits and related types
import concurrency.resource_limits.{ResourceLimits, LimitViolation, LimitedResult}

/**
Handle for an isolated thread.

Used to join threads and get their results.
*/
struct ThreadHandle:
    _handle: i64

    # =========================================================================
    # Helper Methods
    # =========================================================================

    fn is_running() -> bool:
        """Check if thread is still running."""
        return not self.is_done()

    fn is_completed() -> bool:
        """Check if thread has completed (alias for is_done)."""
        return self.is_done()

    fn get_id() -> i64:
        """Get thread ID (alias for id)."""
        return self.id()

    fn get_handle() -> i64:
        """Get raw handle value."""
        return self._handle

    fn summary() -> text:
        """Get summary of thread handle state."""
        val status = if self.is_done(): "completed" else: "running"
        return "ThreadHandle: id={self.id()}, {status}"

    # =========================================================================
    # Existing Methods
    # =========================================================================

    fn join() -> Any:
        """Wait for the thread to complete and get its result.

        ```sdoctest
        >>> val handle = spawn_isolated(42) \x: x * 2
        >>> handle.join()
        84
        ```
        """
        return rt_thread_join(self._handle)

    fn is_done() -> bool:
        """Check if the thread has completed without blocking.

        ```sdoctest
        >>> val handle = spawn_isolated(42) \x: x
        >>> handle.is_done()  # May be true or false
        ...
        ```
        """
        return rt_thread_is_done(self._handle) == 1

    fn id() -> i64:
        """Get the unique ID of this thread."""
        return rt_thread_id(self._handle)

    fn free():
        """Free the thread handle.
        If the thread hasn't been joined, it will be detached.
        """
        rt_thread_free(self._handle)

/**
Spawn an isolated thread with a single data argument.

The data is deep-copied for the thread, ensuring no shared mutable state.
The closure receives the copied data and executes in a separate OS thread.

Arguments:
- data: Data to copy into the thread
- closure: Function to execute with the copied data

Returns:
A ThreadHandle that can be used to join the thread.

```sdoctest
>>> val result_channel = Channel.new()
>>> val handle = spawn_isolated([1, 2, 3], result_channel) \data, chan:
...     chan.send(data.sum())
>>> result_channel.recv()
6
```
*/
fn spawn_isolated(data: Any, closure: fn(Any) -> Any) -> ThreadHandle:
    val handle = rt_thread_spawn_isolated(closure as i64, data)
    return ThreadHandle(_handle: handle)

/**
Spawn an isolated thread with two data arguments (e.g., data + channel).

```sdoctest
>>> val ch = Channel.new()
>>> val handle = spawn_isolated2([1, 2, 3], ch) \data, chan:
...     chan.send(data.sum())
>>> ch.recv()
6
```
*/
fn spawn_isolated2(data1: Any, data2: Any, closure: fn(Any, Any) -> Any) -> ThreadHandle:
    val handle = rt_thread_spawn_isolated2(closure as i64, data1, data2)
    return ThreadHandle(_handle: handle)


# ============================================================================
# Resource-Limited Threads
# ============================================================================

"""
Handle for a resource-limited isolated thread.

Extends ThreadHandle with resource limit tracking and violation detection.
"""
struct LimitedThreadHandle:
    _handle: i64
    _limits: ResourceLimits

    # =========================================================================
    # Basic Operations
    # =========================================================================

    """
    Wait for the thread to complete and get its result.

    Returns the result value, or NIL if the thread was killed.
    """
    fn join() -> Any:
        return rt_thread_join_limited(self._handle)

    """
    Check if the thread has completed without blocking.
    """
    fn is_done() -> bool:
        return rt_thread_is_done_limited(self._handle) == 1

    """
    Check if the thread is still running.
    """
    fn is_running() -> bool:
        return not self.is_done()

    """
    Get the unique ID of this thread.
    """
    fn id() -> i64:
        return rt_thread_id_limited(self._handle)

    """
    Free the thread handle.
    """
    fn free():
        rt_thread_free_limited(self._handle)

    # =========================================================================
    # Resource Limit Methods
    # =========================================================================

    """
    Check if the thread was killed due to a resource limit violation.
    """
    fn was_killed() -> bool:
        return rt_thread_was_killed(self._handle) == 1

    """
    Get the resource limits applied to this thread.
    """
    fn limits() -> ResourceLimits:
        return self._limits

    """
    Get the violation that caused the thread to be killed, if any.
    """
    fn get_violation() -> Option<LimitViolation>:
        if not self.was_killed():
            return None

        val violation_type = rt_thread_get_violation_type(self._handle)
        val violation_value = rt_thread_get_violation_value(self._handle)

        match violation_type:
            case 1:  # CPU time
                return Some(LimitViolation.CpuTimeExceeded(violation_value))
            case 2:  # Memory
                return Some(LimitViolation.MemoryExceeded(violation_value))
            case 3:  # File descriptor
                return Some(LimitViolation.FileDescriptorExceeded(violation_value))
            case 4:  # Thread count
                return Some(LimitViolation.ThreadLimitExceeded(violation_value))
            case 5:  # Unknown
                return Some(LimitViolation.Unknown("Unknown violation"))
            case _:
                return None

    """
    Wait for the thread and return a LimitedResult with success or violation info.
    """
    fn join_result() -> LimitedResult<Any>:
        val result = self.join()

        if self.was_killed():
            match self.get_violation():
                case Some(violation):
                    return LimitedResult.Killed(violation)
                case None:
                    return LimitedResult.Error("Thread was killed but no violation info available")
        else:
            return LimitedResult.Success(result)

    """
    Get a summary of this thread handle.
    """
    fn summary() -> text:
        val status = if self.is_done():
            if self.was_killed():
                "killed"
            else:
                "completed"
        else:
            "running"
        return "LimitedThreadHandle: id={self.id()}, {status}, {self._limits.summary()}"


"""
Spawn an isolated thread with resource limits.

The data is deep-copied for the thread, ensuring no shared mutable state.
Resource limits are applied when the thread starts.

Arguments:
- data: Data to copy into the thread
- limits: Resource limits to apply
- closure: Function to execute with the copied data

Returns:
A LimitedThreadHandle that can be used to join the thread and check for violations.

```simple
val limits = ResourceLimits.new().with_cpu_time(10).with_memory_mb(128)
val handle = spawn_limited(42, limits) \x:
    # This thread is constrained by the resource limits
    x * 2
val result = handle.join_result()
```
"""
fn spawn_limited(data: Any, limits: ResourceLimits, closure: fn(Any) -> Any) -> LimitedThreadHandle:
    val cpu = match limits.cpu_time_seconds:
        case Some(secs): secs
        case None: -1

    val mem = match limits.memory_bytes:
        case Some(bytes): bytes
        case None: -1

    val fd = match limits.file_descriptors:
        case Some(count): count
        case None: -1

    val threads = match limits.thread_count:
        case Some(count): count
        case None: -1

    val handle = rt_thread_spawn_limited(closure as i64, data, cpu, mem, fd, threads)
    return LimitedThreadHandle(_handle: handle, _limits: limits)


"""
Spawn an isolated thread with resource limits and two data arguments.

Similar to spawn_limited but accepts two data arguments (e.g., data + channel).

```simple
val limits = ResourceLimits.default_test_limits()
val ch = Channel.new()
val handle = spawn_limited2([1, 2, 3], ch, limits) \data, result_ch:
    result_ch.send(data.sum())
val result = ch.recv()
```
"""
fn spawn_limited2(data1: Any, data2: Any, limits: ResourceLimits, closure: fn(Any, Any) -> Any) -> LimitedThreadHandle:
    val cpu = match limits.cpu_time_seconds:
        case Some(secs): secs
        case None: -1

    val mem = match limits.memory_bytes:
        case Some(bytes): bytes
        case None: -1

    val fd = match limits.file_descriptors:
        case Some(count): count
        case None: -1

    val threads = match limits.thread_count:
        case Some(count): count
        case None: -1

    val handle = rt_thread_spawn_limited2(closure as i64, data1, data2, cpu, mem, fd, threads)
    return LimitedThreadHandle(_handle: handle, _limits: limits)


/**
Get the number of available CPU cores.

Useful for determining the optimal parallelism level.

```sdoctest
>>> available_parallelism() >= 1
true
```
*/
fn available_parallelism() -> i64:
    return rt_thread_available_parallelism()

/**
Sleep the current thread for the specified milliseconds.

```sdoctest
>>> sleep(10)  # Sleep for 10ms
```
*/
fn sleep(millis: i64):
    rt_thread_sleep(millis)

/**
Yield the current thread, allowing other threads to run.

This is a hint to the scheduler that the current thread is willing
to give up its time slice.

```sdoctest
>>> yield_thread()
```
*/
fn yield_thread():
    rt_thread_yield()

/**
Execute a function in parallel across multiple isolated threads.

Divides work into chunks and processes them in parallel.
Returns results in order.

```sdoctest
>>> val data = [1, 2, 3, 4, 5, 6, 7, 8]
>>> val results = parallel_map(data, \x: x * 2, 4)
>>> results
[2, 4, 6, 8, 10, 12, 14, 16]
```
*/
fn parallel_map<T, R>(items: List<T>, func: fn(T) -> R, num_threads: i64) -> List<R>:
    val n = len(items)
    if n == 0:
        return []

    # Use available parallelism if not specified
    val threads = if num_threads <= 0:
        available_parallelism()
    else:
        num_threads

    # For small workloads, just do it sequentially
    if n <= threads:
        return items.map(func)

    # Divide work into chunks
    val chunk_size = (n + threads - 1) / threads
    val result_channels = []
    val handles = []

    for i in range(threads):
        val start = i * chunk_size
        val end = min(start + chunk_size, n)
        if start >= n:
            break

        val chunk = items[start:end]
        val ch = Channel.new()
        result_channels.push(ch)

        val handle = spawn_isolated2(chunk, ch) \data, result_ch:
            val results = data.map(func)
            result_ch.send(results)
        handles.push(handle)

    # Collect results
    val results = []
    for ch in result_channels:
        val chunk_results = ch.recv()
        results.extend(chunk_results)

    # Clean up handles
    for handle in handles:
        handle.join()
        handle.free()

    return results

/**
Execute a reduction in parallel across multiple isolated threads.

```sdoctest
>>> val data = [1, 2, 3, 4, 5, 6, 7, 8]
>>> val sum = parallel_reduce(data, \a, b: a + b, 0, 4)
>>> sum
36
```
*/
fn parallel_reduce<T, R>(items: List<T>, reducer: fn(R, T) -> R, initial: R, num_threads: i64) -> R:
    val n = len(items)
    if n == 0:
        return initial

    val threads = if num_threads <= 0:
        available_parallelism()
    else:
        num_threads

    # For small workloads, do it sequentially
    if n <= threads:
        val result = initial
        for item in items:
            result = reducer(result, item)
        return result

    # Divide work into chunks
    val chunk_size = (n + threads - 1) / threads
    val result_channels = []
    val handles = []

    for i in range(threads):
        val start = i * chunk_size
        val end = min(start + chunk_size, n)
        if start >= n:
            break

        val chunk = items[start:end]
        val ch = Channel.new()
        result_channels.push(ch)

        val handle = spawn_isolated2(chunk, ch) \data, result_ch:
            val partial = initial
            for item in data:
                partial = reducer(partial, item)
            result_ch.send(partial)
        handles.push(handle)

    # Combine partial results
    val result = initial
    for ch in result_channels:
        val partial = ch.recv()
        result = reducer(result, partial)

    # Clean up handles
    for handle in handles:
        handle.join()
        handle.free()

    return result

# Export thread utility functions for easy access
export available_parallelism
export sleep
export yield_thread
export spawn_isolated
export spawn_isolated2
export spawn_limited
export spawn_limited2
export parallel_map
export parallel_reduce
