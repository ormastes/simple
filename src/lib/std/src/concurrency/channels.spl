/**
Channel Utilities

Channels provide typed communication between concurrent actors.
They are safer than raw send/recv with explicit sender/receiver.

Basic Channel Usage:
```sdoctest
>>> val (tx, rx) = channel()
>>> tx.send(42)
>>> rx.recv()
Some(42)
```
*/

# Import Resource trait for cleanup
use core.resource.Resource

# FFI declarations for channel operations
extern fn rt_channel_new() -> i64
extern fn rt_channel_send(channel_id: i64, value: Any)
extern fn rt_channel_try_recv(channel_id: i64) -> Any
extern fn rt_channel_recv(channel_id: i64) -> Any
extern fn rt_channel_close(channel_id: i64)
extern fn rt_channel_is_closed(channel_id: i64) -> i64

/**
FFI-backed Channel for thread communication.

Uses Rust's mpsc channels under the hood for true multi-threaded communication.
*/
struct Channel:
    _id: i64

    fn new() -> Channel:
        val id = rt_channel_new()
        return Channel(_id: id)

    fn send(value: Any):
        rt_channel_send(self._id, value)

    fn try_recv() -> Any:
        return rt_channel_try_recv(self._id)

    fn recv() -> Any:
        return rt_channel_recv(self._id)

    fn close():
        rt_channel_close(self._id)

    fn is_closed() -> bool:
        return rt_channel_is_closed(self._id) == 1

# Resource trait implementation for Channel
impl Resource for Channel:
    fn close():
        """Close the channel."""
        rt_channel_close(self._id)

    fn is_open() -> bool:
        """Check if the channel is open."""
        not self.is_closed()

    fn resource_name() -> text:
        """Get the resource name for leak reports."""
        "Channel(id={self._id})"

/**
Create a new FFI-backed Channel.

Uses Python-style construction: calls FFI to get channel ID, then constructs Channel.
*/
fn new_channel() -> Channel:
    val id = rt_channel_new()
    return Channel(_id: id)

/**
Bounded channel with capacity limit
*/
struct BoundedChannel<T>:
    capacity: i32
    buffer: List<T>
    closed: bool

    # =========================================================================
    # Helper Methods
    # =========================================================================

    fn is_empty() -> bool:
        """Check if channel has no buffered items."""
        return self.buffer.is_empty()

    fn is_full() -> bool:
        """Check if channel is at capacity."""
        return len(self.buffer) >= self.capacity

    fn is_closed() -> bool:
        """Check if channel is closed."""
        return self.closed

    fn len() -> i32:
        """Get number of buffered items."""
        return len(self.buffer)

    fn available() -> i32:
        """Get available space in buffer."""
        return self.capacity - len(self.buffer)

    fn utilization() -> f64:
        """Calculate buffer utilization (0.0 to 1.0)."""
        if self.capacity > 0:
            return (len(self.buffer) as f64) / (self.capacity as f64)
        return 0.0

    fn can_send() -> bool:
        """Check if can send without blocking."""
        return not self.closed and not self.is_full()

    fn summary() -> text:
        """Get summary of channel state."""
        val status = if self.closed: "closed" else: "open"
        val util = (self.utilization() * 100.0) as i32
        return "BoundedChannel: {self.len()}/{self.capacity} ({util}% full), {status}"

    fn new(capacity: i32) -> BoundedChannel<T>:
        """Create a new bounded channel with the given capacity."""
        return BoundedChannel(capacity: capacity, buffer: [], closed: false)

    fn send(value: T) -> bool:
        if self.closed:
            return false
        if len(self.buffer) >= self.capacity:
            # In full impl, would block
            return false
        self.buffer.push(value)
        return true

    fn recv() -> Option<T>:
        if self.buffer.is_empty:
            if self.closed:
                return Option.None
            # In full impl, would block
            return Option.None
        return Option.Some(self.buffer.pop_front())

    fn close():
        self.closed = true

# Resource trait implementation for BoundedChannel
impl Resource for BoundedChannel<T>:
    fn close():
        """Close the channel."""
        self.closed = true

    fn is_open() -> bool:
        """Check if the channel is open."""
        not self.closed

    fn resource_name() -> text:
        """Get the resource name for leak reports."""
        "BoundedChannel(capacity={self.capacity})"

/**
Unbounded channel (no capacity limit)
*/
struct UnboundedChannel<T>:
    buffer: List<T>
    closed: bool

    # =========================================================================
    # Helper Methods
    # =========================================================================

    fn is_empty() -> bool:
        """Check if channel has no buffered items."""
        return self.buffer.is_empty()

    fn is_closed() -> bool:
        """Check if channel is closed."""
        return self.closed

    fn len() -> i32:
        """Get number of buffered items."""
        return len(self.buffer)

    fn has_items() -> bool:
        """Check if channel has buffered items."""
        return not self.buffer.is_empty()

    fn can_send() -> bool:
        """Check if can send (always true for unbounded unless closed)."""
        return not self.closed

    fn can_recv() -> bool:
        """Check if can receive (has items)."""
        return not self.buffer.is_empty()

    fn summary() -> text:
        """Get summary of channel state."""
        val status = if self.closed: "closed" else: "open"
        return "UnboundedChannel: {self.len()} items, {status}"

    fn new() -> UnboundedChannel<T>:
        """Create a new unbounded channel."""
        return UnboundedChannel(buffer: [], closed: false)

    fn send(value: T):
        if not self.closed:
            self.buffer.push(value)

    fn recv() -> Option<T>:
        if self.buffer.is_empty:
            return Option.None
        return Option.Some(self.buffer.pop_front())

    fn close():
        self.closed = true

# Resource trait implementation for UnboundedChannel
impl Resource for UnboundedChannel<T>:
    fn close():
        """Close the channel."""
        self.closed = true

    fn is_open() -> bool:
        """Check if the channel is open."""
        not self.closed

    fn resource_name() -> text:
        """Get the resource name for leak reports."""
        "UnboundedChannel(len={self.len()})"

/**
One-shot channel for single value transfer
*/
struct Oneshot<T>:
    value: Option<T>
    completed: bool

    # =========================================================================
    # Helper Methods
    # =========================================================================

    fn is_completed() -> bool:
        """Check if value has been sent."""
        return self.completed

    fn is_pending() -> bool:
        """Check if still waiting for value."""
        return not self.completed

    fn has_value() -> bool:
        """Check if has a value (completed)."""
        return self.completed

    fn can_send() -> bool:
        """Check if can send (not yet completed)."""
        return not self.completed

    fn summary() -> text:
        """Get summary of oneshot state."""
        val status = if self.completed: "completed" else: "pending"
        return "Oneshot: {status}"

    fn new() -> Oneshot<T>:
        """Create a new oneshot channel."""
        return Oneshot(value: Option.None, completed: false)

    fn send(value: T) -> bool:
        if self.completed:
            return false
        self.value = Option.Some(value)
        self.completed = true
        return true

    fn recv() -> Option<T>:
        if self.completed:
            return self.value
        return Option.None

/**
Create a sender/receiver pair (sugar for channel creation)

Python-style construction: `channel()` returns (tx, rx) tuple.
Calls UnboundedChannel() which invokes UnboundedChannel.new().

```sdoctest
>>> val (tx, rx) = channel()
>>> tx.send(42)
>>> rx.recv()
Some(42)
```
*/
fn channel():
    val ch = UnboundedChannel()
    return (ch, ch)  # Same object, but conceptually tx/rx

/**
Create a bounded channel (single instance)

Python-style construction: BoundedChannel(10) calls BoundedChannel.new(10).
*/
fn make_bounded_channel(capacity: i32):
    return BoundedChannel(capacity)

/**
Create a bounded channel pair

Python-style construction: `bounded_channel(10)` creates channel with capacity 10.
Calls BoundedChannel(10) which invokes BoundedChannel.new(10).
*/
fn bounded_channel(capacity: i32):
    val ch = BoundedChannel(capacity)
    return (ch, ch)

/**
Create a oneshot channel pair

Python-style construction: `oneshot()` creates one-shot channel.
Calls Oneshot() which invokes Oneshot.new().
*/
fn oneshot():
    val ch = Oneshot()
    return (ch, ch)

# Export channel functions and types
pub use Channel
pub use BoundedChannel
pub use UnboundedChannel
pub use Oneshot
pub use new_channel
pub use make_bounded_channel
pub use channel
pub use bounded_channel
pub use oneshot
