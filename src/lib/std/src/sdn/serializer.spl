///
Module: sdn.serializer

SDN serializer - renders SdnValue back to SDN text format.

Features:
- Smart formatting (inline vs block form)
- Proper indentation
- Escape sequences in strings
- JSON output support

Usage:
    import sdn.serializer
    val sdn_text = to_sdn(value)
    val json_text = to_json(value)
///

import value.SdnValue

# Public exports
export to_sdn, to_json, render_value, render_json

/// Render an SDN value to SDN text format
fn to_sdn(value: SdnValue) -> text:
    return render_value(value, 0)

/// Render an SDN value to JSON format
fn to_json(value: SdnValue) -> text:
    return render_json(value)

/// Render SDN value to string with indentation
fn render_value(value: SdnValue, indent: i32) -> text:
    val prefix = "    ".repeat(indent)

    match value:
        case SdnValue.Null:
            return "null"

        case SdnValue.bool(b):
            return if b: "true" else: "false"

        case SdnValue.i32(i):
            return i.to_string()

        case SdnValue.f32(f):
            return f.to_string()

        case SdnValue.text(s):
            # Quote if contains whitespace or special chars
            if needs_quoting(s):
                return "\"${escape_string(s)}\""
            else:
                return s

        case SdnValue.Array(arr):
            if arr.len == 0:
                return "[]"
            elif is_simple_array(arr):
                # Inline format for simple arrays
                var items = []
                for v in arr:
                    items.push(render_value(v, 0))
                return "[${items.join(\", \")}]"
            else:
                # Block format for complex arrays
                var result = ""
                for v in arr:
                    result += "\n${prefix}    ${render_value(v, indent + 1)}"
                return result

        case SdnValue.Dict(dict):
            if dict.len == 0:
                return "{}"
            elif is_simple_dict(dict):
                # Inline format for simple dicts
                var items = []
                for (k, v) in dict.items():
                    items.push("${k}: ${render_value(v, 0)}")
                return "{${items.join(\", \")}}"
            else:
                # Block format for complex dicts
                var result = ""
                for (k, v) in dict.items():
                    if is_block_value(v):
                        result += "\n${prefix}${k}:"
                        result += render_value(v, indent + 1)
                    else:
                        result += "\n${prefix}${k}: ${render_value(v, 0)}"
                return result

        case SdnValue.Table(fields, _, rows):
            var result = ""

            # Add field headers if named table
            match fields:
                case Some(field_list):
                    result += "|${field_list.join(\", \")}|"
                case nil:
                    pass

            # Add rows
            for row in rows:
                var items = []
                for v in row:
                    items.push(render_value(v, 0))
                result += "\n${prefix}    ${items.join(\", \")}"

            return result

### Helper functions for format decisions

fn needs_quoting(s: text) -> bool:
    """Check if string needs quotes"""
    return s.contains(" ") or s.contains(",") or s.contains(":") or s.contains("\"")

fn escape_string(s: text) -> text:
    """Escape special characters in string"""
    var result = ""
    for ch in s.chars():
        match ch:
            case '\\':
                result += "\\\\"
            case '"':
                result += "\\\""
            case '\n':
                result += "\\n"
            case '\t':
                result += "\\t"
            case '\r':
                result += "\\r"
            case _:
                result += ch
    return result

fn is_simple_array(arr: List<SdnValue>) -> bool:
    """Check if array is simple (can be rendered inline)"""
    if arr.len > 5:
        return false

    for v in arr:
        match v:
            case SdnValue.Null:
                pass
            case SdnValue.bool(_):
                pass
            case SdnValue.i32(_):
                pass
            case SdnValue.f32(_):
                pass
            case SdnValue.text(_):
                pass
            case _:
                return false  # Complex type, not simple

    return true

fn is_simple_dict(dict: Dict<text, SdnValue>) -> bool:
    """Check if dict is simple (can be rendered inline)"""
    if dict.len > 3:
        return false

    for (_, v) in dict.items():
        match v:
            case SdnValue.Null:
                pass
            case SdnValue.bool(_):
                pass
            case SdnValue.i32(_):
                pass
            case SdnValue.f32(_):
                pass
            case SdnValue.text(_):
                pass
            case _:
                return false  # Complex type, not simple

    return true

fn is_block_value(value: SdnValue) -> bool:
    """Check if value should be rendered as a block"""
    match value:
        case SdnValue.Dict(dict):
            return not is_simple_dict(dict)
        case SdnValue.Array(arr):
            return not is_simple_array(arr)
        case SdnValue.Table(_, _, _):
            return true
        case _:
            return false

### JSON rendering

fn render_json(value: SdnValue) -> text:
    """Render SDN value as JSON"""
    match value:
        case SdnValue.Null:
            return "null"

        case SdnValue.bool(b):
            return if b: "true" else: "false"

        case SdnValue.i32(i):
            return i.to_string()

        case SdnValue.f32(f):
            return f.to_string()

        case SdnValue.text(s):
            return "\"${escape_json_string(s)}\""

        case SdnValue.Array(arr):
            var items = []
            for v in arr:
                items.push(render_json(v))
            return "[${items.join(\", \")}]"

        case SdnValue.Dict(dict):
            var pairs = []
            for (k, v) in dict.items():
                pairs.push("\"${escape_json_string(k)}\": ${render_json(v)}")
            return "{${pairs.join(\", \")}}"

        case SdnValue.Table(fields, _, rows):
            # Render table as array of objects (if named) or array of arrays
            match fields:
                case Some(field_list):
                    # Named table → array of objects
                    var objects = []
                    for row in rows:
                        var pairs = []
                        for i in 0..field_list.len:
                            if i < row.len:
                                val field = field_list[i]
                                val item = row[i]
                                pairs.push("\"${escape_json_string(field)}\": ${render_json(item)}")
                        objects.push("{${pairs.join(\", \")}}")
                    return "[${objects.join(\", \")}]"

                case nil:
                    # Typed table → array of arrays
                    var arrays = []
                    for row in rows:
                        var items = []
                        for v in row:
                            items.push(render_json(v))
                        arrays.push("[${items.join(\", \")}]")
                    return "[${arrays.join(\", \")}]"

fn escape_json_string(s: text) -> text:
    """Escape string for JSON"""
    var result = ""
    for ch in s.chars():
        match ch:
            case '\\':
                result += "\\\\"
            case '"':
                result += "\\\""
            case '\n':
                result += "\\n"
            case '\t':
                result += "\\t"
            case '\r':
                result += "\\r"
            case '\b':
                result += "\\b"
            case '\f':
                result += "\\"
            case _:
                result += ch
    return result
