///
Module: sdn.value

SDN runtime value types representing parsed SDN data.

Provides:
- SdnValue: Enum representing any SDN value
- Type checking methods (is_null, is_int, etc.)
- Type conversion methods (as_i64, as_str, etc.)
- Path navigation (get, get_path)
- Mutation (insert, push)
///

# Public exports
export SdnValue

/// SDN value representing any parsed SDN data
enum SdnValue:
    Null
    bool(bool)
    i32(i32)
    f32(f32)
    text(text)
    Array(List<SdnValue>)
    Dict(Dict<text, SdnValue>)
    Table:
        fields: Option<List<text>>   # Named fields (for named tables)
        types: Option<List<text>>    # Type names (for typed tables)
        rows: List<List<SdnValue>>     # Table rows

impl SdnValue:
    # Constructors
    fn null() -> SdnValue:
        return SdnValue.Null

    fn bool_val(b: bool) -> SdnValue:
        return SdnValue.bool(b)

    fn int_val(i: i32) -> SdnValue:
        return SdnValue.i32(i)

    fn float_val(f: f32) -> SdnValue:
        return SdnValue.f32(f)

    fn string_val(s: text) -> SdnValue:
        return SdnValue.text(s)

    fn array_val(values: List<SdnValue>) -> SdnValue:
        return SdnValue.Array(values)

    fn dict_val() -> SdnValue:
        return SdnValue.Dict({})

    fn named_table(fields: List<text>, rows: List<List<SdnValue>>) -> SdnValue:
        return SdnValue.Table(
            fields: Some(fields),
            types: None,
            rows: rows
        )

    fn typed_table(types: List<text>, rows: List<List<SdnValue>>) -> SdnValue:
        return SdnValue.Table(
            fields: None,
            types: Some(types),
            rows: rows
        )

    # Type checking
    fn is_null() -> bool:
        match self:
            case Null:
                return True
            case _:
                return False

    fn is_bool() -> bool:
        match self:
            case bool(_):
                return True
            case _:
                return False

    fn is_int() -> bool:
        match self:
            case i32(_):
                return True
            case _:
                return False

    fn is_float() -> bool:
        match self:
            case f32(_):
                return True
            case _:
                return False

    fn is_number() -> bool:
        match self:
            case i32(_):
                return True
            case f32(_):
                return True
            case _:
                return False

    fn is_string() -> bool:
        match self:
            case text(_):
                return True
            case _:
                return False

    fn is_array() -> bool:
        match self:
            case Array(_):
                return True
            case _:
                return False

    fn is_dict() -> bool:
        match self:
            case Dict(_):
                return True
            case _:
                return False

    fn is_table() -> bool:
        match self:
            case Table(_, _, _):
                return True
            case _:
                return False

    # Type conversions
    fn as_bool() -> Option<bool>:
        match self:
            case bool(b):
                return Some(b)
            case _:
                return None

    fn as_i64() -> Option<i32>:
        match self:
            case i32(i):
                return Some(i)
            case _:
                return None

    fn as_f64() -> Option<f32>:
        match self:
            case f32(f):
                return Some(f)
            case i32(i):
                # i32 can be coerced to f32
                return Some(i.to_float())
            case _:
                return None

    fn as_str() -> Option<text>:
        match self:
            case text(s):
                return Some(s)
            case _:
                return None

    fn as_array() -> Option<List<SdnValue>>:
        match self:
            case Array(arr):
                return Some(arr)
            case _:
                return None

    fn as_dict() -> Option<Dict<text, SdnValue>>:
        match self:
            case Dict(dict):
                return Some(dict)
            case _:
                return None

    # Access methods
    fn get(key: text) -> Option<SdnValue>:
        """
        Get value at key (for dicts) or index (for arrays).

        For dicts: returns value at key
        For arrays: parses key as integer index
        For other types: returns None
        """
        match self:
            case Dict(dict):
                return dict.get(key)

            case Array(arr):
                # Try to parse key as integer index
                val idx = key.to_int()
                match idx:
                    case Some(i):
                        if i >= 0 and i < arr.len:
                            return Some(arr[i])
                        else:
                            return None
                    case None:
                        return None

            case _:
                return None

    fn get_path(path: text) -> Option<SdnValue>:
        """
        Get value at a dotted path (e.g., "server.port").

        Splits path on '.' and navigates through the value tree.
        """
        val keys = path.split(".")
        var current = self

        for key in keys:
            match current.get(key):
                case Some(val):
                    current = val
                case None:
                    return None

        return Some(current)

    # Mutation methods
    me insert(key: text, value: SdnValue) -> Option<SdnValue>:
        """
        Insert a value into a dict.

        Returns the previous value if key existed, None otherwise.
        Only works on Dict values.
        """
        match self:
            case Dict(mut dict):
                val prev = dict.get(key)
                dict[key] = value
                return prev

            case _:
                return None

    me push(value: SdnValue) -> bool:
        """
        Push a value to an array.

        Returns True if successful, False otherwise.
        Only works on Array values.
        """
        match self:
            case Array(mut arr):
                arr.push(value)
                return True

            case _:
                return False

    # Utility methods
    fn type_name() -> text:
        """Get the type name of this value"""
        match self:
            case Null:
                return "null"
            case bool(_):
                return "bool"
            case i32(_):
                return "i32"
            case f32(_):
                return "f32"
            case text(_):
                return "string"
            case Array(_):
                return "array"
            case Dict(_):
                return "dict"
            case Table(_, _, _):
                return "table"

    fn to_string() -> text:
        """Format value as SDN string"""
        match self:
            case Null:
                return "null"

            case bool(b):
                return if b: "true" else: "false"

            case i32(i):
                return i.to_string()

            case f32(f):
                return f.to_string()

            case text(s):
                # Quote if contains special chars or spaces
                if self.needs_quoting(s):
                    return "\"${self.escape_string(s)}\""
                else:
                    return s

            case Array(arr):
                val parts = []
                for val in arr:
                    parts.push(val.to_string())
                return "[${parts.join(\", \")}]"

            case Dict(dict):
                val parts = []
                for (key, val) in dict.items():
                    parts.push("${key}: ${val.to_string()}")
                return "{${parts.join(\", \")}}"

            case Table(fields, _, rows):
                var result = ""

                # Add field headers if named table
                match fields:
                    case Some(field_list):
                        result += "|${field_list.join(\", \")}|"
                    case None:
                        pass

                # Add rows
                for row in rows:
                    result += "\n    "
                    val parts = []
                    for val in row:
                        parts.push(val.to_string())
                    result += parts.join(", ")

                return result

    # Helper methods for string formatting
    fn needs_quoting(s: text) -> bool:
        """Check if string needs quotes"""
        # Quote if contains whitespace or special chars
        return s.contains(" ") or s.contains(",") or s.contains(":")

    fn escape_string(s: text) -> text:
        """Escape special characters in string"""
        var result = ""
        for ch in s.chars():
            match ch:
                case '"':
                    result += "\\\""
                case '\\':
                    result += "\\\\"
                case '\n':
                    result += "\\n"
                case '\t':
                    result += "\\t"
                case '\r':
                    result += "\\r"
                case _:
                    result += ch
        return result

    # =========================================================================
    # Helper Methods
    # =========================================================================

    fn is_primitive() -> bool:
        """Check if value is a primitive (null, bool, i32, f32, string)."""
        match self:
            case Null: True
            case bool(_): True
            case i32(_): True
            case f32(_): True
            case text(_): True
            case _: False

    fn is_collection() -> bool:
        """Check if value is a collection (array, dict, table)."""
        match self:
            case Array(_): True
            case Dict(_): True
            case Table(_, _, _): True
            case _: False

    fn is_truthy() -> bool:
        """Check if value is truthy (non-null, non-false, non-zero, non-empty)."""
        match self:
            case Null: False
            case bool(b): b
            case i32(i): i != 0
            case f32(f): f != 0.0
            case text(s): s.len() > 0
            case Array(arr): arr.len() > 0
            case Dict(dict): dict.len() > 0
            case Table(_, _, rows): rows.len() > 0

    fn is_empty() -> bool:
        """Check if collection is empty (always False for primitives)."""
        match self:
            case Array(arr): arr.len() == 0
            case Dict(dict): dict.len() == 0
            case Table(_, _, rows): rows.len() == 0
            case _: False

    fn len() -> Option<i32>:
        """Get length of collection (None for primitives)."""
        match self:
            case Array(arr): Some(arr.len())
            case Dict(dict): Some(dict.len())
            case Table(_, _, rows): Some(rows.len())
            case text(s): Some(s.len())
            case _: None

    fn is_named_table() -> bool:
        """Check if table has named fields."""
        match self:
            case Table(fields, _, _):
                return fields.is_some()
            case _:
                return False

    fn is_typed_table() -> bool:
        """Check if table has type annotations."""
        match self:
            case Table(_, types, _):
                return types.is_some()
            case _:
                return False

    fn has_key(key: text) -> bool:
        """Check if dict contains key."""
        match self:
            case Dict(dict):
                return dict.contains_key(key)
            case _:
                return False

    fn keys() -> Option<List<text>>:
        """Get list of keys (for dict) or None."""
        match self:
            case Dict(dict):
                return Some(dict.keys())
            case _:
                return None

    fn values() -> Option<List<SdnValue>>:
        """Get list of values (for dict or array) or None."""
        match self:
            case Dict(dict):
                return Some(dict.values())
            case Array(arr):
                return Some(arr)
            case _:
                return None

    fn contains(value: SdnValue) -> bool:
        """Check if array contains value (uses string comparison)."""
        match self:
            case Array(arr):
                for item in arr:
                    if item.to_string() == value.to_string():
                        return True
                return False
            case _:
                return False

    fn index_of(value: SdnValue) -> Option<i32>:
        """Find index of value in array."""
        match self:
            case Array(arr):
                for i in 0..arr.len():
                    if arr[i].to_string() == value.to_string():
                        return Some(i)
                return None
            case _:
                return None

    fn row_count() -> Option<i32>:
        """Get number of rows in table."""
        match self:
            case Table(_, _, rows):
                return Some(rows.len())
            case _:
                return None

    fn column_count() -> Option<i32>:
        """Get number of columns in table."""
        match self:
            case Table(fields, _, rows):
                # Check fields first
                match fields:
                    case Some(field_list):
                        return Some(field_list.len())
                    case None:
                        # Check first row
                        if rows.len() > 0:
                            return Some(rows[0].len())
                        else:
                            return Some(0)
            case _:
                return None

    fn summary() -> text:
        """Get summary of SDN value."""
        val type_name = self.type_name()
        match self:
            case Null:
                return "SdnValue: null"
            case bool(b):
                return "SdnValue: bool ({b})"
            case i32(i):
                return "SdnValue: i32 ({i})"
            case f32(f):
                return "SdnValue: f32 ({f})"
            case text(s):
                val preview = if s.len() > 20:
                    s.slice(0, 20) + "..."
                else:
                    s
                return "SdnValue: string ('{preview}')"
            case Array(arr):
                return "SdnValue: array ({arr.len()} elements)"
            case Dict(dict):
                return "SdnValue: dict ({dict.len()} entries)"
            case Table(_, _, rows):
                return "SdnValue: table ({rows.len()} rows)"

# Create default value (null)
fn default_sdn_value() -> SdnValue:
    return SdnValue.Null
