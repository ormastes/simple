# Expectations - expect/to/not_to DSL
# Provides fluent assertion interface

import matchers.{Matcher, MatchResult}

# Expectation target - wraps actual value
class Expectation<T>:
    actual: T
    negated: bool
    
    fn new(actual: T) -> Expectation<T>:
        return Expectation {
            actual: actual,
            negated: false
        }
    
    # Positive assertion: expect x to eq 5
    fn to(matcher: Matcher<T>) -> void:
        val result = matcher.matches(self.actual)
        
        if self.negated:
            if result.matched:
                fail(result.failure_message)
        else:
            if not result.matched:
                fail(result.failure_message)
    
    # Negative assertion: expect x not_to eq 5
    me not_to(matcher: Matcher<T>) -> void:
        self.negated = true
        self.to(matcher)

# Main expect function
fn expect<T>(actual: T) -> Expectation<T>:
    return Expectation.new(actual)

# Block expectation for errors
class BlockExpectation:
    block: fn() -> void

    fn new(block: fn() -> void) -> BlockExpectation:
        return BlockExpectation { block: block }
    
    fn to(matcher: Matcher<Any>) -> void:
        # Execute block (Simple does not support exceptions)
        # Error handling not available without exception support
        self.block()

        # Pass nil to matcher (no error capture available)
        val result = matcher.matches(nil)
        if not result.matched:
            fail(result.failure_message)

# expect_raises: Block form for error expectations
# Usage: expect_raises ValueError: do_something()
# NOTE: Simple does not support exceptions - this function is a no-op
fn expect_raises(error_type: Type, block: fn() -> void) -> void:
    # Simple does not support exception handling
    # Just execute the block without error checking
    block()

# Failure helper
fn fail(message: text) -> void:
    panic("Expectation failed: {message}")
