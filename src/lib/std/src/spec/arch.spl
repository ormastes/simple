# Architecture Testing DSL for Simple
# Provides ArchUnit-style layer validation and dependency rules
#
# Features:
# - #942: @arch_test decorator for architecture test functions
# - #943: Layer definition DSL with glob patterns
# - Layer access rules: may_only_access, may_not_access, etc.
# - No-mock-in-production validation
# - Skip-layer prevention

# ============================================================================
# Layer Definition
# ============================================================================

# Layer represents a named group of modules matching glob patterns
struct Layer:
    name: text
    patterns: List<text>

    # Create a new layer with name and patterns
    fn new(name: text, patterns: List<text>) -> Layer:
        return Layer { name: name, patterns: patterns }

    # Check if a module path matches this layer
    fn contains(module_path: text) -> bool:
        for pattern in self.patterns:
            if glob_match(pattern=pattern, path=module_path):
                return true
        return false

# LayerRef is a builder for layer access rules
struct LayerRef:
    layer_name: text
    rules: List<AccessRule>

    fn new(name: text) -> LayerRef:
        return LayerRef { layer_name: name, rules: [] }

    # Layer may only access the specified layers
    fn may_only_access(targets: List<text>) -> LayerRef:
        self.rules.push(AccessRule.MayOnlyAccess(self.layer_name, targets))
        return self

    # Layer may not access the specified layers
    fn may_not_access(targets: List<text>) -> LayerRef:
        self.rules.push(AccessRule.MayNotAccess(self.layer_name, targets))
        return self

    # Layer may not be accessed by the specified layers
    fn may_not_be_accessed_by(sources: List<text>) -> LayerRef:
        self.rules.push(AccessRule.MayNotBeAccessedBy(self.layer_name, sources))
        return self

    # Layer may only be accessed by the specified layers
    fn may_only_be_accessed_by(sources: List<text>) -> LayerRef:
        self.rules.push(AccessRule.MayOnlyBeAccessedBy(self.layer_name, sources))
        return self

    # Check the rules against the architecture
    fn check() -> ArchCheckResult:
        return current_arch.check_rules(self.rules)

# Create a layer reference for building rules
fn layer(name: text) -> LayerRef:
    return LayerRef.new(name)

# ============================================================================
# Access Rules
# ============================================================================

enum AccessRule:
    MayOnlyAccess(source: text, targets: List<text>)
    MayNotAccess(source: text, targets: List<text>)
    MayNotBeAccessedBy(target: text, sources: List<text>)
    MayOnlyBeAccessedBy(target: text, sources: List<text>)

impl AccessRule:
    fn is_may_only_access() -> bool:
        """Check if this is MayOnlyAccess rule.
        Returns: true for MayOnlyAccess
        Example: AccessRule.MayOnlyAccess(source: "app", targets: ["core"]).is_may_only_access()  # → true
        """
        match self:
            case AccessRule.MayOnlyAccess(_, _): true
            case _: false

    fn is_may_not_access() -> bool:
        """Check if this is MayNotAccess rule.
        Returns: true for MayNotAccess
        Example: AccessRule.MayNotAccess(source: "ui", targets: ["db"]).is_may_not_access()  # → true
        """
        match self:
            case AccessRule.MayNotAccess(_, _): true
            case _: false

    fn is_may_not_be_accessed_by() -> bool:
        """Check if this is MayNotBeAccessedBy rule.
        Returns: true for MayNotBeAccessedBy
        Example: AccessRule.MayNotBeAccessedBy(target: "core", sources: ["ui"]).is_may_not_be_accessed_by()  # → true
        """
        match self:
            case AccessRule.MayNotBeAccessedBy(_, _): true
            case _: false

    fn is_may_only_be_accessed_by() -> bool:
        """Check if this is MayOnlyBeAccessedBy rule.
        Returns: true for MayOnlyBeAccessedBy
        Example: AccessRule.MayOnlyBeAccessedBy(target: "api", sources: ["app"]).is_may_only_be_accessed_by()  # → true
        """
        match self:
            case AccessRule.MayOnlyBeAccessedBy(_, _): true
            case _: false

    fn is_allow_rule() -> bool:
        """Check if rule is an allow/whitelist rule.
        Returns: true for MayOnlyAccess or MayOnlyBeAccessedBy
        Example: AccessRule.MayOnlyAccess(source: "app", targets: ["core"]).is_allow_rule()  # → true
        """
        match self:
            case AccessRule.MayOnlyAccess(_, _): true
            case AccessRule.MayOnlyBeAccessedBy(_, _): true
            case _: false

    fn is_deny_rule() -> bool:
        """Check if rule is a deny/blacklist rule.
        Returns: true for MayNotAccess or MayNotBeAccessedBy
        Example: AccessRule.MayNotAccess(source: "ui", targets: ["db"]).is_deny_rule()  # → true
        """
        match self:
            case AccessRule.MayNotAccess(_, _): true
            case AccessRule.MayNotBeAccessedBy(_, _): true
            case _: false

    fn is_source_rule() -> bool:
        """Check if rule constrains source (what a layer can access).
        Returns: true for MayOnlyAccess or MayNotAccess
        Example: AccessRule.MayNotAccess(source: "ui", targets: ["db"]).is_source_rule()  # → true
        """
        match self:
            case AccessRule.MayOnlyAccess(_, _): true
            case AccessRule.MayNotAccess(_, _): true
            case _: false

    fn is_target_rule() -> bool:
        """Check if rule constrains target (what can access a layer).
        Returns: true for MayNotBeAccessedBy or MayOnlyBeAccessedBy
        Example: AccessRule.MayNotBeAccessedBy(target: "core", sources: ["ui"]).is_target_rule()  # → true
        """
        match self:
            case AccessRule.MayNotBeAccessedBy(_, _): true
            case AccessRule.MayOnlyBeAccessedBy(_, _): true
            case _: false

    fn to_string() -> text:
        """Convert AccessRule to string representation.
        Returns: rule description
        Example: AccessRule.MayOnlyAccess(source: "app", targets: ["core", "util"]).to_string()
                # → "app may only access [core, util]"
        """
        val sep = ", "
        match self:
            case AccessRule.MayOnlyAccess(source, targets):
                val joined = targets.join(sep)
                "{source} may only access [{joined}]"
            case AccessRule.MayNotAccess(source, targets):
                val joined = targets.join(sep)
                "{source} may not access [{joined}]"
            case AccessRule.MayNotBeAccessedBy(target, sources):
                val joined = sources.join(sep)
                "{target} may not be accessed by [{joined}]"
            case AccessRule.MayOnlyBeAccessedBy(target, sources):
                val joined = sources.join(sep)
                "{target} may only be accessed by [{joined}]"

    fn description() -> text:
        """Get human-readable description of the rule type.
        Returns: descriptive explanation
        Example: AccessRule.MayOnlyAccess(source: "app", targets: ["core"]).description()
                # → "Source allow rule: restricts layer to specific dependencies"
        """
        match self:
            case AccessRule.MayOnlyAccess(_, _):
                "Source allow rule: restricts layer to specific dependencies"
            case AccessRule.MayNotAccess(_, _):
                "Source deny rule: forbids layer from accessing specific dependencies"
            case AccessRule.MayNotBeAccessedBy(_, _):
                "Target deny rule: forbids specific layers from accessing this layer"
            case AccessRule.MayOnlyBeAccessedBy(_, _):
                "Target allow rule: restricts access to this layer from specific sources"

    fn summary() -> text:
        """Get comprehensive summary of the access rule.
        Returns: summary with rule, description, and type
        Example: AccessRule.MayNotAccess(source: "ui", targets: ["db"]).summary()
                # → "AccessRule: ui may not access [db] (Source deny rule: forbids layer from accessing specific dependencies, deny rule, source rule)"
        """
        val rule_str = self.to_string()
        val desc = self.description()
        var types = []

        if self.is_allow_rule():
            types.push("allow rule")
        elif self.is_deny_rule():
            types.push("deny rule")

        if self.is_source_rule():
            types.push("source rule")
        elif self.is_target_rule():
            types.push("target rule")

        val types_str = types.join(", ")
        "AccessRule: {rule_str} ({desc}, {types_str})"

# ============================================================================
# Architecture Definition
# ============================================================================

# Current architecture being validated (set by arch_test decorator)
val current_arch: Option<Architecture> = None

struct Architecture:
    layers: Dict<text, Layer>
    dependencies: Dict<text, List<text>>  # module -> list of imported modules
    file_contents: Dict<text, text>       # module -> file content

    static fn new() -> Architecture:
        return Architecture {
            layers: {},
            dependencies: {},
            file_contents: {}
        }

    # Define a layer with glob patterns
    fn layer(name: text, patterns: List<text>) -> Architecture:
        self.layers[name] = Layer.new(name, patterns)
        return self

    # Get layer by name
    fn get_layer(name: text) -> Option<Layer>:
        return self.layers.get(name)

    # Find which layer a module belongs to
    fn layer_of(module_path: text) -> Option<text>:
        for name, layer in self.layers:
            if layer.contains(module_path):
                return Some(name)
        return None

    # Check a list of rules against this architecture
    fn check_rules(rules: List<AccessRule>) -> ArchCheckResult:
        val violations: List<Violation> = []

        for rule in rules:
            match rule:
                case AccessRule.MayOnlyAccess(source, targets):
                    violations.extend(self.check_may_only_access(source, targets))
                case AccessRule.MayNotAccess(source, targets):
                    violations.extend(self.check_may_not_access(source, targets))
                case AccessRule.MayNotBeAccessedBy(target, sources):
                    violations.extend(self.check_may_not_be_accessed_by(target, sources))
                case AccessRule.MayOnlyBeAccessedBy(target, sources):
                    violations.extend(self.check_may_only_be_accessed_by(target, sources))

        if violations.is_empty():
            return ArchCheckResult.Pass
        else:
            return ArchCheckResult.Fail(violations)

    fn check_may_only_access(source_layer: text, allowed: List<text>) -> List<Violation>:
        val violations: List<Violation> = []
        val source = self.get_layer(source_layer)

        match source:
            case Some(src_layer):
                for module, deps in self.dependencies:
                    if src_layer.contains(module):
                        for dep in deps:
                            val dep_layer = self.layer_of(dep)
                            match dep_layer:
                                case Some(target_layer_name):
                                    if target_layer_name != source_layer and not allowed.contains(target_layer_name):
                                        violations.push(Violation {
                                            rule: "MayOnlyAccess",
                                            message: "Layer '{source_layer}' accessed '{target_layer_name}' which is not in allowed list",
                                            source: Some(module),
                                            target: Some(dep)
                                        })
                                case None:
                                    pass  # External dependency, skip
            case None:
                pass

        return violations

    fn check_may_not_access(source_layer: text, forbidden: List<text>) -> List<Violation>:
        val violations: List<Violation> = []
        val source = self.get_layer(source_layer)

        match source:
            case Some(src_layer):
                for module, deps in self.dependencies:
                    if src_layer.contains(module):
                        for dep in deps:
                            val dep_layer = self.layer_of(dep)
                            match dep_layer:
                                case Some(target_layer_name):
                                    if forbidden.contains(target_layer_name):
                                        violations.push(Violation {
                                            rule: "MayNotAccess",
                                            message: "Layer '{source_layer}' accessed forbidden layer '{target_layer_name}'",
                                            source: Some(module),
                                            target: Some(dep)
                                        })
                                case None:
                                    pass
            case None:
                pass

        return violations

    fn check_may_not_be_accessed_by(target_layer: text, forbidden_sources: List<text>) -> List<Violation>:
        val violations: List<Violation> = []
        val target = self.get_layer(target_layer)

        match target:
            case Some(tgt_layer):
                for module, deps in self.dependencies:
                    val src_layer = self.layer_of(module)
                    match src_layer:
                        case Some(source_layer_name):
                            if forbidden_sources.contains(source_layer_name):
                                for dep in deps:
                                    if tgt_layer.contains(dep):
                                        violations.push(Violation {
                                            rule: "MayNotBeAccessedBy",
                                            message: "Layer '{target_layer}' was accessed by forbidden layer '{source_layer_name}'",
                                            source: Some(module),
                                            target: Some(dep)
                                        })
                        case None:
                            pass
            case None:
                pass

        return violations

    fn check_may_only_be_accessed_by(target_layer: text, allowed_sources: List<text>) -> List<Violation>:
        val violations: List<Violation> = []
        val target = self.get_layer(target_layer)

        match target:
            case Some(tgt_layer):
                for module, deps in self.dependencies:
                    val src_layer = self.layer_of(module)
                    match src_layer:
                        case Some(source_layer_name):
                            if source_layer_name != target_layer and not allowed_sources.contains(source_layer_name):
                                for dep in deps:
                                    if tgt_layer.contains(dep):
                                        violations.push(Violation {
                                            rule: "MayOnlyBeAccessedBy",
                                            message: "Layer '{target_layer}' was accessed by non-allowed layer '{source_layer_name}'",
                                            source: Some(module),
                                            target: Some(dep)
                                        })
                        case None:
                            pass
            case None:
                pass

        return violations

# ============================================================================
# Validation Results
# ============================================================================

struct Violation:
    rule: text
    message: text
    source: Option<text>
    target: Option<text>

    fn to_string() -> text:
        val s = "[{self.rule}] {self.message}"
        match self.source:
            case Some(src):
                s = s + " (from: {src})"
            case None:
                pass
        match self.target:
            case Some(tgt):
                s = s + " (to: {tgt})"
            case None:
                pass
        return s

enum ArchCheckResult:
    Pass
    Fail(violations: List<Violation>)

    fn is_ok() -> bool:
        match self:
            case ArchCheckResult.Pass:
                return true
            case ArchCheckResult.Fail(_):
                return false

    fn violations() -> List<Violation>:
        match self:
            case ArchCheckResult.Pass:
                return []
            case ArchCheckResult.Fail(v):
                return v

    fn is_pass() -> bool:
        """Check if this is Pass result.
        Returns: true for Pass
        Example: ArchCheckResult.Pass.is_pass()  # → true
        """
        match self:
            case ArchCheckResult.Pass: true
            case _: false

    fn is_fail() -> bool:
        """Check if this is Fail result.
        Returns: true for Fail
        Example: ArchCheckResult.Fail(violations: []).is_fail()  # → true
        """
        match self:
            case ArchCheckResult.Fail(_): true
            case _: false

    fn violation_count() -> i32:
        """Get number of violations.
        Returns: number of violations (0 for Pass)
        Example: ArchCheckResult.Fail(violations: vs).violation_count()  # → vs.len()
        """
        match self:
            case ArchCheckResult.Pass: 0
            case ArchCheckResult.Fail(v): v.len()

    fn to_string() -> text:
        """Convert ArchCheckResult to string representation.
        Returns: result description
        Example: ArchCheckResult.Pass.to_string()  # → "pass"
        """
        match self:
            case ArchCheckResult.Pass: "pass"
            case ArchCheckResult.Fail(violations):
                var suffix = "s"
                if violations.len() == 1:
                    suffix = ""
                "fail ({violations.len()} violation{suffix})"

    fn description() -> text:
        """Get human-readable description of the check result.
        Returns: descriptive explanation
        Example: ArchCheckResult.Pass.description()
                # → "Architecture check passed: all rules satisfied"
        """
        match self:
            case ArchCheckResult.Pass:
                "Architecture check passed: all rules satisfied"
            case ArchCheckResult.Fail(violations):
                var suffix = "s"
                if violations.len() == 1:
                    suffix = ""
                "Architecture check failed: {violations.len()} violation{suffix} found"

    fn summary() -> text:
        """Get comprehensive summary of the check result.
        Returns: summary with result, description, and details
        Example: ArchCheckResult.Fail(violations: vs).summary()
                # → "ArchCheckResult: fail (2 violations) (Architecture check failed: 2 violations found, has violations)"
        """
        val result_str = self.to_string()
        val desc = self.description()
        var detail = "has violations"
        if self.is_pass():
            detail = "no violations"

        "ArchCheckResult: {result_str} ({desc}, {detail})"

# ============================================================================
# Special Checks
# ============================================================================

# Check that no mock annotations exist in production code
fn no_mock_in_production(prod_patterns: List<text>) -> ArchCheckResult:
    val violations: List<Violation> = []

    match current_arch:
        case Some(arch):
            for module, content in arch.file_contents:
                # Check if module matches production patterns
                val is_prod = false
                for pattern in prod_patterns:
                    if glob_match(pattern=pattern, path=module):
                        is_prod = true
                        break

                if is_prod:
                    # Check for mock annotations
                    if content.contains("@mock") or content.contains("#[mock]"):
                        violations.push(Violation {
                            rule: "NoMockInProduction",
                            message: "Mock annotation found in production code",
                            source: Some(module),
                            target: None
                        })
        case None:
            pass

    if violations.is_empty():
        return ArchCheckResult.Pass
    else:
        return ArchCheckResult.Fail(violations)

# Check for circular dependencies between layers
fn no_layer_cycles() -> ArchCheckResult:
    val violations: List<Violation> = []

    match current_arch:
        case Some(arch):
            # Build layer dependency graph
            val layer_deps: Dict<text, Set<text>> = {}

            for name, _ in arch.layers:
                layer_deps[name] = Set.new()

            for module, deps in arch.dependencies:
                val src_layer = arch.layer_of(module)
                match src_layer:
                    case Some(src):
                        for dep in deps:
                            val tgt_layer = arch.layer_of(dep)
                            match tgt_layer:
                                case Some(tgt):
                                    if src != tgt:
                                        layer_deps[src].add(tgt)
                                case None:
                                    pass
                    case None:
                        pass

            # Detect cycles using DFS
            val visited: Set<text> = Set.new()
            val rec_stack: Set<text> = Set.new()

            fn has_cycle(node: text) -> Option<List<text>>:
                visited.add(node)
                rec_stack.add(node)

                match layer_deps.get(node):
                    case Some(neighbors):
                        for neighbor in neighbors:
                            if not visited.contains(neighbor):
                                match has_cycle(neighbor):
                                    case Some(path):
                                        path.insert(0, node)
                                        return Some(path)
                                    case None:
                                        pass
                            elif rec_stack.contains(neighbor):
                                return Some([node, neighbor])
                    case None:
                        pass

                rec_stack.remove(node)
                return None

            for name, _ in arch.layers:
                if not visited.contains(name):
                    match has_cycle(name):
                        case Some(cycle):
                            violations.push(Violation {
                                rule: "NoLayerCycles",
                                message: "Circular dependency detected: {cycle.join(' -> ')}",
                                source: None,
                                target: None
                            })
                        case None:
                            pass
        case None:
            pass

    if violations.is_empty():
        return ArchCheckResult.Pass
    else:
        return ArchCheckResult.Fail(violations)

# Check that no layer is skipped (e.g., UI -> DB without going through Service)
fn no_skip_layer(layer_order: List<text>) -> ArchCheckResult:
    val violations: List<Violation> = []

    match current_arch:
        case Some(arch):
            for module, deps in arch.dependencies:
                val src_layer = arch.layer_of(module)
                match src_layer:
                    case Some(src):
                        val src_idx = layer_order.index_of(src)
                        match src_idx:
                            case Some(si):
                                for dep in deps:
                                    val tgt_layer = arch.layer_of(dep)
                                    match tgt_layer:
                                        case Some(tgt):
                                            val tgt_idx = layer_order.index_of(tgt)
                                            match tgt_idx:
                                                case Some(ti):
                                                    # Check if skipping more than one layer
                                                    if ti > si + 1:
                                                        val skipped = layer_order.slice(si + 1, ti)
                                                        violations.push(Violation {
                                                            rule: "NoSkipLayer",
                                                            message: "Layer '{src}' skipped layers {skipped} to access '{tgt}'",
                                                            source: Some(module),
                                                            target: Some(dep)
                                                        })
                                                case None:
                                                    pass
                                        case None:
                                            pass
                            case None:
                                pass
                    case None:
                        pass
        case None:
            pass

    if violations.is_empty():
        return ArchCheckResult.Pass
    else:
        return ArchCheckResult.Fail(violations)

# ============================================================================
# @arch_test Decorator (#942)
# ============================================================================

# Decorator to mark a function as an architecture test
# Sets up the architecture context before running the test
# Note: Macro syntax placeholder - these decorators are implemented in the compiler
# These macros are disabled due to parser limitations
fn __arch_test_placeholder() -> void:
    pass

fn __layers_placeholder() -> void:
    pass

# ============================================================================
# Glob Pattern Matching (simplified)
# ============================================================================

fn glob_match(pattern: text, path: text) -> bool:
    # Simplified glob matching for ** and *
    if pattern == "**":
        return true

    if pattern.ends_with("/**"):
        val prefix = pattern[0:-3]
        return path.starts_with(prefix)

    if pattern.contains("*"):
        # Simple wildcard matching
        val parts = pattern.split("*")
        if parts.len() == 2:
            return path.starts_with(parts[0]) and path.ends_with(parts[1])

    return pattern == path

# ============================================================================
# Exports
# ============================================================================

pub use Layer, LayerRef, AccessRule, Architecture, Violation, ArchCheckResult
pub use layer, no_mock_in_production, no_layer_cycles, no_skip_layer
pub use arch_test, layers
