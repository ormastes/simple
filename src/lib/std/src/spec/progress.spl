# Test Progress Reporting
# Allows long-running tests to report progress during execution

import core.time.{now_ms}

# Progress tracker class to manage test execution progress
class ProgressTracker:
    start_time_ms: Option<i64>

    static fn new() -> ProgressTracker:
        return ProgressTracker {
            start_time_ms: nil
        }

    me init():
        """Initialize progress tracking for current test."""
        self.start_time_ms = Some(now_ms())

    me reset():
        """Reset progress tracking."""
        self.start_time_ms = nil

    fn get_elapsed_seconds() -> f64:
        """Get elapsed time in seconds since test started."""
        match self.start_time_ms:
            case Some(start):
                val current = now_ms()
                val elapsed_ms = current - start
                return (elapsed_ms as f64) / 1000.0
            case _:
                return 0.0

# Global progress tracker instance
val global_tracker: ProgressTracker = ProgressTracker.new()

# Initialize progress tracking (called at test start)
fn init_progress():
    """Initialize progress tracking for current test."""
    global_tracker.init()

# Reset progress tracking (called at test end)
fn reset_progress():
    """Reset progress tracking."""
    global_tracker.reset()

# Get elapsed time since test started
fn get_elapsed_time() -> f64:
    """Get elapsed time in seconds since test started."""
    return global_tracker.get_elapsed_seconds()

# Format elapsed time as human-readable string
fn format_elapsed(seconds: f64) -> text:
    """Format elapsed time as human-readable string.

    Examples:
    - 0.123s → "0.1s"
    - 1.5s → "1.5s"
    - 65s → "1m 5s"
    - 3665s → "1h 1m 5s"
    """
    if seconds < 1.0:
        # Less than 1 second - show deciseconds
        val deciseconds = (seconds * 10.0).round() / 10.0
        return "{deciseconds}s"
    elif seconds < 60.0:
        # Less than 1 minute - show seconds with 1 decimal
        val sec = (seconds * 10.0).round() / 10.0
        return "{sec}s"
    elif seconds < 3600.0:
        # Less than 1 hour - show minutes and seconds
        val minutes = (seconds / 60.0).floor()
        val secs = (seconds % 60.0).floor()
        return "{minutes}m {secs}s"
    else:
        # 1 hour or more - show hours, minutes, seconds
        val hours = (seconds / 3600.0).floor()
        val minutes = ((seconds % 3600.0) / 60.0).floor()
        val secs = (seconds % 60.0).floor()
        return "{hours}h {minutes}m {secs}s"

# Report progress during test execution
fn progress(message: text):
    """Report progress during test execution.

    Prints a progress message to stderr with elapsed time.
    This allows long-running tests to show they're still active.

    Usage:
        progress("Loading modules 5/15...")
        progress("Processing data...")
        progress("Completed: 75%")

    Output format:
        [PROGRESS 12.3s] Loading modules 5/15...

    Args:
        message: Progress message to display
    """
    val elapsed = get_elapsed_time()
    val elapsed_str = format_elapsed(elapsed)
    eprintln("[PROGRESS {elapsed_str}] {message}")

# Convenience function for percentage progress
fn progress_pct(current: i32, total: i32, label: text):
    """Report percentage-based progress.

    Usage:
        progress_pct(5, 15, "modules loaded")
        # Output: [PROGRESS 2.3s] 33% - modules loaded (5/15)
    """
    val pct = (current * 100) / total
    progress("{pct}% - {label} ({current}/{total})")

# Convenience function for step-based progress
fn progress_step(step: i32, total: i32, message: text):
    """Report step-based progress.

    Usage:
        progress_step(3, 10, "Verifying files")
        # Output: [PROGRESS 1.5s] Step 3/10: Verifying files
    """
    progress("Step {step}/{total}: {message}")

export progress, progress_pct, progress_step
export init_progress, reset_progress, get_elapsed_time, format_elapsed
