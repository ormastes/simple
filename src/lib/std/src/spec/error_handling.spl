# Error Handling Framework for SSpec
#
# Provides comprehensive error handling architecture for test execution.
# Ready for Phase 2 integration with try/catch language support.

use core.time.{now_iso8601}

# =========================================================================
# Error Types
# =========================================================================

enum ErrorType:
    Assertion        # Assertion failure
    Panic            # Runtime panic
    Timeout          # Test execution timeout
    Setup            # Error in setup hooks
    Teardown         # Error in teardown/cleanup
    External         # Error from external call/FFI
    Unknown          # Unknown error type

class TestError:
    """Comprehensive error information."""
    error_type: ErrorType
    message: text
    details: text
    stacktrace: Option<List<text>>  # Call stack frames
    line_number: Option<i32>        # Line where error occurred
    file_name: Option<text>         # File where error occurred
    timestamp: text                 # When error occurred

    static fn new(error_type: ErrorType, message: text) -> TestError:
        return TestError {
            error_type: error_type,
            message: message,
            details: "",
            stacktrace: None,
            line_number: None,
            file_name: None,
            timestamp: now_iso8601()
        }

    fn with_details(details: text) -> TestError:
        self.details = details
        return self

    fn with_location(file: text, line: i32) -> TestError:
        self.file_name = Some(file)
        self.line_number = Some(line)
        return self

    fn to_string() -> text:
        var output = match self.error_type:
            Assertion => "Assertion Error"
            Panic => "Panic"
            Timeout => "Timeout"
            Setup => "Setup Error"
            Teardown => "Teardown Error"
            External => "External Error"
            Unknown => "Unknown Error"

        output = "{output}: {self.message}"

        if not self.details.is_empty():
            output = "{output}\n  Details: {self.details}"

        match self.file_name:
            Some(file):
                match self.line_number:
                    Some(line):
                        output = "{output}\n  at {file}:{line}"
                    nil:
                        output = "{output}\n  in {file}"
            nil: pass

        return output

# =========================================================================
# Error Recovery Strategies
# =========================================================================

enum RecoveryStrategy:
    Fail          # Stop immediately
    Skip          # Mark as pending/skipped
    Retry         # Try again
    Ignore        # Continue as if nothing happened

class ErrorRecovery:
    """Configuration for error recovery behavior."""
    strategy: RecoveryStrategy
    max_retries: i32
    retry_delay_ms: i32

    static fn new(strategy: RecoveryStrategy) -> ErrorRecovery:
        return ErrorRecovery {
            strategy: strategy,
            max_retries: 1,
            retry_delay_ms: 0
        }

    static fn with_retries(max_retries: i32) -> ErrorRecovery:
        return ErrorRecovery {
            strategy: RecoveryStrategy.Retry,
            max_retries: max_retries,
            retry_delay_ms: 100
        }

# =========================================================================
# Error Context - Tracks error state during execution
# =========================================================================

class ErrorContext:
    """Maintains error state during test execution."""
    errors: List<TestError>
    in_error: bool
    recovery_strategy: RecoveryStrategy

    static fn new() -> ErrorContext:
        return ErrorContext {
            errors: [],
            in_error: false,
            recovery_strategy: RecoveryStrategy.Fail
        }

    fn add_error(error: TestError) -> void:
        self.errors.append(error)
        self.in_error = true

    fn clear() -> void:
        self.errors = []
        self.in_error = false

    fn has_errors() -> bool:
        return self.errors.len() > 0

    fn last_error() -> Option<TestError>:
        if self.errors.len() > 0:
            Some(self.errors[self.errors.len() - 1])
        else:
            None

    fn all_errors() -> List<TestError>:
        return self.errors

    fn summary() -> text:
        if self.errors.len() == 0:
            return "No errors"

        var summary = "{self.errors.len()} error(s):\n"
        for error in self.errors:
            summary = "{summary}  - {error.to_string()}\n"
        return summary

# =========================================================================
# Panic Handler - For capturing panic information (Phase 2 ready)
# =========================================================================

class PanicInfo:
    """Information about a panic."""
    message: text
    file: text
    line: i32
    column: i32

    fn to_error() -> TestError:
        val error = TestError.new(ErrorType.Panic, self.message)
        error.with_location(self.file, self.line)

# =========================================================================
# Assertion Error - Special handling for assertion failures
# =========================================================================

class AssertionError:
    """Detailed assertion failure information."""
    expected: text
    actual: text
    message: text
    expression: text

    static fn new(expected: text, actual: text, message: text) -> AssertionError:
        return AssertionError {
            expected: expected,
            actual: actual,
            message: message,
            expression: ""
        }

    fn to_error() -> TestError:
        var details = ""
        details = "{details}Expected: {self.expected}\n"
        details = "{details}Actual: {self.actual}"

        if not self.expression.is_empty():
            details = "{details}\nExpression: {self.expression}"

        val error = TestError.new(ErrorType.Assertion, self.message)
        error.with_details(details)

# =========================================================================
# Timeout Handler
# =========================================================================

class TimeoutError:
    """Timeout during test execution."""
    timeout_ms: i32
    operation: text

    static fn new(timeout_ms: i32, operation: text) -> TimeoutError:
        return TimeoutError {
            timeout_ms: timeout_ms,
            operation: operation
        }

    fn to_error() -> TestError:
        val message = "Operation '{self.operation}' timed out after {self.timeout_ms}ms"
        TestError.new(ErrorType.Timeout, message)

# =========================================================================
# Error Handling Utilities (Phase 2 ready)
# =========================================================================

fn capture_panic_info(panic_msg: text, file: text, line: i32, col: i32) -> PanicInfo:
    """Capture panic information.

    Phase 2: Called by panic handler when try/catch is implemented.
    """
    return PanicInfo {
        message: panic_msg,
        file: file,
        line: line,
        column: col
    }

fn should_recover_from_error(error_type: ErrorType, strategy: RecoveryStrategy) -> bool:
    """Determine if error should trigger recovery instead of failure."""
    match strategy:
        RecoveryStrategy.Fail => false
        RecoveryStrategy.Skip => true
        RecoveryStrategy.Retry => true
        RecoveryStrategy.Ignore => true

fn format_error_for_output(error: TestError) -> text:
    """Format error for test output display."""
    return error.to_string()

# =========================================================================
# Helper: Get current timestamp
# =========================================================================

fn now_iso8601() -> text:
    """Get current ISO 8601 timestamp."""
    return core.time.now_iso8601()

# =========================================================================
# Exports
# =========================================================================

pub use ErrorType, TestError, RecoveryStrategy, ErrorRecovery, ErrorContext
pub use PanicInfo, AssertionError, TimeoutError
pub use capture_panic_info, should_recover_from_error, format_error_for_output
