# text Matchers - include, start_with, end_with, match
# text-specific matchers for text validation

import matchers.{Matcher, MatchResult}

# Include matcher for strings: expect "hello world" to include "world"
class IncludeStringMatcher:
    expected: text

impl IncludeStringMatcher:
    fn new(expected: text) -> IncludeStringMatcher:
        return IncludeStringMatcher { expected: expected }

impl Matcher for IncludeStringMatcher:
    fn matches(actual: text) -> MatchResult:
        if actual.contains(self.expected):
            return MatchResult.success()
        else:
            return MatchResult.failure(
                "Expected \"{actual}\" to include \"{self.expected}\""
            )

fn include_string(expected: text) -> IncludeStringMatcher:
    return IncludeStringMatcher.new(expected)

# Start with matcher: expect "hello" to start_with "hel"
class StartWithMatcher:
    expected_prefix: text

impl StartWithMatcher:
    fn new(expected_prefix: text) -> StartWithMatcher:
        return StartWithMatcher { expected_prefix: expected_prefix }

impl Matcher for StartWithMatcher:
    fn matches(actual: text) -> MatchResult:
        if actual.starts_with(self.expected_prefix):
            return MatchResult.success()
        else:
            return MatchResult.failure(
                "Expected \"{actual}\" to start with \"{self.expected_prefix}\""
            )

fn start_with(expected_prefix: text) -> StartWithMatcher:
    return StartWithMatcher.new(expected_prefix)

# End with matcher: expect "hello" to end_with "lo"
class EndWithMatcher:
    expected_suffix: text

impl EndWithMatcher:
    fn new(expected_suffix: text) -> EndWithMatcher:
        return EndWithMatcher { expected_suffix: expected_suffix }

impl Matcher for EndWithMatcher:
    fn matches(actual: text) -> MatchResult:
        if actual.ends_with(self.expected_suffix):
            return MatchResult.success()
        else:
            return MatchResult.failure(
                "Expected \"{actual}\" to end with \"{self.expected_suffix}\""
            )

fn end_with(expected_suffix: text) -> EndWithMatcher:
    return EndWithMatcher.new(expected_suffix)

# Empty string matcher: expect "" to be_blank
class BeBlankMatcher:
    _dummy: bool

impl BeBlankMatcher:
    fn new() -> BeBlankMatcher:
        return BeBlankMatcher { _dummy: false }

impl Matcher for BeBlankMatcher:
    fn matches(actual: text) -> MatchResult:
        if actual.is_empty() or actual.trim().is_empty():
            return MatchResult.success()
        else:
            return MatchResult.failure(
                "Expected \"{actual}\" to be blank"
            )

fn be_blank() -> BeBlankMatcher:
    return BeBlankMatcher.new()
