# BDD Runtime - Per-example state management and memoization
# Manages test execution context, let memoization, and example state

# Per-example state storage
class ExampleState:
    state: Dict<text, Any>
    memoized: Dict<text, Any>
    memoized_blocks: Dict<text, fn() -> Any>

impl ExampleState:
    fn new() -> ExampleState:
        return ExampleState {
            state: {},
            memoized: {},
            memoized_blocks: {}
        }

    fn set(key: text, value: Any) -> void:
        """Set a state value."""
        self.state.insert(key, value)

    fn get(key: text) -> Option<Any>:
        """Get a state value."""
        return self.state.get(key)

    fn has(key: text) -> bool:
        """Check if state key exists."""
        return self.state.contains_key(key)

    fn set_memoized_block(key: text, block: fn() -> Any) -> void:
        """Register a memoized lazy block."""
        self.memoized_blocks.insert(key, block)

    fn get_memoized(key: text) -> Option<Any>:
        """Get memoized value, evaluating block if needed."""
        # Check if already memoized
        match self.memoized.get(key):
            case Some(value):
                return Some(value)
            case None:
                # Try to evaluate the block
                match self.memoized_blocks.get(key):
                    case Some(block):
                        val value = block()
                        self.memoized.insert(key, value)
                        return Some(value)
                    case None:
                        return None

    fn has_memoized(key: text) -> bool:
        """Check if memoized value or block exists."""
        return self.memoized.contains_key(key) or self.memoized_blocks.contains_key(key)

    fn clear() -> void:
        """Clear all state (called between examples)."""
        self.state.clear()
        self.memoized.clear()
        self.memoized_blocks.clear()

# Runtime configuration and state
class Runtime:
    example_state: ExampleState
    config: Dict<text, Any>

impl Runtime:
    fn new() -> Runtime:
        return Runtime {
            example_state: ExampleState.new(),
            config: {}
        }

    # =========================================================================
    # Example State Management
    # =========================================================================

    fn reset_example_state() -> void:
        """Clear example state (call before each example)."""
        self.example_state.clear()

    fn set_example_state(key: text, value: Any) -> void:
        """Set a per-example state value."""
        self.example_state.set(key, value)

    fn get_example_state(key: text) -> Option<Any>:
        """Get a per-example state value."""
        return self.example_state.get(key)

    fn has_example_state(key: text) -> bool:
        """Check if example state key exists."""
        return self.example_state.has(key)

    # =========================================================================
    # Memoization Support (for let_lazy)
    # =========================================================================

    fn set_memoized(key: text, block: fn() -> Any) -> void:
        """Register a memoized lazy block."""
        self.example_state.set_memoized_block(key, block)

    fn get_memoized(key: text) -> Option<Any>:
        """Get memoized value, evaluating block on first access."""
        return self.example_state.get_memoized(key)

    fn has_memoized(key: text) -> bool:
        """Check if memoized value exists."""
        return self.example_state.has_memoized(key)

    # =========================================================================
    # Configuration
    # =========================================================================

    fn set_config(key: text, value: Any) -> void:
        """Set a configuration value."""
        self.config.insert(key, value)

    fn get_config(key: text) -> Option<Any>:
        """Get a configuration value."""
        return self.config.get(key)

    fn set_slow_tests(enabled: bool) -> void:
        """Enable/disable slow test execution."""
        self.set_config("run_slow_tests", enabled)

    fn should_run_slow_tests() -> bool:
        """Check if slow tests should run."""
        match self.get_config("run_slow_tests"):
            case Some(value):
                return value as bool
            case None:
                return false

# Global runtime instance
val global_runtime: Runtime = Runtime.new()

# Convenience functions that use global runtime

fn set_example_state(key: text, value: Any) -> void:
    """Set example state on global runtime."""
    global_runtime.set_example_state(key, value)

fn get_example_state(key: text) -> Option<Any>:
    """Get example state from global runtime."""
    return global_runtime.get_example_state(key)

fn set_memoized(key: text, block: fn() -> Any) -> void:
    """Set memoized block on global runtime."""
    global_runtime.set_memoized(key, block)

fn get_memoized(key: text) -> Option<Any>:
    """Get memoized value from global runtime."""
    return global_runtime.get_memoized(key)

fn has_memoized(key: text) -> bool:
    """Check if memoized value exists in global runtime."""
    return global_runtime.has_memoized(key)

fn reset_example_state() -> void:
    """Reset example state on global runtime."""
    global_runtime.reset_example_state()

export ExampleState, Runtime
export global_runtime
export set_example_state, get_example_state
export set_memoized, get_memoized, has_memoized
export reset_example_state
