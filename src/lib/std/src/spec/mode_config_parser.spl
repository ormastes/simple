# Configuration File Parsing (#2051)
# Parse mode configuration from SDN, TOML, and file attributes

import execution_mode.{ModeSet, string_to_mode}
import mode_config.{ModeConfig, ProjectConfig, DirectoryConfig, FileConfig, FailureStrategy, string_to_failure_strategy, parse_mode_list}

## SDN Configuration Parser
# Parse .spec_config.sdn files for directory-level configuration

# Parse SDN config file
fn parse_sdn_config(content: text) -> Option<DirectoryConfig>:
    """Parse SDN configuration for directory-level test settings.

    Format:
        modes: [interpreter, jit, smf_cranelift]
        skip_modes: [smf_llvm]
        mode_failure_strategy: skip_remaining
    """
    var config = DirectoryConfig.new()

    val lines = content.split("\n")
    for line in lines:
        val trimmed = line.trim()
        if trimmed.is_empty() or trimmed.starts_with("#"):
            continue

        # Parse key: value pairs
        if trimmed.contains(":"):
            val parts = trimmed.split(":")
            if parts.len() >= 2:
                val key = parts[0].trim()
                val value = parts.slice_from(1).join(":").trim()

                match key:
                    case "modes":
                        config.modes = parse_mode_list(value)
                    case "skip_modes":
                        config.skip_modes = parse_mode_list(value)
                    case "mode_failure_strategy":
                        config.failure_strategy = string_to_failure_strategy(value)
                    case _:
                        pass

    Some(config)

# Example .spec_config.sdn format:
# modes: [interpreter, jit, smf_cranelift]
# skip_modes: [smf_llvm]
# mode_failure_strategy: skip_remaining

## TOML Configuration Parser
# Parse simple.toml [test] section for project-level configuration

# Parse TOML [test] section
fn parse_toml_test_config(content: text) -> Option<ProjectConfig>:
    """Parse TOML [test] section for project-level test configuration.

    Format:
        [test]
        default_modes = ["interpreter", "jit", "smf_cranelift", "smf_llvm"]
        mode_failure_strategy = "skip_remaining"
    """
    var config = ProjectConfig.default()
    var in_test_section = false

    val lines = content.split("\n")
    for line in lines:
        val trimmed = line.trim()
        if trimmed.is_empty() or trimmed.starts_with("#"):
            continue

        # Check for section headers
        if trimmed.starts_with("["):
            in_test_section = trimmed == "[test]"
            continue

        # Parse key = value pairs in [test] section
        if in_test_section and trimmed.contains("="):
            val parts = trimmed.split("=")
            if parts.len() >= 2:
                val key = parts[0].trim()
                val value = parts.slice_from(1).join("=").trim()

                match key:
                    case "default_modes":
                        config.default_modes = parse_mode_list(value)
                    case "mode_failure_strategy":
                        # Remove quotes if present
                        val clean_value = value.replace("\"", "").replace("'", "")
                        config.failure_strategy = string_to_failure_strategy(clean_value)
                    case "timeout_seconds":
                        config.timeout_seconds = parse_int(value)
                    case "parallel":
                        config.parallel = value.trim() == "true"
                    case _:
                        pass

    Some(config)

fn parse_int(s: text) -> i32:
    """Parse integer from string."""
    var result: i32 = 0
    for ch in s.trim().chars():
        if ch >= '0' and ch <= '9':
            result = result * 10 + ((ch as i32) - ('0' as i32))
        else:
            break
    result

# Example simple.toml [test] section:
# [test]
# default_modes = ["interpreter", "jit", "smf_cranelift", "smf_llvm"]
# mode_failure_strategy = "skip_remaining"

## File Attribute Parser
# Parse #[modes(...)] attributes from file content

# Parse file attributes for mode configuration
fn parse_file_attributes(content: text) -> FileConfig:
    """Parse file-level attributes for mode configuration.

    Supported attributes:
        #[modes(interpreter, jit)]
        #[skip_modes(smf_llvm)]
        #[only_modes(interpreter)]
        #[mode_failure_strategy(fail_all)]
    """
    var config = FileConfig.new()

    val lines = content.split("\n")
    for line in lines:
        val trimmed = line.trim()

        # Look for #[attribute(...)] pattern
        if trimmed.starts_with("#[") and trimmed.contains("]"):
            # Extract attribute name and value
            val attr_content = extract_attribute(trimmed)

            match attr_content:
                case Some((name, value)):
                    match name:
                        case "modes":
                            config.modes = parse_mode_list(value)
                        case "skip_modes":
                            config.skip_modes = parse_mode_list(value)
                        case "only_modes":
                            # only_modes sets explicit list, clears skip
                            config.modes = parse_mode_list(value)
                            config.skip_modes = ModeSet.empty()
                        case "mode_failure_strategy":
                            config.failure_strategy = string_to_failure_strategy(value)
                        case _:
                            pass
                case None:
                    pass

    config

fn extract_attribute(line: text) -> Option<(text, text)>:
    """Extract attribute name and value from #[name(value)] pattern."""
    # Find the attribute name (between #[ and ()
    val start = 2  # After "#["
    var paren_pos = line.find("(")

    if paren_pos < 0:
        return None

    val name = line.substring(start, paren_pos).trim()

    # Find the value (between ( and ))
    val close_paren = line.rfind(")")
    if close_paren <= paren_pos:
        return None

    val value = line.substring(paren_pos + 1, close_paren).trim()

    Some((name, value))

## Configuration Discovery
# Find and load configuration files in the hierarchy

# Discover project configuration from simple.toml
fn discover_project_config(project_root: text) -> ProjectConfig:
    @extern("runtime", "rt_file_read_text")
    fn _rt_file_read_text(path_ptr: &u8, path_len: u64) -> text

    @extern("runtime", "rt_file_exists")
    fn _rt_file_exists(path_ptr: &u8, path_len: u64) -> bool

    val toml_path = "{project_root}/simple.toml"

    # Check if file exists
    if not _rt_file_exists(toml_path.ptr(), toml_path.len()):
        return ProjectConfig.default()

    # Read and parse TOML
    val content = _rt_file_read_text(toml_path.ptr(), toml_path.len())
    if content.is_empty():
        return ProjectConfig.default()

    # Parse TOML content for test config section
    parse_project_toml(content)

# Discover directory configuration from .spec_config.sdn
fn discover_directory_config(dir_path: text, parent: ModeConfig) -> ModeConfig:
    @extern("runtime", "rt_file_read_text")
    fn _rt_file_read_text(path_ptr: &u8, path_len: u64) -> text

    @extern("runtime", "rt_file_exists")
    fn _rt_file_exists(path_ptr: &u8, path_len: u64) -> bool

    val sdn_path = "{dir_path}/.spec_config.sdn"

    # Check if file exists
    if not _rt_file_exists(sdn_path.ptr(), sdn_path.len()):
        return parent

    # Read and parse SDN config
    val content = _rt_file_read_text(sdn_path.ptr(), sdn_path.len())
    if content.is_empty():
        return parent

    # Parse SDN format to DirectoryConfig
    val dir_config = parse_directory_config(content)
    dir_config.to_mode_config(parent)

# Discover file configuration from file attributes
fn discover_file_config(file_path: text, parent: ModeConfig) -> ModeConfig:
    """Discover file-level configuration from file attributes.

    Reads the file and parses any #[modes(...)] or similar attributes
    to determine file-specific test configuration.

    Args:
        file_path: Path to the test file
        parent: Parent configuration to inherit from

    Returns:
        ModeConfig with file-level overrides applied
    """
    @extern("runtime", "rt_file_read_text")
    fn _rt_file_read_text(path_ptr: &u8, path_len: u64) -> text

    @extern("runtime", "rt_file_exists")
    fn _rt_file_exists(path_ptr: &u8, path_len: u64) -> bool

    # Check if file exists
    if not _rt_file_exists(file_path.ptr(), file_path.len()):
        return parent

    # Read file content
    val content = _rt_file_read_text(file_path.ptr(), file_path.len())
    if content.is_empty():
        return parent

    # Parse file attributes
    val file_config = parse_file_attributes(content)

    # Apply file config to parent
    file_config.to_mode_config(parent)

## Configuration Builder
# Build complete configuration hierarchy for a test file

struct ConfigHierarchy:
    project: ProjectConfig
    directory: Option<DirectoryConfig>
    file: Option<FileConfig>

impl ConfigHierarchy:
    # Build configuration hierarchy for a test file path
    static fn for_file(file_path: text) -> ConfigHierarchy:
        # Extract project root and directory from file path
        val project_root = extract_project_root(file_path)
        val dir_path = extract_directory(file_path)

        # Load configurations
        val project = discover_project_config(project_root)

        # Load directory and file configs
        val parent_config = project.to_mode_config()
        val dir_config = discover_directory_config(dir_path, parent_config)
        val file_config = discover_file_config(file_path, dir_config)

        # Note: We use ModeConfig as the unified format, directory/file stored as None
        # since we apply them sequentially above
        ConfigHierarchy(
            project: project,
            directory: None,
            file: None
        )

    # Build ModeConfig from the hierarchy
    fn build_config() -> ModeConfig:
        # Start with project config
        var config = self.project.to_mode_config()

        # Apply directory config if present
        match self.directory:
            case Some(dir_config) =>
                config = dir_config.to_mode_config(config)
            case None => pass

        # Apply file config if present
        match self.file:
            case Some(file_config) =>
                config = file_config.to_mode_config(config)
            case None => pass

        config

## Helper Functions

# Extract project root from file path
# Looks for simple.toml or .git directory
fn extract_project_root(file_path: text) -> text:
    """Find project root by walking up directories looking for markers."""
    @extern("runtime", "rt_path_dirname")
    fn _rt_path_dirname(path_ptr: &u8, path_len: u64) -> text

    @extern("runtime", "rt_file_exists")
    fn _rt_file_exists(path_ptr: &u8, path_len: u64) -> bool

    # Start from the file's directory
    var current_dir = _rt_path_dirname(file_path.ptr(), file_path.len())
    if current_dir.is_empty():
        current_dir = "."

    # Walk up directories looking for project markers
    var iterations = 0
    while iterations < 100:  # Safety limit
        # Check for simple.toml
        val toml_path = current_dir + "/simple.toml"
        if _rt_file_exists(toml_path.ptr(), toml_path.len()):
            return current_dir

        # Check for .git directory
        val git_path = current_dir + "/.git"
        if _rt_file_exists(git_path.ptr(), git_path.len()):
            return current_dir

        # Go up one level
        val parent = _rt_path_dirname(current_dir.ptr(), current_dir.len())

        # Stop if we reached root (dirname returns empty or same path)
        if parent.is_empty() or parent == current_dir:
            break

        current_dir = parent
        iterations += 1

    # Fallback to current directory
    "."

# Extract directory from file path
fn extract_directory(file_path: text) -> text:
    """Extract parent directory from file path."""
    @extern("runtime", "rt_path_dirname")
    fn _rt_path_dirname(path_ptr: &u8, path_len: u64) -> text

    val dirname = _rt_path_dirname(file_path.ptr(), file_path.len())
    if dirname.is_empty():
        return "."
    else:
        return dirname

# Parse mode names from string list
fn parse_mode_names(names: List<text>) -> Option<ModeSet>:
    var modes = []

    for name in names:
        match string_to_mode(name):
            case Some(mode) => modes.push(mode)
            case None => return None

    Some(ModeSet.new(modes))

## Exports
export ConfigHierarchy
export parse_sdn_config
export parse_toml_test_config
export parse_file_attributes
export discover_project_config
export discover_directory_config
export discover_file_config
export parse_mode_names
