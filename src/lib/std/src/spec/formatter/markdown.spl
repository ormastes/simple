# Markdown Documentation Generator for BDD Specs
# Converts describe/context/it blocks into GitHub-compatible Markdown
# Supports screenshot embedding and diagram generation placeholders

use core.collections.{List, Dict}
use core.string.text
import screenshot.{screenshot_exists, get_screenshot_path, screenshot_markdown}

# Import file helpers
use io.fs_helpers.{read_text_file, exist as path_file_exists}

class MarkdownFormatter:
    output: text
    include_screenshots: bool
    include_diagrams: bool
    test_file: Option<text>

    static fn new() -> MarkdownFormatter:
        return MarkdownFormatter(
            output: text.empty(),
            include_screenshots: true,
            include_diagrams: true,
            test_file: nil
        )

    fn with_test_file(file: text) -> MarkdownFormatter:
        return MarkdownFormatter(
            output: self.output,
            include_screenshots: self.include_screenshots,
            include_diagrams: self.include_diagrams,
            test_file: Some(file)
        )

    fn with_screenshots(enabled: bool) -> MarkdownFormatter:
        return MarkdownFormatter(
            output: self.output,
            include_screenshots: enabled,
            include_diagrams: self.include_diagrams,
            test_file: self.test_file
        )

    fn with_diagrams(enabled: bool) -> MarkdownFormatter:
        return MarkdownFormatter(
            output: self.output,
            include_screenshots: self.include_screenshots,
            include_diagrams: enabled,
            test_file: self.test_file
        )

    fn format_describe(name: text, level: i32) -> text:
        val prefix = "#" * (level + 1)
        return "{prefix} {name}\n\n"

    fn format_context(name: text, level: i32) -> text:
        val prefix = "#" * (level + 2)
        return "{prefix} {name}\n\n"

    fn format_example(name: text, status: text, error: Option<text>) -> text:
        var icon = "❓"
        match status:
            case "pass":
                icon = "✅"
            case "fail":
                icon = "❌"
            case "skip":
                icon = "⏭️"
            case _:
                icon = "❓"

        var result = "{icon} **{name}**\n\n"

        match error:
            case Some(err):
                result = result + "```\nError: {err}\n```\n\n"
            case None:
                pass

        return result

    fn format_example_with_media(name: text, status: text, error: Option<text>, is_gui: bool, has_diagram: bool) -> text:
        var result = self.format_example(name, status, error)

        # Add screenshot section for @gui tests
        if is_gui and self.include_screenshots:
            result = result + self.format_screenshot_section(name)

        # Add diagram section if available
        if has_diagram and self.include_diagrams:
            result = result + self.format_diagram_section(name)

        return result

    fn format_screenshot_section(test_name: text) -> text:
        match self.test_file:
            case Some(file):
                val before_exists = screenshot_exists(test_name, file, "before")
                val after_exists = screenshot_exists(test_name, file, "after")

                if before_exists or after_exists:
                    var section = "<details>\n<summary>Screenshots</summary>\n\n"

                    if before_exists:
                        section = section + "**Before:**\n\n"
                        section = section + screenshot_markdown(test_name, file, "before") + "\n\n"

                    if after_exists:
                        section = section + "**After:**\n\n"
                        section = section + screenshot_markdown(test_name, file, "after") + "\n\n"

                    section = section + "</details>\n\n"
                    return section
                else:
                    # Show placeholder with generation instructions
                    return self.format_screenshot_placeholder(test_name, file)
            case None:
                return ""

    fn format_screenshot_placeholder(test_name: text, test_file: text) -> text:
        val cmd = "simple test --refresh-gui-image {test_file}"
        var result = "<details>\n<summary>Screenshots (not available)</summary>\n\n"
        result = result + "> **Screenshot not captured**\n>\n"
        result = result + "> To generate: `{cmd}`\n\n"
        result = result + "</details>\n\n"
        return result

    fn format_diagram_section(test_name: text) -> text:
        match self.test_file:
            case Some(file):
                val diagram_path = self.get_diagram_path(test_name, file)
                if diagram_path.is_some():
                    val path = diagram_path.unwrap()
                    val content = _read_diagram_content(path)
                    var result = "<details>\n<summary>Sequence Diagram</summary>\n\n"
                    result = result + "```mermaid\n"
                    result = result + content
                    result = result + "\n```\n\n</details>\n\n"
                    return result
                else:
                    return self.format_diagram_placeholder(test_name, file)
            case None:
                return ""

    fn format_diagram_placeholder(test_name: text, test_file: text) -> text:
        val cmd = "simple test --seq-diagram {test_file}"
        var result = "<details>\n<summary>Diagram (not available)</summary>\n\n"
        result = result + "> **Diagram not generated**\n>\n"
        result = result + "> To generate: `{cmd}`\n\n"
        result = result + "</details>\n\n"
        return result

    fn get_diagram_path(test_name: text, test_file: text) -> Option<text>:
        # Compute diagram path similar to screenshot path
        val base_dir = "doc/spec/diagrams"
        val relative = test_file
            .replace("simple/std_lib/test/", "")
            .replace("test/", "")
            .replace("_spec.spl", "")
            .replace("_test.spl", "")
            .replace(".spl", "")

        val safe_name = test_name.replace(" ", "_").replace("/", "_").to_lowercase()
        val path = "{base_dir}/{relative}/{safe_name}.mmd"

        if path_file_exists(path):
            return Some(path)
        else:
            return None

    fn format_code_block(code: text, language: text) -> text:
        return "```{language}\n{code}\n```\n\n"

# Internal: Read diagram content from file
fn _read_diagram_content(path: text) -> text:
    match read_text_file(path):
        case Ok(content):
            return content
        case Err(_):
            return "# Error reading diagram"

# Convert spec results to Markdown documentation
fn format_spec_to_markdown(spec_results: Dict<text, Any>) -> text:
    val formatter = MarkdownFormatter.new()
    var output = text.empty()

    # Extract spec metadata
    val suite_name = spec_results.get("suite_name").unwrap_or("Test Suite")
    output = output + "# {suite_name}\n\n"

    # Add timestamp
    match spec_results.get("timestamp"):
        case Some(timestamp):
            output = output + "*Generated: {timestamp}*\n\n"
        case None:
            pass

    # Process describe blocks
    match spec_results.get("describe_blocks"):
        case Some(describes):
            for describe in describes:
                output = output + formatter.format_describe(
                    describe.get("description").unwrap_or(""),
                    1
                )

                # Process contexts
                match describe.get("contexts"):
                    case Some(contexts):
                        for ctx in contexts:
                            output = output + formatter.format_context(
                                ctx.get("description").unwrap_or(""),
                                2
                            )

                            # Process examples (it blocks)
                            match ctx.get("examples"):
                                case Some(example_list):
                                    for example in example_list:
                                        val status = example.get("status").unwrap_or("unknown")
                                        val name = example.get("description").unwrap_or("")
                                        val error = example.get("error")

                                        output = output + formatter.format_example(name, status, error)

                                        # Add code if available
                                        match example.get("code"):
                                            case Some(code):
                                                output = output + formatter.format_code_block(code, "simple")
                                            case None:
                                                pass
                                case None:
                                    pass
                    case None:
                        pass
        case None:
            pass

    # Add summary
    match spec_results.get("summary"):
        case Some(summary):
            output = output + "\n---\n\n## Summary\n\n"
            val total = summary.get("total").unwrap_or(0)
            val passed = summary.get("passed").unwrap_or(0)
            val failed = summary.get("failed").unwrap_or(0)
            val skipped = summary.get("skipped").unwrap_or(0)

            output = output + "- **Total:** {total} tests\n"
            output = output + "- **Passed:** {passed} ✅\n"
            output = output + "- **Failed:** {failed} ❌\n"
            output = output + "- **Skipped:** {skipped} ⏭️\n"
        case None:
            pass

    return output
