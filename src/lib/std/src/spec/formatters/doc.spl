# Documentation Formatter - Hierarchical test output
# Shows nested describe/context/it structure like RSpec --format documentation

import spec.runner.executor.{TestResult, ExecutionResults, TestStatus}
import spec.registry.{ExampleGroup, get_all_groups}
import io.{println}
import text.color.{green, red, yellow, cyan}

# Documentation formatter - hierarchical output
class DocFormatter:
    show_colors: bool
    indent_size: i32
    show_duration: bool

impl DocFormatter:
    fn new() -> DocFormatter:
        return DocFormatter {
            show_colors: true,
            indent_size: 2,
            show_duration: false
        }

    fn without_colors() -> DocFormatter:
        """Disable colored output."""
        self.show_colors = false
        return self

    fn with_indent(size: i32) -> DocFormatter:
        """Set indentation size."""
        self.indent_size = size
        return self

    fn with_duration() -> DocFormatter:
        """Show duration for each test."""
        self.show_duration = true
        return self

    fn indent(level: i32) -> text:
        """Get indentation string for nesting level."""
        val spaces = " ".repeat(level * self.indent_size)
        return spaces

    fn format_status_marker(status: TestStatus) -> text:
        """Get status marker for a test."""
        match status:
            case TestStatus.Passed:
                return if self.show_colors: green("✓") else: "✓"
            case TestStatus.Failed(_):
                return if self.show_colors: red("✗") else: "✗"
            case TestStatus.Pending:
                return if self.show_colors: yellow("○") else: "○"
            case TestStatus.Skipped:
                return if self.show_colors: cyan("⊘") else: "S"

    fn format_example(result: TestResult, level: i32, failure_index: Option<i32>) -> text:
        """Format a single test example."""
        val marker = self.format_status_marker(result.status)
        val desc = result.example.description
        val indent_str = self.indent(level)

        var output = "{indent_str}{marker} {desc}"

        # Add failure number if failed
        match failure_index:
            case Some(index):
                output = output + " (FAILED - {index})"
            case None:
                pass

        # Add duration if requested
        if self.show_duration:
            val duration_ms = result.duration_ms
            output = output + " ({duration_ms}ms)"

        # Add pending indicator
        if result.is_pending():
            output = output + " (PENDING)"

        return output

    fn format_group(group: ExampleGroup, results: ExecutionResults, level: i32) -> text:
        """Format a test group and its children."""
        var output = ""

        # Print group description
        val indent_str = self.indent(level)
        output = output + "{indent_str}{group.description}\n"

        # Print examples in this group
        for result in results.results:
            if result.group == group:
                # Find failure index if failed
                var failure_index: Option<i32> = None
                if result.is_failed():
                    val failures = results.failures()
                    var idx = 1
                    for failure in failures:
                        if failure == result:
                            failure_index = Some(idx)
                            break
                        idx = idx + 1

                val example_line = self.format_example(result, level + 1, failure_index)
                output = output + example_line + "\n"

        # Print child groups recursively
        for child in group.children:
            output = output + self.format_group(child, results, level + 1)

        return output

    fn format_failures(results: ExecutionResults) -> text:
        """Format failure details."""
        val failures = results.failures()

        if failures.is_empty():
            return ""

        var output = "\nFailures:\n\n"

        var index = 1
        for failure in failures:
            val desc = failure.full_description()
            output = output + "  {index}) {desc}\n"

            match failure.failure_message:
                case Some(message):
                    output = output + "     {message}\n"
                case None:
                    output = output + "     Test failed\n"

            output = output + "\n"
            index = index + 1

        return output

    fn format_summary(results: ExecutionResults) -> text:
        """Format summary line."""
        val total = results.total_count()
        val failed = results.failed_count()
        val pending = results.pending_count()
        val duration = results.total_duration_ms / 1000.0

        var summary = "Finished in {duration}s\n"
        summary = summary + "{total} examples, {failed} failures"

        if pending > 0:
            summary = summary + ", {pending} pending"

        # Color summary based on results
        if self.show_colors:
            if results.all_passed():
                summary = green(summary)
            else if results.has_failures():
                summary = red(summary)
            else:
                summary = yellow(summary)

        return summary

    fn format_results(results: ExecutionResults) -> text:
        """Format complete hierarchical test results."""
        var output = "\n"

        # Format all top-level groups
        val groups = get_all_groups()
        for group in groups:
            output = output + self.format_group(group, results, 0)

        # Add failures section
        output = output + self.format_failures(results)

        # Add summary
        output = output + self.format_summary(results)

        return output

    fn print_results(results: ExecutionResults) -> void:
        """Print formatted results to stdout."""
        println(self.format_results(results))

# Convenience function to format and print results
fn print_doc_results(results: ExecutionResults) -> void:
    """Format results with doc formatter and print."""
    val formatter = DocFormatter.new()
    formatter.print_results(results)

fn print_doc_results_no_color(results: ExecutionResults) -> void:
    """Format results without colors and print."""
    val formatter = DocFormatter.new().without_colors()
    formatter.print_results(results)

fn print_doc_results_with_duration(results: ExecutionResults) -> void:
    """Format results with duration and print."""
    val formatter = DocFormatter.new().with_duration()
    formatter.print_results(results)

export DocFormatter
export print_doc_results, print_doc_results_no_color, print_doc_results_with_duration
