# BDD DSL - RSpec-style describe/context/it blocks
# Implements example group registration and hook management
# Extended with Context Sharing support and Shared Examples (TEST-010, TEST-011)

import registry.{ExampleGroup, Example, Hook, ContextDefinition, Given, SharedExampleDefinition}

# Current execution context (stack of groups)
val group_stack: List<ExampleGroup> = []
var current_group: Option<ExampleGroup> = nil

# Current context definition being built (for Context { ... })
var current_context_def: Option<ContextDefinition> = nil

# context_def: Define a reusable named context
# Usage: context_def :admin_user: ...
fn context_def(name: Symbol, block: fn()):
    val ctx_def = ContextDefinition.new(name)
    current_context_def = Some(ctx_def)

    # Execute block to collect givens
    block()

    # Register the context definition
    match current_context_def:
        case Some(context_def):
            registry.register_context(name, context_def)
        case None:
            pass

    current_context_def = nil

# describe: Create a top-level example group
# Usage: describe "MyClass": ...
fn describe(description: text, block: fn()):
    val group = ExampleGroup.new(description, nil)
    group_stack.push(group)
    current_group = Some(group)
    
    # Execute block to collect nested specs
    block()
    
    # Register with global registry
    registry.register_group(group)
    
    group_stack.pop()
    if group_stack.is_empty():
        current_group = nil
    else:
        current_group = Some(group_stack.last())

# context: Create a nested example group (alias for describe)
# Usage: context "when logged in": ...
fn context(description: text, block: fn()):
    match current_group:
        case Some(parent):
            val group = ExampleGroup.new(description, Some(parent))
            parent.add_child(group)
            group_stack.push(group)
            current_group = Some(group)

            block()

            group_stack.pop()
            current_group = Some(parent)
        case None:
            # If no parent, treat as top-level describe
            describe(description, block)

# context: Reference a single reusable context (capital C Context definition)
# Usage: context :admin_user: ...
fn context(name: Symbol, block: fn()):
    context_with_symbols([name], block)

# context_compose: Reference and compose multiple reusable contexts
# Usage: context_compose :admin_user, :with_database: ...
fn context_compose(names: List<Symbol>, block: fn()):
    context_with_symbols(names, block)

# context_with_symbols: Create nested group and apply context definitions
# Internal helper for context(:symbol) syntax
fn context_with_symbols(names: List<Symbol>, block: fn()):
    match current_group:
        case Some(parent):
            # Create intermediate group for composing contexts
            val context_names = names.map(\s: s.to_string())
            val group_desc = "with " + context_names.join(", ")

            val group = ExampleGroup.new(group_desc, Some(parent))
            parent.add_child(group)
            group_stack.push(group)
            current_group = Some(group)

            # Apply each context definition's givens as before_each hooks
            for name in names:
                match registry.get_context(name):
                    case Some(context_def):
                        # Add givens as hooks
                        for given in context_def.givens:
                            match given:
                                case Given.Lazy(given_name, given_block):
                                    # Create before_each hook that stores the value
                                    group.add_hook(Hook.BeforeEach(\: runtime.set_example_state(given_name.to_string(), given_block())))
                                case Given.Eager(given_block):
                                    # Add eager setup as before_each
                                    group.add_hook(Hook.BeforeEach(given_block))
                    case None:
                        panic("Context ${name} not found")

            block()

            group_stack.pop()
            current_group = Some(parent)
        case None:
            panic("context() must be called within a describe or context block")

# it: Define a single test example
# Usage: it "does something": ...
fn it(description: text, block: fn()):
    match current_group:
        case Some(group):
            val example = Example.new(description, block)
            group.add_example(example)
        case None:
            panic("it() must be called within a describe or context block")

# skip: Define a pending/skipped test example
# Usage: skip "does something not yet implemented": ...
fn skip(description: text, block: fn()):
    match current_group:
        case Some(group):
            val example = Example.new(description, block).skip()
            group.add_example(example)
        case None:
            panic("skip() must be called within a describe or context block")

# slow_it: Define a slow/long-running test example (120+ seconds)
# Usage: slow_it "generates all verification files": ...
# These tests are marked as slow and can be run with --only-slow
fn slow_it(description: text, block: fn()):
    match current_group:
        case Some(group):
            val example = Example.new(description, block).slow()
            group.add_example(example)
        case None:
            panic("slow_it() must be called within a describe or context block")

# ignore_it: Create a test that is always ignored (never runs)
# Usage: ignore_it "description": block
fn ignore_it(description: text, block: fn()):
    match current_group:
        case Some(group):
            val example = Example.new(description, block).ignore()

            # Skip if RUN_SLOW_TESTS is not set to "1" or "true"
            if run_slow != "1" and run_slow != "true":
                example.skip()

            group.add_example(example)
        case None:
            panic("slow_it() must be called within a describe or context block")

# ============================================================================
# TEST-012: Let Memoization - Per-example state management
# ============================================================================
#
# Simple provides two styles of val for different use cases:
#
# 1. `val` (macro) - Eager evaluation before each example
#    - Value is computed before each example runs
#    - Use when the value is always needed
#    - Syntax: val x = make_x()
#
# 2. `let_lazy` - True lazy memoization
#    - Value is computed only on first access within an example
#    - Value is cached for the duration of the example
#    - Access via: `x` (implicit) or `get_let(:x)` (explicit)
#    - Use for expensive computations that may not be needed
#    - Syntax: let_lazy :x, \: make_x()
#
# Both are reset/cleared between examples automatically.

# val: Define eager per-example state (runs before each example)
# Usage: val user = User.new("test")
# Note: This is a compile-time macro that transforms to before_each
# Note: This macro is a placeholder - actual val transformation happens in compiler
# The macro definition is disabled due to parser limitations
# Placeholder function that documents the intended usage
fn __let_macro_placeholder():
    pass

# let_lazy: Define truly lazy memoized per-example state
# Usage: let_lazy :user, \: User.new("test")
# The block is only evaluated when the value is first accessed within an example
fn let_lazy(name: Symbol, block: fn() -> Any):
    match current_group:
        case Some(group):
            # Create a before_each hook that registers the memoized block
            # The block itself is NOT called here - only when accessed
            val name_str = name.to_string()
            group.add_hook(Hook.BeforeEach(\: runtime.set_memoized(name_str, block)))
        case None:
            panic("let_lazy() must be called within a describe or context block")

# get_let: Explicitly get a lazy memoized value (triggers evaluation if needed)
# Usage: val value = get_let(:user)
# This is useful when you want to be explicit about accessing memoized state
fn get_let(name: Symbol) -> Any:
    val name_str = name.to_string()
    match runtime.get_memoized(name_str):
        case Some(value):
            return value
        case None:
            # Fall back to regular example state
            match runtime.get_example_state(name_str):
                case Some(value):
                    return value
                case None:
                    panic("No val/let_lazy value found for '${name_str}'")

# Check if a val value exists (either lazy or eager)
fn has_let(name: Symbol) -> bool:
    val name_str = name.to_string()
    return runtime.has_memoized(name_str) or runtime.get_example_state(name_str).is_some()

# given: Define a fixture (unnamed eager setup)
# Usage: given { setup_code() }  -> Runs before each example
fn given(block: fn()):
    match current_context_def:
        case Some(ctx_d):
            # Eager given inside a Context definition
            ctx_d.add_given(Given.Eager(block))
        case None:
            # Regular eager setup (like before_each) when not in Context definition
            match current_group:
                case Some(group):
                    group.add_hook(Hook.BeforeEach(block))
                case None:
                    panic("given() must be called within a describe/context block or Context definition")

# given: Reference a context_def within a given block (overloaded version)
# Usage: given :context_name -> Apply context_def givens inside given block
# This allows composing contexts inline within setup blocks
fn given(context_name: Symbol):
    match current_group:
        case Some(group):
            # Look up the context definition
            match registry.get_context(context_name):
                case Some(context_def):
                    # Apply each given from the context as before_each hooks
                    for given in context_def.givens:
                        match given:
                            case Given.Lazy(given_name, given_block):
                                # Create before_each hook that stores the memoized value
                                group.add_hook(Hook.BeforeEach(\: runtime.set_example_state(given_name.to_string(), given_block())))
                            case Given.Eager(given_block):
                                # Add eager setup as before_each
                                group.add_hook(Hook.BeforeEach(given_block))
                case None:
                    panic("Context ${context_name} not found")
        case None:
            panic("given() must be called within a describe/context block")

# given: Define a named eager fixture (overloaded version)
# Usage: given :setup, \: setup_code()  -> Named eager setup that runs before each example
# Named eager fixtures run eagerly (before each example) but can be documented/identified by name
fn given(name: Symbol, block: fn()):
    match current_context_def:
        case Some(ctx_d):
            # Named eager given inside a Context definition
            ctx_d.add_given(Given.Eager(block))
        case None:
            # Named eager setup in regular context - same behavior as unnamed given
            match current_group:
                case Some(group):
                    group.add_hook(Hook.BeforeEach(block))
                case None:
                    panic("given() must be called within a describe/context block or Context definition")

# given_lazy: Define a lazy (memoized) fixture
# Usage in Context definition: given_lazy :user, \: User.new("test")
# Usage in context block: given_lazy :user, \: User.new("test")
# Lazy fixtures are memoized per example (called once, cached for duration of example)
fn given_lazy(name: Symbol, block: fn() -> Any):
    match current_context_def:
        case Some(ctx_d):
            # In context definition - add to context's givens list
            ctx_d.add_given(Given.Lazy(name, block))
        case None:
            # In regular context/describe block - create before_each hook with memoization
            match current_group:
                case Some(group):
                    # Create a before_each hook that memoizes the value
                    group.add_hook(Hook.BeforeEach(\: runtime.set_example_state(name.to_string(), block())))
                case None:
                    panic("given_lazy() must be called within a describe/context block or Context definition")

# then: BDD-style assertion (optional - synonym for expect truthy)
# Usage: then { expression_is_truthy }
# This is syntactic sugar for: expect(...).to be_truthy
fn then(block: fn() -> bool):
    val result = block()
    if not result:
        panic("Expected truthy value in then block")

# Hook definitions
fn before_each(block: fn()):
    match current_group:
        case Some(group):
            group.add_hook(Hook.BeforeEach(block))
        case None:
            panic("before_each() must be called within a describe or context block")

fn after_each(block: fn()):
    match current_group:
        case Some(group):
            group.add_hook(Hook.AfterEach(block))
        case None:
            panic("after_each() must be called within a describe or context block")

fn before_all(block: fn()):
    match current_group:
        case Some(group):
            group.add_hook(Hook.BeforeAll(block))
        case None:
            panic("before_all() must be called within a describe or context block")

fn after_all(block: fn()):
    match current_group:
        case Some(group):
            group.add_hook(Hook.AfterAll(block))
        case None:
            panic("after_all() must be called within a describe or context block")

# ============================================================================
# TEST-010: Shared Examples - Define reusable example groups
# ============================================================================
#
# shared_examples allows you to define a group of examples that can be
# included in multiple describe/context blocks using it_behaves_like.
#
# The shared examples block has access to helper functions and fixtures
# defined in the scope where it_behaves_like is called.
#
# Usage:
#   shared_examples "a stack-like container":
#       it "supports push/pop":
#           s = make()  # Uses 'make' function from calling scope
#           s.push(1)
#           expect s.pop() to eq 1
#
#   describe "Stack":
#       fn make() -> Stack:
#           return Stack.new()
#
#       it_behaves_like "a stack-like container"
#
fn shared_examples(name: text, block: fn()):
    val definition = SharedExampleDefinition.new(name, block)
    registry.register_shared_examples(name, definition)

# Variant with description for documentation
fn shared_examples(name: text, description: text, block: fn()):
    val definition = SharedExampleDefinition.new(name, block).with_description(description)
    registry.register_shared_examples(name, definition)

# ============================================================================
# TEST-011: it_behaves_like - Include shared examples in current context
# ============================================================================
#
# it_behaves_like includes the examples from a shared_examples definition
# into the current describe/context block. It creates a nested context
# named "behaves like {name}" and executes the shared block within it.
#
# The shared examples have access to:
# - Helper functions defined in the current scope (e.g., factory functions)
# - Fixtures defined via given/given_lazy in the current context
# - The full example group hierarchy for hook execution
#
# Usage:
#   describe "Stack":
#       fn make() -> Stack:
#           return Stack.new()
#
#       it_behaves_like "a stack-like container"
#
#   describe "Deque":
#       fn make() -> Deque:
#           return Deque.new()
#
#       it_behaves_like "a stack-like container"
#
fn it_behaves_like(name: text):
    match registry.get_shared_examples(name):
        case Some(definition):
            # Create a nested context for the shared examples
            # This provides proper isolation and hook inheritance
            val context_name = "behaves like ${name}"
            context(context_name, definition.block)
        case None:
            panic("Shared example '${name}' not found. Did you define it with shared_examples(\"${name}\")?")

# Variant: include_examples is an alias for it_behaves_like (RSpec compatibility)
fn include_examples(name: text):
    it_behaves_like(name)

