# CLI Entry Point - Command-line interface for running tests
# Usage: simple test [options]

use spec.runner.executor.{TestExecutor, ExecutionResults, TestInfo}
use spec.runner.filter.{TestFilter}
use spec.formatters.progress.{ProgressFormatter, print_progress_results}
use spec.formatters.doc.{DocFormatter, print_doc_results}
use spec.formatters.json.{JsonFormatter, print_json_results, write_json_results}
use shell.{args, env, exit}
use io.{println, eprintln}

# CLI configuration
class TestCli:
    formatter: text  # "progress", "doc", "json"
    run_slow: bool
    only_slow: bool
    only_skipped: bool
    list_mode: bool
    list_ignored: bool
    show_tags: bool
    filter: TestFilter
    output_file: Option<text>
    show_help: bool
    verbose: bool
    fail_fast: bool

impl TestCli:
    fn new() -> TestCli:
        return TestCli {
            formatter: "progress",
            run_slow: false,
            only_slow: false,
            only_skipped: false,
            list_mode: false,
            list_ignored: false,
            show_tags: false,
            filter: TestFilter.new(),
            output_file: None,
            show_help: false,
            verbose: false,
            fail_fast: false
        }

    fn parse_args(args: List<text>) -> TestCli:
        """Parse command-line arguments."""
        var i = 0

        while i < args.len():
            val arg = args[i]

            match arg:
                case "--format":
                    i = i + 1
                    if i < args.len():
                        self.formatter = args[i]

                case "-f":
                    i = i + 1
                    if i < args.len():
                        self.formatter = args[i]

                case "--slow":
                    self.run_slow = true

                case "--only-slow":
                    self.only_slow = true
                    self.filter.with_tag("slow")

                case "--only-skipped":
                    self.only_skipped = true
                    self.filter.with_tag("skip")

                case "--list":
                    self.list_mode = true

                case "-l":
                    self.list_mode = true

                case "--list-ignored":
                    self.list_mode = true
                    self.list_ignored = true
                    self.filter.with_tag("slow")

                case "--show-tags":
                    self.show_tags = true

                case "--tag":
                    i = i + 1
                    if i < args.len():
                        self.filter.with_tag(args[i])

                case "-t":
                    i = i + 1
                    if i < args.len():
                        self.filter.with_tag(args[i])

                case "--exclude-tag":
                    i = i + 1
                    if i < args.len():
                        self.filter.without_tag(args[i])

                case "--pattern":
                    i = i + 1
                    if i < args.len():
                        self.filter.matching(args[i])

                case "-p":
                    i = i + 1
                    if i < args.len():
                        self.filter.matching(args[i])

                case "--output":
                    i = i + 1
                    if i < args.len():
                        self.output_file = Some(args[i])

                case "-o":
                    i = i + 1
                    if i < args.len():
                        self.output_file = Some(args[i])

                case "--verbose":
                    self.verbose = true

                case "-v":
                    self.verbose = true

                case "--fail-fast":
                    self.fail_fast = true

                case "--help":
                    self.show_help = true

                case "-h":
                    self.show_help = true

                case _:
                    # Treat unknown args as pattern filters
                    if not arg.starts_with("-"):
                        self.filter.matching(arg)

            i = i + 1

        return self

    fn print_help() -> void:
        """Print usage help."""
        println("Usage: simple test [options] [pattern]")
        println("")
        println("Options:")
        println("  -f, --format FORMAT      Output format: progress, doc, json (default: progress)")
        println("  -l, --list               List tests without running them")
        println("  --list-ignored           List tests that will be ignored (Rust #[ignore])")
        println("  --show-tags              Show tags in list output")
        println("  --slow                   Include slow tests (default: skip slow tests)")
        println("  --only-slow              Run only slow tests")
        println("  --only-skipped           Run only skipped tests")
        println("  -t, --tag TAG            Run only tests with this tag")
        println("  --exclude-tag TAG        Skip tests with this tag")
        println("  -p, --pattern PATTERN    Run only tests matching pattern")
        println("  -o, --output FILE        Write output to file (JSON format only)")
        println("  -v, --verbose            Verbose output")
        println("  --fail-fast              Stop on first failure")
        println("  -h, --help               Show this help message")
        println("")
        println("Examples:")
        println("  simple test                          # Run all tests")
        println("  simple test --list                   # List all tests")
        println("  simple test --list --show-tags       # List tests with tags")
        println("  simple test --list-ignored           # List tests marked with #[ignore]")
        println("  simple test --list --only-slow       # List only slow tests")
        println("  simple test --format doc             # Hierarchical output")
        println("  simple test --tag unit               # Run only unit tests")
        println("  simple test --slow                   # Include slow tests")
        println("  simple test --only-slow              # Run only slow tests")
        println("  simple test --only-skipped           # Run only skipped tests")
        println("  simple test Calculator               # Run tests matching 'Calculator'")
        println("  simple test --format json -o results.json  # JSON output to file")

    fn run() -> i32:
        """Run tests and return exit code (0 = success, 1 = failure)."""
        # Show help if requested
        if self.show_help:
            self.print_help()
            return 0

        # Configure executor
        var executor = TestExecutor.new()

        # Handle slow test options
        if self.run_slow or self.only_slow:
            executor.with_slow_tests(true)

        # Apply filters to executor
        if not self.filter.is_empty():
            executor.with_filter(self.filter)

        # List mode - show tests without running
        if self.list_mode:
            var test_list = executor.list_tests()

            # Filter for ignored tests if requested
            if self.list_ignored:
                test_list = test_list.filter(\t: t.is_ignored or t.is_slow)

            # Print header
            if self.list_ignored:
                println("Ignored Tests:")
                println("These tests are marked with ignore_it() or slow_it()")
                println("")
            else:
                println("Tests:")

            # Print each test
            for test_info in test_list:
                # Build status indicators
                var status_parts: List<text> = []

                if test_info.is_ignored:
                    status_parts.push("ignored")
                if test_info.is_slow:
                    status_parts.push("slow")
                if test_info.is_skipped:
                    status_parts.push("skipped")

                # Show tags if requested or if listing ignored
                val show_tag_info = self.show_tags or self.list_ignored
                val tags_str = if show_tag_info and not test_info.tags.is_empty():
                    " [" + test_info.tags.join(", ") + "]"
                else:
                    ""

                # Show status indicators
                val status_str = if not status_parts.is_empty():
                    " (" + status_parts.join(", ") + ")"
                else:
                    ""

                println("  {test_info.full_description}{tags_str}{status_str}")

            # Print summary
            println("")
            if self.list_ignored:
                val ignored_count = test_list.filter(\t: t.is_ignored).len()
                val slow_count = test_list.filter(\t: t.is_slow).len()
                println("Total: {test_list.len()} ignored tests")
                if ignored_count > 0:
                    println("  ignore_it: {ignored_count} (intentionally disabled)")
                if slow_count > 0:
                    println("  slow_it: {slow_count} (generates Rust #[ignore])")
                println("")
                println("Note:")
                println("  - ignore_it tests are never run")
                println("  - slow_it tests can be run with: cargo test -- --ignored")
            else:
                val ignored_count = test_list.filter(\t: t.is_ignored).len()
                val slow_count = test_list.filter(\t: t.is_slow).len()
                val skip_count = test_list.filter(\t: t.is_skipped).len()
                println("Total: {test_list.len()} tests")
                if ignored_count > 0:
                    println("  Ignored: {ignored_count} (intentionally disabled)")
                if slow_count > 0:
                    println("  Slow: {slow_count} (will be ignored at Rust level)")
                if skip_count > 0:
                    println("  Skipped: {skip_count} (not yet implemented)")

            return 0

        # Run tests
        if self.verbose:
            println("Running tests...")

        val results = executor.run()

        # Format and output results
        match self.formatter:
            case "progress":
                print_progress_results(results)

            case "doc":
                print_doc_results(results)

            case "json":
                match self.output_file:
                    case Some(path):
                        write_json_results(results, path)
                        if self.verbose:
                            println("Results written to {path}")
                    case None:
                        print_json_results(results)

            case _:
                eprintln("Unknown format: {self.formatter}")
                eprintln("Valid formats: progress, doc, json")
                return 1

        # Return exit code based on results
        if results.all_passed():
            return 0
        else:
            return 1

# Main entry point
fn main() -> i32:
    """Main entry point for test runner."""
    val cli_args = args()

    # Create CLI and parse arguments
    var cli = TestCli.new()
    cli.parse_args(cli_args)

    # Run tests
    return cli.run()

# Convenience function for running tests programmatically
fn run_tests_with_format(formatter: text) -> ExecutionResults:
    """Run tests with specified formatter."""
    val executor = TestExecutor.new()
    val results = executor.run()

    match formatter:
        case "progress":
            print_progress_results(results)
        case "doc":
            print_doc_results(results)
        case "json":
            print_json_results(results)
        case _:
            print_progress_results(results)

    return results

export TestCli, main, run_tests_with_format
