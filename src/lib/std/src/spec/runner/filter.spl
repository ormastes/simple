# Test Filtering - Tag and pattern-based test selection
# Allows selective test execution based on tags, descriptions, and file paths

use spec.registry.{ExampleGroup, Example}

# Filter configuration
class TestFilter:
    include_tags: List<text>
    exclude_tags: List<text>
    include_patterns: List<text>
    exclude_patterns: List<text>
    focus_mode: bool  # Run only focused tests (fit, fdescribe)

impl TestFilter:
    fn new() -> TestFilter:
        return TestFilter {
            include_tags: [],
            exclude_tags: [],
            include_patterns: [],
            exclude_patterns: [],
            focus_mode: false
        }

    # Tag filters
    fn with_tag(tag: text) -> TestFilter:
        """Include tests with this tag."""
        self.include_tags.push(tag)
        return self

    fn with_tags(tags: List<text>) -> TestFilter:
        """Include tests with any of these tags."""
        self.include_tags.extend(tags)
        return self

    fn without_tag(tag: text) -> TestFilter:
        """Exclude tests with this tag."""
        self.exclude_tags.push(tag)
        return self

    fn without_tags(tags: List<text>) -> TestFilter:
        """Exclude tests with any of these tags."""
        self.exclude_tags.extend(tags)
        return self

    # Pattern filters
    fn matching(pattern: text) -> TestFilter:
        """Include tests matching description pattern."""
        self.include_patterns.push(pattern)
        return self

    fn not_matching(pattern: text) -> TestFilter:
        """Exclude tests matching description pattern."""
        self.exclude_patterns.push(pattern)
        return self

    # Focus mode
    fn focus_only() -> TestFilter:
        """Run only focused tests."""
        self.focus_mode = true
        return self

    # Matching logic
    fn matches_tags(example: Example) -> bool:
        """Check if example matches tag filters."""
        # Check exclude tags first (blacklist)
        for tag in self.exclude_tags:
            if example.has_tag(tag):
                return false

        # If include tags specified, must match at least one (whitelist)
        if not self.include_tags.is_empty():
            var has_match = false
            for tag in self.include_tags:
                if example.has_tag(tag):
                    has_match = true
                    break
            return has_match

        # No tag filters or passed all checks
        return true

    fn matches_pattern(full_description: text) -> bool:
        """Check if description matches pattern filters."""
        # Check exclude patterns first (blacklist)
        for pattern in self.exclude_patterns:
            if full_description.contains(pattern):
                return false

        # If include patterns specified, must match at least one (whitelist)
        if not self.include_patterns.is_empty():
            var has_match = false
            for pattern in self.include_patterns:
                if full_description.contains(pattern):
                    has_match = true
                    break
            return has_match

        # No pattern filters or passed all checks
        return true

    fn matches_example(example: Example, group: ExampleGroup) -> bool:
        """Check if example matches all filter criteria."""
        # Check tags
        if not self.matches_tags(example):
            return false

        # Check patterns
        val full_desc = group.full_description() + " " + example.description
        if not self.matches_pattern(full_desc):
            return false

        # Check focus mode
        if self.focus_mode:
            if not example.has_tag("focus"):
                return false

        return true

    fn is_empty() -> bool:
        """Check if filter has any criteria."""
        if not self.include_tags.is_empty():
            return false
        if not self.exclude_tags.is_empty():
            return false
        if not self.include_patterns.is_empty():
            return false
        if not self.exclude_patterns.is_empty():
            return false
        if self.focus_mode:
            return false
        return true

# Common filter presets

fn filter_unit_tests() -> TestFilter:
    """Filter for unit tests only."""
    return TestFilter.new().with_tag("unit")

fn filter_integration_tests() -> TestFilter:
    """Filter for integration tests only."""
    return TestFilter.new().with_tag("integration")

fn filter_system_tests() -> TestFilter:
    """Filter for system/e2e tests only."""
    return TestFilter.new().with_tag("system")

fn filter_fast_tests() -> TestFilter:
    """Filter for fast tests (exclude slow)."""
    return TestFilter.new().without_tag("slow")

fn filter_slow_tests() -> TestFilter:
    """Filter for slow tests only."""
    return TestFilter.new().with_tag("slow")

fn filter_focus() -> TestFilter:
    """Filter for focused tests only."""
    return TestFilter.new().focus_only()

# Tag shortcuts for common test types
pub const TAG_UNIT: text = "unit"
pub const TAG_INTEGRATION: text = "integration"
pub const TAG_SYSTEM: text = "system"
pub const TAG_SLOW: text = "slow"
pub const TAG_FOCUS: text = "focus"
pub const TAG_WIP: text = "wip"  # Work in progress
pub const TAG_SKIP: text = "skip"

export TestFilter
export filter_unit_tests, filter_integration_tests, filter_system_tests
export filter_fast_tests, filter_slow_tests, filter_focus
export TAG_UNIT, TAG_INTEGRATION, TAG_SYSTEM, TAG_SLOW, TAG_FOCUS, TAG_WIP, TAG_SKIP
