# Multi-Mode Test Execution (#2050-#2054)
# Executes tests across multiple execution modes with reporting

import execution_mode.{ExecutionMode, ModeSet, mode_to_string, is_mode_available}
import mode_config.{ModeConfig, FailureStrategy}

# FFI for runtime mode configuration
extern fn runtime_set_jit_enabled(enabled: bool)
extern fn runtime_set_backend(backend: text)
extern fn get_current_time_ms() -> i32

## Test Result
# Result of running a single test in a specific mode
struct TestResult:
    test_name: text
    mode: ExecutionMode
    status: TestStatus
    error: Option<text>
    duration_ms: i32
    config_source: text  # Which level set the mode configuration

enum TestStatus:
    Passed
    Failed
    Skipped

## Mode Execution Result
# Aggregates results across all modes for a single test
struct ModeExecutionResult:
    test_name: text
    results: List<TestResult>
    total_modes: i32
    passed_modes: i32
    failed_modes: i32
    skipped_modes: i32

    fn new(test_name: text) -> ModeExecutionResult:
        ModeExecutionResult {
            test_name: test_name,
            results: [],
            total_modes: 0,
            passed_modes: 0,
            failed_modes: 0,
            skipped_modes: 0
        }

    # Add a test result
    var fn add_result(result: TestResult) -> ModeExecutionResult:
        self.results.push(result)
        self.total_modes = self.total_modes + 1

        match result.status:
            case TestStatus.Passed => self.passed_modes = self.passed_modes + 1
            case TestStatus.Failed => self.failed_modes = self.failed_modes + 1
            case TestStatus.Skipped => self.skipped_modes = self.skipped_modes + 1

        self

    # Check if all modes passed
    fn all_passed() -> bool:
        self.failed_modes == 0 and self.skipped_modes == 0

    # Check if any mode failed
    fn has_failures() -> bool:
        self.failed_modes > 0

## Mode Runner
# Executes tests in multiple modes
struct ModeRunner:
    config: ModeConfig
    results: List<ModeExecutionResult>

    fn new(config: ModeConfig) -> ModeRunner:
        ModeRunner {
            config: config,
            results: []
        }

    # Set execution mode for the runtime
    fn set_execution_mode(mode: ExecutionMode):
        """Configure the runtime to execute in the specified mode.

        This sets the execution context so subsequent code runs
        in the appropriate mode (interpreter, JIT, etc.).
        """
        match mode:
            case ExecutionMode.Interpreter:
                # Default mode - no special setup needed
                pass
            case ExecutionMode.JIT:
                # Enable JIT compilation for this execution
                runtime_set_jit_enabled(true)
            case ExecutionMode.SMF_Cranelift:
                # Use Cranelift backend
                runtime_set_backend("cranelift")
            case ExecutionMode.SMF_LLVM:
                # Use LLVM backend
                runtime_set_backend("llvm")
            case _:
                # Unknown mode - use interpreter
                pass

    # Run a test function in all configured modes
    var fn run_test(test_name: text, test_fn: fn() -> void) -> ModeExecutionResult:
        val modes = self.config.resolve_modes()
        val strategy = self.config.resolve_failure_strategy()

        var exec_result = ModeExecutionResult.new(test_name)

        for mode in modes.to_list():
            # Skip unavailable modes
            if not is_mode_available(mode):
                val result = TestResult {
                    test_name: test_name,
                    mode: mode,
                    status: TestStatus.Skipped,
                    error: Some("Mode not implemented"),
                    duration_ms: 0,
                    config_source: "availability_check"
                }
                exec_result = exec_result.add_result(result)
                continue

            # Execute test in this mode
            val result = self.execute_in_mode(test_name, test_fn, mode)
            exec_result = exec_result.add_result(result)

            # Handle failure based on strategy
            if result.status == TestStatus.Failed:
                match strategy:
                    case FailureStrategy.FailAll =>
                        # Stop execution, mark remaining modes as skipped
                        exec_result = self.skip_remaining_modes(exec_result, modes, mode)
                        break
                    case FailureStrategy.SkipRemaining =>
                        # Continue with next mode
                        pass
                    case FailureStrategy.CollectAll =>
                        # Continue running all modes
                        pass

        self.results.push(exec_result)
        exec_result

    # Execute test in a specific mode
    fn execute_in_mode(test_name: text, test_fn: fn() -> void, mode: ExecutionMode) -> TestResult:
        val start_time = get_current_time_ms()

        # Try to execute the test
        var status = TestStatus.Passed
        var error = None

        # Execute test in specified mode
        # Mode switching is handled by setting execution context before running
        self.set_execution_mode(mode)

        match self.try_execute(test_fn):
            case Ok(_) =>
                status = TestStatus.Passed
            case Err(err) =>
                status = TestStatus.Failed
                error = Some(err)

        val duration = get_current_time_ms() - start_time

        TestResult {
            test_name: test_name,
            mode: mode,
            status: status,
            error: error,
            duration_ms: duration,
            config_source: self.config.get_effective_source()
        }

    # Try to execute a test function, catching errors
    fn try_execute(test_fn: fn() -> void) -> Result<void, text>:
        """Execute test function with error catching.

        Uses Result-based error handling (Simple does not have try/catch).
        """
        test_fn()
        return Ok(())

    # Skip remaining modes after a failure
    fn skip_remaining_modes(mut exec_result: ModeExecutionResult, modes: ModeSet, failed_mode: ExecutionMode) -> ModeExecutionResult:
        var found_failed = false

        for mode in modes.to_list():
            if mode == failed_mode:
                found_failed = true
                continue

            if found_failed:
                val result = TestResult {
                    test_name: exec_result.test_name,
                    mode: mode,
                    status: TestStatus.Skipped,
                    error: Some("Skipped due to failure in {mode_to_string(failed_mode)}"),
                    duration_ms: 0,
                    config_source: "failure_strategy"
                }
                exec_result = exec_result.add_result(result)

        exec_result

    # Get all test results
    fn get_results() -> List<ModeExecutionResult>:
        self.results

## Helper: run_in_modes
# Execute a block of code/tests in specific modes
# Usage: run_in_modes([ExecutionMode.JIT, ExecutionMode.SMF_Cranelift]):
#            it "test": ...
## Module-level mode configuration
var _current_modes: ModeSet = ModeSet.all()

export fn run_in_modes(modes: ModeSet, block: fn() -> void) -> void:
    # Save previous mode configuration
    val previous_modes = _current_modes

    # Set mode configuration for nested tests
    _current_modes = modes

    # Execute the block with the mode configuration
    block()

    # Restore previous mode configuration
    _current_modes = previous_modes

## Get current mode configuration
export fn get_current_modes() -> ModeSet:
    _current_modes

## Helper: get current time in milliseconds
# Get current Unix timestamp in milliseconds
fn get_current_time_ms() -> i32:
    """Get current Unix timestamp in milliseconds."""
    @extern("runtime", "rt_time_now_unix_micros")
    fn _rt_time_now_unix_micros() -> i64

    # Convert microseconds to milliseconds
    (_rt_time_now_unix_micros() / 1000) as i32

## Result: type alias for error handling
# Temporary definition until core Result type is available
enum Result<T, E>:
    Ok(T)
    Err(E)

## Exports
export TestResult
export TestStatus
export ModeExecutionResult
export ModeRunner
