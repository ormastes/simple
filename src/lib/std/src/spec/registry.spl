# BDD Registry - Core types and global state for spec framework
#
# This module provides the core data structures used by the BDD framework:
# - ExampleGroup: Hierarchical test organization (describe/context blocks)
# - Example: Individual test cases (it blocks)
# - Hook: Lifecycle hooks (before_each, after_each, etc.)
# - ContextDefinition: Reusable context definitions
# - Given: Setup blocks for contexts
# - SharedExampleDefinition: Shared example groups
#
# The registry maintains global state for registered groups, contexts, and
# shared examples, allowing the DSL functions to coordinate test execution.

# ============================================================================
# Core Types
# ============================================================================

# Hook - Lifecycle callback for test setup and teardown
# Note: Using Any type for blocks to work around parser limitations with function types in enums
enum Hook:
    BeforeEach(block: Any)   # Run before each example - fn() -> void
    AfterEach(block: Any)    # Run after each example - fn() -> void
    BeforeAll(block: Any)    # Run once before all examples in group - fn() -> void
    AfterAll(block: Any)     # Run once after all examples in group - fn() -> void

# Given - Setup block for context definitions
enum Given:
    Lazy(name: Any, block: Any)   # Lazy evaluated on first access - (Symbol, fn() -> Any)
    Eager(block: Any)              # Eagerly evaluated before each - fn() -> void

# Example - Individual test case
class Example:
    description: text
    block: fn()
    is_skipped: bool
    tags: List<text>           # Tags like "slow", "integration", "gui"
    timeout_seconds: Option<i32>  # Optional timeout in seconds

    fn new(description: text, block: fn()) -> Example:
        return Example(description, block, false, [], nil)

    me skip() -> Example:
        """Mark this example as skipped/pending."""
        self.is_skipped = true
        return self

    me slow() -> Example:
        """Mark this example as slow/long-running (120+ seconds)."""
        if not self.tags.contains("slow"):
            self.tags = self.tags.push("slow")
        return self

    me with_timeout(seconds: i32) -> Example:
        """Set a custom timeout for this example."""
        self.timeout_seconds = Some(seconds)
        return self

    me with_tag(tag: text) -> Example:
        """Add a tag to this example."""
        if not self.tags.contains(tag):
            self.tags = self.tags.push(tag)
        return self

    fn has_tag(tag: text) -> bool:
        """Check if this example has a specific tag."""
        return self.tags.contains(tag)

    fn is_pending() -> bool:
        """Check if this example is pending/skipped."""
        return self.is_skipped

    fn should_run(run_slow: bool) -> bool:
        """Check if this example should run based on configuration."""
        if self.is_skipped:
            return false
        if self.has_tag("slow") and not run_slow:
            return false
        return true

    fn run():
        """Execute the example block (unless skipped)."""
        if not self.is_skipped:
            self.block()

# ExampleGroup - Hierarchical container for examples (describe/context blocks)
class ExampleGroup:
    description: text
    parent: Option<ExampleGroup>
    children: List<ExampleGroup>
    test_examples: List<Example>
    hooks: List<Hook>

    fn new(description: text, parent: Option<ExampleGroup>) -> ExampleGroup:
        return ExampleGroup(description, parent, [], [], [])

    me add_child(child: ExampleGroup):
        """Add a nested example group (context)."""
        self.children = self.children.push(child)

    me add_example(example: Example):
        """Add a test example (it block)."""
        self.test_examples = self.test_examples.push(example)

    me add_hook(hook: Hook):
        """Add a lifecycle hook."""
        self.hooks = self.hooks.push(hook)

    fn get_before_each_hooks() -> List<Any>:
        """Extract all before_each hook blocks."""
        var blocks: List<Any> = []
        for hook in self.hooks:
            match hook:
                case Hook.BeforeEach(block):
                    blocks = blocks.push(block)
                case _:
                    ()
        return blocks

    fn get_after_each_hooks() -> List<Any>:
        """Extract all after_each hook blocks."""
        var blocks: List<Any> = []
        for hook in self.hooks:
            match hook:
                case Hook.AfterEach(block):
                    blocks = blocks.push(block)
                case _:
                    ()
        return blocks

    fn get_before_all_hooks() -> List<Any>:
        """Extract all before_all hook blocks."""
        var blocks: List<Any> = []
        for hook in self.hooks:
            match hook:
                case Hook.BeforeAll(block):
                    blocks = blocks.push(block)
                case _:
                    ()
        return blocks

    fn get_after_all_hooks() -> List<Any>:
        """Extract all after_all hook blocks."""
        var blocks: List<Any> = []
        for hook in self.hooks:
            match hook:
                case Hook.AfterAll(block):
                    blocks = blocks.push(block)
                case _:
                    ()
        return blocks

    fn full_description() -> text:
        """Get the full hierarchical description path."""
        match self.parent:
            case Some(parent):
                return parent.full_description() + " " + self.description
            case nil:
                return self.description

    fn example_count() -> i32:
        """Count total examples in this group and children."""
        var count = self.test_examples.len()
        for child in self.children:
            count = count + child.example_count()
        return count

# ContextDefinition - Reusable context with setup blocks
class ContextDefinition:
    name: text
    givens: List<Given>

    fn new(name: text) -> ContextDefinition:
        return ContextDefinition(name, [])

    me add_given(given: Given):
        """Add a setup block to this context."""
        self.givens = self.givens.push(given)

# SharedExampleDefinition - Reusable example group
# Note: Using Any type for block to work around parser limitations with function types
class SharedExampleDefinition:
    name: text
    block: Any  # fn() -> void
    description: Option<text>

    fn new(name: text, block: Any) -> SharedExampleDefinition:
        return SharedExampleDefinition(name, block, nil)

    me with_description(desc: text) -> SharedExampleDefinition:
        """Add a description to this shared example group."""
        self.description = Some(desc)
        return self

# ============================================================================
# Global Registry State
# ============================================================================

# Top-level example groups (from describe blocks)
var registered_groups = []

# Context definitions (from context_def blocks)
var context_registry = {}

# Shared example definitions (from shared_examples blocks)
var shared_examples_registry = {}

# ============================================================================
# Registry Functions
# ============================================================================

fn register_group(group: ExampleGroup):
    """Register a top-level example group."""
    registered_groups = registered_groups.push(group)

fn get_all_groups() -> List<ExampleGroup>:
    """Get all registered top-level groups."""
    return registered_groups

fn clear_groups():
    """Clear all registered groups (for testing)."""
    registered_groups = []

fn register_context(name: text, ctx_def: ContextDefinition):
    """Register a reusable context definition."""
    context_registry.insert(name, ctx_def)

fn get_context(name: text) -> Option<ContextDefinition>:
    """Get a registered context definition by name."""
    return context_registry.get(name)

fn clear_contexts():
    """Clear all registered contexts (for testing)."""
    context_registry = {}

fn register_shared_examples(name: text, shared_def: SharedExampleDefinition):
    """Register a shared example group."""
    shared_examples_registry.insert(name, shared_def)

fn get_shared_examples(name: text) -> Option<SharedExampleDefinition>:
    """Get a registered shared example group by name."""
    return shared_examples_registry.get(name)

fn clear_shared_examples():
    """Clear all registered shared examples (for testing)."""
    shared_examples_registry = {}

fn reset_registry():
    """Clear all registry state (groups, contexts, shared examples)."""
    clear_groups()
    clear_contexts()
    clear_shared_examples()

# ============================================================================
# Export All Public Types and Functions
# ============================================================================

export Hook, Given, Example, ExampleGroup, ContextDefinition, SharedExampleDefinition
export register_group, get_all_groups, clear_groups
export register_context, get_context, clear_contexts
export register_shared_examples, get_shared_examples, clear_shared_examples
export reset_registry
