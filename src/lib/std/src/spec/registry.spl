# BDD Registry - Core types and global state for spec framework
#
# This module provides the core data structures used by the BDD framework:
# - ExampleGroup: Hierarchical test organization (describe/context blocks)
# - Example: Individual test cases (it blocks)
# - Hook: Lifecycle hooks (before_each, after_each, etc.)
# - ContextDefinition: Reusable context definitions
# - Given: Setup blocks for contexts
# - SharedExampleDefinition: Shared example groups
#
# The registry maintains global state for registered groups, contexts, and
# shared examples, allowing the DSL functions to coordinate test execution.

import concurrency.resource_limits.{ResourceLimits}

# ============================================================================
# Core Types
# ============================================================================

# Hook - Lifecycle callback for test setup and teardown
# Note: Using Any type for blocks to work around parser limitations with function types in enums
enum Hook:
    BeforeEach(block: Any)   # Run before each example - fn() -> void
    AfterEach(block: Any)    # Run after each example - fn() -> void
    BeforeAll(block: Any)    # Run once before all examples in group - fn() -> void
    AfterAll(block: Any)     # Run once after all examples in group - fn() -> void

# Given - Setup block for context definitions
enum Given:
    Lazy(name: Any, block: Any)   # Lazy evaluated on first access - (Symbol, fn() -> Any)
    Eager(block: Any)              # Eagerly evaluated before each - fn() -> void

# MockMode - Controls mock availability for tests
enum MockMode:
    All         # Unit tests - allow all mocks (default)
    HalOnly     # Integration tests - only HAL mocks allowed
    Disabled    # System tests - no mocks allowed
    Custom      # Custom pattern-based restriction

# Example - Individual test case
class Example:
    description: text
    block: fn()
    is_skipped: bool
    tags: List<text>           # Tags like "slow", "integration", "gui"
    timeout_seconds: Option<i32>  # Optional timeout in seconds
    resource_limits: Option<ResourceLimits>  # Resource limits for isolated execution
    mock_mode: MockMode        # Mock policy for this example

    fn new(description: text, block: fn()) -> Example:
        return Example(description, block, false, [], nil, nil, MockMode.All)

    me skip() -> Example:
        """Mark this example as skipped/pending."""
        self.is_skipped = true
        return self

    me slow() -> Example:
        """Mark this example as slow/long-running (120+ seconds)."""
        if not self.tags.contains("slow"):
            self.tags = self.tags.push("slow")
        return self

    me ignore() -> Example:
        """Mark this example as ignored (never runs)."""
        if not self.tags.contains("ignored"):
            self.tags = self.tags.push("ignored")
        return self

    me with_timeout(seconds: i32) -> Example:
        """Set a custom timeout for this example."""
        self.timeout_seconds = Some(seconds)
        return self

    me with_tag(tag: text) -> Example:
        """Add a tag to this example."""
        if not self.tags.contains(tag):
            self.tags = self.tags.push(tag)
        return self

    fn has_tag(tag: text) -> bool:
        """Check if this example has a specific tag."""
        return self.tags.contains(tag)

    me with_resource_limits(limits: ResourceLimits) -> Example:
        """Set resource limits for this example."""
        self.resource_limits = Some(limits)
        return self

    me with_mock_mode(mode: MockMode) -> Example:
        """Set mock policy mode for this example."""
        self.mock_mode = mode
        return self

    me unit_test() -> Example:
        """Mark as unit test (allow all mocks)."""
        self.mock_mode = MockMode.All
        return self

    me integration_test() -> Example:
        """Mark as integration test (HAL-only mocks)."""
        self.mock_mode = MockMode.HalOnly
        return self

    me system_test() -> Example:
        """Mark as system test (no mocks allowed)."""
        self.mock_mode = MockMode.Disabled
        return self

    fn has_resource_limits() -> bool:
        """Check if this example has resource limits set."""
        return self.resource_limits.is_some()

    fn get_resource_limits() -> Option<ResourceLimits>:
        """Get the resource limits for this example."""
        return self.resource_limits

    fn is_pending() -> bool:
        """Check if this example is pending/skipped."""
        return self.is_skipped

    fn is_ignored() -> bool:
        """Check if this example is ignored."""
        return self.has_tag("ignored")

    fn should_run(run_slow: bool) -> bool:
        """Check if this example should run based on configuration."""
        if self.is_skipped:
            return false
        if self.has_tag("ignored"):
            return false
        if self.has_tag("slow") and not run_slow:
            return false
        return true

    fn run():
        """Execute the example block (unless skipped)."""
        if not self.is_skipped:
            self.block()

# ExampleGroup - Hierarchical container for examples (describe/context blocks)
class ExampleGroup:
    description: text
    parent: Option<ExampleGroup>
    children: List<ExampleGroup>
    test_examples: List<Example>
    hooks: List<Hook>
    mock_mode: Option<MockMode>  # Optional mock policy for entire group

    fn new(description: text, parent: Option<ExampleGroup>) -> ExampleGroup:
        return ExampleGroup(description, parent, [], [], [], nil)

    me add_child(child: ExampleGroup):
        """Add a nested example group (context)."""
        self.children = self.children.push(child)

    me add_example(example: Example):
        """Add a test example (it block)."""
        self.test_examples = self.test_examples.push(example)

    me add_hook(hook: Hook):
        """Add a lifecycle hook."""
        self.hooks = self.hooks.push(hook)

    me with_mock_mode(mode: MockMode):
        """Set mock policy mode for all examples in this group."""
        self.mock_mode = Some(mode)

    fn get_effective_mock_mode() -> MockMode:
        """Get the effective mock mode, inheriting from parent if not set."""
        if self.mock_mode.?:
            return self.mock_mode.unwrap()
        if self.parent.?:
            return self.parent.unwrap().get_effective_mock_mode()
        return MockMode.All  # Default to allowing all mocks

    fn get_before_each_hooks() -> List<Any>:
        """Extract all before_each hook blocks."""
        var blocks: List<Any> = []
        for hook in self.hooks:
            match hook:
                case Hook.BeforeEach(block):
                    blocks = blocks.push(block)
                case _:
                    ()
        return blocks

    fn get_after_each_hooks() -> List<Any>:
        """Extract all after_each hook blocks."""
        var blocks: List<Any> = []
        for hook in self.hooks:
            match hook:
                case Hook.AfterEach(block):
                    blocks = blocks.push(block)
                case _:
                    ()
        return blocks

    fn get_before_all_hooks() -> List<Any>:
        """Extract all before_all hook blocks."""
        var blocks: List<Any> = []
        for hook in self.hooks:
            match hook:
                case Hook.BeforeAll(block):
                    blocks = blocks.push(block)
                case _:
                    ()
        return blocks

    fn get_after_all_hooks() -> List<Any>:
        """Extract all after_all hook blocks."""
        var blocks: List<Any> = []
        for hook in self.hooks:
            match hook:
                case Hook.AfterAll(block):
                    blocks = blocks.push(block)
                case _:
                    ()
        return blocks

    fn full_description() -> text:
        """Get the full hierarchical description path."""
        match self.parent:
            case Some(parent):
                return parent.full_description() + " " + self.description
            case nil:
                return self.description

    fn example_count() -> i32:
        """Count total examples in this group and children."""
        var count = self.test_examples.len()
        for child in self.children:
            count = count + child.example_count()
        return count

# ContextDefinition - Reusable context with setup blocks
class ContextDefinition:
    name: text
    givens: List<Given>

    fn new(name: text) -> ContextDefinition:
        return ContextDefinition(name, [])

    me add_given(given: Given):
        """Add a setup block to this context."""
        self.givens = self.givens.push(given)

# SharedExampleDefinition - Reusable example group
# Note: Using Any type for block to work around parser limitations with function types
class SharedExampleDefinition:
    name: text
    block: Any  # fn() -> void
    description: Option<text>

    fn new(name: text, block: Any) -> SharedExampleDefinition:
        return SharedExampleDefinition(name, block, nil)

    me with_description(desc: text) -> SharedExampleDefinition:
        """Add a description to this shared example group."""
        self.description = Some(desc)
        return self

# ============================================================================
# Global Registry State (via FFI - shared across all module imports)
# ============================================================================
# Note: Registry state is stored in Rust thread-local storage to ensure
# all modules that import spec.registry share the same state.

# ============================================================================
# Registry Functions (FFI wrappers)
# ============================================================================

fn register_group(group: ExampleGroup):
    """Register a top-level example group."""
    print "DEBUG: register_group called with {group.description}"
    __bdd_register_group(group)
    print "DEBUG: after FFI call, groups = {__bdd_get_all_groups().len()}"

fn get_all_groups() -> List<ExampleGroup>:
    """Get all registered top-level groups."""
    return __bdd_get_all_groups()

fn clear_groups():
    """Clear all registered groups (for testing)."""
    __bdd_clear_groups()

fn register_context(name: text, ctx_def: ContextDefinition):
    """Register a reusable context definition."""
    __bdd_register_context(name, ctx_def)

fn get_context(name: text) -> Option<ContextDefinition>:
    """Get a registered context definition by name."""
    return __bdd_get_context(name)

fn clear_contexts():
    """Clear all registered contexts (for testing)."""
    __bdd_clear_contexts()

fn register_shared_examples(name: text, shared_def: SharedExampleDefinition):
    """Register a shared example group."""
    __bdd_register_shared_examples(name, shared_def)

fn get_shared_examples(name: text) -> Option<SharedExampleDefinition>:
    """Get a registered shared example group by name."""
    return __bdd_get_shared_examples(name)

fn clear_shared_examples():
    """Clear all registered shared examples (for testing)."""
    __bdd_clear_shared_examples()

fn reset_registry():
    """Clear all registry state (groups, contexts, shared examples)."""
    __bdd_reset_registry()

# ============================================================================
# Export All Public Types and Functions
# ============================================================================

export Hook, Given, Example, ExampleGroup, ContextDefinition, SharedExampleDefinition
export register_group, get_all_groups, clear_groups
export register_context, get_context, clear_contexts
export register_shared_examples, get_shared_examples, clear_shared_examples
export reset_registry
