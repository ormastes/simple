# Size Unit Types
# Byte counts and data size units with conversions

# Base unit: ByteCount
unit ByteCount: u64 as bytes

# Derived units (binary - powers of 1024)
unit KibiBytes: u64 as kib     # 1024 bytes
unit MebiBytes: u64 as mib     # 1024 KiB
unit GibiBytes: u64 as gib     # 1024 MiB
unit TebiBytes: u64 as tib     # 1024 GiB

# Derived units (decimal - powers of 1000)
unit KiloBytes: u64 as kb      # 1000 bytes
unit MegaBytes: u64 as mb      # 1000 KB
unit GigaBytes: u64 as gb      # 1000 MB
unit TeraBytes: u64 as tb      # 1000 GB

# Unit family for automatic conversion
unit family ByteSize: u64 as bytes
    ByteCount = 1
    KibiBytes = 1024
    MebiBytes = 1_048_576
    GibiBytes = 1_073_741_824
    TebiBytes = 1_099_511_627_776

# Constants
const BYTES_PER_KIB: u64 = 1024
const BYTES_PER_MIB: u64 = 1_048_576
const BYTES_PER_GIB: u64 = 1_073_741_824
const BYTES_PER_TIB: u64 = 1_099_511_627_776

const BYTES_PER_KB: u64 = 1000
const BYTES_PER_MB: u64 = 1_000_000
const BYTES_PER_GB: u64 = 1_000_000_000
const BYTES_PER_TB: u64 = 1_000_000_000_000

# ByteCount implementation
impl ByteCount:
    fn from_u64(n: u64) -> ByteCount:
        return n_bytes

    fn to_u64() -> u64:
        return self as u64

    fn zero() -> ByteCount:
        return 0_bytes

    # Binary conversions
    fn to_kib() -> KibiBytes:
        return ((self as u64) / BYTES_PER_KIB)_kib

    fn to_mib() -> MebiBytes:
        return ((self as u64) / BYTES_PER_MIB)_mib

    fn to_gib() -> GibiBytes:
        return ((self as u64) / BYTES_PER_GIB)_gib

    fn to_tib() -> TebiBytes:
        return ((self as u64) / BYTES_PER_TIB)_tib

    # Decimal conversions
    fn to_kb() -> KiloBytes:
        return ((self as u64) / BYTES_PER_KB)_kb

    fn to_mb() -> MegaBytes:
        return ((self as u64) / BYTES_PER_MB)_mb

    fn to_gb() -> GigaBytes:
        return ((self as u64) / BYTES_PER_GB)_gb

    fn to_tb() -> TeraBytes:
        return ((self as u64) / BYTES_PER_TB)_tb

    # Formatting
    fn to_human_readable() -> str:
        val bytes = self as u64
        if bytes >= BYTES_PER_TIB:
            return "{bytes / BYTES_PER_TIB} TiB"
        if bytes >= BYTES_PER_GIB:
            return "{bytes / BYTES_PER_GIB} GiB"
        if bytes >= BYTES_PER_MIB:
            return "{bytes / BYTES_PER_MIB} MiB"
        if bytes >= BYTES_PER_KIB:
            return "{bytes / BYTES_PER_KIB} KiB"
        return "{bytes} bytes"

    # Arithmetic
    fn add(other: ByteCount) -> ByteCount:
        return ((self as u64) + (other as u64))_bytes

    fn sub(other: ByteCount) -> ByteCount:
        val a = self as u64
        val b = other as u64
        if b > a:
            return 0_bytes
        return (a - b)_bytes

    fn mul(n: u64) -> ByteCount:
        return ((self as u64) * n)_bytes

    fn div(n: u64) -> ByteCount:
        if n == 0:
            return 0_bytes
        return ((self as u64) / n)_bytes

    # Comparison
    fn is_zero() -> bool:
        return (self as u64) == 0

    fn min(other: ByteCount) -> ByteCount:
        if (self as u64) < (other as u64):
            return self
        return other

    fn max(other: ByteCount) -> ByteCount:
        if (self as u64) > (other as u64):
            return self
        return other

# KibiBytes implementation
impl KibiBytes:
    fn from_u64(n: u64) -> KibiBytes:
        return n_kib

    fn to_bytes() -> ByteCount:
        return ((self as u64) * BYTES_PER_KIB)_bytes

    fn to_mib() -> MebiBytes:
        return ((self as u64) / 1024)_mib

# MebiBytes implementation
impl MebiBytes:
    fn from_u64(n: u64) -> MebiBytes:
        return n_mib

    fn to_bytes() -> ByteCount:
        return ((self as u64) * BYTES_PER_MIB)_bytes

    fn to_kib() -> KibiBytes:
        return ((self as u64) * 1024)_kib

    fn to_gib() -> GibiBytes:
        return ((self as u64) / 1024)_gib

# GibiBytes implementation
impl GibiBytes:
    fn from_u64(n: u64) -> GibiBytes:
        return n_gib

    fn to_bytes() -> ByteCount:
        return ((self as u64) * BYTES_PER_GIB)_bytes

    fn to_mib() -> MebiBytes:
        return ((self as u64) * 1024)_mib

    fn to_tib() -> TebiBytes:
        return ((self as u64) / 1024)_tib

# TebiBytes implementation
impl TebiBytes:
    fn from_u64(n: u64) -> TebiBytes:
        return n_tib

    fn to_bytes() -> ByteCount:
        return ((self as u64) * BYTES_PER_TIB)_bytes

    fn to_gib() -> GibiBytes:
        return ((self as u64) * 1024)_gib

# KiloBytes implementation (decimal)
impl KiloBytes:
    fn from_u64(n: u64) -> KiloBytes:
        return n_kb

    fn to_bytes() -> ByteCount:
        return ((self as u64) * BYTES_PER_KB)_bytes

# MegaBytes implementation (decimal)
impl MegaBytes:
    fn from_u64(n: u64) -> MegaBytes:
        return n_mb

    fn to_bytes() -> ByteCount:
        return ((self as u64) * BYTES_PER_MB)_bytes

# GigaBytes implementation (decimal)
impl GigaBytes:
    fn from_u64(n: u64) -> GigaBytes:
        return n_gb

    fn to_bytes() -> ByteCount:
        return ((self as u64) * BYTES_PER_GB)_bytes

# TeraBytes implementation (decimal)
impl TeraBytes:
    fn from_u64(n: u64) -> TeraBytes:
        return n_tb

    fn to_bytes() -> ByteCount:
        return ((self as u64) * BYTES_PER_TB)_bytes

# Utility function for parsing human-readable sizes
fn parse_size(s: str) -> Result<ByteCount, SizeError>:
    val s = s.trim().upper()

    # Try to split number and unit
    var num_end = 0
    for i in 0..s.len():
        val c = s.char_at(i)
        if c.is_digit() or c == '.':
            num_end = i + 1
        else:
            break

    if num_end == 0:
        return Err(SizeError::InvalidFormat)

    val num_str = s.slice(0, num_end)
    val unit = s.slice(num_end, s.len()).trim()

    val num = match num_str.parse_u64():
        case Ok(n): n
        case Err(_): return Err(SizeError::InvalidNumber)

    match unit:
        case "" | "B" | "BYTES":
            return Ok(num_bytes)
        case "KB":
            return Ok((num * BYTES_PER_KB)_bytes)
        case "MB":
            return Ok((num * BYTES_PER_MB)_bytes)
        case "GB":
            return Ok((num * BYTES_PER_GB)_bytes)
        case "TB":
            return Ok((num * BYTES_PER_TB)_bytes)
        case "KIB" | "K":
            return Ok((num * BYTES_PER_KIB)_bytes)
        case "MIB" | "M":
            return Ok((num * BYTES_PER_MIB)_bytes)
        case "GIB" | "G":
            return Ok((num * BYTES_PER_GIB)_bytes)
        case "TIB" | "T":
            return Ok((num * BYTES_PER_TIB)_bytes)
        case _:
            return Err(SizeError::InvalidUnit)

enum SizeError:
    InvalidFormat
    InvalidNumber
    InvalidUnit
    Overflow

impl SizeError:
    # =========================================================================
    # Helper Methods
    # =========================================================================

    fn to_string() -> text:
        """Convert error to string."""
        match self:
            case InvalidFormat: return "InvalidFormat"
            case InvalidNumber: return "InvalidNumber"
            case InvalidUnit: return "InvalidUnit"
            case Overflow: return "Overflow"

    fn description() -> text:
        """Get detailed error description."""
        match self:
            case InvalidFormat: return "Invalid size format"
            case InvalidNumber: return "Invalid number in size string"
            case InvalidUnit: return "Invalid or unknown size unit"
            case Overflow: return "Size value overflow"

    fn is_invalid_format() -> bool:
        """Check if this is InvalidFormat error."""
        match self:
            case InvalidFormat: true
            case _: false

    fn is_invalid_number() -> bool:
        """Check if this is InvalidNumber error."""
        match self:
            case InvalidNumber: true
            case _: false

    fn is_invalid_unit() -> bool:
        """Check if this is InvalidUnit error."""
        match self:
            case InvalidUnit: true
            case _: false

    fn is_overflow() -> bool:
        """Check if this is Overflow error."""
        match self:
            case Overflow: true
            case _: false

    fn is_parse_error() -> bool:
        """Check if this is a parsing error (format, number, unit).

        Returns:
            true for InvalidFormat, InvalidNumber, or InvalidUnit

        Example:
            SizeError::InvalidFormat.is_parse_error()  # → true
            SizeError::Overflow.is_parse_error()  # → false
        """
        match self:
            case InvalidFormat: true
            case InvalidNumber: true
            case InvalidUnit: true
            case _: false

    fn is_recoverable() -> bool:
        """Check if error might be recoverable with different input.

        Returns:
            true for parsing errors (user can retry with valid input)
            false for Overflow (value exceeds limits)

        Example:
            SizeError::InvalidFormat.is_recoverable()  # → true
            SizeError::Overflow.is_recoverable()  # → false
        """
        return self.is_parse_error()

    fn name() -> text:
        """Get error name without details.

        Returns:
            Short error name

        Example:
            SizeError::InvalidUnit.name()  # → "invalid_unit"
        """
        match self:
            case InvalidFormat: return "invalid_format"
            case InvalidNumber: return "invalid_number"
            case InvalidUnit: return "invalid_unit"
            case Overflow: return "overflow"

    fn summary() -> text:
        """Get comprehensive error summary with type and details.

        Returns:
            Human-readable summary

        Example:
            SizeError::InvalidFormat.summary()
            # → "SizeError: invalid_format (parsing error, recoverable)"
        """
        val name = self.name()
        val desc = self.description()
        val kind = if self.is_parse_error():
            "parsing error"
        else:
            "value error"
        val recoverable = if self.is_recoverable():
            "recoverable"
        else:
            "fatal"
        return "SizeError: {name} ({kind}, {recoverable})"
