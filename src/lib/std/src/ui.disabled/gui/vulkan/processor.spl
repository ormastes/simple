# Async Element Processor
#
# Convert element tree to GPU draw list using async operations.
# This is the async version of ElementProcessor from vulkan.spl.

use core.*
use concurrency.*
use ui.element.*
use ui.widget.Color

use types.{DrawList, VertexBuilder, LayoutResult, DirtyRegion, Vertex, DrawCall, PipelineType, Rect}

export AsyncElementProcessor

# ============================================================================
# Async Element Processor
# ============================================================================

struct AsyncElementProcessor:
    vertex_builder: VertexBuilder
    draw_list: DrawList

impl AsyncElementProcessor:
    static fn new() -> AsyncElementProcessor:
        return AsyncElementProcessor {vertex_builder: VertexBuilder.new(), draw_list: DrawList.new()}

    async fn process_tree_async(self, tree: &ElementTree, layout: &LayoutResult)
        -> Future<DrawList>:
        # Clear previous frame
        self.draw_list.clear()
        self.vertex_builder.clear()

        # Process tree (can be parallelized by subtree)
        await self.process_element_async(tree.root(), layout)

        # Finalize
        self.draw_list.vertices = self.vertex_builder.vertices
        self.draw_list.indices = self.vertex_builder.indices

        return Future.ready(self.draw_list)

    async fn process_element_async(self, elem: &Element, layout: &LayoutResult)
        -> Future<()>:
        # Get layout bounds for this element
        val bounds = layout.get_bounds(elem.id)

        # Generate geometry based on element type
        match elem.kind:
            case ElementKind.Box:
                self.emit_rounded_rect(bounds, 4.0, elem)
            case ElementKind.Button:
                self.emit_button(bounds, elem)
            case ElementKind.Text:
                self.emit_text(bounds, elem)
            case _:
                # Default: just background if specified
                if self.has_background(elem):
                    self.emit_rect(bounds, self.get_bg_color(elem))

        # Process children in parallel using join_all
        var child_futures: Array<Future<()>> = []
        for child in &elem.children:
            child_futures.push(self.process_element_async(child, layout))

        if child_futures.len() > 0:
            await Future.all(child_futures)

        return Future.ready(())

    async fn process_dirty_regions_async(self, layouts: &Array<LayoutResult>)
        -> Future<DrawList>:
        # Clear previous data
        self.draw_list.clear()
        self.vertex_builder.clear()

        # Process each dirty layout
        for layout in layouts:
            # Would iterate elements within dirty bounds
            pass

        # Finalize
        self.draw_list.vertices = self.vertex_builder.vertices
        self.draw_list.indices = self.vertex_builder.indices

        return Future.ready(self.draw_list)

    # =========================================================================
    # Style Helpers
    # =========================================================================

    fn has_background(elem: &Element) -> bool:
        return elem.styles.contains_key("background-color")

    fn get_bg_color(elem: &Element) -> Color:
        if val Some(color_str) = elem.styles.get("background-color"):
            if color_str.starts_with("#"):
                match Color.hex(color_str):
                    case Ok(c): return c
                    case Err(_): pass
            match color_str.lower().as_str():
                case "black": return Color.rgb(0, 0, 0)
                case "white": return Color.rgb(255, 255, 255)
                case "red": return Color.rgb(255, 0, 0)
                case "green": return Color.rgb(0, 255, 0)
                case "blue": return Color.rgb(0, 0, 255)
                case "gray" | "grey": return Color.rgb(128, 128, 128)
                case _: pass
        return Color.rgb(255, 255, 255)

    fn get_text_color(elem: &Element) -> Color:
        if val Some(color_str) = elem.styles.get("color"):
            if color_str.starts_with("#"):
                match Color.hex(color_str):
                    case Ok(c): return c
                    case Err(_): pass
            match color_str.lower().as_str():
                case "black": return Color.rgb(0, 0, 0)
                case "white": return Color.rgb(255, 255, 255)
                case "red": return Color.rgb(255, 0, 0)
                case "green": return Color.rgb(0, 255, 0)
                case "blue": return Color.rgb(0, 0, 255)
                case "gray" | "grey": return Color.rgb(128, 128, 128)
                case _: pass
        return Color.rgb(0, 0, 0)

    # =========================================================================
    # Geometry Generation
    # =========================================================================

    fn emit_rect(bounds: Rect, color: Color):
        val base_vertex = self.vertex_builder.vertices.len() as u32
        val base_index = self.vertex_builder.indices.len() as u32
        val color_packed = color.rgba

        val x0 = bounds.x
        val y0 = bounds.y
        val x1 = bounds.x + bounds.width
        val y1 = bounds.y + bounds.height

        # Add 4 vertices
        self.vertex_builder.vertices.push(Vertex { position: (x0, y0), uv: (0.0, 0.0), color: color_packed })
        self.vertex_builder.vertices.push(Vertex { position: (x1, y0), uv: (1.0, 0.0), color: color_packed })
        self.vertex_builder.vertices.push(Vertex { position: (x1, y1), uv: (1.0, 1.0), color: color_packed })
        self.vertex_builder.vertices.push(Vertex { position: (x0, y1), uv: (0.0, 1.0), color: color_packed })

        # Add 6 indices (2 triangles)
        self.vertex_builder.indices.push(base_vertex + 0)
        self.vertex_builder.indices.push(base_vertex + 1)
        self.vertex_builder.indices.push(base_vertex + 2)
        self.vertex_builder.indices.push(base_vertex + 2)
        self.vertex_builder.indices.push(base_vertex + 3)
        self.vertex_builder.indices.push(base_vertex + 0)

        self.draw_list.draw_calls.push(DrawCall {
            pipeline_type: PipelineType.SolidColor,
            vertex_offset: base_vertex,
            vertex_count: 4,
            index_offset: base_index,
            index_count: 6,
            texture_id: None,
            scissor: None
        })

    fn emit_rounded_rect(bounds: Rect, radius: f32, elem: &Element):
        val base_vertex = self.vertex_builder.vertices.len() as u32
        val base_index = self.vertex_builder.indices.len() as u32
        val color = self.get_bg_color(elem)
        val color_packed = color.rgba

        val x0 = bounds.x
        val y0 = bounds.y
        val x1 = bounds.x + bounds.width
        val y1 = bounds.y + bounds.height

        self.vertex_builder.vertices.push(Vertex { position: (x0, y0), uv: (0.0, 0.0), color: color_packed })
        self.vertex_builder.vertices.push(Vertex { position: (x1, y0), uv: (1.0, 0.0), color: color_packed })
        self.vertex_builder.vertices.push(Vertex { position: (x1, y1), uv: (1.0, 1.0), color: color_packed })
        self.vertex_builder.vertices.push(Vertex { position: (x0, y1), uv: (0.0, 1.0), color: color_packed })

        self.vertex_builder.indices.push(base_vertex + 0)
        self.vertex_builder.indices.push(base_vertex + 1)
        self.vertex_builder.indices.push(base_vertex + 2)
        self.vertex_builder.indices.push(base_vertex + 2)
        self.vertex_builder.indices.push(base_vertex + 3)
        self.vertex_builder.indices.push(base_vertex + 0)

        self.draw_list.draw_calls.push(DrawCall {
            pipeline_type: PipelineType.RoundedRect,
            vertex_offset: base_vertex,
            vertex_count: 4,
            index_offset: base_index,
            index_count: 6,
            texture_id: None,
            scissor: Some(bounds)
        })

    fn emit_text(bounds: Rect, elem: &Element):
        val text_content = match &elem.text:
            case Some(t): t
            case None: return

        if text_content.is_empty():
            return

        val text_color = self.get_text_color(elem)
        val color_packed = text_color.rgba
        val glyph_width: f32 = 8.0
        val glyph_height: f32 = 16.0
        val atlas_cols: f32 = 16.0
        val atlas_rows: f32 = 16.0
        val uv_width = 1.0 / atlas_cols
        val uv_height = 1.0 / atlas_rows

        var x = bounds.x
        var y = bounds.y
        val base_vertex = self.vertex_builder.vertices.len() as u32
        val base_index = self.vertex_builder.indices.len() as u32
        var vertex_count: u32 = 0
        var index_count: u32 = 0

        for ch in text_content.chars():
            if x + glyph_width > bounds.x + bounds.width:
                x = bounds.x
                y = y + glyph_height
                if y + glyph_height > bounds.y + bounds.height:
                    break

            if ch == '\n':
                x = bounds.x
                y = y + glyph_height
                continue

            val char_code = ch as u32
            val atlas_col = (char_code % 16) as f32
            val atlas_row = (char_code / 16) as f32
            val u0 = atlas_col * uv_width
            val v0 = atlas_row * uv_height
            val u1 = u0 + uv_width
            val v1 = v0 + uv_height
            val quad_base = base_vertex + vertex_count

            self.vertex_builder.vertices.push(Vertex { position: (x, y), uv: (u0, v0), color: color_packed })
            self.vertex_builder.vertices.push(Vertex { position: (x + glyph_width, y), uv: (u1, v0), color: color_packed })
            self.vertex_builder.vertices.push(Vertex { position: (x + glyph_width, y + glyph_height), uv: (u1, v1), color: color_packed })
            self.vertex_builder.vertices.push(Vertex { position: (x, y + glyph_height), uv: (u0, v1), color: color_packed })

            self.vertex_builder.indices.push(quad_base + 0)
            self.vertex_builder.indices.push(quad_base + 1)
            self.vertex_builder.indices.push(quad_base + 2)
            self.vertex_builder.indices.push(quad_base + 2)
            self.vertex_builder.indices.push(quad_base + 3)
            self.vertex_builder.indices.push(quad_base + 0)

            vertex_count = vertex_count + 4
            index_count = index_count + 6
            x = x + glyph_width

        if vertex_count > 0:
            self.draw_list.draw_calls.push(DrawCall {
                pipeline_type: PipelineType.Text,
                vertex_offset: base_vertex,
                vertex_count: vertex_count,
                index_offset: base_index,
                index_count: index_count,
                texture_id: None,
                scissor: None
            })

    fn emit_button(bounds: Rect, elem: &Element):
        self.emit_rounded_rect(bounds, 4.0, elem)

        if val Some(text_content) = &elem.text:
            val glyph_width: f32 = 8.0
            val glyph_height: f32 = 16.0
            val text_width = text_content.len() as f32 * glyph_width
            val text_height = glyph_height
            val text_x = bounds.x + (bounds.width - text_width) / 2.0
            val text_y = bounds.y + (bounds.height - text_height) / 2.0
            val text_bounds = Rect { x: text_x, y: text_y, width: text_width, height: text_height }
            self.emit_text(text_bounds, elem)
