# Widget - Core Widget Trait and Types
#
# Defines the base Widget trait that all UI components implement.
# This enables the builder pattern for composable, type-safe UI construction.
#
# Based on: doc/research/ui_framework_unified.md

use core.*
use ui.element.*
use units.ui.PixelDimension

# Build context for widget tree construction
pub struct BuildContext:
    # ID allocator for elements
    next_id: u64
    # Parent element (for relative positioning)
    parent: Option<NodeId>
    # Theme reference
    theme_id: u64

impl BuildContext:
    # Create a new build context
    pub fn new() -> BuildContext:
        return BuildContext {next_id: 0, parent: None, theme_id: 0}

    # Allocate a new NodeId
    pub fn alloc_id(mut self) -> NodeId:
        val id = NodeId.new(self.next_id)
        self.next_id = self.next_id + 1
        return id

    # Create a child context with a parent element
    pub fn with_parent(self, parent_id: NodeId) -> BuildContext:
        return BuildContext {
            next_id: self.next_id,
            parent: Some(parent_id),
            theme_id: self.theme_id
        }

# Widget node that contains the built element tree
pub struct WidgetNode:
    # The root element of this widget
    root: Element
    # Any child widget nodes
    children: Array<WidgetNode>

impl WidgetNode:
    # Create a new widget node
    pub fn new(root: Element) -> WidgetNode:
        return WidgetNode {
            root: root,
            children: []
        }

    # Add a child widget node
    pub fn add_child(mut self, child: WidgetNode):
        self.children.push(child)

    # Get the root element
    pub fn element(self) -> Element:
        return self.root

    # Convert to element tree (flattens widget nodes)
    pub fn to_element(self) -> Element:
        var elem = self.root.clone()
        for child in self.children:
            elem = elem.with_child(child.to_element())
        return elem

# Core Widget trait - all widgets implement this
pub trait Widget:
    # Build this widget into an element tree
    fn build(ctx: &mut BuildContext) -> WidgetNode

# Alignment enums for layout
pub enum Align:
    Start
    Center
    End
    Stretch

impl Align:
    pub fn is_start(self) -> bool:
        """Check if this is Start alignment.
        Returns: true for Start
        Example: Align.Start.is_start()  # → true
        """
        match self:
            case Align.Start: true
            case _: false

    pub fn is_center(self) -> bool:
        """Check if this is Center alignment.
        Returns: true for Center
        Example: Align.Center.is_center()  # → true
        """
        match self:
            case Align.Center: true
            case _: false

    pub fn is_end(self) -> bool:
        """Check if this is End alignment.
        Returns: true for End
        Example: Align.End.is_end()  # → true
        """
        match self:
            case Align.End: true
            case _: false

    pub fn is_stretch(self) -> bool:
        """Check if this is Stretch alignment.
        Returns: true for Stretch
        Example: Align.Stretch.is_stretch()  # → true
        """
        match self:
            case Align.Stretch: true
            case _: false

    pub fn to_string(self) -> text:
        """Convert Align to string representation.
        Returns: lowercase alignment name
        Example: Align.Center.to_string()  # → "center"
        """
        match self:
            case Align.Start: "start"
            case Align.Center: "center"
            case Align.End: "end"
            case Align.Stretch: "stretch"

    pub fn description(self) -> text:
        """Get human-readable description of the alignment.
        Returns: descriptive explanation
        Example: Align.Stretch.description()  # → "Stretch to fill available space"
        """
        match self:
            case Align.Start: "Align to start edge"
            case Align.Center: "Center alignment"
            case Align.End: "Align to end edge"
            case Align.Stretch: "Stretch to fill available space"

    pub fn summary(self) -> text:
        """Get comprehensive summary of the alignment.
        Returns: summary with alignment name and description
        Example: Align.Center.summary()
                # → "Align: center (Center alignment)"
        """
        val name = self.to_string()
        val desc = self.description()
        "Align: {name} ({desc})"

pub enum Justify:
    Start
    Center
    End
    SpaceBetween
    SpaceAround
    SpaceEvenly

impl Justify:
    pub fn is_start(self) -> bool:
        """Check if this is Start justification.
        Returns: true for Start
        Example: Justify.Start.is_start()  # → true
        """
        match self:
            case Justify.Start: true
            case _: false

    pub fn is_center(self) -> bool:
        """Check if this is Center justification.
        Returns: true for Center
        Example: Justify.Center.is_center()  # → true
        """
        match self:
            case Justify.Center: true
            case _: false

    pub fn is_end(self) -> bool:
        """Check if this is End justification.
        Returns: true for End
        Example: Justify.End.is_end()  # → true
        """
        match self:
            case Justify.End: true
            case _: false

    pub fn is_space_between(self) -> bool:
        """Check if this is SpaceBetween justification.
        Returns: true for SpaceBetween
        Example: Justify.SpaceBetween.is_space_between()  # → true
        """
        match self:
            case Justify.SpaceBetween: true
            case _: false

    pub fn is_space_around(self) -> bool:
        """Check if this is SpaceAround justification.
        Returns: true for SpaceAround
        Example: Justify.SpaceAround.is_space_around()  # → true
        """
        match self:
            case Justify.SpaceAround: true
            case _: false

    pub fn is_space_evenly(self) -> bool:
        """Check if this is SpaceEvenly justification.
        Returns: true for SpaceEvenly
        Example: Justify.SpaceEvenly.is_space_evenly()  # → true
        """
        match self:
            case Justify.SpaceEvenly: true
            case _: false

    pub fn uses_spacing(self) -> bool:
        """Check if justification uses spacing between items.
        Returns: true for SpaceBetween, SpaceAround, or SpaceEvenly
        Example: Justify.SpaceBetween.uses_spacing()  # → true
        """
        match self:
            case Justify.SpaceBetween: true
            case Justify.SpaceAround: true
            case Justify.SpaceEvenly: true
            case _: false

    pub fn to_string(self) -> text:
        """Convert Justify to string representation.
        Returns: kebab-case justification name
        Example: Justify.SpaceBetween.to_string()  # → "space-between"
        """
        match self:
            case Justify.Start: "start"
            case Justify.Center: "center"
            case Justify.End: "end"
            case Justify.SpaceBetween: "space-between"
            case Justify.SpaceAround: "space-around"
            case Justify.SpaceEvenly: "space-evenly"

    pub fn description(self) -> text:
        """Get human-readable description of the justification.
        Returns: descriptive explanation
        Example: Justify.SpaceBetween.description()
                # → "Space items with gaps between them"
        """
        match self:
            case Justify.Start: "Pack items to start"
            case Justify.Center: "Center items"
            case Justify.End: "Pack items to end"
            case Justify.SpaceBetween: "Space items with gaps between them"
            case Justify.SpaceAround: "Space items with equal space around each"
            case Justify.SpaceEvenly: "Space items with equal gaps"

    pub fn summary(self) -> text:
        """Get comprehensive summary of the justification.
        Returns: summary with justification name, description, and type
        Example: Justify.SpaceAround.summary()
                # → "Justify: space-around (Space items with equal space around each, uses spacing)"
        """
        val name = self.to_string()
        val desc = self.description()
        val jtype = if self.uses_spacing():
            "uses spacing"
        else:
            "edge-aligned"
        "Justify: {name} ({desc}, {jtype})"

pub enum Alignment:
    TopLeft
    TopCenter
    TopRight
    CenterLeft
    Center
    CenterRight
    BottomLeft
    BottomCenter
    BottomRight

impl Alignment:
    pub fn is_top_left(self) -> bool:
        """Check if this is TopLeft alignment.
        Returns: true for TopLeft
        Example: Alignment.TopLeft.is_top_left()  # → true
        """
        match self:
            case Alignment.TopLeft: true
            case _: false

    pub fn is_top_center(self) -> bool:
        """Check if this is TopCenter alignment.
        Returns: true for TopCenter
        Example: Alignment.TopCenter.is_top_center()  # → true
        """
        match self:
            case Alignment.TopCenter: true
            case _: false

    pub fn is_top_right(self) -> bool:
        """Check if this is TopRight alignment.
        Returns: true for TopRight
        Example: Alignment.TopRight.is_top_right()  # → true
        """
        match self:
            case Alignment.TopRight: true
            case _: false

    pub fn is_center_left(self) -> bool:
        """Check if this is CenterLeft alignment.
        Returns: true for CenterLeft
        Example: Alignment.CenterLeft.is_center_left()  # → true
        """
        match self:
            case Alignment.CenterLeft: true
            case _: false

    pub fn is_center(self) -> bool:
        """Check if this is Center alignment.
        Returns: true for Center
        Example: Alignment.Center.is_center()  # → true
        """
        match self:
            case Alignment.Center: true
            case _: false

    pub fn is_center_right(self) -> bool:
        """Check if this is CenterRight alignment.
        Returns: true for CenterRight
        Example: Alignment.CenterRight.is_center_right()  # → true
        """
        match self:
            case Alignment.CenterRight: true
            case _: false

    pub fn is_bottom_left(self) -> bool:
        """Check if this is BottomLeft alignment.
        Returns: true for BottomLeft
        Example: Alignment.BottomLeft.is_bottom_left()  # → true
        """
        match self:
            case Alignment.BottomLeft: true
            case _: false

    pub fn is_bottom_center(self) -> bool:
        """Check if this is BottomCenter alignment.
        Returns: true for BottomCenter
        Example: Alignment.BottomCenter.is_bottom_center()  # → true
        """
        match self:
            case Alignment.BottomCenter: true
            case _: false

    pub fn is_bottom_right(self) -> bool:
        """Check if this is BottomRight alignment.
        Returns: true for BottomRight
        Example: Alignment.BottomRight.is_bottom_right()  # → true
        """
        match self:
            case Alignment.BottomRight: true
            case _: false

    pub fn is_top(self) -> bool:
        """Check if alignment is in top row.
        Returns: true for TopLeft, TopCenter, or TopRight
        Example: Alignment.TopCenter.is_top()  # → true
        """
        match self:
            case Alignment.TopLeft: true
            case Alignment.TopCenter: true
            case Alignment.TopRight: true
            case _: false

    pub fn is_middle(self) -> bool:
        """Check if alignment is in middle row.
        Returns: true for CenterLeft, Center, or CenterRight
        Example: Alignment.Center.is_middle()  # → true
        """
        match self:
            case Alignment.CenterLeft: true
            case Alignment.Center: true
            case Alignment.CenterRight: true
            case _: false

    pub fn is_bottom(self) -> bool:
        """Check if alignment is in bottom row.
        Returns: true for BottomLeft, BottomCenter, or BottomRight
        Example: Alignment.BottomRight.is_bottom()  # → true
        """
        match self:
            case Alignment.BottomLeft: true
            case Alignment.BottomCenter: true
            case Alignment.BottomRight: true
            case _: false

    pub fn is_left(self) -> bool:
        """Check if alignment is in left column.
        Returns: true for TopLeft, CenterLeft, or BottomLeft
        Example: Alignment.CenterLeft.is_left()  # → true
        """
        match self:
            case Alignment.TopLeft: true
            case Alignment.CenterLeft: true
            case Alignment.BottomLeft: true
            case _: false

    pub fn is_centered_horizontal(self) -> bool:
        """Check if alignment is horizontally centered.
        Returns: true for TopCenter, Center, or BottomCenter
        Example: Alignment.Center.is_centered_horizontal()  # → true
        """
        match self:
            case Alignment.TopCenter: true
            case Alignment.Center: true
            case Alignment.BottomCenter: true
            case _: false

    pub fn is_right(self) -> bool:
        """Check if alignment is in right column.
        Returns: true for TopRight, CenterRight, or BottomRight
        Example: Alignment.TopRight.is_right()  # → true
        """
        match self:
            case Alignment.TopRight: true
            case Alignment.CenterRight: true
            case Alignment.BottomRight: true
            case _: false

    pub fn is_corner(self) -> bool:
        """Check if alignment is a corner position.
        Returns: true for TopLeft, TopRight, BottomLeft, or BottomRight
        Example: Alignment.TopLeft.is_corner()  # → true
        """
        match self:
            case Alignment.TopLeft: true
            case Alignment.TopRight: true
            case Alignment.BottomLeft: true
            case Alignment.BottomRight: true
            case _: false

    pub fn to_string(self) -> text:
        """Convert Alignment to string representation.
        Returns: kebab-case alignment name
        Example: Alignment.TopLeft.to_string()  # → "top-left"
        """
        match self:
            case Alignment.TopLeft: "top-left"
            case Alignment.TopCenter: "top-center"
            case Alignment.TopRight: "top-right"
            case Alignment.CenterLeft: "center-left"
            case Alignment.Center: "center"
            case Alignment.CenterRight: "center-right"
            case Alignment.BottomLeft: "bottom-left"
            case Alignment.BottomCenter: "bottom-center"
            case Alignment.BottomRight: "bottom-right"

    pub fn description(self) -> text:
        """Get human-readable description of the alignment.
        Returns: descriptive explanation
        Example: Alignment.Center.description()  # → "Centered both horizontally and vertically"
        """
        match self:
            case Alignment.TopLeft: "Top-left corner alignment"
            case Alignment.TopCenter: "Top edge, horizontally centered"
            case Alignment.TopRight: "Top-right corner alignment"
            case Alignment.CenterLeft: "Left edge, vertically centered"
            case Alignment.Center: "Centered both horizontally and vertically"
            case Alignment.CenterRight: "Right edge, vertically centered"
            case Alignment.BottomLeft: "Bottom-left corner alignment"
            case Alignment.BottomCenter: "Bottom edge, horizontally centered"
            case Alignment.BottomRight: "Bottom-right corner alignment"

    pub fn summary(self) -> text:
        """Get comprehensive summary of the alignment.
        Returns: summary with alignment name, description, and position type
        Example: Alignment.Center.summary()
                # → "Alignment: center (Centered both horizontally and vertically, edge)"
        """
        val name = self.to_string()
        val desc = self.description()
        val pos_type = if self.is_corner():
            "corner"
        elif self == Alignment.Center:
            "center"
        else:
            "edge"
        "Alignment: {name} ({desc}, {pos_type})"

# Edge insets for padding/margin
pub struct EdgeInsets:
    pub top: PixelDimension
    pub right: PixelDimension
    pub bottom: PixelDimension
    pub left: PixelDimension

impl EdgeInsets:
    # Create insets with all sides equal
    pub fn all(value: PixelDimension) -> EdgeInsets:
        return EdgeInsets {
            top: value,
            right: value,
            bottom: value,
            left: value
        }

    # Create insets with symmetric values
    pub fn symmetric(vertical: PixelDimension, horizontal: PixelDimension) -> EdgeInsets:
        return EdgeInsets {
            top: vertical,
            right: horizontal,
            bottom: vertical,
            left: horizontal
        }

    # Create zero insets
    pub fn zero() -> EdgeInsets:
        return EdgeInsets.all(PixelDimension.zero())

    # Convert to CSS padding/margin string
    pub fn to_css(self) -> text:
        return "{self.top.value()}px {self.right.value()}px {self.bottom.value()}px {self.left.value()}px"

# Size constraints
pub struct BoxConstraints:
    pub min_width: Option<PixelDimension>
    pub max_width: Option<PixelDimension>
    pub min_height: Option<PixelDimension>
    pub max_height: Option<PixelDimension>

impl BoxConstraints:
    # Create unbounded constraints
    pub fn unbounded() -> BoxConstraints:
        return BoxConstraints {
            min_width: None,
            max_width: None,
            min_height: None,
            max_height: None
        }

    # Create tight constraints (fixed size)
    pub fn tight(width: PixelDimension, height: PixelDimension) -> BoxConstraints:
        return BoxConstraints {
            min_width: Some(width),
            max_width: Some(width),
            min_height: Some(height),
            max_height: Some(height)
        }

# Color type for theming
pub struct Color:
    pub rgba: u32  # RGBA in format 0xRRGGBBAA

impl Color:
    # Create color from RGB values (0-255)
    pub fn rgb(r: u8, g: u8, b: u8) -> Color:
        return Color {
            rgba: ((r as u32) << 24) | ((g as u32) << 16) | ((b as u32) << 8) | 0xFF
        }

    # Create color from RGBA values (0-255)
    pub fn rgba(r: u8, g: u8, b: u8, a: u8) -> Color:
        return Color {
            rgba: ((r as u32) << 24) | ((g as u32) << 16) | ((b as u32) << 8) | (a as u32)
        }

    # Create color from hex string (e.g., "#FF5733" or "#FF5733AA")
    pub fn hex(hex: &str) -> Result<Color, text>:
        # Remove '#' prefix if present
        val hex_clean = ""
        if hex.starts_with("#"):
            hex_clean = hex[1..]
        else:
            hex_clean = hex

        if hex_clean.len() == 6:
            # RGB format
            val r = u8.from_str_radix(&hex_clean[0..2], 16)?
            val g = u8.from_str_radix(&hex_clean[2..4], 16)?
            val b = u8.from_str_radix(&hex_clean[4..6], 16)?
            return Ok(Color.rgb(r, g, b))
        else if hex_clean.len() == 8:
            # RGBA format
            val r = u8.from_str_radix(&hex_clean[0..2], 16)?
            val g = u8.from_str_radix(&hex_clean[2..4], 16)?
            val b = u8.from_str_radix(&hex_clean[4..6], 16)?
            val a = u8.from_str_radix(&hex_clean[6..8], 16)?
            return Ok(Color.rgba(r, g, b, a))
        else:
            return Err("Invalid hex color format: {hex_clean}")

    # Get red component
    pub fn red(self) -> u8:
        return ((self.rgba >> 24) & 0xFF) as u8

    # Get green component
    pub fn green(self) -> u8:
        return ((self.rgba >> 16) & 0xFF) as u8

    # Get blue component
    pub fn blue(self) -> u8:
        return ((self.rgba >> 8) & 0xFF) as u8

    # Get alpha component
    pub fn alpha(self) -> u8:
        return (self.rgba & 0xFF) as u8

    # Convert to CSS color string
    pub fn to_css(self) -> text:
        val r = self.red()
        val g = self.green()
        val b = self.blue()
        val a = self.alpha()
        if a == 255:
            return "rgb({r}, {g}, {b})"
        else:
            val alpha_f = (a as f64) / 255.0
            return "rgba({r}, {g}, {b}, {alpha_f})"

# Common color constants
impl Color:
    pub fn transparent() -> Color:
        return Color { rgba: 0 }

    pub fn black() -> Color:
        return Color.rgb(0, 0, 0)

    pub fn white() -> Color:
        return Color.rgb(255, 255, 255)

    pub fn red() -> Color:
        return Color.rgb(255, 0, 0)

    pub fn green() -> Color:
        return Color.rgb(0, 255, 0)

    pub fn blue() -> Color:
        return Color.rgb(0, 0, 255)
