# #1289-1290: Binary format & Streaming
# =============================================================================

pub fn encode_protobuf(output: &McpOutput) -> Result<Array<u8>, McpError>:
    """Encode MCP output in protobuf-like binary format.

    Wire format:
    - Field 1 (items): repeated message
      - Each item: [tag][length][kind][line_len][line][children_count][children...][metadata]

    Uses varint encoding for integers and length-prefixed strings.
    """
    var bytes: Array<u8> = []

    # Header: magic bytes "MCP1"
    bytes.push(0x4D)  # 'M'
    bytes.push(0x43)  # 'C'
    bytes.push(0x50)  # 'P'
    bytes.push(0x31)  # '1'

    # Encode item count as varint
    encode_varint(&mut bytes, output.items.len() as u64)

    # Encode each item
    for item in output.items:
        encode_mcp_item(&mut bytes, item)?

    Ok(bytes)

fn encode_varint(bytes: &mut Array<u8>, value: u64):
    """Encode unsigned integer as varint."""
    var v = value
    while v >= 0x80:
        bytes.push(((v & 0x7F) | 0x80) as u8)
        v = v >> 7
    bytes.push((v & 0x7F) as u8)

fn encode_string(bytes: &mut Array<u8>, s: &str):
    """Encode string with length prefix."""
    val s_bytes = s.as_bytes()
    encode_varint(bytes, s_bytes.len() as u64)
    for b in s_bytes:
        bytes.push(b)

fn encode_item_kind(kind: &ItemKind) -> u8:
    """Map ItemKind to byte value."""
    match kind:
        case Function: 0
        case Struct: 1
        case Enum: 2
        case EnumVariant: 3
        case Trait: 4
        case Impl: 5
        case Module: 6
        case Import: 7
        case Field: 8
        case _: 255

fn encode_mcp_item(bytes: &mut Array<u8>, item: &McpItem) -> Result<(), McpError>:
    """Encode single MCP item."""
    # Kind (1 byte)
    bytes.push(encode_item_kind(&item.kind))

    # Line text
    encode_string(bytes, &item.line)

    # Children count and recursive encoding
    encode_varint(bytes, item.children.len() as u64)
    for child in item.children:
        encode_mcp_item(bytes, child)?

    # Metadata (simplified - just encode overlay count and key-value pairs)
    val overlays = item.metadata.get_overlays()
    encode_varint(bytes, overlays.len() as u64)
    for (key, value) in overlays:
        encode_string(bytes, key)
        encode_string(bytes, value)

    Ok(())

pub fn decode_protobuf(bytes: &Array<u8>) -> Result<McpOutput, McpError>:
    """Decode MCP output from protobuf-like binary format."""
    if bytes.len() < 4:
        return Err(McpError.ParseError("Invalid header"))

    # Check magic bytes
    if bytes[0] != 0x4D or bytes[1] != 0x43 or bytes[2] != 0x50 or bytes[3] != 0x31:
        return Err(McpError.ParseError("Invalid magic bytes"))

    var offset: usize = 4
    var output = McpOutput.new()

    # Decode item count
    val (item_count, new_offset) = decode_varint(bytes, offset)?
    offset = new_offset

    # Decode items
    for _ in 0..item_count:
        val (item, new_offset) = decode_mcp_item(bytes, offset)?
        output.add_item(item)
        offset = new_offset

    Ok(output)

fn decode_varint(bytes: &Array<u8>, offset: usize) -> Result<(u64, usize), McpError>:
    """Decode varint from bytes."""
    var value: u64 = 0
    var shift: u64 = 0
    var pos = offset

    while pos < bytes.len():
        val b = bytes[pos] as u64
        value = value | ((b & 0x7F) << shift)
        pos = pos + 1

        if (b & 0x80) == 0:
            return Ok((value, pos))

        shift = shift + 7
        if shift >= 64:
            return Err(McpError.ParseError("Varint overflow"))

    Err(McpError.ParseError("Unexpected end of varint"))

fn decode_string(bytes: &Array<u8>, offset: usize) -> Result<(text, usize), McpError>:
    """Decode length-prefixed string."""
    val (len, new_offset) = decode_varint(bytes, offset)?
    val end = new_offset + (len as usize)

    if end > bytes.len():
        return Err(McpError.ParseError("String extends past end"))

    var s = ""
    for i in new_offset..end:
        s = s + (bytes[i] as char).to_string()

    Ok((s, end))

fn decode_item_kind(b: u8) -> ItemKind:
    """Map byte to ItemKind."""
    match b:
        case 0: ItemKind.Function
        case 1: ItemKind.Struct
        case 2: ItemKind.Enum
        case 3: ItemKind.EnumVariant
        case 4: ItemKind.Trait
        case 5: ItemKind.Impl
        case 6: ItemKind.Module
        case 7: ItemKind.Import
        case 8: ItemKind.Field
        case _: ItemKind.Function  # Default

fn decode_mcp_item(bytes: &Array<u8>, offset: usize) -> Result<(McpItem, usize), McpError>:
    """Decode single MCP item."""
    var pos = offset

    # Kind
    if pos >= bytes.len():
        return Err(McpError.ParseError("Unexpected end"))
    val kind = decode_item_kind(bytes[pos])
    pos = pos + 1

    # Line text
    val (line, new_pos) = decode_string(bytes, pos)?
    pos = new_pos

    # Children
    val (child_count, new_pos2) = decode_varint(bytes, pos)?
    pos = new_pos2

    var children: Array<McpItem> = []
    for _ in 0..child_count:
        val (child, new_pos) = decode_mcp_item(bytes, pos)?
        children.push(child)
        pos = new_pos

    # Metadata
    val (overlay_count, new_pos3) = decode_varint(bytes, pos)?
    pos = new_pos3

    var metadata = McpMetadata.new()
    for _ in 0..overlay_count:
        val (key, new_pos) = decode_string(bytes, pos)?
        pos = new_pos
        val (value, new_pos2) = decode_string(bytes, pos)?
        pos = new_pos2
        metadata.add_overlay(key, value)

    Ok((McpItem { kind: kind, line: line, children: children, metadata: metadata }, pos))

pub fn stream_incremental(source: &str, chunk_size: u64) -> McpStream:
    return McpStream.new(source, chunk_size)

pub struct McpStream:
    source: text
    position: u64
    chunk_size: u64

impl McpStream:
    fn new(source: &str, chunk_size: u64) -> McpStream:
        return McpStream {
            source: source.to_string(),
            position: 0,
            chunk_size: chunk_size
        }

    pub fn next_chunk(self) -> Option<McpOutput>:
        # Check if we have more data to read
        if self.position >= self.source.len() as u64:
            return None

        # Calculate end position for this chunk
        val end_pos = min(self.position + self.chunk_size, self.source.len() as u64)

        # Extract chunk from source
        val chunk = self.source.substring(self.position as i32, end_pos as i32)

        # Create output for this chunk
        var output = McpOutput.new()
        output.content = chunk
        output.start_offset = self.position
        output.end_offset = end_pos

        # Advance position
        self.position = end_pos

        return Some(output)

# =============================================================================
