# Dependency Symbol Extraction for Simple Language
# Extracts import/use statements and tracks symbol dependencies

use core.*
use mcp.simple_lang.parser.*
use mcp.simple_lang.types.*

# Dependency type
pub enum DependencyType:
    Import       # import foo
    Use          # use foo.*
    From         # from foo use bar

impl DependencyType:
    pub fn is_import(self) -> bool:
        """Check if this is Import type.
        Returns: true for Import
        Example: DependencyType.Import.is_import()  # → true
        """
        match self:
            case Import: true
            case _: false

    pub fn is_use(self) -> bool:
        """Check if this is Use type.
        Returns: true for Use
        Example: DependencyType.Use.is_use()  # → true
        """
        match self:
            case Use: true
            case _: false

    pub fn is_from(self) -> bool:
        """Check if this is From type.
        Returns: true for From
        Example: DependencyType.From.is_from()  # → true
        """
        match self:
            case From: true
            case _: false

    pub fn allows_wildcard(self) -> bool:
        """Check if this type allows wildcard imports.
        Returns: true for Use (use foo.*)
        Example: DependencyType.Use.allows_wildcard()  # → true
        """
        match self:
            case Use: true
            case _: false

    pub fn requires_module_path(self) -> bool:
        """Check if dependency type requires module path.
        Returns: true for all variants
        Example: DependencyType.Import.requires_module_path()  # → true
        """
        true

    pub fn to_string(self) -> text:
        """Convert DependencyType to string representation.
        Returns: lowercase dependency type name
        Example: DependencyType.Import.to_string()  # → "import"
        """
        match self:
            case Import: "import"
            case Use: "use"
            case From: "from"

    pub fn description(self) -> text:
        """Get human-readable description of the dependency type.
        Returns: descriptive explanation with syntax
        Example: DependencyType.From.description()  # → "From-import statement (from foo use bar)"
        """
        match self:
            case Import: "Import statement (import foo)"
            case Use: "Use statement (use foo.*)"
            case From: "From-import statement (from foo use bar)"

    pub fn summary(self) -> text:
        """Get comprehensive summary of the dependency type.
        Returns: summary with name, description, and properties
        Example: DependencyType.Use.summary()
                # → "DependencyType: use (Use statement (use foo.*), allows wildcard)"
        """
        val name = self.to_string()
        val desc = self.description()
        var props = []

        if self.allows_wildcard():
            props.push("allows wildcard")

        val props_str = if props.len() > 0:
            ", " + props.join(", ")
        else:
            ""

        "DependencyType: {name} ({desc}{props_str})"

# Dependency entry
pub class Dependency:
    pub dep_type: DependencyType
    pub module_path: text
    pub imported_symbols: List<text>
    pub line_number: i64
    pub is_public: bool

# Dependency graph
pub class DependencyGraph:
    pub dependencies: List<Dependency>
    pub internal_deps: List<Dependency>   # Dependencies within project
    pub external_deps: List<Dependency>   # Dependencies from stdlib/packages
    pub symbol_usage: Dict<text, List<text>>  # Symbol -> used in functions
    pub module_name: text

# Parse dependencies from Simple source code
pub fn extract_dependencies(source: text) -> DependencyGraph:
    print("DEBUG: extract_dependencies start")
    val lines = source.split("\n")
    var dependencies = []
    var import_aliases = {}

    print("DEBUG: starting main loop, lines={lines.len()}")
    for i in range(lines.len()):
        val line = lines[i]
        val stripped = line.strip()
        print("DEBUG: line {i}: {stripped}")

        # Parse import statements
        if stripped.starts_with("import ") or stripped.starts_with("pub import "):
            val dep = parse_import(stripped, i + 1)
            dependencies.append(dep)
            val alias = parse_import_alias(stripped)
            if alias != "":
                import_aliases[dep.module_path] = alias

        # Parse use statements
        elif stripped.starts_with("use ") or stripped.starts_with("pub use "):
            val dep = parse_use(stripped, i + 1)
            dependencies.append(dep)

        # Parse from...use statements
        elif stripped.starts_with("from "):
            val dep = parse_from_use(stripped, i + 1)
            dependencies.append(dep)

    print("DEBUG: classify deps, count={dependencies.len()}")
    # Classify dependencies
    var internal_deps = []
    var external_deps = []

    for dep in dependencies:
        if is_internal_module(dep.module_path):
            internal_deps.append(dep)
        else:
            external_deps.append(dep)

    print("DEBUG: extracting symbol usage")
    # Extract symbol usage
    val symbol_usage = extract_symbol_usage(source, dependencies, import_aliases)
    val module_name = parse_module_name(source)

    return DependencyGraph(
        dependencies: dependencies,
        internal_deps: internal_deps,
        external_deps: external_deps,
        symbol_usage: symbol_usage,
        module_name: module_name
    )

# Parse import statement
fn parse_import(line: text, line_num: i64) -> Dependency:
    val is_public = line.starts_with("pub ")
    var module_part = line

    if is_public:
        module_part = line[11:]  # Remove "pub import "
    else:
        module_part = line[7:]   # Remove "import "

    # Handle "import foo as bar"
    var module_path = module_part
    if module_part.contains(" as "):
        val idx = module_part.find(" as ").unwrap()
        module_path = module_part[0:idx].strip()

    return Dependency(
        dep_type: DependencyType.Import,
        module_path: module_path.strip(),
        imported_symbols: [],
        line_number: line_num,
        is_public: is_public
    )

# Parse import alias (import foo as bar)
fn parse_import_alias(line: text) -> text:
    var module_part = line
    if line.starts_with("pub "):
        module_part = line[11:]
    else:
        module_part = line[7:]

    if module_part.contains(" as "):
        val idx = module_part.find(" as ").unwrap()
        val alias = module_part[idx + 4:]
        return alias.strip()

    return ""

# Parse use statement
fn parse_use(line: text, line_num: i64) -> Dependency:
    print("DEBUG parse_use: {line}")
    val is_public = line.starts_with("pub ")
    var module_part = line

    if is_public:
        module_part = line[8:]  # Remove "pub use "
    else:
        module_part = line[4:]   # Remove "use "

    # Handle "use foo.*" or "use foo.{bar, baz}"
    var imported_symbols = []

    var module_path = ""
    if module_part.ends_with(".*"):
        # Wildcard import
        module_path = module_part[0:-2]  # Remove .*
    elif module_part.contains(".{"):
        # Selective import: use foo.{bar, baz}
        val idx = module_part.find(".{").unwrap()
        module_path = module_part[0:idx]

        # Extract symbols between { }
        var symbol_part = module_part[idx+2:]
        if symbol_part.ends_with("}"):
            symbol_part = symbol_part[0:-1]
        imported_symbols = symbol_part.split(",")
        # Trim each symbol
        for i in range(imported_symbols.len()):
            imported_symbols[i] = imported_symbols[i].strip()
    else:
        module_path = module_part

    print("DEBUG parse_use done: module={module_path}, symbols={imported_symbols.len()}")
    return Dependency(
        dep_type: DependencyType.Use,
        module_path: module_path.strip(),
        imported_symbols: imported_symbols,
        line_number: line_num,
        is_public: is_public
    )

# Parse from...use statement
fn parse_from_use(line: text, line_num: i64) -> Dependency:
    # Format: from foo use bar, baz

    # Extract module path
    val use_idx_opt = line.find(" use ")
    if not use_idx_opt.?:
        # Invalid format
        return Dependency(
            dep_type: DependencyType.From,
            module_path: "",
            imported_symbols: [],
            line_number: line_num,
            is_public: false
        )

    val use_idx = use_idx_opt.unwrap()
    val module_path = line[5:use_idx].strip()  # Between "from " and " use "

    # Extract symbols
    val symbol_part = line[use_idx + 5:].strip()
    var imported_symbols = symbol_part.split(",")

    # Trim each symbol
    for i in range(imported_symbols.len()):
        imported_symbols[i] = imported_symbols[i].strip()

    return Dependency(
        dep_type: DependencyType.From,
        module_path: module_path,
        imported_symbols: imported_symbols,
        line_number: line_num,
        is_public: false
    )

# Check if module is internal to project
fn is_internal_module(module_path: text) -> bool:
    # Check for common stdlib/external prefixes
    if module_path.starts_with("std."):
        return false
    elif module_path.starts_with("core."):
        return false
    elif module_path.starts_with("mcp."):
        return false

    # If starts with project name or relative path, it's internal
    if module_path.starts_with("./") or module_path.starts_with("../"):
        return true

    # Otherwise, check if it looks like a package name
    # Simple heuristic: if no dots, probably internal module
    return not module_path.contains(".")

# Format dependency graph for MCP
pub fn format_dependency_graph(graph: DependencyGraph) -> text:
    var result = "DEP> Dependency Graph {\n"

    result = result + "  Total dependencies: " + graph.dependencies.len().to_string() + "\n"
    result = result + "  Internal: " + graph.internal_deps.len().to_string() + "\n"
    result = result + "  External: " + graph.external_deps.len().to_string() + "\n"

    result = result + "\n  External Dependencies:\n"
    for dep in graph.external_deps:
        result = result + "    " + format_dependency_entry(dep) + "\n"

    result = result + "\n  Internal Dependencies:\n"
    for dep in graph.internal_deps:
        result = result + "    " + format_dependency_entry(dep) + "\n"

    result = result + "}\n"
    return result

# Format single dependency entry
fn format_dependency_entry(dep: Dependency) -> text:
    var dep_type_str = ""
    if dep.dep_type.is_import():
        dep_type_str = "import"
    elif dep.dep_type.is_use():
        dep_type_str = "use"
    else:
        dep_type_str = "from"

    var result = dep_type_str + " " + dep.module_path

    if dep.imported_symbols.len() > 0:
        symbols_str = ", ".join(dep.imported_symbols)
        result = result + " {" + symbols_str + "}"

    if dep.is_public:
        result = result + " (pub)"

    return result

# Get direct dependencies for a module
pub fn get_direct_dependencies(graph: DependencyGraph) -> List<text>:
    var modules = []

    for dep in graph.dependencies:
        if not modules.contains(dep.module_path):
            modules.append(dep.module_path)

    return modules

# Check for circular dependencies (simplified)
pub fn detect_circular_dependencies(graph: DependencyGraph) -> List<text>:
    var cycles = []

    if graph.module_name == "":
        return cycles

    for dep in graph.internal_deps:
        if dep.module_path == graph.module_name:
            cycles.append(graph.module_name + " -> " + graph.module_name)

    return cycles

# Extract module name from source (module foo.bar:)
fn parse_module_name(source: text) -> text:
    val lines = source.split("\n")
    for line in lines:
        val stripped = line.strip()
        if stripped.starts_with("module "):
            var name_part = stripped.substring(7, stripped.len())
            if name_part.contains(" requires"):
                val idx = name_part.find(" requires").unwrap()
                name_part = name_part.substring(0, idx)
            if name_part.ends_with(":"):
                name_part = name_part.substring(0, name_part.len() - 1)
            return name_part.strip()
    return ""

# Extract symbol usage for dependency tracking
fn extract_symbol_usage(
    source: text,
    dependencies: List<Dependency>,
    import_aliases: Dict<text, text>
) -> Dict<text, List<text>>:
    var symbol_usage = {}
    val symbols = parse_file(source)

    for symbol in symbols:
        if symbol.kind.to_string() != "function":
            continue
        val body = symbol.body
        val func_name = symbol.name

        for dep in dependencies:
            if dep.dep_type.is_import():
                if is_module_used(body, dep.module_path, import_aliases):
                    record_usage(symbol_usage, dep.module_path, func_name)
            elif dep.dep_type.is_use():
                if dep.imported_symbols.len() > 0:
                    for sym in dep.imported_symbols:
                        if contains_symbol(body, sym):
                            record_usage(symbol_usage, sym, func_name)
                else:
                    if is_module_used(body, dep.module_path, {}):
                        record_usage(symbol_usage, dep.module_path, func_name)
            else:
                for sym in dep.imported_symbols:
                    if contains_symbol(body, sym):
                        record_usage(symbol_usage, sym, func_name)

    return symbol_usage

fn record_usage(symbol_usage: Dict<text, List<text>>, symbol: text, func_name: text):
    if not symbol_usage.contains_key(symbol):
        symbol_usage[symbol] = []
    if not symbol_usage[symbol].contains(func_name):
        symbol_usage[symbol].append(func_name)

fn is_module_used(body: text, module_path: text, import_aliases: Dict<text, text>) -> bool:
    if module_path == "":
        return false

    if body.contains(module_path + "."):
        return true

    if not module_path.contains(".") and contains_symbol(body, module_path):
        return true

    if import_aliases.contains_key(module_path):
        val alias = import_aliases.get(module_path)
        if body.contains(alias + "."):
            return true
        if not alias.contains(".") and contains_symbol(body, alias):
            return true

    return false

fn contains_symbol(text: text, symbol: text) -> bool:
    if symbol.len() == 0:
        return false
    if text.len() < symbol.len():
        return false

    val max_idx = text.len() - symbol.len()
    var i = 0
    while i <= max_idx:
        if text.substring(i, i + symbol.len()) == symbol:
            var prev_ok = true
            var next_ok = true

            if i > 0:
                val prev = text.char_at(i - 1)
                if is_identifier_char(prev):
                    prev_ok = false

            if i + symbol.len() < text.len():
                val next = text.char_at(i + symbol.len())
                if is_identifier_char(next):
                    next_ok = false

            if prev_ok and next_ok:
                return true

        i = i + 1

    return false

fn is_identifier_char(ch: text) -> bool:
    if ch.len() == 0:
        return false
    val code = ch.ord()
    if code >= 48 and code <= 57:
        return true
    if code >= 65 and code <= 90:
        return true
    if code >= 97 and code <= 122:
        return true
    if ch == "_":
        return true
    return false
