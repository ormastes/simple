# MCP Type Definitions

# Block mark types for MCP output
pub enum BlockMark:
    ClassCollapsed
    ClassExpanded
    FunctionCollapsed
    FunctionExpanded
    TraitCollapsed
    TraitExpanded
    PointcutCollapsed
    PointcutExpanded
    VirtualInfo

impl BlockMark:
    pub fn to_string(self) -> text:
        """Convert block mark to string representation."""
        match self:
            case ClassCollapsed: "C>"
            case ClassExpanded: "C▼"
            case FunctionCollapsed: "F>"
            case FunctionExpanded: "F▼"
            case TraitCollapsed: "T>"
            case TraitExpanded: "T▼"
            case PointcutCollapsed: "P>"
            case PointcutExpanded: "P▼"
            case VirtualInfo: "V•"

    pub fn description(self) -> text:
        """Get block mark description."""
        match self:
            case ClassCollapsed: "Collapsed class definition"
            case ClassExpanded: "Expanded class definition"
            case FunctionCollapsed: "Collapsed function"
            case FunctionExpanded: "Expanded function"
            case TraitCollapsed: "Collapsed trait definition"
            case TraitExpanded: "Expanded trait definition"
            case PointcutCollapsed: "Collapsed pointcut"
            case PointcutExpanded: "Expanded pointcut"
            case VirtualInfo: "Virtual method info"

    pub fn is_class_collapsed(self) -> bool:
        """Check if mark is ClassCollapsed."""
        match self:
            case ClassCollapsed: true
            case _: false

    pub fn is_class_expanded(self) -> bool:
        """Check if mark is ClassExpanded."""
        match self:
            case ClassExpanded: true
            case _: false

    pub fn is_function_collapsed(self) -> bool:
        """Check if mark is FunctionCollapsed."""
        match self:
            case FunctionCollapsed: true
            case _: false

    pub fn is_function_expanded(self) -> bool:
        """Check if mark is FunctionExpanded."""
        match self:
            case FunctionExpanded: true
            case _: false

    pub fn is_trait_collapsed(self) -> bool:
        """Check if mark is TraitCollapsed."""
        match self:
            case TraitCollapsed: true
            case _: false

    pub fn is_trait_expanded(self) -> bool:
        """Check if mark is TraitExpanded."""
        match self:
            case TraitExpanded: true
            case _: false

    pub fn is_pointcut_collapsed(self) -> bool:
        """Check if mark is PointcutCollapsed."""
        match self:
            case PointcutCollapsed: true
            case _: false

    pub fn is_pointcut_expanded(self) -> bool:
        """Check if mark is PointcutExpanded."""
        match self:
            case PointcutExpanded: true
            case _: false

    pub fn is_virtual_info(self) -> bool:
        """Check if mark is VirtualInfo."""
        match self:
            case VirtualInfo: true
            case _: false

    pub fn is_collapsed(self) -> bool:
        """Check if mark represents a collapsed block."""
        match self:
            case ClassCollapsed: true
            case FunctionCollapsed: true
            case TraitCollapsed: true
            case PointcutCollapsed: true
            case _: false

    pub fn is_expanded(self) -> bool:
        """Check if mark represents an expanded block."""
        match self:
            case ClassExpanded: true
            case FunctionExpanded: true
            case TraitExpanded: true
            case PointcutExpanded: true
            case _: false

    pub fn is_class_mark(self) -> bool:
        """Check if mark is class-related."""
        match self:
            case ClassCollapsed: true
            case ClassExpanded: true
            case _: false

    pub fn is_function_mark(self) -> bool:
        """Check if mark is function-related."""
        match self:
            case FunctionCollapsed: true
            case FunctionExpanded: true
            case _: false

    pub fn is_trait_mark(self) -> bool:
        """Check if mark is trait-related."""
        match self:
            case TraitCollapsed: true
            case TraitExpanded: true
            case _: false

    pub fn is_pointcut_mark(self) -> bool:
        """Check if mark is pointcut-related."""
        match self:
            case PointcutCollapsed: true
            case PointcutExpanded: true
            case _: false

    pub fn summary(self) -> text:
        """Get block mark summary."""
        val symbol = self.to_string()
        val desc = self.description()
        val state = if self.is_collapsed():
            "collapsed"
        elif self.is_expanded():
            "expanded"
        else:
            "info"
        return "BlockMark: {symbol} ({desc}, {state})"

# Convert block mark to string representation
pub fn block_mark_to_string(mark: BlockMark) -> text:
    if mark == BlockMark.ClassCollapsed:
        return "C>"
    elif mark == BlockMark.ClassExpanded:
        return "C▼"
    elif mark == BlockMark.FunctionCollapsed:
        return "F>"
    elif mark == BlockMark.FunctionExpanded:
        return "F▼"
    elif mark == BlockMark.TraitCollapsed:
        return "T>"
    elif mark == BlockMark.TraitExpanded:
        return "T▼"
    elif mark == BlockMark.PointcutCollapsed:
        return "P>"
    elif mark == BlockMark.PointcutExpanded:
        return "P▼"
    elif mark == BlockMark.VirtualInfo:
        return "V•"
    else:
        return "??"

# Symbol visibility
pub enum Visibility:
    Public
    Private

impl Visibility:
    pub fn to_string(self) -> text:
        """Convert visibility to string."""
        match self:
            case Public: "public"
            case Private: "private"

    pub fn description(self) -> text:
        """Get visibility description."""
        match self:
            case Public: "Accessible from any module"
            case Private: "Accessible only within module"

    pub fn is_public(self) -> bool:
        """Check if visibility is Public."""
        match self:
            case Public: true
            case _: false

    pub fn is_private(self) -> bool:
        """Check if visibility is Private."""
        match self:
            case Private: true
            case _: false

    pub fn allows_external_access(self) -> bool:
        """Check if visibility allows external access."""
        match self:
            case Public: true
            case Private: false

    pub fn summary(self) -> text:
        """Get visibility summary."""
        val name = self.to_string()
        val desc = self.description()
        val access = if self.allows_external_access(): "external" else: "internal-only"
        return "Visibility: {name} ({desc}, {access})"

# Symbol types
pub enum SymbolKind:
    Class
    Struct
    Function
    Method
    Trait
    Pointcut
    Variable

impl SymbolKind:
    pub fn to_string(self) -> text:
        """Convert symbol kind to string."""
        match self:
            case Class: "class"
            case Struct: "struct"
            case Function: "function"
            case Method: "method"
            case Trait: "trait"
            case Pointcut: "pointcut"
            case Variable: "variable"

    pub fn description(self) -> text:
        """Get symbol kind description."""
        match self:
            case Class: "Class definition"
            case Struct: "Struct definition"
            case Function: "Free function"
            case Method: "Class or trait method"
            case Trait: "Trait definition"
            case Pointcut: "AOP pointcut"
            case Variable: "Variable or constant"

    pub fn is_class(self) -> bool:
        """Check if kind is Class."""
        match self:
            case Class: true
            case _: false

    pub fn is_struct(self) -> bool:
        """Check if kind is Struct."""
        match self:
            case Struct: true
            case _: false

    pub fn is_function(self) -> bool:
        """Check if kind is Function."""
        match self:
            case Function: true
            case _: false

    pub fn is_method(self) -> bool:
        """Check if kind is Method."""
        match self:
            case Method: true
            case _: false

    pub fn is_trait(self) -> bool:
        """Check if kind is Trait."""
        match self:
            case Trait: true
            case _: false

    pub fn is_pointcut(self) -> bool:
        """Check if kind is Pointcut."""
        match self:
            case Pointcut: true
            case _: false

    pub fn is_variable(self) -> bool:
        """Check if kind is Variable."""
        match self:
            case Variable: true
            case _: false

    pub fn is_type_definition(self) -> bool:
        """Check if kind defines a type (Class, Struct, or Trait)."""
        match self:
            case Class: true
            case Struct: true
            case Trait: true
            case _: false

    pub fn is_callable(self) -> bool:
        """Check if kind is callable (Function or Method)."""
        match self:
            case Function: true
            case Method: true
            case _: false

    pub fn is_aop_construct(self) -> bool:
        """Check if kind is AOP-related (Pointcut)."""
        match self:
            case Pointcut: true
            case _: false

    pub fn summary(self) -> text:
        """Get symbol kind summary."""
        val name = self.to_string()
        val desc = self.description()
        val category = if self.is_type_definition():
            "type"
        elif self.is_callable():
            "callable"
        elif self.is_aop_construct():
            "aop"
        else:
            "value"
        return "SymbolKind: {name} ({desc}, {category})"

# Symbol information extracted from source
pub class Symbol:
    pub kind: SymbolKind
    pub name: text
    pub visibility: Visibility
    pub signature: text
    pub body: text
    pub line_start: i64
    pub line_end: i64
    pub is_collapsed: bool

    pub fn new(kind: SymbolKind, name: text, vis: Visibility) -> Symbol:
        return Symbol {
            kind: kind,
            name: name,
            visibility: vis,
            signature: "",
            body: "",
            line_start: 0,
            line_end: 0,
            is_collapsed: true
        }

# MCP output metadata
pub class McpMetadata:
    pub mode: text
    pub line_numbers: text
    pub show_coverage: bool
    pub show_block_guides: bool

    pub fn default() -> McpMetadata:
        return McpMetadata {
            mode: "mcp",
            line_numbers: "plain",
            show_coverage: false,
            show_block_guides: false
        }

# MCP output format
pub class McpOutput:
    pub text: text
    pub meta: Option<McpMetadata>

    pub fn new(text: text) -> McpOutput:
        return McpOutput {
            text: text,
            meta: nil
        }

    pub fn with_metadata(text: text, meta: McpMetadata) -> McpOutput:
        return McpOutput {
            text: text,
            meta: Some(meta)
        }

# File context for MCP
pub class FileContext:
    pub path: text
    pub source: text
    pub symbols: List<Symbol>

    pub fn new(path: text, source: text) -> FileContext:
        return FileContext {
            path: path,
            source: source,
            symbols: []
        }

# Exports
pub use BlockMark
pub use block_mark_to_string
pub use Visibility
pub use SymbolKind
pub use Symbol
pub use McpMetadata
pub use McpOutput
pub use FileContext
