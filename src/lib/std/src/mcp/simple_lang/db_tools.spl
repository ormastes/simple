# MCP Database Query Tools
# Provides tools to query all SDN databases (tests, features, bugs, TODOs, qualified ignores)

use infra.file_io.read_file
use sdn.*
use mcp.core.*

# Helper: format rows as a markdown table
fn format_markdown_table(headers: List<text>, rows: List<List<text>>) -> text:
    if rows.len() == 0:
        return "(no results)"

    # Header row
    var result = "| " + headers.join(" | ") + " |\n"
    result = result + "| " + headers.map(\h: "---").join(" | ") + " |\n"

    # Data rows
    for row in rows:
        result = result + "| " + row.join(" | ") + " |\n"

    result

# Helper: apply limit to rows
fn apply_limit(rows: List<List<text>>, limit: i64) -> List<List<text>>:
    if limit <= 0:
        rows
    else:
        rows[0:limit]

# Tool: query_tests - Query test execution database
fn create_query_tests_tool() -> ToolHandler:
    val handler = \args:
        val status_filter = args.get("status")
        val category_filter = args.get("category")
        val limit = args.get("limit") ?? 50

        match read_file("doc/test/test_db.sdn"):
            case Err(e): "Error reading test database: {e}"
            case Ok(content):
                val doc = parse(content)
                val table = doc.get_table("tests")
                if not table.?:
                    return "No tests table found in test_db.sdn"

                val headers = ["test_id", "test_name", "status", "category", "last_run"]
                var rows = []

                for record in table.rows():
                    val status = record.get("status")
                    val category = record.get("category")

                    # Apply filters
                    if status_filter.? and status != status_filter:
                        continue
                    if category_filter.? and category != category_filter:
                        continue

                    rows.append([
                        record.get("test_id"),
                        record.get("test_name"),
                        status,
                        category,
                        record.get("last_run")
                    ])

                rows = apply_limit(rows, limit)
                format_markdown_table(headers, rows)

    create_text_tool("query_tests", "Query test execution database. Params: status (passed/failed/ignored/skipped), category, limit", handler)

# Tool: query_features - Query feature database
fn create_query_features_tool() -> ToolHandler:
    val handler = \args:
        val status_filter = args.get("status")
        val category_filter = args.get("category")
        val limit = args.get("limit") ?? 50

        match read_file("doc/feature/feature_db.sdn"):
            case Err(e): "Error reading feature database: {e}"
            case Ok(content):
                val doc = parse(content)
                val table = doc.get_table("features")
                if not table.?:
                    return "No features table found in feature_db.sdn"

                val headers = ["feature_id", "name", "status", "category"]
                var rows = []

                for record in table.rows():
                    val status = record.get("status")
                    val category = record.get("category")

                    if status_filter.? and status != status_filter:
                        continue
                    if category_filter.? and category != category_filter:
                        continue

                    rows.append([
                        record.get("feature_id"),
                        record.get("name"),
                        status,
                        category
                    ])

                rows = apply_limit(rows, limit)
                format_markdown_table(headers, rows)

    create_text_tool("query_features", "Query feature database. Params: status (complete/in_progress/planned), category, limit", handler)

# Tool: query_bugs - Query bug database
fn create_query_bugs_tool() -> ToolHandler:
    val handler = \args:
        val severity_filter = args.get("severity")
        val status_filter = args.get("status")
        val limit = args.get("limit") ?? 50

        match read_file("doc/bug/bug_db.sdn"):
            case Err(e): "Error reading bug database: {e}"
            case Ok(content):
                val doc = parse(content)
                val table = doc.get_table("bugs")
                if not table.?:
                    return "No bugs table found in bug_db.sdn"

                val headers = ["bug_id", "description", "severity", "status"]
                var rows = []

                for record in table.rows():
                    val severity = record.get("severity")
                    val status = record.get("status")

                    if severity_filter.? and severity != severity_filter:
                        continue
                    if status_filter.? and status != status_filter:
                        continue

                    rows.append([
                        record.get("bug_id"),
                        record.get("description"),
                        severity,
                        status
                    ])

                rows = apply_limit(rows, limit)
                format_markdown_table(headers, rows)

    create_text_tool("query_bugs", "Query bug database. Params: severity (P0-P3), status, limit", handler)

# Tool: query_todos - Query TODO database
fn create_query_todos_tool() -> ToolHandler:
    val handler = \args:
        val area_filter = args.get("area")
        val priority_filter = args.get("priority")
        val keyword_filter = args.get("keyword")
        val limit = args.get("limit") ?? 50

        match read_file("doc/todo/todo_db.sdn"):
            case Err(e): "Error reading TODO database: {e}"
            case Ok(content):
                val doc = parse(content)
                val table = doc.get_table("todos")
                if not table.?:
                    return "No todos table found in todo_db.sdn"

                val headers = ["id", "keyword", "area", "priority", "description", "file"]
                var rows = []

                for record in table.rows():
                    val area = record.get("area")
                    val priority = record.get("priority")
                    val keyword = record.get("keyword")

                    if area_filter.? and area != area_filter:
                        continue
                    if priority_filter.? and priority != priority_filter:
                        continue
                    if keyword_filter.? and keyword != keyword_filter:
                        continue

                    rows.append([
                        record.get("id"),
                        keyword,
                        area,
                        priority,
                        record.get("description"),
                        record.get("file")
                    ])

                rows = apply_limit(rows, limit)
                format_markdown_table(headers, rows)

    create_text_tool("query_todos", "Query TODO database. Params: area, priority (P0-P3), keyword (TODO/FIXME), limit", handler)

# Tool: query_qualified_ignores - Query qualified ignore records
fn create_query_qualified_ignores_tool() -> ToolHandler:
    val handler = \args:
        val limit = args.get("limit") ?? 50

        match read_file("doc/test/test_db.sdn"):
            case Err(e): "Error reading test database: {e}"
            case Ok(content):
                val doc = parse(content)
                val table = doc.get_table("tests")
                if not table.?:
                    return "No tests table found in test_db.sdn"

                val headers = ["test_id", "test_name", "status", "qualified_by", "qualified_at", "qualified_reason"]
                var rows = []

                for record in table.rows():
                    val status = record.get("status")
                    val qualified_by = record.get("qualified_by")

                    # Show ignored/qualified_ignore tests, especially those with qualification info
                    if status != "ignored" and status != "qualified_ignore" and status != "qualifiedignore":
                        continue

                    rows.append([
                        record.get("test_id"),
                        record.get("test_name"),
                        status,
                        qualified_by ?? "-",
                        record.get("qualified_at") ?? "-",
                        record.get("qualified_reason") ?? "-"
                    ])

                rows = apply_limit(rows, limit)
                format_markdown_table(headers, rows)

    create_text_tool("query_qualified_ignores", "Query qualified ignore records from test database. Params: limit", handler)

# Create all database query tools
pub fn create_db_query_tools() -> List<ToolHandler>:
    [
        create_query_tests_tool(),
        create_query_features_tool(),
        create_query_bugs_tool(),
        create_query_todos_tool(),
        create_query_qualified_ignores_tool()
    ]
