# Erlang Language MCP-MCP Provider

use core.*
use mcp.core.protocol.*
use mcp.multi_lang.*
use mcp.multi_lang.base_provider.*

pub struct ErlangProvider:
    parser: TreeSitterParser

impl ErlangProvider:
    pub fn new() -> ErlangProvider:
        return ErlangProvider { parser: create_parser("erlang") }

impl LanguageProvider for ErlangProvider:
    fn name() -> text:
        return "erlang".to_string()

    fn extensions() -> Array<text>:
        return ["erl".to_string(), "hrl".to_string()]

    fn fold(source: &str, opts: &FoldOptions) -> Result<McpOutput, McpError>:
        var output = McpOutput.new()

        # Parse Erlang code patterns for functions, modules, exports
        var current_line = 0
        for line in source.lines():
            current_line += 1
            val trimmed = line.trim()

            # Module: -module(name).
            if trimmed.starts_with("-module("):
                val start = 8  # len("-module(")
                val end = trimmed.index_of(")").unwrap_or(trimmed.len() as i32)
                val module_name = trimmed.substring(start, end)
                output.add_symbol(Symbol.new(module_name, SymbolKind.Module, current_line))

            # Export: -export([func/arity, ...]).
            elif trimmed.starts_with("-export("):
                # Skip, exports are not symbols themselves
                pass

            # Record: -record(name, {...}).
            elif trimmed.starts_with("-record("):
                val start = 8  # len("-record(")
                val end = trimmed.index_of(",").unwrap_or(trimmed.len() as i32)
                val record_name = trimmed.substring(start, end)
                output.add_symbol(Symbol.new(record_name, SymbolKind.Struct, current_line))

            # Function: name(args) -> or name(args) when Guard ->
            elif trimmed.contains("(") and trimmed.contains("->") and not trimmed.starts_with("-") and not trimmed.starts_with("%"):
                val paren_idx = trimmed.index_of("(").unwrap_or(0)
                val func_name = trimmed.substring(0, paren_idx).trim()
                if func_name.len() > 0 and func_name.chars().next().unwrap_or('A').is_lowercase():
                    output.add_symbol(Symbol.new(func_name, SymbolKind.Function, current_line))

        return Ok(output)

    fn get_symbols(source: &str) -> Result<Array<Symbol>, McpError>:
        return default_get_symbols(source)

    fn get_diagnostics(source: &str) -> Result<Array<Diagnostic>, McpError>:
        return default_get_diagnostics(source)
