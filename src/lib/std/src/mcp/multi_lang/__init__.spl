# Multi-Language MCP-MCP Support
#
# Provides MCP-MCP folding for multiple programming languages using Tree-sitter.
# Unified interface for language-agnostic code representation.
#
# Supported Languages:
#   - Rust
#   - Python
#   - JavaScript/TypeScript
#   - Go
#   - C/C++
#   - Ruby
#   - Erlang
#
# Key Features:
#   - Language auto-detection
#   - Unified folding format
#   - Cross-language workspace support
#   - Language-specific virtual info overlays

use core.*
use mcp.core.protocol.*
use mcp.core.provider.*

# Re-export language providers
pub use mcp.multi_lang.rust.*
pub use mcp.multi_lang.python.*
pub use mcp.multi_lang.javascript.*
pub use mcp.multi_lang.go.*
pub use mcp.multi_lang.c.*
pub use mcp.multi_lang.ruby.*
pub use mcp.multi_lang.erlang.*

# Multi-language MCP-MCP manager
pub struct MultiLangMcp:
    providers: Dict<text, Box<LanguageProvider>>
    auto_detect: bool
    workspace_root: text

# Language provider trait
pub trait LanguageProvider:
    fn name() -> text
    fn extensions() -> Array<text>
    fn fold(source: &str, opts: &FoldOptions) -> Result<McpOutput, McpError>
    fn get_symbols(source: &str) -> Result<Array<Symbol>, McpError>
    fn get_diagnostics(source: &str) -> Result<Array<Diagnostic>, McpError>

# Language type enumeration
pub enum Language:
    Simple
    Rust
    Python
    JavaScript
    TypeScript
    Go
    C
    Cpp
    Ruby
    Erlang
    Unknown

impl Language:
    pub fn from_extension(ext: &str) -> Language:
        match ext:
            case "spl": return Language::Simple
            case "rs": return Language::Rust
            case "py" | "pyi": return Language::Python
            case "js" | "mjs" | "cjs": return Language::JavaScript
            case "ts" | "tsx": return Language::TypeScript
            case "go": return Language::Go
            case "c" | "h": return Language::C
            case "cpp" | "cc" | "cxx" | "hpp": return Language::Cpp
            case "rb": return Language::Ruby
            case "erl" | "hrl": return Language::Erlang
            case _: return Language::Unknown

    pub fn to_string(self) -> text:
        match self:
            case Language::Simple: return "simple".to_string()
            case Language::Rust: return "rust".to_string()
            case Language::Python: return "python".to_string()
            case Language::JavaScript: return "javascript".to_string()
            case Language::TypeScript: return "typescript".to_string()
            case Language::Go: return "go".to_string()
            case Language::C: return "c".to_string()
            case Language::Cpp: return "cpp".to_string()
            case Language::Ruby: return "ruby".to_string()
            case Language::Erlang: return "erlang".to_string()
            case Language::Unknown: return "unknown".to_string()

    pub fn description(self) -> text:
        """Get language description."""
        match self:
            case Language::Simple: return "Simple programming language"
            case Language::Rust: return "Rust systems programming language"
            case Language::Python: return "Python dynamic programming language"
            case Language::JavaScript: return "JavaScript web programming language"
            case Language::TypeScript: return "TypeScript statically-typed JavaScript"
            case Language::Go: return "Go systems programming language"
            case Language::C: return "C systems programming language"
            case Language::Cpp: return "C++ systems programming language"
            case Language::Ruby: return "Ruby dynamic programming language"
            case Language::Erlang: return "Erlang functional programming language"
            case Language::Unknown: return "Unknown or unsupported language"

    pub fn is_simple(self) -> bool:
        """Check if language is Simple."""
        match self:
            case Language::Simple: true
            case _: false

    pub fn is_rust(self) -> bool:
        """Check if language is Rust."""
        match self:
            case Language::Rust: true
            case _: false

    pub fn is_python(self) -> bool:
        """Check if language is Python."""
        match self:
            case Language::Python: true
            case _: false

    pub fn is_javascript(self) -> bool:
        """Check if language is JavaScript."""
        match self:
            case Language::JavaScript: true
            case _: false

    pub fn is_typescript(self) -> bool:
        """Check if language is TypeScript."""
        match self:
            case Language::TypeScript: true
            case _: false

    pub fn is_go(self) -> bool:
        """Check if language is Go."""
        match self:
            case Language::Go: true
            case _: false

    pub fn is_c(self) -> bool:
        """Check if language is C."""
        match self:
            case Language::C: true
            case _: false

    pub fn is_cpp(self) -> bool:
        """Check if language is C++."""
        match self:
            case Language::Cpp: true
            case _: false

    pub fn is_ruby(self) -> bool:
        """Check if language is Ruby."""
        match self:
            case Language::Ruby: true
            case _: false

    pub fn is_erlang(self) -> bool:
        """Check if language is Erlang."""
        match self:
            case Language::Erlang: true
            case _: false

    pub fn is_unknown(self) -> bool:
        """Check if language is Unknown."""
        match self:
            case Language::Unknown: true
            case _: false

    pub fn is_systems_language(self) -> bool:
        """Check if language is systems programming language."""
        match self:
            case Language::Rust: true
            case Language::Go: true
            case Language::C: true
            case Language::Cpp: true
            case _: false

    pub fn is_dynamic_language(self) -> bool:
        """Check if language is dynamically typed."""
        match self:
            case Language::Python: true
            case Language::JavaScript: true
            case Language::Ruby: true
            case Language::Erlang: true
            case _: false

    pub fn is_static_language(self) -> bool:
        """Check if language is statically typed."""
        match self:
            case Language::Simple: true
            case Language::Rust: true
            case Language::TypeScript: true
            case Language::Go: true
            case Language::C: true
            case Language::Cpp: true
            case _: false

    pub fn is_functional(self) -> bool:
        """Check if language has strong functional programming support."""
        match self:
            case Language::Erlang: true
            case Language::Rust: true
            case _: false

    pub fn is_web_language(self) -> bool:
        """Check if language is commonly used for web development."""
        match self:
            case Language::JavaScript: true
            case Language::TypeScript: true
            case Language::Python: true
            case Language::Ruby: true
            case _: false

    pub fn summary(self) -> text:
        """Get language summary."""
        val name = self.to_string()
        val desc = self.description()
        var props = []
        if self.is_systems_language():
            props.push("systems")
        if self.is_dynamic_language():
            props.push("dynamic")
        if self.is_static_language():
            props.push("static")
        if self.is_functional():
            props.push("functional")
        if self.is_web_language():
            props.push("web")
        if props.len() > 0:
            val props_str = ", ".join(props)
            return "Language: {name} ({desc}, {props_str})"
        else:
            return "Language: {name} ({desc})"

# Symbol information
pub struct Symbol:
    pub name: text
    pub kind: SymbolKind
    pub range: Range
    pub signature: Option<text>
    pub visibility: Visibility

pub enum SymbolKind:
    Function
    Class
    Struct
    Enum
    Trait
    Method
    Field
    Variable
    Constant
    Module

impl SymbolKind:
    pub fn is_function(self) -> bool:
        """Check if this is Function kind."""
        match self:
            case Function: true
            case _: false

    pub fn is_class(self) -> bool:
        """Check if this is Class kind."""
        match self:
            case Class: true
            case _: false

    pub fn is_struct(self) -> bool:
        """Check if this is Struct kind."""
        match self:
            case Struct: true
            case _: false

    pub fn is_enum(self) -> bool:
        """Check if this is Enum kind."""
        match self:
            case Enum: true
            case _: false

    pub fn is_trait(self) -> bool:
        """Check if this is Trait kind."""
        match self:
            case Trait: true
            case _: false

    pub fn is_method(self) -> bool:
        """Check if this is Method kind."""
        match self:
            case Method: true
            case _: false

    pub fn is_field(self) -> bool:
        """Check if this is Field kind."""
        match self:
            case Field: true
            case _: false

    pub fn is_variable(self) -> bool:
        """Check if this is Variable kind."""
        match self:
            case Variable: true
            case _: false

    pub fn is_constant(self) -> bool:
        """Check if this is Constant kind."""
        match self:
            case Constant: true
            case _: false

    pub fn is_module(self) -> bool:
        """Check if this is Module kind."""
        match self:
            case Module: true
            case _: false

    pub fn is_type_def(self) -> bool:
        """Check if symbol is a type definition."""
        match self:
            case Class: true
            case Struct: true
            case Enum: true
            case Trait: true
            case _: false

    pub fn is_callable(self) -> bool:
        """Check if symbol is callable."""
        match self:
            case Function: true
            case Method: true
            case _: false

    pub fn is_data_member(self) -> bool:
        """Check if symbol is a data member."""
        match self:
            case Field: true
            case Variable: true
            case Constant: true
            case _: false

    pub fn to_string(self) -> text:
        """Convert to string."""
        match self:
            case Function: "function"
            case Class: "class"
            case Struct: "struct"
            case Enum: "enum"
            case Trait: "trait"
            case Method: "method"
            case Field: "field"
            case Variable: "variable"
            case Constant: "constant"
            case Module: "module"

    pub fn description(self) -> text:
        """Get description."""
        match self:
            case Function: "Function definition"
            case Class: "Class definition"
            case Struct: "Struct definition"
            case Enum: "Enum definition"
            case Trait: "Trait definition"
            case Method: "Method definition"
            case Field: "Field member"
            case Variable: "Variable declaration"
            case Constant: "Constant declaration"
            case Module: "Module definition"

    pub fn summary(self) -> text:
        """Get summary."""
        val name = self.to_string()
        val desc = self.description()
        var cats = []
        if self.is_type_def():
            cats.push("type")
        if self.is_callable():
            cats.push("callable")
        if self.is_data_member():
            cats.push("data")
        val cats_str = if cats.len() > 0: ", " + cats.join(", ") else: ""
        "SymbolKind: {name} ({desc}{cats_str})"

pub enum Visibility:
    Public
    Private
    Protected
    Internal

impl Visibility:
    pub fn is_public(self) -> bool:
        """Check if this is Public visibility."""
        match self:
            case Public: true
            case _: false

    pub fn is_private(self) -> bool:
        """Check if this is Private visibility."""
        match self:
            case Private: true
            case _: false

    pub fn is_protected(self) -> bool:
        """Check if this is Protected visibility."""
        match self:
            case Protected: true
            case _: false

    pub fn is_internal(self) -> bool:
        """Check if this is Internal visibility."""
        match self:
            case Internal: true
            case _: false

    pub fn is_restricted(self) -> bool:
        """Check if access is restricted."""
        match self:
            case Public: false
            case _: true

    pub fn allows_external_access(self) -> bool:
        """Check if allows external package access."""
        match self:
            case Public: true
            case _: false

    pub fn to_string(self) -> text:
        """Convert to string."""
        match self:
            case Public: "public"
            case Private: "private"
            case Protected: "protected"
            case Internal: "internal"

    pub fn description(self) -> text:
        """Get description."""
        match self:
            case Public: "Accessible everywhere"
            case Private: "Accessible only within defining scope"
            case Protected: "Accessible in derived classes"
            case Internal: "Accessible within package"

    pub fn summary(self) -> text:
        """Get summary."""
        val name = self.to_string()
        val desc = self.description()
        val access = if self.is_restricted(): "restricted" else: "unrestricted"
        "Visibility: {name} ({desc}, {access})"

# Diagnostic information
pub struct Diagnostic:
    pub severity: DiagnosticSeverity
    pub range: Range
    pub message: text
    pub code: Option<text>

pub enum DiagnosticSeverity:
    Error
    Warning
    Info
    Hint

impl DiagnosticSeverity:
    pub fn is_error(self) -> bool:
        """Check if this is Error severity."""
        match self:
            case Error: true
            case _: false

    pub fn is_warning(self) -> bool:
        """Check if this is Warning severity."""
        match self:
            case Warning: true
            case _: false

    pub fn is_info(self) -> bool:
        """Check if this is Info severity."""
        match self:
            case Info: true
            case _: false

    pub fn is_hint(self) -> bool:
        """Check if this is Hint severity."""
        match self:
            case Hint: true
            case _: false

    pub fn is_critical(self) -> bool:
        """Check if diagnostic is critical (Error or Warning)."""
        match self:
            case Error: true
            case Warning: true
            case _: false

    pub fn is_informational(self) -> bool:
        """Check if diagnostic is informational (Info or Hint)."""
        match self:
            case Info: true
            case Hint: true
            case _: false

    pub fn to_string(self) -> text:
        """Convert to string."""
        match self:
            case Error: "error"
            case Warning: "warning"
            case Info: "info"
            case Hint: "hint"

    pub fn description(self) -> text:
        """Get description."""
        match self:
            case Error: "Compilation error"
            case Warning: "Compilation warning"
            case Info: "Informational message"
            case Hint: "Code improvement hint"

    pub fn summary(self) -> text:
        """Get summary."""
        val name = self.to_string()
        val desc = self.description()
        val level = if self.is_critical(): "critical" else: "informational"
        "DiagnosticSeverity: {name} ({desc}, {level})"

# Source code range
pub struct Range:
    pub start: Position
    pub end: Position

pub struct Position:
    pub line: u32
    pub column: u32

# =============================================================================
# MultiLangMcp Implementation
# =============================================================================

impl MultiLangMcp:
    # Create new multi-language MCP manager
    pub fn new(workspace_root: &str) -> MultiLangMcp:
        var providers: Dict<text, Box<LanguageProvider>> = Dict::new()

        # Register language providers
        providers.insert("rust".to_string(), Box::new(RustProvider::new()))
        providers.insert("python".to_string(), Box::new(PythonProvider::new()))
        providers.insert("javascript".to_string(), Box::new(JavaScriptProvider::new()))
        providers.insert("typescript".to_string(), Box::new(JavaScriptProvider::new()))  # Reuse JS provider
        providers.insert("go".to_string(), Box::new(GoProvider::new()))
        providers.insert("c".to_string(), Box::new(CProvider::new()))
        providers.insert("cpp".to_string(), Box::new(CProvider::new()))  # Reuse C provider
        providers.insert("ruby".to_string(), Box::new(RubyProvider::new()))
        providers.insert("erlang".to_string(), Box::new(ErlangProvider::new()))

        return MultiLangMcp {
            providers: providers,
            auto_detect: true,
            workspace_root: workspace_root.to_string()
        }

    # Fold source code with language auto-detection
    pub fn fold_auto(self, file_path: &str, source: &str, opts: &FoldOptions)
        -> Result<McpOutput, McpError>:

        val lang = self.detect_language(file_path)
        return self.fold_with_language(lang, source, opts)

    # Fold source code with explicit language
    pub fn fold_with_language(self, lang: Language, source: &str, opts: &FoldOptions)
        -> Result<McpOutput, McpError>:

        val lang_name = lang.to_string()

        if val Some(provider) = self.providers.get(&lang_name):
            return provider.fold(source, opts)

        return Err(McpError::UnsupportedLanguage(lang_name))

    # Detect language from file path
    pub fn detect_language(self, file_path: &str) -> Language:
        if not self.auto_detect:
            return Language::Unknown

        # Extract extension
        if val Some(dot_pos) = file_path.rfind('.'):
            val ext = &file_path[dot_pos + 1..]
            return Language::from_extension(ext)

        return Language::Unknown

    # Get all symbols from source
    pub fn get_symbols(self, file_path: &str, source: &str)
        -> Result<Array<Symbol>, McpError>:

        val lang = self.detect_language(file_path)
        val lang_name = lang.to_string()

        if val Some(provider) = self.providers.get(&lang_name):
            return provider.get_symbols(source)

        return Err(McpError::UnsupportedLanguage(lang_name))

    # Get diagnostics from source
    pub fn get_diagnostics(self, file_path: &str, source: &str)
        -> Result<Array<Diagnostic>, McpError>:

        val lang = self.detect_language(file_path)
        val lang_name = lang.to_string()

        if val Some(provider) = self.providers.get(&lang_name):
            return provider.get_diagnostics(source)

        return Ok([])  # Default: no diagnostics

    # Fold entire workspace (multi-language)
    pub fn fold_workspace(self, paths: &Array<text>, opts: &FoldOptions)
        -> Result<McpOutput, McpError>:

        var combined_output = McpOutput::new()

        for path in paths:
            # Read file
            val source = read_file_to_string(path)?

            # Fold with auto-detection
            val output = self.fold_auto(path, &source, opts)?

            # Merge into combined output
            combined_output.merge(output)

        return Ok(combined_output)

    # Search across multiple languages
    pub fn multi_language_search(self, query: &str, paths: &Array<text>)
        -> Result<Array<SearchResult>, McpError>:

        var results: Array<SearchResult> = []

        for path in paths:
            val source = read_file_to_string(path)?
            val symbols = self.get_symbols(path, &source)?

            # Filter symbols matching query
            for symbol in symbols:
                if symbol.name.contains(query):
                    results.push(SearchResult {
                        file_path: path.clone(),
                        symbol: symbol,
                        language: self.detect_language(path)
                    })

        return Ok(results)

# Search result
pub struct SearchResult:
    pub file_path: text
    pub symbol: Symbol
    pub language: Language

# Helper: Read file to string
fn read_file_to_string(path: &str) -> Result<text, McpError>:
    """Read file contents as UTF-8 string."""
    @extern("runtime", "rt_file_read_text")
    fn _rt_file_read_text(path_ptr: &u8, path_len: u64) -> Any

    val result = _rt_file_read_text(path.ptr(), path.len())
    if result.is_nil():
        return Err(McpError::IoError("Failed to read file: " + path))
    else:
        return Ok(result as text)

# MCP Error types
pub enum McpError:
    UnsupportedLanguage(text)
    ParseError(text)
    IoError(text)

impl McpError:
    pub fn to_string(self) -> text:
        match self:
            case McpError::UnsupportedLanguage(lang):
                return format("Unsupported language: {}", lang)
            case McpError::ParseError(msg):
                return format("Parse error: {}", msg)
            case McpError::IoError(msg):
                return format("IO error: {}", msg)

    pub fn description(self) -> text:
        """Get error description."""
        match self:
            case McpError::UnsupportedLanguage(_):
                return "Language is not supported by MCP server"
            case McpError::ParseError(_):
                return "Failed to parse source code"
            case McpError::IoError(_):
                return "Input/output operation failed"

    pub fn is_unsupported_language(self) -> bool:
        """Check if error is UnsupportedLanguage."""
        match self:
            case McpError::UnsupportedLanguage(_): true
            case _: false

    pub fn is_parse_error(self) -> bool:
        """Check if error is ParseError."""
        match self:
            case McpError::ParseError(_): true
            case _: false

    pub fn is_io_error(self) -> bool:
        """Check if error is IoError."""
        match self:
            case McpError::IoError(_): true
            case _: false

    pub fn is_recoverable(self) -> bool:
        """Check if error might be recoverable."""
        match self:
            case McpError::UnsupportedLanguage(_): false
            case McpError::ParseError(_): false
            case McpError::IoError(_): true

    pub fn is_user_error(self) -> bool:
        """Check if error is likely due to user input."""
        match self:
            case McpError::UnsupportedLanguage(_): true
            case McpError::ParseError(_): true
            case McpError::IoError(_): false

    pub fn summary(self) -> text:
        """Get error summary."""
        val name = self.to_string()
        val desc = self.description()
        var props = []
        if self.is_recoverable():
            props.push("recoverable")
        else:
            props.push("non-recoverable")
        if self.is_user_error():
            props.push("user-error")
        if props.len() > 0:
            val props_str = ", ".join(props)
            return "McpError: {name} ({desc}, {props_str})"
        else:
            return "McpError: {name} ({desc})"
