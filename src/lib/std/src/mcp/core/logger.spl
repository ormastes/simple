# MCP File-based Logger
# Provides structured logging to files for debugging without interfering with stdio transport

# Note: File I/O functions would need to be implemented or mocked for testing
# For now, we'll use a simplified approach that works in the interpreter

# Log levels
pub enum LogLevel:
    Trace
    Debug
    Info
    Warn
    Error
    Fatal

impl LogLevel:
    pub fn to_string() -> text:
        match self:
            case LogLevel.Trace: "TRACE"
            case LogLevel.Debug: "DEBUG"
            case LogLevel.Info: "INFO"
            case LogLevel.Warn: "WARN"
            case LogLevel.Error: "ERROR"
            case LogLevel.Fatal: "FATAL"

    pub fn to_priority() -> i64:
        match self:
            case LogLevel.Trace: 0
            case LogLevel.Debug: 1
            case LogLevel.Info: 2
            case LogLevel.Warn: 3
            case LogLevel.Error: 4
            case LogLevel.Fatal: 5

# Logger configuration
pub class McpLogger:
    pub file_path: text
    pub min_level: LogLevel
    pub enabled: bool
    pub max_file_size: i64  # Max log file size in bytes (default 10MB)
    pub current_size: i64
    pub buffer: List<text>  # Buffer for batching writes
    pub buffer_size: i64    # Max buffer entries before flush (default 10)

    static fn new(file_path: text) -> McpLogger:
        return McpLogger(
            file_path: file_path,
            min_level: LogLevel.Debug,
            enabled: true,
            max_file_size: 10_000_000,  # 10MB
            current_size: 0,
            buffer: [],
            buffer_size: 10
        )

    static fn with_level(level: LogLevel) -> McpLogger:
        var logger = McpLogger.new("")
        logger.min_level = level
        logger

    pub me disable():
        self.enabled = false

    pub me enable():
        self.enabled = true

    pub me set_max_size(size: i64):
        self.max_file_size = size

    pub me set_buffer_size(size: i64):
        self.buffer_size = size

    # Initialize log file (create if doesn't exist)
    pub fn initialize() -> Result<(), text>:
        if self.file_path == "":
            return Ok(())

        # TODO: File I/O not yet implemented in interpreter
        # For now, just mark as initialized
        Ok(())

    # Get current timestamp
    fn get_timestamp() -> text:
        # TODO: Use proper datetime when available
        # For now, use a simple counter-based approach
        "timestamp"

    # Format log entry
    fn format_entry(level: LogLevel, message: text, context: Dict<text, text>) -> text:
        var entry = "[{self.get_timestamp()}] [{level.to_string()}] {message}"

        # Add context if present
        if not context.is_empty():
            entry = entry + " | Context: "
            var first = true
            for key in context.keys():
                if not first:
                    entry = entry + ", "
                entry = entry + "{key}={context.get(key)}"
                first = false

        entry + "\n"

    # Write to file (with rotation check)
    me write_to_file(content: text) -> Result<(), text>:
        if self.file_path == "":
            return Ok(())

        # Check file size and rotate if needed
        if self.current_size > self.max_file_size:
            self.rotate_log()?

        # TODO: File I/O not yet implemented
        # For now, just track size
        self.current_size = self.current_size + content.len()
        Ok(())

    # Rotate log file
    me rotate_log() -> Result<(), text>:
        # Rename current log with timestamp
        val backup_path = "{self.file_path}.old"

        # TODO: Use proper file rename when available
        # For now, just reset size and truncate
        self.current_size = 0

        # Write rotation marker
        val marker = "\n=== Log Rotated at {self.get_timestamp()} ===\n\n"
        self.write_to_file(marker)

    # Flush buffered logs
    pub me flush() -> Result<(), text>:
        if self.buffer.is_empty():
            return Ok(())

        var combined = ""
        for entry in self.buffer:
            combined = combined + entry

        self.buffer = []
        self.write_to_file(combined)

    # Log with context
    pub me log_with_context(level: LogLevel, message: text, context: Dict<text, text>):
        if not self.enabled:
            return

        if level.to_priority() < self.min_level.to_priority():
            return

        val entry = self.format_entry(level, message, context)

        # Add to buffer
        self.buffer = self.buffer + [entry]

        # Flush if buffer is full or level is error/fatal
        if self.buffer.len() >= self.buffer_size or level.to_priority() >= LogLevel.Error.to_priority():
            match self.flush():
                case Ok(_):
                    pass
                case Err(e):
                    # Failed to flush - write to stderr as fallback
                    stderr_write("[MCP-Logger] Failed to flush: {e}\n")
                    stderr_flush()

    # Convenience methods
    pub me trace(message: text):
        self.log_with_context(LogLevel.Trace, message, {})

    pub me debug(message: text):
        self.log_with_context(LogLevel.Debug, message, {})

    pub me info(message: text):
        self.log_with_context(LogLevel.Info, message, {})

    pub me warn(message: text):
        self.log_with_context(LogLevel.Warn, message, {})

    pub me error(message: text):
        self.log_with_context(LogLevel.Error, message, {})

    pub me fatal(message: text):
        self.log_with_context(LogLevel.Fatal, message, {})

    # Log with context dict
    pub me trace_ctx(message: text, context: Dict<text, text>):
        self.log_with_context(LogLevel.Trace, message, context)

    pub me debug_ctx(message: text, context: Dict<text, text>):
        self.log_with_context(LogLevel.Debug, message, context)

    pub me info_ctx(message: text, context: Dict<text, text>):
        self.log_with_context(LogLevel.Info, message, context)

    pub me warn_ctx(message: text, context: Dict<text, text>):
        self.log_with_context(LogLevel.Warn, message, context)

    pub me error_ctx(message: text, context: Dict<text, text>):
        self.log_with_context(LogLevel.Error, message, context)

    pub me fatal_ctx(message: text, context: Dict<text, text>):
        self.log_with_context(LogLevel.Fatal, message, context)

# Global logger instance (thread-safe singleton pattern)
var GLOBAL_LOGGER: Option<McpLogger> = None

# Initialize global logger
pub fn init_logger(file_path: text) -> Result<(), text>:
    var logger = McpLogger.new(file_path)
    match logger.initialize():
        case Ok(_):
            GLOBAL_LOGGER = Some(logger)
            Ok(())
        case Err(e):
            Err(e)

# Get global logger (creates if not exists)
pub fn get_logger() -> McpLogger:
    match GLOBAL_LOGGER:
        case Some(logger):
            return logger
        case None:
            # Create disabled logger as fallback
            var logger = McpLogger.new("")
            logger.disable()
            return logger

# Convenience functions using global logger
pub fn log_trace(message: text):
    get_logger().trace(message)

pub fn log_debug(message: text):
    get_logger().debug(message)

pub fn log_info(message: text):
    get_logger().info(message)

pub fn log_warn(message: text):
    get_logger().warn(message)

pub fn log_error(message: text):
    get_logger().error(message)

pub fn log_fatal(message: text):
    get_logger().fatal(message)

# Context versions
pub fn log_trace_ctx(message: text, context: Dict<text, text>):
    get_logger().trace_ctx(message, context)

pub fn log_debug_ctx(message: text, context: Dict<text, text>):
    get_logger().debug_ctx(message, context)

pub fn log_info_ctx(message: text, context: Dict<text, text>):
    get_logger().info_ctx(message, context)

pub fn log_warn_ctx(message: text, context: Dict<text, text>):
    get_logger().warn_ctx(message, context)

pub fn log_error_ctx(message: text, context: Dict<text, text>):
    get_logger().error_ctx(message, context)

pub fn log_fatal_ctx(message: text, context: Dict<text, text>):
    get_logger().fatal_ctx(message, context)

# Flush global logger
pub fn flush_logs() -> Result<(), text>:
    match GLOBAL_LOGGER:
        case Some(logger):
            logger.flush()
        case None:
            Ok(())

# Extern functions
extern fn stderr_write(s: text)
extern fn stderr_flush()
