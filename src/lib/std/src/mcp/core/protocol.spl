# MCP Core Protocol Types
# Model Context Protocol - Generic message types for any language/tool

use core.*

# JSON-RPC 2.0 Request
pub class JsonRpcRequest:
    pub jsonrpc: text  # Always "2.0"
    pub id: i64
    pub method: text
    pub params: Dict<text, Any>

    pub fn new(id: i64, method: text, params: Dict<text, Any>) -> JsonRpcRequest:
        return JsonRpcRequest(jsonrpc: "2.0", id: id, method: method, params: params)

# JSON-RPC 2.0 Response (success)
pub class JsonRpcResponse:
    pub jsonrpc: text  # Always "2.0"
    pub id: i64
    pub result: Any

    pub fn new(id: i64, result: Any) -> JsonRpcResponse:
        return JsonRpcResponse(jsonrpc: "2.0", id: id, result: result)

# JSON-RPC 2.0 Error Response
pub class JsonRpcError:
    pub jsonrpc: text  # Always "2.0"
    pub id: i64
    pub error: ErrorObject

    pub fn new(id: i64, error: ErrorObject) -> JsonRpcError:
        return JsonRpcError(jsonrpc: "2.0", id: id, error: error)

# Error object
pub class ErrorObject:
    pub code: i64
    pub message: text
    pub data: Option<Any>

    pub fn new(code: i64, message: text) -> ErrorObject:
        return ErrorObject(code: code, message: message, data: nil)

# MCP Resource - Represents a code resource (file, symbol, etc.)
pub class Resource:
    pub uri: text           # Unique identifier (file://, symbol://, etc.)
    pub name: text          # Human-readable name
    pub description: text   # Optional description
    pub mime_type: text     # MIME type (text/x-simple, text/x-rust, etc.)

    pub fn new(uri: text, name: text, mime_type: text) -> Resource:
        return Resource(uri: uri, name: name, description: "", mime_type: mime_type)

# MCP Tool - Represents an executable tool/function
pub class Tool:
    pub name: text          # Tool name (e.g., "read_code", "expand_symbol")
    pub description: text   # What the tool does
    pub input_schema: Dict<text, Any>  # JSON schema for parameters

    pub fn new(name: text, description: text) -> Tool:
        return Tool(name: name, description: description, input_schema: {})

# MCP Prompt - Represents a prompt template
pub class Prompt:
    pub name: text
    pub description: text
    pub arguments: List<PromptArgument>

    pub fn new(name: text, description: text) -> Prompt:
        return Prompt(name: name, description: description, arguments: [])

# Prompt argument
pub class PromptArgument:
    pub name: text
    pub description: text
    pub required: bool

    pub fn new(name: text, description: text, required: bool) -> PromptArgument:
        return PromptArgument(name: name, description: description, required: required)

# Resource contents
pub class ResourceContents:
    pub uri: text
    pub mime_type: text
    pub text: text           # For text resources
    pub blob: Option<List<u8>> # For binary resources

    pub fn new(uri: text, mime_type: text, text: text) -> ResourceContents:
        return ResourceContents(uri: uri, mime_type: mime_type, text: text, blob: nil)

# Tool call result
pub class ToolResult:
    pub content: List<ContentBlock>
    pub is_error: bool

    pub fn new(text: text) -> ToolResult:
        val block = ContentBlock.text(text)
        return ToolResult(content: [block], is_error: false)

    pub fn error(message: text) -> ToolResult:
        val block = ContentBlock.text(message)
        return ToolResult(content: [block], is_error: true)

# Content block (text, image, resource)
pub enum ContentBlock:
    Text(text)
    Image(ImageData)
    Resource(ResourceContents)

    pub fn text(content: text) -> ContentBlock:
        return ContentBlock.Text(content)

    pub fn to_string(self) -> text:
        """Convert content block to string."""
        match self:
            case Text(_): "text"
            case Image(_): "image"
            case Resource(_): "resource"

    pub fn description(self) -> text:
        """Get content block description."""
        match self:
            case Text(_): "Text content block"
            case Image(_): "Image content block"
            case Resource(_): "Resource content block"

    pub fn is_text(self) -> bool:
        """Check if block is Text."""
        match self:
            case Text(_): true
            case _: false

    pub fn is_image(self) -> bool:
        """Check if block is Image."""
        match self:
            case Image(_): true
            case _: false

    pub fn is_resource(self) -> bool:
        """Check if block is Resource."""
        match self:
            case Resource(_): true
            case _: false

    pub fn summary(self) -> text:
        """Get content block summary."""
        val type_name = self.to_string()
        val desc = self.description()
        return "ContentBlock: {type_name} ({desc})"

# Image data
pub class ImageData:
    pub mime_type: text
    pub data: text  # Base64 encoded

    pub fn new(mime_type: text, data: text) -> ImageData:
        return ImageData(mime_type: mime_type, data: data)

# Standard MCP methods
pub enum McpMethod:
    Initialize
    Ping
    ListResources
    ReadResource
    ListTools
    CallTool
    ListPrompts
    GetPrompt

    pub fn to_string(self) -> text:
        if self == McpMethod.Initialize:
            return "initialize"
        elif self == McpMethod.Ping:
            return "ping"
        elif self == McpMethod.ListResources:
            return "resources/list"
        elif self == McpMethod.ReadResource:
            return "resources/read"
        elif self == McpMethod.ListTools:
            return "tools/list"
        elif self == McpMethod.CallTool:
            return "tools/call"
        elif self == McpMethod.ListPrompts:
            return "prompts/list"
        elif self == McpMethod.GetPrompt:
            return "prompts/get"
        else:
            return "unknown"

    pub fn description(self) -> text:
        """Get MCP method description."""
        match self:
            case Initialize: "Initialize MCP connection"
            case Ping: "Ping server to check connection"
            case ListResources: "List available resources"
            case ReadResource: "Read a specific resource"
            case ListTools: "List available tools"
            case CallTool: "Execute a tool"
            case ListPrompts: "List available prompts"
            case GetPrompt: "Get a specific prompt"

    pub fn is_initialize(self) -> bool:
        """Check if method is Initialize."""
        match self:
            case Initialize: true
            case _: false

    pub fn is_ping(self) -> bool:
        """Check if method is Ping."""
        match self:
            case Ping: true
            case _: false

    pub fn is_list_resources(self) -> bool:
        """Check if method is ListResources."""
        match self:
            case ListResources: true
            case _: false

    pub fn is_read_resource(self) -> bool:
        """Check if method is ReadResource."""
        match self:
            case ReadResource: true
            case _: false

    pub fn is_list_tools(self) -> bool:
        """Check if method is ListTools."""
        match self:
            case ListTools: true
            case _: false

    pub fn is_call_tool(self) -> bool:
        """Check if method is CallTool."""
        match self:
            case CallTool: true
            case _: false

    pub fn is_list_prompts(self) -> bool:
        """Check if method is ListPrompts."""
        match self:
            case ListPrompts: true
            case _: false

    pub fn is_get_prompt(self) -> bool:
        """Check if method is GetPrompt."""
        match self:
            case GetPrompt: true
            case _: false

    pub fn is_resource_method(self) -> bool:
        """Check if method is resource-related."""
        match self:
            case ListResources: true
            case ReadResource: true
            case _: false

    pub fn is_tool_method(self) -> bool:
        """Check if method is tool-related."""
        match self:
            case ListTools: true
            case CallTool: true
            case _: false

    pub fn is_prompt_method(self) -> bool:
        """Check if method is prompt-related."""
        match self:
            case ListPrompts: true
            case GetPrompt: true
            case _: false

    pub fn is_list_method(self) -> bool:
        """Check if method is a list operation."""
        match self:
            case ListResources: true
            case ListTools: true
            case ListPrompts: true
            case _: false

    pub fn summary(self) -> text:
        """Get MCP method summary."""
        val name = self.to_string()
        val desc = self.description()
        val category = if self.is_initialize():
            "initialization"
        elif self.is_ping():
            "health-check"
        elif self.is_resource_method():
            "resources"
        elif self.is_tool_method():
            "tools"
        elif self.is_prompt_method():
            "prompts"
        else:
            "unknown"
        return "McpMethod: {name} ({desc}, category={category})"

# Server capabilities
pub class ServerCapabilities:
    pub resources: bool
    pub tools: bool
    pub prompts: bool

    pub fn default() -> ServerCapabilities:
        return ServerCapabilities(resources: true, tools: true, prompts: false)

# Initialize result
pub class InitializeResult:
    pub protocol_version: text
    pub capabilities: ServerCapabilities
    pub server_info: ServerInfo

    pub fn new(name: text, version: text) -> InitializeResult:
        return InitializeResult(protocol_version: "2024-11-05", capabilities: ServerCapabilities.default(), server_info: ServerInfo.new(name, version))

# Server info
pub class ServerInfo:
    pub name: text
    pub version: text

    pub fn new(name: text, version: text) -> ServerInfo:
        return ServerInfo(name: name, version: version)
