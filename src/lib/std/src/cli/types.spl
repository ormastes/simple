# CLI Types - Argument specification types

# Note: Types are already declared as pub below, no need for pub use

# Argument types
pub enum ArgType:
    Flag
    Option
    Positional
    FileOption
    FilePositional

impl ArgType:
    # Convert argument type to string
    pub fn to_string(self) -> text:
        match self:
            case Flag: return "Flag"
            case Option: return "Option"
            case Positional: return "Positional"
            case FileOption: return "FileOption"
            case FilePositional: return "FilePositional"

    # Get detailed description of argument type
    pub fn description(self) -> text:
        match self:
            case Flag: return "Boolean flag"
            case Option: return "text option"
            case Positional: return "Positional string argument"
            case FileOption: return "File option (auto-staged)"
            case FilePositional: return "File positional argument (auto-staged)"

    # Check if this is a Flag type
    pub fn is_flag(self) -> bool:
        match self:
            case Flag: true
            case _: false

    # Check if this is an Option type
    pub fn is_option(self) -> bool:
        match self:
            case Option: true
            case _: false

    # Check if this is a Positional type
    pub fn is_positional(self) -> bool:
        match self:
            case Positional: true
            case _: false

    # Check if this is a FileOption type
    pub fn is_file_option(self) -> bool:
        match self:
            case FileOption: true
            case _: false

    # Check if this is a FilePositional type
    pub fn is_file_positional(self) -> bool:
        match self:
            case FilePositional: true
            case _: false

    # Check if this is a file-related type
    pub fn is_file_type(self) -> bool:
        match self:
            case FileOption: true
            case FilePositional: true
            case _: false

    # Check if this argument type requires a value
    pub fn requires_value(self) -> bool:
        match self:
            case Flag: false
            case _: true

    # Get argument type summary
    pub fn summary(self) -> text:
        val name = self.to_string()
        val desc = self.description()
        var props = []
        if self.requires_value():
            props.push("requires value")
        else:
            props.push("no value")
        if self.is_file_type():
            props.push("file type")
        val props_str = props.join(", ")
        return "ArgType: {name} ({desc}, {props_str})"

# Argument specification
pub struct ArgSpec:
    name: text
    short: Option<text>
    long: text
    help: text
    required: bool
    default_value: Option<text>
    arg_type: ArgType
    auto_stage: bool
    must_exist: bool
    must_be_readable: bool
    must_be_writable: bool
    allowed_extensions: Array<text>

impl ArgSpec:
    # Check if has short name
    pub fn has_short(self) -> bool:
        return self.short.is_some()

    # Check if has default value
    pub fn has_default(self) -> bool:
        return self.default_value.is_some()

    # Check if argument is required
    pub fn is_required(self) -> bool:
        return self.required

    # Check if argument is optional
    pub fn is_optional(self) -> bool:
        return not self.required

    # Check if this is a file argument type
    pub fn is_file_type(self) -> bool:
        return self.arg_type.is_file_type()

    # Check if auto-staging is enabled
    pub fn is_auto_stage_enabled(self) -> bool:
        return self.auto_stage

    # Check if file must exist
    pub fn has_existence_check(self) -> bool:
        return self.must_exist

    # Check if file must be readable
    pub fn has_read_check(self) -> bool:
        return self.must_be_readable

    # Check if file must be writable
    pub fn has_write_check(self) -> bool:
        return self.must_be_writable

    # Check if has extension restrictions
    pub fn has_extension_restrictions(self) -> bool:
        return self.allowed_extensions.len() > 0

    # Get count of allowed extensions
    pub fn extension_count(self) -> usize:
        return self.allowed_extensions.len()

    # Check if extension is allowed
    pub fn allows_extension(self, ext: text) -> bool:
        if self.allowed_extensions.len() == 0:
            return true
        for allowed in &self.allowed_extensions:
            if allowed == ext:
                return true
        return false

    # Get summary of argument spec
    pub fn summary(self) -> text:
        val req = if self.required: "required" else: "optional"
        val short_str = if self.has_short(): " (-{self.short.unwrap()})" else: ""
        return "ArgSpec: --{self.long}{short_str}, {self.arg_type.to_string()}, {req}"

# Subcommand specification
pub struct SubcommandSpec:
    name: text
    description: text
    aliases: Array<text>

impl SubcommandSpec:
    # Create a new subcommand specification
    static fn new(name: text, description: text) -> SubcommandSpec:
        return SubcommandSpec {
            name: name,
            description: description,
            aliases: []
        }

    # Add an alias for this subcommand
    pub fn with_alias(mut self, alias: text) -> SubcommandSpec:
        self.aliases.push(alias)
        return self

    # Check if input matches this subcommand name or any alias
    pub fn matches(self, input: text) -> bool:
        if input == self.name:
            return true
        for alias in &self.aliases:
            if input == alias:
                return true
        return false

    # Check if subcommand has any aliases
    pub fn has_aliases(self) -> bool:
        return self.aliases.len() > 0

    # Get summary of subcommand spec
    pub fn summary(self) -> text:
        val alias_str = if self.has_aliases(): " (aliases: " + self.aliases.join(", ") + ")" else: ""
        return "SubcommandSpec: {self.name}{alias_str} - {self.description}"
