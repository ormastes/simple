# CLI File Validation - File argument validation and staging utilities
#
# Supports both sync and async modes:
# - Sync mode (default): Validates paths only, no file loading
# - Async mode (via ArgParser.with_async_loading): Starts background loading during parse

# Extern declarations for file system FFI
extern fn rt_file_exists(path: text) -> bool
extern fn rt_file_canonicalize(path: text) -> text

import units.core.Count

# Import async file handle types for background loading
use std.file.{AsyncFileHandle, FileState, MmapRegion, OpenOptions, FileError}

# File validation result
pub enum FileValidation:
    Valid(text)
    NotFound(text)
    NotFile(text)
    NotReadable(text)
    NotWritable(text)

impl FileValidation:
    # Check if file exists (valid)
    pub fn is_exists(self) -> bool:
        match self:
            case Valid(_): true
            case _: false

    # Check if file was not found
    pub fn is_not_found(self) -> bool:
        match self:
            case NotFound(_): true
            case _: false

    # Check if path is not a file (e.g., directory)
    pub fn is_not_file(self) -> bool:
        match self:
            case NotFile(_): true
            case _: false

    # Check if file is not readable
    pub fn is_not_readable(self) -> bool:
        match self:
            case NotReadable(_): true
            case _: false

    # Check if file is not writable
    pub fn is_not_writable(self) -> bool:
        match self:
            case NotWritable(_): true
            case _: false

    # Check if validation failed
    pub fn is_error(self) -> bool:
        match self:
            case Valid(_): false
            case _: true

    # Check if validation passed
    pub fn is_valid(self) -> bool:
        match self:
            case Valid(_): true
            case _: false

    # Check if error is permission-related
    pub fn is_permission_error(self) -> bool:
        match self:
            case NotReadable(_): true
            case NotWritable(_): true
            case _: false

    # Get the file path
    pub fn get_path(self) -> text:
        match self:
            case Valid(path): path
            case NotFound(path): path
            case NotFile(path): path
            case NotReadable(path): path
            case NotWritable(path): path

    # Convert validation result to string
    pub fn to_string(self) -> text:
        match self:
            case Valid(_): "exists"
            case NotFound(_): "not-found"
            case NotFile(_): "not-file"
            case NotReadable(_): "not-readable"
            case NotWritable(_): "not-writable"

    # Get validation result description
    pub fn description(self) -> text:
        match self:
            case Valid(_): "File exists and is valid"
            case NotFound(_): "File does not exist"
            case NotFile(_): "Path is not a regular file"
            case NotReadable(_): "File exists but is not readable"
            case NotWritable(_): "File exists but is not writable"

    # Get file validation summary
    pub fn summary(self) -> text:
        val name = self.to_string()
        val desc = self.description()
        val path = self.get_path()
        val status = if self.is_valid(): "valid" else: "error"
        return "FileValidation: {name} ({desc}): {path} [{status}]"

# File metadata
pub struct FileInfo:
    path: text
    absolute_path: text
    file_exists: bool
    is_file: bool
    is_dir: bool
    is_readable: bool
    is_writable: bool

# Staged files for processing
pub struct StagedFiles:
    files: Array<FileInfo>
    handles: Array<AsyncFileHandle>
    errors: Array<text>

    # Get all successfully staged files
    pub fn staged(self) -> Array<FileInfo>:
        var result = []
        for f in self.files:
            if f.file_exists and f.is_file:
                result.push(f)
        return result

    # Get async file handles
    pub fn handles(self) -> Array<AsyncFileHandle>:
        return self.handles

    # Wait for all files to load (async)
    pub async fn wait_all(self) -> Result<Array<MmapRegion>, Error>:
        var regions = []
        for handle in self.handles:
            val region = await handle.wait()?
            regions.push(region)
        return Ok(regions)

    # Get files that are already ready (non-blocking)
    pub fn ready_handles(self) -> Array<AsyncFileHandle>:
        var ready = []
        for handle in self.handles:
            if handle.is_ready():
                ready.push(handle)
        return ready

    # Get all errors
    pub fn get_errors(self) -> Array<text>:
        return self.errors

    # Check if any files have errors
    pub fn has_errors(self) -> bool:
        return self.errors.len() > 0

    # Get count of successfully staged files
    pub fn count(self) -> Count:
        val len_i32 = self.staged().len()
        return Count.from_i64(len_i32 as i64)

# File argument validator
pub struct FileValidator:
    must_exist: bool
    must_be_file: bool
    must_be_readable: bool
    must_be_writable: bool
    allowed_extensions: Array<text>

    # Create a new file validator
    static fn new() -> FileValidator:
        return FileValidator {
            must_exist: false,
            must_be_file: true,
            must_be_readable: false,
            must_be_writable: false,
            allowed_extensions: []
        }

    # Require file to exist
    pub fn require_exists(mut self) -> FileValidator:
        self.must_exist = true
        return self

    # Require file to be readable
    pub fn require_readable(mut self) -> FileValidator:
        self.must_be_readable = true
        return self

    # Require file to be writable
    pub fn require_writable(mut self) -> FileValidator:
        self.must_be_writable = true
        return self

    # Allow only specific extensions
    pub fn with_extensions(mut self, extensions: Array<text>) -> FileValidator:
        self.allowed_extensions = extensions
        return self

    # Validate a file path
    pub fn validate(self, path: text) -> Result<FileInfo, text>:
        val does_exist = file_exists(path)
        val info = get_file_info(path)

        if self.must_exist and not does_exist:
            return Err("File does not exist: {path}")

        if self.must_be_file and does_exist and info.is_dir:
            return Err("Path is a directory, not a file: {path}")

        if self.must_be_readable and does_exist and not info.is_readable:
            return Err("File is not readable: {path}")

        if self.must_be_writable and does_exist and not info.is_writable:
            return Err("File is not writable: {path}")

        if self.allowed_extensions.len() > 0:
            val ext = get_file_extension(path)
            var valid_ext = false
            for allowed in self.allowed_extensions:
                if ext == allowed:
                    valid_ext = true

            if not valid_ext:
                return Err("Invalid file extension: {ext} (allowed: {self.allowed_extensions})")

        return Ok(info)

# File staging manager
pub struct FileStager:
    validators: Dict<text, FileValidator>

    # Create a new file stager
    static fn new() -> FileStager:
        return FileStager {
            validators: {}
        }

    # Add a file validator for an argument
    pub fn add_validator(mut self, arg_name: text, validator: FileValidator) -> FileStager:
        self.validators.insert(arg_name, validator)
        return self

    # Stage files from parsed arguments (sync mode)
    pub fn stage_files(self, args: ParsedArgs) -> StagedFiles:
        var files: Array<FileInfo> = []
        var errors: Array<text> = []

        for (name, validator) in self.validators:
            val value = args.get_option(name)
            match value:
                case Some(path):
                    match validator.validate(path):
                        case Ok(info):
                            files.push(info)
                        case Err(error):
                            errors.push("{name}: {error}")
                case None:
                    pass

        val positionals = args.get_all_positionals()
        for path in positionals:
            val default_validator = FileValidator.new().require_exists()
            match default_validator.validate(path):
                case Ok(info):
                    files.push(info)
                case Err(error):
                    errors.push("positional: {error}")

        return StagedFiles {
            files: files,
            handles: [],
            errors: errors
        }

    # Stage files with async loading
    pub fn stage_files_async(self, args: ParsedArgs, options: OpenOptions) -> StagedFiles:
        var files: Array<FileInfo> = []
        var handles: Array<AsyncFileHandle> = []
        var errors: Array<text> = []

        for (name, validator) in self.validators:
            val value = args.get_option(name)
            match value:
                case Some(path):
                    match validator.validate(path):
                        case Ok(info):
                            files.push(info)
                            val handle = AsyncFileHandle.with_options(info.path, options)
                            handle.start_loading()
                            handles.push(handle)
                        case Err(error):
                            errors.push("{name}: {error}")
                case None:
                    pass

        val positionals = args.get_all_positionals()
        for path in positionals:
            val default_validator = FileValidator.new().require_exists()
            match default_validator.validate(path):
                case Ok(info):
                    files.push(info)
                    val handle = AsyncFileHandle.with_options(info.path, options)
                    handle.start_loading()
                    handles.push(handle)
                case Err(error):
                    errors.push("positional: {error}")

        return StagedFiles {
            files: files,
            handles: handles,
            errors: errors
        }

# File utility functions

fn file_exists(path: text) -> bool:
    return rt_file_exists(path)

fn get_file_info(path: text) -> FileInfo:
    val does_exist = rt_file_exists(path)
    val absolute_path = normalize_path(path)
    val is_file_val = does_exist and not path.ends_with("/")
    val is_dir_val = does_exist and path.ends_with("/")

    return FileInfo {
        path: path,
        absolute_path: absolute_path,
        file_exists: does_exist,
        is_file: is_file_val,
        is_dir: is_dir_val,
        is_readable: does_exist,
        is_writable: does_exist
    }

pub fn normalize_path(path: text) -> text:
    return rt_file_canonicalize(path)

pub fn get_file_extension(path: text) -> text:
    val parts = path.split(".")
    if parts.len() > 1:
        return parts[parts.len() - 1]
    return ""

pub fn is_absolute_path(path: text) -> bool:
    return path.starts_with("/") or path.starts_with("C:") or path.starts_with("D:")

pub fn is_relative_path(path: text) -> bool:
    return not is_absolute_path(path)

pub fn join_paths(base: text, relative: text) -> text:
    if base.ends_with("/"):
        return "{base}{relative}"
    else:
        return "{base}/{relative}"

pub fn get_directory(path: text) -> text:
    val parts = path.split("/")
    if parts.len() > 1:
        var dir = ""
        var i = 0
        while i < parts.len() - 1:
            if i > 0:
                dir = "{dir}/"
            dir = "{dir}{parts[i]}"
            i = i + 1
        return dir
    return "."

pub fn get_filename(path: text) -> text:
    val parts = path.split("/")
    if parts.len() > 0:
        return parts[parts.len() - 1]
    return path

pub fn get_basename(path: text) -> text:
    val filename = get_filename(path)
    val parts = filename.split(".")
    if parts.len() > 1:
        var base = ""
        var i = 0
        while i < parts.len() - 1:
            if i > 0:
                base = "{base}."
            base = "{base}{parts[i]}"
            i = i + 1
        return base
    return filename

pub fn validate_files(paths: Array<text>, validator: FileValidator) -> Result<Array<FileInfo>, Array<text>>:
    var files: Array<FileInfo> = []
    var errors: Array<text> = []

    for path in paths:
        match validator.validate(path):
            case Ok(info):
                files.push(info)
            case Err(error):
                errors.push(error)

    if errors.len() > 0:
        return Err(errors)

    return Ok(files)

# Validator for input files (must exist, readable)
pub fn input_file_validator() -> FileValidator:
    return FileValidator.new()
        .require_exists()
        .require_readable()

# Validator for output files (can be created, writable)
pub fn output_file_validator() -> FileValidator:
    return FileValidator.new()
        .require_writable()

# Validator for config files
pub fn config_file_validator() -> FileValidator:
    return FileValidator.new()
        .require_exists()
        .require_readable()
        .with_extensions(["json", "toml", "yaml", "yml", "conf"])

# Validator for source code files
pub fn source_file_validator() -> FileValidator:
    return FileValidator.new()
        .require_exists()
        .require_readable()
        .with_extensions(["spl", "rs", "py", "js", "ts"])
