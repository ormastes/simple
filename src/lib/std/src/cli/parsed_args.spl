# CLI ParsedArgs - Parsed argument results

export ParsedArgs

import cli.file as file

# Parsed arguments result with staged files
pub struct ParsedArgs:
    flags: Dict<text, bool>
    options: Dict<text, text>
    positionals: Array<text>
    files: file.StagedFiles
    subcommand: Option<text>
    subcommand_args: Array<text>

    # =========================================================================
    # Helper Methods
    # =========================================================================

    # Check if any flags are present
    pub fn has_flags(self) -> bool:
        return self.flags.len() > 0

    # Check if any options are present
    pub fn has_options(self) -> bool:
        return self.options.len() > 0

    # Check if any positional arguments are present
    pub fn has_positionals(self) -> bool:
        return self.positionals.len() > 0

    # Check if any files are staged
    pub fn has_files(self) -> bool:
        return self.files.staged().len() > 0

    # Check if a subcommand was specified
    pub fn has_subcommand(self) -> bool:
        return self.subcommand.is_some()

    # Get the subcommand name if specified
    pub fn get_subcommand(self) -> Option<text>:
        return self.subcommand

    # Get arguments that follow the subcommand
    pub fn get_subcommand_args(self) -> Array<text>:
        return self.subcommand_args

    # Get number of flags
    pub fn flag_count(self) -> usize:
        return self.flags.len()

    # Get number of options
    pub fn option_count(self) -> usize:
        return self.options.len()

    # Get number of positional arguments
    pub fn positional_count(self) -> usize:
        return self.positionals.len()

    # Get number of staged files
    pub fn file_count(self) -> usize:
        return self.files.staged().len()

    # Check if no arguments are present
    pub fn is_empty(self) -> bool:
        return not self.has_flags() and not self.has_options() and not self.has_positionals()

    # Check if an option is present
    pub fn has_option(self, name: text) -> bool:
        return self.options.contains_key(name)

    # Get all flag names
    pub fn get_flag_names(self) -> Array<text>:
        return self.flags.keys()

    # Get all option names
    pub fn get_option_names(self) -> Array<text>:
        return self.options.keys()

    # Get summary of parsed arguments
    pub fn summary(self) -> text:
        val subcmd_str = if self.has_subcommand(): ", subcommand: " + self.subcommand.unwrap() else: ""
        return "ParsedArgs: {self.flag_count()} flags, {self.option_count()} options, {self.positional_count()} positionals, {self.file_count()} files{subcmd_str}"

    # =========================================================================
    # Existing Methods
    # =========================================================================

    # Check if a flag is present
    pub fn has_flag(self, name: text) -> bool:
        val result = false
        if self.flags.contains_key(name):
            result = self.flags.get(name).unwrap_or(false)
        return result

    # Get a flag value
    pub fn get_flag(self, name: text) -> bool:
        return self.has_flag(name)

    # Get an option value as string
    pub fn get_option(self, name: text) -> Option<text>:
        if self.options.contains_key(name):
            return Some(self.options.get(name).unwrap())
        return None

    # Get an option value with default
    pub fn get_option_or(self, name: text, default_val: text) -> text:
        val result = ""
        if self.options.contains_key(name):
            result = self.options.get(name).unwrap()
        else:
            result = default_val
        return result

    # Get an option value as an integer
    # Returns Some(value) if option exists and can be parsed, None otherwise
    pub fn get_option_int(self, name: text) -> Option<i64>:
        if self.options.contains_key(name):
            val s = self.options.get(name).unwrap()
            return Some(parse_int_safe(s))
        return None

    # Get an option value as a float
    # Returns Some(value) if option exists and can be parsed, None otherwise
    pub fn get_option_float(self, name: text) -> Option<f64>:
        if self.options.contains_key(name):
            val s = self.options.get(name).unwrap()
            return Some(parse_float_safe(s))
        return None

    # Get an option value as integer with default
    pub fn get_option_int_or(self, name: text, default_val: i64) -> i64:
        match self.get_option_int(name):
            case Some(v): return v
            case None: return default_val

    # Get an option value as float with default
    pub fn get_option_float_or(self, name: text, default_val: f64) -> f64:
        match self.get_option_float(name):
            case Some(v): return v
            case None: return default_val

    # Get a positional argument by index
    pub fn get_positional_at(self, index: i32) -> Option<text>:
        if index >= 0 and index < self.positionals.len():
            return Some(self.positionals[index])
        return None

    # Get all positionals
    pub fn get_all_positionals(self) -> Array<text>:
        return self.positionals

    # Get all successfully staged files
    pub fn get_staged_files(self) -> Array<file.FileInfo>:
        return self.files.staged()

    # Get file by path (searches staged files by path)
    pub fn get_file(self, path: text) -> Option<file.FileInfo>:
        for f in self.files.staged():
            if f.path == path or f.absolute_path == path:
                return Some(f)
        return None


# ============================================================================
# Helper Functions for Parsing
# ============================================================================

fn parse_int_safe(s: text) -> i64:
    # Parse a string as an integer, returning 0 for invalid input
    val trimmed = s.trim()
    if trimmed.len() == 0:
        return 0

    var result: i64 = 0
    var negative = false
    var start = 0

    if trimmed.char_at(0) == "-":
        negative = true
        start = 1
    elif trimmed.char_at(0) == "+":
        start = 1

    for i in start..trimmed.len():
        val ch = trimmed.char_at(i)
        if ch >= "0" and ch <= "9":
            val digit = ch.ord() - 48  # 48 is ord('0')
            result = result * 10 + digit
        else:
            break  # Stop at first non-digit

    if negative:
        return -result
    return result


fn parse_float_safe(s: text) -> f64:
    # Parse a string as a float, returning 0.0 for invalid input
    val trimmed = s.trim()
    if trimmed.len() == 0:
        return 0.0

    var negative = false
    var pos = 0

    # Check for sign
    if trimmed.char_at(0) == "-":
        negative = true
        pos = 1
    elif trimmed.char_at(0) == "+":
        pos = 1

    # Parse integer part
    var int_part: f64 = 0.0
    while pos < trimmed.len():
        val ch = trimmed.char_at(pos)
        if ch >= "0" and ch <= "9":
            val digit = (ch.ord() - 48) as f64
            int_part = int_part * 10.0 + digit
            pos = pos + 1
        else:
            break

    var decimal_part: f64 = 0.0

    # Parse decimal part if present
    if pos < trimmed.len() and trimmed.char_at(pos) == ".":
        pos = pos + 1
        var decimal_places: f64 = 0.1

        while pos < trimmed.len():
            val ch = trimmed.char_at(pos)
            if ch >= "0" and ch <= "9":
                val digit = (ch.ord() - 48) as f64
                decimal_part = decimal_part + digit * decimal_places
                decimal_places = decimal_places * 0.1
                pos = pos + 1
            else:
                break

    var result = int_part + decimal_part

    # Parse exponent if present (e.g., e-3, E+5)
    if pos < trimmed.len() and (trimmed.char_at(pos) == "e" or trimmed.char_at(pos) == "E"):
        pos = pos + 1
        var exp_negative = false

        if pos < trimmed.len() and trimmed.char_at(pos) == "-":
            exp_negative = true
            pos = pos + 1
        elif pos < trimmed.len() and trimmed.char_at(pos) == "+":
            pos = pos + 1

        var exponent: i64 = 0
        while pos < trimmed.len():
            val ch = trimmed.char_at(pos)
            if ch >= "0" and ch <= "9":
                val digit = ch.ord() - 48
                exponent = exponent * 10 + digit
                pos = pos + 1
            else:
                break

        # Apply exponent
        var exp_factor: f64 = 1.0
        for _ in 0..exponent:
            if exp_negative:
                exp_factor = exp_factor * 0.1
            else:
                exp_factor = exp_factor * 10.0
        result = result * exp_factor

    if negative:
        return -result
    return result
