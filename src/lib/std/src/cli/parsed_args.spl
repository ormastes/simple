# CLI ParsedArgs - Parsed argument results

export ParsedArgs

import cli.file as file

# Parsed arguments result with staged files
pub struct ParsedArgs:
    flags: Dict<text, bool>
    options: Dict<text, text>
    positionals: Array<text>
    files: file.StagedFiles  # Automatically staged files

    # =========================================================================
    # Helper Methods
    # =========================================================================

    pub fn has_flags(self) -> bool:
        """Check if any flags are present."""
        return self.flags.len() > 0

    pub fn has_options(self) -> bool:
        """Check if any options are present."""
        return self.options.len() > 0

    pub fn has_positionals(self) -> bool:
        """Check if any positional arguments are present."""
        return self.positionals.len() > 0

    pub fn has_files(self) -> bool:
        """Check if any files are staged."""
        return self.files.staged().len() > 0

    pub fn flag_count(self) -> usize:
        """Get number of flags."""
        return self.flags.len()

    pub fn option_count(self) -> usize:
        """Get number of options."""
        return self.options.len()

    pub fn positional_count(self) -> usize:
        """Get number of positional arguments."""
        return self.positionals.len()

    pub fn file_count(self) -> usize:
        """Get number of staged files."""
        return self.files.staged().len()

    pub fn is_empty(self) -> bool:
        """Check if no arguments are present."""
        return not self.has_flags() and not self.has_options() and not self.has_positionals()

    pub fn has_option(self, name: text) -> bool:
        """Check if an option is present."""
        return self.options.contains_key(name)

    pub fn get_flag_names(self) -> Array<text>:
        """Get all flag names."""
        return self.flags.keys()

    pub fn get_option_names(self) -> Array<text>:
        """Get all option names."""
        return self.options.keys()

    pub fn summary(self) -> text:
        """Get summary of parsed arguments."""
        return "ParsedArgs: {self.flag_count()} flags, {self.option_count()} options, {self.positional_count()} positionals, {self.file_count()} files"

    # =========================================================================
    # Existing Methods
    # =========================================================================

    # Check if a flag is present
    pub fn has_flag(self, name: text) -> bool:
        val result = false
        if self.flags.contains_key(name):
            result = self.flags.get(name).unwrap_or(false)
        return result

    # Get a flag value
    pub fn get_flag(self, name: text) -> bool:
        return self.has_flag(name)

    # Get an option value as string
    pub fn get_option(self, name: text) -> Option<text>:
        if self.options.contains_key(name):
            return Some(self.options.get(name).unwrap())
        return None

    # Get an option value with default
    pub fn get_option_or(self, name: text, default_val: text) -> text:
        val result = ""
        if self.options.contains_key(name):
            result = self.options.get(name).unwrap()
        else:
            result = default_val
        return result

    # Get an option value as an integer
    pub fn get_option_int(self, name: text) -> Option<i64>:
        """Get an option value parsed as an integer.

        Args:
            name: Option name

        Returns:
            Some(value) if option exists and can be parsed as integer, None otherwise

        Example:
            val count = args.get_option_int("count").unwrap_or(10)
        """
        if self.options.contains_key(name):
            val s = self.options.get(name).unwrap()
            return Some(parse_int_safe(s))
        return None

    # Get an option value as a float
    pub fn get_option_float(self, name: text) -> Option<f64>:
        """Get an option value parsed as a float.

        Args:
            name: Option name

        Returns:
            Some(value) if option exists and can be parsed as float, None otherwise

        Example:
            val rate = args.get_option_float("rate").unwrap_or(0.01)
        """
        if self.options.contains_key(name):
            val s = self.options.get(name).unwrap()
            return Some(parse_float_safe(s))
        return None

    # Get an option value as integer with default
    pub fn get_option_int_or(self, name: text, default_val: i64) -> i64:
        """Get an option value as integer, with a default.

        Args:
            name: Option name
            default_val: Value to return if option missing or invalid

        Returns:
            Parsed integer or the default value
        """
        match self.get_option_int(name):
            case Some(v): return v
            case None: return default_val

    # Get an option value as float with default
    pub fn get_option_float_or(self, name: text, default_val: f64) -> f64:
        """Get an option value as float, with a default.

        Args:
            name: Option name
            default_val: Value to return if option missing or invalid

        Returns:
            Parsed float or the default value
        """
        match self.get_option_float(name):
            case Some(v): return v
            case None: return default_val

    # Get a positional argument by index
    pub fn get_positional_at(self, index: i32) -> Option<text>:
        if index >= 0 and index < self.positionals.len():
            return Some(self.positionals[index])
        return None

    # Get all positionals
    pub fn get_all_positionals(self) -> Array<text>:
        return self.positionals

    # Get all successfully staged files
    pub fn get_staged_files(self) -> Array<file.FileInfo>:
        return self.files.staged()

    # Get file by option name
    pub fn get_file(self, name: text) -> Option<file.FileInfo>:
        # Find file matching this option name using source_arg tracking
        for f in self.files.staged():
            # Check if file came from matching argument
            if f.source_arg == name or f.source_arg == "--" + name:
                return Some(f)

        # Fallback: check if name was a positional that resolves to a file
        if self.positional_sources.contains_key(name):
            val index = self.positional_sources.get(name).unwrap_or(-1)
            if index >= 0 and index < self.files.staged().len():
                return Some(self.files.staged()[index])

        return None


# ============================================================================
# Helper Functions for Parsing
# ============================================================================

fn parse_int_safe(s: text) -> i64:
    """Parse a string as an integer, returning 0 for invalid input.

    Supports:
    - Positive and negative integers
    - Leading whitespace is trimmed
    - Invalid characters stop parsing

    Args:
        s: String to parse

    Returns:
        Parsed integer or 0 if invalid
    """
    val trimmed = s.trim()
    if trimmed.len() == 0:
        return 0

    var result: i64 = 0
    var negative = false
    var start = 0

    if trimmed.char_at(0) == "-":
        negative = true
        start = 1
    elif trimmed.char_at(0) == "+":
        start = 1

    for i in start..trimmed.len():
        val ch = trimmed.char_at(i)
        if ch >= "0" and ch <= "9":
            val digit = ch.ord() - 48  # 48 is ord('0')
            result = result * 10 + digit
        else:
            break  # Stop at first non-digit

    if negative:
        return -result
    return result


fn parse_float_safe(s: text) -> f64:
    """Parse a string as a float, returning 0.0 for invalid input.

    Supports:
    - Positive and negative numbers
    - Decimal points
    - Scientific notation (e.g., 1.5e-3)
    - Leading whitespace is trimmed

    Args:
        s: String to parse

    Returns:
        Parsed float or 0.0 if invalid
    """
    val trimmed = s.trim()
    if trimmed.len() == 0:
        return 0.0

    var negative = false
    var pos = 0

    # Check for sign
    if trimmed.char_at(0) == "-":
        negative = true
        pos = 1
    elif trimmed.char_at(0) == "+":
        pos = 1

    # Parse integer part
    var int_part: f64 = 0.0
    while pos < trimmed.len():
        val ch = trimmed.char_at(pos)
        if ch >= "0" and ch <= "9":
            val digit = (ch.ord() - 48) as f64
            int_part = int_part * 10.0 + digit
            pos = pos + 1
        else:
            break

    var decimal_part: f64 = 0.0

    # Parse decimal part if present
    if pos < trimmed.len() and trimmed.char_at(pos) == ".":
        pos = pos + 1
        var decimal_places: f64 = 0.1

        while pos < trimmed.len():
            val ch = trimmed.char_at(pos)
            if ch >= "0" and ch <= "9":
                val digit = (ch.ord() - 48) as f64
                decimal_part = decimal_part + digit * decimal_places
                decimal_places = decimal_places * 0.1
                pos = pos + 1
            else:
                break

    var result = int_part + decimal_part

    # Parse exponent if present (e.g., e-3, E+5)
    if pos < trimmed.len() and (trimmed.char_at(pos) == "e" or trimmed.char_at(pos) == "E"):
        pos = pos + 1
        var exp_negative = false

        if pos < trimmed.len() and trimmed.char_at(pos) == "-":
            exp_negative = true
            pos = pos + 1
        elif pos < trimmed.len() and trimmed.char_at(pos) == "+":
            pos = pos + 1

        var exponent: i64 = 0
        while pos < trimmed.len():
            val ch = trimmed.char_at(pos)
            if ch >= "0" and ch <= "9":
                val digit = ch.ord() - 48
                exponent = exponent * 10 + digit
                pos = pos + 1
            else:
                break

        # Apply exponent
        var exp_factor: f64 = 1.0
        for _ in 0..exponent:
            if exp_negative:
                exp_factor = exp_factor * 0.1
            else:
                exp_factor = exp_factor * 10.0
        result = result * exp_factor

    if negative:
        return -result
    return result
