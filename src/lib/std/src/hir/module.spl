# HIR Module Definitions
#
# Function and module-level HIR structures.
# Provides the container types for HIR expressions and statements.
#
# Architecture:
#   HirModule contains HirFunctions
#   HirFunction contains HirBody (statements + locals)
#   All tree structures use indices into arenas

# TODO: Enable when module system supports relative imports
# use ..types.{TypeId, LocalVar, CapturedVar, HirExprKind, HirStmtKind}

# For now, we duplicate minimal type definitions needed
# TypeId - index into type registry (see types.spl)
struct TypeId:
    id: u32

impl TypeId:
    static fn void_ty() -> TypeId:
        TypeId(id: 0)

    fn is_void() -> bool:
        self.id == 0

# LocalVar - local variable metadata (see types.spl)
struct LocalVar:
    name: text
    ty: TypeId
    is_mutable: bool
    index: u32

impl LocalVar:
    static fn new(name: text, ty: TypeId, is_mutable: bool, index: u32) -> LocalVar:
        LocalVar(name: name, ty: ty, is_mutable: is_mutable, index: index)

# CapturedVar - captured variable in closure (see types.spl)
struct CapturedVar:
    local_index: u32

# =============================================================================
# Function Parameter
# =============================================================================

# Function parameter definition
struct HirParam:
    name: text
    ty: TypeId
    index: u32
    is_mutable: bool

impl HirParam:
    # Create immutable parameter
    static fn new(name: text, ty: TypeId, index: u32) -> HirParam:
        HirParam(name: name, ty: ty, index: index, is_mutable: false)

    # Create mutable parameter
    static fn mutable(name: text, ty: TypeId, index: u32) -> HirParam:
        HirParam(name: name, ty: ty, index: index, is_mutable: true)

    # Convert to LocalVar for use in function body
    fn to_local_var() -> LocalVar:
        LocalVar.new(self.name, self.ty, self.is_mutable, self.index)


# =============================================================================
# Function Visibility
# =============================================================================

# Function visibility
enum Visibility:
    # Private to module
    Private
    # Public to all
    Public
    # Public within crate only
    Crate

impl Visibility:
    fn to_string() -> text:
        match self:
            Visibility.Private -> "private"
            Visibility.Public -> "public"
            Visibility.Crate -> "crate"

    fn is_public() -> bool:
        match self:
            Visibility.Public -> true
            _ -> false

    fn is_private() -> bool:
        match self:
            Visibility.Private -> true
            _ -> false


# =============================================================================
# Function Signature
# =============================================================================

# Function signature (type-level info)
struct HirFunctionSig:
    name: text
    params: [HirParam]
    return_type: TypeId
    visibility: Visibility
    is_async: bool
    is_method: bool
    is_static: bool

impl HirFunctionSig:
    # Create basic function signature
    static fn new(name: text, params: [HirParam], return_type: TypeId) -> HirFunctionSig:
        HirFunctionSig(
            name: name,
            params: params,
            return_type: return_type,
            visibility: Visibility.Private,
            is_async: false,
            is_method: false,
            is_static: false
        )

    # Create public function
    static fn public(name: text, params: [HirParam], return_type: TypeId) -> HirFunctionSig:
        HirFunctionSig(
            name: name,
            params: params,
            return_type: return_type,
            visibility: Visibility.Public,
            is_async: false,
            is_method: false,
            is_static: false
        )

    # Create async function signature
    static fn async_fn(name: text, params: [HirParam], return_type: TypeId) -> HirFunctionSig:
        HirFunctionSig(
            name: name,
            params: params,
            return_type: return_type,
            visibility: Visibility.Private,
            is_async: true,
            is_method: false,
            is_static: false
        )

    # Create method signature
    static fn method(name: text, params: [HirParam], return_type: TypeId) -> HirFunctionSig:
        HirFunctionSig(
            name: name,
            params: params,
            return_type: return_type,
            visibility: Visibility.Private,
            is_async: false,
            is_method: true,
            is_static: false
        )

    # Create static method signature
    static fn static_method(name: text, params: [HirParam], return_type: TypeId) -> HirFunctionSig:
        HirFunctionSig(
            name: name,
            params: params,
            return_type: return_type,
            visibility: Visibility.Private,
            is_async: false,
            is_method: false,
            is_static: true
        )

    # Get parameter count
    fn param_count() -> u32:
        self.params.len() as u32

    # Get parameter by index
    fn get_param(index: u32) -> Option<HirParam>:
        if index < self.param_count():
            Some(self.params[index as i32])
        else:
            None

    # Check if this returns void
    fn returns_void() -> bool:
        self.return_type.is_void()


# =============================================================================
# Expression Index (for arena-based tree)
# =============================================================================

# Index into expression arena
struct ExprId:
    index: u32

impl ExprId:
    static fn new(index: u32) -> ExprId:
        ExprId(index: index)

    # Invalid/null expression
    static fn invalid() -> ExprId:
        ExprId(index: 0xFFFFFFFF)

    fn is_valid() -> bool:
        self.index != 0xFFFFFFFF


# Index into statement arena
struct StmtId:
    index: u32

impl StmtId:
    static fn new(index: u32) -> StmtId:
        StmtId(index: index)

    static fn invalid() -> StmtId:
        StmtId(index: 0xFFFFFFFF)

    fn is_valid() -> bool:
        self.index != 0xFFFFFFFF


# =============================================================================
# HIR Body (function body with locals)
# =============================================================================

# Function body containing locals and root statement
struct HirBody:
    locals: [LocalVar]
    root_stmt: StmtId
    has_return: bool

impl HirBody:
    # Create empty body
    static fn empty() -> HirBody:
        HirBody(locals: [], root_stmt: StmtId.invalid(), has_return: false)

    # Create body with root statement
    static fn new(root_stmt: StmtId) -> HirBody:
        HirBody(locals: [], root_stmt: root_stmt, has_return: false)

    # Get local count
    fn local_count() -> u32:
        self.locals.len() as u32

    # Add a local variable
    me add_local(local: LocalVar):
        self.locals = self.locals + [local]

    # Get local by index
    fn get_local(index: u32) -> Option<LocalVar>:
        if index < self.local_count():
            Some(self.locals[index as i32])
        else:
            None

    # Find local by name
    fn find_local(name: text) -> Option<LocalVar>:
        for local in self.locals:
            if local.name == name:
                return Some(local)
        None


# =============================================================================
# HIR Function
# =============================================================================

# Complete HIR function definition
struct HirFunction:
    id: u32
    sig: HirFunctionSig
    body: HirBody
    captures: [CapturedVar]

impl HirFunction:
    # Create function with signature only (no body yet)
    static fn new(id: u32, sig: HirFunctionSig) -> HirFunction:
        HirFunction(id: id, sig: sig, body: HirBody.empty(), captures: [])

    # Create function with body
    static fn with_body(id: u32, sig: HirFunctionSig, body: HirBody) -> HirFunction:
        HirFunction(id: id, sig: sig, body: body, captures: [])

    # Get function name
    fn name() -> text:
        self.sig.name

    # Get return type
    fn return_type() -> TypeId:
        self.sig.return_type

    # Check if this is a closure (has captures)
    fn is_closure() -> bool:
        self.captures.len() > 0

    # Check if this is async
    fn is_async() -> bool:
        self.sig.is_async

    # Check if this is a method
    fn is_method() -> bool:
        self.sig.is_method

    # Get parameter count
    fn param_count() -> u32:
        self.sig.param_count()

    # Get local count
    fn local_count() -> u32:
        self.body.local_count()

    # Get capture count
    fn capture_count() -> u32:
        self.captures.len() as u32

    # Add capture
    me add_capture(capture: CapturedVar):
        self.captures = self.captures + [capture]


# =============================================================================
# Type Definition Kind
# =============================================================================

# Kind of type definition
enum TypeDefKind:
    # Struct type
    Struct
    # Class type
    Class
    # Enum type
    Enum
    # Trait definition
    Trait
    # Type alias
    Alias

impl TypeDefKind:
    fn to_string() -> text:
        match self:
            TypeDefKind.Struct -> "struct"
            TypeDefKind.Class -> "class"
            TypeDefKind.Enum -> "enum"
            TypeDefKind.Trait -> "trait"
            TypeDefKind.Alias -> "alias"

    fn is_struct() -> bool:
        match self:
            TypeDefKind.Struct -> true
            _ -> false

    fn is_class() -> bool:
        match self:
            TypeDefKind.Class -> true
            _ -> false

    fn is_enum() -> bool:
        match self:
            TypeDefKind.Enum -> true
            _ -> false

    fn is_trait() -> bool:
        match self:
            TypeDefKind.Trait -> true
            _ -> false


# =============================================================================
# Field Definition
# =============================================================================

# Field in struct/class
struct HirField:
    name: text
    ty: TypeId
    index: u32
    is_mutable: bool
    visibility: Visibility

impl HirField:
    static fn new(name: text, ty: TypeId, index: u32) -> HirField:
        HirField(name: name, ty: ty, index: index, is_mutable: false, visibility: Visibility.Private)

    static fn mutable(name: text, ty: TypeId, index: u32) -> HirField:
        HirField(name: name, ty: ty, index: index, is_mutable: true, visibility: Visibility.Private)

    static fn public(name: text, ty: TypeId, index: u32) -> HirField:
        HirField(name: name, ty: ty, index: index, is_mutable: false, visibility: Visibility.Public)


# =============================================================================
# Enum Variant
# =============================================================================

# Enum variant definition
struct HirVariant:
    name: text
    index: u32
    payload_type: Option<TypeId>

impl HirVariant:
    # Create unit variant (no payload)
    static fn unit(name: text, index: u32) -> HirVariant:
        HirVariant(name: name, index: index, payload_type: None)

    # Create variant with payload
    static fn with_payload(name: text, index: u32, ty: TypeId) -> HirVariant:
        HirVariant(name: name, index: index, payload_type: Some(ty))

    # Check if this has a payload
    fn has_payload() -> bool:
        self.payload_type.is_some()


# =============================================================================
# Type Definition
# =============================================================================

# Type definition (struct, class, enum, trait)
struct HirTypeDef:
    id: u32
    name: text
    kind: TypeDefKind
    type_id: TypeId
    fields: [HirField]
    variants: [HirVariant]
    methods: [u32]
    visibility: Visibility

impl HirTypeDef:
    # Create struct definition
    static fn struct_def(id: u32, name: text, type_id: TypeId, fields: [HirField]) -> HirTypeDef:
        HirTypeDef(
            id: id,
            name: name,
            kind: TypeDefKind.Struct,
            type_id: type_id,
            fields: fields,
            variants: [],
            methods: [],
            visibility: Visibility.Private
        )

    # Create class definition
    static fn class_def(id: u32, name: text, type_id: TypeId, fields: [HirField]) -> HirTypeDef:
        HirTypeDef(
            id: id,
            name: name,
            kind: TypeDefKind.Class,
            type_id: type_id,
            fields: fields,
            variants: [],
            methods: [],
            visibility: Visibility.Private
        )

    # Create enum definition
    static fn enum_def(id: u32, name: text, type_id: TypeId, variants: [HirVariant]) -> HirTypeDef:
        HirTypeDef(
            id: id,
            name: name,
            kind: TypeDefKind.Enum,
            type_id: type_id,
            fields: [],
            variants: variants,
            methods: [],
            visibility: Visibility.Private
        )

    # Get field count
    fn field_count() -> u32:
        self.fields.len() as u32

    # Get variant count
    fn variant_count() -> u32:
        self.variants.len() as u32

    # Get method count
    fn method_count() -> u32:
        self.methods.len() as u32

    # Find field by name
    fn find_field(name: text) -> Option<HirField>:
        for field in self.fields:
            if field.name == name:
                return Some(field)
        None

    # Find variant by name
    fn find_variant(name: text) -> Option<HirVariant>:
        for variant in self.variants:
            if variant.name == name:
                return Some(variant)
        None

    # Add method reference
    me add_method(func_id: u32):
        self.methods = self.methods + [func_id]


# =============================================================================
# Import Item
# =============================================================================

# Import item in module
struct HirImport:
    module_path: text
    name: text
    alias_name: Option<text>
    is_wildcard: bool

impl HirImport:
    # Create simple import
    static fn new(module_path: text, name: text) -> HirImport:
        val no_alias: Option<text> = None
        HirImport(module_path: module_path, name: name, alias_name: no_alias, is_wildcard: false)

    # Create aliased import
    static fn aliased(module_path: text, name: text, import_alias: text) -> HirImport:
        val the_alias: Option<text> = Some(import_alias)
        HirImport(module_path: module_path, name: name, alias_name: the_alias, is_wildcard: false)

    # Create wildcard import
    static fn wildcard(module_path: text) -> HirImport:
        val no_alias: Option<text> = None
        HirImport(module_path: module_path, name: "*", alias_name: no_alias, is_wildcard: true)

    # Get effective name (alias if present, otherwise name)
    fn effective_name() -> text:
        match self.alias_name:
            Some(a) -> a
            None -> self.name


# =============================================================================
# HIR Module
# =============================================================================

# HIR Module - top-level container
struct HirModule:
    name: text
    path: text
    imports: [HirImport]
    functions: [HirFunction]
    types: [HirTypeDef]
    globals: [LocalVar]

impl HirModule:
    # Create empty module
    static fn new(name: text, path: text) -> HirModule:
        HirModule(
            name: name,
            path: path,
            imports: [],
            functions: [],
            types: [],
            globals: []
        )

    # Get function count
    fn function_count() -> u32:
        self.functions.len() as u32

    # Get type count
    fn type_count() -> u32:
        self.types.len() as u32

    # Get global count
    fn global_count() -> u32:
        self.globals.len() as u32

    # Add import
    me add_import(item: HirImport):
        self.imports = self.imports + [item]

    # Add function
    me add_function(func: HirFunction):
        self.functions = self.functions + [func]

    # Add type definition
    me add_type(type_def: HirTypeDef):
        self.types = self.types + [type_def]

    # Add global variable
    me add_global(global: LocalVar):
        self.globals = self.globals + [global]

    # Find function by name
    fn find_function(name: text) -> Option<HirFunction>:
        for func in self.functions:
            if func.name() == name:
                return Some(func)
        None

    # Find type by name
    fn find_type(name: text) -> Option<HirTypeDef>:
        for type_def in self.types:
            if type_def.name == name:
                return Some(type_def)
        None

    # Find global by name
    fn find_global(name: text) -> Option<LocalVar>:
        for global in self.globals:
            if global.name == name:
                return Some(global)
        None
