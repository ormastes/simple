# Skybox Shaders - Infinite-distance background rendering
#
# Renders a cubemap at infinite distance with optimized depth handling.
# Removes camera translation to create parallax-free background.
#
# Based on: doc/spec/graphics_3d.md (Part 1.4: Skybox Rendering)

use core.*
use graphics.math.*

# =============================================================================
# Skybox Vertex Input
# =============================================================================

pub struct SkyboxVertexInput:
    position: Vec3      # Cube position (-1 to 1 range)

# =============================================================================
# Skybox Uniforms
# =============================================================================

pub struct SkyboxUniforms:
    view_proj_matrix: Mat4    # View-projection (without translation)
    brightness: f32           # Exposure multiplier
    tint_color: Vec3          # Color tint

# =============================================================================
# Skybox Varyings
# =============================================================================

pub struct SkyboxVaryings:
    tex_coord: Vec3    # Cubemap sampling direction

# =============================================================================
# Skybox Vertex Shader
# =============================================================================

#[vertex_shader]
pub fn skybox_vertex_shader(
    input: SkyboxVertexInput,
    uniforms: SkyboxUniforms
) -> (Vec4, SkyboxVaryings):
    # Use cube position as cubemap sampling direction
    val tex_coord = input.position

    # Transform to clip space
    var clip_pos = uniforms.view_proj_matrix.transform_point(input.position)

    # Set depth to 1.0 (far plane) by setting z = w
    # After perspective divide, z/w = 1.0
    clip_pos.z = clip_pos.w

    # Output varyings
    val varyings = SkyboxVaryings {tex_coord: tex_coord}

    return (clip_pos, varyings)

# =============================================================================
# Skybox Fragment Shader
# =============================================================================

#[fragment_shader]
pub fn skybox_fragment_shader(
    varyings: SkyboxVaryings,
    uniforms: SkyboxUniforms
) -> Vec4:
    # Sample cubemap using direction vector
    val color = sample_cubemap(skybox_cubemap, varyings.tex_coord)

    # Apply brightness and tint
    val final_color = color.rgb() * uniforms.brightness * uniforms.tint_color

    return Vec4.from_vec3(final_color, 1.0)

# =============================================================================
# HDR Skybox Fragment Shader
# =============================================================================

#[fragment_shader]
pub fn skybox_hdr_fragment_shader(
    varyings: SkyboxVaryings,
    uniforms: SkyboxUniforms
) -> Vec4:
    # Sample HDR cubemap
    val hdr_color = sample_cubemap(skybox_cubemap, varyings.tex_coord)

    # Apply exposure
    val exposed = hdr_color.rgb() * uniforms.brightness

    # Tone mapping (Reinhard)
    val tone_mapped = exposed / (exposed + Vec3.one())

    # Gamma correction
    val gamma_corrected = pow_vec3(v=tone_mapped, exp=Vec3.new(1.0 / 2.2, 1.0 / 2.2, 1.0 / 2.2))

    # Apply tint
    val final_color = gamma_corrected * uniforms.tint_color

    return Vec4.from_vec3(final_color, 1.0)

# =============================================================================
# Procedural Sky Fragment Shader
# =============================================================================

pub struct ProceduralSkyUniforms:
    view_proj_matrix: Mat4
    sun_direction: Vec3
    sun_color: Vec3
    sky_color: Vec3
    horizon_color: Vec3
    ground_color: Vec3
    sun_size: f32
    atmosphere_intensity: f32

#[fragment_shader]
pub fn procedural_sky_fragment_shader(
    varyings: SkyboxVaryings,
    uniforms: ProceduralSkyUniforms
) -> Vec4:
    val dir = varyings.tex_coord.normalize()

    # Calculate gradient based on Y coordinate
    val t = (dir.y + 1.0) * 0.5  # Map -1..1 to 0..1

    # Sky gradient
    val sky_gradient = if dir.y >= 0.0:
        # Upper hemisphere: sky to horizon
        lerp_vec3(a=uniforms.horizon_color, b=uniforms.sky_color, dir.y)
    else:
        # Lower hemisphere: horizon to ground
        lerp_vec3(a=uniforms.ground_color, b=uniforms.horizon_color, dir.y + 1.0)

    # Sun contribution
    val sun_dot = max(a=dot(a=dir, b=uniforms.sun_direction), b=0.0)
    val sun_intensity = pow(base=sun_dot, exp=1.0 / uniforms.sun_size)
    val sun_contribution = uniforms.sun_color * sun_intensity

    # Atmospheric scattering (simple approximation)
    val atmosphere = uniforms.atmosphere_intensity * pow(base=1.0 - abs(dir.y), exp=2.0)
    val atmosphere_color = uniforms.sun_color * atmosphere

    # Combine
    val final_color = sky_gradient + sun_contribution + atmosphere_color

    return Vec4.from_vec3(final_color, 1.0)

# =============================================================================
# Starfield Fragment Shader
# =============================================================================

pub struct StarfieldUniforms:
    view_proj_matrix: Mat4
    star_brightness: f32
    nebula_color: Vec3
    nebula_intensity: f32
    time: f32  # For twinkling

#[fragment_shader]
pub fn starfield_fragment_shader(
    varyings: SkyboxVaryings,
    uniforms: StarfieldUniforms
) -> Vec4:
    val dir = varyings.tex_coord.normalize()

    # Generate stars using hash function
    val star_density = 0.001
    val star_hash = hash_direction(dir)

    var color = Vec3.zero()

    # Stars
    if star_hash < star_density:
        val star_size = fract(star_hash * 1000.0)
        val star_intensity = star_size * uniforms.star_brightness

        # Twinkling effect
        val twinkle = sin(uniforms.time * 5.0 + star_hash * 100.0) * 0.3 + 0.7

        color = color + Vec3.one() * star_intensity * twinkle

    # Nebula (noise-based)
    val nebula_noise = simplex_noise_3d(dir * 2.0)
    val nebula = max(a=nebula_noise, b=0.0) * uniforms.nebula_intensity
    color = color + uniforms.nebula_color * nebula

    return Vec4.from_vec3(color, 1.0)

# =============================================================================
# Helper Functions
# =============================================================================

fn max(a: f32, b: f32) -> f32:
    return if a > b: a else: b

fn dot(a: Vec3, b: Vec3) -> f32:
    return a.x * b.x + a.y * b.y + a.z * b.z

fn pow(base: f32, exp: f32) -> f32:
    # Would use math library
    return 0.0  # Placeholder

fn pow_vec3(v: Vec3, exp: Vec3) -> Vec3:
    return Vec3.new(
        pow(base=v.x, exp=exp.x),
        pow(base=v.y, exp=exp.y),
        pow(base=v.z, exp=exp.z)
    )

fn lerp_vec3(a: Vec3, b: Vec3, t: f32) -> Vec3:
    return a * (1.0 - t) + b * t  # a and b are Vec3, t is f32 - types differ

fn fract(x: f32) -> f32:
    # Would use math library
    return x - floor(x)

fn floor(x: f32) -> f32:
    # Would use math library
    return 0.0  # Placeholder

fn sin(x: f32) -> f32:
    # Would use math library
    return 0.0  # Placeholder

# Simple hash function for procedural generation
fn hash_direction(dir: Vec3) -> f32:
    val p = Vec3.new(
        dot(a=dir, b=Vec3.new(127.1, 311.7, 74.7)),
        dot(a=dir, b=Vec3.new(269.5, 183.3, 246.1)),
        dot(a=dir, b=Vec3.new(113.5, 271.9, 124.6))
    )

    return fract(sin(p.x + p.y + p.z) * 43758.5453123)

# Simplex noise (3D)
fn simplex_noise_3d(p: Vec3) -> f32:
    # Simplified noise - would use proper simplex implementation
    val hash = hash_direction(p)
    return hash * 2.0 - 1.0  # Map to -1..1

# =============================================================================
# Texture Sampling
# =============================================================================

extern fn sample_cubemap(cubemap_id: u64, direction: Vec3) -> Vec4
extern fn skybox_cubemap() -> u64
