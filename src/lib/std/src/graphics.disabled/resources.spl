# Resources - Resource management and registries
#
# Provides centralized registries for meshes, materials, and textures
# with automatic handle generation and resource lifecycle management.
#
# Based on: doc/plans/3d_engine_core_implementation.md (Phase 7)

use core.*
use graphics.math.*
use graphics.scene.*
use graphics.render.*

# =============================================================================
# MeshRegistry - Mesh resource registry
# =============================================================================

pub struct MeshRegistry:
    meshes: Dict<u64, Mesh>
    next_id: u64

impl MeshRegistry:
    pub fn new() -> MeshRegistry:
        return MeshRegistry {meshes: Dict.new(), next_id: 1}

    # Register a mesh and get its handle
    pub fn register(mut self, mesh: Mesh) -> MeshHandle:
        val id = self.next_id
        self.next_id = self.next_id + 1
        self.meshes.insert(id, mesh)
        return MeshHandle.new(id)

    # Get mesh by handle
    pub fn get(self, handle: MeshHandle) -> Option<Mesh>:
        if not handle.is_valid():
            return None
        return self.meshes.get(handle.id)

    # Check if mesh exists
    pub fn contains(self, handle: MeshHandle) -> bool:
        if not handle.is_valid():
            return false
        return self.meshes.contains_key(handle.id)

    # Remove mesh by handle
    pub fn remove(mut self, handle: MeshHandle) -> Option<Mesh>:
        if not handle.is_valid():
            return None
        return self.meshes.remove(handle.id)

    # Get mesh count
    pub fn count(self) -> i32:
        return self.meshes.len()

    # Clear all meshes
    pub fn clear(mut self):
        self.meshes.clear()
        self.next_id = 1

    # =============================================================================
    # Mesh Primitive Presets - Register common mesh primitives
    # =============================================================================

    pub fn register_cube(mut self) -> MeshHandle:
        val mesh = create_cube()
        return self.register(mesh)

    pub fn register_sphere(mut self, segments: i32) -> MeshHandle:
        val mesh = create_sphere(segments)
        return self.register(mesh)

    pub fn register_plane(mut self, subdivisions: i32) -> MeshHandle:
        val mesh = create_plane(subdivisions)
        return self.register(mesh)

    pub fn register_cylinder(mut self, segments: i32) -> MeshHandle:
        val mesh = create_cylinder(segments)
        return self.register(mesh)

    pub fn register_cone(mut self, segments: i32) -> MeshHandle:
        val mesh = create_cone(segments)
        return self.register(mesh)

    pub fn register_torus(mut self, major_segments: i32, minor_segments: i32) -> MeshHandle:
        val mesh = create_torus(major_segments, minor_segments)
        return self.register(mesh)

    pub fn register_quad(mut self) -> MeshHandle:
        val mesh = create_quad()
        return self.register(mesh)

    # =========================================================================
    # Helper Methods
    # =========================================================================

    pub fn is_empty(self) -> bool:
        """Check if registry has no meshes.

        Returns:
            true if no meshes registered

        Example:
            registry.is_empty()  # → false
        """
        return self.meshes.is_empty()

    pub fn has_meshes(self) -> bool:
        """Check if registry has any meshes.

        Returns:
            true if meshes exist

        Example:
            registry.has_meshes()  # → true
        """
        return not self.is_empty()

    pub fn summary(self) -> text:
        """Get registry summary.

        Returns:
            Human-readable summary

        Example:
            registry.summary()
            # → "MeshRegistry: 15 meshes"
        """
        val count = self.count()
        return "MeshRegistry: {count} meshes"

# =============================================================================
# MaterialRegistry - Material resource registry
# =============================================================================

pub struct MaterialRegistry:
    materials: Dict<u64, Material>
    next_id: u64

impl MaterialRegistry:
    pub fn new() -> MaterialRegistry:
        return MaterialRegistry {
            materials: Dict.new(),
            next_id: 1
        }

    # Register a material and get its handle
    pub fn register(mut self, material: Material) -> MaterialHandle:
        val id = self.next_id
        self.next_id = self.next_id + 1
        self.materials.insert(id, material)
        return MaterialHandle.new(id)

    # Get material by handle
    pub fn get(self, handle: MaterialHandle) -> Option<Material>:
        if not handle.is_valid():
            return None
        return self.materials.get(handle.id)

    # Check if material exists
    pub fn contains(self, handle: MaterialHandle) -> bool:
        if not handle.is_valid():
            return false
        return self.materials.contains_key(handle.id)

    # Update material
    pub fn update(mut self, handle: MaterialHandle, material: Material) -> bool:
        if not handle.is_valid():
            return false
        if not self.materials.contains_key(handle.id):
            return false
        self.materials.insert(handle.id, material)
        return true

    # Remove material by handle
    pub fn remove(mut self, handle: MaterialHandle) -> Option<Material>:
        if not handle.is_valid():
            return None
        return self.materials.remove(handle.id)

    # Get material count
    pub fn count(self) -> i32:
        return self.materials.len()

    # Clear all materials
    pub fn clear(mut self):
        self.materials.clear()
        self.next_id = 1

    # =============================================================================
    # Material Presets - Register common materials
    # =============================================================================

    pub fn register_pbr(mut self, albedo: Color, metallic: f32, roughness: f32) -> MaterialHandle:
        val pbr = PbrMaterial.new(albedo, metallic, roughness)
        return self.register(Material.Pbr(pbr))

    pub fn register_pbr_gold(mut self) -> MaterialHandle:
        return self.register(Material.Pbr(PbrMaterial.gold()))

    pub fn register_pbr_silver(mut self) -> MaterialHandle:
        return self.register(Material.Pbr(PbrMaterial.silver()))

    pub fn register_pbr_copper(mut self) -> MaterialHandle:
        return self.register(Material.Pbr(PbrMaterial.copper()))

    pub fn register_phong(mut self, diffuse: Color, specular: Color, shininess: f32) -> MaterialHandle:
        val phong = PhongMaterial.new(diffuse, specular, shininess)
        return self.register(Material.Phong(phong))

    pub fn register_phong_emerald(mut self) -> MaterialHandle:
        return self.register(Material.Phong(PhongMaterial.emerald()))

    pub fn register_unlit(mut self, color: Color) -> MaterialHandle:
        val unlit = UnlitMaterial.new(color)
        return self.register(Material.Unlit(unlit))

    # =========================================================================
    # Helper Methods
    # =========================================================================

    pub fn is_empty(self) -> bool:
        """Check if registry has no materials.

        Returns:
            true if no materials registered

        Example:
            registry.is_empty()  # → false
        """
        return self.materials.is_empty()

    pub fn has_materials(self) -> bool:
        """Check if registry has any materials.

        Returns:
            true if materials exist

        Example:
            registry.has_materials()  # → true
        """
        return not self.is_empty()

    pub fn summary(self) -> text:
        """Get registry summary.

        Returns:
            Human-readable summary

        Example:
            registry.summary()
            # → "MaterialRegistry: 8 materials"
        """
        val count = self.count()
        return "MaterialRegistry: {count} materials"

# =============================================================================
# TextureRegistry - Texture resource registry
# =============================================================================

pub struct TextureRegistry:
    textures: Dict<u64, Texture2D>
    cubemaps: Dict<u64, CubemapTexture>
    next_id: u64

impl TextureRegistry:
    pub fn new() -> TextureRegistry:
        return TextureRegistry {
            textures: Dict.new(),
            cubemaps: Dict.new(),
            next_id: 1
        }

    # Register a 2D texture and get its handle
    pub fn register_texture(mut self, texture: Texture2D) -> TextureHandle:
        val id = self.next_id
        self.next_id = self.next_id + 1
        self.textures.insert(id, texture)
        return TextureHandle.new(id)

    # Register a cubemap and get its handle
    pub fn register_cubemap(mut self, cubemap: CubemapTexture) -> TextureHandle:
        val id = self.next_id
        self.next_id = self.next_id + 1
        self.cubemaps.insert(id, cubemap)
        return TextureHandle.new(id)

    # Get 2D texture by handle
    pub fn get_texture(self, handle: TextureHandle) -> Option<Texture2D>:
        if not handle.is_valid():
            return None
        return self.textures.get(handle.id)

    # Get cubemap by handle
    pub fn get_cubemap(self, handle: TextureHandle) -> Option<CubemapTexture>:
        if not handle.is_valid():
            return None
        return self.cubemaps.get(handle.id)

    # Check if texture exists (either 2D or cubemap)
    pub fn contains(self, handle: TextureHandle) -> bool:
        if not handle.is_valid():
            return false
        return self.textures.contains_key(handle.id) or self.cubemaps.contains_key(handle.id)

    # Remove texture by handle (checks both 2D and cubemap)
    pub fn remove(mut self, handle: TextureHandle) -> bool:
        if not handle.is_valid():
            return false

        if self.textures.contains_key(handle.id):
            self.textures.remove(handle.id)
            return true

        if self.cubemaps.contains_key(handle.id):
            self.cubemaps.remove(handle.id)
            return true

        return false

    # Get total texture count (2D + cubemaps)
    pub fn count(self) -> i32:
        return self.textures.len() + self.cubemaps.len()

    # Get 2D texture count
    pub fn texture_count(self) -> i32:
        return self.textures.len()

    # Get cubemap count
    pub fn cubemap_count(self) -> i32:
        return self.cubemaps.len()

    # Clear all textures
    pub fn clear(mut self):
        # Clean up Vulkan resources
        for (_, texture) in self.textures:
            texture.destroy()
        for (_, cubemap) in self.cubemaps:
            cubemap.destroy()

        self.textures.clear()
        self.cubemaps.clear()
        self.next_id = 1

    # =============================================================================
    # Texture Creation Helpers
    # =============================================================================

    pub fn create_texture(
        mut self,
        width: u32,
        height: u32,
        format: TextureFormat
    ) -> TextureHandle:
        val texture = Texture2D.new(width, height, format)
        return self.register_texture(texture)

    pub fn create_texture_from_pixels(
        mut self,
        width: u32,
        height: u32,
        format: TextureFormat,
        pixels: Array<u8>
    ) -> TextureHandle:
        val texture = Texture2D.from_pixels(width, height, format, pixels)
        return self.register_texture(texture)

    pub fn create_cubemap(mut self, size: u32, format: TextureFormat) -> TextureHandle:
        val cubemap = CubemapTexture.new(size, format)
        return self.register_cubemap(cubemap)

    # =========================================================================
    # Helper Methods
    # =========================================================================

    pub fn is_empty(self) -> bool:
        """Check if registry has no textures.

        Returns:
            true if no textures registered

        Example:
            registry.is_empty()  # → false
        """
        return self.textures.is_empty() and self.cubemaps.is_empty()

    pub fn has_textures(self) -> bool:
        """Check if registry has any textures.

        Returns:
            true if textures exist

        Example:
            registry.has_textures()  # → true
        """
        return not self.is_empty()

    pub fn has_2d_textures(self) -> bool:
        """Check if registry has 2D textures.

        Returns:
            true if 2D textures exist

        Example:
            registry.has_2d_textures()  # → true
        """
        return not self.textures.is_empty()

    pub fn has_cubemaps(self) -> bool:
        """Check if registry has cubemaps.

        Returns:
            true if cubemaps exist

        Example:
            registry.has_cubemaps()  # → false
        """
        return not self.cubemaps.is_empty()

    pub fn summary(self) -> text:
        """Get registry summary.

        Returns:
            Human-readable summary

        Example:
            registry.summary()
            # → "TextureRegistry: 10 textures (8 2D, 2 cubemaps)"
        """
        val total = self.count()
        val tex2d = self.texture_count()
        val cubes = self.cubemap_count()
        return "TextureRegistry: {total} textures ({tex2d} 2D, {cubes} cubemaps)"

# =============================================================================
# ResourceManager - Unified resource management
# =============================================================================

pub struct ResourceManager:
    meshes: MeshRegistry
    materials: MaterialRegistry
    textures: TextureRegistry

impl ResourceManager:
    # Create new resource manager
    pub fn new() -> ResourceManager:
        return ResourceManager {
            meshes: MeshRegistry.new(),
            materials: MaterialRegistry.new(),
            textures: TextureRegistry.new()
        }

    # Access registries
    pub fn meshes(mut self) -> MeshRegistry:
        return self.meshes

    pub fn materials(mut self) -> MaterialRegistry:
        return self.materials

    pub fn textures(mut self) -> TextureRegistry:
        return self.textures

    # Get resource counts
    pub fn mesh_count(self) -> i32:
        return self.meshes.count()

    pub fn material_count(self) -> i32:
        return self.materials.count()

    pub fn texture_count(self) -> i32:
        return self.textures.count()

    pub fn total_resource_count(self) -> i32:
        return self.meshes.count() + self.materials.count() + self.textures.count()

    # Clear all resources
    pub fn clear_all(mut self):
        self.meshes.clear()
        self.materials.clear()
        self.textures.clear()

    # =============================================================================
    # Common Resource Initialization
    # =============================================================================

    # Initialize with default primitives and materials
    pub fn init_defaults(mut self):
        # Register primitive meshes
        self.meshes.register_cube()
        self.meshes.register_sphere(32)
        self.meshes.register_plane(10)
        self.meshes.register_cylinder(32)
        self.meshes.register_cone(32)
        self.meshes.register_torus(32, 16)

        # Register common materials
        self.materials.register_pbr_gold()
        self.materials.register_pbr_silver()
        self.materials.register_pbr_copper()
        self.materials.register_phong_emerald()
        self.materials.register_unlit(Color.white())

    # Resource statistics
    pub fn print_statistics(self):
        io.println("Resource Statistics:")
        io.println("  Meshes:    " + self.mesh_count().to_string())
        io.println("  Materials: " + self.material_count().to_string())
        io.println("  Textures:  " + self.texture_count().to_string())
        io.println("  Total:     " + self.total_resource_count().to_string())

    # =========================================================================
    # Helper Methods
    # =========================================================================

    pub fn is_empty(self) -> bool:
        """Check if all registries are empty.

        Returns:
            true if no resources registered

        Example:
            manager.is_empty()  # → false
        """
        return self.meshes.is_empty() and self.materials.is_empty() and self.textures.is_empty()

    pub fn has_resources(self) -> bool:
        """Check if any resources exist.

        Returns:
            true if resources exist

        Example:
            manager.has_resources()  # → true
        """
        return not self.is_empty()

    pub fn has_meshes(self) -> bool:
        """Check if mesh registry has any meshes.

        Returns:
            true if meshes exist

        Example:
            manager.has_meshes()  # → true
        """
        return self.meshes.has_meshes()

    pub fn has_materials(self) -> bool:
        """Check if material registry has any materials.

        Returns:
            true if materials exist

        Example:
            manager.has_materials()  # → true
        """
        return self.materials.has_materials()

    pub fn has_textures(self) -> bool:
        """Check if texture registry has any textures.

        Returns:
            true if textures exist

        Example:
            manager.has_textures()  # → false
        """
        return self.textures.has_textures()

    pub fn summary(self) -> text:
        """Get resource manager summary.

        Returns:
            Human-readable summary

        Example:
            manager.summary()
            # → "ResourceManager: 35 resources (15 meshes, 8 materials, 12 textures)"
        """
        val total = self.total_resource_count()
        val meshes = self.mesh_count()
        val materials = self.material_count()
        val textures = self.texture_count()
        return "ResourceManager: {total} resources ({meshes} meshes, {materials} materials, {textures} textures)"
