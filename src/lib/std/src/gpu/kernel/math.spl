# GPU Math - GPU-optimized mathematical functions
#
# Provides fast math functions optimized for GPU execution.

# Fast approximations (less accurate but faster)

# Fast reciprocal approximation (1/x)
@gpu_intrinsic("math_rcp")
fn rcp(x: f32) -> f32:
    return 1.0 / x

# Fast reciprocal square root approximation (1/sqrt(x))
@gpu_intrinsic("math_rsqrt")
fn rsqrt(x: f32) -> f32:
    return 1.0 / sqrt(x)

# Fast square root
@gpu_intrinsic("math_sqrt")
fn sqrt(x: f32) -> f32:
    extern fn rt_math_sqrt(x: f32) -> f32
    return rt_math_sqrt(x)

# Trigonometric functions
@gpu_intrinsic("math_sin")
fn sin(x: f32) -> f32:
    extern fn rt_math_sin(x: f32) -> f32
    return rt_math_sin(x)

@gpu_intrinsic("math_cos")
fn cos(x: f32) -> f32:
    extern fn rt_math_cos(x: f32) -> f32
    return rt_math_cos(x)

@gpu_intrinsic("math_tan")
fn tan(x: f32) -> f32:
    extern fn rt_math_tan(x: f32) -> f32
    return rt_math_tan(x)

# Inverse trigonometric functions
@gpu_intrinsic("math_asin")
fn asin(x: f32) -> f32:
    extern fn rt_math_asin(x: f32) -> f32
    return rt_math_asin(x)

@gpu_intrinsic("math_acos")
fn acos(x: f32) -> f32:
    extern fn rt_math_acos(x: f32) -> f32
    return rt_math_acos(x)

@gpu_intrinsic("math_atan")
fn atan(x: f32) -> f32:
    extern fn rt_math_atan(x: f32) -> f32
    return rt_math_atan(x)

@gpu_intrinsic("math_atan2")
fn atan2(y: f32, x: f32) -> f32:
    extern fn rt_math_atan2(y: f32, x: f32) -> f32
    return rt_math_atan2(y, x)

# Exponential and logarithmic
@gpu_intrinsic("math_exp")
fn exp(x: f32) -> f32:
    extern fn rt_math_exp(x: f32) -> f32
    return rt_math_exp(x)

@gpu_intrinsic("math_exp2")
fn exp2(x: f32) -> f32:
    return exp(x * 0.693147180559945)  # x * ln(2)

@gpu_intrinsic("math_log")
fn log(x: f32) -> f32:
    extern fn rt_math_log(x: f32) -> f32
    return rt_math_log(x)

@gpu_intrinsic("math_log2")
fn log2(x: f32) -> f32:
    extern fn rt_math_log2(x: f32) -> f32
    return rt_math_log2(x)

@gpu_intrinsic("math_log10")
fn log10(x: f32) -> f32:
    extern fn rt_math_log10(x: f32) -> f32
    return rt_math_log10(x)

# Power functions
@gpu_intrinsic("math_pow")
fn pow(base: f32, exp: f32) -> f32:
    extern fn rt_math_pow(base: f32, exp: f32) -> f32
    return rt_math_pow(base, exp)

# Absolute value
@gpu_intrinsic("math_abs")
fn abs(x: f32) -> f32:
    if x < 0.0:
        return -x
    return x

@gpu_intrinsic("math_abs_i32")
fn abs_i32(x: i32) -> i32:
    if x < 0:
        return -x
    return x

# Sign
@gpu_intrinsic("math_sign")
fn sign(x: f32) -> f32:
    if x > 0.0:
        return 1.0
    elif x < 0.0:
        return -1.0
    return 0.0

# Floor and ceiling
@gpu_intrinsic("math_floor")
fn floor(x: f32) -> f32:
    extern fn rt_math_floor(x: f32) -> f32
    return rt_math_floor(x)

@gpu_intrinsic("math_ceil")
fn ceil(x: f32) -> f32:
    extern fn rt_math_ceil(x: f32) -> f32
    return rt_math_ceil(x)

# Round to nearest
@gpu_intrinsic("math_round")
fn round(x: f32) -> f32:
    return floor(x + 0.5)

# Truncate (round towards zero)
@gpu_intrinsic("math_trunc")
fn trunc(x: f32) -> f32:
    return (x as i32) as f32

# Fractional part
@gpu_intrinsic("math_fract")
fn fract(x: f32) -> f32:
    return x - floor(x)

# Modulo (always positive)
@gpu_intrinsic("math_mod")
fn mod_f32(x: f32, y: f32) -> f32:
    return x - y * floor(x / y)

# Min/max
@gpu_intrinsic("math_min")
fn min(a: f32, b: f32) -> f32:
    if a < b:
        return a
    return b

@gpu_intrinsic("math_max")
fn max(a: f32, b: f32) -> f32:
    if a > b:
        return a
    return b

@gpu_intrinsic("math_min_i32")
fn min_i32(a: i32, b: i32) -> i32:
    if a < b:
        return a
    return b

@gpu_intrinsic("math_max_i32")
fn max_i32(a: i32, b: i32) -> i32:
    if a > b:
        return a
    return b

# Clamp
@gpu_intrinsic("math_clamp")
fn clamp(x: f32, min_val: f32, max_val: f32) -> f32:
    return min(a=max(a=x, b=min_val), b=max_val)

# Saturate (clamp to 0-1)
@gpu_intrinsic("math_saturate")
fn saturate(x: f32) -> f32:
    return clamp(x=x, min_val=0.0, max_val=1.0)

# Linear interpolation
@gpu_intrinsic("math_lerp")
fn lerp(a: f32, b: f32, t: f32) -> f32:
    return a + (b - a) * t

# Smooth step
@gpu_intrinsic("math_smoothstep")
fn smoothstep(edge0: f32, edge1: f32, x: f32) -> f32:
    val t = clamp(x=(x - edge0) / (edge1 - edge0), min_val=0.0, max_val=1.0)
    return t * t * (3.0 - 2.0 * t)

# Step function
@gpu_intrinsic("math_step")
fn step(edge: f32, x: f32) -> f32:
    if x < edge:
        return 0.0
    return 1.0

# Constants
const PI: f32 = 3.14159265358979323846
const TAU: f32 = 6.28318530717958647692
const E: f32 = 2.71828182845904523536
const SQRT2: f32 = 1.41421356237309504880

pub use rcp, rsqrt, sqrt
pub use sin, cos, tan, asin, acos, atan, atan2
pub use exp, exp2, log, log2, log10, pow
pub use abs, abs_i32, sign
pub use floor, ceil, round, trunc, fract, mod_f32
pub use min, max, min_i32, max_i32, clamp, saturate
pub use lerp, smoothstep, step
pub use PI, TAU, E, SQRT2
