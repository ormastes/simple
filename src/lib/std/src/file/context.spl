# Context Manager Support for File I/O
#
# Implements context manager protocols for automatic resource cleanup.
# Enables `with` and `async with` statements for file handling.

use file.mmap
use file.async_handle

# Sync context manager trait
pub trait ContextManager<T>:
    fn __enter__() -> T
    fn __exit__(exc: Option<Exception>) -> bool

# Async context manager trait
pub trait AsyncContextManager<T>:
    async fn __aenter__(self) -> T
    async fn __aexit__(self, exc: Option<Exception>) -> bool

# Context manager for MmapRegion (sync)
impl ContextManager<MmapRegion> for MmapRegion:
    fn __enter__() -> MmapRegion:
        # Return self - already loaded
        return self

    fn __exit__(exc: Option<Exception>) -> bool:
        # Cleanup: unmap the memory region
        # Import sys_munmap from parent module
        from file import sys_munmap

        # Unmap the memory region
        val result = sys_munmap(self.data, self.length)
        # Ignore munmap errors during cleanup

        # Don't suppress exceptions
        return false

# Async context manager for AsyncFileHandle (Pattern 1: auto-loading)
# Usage: async with await file.open(path) as mmap:
impl AsyncContextManager<MmapRegion> for AsyncFileHandle:
    async fn __aenter__(self) -> MmapRegion:
        # Wait for loading to complete, then return the region
        val region = await self.wait()
        match region:
            case Ok(r):
                return r
            case Err(e):
                # File loading failed - panic with error message
                panic("Failed to load file: " + e.to_string())

    async fn __aexit__(self, exc: Option<Exception>) -> bool:
        # Cleanup: unmap the region if it was loaded
        from file import sys_munmap

        match self.state:
            case FileState.Ready(region):
                val result = sys_munmap(region.data, region.length)
                # Ignore munmap errors during cleanup
            case _:
                pass
        return false

# Alternative: Lazy loading context manager (Pattern 3)
# This would be used with a hypothetical open_lazy() function
# Usage: async with await file.open_lazy(path) as handle:
impl AsyncContextManager<AsyncFileHandle> for AsyncFileHandle:
    async fn __aenter__(self) -> AsyncFileHandle:
        # Start loading if not already started
        if not self.is_ready() and not self.is_failed():
            self.start_loading()
        return self

    async fn __aexit__(self, exc: Option<Exception>) -> bool:
        # Cleanup: cancel loading if still in progress, unmap if ready
        from file import sys_munmap

        match self.state:
            case FileState.Loading:
                self.cancel()
            case FileState.Ready(region):
                val result = sys_munmap(region.data, region.length)
                # Ignore munmap errors during cleanup
            case _:
                pass
        return false

# Exception type for file operations
# (Placeholder - should be defined in core error system)
pub struct Exception:
    message: text

    pub fn new(message: text) -> Exception:
        return Exception { message: message }

    # =========================================================================
    # Helper Methods
    # =========================================================================

    pub fn is_empty(self) -> bool:
        """Check if exception message is empty."""
        return self.message.is_empty()

    pub fn len(self) -> usize:
        """Get length of exception message."""
        return self.message.len()

    pub fn contains(self, needle: &str) -> bool:
        """Check if exception message contains a substring."""
        return self.message.contains(needle)

    pub fn starts_with(self, prefix: &str) -> bool:
        """Check if exception message starts with prefix."""
        return self.message.starts_with(prefix)

    pub fn ends_with(self, suffix: &str) -> bool:
        """Check if exception message ends with suffix."""
        return self.message.ends_with(suffix)

    pub fn to_string(self) -> text:
        """Convert exception to string."""
        return self.message.clone()

    pub fn summary(self) -> text:
        """Get summary of exception."""
        val preview = if self.message.len() > 50:
            self.message.slice(0, 50) + "..."
        else:
            self.message.clone()
        return "Exception: {preview}"
