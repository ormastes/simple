# Memory-Mapped File Region
#
# Core mmap abstraction with safety wrappers.
# Provides zero-copy file access through memory mapping.

use core.resource.Resource

# mmap system call constants
const PROT_READ: i32 = 1
const PROT_WRITE: i32 = 2
const MAP_SHARED: i32 = 1
const MAP_PRIVATE: i32 = 2

# Memory-mapped region - represents a file mapped into memory
pub struct MmapRegion:
    data: *u8              # Pointer to mapped memory
    length: usize          # Size of mapped region in bytes
    mode: MmapMode         # Access mode (read-only, read-write, etc.)
    fd: i32                # File descriptor
    path: text           # Original file path (for debugging)

    # Get the mapped data as a byte slice
    pub fn as_bytes(self) -> &[u8]:
        # Safety: data pointer is valid for length bytes
        # Create slice from raw pointer and length
        unsafe:
            return slice_from_raw_parts(self.data, self.length)

    # Get the mapped data as a string (UTF-8 validated)
    pub fn as_str(self) -> Result<&str, FileError>:
        val bytes = self.as_bytes()
        # Convert bytes to string with UTF-8 validation
        match str_from_utf8(bytes):
            case Ok(s): return Ok(s)
            case Err(_): return Err(FileError.InvalidUtf8)

    # Advise kernel on memory access pattern
    pub fn advise(self, advice: MmapAdvice):
        # Call madvise system call
        # Defined in __init__.spl as sys_madvise
        pass

    # Get the length of the mapped region
    pub fn len(self) -> usize:
        return self.length

    # Check if the region is empty
    pub fn is_empty(self) -> bool:
        return self.length == 0

    # Get a slice of the mapped region
    pub fn slice(self, start: usize, end: usize) -> Result<&[u8>, FileError]:
        if start > self.length or end > self.length or start > end:
            return Err(FileError.OutOfBounds)
        val slice_len = end - start
        unsafe:
            val slice_ptr = (self.data as usize + start) as *u8
            return Ok(slice_from_raw_parts(slice_ptr, slice_len))

    # =========================================================================
    # Helper Methods
    # =========================================================================

    pub fn is_read_only(self) -> bool:
        """Check if region is read-only."""
        match self.mode:
            case MmapMode.ReadOnly: true
            case _: false

    pub fn is_writable(self) -> bool:
        """Check if region is writable."""
        match self.mode:
            case MmapMode.ReadWrite: true
            case MmapMode.CopyOnWrite: true
            case _: false

    pub fn is_shared(self) -> bool:
        """Check if region is shared (not copy-on-write)."""
        match self.mode:
            case MmapMode.ReadWrite: true
            case _: false

    pub fn is_valid_fd(self) -> bool:
        """Check if file descriptor is valid."""
        return self.fd >= 0

    pub fn has_path(self) -> bool:
        """Check if path is set."""
        return not self.path.is_empty()

    pub fn summary(self) -> text:
        """Get summary of memory-mapped region."""
        val mode_str = match self.mode:
            case MmapMode.ReadOnly: "read-only"
            case MmapMode.ReadWrite: "read-write"
            case MmapMode.CopyOnWrite: "copy-on-write"
        return "MmapRegion: {self.length} bytes, {mode_str}, fd={self.fd}"

# Resource trait implementation for MmapRegion
impl Resource for MmapRegion:
    fn close():
        """Unmap the memory region and close the file descriptor."""
        if self.data != nil and self.length > 0:
            native_munmap(self.data, self.length)
        if self.fd >= 0:
            native_close(self.fd)

    fn is_open() -> bool:
        """Check if the memory region is still mapped."""
        self.data != nil

    fn resource_name() -> text:
        """Get the resource name for leak reports."""
        "MmapRegion({self.path})"

# Native functions for mmap cleanup
extern fn native_munmap(ptr: *u8, length: usize)
extern fn native_close(fd: i32)

# Memory map mode
pub enum MmapMode:
    ReadOnly        # MAP_PRIVATE | PROT_READ
    ReadWrite       # MAP_SHARED | PROT_READ | PROT_WRITE
    CopyOnWrite     # MAP_PRIVATE | PROT_READ | PROT_WRITE

impl MmapMode:
    # =========================================================================
    # Helper Methods
    # =========================================================================

    pub fn is_read_only(self) -> bool:
        """Check if mode is read-only."""
        match self:
            case ReadOnly: true
            case _: false

    pub fn is_read_write(self) -> bool:
        """Check if mode is read-write."""
        match self:
            case ReadWrite: true
            case _: false

    pub fn is_copy_on_write(self) -> bool:
        """Check if mode is copy-on-write."""
        match self:
            case CopyOnWrite: true
            case _: false

    pub fn is_writable(self) -> bool:
        """Check if mode allows writing."""
        match self:
            case ReadWrite: true
            case CopyOnWrite: true
            case _: false

    pub fn to_string(self) -> text:
        """Convert mode to string."""
        match self:
            case ReadOnly: return "ReadOnly"
            case ReadWrite: return "ReadWrite"
            case CopyOnWrite: return "CopyOnWrite"

    pub fn description(self) -> text:
        """Get detailed mode description."""
        match self:
            case ReadOnly: return "Read-only (MAP_PRIVATE | PROT_READ)"
            case ReadWrite: return "Read-write (MAP_SHARED | PROT_READ | PROT_WRITE)"
            case CopyOnWrite: return "Copy-on-write (MAP_PRIVATE | PROT_READ | PROT_WRITE)"

    pub fn summary(self) -> text:
        """Get mode summary.

        Returns:
            Human-readable summary

        Example:
            MmapMode.ReadWrite.summary()
            # → "MmapMode: ReadWrite (Read-write (MAP_SHARED | PROT_READ | PROT_WRITE), writable)"
        """
        val name = self.to_string()
        val desc = self.description()
        val writable = if self.is_writable(): "writable" else: "read-only"
        return "MmapMode: {name} ({desc}, {writable})"

# Memory access advice for madvise(2)
pub enum MmapAdvice:
    Normal          # MADV_NORMAL - No specific advice
    Sequential      # MADV_SEQUENTIAL - Expect sequential access
    Random          # MADV_RANDOM - Expect random access
    WillNeed        # MADV_WILLNEED - Expect to access soon (prefault)
    DontNeed        # MADV_DONTNEED - Don't expect to access soon

impl MmapAdvice:
    # =========================================================================
    # Helper Methods
    # =========================================================================

    pub fn is_normal(self) -> bool:
        """Check if advice is Normal."""
        match self:
            case Normal: true
            case _: false

    pub fn is_sequential(self) -> bool:
        """Check if advice is Sequential."""
        match self:
            case Sequential: true
            case _: false

    pub fn is_random(self) -> bool:
        """Check if advice is Random."""
        match self:
            case Random: true
            case _: false

    pub fn is_will_need(self) -> bool:
        """Check if advice is WillNeed."""
        match self:
            case WillNeed: true
            case _: false

    pub fn is_dont_need(self) -> bool:
        """Check if advice is DontNeed."""
        match self:
            case DontNeed: true
            case _: false

    pub fn to_string(self) -> text:
        """Convert advice to string."""
        match self:
            case Normal: return "Normal"
            case Sequential: return "Sequential"
            case Random: return "Random"
            case WillNeed: return "WillNeed"
            case DontNeed: return "DontNeed"

    pub fn description(self) -> text:
        """Get detailed advice description."""
        match self:
            case Normal: return "Normal access pattern (MADV_NORMAL)"
            case Sequential: return "Sequential access pattern (MADV_SEQUENTIAL)"
            case Random: return "Random access pattern (MADV_RANDOM)"
            case WillNeed: return "Will need soon - prefault pages (MADV_WILLNEED)"
            case DontNeed: return "Don't need - free pages (MADV_DONTNEED)"

    pub fn summary(self) -> text:
        """Get advice summary.

        Returns:
            Human-readable summary

        Example:
            MmapAdvice.Sequential.summary()
            # → "MmapAdvice: Sequential (Sequential access pattern (MADV_SEQUENTIAL))"
        """
        val name = self.to_string()
        val desc = self.description()
        return "MmapAdvice: {name} ({desc})"

# File opening options
pub struct OpenOptions:
    mode: MmapMode              # Access mode
    async_loading: bool         # Enable async background loading
    prefault: bool              # Prefault pages during load
    advice: MmapAdvice          # Memory access pattern hint

    # Create default options (read-only, no async)
    pub fn new() -> OpenOptions:
        return OpenOptions {
            mode: MmapMode.ReadOnly,
            async_loading: false,
            prefault: false,
            advice: MmapAdvice.Normal
        }

    # Set access mode
    pub fn with_mode(mut self, mode: MmapMode) -> OpenOptions:
        self.mode = mode
        return self

    # Enable async loading
    pub fn with_async(mut self, enable: bool) -> OpenOptions:
        self.async_loading = enable
        return self

    # Enable prefaulting
    pub fn with_prefault(mut self, enable: bool) -> OpenOptions:
        self.prefault = enable
        return self

    # Set access pattern advice
    pub fn with_advice(mut self, advice: MmapAdvice) -> OpenOptions:
        self.advice = advice
        return self

    # Get mmap protection flags (for sys_mmap)
    pub fn get_prot_flags(self) -> i32:
        match self.mode:
            case MmapMode.ReadOnly:
                return PROT_READ
            case MmapMode.ReadWrite:
                return PROT_READ | PROT_WRITE
            case MmapMode.CopyOnWrite:
                return PROT_READ | PROT_WRITE

    # Get mmap flags (for sys_mmap)
    pub fn get_map_flags(self) -> i32:
        match self.mode:
            case MmapMode.ReadOnly:
                return MAP_PRIVATE
            case MmapMode.ReadWrite:
                return MAP_SHARED
            case MmapMode.CopyOnWrite:
                return MAP_PRIVATE

    # =========================================================================
    # Helper Methods
    # =========================================================================

    pub fn is_async_enabled(self) -> bool:
        """Check if async loading is enabled."""
        return self.async_loading

    pub fn is_prefault_enabled(self) -> bool:
        """Check if prefaulting is enabled."""
        return self.prefault

    pub fn is_read_only(self) -> bool:
        """Check if mode is read-only."""
        return self.mode.is_read_only()

    pub fn is_writable(self) -> bool:
        """Check if mode is writable."""
        return self.mode.is_writable()

    pub fn has_optimizations(self) -> bool:
        """Check if any optimizations are enabled."""
        return self.async_loading or self.prefault or not self.advice.is_normal()

    pub fn summary(self) -> text:
        """Get summary of open options."""
        val mode_str = self.mode.to_string()
        val async_str = if self.async_loading: "async" else: "sync"
        val prefault_str = if self.prefault: "prefault" else: "no-prefault"
        return "OpenOptions: {mode_str}, {async_str}, {prefault_str}"

# File I/O errors
pub enum FileError:
    NotFound(text)           # File not found at path
    PermissionDenied(text)   # Permission denied for file
    MmapFailed(text)         # mmap system call failed
    InvalidUtf8                # File contents not valid UTF-8
    OutOfBounds                # Slice operation out of bounds
    AlreadyClosed              # Operation on closed file
    IoError(text)            # Generic I/O error

impl FileError:
    # =========================================================================
    # Helper Methods
    # =========================================================================

    pub fn to_string(self) -> text:
        """Convert error to string."""
        match self:
            case NotFound(path): return "NotFound: {path}"
            case PermissionDenied(path): return "PermissionDenied: {path}"
            case MmapFailed(msg): return "MmapFailed: {msg}"
            case InvalidUtf8: return "InvalidUtf8"
            case OutOfBounds: return "OutOfBounds"
            case AlreadyClosed: return "AlreadyClosed"
            case IoError(msg): return "IoError: {msg}"

    pub fn description(self) -> text:
        """Get detailed error description."""
        match self:
            case NotFound(path): return "File not found at path: {path}"
            case PermissionDenied(path): return "Permission denied for file: {path}"
            case MmapFailed(msg): return "Memory mapping failed: {msg}"
            case InvalidUtf8: return "File contents are not valid UTF-8"
            case OutOfBounds: return "Slice operation is out of bounds"
            case AlreadyClosed: return "Operation on already closed file"
            case IoError(msg): return "I/O error: {msg}"

    pub fn is_not_found(self) -> bool:
        """Check if this is NotFound error."""
        match self:
            case NotFound(_): true
            case _: false

    pub fn is_permission_denied(self) -> bool:
        """Check if this is PermissionDenied error."""
        match self:
            case PermissionDenied(_): true
            case _: false

    pub fn is_mmap_failed(self) -> bool:
        """Check if this is MmapFailed error."""
        match self:
            case MmapFailed(_): true
            case _: false

    pub fn is_invalid_utf8(self) -> bool:
        """Check if this is InvalidUtf8 error."""
        match self:
            case InvalidUtf8: true
            case _: false

    pub fn is_out_of_bounds(self) -> bool:
        """Check if this is OutOfBounds error."""
        match self:
            case OutOfBounds: true
            case _: false

    pub fn is_already_closed(self) -> bool:
        """Check if this is AlreadyClosed error."""
        match self:
            case AlreadyClosed: true
            case _: false

    pub fn is_io_error(self) -> bool:
        """Check if this is IoError."""
        match self:
            case IoError(_): true
            case _: false

    pub fn has_path(self) -> bool:
        """Check if error includes a file path."""
        match self:
            case NotFound(_): true
            case PermissionDenied(_): true
            case _: false

    pub fn get_path(self) -> Option<text>:
        """Get the file path if present."""
        match self:
            case NotFound(path): Some(path)
            case PermissionDenied(path): Some(path)
            case _: nil

    pub fn summary(self) -> text:
        """Get error summary.

        Returns:
            Human-readable summary

        Example:
            FileError.NotFound("/tmp/test.txt").summary()
            # → "FileError: NotFound (File not found at path: /tmp/test.txt)"
        """
        val type_name = match self:
            case NotFound(_): "NotFound"
            case PermissionDenied(_): "PermissionDenied"
            case MmapFailed(_): "MmapFailed"
            case InvalidUtf8: "InvalidUtf8"
            case OutOfBounds: "OutOfBounds"
            case AlreadyClosed: "AlreadyClosed"
            case IoError(_): "IoError"

        val desc = self.description()
        return "FileError: {type_name} ({desc})"
