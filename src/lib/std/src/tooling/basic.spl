# Basic CLI operations
# Migrated from: src/driver/src/cli/basic.rs
# Purpose: Running files, code, and watching for changes

# Create a runner with appropriate GC configuration
fn create_runner(gc_log: bool, gc_off: bool) -> Runner:
    if gc_off:
        create_runner_no_gc()
    elif gc_log:
        create_runner_with_gc_logging()
    else:
        create_runner_default()

# Run a source file (.spl) or compiled binary (.smf)
fn run_file(path: text, gc_log: bool, gc_off: bool) -> i32:
    run_file_with_args(path, gc_log, gc_off, [])

# Run a source file (.spl) with command-line arguments
fn run_file_with_args(path: text, gc_log: bool, gc_off: bool, args: List<text>) -> i32:
    val runner = create_runner(gc_log, gc_off)

    # Use interpreted mode with args for spl files
    val extension = get_file_extension(path)

    val result = if is_source_extension(extension):
        run_file_interpreted_with_args(runner, path, args)
    else:
        run_compiled_file(runner, path)

    match result:
        Ok(code) => code
        Err(e) =>
            print_err("error: {e}")
            1

# Run code from a string
fn run_code(code: text, gc_log: bool, gc_off: bool) -> i32:
    val runner = create_runner(gc_log, gc_off)

    # Wrap expression in main if not already a full program
    val full_code = if needs_main_wrapper(code):
        "main = {code}"
    else:
        code

    match run_source_in_memory(runner, full_code):
        Ok(exit_code) =>
            print "{exit_code}"
            exit_code
        Err(e) =>
            print_err("error: {e}")
            1

# Watch a file for changes and auto-recompile
fn watch_file(path: text) -> i32:
    print "Watching {path} for changes..."
    print "Press Ctrl-C to stop."

    match watch_file_for_changes(path, true):
        Ok(_) => 0
        Err(e) =>
            print_err("error: {e}")
            1

# Helper: Check if code needs main wrapper
fn needs_main_wrapper(code: text) -> bool:
    not (code.contains("main") or code.contains("fn ") or code.contains("let "))

# Helper: Check if extension is source file
fn is_source_extension(ext: text) -> bool:
    ext == "spl" or ext == "simple" or ext == "sscript" or ext == ""

# Helper: Get file extension from path
fn get_file_extension(path: text) -> text:
    # Find last dot
    val parts = path.split(".")
    if parts.len() > 1:
        parts[parts.len() - 1]
    else:
        ""


# Stub types and functions
# NOTE: Placeholder - integrate with runner module when available

struct Runner:
    gc_enabled: bool

# Stub functions for runner operations
fn create_runner_default() -> Runner:
    Runner(gc_enabled: true)

fn create_runner_no_gc() -> Runner:
    Runner(gc_enabled: false)

fn create_runner_with_gc_logging() -> Runner:
    Runner(gc_enabled: true)

fn run_file_interpreted_with_args(runner: Runner, path: text, args: List<text>) -> Result<i32, text>:
    print "[run] Would run {path} with args (interpreted) (stub)"
    Ok(0)

fn run_compiled_file(runner: Runner, path: text) -> Result<i32, text>:
    print "[run] Would run compiled file {path} (stub)"
    Ok(0)

fn run_source_in_memory(runner: Runner, code: text) -> Result<i32, text>:
    print "[run] Would execute code in memory (stub)"
    Ok(0)

fn watch_file_for_changes(path: text, auto_recompile: bool) -> Result<text, text>:
    print "[watch] Would watch {path} for changes (stub)"
    Ok("watching")

# Helper for stderr output
fn print_err(msg: text):
    eprint msg
