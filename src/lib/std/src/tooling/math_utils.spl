# Math utilities for common mathematical operations
# Pure implementations without FFI dependencies

# =====================================
# Integer Math
# =====================================

# Absolute value for integers
fn abs_i32(n: i32) -> i32:
    if n < 0:
        -n
    else:
        n

fn abs_i64(n: i64) -> i64:
    if n < 0:
        -n
    else:
        n

# Minimum of two integers
fn min_i32(a: i32, b: i32) -> i32:
    if a < b:
        a
    else:
        b

fn min_i64(a: i64, b: i64) -> i64:
    if a < b:
        a
    else:
        b

# Maximum of two integers
fn max_i32(a: i32, b: i32) -> i32:
    if a > b:
        a
    else:
        b

fn max_i64(a: i64, b: i64) -> i64:
    if a > b:
        a
    else:
        b

# Clamp value between min and max
fn clamp_i32(value: i32, min_val: i32, max_val: i32) -> i32:
    if value < min_val:
        return min_val
    if value > max_val:
        return max_val
    value

fn clamp_i64(value: i64, min_val: i64, max_val: i64) -> i64:
    if value < min_val:
        return min_val
    if value > max_val:
        return max_val
    value

# Sign of integer (-1, 0, 1)
fn sign_i32(n: i32) -> i32:
    if n < 0:
        return -1
    if n > 0:
        return 1
    0

fn sign_i64(n: i64) -> i64:
    if n < 0:
        return -1
    if n > 0:
        return 1
    0

# Power function for integers (exponentiation by squaring)
fn pow_i32(base: i32, exp: u32) -> i32:
    if exp == 0:
        return 1

    var result = 1
    var b = base
    var e = exp

    while e > 0:
        if e % 2 == 1:
            result = result * b
        b = b * b
        e = e / 2

    result

fn pow_i64(base: i64, exp: u32) -> i64:
    if exp == 0:
        return 1

    var result: i64 = 1
    var b = base
    var e = exp

    while e > 0:
        if e % 2 == 1:
            result = result * b
        b = b * b
        e = e / 2

    result

# Greatest common divisor (Euclidean algorithm)
fn gcd(a: i32, b: i32) -> i32:
    var x = abs_i32(a)
    var y = abs_i32(b)

    while y != 0:
        val temp = y
        y = x % y
        x = temp

    x

# Least common multiple
fn lcm(a: i32, b: i32) -> i32:
    if a == 0 or b == 0:
        return 0

    abs_i32(a * b) / gcd(a, b)

# Check if number is even
fn is_even(n: i32) -> bool:
    n % 2 == 0

# Check if number is odd
fn is_odd(n: i32) -> bool:
    n % 2 != 0

# Check if number is power of two
fn is_power_of_two(n: i32) -> bool:
    n > 0 and (n & (n - 1)) == 0

# Next power of two
fn next_power_of_two(n: i32) -> i32:
    if n <= 1:
        return 1

    var power = 1
    while power < n:
        power = power * 2

    power

# Factorial (iterative)
fn factorial(n: u32) -> u64:
    if n == 0 or n == 1:
        return 1

    var result: u64 = 1
    var i = 2

    while i <= n:
        result = result * (i as u64)
        i = i + 1

    result

# Binomial coefficient (n choose k)
fn binomial(n: u32, k: u32) -> u64:
    if k > n:
        return 0

    if k == 0 or k == n:
        return 1

    # Use symmetry to reduce computation
    var k_opt = k
    if k > n - k:
        k_opt = n - k

    var result: u64 = 1
    var i: u32 = 0

    while i < k_opt:
        result = result * ((n - i) as u64)
        result = result / ((i + 1) as u64)
        i = i + 1

    result

# =====================================
# Float Math
# =====================================

# Absolute value for floats
fn abs_f32(n: f32) -> f32:
    if n < 0.0:
        -n
    else:
        n

fn abs_f64(n: f64) -> f64:
    if n < 0.0:
        -n
    else:
        n

# Minimum of two floats
fn min_f32(a: f32, b: f32) -> f32:
    if a < b:
        a
    else:
        b

fn min_f64(a: f64, b: f64) -> f64:
    if a < b:
        a
    else:
        b

# Maximum of two floats
fn max_f32(a: f32, b: f32) -> f32:
    if a > b:
        a
    else:
        b

fn max_f64(a: f64, b: f64) -> f64:
    if a > b:
        a
    else:
        b

# Clamp float between min and max
fn clamp_f32(value: f32, min_val: f32, max_val: f32) -> f32:
    if value < min_val:
        return min_val
    if value > max_val:
        return max_val
    value

fn clamp_f64(value: f64, min_val: f64, max_val: f64) -> f64:
    if value < min_val:
        return min_val
    if value > max_val:
        return max_val
    value

# Sign of float (-1.0, 0.0, 1.0)
fn sign_f32(n: f32) -> f32:
    if n < 0.0:
        return -1.0
    if n > 0.0:
        return 1.0
    0.0

fn sign_f64(n: f64) -> f64:
    if n < 0.0:
        return -1.0
    if n > 0.0:
        return 1.0
    0.0

# Linear interpolation
fn lerp(a: f64, b: f64, t: f64) -> f64:
    a + (b - a) * t

# Inverse linear interpolation
fn inverse_lerp(a: f64, b: f64, value: f64) -> f64:
    if a == b:
        return 0.0

    (value - a) / (b - a)

# Remap value from one range to another
fn remap(value: f64, from_min: f64, from_max: f64, to_min: f64, to_max: f64) -> f64:
    val t = inverse_lerp(from_min, from_max, value)
    lerp(to_min, to_max, t)

# Check if floats are approximately equal (with epsilon)
fn approx_equal_f32(a: f32, b: f32, epsilon: f32) -> bool:
    abs_f32(a - b) < epsilon

fn approx_equal_f64(a: f64, b: f64, epsilon: f64) -> bool:
    abs_f64(a - b) < epsilon

# Floor (round down to nearest integer)
fn floor_f64(n: f64) -> i64:
    val int_part = n as i64
    if n < 0.0 and n != (int_part as f64):
        int_part - 1
    else:
        int_part

# Ceiling (round up to nearest integer)
fn ceil_f64(n: f64) -> i64:
    val int_part = n as i64
    if n > 0.0 and n != (int_part as f64):
        int_part + 1
    else:
        int_part

# Round to nearest integer
fn round_f64(n: f64) -> i64:
    if n >= 0.0:
        floor_f64(n + 0.5)
    else:
        ceil_f64(n - 0.5)

# Fractional part
fn fract(n: f64) -> f64:
    n - (floor_f64(n) as f64)

# =====================================
# Range Operations
# =====================================

# Check if value is in range [min, max]
fn in_range_i32(value: i32, min_val: i32, max_val: i32) -> bool:
    value >= min_val and value <= max_val

fn in_range_f64(value: f64, min_val: f64, max_val: f64) -> bool:
    value >= min_val and value <= max_val

# Wrap value to range [min, max)
fn wrap_i32(value: i32, min_val: i32, max_val: i32) -> i32:
    val range = max_val - min_val
    if range <= 0:
        return min_val

    var result = value
    while result < min_val:
        result = result + range
    while result >= max_val:
        result = result - range

    result

fn wrap_f64(value: f64, min_val: f64, max_val: f64) -> f64:
    val range = max_val - min_val
    if range <= 0.0:
        return min_val

    var result = value
    while result < min_val:
        result = result + range
    while result >= max_val:
        result = result - range

    result

# =====================================
# Statistical Functions
# =====================================

# Average of a list of integers
fn average_i32(values: List<i32>) -> f64:
    if values.is_empty():
        return 0.0

    var sum: i64 = 0
    for val in values:
        sum = sum + (val as i64)

    (sum as f64) / (values.len() as f64)

# Average of a list of floats
fn average_f64(values: List<f64>) -> f64:
    if values.is_empty():
        return 0.0

    var sum = 0.0
    for val in values:
        sum = sum + val

    sum / (values.len() as f64)

# Median of a list (requires sorted list)
fn median_i32(sorted_values: List<i32>) -> f64:
    if sorted_values.is_empty():
        return 0.0

    val len = sorted_values.len()
    if len % 2 == 1:
        # Odd length - return middle value
        return sorted_values[len / 2] as f64
    else:
        # Even length - return average of two middle values
        val mid1 = sorted_values[len / 2 - 1]
        val mid2 = sorted_values[len / 2]
        return (mid1 + mid2) as f64 / 2.0

# Sum of a list
fn sum_i32(values: List<i32>) -> i32:
    var total = 0
    for val in values:
        total = total + val
    total

fn sum_i64(values: List<i64>) -> i64:
    var total: i64 = 0
    for val in values:
        total = total + val
    total

fn sum_f64(values: List<f64>) -> f64:
    var total = 0.0
    for val in values:
        total = total + val
    total

# Product of a list
fn product_i32(values: List<i32>) -> i32:
    if values.is_empty():
        return 1

    var result = 1
    for val in values:
        result = result * val
    result

fn product_f64(values: List<f64>) -> f64:
    if values.is_empty():
        return 1.0

    var result = 1.0
    for val in values:
        result = result * val
    result
