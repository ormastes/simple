# String utilities for text processing

# Trim suffix from end of string
fn trim_end(s: text, suffix: text) -> text:
    if s.ends_with(suffix):
        s.substring(0, s.len() - suffix.len())
    else:
        s

# Trim prefix from start of string
fn trim_start(s: text, prefix: text) -> text:
    if s.starts_with(prefix):
        s.substring(prefix.len(), s.len())
    else:
        s

# Trim multiple suffixes in sequence
fn trim_end_all(s: text, suffixes: List<text>) -> text:
    var result = s
    for suffix in suffixes:
        result = trim_end(s=result, suffix=suffix)
    result

# Trim multiple prefixes in sequence
fn trim_start_all(s: text, prefixes: List<text>) -> text:
    var result = s
    for prefix in prefixes:
        result = trim_start(s=result, prefix=prefix)
    result

# Check if string contains any of the given patterns
fn contains_any(s: text, patterns: List<text>) -> bool:
    patterns.iter().any(\p: s.contains(p))

# Check if string starts with any of the given prefixes
fn starts_with_any(s: text, prefixes: List<text>) -> bool:
    prefixes.iter().any(\p: s.starts_with(p))

# Check if string ends with any of the given suffixes
fn ends_with_any(s: text, suffixes: List<text>) -> bool:
    suffixes.iter().any(\p: s.ends_with(p))

# Split string and take first N parts
fn split_take(s: text, separator: text, n: i32) -> List<text>:
    val parts = s.split(separator)
    if parts.len() <= n:
        parts
    else:
        parts[0..n]

# Split string and take last N parts
fn split_take_last(s: text, separator: text, n: i32) -> List<text>:
    val parts = s.split(separator)
    if parts.len() <= n:
        parts
    else:
        parts[parts.len()-n..parts.len()]

# Join list of strings with separator, filtering empty strings
fn join_non_empty(parts: List<text>, separator: text) -> text:
    parts.filter(\p: p.len() > 0).join(separator)

# Count occurrences of substring
fn count_occurrences(s: text, pattern: text) -> i32:
    if pattern.is_empty():
        return 0

    var count = 0
    var pos = 0

    while pos < s.len():
        match s.substring(pos, s.len()).find(pattern):
            Some(idx) =>
                count = count + 1
                pos = pos + idx + pattern.len()
            None =>
                break

    count

# Extract substring between two delimiters
fn extract_between(s: text, start_delim: text, end_delim: text) -> Option<text>:
    match s.find(start_delim):
        None => None
        Some(start_idx) =>
            val after_start = start_idx + start_delim.len()
            val remainder = s.substring(after_start, s.len())
            match remainder.find(end_delim):
                None => None
                Some(end_idx) =>
                    Some(remainder.substring(0, end_idx))

# Extract all substrings between delimiters
fn extract_all_between(s: text, start_delim: text, end_delim: text) -> List<text>:
    var results = []
    var remaining = s

    loop:
        match extract_between(s=remaining, start_delim=start_delim, end_delim=end_delim):
            None => break
            Some(extracted) =>
                results.push(extracted)
                match remaining.find(start_delim):
                    Some(start_idx) =>
                        val after_start = start_idx + start_delim.len()
                        match remaining.substring(after_start, remaining.len()).find(end_delim):
                            Some(end_idx) =>
                                val skip_to = after_start + end_idx + end_delim.len()
                                remaining = remaining.substring(skip_to, remaining.len())
                            None =>
                                break
                    None =>
                        break

    results

# Truncate string to max length, adding ellipsis if needed
fn truncate(s: text, max_len: i32, ellipsis: text) -> text:
    if s.len() <= max_len:
        return s

    val available = max_len - ellipsis.len()
    if available <= 0:
        return ellipsis

    s.substring(0, available) + ellipsis

# Pad string to specified length with character
fn pad_left(s: text, total_len: i32, pad_char: text) -> text:
    if s.len() >= total_len:
        return s

    val padding_needed = total_len - s.len()
    var padding = ""
    for _ in 0..padding_needed:
        padding = padding + pad_char

    padding + s

fn pad_right(s: text, total_len: i32, pad_char: text) -> text:
    if s.len() >= total_len:
        return s

    val padding_needed = total_len - s.len()
    var padding = ""
    for _ in 0..padding_needed:
        padding = padding + pad_char

    s + padding

# Remove all whitespace from string
fn remove_whitespace(s: text) -> text:
    s.replace(" ", "")
        .replace("\t", "")
        .replace("\n", "")
        .replace("\r", "")

# Collapse multiple spaces into single space
fn normalize_whitespace(s: text) -> text:
    var result = s
    while result.contains("  "):
        result = result.replace("  ", " ")
    result.trim()

# Convert to snake_case
fn to_snake_case(s: text) -> text:
    # Simple implementation: lowercase and replace spaces/hyphens with underscores
    s.lower()
        .replace(" ", "_")
        .replace("-", "_")

# Convert to kebab-case
fn to_kebab_case(s: text) -> text:
    s.lower()
        .replace(" ", "-")
        .replace("_", "-")

# Check if string is alphanumeric
fn is_alphanumeric_str(s: text) -> bool:
    if s.is_empty():
        return false

    for ch in s.chars():
        if not (ch.is_alphabetic() or ch.is_numeric()):
            return false

    true

# Check if string is valid identifier
fn is_valid_identifier(s: text) -> bool:
    if s.is_empty():
        return false

    # First character must be letter or underscore
    val first = s.chars()[0]
    if not (first.is_alphabetic() or first == "_"):
        return false

    # Rest can be letters, numbers, or underscore
    for ch in s.chars():
        if not (ch.is_alphanumeric() or ch == "_"):
            return false

    true

# Split string once by delimiter
fn split_once(s: text, delimiter: text) -> Option<(text, text)>:
    match s.find(delimiter):
        None => None
        Some(idx) =>
            val first = s.substring(0, idx)
            val rest = s.substring(idx + delimiter.len(), s.len())
            Some((first, rest))

# Repeat string N times
fn repeat(s: text, count: i32) -> text:
    if count <= 0:
        return ""

    var result = ""
    var i = 0
    while i < count:
        result = result + s
        i = i + 1
    result

# Capitalize first letter
fn capitalize(s: text) -> text:
    if s.is_empty():
        return s

    val chars = s.chars()
    val first = chars[0].upper()
    if s.len() == 1:
        return first

    val rest = s.substring(1, s.len())
    first + rest

# Title case: capitalize first letter of each word
fn title_case(s: text) -> text:
    val words = s.split(" ")
    var result_words: List<text> = []

    for word in words:
        if word.len() > 0:
            result_words.push(capitalize(word))
        else:
            result_words.push(word)

    result_words.join(" ")

# Reverse a string
fn reverse(s: text) -> text:
    if s.is_empty():
        return s

    val chars = s.chars()
    var result = ""
    var i = chars.len() - 1

    while i >= 0:
        result = result + chars[i]
        i = i - 1

    result

# Check if string contains only whitespace
fn is_whitespace(s: text) -> bool:
    if s.is_empty():
        return true

    for ch in s.chars():
        if ch != " " and ch != "\t" and ch != "\n" and ch != "\r":
            return false

    true

# Replace all occurrences
fn replace_all(s: text, old: text, new: text) -> text:
    if old.is_empty():
        return s

    var result = s
    while result.contains(old):
        result = result.replace(old, new)

    result

# Get substring from start (inclusive) to end (exclusive)
# Safer than raw substring with bounds checking
fn safe_substring(s: text, start: i32, end: i32) -> text:
    val len = s.len()

    var actual_start = start
    var actual_end = end

    # Clamp to valid range
    if actual_start < 0:
        actual_start = 0
    if actual_start > len:
        actual_start = len

    if actual_end < 0:
        actual_end = 0
    if actual_end > len:
        actual_end = len

    if actual_start >= actual_end:
        return ""

    s.substring(actual_start, actual_end)

# Left justify string to width
fn ljust(s: text, width: i32, fill: text) -> text:
    pad_right(s=s, total_len=width, pad_char=fill)

# Right justify string to width
fn rjust(s: text, width: i32, fill: text) -> text:
    pad_left(s=s, total_len=width, pad_char=fill)

# Center string in width
fn center(s: text, width: i32, fill: text) -> text:
    if s.len() >= width:
        return s

    val total_padding = width - s.len()
    val left_pad = total_padding / 2
    val right_pad = total_padding - left_pad

    var left = ""
    for _ in 0..left_pad:
        left = left + fill

    var right = ""
    for _ in 0..right_pad:
        right = right + fill

    left + s + right
