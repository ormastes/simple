# Parallel Test Execution
# Run tests in parallel for faster feedback

use tooling.testing.runner.{TestRunResult, TestSuite}
use tooling.testing.discovery.TestDiscovery

# Worker pool configuration
pub class WorkerPoolConfig:
    pub workers: i32
    pub isolation: IsolationLevel
    pub timeout_seconds: i32

    pub fn new(): WorkerPoolConfig =
        """Create default worker pool configuration."""
        WorkerPoolConfig {
            workers: 4,
            isolation: IsolationLevel::Process,
            timeout_seconds: 300
        }

    pub fn with_workers(self, count: i32): WorkerPoolConfig =
        """Set worker count.

        Args:
            count: Number of workers

        Returns:
            Modified config
        """
        self.workers = count
        self

    pub fn with_isolation(self, level: IsolationLevel): WorkerPoolConfig =
        """Set isolation level.

        Args:
            level: Isolation level

        Returns:
            Modified config
        """
        self.isolation = level
        self

    pub fn with_timeout(self, seconds: i32): WorkerPoolConfig =
        """Set timeout.

        Args:
            seconds: Timeout in seconds

        Returns:
            Modified config
        """
        self.timeout_seconds = seconds
        self

    pub fn is_isolated(self): bool =
        """Check if isolation is memory-isolated."""
        self.isolation.is_isolated()

    pub fn summary(self): text =
        """Get config summary."""
        "WorkerPool: {self.workers} workers, {self.isolation.to_string()} isolation, {self.timeout_seconds}s timeout"

# Isolation level for parallel execution
pub enum IsolationLevel:
    Thread      # Thread-based parallelism (shared memory)
    Process     # Process-based parallelism (full isolation)
    Actor       # Actor-based parallelism

    pub fn to_string(self): text =
        """Convert isolation level to string.

        Returns:
            Level name

        Example:
            IsolationLevel::Process.to_string()  # → "process"
        """
        match self:
            IsolationLevel::Thread: "thread"
            IsolationLevel::Process: "process"
            IsolationLevel::Actor: "actor"

    pub fn description(self): text =
        """Get isolation level description.

        Returns:
            Human-readable description

        Example:
            IsolationLevel::Process.description()
            # → "Process-based parallelism with full isolation"
        """
        match self:
            IsolationLevel::Thread:
                "Thread-based parallelism with shared memory"
            IsolationLevel::Process:
                "Process-based parallelism with full isolation"
            IsolationLevel::Actor:
                "Actor-based parallelism with message passing"

    pub fn is_isolated(self): bool =
        """Check if isolation provides memory isolation.

        Returns:
            True if memory is isolated between workers

        Example:
            IsolationLevel::Thread.is_isolated()  # → false (shared memory)
            IsolationLevel::Process.is_isolated()  # → true (separate memory)
        """
        match self:
            IsolationLevel::Thread: false
            IsolationLevel::Process: true
            IsolationLevel::Actor: true

# Work item for parallel execution
pub class WorkItem:
    pub id: i32
    pub suite: TestSuite
    pub status: WorkStatus

    pub fn new(id: i32, suite: TestSuite): WorkItem =
        """Create work item.

        Args:
            id: Work item ID
            suite: Test suite to execute

        Returns:
            Work item
        """
        WorkItem {
            id: id,
            suite: suite,
            status: WorkStatus::Pending
        }

    pub fn is_pending(self): bool =
        """Check if work item is pending.

        Returns:
            True if pending
        """
        match self.status:
            WorkStatus::Pending: true
            _: false

    pub fn is_running(self): bool =
        """Check if work item is running.

        Returns:
            True if running
        """
        match self.status:
            WorkStatus::Running: true
            _: false

    pub fn is_done(self): bool =
        """Check if work item is done.

        Returns:
            True if completed or failed
        """
        self.status.is_done()

    pub fn mark_running(self):
        """Mark work item as running."""
        self.status = WorkStatus::Running

    pub fn mark_completed(self):
        """Mark work item as completed."""
        self.status = WorkStatus::Completed

    pub fn mark_failed(self):
        """Mark work item as failed."""
        self.status = WorkStatus::Failed

    pub fn summary(self): text =
        """Get work item summary."""
        "WorkItem #{self.id}: {self.suite.name} ({self.status.to_string()})"

# Work item status
pub enum WorkStatus:
    Pending
    Running
    Completed
    Failed

    pub fn to_string(self): text =
        """Convert work status to string.

        Returns:
            Status name

        Example:
            WorkStatus::Running.to_string()  # → "running"
        """
        match self:
            WorkStatus::Pending: "pending"
            WorkStatus::Running: "running"
            WorkStatus::Completed: "completed"
            WorkStatus::Failed: "failed"

    pub fn is_done(self): bool =
        """Check if work item is done (completed or failed).

        Returns:
            True if done

        Example:
            WorkStatus::Completed.is_done()  # → true
            WorkStatus::Running.is_done()  # → false
        """
        match self:
            WorkStatus::Pending: false
            WorkStatus::Running: false
            WorkStatus::Completed: true
            WorkStatus::Failed: true

    pub fn description(self): text =
        """Get status description."""
        match self:
            WorkStatus::Pending: "Waiting to execute"
            WorkStatus::Running: "Currently executing"
            WorkStatus::Completed: "Successfully completed"
            WorkStatus::Failed: "Execution failed"

# Parallel test executor
pub class ParallelExecutor:
    pub config: WorkerPoolConfig
    pub verbose: bool

    pub fn new(workers: i32, isolation: IsolationLevel): ParallelExecutor =
        """Create parallel executor.

        Args:
            workers: Number of worker threads/processes
            isolation: Isolation level

        Returns:
            Parallel executor

        Example:
            val executor = ParallelExecutor.new(4, IsolationLevel::Process)

            val result = executor.run_parallel(
                test_suites,
                fn(suite): run_test_suite(suite)
            )

            print("Ran {result.total_tests} tests in {result.duration_ms}ms")
        """
        var config = WorkerPoolConfig.new()
        config.workers = workers
        config.isolation = isolation

        ParallelExecutor {
            config: config,
            verbose: false
        }

    pub fn set_verbose(self, enabled: bool):
        """Enable verbose logging."""
        self.verbose = enabled

    pub fn is_verbose(self): bool =
        """Check if verbose."""
        self.verbose

    pub fn with_verbose(self, enabled: bool): ParallelExecutor =
        """Set verbose (fluent API)."""
        self.verbose = enabled
        self

    pub fn summary(self): text =
        """Get executor summary."""
        val verbose_str = if self.verbose: "true" else: "false"
        "ParallelExecutor: {self.config.workers} workers, {self.config.isolation.to_string()} (verbose: {verbose_str})"

    pub fn set_timeout(self, seconds: i32):
        """Set worker timeout.

        Args:
            seconds: Timeout in seconds
        """
        self.config.timeout_seconds = seconds

    pub fn run_parallel(
        self,
        suites: List<TestSuite>,
        runner: (TestSuite) -> TestRunResult
    ): TestRunResult =
        """Run test suites in parallel.

        Args:
            suites: Test suites to run
            runner: Function to run single suite

        Returns:
            Combined test result

        Example:
            val executor = ParallelExecutor.new(4, IsolationLevel::Process)

            val result = executor.run_parallel(suites, fn(suite):
                # This runs in parallel across 4 workers
                return run_test_suite(suite)
            )

            # 4x speedup on 4-core machine
            print("Completed in {result.duration_ms}ms")
        """
        @extern("runtime", "rt_time_now_unix_micros")
        fn _rt_time_now_unix_micros() -> i64

        val start_time = _rt_time_now_unix_micros() / 1000  # Convert microseconds to milliseconds

        if self.verbose:
            print("Running {suites.len()} test suites on {self.config.workers} workers")

        # Create work items
        val work_items = self.create_work_items(suites)

        # Execute work items in parallel
        val results = self.execute_work_items(work_items, runner)

        # Aggregate results
        val combined = self.aggregate_results(results)

        val end_time = _rt_time_now_unix_micros() / 1000  # Convert microseconds to milliseconds
        combined.duration_ms = end_time - start_time

        if self.verbose:
            print("Parallel execution completed in {combined.duration_ms}ms")

        combined

    fn create_work_items(suites: List<TestSuite>): List<WorkItem> =
        """Create work items from test suites.

        Args:
            suites: Test suites

        Returns:
            Work items
        """
        val items: List<WorkItem> = []

        for (i, suite) in suites.enumerate():
            items.append(WorkItem.new(i, suite))

        items

    fn execute_work_items(work_items: List<WorkItem>,
        runner: (TestSuite) -> TestRunResult
    ): List<TestRunResult> =
        """Execute work items in parallel.

        Args:
            work_items: Work items to execute
            runner: Test runner function

        Returns:
            List of test results
        """
        match self.config.isolation:
            IsolationLevel::Thread:
                self.execute_with_threads(work_items, runner)
            IsolationLevel::Process:
                self.execute_with_processes(work_items, runner)
            IsolationLevel::Actor:
                self.execute_with_actors(work_items, runner)

    fn execute_with_threads(work_items: List<WorkItem>,
        runner: (TestSuite) -> TestRunResult
    ): List<TestRunResult> =
        """Execute work items using threads.

        Args:
            work_items: Work items
            runner: Test runner

        Returns:
            Test results
        """
        import concurrency.threads.{rt_thread_spawn_isolated, rt_thread_join, ThreadHandle}

        val results: List<TestRunResult> = []
        var handles: List<(i64, WorkItem)> = []

        # Spawn a thread for each work item (up to worker count)
        var spawned = 0
        for item in work_items:
            if spawned >= self.worker_count:
                # Wait for one to complete before spawning more
                if handles.len() > 0:
                    val (handle, completed_item) = handles.remove(0)
                    val thread = ThreadHandle(_handle: handle)
                    val result = thread.join() as TestRunResult
                    results.append(result)
                    spawned -= 1

            # Spawn worker thread
            val work_fn = || runner(item.suite)
            val handle = rt_thread_spawn_isolated(work_fn, ())
            handles.append((handle, item))
            spawned += 1

        # Wait for remaining threads
        for (handle, item) in handles:
            val thread = ThreadHandle(_handle: handle)
            val result = thread.join() as TestRunResult
            results.append(result)

        results

    fn execute_with_processes(work_items: List<WorkItem>,
        runner: (TestSuite) -> TestRunResult
    ): List<TestRunResult> =
        """Execute work items using processes.

        Args:
            work_items: Work items
            runner: Test runner

        Returns:
            Test results
        """
        import shell

        val results: List<TestRunResult> = []

        # Serialize work items to temp files and spawn processes
        for item in work_items:
            # Create temp file with test spec
            val temp_path = "/tmp/test_work_{item.id}.json"
            serialize_work_item(temp_path, item)

            # Run test in subprocess
            val proc_result = shell.run("simple", ["test", "--work-file", temp_path])

            # Parse result from subprocess output
            val result = parse_test_output(proc_result.stdout)
            results.append(result)

            # Cleanup temp file
            @extern("runtime", "rt_file_delete")
            fn _rt_file_delete(path_ptr: &u8, path_len: u64)
            _rt_file_delete(temp_path.ptr(), temp_path.len())

        results

    fn execute_with_actors(work_items: List<WorkItem>,
        runner: (TestSuite) -> TestRunResult
    ): List<TestRunResult> =
        """Execute work items using actors.

        Args:
            work_items: Work items
            runner: Test runner

        Returns:
            Test results
        """
        @extern("runtime", "rt_actor_spawn")
        fn _rt_actor_spawn(fn_ptr: u64, initial_state: Any) -> i64

        @extern("runtime", "rt_actor_send")
        fn _rt_actor_send(actor: i64, message: Any)

        @extern("runtime", "rt_actor_recv")
        fn _rt_actor_recv(timeout_ms: i64) -> Any

        val results: List<TestRunResult> = []

        # Create worker actor function
        fn worker_actor(state: Any):
            while true:
                val msg = _rt_actor_recv(-1)  # Block until message
                match msg:
                    WorkItem(item) ->
                        val result = runner(item.suite)
                        # Send result back
                        _rt_actor_send(state as i64, result)
                    StopMessage ->
                        break
                    _ ->
                        pass

        # Spawn worker actors
        var workers: List<i64> = []
        val coordinator_actor = _rt_actor_spawn(0, ())  # Self as coordinator

        for i in 0..self.worker_count:
            val worker = _rt_actor_spawn(worker_actor as u64, coordinator_actor)
            workers.append(worker)

        # Distribute work items round-robin
        var worker_idx = 0
        for item in work_items:
            _rt_actor_send(workers[worker_idx], item)
            worker_idx = (worker_idx + 1) % self.worker_count

        # Collect results
        for _ in 0..work_items.len():
            val result = _rt_actor_recv(30000) as TestRunResult  # 30s timeout
            results.append(result)

        # Stop workers
        for worker in workers:
            _rt_actor_send(worker, StopMessage)

        results


# Helper functions for process-based parallelism
fn serialize_work_item(path: text, item: WorkItem):
    """Serialize work item to JSON file."""
    @extern("runtime", "rt_file_write")
    fn _rt_file_write(path_ptr: &u8, path_len: u64, data_ptr: &u8, data_len: u64) -> bool

    val json = "{\"id\": {item.id}, \"suite\": \"{item.suite.name}\"}"
    _rt_file_write(path.ptr(), path.len(), json.ptr(), json.len())

fn parse_test_output(output: text): TestRunResult =
    """Parse test result from subprocess output."""
    # Simple parsing - expect JSON-like output
    var result = TestRunResult.new()

    if output.contains("\"passed\":"):
        val passed_start = output.find("\"passed\":") + 9
        val passed_end = output.find(",", passed_start)
        result.passed = parse_int(output.substring(passed_start, passed_end))

    if output.contains("\"failed\":"):
        val failed_start = output.find("\"failed\":") + 9
        val failed_end = output.find(",", failed_start)
        result.failed = parse_int(output.substring(failed_start, failed_end))

    result

fn parse_int(s: text): i32 =
    """Parse integer from string."""
    var result: i32 = 0
    for ch in s.trim().chars():
        if ch >= '0' and ch <= '9':
            result = result * 10 + ((ch as i32) - ('0' as i32))
        else:
            break
    result

# Message types for actor-based parallelism
enum ActorMessage:
    WorkItem(WorkItem)
    StopMessage

    fn aggregate_results(results: List<TestRunResult>): TestRunResult =
        """Aggregate parallel test results.

        Args:
            results: Individual test results

        Returns:
            Combined result
        """
        val combined = TestRunResult.new()

        for result in results:
            combined.total_tests += result.total_tests
            combined.passed += result.passed
            combined.failed += result.failed
            combined.skipped += result.skipped
            combined.failures.extend(result.failures)

        combined

    pub fn estimate_speedup(self, suite_count: i32): f64 =
        """Estimate speedup from parallel execution.

        Args:
            suite_count: Number of test suites

        Returns:
            Estimated speedup factor

        Example:
            val executor = ParallelExecutor.new(4, IsolationLevel::Process)
            val speedup = executor.estimate_speedup(12)
            # → ~3.5x (accounting for overhead)
        """
        val workers = self.config.workers as f64
        val suites = suite_count as f64

        if suites <= workers:
            return suites  # Limited by suite count

        # Amdahl's law with 90% parallelizable work
        val parallel_fraction = 0.9
        val speedup = 1.0 / ((1.0 - parallel_fraction) + (parallel_fraction / workers))

        speedup

    pub fn get_worker_count(self): i32 =
        """Get number of workers.

        Returns:
            Worker count
        """
        self.config.workers

    pub fn get_optimal_workers(cores: i32, suite_count: i32): i32 =
        """Calculate optimal worker count.

        Args:
            cores: CPU core count
            suite_count: Number of test suites

        Returns:
            Optimal worker count

        Example:
            # 8 cores, 100 test suites
            ParallelExecutor::get_optimal_workers(8, 100)
            # → 8 (use all cores)

            # 8 cores, 3 test suites
            ParallelExecutor::get_optimal_workers(8, 3)
            # → 3 (no benefit from more workers)
        """
        if suite_count < cores:
            suite_count
        else:
            cores
