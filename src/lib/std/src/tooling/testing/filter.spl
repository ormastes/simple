# Test Filtering & Selection
# Run subset of tests based on filters

use tooling.core.project.Language
use tooling.testing.discovery.TestSuite

# Test filter criteria
pub class TestFilter:
    pub pattern: text
    pub language: Option<Language>
    pub file_patterns: List<text>
    pub tag_filters: List<text>
    pub changed_files_only: bool
    pub changed_files: List<text>

    pub fn new(): TestFilter =
        """Create empty test filter.

        Returns:
            Empty filter (matches all tests)

        Example:
            val filter = TestFilter.new()

            filter.by_pattern("integration")
            filter.by_language(Language.Rust)

            val filtered_tests = filter.apply(all_tests)
            print("Running {filtered_tests.len()} filtered tests")
        """
        TestFilter {
            pattern: "",
            language: none,
            file_patterns: [],
            tag_filters: [],
            changed_files_only: false,
            changed_files: []
        }

    pub fn has_filters(self): bool =
        """Check if any filters are set.

        Returns:
            True if filters are active

        Example:
            if not filter.has_filters():
                print("Running all tests")
        """
        self.pattern != "" or
        self.language.is_some() or
        self.file_patterns.len() > 0 or
        self.tag_filters.len() > 0 or
        self.changed_files_only

    pub fn is_empty(self): bool =
        """Check if filter is empty (no filters set).

        Returns:
            True if no filters
        """
        not self.has_filters()

    pub fn summary(self): text =
        """Get filter summary.

        Returns:
            Human-readable summary

        Example:
            filter.summary()
            # â†’ "Filters: pattern='integration', language=Rust, 2 file patterns"
        """
        var parts: List<text> = []

        if self.pattern != "":
            parts.append("pattern='{self.pattern}'")

        match self.language:
            some(lang):
                parts.append("language={lang}")
            none:
                pass

        if self.file_patterns.len() > 0:
            parts.append("{self.file_patterns.len()} file patterns")

        if self.tag_filters.len() > 0:
            parts.append("{self.tag_filters.len()} tags")

        if self.changed_files_only:
            parts.append("changed files only")

        if parts.len() == 0:
            "No filters (all tests)"
        else:
            "Filters: {parts.join(', ')}"

    pub fn clear(self):
        """Clear all filters."""
        self.pattern = ""
        self.language = none
        self.file_patterns = []
        self.tag_filters = []
        self.changed_files_only = false

    pub fn by_pattern(self, pattern: text):
        """Filter by test name pattern.

        Args:
            pattern: Substring or regex pattern

        Example:
            filter.by_pattern("integration")
            # Matches: test_integration_api, integration_db_spec, etc.
        """
        self.pattern = pattern

    pub fn by_language(self, language: Language):
        """Filter by language.

        Args:
            language: Language to filter by

        Example:
            filter.by_language(Language.Rust)
            # Only run Rust tests
        """
        self.language = some(language)

    pub fn by_file(self, file_pattern: text):
        """Filter by file pattern.

        Args:
            file_pattern: Glob pattern for files

        Example:
            filter.by_file("api/**/*_spec.spl")
            # Only run tests in api directory
        """
        self.file_patterns.append(file_pattern)

    pub fn by_tag(self, tag: text):
        """Filter by test tag/marker.

        Args:
            tag: Tag to filter by

        Example:
            filter.by_tag("slow")
            # Only run tests marked as @slow
        """
        self.tag_filters.append(tag)

    pub fn by_changed_files(self, changed_files: List<text>):
        """Filter to tests affected by changed files.

        Args:
            changed_files: Files that changed

        Example:
            val changed = git.get_changed_files("HEAD~1")
            filter.by_changed_files(changed)
            # Only run tests covering changed code
        """
        self.changed_files_only = true
        self.changed_files = changed_files

    pub fn apply(self, suites: List<TestSuite>): List<TestSuite> =
        """Apply filter to test suites.

        Args:
            suites: All test suites

        Returns:
            Filtered test suites

        Example:
            val filter = TestFilter.new()
            filter.by_pattern("unit")
            filter.by_language(Language.Simple)

            val filtered = filter.apply(all_suites)
            # Only Simple unit tests
        """
        var filtered = suites

        # Apply language filter
        match self.language:
            some(lang):
                filtered = self.filter_by_language(filtered, lang)
            none:
                pass

        # Apply pattern filter
        if not self.pattern.is_empty():
            filtered = self.filter_by_pattern(filtered, self.pattern)

        # Apply file pattern filter
        if self.file_patterns.len() > 0:
            filtered = self.filter_by_file_patterns(filtered, self.file_patterns)

        filtered

    fn filter_by_language(suites: List<TestSuite>,
        language: Language
    ): List<TestSuite> =
        """Filter suites by language.

        Args:
            suites: Test suites
            language: Language to match

        Returns:
            Filtered suites
        """
        val filtered: List<TestSuite> = []

        for suite in suites:
            if suite.language == language:
                filtered.append(suite)

        filtered

    fn filter_by_pattern(suites: List<TestSuite>,
        pattern: text
    ): List<TestSuite> =
        """Filter suites by name pattern.

        Args:
            suites: Test suites
            pattern: Pattern to match

        Returns:
            Filtered suites
        """
        val filtered: List<TestSuite> = []

        for suite in suites:
            if self.matches_pattern(suite, pattern):
                filtered.append(suite)

        filtered

    fn filter_by_file_patterns(suites: List<TestSuite>,
        patterns: List<text>
    ): List<TestSuite> =
        """Filter suites by file patterns.

        Args:
            suites: Test suites
            patterns: Glob patterns

        Returns:
            Filtered suites
        """
        val filtered: List<TestSuite> = []

        for suite in suites:
            for pattern in patterns:
                if self.matches_file_pattern(suite, pattern):
                    filtered.append(suite)
                    break

        filtered

    fn matches_pattern(suite: TestSuite, pattern: text): bool =
        """Check if suite matches pattern.

        Args:
            suite: Test suite
            pattern: Pattern to match

        Returns:
            True if matches

        Supports:
        - Exact match: "app_test"
        - Wildcard: "*_test", "test_*", "*integration*"
        - Substring: "user" matches "user_test.spl"
        """
        # Simple wildcard matching
        if pattern.contains("*"):
            return self.matches_wildcard(suite.path, pattern)
        else:
            # Substring match
            return suite.path.contains(pattern)

    fn matches_wildcard(text: text, pattern: text): bool =
        """Check if text matches wildcard pattern.

        Args:
            text: Text to match
            pattern: Wildcard pattern (* matches anything)

        Returns:
            True if matches

        Examples:
        - "*_test" matches "app_test", "user_test"
        - "test_*" matches "test_app", "test_user"
        - "*integration*" matches "app_integration_test"
        """
        if pattern == "*":
            return true

        if pattern.starts_with("*") and pattern.ends_with("*"):
            # *substring*
            val substr = pattern[1:pattern.len()-1]
            return text.contains(substr)
        elif pattern.starts_with("*"):
            # *suffix
            val suffix = pattern[1:]
            return text.ends_with(suffix)
        elif pattern.ends_with("*"):
            # prefix*
            val prefix = pattern[0:pattern.len()-1]
            return text.starts_with(prefix)
        else:
            # No wildcards, exact match
            return text == pattern

    fn matches_file_pattern(suite: TestSuite, pattern: text): bool =
        """Check if suite matches file pattern.

        Args:
            suite: Test suite
            pattern: Glob pattern (simplified)

        Returns:
            True if matches

        Supports:
        - *.spl - Files ending with .spl
        - test_*.py - Files starting with test_ and ending with .py
        - **/*_spec.spl - Any _spec.spl file in any directory
        """
        # Extract filename from path
        val filename = self.get_filename(suite.path)

        # Match against pattern
        if pattern.starts_with("**/"):
            # Recursive pattern - match filename only
            val file_pattern = pattern[3:]
            return self.matches_glob_pattern(filename, file_pattern)
        else:
            # Direct pattern
            return self.matches_glob_pattern(filename, pattern)

    fn get_filename(path: text): text =
        """Extract filename from path.

        Args:
            path: File path

        Returns:
            Filename
        """
        val last_slash = path.rfind("/")
        if last_slash >= 0:
            path[last_slash+1:]
        else:
            path

    fn matches_glob_pattern(name: text, pattern: text): bool =
        """Check if name matches glob pattern.

        Args:
            name: Filename
            pattern: Glob pattern

        Returns:
            True if matches
        """
        if pattern.starts_with("*"):
            # Pattern: *.ext or *_suffix.ext
            val suffix = pattern[1:]
            name.ends_with(suffix)
        elif pattern.ends_with("*"):
            # Pattern: prefix_*
            val prefix = pattern[0:pattern.len()-1]
            name.starts_with(prefix)
        elif pattern.contains("*"):
            # Pattern: prefix_*.ext
            val star_idx = pattern.find("*")
            val prefix = pattern[0:star_idx]
            val suffix = pattern[star_idx+1:]
            name.starts_with(prefix) and name.ends_with(suffix)
        else:
            # Exact match
            name == pattern

# Smart test selection - select tests based on code changes
pub class SmartTestSelector:
    pub dependency_graph: Dict<text, List<text>>
    pub reverse_deps: Dict<text, List<text>>
    pub test_coverage: Dict<text, List<text>>
    pub test_files: List<text>
    pub verbose: bool

    pub fn new(): SmartTestSelector =
        """Create smart test selector.

        Returns:
            Smart selector

        Example:
            val selector = SmartTestSelector.new()
            selector.analyze_project(".")

            val changed_files = ["app.spl", "lib.spl"]
            val affected_tests = selector.select_tests(changed_files)

            print("Running {affected_tests.len()} affected tests")
            # 10x faster CI for small changes
        """
        SmartTestSelector {
            dependency_graph: {},
            reverse_deps: {},
            test_coverage: {},
            test_files: [],
            verbose: false
        }

    pub fn set_verbose(self, enabled: bool):
        """Enable verbose logging."""
        self.verbose = enabled

    pub fn analyze_project(self, root: text):
        """Analyze project to build dependency graph and coverage.

        Args:
            root: Project root

        This builds:
        1. dependency_graph: file -> [files it imports]
        2. reverse_deps: file -> [files that import it]
        3. test_coverage: file -> [tests that cover it]
        """
        @extern("runtime", "rt_file_read")
        fn _rt_file_read(path_ptr: &u8, path_len: u64) -> text

        if self.verbose:
            print("Analyzing project at {root}...")

        # Find all source files
        val source_files = self.find_source_files(root)

        if self.verbose:
            print("Found {source_files.len()} source files")

        # Build dependency graph by parsing imports
        for file in source_files:
            val content = _rt_file_read(file.ptr(), file.len())
            val imports = self.parse_imports(content, root)
            self.dependency_graph[file] = imports

            # Build reverse dependency graph
            for imported in imports:
                if not self.reverse_deps.contains_key(imported):
                    self.reverse_deps[imported] = []
                self.reverse_deps[imported].append(file)

        # Identify test files and build coverage mapping
        self.test_files = self.identify_test_files(source_files)

        if self.verbose:
            print("Found {self.test_files.len()} test files")

        # Build test coverage: map each source file to tests that cover it
        for test_file in self.test_files:
            # A test covers: itself + its direct imports + transitive imports
            val covered_files = self.get_transitive_deps(test_file)
            covered_files.append(test_file)

            for covered in covered_files:
                if not self.test_coverage.contains_key(covered):
                    self.test_coverage[covered] = []
                self.test_coverage[covered].append(test_file)

        if self.verbose:
            print("Dependency analysis complete")

    fn find_source_files(root: text): List<text> =
        """Find all source files in project."""
        import host.async_nogc_mut.io.fs
        import host.common.io.types.{FileType, DirPath}

        val files: List<text> = []
        self.find_source_files_recursive(root, files)
        files

    fn find_source_files_recursive(dir: text, results: List<text>):
        """Recursively find source files."""
        import host.async_nogc_mut.io.fs
        import host.common.io.types.{FileType, DirPath}

        match fs.read_dir(dir as DirPath):
            Ok(entries):
                for entry in entries:
                    val name = entry.name() as text
                    val path = entry.path() as text

                    match entry.file_type():
                        FileType.File:
                            # Include source files by extension
                            if name.ends_with(".spl") or name.ends_with(".rs") or
                               name.ends_with(".py") or name.ends_with(".ts") or
                               name.ends_with(".js"):
                                results.append(path)
                        FileType.Directory:
                            # Skip common non-source directories
                            if not self.should_skip_directory(name):
                                self.find_source_files_recursive(path, results)
                        _:
                            pass
            Err(_):
                pass

    fn should_skip_directory(name: text): bool =
        """Check if directory should be skipped."""
        name == "node_modules" or
        name == "target" or
        name == "__pycache__" or
        name == ".git" or
        name == ".venv" or
        name == "venv" or
        name == "build" or
        name == "dist" or
        name.starts_with(".")

    fn parse_imports(content: text, root: text): List<text> =
        """Parse import statements from source code.

        Supports:
        - Simple: use module.submodule, import module
        - Rust: use crate.module, mod module
        - Python: import module, from module import
        - TypeScript/JS: import { } from 'module'
        """
        val imports: List<text> = []

        for line in content.lines():
            val trimmed = line.trim()

            # Simple language imports
            if trimmed.starts_with("use ") or trimmed.starts_with("import "):
                val module = self.extract_module_name(trimmed)
                if not module.is_empty():
                    val resolved = self.resolve_module_path(module, root)
                    if not resolved.is_empty():
                        imports.append(resolved)

            # Python from imports
            elif trimmed.starts_with("from "):
                val module = self.extract_from_import(trimmed)
                if not module.is_empty():
                    val resolved = self.resolve_module_path(module, root)
                    if not resolved.is_empty():
                        imports.append(resolved)

        imports

    fn extract_module_name(line: text): text =
        """Extract module name from import line."""
        # Handle: use module.path, import module.path
        val parts = line.split(" ")
        if parts.len() >= 2:
            val module_part = parts[1]
            # Remove trailing punctuation
            val cleaned = module_part.trim_end_matches(";").trim_end_matches(":")
            # Convert dots to path separator
            return cleaned.replace(".", "/")
        ""

    fn extract_from_import(line: text): text =
        """Extract module from 'from X import Y' statement."""
        # Handle: from module import something
        val parts = line.split(" ")
        if parts.len() >= 2:
            return parts[1].replace(".", "/")
        ""

    fn resolve_module_path(module: text, root: text): text =
        """Resolve module name to file path."""
        @extern("runtime", "rt_file_exists")
        fn _rt_file_exists(path_ptr: &u8, path_len: u64) -> bool

        # Try different extensions
        val extensions = [".spl", ".rs", ".py", ".ts", ".js"]

        for ext in extensions:
            val path = "{root}/{module}{ext}"
            if _rt_file_exists(path.ptr(), path.len()):
                return path

            # Also try with /mod or __init__ for directories
            val dir_path = "{root}/{module}"
            val mod_path = "{dir_path}/mod{ext}"
            if _rt_file_exists(mod_path.ptr(), mod_path.len()):
                return mod_path

        ""

    fn identify_test_files(files: List<text>): List<text> =
        """Identify which files are test files."""
        val test_files: List<text> = []

        for file in files:
            val filename = self.get_filename(file)
            # Common test file patterns
            if filename.ends_with("_test.spl") or filename.ends_with("_spec.spl") or
               filename.starts_with("test_") or filename.ends_with("_test.rs") or
               filename.ends_with("_test.py") or filename.ends_with(".test.ts") or
               filename.ends_with(".spec.ts") or filename.ends_with(".test.js") or
               filename.ends_with(".spec.js"):
                test_files.append(file)

        test_files

    fn get_filename(path: text): text =
        """Extract filename from path."""
        val last_slash = path.rfind("/")
        if last_slash >= 0:
            path[last_slash+1:]
        else:
            path

    fn get_transitive_deps(file: text): List<text> =
        """Get all transitive dependencies of a file."""
        val visited: Dict<text, bool> = {}
        val result: List<text> = []
        self.collect_transitive_deps(file, visited, result)
        result

    fn collect_transitive_deps(file: text, visited: Dict<text, bool>, result: List<text>):
        """Recursively collect transitive dependencies."""
        if visited.contains_key(file):
            return

        visited[file] = true

        match self.dependency_graph.get(file):
            some(deps):
                for dep in deps:
                    if not visited.contains_key(dep):
                        result.append(dep)
                        self.collect_transitive_deps(dep, visited, result)
            none:
                pass

    pub fn select_tests(self, changed_files: List<text>): List<text> =
        """Select tests affected by changed files.

        Args:
            changed_files: Files that changed

        Returns:
            Test files to run

        Algorithm:
        1. Find files that directly changed
        2. Find files that depend on changed files (transitive)
        3. Find tests that cover those files
        4. Return unique set of tests
        """
        val affected: List<text> = []

        # Find all affected files (changed + dependents)
        val all_affected_files = self.get_affected_files(changed_files)

        if self.verbose:
            print("Changed files affect {all_affected_files.len()} files total")

        # Find tests covering affected files
        for file in all_affected_files:
            match self.test_coverage.get(file):
                some(tests):
                    affected.extend(tests)
                none:
                    pass

        # Also include changed test files directly
        for file in changed_files:
            if self.test_files.contains(file):
                affected.append(file)

        # Deduplicate
        self.deduplicate(affected)

    fn get_affected_files(changed_files: List<text>): List<text> =
        """Get all files affected by changes (including transitive dependents)."""
        val affected: List<text> = []
        val visited: Dict<text, bool> = {}

        for file in changed_files:
            self.collect_reverse_transitive_deps(file, visited, affected)

        # Include the changed files themselves
        for file in changed_files:
            if not visited.contains_key(file):
                affected.append(file)

        affected

    fn collect_reverse_transitive_deps(file: text, visited: Dict<text, bool>, result: List<text>):
        """Collect files that depend on this file (transitively)."""
        if visited.contains_key(file):
            return

        visited[file] = true
        result.append(file)

        # Find files that import this file
        match self.reverse_deps.get(file):
            some(dependents):
                for dependent in dependents:
                    self.collect_reverse_transitive_deps(dependent, visited, result)
            none:
                pass

    fn deduplicate(list: List<text>): List<text> =
        """Remove duplicates from list.

        Args:
            list: List with possible duplicates

        Returns:
            Unique list

        Algorithm:
        - Uses dict as set for O(n) deduplication
        - Preserves first occurrence order
        """
        val unique: List<text> = []
        val seen: Dict<text, bool> = {}

        for item in list:
            if not seen.contains_key(item):
                seen[item] = true
                unique.append(item)

        unique
