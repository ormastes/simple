# TODO Comment Parser for Simple and Rust Source Files
#
# This module extracts TODO/FIXME comments from both Simple (.spl) and Rust (.rs) files,
# validates them against the project's TODO format specification, and provides structured
# data for the TODO database system.
#
# Format specification:
#   TODO: [area][priority] description [#issue] [blocked:#issue,#issue]
#   FIXME: [area][priority] description [#issue] [blocked:#issue,#issue]
#
# #![skip_todo]

use core.regex.{Pattern, Match}

# =========================================================================
# Constants
# =========================================================================

# Valid TODO areas
val TODO_AREAS: List<text> = [
    "runtime", "codegen", "compiler", "parser", "type", "stdlib",
    "gpu", "ui", "test", "driver", "loader", "pkg", "doc"
]

# Valid TODO priorities (both numeric and named)
val TODO_PRIORITIES: List<text> = [
    "P0", "P1", "P2", "P3", "critical", "high", "medium", "low"
]

# =========================================================================
# Data Structures
# =========================================================================

# Source code language
enum Language:
    Rust
    Simple
    Markdown
    Unknown

# Parse error
class ParseError:
    file: text
    line: i32
    message: text
    raw_text: text

    static fn new(file: text, line: i32, message: text, raw_text: text) -> ParseError:
        return ParseError {
            file: file,
            line: line,
            message: message,
            raw_text: raw_text
        }

    fn to_string() -> text:
        return "{self.file}:{self.line}: {self.message}"

# Parse result for a single file
class ParseResult:
    todos: List<TodoItem>
    errors: List<ParseError>

    static fn new() -> ParseResult:
        return ParseResult { todos: [], errors: [] }

    fn add_todo(todo: TodoItem) -> ParseResult:
        var new_todos = self.todos
        new_todos.append(todo)
        return ParseResult { todos: new_todos, errors: self.errors }

    fn add_error(error: ParseError) -> ParseResult:
        var new_errors = self.errors
        new_errors.append(error)
        return ParseResult { todos: self.todos, errors: new_errors }

    fn merge(other: ParseResult) -> ParseResult:
        var merged_todos = self.todos
        var merged_errors = self.errors
        for todo in other.todos:
            merged_todos.append(todo)
        for error in other.errors:
            merged_errors.append(error)
        return ParseResult { todos: merged_todos, errors: merged_errors }

# Represents a parsed TODO comment
class TodoItem:
    keyword: text       # TODO or FIXME
    area: text          # Component area (runtime, codegen, etc.)
    priority: text      # Priority level (P0-P3 or critical/high/medium/low)
    description: text   # Description of what needs to be done
    issue: Option<text> # Optional issue number (without #)
    blocked: List<text> # Optional blocked issue numbers (without #)
    file: text          # Source file path
    line: i32           # Line number in file (1-indexed)
    raw_text: text      # Full original comment text

    static fn new(
        keyword: text,
        area: text,
        priority: text,
        description: text,
        issue: Option<text>,
        blocked: List<text>,
        file: text,
        line: i32,
        raw_text: text
    ) -> TodoItem:
        return TodoItem {
            keyword: keyword,
            area: area,
            priority: priority,
            description: description,
            issue: issue,
            blocked: blocked,
            file: file,
            line: line,
            raw_text: raw_text
        }

    # Normalize priority (critical -> P0, high -> P1, etc.)
    fn normalized_priority() -> text:
        return normalize_priority(self.priority)

    # Check if TODO is valid according to format spec
    fn is_valid() -> bool:
        val area_valid = TODO_AREAS.contains(self.area)
        val priority_valid = TODO_PRIORITIES.contains(self.priority)
        return area_valid and priority_valid

    # Get validation errors if any
    fn validation_errors() -> List<text>:
        var errors: List<text> = []

        if not TODO_AREAS.contains(self.area):
            val areas_str = TODO_AREAS.join(", ")
            errors.append("Invalid area '{self.area}'. Valid areas: {areas_str}")

        if not TODO_PRIORITIES.contains(self.priority):
            val priorities_str = TODO_PRIORITIES.join(", ")
            errors.append("Invalid priority '{self.priority}'. Valid priorities: {priorities_str}")

        return errors

    fn to_string() -> text:
        val issue_str = match self.issue:
            Some(num) => " [#{num}]"
            None => ""
        val blocked_str = if self.blocked.len() > 0:
            val nums = self.blocked.map(\n: "#{n}").join(",")
            " [blocked:{nums}]"
        else:
            ""
        return "{self.keyword}: [{self.area}][{self.priority}] {self.description}{issue_str}{blocked_str}"

# =========================================================================
# TODO Parser
# =========================================================================

class TodoParser:
    pattern: Pattern
    html_comment_pattern: Pattern
    include_invalid: bool

    static fn new() -> TodoParser:
        # Pattern: TODO/FIXME: [area][priority] description [#issue] [blocked:#issue,#issue]
        val pattern_str = r"(TODO|FIXME):\s*\[([^\]]+)\]\[([^\]]+)\]\s*(.+?)(?:\s*\[#(\d+)\])?(?:\s*\[blocked:((?:#?\d+(?:,#?\d+)*)?)\])?\s*$"
        return TodoParser {
            pattern: Pattern.new(pattern_str),
            html_comment_pattern: Pattern.new(r"<!--\s*(.+?)\s*-->"),
            include_invalid: false
        }

    # Create parser that includes invalid TODOs
    fn with_invalid() -> TodoParser:
        return TodoParser {
            pattern: self.pattern,
            html_comment_pattern: self.html_comment_pattern,
            include_invalid: true
        }

    # Parse TODOs from a file
    fn parse_file(path: text) -> Result<ParseResult, text>:
        val content = read_file(path)
        if content == "":
            return Err("Failed to read file: {path}")

        val language = detect_language(path)
        match language:
            Language::Rust => self.parse_rust(content, path)
            Language::Simple => self.parse_simple(content, path)
            Language::Markdown => self.parse_markdown(content, path)
            Language::Unknown => Err("Unsupported file type: {path}")

    # Parse TODOs from Rust source code
    fn parse_rust(content: text, path: text) -> Result<ParseResult, text>:
        var result = ParseResult.new()
        val lines = content.split("\n")

        for i in 0..lines.len():
            val line_num = i + 1  # 1-indexed
            val line = lines[i]
            val trimmed = line.trim()

            # Check for Rust comments: // or ///
            if not trimmed.starts_with("//"):
                continue

            # Extract comment content
            val comment = if trimmed.starts_with("///"):
                trimmed.trim_start("///").trim()
            else:
                trimmed.trim_start("//").trim()

            # Check if contains TODO or FIXME
            if not comment.contains("TODO") and not comment.contains("FIXME"):
                continue

            # Skip if inside string literal (simple heuristic)
            if is_in_string(trimmed, "TODO") or is_in_string(trimmed, "FIXME"):
                continue

            # Try to parse TODO
            match self.parse_todo_comment(comment, path, line_num, line):
                Ok(Some(todo)) =>
                    if self.include_invalid or todo.is_valid():
                        result = result.add_todo(todo)
                    else:
                        val errors_str = todo.validation_errors().join(", ")
                        result = result.add_error(ParseError.new(
                            path, line_num,
                            "Invalid TODO format: {errors_str}",
                            line
                        ))
                Ok(None) =>
                    pass  # Not a TODO comment, skip
                Err(msg) =>
                    result = result.add_error(ParseError.new(path, line_num, msg, line))

        return Ok(result)

    # Parse TODOs from Simple source code
    fn parse_simple(content: text, path: text) -> Result<ParseResult, text>:
        var result = ParseResult.new()
        val lines = content.split("\n")

        for i in 0..lines.len():
            val line_num = i + 1  # 1-indexed
            val line = lines[i]
            val trimmed = line.trim()

            # Check for Simple comments: #
            if not trimmed.starts_with("#"):
                continue

            # Extract comment content
            val comment = trimmed.trim_start("#").trim()

            # Check if contains TODO or FIXME
            if not comment.contains("TODO") and not comment.contains("FIXME"):
                continue

            # Skip if inside string literal
            if is_in_string(trimmed, "TODO") or is_in_string(trimmed, "FIXME"):
                continue

            # Try to parse TODO
            match self.parse_todo_comment(comment, path, line_num, line):
                Ok(Some(todo)) =>
                    if self.include_invalid or todo.is_valid():
                        result = result.add_todo(todo)
                    else:
                        val errors_str = todo.validation_errors().join(", ")
                        result = result.add_error(ParseError.new(
                            path, line_num,
                            "Invalid TODO format: {errors_str}",
                            line
                        ))
                Ok(None) =>
                    pass  # Not a TODO comment, skip
                Err(msg) =>
                    result = result.add_error(ParseError.new(path, line_num, msg, line))

        return Ok(result)

    # Parse TODOs from Markdown files
    fn parse_markdown(content: text, path: text) -> Result<ParseResult, text>:
        var result = ParseResult.new()
        val lines = content.split("\n")

        for i in 0..lines.len():
            val line_num = i + 1  # 1-indexed
            val line = lines[i]

            # Check for HTML comments
            val matches = self.html_comment_pattern.findall(line)
            for m in matches:
                val comment = m.group(1).unwrap_or("")

                if not comment.contains("TODO") and not comment.contains("FIXME"):
                    continue

                match self.parse_todo_comment(comment, path, line_num, line):
                    Ok(Some(todo)) =>
                        if self.include_invalid or todo.is_valid():
                            result = result.add_todo(todo)
                        else:
                            val errors_str = todo.validation_errors().join(", ")
                            result = result.add_error(ParseError.new(
                                path, line_num,
                                "Invalid TODO format: {errors_str}",
                                line
                            ))
                    Ok(None) =>
                        pass
                    Err(msg) =>
                        result = result.add_error(ParseError.new(path, line_num, msg, line))

        return Ok(result)

    # Parse a single TODO comment line
    fn parse_todo_comment(comment: text, file: text, line: i32, raw_text: text) -> Result<Option<TodoItem>, text>:
        # Check if starts with TODO: or FIXME:
        if not comment.starts_with("TODO:") and not comment.starts_with("FIXME:"):
            return Ok(None)  # Not a standard TODO comment

        # Try to match the pattern
        match self.pattern.search(comment):
            Some(captures) =>
                val keyword = captures.group(1).unwrap_or("")
                val area = captures.group(2).unwrap_or("").trim()
                val priority = captures.group(3).unwrap_or("").trim()
                val description = captures.group(4).unwrap_or("").trim()
                val issue = captures.group(5)
                val blocked_str = captures.group(6).unwrap_or("")

                # Parse blocked issues
                val blocked: List<text> = if blocked_str.len() > 0:
                    blocked_str.split(",")
                        .map(\s: s.trim().trim_start("#"))
                        .filter(\s: s.len() > 0)
                else:
                    []

                return Ok(Some(TodoItem.new(
                    keyword, area, priority, description,
                    issue, blocked, file, line, raw_text
                )))
            None =>
                return Err("TODO/FIXME missing [area][priority] format. Expected: TODO: [area][priority] description")

    # Scan directory recursively for TODO comments
    fn scan_directory(dir: text) -> Result<ParseResult, text>:
        var result = ParseResult.new()
        val files = walk_directory(dir, ["**/*.rs", "**/*.spl", "**/*.md"], [
            "**/target/**", "**/build/**", "**/vendor/**", "**/node_modules/**", "**/.*"
        ])

        for file in files:
            match self.parse_file(file):
                Ok(file_result) =>
                    result = result.merge(file_result)
                Err(e) =>
                    print "Warning: Failed to parse {file}: {e}"

        return Ok(result)

# =========================================================================
# Helper Functions
# =========================================================================

# Detect language from file extension
fn detect_language(path: text) -> Language:
    if path.ends_with(".rs"):
        return Language::Rust
    elif path.ends_with(".spl"):
        return Language::Simple
    elif path.ends_with(".md"):
        return Language::Markdown
    else:
        return Language::Unknown

# Normalize priority level
fn normalize_priority(priority: text) -> text:
    val lower = priority.to_lowercase()
    match lower:
        "critical" => "P0"
        "high" => "P1"
        "medium" => "P2"
        "low" => "P3"
        _ => priority  # Keep P0-P3 as-is

# Check if keyword appears inside a string literal (simple heuristic)
fn is_in_string(line: text, keyword: text) -> bool:
    match line.find(keyword):
        Some(keyword_pos) =>
            val before = line.slice(0, keyword_pos)
            val double_quotes = before.count("\"")
            val single_quotes = before.count("'")
            # If odd number of quotes, we're inside a string
            return double_quotes % 2 == 1 or single_quotes % 2 == 1
        None =>
            return false

# =========================================================================
# FFI Functions (File System Operations)
# =========================================================================

# Read file contents
fn read_file(path: text) -> text:
    @extern("runtime", "rt_file_read_text")
    fn _rt_file_read_text(path_ptr: &u8, path_len: u64) -> text

    return _rt_file_read_text(path.ptr(), path.len())

# Check if path exists
fn exist(path: text) -> bool:
    @extern("runtime", "rt_path_exists")
    fn _rt_path_exists(path_ptr: &u8, path_len: u64) -> bool

    return _rt_path_exists(path.ptr(), path.len())

# Walk directory with patterns
fn walk_directory(root: text, include_patterns: List<text>, exclude_patterns: List<text>) -> List<text>:
    @extern("runtime", "rt_walk_directory")
    fn _rt_walk_directory(
        root_ptr: &u8, root_len: u64,
        include_ptr: &List<text>,
        exclude_ptr: &List<text>
    ) -> List<text>

    return _rt_walk_directory(root.ptr(), root.len(), &include_patterns, &exclude_patterns)

# =========================================================================
# Exports
# =========================================================================

export TodoItem, TodoParser, ParseResult, ParseError, Language
export detect_language, normalize_priority, is_in_string
export TODO_AREAS, TODO_PRIORITIES
