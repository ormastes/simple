# TODO Collector
#
# Collects TODO/FIXME comments from codebase and converts them to dashboard format.
# Extends the existing todo_parser module with age tracking and status management.
#
# #![skip_todo]

use core.time.{now_iso8601, now_timestamp}
use tooling.todo_parser.{TodoParser, TodoItem as ParserTodoItem}
use tooling.dashboard.types.{TodoItem}

# =========================================================================
# TODO Collector
# =========================================================================

class TodoCollector:
    root_path: text
    parser: TodoParser

    static fn new(root_path: text) -> TodoCollector:
        return TodoCollector {
            root_path: root_path,
            parser: TodoParser.new()
        }

    # Collect all TODOs from codebase
    fn collect() -> List<TodoItem>:
        print "  Scanning for TODOs..."

        match self.parser.scan_directory(self.root_path):
            Err(e) =>
                print "    Error: {e}"
                []
            Ok(result) =>
                print "    Found {result.todos.len()} TODOs, {result.errors.len()} errors"

                # Convert parser TODOs to dashboard TODOs
                var dashboard_todos: List<TodoItem> = []
                for i in 0..result.todos.len():
                    val parser_todo = result.todos[i]
                    val dashboard_todo = convert_to_dashboard_todo(parser_todo, i)
                    dashboard_todos.append(dashboard_todo)

                dashboard_todos

# =========================================================================
# Conversion Functions
# =========================================================================

# Convert parser TODO to dashboard TODO with extended fields
fn convert_to_dashboard_todo(parser_todo: ParserTodoItem, id: i32) -> TodoItem:
    # Calculate age from git history if available
    val age_days = calculate_todo_age_from_git(parser_todo.file, parser_todo.line)

    # Convert issue option to string
    val issue_str = match parser_todo.issue:
        Some(num) => num
        nil => ""

    # Convert blocked list to comma-separated string
    val blocked_str = parser_todo.blocked.join(",")

    # Determine status
    val status = infer_todo_status(parser_todo)

    # Get timestamp
    val timestamp = now_iso8601()

    return TodoItem.new(
        id,
        parser_todo.keyword,
        parser_todo.area,
        parser_todo.priority,
        parser_todo.description,
        parser_todo.file,
        parser_todo.line,
        issue_str,
        blocked_str,
        status,
        age_days,
        "",  # assigned - TODO: Extract from TODO comment or git blame
        timestamp
    )

# Infer TODO status based on metadata
fn infer_todo_status(todo: ParserTodoItem) -> text:
    # If blocked, mark as blocked
    if todo.blocked.len() > 0:
        return "blocked"

    # If has issue number, assume in progress
    match todo.issue:
        Some(_) => "in_progress"
        nil => "open"

# =========================================================================
# Git Integration for TODO Age
# =========================================================================

fn calculate_todo_age_from_git(file: text, line: i32) -> i32:
    """Calculate TODO age in days using git blame.

    Args:
        file: File path containing TODO
        line: Line number of TODO

    Returns:
        Age in days, or 0 if git is unavailable or TODO not found
    """
    # Attempt to get the first commit that introduced this line
    # Using git blame for the specific line
    val git_result = get_line_first_commit_date(file, line)

    match git_result:
        Some(commit_date):
            # Calculate days between commit date and today
            calculate_days_since(commit_date)
        nil:
            # Git unavailable or line not found - return 0
            0

fn get_line_first_commit_date(file: text, line: i32) -> Option<text>:
    """Get the date when a line was first introduced (via git blame).

    Returns ISO 8601 date string, or None if unavailable.

    Attempts to run: git blame -L<line>,<line> --porcelain <file>
    and extract the commit timestamp.
    """
    # This is a placeholder - real implementation would:
    # 1. Run: git blame -L<line>,<line> --porcelain <file>
    # 2. Parse first line to get commit hash
    # 3. Run: git log -1 --format=%aI <commit>
    # 4. Return ISO date

    # For now, return None to indicate git not used
    # Phase 2 will integrate actual git commands
    nil

fn calculate_days_since(iso_date: text) -> i32:
    """Calculate days since ISO 8601 date.

    Args:
        iso_date: Date in ISO 8601 format (YYYY-MM-DD...)

    Returns:
        Number of days since that date until today
    """
    if iso_date.len() < 10:
        return 0

    # Extract date components from ISO 8601
    val commit_year = parse_date_component(iso_date, start=0, end=4)
    val commit_month = parse_date_component(iso_date, start=5, end=7)
    val commit_day = parse_date_component(iso_date, start=8, end=10)

    # Get current date
    val now_str = now_iso8601()
    val curr_year = parse_date_component(now_str, start=0, end=4)
    val curr_month = parse_date_component(now_str, start=5, end=7)
    val curr_day = parse_date_component(now_str, start=8, end=10)

    # Calculate days difference (simplified - doesn't account for all edge cases)
    val days_per_year = 365
    val year_diff = (curr_year - commit_year) * days_per_year

    # Adjust for leap years in between
    var leap_days = 0
    for y in commit_year..curr_year:
        if is_leap_year_simple(y):
            leap_days = leap_days + 1

    # Month and day calculation (simplified)
    val days_this_year = get_day_of_year(month=curr_month, day=curr_day) - get_day_of_year(month=commit_month, day=commit_day)

    return year_diff + leap_days + days_this_year

fn parse_date_component(date_str: text, start: i32, end: i32) -> i32:
    """Parse integer component from date string."""
    var result = 0
    for i in start..end:
        if i < date_str.len():
            val ch = date_str[i]
            if ch >= "0" and ch <= "9":
                result = result * 10 + (ch.to_i32() - "0".to_i32())
    return result

fn is_leap_year_simple(year: i32) -> bool:
    """Check if year is leap year."""
    if year % 400 == 0:
        return true
    if year % 100 == 0:
        return false
    if year % 4 == 0:
        return true
    return false

fn get_day_of_year(month: i32, day: i32) -> i32:
    """Get day number within year (1-366)."""
    val days_in_months = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]
    var total_days = day

    for m in 1..month:
        if m >= 1 and m <= 12:
            total_days = total_days + days_in_months[m - 1]

    return total_days

# =========================================================================
# Convenience Functions
# =========================================================================

# Collect TODOs from default location
fn collect_todos() -> List<TodoItem>:
    val collector = TodoCollector.new(".")
    return collector.collect()

# Collect TODOs from custom path
fn collect_todos_from(path: text) -> List<TodoItem>:
    val collector = TodoCollector.new(path)
    return collector.collect()

# =========================================================================
# Exports
# =========================================================================

