# VCS (Jujutsu) Collector
#
# Collects version control state from Jujutsu repository including
# current bookmark, commit info, and working copy status.

use core.time.{now_iso8601}
use tooling.dashboard.types.{VcsState}

# =========================================================================
# VCS Collector
# =========================================================================

class VcsCollector:
    repo_path: text

    static fn new() -> VcsCollector:
        return VcsCollector { repo_path: "." }

    static fn with_path(path: text) -> VcsCollector:
        return VcsCollector { repo_path: path }

    # Collect VCS state
    fn collect() -> VcsState:
        val bookmark = get_current_bookmark()
        val commit_id = get_current_commit_id()
        val commit_message = get_current_commit_message()
        val uncommitted = count_uncommitted_files()
        val untracked = count_untracked_files()

        return VcsState.new(
            bookmark,
            commit_id,
            commit_message,
            uncommitted,
            untracked,
            now_iso8601()
        )

# =========================================================================
# Jujutsu Command Wrappers
# =========================================================================

# Get current bookmark name
fn get_current_bookmark() -> text:
    # Execute: jj log -r @ --no-graph -T 'bookmarks'
    val output = execute_command("jj log -r @ --no-graph -T bookmarks")
    return output.trim()

# Get current commit ID
fn get_current_commit_id() -> text:
    # Execute: jj log -r @ --no-graph -T 'commit_id.short()'
    val output = execute_command("jj log -r @ --no-graph -T 'commit_id.short()'")
    return output.trim()

# Get current commit message
fn get_current_commit_message() -> text:
    # Execute: jj log -r @ --no-graph -T 'description.first_line()'
    val output = execute_command("jj log -r @ --no-graph -T 'description.first_line()'")
    return output.trim()

# Count uncommitted files
fn count_uncommitted_files() -> i32:
    # Execute: jj status --no-pager
    val output = execute_command("jj status --no-pager")
    return count_lines_starting_with(output, "M ")

# Count untracked files
fn count_untracked_files() -> i32:
    # Execute: jj status --no-pager
    val output = execute_command("jj status --no-pager")
    return count_lines_starting_with(output, "A ")

# =========================================================================
# Helper Functions
# =========================================================================

# Execute shell command and return output
fn execute_command(cmd: text) -> text:
    # This would use FFI to execute shell command
    # For now, return placeholder
    @extern("runtime", "rt_execute_command")
    fn _rt_execute_command(cmd_ptr: &u8, cmd_len: u64) -> text

    return _rt_execute_command(cmd.ptr(), cmd.len())

# Count lines starting with prefix
fn count_lines_starting_with(content: text, prefix: text) -> i32:
    var count = 0
    val lines = content.split("\n")

    for line in lines:
        if line.trim().starts_with(prefix):
            count = count + 1

    return count

# =========================================================================
# Convenience Functions
# =========================================================================

# Collect VCS state from default location
fn collect_vcs_state() -> VcsState:
    val collector = VcsCollector.new()
    return collector.collect()

# Collect VCS state from custom path
fn collect_vcs_state_from(path: text) -> VcsState:
    val collector = VcsCollector.with_path(path)
    return collector.collect()

# =========================================================================
# Exports
# =========================================================================

