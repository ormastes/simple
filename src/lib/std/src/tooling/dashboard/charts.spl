# Dashboard ASCII Chart Rendering
#
# Provides ASCII-based chart visualization for metrics and trends.
# Supports bar charts, line charts, and sparklines.

# =========================================================================
# Chart Types
# =========================================================================

class BarChart:
    """ASCII bar chart."""
    title: text
    values: List<(text, f64)>
    max_width: i32

    static fn new(title: text, max_width: i32) -> BarChart:
        return BarChart {
            title: title,
            values: [],
            max_width: max_width
        }

    fn add_value(label: text, value: f64) -> BarChart:
        self.values.append((label, value))
        return self

    fn render() -> text:
        if self.values.len() == 0:
            return "No data\n"

        # Find max value for scaling
        var max_val = 0.0
        for v in self.values:
            if v.1 > max_val:
                max_val = v.1

        if max_val == 0.0:
            max_val = 1.0

        var output = "{self.title}\n\n"

        # Find longest label for alignment
        var max_label_len = 0
        for v in self.values:
            if v.0.len() > max_label_len:
                max_label_len = v.0.len()

        # Render each bar
        for v in self.values:
            val label = v.0
            val value = v.1
            val percent = (value / max_val) * 100.0
            val bar_width = (percent / 100.0) * (self.max_width as f64)

            output = "{output}{label:<label_width} │ "

            # Draw bar
            var bar = ""
            for i in 0..(bar_width as i32):
                bar = "{bar}█"

            output = "{output}{bar} {value:.1f}%\n"

        return output

    fn to_string() -> text:
        return self.render()

class LineChart:
    """ASCII line chart with trend visualization."""
    title: text
    values: List<f64>
    height: i32

    static fn new(title: text, height: i32) -> LineChart:
        return LineChart {
            title: title,
            values: [],
            height: height
        }

    fn add_value(val: f64) -> LineChart:
        self.values.append(val)
        return self

    fn render() -> text:
        if self.values.len() == 0:
            return "No data\n"

        var output = "{self.title}\n\n"

        # Find min/max for scaling
        var min_val = self.values[0]
        var max_val = self.values[0]

        for v in self.values:
            if v < min_val:
                min_val = v
            if v > max_val:
                max_val = v

        # Create grid
        val range = max_val - min_val
        if range == 0.0:
            max_val = min_val + 1.0

        # Render chart
        for row in 0..self.height:
            val threshold = max_val - ((row as f64) / (self.height as f64)) * (max_val - min_val)

            output = "{output}│ "
            for col in 0..self.values.len():
                val value = self.values[col]
                val ch = if value >= threshold:
                    "▄"
                else:
                    " "
                output = "{output}{ch}"
            output = "{output}\n"

        output = "{output}└─"
        for i in 0..self.values.len():
            output = "{output}─"
        output = "{output}\n"

        return output

    fn to_string() -> text:
        return self.render()

class Sparkline:
    """Compact sparkline chart."""
    values: List<f64>

    static fn new(values: List<f64>) -> Sparkline:
        return Sparkline { values: values }

    fn render() -> text:
        if self.values.len() == 0:
            return "▁"

        var min_val = self.values[0]
        var max_val = self.values[0]

        for v in self.values:
            if v < min_val:
                min_val = v
            if v > max_val:
                max_val = v

        val range = max_val - min_val
        if range == 0.0:
            return "▂▂▂▂▂"

        var output = ""
        for v in self.values:
            val normalized = (v - min_val) / range
            val level = (normalized * 8.0) as i32

            val ch = match level:
                | 0 -> "▁"
                | 1 -> "▂"
                | 2 -> "▃"
                | 3 -> "▄"
                | 4 -> "▅"
                | 5 -> "▆"
                | 6 -> "▇"
                | _ -> "█"

            output = "{output}{ch}"

        return output

    fn to_string() -> text:
        return self.render()

# =========================================================================
# Chart Rendering Functions
# =========================================================================

fn create_progress_bar(value: f64, max_value: f64, width: i32) -> text:
    """Create a simple progress bar.

    Args:
        value: Current value
        max_value: Maximum value
        width: Bar width in characters

    Returns:
        ASCII progress bar string
    """
    if max_value == 0.0:
        return "[" + repeat_char("█", width) + "] 0%"

    val percent = (value / max_value) * 100.0
    val filled = (percent / 100.0) * (width as f64)
    val empty = width - (filled as i32)

    var bar = "["
    bar = "{bar}{repeat_char("█", filled as i32)}"
    bar = "{bar}{repeat_char("░", empty)}"
    bar = "{bar}] {percent:.0f}%"

    return bar

fn create_trend_indicator(previous: f64, current: f64) -> text:
    """Create a trend indicator (up/down/stable).

    Args:
        previous: Previous value
        current: Current value

    Returns:
        Trend indicator string with emoji and percentage
    """
    if previous == 0.0:
        return "→ new"

    val change = current - previous
    val change_percent = (change / previous) * 100.0

    if change_percent > 2.0:
        return "↑ +{change_percent:.1f}%"
    elif change_percent < -2.0:
        return "↓ {change_percent:.1f}%"
    else:
        return "→ {change_percent:+.1f}%"

fn create_status_box(title: text, content: text, width: i32) -> text:
    """Create a bordered box with content.

    Args:
        title: Box title
        content: Box content
        width: Box width

    Returns:
        ASCII box string
    """
    var box = "┌─ {title} "

    # Calculate padding
    val remaining = width - title.len() - 3
    for i in 0..remaining:
        box = "{box}─"
    box = "{box}┐\n"

    box = "{box}│ {content} │\n"

    box = "{box}└"
    for i in 0..width:
        box = "{box}─"
    box = "{box}┘\n"

    return box

fn repeat_char(ch: text, count: i32) -> text:
    """Repeat a character N times."""
    var result = ""
    for i in 0..count:
        result = "{result}{ch}"
    return result

# =========================================================================
# Exports
# =========================================================================

