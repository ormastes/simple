# Dashboard Configuration
#
# Loads and manages dashboard configuration from .simple/dashboard.toml

use io.fs_helpers.{read_text_file, file_exists, write_text_file}
use tooling.dashboard.alerts.{AlertConfig}

# =========================================================================
# Configuration
# =========================================================================

class DashboardConfig:
    alerts: AlertConfig
    trends_history_days: i32
    snapshot_frequency: text
    web_port: i32
    web_auto_refresh_seconds: i32
    web_dark_mode: bool

    static fn default() -> DashboardConfig:
        return DashboardConfig {
            alerts: AlertConfig.default(),
            trends_history_days: 90,
            snapshot_frequency: "daily",
            web_port: 3000,
            web_auto_refresh_seconds: 30,
            web_dark_mode: false
        }

    # Load from file
    static fn from_file(path: text) -> Result<DashboardConfig, text>:
        if not file_exists(path):
            return Ok(DashboardConfig.default())

        match read_text_file(path):
            Err(e) => Err("Failed to read config file: {e}")
            Ok(content) => parse_toml_config(content)

    # Load from default location
    static fn load() -> DashboardConfig:
        match DashboardConfig.from_file(".simple/dashboard.toml"):
            Ok(config) => config
            Err(_) => DashboardConfig.default()

# =========================================================================
# TOML Parser (Simplified)
# =========================================================================

fn parse_toml_config(content: text) -> Result<DashboardConfig, text>:
    var config = DashboardConfig.default()
    val lines = content.split("\n")

    var current_section = ""

    for line in lines:
        val trimmed = line.trim()

        # Skip comments and empty lines
        if trimmed.starts_with("#") or trimmed.len() == 0:
            continue

        # Section headers
        if trimmed.starts_with("[") and trimmed.ends_with("]"):
            current_section = trimmed.slice(1, trimmed.len() - 1)
            continue

        # Key-value pairs
        if trimmed.contains("="):
            val parts = trimmed.split("=")
            if parts.len() < 2:
                continue

            val key = parts[0].trim()
            val value = parts[1].trim()

            match current_section:
                "alerts" => parse_alert_config(key, value, config.alerts)
                "trends" => parse_trends_config(key, value, config)
                "web" => parse_web_config(key, value, config)
                _ => pass

    return Ok(config)

# Parse alert configuration
fn parse_alert_config(key: text, value: text, alerts: AlertConfig):
    match key:
        "coverage_threshold" =>
            alerts.coverage_min = parse_float(value)
        "coverage_regression" =>
            alerts.coverage_regression = parse_float(value)
        "p0_todo_max" =>
            alerts.todo_p0_max = parse_int(value)
        "todo_increase" =>
            alerts.todo_increase = parse_int(value)
        "build_time_regression" =>
            alerts.build_time_regression = parse_float(value)
        _ => pass

# Parse trends configuration
fn parse_trends_config(key: text, value: text, config: DashboardConfig):
    match key:
        "history_days" =>
            config.trends_history_days = parse_int(value)
        "snapshot_frequency" =>
            config.snapshot_frequency = unquote(value)
        _ => pass

# Parse web configuration
fn parse_web_config(key: text, value: text, config: DashboardConfig):
    match key:
        "port" =>
            config.web_port = parse_int(value)
        "auto_refresh_seconds" =>
            config.web_auto_refresh_seconds = parse_int(value)
        "dark_mode" =>
            config.web_dark_mode = parse_bool(value)
        _ => pass

# =========================================================================
# Helper Functions
# =========================================================================

# Parse integer
fn parse_int(s: text) -> i32:
    var result = 0
    var start = 0

    for i in start..s.len():
        val ch = s.char_at(i)
        if ch >= '0' and ch <= '9':
            result = result * 10 + (ch - '0')

    return result

# Parse float (simplified)
fn parse_float(s: text) -> f64:
    # TODO: Implement proper float parsing
    return (parse_int(s) as f64)

# Parse boolean
fn parse_bool(s: text) -> bool:
    val lower = s.to_lowercase()
    return lower == "true" or lower == "1" or lower == "yes"

# Remove quotes from string
fn unquote(s: text) -> text:
    var result = s.trim()
    if result.starts_with("\"") and result.ends_with("\""):
        result = result.slice(1, result.len() - 1)
    return result

# =========================================================================
# Configuration Template
# =========================================================================

fn generate_config_template() -> text:
    var toml = "# Simple Dashboard Configuration\n\n"

    toml = "{toml}[alerts]\n"
    toml = "{toml}# Coverage threshold (minimum percentage)\n"
    toml = "{toml}coverage_threshold = 80.0\n\n"
    toml = "{toml}# Coverage regression threshold (percentage drop)\n"
    toml = "{toml}coverage_regression = 1.0\n\n"
    toml = "{toml}# Maximum P0 TODOs before alert\n"
    toml = "{toml}p0_todo_max = 5\n\n"
    toml = "{toml}# TODO increase threshold\n"
    toml = "{toml}todo_increase = 10\n\n"
    toml = "{toml}# Build time regression threshold (percentage)\n"
    toml = "{toml}build_time_regression = 10.0\n\n"

    toml = "{toml}[trends]\n"
    toml = "{toml}# Number of days to retain historical data\n"
    toml = "{toml}history_days = 90\n\n"
    toml = "{toml}# Snapshot frequency: daily, hourly\n"
    toml = "{toml}snapshot_frequency = \"daily\"\n\n"

    toml = "{toml}[web]\n"
    toml = "{toml}# Web dashboard port\n"
    toml = "{toml}port = 3000\n\n"
    toml = "{toml}# Auto-refresh interval (seconds)\n"
    toml = "{toml}auto_refresh_seconds = 30\n\n"
    toml = "{toml}# Enable dark mode\n"
    toml = "{toml}dark_mode = false\n"

    return toml

# =========================================================================
# Configuration Validation
# =========================================================================

fn validate_config(config: DashboardConfig) -> Result<(), text>:
    """Validate configuration values."""
    # Validate trends
    if config.trends_history_days <= 0:
        return Err("trends_history_days must be positive")

    if config.trends_history_days > 365:
        return Err("trends_history_days should not exceed 365 days")

    # Validate web settings
    if config.web_port <= 0 or config.web_port > 65535:
        return Err("web_port must be between 1 and 65535")

    if config.web_auto_refresh_seconds <= 0:
        return Err("web_auto_refresh_seconds must be positive")

    # Validate snapshot frequency
    if config.snapshot_frequency != "daily" and config.snapshot_frequency != "hourly":
        return Err("snapshot_frequency must be 'daily' or 'hourly'")

    return Ok(())

fn validate_config_file(path: text) -> Result<(), text>:
    """Validate a configuration file."""
    match read_text_file(path):
        Ok(content) =>
            match parse_toml_config(content):
                Ok(config) => validate_config(config)
                Err(e) => Err("Failed to parse config: {e}")
        Err(e) => Err("Failed to read config file: {e}")

# =========================================================================
# Configuration Display
# =========================================================================

fn format_config(config: DashboardConfig) -> text:
    """Format configuration for display."""
    var output = "Dashboard Configuration\n"
    output = "{output}====================================\n\n"

    output = "{output}Alerts:\n"
    output = "{output}  coverage_threshold:     {config.alerts.coverage_min}\n"
    output = "{output}  coverage_regression:    {config.alerts.coverage_regression}\n"
    output = "{output}  p0_todo_max:           {config.alerts.todo_p0_max}\n"
    output = "{output}  todo_increase:         {config.alerts.todo_increase}\n"
    output = "{output}  build_time_regression: {config.alerts.build_time_regression}\n\n"

    output = "{output}Trends:\n"
    output = "{output}  history_days:      {config.trends_history_days}\n"
    output = "{output}  snapshot_frequency: {config.snapshot_frequency}\n\n"

    output = "{output}Web:\n"
    output = "{output}  port:                  {config.web_port}\n"
    output = "{output}  auto_refresh_seconds:  {config.web_auto_refresh_seconds}\n"
    output = "{output}  dark_mode:            {if config.web_dark_mode: "true" else: "false"}\n"

    return output

# =========================================================================
# Configuration Update
# =========================================================================

fn update_config_value(config: DashboardConfig, key: text, value: text) -> Result<(), text>:
    """Update a single configuration value."""
    match key:
        "alerts.coverage_threshold" =>
            config.alerts.coverage_min = parse_float(value)
            return Ok(())
        "alerts.coverage_regression" =>
            config.alerts.coverage_regression = parse_float(value)
            return Ok(())
        "alerts.p0_todo_max" =>
            config.alerts.todo_p0_max = parse_int(value)
            return Ok(())
        "alerts.todo_increase" =>
            config.alerts.todo_increase = parse_int(value)
            return Ok(())
        "trends.history_days" =>
            config.trends_history_days = parse_int(value)
            return Ok(())
        "trends.snapshot_frequency" =>
            config.snapshot_frequency = unquote(value)
            return Ok(())
        "web.port" =>
            config.web_port = parse_int(value)
            return Ok(())
        "web.auto_refresh_seconds" =>
            config.web_auto_refresh_seconds = parse_int(value)
            return Ok(())
        "web.dark_mode" =>
            config.web_dark_mode = parse_bool(value)
            return Ok(())
        _ => Err("Unknown configuration key: {key}")

fn save_config(config: DashboardConfig, path: text) -> Result<(), text>:
    """Save configuration to file."""
    # Generate TOML from config
    var toml = "# Simple Dashboard Configuration\n\n"

    toml = "{toml}[alerts]\n"
    toml = "{toml}coverage_threshold = {config.alerts.coverage_min}\n"
    toml = "{toml}coverage_regression = {config.alerts.coverage_regression}\n"
    toml = "{toml}p0_todo_max = {config.alerts.todo_p0_max}\n"
    toml = "{toml}todo_increase = {config.alerts.todo_increase}\n"
    toml = "{toml}build_time_regression = {config.alerts.build_time_regression}\n\n"

    toml = "{toml}[trends]\n"
    toml = "{toml}history_days = {config.trends_history_days}\n"
    toml = "{toml}snapshot_frequency = \"{config.snapshot_frequency}\"\n\n"

    toml = "{toml}[web]\n"
    toml = "{toml}port = {config.web_port}\n"
    toml = "{toml}auto_refresh_seconds = {config.web_auto_refresh_seconds}\n"
    toml = "{toml}dark_mode = {if config.web_dark_mode: "true" else: "false"}\n"

    return write_text_file(path, toml)

# =========================================================================
# Convenience Functions
# =========================================================================

# Load configuration with fallback to defaults
fn load_config() -> DashboardConfig:
    return DashboardConfig.load()

# Create default configuration file
fn create_default_config(path: text) -> Result<(), text>:
    val content = generate_config_template()
    return write_text_file(path, content)

# =========================================================================
# Exports
# =========================================================================

