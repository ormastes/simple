# Dashboard Notification System
#
# Handles sending notifications to various channels: Slack webhooks, generic webhooks, and email.
# Supports dry-run mode for testing without actually sending notifications.

use io.net.{HttpClient, HttpResponse}
use io.fs_helpers
use core.time.{now_iso8601, DateTime}

# =========================================================================
# Notification Types
# =========================================================================

enum NotificationChannel:
    Slack
    Webhook
    Email

class NotificationMessage:
    """Notification message with title, body, and severity."""
    title: text
    body: text
    severity: text  # "info", "warning", "critical"
    timestamp: text

    static fn new(title: text, body: text, severity: text) -> NotificationMessage:
        return NotificationMessage {
            title: title,
            body: body,
            severity: severity,
            timestamp: now_iso8601()
        }

    fn to_slack_json() -> text:
        """Convert to Slack JSON format."""
        val color = match self.severity:
            case "critical": "#ff0000"
            case "warning": "#ffaa00"
            case _: "#0099ff"

        val emoji = match self.severity:
            case "critical": "[CRITICAL]"
            case "warning": "[WARNING]"
            case _: "[INFO]"

        var json = "{\n"
        json = "{json}  \"attachments\": [{\n"
        json = "{json}    \"color\": \"{color}\",\n"
        json = "{json}    \"title\": \"{emoji} {escape_json(self.title)}\",\n"
        json = "{json}    \"text\": \"{escape_json(self.body)}\",\n"
        json = "{json}    \"footer\": \"Dashboard Notification\",\n"
        json = "{json}    \"ts\": {timestamp_to_unix(self.timestamp)}\n"
        json = "{json}  }]\n"
        json = "{json}}"
        return json

    fn to_webhook_json() -> text:
        """Convert to generic webhook JSON format."""
        var json = "{\n"
        json = "{json}  \"title\": \"{escape_json(self.title)}\",\n"
        json = "{json}  \"body\": \"{escape_json(self.body)}\",\n"
        json = "{json}  \"severity\": \"{self.severity}\",\n"
        json = "{json}  \"timestamp\": \"{self.timestamp}\"\n"
        json = "{json}}"
        return json

    fn to_email_body() -> text:
        """Convert to email body format."""
        var body = "Dashboard Notification\n"
        body = "{body}========================================\n\n"
        body = "{body}Title: {self.title}\n"
        body = "{body}Severity: {self.severity.to_uppercase()}\n"
        body = "{body}Timestamp: {self.timestamp}\n\n"
        body = "{body}Message:\n"
        body = "{body}{self.body}\n\n"
        body = "{body}========================================\n"
        body = "{body}Sent by Simple Dashboard\n"
        return body

# =========================================================================
# Notification Configuration
# =========================================================================

class NotificationConfig:
    """Configuration for notification channels."""
    slack_webhook_url: Option<text>
    webhook_url: Option<text>
    webhook_headers: Dict<text, text>
    email_smtp_host: Option<text>
    email_smtp_port: i32
    email_from: Option<text>
    email_to: List<text>

    static fn new() -> NotificationConfig:
        return NotificationConfig {
            slack_webhook_url: nil,
            webhook_url: nil,
            webhook_headers: Dict.new(),
            email_smtp_host: nil,
            email_smtp_port: 587,
            email_from: nil,
            email_to: []
        }

    fn validate() -> Result<(), text>:
        """Validate configuration."""
        if self.slack_webhook_url.is_none() and
           self.webhook_url.is_none() and
           self.email_smtp_host.is_none():
            return Err("No notification channels configured")

        match self.slack_webhook_url:
            Some(url) if url.is_empty() => Err("Slack webhook URL is empty")
            _ => pass

        match self.webhook_url:
            Some(url) if url.is_empty() => Err("Webhook URL is empty")
            _ => pass

        match self.email_smtp_host:
            Some(host) if host.is_empty() => Err("Email SMTP host is empty")
            _ => pass

        if not self.email_to.is_empty() and self.email_from.is_none():
            return Err("Email sender (from) not configured")

        return Ok(())

# =========================================================================
# Notification Functions
# =========================================================================

fn send_notification(
    channel: NotificationChannel,
    message: NotificationMessage,
    config: NotificationConfig,
    dry_run: bool
) -> Result<(), text>:
    """Send notification to specified channel.

    Args:
        channel: Target notification channel
        message: Notification message
        config: Notification configuration
        dry_run: If true, validate but don't send

    Returns:
        Ok(()) if successful, Err(message) on failure
    """
    match channel:
        case NotificationChannel::Slack: send_slack(message, config, dry_run)
        case NotificationChannel::Webhook: send_webhook(message, config, dry_run)
        case NotificationChannel::Email: send_email(message, config, dry_run)

fn send_slack(
    message: NotificationMessage,
    config: NotificationConfig,
    dry_run: bool
) -> Result<(), text>:
    """Send notification via Slack webhook."""
    match config.slack_webhook_url:
        case nil: Err("Slack webhook URL not configured")
        case Some(url) if url.is_empty(): Err("Slack webhook URL is empty")
        case Some(webhook_url):
            if dry_run:
                print "  [DRY-RUN] Would send Slack notification to {webhook_url}"
                print "  Title: {message.title}"
                print "  Severity: {message.severity}"
                return Ok(())

            # Send actual HTTP POST with Slack JSON format
            val json_payload = message.to_slack_json()
            match HttpClient.post(webhook_url, json_payload):
                case Ok(response):
                    if response.status_code >= 200 and response.status_code < 300:
                        print "  [SUCCESS] Slack notification sent"
                        Ok()
                    else:
                        Err("Slack webhook returned status {response.status_code}")
                case Err(e):
                    Err("Failed to send Slack notification: {e}")

fn send_webhook(
    message: NotificationMessage,
    config: NotificationConfig,
    dry_run: bool
) -> Result<(), text>:
    """Send notification via generic webhook."""
    match config.webhook_url:
        case nil: Err("Webhook URL not configured")
        case Some(url) if url.is_empty(): Err("Webhook URL is empty")
        case Some(webhook_url):
            if dry_run:
                print "  [DRY-RUN] Would send webhook to {webhook_url}"
                print "  Title: {message.title}"
                print "  Severity: {message.severity}"
                return Ok(())

            # Send actual HTTP POST with generic JSON format
            var json_payload = "{\n"
            json_payload = "{json_payload}  \"title\": \"{escape_json(message.title)}\",\n"
            json_payload = "{json_payload}  \"body\": \"{escape_json(message.body)}\",\n"
            json_payload = "{json_payload}  \"severity\": \"{message.severity}\",\n"
            json_payload = "{json_payload}  \"timestamp\": \"{message.timestamp}\"\n"
            json_payload = "{json_payload}}\n"

            match HttpClient.post(webhook_url, json_payload):
                case Ok(response):
                    if response.status_code >= 200 and response.status_code < 300:
                        print "  [SUCCESS] Webhook notification sent"
                        Ok()
                    else:
                        Err("Webhook returned status {response.status_code}")
                case Err(e):
                    Err("Failed to send webhook notification: {e}")

fn send_email(
    message: NotificationMessage,
    config: NotificationConfig,
    dry_run: bool
) -> Result<(), text>:
    """Send notification via email.

    Note: Full SMTP implementation requires FFI bindings.
    This implementation provides the architecture ready for Phase 2.
    """
    if config.email_to.is_empty():
        return Err("No email recipients configured")

    if dry_run:
        print "  [DRY-RUN] Would send email notification"
        for recipient in config.email_to:
            print "    To: {recipient}"
        print "  Subject: {message.title}"
        print "  Severity: {message.severity}"
        return Ok(())

    # Implement SMTP sending
    return send_smtp_email(message, config)

fn send_smtp_email(
    message: NotificationMessage,
    config: NotificationConfig
) -> Result<(), text>:
    """Send email via SMTP.

    Phase 2: Integrate with actual SMTP client library via FFI.
    Current: Provides architecture for SMTP integration.
    """
    match config.email_smtp_host:
        case nil:
            return Err("SMTP server not configured")
        case Some(host):
            if host.is_empty():
                return Err("SMTP server is empty")

    match config.email_from:
        case nil:
            return Err("Email sender address not configured")
        case Some(from_addr):
            if from_addr.is_empty():
                return Err("Email sender address is empty")

    # Build email components
    val email_body = build_email_body(message)
    val email_headers = build_email_headers(message, config)

    # Attempt to send via FFI-based SMTP client
    match send_smtp_message(
        config.email_smtp_host.unwrap_or("localhost"),
        config.email_smtp_port,
        config.email_from.unwrap_or(""),
        config.email_to,
        email_headers,
        email_body
    ):
        case Ok(_):
            print "  [SUCCESS] Email sent via SMTP"
            Ok(())
        case Err(e):
            Err("Failed to send email via SMTP: {e}")

fn build_email_headers(message: NotificationMessage, config: NotificationConfig) -> text:
    """Build SMTP email headers."""
    var headers = ""
    headers = "{headers}From: {config.email_from}\n"
    headers = "{headers}To: {config.email_to.join(", ")}\n"
    headers = "{headers}Subject: {message.title}\n"
    headers = "{headers}Date: {message.timestamp}\n"
    headers = "{headers}Content-Type: text/plain; charset=UTF-8\n"
    headers = "{headers}X-Severity: {message.severity}\n"
    return headers

fn build_email_body(message: NotificationMessage) -> text:
    """Build email message body."""
    var body = ""
    body = "{body}Dashboard Alert: {message.title}\n"
    body = "{body}Severity: {message.severity}\n"
    body = "{body}Time: {message.timestamp}\n"
    body = "{body}\n"
    body = "{body}{message.body}\n"
    body = "{body}\n"
    body = "{body}---\n"
    body = "{body}This is an automated message from Simple Dashboard.\n"
    return body

extern fn send_smtp_message(
    server: text,
    port: i32,
    from: text,
    to_list: List<text>,
    headers: text,
    body: text
) -> Result<(), text>

fn unwrap_or(opt: Option<text>, default: text) -> text:
    """Extract value from Option or use default."""
    match opt:
        case Some(v): v
        case nil: default

# =========================================================================
# Helper Functions
# =========================================================================

fn now_iso8601() -> text:
    """Get current timestamp in ISO 8601 format.

    Returns a timestamp in format: YYYY-MM-DDTHH:MM:SSZ
    """
    return core.time.now_iso8601()

fn timestamp_to_unix(iso8601: text) -> i64:
    """Convert ISO 8601 timestamp to Unix timestamp.

    Supports formats:
    - YYYY-MM-DDTHH:MM:SSZ (UTC)
    - YYYY-MM-DDTHH:MM:SS+HH:MM (with timezone)
    - YYYY-MM-DD HH:MM:SS (space separator)

    Args:
        iso8601: Timestamp in ISO 8601 format

    Returns:
        Unix timestamp (seconds since epoch), or 0 if parsing fails
    """
    if iso8601.len() < 10:
        return 0  # Invalid format

    # Validate basic structure (YYYY-MM-DD)
    if iso8601[4] != "-" or iso8601[7] != "-":
        return 0  # Invalid format

    # Parse date components
    val year = parse_int_substring(iso8601, 0, 4)
    val month = parse_int_substring(iso8601, 5, 7)
    val day = parse_int_substring(iso8601, 8, 10)

    # Validate date ranges
    if year < 1970 or year > 9999:
        return 0
    if month < 1 or month > 12:
        return 0
    if day < 1 or day > 31:
        return 0

    # Parse time if present
    var hour = 0
    var minute = 0
    var second = 0
    var tz_offset = 0

    if iso8601.len() > 10:
        # Check for time separator (T or space)
        if iso8601[10] != "T" and iso8601[10] != " ":
            return 0

        if iso8601.len() >= 19:
            # Validate time structure
            if iso8601[13] != ":" or iso8601[16] != ":":
                return 0

            hour = parse_int_substring(iso8601, 11, 13)
            minute = parse_int_substring(iso8601, 14, 16)
            second = parse_int_substring(iso8601, 17, 19)

            # Validate time ranges
            if hour < 0 or hour > 23:
                return 0
            if minute < 0 or minute > 59:
                return 0
            if second < 0 or second > 59:
                return 0

            # Parse timezone offset if present
            if iso8601.len() > 19:
                val tz_char = iso8601[19]
                if tz_char == "Z":
                    tz_offset = 0  # UTC
                elif tz_char == "+" or tz_char == "-":
                    # Parse +HH:MM or -HH:MM format
                    if iso8601.len() >= 25:
                        val tz_hours = parse_int_substring(iso8601, 20, 22)
                        val tz_mins = parse_int_substring(iso8601, 23, 25)
                        tz_offset = (tz_hours * 3600 + tz_mins * 60) as i64
                        if tz_char == "-":
                            tz_offset = -tz_offset

    # Calculate Unix timestamp
    val days_since_epoch = days_from_year_0_to_date(year, month, day)
    val seconds = (days_since_epoch as i64) * 86400 + (hour as i64) * 3600 + (minute as i64) * 60 + (second as i64)

    # Adjust for timezone
    return seconds - tz_offset

fn parse_int_substring(s: text, start: i32, end: i32) -> i32:
    """Extract and parse integer from string substring."""
    var result = 0
    for i in start..end:
        if i < s.len():
            val ch = s[i]
            if ch >= "0" and ch <= "9":
                result = result * 10 + (ch.to_i32() - "0".to_i32())
    return result

fn days_from_year_0_to_date(year: i32, month: i32, day: i32) -> i32:
    """Calculate days from year 0 to given date (approximate)."""
    # Simplified calculation - not exact but close enough
    val y = year - 1970  # Unix epoch start
    var days = y * 365 + y / 4 - y / 100 + y / 400

    # Add days for months (simplified - doesn't account for leap years perfectly)
    val month_days = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]
    for i in 0..month - 1:
        days = days + month_days[i]

    # Add leap day if needed
    if is_leap_year(year) and month > 2:
        days = days + 1

    # Add day of month
    days = days + day

    return days

fn is_leap_year(year: i32) -> bool:
    """Check if year is a leap year."""
    if year % 400 == 0:
        return true
    if year % 100 == 0:
        return false
    if year % 4 == 0:
        return true
    return false

fn format_timestamp_for_display(iso8601: text) -> text:
    """Format ISO 8601 timestamp for human-readable display.

    Example: 2026-01-21T12:00:00Z -> "Jan 21, 2026 12:00"
    """
    if iso8601.len() < 19:
        return iso8601

    # Extract components
    val year = iso8601.substring(0, 4)
    val month_num = parse_int_substring(iso8601, 5, 7)
    val day = iso8601.substring(8, 10)
    val time = iso8601.substring(11, 16)  # HH:MM

    # Month names
    val months = ["Jan", "Feb", "Mar", "Apr", "May", "Jun",
                  "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"]

    val month_name = if month_num >= 1 and month_num <= 12:
        months[month_num - 1]
    else:
        "???"

    return "{month_name} {day}, {year} {time}"

fn escape_json(s: text) -> text:
    """Escape special characters in JSON string."""
    var result = s
    result = result.replace("\\", "\\\\")
    result = result.replace("\"", "\\\"")
    result = result.replace("\n", "\\n")
    result = result.replace("\r", "\\r")
    result = result.replace("\t", "\\t")
    return result

# =========================================================================
# Exports
# =========================================================================

