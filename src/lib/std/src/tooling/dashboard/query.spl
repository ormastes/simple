# Dashboard Query Engine
#
# Provides SQL-like query interface for dashboard data.
# Syntax: <entity> [where <condition>] [order by <field> [asc|desc]] [limit <n>]
#
# Examples:
#   todos where priority=P0
#   features where status=incomplete
#   coverage where percent < 80
#   tests where status=failed order by name limit 10

use tooling.dashboard.types.{DashboardData, Feature, TodoItem, CoverageMetric}

# =========================================================================
# Query Types
# =========================================================================

enum QueryEntity:
    Todos
    Features
    Coverage
    Tests
    Plans

enum QueryOp:
    Eq         # =
    NotEq      # !=
    Lt         # <
    Gt         # >
    LtEq       # <=
    GtEq       # >=
    Contains   # contains
    StartsWith # starts_with

enum ConditionLogic:
    And
    Or

class QueryCondition:
    """Single query condition."""
    field: text
    op: QueryOp
    value: text
    logic: ConditionLogic  # How this condition combines with the next

    static fn new(field: text, op: QueryOp, value: text) -> QueryCondition:
        return QueryCondition {
            field: field,
            op: op,
            value: value,
            logic: ConditionLogic::And
        }

    fn with_logic(logic: ConditionLogic) -> QueryCondition:
        self.logic = logic
        return self

    fn eval_string(field_value: text) -> bool:
        """Evaluate condition against string value."""
        match self.op:
            QueryOp::Eq => field_value == self.value
            QueryOp::NotEq => field_value != self.value
            QueryOp::Contains => field_value.contains(self.value)
            QueryOp::StartsWith => field_value.starts_with(self.value)
            _ => false

    fn eval_number(field_value: f64) -> bool:
        """Evaluate condition against numeric value."""
        val threshold = parse_f64(self.value)?
        match self.op:
            QueryOp::Eq => field_value == threshold
            QueryOp::NotEq => field_value != threshold
            QueryOp::Lt => field_value < threshold
            QueryOp::Gt => field_value > threshold
            QueryOp::LtEq => field_value <= threshold
            QueryOp::GtEq => field_value >= threshold
            _ => false

class Query:
    """Parsed query."""
    entity: QueryEntity
    conditions: List<QueryCondition>
    order_by: Option<text>
    order_desc: bool
    limit: Option<i32>

    static fn new(entity: QueryEntity) -> Query:
        return Query {
            entity: entity,
            conditions: [],
            order_by: nil,
            order_desc: false,
            limit: nil
        }

    fn add_condition(condition: QueryCondition) -> Query:
        self.conditions.append(condition)
        return self

    fn set_order_by(field: text, desc: bool) -> Query:
        self.order_by = Some(field)
        self.order_desc = desc
        return self

    fn set_limit(n: i32) -> Query:
        self.limit = Some(n)
        return self

class QueryResult:
    """Query result rows."""
    entity: QueryEntity
    rows: List<Dict<text, text>>
    count: i32

    static fn new(entity: QueryEntity) -> QueryResult:
        return QueryResult {
            entity: entity,
            rows: [],
            count: 0
        }

    fn add_row(row: Dict<text, text>) -> QueryResult:
        self.rows.append(row)
        self.count = self.count + 1
        return self

    fn format_table() -> text:
        if self.rows.len() == 0:
            return "No results\n"

        var table = "Found {self.count} results:\n\n"

        match self.entity:
            QueryEntity::Todos =>
                table = "{table}ID │ Priority │ Area │ Status\n"
                table = "{table}─────┼──────────┼──────┼──────────\n"
                for row in self.rows:
                    val id = row.get("id")?
                    val priority = row.get("priority")?
                    val area = row.get("area")?
                    val status = row.get("status")?
                    table = "{table}{id} │ {priority} │ {area} │ {status}\n"

            QueryEntity::Features =>
                table = "{table}ID │ Category │ Name │ Status\n"
                table = "{table}─────┼──────────┼──────┼──────────\n"
                for row in self.rows:
                    val id = row.get("id")?
                    val category = row.get("category")?
                    val name = row.get("name")?
                    val status = row.get("status")?
                    table = "{table}{id} │ {category} │ {name} │ {status}\n"

            QueryEntity::Coverage =>
                table = "{table}Level │ Percent\n"
                table = "{table}──────┼────────\n"
                for row in self.rows:
                    val level = row.get("level")?
                    val percent = row.get("percent")?
                    table = "{table}{level} │ {percent}%\n"

            _ =>
                table = "{table}Results: {self.count} rows\n"

        return table

    fn format_json() -> text:
        var json = "{\n"
        json = "{json}  \"entity\": \"{entity_name(self.entity)}\",\n"
        json = "{json}  \"count\": {self.count},\n"
        json = "{json}  \"rows\": [\n"

        for i in 0..self.rows.len():
            val row = self.rows[i]
            json = "{json}    {\n"

            var first = true
            for key in row.keys():
                if not first:
                    json = "{json},\n"
                first = false

                val value = row[key]
                json = "{json}      \"{key}\": \"{escape_json(value)}\"\n"

            json = "{json}    }"
            if i < self.rows.len() - 1:
                json = "{json},"
            json = "{json}\n"

        json = "{json}  ]\n"
        json = "{json}}"
        return json

# =========================================================================
# Query Parser
# =========================================================================

fn parse_query(query_str: text) -> Result<Query, text>:
    """Parse query string into Query object.

    Syntax: <entity> [where <conditions>] [order by <field>] [limit <n>]
    """
    val tokens = tokenize_query(query_str)

    if tokens.len() == 0:
        return Err("Empty query")

    # Parse entity
    val entity = match tokens[0]:
        "todos" => QueryEntity::Todos
        "features" => QueryEntity::Features
        "coverage" => QueryEntity::Coverage
        "tests" => QueryEntity::Tests
        "plans" => QueryEntity::Plans
        _ => Err("Unknown entity: {tokens[0]}")

    var query = Query.new(entity)
    var pos = 1

    # Parse WHERE clause
    if pos < tokens.len() and tokens[pos] == "where":
        pos = pos + 1
        match parse_conditions(tokens, pos):
            Ok((conditions, next_pos)) =>
                for cond in conditions:
                    query = query.add_condition(cond)
                pos = next_pos
            Err(e) => Err("Error parsing conditions: {e}")

    # Parse ORDER BY clause
    if pos < tokens.len() and tokens[pos] == "order":
        if pos + 1 >= tokens.len() or tokens[pos + 1] != "by":
            return Err("Expected 'by' after 'order'")

        pos = pos + 2

        if pos >= tokens.len():
            return Err("Expected field name after 'order by'")

        val field = tokens[pos]
        pos = pos + 1

        val desc = if pos < tokens.len() and tokens[pos] == "desc":
            pos = pos + 1
            true
        else:
            false

        query = query.set_order_by(field, desc)

    # Parse LIMIT clause
    if pos < tokens.len() and tokens[pos] == "limit":
        if pos + 1 >= tokens.len():
            return Err("Expected number after 'limit'")

        val limit_value = parse_i32(tokens[pos + 1])?
        query = query.set_limit(limit_value)

    return Ok(query)

fn parse_conditions(tokens: List<text>, start: i32) -> Result<tuple<List<QueryCondition>, i32>, text>:
    """Parse WHERE conditions with AND/OR support."""
    var conditions: List<QueryCondition> = []
    var pos = start

    # Parse first condition
    if pos + 2 >= tokens.len():
        return Err("Invalid condition")

    val field = tokens[pos]
    val op_str = tokens[pos + 1]
    val value = tokens[pos + 2]
    pos = pos + 3

    val op = match op_str:
        "=" => QueryOp::Eq
        "!=" => QueryOp::NotEq
        "<" => QueryOp::Lt
        ">" => QueryOp::Gt
        "<=" => QueryOp::LtEq
        ">=" => QueryOp::GtEq
        "contains" => QueryOp::Contains
        "starts_with" => QueryOp::StartsWith
        _ => Err("Unknown operator: {op_str}")

    var cond = QueryCondition.new(field, op, value)
    conditions.append(cond)

    # Parse additional conditions with and/or
    while pos < tokens.len() and (tokens[pos] == "and" or tokens[pos] == "or"):
        val logic = if tokens[pos] == "and":
            ConditionLogic::And
        else:
            ConditionLogic::Or

        pos = pos + 1

        # Update previous condition's logic
        if conditions.len() > 0:
            conditions[conditions.len() - 1].logic = logic

        # Parse next condition
        if pos + 2 >= tokens.len():
            return Err("Expected condition after '{tokens[pos - 1]}'")

        val next_field = tokens[pos]
        val next_op_str = tokens[pos + 1]
        val next_value = tokens[pos + 2]
        pos = pos + 3

        val next_op = match next_op_str:
            "=" => QueryOp::Eq
            "!=" => QueryOp::NotEq
            "<" => QueryOp::Lt
            ">" => QueryOp::Gt
            "<=" => QueryOp::LtEq
            ">=" => QueryOp::GtEq
            "contains" => QueryOp::Contains
            "starts_with" => QueryOp::StartsWith
            _ => Err("Unknown operator: {next_op_str}")

        conditions.append(QueryCondition.new(next_field, next_op, next_value))

    return Ok((conditions, pos))

fn tokenize_query(query_str: text) -> List<text>:
    """Split query into tokens."""
    var tokens: List<text> = []
    var current_token = ""

    for ch in query_str:
        if ch == ' ':
            if not current_token.is_empty():
                tokens.append(current_token)
                current_token = ""
        else:
            current_token = "{current_token}{ch}"

    if not current_token.is_empty():
        tokens.append(current_token)

    return tokens

# =========================================================================
# Query Execution
# =========================================================================

fn execute_query(query: Query, data: DashboardData) -> QueryResult:
    """Execute query against dashboard data."""
    var result = QueryResult.new(query.entity)

    match query.entity:
        QueryEntity::Todos =>
            for todo in data.todos:
                if should_include_todo(todo, query.conditions):
                    var row = Dict.new()
                    row.insert("id", "{todo.id}")
                    row.insert("priority", todo.priority)
                    row.insert("area", todo.area)
                    row.insert("status", todo.status)
                    result = result.add_row(row)

        QueryEntity::Features =>
            for feature in data.features:
                if should_include_feature(feature, query.conditions):
                    var row = Dict.new()
                    row.insert("id", "{feature.id}")
                    row.insert("category", feature.category)
                    row.insert("name", feature.name)
                    row.insert("status", feature.status)
                    result = result.add_row(row)

        QueryEntity::Coverage =>
            for cov in data.coverage:
                if should_include_coverage(cov, query.conditions):
                    var row = Dict.new()
                    row.insert("level", cov.level)
                    row.insert("percent", "{cov.lines_percent}")
                    result = result.add_row(row)

        _ =>
            pass

    # Apply limit
    match query.limit:
        Some(n) =>
            if result.rows.len() > n:
                result.rows = result.rows.slice(0, n)
                result.count = n
        nil =>
            pass

    return result

fn should_include_todo(todo: TodoItem, conditions: List<QueryCondition>) -> bool:
    """Check if todo matches conditions with AND/OR logic."""
    if conditions.len() == 0:
        return true

    var result = true
    var current_logic = ConditionLogic::And

    for i in 0..conditions.len():
        val cond = conditions[i]
        val value = match cond.field:
            "priority" => todo.priority
            "area" => todo.area
            "status" => todo.status
            _ => ""

        val matches = cond.eval_string(value)

        # Apply logic from previous condition
        if i == 0:
            result = matches
        else:
            match current_logic:
                ConditionLogic::And =>
                    result = result and matches
                ConditionLogic::Or =>
                    result = result or matches

        # Store this condition's logic for next iteration
        if i < conditions.len() - 1:
            current_logic = conditions[i].logic

    return result

fn should_include_feature(feature: Feature, conditions: List<QueryCondition>) -> bool:
    """Check if feature matches conditions with AND/OR logic."""
    if conditions.len() == 0:
        return true

    var result = true
    var current_logic = ConditionLogic::And

    for i in 0..conditions.len():
        val cond = conditions[i]
        val value = match cond.field:
            "category" => feature.category
            "name" => feature.name
            "status" => feature.status
            _ => ""

        val matches = cond.eval_string(value)

        # Apply logic from previous condition
        if i == 0:
            result = matches
        else:
            match current_logic:
                ConditionLogic::And =>
                    result = result and matches
                ConditionLogic::Or =>
                    result = result or matches

        # Store this condition's logic for next iteration
        if i < conditions.len() - 1:
            current_logic = conditions[i].logic

    return result

fn should_include_coverage(cov: CoverageMetric, conditions: List<QueryCondition>) -> bool:
    """Check if coverage metric matches conditions with AND/OR logic."""
    if conditions.len() == 0:
        return true

    var result = true
    var current_logic = ConditionLogic::And

    for i in 0..conditions.len():
        val cond = conditions[i]
        val value = match cond.field:
            "level" => cov.level
            _ => ""

        val matches = cond.eval_string(value)

        # Apply logic from previous condition
        if i == 0:
            result = matches
        else:
            match current_logic:
                ConditionLogic::And =>
                    result = result and matches
                ConditionLogic::Or =>
                    result = result or matches

        # Store this condition's logic for next iteration
        if i < conditions.len() - 1:
            current_logic = conditions[i].logic

    return result

# =========================================================================
# Helper Functions
# =========================================================================

fn entity_name(entity: QueryEntity) -> text:
    match entity:
        QueryEntity::Todos => "todos"
        QueryEntity::Features => "features"
        QueryEntity::Coverage => "coverage"
        QueryEntity::Tests => "tests"
        QueryEntity::Plans => "plans"

fn escape_json(s: text) -> text:
    """Escape special characters in JSON string."""
    var result = s
    result = result.replace("\\", "\\\\")
    result = result.replace("\"", "\\\"")
    result = result.replace("\n", "\\n")
    result = result.replace("\r", "\\r")
    result = result.replace("\t", "\\t")
    return result

fn parse_i32(s: text) -> Result<i32, text>:
    """Parse integer."""
    var result = 0
    for i in 0..s.len():
        val ch = s.char_at(i)
        if ch >= '0' and ch <= '9':
            result = result * 10 + (ch - '0')
    return Ok(result)

fn parse_f64(s: text) -> Result<f64, text>:
    """Parse float."""
    var result = 0.0
    for i in 0..s.len():
        val ch = s.char_at(i)
        if ch >= '0' and ch <= '9':
            result = (result * 10.0) + ((ch - '0') as f64)
    return Ok(result)

# =========================================================================
# Exports
# =========================================================================

