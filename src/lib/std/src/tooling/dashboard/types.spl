# Dashboard Core Data Types
#
# This module defines all data structures used by the dashboard system
# for tracking project metrics, status, and trends.

# =========================================================================
# Enums and Status Types
# =========================================================================

# Collection mode for data gathering
enum CollectionMode:
    Quick       # Fast scan, minimal data
    Full        # Complete scan, all data
    Incremental # Only changed files

# Feature/test status
enum Status:
    Complete
    InProgress
    Planned
    Blocked
    NotSupported

# Trend direction
enum TrendStatus:
    Improving
    Degrading
    Stable
    Unknown

# Test execution status
enum TestStatus:
    Passed
    Failed
    Skipped
    Pending

# =========================================================================
# Feature Tracking
# =========================================================================

# Represents a language feature
class Feature:
    id: i32
    category: text
    name: text
    description: text
    spec: text
    mode_interpreter: Status
    mode_jit: Status
    mode_smf_cranelift: Status
    mode_smf_llvm: Status
    platforms: text
    status: Status

    static fn new(
        id: i32,
        category: text,
        name: text,
        description: text,
        spec: text,
        mode_interpreter: Status,
        mode_jit: Status,
        mode_smf_cranelift: Status,
        mode_smf_llvm: Status,
        platforms: text,
        status: Status
    ) -> Feature:
        return Feature {
            id: id,
            category: category,
            name: name,
            description: description,
            spec: spec,
            mode_interpreter: mode_interpreter,
            mode_jit: mode_jit,
            mode_smf_cranelift: mode_smf_cranelift,
            mode_smf_llvm: mode_smf_llvm,
            platforms: platforms,
            status: status
        }

    fn is_complete() -> bool:
        return self.status == Status::Complete

# =========================================================================
# SSpec Test Tracking
# =========================================================================

# Represents a SSpec BDD test file
class SspecTest:
    id: i32
    file: text
    title: text
    category: text
    difficulty: text
    status: Status
    total_tests: i32
    passed: i32
    failed: i32
    duration_ms: i32
    has_docs: bool
    last_run: text  # ISO8601 timestamp

    static fn new(
        id: i32,
        file: text,
        title: text,
        category: text,
        difficulty: text,
        status: Status,
        total_tests: i32,
        passed: i32,
        failed: i32,
        duration_ms: i32,
        has_docs: bool,
        last_run: text
    ) -> SspecTest:
        return SspecTest {
            id: id,
            file: file,
            title: title,
            category: category,
            difficulty: difficulty,
            status: status,
            total_tests: total_tests,
            passed: passed,
            failed: failed,
            duration_ms: duration_ms,
            has_docs: has_docs,
            last_run: last_run
        }

    fn success_rate() -> f64:
        if self.total_tests == 0:
            return 0.0
        return (self.passed as f64) / (self.total_tests as f64) * 100.0

# =========================================================================
# TODO Tracking
# =========================================================================

# Represents a TODO comment (extends existing TodoItem)
class TodoItem:
    id: i32
    keyword: text       # TODO or FIXME
    area: text          # Component area
    priority: text      # P0-P3
    description: text
    file: text
    line: i32
    issue: text         # Issue number (may be empty)
    blocked: text       # Comma-separated blocked issues
    status: text        # open, in_progress, done
    age_days: i32       # Days since creation
    assigned: text      # Assignee (may be empty)
    last_updated: text  # ISO8601 timestamp

    static fn new(
        id: i32,
        keyword: text,
        area: text,
        priority: text,
        description: text,
        file: text,
        line: i32,
        issue: text,
        blocked: text,
        status: text,
        age_days: i32,
        assigned: text,
        last_updated: text
    ) -> TodoItem:
        return TodoItem {
            id: id,
            keyword: keyword,
            area: area,
            priority: priority,
            description: description,
            file: file,
            line: line,
            issue: issue,
            blocked: blocked,
            status: status,
            age_days: age_days,
            assigned: assigned,
            last_updated: last_updated
        }

    fn is_critical() -> bool:
        return self.priority == "P0"

    fn is_blocked() -> bool:
        return self.blocked.len() > 0

# =========================================================================
# Coverage Metrics
# =========================================================================

# Code coverage data
class CoverageMetric:
    id: i32
    level: text            # file, crate, workspace
    crate: text            # Crate name
    file: text             # File path (empty for crate-level)
    lines_total: i32
    lines_covered: i32
    lines_percent: f64
    branches_covered: i32
    branches_percent: f64
    timestamp: text        # ISO8601

    static fn new(
        id: i32,
        level: text,
        crate: text,
        file: text,
        lines_total: i32,
        lines_covered: i32,
        lines_percent: f64,
        branches_covered: i32,
        branches_percent: f64,
        timestamp: text
    ) -> CoverageMetric:
        return CoverageMetric {
            id: id,
            level: level,
            crate: crate,
            file: file,
            lines_total: lines_total,
            lines_covered: lines_covered,
            lines_percent: lines_percent,
            branches_covered: branches_covered,
            branches_percent: branches_percent,
            timestamp: timestamp
        }

    fn is_well_covered() -> bool:
        return self.lines_percent >= 80.0

# =========================================================================
# Duplication Metrics
# =========================================================================

# Code duplication data
class DuplicationMetric:
    id: i32
    file1: text
    file2: text
    lines: i32
    tokens: i32
    percentage: f64
    timestamp: text

    static fn new(
        id: i32,
        file1: text,
        file2: text,
        lines: i32,
        tokens: i32,
        percentage: f64,
        timestamp: text
    ) -> DuplicationMetric:
        return DuplicationMetric {
            id: id,
            file1: file1,
            file2: file2,
            lines: lines,
            tokens: tokens,
            percentage: percentage,
            timestamp: timestamp
        }

# =========================================================================
# Test Execution
# =========================================================================

# Test execution results
class TestExecution:
    id: i32
    mode: text          # unit, integration, system, all
    suite: text         # Test suite name
    total: i32
    passed: i32
    failed: i32
    skipped: i32
    duration_ms: i32
    timestamp: text

    static fn new(
        id: i32,
        mode: text,
        suite: text,
        total: i32,
        passed: i32,
        failed: i32,
        skipped: i32,
        duration_ms: i32,
        timestamp: text
    ) -> TestExecution:
        return TestExecution {
            id: id,
            mode: mode,
            suite: suite,
            total: total,
            passed: passed,
            failed: failed,
            skipped: skipped,
            duration_ms: duration_ms,
            timestamp: timestamp
        }

    fn success_rate() -> f64:
        if self.total == 0:
            return 0.0
        return (self.passed as f64) / (self.total as f64) * 100.0

# =========================================================================
# Lean Verification
# =========================================================================

# Lean verification status
class VerificationStatus:
    id: i32
    module: text
    property: text
    status: text        # proved, axiom, pending
    proof_lines: i32
    timestamp: text

    static fn new(
        id: i32,
        module: text,
        property: text,
        status: text,
        proof_lines: i32,
        timestamp: text
    ) -> VerificationStatus:
        return VerificationStatus {
            id: id,
            module: module,
            property: property,
            status: status,
            proof_lines: proof_lines,
            timestamp: timestamp
        }

    fn is_proved() -> bool:
        return self.status == "proved"

# =========================================================================
# VCS State
# =========================================================================

# Version control system state
class VcsState:
    bookmark: text
    commit_id: text
    commit_message: text
    uncommitted_files: i32
    untracked_files: i32
    timestamp: text

    static fn new(
        bookmark: text,
        commit_id: text,
        commit_message: text,
        uncommitted_files: i32,
        untracked_files: i32,
        timestamp: text
    ) -> VcsState:
        return VcsState {
            bookmark: bookmark,
            commit_id: commit_id,
            commit_message: commit_message,
            uncommitted_files: uncommitted_files,
            untracked_files: untracked_files,
            timestamp: timestamp
        }

    fn is_clean() -> bool:
        return self.uncommitted_files == 0 and self.untracked_files == 0

# =========================================================================
# Build Times
# =========================================================================

# Build time tracking
class BuildTime:
    id: i32
    timestamp: text
    target: text          # debug, release, test
    mode: text            # incremental, clean
    duration_ms: i32
    crates_compiled: i32
    incremental: bool
    commit_id: text

    static fn new(
        id: i32,
        timestamp: text,
        target: text,
        mode: text,
        duration_ms: i32,
        crates_compiled: i32,
        incremental: bool,
        commit_id: text
    ) -> BuildTime:
        return BuildTime {
            id: id,
            timestamp: timestamp,
            target: target,
            mode: mode,
            duration_ms: duration_ms,
            crates_compiled: crates_compiled,
            incremental: incremental,
            commit_id: commit_id
        }

    fn duration_seconds() -> f64:
        return (self.duration_ms as f64) / 1000.0

# =========================================================================
# Dependencies
# =========================================================================

# Dependency health tracking
class Dependency:
    id: i32
    crate_name: text
    current_version: text
    latest_version: text
    outdated: bool
    has_security_issue: bool
    last_checked: text

    static fn new(
        id: i32,
        crate_name: text,
        current_version: text,
        latest_version: text,
        outdated: bool,
        has_security_issue: bool,
        last_checked: text
    ) -> Dependency:
        return Dependency {
            id: id,
            crate_name: crate_name,
            current_version: current_version,
            latest_version: latest_version,
            outdated: outdated,
            has_security_issue: has_security_issue,
            last_checked: last_checked
        }

    fn needs_update() -> bool:
        return self.outdated or self.has_security_issue

# =========================================================================
# Plan Tracking
# =========================================================================

# Implementation plan tracking
class Plan:
    id: i32
    file: text
    title: text
    status: text          # in_progress, completed, blocked
    created: text
    last_updated: text
    total_steps: i32
    completed_steps: i32
    blocked: bool

    static fn new(
        id: i32,
        file: text,
        title: text,
        status: text,
        created: text,
        last_updated: text,
        total_steps: i32,
        completed_steps: i32,
        blocked: bool
    ) -> Plan:
        return Plan {
            id: id,
            file: file,
            title: title,
            status: status,
            created: created,
            last_updated: last_updated,
            total_steps: total_steps,
            completed_steps: completed_steps,
            blocked: blocked
        }

    fn progress_percent() -> f64:
        if self.total_steps == 0:
            return 0.0
        return (self.completed_steps as f64) / (self.total_steps as f64) * 100.0

# =========================================================================
# Trend Analysis
# =========================================================================

# Historical trend data
class Trend:
    metric: text
    current: f64
    previous: f64
    change_percent: f64
    status: TrendStatus
    history: List<f64>    # Last N data points

    static fn new(
        metric: text,
        current: f64,
        previous: f64,
        change_percent: f64,
        status: TrendStatus,
        history: List<f64>
    ) -> Trend:
        return Trend {
            metric: metric,
            current: current,
            previous: previous,
            change_percent: change_percent,
            status: status,
            history: history
        }

# =========================================================================
# Alert System
# =========================================================================

# Alert for regressions or issues
class Alert:
    level: text           # critical, warning, info
    metric: text
    message: text
    current_value: f64
    threshold: f64
    timestamp: text

    static fn new(
        level: text,
        metric: text,
        message: text,
        current_value: f64,
        threshold: f64,
        timestamp: text
    ) -> Alert:
        return Alert {
            level: level,
            metric: metric,
            message: message,
            current_value: current_value,
            threshold: threshold,
            timestamp: timestamp
        }

    fn is_critical() -> bool:
        return self.level == "critical"

# =========================================================================
# Aggregate Dashboard Data
# =========================================================================

# Complete dashboard data snapshot
class DashboardData:
    features: List<Feature>
    sspec_tests: List<SspecTest>
    todos: List<TodoItem>
    coverage: List<CoverageMetric>
    duplication: List<DuplicationMetric>
    test_executions: List<TestExecution>
    verification: List<VerificationStatus>
    vcs_state: VcsState
    build_times: List<BuildTime>
    dependencies: List<Dependency>
    plans: List<Plan>
    timestamp: text

    static fn new(
        features: List<Feature>,
        sspec_tests: List<SspecTest>,
        todos: List<TodoItem>,
        coverage: List<CoverageMetric>,
        duplication: List<DuplicationMetric>,
        test_executions: List<TestExecution>,
        verification: List<VerificationStatus>,
        vcs_state: VcsState,
        build_times: List<BuildTime>,
        dependencies: List<Dependency>,
        plans: List<Plan>,
        timestamp: text
    ) -> DashboardData:
        return DashboardData {
            features: features,
            sspec_tests: sspec_tests,
            todos: todos,
            coverage: coverage,
            duplication: duplication,
            test_executions: test_executions,
            verification: verification,
            vcs_state: vcs_state,
            build_times: build_times,
            dependencies: dependencies,
            plans: plans,
            timestamp: timestamp
        }

    # Summary statistics
    fn total_features() -> i32:
        return self.features.len()

    fn completed_features() -> i32:
        return self.features.filter(\f: f.is_complete()).len()

    fn total_todos() -> i32:
        return self.todos.len()

    fn critical_todos() -> i32:
        return self.todos.filter(\t: t.is_critical()).len()

    fn overall_coverage() -> f64:
        val workspace_coverage = self.coverage.filter(\c: c.level == "workspace")
        if workspace_coverage.len() > 0:
            return workspace_coverage[0].lines_percent
        return 0.0

# =========================================================================
# Exports
# =========================================================================

