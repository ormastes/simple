# Dashboard Comparative Analysis
#
# Compares metrics between two time periods or snapshots.
# Supports comparing against historical snapshots or current live data.

use tooling.dashboard.snapshots.{SnapshotData, SnapshotManager, load_recent_snapshots}
use tooling.dashboard.types.{DashboardData}
use tooling.dashboard.collector.{collect_full}

# =========================================================================
# Comparison Data Types
# =========================================================================

class ComparisonSnapshot:
    """Snapshot for comparison with comprehensive metrics."""
    date: text
    coverage: f64
    features_complete: i32
    features_total: i32
    todos_total: i32
    todos_p0: i32
    tests_count: i32
    duplication_percent: f64
    build_time_ms: i32
    verification_pass_percent: f64

    static fn new(
        date: text,
        coverage: f64,
        features_complete: i32,
        features_total: i32,
        todos_total: i32,
        todos_p0: i32,
        tests_count: i32
    ) -> ComparisonSnapshot:
        return ComparisonSnapshot {
            date: date,
            coverage: coverage,
            features_complete: features_complete,
            features_total: features_total,
            todos_total: todos_total,
            todos_p0: todos_p0,
            tests_count: tests_count,
            duplication_percent: 0.0,
            build_time_ms: 0,
            verification_pass_percent: 100.0
        }

    static fn from_dashboard_data(data: DashboardData) -> ComparisonSnapshot:
        return ComparisonSnapshot.new(
            data.timestamp,
            data.overall_coverage(),
            data.completed_features(),
            data.total_features(),
            data.total_todos(),
            data.critical_todos(),
            data.sspec_tests.len()
        )

    static fn from_snapshot_data(snapshot: SnapshotData) -> ComparisonSnapshot:
        return ComparisonSnapshot.new(
            snapshot.date,
            snapshot.coverage_percent,
            snapshot.features_complete,
            snapshot.features_total,
            snapshot.todos_total,
            snapshot.todos_critical,
            snapshot.sspec_tests
        )

    fn features_percent() -> f64:
        if self.features_total == 0:
            return 0.0
        return ((self.features_complete as f64) / (self.features_total as f64)) * 100.0

class MetricComparison:
    """Single metric comparison."""
    name: text
    baseline_value: f64
    current_value: f64
    change: f64
    change_percent: f64
    trend: text  # "improving", "degrading", "stable"

    static fn new(name: text, baseline: f64, current: f64) -> MetricComparison:
        val change = current - baseline
        val change_percent = if baseline == 0.0:
            0.0
        else:
            (change / baseline) * 100.0

        val trend = if change > 0.5:
            "improving"
        elif change < -0.5:
            "degrading"
        else:
            "stable"

        return MetricComparison {
            name: name,
            baseline_value: baseline,
            current_value: current,
            change: change,
            change_percent: change_percent,
            trend: trend
        }

    fn to_string() -> text:
        val trend_icon = match self.trend:
            case "improving": "[UP]"
            case "degrading": "[DOWN]"
            case _: "[STABLE]"

        return "{self.name}: {self.baseline_value:.1f}% -> {self.current_value:.1f}% ({self.change_percent:+.1f}%) {trend_icon}"

class ComparisonReport:
    """Full comparison report."""
    baseline_date: text
    current_date: text
    baseline_snapshot: ComparisonSnapshot
    current_snapshot: ComparisonSnapshot
    comparisons: List<MetricComparison>

    static fn new(
        baseline: ComparisonSnapshot,
        current: ComparisonSnapshot
    ) -> ComparisonReport:
        var comparisons: List<MetricComparison> = []

        # Coverage comparison
        comparisons.append(MetricComparison.new(
            "Coverage",
            baseline.coverage,
            current.coverage
        ))

        # Features comparison
        comparisons.append(MetricComparison.new(
            "Features",
            baseline.features_percent(),
            current.features_percent()
        ))

        # TODOs comparison (lower is better)
        var baseline_todos_normalized = if baseline.todos_total > 0:
            (baseline.todos_p0 as f64)
        else:
            0.0
        var current_todos_normalized = if current.todos_total > 0:
            (current.todos_p0 as f64)
        else:
            0.0

        comparisons.append(MetricComparison.new(
            "P0 TODOs",
            baseline_todos_normalized,
            current_todos_normalized
        ))

        # Tests comparison
        comparisons.append(MetricComparison.new(
            "Tests",
            (baseline.tests_count as f64),
            (current.tests_count as f64)
        ))

        # Duplication comparison (lower is better)
        comparisons.append(MetricComparison.new(
            "Duplication",
            baseline.duplication_percent,
            current.duplication_percent
        ))

        # Verification pass rate
        comparisons.append(MetricComparison.new(
            "Verification",
            baseline.verification_pass_percent,
            current.verification_pass_percent
        ))

        return ComparisonReport {
            baseline_date: baseline.date,
            current_date: current.date,
            baseline_snapshot: baseline,
            current_snapshot: current,
            comparisons: comparisons
        }

    fn improving_count() -> i32:
        var count = 0
        for comp in self.comparisons:
            if comp.trend == "improving":
                count = count + 1
        return count

    fn degrading_count() -> i32:
        var count = 0
        for comp in self.comparisons:
            if comp.trend == "degrading":
                count = count + 1
        return count

    fn summary() -> text:
        var summary = "Comparison Report: {self.baseline_date} → {self.current_date}\n"
        summary = "{summary}\n"
        summary = "{summary}Improvements: {self.improving_count()}\n"
        summary = "{summary}Regressions: {self.degrading_count()}\n"
        return summary

    fn format_table() -> text:
        var table = "Metric       | Baseline | Current  | Change  | Trend\n"
        table = "{table}─────────────┼──────────┼──────────┼─────────┼──────\n"

        for comp in self.comparisons:
            val trend_icon = match comp.trend:
                case "improving": "UP"
                case "degrading": "DOWN"
                case _: "STABLE"

            table = "{table}{comp.name:<12} | {comp.baseline_value:>7.1f}% | {comp.current_value:>7.1f}% | {comp.change_percent:>+6.1f}% | {trend_icon:<6}\n"

        return table

    fn format_json() -> text:
        var json = "{\n"
        json = "{json}  \"baseline_date\": \"{self.baseline_date}\",\n"
        json = "{json}  \"current_date\": \"{self.current_date}\",\n"
        json = "{json}  \"baseline\": {\n"
        json = "{json}    \"coverage\": {self.baseline_snapshot.coverage},\n"
        json = "{json}    \"features_percent\": {self.baseline_snapshot.features_percent()},\n"
        json = "{json}    \"todos_p0\": {self.baseline_snapshot.todos_p0}\n"
        json = "{json}  },\n"
        json = "{json}  \"current\": {\n"
        json = "{json}    \"coverage\": {self.current_snapshot.coverage},\n"
        json = "{json}    \"features_percent\": {self.current_snapshot.features_percent()},\n"
        json = "{json}    \"todos_p0\": {self.current_snapshot.todos_p0}\n"
        json = "{json}  },\n"
        json = "{json}  \"improvements\": {self.improving_count()},\n"
        json = "{json}  \"regressions\": {self.degrading_count()}\n"
        json = "{json}}"
        return json

# =========================================================================
# Comparison Functions
# =========================================================================

fn compare_snapshots(
    baseline: ComparisonSnapshot,
    current: ComparisonSnapshot
) -> ComparisonReport:
    """Compare two snapshots."""
    return ComparisonReport.new(baseline, current)

fn load_snapshot_by_date(date: text) -> Result<ComparisonSnapshot, text>:
    """Load snapshot for a specific date.

    Args:
        date: Date in YYYY-MM-DD format

    Returns:
        ComparisonSnapshot if found, error otherwise
    """
    val manager = SnapshotManager.new()
    match manager.load_snapshot(date):
        case Ok(snapshot_data):
            Ok(ComparisonSnapshot.from_snapshot_data(snapshot_data))
        case Err(e):
            Err("Failed to load snapshot for {date}: {e}")

fn get_current_snapshot() -> Result<ComparisonSnapshot, text>:
    """Get snapshot of current live data."""
    match collect_full():
        case Ok(data): Ok(ComparisonSnapshot.from_dashboard_data(data))
        case Err(e): Err("Failed to collect current data: {e}")

fn compare_with_date(
    baseline_date: text,
    current_date: Option<text>
) -> Result<ComparisonReport, text>:
    """Compare baseline date with current or specified date.

    Args:
        baseline_date: Baseline date (YYYY-MM-DD)
        current_date: Current date to compare to, or nil for live data

    Returns:
        ComparisonReport if successful, error otherwise
    """
    # Load baseline snapshot
    match load_snapshot_by_date(baseline_date):
        case Ok(baseline):
            # Load current snapshot
            val current_result = match current_date:
                case Some(date): load_snapshot_by_date(date)
                case nil: get_current_snapshot()

            match current_result:
                case Ok(current): Ok(compare_snapshots(baseline, current))
                case Err(e): Err("Failed to load current snapshot: {e}")
        case Err(e): Err("Failed to load baseline snapshot: {e}")

# =========================================================================
# Exports
# =========================================================================

