# Feature Test Scaffolding Tool
# Migrated from: scripts/scaffold_feature_test.py
# Purpose: Generate BDD test templates from feature markdown files

import fs.{read_text, write_text}
import regex.{captures, find_all, is_match}

# Feature metadata extracted from markdown
struct FeatureMetadata:
    feature_id: text
    feature_name: text
    category: text
    difficulty: u64
    status: text
    impl_type: text
    spec_ref: text
    files: List<text>
    tests: List<text>
    description: text
    dependencies: List<u64>
    required_by: List<u64>
    notes: text

impl FeatureMetadata:
    # Create empty metadata
    static fn new() -> FeatureMetadata:
        FeatureMetadata(
            feature_id: "",
            feature_name: "",
            category: "",
            difficulty: 3,
            status: "✅ Complete",
            impl_type: "R",
            spec_ref: "",
            files: [],
            tests: [],
            description: "",
            dependencies: [],
            required_by: [],
            notes: ""
        )

    # Create with basic info
    static fn with_info(id: text, name: text, category: text) -> FeatureMetadata:
        var meta = FeatureMetadata.new()
        meta.feature_id = id
        meta.feature_name = name
        meta.category = category
        meta

# Scaffold generation result
struct ScaffoldResult:
    success: bool
    content: text
    error_message: text

impl ScaffoldResult:
    # Create success result
    static fn success(content: text) -> ScaffoldResult:
        ScaffoldResult(
            success: true,
            content: content,
            error_message: ""
        )

    # Create error result
    static fn error(message: text) -> ScaffoldResult:
        ScaffoldResult(
            success: false,
            content: "",
            error_message: message
        )

# Parse overview table from markdown content
fn parse_overview_table(content: text) -> FeatureMetadata:
    var metadata = FeatureMetadata.new()

    # Extract Feature ID: | **Feature ID** | #123 |
    val id_caps = captures(r"\|\s*\*\*Feature ID\*\*\s*\|\s*#?(\d+)\s*\|", content)
    if id_caps.len() > 1:
        metadata.feature_id = id_caps[1]

    # Extract Feature Name: | **Feature Name** | My Feature |
    val name_caps = captures(r"\|\s*\*\*Feature Name\*\*\s*\|\s*([^|]+)\s*\|", content)
    if name_caps.len() > 1:
        metadata.feature_name = name_caps[1].trim()

    # Extract Category: | **Category** | core |
    val cat_caps = captures(r"\|\s*\*\*Category\*\*\s*\|\s*([^|]+)\s*\|", content)
    if cat_caps.len() > 1:
        metadata.category = cat_caps[1].trim()

    # Extract Difficulty: | **Difficulty** | 3 |
    val diff_caps = captures(r"\|\s*\*\*Difficulty\*\*\s*\|\s*(\d+)\s*\|", content)
    if diff_caps.len() > 1:
        match diff_caps[1].parse_u64():
            Some(d): metadata.difficulty = d
            None: pass

    # Extract Status: | **Status** | ✅ Complete |
    val status_caps = captures(r"\|\s*\*\*Status\*\*\s*\|\s*([^|]+)\s*\|", content)
    if status_caps.len() > 1:
        metadata.status = status_caps[1].trim()

    # Extract Impl Type: | **Type** | R |
    val type_caps = captures(r"\|\s*\*\*Type\*\*\s*\|\s*([^|]+)\s*\|", content)
    if type_caps.len() > 1:
        metadata.impl_type = type_caps[1].trim()

    # Extract Spec Ref: | **Spec Ref** | spec/lexer.md |
    val spec_caps = captures(r"\|\s*\*\*Spec Ref\*\*\s*\|\s*([^|]+)\s*\|", content)
    if spec_caps.len() > 1:
        metadata.spec_ref = spec_caps[1].trim()

    metadata

# Extract content from a specific markdown section
fn extract_section(content: text, section_name: text) -> text:
    # Look for ## section_name then capture until next ## or end
    val lines = content.split("\n")
    var in_section = false
    var result_lines: List<text> = []

    for line in lines:
        if line.starts_with("## "):
            val header = line.slice(3, line.len()).trim()
            if header == section_name:
                in_section = true
                continue
            elif in_section:
                # Found next section, stop
                break

        if in_section:
            result_lines.push(line)

    result_lines.join("\n").trim()

# Extract file paths from implementation files table
fn parse_file_table(content: text) -> List<text>:
    var files: List<text> = []

    # Find table rows with file paths: | `path/to/file.rs` | ... |
    val matches = find_all(r"\|\s*`([^`]+)`\s*\|", content)
    var i = 0
    while i < matches.len():
        val match_ = matches[i]
        # match_.text contains the full match, extract the path from capture
        val path_caps = captures(r"`([^`]+)`", match_.text)
        if path_caps.len() > 1:
            files.push(path_caps[1])
        i = i + 1

    files

# Extract test file paths from testing section
fn parse_test_table(content: text, section_name: text) -> List<text>:
    # First extract the relevant section
    val section = extract_section(content=content, section_name=section_name)
    # Then parse the file table within it
    parse_file_table(section)

# Extract code examples from Examples section
fn extract_code_examples(content: text) -> List<text>:
    var examples: List<text> = []

    # Find ```simple code blocks
    # This is a simplified approach - find lines between ```simple and ```
    val lines = content.split("\n")
    var in_code_block = false
    var current_example: List<text> = []

    for line in lines:
        if line.trim().starts_with("```simple"):
            in_code_block = true
            current_example = []
            continue
        elif line.trim() == "```" and in_code_block:
            in_code_block = false
            if current_example.len() > 0:
                examples.push(current_example.join("\n"))
            continue

        if in_code_block:
            current_example.push(line)

    examples

# Extract depends_on and required_by feature IDs
fn parse_dependencies(content: text) -> (List<u64>, List<u64>):
    var depends_on: List<u64> = []
    var required_by: List<u64> = []

    # Pattern: Depends on: #1, #2, #3
    val deps_caps = captures(r"Depends on:\s*([^\n]+)", content)
    if deps_caps.len() > 1:
        val deps_str = deps_caps[1]
        # Extract all #NNN patterns
        val dep_matches = find_all(r"#(\d+)", deps_str)
        var i = 0
        while i < dep_matches.len():
            val match_ = dep_matches[i]
            val num_caps = captures(r"#(\d+)", match_.text)
            if num_caps.len() > 1:
                match num_caps[1].parse_u64():
                    Some(num): depends_on.push(num)
                    None: pass
            i = i + 1

    # Pattern: Required by: #4, #5, #6
    val reqs_caps = captures(r"Required by:\s*([^\n]+)", content)
    if reqs_caps.len() > 1:
        val reqs_str = reqs_caps[1]
        # Extract all #NNN patterns
        val req_matches = find_all(r"#(\d+)", reqs_str)
        var j = 0
        while j < req_matches.len():
            val match_ = req_matches[j]
            val num_caps = captures(r"#(\d+)", match_.text)
            if num_caps.len() > 1:
                match num_caps[1].parse_u64():
                    Some(num): required_by.push(num)
                    None: pass
            j = j + 1

    (depends_on, required_by)

# Generate BDD test scaffold from feature metadata
fn generate_test_scaffold(metadata: FeatureMetadata, source_file: text) -> text:
    var output = ""

    # Header comments
    output = output + "# Scaffolded from {source_file}\n"
    output = output + "# TODO: Add real test assertions before marking complete\n\n"

    # Import
    output = output + "use spec.feature_doc.feature_metadata\n\n"

    # Describe block with feature metadata
    output = output + "describe \"{metadata.feature_name} (#{metadata.feature_id})\":\n"
    output = output + "    feature_metadata(\n"
    output = output + "        id: {metadata.feature_id},\n"
    output = output + "        name: \"{metadata.feature_name}\",\n"
    output = output + "        category: \"{metadata.category}\",\n"
    output = output + "        difficulty: {metadata.difficulty},\n"
    output = output + "        status: \"{metadata.status}\",\n"
    output = output + "        impl_type: \"{metadata.impl_type}\",\n"
    output = output + "        spec_ref: \"{metadata.spec_ref}\",\n"

    # Files list
    if metadata.files.is_empty():
        output = output + "        files: [],\n"
    else:
        output = output + "        files: [\n"
        var i = 0
        while i < metadata.files.len():
            output = output + "            \"{metadata.files[i]}\",\n"
            i = i + 1
        output = output + "        ],\n"

    # Tests list
    if metadata.tests.is_empty():
        output = output + "        tests: [],\n"
    else:
        output = output + "        tests: [\n"
        var i = 0
        while i < metadata.tests.len():
            output = output + "            \"{metadata.tests[i]}\",\n"
            i = i + 1
        output = output + "        ],\n"

    # Description (triple-quoted string)
    if metadata.description.is_empty():
        output = output + "        description: \"\",\n"
    else:
        output = output + "        description: \"\"\"\n"
        output = output + "{metadata.description}\n"
        output = output + "        \"\"\",\n"

    # Dependencies
    if metadata.dependencies.is_empty():
        output = output + "        dependencies: [],\n"
    else:
        val deps_str = join_u64_list(metadata.dependencies)
        output = output + "        dependencies: [{deps_str}],\n"

    # Required by
    if metadata.required_by.is_empty():
        output = output + "        required_by: [],\n"
    else:
        val reqs_str = join_u64_list(metadata.required_by)
        output = output + "        required_by: [{reqs_str}],\n"

    # Notes
    if metadata.notes.is_empty():
        output = output + "        notes: \"\"\n"
    else:
        output = output + "        notes: \"\"\"\n"
        output = output + "{metadata.notes}\n"
        output = output + "        \"\"\"\n"

    output = output + "    )\n\n"

    # Add test stubs
    output = output + "    # TODO: Add test contexts and examples\n"
    output = output + "    context \"Basic Functionality\":\n"
    output = output + "        it \"works as expected\":\n"
    output = output + "            # TODO: Import required modules\n"
    output = output + "            # TODO: Add test setup\n"
    output = output + "            # TODO: Write assertions\n"
    output = output + "            skip \"TODO: Add real assertion\"\n\n"

    output

# Helper: Join list of u64 with commas
fn join_u64_list(list: List<u64>) -> text:
    var result = ""
    var i = 0
    while i < list.len():
        if i > 0:
            result = result + ", "
        result = result + "{list[i]}"
        i = i + 1
    result

# Generate scaffold from markdown file
fn scaffold_from_file(md_path: text) -> ScaffoldResult:
    # Read markdown file
    match read_text(md_path):
        Ok(content):
            # Parse metadata from the overview table
            var metadata = parse_overview_table(content)

            # Extract description from "Description" section
            metadata.description = extract_section(content=content, section_name="Description")

            # Parse file table for implementation files
            metadata.files = parse_file_table(extract_section(content=content, section_name="Implementation Files"))

            # Parse test table for test files
            metadata.tests = parse_test_table(content=content, section_name="Testing")

            # Extract dependencies and required_by
            val (deps, reqs) = parse_dependencies(content)
            metadata.dependencies = deps
            metadata.required_by = reqs

            # Extract notes section
            metadata.notes = extract_section(content=content, section_name="Notes")

            # Generate scaffold
            val scaffold_content = generate_test_scaffold(metadata, md_path)
            ScaffoldResult.success(scaffold_content)
        Err(e):
            ScaffoldResult.error("Failed to read markdown file: {e}")

# Scaffold statistics
struct ScaffoldStats:
    total_scaffolds: u64
    successful: u64
    failed: u64

impl ScaffoldStats:
    # Create empty stats
    static fn new() -> ScaffoldStats:
        ScaffoldStats(
            total_scaffolds: 0,
            successful: 0,
            failed: 0
        )

    # Record successful scaffold
    me add_success():
        self.total_scaffolds = self.total_scaffolds + 1
        self.successful = self.successful + 1

    # Record failed scaffold
    me add_failure():
        self.total_scaffolds = self.total_scaffolds + 1
        self.failed = self.failed + 1

    # Generate summary
    fn summary() -> text:
        var report = ""
        report = report + "Scaffold Generation Summary:\n"
        report = report + "  Total: {self.total_scaffolds}\n"
        report = report + "  Successful: {self.successful}\n"
        report = report + "  Failed: {self.failed}\n"
        report

# Write scaffold to file
fn write_scaffold_to_file(output_path: text, content: text) -> Result<(), text>:
    match write_text(path=output_path, content=content):
        Ok(_): Ok(())
        Err(e): Err("Failed to write scaffold: {e}")

# Generate and write scaffold from markdown file to output file
fn scaffold_and_write(md_path: text, output_path: text) -> Result<(), text>:
    match scaffold_from_file(md_path):
        Ok(result):
            if result.success:
                write_scaffold_to_file(output_path=output_path, content=result.content)
            else:
                Err(result.error_message)
        Err(e):
            Err(e)

# CLI options for scaffold_feature command
struct ScaffoldFeatureOptions:
    markdown_file: Option<text>
    output_file: Option<text>
    stdout: bool
    show_help: bool

impl ScaffoldFeatureOptions:
    # Create default options
    static fn default() -> ScaffoldFeatureOptions:
        ScaffoldFeatureOptions(
            markdown_file: None,
            output_file: None,
            stdout: false,
            show_help: false
        )

    # Parse CLI arguments
    static fn parse(args: List<text>) -> ScaffoldFeatureOptions:
        var options = ScaffoldFeatureOptions.default()
        var positional_count = 0
        var i = 0

        while i < args.len():
            val arg = args[i]

            if arg == "--stdout" or arg == "-s":
                options.stdout = true
            elif arg == "--output" or arg == "-o" and i + 1 < args.len():
                i = i + 1
                options.output_file = Some(args[i])
            elif arg == "--help" or arg == "-h":
                options.show_help = true
            elif not arg.starts_with("-"):
                # Positional arguments: markdown_file and output_file
                if positional_count == 0:
                    options.markdown_file = Some(arg)
                elif positional_count == 1:
                    options.output_file = Some(arg)
                positional_count = positional_count + 1

            i = i + 1

        options

# Print usage help for scaffold_feature
fn print_scaffold_feature_help() -> text:
    var help = ""
    help = help + "Usage: simple scaffold-feature [OPTIONS] <MARKDOWN_FILE> [OUTPUT_FILE]\n\n"
    help = help + "Generate BDD test templates from feature markdown files.\n\n"
    help = help + "Arguments:\n"
    help = help + "  MARKDOWN_FILE    Feature description markdown file\n"
    help = help + "  OUTPUT_FILE      Output _spec.spl file (optional)\n\n"
    help = help + "Options:\n"
    help = help + "  -o, --output     Specify output file explicitly\n"
    help = help + "  -s, --stdout     Print scaffold to stdout instead of file\n"
    help = help + "  -h, --help       Show this help message\n\n"
    help = help + "Examples:\n"
    help = help + "  simple scaffold-feature doc/features/001_lexer.md\n"
    help = help + "  simple scaffold-feature doc/features/001_lexer.md tests/001_lexer_spec.spl\n"
    help = help + "  simple scaffold-feature --stdout doc/features/001_lexer.md\n"
    help

# Main entry point
fn main_scaffold_feature(args: List<text>) -> Result<(), text>:
    val options = ScaffoldFeatureOptions.parse(args)

    # Show help if requested
    if options.show_help:
        print print_scaffold_feature_help()
        return Ok(())

    # Require markdown file
    match options.markdown_file:
        Some(md_path):
            print "Scaffolding from: {md_path}"

            # Generate scaffold
            val result = scaffold_from_file(md_path)

            if result.success:
                if options.stdout:
                    # Print to stdout
                    print result.content
                    Ok(())
                else:
                    # Write to file
                    val output_path = match options.output_file:
                        Some(path): path
                        None:
                            # Generate default output path
                            # Replace .md with _spec.spl
                            val base = md_path.replace(".md", "")
                            "{base}_spec.spl"

                    match write_scaffold_to_file(output_path=output_path, content=result.content):
                        Ok(_):
                            print "Scaffold written to: {output_path}"
                            Ok(())
                        Err(e):
                            Err(e)
            else:
                Err(result.error_message)
        None:
            Err("Missing required argument: MARKDOWN_FILE\nRun with --help for usage information.")
