# Compilation command handlers
# Migrated from: src/driver/src/cli/commands/compile_commands.rs
# Purpose: Handle compile, targets, and linkers commands

# Handle 'compile' command - compile source to SMF or native binary
fn handle_compile(args: List<text>) -> i32:
    if args.len() < 2:
        print_compile_help()
        return 1

    val source = args[1]

    # Parse output file
    val output = find_flag_value(args, "-o", "-o", "")

    # Parse flags
    val native = args.any(\a: a == "--native")
    val snapshot = args.any(\a: a == "--snapshot")

    # Parse target architecture
    val target = parse_target_flag(args)

    # Parse linker
    val linker = parse_linker_flag(args)

    # Print linker info if specified
    if linker.is_some():
        val l = linker.unwrap()
        if not is_linker_available(l):
            print_err("warning: linker '{l}' not found on system")
        elif native:
            print "Using linker: {l}"

    if native:
        # Parse native binary options
        val layout_optimize = args.any(\a: a == "--layout-optimize")
        val strip = args.any(\a: a == "--strip")
        val pie = not args.any(\a: a == "--no-pie")
        val is_shared = args.any(\a: a == "--shared")
        val generate_map = args.any(\a: a == "--map")

        compile_file_native(
            source,
            output,
            target,
            linker,
            layout_optimize,
            strip,
            pie,
            is_shared,
            generate_map
        )
    else:
        # Compile to SMF
        val options = parse_compile_options(args)
        compile_file(source, output, target, snapshot, options)

# Handle 'targets' command - list available compilation targets
fn handle_targets() -> i32:
    list_targets()

# Handle 'linkers' command - list available native linkers
fn handle_linkers() -> i32:
    list_linkers()

# Parse --target flag
fn parse_target_flag(args: List<text>) -> Option<text>:
    val pos = args.position(\a: a == "--target")
    if pos.is_some():
        val idx = pos.unwrap()
        if idx + 1 < args.len():
            val target_str = args[idx + 1]
            # Validate target architecture
            match parse_target_arch(target_str):
                Ok(arch) =>
                    # Return target with host OS
                    Some(create_target(arch))
                Err(e) =>
                    print_err("error: {e}")
                    exit_process(1)
                    None  # Unreachable but needed for type
        else:
            None
    else:
        None

# Parse --linker flag
fn parse_linker_flag(args: List<text>) -> Option<text>:
    val pos = args.position(\a: a == "--linker")
    if pos.is_some():
        val idx = pos.unwrap()
        if idx + 1 < args.len():
            val linker_name = args[idx + 1]
            # Validate linker name
            match validate_linker_name(linker_name):
                Ok(l) =>
                    Some(l)
                Err(_) =>
                    print_err("error: unknown linker '{linker_name}'. Available: mold, lld, ld")
                    exit_process(1)
                    None  # Unreachable but needed for type
        else:
            None
    else:
        None

# Print compile command help
fn print_compile_help():
    print_err("error: compile requires a source file")
    print_err("Usage: simple compile <source.spl> [-o <output>] [--native] [--target <arch>] [--linker <name>] [--snapshot]")
    print_err("")
    print_err("Options:")
    print_err("  -o <output>         Output file (default: source.smf or source for --native)")
    print_err("  --native            Compile to standalone native binary (ELF/PE)")
    print_err("  --target <arch>     Target architecture (x86_64, aarch64, etc.)")
    print_err("  --linker <name>     Native linker to use (mold, lld, ld)")
    print_err("  --layout-optimize   Enable 4KB page layout optimization")
    print_err("  --strip             Strip symbols from output")
    print_err("  --pie               Create position-independent executable (default)")
    print_err("  --no-pie            Disable position-independent executable")
    print_err("  --shared            Create shared library (.so/.dll)")
    print_err("  --map               Generate linker map file")
    print_err("  --snapshot          Create JJ snapshot with build state")

# Helper: Find flag value with default (reused from web_commands pattern)
fn find_flag_value(args: List<text>, flag1: text, flag2: text, default_val: text) -> text:
    # Try flag1
    val pos1 = args.position(\a: a == flag1)
    if pos1.is_some():
        val idx = pos1.unwrap()
        if idx + 1 < args.len():
            return args[idx + 1]

    # Try flag2
    val pos2 = args.position(\a: a == flag2)
    if pos2.is_some():
        val idx = pos2.unwrap()
        if idx + 1 < args.len():
            return args[idx + 1]

    # Return default value
    default_val


# Stub types and functions
# NOTE: Placeholder - integrate with compiler module when available

struct CompileOptions:
    debug: bool
    optimize: bool
    verify: bool

# Stub functions for compilation
fn compile_file(source: text, output: text, target: Option<text>, snapshot: bool, options: CompileOptions) -> i32:
    print "[compile] Would compile {source} to SMF (stub)"
    print "[compile]   output: {output}, snapshot: {snapshot}"
    0

fn compile_file_native(
    source: text,
    output: text,
    target: Option<text>,
    linker: Option<text>,
    layout_optimize: bool,
    strip: bool,
    pie: bool,
    is_shared: bool,
    generate_map: bool
) -> i32:
    print "[compile] Would compile {source} to native binary (stub)"
    print "[compile]   layout_optimize: {layout_optimize}, strip: {strip}, pie: {pie}"
    print "[compile]   is_shared: {is_shared}, generate_map: {generate_map}"
    0

fn list_targets() -> i32:
    print "[targets] Available compilation targets:"
    print "  - x86_64"
    print "  - aarch64"
    print "  - riscv64"
    0

fn list_linkers() -> i32:
    print "[linkers] Available native linkers:"
    print "  - mold   (fast modern linker)"
    print "  - lld    (LLVM linker)"
    print "  - ld     (GNU linker)"
    0

fn parse_target_arch(arch_str: text) -> Result<text, text>:
    match arch_str:
        "x86_64" => Ok("x86_64")
        "aarch64" => Ok("aarch64")
        "riscv64" => Ok("riscv64")
        _ => Err("unknown architecture '{arch_str}'")

fn create_target(arch: text) -> text:
    "{arch}-unknown-linux"

fn validate_linker_name(name: text) -> Result<text, text>:
    match name:
        "mold" => Ok("mold")
        "lld" => Ok("lld")
        "ld" => Ok("ld")
        _ => Err("unknown linker")

fn is_linker_available(linker: text) -> bool:
    # Stub: assume all linkers available
    true

fn parse_compile_options(args: List<text>) -> CompileOptions:
    CompileOptions(
        debug: args.any(\a: a == "--debug"),
        optimize: args.any(\a: a == "--optimize"),
        verify: args.any(\a: a == "--verify")
    )

fn exit_process(code: i32):
    # Stub: would call system exit
    print "[exit] Would exit with code {code}"

# Helper for stderr output
fn print_err(msg: text):
    eprint msg
