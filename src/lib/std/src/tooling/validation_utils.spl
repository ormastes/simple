# Validation utilities
# Pure Simple implementations without regex

# =====================================
# Email Validation (Basic)
# =====================================

# Basic email validation without regex
# Checks: has @, has domain, has TLD, no invalid chars
fn is_valid_email(email: text) -> bool:
    if email.is_empty():
        return false

    # Must contain exactly one @
    val parts = email.split("@")
    if parts.len() != 2:
        return false

    val local = parts[0]
    val domain = parts[1]

    # Local part must not be empty
    if local.is_empty():
        return false

    # Domain must have at least one dot
    val domain_parts = domain.split(".")
    if domain_parts.len() < 2:
        return false

    # Last part (TLD) must not be empty and at least 2 chars
    val tld = domain_parts[domain_parts.len() - 1]
    if tld.len() < 2:
        return false

    # Check for invalid characters
    if email.contains(" ") or email.contains(",") or email.contains(";"):
        return false

    true

# =====================================
# URL Validation (Basic)
# =====================================

# Basic URL validation without regex
# Checks: has scheme, has domain
fn is_valid_url(url: text) -> bool:
    if url.is_empty():
        return false

    # Must start with http:// or https://
    if not url.starts_with("http://") and not url.starts_with("https://"):
        return false

    # Remove scheme
    var remainder = url
    if url.starts_with("https://"):
        remainder = url.substring(8, url.len())
    elif url.starts_with("http://"):
        remainder = url.substring(7, url.len())

    # Must have something after scheme
    if remainder.is_empty():
        return false

    # Must have a domain (at least one char before /, ?, or #)
    var domain_end = remainder.len()
    if remainder.contains("/"):
        match remainder.find("/"):
            Some(idx) => domain_end = idx
            None => pass

    if domain_end == 0:
        return false

    true

# =====================================
# Number Validation
# =====================================

# Check if string is valid integer
fn is_integer(s: text) -> bool:
    if s.is_empty():
        return false

    var start = 0
    # Allow leading minus
    if s.starts_with("-"):
        start = 1
        if s.len() == 1:
            return false

    for i in start..s.len():
        val ch = s.chars()[i]
        if not ch.is_numeric():
            return false

    true

# Check if string is valid float
fn is_float(s: text) -> bool:
    if s.is_empty():
        return false

    var has_dot = false
    var start = 0

    # Allow leading minus
    if s.starts_with("-"):
        start = 1
        if s.len() == 1:
            return false

    for i in start..s.len():
        val ch = s.chars()[i]
        if ch == ".":
            if has_dot:
                return false  # Multiple dots
            has_dot = true
        elif not ch.is_numeric():
            return false

    # Must have at least one digit
    true

# Check if string is valid hexadecimal
fn is_hex(s: text) -> bool:
    if s.is_empty():
        return false

    var start = 0
    # Allow 0x prefix
    if s.starts_with("0x") or s.starts_with("0X"):
        start = 2
        if s.len() == 2:
            return false

    for i in start..s.len():
        val ch = s.chars()[i]
        if not is_hex_char(ch):
            return false

    true

fn is_hex_char(ch: text) -> bool:
    if ch.len() != 1:
        return false

    val c = ch.chars()[0]
    c.is_numeric() or
        c == "a" or c == "b" or c == "c" or c == "d" or c == "e" or c == "f" or
        c == "A" or c == "B" or c == "C" or c == "D" or c == "E" or c == "F"

# =====================================
# String Format Validation
# =====================================

# Check if string is valid identifier (letters, numbers, underscore)
# Must start with letter or underscore
fn is_identifier(s: text) -> bool:
    if s.is_empty():
        return false

    val chars = s.chars()
    val first = chars[0]

    # First char must be letter or underscore
    if not (first.is_alphabetic() or first == "_"):
        return false

    # Rest can be alphanumeric or underscore
    for ch in chars:
        if not (ch.is_alphanumeric() or ch == "_"):
            return false

    true

# Check if string contains only alphabetic characters
fn is_alpha(s: text) -> bool:
    if s.is_empty():
        return false

    for ch in s.chars():
        if not ch.is_alphabetic():
            return false

    true

# Check if string contains only alphanumeric characters
fn is_alphanumeric_str(s: text) -> bool:
    if s.is_empty():
        return false

    for ch in s.chars():
        if not ch.is_alphanumeric():
            return false

    true

# Check if string contains only digits
fn is_digits(s: text) -> bool:
    if s.is_empty():
        return false

    for ch in s.chars():
        if not ch.is_numeric():
            return false

    true

# Check if string is valid UUID format (8-4-4-4-12)
fn is_uuid(s: text) -> bool:
    if s.len() != 36:
        return false

    # Check positions of hyphens
    if s.chars()[8] != "-" or s.chars()[13] != "-" or
       s.chars()[18] != "-" or s.chars()[23] != "-":
        return false

    # Check hex digits in correct positions
    val sections = [
        (0, 8),    # 8 hex
        (9, 13),   # 4 hex
        (14, 18),  # 4 hex
        (19, 23),  # 4 hex
        (24, 36)   # 12 hex
    ]

    for (start, end) in sections:
        for i in start..end:
            if not is_hex_char(s.chars()[i]):
                return false

    true

# =====================================
# IP Address Validation
# =====================================

# Validate IPv4 address (e.g., 192.168.1.1)
fn is_ipv4(s: text) -> bool:
    val parts = s.split(".")
    if parts.len() != 4:
        return false

    for part in parts:
        # Must be numeric
        if not is_digits(part):
            return false

        # Parse number
        use super.parse_utils.parse_int
        match parse_int(part):
            Some(num) =>
                # Must be 0-255
                if num < 0 or num > 255:
                    return false
            None =>
                return false

    true

# =====================================
# Path Validation
# =====================================

# Check if path looks like absolute path
fn is_absolute_path(path: text) -> bool:
    if path.is_empty():
        return false

    # Unix absolute path
    if path.starts_with("/"):
        return true

    # Windows absolute path (C:\, D:\, etc.)
    if path.len() >= 3:
        val first = path.chars()[0]
        val second = path.chars()[1]
        val third = path.chars()[2]

        if first.is_alphabetic() and second == ":" and (third == "\\" or third == "/"):
            return true

    false

# Check if path is relative
fn is_relative_path(path: text) -> bool:
    not is_absolute_path(path)

# =====================================
# Length Validation
# =====================================

# Check if string length is within range
fn is_length_between(s: text, min_len: i32, max_len: i32) -> bool:
    val len = s.len()
    len >= min_len and len <= max_len

# Check if string is not empty
fn is_not_empty(s: text) -> bool:
    not s.is_empty()

# Check if string has minimum length
fn has_min_length(s: text, min_len: i32) -> bool:
    s.len() >= min_len

# Check if string has maximum length
fn has_max_length(s: text, max_len: i32) -> bool:
    s.len() <= max_len

# =====================================
# Content Validation
# =====================================

# Check if string contains only allowed characters
fn contains_only(s: text, allowed: text) -> bool:
    for ch in s.chars():
        if not allowed.contains(ch):
            return false

    true

# Check if string contains any forbidden characters
fn contains_none(s: text, forbidden: text) -> bool:
    for ch in s.chars():
        if forbidden.contains(ch):
            return false

    true

# Check if string matches pattern (simplified without regex)
# Pattern: only supports * wildcard for "any characters"
fn simple_match(s: text, pattern: text) -> bool:
    if pattern.is_empty():
        return s.is_empty()

    if not pattern.contains("*"):
        # No wildcard, must match exactly
        return s == pattern

    # Split by * and check each part
    val parts = pattern.split("*")
    var remaining = s

    for i in 0..parts.len():
        val part = parts[i]

        if part.is_empty():
            continue

        if i == 0:
            # First part must match start
            if not remaining.starts_with(part):
                return false
            remaining = remaining.substring(part.len(), remaining.len())
        elif i == parts.len() - 1:
            # Last part must match end
            if not remaining.ends_with(part):
                return false
        else:
            # Middle part must be found
            match remaining.find(part):
                Some(idx) =>
                    remaining = remaining.substring(idx + part.len(), remaining.len())
                None =>
                    return false

    true

# =====================================
# Common Validation Combinators
# =====================================

# Validate using multiple validators (all must pass)
fn validate_all(s: text, validators: List<fn(text) -> bool>) -> bool:
    for validator in validators:
        if not validator(s):
            return false

    true

# Validate using multiple validators (at least one must pass)
fn validate_any(s: text, validators: List<fn(text) -> bool>) -> bool:
    for validator in validators:
        if validator(s):
            return true

    false

# Validate with custom error message
struct ValidationResult:
    valid: bool
    error: text

impl ValidationResult:
    static fn ok() -> ValidationResult:
        ValidationResult(valid: true, error: "")

    static fn err(message: text) -> ValidationResult:
        ValidationResult(valid: false, error: message)

# Validate string with custom message
fn validate(s: text, validator: fn(text) -> bool, error_message: text) -> ValidationResult:
    if validator(s):
        ValidationResult.ok()
    else:
        ValidationResult.err(error_message)
