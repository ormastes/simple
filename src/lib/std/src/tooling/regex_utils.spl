# Regular Expression Utilities
#
# Provides pattern matching and text manipulation using regular expressions.
# This module wraps Rust's regex crate with a Simple-friendly API.
#
# Common use cases:
# - Pattern matching and validation
# - Text extraction and capture groups
# - Search and replace operations
# - Text splitting by patterns

# ============================================================================
# FFI Declarations
# ============================================================================

# Core regex operations
extern fn ffi_regex_is_match(pattern: text, text: text) -> bool
extern fn ffi_regex_find(pattern: text, text: text) -> [text]  # [text, start, end] or []
extern fn ffi_regex_find_all(pattern: text, text: text) -> [[text]]  # [[text, start, end], ...]
extern fn ffi_regex_captures(pattern: text, text: text) -> [text]  # [full_match, group1, ...] or []

# Replacement and splitting
extern fn ffi_regex_replace(pattern: text, text: text, replacement: text) -> text
extern fn ffi_regex_replace_all(pattern: text, text: text, replacement: text) -> text
extern fn ffi_regex_split(pattern: text, text: text) -> [text]
extern fn ffi_regex_split_n(pattern: text, text: text, limit: i64) -> [text]

# ============================================================================
# Core Types
# ============================================================================

# Represents a single match in text
struct Match:
    text: text          # The matched text
    start: i64          # Start byte position
    end: i64            # End byte position

# Represents captured groups from a regex match
struct Captures:
    full_match: text           # The entire matched text (group 0)
    groups: [Option<text>]     # Captured groups (group 1, 2, ...)

# ============================================================================
# Pattern Matching
# ============================================================================

# Check if pattern matches anywhere in text
#
# Example:
#   regex_is_match(r"\d+", "Hello 123")  # => true
#   regex_is_match(r"^\d+$", "Hello 123")  # => false
fn regex_is_match(pattern: text, text: text) -> bool:
    ffi_regex_is_match(pattern=pattern, text=text)

# ============================================================================
# Finding Matches
# ============================================================================

# Find first match of pattern in text
#
# Example:
#   regex_find(r"\d+", "Price: $42.99")  # => Some(Match { text: "42", ... })
fn regex_find(pattern: text, text: text) -> Option<Match>:
    val result = ffi_regex_find(pattern=pattern, text=text)

    # Empty array means no match
    if result.len() == 0:
        return None

    # Array contains [text, start, end]
    if result.len() >= 3:
        return Some(Match {
            text: result[0],
            start: result[1],
            end: result[2]
        })

    None

# Find all matches of pattern in text
#
# Example:
#   regex_find_all(r"\d+", "12 apples, 34 oranges")
#   # => [Match{text: "12", ...}, Match{text: "34", ...}]
fn regex_find_all(pattern: text, text: text) -> [Match]:
    val results = ffi_regex_find_all(pattern=pattern, text=text)
    var matches: [Match] = []

    for match_data in results:
        if match_data.len() >= 3:
            matches.push(Match {
                text: match_data[0],
                start: match_data[1],
                end: match_data[2]
            })

    matches

# ============================================================================
# Capture Groups
# ============================================================================

# Capture groups from first match
#
# Example:
#   val caps = regex_captures(r"(\d{3})-(\d{3})-(\d{4})", "Call 555-123-4567")
#   caps.groups[0]  # => Some("555")
#   caps.groups[1]  # => Some("123")
#   caps.groups[2]  # => Some("4567")
fn regex_captures(pattern: text, text: text) -> Option<Captures>:
    val result = ffi_regex_captures(pattern=pattern, text=text)

    # Empty array means no match
    if result.len() == 0:
        return None

    # First element is full match, rest are groups
    val full_match = result[0]
    var groups: [Option<text>] = []

    # Collect capture groups (skip full match at index 0)
    for i in 1..result.len():
        val group_str = result[i]
        # Empty string means group didn't match
        if group_str == "":
            groups.push(None)
        else:
            groups.push(Some(group_str))

    Some(Captures {
        full_match: full_match,
        groups: groups
    })

# ============================================================================
# Search and Replace
# ============================================================================

# Replace first match of pattern in text
#
# Example:
#   regex_replace(r"\d+", "I have 5 apples", "many")
#   # => "I have many apples"
fn regex_replace(pattern: text, text: text, replacement: text) -> text:
    ffi_regex_replace(pattern=pattern, text=text, replacement=replacement)

# Replace all matches of pattern in text
#
# Example:
#   regex_replace_all(r"\d+", "I have 5 apples and 3 oranges", "X")
#   # => "I have X apples and X oranges"
fn regex_replace_all(pattern: text, text: text, replacement: text) -> text:
    ffi_regex_replace_all(pattern=pattern, text=text, replacement=replacement)

# ============================================================================
# Text Splitting
# ============================================================================

# Split text by pattern
#
# Example:
#   regex_split(r"\s+", "one  two   three")
#   # => ["one", "two", "three"]
fn regex_split(pattern: text, text: text) -> [text]:
    ffi_regex_split(pattern=pattern, text=text)

# Split text by pattern with limit
#
# Example:
#   regex_split_n(r"\s+", "one two three four", 2)
#   # => ["one", "two three four"]
fn regex_split_n(pattern: text, text: text, limit: i64) -> [text]:
    ffi_regex_split_n(pattern=pattern, text=text, limit=limit)

# ============================================================================
# Common Validation Patterns
# ============================================================================

# Check if text is a valid email address
#
# Example:
#   is_valid_email("user@example.com")  # => true
#   is_valid_email("not-an-email")  # => false
fn is_valid_email(email: text) -> bool:
    regex_is_match(pattern=r"^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$", text=email)

# Check if text is a valid URL
#
# Example:
#   is_valid_url("https://example.com")  # => true
#   is_valid_url("not a url")  # => false
fn is_valid_url(url: text) -> bool:
    regex_is_match(pattern=r"^https?://[a-zA-Z0-9.-]+(\:[0-9]+)?(/.*)?$", text=url)

# Check if text is a valid IPv4 address
#
# Example:
#   is_valid_ipv4("192.168.1.1")  # => true
#   is_valid_ipv4("256.1.1.1")  # => false
fn is_valid_ipv4(ip: text) -> bool:
    regex_is_match(pattern=r"^((25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$", text=ip)

# Check if text is a valid US phone number
#
# Example:
#   is_valid_phone_us("555-123-4567")  # => true
#   is_valid_phone_us("123")  # => false
fn is_valid_phone_us(phone: text) -> bool:
    # Matches: 555-123-4567, (555) 123-4567, 555.123.4567, 5551234567
    regex_is_match(pattern=r"^(\+1[-.\s]?)?\(?([0-9]{3})\)?[-.\s]?([0-9]{3})[-.\s]?([0-9]{4})$", text=phone)

# ============================================================================
# Extraction Utilities
# ============================================================================

# Extract all email addresses from text
#
# Example:
#   extract_emails("Contact alice@example.com or bob@test.org")
#   # => ["alice@example.com", "bob@test.org"]
fn extract_emails(text: text) -> [text]:
    val matches = regex_find_all(pattern=r"[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}", text=text)
    matches.map(\m: m.text)

# Extract all numbers from text
#
# Example:
#   extract_numbers("There are 42 apples and 17 oranges")
#   # => ["42", "17"]
fn extract_numbers(text: text) -> [text]:
    val matches = regex_find_all(pattern=r"\d+", text=text)
    matches.map(\m: m.text)

# Extract all URLs from text
#
# Example:
#   extract_urls("Visit https://example.com or http://test.org")
#   # => ["https://example.com", "http://test.org"]
fn extract_urls(text: text) -> [text]:
    val matches = regex_find_all(pattern=r"https?://[a-zA-Z0-9.-]+(\:[0-9]+)?(/[^\s]*)?", text=text)
    matches.map(\m: m.text)

# Extract all words from text (sequences of alphanumeric characters)
#
# Example:
#   extract_words("Hello, world! How are you?")
#   # => ["Hello", "world", "How", "are", "you"]
fn extract_words(text: text) -> [text]:
    val matches = regex_find_all(pattern=r"\w+", text=text)
    matches.map(\m: m.text)

# ============================================================================
# Exports
# ============================================================================

pub use Match, Captures
pub use regex_is_match, regex_find, regex_find_all
pub use regex_captures, regex_replace, regex_replace_all, regex_split, regex_split_n
pub use is_valid_email, is_valid_url, is_valid_ipv4, is_valid_phone_us
pub use extract_emails, extract_numbers, extract_urls, extract_words
