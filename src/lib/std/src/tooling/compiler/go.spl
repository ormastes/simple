# Go Compiler Adapter
# Wrapper around go build/test/fmt

use tooling.core.project.{Language, LanguageConfig}
use tooling.compiler.compiler_interface.{LanguageCompiler, CompilationMode, CompilationResult}
use core.result.{Result, Ok, Err}

# FFI for process execution
@extern("runtime", "rt_process_run")
fn _rt_process_run(cmd_ptr: &u8, cmd_len: u64, args_ptr: &u8, args_len: u64) -> (i32, text, text)

# Go compiler adapter
pub class GoCompiler:
    pub language: Language

    pub fn new(): GoCompiler:
        """Create Go compiler.

        Returns:
            Compiler instance
        """
        GoCompiler {
            language: Language.Go
        }

    pub fn get_language(self): Language:
        """Get language type.

        Returns:
            Language.Go
        """
        self.language

    pub fn get_tool_name(self): text:
        """Get build tool name.

        Returns:
            "go"
        """
        "go"

    pub fn get_commands(self): List<text>:
        """Get available Go commands.

        Returns:
            List of Go commands

        Example:
            compiler.get_commands()
            # â†’ ["build", "test", "vet", "fmt", "mod"]
        """
        ["build", "test", "vet", "fmt", "mod"]

    pub fn compile(
        self,
        config: LanguageConfig,
        mode: CompilationMode,
        incremental: bool
    ): CompilationResult:
        """Compile Go project.

        Uses 'go build' command.

        Args:
            config: Language configuration
            mode: Debug or Release
            incremental: Use incremental compilation (Go always incremental)

        Returns:
            Compilation result
        """
        start_time = time.now()

        # Determine build command
        build_cmd = self.get_build_command(mode, config)

        # Execute go build command
        val cmd = "go"
        val args = build_cmd.substring(3, build_cmd.len())  # Remove "go " prefix
        val (exit_code, stdout, stderr) = _rt_process_run(cmd.ptr(), cmd.len(), args.ptr(), args.len())

        # Parse errors and warnings from output
        var errors: List<text> = []
        var warnings: List<text> = []
        for line in stderr.lines():
            if line.contains("error:"):
                errors.append(line)
            elif line.contains("warning:"):
                warnings.append(line)

        CompilationResult {
            status: if exit_code == 0 { "success" } else { "failed" },
            output_path: config.output_dir + "/" + config.name,
            duration_ms: time.now() - start_time,
            errors: errors,
            warnings: warnings
        }

    fn get_build_command(mode: CompilationMode, config: LanguageConfig): text:
        """Get go build command.

        Args:
            mode: Compilation mode
            config: Language configuration

        Returns:
            Build command string
        """
        # Base command
        cmd = "go build"

        # Add output flag
        cmd = cmd + " -o {config.output_dir}/{config.name}"

        # Add mode-specific flags
        cmd = match mode:
            CompilationMode.Debug ->
                # Debug: include debug symbols
                cmd + " -gcflags='all=-N -l'"
            CompilationMode.Release ->
                # Release: optimize and strip symbols
                cmd + " -ldflags='-s -w' -trimpath"

        cmd

    pub fn supports_incremental(self): bool:
        """Check if incremental compilation is supported.

        Go always uses incremental compilation via its build cache.

        Returns:
            Always true for Go
        """
        true

    pub fn get_default_output_dir(self): text:
        """Get default output directory.

        Returns:
            Default output path
        """
        "bin"

    pub fn run_tests(self, config: LanguageConfig): CompilationResult:
        """Run Go tests using 'go test'.

        Args:
            config: Language configuration

        Returns:
            Test result
        """
        start_time = time.now()

        # Execute go test command
        val cmd = "go"
        val args = "test ./..."
        val (exit_code, stdout, stderr) = _rt_process_run(cmd.ptr(), cmd.len(), args.ptr(), args.len())

        var errors: List<text> = []
        var warnings: List<text> = []
        for line in stderr.lines():
            if line.contains("FAIL"):
                errors.append(line)

        CompilationResult {
            status: if exit_code == 0 { "success" } else { "failed" },
            output_path: "",
            duration_ms: time.now() - start_time,
            errors: errors,
            warnings: warnings
        }

    pub fn vet(self, config: LanguageConfig): List<text>:
        """Run 'go vet' for code analysis.

        Args:
            config: Language configuration

        Returns:
            List of vet warnings
        """
        # Execute go vet command
        val cmd = "go"
        val args = "vet ./..."
        val (exit_code, stdout, stderr) = _rt_process_run(cmd.ptr(), cmd.len(), args.ptr(), args.len())

        var warnings: List<text> = []
        for line in stderr.lines():
            warnings.append(line)
        warnings

    pub fn format(self, config: LanguageConfig): bool:
        """Format code using 'go fmt'.

        Args:
            config: Language configuration

        Returns:
            True if successful
        """
        # Execute go fmt command
        val cmd = "go"
        val args = "fmt ./..."
        val (exit_code, stdout, stderr) = _rt_process_run(cmd.ptr(), cmd.len(), args.ptr(), args.len())

        exit_code == 0

    pub fn mod_tidy(self, config: LanguageConfig): bool:
        """Run 'go mod tidy' to clean dependencies.

        Args:
            config: Language configuration

        Returns:
            True if successful
        """
        # Execute go mod tidy command
        val cmd = "go"
        val args = "mod tidy"
        val (exit_code, stdout, stderr) = _rt_process_run(cmd.ptr(), cmd.len(), args.ptr(), args.len())

        exit_code == 0

# Trait implementation
impl LanguageCompiler for GoCompiler:
    fn compile(config: LanguageConfig, mode: CompilationMode, incremental: bool): CompilationResult:
        self.compile(config, mode, incremental)

    fn supports_incremental(): bool:
        self.supports_incremental()

    fn get_default_output_dir(): text:
        self.get_default_output_dir()
