//! Error construction utilities for extern functions
//!
//! This module provides standardized error constructors to maintain
//! consistent error messages across extern function implementations.
//!
//! Lean-friendly: Pure string construction with deterministic output.

/// Error code constants (match Rust error codes)
enum ErrorCode:
    InvalidOperation
    UndefinedFunction
    ArgumentCountMismatch
    TypeMismatch
    RuntimeError

impl ErrorCode:
    fn to_string() -> text:
        match self:
            ErrorCode.InvalidOperation:
                "INVALID_OPERATION"
            ErrorCode.UndefinedFunction:
                "UNDEFINED_FUNCTION"
            ErrorCode.ArgumentCountMismatch:
                "ARGUMENT_COUNT_MISMATCH"
            ErrorCode.TypeMismatch:
                "TYPE_MISMATCH"
            ErrorCode.RuntimeError:
                "RUNTIME_ERROR"

/// Error context for diagnostics
struct ErrorContext:
    code: ErrorCode
    help: text

impl ErrorContext:
    static fn new() -> ErrorContext:
        ErrorContext(
            code: ErrorCode.RuntimeError,
            help: ""
        )

    fn with_code(code: ErrorCode) -> ErrorContext:
        ErrorContext(code: code, help: self.help)

    fn with_help(help_text: text) -> ErrorContext:
        ErrorContext(code: self.code, help: help_text)

/// Compile error representation
struct CompileError:
    message: text
    context: ErrorContext

impl CompileError:
    static fn semantic_with_context(msg: text, ctx: ErrorContext) -> CompileError:
        CompileError(message: msg, context: ctx)

    static fn runtime(msg: text) -> CompileError:
        val ctx = ErrorContext(
            code: ErrorCode.RuntimeError,
            help: ""
        )
        CompileError(message: msg, context: ctx)

    fn to_string() -> text:
        "[{self.context.code.to_string()}] {self.message}"

    fn with_help() -> text:
        if self.context.help.len() > 0:
            "{self.to_string()}\nHelp: {self.context.help}"
        else:
            self.to_string()

/// Create a semantic error with a formatted message
///
/// # Example
/// ```simple
/// val err = semantic_error("invalid operation on list")
/// ```
fn semantic_error(msg: text) -> CompileError:
    val ctx = ErrorContext.new()
        .with_code(ErrorCode.InvalidOperation)
        .with_help("check the operation arguments and types")
    CompileError.semantic_with_context(msg, ctx)

/// Create an error for unknown extern function
///
/// # Example
/// ```simple
/// val err = unknown_function("rt_foo_bar")
/// # => "unknown extern function: rt_foo_bar"
/// ```
fn unknown_function(name: text) -> CompileError:
    val ctx = ErrorContext.new()
        .with_code(ErrorCode.UndefinedFunction)
        .with_help("check that the extern function name is spelled correctly")
    val msg = "unknown extern function: {name}"
    CompileError.semantic_with_context(msg, ctx)

/// Create an error for wrong argument count
///
/// # Example
/// ```simple
/// val err = wrong_arg_count("add", 2, 3)
/// # => "add expects 2 argument(s), got 3"
/// ```
fn wrong_arg_count(func_name: text, expected: u32, got: u32) -> CompileError:
    val ctx = ErrorContext.new()
        .with_code(ErrorCode.ArgumentCountMismatch)
        .with_help("{expected} argument(s) required")
    val msg = "{func_name} expects {expected} argument(s), got {got}"
    CompileError.semantic_with_context(msg, ctx)

/// Create an error for wrong argument type
///
/// # Example
/// ```simple
/// val err = wrong_arg_type("concat", 1, "string")
/// # => "concat expects string argument at position 1"
/// ```
fn wrong_arg_type(func_name: text, position: u32, expected: text) -> CompileError:
    val ctx = ErrorContext.new()
        .with_code(ErrorCode.TypeMismatch)
        .with_help("argument at position {position} should be of type {expected}")
    val msg = "{func_name} expects {expected} argument at position {position}"
    CompileError.semantic_with_context(msg, ctx)

/// Create an error for deprecated function
///
/// # Example
/// ```simple
/// val err = deprecated_function("old_api", "new_api", "Performance improvements")
/// # => "'old_api' is deprecated. Use 'new_api' instead. Performance improvements"
/// ```
fn deprecated_function(old_name: text, new_name: text, reason: text) -> CompileError:
    val msg = "'{old_name}' is deprecated. Use '{new_name}' instead. {reason}"
    CompileError.runtime(msg)

/// Create a runtime error
///
/// # Example
/// ```simple
/// val err = runtime_error("division by zero")
/// ```
fn runtime_error(msg: text) -> CompileError:
    CompileError.runtime(msg)
