//! Pattern matching utilities
//!
//! Core pattern matching logic for the Simple interpreter.
//! This module implements pattern binding and matching semantics
//! that can be formally verified in Lean.
//!
//! Lean-friendly: Pure pattern matching logic with exhaustive cases

/// Pattern types used in Simple language
enum Pattern:
    Wildcard
    Identifier(name: text)
    MutIdentifier(name: text)
    MoveIdentifier(name: text)
    Literal(value: text)
    Tuple(patterns: List<Pattern>)
    Array(patterns: List<Pattern>)
    Typed(pattern: Pattern, type_name: text)
    EnumVariant(enum_name: text, variant: text, fields: List<Pattern>)
    StructPattern(struct_name: text, fields: List<(text, Pattern)>)

impl Pattern:
    fn to_string() -> text:
        match self:
            Pattern.Wildcard:
                "_"
            Pattern.Identifier(name):
                name
            Pattern.MutIdentifier(name):
                "mut {name}"
            Pattern.MoveIdentifier(name):
                "move {name}"
            Pattern.Literal(value):
                value
            Pattern.Tuple(patterns):
                val inner = patterns.map(\p: p.to_string()).join(", ")
                "({inner})"
            Pattern.Array(patterns):
                val inner = patterns.map(\p: p.to_string()).join(", ")
                "[{inner}]"
            Pattern.Typed(pattern, type_name):
                "{pattern.to_string()}: {type_name}"
            Pattern.EnumVariant(enum_name, variant, fields):
                "{enum_name}.{variant}"
            Pattern.StructPattern(struct_name, fields):
                struct_name

    /// Check if pattern is exhaustive (covers all cases)
    fn is_exhaustive() -> bool:
        match self:
            Pattern.Wildcard:
                true
            Pattern.Identifier(_):
                true
            Pattern.MutIdentifier(_):
                true
            Pattern.MoveIdentifier(_):
                true
            _:
                false

    /// Check if pattern binds any variables
    fn binds_variables() -> bool:
        match self:
            Pattern.Wildcard:
                false
            Pattern.Identifier(_):
                true
            Pattern.MutIdentifier(_):
                true
            Pattern.MoveIdentifier(_):
                true
            Pattern.Literal(_):
                false
            Pattern.Tuple(patterns):
                patterns.any(\p: p.binds_variables())
            Pattern.Array(patterns):
                patterns.any(\p: p.binds_variables())
            Pattern.Typed(pattern, _):
                pattern.binds_variables()
            Pattern.EnumVariant(_, _, fields):
                fields.any(\p: p.binds_variables())
            Pattern.StructPattern(_, fields):
                fields.any(\(_, p): p.binds_variables())

    /// Get all variable names bound by this pattern
    fn bound_names() -> List<text>:
        match self:
            Pattern.Wildcard:
                []
            Pattern.Identifier(name):
                [name]
            Pattern.MutIdentifier(name):
                [name]
            Pattern.MoveIdentifier(name):
                [name]
            Pattern.Literal(_):
                []
            Pattern.Tuple(patterns):
                patterns.flat_map(\p: p.bound_names())
            Pattern.Array(patterns):
                patterns.flat_map(\p: p.bound_names())
            Pattern.Typed(pattern, _):
                pattern.bound_names()
            Pattern.EnumVariant(_, _, fields):
                fields.flat_map(\p: p.bound_names())
            Pattern.StructPattern(_, fields):
                fields.flat_map(\(_, p): p.bound_names())

/// Pattern match result
enum MatchResult:
    Success(bindings: List<(text, text)>)
    Failure(reason: text)

impl MatchResult:
    fn is_success() -> bool:
        match self:
            MatchResult.Success(_):
                true
            MatchResult.Failure(_):
                false

    fn bindings() -> List<(text, text)>:
        match self:
            MatchResult.Success(bindings):
                bindings
            MatchResult.Failure(_):
                []

/// Mutating method names for arrays
val ARRAY_MUTATING_METHODS = [
    "append",
    "push",
    "pop",
    "insert",
    "remove",
    "reverse",
    "concat",
    "extend",
    "sort",
    "sort_desc",
    "clear"
]

/// Mutating method names for dictionaries
val DICT_MUTATING_METHODS = [
    "set",
    "insert",
    "remove",
    "delete",
    "merge",
    "extend",
    "clear"
]

/// Check if method name is mutating for arrays
fn is_array_mutating_method(method: text) -> bool:
    ARRAY_MUTATING_METHODS.contains(method)

/// Check if method name is mutating for dictionaries
fn is_dict_mutating_method(method: text) -> bool:
    DICT_MUTATING_METHODS.contains(method)

/// Check if method name is mutating for any collection type
fn is_mutating_method(method: text, collection_type: text) -> bool:
    if collection_type == "Array":
        is_array_mutating_method(method)
    else if collection_type == "Dict":
        is_dict_mutating_method(method)
    else:
        false

/// Pattern complexity metric (for exhaustiveness checking)
fn pattern_complexity(pattern: Pattern) -> u32:
    match pattern:
        Pattern.Wildcard:
            1
        Pattern.Identifier(_):
            1
        Pattern.MutIdentifier(_):
            1
        Pattern.MoveIdentifier(_):
            1
        Pattern.Literal(_):
            1
        Pattern.Tuple(patterns):
            1 + patterns.map(\p: pattern_complexity(p)).sum()
        Pattern.Array(patterns):
            1 + patterns.map(\p: pattern_complexity(p)).sum()
        Pattern.Typed(pattern, _):
            1 + pattern_complexity(pattern)
        Pattern.EnumVariant(_, _, fields):
            1 + fields.map(\p: pattern_complexity(p)).sum()
        Pattern.StructPattern(_, fields):
            1 + fields.map(\(_, p): pattern_complexity(p)).sum()

/// Check if two patterns overlap (for exhaustiveness checking)
///
/// Two patterns overlap if there exists a value that matches both.
/// This is a conservative approximation used for exhaustiveness analysis.
fn patterns_overlap(p1: Pattern, p2: Pattern) -> bool:
    match (p1, p2):
        (Pattern.Wildcard, _):
            true
        (_, Pattern.Wildcard):
            true
        (Pattern.Identifier(_), _):
            true
        (_, Pattern.Identifier(_)):
            true
        (Pattern.MutIdentifier(_), _):
            true
        (_, Pattern.MutIdentifier(_)):
            true
        (Pattern.Literal(v1), Pattern.Literal(v2)):
            v1 == v2
        (Pattern.Tuple(patterns1), Pattern.Tuple(patterns2)):
            if patterns1.len() != patterns2.len():
                false
            else:
                patterns1.zip(patterns2).all(\(a, b): patterns_overlap(a, b))
        (Pattern.Array(patterns1), Pattern.Array(patterns2)):
            if patterns1.len() != patterns2.len():
                false
            else:
                patterns1.zip(patterns2).all(\(a, b): patterns_overlap(a, b))
        (Pattern.Typed(p1, t1), Pattern.Typed(p2, t2)):
            t1 == t2 and patterns_overlap(p1, p2)
        _:
            false

/// Check if a list of patterns is exhaustive
///
/// Patterns are exhaustive if they cover all possible values.
/// This is a simplified check that conservatively reports non-exhaustive
/// when uncertain.
fn are_patterns_exhaustive(patterns: List<Pattern>) -> bool:
    # If any pattern is a wildcard or identifier, it's exhaustive
    patterns.any(\p: p.is_exhaustive())

/// Find duplicate variable bindings in a pattern
///
/// Returns list of variable names that appear more than once.
/// Duplicate bindings are an error in pattern matching.
fn find_duplicate_bindings(pattern: Pattern) -> List<text>:
    val names = pattern.bound_names()
    var seen = []
    var duplicates = []

    for name in names:
        if seen.contains(name):
            if not duplicates.contains(name):
                duplicates.push(name)
        else:
            seen.push(name)

    duplicates

/// Validate pattern for common errors
///
/// Returns error message if pattern is invalid, None otherwise.
fn validate_pattern(pattern: Pattern) -> text?:
    # Check for duplicate bindings
    val duplicates = find_duplicate_bindings(pattern)
    if duplicates.len() > 0:
        val vars = duplicates.join(", ")
        return Some("Duplicate variable bindings: {vars}")

    # Check nested patterns
    match pattern:
        Pattern.Tuple(patterns):
            for p in patterns:
                match validate_pattern(p):
                    Some(err):
                        return Some(err)
                    None:
                        pass
        Pattern.Array(patterns):
            for p in patterns:
                match validate_pattern(p):
                    Some(err):
                        return Some(err)
                    None:
                        pass
        Pattern.Typed(inner, _):
            return validate_pattern(inner)
        _:
            pass

    None

/// Pattern matching statistics
struct PatternStats:
    total_patterns: u32
    wildcard_count: u32
    identifier_count: u32
    complex_count: u32
    max_depth: u32

impl PatternStats:
    static fn from_pattern(pattern: Pattern) -> PatternStats:
        PatternStats.analyze(pattern, 0)

    static fn analyze(pattern: Pattern, depth: u32) -> PatternStats:
        match pattern:
            Pattern.Wildcard:
                PatternStats(
                    total_patterns: 1,
                    wildcard_count: 1,
                    identifier_count: 0,
                    complex_count: 0,
                    max_depth: depth
                )
            Pattern.Identifier(_):
                PatternStats(
                    total_patterns: 1,
                    wildcard_count: 0,
                    identifier_count: 1,
                    complex_count: 0,
                    max_depth: depth
                )
            Pattern.Tuple(patterns):
                val stats_list = patterns.map(\p: PatternStats.analyze(p, depth + 1))
                PatternStats.combine_all(stats_list, 1, 0, 0, depth)
            Pattern.Array(patterns):
                val stats_list = patterns.map(\p: PatternStats.analyze(p, depth + 1))
                PatternStats.combine_all(stats_list, 1, 0, 0, depth)
            _:
                PatternStats(
                    total_patterns: 1,
                    wildcard_count: 0,
                    identifier_count: 0,
                    complex_count: 1,
                    max_depth: depth
                )

    static fn combine_all(
        stats_list: List<PatternStats>,
        base_total: u32,
        base_wildcard: u32,
        base_identifier: u32,
        base_depth: u32
    ) -> PatternStats:
        var total = base_total
        var wildcards = base_wildcard
        var identifiers = base_identifier
        var complex = 0
        var max_d = base_depth

        for stats in stats_list:
            total = total + stats.total_patterns
            wildcards = wildcards + stats.wildcard_count
            identifiers = identifiers + stats.identifier_count
            complex = complex + stats.complex_count
            max_d = if stats.max_depth > max_d: stats.max_depth else: max_d

        PatternStats(
            total_patterns: total,
            wildcard_count: wildcards,
            identifier_count: identifiers,
            complex_count: complex,
            max_depth: max_d
        )
