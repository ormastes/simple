# Simple Language Compiler Adapter
# Integrates Simple native compiler with tooling framework

use tooling.core.project.{Language, LanguageConfig}
use tooling.compiler.interface.{
    LanguageCompiler,
    CompilationMode,
    CompilationResult,
    Artifact,
    ArtifactType,
    CompilationError,
    ErrorSeverity
}

# Simple compiler adapter
pub class SimpleCompiler:
    pub compiler_path: text
    pub optimization_level: i32

    pub fn new(): SimpleCompiler =
        """Create Simple compiler adapter.

        Returns:
            Compiler with default settings

        Example:
            val compiler = SimpleCompiler.new()
            val result = compiler.compile(config, CompilationMode.Release, true)
        """
        SimpleCompiler {
            compiler_path: "simple",  # Use 'simple' from PATH
            optimization_level: 2
        }

    pub fn set_compiler_path(self, path: text):
        """Set path to Simple compiler binary.

        Args:
            path: Path to compiler
        """
        self.compiler_path = path

    pub fn set_optimization_level(self, level: i32):
        """Set optimization level (0-3).

        Args:
            level: Optimization level
        """
        self.optimization_level = level

    pub fn get_optimization_level(self): i32 =
        """Get current optimization level.

        Returns:
            Optimization level (0-3)
        """
        self.optimization_level

    pub fn get_build_command(self, mode: CompilationMode, incremental: bool): text =
        """Get build command for display.

        Args:
            mode: Compilation mode
            incremental: Incremental flag

        Returns:
            Command string

        Example:
            compiler.get_build_command(CompilationMode.Release, true)
            # → "simple build --release --opt=2 --incremental"
        """
        var cmd = "{self.compiler_path} build"

        match mode:
            CompilationMode.Debug:
                pass
            CompilationMode.Release:
                cmd += " --release"
            CompilationMode.Profile:
                cmd += " --profile"

        if self.optimization_level > 0:
            cmd += " --opt={self.optimization_level}"

        if incremental:
            cmd += " --incremental"

        cmd

impl LanguageCompiler for SimpleCompiler:
    fn compile(config: LanguageConfig,
        mode: CompilationMode,
        incremental: bool
    ): CompilationResult =
        """Compile Simple code.

        Args:
            config: Language configuration
            mode: Compilation mode (Debug/Release/Profile)
            incremental: Enable incremental compilation

        Returns:
            Compilation result with artifacts or errors
        """
        @extern("runtime", "rt_time_now_unix_micros")
        fn _rt_time_now_unix_micros() -> i64

        val result = CompilationResult.new()
        val start_time = _rt_time_now_unix_micros() / 1000  # Convert microseconds to milliseconds

        # Build compiler command
        var args: List<text> = []
        args.append("build")

        # Add mode flag
        match mode:
            CompilationMode.Debug:
                pass  # Default
            CompilationMode.Release:
                args.append("--release")
            CompilationMode.Profile:
                args.append("--profile")

        # Add optimization level
        if self.optimization_level > 0:
            args.append("--opt={self.optimization_level}")

        # Add incremental flag
        if incremental:
            args.append("--incremental")

        # Add source directory
        args.append(config.root)

        # Execute compiler using shell.run()
        val output = self.execute_compiler(args)

        # Parse compiler output
        if output.exit_code == 0:
            # Success - add artifacts
            val executable_path = "{config.root}/target/app"
            val artifact = Artifact.new(
                executable_path,
                ArtifactType.Executable,
                Language.Simple
            )
            result.add_artifact(artifact)
        else:
            # Failure - parse errors
            val errors = self.parse_errors(output.stderr)
            for error in errors:
                result.add_error(error)

        val end_time = _rt_time_now_unix_micros() / 1000  # Convert microseconds to milliseconds
        result.duration_ms = end_time - start_time

        result

    fn get_language(): Language =
        """Get language type.

        Returns:
            Language.Simple
        """
        Language.Simple

    fn supports_incremental(): bool =
        """Check if incremental compilation is supported.

        Returns:
            True (Simple supports incremental builds)
        """
        true

    fn get_executable_extension(): text =
        """Get executable file extension.

        Returns:
            "" on Unix, ".exe" on Windows
        """
        @extern("runtime", "rt_platform_name")
        fn _rt_platform_name() -> text

        val platform = _rt_platform_name()
        if platform == "windows":
            ".exe"
        else:
            ""

    fn get_library_extension(): text =
        """Get library file extension.

        Returns:
            ".so" on Linux, ".dylib" on macOS, ".dll" on Windows
        """
        @extern("runtime", "rt_platform_name")
        fn _rt_platform_name() -> text

        val platform = _rt_platform_name()
        match platform:
            "windows": ".dll"
            "macos": ".dylib"
            _: ".so"

# Helper types for process execution
class ProcessOutput:
    pub exit_code: i32
    pub stdout: text
    pub stderr: text

    pub fn new(exit_code: i32, stdout: text, stderr: text): ProcessOutput =
        ProcessOutput {
            exit_code: exit_code,
            stdout: stdout,
            stderr: stderr
        }

    pub fn is_success(self): bool =
        """Check if process succeeded.

        Returns:
            True if exit code is 0
        """
        self.exit_code == 0

    pub fn is_failure(self): bool =
        """Check if process failed.

        Returns:
            True if exit code is non-zero
        """
        self.exit_code != 0

    pub fn has_stdout(self): bool =
        """Check if stdout is non-empty.

        Returns:
            True if stdout has content
        """
        not self.stdout.is_empty()

    pub fn has_stderr(self): bool =
        """Check if stderr is non-empty.

        Returns:
            True if stderr has content
        """
        not self.stderr.is_empty()

    pub fn summary(self): text =
        """Get process output summary.

        Returns:
            Human-readable summary

        Example:
            output.summary()
            # → "Exit code: 0, stdout: 1234 bytes, stderr: 0 bytes"
        """
        "Exit code: {self.exit_code}, stdout: {self.stdout.len()} bytes, stderr: {self.stderr.len()} bytes"

# Helper methods
impl SimpleCompiler:
    fn execute_compiler(args: List<text>): ProcessOutput =
        """Execute Simple compiler.

        Args:
            args: Compiler arguments

        Returns:
            Process output
        """
        import shell

        # Build full command with 'simple' as the executable
        val result = shell.run("simple", args)

        ProcessOutput.new(result.exit_code as i32, result.stdout, result.stderr)

    fn parse_errors(stderr: text): List<CompilationError> =
        """Parse compiler error output.

        Args:
            stderr: Compiler stderr output

        Returns:
            List of parsed errors

        Error format: file:line:column: severity: message
        Example: src/main.spl:10:5: error: undefined variable
        """
        val errors: List<CompilationError> = []

        val lines = stderr.split("\n")
        for line in lines:
            if line.trim().is_empty():
                continue

            # Parse error line
            val parts = line.split(":")
            if parts.len() >= 5:
                val file = parts[0].trim()
                val line_num = self.parse_int(parts[1].trim())
                val column = self.parse_int(parts[2].trim())
                val severity_str = parts[3].trim()
                val message = parts[4..].join(":").trim()

                val severity = match severity_str:
                    "error": ErrorSeverity.Error
                    "warning": ErrorSeverity.Warning
                    "info": ErrorSeverity.Info
                    _: ErrorSeverity.Error

                val error = CompilationError.new(
                    file: file,
                    line: line_num,
                    column: column,
                    message: message,
                    severity: severity,
                    language: Language.Simple
                )
                errors.append(error)

        errors

    fn parse_int(s: text): i32 =
        """Parse integer from string.

        Args:
            s: text to parse

        Returns:
            Parsed integer or 0
        """
        # Simple integer parsing implementation
        val trimmed = s.trim()
        if trimmed.is_empty():
            return 0

        var result: i32 = 0
        var negative = false
        var start_idx = 0

        # Check for sign
        if trimmed[0] == '-':
            negative = true
            start_idx = 1
        elif trimmed[0] == '+':
            start_idx = 1

        # Parse digits
        for i in start_idx..trimmed.len():
            val ch = trimmed[i]
            if ch >= '0' and ch <= '9':
                val digit = (ch as i32) - ('0' as i32)
                result = result * 10 + digit
            else:
                # Invalid character, return what we have so far
                break

        if negative:
            return -result
        else:
            return result
