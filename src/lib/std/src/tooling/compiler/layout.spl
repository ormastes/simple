# Memory Layout Utilities for Struct Types
#
# Provides zero-cost field access through compile-time offset computation.
# Layout follows C ABI rules for compatibility with FFI and codegen.
#
# Key features:
# - C ABI alignment and padding rules
# - Vtable pointer support (at offset 0)
# - Field offset computation (O(1) by index, O(n) by name)
# - Pure functional implementation (Lean-friendly)

# Type ID constants (matches TypeId in types_util.spl)
struct TypeId:
    id: i32

impl TypeId:
    static fn VOID() -> TypeId: TypeId(id: 0)
    static fn BOOL() -> TypeId: TypeId(id: 1)
    static fn I8() -> TypeId: TypeId(id: 2)
    static fn U8() -> TypeId: TypeId(id: 3)
    static fn I16() -> TypeId: TypeId(id: 4)
    static fn U16() -> TypeId: TypeId(id: 5)
    static fn I32() -> TypeId: TypeId(id: 6)
    static fn U32() -> TypeId: TypeId(id: 7)
    static fn I64() -> TypeId: TypeId(id: 8)
    static fn U64() -> TypeId: TypeId(id: 9)
    static fn F32() -> TypeId: TypeId(id: 10)
    static fn F64() -> TypeId: TypeId(id: 11)
    static fn STRING() -> TypeId: TypeId(id: 12)
    static fn NIL() -> TypeId: TypeId(id: 13)

    fn equals(other: TypeId) -> bool:
        self.id == other.id

# Field layout information
struct FieldLayout:
    name: text
    ty: TypeId
    offset: i32
    size: i32

# Struct layout with C ABI rules
struct StructLayout:
    name: text
    fields: [FieldLayout]
    size: i32
    alignment: i32
    has_vtable: bool
    type_id: i32

impl StructLayout:
    # Get size and alignment for a type (C ABI rules)
    static fn type_size_align(ty: TypeId) -> (i32, i32):
        val void_id = TypeId.VOID()
        val bool_id = TypeId.BOOL()
        val i8_id = TypeId.I8()
        val u8_id = TypeId.U8()
        val i16_id = TypeId.I16()
        val u16_id = TypeId.U16()
        val i32_id = TypeId.I32()
        val u32_id = TypeId.U32()
        val i64_id = TypeId.I64()
        val u64_id = TypeId.U64()
        val f32_id = TypeId.F32()
        val f64_id = TypeId.F64()
        val string_id = TypeId.STRING()
        val nil_id = TypeId.NIL()

        if ty.equals(void_id):
            (0, 1)
        else if ty.equals(bool_id):
            (1, 1)
        else if ty.equals(i8_id) or ty.equals(u8_id):
            (1, 1)
        else if ty.equals(i16_id) or ty.equals(u16_id):
            (2, 2)
        else if ty.equals(i32_id) or ty.equals(u32_id):
            (4, 4)
        else if ty.equals(i64_id) or ty.equals(u64_id):
            (8, 8)
        else if ty.equals(f32_id):
            (4, 4)
        else if ty.equals(f64_id):
            (8, 8)
        else if ty.equals(string_id):
            (8, 8)
        else if ty.equals(nil_id):
            (8, 8)
        else:
            (8, 8)

    # Compute padding needed for alignment
    static fn compute_padding(current_offset: i32, alignment: i32) -> i32:
        val remainder = current_offset % alignment
        if remainder == 0:
            0
        else:
            alignment - remainder

    # Create struct layout with computed offsets
    static fn new(
        name: text,
        fields: [(text, TypeId)],
        has_vtable: bool,
        type_id: i32
    ) -> StructLayout:
        var field_layouts: [FieldLayout] = []
        var current_offset = if has_vtable: 8 else: 0
        var max_align = if has_vtable: 8 else: 1

        for field in fields:
            val field_name = field.0
            val field_ty = field.1
            val (size, align) = StructLayout.type_size_align(field_ty)

            val padding = StructLayout.compute_padding(current_offset, align)
            current_offset = current_offset + padding

            field_layouts = field_layouts + [FieldLayout(
                name: field_name,
                ty: field_ty,
                offset: current_offset,
                size: size
            )]

            current_offset = current_offset + size
            if align > max_align:
                max_align = align

        val final_padding = StructLayout.compute_padding(current_offset, max_align)
        val total_size = current_offset + final_padding

        StructLayout(
            name: name,
            fields: field_layouts,
            size: total_size,
            alignment: max_align,
            has_vtable: has_vtable,
            type_id: type_id
        )

    # Get field offset by index (O(1))
    fn field_offset(index: i32) -> Option<i32>:
        if index >= 0 and index < self.fields.length():
            Some(self.fields[index].offset)
        else:
            None

    # Get field offset by name (O(n))
    fn field_offset_by_name(name: text) -> Option<i32>:
        for field in self.fields:
            if field.name == name:
                return Some(field.offset)
        None

    # Get field index by name (O(n))
    fn field_index(name: text) -> Option<i32>:
        var index = 0
        for field in self.fields:
            if field.name == name:
                return Some(index)
            index = index + 1
        None
