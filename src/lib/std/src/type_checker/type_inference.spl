# Type Inference Engine
# Core type checking and inference logic for Simple language
# This will be used to generate Lean4 verification proofs

use std.collections.{HashMap, HashSet, Vec}

# Type representation
enum Type:
    Int
    Bool
    Str
    Float
    Unit
    Var(id: i64)                    # Type variable for inference
    Function(params: Vec<Type>, ret: Type)
    Generic(name: str, args: Vec<Type>)
    DynTrait(trait_name: str)       # Dynamic trait object (Feature #2301)
    Tuple(elements: Vec<Type>)
    Array(element: Type)
    Optional(inner: Type)

impl Type:
    fn to_string() -> str:
        match self:
            Type.Int -> "Int"
            Type.Bool -> "Bool"
            Type.Str -> "Str"
            Type.Float -> "Float"
            Type.Unit -> "Unit"
            Type.Var(id) -> "T{id}"
            Type.Function(params, ret) ->
                val params_str = params.map(\p: p.to_string()).join(", ")
                "fn({params_str}) -> {ret.to_string()}"
            Type.Generic(name, args) ->
                if args.is_empty():
                    name
                else:
                    val args_str = args.map(\a: a.to_string()).join(", ")
                    "{name}<{args_str}>"
            Type.DynTrait(trait_name) ->
                "dyn {trait_name}"
            Type.Tuple(elements) ->
                val elems_str = elements.map(\e: e.to_string()).join(", ")
                "({elems_str})"
            Type.Array(element) ->
                "[{element.to_string()}]"
            Type.Optional(inner) ->
                "Option<{inner.to_string()}>"

# Type unification for Hindley-Milner inference
class TypeUnifier:
    substitution: HashMap<i64, Type>  # Type variable substitutions
    next_var: i64                      # Fresh type variable counter

impl TypeUnifier:
    static fn new() -> TypeUnifier:
        TypeUnifier(
            substitution: {},
            next_var: 0
        )

    me fresh_var() -> Type:
        """Generate a fresh type variable"""
        val var_id = self.next_var
        self.next_var = self.next_var + 1
        Type.Var(var_id)

    fn resolve(ty: Type) -> Type:
        """Follow substitution chain to get concrete type"""
        match ty:
            Type.Var(id) ->
                match self.substitution.get(id):
                    Some(substituted) -> self.resolve(substituted)
                    nil -> ty
            Type.Function(params, ret) ->
                Type.Function(
                    params.map(\p: self.resolve(p)),
                    self.resolve(ret)
                )
            Type.Generic(name, args) ->
                Type.Generic(name, args.map(\a: self.resolve(a)))
            Type.Tuple(elements) ->
                Type.Tuple(elements.map(\e: self.resolve(e)))
            Type.Array(element) ->
                Type.Array(self.resolve(element))
            Type.Optional(inner) ->
                Type.Optional(self.resolve(inner))
            _ -> ty

    me unify(t1: Type, t2: Type) -> Result<Unit, str>:
        """
        Unify two types, updating substitutions.

        Verification properties (will generate Lean theorems):
        - requires: t1 and t2 are well-formed types
        - ensures: unification is symmetric (unify(t1, t2) == unify(t2, t1))
        - ensures: unification is idempotent (unify(t, t) always succeeds)
        - ensures: occurs check prevents infinite types
        """
        val resolved_t1 = self.resolve(t1)
        val resolved_t2 = self.resolve(t2)

        # Same type - trivially unify
        if resolved_t1 == resolved_t2:
            return Ok(Unit)

        match (resolved_t1, resolved_t2):
            # Type variable unification
            (Type.Var(id1), Type.Var(id2)) ->
                if id1 == id2:
                    Ok(Unit)
                else:
                    self.substitution.insert(id1, Type.Var(id2))
                    Ok(Unit)

            (Type.Var(id), other) ->
                if self.occurs_check(id, other):
                    Err("Occurs check failed: infinite type")
                else:
                    self.substitution.insert(id, other)
                    Ok(Unit)

            (other, Type.Var(id)) ->
                if self.occurs_check(id, other):
                    Err("Occurs check failed: infinite type")
                else:
                    self.substitution.insert(id, other)
                    Ok(Unit)

            # DynTrait unification (Feature #2301)
            (Type.DynTrait(name1), Type.DynTrait(name2)) ->
                if name1 == name2:
                    Ok(Unit)
                else:
                    Err("Cannot unify dyn {name1} with dyn {name2}")

            # DynTrait vs concrete type - always fails
            (Type.DynTrait(name), _) ->
                Err("Cannot unify dyn {name} with concrete type")

            (_, Type.DynTrait(name)) ->
                Err("Cannot unify concrete type with dyn {name}")

            # Function unification
            (Type.Function(params1, ret1), Type.Function(params2, ret2)) ->
                if params1.len() != params2.len():
                    return Err("Function arity mismatch")

                # Unify all parameter types
                for (p1, p2) in params1.zip(params2):
                    self.unify(p1, p2)?

                # Unify return types
                self.unify(ret1, ret2)

            # Generic type unification
            (Type.Generic(name1, args1), Type.Generic(name2, args2)) ->
                if name1 != name2:
                    return Err("Cannot unify {name1} with {name2}")
                if args1.len() != args2.len():
                    return Err("Generic arity mismatch for {name1}")

                for (a1, a2) in args1.zip(args2):
                    self.unify(a1, a2)?
                Ok(Unit)

            # Tuple unification
            (Type.Tuple(elems1), Type.Tuple(elems2)) ->
                if elems1.len() != elems2.len():
                    return Err("Tuple arity mismatch")
                for (e1, e2) in elems1.zip(elems2):
                    self.unify(e1, e2)?
                Ok(Unit)

            # Array unification
            (Type.Array(elem1), Type.Array(elem2)) ->
                self.unify(elem1, elem2)

            # Optional unification
            (Type.Optional(inner1), Type.Optional(inner2)) ->
                self.unify(inner1, inner2)

            # Base type mismatch
            _ ->
                Err("Cannot unify {resolved_t1.to_string()} with {resolved_t2.to_string()}")

    fn occurs_check(var_id: i64, ty: Type) -> bool:
        """
        Check if type variable occurs in type (prevents infinite types).

        Verification property:
        - ensures: returns true iff var_id appears in ty's structure
        """
        match self.resolve(ty):
            Type.Var(id) -> id == var_id
            Type.Function(params, ret) ->
                params.any(\p: self.occurs_check(var_id, p)) or self.occurs_check(var_id, ret)
            Type.Generic(_, args) ->
                args.any(\a: self.occurs_check(var_id, a))
            Type.Tuple(elements) ->
                elements.any(\e: self.occurs_check(var_id, e))
            Type.Array(element) ->
                self.occurs_check(var_id, element)
            Type.Optional(inner) ->
                self.occurs_check(var_id, inner)
            _ -> false

# Mixin information for composition
class MixinInfo:
    name: str
    fields: Vec<(str, Type)>
    methods: Vec<str>
    required_traits: Vec<str>
    required_mixins: Vec<str>          # Transitive dependencies (Feature #2201)

impl MixinInfo:
    static fn new(name: str) -> MixinInfo:
        MixinInfo(
            name: name,
            fields: [],
            methods: [],
            required_traits: [],
            required_mixins: []
        )

# Transitive mixin resolver (Feature #2201)
class MixinResolver:
    mixins: HashMap<str, MixinInfo>

    static fn new() -> MixinResolver:
        MixinResolver(mixins: {})

    me register_mixin(info: MixinInfo):
        """Register a mixin definition"""
        self.mixins.insert(info.name.clone(), info)

    fn resolve_transitive(initial_names: Vec<str>) -> Vec<str>:
        """
        Resolve all transitive mixin dependencies via BFS.

        Verification properties (will generate Lean theorems):
        - requires: all mixin names in initial_names are registered
        - ensures: result contains all transitive dependencies
        - ensures: no duplicates in result (diamond deduplication)
        - ensures: result is topologically sorted (dependencies before dependents)
        - ensures: terminates for all inputs (no infinite loops)
        """
        var seen = {}
        var result = []
        var queue = initial_names.clone()

        while not queue.is_empty():
            val name = queue.pop_front().unwrap()

            # Skip if already processed (diamond deduplication)
            if seen.contains(name):
                continue

            seen.insert(name.clone())

            # Look up mixin definition
            match self.mixins.get(name):
                Some(mixin_info) ->
                    # Add to result
                    result.push(name.clone())

                    # Add transitive dependencies to queue
                    for dep in mixin_info.required_mixins:
                        if not seen.contains(dep):
                            queue.push(dep.clone())

                nil ->
                    # Non-existent mixin - skip (returns empty contribution)
                    pass

        result

    fn get_all_fields(type_name: str, mixin_names: Vec<str>) -> Vec<(str, Type)>:
        """
        Collect all fields from transitively resolved mixins.

        Verification properties:
        - requires: mixin_names is result of resolve_transitive()
        - ensures: no field name conflicts in result
        - ensures: all transitive mixin fields included
        """
        var all_fields = []
        var seen_fields = {}

        # Resolve transitive mixins
        val all_mixin_names = self.resolve_transitive(mixin_names)

        # Collect fields from all mixins
        for mixin_name in all_mixin_names:
            match self.mixins.get(mixin_name):
                Some(mixin_info) ->
                    for (field_name, field_type) in mixin_info.fields:
                        if not seen_fields.contains(field_name):
                            all_fields.push((field_name.clone(), field_type.clone()))
                            seen_fields.insert(field_name.clone())
                nil ->
                    pass

        all_fields

# Dispatch mode for trait method calls
enum DispatchMode:
    Static   # Monomorphized, direct call (when binding exists)
    Dynamic  # Vtable lookup (when no binding exists)

# Type checker with inference
class TypeChecker:
    unifier: TypeUnifier
    mixin_resolver: MixinResolver
    trait_impls: HashMap<str, Vec<Type>>      # Trait -> implementing types
    interface_bindings: HashMap<str, Type>    # Trait -> bound type (for static dispatch)
    env: HashMap<str, Type>                   # Variable -> type environment

    static fn new() -> TypeChecker:
        TypeChecker(
            unifier: TypeUnifier.new(),
            mixin_resolver: MixinResolver.new(),
            trait_impls: {},
            interface_bindings: {},
            env: {}
        )

    me fresh_var() -> Type:
        """Generate a fresh type variable for inference"""
        self.unifier.fresh_var()

    me unify(t1: Type, t2: Type) -> Result<Unit, str>:
        """Unify two types"""
        self.unifier.unify(t1, t2)

    fn resolve(ty: Type) -> Type:
        """Resolve a type through substitutions"""
        self.unifier.resolve(ty)

    fn resolve_trait_type(trait_name: str) -> Type:
        """
        Resolve a trait type through interface binding.
        If bound: returns the implementation type (for static dispatch)
        If not bound: returns DynTrait (for dynamic dispatch)

        Verification property:
        - ensures: result is either a bound concrete type or DynTrait
        """
        match self.interface_bindings.get(trait_name):
            Some(impl_type) -> impl_type.clone()
            None -> Type.DynTrait(trait_name.clone())

    fn get_dispatch_mode(trait_name: str) -> DispatchMode:
        """
        Determine dispatch mode for a trait.
        Static if binding exists, Dynamic otherwise.
        """
        if self.interface_bindings.contains_key(trait_name):
            DispatchMode.Static
        else:
            DispatchMode.Dynamic

    me register_mixin(info: MixinInfo):
        """Register a mixin for composition"""
        self.mixin_resolver.register_mixin(info)

    fn resolve_transitive_mixins(names: Vec<str>) -> Vec<str>:
        """Resolve transitive mixin dependencies"""
        self.mixin_resolver.resolve_transitive(names)

    fn get_mixin_fields(type_name: str, mixins: Vec<str>) -> Vec<(str, Type)>:
        """Get all fields from transitively resolved mixins"""
        self.mixin_resolver.get_all_fields(type_name, mixins)

    me bind_interface(trait_name: str, impl_type: Type):
        """Bind a trait interface to a concrete type for static dispatch"""
        self.interface_bindings.insert(trait_name, impl_type)

    me register_trait_impl(trait_name: str, impl_type: Type):
        """Register that a type implements a trait"""
        match self.trait_impls.get_mut(trait_name):
            Some(impls) -> impls.push(impl_type)
            None ->
                val impls = []
                impls.push(impl_type)
                self.trait_impls.insert(trait_name, impls)

    fn can_coerce_to_dyn_trait(concrete_ty: Type, trait_name: str) -> bool:
        """
        Check if a concrete type can be coerced to dyn Trait.

        Verification property:
        - requires: trait_name is a registered trait
        - ensures: true iff concrete_ty implements trait_name
        """
        match self.trait_impls.get(trait_name):
            Some(impls) -> impls.contains(concrete_ty)
            None -> false

# NOTE: Lean verification theorems are defined in verification/type_inference_compile/src/Classes.lean
# The lean{} syntax is not yet supported by the parser, so theorems are maintained separately.
#
# Verification theorems that correspond to this implementation:
# 1. unify_symmetric: Type unification is symmetric
# 2. unify_idempotent: Type unification is idempotent
# 3. transitive_resolution_terminates: Transitive mixin resolution terminates
# 4. diamond_dedup: Diamond deduplication works
# 5. dyntrait_unify: DynTrait only unifies with same trait
#
# See verification/type_inference_compile/src/Classes.lean for the actual Lean4 theorems.
