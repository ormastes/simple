# Typed Tensor - Tensor with compile-time dimension tracking (Simplified)
#
# Basic typed tensor support for shape tracking.

export TypedTensor, TensorType, DimSpec, MemoryReport

use device.{Device, device_code}
use dtype.{DType, dtype_code}


# ============================================================================
# Dimension Specification (Simplified)
# ============================================================================

class DimSpec:
    """Specification for a single dimension."""
    name: str
    sample: i64
    min_val: i64
    max_val: i64

    fn __init__(name: str, sample: i64, min_val: i64, max_val: i64):
        self.name = name
        self.sample = sample
        self.min_val = min_val
        self.max_val = max_val

    static fn exact(value: i64) -> DimSpec:
        """Create exact dimension (sample = min = max)."""
        return DimSpec("", value, value, value)

    static fn named(name: str, sample: i64) -> DimSpec:
        """Create named dimension with sample."""
        return DimSpec(name, sample, 0, 0)

    static fn ranged(name: str, sample: i64, min_val: i64, max_val: i64) -> DimSpec:
        """Create ranged dimension."""
        return DimSpec(name, sample, min_val, max_val)

    static fn dynamic() -> DimSpec:
        """Create dynamic dimension."""
        return DimSpec("", 1, 0, 0)


# ============================================================================
# Tensor Type (Simplified)
# ============================================================================

class TensorType:
    """Type specification for a tensor (shape + dtype)."""
    shape: [i64]
    dtype: DType

    fn __init__(shape: [i64], dtype: DType):
        self.shape = shape
        self.dtype = dtype

    fn ndim() -> i64:
        return self.shape.len() as i64


# ============================================================================
# Memory Report
# ============================================================================

class MemoryReport:
    """Memory estimation report for a tensor type."""
    min_bytes: i64
    max_bytes: i64
    sample_bytes: i64

    fn __init__(min_bytes: i64, max_bytes: i64, sample_bytes: i64):
        self.min_bytes = min_bytes
        self.max_bytes = max_bytes
        self.sample_bytes = sample_bytes


# ============================================================================
# Typed Tensor (Simplified)
# ============================================================================

class TypedTensor:
    """Tensor with compile-time dimension tracking."""
    handle: u64
    tensor_type: TensorType

    fn __init__(handle: u64, tensor_type: TensorType):
        self.handle = handle
        self.tensor_type = tensor_type

    fn shape() -> [i64]:
        return self.tensor_type.shape

    fn dtype() -> DType:
        return self.tensor_type.dtype

    fn ndim() -> i64:
        return self.tensor_type.ndim()

    static fn zeros(shape: [i64], dtype: DType = DType.Float32, device: Device = Device.CPU) -> TypedTensor:
        """Create typed tensor filled with zeros."""
        val tt = TensorType(shape, dtype)
        return TypedTensor(0u64, tt)

    static fn ones(shape: [i64], dtype: DType = DType.Float32, device: Device = Device.CPU) -> TypedTensor:
        """Create typed tensor filled with ones."""
        val tt = TensorType(shape, dtype)
        return TypedTensor(0u64, tt)

    static fn randn(shape: [i64], dtype: DType = DType.Float32, device: Device = Device.CPU) -> TypedTensor:
        """Create typed tensor with random normal values."""
        val tt = TensorType(shape, dtype)
        return TypedTensor(0u64, tt)

