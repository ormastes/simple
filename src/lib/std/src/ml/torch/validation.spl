# Torch Validation Utilities
#
# Runtime validation for ML training pipelines.
# Validates memory, shapes, gradients, and numeric stability.
#
# Usage:
#     import ml.torch.validation.{Validator, ValidationMode, ValidationResult}
#
#     val validator = Validator.new()
#         .check_memory(max_gb=8.0)
#         .check_shapes(true)
#         .check_gradients(true)
#         .check_stability(true)
#
#     val result = validator.validate(model, sample_batch)
#     if result.has_errors():
#         for err in result.errors:
#             print(err.to_string())

export ValidationMode, ValidationResult, ValidationError, Validator
export MemoryStats, ShapeInfo, GradientInfo


# ============================================================================
# Validation Mode
# ============================================================================

# Training validation mode.
enum ValidationMode:
    CheckOnly     # Validate without training
    TrainOnly     # Skip validation, train directly
    CheckAndTrain # Validate first, then train if passing

impl ValidationMode:
    fn is_check_only() -> bool:
        """Check if mode is check-only."""
        match self:
            case CheckOnly: true
            case _: false

    fn is_train_only() -> bool:
        """Check if mode is train-only."""
        match self:
            case TrainOnly: true
            case _: false

    fn should_validate() -> bool:
        """Check if validation should run."""
        match self:
            case TrainOnly: false
            case _: true

    fn should_train() -> bool:
        """Check if training should run."""
        match self:
            case CheckOnly: false
            case _: true

    fn to_string() -> str:
        """Convert to string representation."""
        match self:
            case CheckOnly: "check_only"
            case TrainOnly: "train_only"
            case CheckAndTrain: "check_and_train"


# ============================================================================
# Validation Result Types
# ============================================================================

class ValidationError:
    """A validation error with category and details."""
    category: str  # "memory", "shape", "gradient", "stability", "device"
    message: str
    severity: str  # "error", "warning"

    fn __init__(category: str, message: str, severity: str = "error"):
        self.category = category
        self.message = message
        self.severity = severity

    fn to_string() -> str:
        """Format error for display."""
        return "[{self.severity}] {self.category}: {self.message}"

    fn is_error() -> bool:
        """Check if this is an error (not warning)."""
        return self.severity == "error"


class MemoryStats:
    """Memory usage statistics."""
    param_bytes: i64
    activation_bytes: i64
    total_bytes: i64
    available_bytes: i64

    fn __init__(param_bytes: i64 = 0, activation_bytes: i64 = 0, available_bytes: i64 = 0):
        self.param_bytes = param_bytes
        self.activation_bytes = activation_bytes
        self.total_bytes = param_bytes + activation_bytes
        self.available_bytes = available_bytes

    fn total_gb() -> f64:
        """Get total memory in GB."""
        return self.total_bytes as f64 / (1024.0 * 1024.0 * 1024.0)

    fn param_gb() -> f64:
        """Get parameter memory in GB."""
        return self.param_bytes as f64 / (1024.0 * 1024.0 * 1024.0)

    fn utilization() -> f64:
        """Get memory utilization ratio."""
        if self.available_bytes == 0:
            return 0.0
        return self.total_bytes as f64 / self.available_bytes as f64

    fn to_string() -> str:
        """Format memory stats for display."""
        return "Memory: {self.total_gb():.2f}GB (params: {self.param_gb():.2f}GB)"


class ShapeInfo:
    """Tensor shape information."""
    name: str
    expected: any  # List of dimensions
    actual: any    # List of dimensions
    matches: bool

    fn __init__(name: str, expected: any, actual: any):
        self.name = name
        self.expected = expected
        self.actual = actual
        self.matches = _shapes_match(expected, actual)

    fn to_string() -> str:
        """Format shape info for display."""
        if self.matches:
            return "{self.name}: {self.actual} (OK)"
        return "{self.name}: expected {self.expected}, got {self.actual}"


class GradientInfo:
    """Gradient flow information for a layer."""
    layer_name: str
    has_gradient: bool
    is_zero: bool
    has_nan: bool
    has_inf: bool
    mean: f64
    std: f64

    fn __init__(layer_name: str):
        self.layer_name = layer_name
        self.has_gradient = false
        self.is_zero = false
        self.has_nan = false
        self.has_inf = false
        self.mean = 0.0
        self.std = 0.0

    fn is_healthy() -> bool:
        """Check if gradient is healthy."""
        return self.has_gradient and not self.is_zero and not self.has_nan and not self.has_inf

    fn to_string() -> str:
        """Format gradient info for display."""
        if not self.has_gradient:
            return "{self.layer_name}: no gradient"
        if self.has_nan:
            return "{self.layer_name}: NaN detected"
        if self.has_inf:
            return "{self.layer_name}: Inf detected"
        if self.is_zero:
            return "{self.layer_name}: zero gradient (dead layer)"
        return "{self.layer_name}: mean={self.mean:.6f}, std={self.std:.6f}"


class ValidationResult:
    """Result of validation checks."""
    errors: any     # List of ValidationError
    warnings: any   # List of ValidationError
    memory: MemoryStats
    shapes: any     # List of ShapeInfo
    gradients: any  # List of GradientInfo
    passed: bool

    fn __init__():
        self.errors = []
        self.warnings = []
        self.memory = MemoryStats()
        self.shapes = []
        self.gradients = []
        self.passed = true

    me add_error(category: str, message: str):
        """Add an error to results."""
        self.errors = self.errors.push(ValidationError(category, message, "error"))
        self.passed = false

    me add_warning(category: str, message: str):
        """Add a warning to results."""
        self.warnings = self.warnings.push(ValidationError(category, message, "warning"))

    fn has_errors() -> bool:
        """Check if any errors occurred."""
        return self.errors.len() > 0

    fn error_count() -> i64:
        """Get number of errors."""
        return self.errors.len()

    fn warning_count() -> i64:
        """Get number of warnings."""
        return self.warnings.len()

    fn summary() -> str:
        """Get summary of validation results."""
        if self.passed:
            return "Validation passed ({self.warning_count()} warnings)"
        return "Validation failed: {self.error_count()} errors, {self.warning_count()} warnings"


# ============================================================================
# Validator
# ============================================================================

class Validator:
    """Training pipeline validator.

    Configurable validation for memory, shapes, gradients, and stability.

    Example:
        val validator = Validator.new()
            .check_memory(max_gb=8.0)
            .check_shapes(true)
            .check_gradients(true)

        val result = validator.validate(model, batch)
        if not result.passed:
            for err in result.errors:
                print(err.to_string())
    """
    _check_memory: bool
    _max_memory_gb: f64
    _check_shapes: bool
    _check_gradients: bool
    _check_stability: bool
    _check_device: bool
    _expected_device: str

    fn __init__():
        self._check_memory = false
        self._max_memory_gb = 0.0
        self._check_shapes = false
        self._check_gradients = false
        self._check_stability = false
        self._check_device = false
        self._expected_device = "cuda"

    static fn new() -> Validator:
        """Create a new validator."""
        return Validator()

    me check_memory(max_gb: f64 = 0.0) -> Validator:
        """Enable memory validation.

        Args:
            max_gb: Maximum allowed memory in GB (0 = no limit)

        Returns:
            Self for chaining
        """
        self._check_memory = true
        self._max_memory_gb = max_gb
        return self

    me check_shapes(enabled: bool = true) -> Validator:
        """Enable shape validation.

        Args:
            enabled: Whether to check shapes

        Returns:
            Self for chaining
        """
        self._check_shapes = enabled
        return self

    me check_gradients(enabled: bool = true) -> Validator:
        """Enable gradient flow validation.

        Args:
            enabled: Whether to check gradients

        Returns:
            Self for chaining
        """
        self._check_gradients = enabled
        return self

    me check_stability(enabled: bool = true) -> Validator:
        """Enable numeric stability validation.

        Args:
            enabled: Whether to check for NaN/Inf

        Returns:
            Self for chaining
        """
        self._check_stability = enabled
        return self

    me check_device(device: str = "cuda") -> Validator:
        """Enable device placement validation.

        Args:
            device: Expected device ("cuda", "cpu", etc.)

        Returns:
            Self for chaining
        """
        self._check_device = true
        self._expected_device = device
        return self

    fn validate(model: any, sample_batch: any) -> ValidationResult:
        """Run all enabled validations.

        Args:
            model: Model to validate
            sample_batch: Sample input batch

        Returns:
            ValidationResult with all findings
        """
        var result = ValidationResult()

        if self._check_memory:
            _validate_memory(model, sample_batch, self._max_memory_gb, result)

        if self._check_shapes:
            _validate_shapes(model, sample_batch, result)

        if self._check_gradients:
            _validate_gradients(model, result)

        if self._check_stability:
            _validate_stability(model, sample_batch, result)

        if self._check_device:
            _validate_device(model, sample_batch, self._expected_device, result)

        return result

    fn validate_memory(model: any, batch_size: i64) -> MemoryStats:
        """Estimate memory usage for model and batch.

        Args:
            model: Model to analyze
            batch_size: Expected batch size

        Returns:
            MemoryStats with estimated usage
        """
        return _estimate_memory(model, batch_size)


# ============================================================================
# Cache Statistics
# ============================================================================

class CacheStats:
    """Cache performance statistics."""
    hits: i64
    misses: i64
    evictions: i64
    memory_bytes: i64

    fn __init__():
        self.hits = 0
        self.misses = 0
        self.evictions = 0
        self.memory_bytes = 0

    fn hit_rate() -> f64:
        """Get cache hit rate."""
        val total = self.hits + self.misses
        if total == 0:
            return 0.0
        return self.hits as f64 / total as f64

    fn memory_mb() -> f64:
        """Get memory usage in MB."""
        return self.memory_bytes as f64 / (1024.0 * 1024.0)

    fn to_string() -> str:
        """Format stats for display."""
        return "Cache: {self.hit_rate() * 100.0:.1f}% hit rate, {self.memory_mb():.1f}MB"

    me record_hit():
        """Record a cache hit."""
        self.hits = self.hits + 1

    me record_miss():
        """Record a cache miss."""
        self.misses = self.misses + 1

    me record_eviction():
        """Record a cache eviction."""
        self.evictions = self.evictions + 1

    me update_memory(bytes: i64):
        """Update memory usage."""
        self.memory_bytes = bytes


# ============================================================================
# Helper Functions
# ============================================================================

fn _shapes_match(expected: any, actual: any) -> bool:
    """Check if two shapes match."""
    if not (expected is list) or not (actual is list):
        return false
    if expected.len() != actual.len():
        return false
    for i in 0..expected.len():
        if expected[i] != actual[i]:
            return false
    return true

fn _validate_memory(model: any, batch: any, max_gb: f64, result: ValidationResult):
    """Validate memory usage."""
    val stats = _estimate_memory(model, 1)
    result.memory = stats

    if max_gb > 0.0 and stats.total_gb() > max_gb:
        result.add_error("memory",
            "Estimated memory ({stats.total_gb():.2f}GB) exceeds limit ({max_gb:.2f}GB)")

fn _validate_shapes(model: any, batch: any, result: ValidationResult):
    """Validate tensor shapes through model."""
    # Placeholder - would run forward pass and check shapes
    pass

fn _validate_gradients(model: any, result: ValidationResult):
    """Validate gradient flow."""
    # Placeholder - would check gradients after backward pass
    pass

fn _validate_stability(model: any, batch: any, result: ValidationResult):
    """Validate numeric stability."""
    # Placeholder - would check for NaN/Inf in outputs
    pass

fn _validate_device(model: any, batch: any, expected: str, result: ValidationResult):
    """Validate device placement."""
    # Placeholder - would check all tensors are on expected device
    pass

fn _estimate_memory(model: any, batch_size: i64) -> MemoryStats:
    """Estimate memory usage for model."""
    # Placeholder - would calculate actual memory requirements
    return MemoryStats(
        param_bytes=0,
        activation_bytes=0,
        available_bytes=8 * 1024 * 1024 * 1024  # Assume 8GB
    )
