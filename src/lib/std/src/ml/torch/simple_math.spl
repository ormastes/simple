# Simple Math Operations
#
# Element-wise mathematical operations for tensor manipulation.
#
# ## Functions
# - `clamp(x, min, max)` - Clamp values to range [min, max]
# - `where(cond, x, y)` - Select values based on condition
#
# ## Example
# ```simple
# import ml.torch as torch
# import ml.torch.simple_math as math
#
# val x = torch.randn([10])
# val clamped = math.clamp(x, -1.0, 1.0)
#
# val cond = torch.randn([10])
# val x_vals = torch.ones([10])
# val y_vals = torch.zeros([10])
# val selected = math.where(cond, x_vals, y_vals)
# ```

pub use clamp, select_where

use ml.torch.tensor_class.{Tensor}


# ============================================================================
# Element-wise Operations
# ============================================================================

fn clamp(x: Tensor, min_val: f64, max_val: f64) -> Tensor:
    """Clamp tensor values to range [min, max].

    Element-wise operation that restricts tensor values to the specified range.

    Args:
        x: Input tensor
        min_val: Minimum value (lower bound)
        max_val: Maximum value (upper bound)

    Returns:
        Clamped tensor (same shape as input)
    """
    val handle = @rt_torch_clamp(x.handle, min_val, max_val)
    if handle == 0:
        panic("Clamp failed")
    return Tensor(handle)


fn select_where(cond: Tensor, x: Tensor, y: Tensor) -> Tensor:
    """Select values based on condition.

    Element-wise selection: result[i] = x[i] if cond[i] else y[i]

    Args:
        cond: Condition tensor (boolean or numeric)
        x: Values where condition is true
        y: Values where condition is false

    Returns:
        Selected tensor (same shape as input tensors)
    """
    val handle = @rt_torch_where(cond.handle, x.handle, y.handle)
    if handle == 0:
        panic("Where failed")
    return Tensor(handle)


# ============================================================================
# External FFI Functions
# ============================================================================

extern fn rt_torch_clamp(x: u64, min_val: f64, max_val: f64) -> u64
extern fn rt_torch_where(cond: u64, x: u64, y: u64) -> u64
