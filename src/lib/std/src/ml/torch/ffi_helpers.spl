# FFI Helpers - Tensor Creation Utilities
#
# Provides convenient tensor creation functions that avoid the need for
# shape arrays, eliminating the array.data_ptr() limitation.
#
# ## Functions
# - `randn_1d(size)` - 1D random tensor
# - `randn_2d(rows, cols)` - 2D random tensor
# - `randn_3d(d1, d2, d3)` - 3D random tensor
# - `zeros_1d(size)` - 1D zeros tensor
# - `zeros_2d(rows, cols)` - 2D zeros tensor
# - `ones_1d(size)` - 1D ones tensor
# - `ones_2d(rows, cols)` - 2D ones tensor
#
# ## Example
# ```simple
# import ml.torch as torch
# import ml.torch.ffi_helpers as helpers
#
# # No shape arrays needed!
# val x = helpers.randn_2d(10, 20, device=Device.CUDA(0))
# val y = helpers.zeros_1d(100, device=Device.CUDA(0))
# val z = helpers.ones_2d(5, 5)
# ```

pub use randn_1d, randn_2d, randn_3d
pub use zeros_1d, zeros_2d, zeros_3d
pub use ones_1d, ones_2d, ones_3d

use tensor_class.{Tensor}
use dtype.{DType, dtype_code}
use device.{Device, device_code}


# ============================================================================
# Random Tensors (randn)
# ============================================================================

fn randn_1d(size: i64, dtype: DType = DType.Float32, device: Device = Device.CPU) -> Tensor:
    """Create 1D random tensor from N(0, 1).

    Args:
        size: Length of 1D tensor
        dtype: Data type (default: Float32)
        device: Device to create on (default: CPU)

    Returns:
        1D tensor with shape [size]
    """
    val handle = rt_torch_randn_1d(size, dtype_code(dtype), device_code(device))
    if handle == 0:
        panic("Failed to create 1D randn tensor")
    return Tensor(handle)


fn randn_2d(rows: i64, cols: i64, dtype: DType = DType.Float32, device: Device = Device.CPU) -> Tensor:
    """Create 2D random tensor from N(0, 1).

    Args:
        rows: Number of rows
        cols: Number of columns
        dtype: Data type (default: Float32)
        device: Device to create on (default: CPU)

    Returns:
        2D tensor with shape [rows, cols]
    """
    val handle = rt_torch_randn_2d(rows, cols, dtype_code(dtype), device_code(device))
    if handle == 0:
        panic("Failed to create 2D randn tensor")
    return Tensor(handle)


fn randn_3d(d1: i64, d2: i64, d3: i64, dtype: DType = DType.Float32, device: Device = Device.CPU) -> Tensor:
    """Create 3D random tensor from N(0, 1).

    Args:
        d1: First dimension
        d2: Second dimension
        d3: Third dimension
        dtype: Data type (default: Float32)
        device: Device to create on (default: CPU)

    Returns:
        3D tensor with shape [d1, d2, d3]
    """
    val handle = rt_torch_randn_3d(d1, d2, d3, dtype_code(dtype), device_code(device))
    if handle == 0:
        panic("Failed to create 3D randn tensor")
    return Tensor(handle)


# ============================================================================
# Zeros Tensors
# ============================================================================

fn zeros_1d(size: i64, dtype: DType = DType.Float32, device: Device = Device.CPU) -> Tensor:
    """Create 1D zeros tensor.

    Args:
        size: Length of 1D tensor
        dtype: Data type (default: Float32)
        device: Device to create on (default: CPU)

    Returns:
        1D tensor with shape [size], all zeros
    """
    val handle = rt_torch_zeros_1d(size, dtype_code(dtype), device_code(device))
    if handle == 0:
        panic("Failed to create 1D zeros tensor")
    return Tensor(handle)


fn zeros_2d(rows: i64, cols: i64, dtype: DType = DType.Float32, device: Device = Device.CPU) -> Tensor:
    """Create 2D zeros tensor.

    Args:
        rows: Number of rows
        cols: Number of columns
        dtype: Data type (default: Float32)
        device: Device to create on (default: CPU)

    Returns:
        2D tensor with shape [rows, cols], all zeros
    """
    val handle = rt_torch_zeros_2d(rows, cols, dtype_code(dtype), device_code(device))
    if handle == 0:
        panic("Failed to create 2D zeros tensor")
    return Tensor(handle)


fn zeros_3d(d1: i64, d2: i64, d3: i64, dtype: DType = DType.Float32, device: Device = Device.CPU) -> Tensor:
    """Create 3D zeros tensor.

    Args:
        d1: First dimension
        d2: Second dimension
        d3: Third dimension
        dtype: Data type (default: Float32)
        device: Device to create on (default: CPU)

    Returns:
        3D tensor with shape [d1, d2, d3], all zeros
    """
    val handle = rt_torch_zeros_3d(d1, d2, d3, dtype_code(dtype), device_code(device))
    if handle == 0:
        panic("Failed to create 3D zeros tensor")
    return Tensor(handle)


# ============================================================================
# Ones Tensors
# ============================================================================

fn ones_1d(size: i64, dtype: DType = DType.Float32, device: Device = Device.CPU) -> Tensor:
    """Create 1D ones tensor.

    Args:
        size: Length of 1D tensor
        dtype: Data type (default: Float32)
        device: Device to create on (default: CPU)

    Returns:
        1D tensor with shape [size], all ones
    """
    val handle = rt_torch_ones_1d(size, dtype_code(dtype), device_code(device))
    if handle == 0:
        panic("Failed to create 1D ones tensor")
    return Tensor(handle)


fn ones_2d(rows: i64, cols: i64, dtype: DType = DType.Float32, device: Device = Device.CPU) -> Tensor:
    """Create 2D ones tensor.

    Args:
        rows: Number of rows
        cols: Number of columns
        dtype: Data type (default: Float32)
        device: Device to create on (default: CPU)

    Returns:
        2D tensor with shape [rows, cols], all ones
    """
    val handle = rt_torch_ones_2d(rows, cols, dtype_code(dtype), device_code(device))
    if handle == 0:
        panic("Failed to create 2D ones tensor")
    return Tensor(handle)


fn ones_3d(d1: i64, d2: i64, d3: i64, dtype: DType = DType.Float32, device: Device = Device.CPU) -> Tensor:
    """Create 3D ones tensor.

    Args:
        d1: First dimension
        d2: Second dimension
        d3: Third dimension
        dtype: Data type (default: Float32)
        device: Device to create on (default: CPU)

    Returns:
        3D tensor with shape [d1, d2, d3], all ones
    """
    val handle = rt_torch_ones_3d(d1, d2, d3, dtype_code(dtype), device_code(device))
    if handle == 0:
        panic("Failed to create 3D ones tensor")
    return Tensor(handle)


# External FFI declarations
extern fn rt_torch_randn_1d(size: i64, dtype: i32, device: i32) -> u64
extern fn rt_torch_randn_2d(rows: i64, cols: i64, dtype: i32, device: i32) -> u64
extern fn rt_torch_randn_3d(d1: i64, d2: i64, d3: i64, dtype: i32, device: i32) -> u64
extern fn rt_torch_zeros_1d(size: i64, dtype: i32, device: i32) -> u64
extern fn rt_torch_zeros_2d(rows: i64, cols: i64, dtype: i32, device: i32) -> u64
extern fn rt_torch_zeros_3d(d1: i64, d2: i64, d3: i64, dtype: i32, device: i32) -> u64
extern fn rt_torch_ones_1d(size: i64, dtype: i32, device: i32) -> u64
extern fn rt_torch_ones_2d(rows: i64, cols: i64, dtype: i32, device: i32) -> u64
extern fn rt_torch_ones_3d(d1: i64, d2: i64, d3: i64, dtype: i32, device: i32) -> u64
