# Fast Fourier Transform Operations
#
# Frequency domain operations for signal processing and FFT computations.
#
# ## Functions
# - `fft(x, n, dim, norm)` - 1D Fast Fourier Transform
# - `ifft(x, n, dim, norm)` - 1D Inverse Fast Fourier Transform
# - `rfft(x, n, dim, norm)` - 1D Real FFT (for real-valued inputs)
# - `irfft(x, n, dim, norm)` - 1D Inverse Real FFT
# - `fftn(x, dims, norm)` - N-D Fast Fourier Transform
# - `fftshift(x, dim)` - Shift zero-frequency to center
# - `ifftshift(x, dim)` - Inverse fftshift
#
# ## Example
# ```simple
# import ml.torch as torch
# import ml.torch.fft as fft
#
# val signal = torch.randn([128])
# val spectrum = fft.fft(signal, n=-1, dim=0, norm=0)
# val reconstructed = fft.ifft(spectrum, n=-1, dim=0, norm=0)
# ```

export fft, ifft, rfft, irfft, fftn, fftshift, ifftshift

import ml.torch.tensor_class.{Tensor}


# ============================================================================
# FFT Operations
# ============================================================================

fn fft(x: Tensor, n: i64 = -1, dim: i64 = 0, norm: i32 = 0) -> Tensor:
    """1D Fast Fourier Transform.

    Computes the one dimensional discrete Fourier Transform.

    Args:
        x: Input tensor (complex or real)
        n: Size of Fourier transform (default: -1 for no change)
        dim: Dimension along which to apply FFT (default: 0)
        norm: Normalization mode - 0=None, 1=forward, 2=backward, 3=ortho (default: 0)

    Returns:
        Complex output tensor
    """
    val handle = @rt_torch_fft(x.handle, n, dim, norm)
    if handle == 0:
        panic("FFT failed")
    return Tensor(handle)


fn ifft(x: Tensor, n: i64 = -1, dim: i64 = 0, norm: i32 = 0) -> Tensor:
    """1D Inverse Fast Fourier Transform.

    Computes the one dimensional inverse discrete Fourier Transform.

    Args:
        x: Input tensor (complex)
        n: Size of inverse Fourier transform (default: -1 for no change)
        dim: Dimension along which to apply IFFT (default: 0)
        norm: Normalization mode - 0=None, 1=forward, 2=backward, 3=ortho (default: 0)

    Returns:
        Complex output tensor
    """
    val handle = @rt_torch_ifft(x.handle, n, dim, norm)
    if handle == 0:
        panic("IFFT failed")
    return Tensor(handle)


fn rfft(x: Tensor, n: i64 = -1, dim: i64 = 0, norm: i32 = 0) -> Tensor:
    """1D Real FFT.

    Computes the one dimensional FFT of real-valued input.

    Args:
        x: Input tensor (real-valued)
        n: Size of Fourier transform (default: -1 for no change)
        dim: Dimension along which to apply RFFT (default: 0)
        norm: Normalization mode - 0=None, 1=forward, 2=backward, 3=ortho (default: 0)

    Returns:
        Complex output tensor
    """
    val handle = @rt_torch_rfft(x.handle, n, dim, norm)
    if handle == 0:
        panic("RFFT failed")
    return Tensor(handle)


fn irfft(x: Tensor, n: i64 = -1, dim: i64 = 0, norm: i32 = 0) -> Tensor:
    """1D Inverse Real FFT.

    Computes the inverse of rfft().

    Args:
        x: Input tensor (complex from rfft)
        n: Size of inverse transform (default: -1 for no change)
        dim: Dimension along which to apply IRFFT (default: 0)
        norm: Normalization mode - 0=None, 1=forward, 2=backward, 3=ortho (default: 0)

    Returns:
        Real output tensor
    """
    val handle = @rt_torch_irfft(x.handle, n, dim, norm)
    if handle == 0:
        panic("IRFFT failed")
    return Tensor(handle)


fn fftn(x: Tensor, dims: [i64], norm: i32 = 0) -> Tensor:
    """N-D Fast Fourier Transform.

    Computes the N-dimensional FFT over specified dimensions.

    Args:
        x: Input tensor
        dims: Dimensions along which to apply FFT
        norm: Normalization mode - 0=None, 1=forward, 2=backward, 3=ortho (default: 0)

    Returns:
        Complex output tensor
    """
    # Note: In a real implementation, we'd pass dims_ptr and ndim
    # For now, we use a simplified approach with individual dimensions
    val handle = @rt_torch_fftn(x.handle, dims.as_ptr() as u64, dims.len() as i32, norm)
    if handle == 0:
        panic("FFTN failed")
    return Tensor(handle)


fn fftshift(x: Tensor, dim: i64 = -1) -> Tensor:
    """Shift zero-frequency component to center of spectrum.

    Rearranges the output so that the zero-frequency component is at the center.

    Args:
        x: Input tensor
        dim: Dimension to shift, or -1 for all dimensions (default: -1)

    Returns:
        Shifted output tensor
    """
    val handle = @rt_torch_fftshift(x.handle, dim)
    if handle == 0:
        panic("FFTShift failed")
    return Tensor(handle)


fn ifftshift(x: Tensor, dim: i64 = -1) -> Tensor:
    """Inverse of fftshift.

    Reverses the fftshift operation.

    Args:
        x: Input tensor
        dim: Dimension to shift, or -1 for all dimensions (default: -1)

    Returns:
        Shifted output tensor
    """
    val handle = @rt_torch_ifftshift(x.handle, dim)
    if handle == 0:
        panic("IFFTShift failed")
    return Tensor(handle)


# ============================================================================
# External FFI Functions
# ============================================================================

extern fn rt_torch_fft(x: u64, n: i64, dim: i64, norm: i32) -> u64
extern fn rt_torch_ifft(x: u64, n: i64, dim: i64, norm: i32) -> u64
extern fn rt_torch_rfft(x: u64, n: i64, dim: i64, norm: i32) -> u64
extern fn rt_torch_irfft(x: u64, n: i64, dim: i64, norm: i32) -> u64
extern fn rt_torch_fftn(x: u64, dims_ptr: u64, ndim: i32, norm: i32) -> u64
extern fn rt_torch_fftshift(x: u64, dim: i64) -> u64
extern fn rt_torch_ifftshift(x: u64, dim: i64) -> u64
