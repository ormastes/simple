# Bare Metal Time - Time and delay functions
#
# Provides timing primitives for bare metal environments.

# FFI declarations
@extern("bare", "time_cycles")
fn cycles() -> u64:
    pass

@extern("bare", "time_micros")
fn micros() -> u64:
    pass

@extern("bare", "time_millis")
fn millis() -> u64:
    pass

@extern("bare", "time_delay_cycles")
fn delay_cycles(count: u64):
    pass

@extern("bare", "time_delay_micros")
fn delay_micros(us: u64):
    pass

@extern("bare", "time_delay_millis")
fn delay_millis(ms: u64):
    pass

# Get system tick count (platform-specific resolution)
@extern("bare", "time_ticks")
fn ticks() -> u64:
    pass

# Get ticks per second (for tick to time conversion)
@extern("bare", "time_ticks_per_second")
fn ticks_per_second() -> u64:
    pass

# Convert ticks to microseconds
fn ticks_to_micros(t: u64) -> u64:
    return t * 1000000 / ticks_per_second()

# Convert ticks to milliseconds
fn ticks_to_millis(t: u64) -> u64:
    return t * 1000 / ticks_per_second()

# Instant - a point in time
struct Instant:
    ticks: u64

    static fn now() -> Instant:
        return Instant(ticks: ticks())

    fn elapsed() -> Duration:
        val now = ticks()
        return Duration(ticks: now - self.ticks)

    fn elapsed_micros() -> u64:
        return self.elapsed().as_micros()

    fn elapsed_millis() -> u64:
        return self.elapsed().as_millis()

    fn since(other: Instant) -> Duration:
        return Duration(ticks: self.ticks - other.ticks)

# Duration - a span of time
struct Duration:
    ticks: u64

    static fn from_micros(us: u64) -> Duration:
        return Duration(ticks: us * ticks_per_second() / 1000000)

    static fn from_millis(ms: u64) -> Duration:
        return Duration(ticks: ms * ticks_per_second() / 1000)

    static fn from_secs(s: u64) -> Duration:
        return Duration(ticks: s * ticks_per_second())

    fn as_micros() -> u64:
        return ticks_to_micros(self.ticks)

    fn as_millis() -> u64:
        return ticks_to_millis(self.ticks)

    fn as_secs() -> u64:
        return self.ticks / ticks_per_second()

    fn is_zero() -> bool:
        return self.ticks == 0

# Timer for periodic events
struct PeriodicTimer:
    interval: Duration
    last_tick: u64

    static fn new(interval: Duration) -> PeriodicTimer:
        return PeriodicTimer(interval: interval, last_tick: ticks())

    # Check if timer has elapsed, reset if so
    me check() -> bool:
        val now = ticks()
        if now - self.last_tick >= self.interval.ticks:
            self.last_tick = now
            return true
        return false

    # Get remaining time until next tick
    fn remaining() -> Duration:
        val now = ticks()
        val elapsed = now - self.last_tick
        if elapsed >= self.interval.ticks:
            return Duration(ticks: 0)
        return Duration(ticks: self.interval.ticks - elapsed)

    me reset():
        self.last_tick = ticks()

# One-shot timer
struct OneShotTimer:
    deadline: u64
    triggered: bool

    static fn new(timeout: Duration) -> OneShotTimer:
        return OneShotTimer(deadline: ticks() + timeout.ticks, triggered: false)

    # Check if timer has elapsed
    fn is_expired() -> bool:
        return ticks() >= self.deadline

    # Check and mark as triggered
    me check() -> bool:
        if self.triggered:
            return false
        if self.is_expired():
            self.triggered = true
            return true
        return false

    # Get remaining time
    fn remaining() -> Duration:
        val now = ticks()
        if now >= self.deadline:
            return Duration(ticks: 0)
        return Duration(ticks: self.deadline - now)

pub use cycles, micros, millis
pub use delay_cycles, delay_micros, delay_millis
pub use ticks, ticks_per_second, ticks_to_micros, ticks_to_millis
pub use Instant, Duration, PeriodicTimer, OneShotTimer
