# I2C - Inter-Integrated Circuit HAL
#
# Hardware abstraction layer for I2C/TWI communication.

# I2C speed modes
enum I2cSpeed:
    Standard   # 100 kHz
    Fast       # 400 kHz
    FastPlus   # 1 MHz
    HighSpeed  # 3.4 MHz

# I2C configuration
struct I2cConfig:
    speed: I2cSpeed
    address_10bit: bool

    static fn default() -> I2cConfig:
        return I2cConfig(
            speed: I2cSpeed.Standard,
            address_10bit: false
        )

# I2C result
enum I2cResult:
    Ok
    Nack
    BusError
    ArbitrationLost
    Timeout

# I2C trait
trait I2c:
    # Initialize I2C with configuration
    me init(config: I2cConfig)

    # Write bytes to device
    me write(addr: u16, data: [u8]) -> I2cResult

    # Read bytes from device
    fn read(addr: u16, len: usize) -> Result<[u8], I2cResult>

    # Write then read (combined transaction)
    fn write_read(addr: u16, write_data: [u8], read_len: usize) -> Result<[u8], I2cResult>

    # Scan for devices on bus
    fn scan() -> List<u16>:
        var found: List<u16> = []
        for addr in 0x08..0x78:  # Valid 7-bit address range
            if self.probe(addr as u16):
                found.push(addr as u16)
        return found

    # Check if device responds at address
    fn probe(addr: u16) -> bool:
        match self.write(addr, []):
            I2cResult.Ok: return true
            _: return false

# Generic I2C implementation
struct GenericI2c:
    base_addr: usize
    config: I2cConfig

    static fn new(base: usize) -> GenericI2c:
        return GenericI2c(base_addr: base, config: I2cConfig.default())

impl GenericI2c: I2c:
    me init(config: I2cConfig):
        self.config = config
        # Platform-specific initialization
        pass

    me write(addr: u16, data: [u8]) -> I2cResult:
        # Platform-specific implementation
        return I2cResult.Ok

    fn read(addr: u16, len: usize) -> Result<[u8], I2cResult>:
        # Platform-specific implementation
        return Result.ok([])

    fn write_read(addr: u16, write_data: [u8], read_len: usize) -> Result<[u8], I2cResult>:
        match self.write(addr, write_data):
            I2cResult.Ok:
                return self.read(addr, read_len)
            err:
                return Result.err(err)

# I2C device wrapper for specific slave
struct I2cDevice:
    i2c: I2c
    addr: u16

    static fn new(i2c: I2c, addr: u16) -> I2cDevice:
        return I2cDevice(i2c: i2c, addr: addr)

    # Write to device
    me write(data: [u8]) -> I2cResult:
        return self.i2c.write(self.addr, data)

    # Read from device
    fn read(len: usize) -> Result<[u8], I2cResult>:
        return self.i2c.read(self.addr, len)

    # Write register address then read
    fn read_reg(reg: u8, len: usize) -> Result<[u8], I2cResult>:
        return self.i2c.write_read(self.addr, [reg], len)

    # Write to register
    me write_reg(reg: u8, data: [u8]) -> I2cResult:
        var write_data: [u8] = [reg]
        for byte in data:
            write_data.push(byte)
        return self.i2c.write(self.addr, write_data)

    # Read single byte from register
    fn read_reg_byte(reg: u8) -> Result<u8, I2cResult>:
        match self.read_reg(reg, 1):
            Result.Ok(data):
                return Result.ok(data[0])
            Result.Err(err):
                return Result.err(err)

    # Write single byte to register
    me write_reg_byte(reg: u8, value: u8) -> I2cResult:
        return self.write_reg(reg, [value])

export I2cSpeed, I2cConfig, I2cResult
export I2c, GenericI2c, I2cDevice
