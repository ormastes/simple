# UART - Universal Asynchronous Receiver/Transmitter HAL
#
# Hardware abstraction layer for UART/serial communication.

# Parity modes
enum Parity:
    None
    Even
    Odd

# Stop bits
enum StopBits:
    One
    Two

# Data bits
enum DataBits:
    Five
    Six
    Seven
    Eight

# UART configuration
struct UartConfig:
    baud_rate: u32
    data_bits: DataBits
    parity: Parity
    stop_bits: StopBits
    flow_control: bool

    static fn default() -> UartConfig:
        return UartConfig(
            baud_rate: 115200,
            data_bits: DataBits.Eight,
            parity: Parity.None,
            stop_bits: StopBits.One,
            flow_control: false
        )

    fn with_baud(baud: u32) -> UartConfig:
        return UartConfig(
            baud_rate: baud,
            data_bits: self.data_bits,
            parity: self.parity,
            stop_bits: self.stop_bits,
            flow_control: self.flow_control
        )

# UART trait
trait Uart:
    # Initialize UART with configuration
    me init(config: UartConfig)

    # Write a single byte
    me write_byte(byte: u8)

    # Read a single byte (blocking)
    fn read_byte() -> u8

    # Check if data available to read
    fn is_readable() -> bool

    # Check if ready to write
    fn is_writable() -> bool

    # Write multiple bytes
    me write_bytes(data: [u8]):
        for byte in data:
            self.write_byte(byte)

    # Write string
    me write_str(s: text):
        for i in 0..s.len():
            self.write_byte(s[i] as u8)

    # Read byte if available (non-blocking)
    fn try_read_byte() -> Option<u8>:
        if self.is_readable():
            return Option.some(self.read_byte())
        return Option.none()

    # Flush transmit buffer
    me flush()

    # Set baud rate
    me set_baud_rate(baud: u32)

# Generic UART implementation
struct GenericUart:
    base_addr: usize
    config: UartConfig

    static fn new(base: usize) -> GenericUart:
        return GenericUart(base_addr: base, config: UartConfig.default())

impl GenericUart: Uart:
    me init(config: UartConfig):
        self.config = config
        # Platform-specific initialization
        pass

    me write_byte(byte: u8):
        # Platform-specific implementation
        pass

    fn read_byte() -> u8:
        # Platform-specific implementation
        return 0

    fn is_readable() -> bool:
        # Platform-specific implementation
        return false

    fn is_writable() -> bool:
        # Platform-specific implementation
        return true

    me flush():
        # Platform-specific implementation
        pass

    me set_baud_rate(baud: u32):
        self.config.baud_rate = baud
        # Platform-specific implementation
        pass

# UART interrupt types
enum UartInterrupt:
    RxReady
    TxEmpty
    Error

# Interrupt handler type
type UartInterruptHandler = fn(UartInterrupt) -> ()

# Enable UART interrupt
fn enable_interrupt(uart_id: u8, interrupt: UartInterrupt, handler: UartInterruptHandler):
    # Platform-specific implementation
    pass

# Disable UART interrupt
fn disable_interrupt(uart_id: u8, interrupt: UartInterrupt):
    # Platform-specific implementation
    pass

pub use Parity, StopBits, DataBits, UartConfig
pub use Uart, GenericUart
pub use UartInterrupt, UartInterruptHandler
pub use enable_interrupt, disable_interrupt
