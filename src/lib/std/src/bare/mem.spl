# Bare Metal Memory - Memory management for bare metal
#
# Provides low-level memory operations for bare metal environments.

# FFI declarations
@extern("bare", "mem_read_u8")
fn read_u8(addr: usize) -> u8:
    pass

@extern("bare", "mem_read_u16")
fn read_u16(addr: usize) -> u16:
    pass

@extern("bare", "mem_read_u32")
fn read_u32(addr: usize) -> u32:
    pass

@extern("bare", "mem_read_u64")
fn read_u64(addr: usize) -> u64:
    pass

@extern("bare", "mem_write_u8")
fn write_u8(addr: usize, value: u8):
    pass

@extern("bare", "mem_write_u16")
fn write_u16(addr: usize, value: u16):
    pass

@extern("bare", "mem_write_u32")
fn write_u32(addr: usize, value: u32):
    pass

@extern("bare", "mem_write_u64")
fn write_u64(addr: usize, value: u64):
    pass

# Volatile read/write (prevents compiler optimization)
@extern("bare", "mem_volatile_read_u8")
fn volatile_read_u8(addr: usize) -> u8:
    pass

@extern("bare", "mem_volatile_read_u16")
fn volatile_read_u16(addr: usize) -> u16:
    pass

@extern("bare", "mem_volatile_read_u32")
fn volatile_read_u32(addr: usize) -> u32:
    pass

@extern("bare", "mem_volatile_write_u8")
fn volatile_write_u8(addr: usize, value: u8):
    pass

@extern("bare", "mem_volatile_write_u16")
fn volatile_write_u16(addr: usize, value: u16):
    pass

@extern("bare", "mem_volatile_write_u32")
fn volatile_write_u32(addr: usize, value: u32):
    pass

# Memory copy and set
@extern("bare", "mem_copy")
fn copy(dest: usize, src: usize, len: usize):
    pass

@extern("bare", "mem_set")
fn set(dest: usize, value: u8, len: usize):
    pass

@extern("bare", "mem_zero")
fn zero(dest: usize, len: usize):
    pass

# Compare memory
@extern("bare", "mem_compare")
fn compare(a: usize, b: usize, len: usize) -> i32:
    pass

# Memory region descriptor
struct MemoryRegion:
    start: usize
    size: usize
    flags: u32

    fn end() -> usize:
        return self.start + self.size

    fn contains(addr: usize) -> bool:
        return addr >= self.start and addr < self.end()

    fn overlaps(other: MemoryRegion) -> bool:
        return self.start < other.end() and other.start < self.end()

# Memory flags
const MEM_READ: u32 = 0x01
const MEM_WRITE: u32 = 0x02
const MEM_EXEC: u32 = 0x04
const MEM_CACHED: u32 = 0x08
const MEM_DEVICE: u32 = 0x10

# Simple static allocator for bare metal
struct StaticAllocator:
    heap_start: usize
    heap_end: usize
    current: usize

    static fn new(heap_start: usize, heap_size: usize) -> StaticAllocator:
        return StaticAllocator(
            heap_start: heap_start,
            heap_end: heap_start + heap_size,
            current: heap_start
        )

    # Allocate memory (no free support in this simple allocator)
    me alloc(size: usize, align: usize) -> Option<usize>:
        # Align current pointer
        val aligned = (self.current + align - 1) & ~(align - 1)

        if aligned + size > self.heap_end:
            return Option.none()

        self.current = aligned + size
        return Option.some(aligned)

    fn bytes_used() -> usize:
        return self.current - self.heap_start

    fn bytes_free() -> usize:
        return self.heap_end - self.current

    me reset():
        self.current = self.heap_start

export read_u8, read_u16, read_u32, read_u64
export write_u8, write_u16, write_u32, write_u64
export volatile_read_u8, volatile_read_u16, volatile_read_u32
export volatile_write_u8, volatile_write_u16, volatile_write_u32
export copy, set, zero, compare
export MemoryRegion, StaticAllocator
export MEM_READ, MEM_WRITE, MEM_EXEC, MEM_CACHED, MEM_DEVICE
