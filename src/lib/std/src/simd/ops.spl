# SIMD Operations - Vector arithmetic and logic operations
#
# Provides element-wise operations on SIMD vector types.

use types.{Vec2i32, Vec2f32, Vec4i32, Vec4f32, Vec8i32, Vec8f32}

# Vector addition
fn add_vec2i32(a: Vec2i32, b: Vec2i32) -> Vec2i32:
    return Vec2i32(x: a.x + b.x, y: a.y + b.y)

fn add_vec2f32(a: Vec2f32, b: Vec2f32) -> Vec2f32:
    return Vec2f32(x: a.x + b.x, y: a.y + b.y)

fn add_vec4i32(a: Vec4i32, b: Vec4i32) -> Vec4i32:
    return Vec4i32(x: a.x + b.x, y: a.y + b.y, z: a.z + b.z, w: a.w + b.w)

fn add_vec4f32(a: Vec4f32, b: Vec4f32) -> Vec4f32:
    return Vec4f32(x: a.x + b.x, y: a.y + b.y, z: a.z + b.z, w: a.w + b.w)

# Vector multiplication
fn mul_vec2i32(a: Vec2i32, b: Vec2i32) -> Vec2i32:
    return Vec2i32(x: a.x * b.x, y: a.y * b.y)

fn mul_vec2f32(a: Vec2f32, b: Vec2f32) -> Vec2f32:
    return Vec2f32(x: a.x * b.x, y: a.y * b.y)

fn mul_vec4i32(a: Vec4i32, b: Vec4i32) -> Vec4i32:
    return Vec4i32(x: a.x * b.x, y: a.y * b.y, z: a.z * b.z, w: a.w * b.w)

fn mul_vec4f32(a: Vec4f32, b: Vec4f32) -> Vec4f32:
    return Vec4f32(x: a.x * b.x, y: a.y * b.y, z: a.z * b.z, w: a.w * b.w)

# Reduction operations
fn reduce_add_vec2i32(v: Vec2i32) -> i32:
    return v.x + v.y

fn reduce_add_vec2f32(v: Vec2f32) -> f32:
    return v.x + v.y

fn reduce_add_vec4i32(v: Vec4i32) -> i32:
    return v.x + v.y + v.z + v.w

fn reduce_add_vec4f32(v: Vec4f32) -> f32:
    return v.x + v.y + v.z + v.w

fn reduce_mul_vec2i32(v: Vec2i32) -> i32:
    return v.x * v.y

fn reduce_mul_vec2f32(v: Vec2f32) -> f32:
    return v.x * v.y

fn reduce_mul_vec4i32(v: Vec4i32) -> i32:
    return v.x * v.y * v.z * v.w

fn reduce_mul_vec4f32(v: Vec4f32) -> f32:
    return v.x * v.y * v.z * v.w

# Min/max operations
fn min_vec2i32(a: Vec2i32, b: Vec2i32) -> Vec2i32:
    val x = if a.x < b.x: a.x else: b.x
    val y = if a.y < b.y: a.y else: b.y
    return Vec2i32(x: x, y: y)

fn max_vec2i32(a: Vec2i32, b: Vec2i32) -> Vec2i32:
    val x = if a.x > b.x: a.x else: b.x
    val y = if a.y > b.y: a.y else: b.y
    return Vec2i32(x: x, y: y)

fn min_vec4f32(a: Vec4f32, b: Vec4f32) -> Vec4f32:
    val x = if a.x < b.x: a.x else: b.x
    val y = if a.y < b.y: a.y else: b.y
    val z = if a.z < b.z: a.z else: b.z
    val w = if a.w < b.w: a.w else: b.w
    return Vec4f32(x: x, y: y, z: z, w: w)

fn max_vec4f32(a: Vec4f32, b: Vec4f32) -> Vec4f32:
    val x = if a.x > b.x: a.x else: b.x
    val y = if a.y > b.y: a.y else: b.y
    val z = if a.z > b.z: a.z else: b.z
    val w = if a.w > b.w: a.w else: b.w
    return Vec4f32(x: x, y: y, z: z, w: w)

# Dot product
fn dot_vec2f32(a: Vec2f32, b: Vec2f32) -> f32:
    return a.x * b.x + a.y * b.y

fn dot_vec4f32(a: Vec4f32, b: Vec4f32) -> f32:
    return a.x * b.x + a.y * b.y + a.z * b.z + a.w * b.w

export add_vec2i32, add_vec2f32, add_vec4i32, add_vec4f32
export mul_vec2i32, mul_vec2f32, mul_vec4i32, mul_vec4f32
export reduce_add_vec2i32, reduce_add_vec2f32, reduce_add_vec4i32, reduce_add_vec4f32
export reduce_mul_vec2i32, reduce_mul_vec2f32, reduce_mul_vec4i32, reduce_mul_vec4f32
export min_vec2i32, max_vec2i32, min_vec4f32, max_vec4f32
export dot_vec2f32, dot_vec4f32
