# StringView - Non-owning string slice
#
# A lightweight, non-owning view into a string. Does not allocate or copy.
# Similar to Rust's &str or C++'s string_view.

# StringView - a non-owning view into a string
struct StringView:
    source: text
    start: i64
    end: i64

    # Create a view of the entire string
    static fn from(s: text) -> StringView:
        return StringView(source: s, start: 0, end: s.len())

    # Create a view of a substring
    static fn slice(s: text, start: i64, end: i64) -> StringView:
        val actual_start = if start < 0: 0 else: start
        val actual_end = if end > s.len(): s.len() else: end
        return StringView(source: s, start: actual_start, end: actual_end)

    # Get the length of the view
    fn len() -> i64:
        return self.end - self.start

    fn is_empty() -> bool:
        return self.len() == 0

    # Convert view to owned string
    fn to_string() -> text:
        return self.source[self.start:self.end]

    # Get character at index within view
    fn char_at(index: i64) -> Option<char>:
        if index < 0 or index >= self.len():
            return Option.none()
        return Option.some(self.source[self.start + index])

    # Get a sub-view
    fn subview(start: i64, end: i64) -> StringView:
        val actual_start = self.start + (if start < 0: 0 else: start)
        val actual_end = self.start + (if end > self.len(): self.len() else: end)
        return StringView(source: self.source, start: actual_start, end: actual_end)

    # Check if view starts with prefix
    fn starts_with(prefix: text) -> bool:
        if prefix.len() > self.len():
            return false
        for i in 0..prefix.len():
            if self.source[self.start + i] != prefix[i]:
                return false
        return true

    # Check if view ends with suffix
    fn ends_with(suffix: text) -> bool:
        if suffix.len() > self.len():
            return false
        val offset = self.len() - suffix.len()
        for i in 0..suffix.len():
            if self.source[self.start + offset + i] != suffix[i]:
                return false
        return true

    # Check if view contains substring
    fn contains(substr: text) -> bool:
        return self.find(substr).is_some()

    # Find first occurrence of substring
    fn find(substr: text) -> Option<i64>:
        if substr.len() > self.len():
            return Option.none()
        for i in 0..(self.len() - substr.len() + 1):
            var found = true
            for j in 0..substr.len():
                if self.source[self.start + i + j] != substr[j]:
                    found = false
                    break
            if found:
                return Option.some(i)
        return Option.none()

    # Trim whitespace from both ends (returns new view)
    fn trim() -> StringView:
        var new_start = self.start
        var new_end = self.end

        while new_start < new_end and self.is_whitespace(self.source[new_start]):
            new_start = new_start + 1

        while new_end > new_start and self.is_whitespace(self.source[new_end - 1]):
            new_end = new_end - 1

        return StringView(source: self.source, start: new_start, end: new_end)

    fn trim_start() -> StringView:
        var new_start = self.start
        while new_start < self.end and self.is_whitespace(self.source[new_start]):
            new_start = new_start + 1
        return StringView(source: self.source, start: new_start, end: self.end)

    fn trim_end() -> StringView:
        var new_end = self.end
        while new_end > self.start and self.is_whitespace(self.source[new_end - 1]):
            new_end = new_end - 1
        return StringView(source: self.source, start: self.start, end: new_end)

    # Split view into parts
    fn split(delimiter: text) -> List<StringView>:
        var result: List<StringView> = []
        var current_start = self.start

        for i in 0..(self.len() - delimiter.len() + 1):
            var is_delimiter = true
            for j in 0..delimiter.len():
                if self.source[self.start + i + j] != delimiter[j]:
                    is_delimiter = false
                    break

            if is_delimiter:
                result.push(StringView(
                    source: self.source,
                    start: current_start,
                    end: self.start + i
                ))
                current_start = self.start + i + delimiter.len()

        result.push(StringView(
            source: self.source,
            start: current_start,
            end: self.end
        ))

        return result

    # Compare with another view
    fn equals(other: StringView) -> bool:
        if self.len() != other.len():
            return false
        for i in 0..self.len():
            if self.source[self.start + i] != other.source[other.start + i]:
                return false
        return true

    fn equals_str(s: text) -> bool:
        return self.equals(StringView.from(s))

    # Private helper
    fn is_whitespace(c: char) -> bool:
        return c == ' ' or c == '\t' or c == '\n' or c == '\r'

pub use StringView
