# Test Database Operations
#
# Provides test database management with atomic operations and locking.
# Mirrors Rust test_db.rs logic for consistency.

use simple_sdn.*
use db.atomic.*

# Test run record for test_runs table
pub struct TestRun:
    run_id: i64
    start_time: text
    end_time: text
    pid: i64
    hostname: text
    status: text
    test_count: i64
    passed: i64
    failed: i64
    crashed: i64
    timed_out: i64

impl TestRun:
    # Create new test run record
    static fn new(
        run_id: i64,
        start_time: text,
        end_time: text,
        test_count: i64,
        passed: i64,
        failed: i64,
        timed_out: i64
    ) -> TestRun:
        TestRun {
            run_id: run_id,
            start_time: start_time,
            end_time: end_time,
            pid: 0,
            hostname: "simple-runner",
            status: "completed",
            test_count: test_count,
            passed: passed,
            failed: failed,
            crashed: 0,
            timed_out: timed_out
        }

    # Convert to SDN row format
    fn to_sdn_row() -> text:
        "        {self.run_id}, \"{self.start_time}\", \"{self.end_time}\", {self.pid}, \"{self.hostname}\", \"{self.status}\", {self.test_count}, {self.passed}, {self.failed}, {self.crashed}, {self.timed_out}"

# Append a test run to the test_db.sdn file atomically
#
# This function safely appends a new test run record using:
# 1. File locking to prevent concurrent access
# 2. Read-modify-write to preserve existing data
# 3. Atomic write to prevent corruption
pub fn append_test_run(
    db_path: text,
    test_run: TestRun
) -> Result<(), text>:
    atomic_update_file(db_path, \content:
        # Check if content is empty or needs test_runs table
        if content.trim() == "":
            # Create new database with test_runs table
            val header = "test_runs |run_id, start_time, end_time, pid, hostname, status, test_count, passed, failed, crashed, timed_out|\n"
            return header + test_run.to_sdn_row() + "\n"

        # Check if test_runs table exists
        if content.contains("test_runs |"):
            # Append to existing test_runs table
            return content.trim() + "\n" + test_run.to_sdn_row() + "\n"
        else:
            # Add test_runs table at the end
            val header = "\ntest_runs |run_id, start_time, end_time, pid, hostname, status, test_count, passed, failed, crashed, timed_out|\n"
            return content.trim() + "\n" + header + test_run.to_sdn_row() + "\n"
    )

# Load test database with locking
pub fn load_test_db(db_path: text) -> Result<text, text>:
    atomic_read_file(db_path)

# Save test database with atomic write and locking
pub fn save_test_db(db_path: text, content: text) -> Result<(), text>:
    atomic_write_file_locked(db_path, content)
