# SC-DRF Memory Model
# Sequentially Consistent - Data Race Free memory model.
#
# This implements Simple's memory consistency guarantee:
# Programs that are data-race-free will observe sequentially consistent behavior.

# Memory ordering for atomic operations
enum MemoryOrder:
    Relaxed    # No ordering constraints
    Acquire    # Prevents reordering of later reads
    Release    # Prevents reordering of earlier writes
    AcqRel     # Both acquire and release
    SeqCst     # Sequentially consistent

    fn is_relaxed() -> bool:
        """Check if this is Relaxed ordering.
        Returns: true for Relaxed
        Example: MemoryOrder.Relaxed.is_relaxed()  # → true
        """
        match self:
            case Relaxed: true
            case _: false

    fn is_acquire() -> bool:
        """Check if this is Acquire ordering.
        Returns: true for Acquire
        Example: MemoryOrder.Acquire.is_acquire()  # → true
        """
        match self:
            case Acquire: true
            case _: false

    fn is_release() -> bool:
        """Check if this is Release ordering.
        Returns: true for Release
        Example: MemoryOrder.Release.is_release()  # → true
        """
        match self:
            case Release: true
            case _: false

    fn is_acq_rel() -> bool:
        """Check if this is AcqRel ordering.
        Returns: true for AcqRel
        Example: MemoryOrder.AcqRel.is_acq_rel()  # → true
        """
        match self:
            case AcqRel: true
            case _: false

    fn is_seq_cst() -> bool:
        """Check if this is SeqCst ordering.
        Returns: true for SeqCst
        Example: MemoryOrder.SeqCst.is_seq_cst()  # → true
        """
        match self:
            case SeqCst: true
            case _: false

    fn has_acquire_semantics() -> bool:
        """Check if this ordering has acquire semantics.
        Acquire semantics prevent reordering of later reads.
        Returns: true for Acquire, AcqRel, or SeqCst
        Example: MemoryOrder.Acquire.has_acquire_semantics()  # → true
        """
        match self:
            case Acquire: true
            case AcqRel: true
            case SeqCst: true
            case _: false

    fn has_release_semantics() -> bool:
        """Check if this ordering has release semantics.
        Release semantics prevent reordering of earlier writes.
        Returns: true for Release, AcqRel, or SeqCst
        Example: MemoryOrder.Release.has_release_semantics()  # → true
        """
        match self:
            case Release: true
            case AcqRel: true
            case SeqCst: true
            case _: false

    fn is_weakest() -> bool:
        """Check if this is the weakest ordering (Relaxed).
        Returns: true for Relaxed
        Example: MemoryOrder.Relaxed.is_weakest()  # → true
        """
        match self:
            case Relaxed: true
            case _: false

    fn is_strongest() -> bool:
        """Check if this is the strongest ordering (SeqCst).
        Returns: true for SeqCst
        Example: MemoryOrder.SeqCst.is_strongest()  # → true
        """
        match self:
            case SeqCst: true
            case _: false

    fn to_string() -> text:
        """Convert MemoryOrder to string representation.
        Returns: lowercase string name
        Example: MemoryOrder.Acquire.to_string()  # → "acquire"
        """
        match self:
            case Relaxed: "relaxed"
            case Acquire: "acquire"
            case Release: "release"
            case AcqRel: "acq_rel"
            case SeqCst: "seq_cst"

    fn description() -> text:
        """Get human-readable description of the memory ordering.
        Returns: descriptive explanation
        Example: MemoryOrder.Acquire.description()  # → "Prevents reordering of later reads"
        """
        match self:
            case Relaxed: "No ordering constraints"
            case Acquire: "Prevents reordering of later reads"
            case Release: "Prevents reordering of earlier writes"
            case AcqRel: "Both acquire and release semantics"
            case SeqCst: "Sequentially consistent ordering"

    fn summary() -> text:
        """Get comprehensive summary of the memory ordering.
        Returns: summary with name, description, and properties
        Example: MemoryOrder.AcqRel.summary()
                # → "MemoryOrder: acq_rel (Both acquire and release semantics, acquire semantics, release semantics)"
        """
        val name = self.to_string()
        val desc = self.description()
        var props = []

        if self.has_acquire_semantics():
            props.push("acquire semantics")
        if self.has_release_semantics():
            props.push("release semantics")
        if self.is_weakest():
            props.push("weakest ordering")
        if self.is_strongest():
            props.push("strongest ordering")

        val props_str = if props.len() > 0:
            ", " + props.join(", ")
        else:
            ""

        "MemoryOrder: {name} ({desc}{props_str})"

# Memory location identifier
class MemoryLocation:
    address: i32
    size: i32
    is_atomic: bool

    fn new(address: i32, size: i32) -> MemoryLocation:
        MemoryLocation(address: address, size: size, is_atomic: false)

    fn atomic(address: i32, size: i32) -> MemoryLocation:
        MemoryLocation(address: address, size: size, is_atomic: true)

    # Check if two locations overlap
    fn overlaps(other: MemoryLocation) -> bool:
        val self_end = self.address + self.size
        val other_end = other.address + other.size
        self.address < other_end and other.address < self_end

# Memory access kind
enum AccessKind:
    Read
    Write
    ReadWrite  # Atomic RMW operations

    fn is_read_only() -> bool:
        """Check if this is Read-only access.
        Returns: true for Read
        Example: AccessKind.Read.is_read_only()  # → true
        """
        match self:
            case Read: true
            case _: false

    fn is_write_only() -> bool:
        """Check if this is Write-only access.
        Returns: true for Write
        Example: AccessKind.Write.is_write_only()  # → true
        """
        match self:
            case Write: true
            case _: false

    fn is_read_write() -> bool:
        """Check if this is ReadWrite (RMW) access.
        Returns: true for ReadWrite
        Example: AccessKind.ReadWrite.is_read_write()  # → true
        """
        match self:
            case ReadWrite: true
            case _: false

    fn is_write() -> bool:
        """Check if this access includes writes.
        Returns: true for Write or ReadWrite
        Example: AccessKind.Write.is_write()  # → true
        """
        match self:
            case Write: true
            case ReadWrite: true
            case Read: false

    fn is_read() -> bool:
        """Check if this access includes reads.
        Returns: true for Read or ReadWrite
        Example: AccessKind.Read.is_read()  # → true
        """
        match self:
            case Read: true
            case ReadWrite: true
            case Write: false

    fn is_atomic_rmw() -> bool:
        """Check if this is an atomic read-modify-write operation.
        Returns: true for ReadWrite
        Example: AccessKind.ReadWrite.is_atomic_rmw()  # → true
        """
        match self:
            case ReadWrite: true
            case _: false

    fn can_conflict_with(other: AccessKind) -> bool:
        """Check if this access can conflict with another.
        Two accesses conflict if at least one is a write.
        Returns: true if at least one is a write
        Example: AccessKind.Write.can_conflict_with(AccessKind.Read)  # → true
        """
        self.is_write() or other.is_write()

    fn to_string() -> text:
        """Convert AccessKind to string representation.
        Returns: lowercase string name
        Example: AccessKind.ReadWrite.to_string()  # → "read_write"
        """
        match self:
            case Read: "read"
            case Write: "write"
            case ReadWrite: "read_write"

    fn description() -> text:
        """Get human-readable description of the access kind.
        Returns: descriptive explanation
        Example: AccessKind.ReadWrite.description()  # → "Atomic read-modify-write operation"
        """
        match self:
            case Read: "Read-only access"
            case Write: "Write-only access"
            case ReadWrite: "Atomic read-modify-write operation"

    fn summary() -> text:
        """Get comprehensive summary of the access kind.
        Returns: summary with name, description, and properties
        Example: AccessKind.ReadWrite.summary()
                # → "AccessKind: read_write (Atomic read-modify-write operation, reads, writes, atomic RMW)"
        """
        val name = self.to_string()
        val desc = self.description()
        var props = []

        if self.is_read():
            props.push("reads")
        if self.is_write():
            props.push("writes")
        if self.is_atomic_rmw():
            props.push("atomic RMW")

        val props_str = if props.len() > 0:
            ", " + props.join(", ")
        else:
            ""

        "AccessKind: {name} ({desc}{props_str})"

# Memory access event
class MemoryAccess:
    thread_id: i32
    location: MemoryLocation
    kind: AccessKind
    order: MemoryOrder
    timestamp: i32

    fn new(thread_id: i32, location: MemoryLocation, kind: AccessKind) -> MemoryAccess:
        MemoryAccess(
            thread_id: thread_id,
            location: location,
            kind: kind,
            order: MemoryOrder.SeqCst,
            timestamp: 0
        )

    var fn with_order(order: MemoryOrder) -> MemoryAccess:
        self.order = order
        self

    var fn with_timestamp(timestamp: i32) -> MemoryAccess:
        self.timestamp = timestamp
        self

# Data race - two conflicting accesses
class DataRace:
    access1: MemoryAccess
    access2: MemoryAccess
    message: text

    fn new(access1: MemoryAccess, access2: MemoryAccess) -> DataRace:
        DataRace(
            access1: access1,
            access2: access2,
            message: "Data race between threads {access1.thread_id} and {access2.thread_id}"
        )

# Check if two accesses conflict (potential data race)
fn accesses_conflict(a1: MemoryAccess, a2: MemoryAccess) -> bool:
    # Same thread - no conflict
    if a1.thread_id == a2.thread_id:
        return false

    # Must access overlapping locations
    if not a1.location.overlaps(a2.location):
        return false

    # At least one must be a write
    if not (a1.kind.is_write() or a2.kind.is_write()):
        return false

    # Atomic accesses with proper ordering don't conflict
    if a1.location.is_atomic and a2.location.is_atomic:
        return false

    true

# Happens-before relationship
class HappensBefore:
    earlier: MemoryAccess
    later: MemoryAccess

    fn new(earlier: MemoryAccess, later: MemoryAccess) -> HappensBefore:
        HappensBefore(earlier: earlier, later: later)

# Synchronization event
enum SyncEvent:
    Lock(mutex_id: i32)
    Unlock(mutex_id: i32)
    Spawn(child_thread: i32)
    Join(child_thread: i32)
    Send(channel_id: i32)
    Recv(channel_id: i32)
    Fence(order: MemoryOrder)

impl SyncEvent:
    fn is_lock() -> bool:
        """Check if this is a Lock event.
        Returns: true for Lock
        Example: SyncEvent.Lock(1).is_lock()  # → true
        """
        match self:
            case Lock(_): true
            case _: false

    fn is_unlock() -> bool:
        """Check if this is an Unlock event.
        Returns: true for Unlock
        Example: SyncEvent.Unlock(1).is_unlock()  # → true
        """
        match self:
            case Unlock(_): true
            case _: false

    fn is_spawn() -> bool:
        """Check if this is a Spawn event.
        Returns: true for Spawn
        Example: SyncEvent.Spawn(2).is_spawn()  # → true
        """
        match self:
            case Spawn(_): true
            case _: false

    fn is_join() -> bool:
        """Check if this is a Join event.
        Returns: true for Join
        Example: SyncEvent.Join(2).is_join()  # → true
        """
        match self:
            case Join(_): true
            case _: false

    fn is_send() -> bool:
        """Check if this is a Send event.
        Returns: true for Send
        Example: SyncEvent.Send(3).is_send()  # → true
        """
        match self:
            case Send(_): true
            case _: false

    fn is_recv() -> bool:
        """Check if this is a Recv event.
        Returns: true for Recv
        Example: SyncEvent.Recv(3).is_recv()  # → true
        """
        match self:
            case Recv(_): true
            case _: false

    fn is_fence() -> bool:
        """Check if this is a Fence event.
        Returns: true for Fence
        Example: SyncEvent.Fence(MemoryOrder.SeqCst).is_fence()  # → true
        """
        match self:
            case Fence(_): true
            case _: false

    fn is_mutex_op() -> bool:
        """Check if this is a mutex operation.
        Returns: true for Lock or Unlock
        Example: SyncEvent.Lock(1).is_mutex_op()  # → true
        """
        match self:
            case Lock(_): true
            case Unlock(_): true
            case _: false

    fn is_thread_op() -> bool:
        """Check if this is a thread operation.
        Returns: true for Spawn or Join
        Example: SyncEvent.Spawn(2).is_thread_op()  # → true
        """
        match self:
            case Spawn(_): true
            case Join(_): true
            case _: false

    fn is_channel_op() -> bool:
        """Check if this is a channel operation.
        Returns: true for Send or Recv
        Example: SyncEvent.Send(3).is_channel_op()  # → true
        """
        match self:
            case Send(_): true
            case Recv(_): true
            case _: false

    fn is_acquire_sync() -> bool:
        """Check if this provides acquire semantics.
        Acquire synchronization receives ordering from other threads.
        Returns: true for Lock, Join, or Recv
        Example: SyncEvent.Lock(1).is_acquire_sync()  # → true
        """
        match self:
            case Lock(_): true
            case Join(_): true
            case Recv(_): true
            case _: false

    fn is_release_sync() -> bool:
        """Check if this provides release semantics.
        Release synchronization sends ordering to other threads.
        Returns: true for Unlock, Spawn, or Send
        Example: SyncEvent.Unlock(1).is_release_sync()  # → true
        """
        match self:
            case Unlock(_): true
            case Spawn(_): true
            case Send(_): true
            case _: false

    fn to_string() -> text:
        """Convert SyncEvent to string representation.
        Returns: event name with parameter
        Example: SyncEvent.Lock(1).to_string()  # → "lock(1)"
        """
        match self:
            case Lock(id): "lock({id})"
            case Unlock(id): "unlock({id})"
            case Spawn(tid): "spawn({tid})"
            case Join(tid): "join({tid})"
            case Send(id): "send({id})"
            case Recv(id): "recv({id})"
            case Fence(order): "fence({order.to_string()})"

    fn description() -> text:
        """Get human-readable description of the sync event.
        Returns: descriptive explanation
        Example: SyncEvent.Lock(1).description()  # → "Acquire mutex lock"
        """
        match self:
            case Lock(_): "Acquire mutex lock"
            case Unlock(_): "Release mutex lock"
            case Spawn(_): "Spawn child thread"
            case Join(_): "Join with child thread"
            case Send(_): "Send on channel"
            case Recv(_): "Receive from channel"
            case Fence(_): "Memory fence"

    fn summary() -> text:
        """Get comprehensive summary of the sync event.
        Returns: summary with name, description, and synchronization properties
        Example: SyncEvent.Lock(1).summary()
                # → "SyncEvent: lock(1) (Acquire mutex lock, mutex op, acquire sync)"
        """
        val name = self.to_string()
        val desc = self.description()
        var props = []

        if self.is_mutex_op():
            props.push("mutex op")
        if self.is_thread_op():
            props.push("thread op")
        if self.is_channel_op():
            props.push("channel op")
        if self.is_acquire_sync():
            props.push("acquire sync")
        if self.is_release_sync():
            props.push("release sync")

        val props_str = if props.len() > 0:
            ", " + props.join(", ")
        else:
            ""

        "SyncEvent: {name} ({desc}{props_str})"

# Thread state for race detection
class ThreadState:
    thread_id: i32
    accesses: List<MemoryAccess>
    sync_events: List<SyncEvent>
    vector_clock: Dict<i32, i32>  # Thread ID -> logical time

    fn new(thread_id: i32) -> ThreadState:
        var vc: Dict<i32, i32> = {}
        vc[thread_id] = 0
        ThreadState(
            thread_id: thread_id,
            accesses: [],
            sync_events: [],
            vector_clock: vc
        )

    var fn tick():
        val current = self.vector_clock.get(self.thread_id).unwrap_or(0)
        self.vector_clock[self.thread_id] = current + 1

    fn get_time() -> i32:
        self.vector_clock.get(self.thread_id).unwrap_or(0)

    var fn merge_clock(other_clock: Dict<i32, i32>):
        for (tid, time) in other_clock:
            val my_time = self.vector_clock.get(tid).unwrap_or(0)
            if time > my_time:
                self.vector_clock[tid] = time

    fn happens_before(other: ThreadState) -> bool:
        # self happens-before other if all entries in self's clock <= other's
        for (tid, time) in self.vector_clock:
            val other_time = other.vector_clock.get(tid).unwrap_or(0)
            if time > other_time:
                return false
        true

    var fn record_access(location: MemoryLocation, kind: AccessKind, order: MemoryOrder):
        self.tick()
        val access = MemoryAccess.new(self.thread_id, location, kind)
            .with_order(order)
            .with_timestamp(self.get_time())
        self.accesses.push(access)

# Race detector state
class RaceDetector:
    threads: Dict<i32, ThreadState>
    races: List<DataRace>
    enabled: bool

    static fn new() -> RaceDetector:
        RaceDetector(threads: {}, races: [], enabled: true)

    var fn get_or_create_thread(thread_id: i32) -> ThreadState:
        match self.threads.get(thread_id):
            case Some(state):
                state
            case None:
                val state = ThreadState.new(thread_id)
                self.threads[thread_id] = state
                state

    var fn record_access(thread_id: i32, location: MemoryLocation, kind: AccessKind, order: MemoryOrder):
        if not self.enabled:
            return

        val thread = self.get_or_create_thread(thread_id)
        thread.record_access(location, kind, order)

        # Check for races with other threads
        for (other_id, other_thread) in self.threads:
            if other_id == thread_id:
                continue

            for other_access in other_thread.accesses:
                if accesses_conflict(thread.accesses.last().unwrap(), other_access):
                    # Check happens-before
                    if not thread.happens_before(other_thread) and not other_thread.happens_before(thread):
                        val race = DataRace.new(
                            thread.accesses.last().unwrap(),
                            other_access
                        )
                        self.races.push(race)

    var fn record_sync(thread_id: i32, event: SyncEvent):
        val thread = self.get_or_create_thread(thread_id)
        thread.sync_events.push(event)

        # Update happens-before based on sync event
        match event:
            case SyncEvent.Spawn(child_thread):
                val child = self.get_or_create_thread(child_thread)
                child.merge_clock(thread.vector_clock)
            case SyncEvent.Join(child_thread):
                match self.threads.get(child_thread):
                    case Some(child):
                        thread.merge_clock(child.vector_clock)
                    case None:
                        pass
            case _:
                pass

    fn has_races() -> bool:
        self.races.len() > 0

    fn get_races() -> List<DataRace>:
        self.races

# SC-DRF guarantee checker
class SCDRFChecker:
    detector: RaceDetector

    static fn new() -> SCDRFChecker:
        SCDRFChecker(detector: RaceDetector.new())

    var fn check_program(accesses: List<MemoryAccess>, syncs: List<(i32, SyncEvent)>) -> bool:
        # Record all sync events first
        for (thread_id, event) in syncs:
            self.detector.record_sync(thread_id, event)

        # Then check accesses for races
        for access in accesses:
            self.detector.record_access(
                access.thread_id,
                access.location,
                access.kind,
                access.order
            )

        not self.detector.has_races()

    fn get_violations() -> List<DataRace>:
        self.detector.get_races()
