# GC Manual Borrow Model
#
# Formal model for garbage collection with manual borrow tracking.
# Mirrors: verification/gc_manual_borrow/src/GcManualBorrow.lean

# Object identifier
class ObjId:
    id: i32

    fn create(id: i32) -> ObjId:
        return ObjId(id)

    fn to_lean() -> text:
        return "ObjId.mk " + str(self.id)

# Borrow status
enum BorrowStatus:
    Unborrowed
    ImmutBorrowed(count: i32)
    MutBorrowed

    fn is_unborrowed() -> bool:
        """Check if this is Unborrowed status.
        Returns: true for Unborrowed
        Example: BorrowStatus.Unborrowed.is_unborrowed()  # → true
        """
        match self:
            case Unborrowed: true
            case _: false

    fn is_immut_borrowed() -> bool:
        """Check if this is ImmutBorrowed status.
        Returns: true for ImmutBorrowed
        Example: BorrowStatus.ImmutBorrowed(2).is_immut_borrowed()  # → true
        """
        match self:
            case ImmutBorrowed(_): true
            case _: false

    fn is_mut_borrowed() -> bool:
        """Check if this is MutBorrowed status.
        Returns: true for MutBorrowed
        Example: BorrowStatus.MutBorrowed.is_mut_borrowed()  # → true
        """
        match self:
            case MutBorrowed: true
            case _: false

    fn is_borrowed() -> bool:
        """Check if object has any active borrows.
        Returns: true for ImmutBorrowed or MutBorrowed
        Example: BorrowStatus.ImmutBorrowed(1).is_borrowed()  # → true
        """
        match self:
            case Unborrowed: false
            case _: true

    fn allows_immut_borrow() -> bool:
        """Check if can create new immutable borrow.
        Immutable borrows allowed when unborrowed or already immutably borrowed.
        Returns: true for Unborrowed or ImmutBorrowed
        Example: BorrowStatus.ImmutBorrowed(2).allows_immut_borrow()  # → true
        """
        match self:
            case Unborrowed: true
            case ImmutBorrowed(_): true
            case MutBorrowed: false

    fn allows_mut_borrow() -> bool:
        """Check if can create new mutable borrow.
        Mutable borrows only allowed when unborrowed.
        Returns: true for Unborrowed
        Example: BorrowStatus.Unborrowed.allows_mut_borrow()  # → true
        """
        match self:
            case Unborrowed: true
            case _: false

    fn is_exclusive() -> bool:
        """Check if borrow has exclusive access.
        Returns: true for MutBorrowed
        Example: BorrowStatus.MutBorrowed.is_exclusive()  # → true
        """
        match self:
            case MutBorrowed: true
            case _: false

    fn is_shared() -> bool:
        """Check if borrow is shared (multiple readers).
        Returns: true for ImmutBorrowed
        Example: BorrowStatus.ImmutBorrowed(3).is_shared()  # → true
        """
        match self:
            case ImmutBorrowed(_): true
            case _: false

    fn get_borrow_count() -> i32:
        """Get number of active immutable borrows.
        Returns: count for ImmutBorrowed, 0 for others
        Example: BorrowStatus.ImmutBorrowed(3).get_borrow_count()  # → 3
        """
        match self:
            case ImmutBorrowed(n): n
            case _: 0

    fn has_multiple_borrows() -> bool:
        """Check if multiple immutable borrows exist.
        Returns: true if ImmutBorrowed with count > 1
        Example: BorrowStatus.ImmutBorrowed(2).has_multiple_borrows()  # → true
        """
        match self:
            case ImmutBorrowed(n): n > 1
            case _: false

    fn to_string() -> text:
        """Convert BorrowStatus to string representation.
        Returns: string name with count for ImmutBorrowed
        Example: BorrowStatus.ImmutBorrowed(2).to_string()  # → "immut_borrowed(2)"
        """
        match self:
            case Unborrowed: "unborrowed"
            case ImmutBorrowed(n): "immut_borrowed({n})"
            case MutBorrowed: "mut_borrowed"

    fn description() -> text:
        """Get human-readable description of the borrow status.
        Returns: descriptive explanation
        Example: BorrowStatus.MutBorrowed.description()  # → "Mutably borrowed (exclusive access)"
        """
        match self:
            case Unborrowed: "Not borrowed (available)"
            case ImmutBorrowed(n): "Immutably borrowed ({n} active borrows)"
            case MutBorrowed: "Mutably borrowed (exclusive access)"

    fn summary() -> text:
        """Get comprehensive summary of the borrow status.
        Returns: summary with status, description, and properties
        Example: BorrowStatus.ImmutBorrowed(2).summary()
                # → "BorrowStatus: immut_borrowed(2) (Immutably borrowed (2 active borrows), borrowed, shared, allows immut borrow)"
        """
        val name = self.to_string()
        val desc = self.description()
        var props = []

        if self.is_borrowed():
            props.push("borrowed")
        if self.is_exclusive():
            props.push("exclusive")
        if self.is_shared():
            props.push("shared")
        if self.allows_immut_borrow():
            props.push("allows immut borrow")
        if self.allows_mut_borrow():
            props.push("allows mut borrow")
        if self.has_multiple_borrows():
            props.push("multiple borrows")

        val props_str = if props.len() > 0:
            ", " + props.join(", ")
        else:
            ""

        "BorrowStatus: {name} ({desc}{props_str})"

    fn to_lean() -> text:
        """Convert to Lean 4 representation.
        Returns: Lean syntax for this borrow status
        Example: BorrowStatus.ImmutBorrowed(2).to_lean()  # → "BorrowStatus.immutBorrowed 2"
        """
        match self:
            case Unborrowed: return "BorrowStatus.unborrowed"
            case ImmutBorrowed(n): return "BorrowStatus.immutBorrowed " + str(n)
            case MutBorrowed: return "BorrowStatus.mutBorrowed"

# Object state in the heap
class ObjState:
    id: ObjId
    borrow_status: BorrowStatus
    ref_count: i32
    is_rooted: bool

    fn create(id: ObjId) -> ObjState:
        return ObjState(id, BorrowStatus.Unborrowed, 1, True)

    fn to_lean() -> text:
        rooted = "false"
        if self.is_rooted:
            rooted = "true"
        return "{{ id := " + self.id.to_lean() + ", borrowStatus := " + self.borrow_status.to_lean() + ", refCount := " + str(self.ref_count) + ", isRooted := " + rooted + " }}"

# GC Heap
class GcHeap:
    objects: List<ObjState>
    next_id: i32

    fn create() -> GcHeap:
        return GcHeap([], 0)

    fn allocate() -> (GcHeap, ObjId):
        new_id = ObjId.create(self.next_id)
        new_obj = ObjState.create(new_id)
        new_objects = self.objects.append(new_obj)
        return (
            GcHeap(new_objects, self.next_id + 1),
            new_id
        )

    fn find_object(id: ObjId) -> ObjState | None:
        for obj in self.objects:
            if obj.id.id == id.id:
                return obj
        return None

    fn update_object(id: ObjId, new_state: ObjState) -> GcHeap:
        new_objects = []
        for obj in self.objects:
            if obj.id.id == id.id:
                new_objects.append(new_state)
            else:
                new_objects.append(obj)
        return GcHeap(new_objects, self.next_id)

# Borrow operations
fn try_immut_borrow(heap: GcHeap, id: ObjId) -> (GcHeap, bool):
    obj = heap.find_object(id)
    if obj is None:
        return (heap, False)

    match obj.borrow_status:
        case BorrowStatus.Unborrowed:
            new_obj = ObjState(obj.id, BorrowStatus.ImmutBorrowed(1), obj.ref_count, obj.is_rooted)
            return (heap.update_object(id, new_obj), True)
        case BorrowStatus.ImmutBorrowed(n):
            new_obj = ObjState(obj.id, BorrowStatus.ImmutBorrowed(n + 1), obj.ref_count, obj.is_rooted)
            return (heap.update_object(id, new_obj), True)
        case BorrowStatus.MutBorrowed:
            return (heap, False)

fn try_mut_borrow(heap: GcHeap, id: ObjId) -> (GcHeap, bool):
    obj = heap.find_object(id)
    if obj is None:
        return (heap, False)

    match obj.borrow_status:
        case BorrowStatus.Unborrowed:
            new_obj = ObjState(obj.id, BorrowStatus.MutBorrowed, obj.ref_count, obj.is_rooted)
            return (heap.update_object(id, new_obj), True)
        case _:
            return (heap, False)

fn release_borrow(heap: GcHeap, id: ObjId) -> GcHeap:
    obj = heap.find_object(id)
    if obj is None:
        return heap

    match obj.borrow_status:
        case BorrowStatus.ImmutBorrowed(n):
            new_status = BorrowStatus.ImmutBorrowed(n - 1)
            if n <= 1:
                new_status = BorrowStatus.Unborrowed
            new_obj = ObjState(obj.id, new_status, obj.ref_count, obj.is_rooted)
            return heap.update_object(id, new_obj)
        case BorrowStatus.MutBorrowed:
            new_obj = ObjState(obj.id, BorrowStatus.Unborrowed, obj.ref_count, obj.is_rooted)
            return heap.update_object(id, new_obj)
        case _:
            return heap

# Specification functions

fn borrow_exclusivity_spec() -> text:
    return "theorem borrow_exclusivity : ∀ heap obj, obj.borrowStatus = mutBorrowed → ¬∃ other, other ≠ obj ∧ borrows heap other obj"

fn gc_safety_spec() -> text:
    return "theorem gc_safety : ∀ heap obj, is_reachable heap obj → ¬is_collected heap obj"
