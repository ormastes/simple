# Lean Naming Conventions
#
# Consistent identifier transformation functions for Simple to Lean translation:
# - PascalCase for types, classes, structures, and theorems
# - camelCase for functions, methods, and variables
# - Reserved word escaping with guillemets

# Lean reserved keywords that need escaping with guillemets
val LEAN_RESERVED: List<text> = [
    "let", "in", "if", "then", "else", "do", "return", "match", "with",
    "def", "theorem", "lemma", "example", "structure", "class", "instance",
    "where", "fun", "forall", "exists", "namespace", "section", "variable",
    "open", "import", "inductive", "mutual", "end", "private", "protected",
    "Type", "Prop", "Sort", "by", "have", "show", "from", "at", "as"
]

# Convert a snake_case Simple name to PascalCase for Lean types/theorems.
#
# Examples:
#   to_pascal_case("my_type") => "MyType"
#   to_pascal_case("simple") => "Simple"
#   to_pascal_case("ref_capability") => "RefCapability"
fn to_pascal_case(name: text) -> text:
    if name.len() == 0:
        return ""

    var result = ""
    var capitalize_next = true

    for c in name:
        if c == "_":
            capitalize_next = true
        else if capitalize_next:
            result = result + c.upper()
            capitalize_next = false
        else:
            result = result + c

    result

# Convert a snake_case Simple name to camelCase for Lean functions/variables.
#
# Examples:
#   to_camel_case("my_function") => "myFunction"
#   to_camel_case("get_value") => "getValue"
#   to_camel_case("simple") => "simple"
fn to_camel_case(name: text) -> text:
    if name.len() == 0:
        return ""

    var result = ""
    var capitalize_next = false
    var is_first = true

    for c in name:
        if c == "_":
            capitalize_next = true
        else if capitalize_next:
            result = result + c.upper()
            capitalize_next = false
        else if is_first:
            result = result + c.lower()
            is_first = false
        else:
            result = result + c

    result

# Check if a name is a Lean reserved word
fn is_reserved(name: text) -> bool:
    for reserved in LEAN_RESERVED:
        if name == reserved:
            return true
    false

# Sanitize an identifier for Lean by escaping reserved words.
# Lean reserved keywords are escaped with guillemets.
#
# Examples:
#   sanitize_lean_ident("let") => "let"
#   sanitize_lean_ident("def") => "def"
#   sanitize_lean_ident("myVar") => "myVar"
fn sanitize_lean_ident(name: text) -> text:
    if is_reserved(name):
        "«{name}»"  # Wrap with guillemets
    else:
        name

# Convert to PascalCase and sanitize for Lean identifiers.
# Used for type names, class names, structure names.
#
# Examples:
#   to_lean_type_name("my_type") => "MyType"
#   to_lean_type_name("type") => "Type"
fn to_lean_type_name(name: text) -> text:
    sanitize_lean_ident(to_pascal_case(name))

# Convert to camelCase and sanitize for Lean identifiers.
# Used for function names, variable names, field names.
#
# Examples:
#   to_lean_func_name("my_function") => "myFunction"
#   to_lean_func_name("let") => "let"
fn to_lean_func_name(name: text) -> text:
    sanitize_lean_ident(to_camel_case(name))

# Convert a Simple module path to Lean namespace.
# Replaces dots with underscores and converts to PascalCase.
#
# Examples:
#   to_lean_namespace("std.collections") => "Std.Collections"
fn to_lean_namespace(path: text) -> text:
    val parts = path.split(".")
    var result: List<text> = []
    for part in parts:
        result = result + [to_pascal_case(part)]
    result.join(".")

# Convert a Simple identifier to a valid Lean identifier.
# Handles special characters and ensures valid Lean syntax.
fn to_lean_ident(name: text) -> text:
    var result = ""
    for c in name:
        if c == "-":
            result = result + "_"
        else if c == " ":
            result = result + "_"
        else if c.is_alphanumeric() or c == "_":
            result = result + c
        # Skip other special characters

    if result.len() == 0:
        return "unnamed"

    # Ensure doesn't start with a digit
    val first = result[0]
    if first.is_digit():
        result = "_" + result

    sanitize_lean_ident(result)

# Export public API
pub use LEAN_RESERVED
pub use to_pascal_case, to_camel_case
pub use is_reserved, sanitize_lean_ident
pub use to_lean_type_name, to_lean_func_name
pub use to_lean_namespace, to_lean_ident
