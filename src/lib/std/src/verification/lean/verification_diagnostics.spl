# Verification Diagnostics and Error Codes
#
# Defines error codes for Lean verification mode violations:
# - V-AOP-xxx: AOP constraint violations
# - V-MACRO-xxx: Macro constraint violations
# - V-TERM-xxx: Termination requirement violations
# - V-UNSAFE-xxx: Unsafe code in verified context
# - V-DEP-xxx: Dependency boundary violations
# - V-INHERIT-xxx: Verification inheritance violations
# - M-INTRO-xxx: Macro introduction contract violations

# Span represents a source code location
class Span:
    start: i32
    end: i32
    line: i32
    column: i32

    static fn new(start: i32, end: i32, line: i32, column: i32) -> Span:
        Span(start, end, line, column)

    static fn empty() -> Span:
        Span(0, 0, 0, 0)

# Severity levels for diagnostics
enum Severity:
    Error
    Warning
    Note
    Help

# Verification error codes
enum VerificationErrorCode:
    # AOP constraint violations
    AopNonGhostTargetsVerified   # V-AOP-001
    AopWildcardInVerified        # V-AOP-002
    AopIntroducesRuntime         # V-AOP-003

    # Macro constraint violations
    MacroUndeclaredIntroduction  # M-INTRO-001
    MacroIntroducesPub           # V-MACRO-001
    MacroIntroducesGlobal        # V-MACRO-002
    MacroIntroducesRuntime       # V-MACRO-003
    MacroAopViolation            # V-MACRO-004

    # Termination requirements
    MissingTermination           # V-TERM-001
    InvalidTermination           # V-TERM-002

    # Unsafe code violations
    UnsafeInVerified             # V-UNSAFE-001
    RawPointerInVerified         # V-UNSAFE-002
    FfiInVerified                # V-UNSAFE-003

    # Dependency violations
    MissingTrustedBoundary       # V-DEP-001
    CircularVerifiedDep          # V-DEP-002

    # Inheritance violations
    VerifiedInheritanceOptOut    # V-INHERIT-001
    VerifiedExtendsUnverified    # V-INHERIT-002

    # Effect violations
    IoInVerified                 # V-EFFECT-001
    ReflectionInVerified         # V-EFFECT-002

    # Contract violations
    GhostAccessesNonGhost        # V-GHOST-001
    ContractHasSideEffects       # V-CONTRACT-001

impl VerificationErrorCode:
    # Get the string code (e.g., "V-AOP-001")
    fn code() -> text:
        match self:
            case AopNonGhostTargetsVerified: "V-AOP-001"
            case AopWildcardInVerified: "V-AOP-002"
            case AopIntroducesRuntime: "V-AOP-003"
            case MacroUndeclaredIntroduction: "M-INTRO-001"
            case MacroIntroducesPub: "V-MACRO-001"
            case MacroIntroducesGlobal: "V-MACRO-002"
            case MacroIntroducesRuntime: "V-MACRO-003"
            case MacroAopViolation: "V-MACRO-004"
            case MissingTermination: "V-TERM-001"
            case InvalidTermination: "V-TERM-002"
            case UnsafeInVerified: "V-UNSAFE-001"
            case RawPointerInVerified: "V-UNSAFE-002"
            case FfiInVerified: "V-UNSAFE-003"
            case MissingTrustedBoundary: "V-DEP-001"
            case CircularVerifiedDep: "V-DEP-002"
            case VerifiedInheritanceOptOut: "V-INHERIT-001"
            case VerifiedExtendsUnverified: "V-INHERIT-002"
            case IoInVerified: "V-EFFECT-001"
            case ReflectionInVerified: "V-EFFECT-002"
            case GhostAccessesNonGhost: "V-GHOST-001"
            case ContractHasSideEffects: "V-CONTRACT-001"

    # Get the default message for this error
    fn message() -> text:
        match self:
            case AopNonGhostTargetsVerified: "non-ghost aspect targets verified join point"
            case AopWildcardInVerified: "verified pointcut uses wildcard pattern"
            case AopIntroducesRuntime: "aspect introduces runtime member in verified context"
            case MacroUndeclaredIntroduction: "macro introduces symbols not declared in `introduces:` clause"
            case MacroIntroducesPub: "macro introduces public item in verified context"
            case MacroIntroducesGlobal: "macro introduces global variable in verified context"
            case MacroIntroducesRuntime: "macro introduces runtime code in verified context"
            case MacroAopViolation: "macro-generated aspect violates verification rules"
            case MissingTermination: "recursive function missing `decreases:` clause"
            case InvalidTermination: "termination argument is not well-founded"
            case UnsafeInVerified: "unsafe operation in verified context"
            case RawPointerInVerified: "raw pointer operation in verified context"
            case FfiInVerified: "FFI call in verified context"
            case MissingTrustedBoundary: "verified code depends on unverified code without @trusted boundary"
            case CircularVerifiedDep: "circular dependency in verification context"
            case VerifiedInheritanceOptOut: "opt-out from verified parent requires explicit @unsafe"
            case VerifiedExtendsUnverified: "verified class cannot extend unverified class"
            case IoInVerified: "IO effect not allowed in verified context"
            case ReflectionInVerified: "reflection not allowed in verified context"
            case GhostAccessesNonGhost: "ghost code cannot access non-ghost state"
            case ContractHasSideEffects: "contract expression must be pure (no side effects)"

    # Get the help text for this error
    fn help() -> text:
        match self:
            case AopNonGhostTargetsVerified: "mark the aspect with `ghost` to allow it in verified context"
            case AopWildcardInVerified: "use explicit pointcuts instead of wildcards for verified code"
            case AopIntroducesRuntime: "only ghost introductions are allowed in verified context"
            case MacroUndeclaredIntroduction: "add all introduced symbols to the `introduces:` clause"
            case MacroIntroducesPub: "macros in verified context can only introduce private items"
            case MacroIntroducesGlobal: "use local variables instead of global state"
            case MacroIntroducesRuntime: "macros in verified context can only introduce ghost code"
            case MacroAopViolation: "ensure macro-generated aspects are marked ghost"
            case MissingTermination: "add `decreases: <expr>` to prove termination"
            case InvalidTermination: "ensure the decreases expression decreases on each recursive call"
            case UnsafeInVerified: "remove unsafe operations or move to @trusted function"
            case RawPointerInVerified: "use references instead of raw pointers"
            case FfiInVerified: "wrap FFI calls in @trusted functions"
            case MissingTrustedBoundary: "add @trusted annotation to the dependency or verify the dependency"
            case CircularVerifiedDep: "break the circular dependency using @trusted annotations"
            case VerifiedInheritanceOptOut: "add @unsafe to explicitly opt out of verification"
            case VerifiedExtendsUnverified: "verify the parent class or use composition instead"
            case IoInVerified: "move IO operations to @trusted functions"
            case ReflectionInVerified: "use explicit types instead of reflection"
            case GhostAccessesNonGhost: "only access ghost variables and parameters in ghost code"
            case ContractHasSideEffects: "ensure contract expressions only read state, don't modify it"

    # Get the severity for this error
    fn severity() -> Severity:
        # All verification errors are hard errors
        Severity.Error

# A verification diagnostic with full context
class VerificationDiagnostic:
    code: VerificationErrorCode
    span: Span
    context: Option<text>
    file: Option<text>
    item_name: Option<text>

    static fn new(code: VerificationErrorCode, span: Span) -> VerificationDiagnostic:
        VerificationDiagnostic(code, span, nil, nil, nil)

    me with_context(ctx: text) -> VerificationDiagnostic:
        self.context = Some(ctx)
        self

    me with_file(f: text) -> VerificationDiagnostic:
        self.file = Some(f)
        self

    me with_item(name: text) -> VerificationDiagnostic:
        self.item_name = Some(name)
        self

    # Format the diagnostic as a string
    fn format() -> text:
        var msg = self.code.message()
        match self.item_name:
            case Some(name):
                msg = "{msg}: `{name}`"
            case nil:
                pass

        var result = "[{self.code.code()}] {msg}"

        match self.file:
            case Some(f):
                result = "{result}\n  --> {f}:{self.span.line}:{self.span.column}"
            case nil:
                pass

        match self.context:
            case Some(ctx):
                result = "{result}\n  note: {ctx}"
            case nil:
                pass

        result = "{result}\n  help: {self.code.help()}"
        result

# Collector for verification diagnostics
class VerificationDiagnostics:
    diagnostics: List<VerificationDiagnostic>

    static fn new() -> VerificationDiagnostics:
        VerificationDiagnostics([])

    me push(diag: VerificationDiagnostic):
        self.diagnostics = self.diagnostics + [diag]

    me error(code: VerificationErrorCode, span: Span) -> VerificationDiagnostic:
        val diag = VerificationDiagnostic.new(code, span)
        self.diagnostics = self.diagnostics + [diag]
        diag

    fn has_errors() -> bool:
        self.diagnostics.len() > 0

    fn error_count() -> i32:
        self.diagnostics.len()

    fn is_empty() -> bool:
        self.diagnostics.len() == 0

    # Format all diagnostics as strings
    fn format_all() -> List<text>:
        var result: List<text> = []
        for diag in self.diagnostics:
            result = result + [diag.format()]
        result

# Helper functions for common error patterns

fn aop_non_ghost_error(span: Span, aspect_name: text) -> VerificationDiagnostic:
    VerificationDiagnostic.new(VerificationErrorCode.AopNonGhostTargetsVerified, span)
        .with_item(aspect_name)

fn missing_termination_error(span: Span, func_name: text) -> VerificationDiagnostic:
    VerificationDiagnostic.new(VerificationErrorCode.MissingTermination, span)
        .with_item(func_name)

fn unsafe_in_verified_error(span: Span, operation: text) -> VerificationDiagnostic:
    VerificationDiagnostic.new(VerificationErrorCode.UnsafeInVerified, span)
        .with_context("unsafe operation: {operation}")

fn io_in_verified_error(span: Span, func_name: text) -> VerificationDiagnostic:
    VerificationDiagnostic.new(VerificationErrorCode.IoInVerified, span)
        .with_item(func_name)

fn ffi_in_verified_error(span: Span, func_name: text) -> VerificationDiagnostic:
    VerificationDiagnostic.new(VerificationErrorCode.FfiInVerified, span)
        .with_item(func_name)

fn ghost_access_error(span: Span, var_name: text) -> VerificationDiagnostic:
    VerificationDiagnostic.new(VerificationErrorCode.GhostAccessesNonGhost, span)
        .with_item(var_name)

fn contract_side_effect_error(span: Span) -> VerificationDiagnostic:
    VerificationDiagnostic.new(VerificationErrorCode.ContractHasSideEffects, span)

# Export public API
pub use Span, Severity, VerificationErrorCode, VerificationDiagnostic, VerificationDiagnostics
pub use aop_non_ghost_error, missing_termination_error, unsafe_in_verified_error
pub use io_in_verified_error, ffi_in_verified_error, ghost_access_error, contract_side_effect_error
