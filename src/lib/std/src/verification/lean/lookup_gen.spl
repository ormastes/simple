# Lookup Function Generator for Lean Code Generation
#
# Generates Lean lookup functions from type definitions.
# Part of Phase 7.2: Auto-generation of lookup/find functions.
#
# Pattern: For a type `XDef`, generates:
#   - `XEnv := List (String x XDef)` - Environment type alias
#   - `lookupX (env : XEnv) (name : String) : Option XDef` - Lookup function
#   - `findX (env : XEnv) (predicate) : Option XDef` - Find with predicate
#   - `containsX (env : XEnv) (name : String) : Bool` - Existence check
#
# Key principle: Generate scaffolding, not proofs. Never introduce `sorry` or `axiom`.

use verification.lean.naming as naming

# Registry definition for lookup generation
class RegistryDef:
    type_name: text           # e.g., "Trait" generates TraitEnv, lookupTrait
    key_type: text            # Type of the key, usually "String"
    value_type: text          # Type of the value, usually "TraitDef"
    key_field: text           # Field name to use for key lookup

    static fn new(type_name: text) -> RegistryDef:
        val pascal_name = naming.to_pascal_case(type_name)
        RegistryDef(type_name, "String", "{pascal_name}Def", "name")

    me with_key_type(ty: text) -> RegistryDef:
        self.key_type = ty
        self

    me with_value_type(ty: text) -> RegistryDef:
        self.value_type = ty
        self

    me with_key_field(field: text) -> RegistryDef:
        self.key_field = field
        self

# Lookup function generator
class LookupGenerator:
    generated_envs: List<text>
    generated_lookups: List<text>

    static fn new() -> LookupGenerator:
        LookupGenerator([], [])

    # Generate environment type alias
    # Example: def TraitEnv := List (String x TraitDef)
    me generate_env_type(registry: RegistryDef) -> text:
        val pascal_name = naming.to_pascal_case(registry.type_name)
        val env_name = "{pascal_name}Env"
        self.generated_envs = self.generated_envs + [env_name]

        "def {env_name} := List ({registry.key_type} x {registry.value_type})\n"

    # Generate lookup function
    # Example:
    # def lookupTrait (env : TraitEnv) (name : String) : Option TraitDef :=
    #   env.find? (fun (n, _) => n == name) |>.map (·.2)
    me generate_lookup(registry: RegistryDef) -> text:
        val pascal_name = naming.to_pascal_case(registry.type_name)
        val camel_name = naming.to_camel_case(registry.type_name)
        val func_name = "lookup{pascal_name}"
        val env_name = "{pascal_name}Env"

        self.generated_lookups = self.generated_lookups + [func_name]

        var out = "def {func_name} (env : {env_name}) (name : {registry.key_type}) : Option {registry.value_type} :=\n"
        out = out + "  env.find? (fun (n, _) => n == name) |>.map (·.2)\n"
        out

    # Generate find function with custom predicate
    # Example:
    # def findTrait (env : TraitEnv) (pred : TraitDef -> Bool) : Option TraitDef :=
    #   (env.find? (fun (_, v) => pred v)).map (·.2)
    me generate_find(registry: RegistryDef) -> text:
        val pascal_name = naming.to_pascal_case(registry.type_name)
        val func_name = "find{pascal_name}"
        val env_name = "{pascal_name}Env"

        var out = "def {func_name} (env : {env_name}) (pred : {registry.value_type} -> Bool) : Option {registry.value_type} :=\n"
        out = out + "  (env.find? (fun (_, v) => pred v)).map (·.2)\n"
        out

    # Generate contains function
    # Example:
    # def containsTrait (env : TraitEnv) (name : String) : Bool :=
    #   (lookupTrait env name).isSome
    me generate_contains(registry: RegistryDef) -> text:
        val pascal_name = naming.to_pascal_case(registry.type_name)
        val func_name = "contains{pascal_name}"
        val lookup_name = "lookup{pascal_name}"
        val env_name = "{pascal_name}Env"

        var out = "def {func_name} (env : {env_name}) (name : {registry.key_type}) : Bool :=\n"
        out = out + "  ({lookup_name} env name).isSome\n"
        out

    # Generate all lookup functions for a registry
    me generate_all_for_registry(registry: RegistryDef) -> text:
        var out = ""
        out = out + self.generate_env_type(registry) + "\n"
        out = out + self.generate_lookup(registry) + "\n"
        out = out + self.generate_find(registry) + "\n"
        out = out + self.generate_contains(registry) + "\n"
        out

    # Generate lookup functions for multiple registries
    me generate_all(registries: List<RegistryDef>) -> text:
        var out = "-- Auto-generated Lean lookup functions\n"
        out = out + "-- Generated by lookup_gen.spl\n\n"

        for registry in registries:
            out = out + self.generate_all_for_registry(registry)
            out = out + "\n"

        out

    # Get generated environment type names
    fn get_generated_envs() -> List<text>:
        self.generated_envs

    # Get generated lookup function names
    fn get_generated_lookups() -> List<text>:
        self.generated_lookups

# Field lookup generator for structures
class FieldLookupGenerator:
    # Generate lookup for a field in a structure
    # Example:
    # def lookupField (cls : ClassDef) (fieldName : String) : Option Ty :=
    #   cls.fields.find? (fun f => f.name == fieldName) |>.map (·.ty)
    fn generate_field_lookup(struct_name: text, field_name: text, key_field: text, value_field: text, value_type: text) -> text:
        val pascal_struct = naming.to_pascal_case(struct_name)
        val pascal_field = naming.to_pascal_case(field_name)
        val func_name = "lookup{pascal_field}"
        val param_name = naming.to_camel_case(struct_name)

        var out = "def {func_name} ({param_name} : {pascal_struct}) ({key_field}Name : String) : Option {value_type} :=\n"
        out = out + "  {param_name}.{field_name}.find? (fun f => f.{key_field} == {key_field}Name) |>.map (·.{value_field})\n"
        out

# Convenience function to generate standard lookup functions for a type
fn generate_standard_lookups(type_name: text) -> text:
    val registry = RegistryDef.new(type_name)
    var gen = LookupGenerator.new()
    gen.generate_all_for_registry(registry)

# Convenience function to generate lookups for multiple types
fn generate_lookups_for_types(type_names: List<text>) -> text:
    var registries: List<RegistryDef> = []
    for name in type_names:
        registries = registries + [RegistryDef.new(name)]

    var gen = LookupGenerator.new()
    gen.generate_all(registries)

# Export public API
pub use RegistryDef, LookupGenerator, FieldLookupGenerator
pub use generate_standard_lookups, generate_lookups_for_types
