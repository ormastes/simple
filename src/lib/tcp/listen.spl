# TCP Listen and Accept Operations
#
# Functions for server-side connection handling

import "types" as Types

# Listen on bound socket
fn tcp_listen(conn: (text, i64, i64, text, text, list, i64)) -> (text, i64, i64, text, text, list, i64):
    val state = Types.tcp_connection_get_state(conn)
    val is_closed = state == Types.TCP_STATE_CLOSED
    if is_closed:
        Types.tcp_connection_set_state(conn, Types.TCP_STATE_LISTEN)
    else:
        conn

# Accept incoming connection
fn tcp_accept(server_conn: (text, i64, i64, text, text, list, i64), client_addr: text, client_port: i64) -> (text, i64, i64, text, text, list, i64):
    val state = Types.tcp_connection_get_state(server_conn)
    val is_listening = state == Types.TCP_STATE_LISTEN
    if is_listening:
        val new_conn = Types.tcp_connection_create(client_addr, client_port)
        Types.tcp_connection_set_state(new_conn, Types.TCP_STATE_ESTABLISHED)
    else:
        Types.tcp_connection_create("", Types.TCP_ERR_INVALID_STATE)

# Check if port is well-known
fn tcp_port_is_well_known(port: i64) -> bool:
    val valid = port >= Types.TCP_MIN_PORT
    if valid:
        port <= Types.TCP_WELL_KNOWN_END
    else:
        false

# Check if port is registered
fn tcp_port_is_registered(port: i64) -> bool:
    val start_valid = port > Types.TCP_WELL_KNOWN_END
    if start_valid:
        port <= Types.TCP_REGISTERED_END
    else:
        false

# Check if port is ephemeral
fn tcp_port_is_ephemeral(port: i64) -> bool:
    val start_valid = port >= Types.TCP_EPHEMERAL_START
    if start_valid:
        port <= Types.TCP_EPHEMERAL_END
    else:
        false

# Allocate ephemeral port (simple counter-based)
fn tcp_port_allocate_ephemeral(used_ports: list) -> i64:
    tcp_port_find_free(Types.TCP_EPHEMERAL_START, used_ports)

# Find next free port
fn tcp_port_find_free(start_port: i64, used_ports: list) -> i64:
    val candidate = start_port
    val is_used = tcp_port_in_list(candidate, used_ports)
    if is_used:
        val next = start_port + 1
        val valid = next <= Types.TCP_EPHEMERAL_END
        if valid:
            tcp_port_find_free(next, used_ports)
        else:
            Types.TCP_EPHEMERAL_START
    else:
        candidate

# Check if port is in list
fn tcp_port_in_list(port: i64, ports: list) -> bool:
    val len = ports.len()
    tcp_port_in_list_helper(port, ports, 0, len)

# Helper for port list check
fn tcp_port_in_list_helper(port: i64, ports: list, index: i64, len: i64) -> bool:
    if index >= len:
        false
    else:
        val current = ports.get(index)
        val current_port = current.to_i64()
        val matches = current_port == port
        if matches:
            true
        else:
            val next_idx = index + 1
            tcp_port_in_list_helper(port, ports, next_idx, len)

# Get standard port for service
fn tcp_port_get_standard(service: text) -> i64:
    if service == "http":
        80
    else:
        if service == "https":
            443
        else:
            if service == "ftp":
                21
            else:
                if service == "ssh":
                    22
                else:
                    if service == "smtp":
                        25
                    else:
                        if service == "dns":
                            53
                        else:
                            if service == "pop3":
                                110
                            else:
                                if service == "imap":
                                    143
                                else:
                                    0

export tcp_listen
export tcp_accept
export tcp_port_is_well_known
export tcp_port_is_registered
export tcp_port_is_ephemeral
export tcp_port_allocate_ephemeral
export tcp_port_find_free
export tcp_port_get_standard
