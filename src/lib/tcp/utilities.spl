# TCP Utility Functions
#
# Helper functions for TCP operations

import "types" as Types
import "send" as Send
import "receive" as Receive

# Convert connection to string representation
fn tcp_connection_to_string(conn: (text, i64, i64, text, text, list, i64)) -> text:
    val addr = Types.tcp_connection_get_address(conn)
    val port = Types.tcp_connection_get_port(conn)
    val state = Types.tcp_connection_get_state(conn)
    val state_str = Types.tcp_state_to_string(state)
    val addr_port = tcp_address_format(addr, port)
    val with_space = addr_port + " "
    val result = with_space + state_str
    result

# Reset connection buffers
fn tcp_connection_reset_buffers(conn: (text, i64, i64, text, text, list, i64)) -> (text, i64, i64, text, text, list, i64):
    val empty = ""
    val with_recv = Types.tcp_connection_set_recv_buffer(conn, empty)
    Types.tcp_connection_set_send_buffer(with_recv, empty)

# Clone connection
fn tcp_connection_clone(conn: (text, i64, i64, text, text, list, i64)) -> (text, i64, i64, text, text, list, i64):
    val addr = Types.tcp_connection_get_address(conn)
    val port = Types.tcp_connection_get_port(conn)
    val state = Types.tcp_connection_get_state(conn)
    val recv_buf = Types.tcp_connection_get_recv_buffer(conn)
    val send_buf = Types.tcp_connection_get_send_buffer(conn)
    val opts = Types.tcp_connection_get_options(conn)
    val ts = Types.tcp_connection_get_timestamp(conn)
    (addr, port, state, recv_buf, send_buf, opts, ts)

# Compare two connections
fn tcp_connection_equals(conn1: (text, i64, i64, text, text, list, i64), conn2: (text, i64, i64, text, text, list, i64)) -> bool:
    val addr1 = Types.tcp_connection_get_address(conn1)
    val addr2 = Types.tcp_connection_get_address(conn2)
    val addr_match = addr1 == addr2
    if addr_match:
        val port1 = Types.tcp_connection_get_port(conn1)
        val port2 = Types.tcp_connection_get_port(conn2)
        port1 == port2
    else:
        false

# Get connection hash (simple address + port combination)
fn tcp_connection_hash(conn: (text, i64, i64, text, text, list, i64)) -> i64:
    val port = Types.tcp_connection_get_port(conn)
    port

# Validate connection
fn tcp_connection_is_valid(conn: (text, i64, i64, text, text, list, i64)) -> bool:
    val addr = Types.tcp_connection_get_address(conn)
    val addr_valid = tcp_ipv4_is_valid(addr)
    if addr_valid:
        val port = Types.tcp_connection_get_port(conn)
        val port_valid = tcp_port_is_valid(port)
        if port_valid:
            val state = Types.tcp_connection_get_state(conn)
            Types.tcp_state_is_valid(state)
        else:
            false
    else:
        false

# Helper: validate IPv4
fn tcp_ipv4_is_valid(address: text) -> bool:
    val parts = address.split(".")
    val len = parts.len()
    len == 4

# Helper: validate port
fn tcp_port_is_valid(port: i64) -> bool:
    val min_valid = port >= Types.TCP_MIN_PORT
    if min_valid:
        port <= Types.TCP_MAX_PORT
    else:
        false

# Helper: format address with port
fn tcp_address_format(address: text, port: i64) -> text:
    val is_ipv6 = address.contains(":")
    if is_ipv6:
        val bracket_start = "["
        val with_addr = bracket_start + address
        val with_bracket = with_addr + "]:"
        val port_str = port.to_str()
        val result = with_bracket + port_str
        result
    else:
        val with_addr = address + ":"
        val port_str = port.to_str()
        val result = with_addr + port_str
        result

export tcp_connection_to_string
export tcp_connection_reset_buffers
export tcp_connection_clone
export tcp_connection_equals
export tcp_connection_hash
export tcp_connection_is_valid
