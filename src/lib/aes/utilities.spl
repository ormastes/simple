# AES Utilities Module
#
# This module contains utility functions for byte operations, conversions,
# key generation, and debugging

# Import dependencies (circular - types needs utilities for state_get)
import aes/types

# =============================================================================
# BITWISE AND BYTE OPERATIONS
# =============================================================================

# XOR two bytes
fn xor_byte(a: i64, b: i64) -> i64:
    # Ensure values are in byte range
    val a_mod = a % 256
    val b_mod = b % 256
    # Simple XOR using bitwise operations simulation
    val result = 0
    var bit = 1
    var temp_a = a_mod
    var temp_b = b_mod
    var sum = 0

    # Process each bit
    var i = 0
    while i < 8:
        val bit_a = temp_a % 2
        val bit_b = temp_b % 2
        val xor_bit = 0

        # XOR logic: different bits = 1, same bits = 0
        if bit_a == bit_b:
            # Both 0 or both 1: XOR = 0
            pass
        else:
            # Different: XOR = 1
            sum = sum + bit

        temp_a = temp_a / 2
        temp_b = temp_b / 2
        bit = bit * 2
        i = i + 1

    sum % 256

# XOR two blocks (16 bytes each)
fn xor_blocks(block_a: list, block_b: list) -> list:
    val result = []
    var i = 0
    while i < 16:
        val xor_val = xor_byte(block_a[i], block_b[i])
        result.append(xor_val)
        i = i + 1
    result

# XOR a list of bytes
fn xor_bytes_list(bytes_a: list, bytes_b: list) -> list:
    val len_a = bytes_a.length()
    val len_b = bytes_b.length()
    val min_len = 0

    if len_a < len_b:
        min_len = len_a
    else:
        min_len = len_b

    val result = []
    var i = 0
    while i < min_len:
        val xor_val = xor_byte(bytes_a[i], bytes_b[i])
        result.append(xor_val)
        i = i + 1
    result

# Galois Field (GF(2^8)) multiplication
# Used in MixColumns operation
fn gmul(a: i64, b: i64) -> i64:
    var p = 0
    var temp_a = a % 256
    var temp_b = b % 256

    var i = 0
    while i < 8:
        # If bit is set in b, XOR with a
        if temp_b % 2 == 1:
            p = xor_byte(p, temp_a)

        # Check high bit of a
        val hi_bit_set = temp_a >= 128

        # Left shift a
        temp_a = (temp_a * 2) % 256

        # If high bit was set, reduce by AES polynomial 0x11b
        if hi_bit_set:
            temp_a = xor_byte(temp_a, 0x1b)

        # Right shift b
        temp_b = temp_b / 2
        i = i + 1

    p % 256

# =============================================================================
# BYTE/TEXT CONVERSION
# =============================================================================

# Convert text to byte list
fn text_to_bytes(text: text) -> list:
    val bytes = []
    var i = 0
    val len = text.length()

    while i < len:
        val char = text[i]
        # Simple ASCII conversion (char code)
        val byte = char.ord()
        bytes.append(byte)
        i = i + 1
    bytes

# Convert byte list to text
fn bytes_to_text(bytes: list) -> text:
    var result = ""
    var i = 0
    val len = bytes.length()

    while i < len:
        val byte = bytes[i]
        val char = byte.chr()
        result = result + char
        i = i + 1
    result

# Convert byte to hex string (2 digits)
fn byte_to_hex(byte: i64) -> text:
    val hex_chars = "0123456789abcdef"
    val b = byte % 256
    val high = b / 16
    val low = b % 16
    hex_chars[high] + hex_chars[low]

# Convert byte list to hex string
fn bytes_to_hex(bytes: list) -> text:
    var result = ""
    var i = 0
    val len = bytes.length()

    while i < len:
        val hex = byte_to_hex(bytes[i])
        result = result + hex
        i = i + 1
    result

# Convert hex digit to value
fn hex_digit_to_value(char: text) -> i64:
    val code = char.ord()

    # '0'-'9': 48-57
    if code >= 48:
        if code <= 57:
            return code - 48

    # 'a'-'f': 97-102
    if code >= 97:
        if code <= 102:
            return code - 97 + 10

    # 'A'-'F': 65-70
    if code >= 65:
        if code <= 70:
            return code - 65 + 10

    0

# Convert hex string to byte list
fn hex_to_bytes(hex: text) -> list:
    val bytes = []
    var i = 0
    val len = hex.length()

    while i < len:
        if i + 1 < len:
            val high = hex_digit_to_value(hex[i])
            val low = hex_digit_to_value(hex[i + 1])
            val byte = high * 16 + low
            bytes.append(byte)
        i = i + 2
    bytes

# =============================================================================
# KEY AND IV GENERATION
# =============================================================================

# Validate key size
fn is_valid_key_size(key_size: i64) -> i64:
    if key_size == 16:
        return 1
    if key_size == 24:
        return 1
    if key_size == 32:
        return 1
    0

# Prepare key (pad or truncate to valid size)
fn prepare_key(key: text, target_size: i64) -> list:
    val key_bytes = text_to_bytes(key)
    val key_len = key_bytes.length()

    if key_len == target_size:
        return key_bytes

    val prepared = []
    var i = 0
    while i < target_size:
        if i < key_len:
            prepared.append(key_bytes[i])
        else:
            prepared.append(0)
        i = i + 1
    prepared

# Extract key bytes from text (pad or truncate)
fn text_to_key_bytes(key: text, size: i64) -> list:
    prepare_key(key, size)

# Generate random AES key of specified size
fn generate_aes_key(size: i64) -> list:
    val valid = is_valid_key_size(size)
    if valid == 0:
        # Default to AES-128
        return generate_aes_key(16)

    # Simple pseudo-random generation (NOT cryptographically secure)
    # In production, use secure random number generator
    val key = []
    var seed = 42
    var i = 0

    while i < size:
        # Linear congruential generator
        seed = (seed * 1103515245 + 12345) % 2147483648
        val byte = seed % 256
        key.append(byte)
        i = i + 1

    key

# Generate random IV (16 bytes)
fn generate_iv() -> list:
    val iv = []
    var seed = 123
    var i = 0

    while i < 16:
        # Linear congruential generator
        seed = (seed * 1103515245 + 12345) % 2147483648
        val byte = seed % 256
        iv.append(byte)
        i = i + 1

    iv

# Generate random nonce for CTR mode (16 bytes)
fn generate_nonce() -> list:
    generate_iv()

# Generate IV from seed (deterministic)
fn generate_iv_from_seed(seed: i64) -> list:
    val iv = []
    var current_seed = seed
    var i = 0

    while i < 16:
        current_seed = (current_seed * 1103515245 + 12345) % 2147483648
        val byte = current_seed % 256
        iv.append(byte)
        i = i + 1

    iv

# =============================================================================
# DEBUGGING AND TESTING UTILITIES
# =============================================================================

# Print state as 4x4 matrix
fn print_state(state: list) -> text:
    var result = ""
    var row = 0

    while row < 4:
        var col = 0
        while col < 4:
            val byte = state_get(state, row, col)
            val hex = byte_to_hex(byte)
            result = result + hex + " "
            col = col + 1
        result = result + "\n"
        row = row + 1

    result

# Print block as hex
fn print_block(block: list) -> text:
    var result = ""
    var i = 0

    while i < block.length():
        val hex = byte_to_hex(block[i])
        result = result + hex
        if (i + 1) % 16 == 0:
            result = result + "\n"
        else:
            if (i + 1) % 4 == 0:
                result = result + " "
        i = i + 1

    result

# Compare two blocks (for testing)
fn blocks_equal(block_a: list, block_b: list) -> i64:
    val len_a = block_a.length()
    val len_b = block_b.length()

    if len_a != len_b:
        return 0

    var i = 0
    while i < len_a:
        if block_a[i] != block_b[i]:
            return 0
        i = i + 1

    1

# =============================================================================
# DATA INTEGRITY
# =============================================================================

# Simple checksum for data integrity
fn compute_checksum(data: list) -> i64:
    var sum = 0
    var i = 0
    val len = data.length()

    while i < len:
        sum = sum + data[i]
        i = i + 1

    sum % 256

# Add checksum to data
fn add_checksum(data: list) -> list:
    val checksum = compute_checksum(data)
    val result = []

    var i = 0
    val len = data.length()
    while i < len:
        result.append(data[i])
        i = i + 1

    result.append(checksum)
    result

# Verify and remove checksum
fn verify_checksum(data: list) -> list:
    val len = data.length()

    if len == 0:
        return data

    val stored_checksum = data[len - 1]

    val data_without_checksum = []
    var i = 0
    while i < len - 1:
        data_without_checksum.append(data[i])
        i = i + 1

    val computed_checksum = compute_checksum(data_without_checksum)

    # If checksums match, return data without checksum
    if stored_checksum == computed_checksum:
        return data_without_checksum

    # Otherwise return original data (checksum verification failed)
    data
