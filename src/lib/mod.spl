#  Simple API (Tier 3)
# Auto-generated API scaffold
#
# This provides an idiomatic Simple API wrapping the FFI bindings.
# Feel free to customize and extend this code.

use lib..ffi.*

# ============================================================================
# Backend Detection
# ============================================================================

fn _available() -> bool:
    rt__available()

fn _version() -> text:
    rt__version()

# ============================================================================
# CudaStream Wrapper Class
# ============================================================================

class CudaStreamWrapper:
    """High-level wrapper for CudaStream.

    Automatically manages memory via RAII pattern.
    """

    handle: i64  # Opaque FFI handle (pointer)
    owns_handle: bool

    # Static factory methods
    static fn cuda_stream_create() -> CudaStreamWrapper:
        val handle = rt__cuda_stream_create()
        CudaStreamWrapper(handle: handle, owns_handle: true)

    static fn cuda_stream_create_with_flags(flags: i32) -> CudaStreamWrapper:
        val handle = rt__cuda_stream_create_with_flags(flags)
        CudaStreamWrapper(handle: handle, owns_handle: true)


    fn drop():
        """Automatically free memory when object goes out of scope."""
        if self.owns_handle:
            rt_cuda_stream_destroy(self.handle)

    # Methods
    fn synchronize() -> bool:
        rt__cudastream_synchronize(self.handle)

    fn query() -> bool:
        rt__cudastream_query(self.handle)

    fn wait_event(event: i64) -> bool:
        rt__cudastream_wait_event(self.handle, event)


# ============================================================================
# CudaEvent Wrapper Class
# ============================================================================

class CudaEventWrapper:
    """High-level wrapper for CudaEvent.

    Automatically manages memory via RAII pattern.
    """

    handle: i64  # Opaque FFI handle (pointer)
    owns_handle: bool

    # Static factory methods
    static fn cuda_event_create() -> CudaEventWrapper:
        val handle = rt__cuda_event_create()
        CudaEventWrapper(handle: handle, owns_handle: true)


    fn drop():
        """Automatically free memory when object goes out of scope."""
        if self.owns_handle:
            rt_cuda_event_destroy(self.handle)

    # Methods
    fn synchronize() -> bool:
        rt__cudaevent_synchronize(self.handle)

    fn query() -> bool:
        rt__cudaevent_query(self.handle)

    fn elapsed_time(end_event: i64) -> f32:
        rt__cudaevent_elapsed_time(self.handle, end_event)


# ============================================================================
# CudaDeviceMem Wrapper Class
# ============================================================================

class CudaDeviceMemWrapper:
    """High-level wrapper for CudaDeviceMem.

    Automatically manages memory via RAII pattern.
    """

    handle: i64  # Opaque FFI handle (pointer)
    owns_handle: bool

    # Static factory methods
    static fn cuda_malloc(size_bytes: i64) -> CudaDeviceMemWrapper:
        val handle = rt__cuda_malloc(size_bytes)
        CudaDeviceMemWrapper(handle: handle, owns_handle: true)


    fn drop():
        """Automatically free memory when object goes out of scope."""
        if self.owns_handle:
            rt_cuda_free(self.handle)

    # Methods
    fn is_null() -> bool:
        rt__cudadevicemem_is_null(self.handle)


# ============================================================================
# Exports
# ============================================================================

export CudaStreamWrapper
export CudaEventWrapper
export CudaDeviceMemWrapper
export _available
export _version

