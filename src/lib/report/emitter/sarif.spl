# SARIF Emitter
#
# Static Analysis Results Interchange Format (SARIF) v2.1.0 output.
# Provides standardized output for static analysis tools.
# See: https://docs.oasis-open.org/sarif/sarif/v2.1.0/sarif-v2.1.0.html

import ..level
import ..location
import ..report
import ..collector
use std.text.{NL}

export SarifEmitter, SarifConfig, SarifRun, SarifTool

# =============================================================================
# SarifConfig: Configuration for SARIF output
# =============================================================================

class SarifConfig:
    tool_name: text             # Name of the tool
    tool_version: text          # Tool version
    tool_uri: text?             # Tool information URI
    include_rules: bool         # Include rule definitions
    include_fixes: bool         # Include fix suggestions
    pretty: bool                # Pretty-print JSON

impl SarifConfig:
    static fn default_config() -> SarifConfig:
        SarifConfig(
            tool_name: "simple",
            tool_version: "0.4.0",
            tool_uri: Some("https://github.com/simple-lang/simple"),
            include_rules: true,
            include_fixes: true,
            pretty: false
        )

    static fn for_tool(name: text, version: text) -> SarifConfig:
        SarifConfig(
            tool_name: name,
            tool_version: version,
            tool_uri: nil,
            include_rules: true,
            include_fixes: true,
            pretty: false
        )

# =============================================================================
# SarifTool: Tool information for SARIF
# =============================================================================

struct SarifTool:
    name: text
    version: text
    information_uri: text?

# =============================================================================
# SarifRun: A single run in SARIF output
# =============================================================================

class SarifRun:
    tool: SarifTool
    results: [Report]
    rules: Dict<text, text>     # rule_id -> description

impl SarifRun:
    static fn create(tool: SarifTool) -> SarifRun:
        SarifRun(
            tool: tool,
            results: [],
            rules: {}
        )

    me add_result(report: Report):
        self.results.push(report)

        # Track rules
        if report.code.?:
            val code = report.code.unwrap()
            if not self.rules.has(code):
                self.rules[code] = report.message

    me add_rule(id: text, description: text):
        self.rules[id] = description

# =============================================================================
# SarifEmitter: Emits SARIF v2.1.0 output
# =============================================================================

class SarifEmitter:
    config: SarifConfig

impl SarifEmitter:
    static fn default_emitter() -> SarifEmitter:
        SarifEmitter(config: SarifConfig__default_config())

    static fn with_config(config: SarifConfig) -> SarifEmitter:
        SarifEmitter(config: config)

    # ==========================================================================
    # JSON encoding helpers
    # ==========================================================================

    fn escape_string(s: text) -> text:
        s.replace("\\", "\\\\")
         .replace("\"", "\\\"")
         .replace("\n", "\\n")
         .replace("\r", "\\r")
         .replace("\t", "\\t")

    fn encode_string(s: text) -> text:
        "\"{self.escape_string(s)}\""

    fn nl() -> text:
        if self.config.pretty: NL else: ""

    fn ind(level: i64) -> text:
        if self.config.pretty: "  ".repeat(level) else: ""

    # ==========================================================================
    # Level mapping
    # ==========================================================================

    fn level_to_sarif(level: ReportLevel) -> text:
        match level:
            case ReportLevel.Error: "error"
            case ReportLevel.Fatal: "error"
            case ReportLevel.Warning: "warning"
            case ReportLevel.Info: "note"
            case ReportLevel.Debug: "none"

    # ==========================================================================
    # Emit methods
    # ==========================================================================

    fn emit(reports: [Report]) -> text:
        val run = SarifRun__create(SarifTool(
            name: self.config.tool_name,
            version: self.config.tool_version,
            information_uri: self.config.tool_uri
        ))

        for report in reports:
            run.add_result(report)

        self.emit_sarif(run)

    fn emit_collector(collector: ReportCollector) -> text:
        self.emit(collector.filter_displayable())

    fn emit_sarif(run: SarifRun) -> text:
        val nl = self.nl()
        val i1 = self.ind(1)
        val i2 = self.ind(2)
        val i3 = self.ind(3)
        val i4 = self.ind(4)

        var output = "{{$nl}"
        output = output + "{i1}\"$schema\": \"https://json.schemastore.org/sarif-2.1.0.json\",{nl}"
        output = output + "{i1}\"version\": \"2.1.0\",{nl}"
        output = output + "{i1}\"runs\": [{{$nl}"

        # Tool
        output = output + "{i2}\"tool\": {{$nl}"
        output = output + "{i3}\"driver\": {{$nl}"
        output = output + "{i4}\"name\": {self.encode_string(run.tool.name)},{nl}"
        output = output + "{i4}\"version\": {self.encode_string(run.tool.version)}"

        if run.tool.information_uri.?:
            output = output + ",{nl}{i4}\"informationUri\": {self.encode_string(run.tool.information_uri.unwrap())}"

        # Rules
        if self.config.include_rules and not run.rules.is_empty():
            output = output + ",{nl}{i4}\"rules\": [{nl}"
            var first_rule = true
            for rule_id in run.rules.keys():
                if not first_rule:
                    output = output + ",{nl}"
                output = output + "{self.ind(5)}{{$nl}"
                output = output + "{self.ind(6)}\"id\": {self.encode_string(rule_id)},{nl}"
                output = output + "{self.ind(6)}\"shortDescription\": {{\"text\": {self.encode_string(run.rules[rule_id])}}}{nl}"
                output = output + "{self.ind(5)}}"
                first_rule = false
            output = output + "{nl}{i4}]"

        output = output + "{nl}{i3}}}{nl}"  # Close driver
        output = output + "{i2}}},{nl}"     # Close tool

        # Results
        output = output + "{i2}\"results\": [{nl}"
        var first_result = true
        for report in run.results:
            if not first_result:
                output = output + ",{nl}"
            output = output + self.emit_result(report, 3)
            first_result = false
        output = output + "{nl}{i2}]{nl}"

        output = output + "{i1}}}]{nl}"     # Close runs
        output = output + "}}"              # Close root
        output

    fn emit_result(report: Report, indent_level: i64) -> text:
        val nl = self.nl()
        val ind = self.ind(indent_level)
        val ind1 = self.ind(indent_level + 1)
        val ind2 = self.ind(indent_level + 2)

        var output = "{ind}{{$nl}"

        # Rule ID
        if report.code.?:
            output = output + "{ind1}\"ruleId\": {self.encode_string(report.code.unwrap())},{nl}"
        else:
            output = output + "{ind1}\"ruleId\": \"unknown\",{nl}"

        # Level
        output = output + "{ind1}\"level\": {self.encode_string(self.level_to_sarif(report.level))},{nl}"

        # Message
        output = output + "{ind1}\"message\": {{\"text\": {self.encode_string(report.message)}}}"

        # Locations
        if report.location.?:
            output = output + ",{nl}{ind1}\"locations\": [{nl}"
            output = output + self.emit_physical_location(report.location.unwrap(), indent_level + 2)
            output = output + "{nl}{ind1}]"

        # Related locations (from labels)
        if not report.labels.is_empty():
            output = output + ",{nl}{ind1}\"relatedLocations\": [{nl}"
            var first_label = true
            for label in report.labels:
                if not first_label:
                    output = output + ",{nl}"
                output = output + "{ind2}{{$nl}"
                output = output + "{self.ind(indent_level + 3)}\"message\": {{\"text\": {self.encode_string(label.message)}}},{nl}"
                output = output + "{self.ind(indent_level + 3)}\"physicalLocation\": " + self.emit_physical_location_inline(label.location) + "{nl}"
                output = output + "{ind2}}"
                first_label = false
            output = output + "{nl}{ind1}]"

        # Fixes
        if self.config.include_fixes and not report.suggestions.is_empty():
            output = output + ",{nl}{ind1}\"fixes\": [{nl}"
            var first_fix = true
            for suggestion in report.suggestions:
                if not first_fix:
                    output = output + ",{nl}"
                output = output + self.emit_fix(suggestion, indent_level + 2)
                first_fix = false
            output = output + "{nl}{ind1}]"

        output = output + "{nl}{ind}}}"
        output

    fn emit_physical_location(location: SourceLocation, indent_level: i64) -> text:
        val nl = self.nl()
        val ind = self.ind(indent_level)
        val ind1 = self.ind(indent_level + 1)
        val ind2 = self.ind(indent_level + 2)

        var output = "{ind}{{$nl}"
        output = output + "{ind1}\"physicalLocation\": {{$nl}"
        output = output + "{ind2}\"artifactLocation\": {{\"uri\": {self.encode_string(location.file)}}},{nl}"
        output = output + "{ind2}\"region\": {{$nl}"
        output = output + "{self.ind(indent_level + 3)}\"startLine\": {location.line},{nl}"
        output = output + "{self.ind(indent_level + 3)}\"startColumn\": {location.column}"

        if location.end_line > 0:
            output = output + ",{nl}{self.ind(indent_level + 3)}\"endLine\": {location.end_line}"
        if location.end_column > 0:
            output = output + ",{nl}{self.ind(indent_level + 3)}\"endColumn\": {location.end_column}"

        output = output + "{nl}{ind2}}}{nl}"  # Close region
        output = output + "{ind1}}}{nl}"      # Close physicalLocation
        output = output + "{ind}}}"
        output

    fn emit_physical_location_inline(location: SourceLocation) -> text:
        var output = "{\"artifactLocation\": {\"uri\": {self.encode_string(location.file)}}, "
        output = output + "\"region\": {"
        output = output + "\"startLine\": {location.line}, "
        output = output + "\"startColumn\": {location.column}"
        if location.end_line > 0:
            output = output + ", \"endLine\": {location.end_line}"
        if location.end_column > 0:
            output = output + ", \"endColumn\": {location.end_column}"
        output = output + "}}"
        output

    fn emit_fix(suggestion: Suggestion, indent_level: i64) -> text:
        val nl = self.nl()
        val ind = self.ind(indent_level)
        val ind1 = self.ind(indent_level + 1)
        val ind2 = self.ind(indent_level + 2)

        var output = "{ind}{{$nl}"
        output = output + "{ind1}\"description\": {{\"text\": {self.encode_string(suggestion.message)}}},{nl}"
        output = output + "{ind1}\"artifactChanges\": [{{$nl}"
        output = output + "{ind2}\"artifactLocation\": {{\"uri\": {self.encode_string(suggestion.location.file)}}},{nl}"
        output = output + "{ind2}\"replacements\": [{{$nl}"
        output = output + "{self.ind(indent_level + 3)}\"deletedRegion\": {{$nl}"
        output = output + "{self.ind(indent_level + 4)}\"startLine\": {suggestion.location.line},{nl}"
        output = output + "{self.ind(indent_level + 4)}\"startColumn\": {suggestion.location.column}"
        if suggestion.location.end_line > 0:
            output = output + ",{nl}{self.ind(indent_level + 4)}\"endLine\": {suggestion.location.end_line}"
        if suggestion.location.end_column > 0:
            output = output + ",{nl}{self.ind(indent_level + 4)}\"endColumn\": {suggestion.location.end_column}"
        output = output + "{nl}{self.ind(indent_level + 3)}}},{nl}"
        output = output + "{self.ind(indent_level + 3)}\"insertedContent\": {{\"text\": {self.encode_string(suggestion.new_text)}}}{nl}"
        output = output + "{ind2}}}]{nl}"     # Close replacements
        output = output + "{ind1}}}]{nl}"     # Close artifactChanges
        output = output + "{ind}}}"
        output
