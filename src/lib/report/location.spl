# Source LocationNL#NL# Unified source location types for all reports in the Simple language.NL# Provides byte-level precision with line/column for display.NLNLuse ansi.{ansi_bold_blue, ansi_reset}NLuse std.text.{NL}NLNLexport Span, SourceLocation, LabelNLNL# =============================================================================NL# Span: Byte range in source codeNL# =============================================================================NLNLstruct Span:NL    start: i64      # Start byte offset (0-based)NL    end: i64        # End byte offset (exclusive)NLNLimpl Span:NL    # Create a span from start to endNL    static fn from_range(start: i64, end: i64) -> Span:NL        Span(start: start, end: end)NLNL    # Create a zero-length span at a positionNL    static fn at(pos: i64) -> Span:NL        Span(start: pos, end: pos)NLNL    # Create an empty spanNL    static fn empty() -> Span:NL        Span(start: 0, end: 0)NLNL    # Get the length of this spanNL    fn len() -> i64:NL        self.end - self.startNLNL    # Check if this span is emptyNL    fn is_empty() -> bool:NL        self.start >= self.endNLNL    # Extend this span to include anotherNL    fn extend_to(other: Span) -> Span:NL        Span(NL            start: self.start.min(other.start),NL            end: self.end.max(other.end)NL        )NLNL    # Check if this span contains a positionNL    fn contains_pos(pos: i64) -> bool:NL        pos >= self.start and pos < self.endNLNL    # Check if this span overlaps with anotherNL    fn overlaps(other: Span) -> bool:NL        self.start < other.end and other.start < self.endNLNL    # Get the text this span coversNL    fn extract(source: text) -> text:NL        if self.start >= 0 and self.end <= source.len():NL            source.slice(self.start, self.end)NL        else:NL            ""NLNL# =============================================================================NL# SourceLocation: Full source location with file, line, columnNL# =============================================================================NLNLstruct SourceLocation:NL    file: text              # File pathNL    span: Span              # Byte rangeNL    line: i64               # Start line (1-based)NL    column: i64             # Start column (1-based)NL    end_line: i64           # End line (1-based), 0 if same as startNL    end_column: i64         # End column (1-based), 0 if same as startNLNLimpl SourceLocation:NL    # Create a location at a specific positionNL    static fn at(file: text, line: i64, column: i64) -> SourceLocation:NL        SourceLocation(NL            file: file,NL            span: Span.at(0),NL            line: line,NL            column: column,NL            end_line: 0,NL            end_column: 0NL        )NLNL    # Create a location with full span informationNL    static fn from_span(file: text, span: Span, line: i64, column: i64, end_line: i64, end_column: i64) -> SourceLocation:NL        SourceLocation(NL            file: file,NL            span: span,NL            line: line,NL            column: column,NL            end_line: end_line,NL            end_column: end_columnNL        )NLNL    # Create a location with just line/column (no byte span)NL    static fn line_col(file: text, line: i64, column: i64) -> SourceLocation:NL        SourceLocation(NL            file: file,NL            span: Span.empty(),NL            line: line,NL            column: column,NL            end_line: 0,NL            end_column: 0NL        )NLNL    # Create an unknown/missing locationNL    static fn unknown() -> SourceLocation:NL        SourceLocation(NL            file: "<unknown>",NL            span: Span.empty(),NL            line: 0,NL            column: 0,NL            end_line: 0,NL            end_column: 0NL        )NLNL    # Check if this location has valid position infoNL    fn is_valid() -> bool:NL        self.line > 0 and self.column > 0NLNL    # Check if this location spans multiple linesNL    fn is_multiline() -> bool:NL        self.end_line > 0 and self.end_line > self.lineNLNL    # Get effective end line (same as start if not specified)NL    fn get_end_line() -> i64:NL        if self.end_line > 0:NL            self.end_lineNL        else:NL            self.lineNLNL    # Get effective end column (same as start if not specified)NL    fn get_end_column() -> i64:NL        if self.end_column > 0:NL            self.end_columnNL        else:NL            self.column + self.span.len().max(1)NLNL    # Format as "file:line:column"NL    fn format_short() -> text:NL        "{self.file}:{self.line}:{self.column}"NLNL    # Format as "file:line:column-end_line:end_column" if multilineNL    fn format_full() -> text:NL        if self.is_multiline():NL            "{self.file}:{self.line}:{self.column}-{self.get_end_line()}:{self.get_end_column()}"NL        else:NL            self.format_short()NLNL    # Extract source text from the location's spanNL    fn extract(source: text) -> text:NL        self.span.extract(source)NLNL    # Show source context with underlineNL    fn show_context(source: text, use_color: bool) -> text:NL        if not self.is_valid():NL            return ""NLNL        val lines = source.split(NL)NL        if self.line <= 0 or self.line > lines.len():NL            return ""NLNL        val blue = if use_color: ansi_bold_blue() else: ""NL        val reset = if use_color: ansi_reset() else: ""NLNL        val line_num = self.lineNL        val line_str = lines[line_num - 1]NLNL        var output = "   {blue}|{reset}\n"NL        output = output + " {blue}{line_num}{reset} {blue}|{reset} {line_str}\n"NLNL        # UnderlineNL        val col = (self.column - 1).max(0)NL        val len = if self.span.len() > 0:NL            self.span.len()NL        else:NL            1NLNL        val spaces = " ".repeat(col)NL        val underline = "^".repeat(len)NLNL        output = output + "   {blue}|{reset} {spaces}{underline}"NLNL        outputNLNL    # Extend to include another location (must be same file)NL    fn extend_to(other: SourceLocation) -> SourceLocation:NL        if self.file != other.file:NL            return selfNLNL        val new_span = self.span.extend_to(other.span)NL        val new_line = self.line.min(other.line)NL        val new_col = if self.line < other.line:NL            self.columnNL        elif other.line < self.line:NL            other.columnNL        else:NL            self.column.min(other.column)NLNL        val new_end_line = self.get_end_line().max(other.get_end_line())NL        val new_end_col = if self.get_end_line() > other.get_end_line():NL            self.get_end_column()NL        elif other.get_end_line() > self.get_end_line():NL            other.get_end_column()NL        else:NL            self.get_end_column().max(other.get_end_column())NLNL        SourceLocation(NL            file: self.file,NL            span: new_span,NL            line: new_line,NL            column: new_col,NL            end_line: new_end_line,NL            end_column: new_end_colNL        )NLNL# =============================================================================NL# Label: Annotated source span with messageNL# =============================================================================NLNLstruct Label:NL    location: SourceLocationNL    message: textNL    primary: bool           # Primary or secondary labelNLNLimpl Label:NL    # Create a primary label (main error location)NL    static fn primary(location: SourceLocation, message: text) -> Label:NL        Label(location: location, message: message, primary: true)NLNL    # Create a secondary label (related location)NL    static fn secondary(location: SourceLocation, message: text) -> Label:NL        Label(location: location, message: message, primary: false)NLNL    # Create a primary label with just file/line/columnNL    static fn at(file: text, line: i64, column: i64, message: text) -> Label:NL        Label(NL            location: SourceLocation.at(file, line, column),NL            message: message,NL            primary: trueNL        )NLNL    # Get the underline character for this labelNL    fn underline_char() -> text:NL        if self.primary:NL            "^"NL        else:NL            "-"NLNL    # Format the label with source contextNL    fn format(source: text, use_color: bool, label_color: text) -> text:NL        val blue = if use_color: ansi_bold_blue() else: ""NL        val reset = if use_color: ansi_reset() else: ""NLNL        var output = "  {blue}-->{reset} {self.location.format_short()}\n"NLNL        if not self.location.is_valid():NL            return outputNLNL        val lines = source.split(NL)NL        if self.location.line <= 0 or self.location.line > lines.len():NL            return outputNLNL        val line_num = self.location.lineNL        val line_str = lines[line_num - 1]NLNL        output = output + "   {blue}|{reset}\n"NL        output = output + " {blue}{line_num}{reset} {blue}|{reset} {line_str}\n"NLNL        # Underline with messageNL        val col = (self.location.column - 1).max(0)NL        val len = if self.location.span.len() > 0:NL            self.location.span.len()NL        else:NL            1NLNL        val spaces = " ".repeat(col)NL        val underline = self.underline_char().repeat(len)NL        val ul_color = if use_color: label_color else: ""NLNL        output = output + "   {blue}|{reset} {spaces}{ul_color}{underline}{reset} {self.message}\n"NLNL        outputNL