# Skip List Utility Functions
#
# This module provides utility functions for skip lists including size, validation,
# statistics, and comparison operations.

import types
import search
import traverse

# Get number of elements in skip list
fn sl_size(skiplist: tuple) -> i64:
    types.sl_get_size(skiplist)

# Check if skip list is empty
fn sl_is_empty(skiplist: tuple) -> i64:
    var size = types.sl_get_size(skiplist)
    if size == 0:
        1
    else:
        0

# Get current height (maximum level in use + 1)
fn sl_height(skiplist: tuple) -> i64:
    var level = types.sl_get_level(skiplist)
    level + 1

# Get maximum allowed height
fn sl_max_height() -> i64:
    types.MAX_LEVELS

# Clear all elements from skip list
fn sl_clear(skiplist: tuple) -> tuple:
    import create
    create.sl_create()

# Get total node count (including head sentinel)
fn sl_node_count(skiplist: tuple) -> i64:
    var nodes = types.sl_get_nodes(skiplist)
    nodes.len()

# Promote node to higher level (if possible)
fn sl_promote_node(skiplist: tuple, key: i64) -> tuple:
    var idx = search.sl_search(skiplist, key)
    if idx == types.NIL_REF:
        return skiplist

    var nodes = types.sl_get_nodes(skiplist)
    var node = nodes[idx]
    var current_node_level = types.sl_node_level(node)

    if current_node_level >= types.MAX_LEVELS - 1:
        return skiplist

    var should_promote = types.sl_should_promote_level(current_node_level)
    if should_promote == 0:
        return skiplist

    var value = types.sl_node_value(node)
    import delete
    var temp = delete.sl_remove(skiplist, key)
    import insert
    insert.sl_insert(temp, key, value)

# Demote node to lower level (if possible)
fn sl_demote_node(skiplist: tuple, key: i64) -> tuple:
    var idx = search.sl_search(skiplist, key)
    if idx == types.NIL_REF:
        return skiplist

    var nodes = types.sl_get_nodes(skiplist)
    var node = nodes[idx]
    var current_node_level = types.sl_node_level(node)

    if current_node_level <= 0:
        return skiplist

    var should_demote = types.sl_should_demote_level(current_node_level)
    if should_demote == 0:
        return skiplist

    var value = types.sl_node_value(node)
    import delete
    var temp = delete.sl_remove(skiplist, key)
    import insert
    insert.sl_insert(temp, key, value)

# Count nodes at each level
fn sl_level_distribution(skiplist: tuple) -> list:
    var nodes = types.sl_get_nodes(skiplist)
    var counts = []
    var i = 0
    while i < types.MAX_LEVELS:
        counts = counts + [0]
        i = i + 1

    var node_idx = 0
    while node_idx < nodes.len():
        var node = nodes[node_idx]
        var node_level = types.sl_node_level(node)

        var lvl = 0
        while lvl <= node_level:
            var old_count = counts[lvl]
            var new_counts = []
            var j = 0
            while j < types.MAX_LEVELS:
                if j == lvl:
                    new_counts = new_counts + [old_count + 1]
                else:
                    var existing_count = counts[j]
                    new_counts = new_counts + [existing_count]
                j = j + 1
            counts = new_counts
            lvl = lvl + 1

        node_idx = node_idx + 1

    counts

# Calculate average node level
fn sl_average_level(skiplist: tuple) -> f64:
    var nodes = types.sl_get_nodes(skiplist)
    var total_levels = 0
    var count = 0

    var i = 1
    while i < nodes.len():
        var node = nodes[i]
        var level = types.sl_node_level(node)
        total_levels = total_levels + level
        count = count + 1
        i = i + 1

    if count == 0:
        return 0.0

    var total_float = total_levels
    var count_float = count
    total_float / count_float

# Get memory usage estimate (approximate pointer count)
fn sl_memory_estimate(skiplist: tuple) -> i64:
    var nodes = types.sl_get_nodes(skiplist)
    var total_pointers = 0

    var i = 0
    while i < nodes.len():
        var node = nodes[i]
        var level = types.sl_node_level(node)
        total_pointers = total_pointers + (level + 1)
        i = i + 1

    total_pointers

# Calculate load factor (actual_pointers / expected_pointers)
fn sl_load_factor(skiplist: tuple) -> f64:
    var size = types.sl_get_size(skiplist)
    if size == 0:
        return 0.0

    var actual_pointers = sl_memory_estimate(skiplist)
    var expected_pointers = size * 2

    var actual_float = actual_pointers
    var expected_float = expected_pointers
    actual_float / expected_float

# Check if two skip lists have equal contents
fn sl_equals(skiplist1: tuple, skiplist2: tuple) -> i64:
    var pairs1 = traverse.sl_to_pairs(skiplist1)
    var pairs2 = traverse.sl_to_pairs(skiplist2)

    if pairs1.len() != pairs2.len():
        return 0

    var i = 0
    while i < pairs1.len():
        var p1 = pairs1[i]
        var p2 = pairs2[i]
        var k1 = p1[0]
        var k2 = p2[0]
        var v1 = p1[1]
        var v2 = p2[1]

        if k1 != k2:
            return 0
        if v1 != v2:
            return 0

        i = i + 1

    1

# Merge two skip lists (union of keys, prefer values from first)
fn sl_merge(skiplist1: tuple, skiplist2: tuple) -> tuple:
    var pairs1 = traverse.sl_to_pairs(skiplist1)
    var pairs2 = traverse.sl_to_pairs(skiplist2)
    import create
    var result = create.sl_create()

    import insert
    result = insert.sl_insert_many(result, pairs1)

    var i = 0
    while i < pairs2.len():
        var pair = pairs2[i]
        var key = pair[0]
        var value = pair[1]
        var exists = search.sl_contains(result, key)
        if exists == 0:
            result = insert.sl_insert(result, key, value)
        i = i + 1

    result

# Validate skip list structure integrity
fn sl_validate(skiplist: tuple) -> i64:
    var nodes = types.sl_get_nodes(skiplist)
    var head_idx = types.sl_get_head_idx(skiplist)
    var current_level = types.sl_get_level(skiplist)

    if nodes.len() == 0:
        return 0

    var prev_key = types.MIN_KEY
    var current_idx = types.sl_node_get_forward(nodes[head_idx], 0)

    while current_idx != types.NIL_REF:
        var current_node = nodes[current_idx]
        var current_key = types.sl_node_key(current_node)

        if current_key <= prev_key:
            return 0

        prev_key = current_key
        current_idx = types.sl_node_get_forward(current_node, 0)

    1

# Check if skip list is sorted
fn sl_is_sorted(skiplist: tuple) -> i64:
    sl_validate(skiplist)

# Get diagnostic string with skip list stats
fn sl_stats_string(skiplist: tuple) -> text:
    var size = types.sl_get_size(skiplist)
    var height = sl_height(skiplist)
    var node_count = sl_node_count(skiplist)
    var avg_level = sl_average_level(skiplist)
    var memory = sl_memory_estimate(skiplist)

    "SkipList[size={size}, height={height}, nodes={node_count}, avg_level={avg_level}, ptrs={memory}]"
