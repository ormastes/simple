# Hook Registry and Core Types
# Lightweight priority-based callback system for CLI hooks

export Hook, HookCallback, HookResult, HookRegistry
export register_hook, run_hooks, create_registry

# Hook result types
enum HookResult:
    Continue          # Continue to next hook
    Stop              # Stop hook chain
    Action(action: text)  # Perform action

# Hook callback type
type HookCallback = fn() -> HookResult

# Hook definition
struct Hook:
    name: text
    priority: i64     # 0-100, lower runs first
    callback: HookCallback

# Hook registry
class HookRegistry:
    hooks: [Hook]

    # Register a hook
    me register(name: text, priority: i64, callback: HookCallback):
        val hook = Hook(
            name: name,
            priority: priority,
            callback: callback
        )
        self.hooks.push(hook)

    # Sort hooks by priority (lower first)
    fn sort_hooks() -> [Hook]:
        # Simple bubble sort for now
        var sorted = self.hooks
        var swapped = true

        while swapped:
            swapped = false
            for i in 0..sorted.len()-1:
                if sorted[i].priority > sorted[i+1].priority:
                    val temp = sorted[i]
                    sorted[i] = sorted[i+1]
                    sorted[i+1] = temp
                    swapped = true

        sorted

    # Run all hooks in priority order
    fn run_all() -> HookResult:
        val sorted = self.sort_hooks()

        for hook in sorted:
            val result = hook.callback()

            match result:
                HookResult.Continue:
                    # Continue to next hook
                    continue

                HookResult.Stop:
                    # Stop processing
                    return HookResult.Stop

                HookResult.Action(action):
                    # Perform action and continue
                    self.perform_action(action)

        HookResult.Continue

    # Run hooks by priority level
    fn run_by_priority(max_priority: i64) -> [HookResult]:
        val sorted = self.sort_hooks()
        var results = []

        for hook in sorted:
            if hook.priority > max_priority:
                break

            val result = hook.callback()
            results.push(result)

            match result:
                HookResult.Stop:
                    break
                _: continue

        results

    # Perform action based on hook result
    fn perform_action(action: text):
        # Actions are handled by caller
        # This is a placeholder for extensibility
        ()

    # Get hook by name
    fn get_hook(name: text) -> Hook?:
        for hook in self.hooks:
            if hook.name == name:
                return Some(hook)
        nil

    # Remove hook by name
    me remove_hook(name: text) -> bool:
        var new_hooks = []
        var found = false

        for hook in self.hooks:
            if hook.name != name:
                new_hooks.push(hook)
            else:
                found = true

        if found:
            self.hooks = new_hooks

        found

    # List all hooks
    fn list_hooks() -> [text]:
        var names = []
        for hook in self.hooks:
            names.push(hook.name)
        names

    # Count hooks
    fn count() -> i64:
        self.hooks.len()

# Create a new hook registry
fn create_registry() -> HookRegistry:
    HookRegistry(hooks: [])

# Global registry instance (singleton pattern)
var global_registry: HookRegistry? = nil

# Get global registry
fn get_global_registry() -> HookRegistry:
    if not global_registry.?:
        global_registry = Some(create_registry())

    global_registry.unwrap()

# Register hook in global registry
fn register_hook(name: text, priority: i64, callback: HookCallback):
    val registry = get_global_registry()
    registry.register(name, priority, callback)

# Run all hooks in global registry
fn run_hooks() -> HookResult:
    val registry = get_global_registry()
    registry.run_all()

# Run hooks by priority in global registry
fn run_hooks_by_priority(max_priority: i64) -> [HookResult]:
    val registry = get_global_registry()
    registry.run_by_priority(max_priority)

# Check if hooks are enabled via environment variable
fn hooks_enabled() -> bool:
    val env_value = get_env("SIMPLE_HOOKS")
    if env_value == "0" or env_value == "false":
        return false
    true

# Check if interactive mode is enabled
fn interactive_mode() -> bool:
    val env_value = get_env("SIMPLE_HOOKS_INTERACTIVE")
    if env_value == "0" or env_value == "false":
        return false
    true

# Get max priority from environment
fn get_max_priority() -> i64:
    # Note: parse_i64 not available in bootstrap runtime
    # Always return default for now
    100  # Default max priority

# Helper to get environment variable
extern fn rt_env_get(key: text) -> text

fn get_env(key: text) -> text:
    rt_env_get(key)
