# Build Detector
# Parses doc/build/build_db.sdn and finds recent errors

use std.io_runtime.{file_exists, file_read}
use std.text.{NL}

export BuildSummary, detect_build_issues, format_summary

# Build summary
struct BuildSummary:
    total_errors: i64
    total_warnings: i64
    recent_errors: [BuildIssue]
    recent_warnings: [BuildIssue]

# Build issue
struct BuildIssue:
    file: text
    line: i64
    message: text
    severity: text

# Detect build issues
fn detect_build_issues(db_path: text) -> BuildSummary:
    val summary = BuildSummary(
        total_errors: 0,
        total_warnings: 0,
        recent_errors: [],
        recent_warnings: []
    )

    if not file_exists(db_path):
        return summary

    val content = file_read(db_path)
    val issues = parse_build_db(content)

    var errors = 0
    var warnings = 0
    var recent_errors = []
    var recent_warnings = []

    for issue in issues:
        if issue.severity == "error":
            errors = errors + 1
            if recent_errors.len() < 10:
                recent_errors.push(issue)
        else if issue.severity == "warning":
            warnings = warnings + 1
            if recent_warnings.len() < 10:
                recent_warnings.push(issue)

    BuildSummary(
        total_errors: errors,
        total_warnings: warnings,
        recent_errors: recent_errors,
        recent_warnings: recent_warnings
    )

# Parse build database
fn parse_build_db(content: text) -> [BuildIssue]:
    var issues = []
    val lines = content.split("\n")
    var in_table = false

    for line in lines:
        val trimmed = line.trim()
        if trimmed.starts_with("#") or trimmed.len() == 0:
            continue

        if trimmed.contains("|") and (trimmed.starts_with("errors") or trimmed.starts_with("warnings")):
            in_table = true
            continue

        if in_table:
            if not trimmed.contains(","):
                in_table = false
                continue

            val values = parse_row_values(trimmed)
            if values.len() >= 4:
                val issue = BuildIssue(
                    file: clean_value(values[0]),
                    line: parse_i64_safe(values[1]),
                    message: clean_value(values[2]),
                    severity: clean_value(values[3])
                )
                issues.push(issue)

    issues

# Parse row values
fn parse_row_values(row: text) -> [text]:
    var values = []
    var current = ""
    var in_quotes = false

    for i in 0..row.len():
        val ch = row[i:i+1]
        if ch == "\"":
            in_quotes = not in_quotes
        else if ch == "," and not in_quotes:
            values.push(current.trim())
            current = ""
        else:
            current = current + ch

    if current.len() > 0:
        values.push(current.trim())

    values

# Clean value
fn clean_value(value: text) -> text:
    var result = value.trim()
    if result.starts_with("\"") and result.ends_with("\""):
        result = result[1:-1]
    result

# Parse i64 safely
fn parse_i64_safe(value: text) -> i64:
    val cleaned = clean_value(value)
    val parsed = cleaned.parse_i64()
    if parsed.?: parsed.unwrap() else: 0

# Format summary
fn format_summary(summary: BuildSummary) -> text:
    if summary.total_errors == 0 and summary.total_warnings == 0:
        return "No build issues found"

    var result = "Build Issues:{NL}"
    result = result + "  Errors: {summary.total_errors}{NL}"
    result = result + "  Warnings: {summary.total_warnings}{NL}"

    if summary.recent_errors.len() > 0:
        result = result + "{NL}Recent Errors:{NL}"
        for issue in summary.recent_errors:
            result = result + "  {issue.file}:{issue.line}: {issue.message}{NL}"

    if summary.recent_warnings.len() > 0:
        result = result + "{NL}Recent Warnings:{NL}"
        for issue in summary.recent_warnings:
            result = result + "  {issue.file}:{issue.line}: {issue.message}{NL}"

    result

