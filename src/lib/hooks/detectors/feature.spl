# Feature Detector
# Parses doc/feature/feature_db.sdn and filters incomplete features

use std.io_runtime.{file_exists, file_read}

export FeatureSummary, detect_features, format_summary

# Feature summary
struct FeatureSummary:
    total: i64
    in_progress: i64
    failed: i64
    planned: i64
    incomplete_features: [FeatureItem]

# Feature item
struct FeatureItem:
    id: text
    name: text
    status: text
    category: text
    test_file: text

# Detect incomplete features
fn detect_features(db_path: text) -> FeatureSummary:
    val summary = FeatureSummary(
        total: 0,
        in_progress: 0,
        failed: 0,
        planned: 0,
        incomplete_features: []
    )

    if not file_exists(db_path):
        return summary

    val content = file_read(db_path)
    val items = parse_feature_db(content)

    var in_progress = 0
    var failed = 0
    var planned = 0
    var incomplete = []

    for item in items:
        if item.status == "in_progress":
            in_progress = in_progress + 1
            incomplete.push(item)
        else if item.status == "failed":
            failed = failed + 1
            incomplete.push(item)
        else if item.status == "planned":
            planned = planned + 1
            incomplete.push(item)

    FeatureSummary(
        total: items.len(),
        in_progress: in_progress,
        failed: failed,
        planned: planned,
        incomplete_features: incomplete
    )

# Parse feature database
fn parse_feature_db(content: text) -> [FeatureItem]:
    var items = []
    val lines = content.split("\n")
    var in_table = false

    for line in lines:
        val trimmed = line.trim()
        if trimmed.starts_with("#") or trimmed.len() == 0:
            continue

        if trimmed.contains("|") and trimmed.starts_with("features"):
            in_table = true
            continue

        if in_table:
            if not trimmed.contains(","):
                in_table = false
                continue

            val values = parse_row_values(trimmed)
            if values.len() >= 5:
                val item = FeatureItem(
                    id: clean_value(values[0]),
                    name: clean_value(values[1]),
                    status: clean_value(values[2]),
                    category: clean_value(values[3]),
                    test_file: clean_value(values[4])
                )
                items.push(item)

    items

# Parse row values
fn parse_row_values(row: text) -> [text]:
    var values = []
    var current = ""
    var in_quotes = false

    for i in 0..row.len():
        val ch = row[i:i+1]
        if ch == "\"":
            in_quotes = not in_quotes
        else if ch == "," and not in_quotes:
            values.push(current.trim())
            current = ""
        else:
            current = current + ch

    if current.len() > 0:
        values.push(current.trim())

    values

# Clean value
fn clean_value(value: text) -> text:
    var result = value.trim()
    if result.starts_with("\"") and result.ends_with("\""):
        result = result[1:-1]
    result

# Format summary
fn format_summary(summary: FeatureSummary) -> text:
    if summary.total == 0:
        return "No features found"

    var result = "Features: {summary.total} total\n"
    result = result + "  In Progress: {summary.in_progress}\n"
    result = result + "  Failed: {summary.failed}\n"
    result = result + "  Planned: {summary.planned}\n"

    if summary.incomplete_features.len() > 0:
        result = result + "\nIncomplete Features:\n"
        for item in summary.incomplete_features:
            result = result + "  [{item.status}] {item.name} ({item.category})\n"

    result

