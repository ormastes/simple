# STOMP Message Module

# ============================================================================
# Header Manipulation
# ============================================================================

# Find header value by name
fn get_header_value(headers: list, name: text):
    var i = 0
    while i < headers.len():
        val header = headers[i]
        val header_name = header[0]
        if header_name == name:
            return header[1]
        i = i + 1
    return nil

# Add header to headers list
fn add_header(headers: list, name: text, value: text) -> list:
    var result = []
    var i = 0
    while i < headers.len():
        result.push(headers[i])
        i = i + 1
    result.push((name, value))
    return result

# Remove header from headers list
fn remove_header(headers: list, name: text) -> list:
    var result = []
    var i = 0
    while i < headers.len():
        val header = headers[i]
        val header_name = header[0]
        if header_name != name:
            result.push(header)
        i = i + 1
    return result

# Update header value (replace if exists, add if not)
fn update_header(headers: list, name: text, value: text) -> list:
    val removed = remove_header(headers, name)
    return add_header(removed, name, value)

# Check if header exists
fn has_header(headers: list, name: text) -> bool:
    val value = get_header_value(headers, name)
    return value != nil

# Get all header names
fn get_header_names(headers: list) -> list:
    var result = []
    var i = 0
    while i < headers.len():
        val header = headers[i]
        val name = header[0]
        result.push(name)
        i = i + 1
    return result

# Count headers
fn count_headers(headers: list) -> i64:
    return headers.len()

# Format headers as text (for debugging)
fn format_stomp_headers(headers: list) -> text:
    var result = ""
    var i = 0
    while i < headers.len():
        val header = headers[i]
        val name = header[0]
        val value = header[1]
        result = result + name
        result = result + ": "
        result = result + value
        result = result + "\n"
        i = i + 1
    return result

# ============================================================================
# Header Encoding/Decoding (STOMP 1.2 Escaping)
# ============================================================================

# Encode header value according to STOMP 1.2 rules
# \r -> \r, \n -> \n, \c -> :, \\ -> \
fn encode_stomp_header_value(value: text) -> text:
    var result = ""
    var i = 0
    while i < value.len():
        val ch = value.substring(i, i + 1)

        if ch == "\r":
            result = result + "\\r"
        else:
            if ch == "\n":
                result = result + "\\n"
            else:
                if ch == ":":
                    result = result + "\\c"
                else:
                    if ch == "\\":
                        result = result + "\\\\"
                    else:
                        result = result + ch

        i = i + 1

    return result

# Decode header value according to STOMP 1.2 rules
fn decode_stomp_header_value(value: text) -> text:
    var result = ""
    var i = 0
    while i < value.len():
        val ch = value.substring(i, i + 1)

        if ch == "\\":
            # Check next character
            val next_idx = i + 1
            if next_idx < value.len():
                val next_ch = value.substring(next_idx, next_idx + 1)

                if next_ch == "r":
                    result = result + "\r"
                    i = i + 1
                else:
                    if next_ch == "n":
                        result = result + "\n"
                        i = i + 1
                    else:
                        if next_ch == "c":
                            result = result + ":"
                            i = i + 1
                        else:
                            if next_ch == "\\":
                                result = result + "\\"
                                i = i + 1
                            else:
                                result = result + ch
            else:
                result = result + ch
        else:
            result = result + ch

        i = i + 1

    return result

# ============================================================================
# Transaction Management
# ============================================================================

# Generate unique transaction ID
fn generate_transaction_id(prefix: text, counter: i64) -> text:
    var result = prefix
    result = result + "-"
    result = result + counter.to_text()
    return result

# Check if frame is part of transaction
fn is_transaction_frame(frame: tuple) -> bool:
    val headers = get_frame_headers(frame)
    return has_header(headers, stomp_header_transaction())

# Get transaction ID from frame
fn get_transaction_id(frame: tuple):
    val headers = get_frame_headers(frame)
    return get_header_value(headers, stomp_header_transaction())

# ============================================================================
# Receipt Handling
# ============================================================================

# Get receipt ID from frame (client request)
fn get_receipt_id(frame: tuple):
    val headers = get_frame_headers(frame)
    return get_header_value(headers, stomp_header_receipt())

# Check if frame requests receipt
fn requests_receipt(frame: tuple) -> bool:
    return has_receipt_id(frame)

# Check if frame has receipt header
fn has_receipt_id(frame: tuple) -> bool:
    val headers = get_frame_headers(frame)
    return has_header(headers, stomp_header_receipt())

# Generate unique receipt ID
fn generate_receipt_id(prefix: text, counter: i64) -> text:
    var result = prefix
    result = result + "-"
    result = result + counter.to_text()
    return result

# ============================================================================
# Error Frame Handling
# ============================================================================

# Get error message from ERROR frame
fn get_error_message(frame: tuple):
    val headers = get_frame_headers(frame)
    return get_header_value(headers, "message")

# Get error details from ERROR frame body
fn get_error_details(frame: tuple) -> text:
    return get_frame_body(frame)


# Export all public functions
