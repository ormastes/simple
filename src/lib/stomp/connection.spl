# STOMP Connection Module

# ============================================================================
# Heartbeat Handling
# ============================================================================

# Parse heartbeat value "cx,cy" into tuple (client_send, client_receive)
fn parse_heartbeat(value: text) -> tuple:
    val parts = value.split(",")

    if parts.len() < 2:
        return (0, 0)

    val send_ms = parts[0].to_int()
    val recv_ms = parts[1].to_int()

    return (send_ms, recv_ms)

# Format heartbeat tuple as "cx,cy" string
fn format_heartbeat(send_ms: i64, recv_ms: i64) -> text:
    var result = send_ms.to_text()
    result = result + ","
    result = result + recv_ms.to_text()
    return result

# Calculate negotiated heartbeat values
# Returns: (send_interval, recv_interval)
fn negotiate_heartbeat(client: tuple, server: tuple) -> tuple:
    val client_send = client[0]
    val client_recv = client[1]
    val server_send = server[0]
    val server_recv = server[1]

    # Client will send at max(client_send, server_recv)
    var send_interval = client_send
    if server_recv > send_interval:
        send_interval = server_recv

    # Client will receive at max(client_recv, server_send)
    var recv_interval = client_recv
    if server_send > recv_interval:
        recv_interval = server_send

    # Zero means no heartbeat
    if client_send == 0:
        send_interval = 0

    if server_recv == 0:
        send_interval = 0

    if client_recv == 0:
        recv_interval = 0

    if server_send == 0:
        recv_interval = 0

    return (send_interval, recv_interval)

# Check if heartbeat is disabled
fn is_heartbeat_disabled(heartbeat: tuple) -> bool:
    val send = heartbeat[0]
    val recv = heartbeat[1]

    var both_zero = false
    if send == 0:
        if recv == 0:
            both_zero = true

    return both_zero


# Export all public functions
