# Suffix Tree Lcs Module

# ============================================================================
# Substring Operations
# ============================================================================

fn suffix_tree_longest_repeated_substring(tree: (text, list, i64)) -> text:
    """Find the longest substring that appears at least twice"""
    val text_val = tree.0
    val nodes = tree.1
    val root_id = tree.2

    var max_depth = 0
    var max_node_id = root_id

    var node_idx = 0
    while node_idx < list_length(nodes):
        val node = list_get(nodes, node_idx)
        val children = node.2

        if list_length(children) >= 2:
            val depth = suffix_tree_node_depth(tree, node_idx)
            if depth > max_depth:
                max_depth = depth
                max_node_id = node_idx

        node_idx = node_idx + 1

    if max_depth == 0:
        return ""

    suffix_tree_path_to_node(tree, max_node_id)

fn suffix_tree_longest_common_substring(text1: text, text2: text) -> text:
    """Find longest common substring between two texts"""
    val separator = "#"
    val combined = text_concat(text_concat(text1, separator), text2)
    val tree = suffix_tree_new(combined)

    val len1 = text_length(text1)
    val len2 = text_length(text2)

    var max_depth = 0
    var max_node_id = 0

    val nodes = tree.1
    var node_idx = 0

    while node_idx < list_length(nodes):
        val node = list_get(nodes, node_idx)
        val leaves = suffix_tree_collect_leaves(tree, node_idx)

        var has_text1 = false
        var has_text2 = false

        var leaf_idx = 0
        while leaf_idx < list_length(leaves):
            val pos = list_get(leaves, leaf_idx)
            if pos < len1:
                has_text1 = true
            if pos > len1:
                has_text2 = true
            leaf_idx = leaf_idx + 1

        if has_text1:
            if has_text2:
                val depth = suffix_tree_node_depth(tree, node_idx)
                if depth > max_depth:
                    max_depth = depth
                    max_node_id = node_idx

        node_idx = node_idx + 1

    if max_depth == 0:
        return ""

    suffix_tree_path_to_node(tree, max_node_id)

fn suffix_tree_all_substrings(tree: (text, list, i64)) -> list:
    """Get all unique substrings in the text"""
    val root_id = tree.2
    suffix_tree_collect_substrings(tree, root_id, "")

fn suffix_tree_collect_substrings(tree: (text, list, i64), node_id: i64, prefix: text) -> list:
    """Recursively collect all substrings from subtree"""
    val nodes = tree.1
    val node = list_get(nodes, node_id)
    val children = node.2

    var substrings = []

    if text_length(prefix) > 0:
        substrings = [prefix]

    var child_idx = 0
    while child_idx < list_length(children):
        val child_entry = list_get(children, child_idx)
        val edge_char = child_entry.0
        val child_id = child_entry.1

        val new_prefix = text_concat(prefix, text_from_char(edge_char))
        val child_substrings = suffix_tree_collect_substrings(tree, child_id, new_prefix)
        substrings = list_concat(substrings, child_substrings)

        child_idx = child_idx + 1

    substrings

# ============================================================================
# LCP Array Operations
# ============================================================================

fn suffix_tree_to_lcp_array(tree: (text, list, i64)) -> list:
    """Compute Longest Common Prefix array from suffix tree"""
    val sa = suffix_tree_to_suffix_array(tree)
    suffix_array_compute_lcp(tree.0, sa)

fn suffix_array_compute_lcp(text: text, sa: list) -> list:
    """Compute LCP array from text and suffix array"""
    val n = list_length(sa)
    var lcp = []

    var i = 0
    while i < n - 1:
        val pos1 = list_get(sa, i)
        val pos2 = list_get(sa, i + 1)

        val suffix1 = text_slice_from(text, pos1)
        val suffix2 = text_slice_from(text, pos2)

        val common_len = text_common_prefix_length(suffix1, suffix2)
        lcp = list_append(lcp, common_len)

        i = i + 1

    lcp

fn lcp_array_from_text(text: text) -> list:
    """Build LCP array directly from text"""
    val tree = suffix_tree_new(text)
    suffix_tree_to_lcp_array(tree)

fn lcp_array_query_range(lcp: list, left: i64, right: i64) -> i64:
    """Query minimum LCP value in range [left, right)"""
    var min_val = 999999999
    var i = left

    while i < right:
        if i < list_length(lcp):
            val val_at_i = list_get(lcp, i)
            if val_at_i < min_val:
                min_val = val_at_i
        i = i + 1

    if min_val == 999999999:
        return 0

    min_val

# ============================================================================
# Advanced Queries
# ============================================================================

fn suffix_tree_substring_frequency(tree: (text, list, i64), substring: text) -> i64:
    """Get frequency of substring in text"""
    val occurrences = suffix_tree_find_all_occurrences(tree, substring)
    list_length(occurrences)

fn suffix_tree_all_repeats(tree: (text, list, i64), min_length: i64) -> list:
    """Find all repeated substrings of minimum length"""
    var repeats = []
    val nodes = tree.1
    var node_idx = 0

    while node_idx < list_length(nodes):
        val node = list_get(nodes, node_idx)
        val children = node.2

        if list_length(children) >= 2:
            val depth = suffix_tree_node_depth(tree, node_idx)
            if depth >= min_length:
                val path = suffix_tree_path_to_node(tree, node_idx)
                repeats = list_append(repeats, path)

        node_idx = node_idx + 1

    repeats

fn suffix_tree_maximal_repeats(tree: (text, list, i64)) -> list:
    """Find all maximal repeated substrings"""
    suffix_tree_all_repeats(tree, 1)

fn suffix_tree_supermaximal_repeats(tree: (text, list, i64)) -> list:
    """Find supermaximal repeated substrings (not contained in other repeats)"""
    val repeats = suffix_tree_all_repeats(tree, 1)

    var super_repeats = []
    var i = 0

    while i < list_length(repeats):
        val repeat = list_get(repeats, i)
        var is_super = true
        var j = 0

        while j < list_length(repeats):
            if i != j:
                val other = list_get(repeats, j)
                if text_length(other) > text_length(repeat):
                    if text_contains(other, repeat):
                        is_super = false
                        j = list_length(repeats)

            j = j + 1

        if is_super:
            super_repeats = list_append(super_repeats, repeat)

        i = i + 1

    super_repeats

fn suffix_tree_branching_tandem_repeats(tree: (text, list, i64)) -> list:
    """Find branching tandem repeats (simplified detection)"""
    suffix_tree_all_repeats(tree, 2)

# ============================================================================
# Comparison and Analysis
# ============================================================================

fn suffix_tree_compare_texts(text1: text, text2: text) -> (i64, i64, text):
    """Compare two texts, return (common_substrings, unique1, unique2, lcs)"""
    val lcs = suffix_tree_longest_common_substring(text1, text2)
    val lcs_len = text_length(lcs)

    # Count unique substrings (simplified)
    val tree1 = suffix_tree_new(text1)
    val tree2 = suffix_tree_new(text2)

    val size1 = suffix_tree_size(tree1)
    val size2 = suffix_tree_size(tree2)

    (lcs_len, size1, lcs)

fn suffix_tree_similarity_score(text1: text, text2: text) -> i64:
    """Compute similarity score based on longest common substring"""
    val lcs = suffix_tree_longest_common_substring(text1, text2)
    val lcs_len = text_length(lcs)
    val len1 = text_length(text1)
    val len2 = text_length(text2)

    if len1 == 0:
        if len2 == 0:
            return 100
        return 0

    if len2 == 0:
        return 0

    val avg_len = (len1 + len2) / 2
    (lcs_len * 100) / avg_len

fn suffix_tree_distance(text1: text, text2: text) -> i64:
    """Compute edit distance approximation using LCS"""
    val lcs = suffix_tree_longest_common_substring(text1, text2)
    val lcs_len = text_length(lcs)
    val len1 = text_length(text1)
    val len2 = text_length(text2)

    (len1 - lcs_len) + (len2 - lcs_len)


# Export all public functions
