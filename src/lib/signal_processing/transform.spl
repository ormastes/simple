# Signal Processing - Transform Module
#
# Signal generation, windowing, convolution, correlation, and resampling

use signal_processing.types.{PI, TWO_PI, sin_f64, cos_f64, floor_f64, abs_f64, sqrt_f64, array_mean, array_copy}

# ============================================================================
# SIGNAL GENERATION
# ============================================================================

fn generate_sine(frequency: f64, sample_rate: f64, duration: f64, amplitude: f64, output: list) -> i64:
    # Generate sine wave
    var n_samples = duration * sample_rate
    var i = 0
    while i < n_samples:
        var t = i / sample_rate
        var phase = TWO_PI * frequency * t
        output[i] = amplitude * sin_f64(phase)
        i = i + 1
    return n_samples

fn generate_cosine(frequency: f64, sample_rate: f64, duration: f64, amplitude: f64, output: list) -> i64:
    # Generate cosine wave
    var n_samples = duration * sample_rate
    var i = 0
    while i < n_samples:
        var t = i / sample_rate
        var phase = TWO_PI * frequency * t
        output[i] = amplitude * cos_f64(phase)
        i = i + 1
    return n_samples

fn generate_square(frequency: f64, sample_rate: f64, duration: f64, amplitude: f64, output: list) -> i64:
    # Generate square wave
    var n_samples = duration * sample_rate
    var period = 1.0 / frequency
    var i = 0
    while i < n_samples:
        var t = i / sample_rate
        var phase_time = t - floor_f64(t / period) * period
        if phase_time < period / 2.0:
            output[i] = amplitude
        else:
            output[i] = 0.0 - amplitude
        i = i + 1
    return n_samples

fn generate_sawtooth(frequency: f64, sample_rate: f64, duration: f64, amplitude: f64, output: list) -> i64:
    # Generate sawtooth wave
    var n_samples = duration * sample_rate
    var period = 1.0 / frequency
    var i = 0
    while i < n_samples:
        var t = i / sample_rate
        var phase_time = t - floor_f64(t / period) * period
        output[i] = 2.0 * amplitude * (phase_time / period - 0.5)
        i = i + 1
    return n_samples

fn generate_triangle(frequency: f64, sample_rate: f64, duration: f64, amplitude: f64, output: list) -> i64:
    # Generate triangle wave
    var n_samples = duration * sample_rate
    var period = 1.0 / frequency
    var i = 0
    while i < n_samples:
        var t = i / sample_rate
        var phase_time = t - floor_f64(t / period) * period
        var phase_norm = phase_time / period
        if phase_norm < 0.25:
            output[i] = 4.0 * amplitude * phase_norm
        else:
            if phase_norm < 0.75:
                output[i] = 2.0 * amplitude - 4.0 * amplitude * phase_norm
            else:
                output[i] = 4.0 * amplitude * phase_norm - 4.0 * amplitude
        i = i + 1
    return n_samples

fn generate_white_noise(amplitude: f64, n_samples: i64, seed: i64, output: list):
    # Generate white noise using simple LCG
    var state = seed
    var i = 0
    while i < n_samples:
        state = (state * 1103515245 + 12345) % 2147483648
        var norm = (state / 1073741824.0) - 1.0
        output[i] = amplitude * norm
        i = i + 1
    pass

fn generate_chirp(f_start: f64, f_end: f64, sample_rate: f64, duration: f64, amplitude: f64, output: list) -> i64:
    # Generate linear chirp (frequency sweep)
    var n_samples = duration * sample_rate
    var k = (f_end - f_start) / duration
    var i = 0
    while i < n_samples:
        var t = i / sample_rate
        var phase = TWO_PI * (f_start * t + 0.5 * k * t * t)
        output[i] = amplitude * sin_f64(phase)
        i = i + 1
    return n_samples

# ============================================================================
# CONVOLUTION AND CORRELATION
# ============================================================================

fn convolve(signal: list, sig_len: i64, kernel: list, kern_len: i64, output: list) -> i64:
    # 1D convolution
    var out_len = sig_len + kern_len - 1
    var i = 0
    while i < out_len:
        output[i] = 0.0
        i = i + 1

    i = 0
    while i < sig_len:
        var j = 0
        while j < kern_len:
            var out_idx = i + j
            output[out_idx] = output[out_idx] + signal[i] * kernel[j]
            j = j + 1
        i = i + 1

    return out_len

fn correlate(signal1: list, len1: i64, signal2: list, len2: i64, output: list) -> i64:
    # Cross-correlation
    var out_len = len1 + len2 - 1
    var i = 0
    while i < out_len:
        output[i] = 0.0
        i = i + 1

    i = 0
    while i < len1:
        var j = 0
        while j < len2:
            var out_idx = i + j
            output[out_idx] = output[out_idx] + signal1[i] * signal2[len2 - 1 - j]
            j = j + 1
        i = i + 1

    return out_len

fn autocorrelate(signal: list, n: i64, max_lag: i64, output: list):
    # Autocorrelation
    var lag = 0
    while lag <= max_lag:
        var sum = 0.0
        var i = 0
        while i < n - lag:
            sum = sum + signal[i] * signal[i + lag]
            i = i + 1
        output[lag] = sum / (n - lag)
        lag = lag + 1
    pass

# ============================================================================
# RESAMPLING
# ============================================================================

fn downsample(signal: list, sig_len: i64, factor: i64, output: list) -> i64:
    # Downsample by integer factor
    var out_len = sig_len / factor
    var i = 0
    while i < out_len:
        output[i] = signal[i * factor]
        i = i + 1
    return out_len

fn upsample(signal: list, sig_len: i64, factor: i64, output: list) -> i64:
    # Upsample by integer factor (zero-stuffing)
    var out_len = sig_len * factor
    var i = 0
    while i < out_len:
        output[i] = 0.0
        i = i + 1

    i = 0
    while i < sig_len:
        output[i * factor] = signal[i]
        i = i + 1

    return out_len

fn interpolate_linear(signal: list, sig_len: i64, factor: i64, output: list) -> i64:
    # Linear interpolation upsampling
    var out_len = sig_len * factor

    var i = 0
    while i < sig_len - 1:
        var base_idx = i * factor
        output[base_idx] = signal[i]

        var j = 1
        while j < factor:
            var alpha = j / factor
            var interp_val = signal[i] * (1.0 - alpha) + signal[i + 1] * alpha
            output[base_idx + j] = interp_val
            j = j + 1
        i = i + 1

    output[out_len - 1] = signal[sig_len - 1]
    return out_len

fn resample_ratio(signal: list, sig_len: i64, up_factor: i64, down_factor: i64, output: list) -> i64:
    # Resample by rational ratio (up_factor / down_factor)
    var temp = []
    var temp_len = upsample(signal, sig_len, up_factor, temp)
    return downsample(temp, temp_len, down_factor, output)

# ============================================================================
# DC REMOVAL AND NORMALIZATION
# ============================================================================

fn remove_dc(signal: list, sig_len: i64, output: list):
    # Remove DC component (mean)
    var mean = array_mean(signal, sig_len)
    var i = 0
    while i < sig_len:
        output[i] = signal[i] - mean
        i = i + 1
    pass

fn normalize_signal(signal: list, sig_len: i64, output: list):
    # Normalize signal to [-1, 1]
    var max_abs = 0.0
    var i = 0
    while i < sig_len:
        var abs_val = abs_f64(signal[i])
        if abs_val > max_abs:
            max_abs = abs_val
        i = i + 1

    if max_abs == 0.0:
        array_copy(signal, output, sig_len)
        return pass

    i = 0
    while i < sig_len:
        output[i] = signal[i] / max_abs
        i = i + 1
    pass

fn rms_value(signal: list, sig_len: i64) -> f64:
    # Root mean square value (helper)
    var sum_sq = 0.0
    var i = 0
    while i < sig_len:
        sum_sq = sum_sq + signal[i] * signal[i]
        i = i + 1
    return sqrt_f64(sum_sq / sig_len)

fn normalize_rms(signal: list, sig_len: i64, target_rms: f64, output: list):
    # Normalize signal to target RMS value
    var current_rms = rms_value(signal, sig_len)
    if current_rms == 0.0:
        array_copy(signal, output, sig_len)
        return pass

    var scale = target_rms / current_rms
    var i = 0
    while i < sig_len:
        output[i] = signal[i] * scale
        i = i + 1
    pass

# ============================================================================
# DIFFERENTIATION AND INTEGRATION
# ============================================================================

fn differentiate(signal: list, sig_len: i64, sample_rate: f64, output: list):
    # Numerical differentiation
    output[0] = 0.0
    var i = 1
    while i < sig_len:
        output[i] = (signal[i] - signal[i - 1]) * sample_rate
        i = i + 1
    pass

fn integrate(signal: list, sig_len: i64, sample_period: f64, output: list):
    # Numerical integration (cumulative sum * dt)
    output[0] = signal[0] * sample_period
    var i = 1
    while i < sig_len:
        output[i] = output[i - 1] + signal[i] * sample_period
        i = i + 1
    pass
