# String Core Utilities
#
# Canonical implementations of core string operations.
# These delegate to runtime built-ins when available.
#
# This module provides the foundation for all string operations across the codebase.
# Other modules should import from here rather than re-implementing these functions.

# Import formatting utilities for str_center
use std.format_utils.{align_center}

# ============================================================================
# Basic String Operations (delegate to built-ins)
# ============================================================================

fn str_len(s: text) -> i64:
    """Get string length."""
    s.len()

fn str_concat(a: text, b: text) -> text:
    """Concatenate two strings."""
    a + b

fn str_eq(a: text, b: text) -> bool:
    """Check string equality."""
    a == b

# ============================================================================
# Slicing and Character Access
# ============================================================================

fn str_slice(s: text, start: i64, end_idx: i64) -> text:
    """Extract substring [start, end_idx).
    CRITICAL: Always use s[0:idx] format - never s[:idx] (runtime parser bug)."""
    s[start:end_idx]

fn str_char_at(s: text, idx: i64) -> text:
    """Get character at index. Returns empty string if out of bounds."""
    if idx < 0 or idx >= s.len():
        return ""
    s[idx:idx+1]

fn str_safe_slice(s: text, start: i64, end_idx: i64) -> text:
    """Safe substring extraction with bounds checking."""
    var s_val = start
    var e_val = end_idx
    if s_val < 0:
        s_val = 0
    if e_val > s.len():
        e_val = s.len()
    if s_val >= e_val:
        return ""
    s[s_val:e_val]

# ============================================================================
# Search Operations
# ============================================================================

fn str_contains(s: text, needle: text) -> bool:
    """Check if string contains substring."""
    s.contains(needle)

fn str_starts_with(s: text, prefix: text) -> bool:
    """Check if string starts with prefix."""
    s.starts_with(prefix)

fn str_ends_with(s: text, suffix: text) -> bool:
    """Check if string ends with suffix."""
    s.ends_with(suffix)

fn str_index_of(s: text, needle: text) -> i64:
    """Find first occurrence of substring. Returns -1 if not found."""
    val result = s.index_of(needle)
    if result == nil:
        return -1
    result

fn str_last_index_of(s: text, needle: text) -> i64:
    """Find last occurrence of substring. Returns -1 if not found."""
    var last_pos = -1
    var search_start = 0

    while search_start < s.len():
        val remaining = s[search_start:]
        val pos = str_index_of(remaining, needle)
        if pos == -1:
            break
        last_pos = search_start + pos
        search_start = last_pos + 1

    last_pos

# ============================================================================
# Whitespace Trimming
# ============================================================================

fn is_whitespace_char(c: text) -> bool:
    """Check if character is whitespace."""
    c == " " or c == "\t" or c == "\n" or c == "\r"

fn str_trim(s: text) -> text:
    """Remove leading and trailing whitespace."""
    s.trim()

fn str_trim_left(s: text) -> text:
    """Remove leading whitespace."""
    var result = s
    while result.len() > 0 and is_whitespace_char(result[0:1]):
        result = result[1:]
    result

fn str_trim_right(s: text) -> text:
    """Remove trailing whitespace."""
    var result = s
    while result.len() > 0:
        val last_idx = result.len() - 1
        val ch = result[last_idx:last_idx+1]
        if ch != " " and ch != "\t" and ch != "\n" and ch != "\r":
            break
        result = result[0:last_idx]
    result

# ============================================================================
# String Replacement
# ============================================================================

fn str_replace(s: text, old_val: text, new_val: text) -> text:
    """Replace first occurrence of old with new."""
    s.replace(old_val, new_val)

fn str_replace_all(s: text, old_val: text, new_val: text) -> text:
    """Replace all occurrences of old with new.
    CRITICAL: Avoid chained method calls (runtime bug) - use intermediate var."""
    var result = s
    while result.contains(old_val):
        result = result.replace(old_val, new_val)
    result

# ============================================================================
# Split and Join
# ============================================================================

fn str_split(s: text, delimiter: text) -> [text]:
    """Split string by delimiter."""
    s.split(delimiter)

fn str_join(parts: [text], separator: text) -> text:
    """Join strings with separator."""
    parts.join(separator)

# ============================================================================
# ASCII Character Helpers (inlined to avoid circular deps)
# ============================================================================

fn char_code_inline(c: text) -> i64:
    """Get ASCII code of single character. Returns 0 for unknown characters.

    Includes full punctuation support for proper text processing."""
    if c == " ": return 32
    if c == "!": return 33
    if c == "#": return 35
    if c == "$": return 36
    if c == "%": return 37
    if c == "&": return 38
    if c == "'": return 39
    if c == "(": return 40
    if c == ")": return 41
    if c == "*": return 42
    if c == "+": return 43
    if c == ",": return 44
    if c == "-": return 45
    if c == ".": return 46
    if c == "/": return 47
    if c == "0": return 48
    if c == "1": return 49
    if c == "2": return 50
    if c == "3": return 51
    if c == "4": return 52
    if c == "5": return 53
    if c == "6": return 54
    if c == "7": return 55
    if c == "8": return 56
    if c == "9": return 57
    if c == ":": return 58
    if c == ";": return 59
    if c == "<": return 60
    if c == "=": return 61
    if c == ">": return 62
    if c == "?": return 63
    if c == "@": return 64
    if c == "A": return 65
    if c == "B": return 66
    if c == "C": return 67
    if c == "D": return 68
    if c == "E": return 69
    if c == "F": return 70
    if c == "G": return 71
    if c == "H": return 72
    if c == "I": return 73
    if c == "J": return 74
    if c == "K": return 75
    if c == "L": return 76
    if c == "M": return 77
    if c == "N": return 78
    if c == "O": return 79
    if c == "P": return 80
    if c == "Q": return 81
    if c == "R": return 82
    if c == "S": return 83
    if c == "T": return 84
    if c == "U": return 85
    if c == "V": return 86
    if c == "W": return 87
    if c == "X": return 88
    if c == "Y": return 89
    if c == "Z": return 90
    if c == "[": return 91
    if c == "]": return 93
    if c == "^": return 94
    if c == "_": return 95
    if c == "a": return 97
    if c == "b": return 98
    if c == "c": return 99
    if c == "d": return 100
    if c == "e": return 101
    if c == "f": return 102
    if c == "g": return 103
    if c == "h": return 104
    if c == "i": return 105
    if c == "j": return 106
    if c == "k": return 107
    if c == "l": return 108
    if c == "m": return 109
    if c == "n": return 110
    if c == "o": return 111
    if c == "p": return 112
    if c == "q": return 113
    if c == "r": return 114
    if c == "s": return 115
    if c == "t": return 116
    if c == "u": return 117
    if c == "v": return 118
    if c == "w": return 119
    if c == "x": return 120
    if c == "y": return 121
    if c == "z": return 122
    if c == "{": return 123
    if c == "|": return 124
    if c == "}": return 125
    if c == "~": return 126
    if c == "\n": return 10
    if c == "\t": return 9
    if c == "\r": return 13
    0

fn char_from_code_inline(code: i64) -> text:
    """Convert ASCII code to character. Returns empty string for unknown codes.

    Includes full punctuation support for proper text processing."""
    if code == 32: return " "
    if code == 33: return "!"
    if code == 35: return "#"
    if code == 36: return "$"
    if code == 37: return "%"
    if code == 38: return "&"
    if code == 39: return "'"
    if code == 40: return "("
    if code == 41: return ")"
    if code == 42: return "*"
    if code == 43: return "+"
    if code == 44: return ","
    if code == 45: return "-"
    if code == 46: return "."
    if code == 47: return "/"
    if code == 48: return "0"
    if code == 49: return "1"
    if code == 50: return "2"
    if code == 51: return "3"
    if code == 52: return "4"
    if code == 53: return "5"
    if code == 54: return "6"
    if code == 55: return "7"
    if code == 56: return "8"
    if code == 57: return "9"
    if code == 58: return ":"
    if code == 59: return ";"
    if code == 60: return "<"
    if code == 61: return "="
    if code == 62: return ">"
    if code == 63: return "?"
    if code == 64: return "@"
    if code == 65: return "A"
    if code == 66: return "B"
    if code == 67: return "C"
    if code == 68: return "D"
    if code == 69: return "E"
    if code == 70: return "F"
    if code == 71: return "G"
    if code == 72: return "H"
    if code == 73: return "I"
    if code == 74: return "J"
    if code == 75: return "K"
    if code == 76: return "L"
    if code == 77: return "M"
    if code == 78: return "N"
    if code == 79: return "O"
    if code == 80: return "P"
    if code == 81: return "Q"
    if code == 82: return "R"
    if code == 83: return "S"
    if code == 84: return "T"
    if code == 85: return "U"
    if code == 86: return "V"
    if code == 87: return "W"
    if code == 88: return "X"
    if code == 89: return "Y"
    if code == 90: return "Z"
    if code == 91: return "["
    if code == 93: return "]"
    if code == 94: return "^"
    if code == 95: return "_"
    if code == 97: return "a"
    if code == 98: return "b"
    if code == 99: return "c"
    if code == 100: return "d"
    if code == 101: return "e"
    if code == 102: return "f"
    if code == 103: return "g"
    if code == 104: return "h"
    if code == 105: return "i"
    if code == 106: return "j"
    if code == 107: return "k"
    if code == 108: return "l"
    if code == 109: return "m"
    if code == 110: return "n"
    if code == 111: return "o"
    if code == 112: return "p"
    if code == 113: return "q"
    if code == 114: return "r"
    if code == 115: return "s"
    if code == 116: return "t"
    if code == 117: return "u"
    if code == 118: return "v"
    if code == 119: return "w"
    if code == 120: return "x"
    if code == 121: return "y"
    if code == 122: return "z"
    if code == 123: return "{"
    if code == 124: return "|"
    if code == 125: return "}"
    if code == 126: return "~"
    if code == 10: return "\n"
    if code == 9: return "\t"
    if code == 13: return "\r"
    ""

# ============================================================================
# Character Classification
# ============================================================================

fn is_alpha_char(c: text) -> bool:
    """Check if character is alphabetic (a-z, A-Z)."""
    val code = char_code_inline(c)
    (code >= 65 and code <= 90) or (code >= 97 and code <= 122)

fn is_digit_char(c: text) -> bool:
    """Check if character is a digit (0-9)."""
    val code = char_code_inline(c)
    code >= 48 and code <= 57

fn is_alnum_char(c: text) -> bool:
    """Check if character is alphanumeric."""
    is_alpha_char(c) or is_digit_char(c)

# ============================================================================
# Case Conversion
# ============================================================================

fn str_to_lower(s: text) -> text:
    """Convert string to lowercase (ASCII only)."""
    var result = ""
    var i = 0
    while i < s.len():
        val ch = s[i:i+1]
        val code = char_code_inline(ch)
        if code >= 65 and code <= 90:
            result = result + char_from_code_inline(code + 32)
        else:
            result = result + ch
        i = i + 1
    result

fn str_to_upper(s: text) -> text:
    """Convert string to uppercase (ASCII only)."""
    var result = ""
    var i = 0
    while i < s.len():
        val ch = s[i:i+1]
        val code = char_code_inline(ch)
        if code >= 97 and code <= 122:
            result = result + char_from_code_inline(code - 32)
        else:
            result = result + ch
        i = i + 1
    result

fn str_capitalize(s: text) -> text:
    """Capitalize first character of string."""
    if s.len() == 0:
        return s
    val first = str_to_upper(s[0:1])
    val rest = s[1:]
    first + rest

# ============================================================================
# String Manipulation
# ============================================================================

fn str_reverse(s: text) -> text:
    """Reverse a string."""
    var result = ""
    var i = s.len() - 1
    while i >= 0:
        result = result + s[i:i+1]
        i = i - 1
    result

fn str_repeat(s: text, count: i64) -> text:
    """Repeat string count times."""
    var result = ""
    var i = 0
    while i < count:
        result = result + s
        i = i + 1
    result

fn str_truncate(s: text, max_len: i64) -> text:
    """Truncate string to max length with ellipsis."""
    if s.len() <= max_len:
        return s
    s[0:max_len] + "..."

fn str_pad_left(s: text, width: i64, pad: text) -> text:
    """Pad string on the left to reach desired width."""
    var result = s
    while result.len() < width:
        result = pad + result
    result

fn str_pad_right(s: text, width: i64, pad: text) -> text:
    """Pad string on the right to reach desired width."""
    var result = s
    while result.len() < width:
        result = result + pad
    result

fn str_center(s: text, width: i64) -> text:
    """Center string within width.

    Delegates to align_center() from std.format_utils.
    """
    align_center(s, width, " ")

# ============================================================================
# Compatibility Aliases
# ============================================================================

fn char_code(c: text) -> i64:
    """Alias for char_code_inline (compatibility with text.spl)."""
    char_code_inline(c)

fn char_from_code(code: i64) -> text:
    """Alias for char_from_code_inline (compatibility with text.spl)."""
    char_from_code_inline(code)

# ============================================================================
# Exports
# ============================================================================

# Basic operations
export str_len, str_concat, str_eq

# Slicing and access
export str_slice, str_char_at, str_safe_slice

# Search
export str_contains, str_starts_with, str_ends_with
export str_index_of, str_last_index_of

# Trimming
export is_whitespace_char
export str_trim, str_trim_left, str_trim_right

# Replacement
export str_replace, str_replace_all

# Split and join
export str_split, str_join

# Character classification
export is_alpha_char, is_digit_char, is_alnum_char

# Character code conversion
export char_code_inline, char_from_code_inline, char_code, char_from_code

# Case conversion
export str_to_lower, str_to_upper, str_capitalize

# Manipulation
export str_reverse, str_repeat, str_truncate
export str_pad_left, str_pad_right, str_center
