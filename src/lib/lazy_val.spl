# Lazy Evaluation and Memoization
#
# Provides Lazy values with deferred evaluation and Memo for caching.

# --- LazyStatus enum ---

enum LazyStatus:
    Pending
    Evaluating
    Ready
    Failed

# --- LazyState ---

class LazyState:
    tag: LazyStatus
    value: i64
    error_msg: text

fn LazyState__Pending() -> LazyState:
    LazyState(tag: LazyStatus.Pending, value: 0, error_msg: "")

fn LazyState__Evaluating() -> LazyState:
    LazyState(tag: LazyStatus.Evaluating, value: 0, error_msg: "")

fn LazyState__Ready(v) -> LazyState:
    LazyState(tag: LazyStatus.Ready, value: v, error_msg: "")

fn LazyState__Failed(msg: text) -> LazyState:
    LazyState(tag: LazyStatus.Failed, value: 0, error_msg: msg)

fn lazy_state_is_pending(s: LazyState) -> bool:
    s.tag == LazyStatus.Pending

fn lazy_state_is_ready(s: LazyState) -> bool:
    s.tag == LazyStatus.Ready

fn lazy_state_is_evaluating(s: LazyState) -> bool:
    s.tag == LazyStatus.Evaluating

fn lazy_state_is_failed(s: LazyState) -> bool:
    s.tag == LazyStatus.Failed

# --- LazyError ---

class LazyError:
    tag: text
    msg: text

fn LazyError__CycleDetected() -> LazyError:
    LazyError(tag: "cycle", msg: "Cycle detected in lazy evaluation")

fn LazyError__EvaluationFailed(msg: text) -> LazyError:
    LazyError(tag: "eval_failed", msg: msg)

fn lazy_error_message(err: LazyError) -> text:
    err.msg

# --- Lazy Stats (module-level) ---

var lazy_total_created: i64 = 0
var lazy_total_forced: i64 = 0
var lazy_cache_hits: i64 = 0
var lazy_cache_misses: i64 = 0

class LazyStats:
    total_created: i64
    total_forced: i64
    cache_hits: i64
    cache_misses: i64

    fn hit_rate() -> f64:
        val total = self.cache_hits + self.cache_misses
        if total == 0:
            return 0.0
        self.cache_hits * 1.0 / total

fn reset_lazy_stats():
    lazy_total_created = 0
    lazy_total_forced = 0
    lazy_cache_hits = 0
    lazy_cache_misses = 0

fn get_lazy_stats() -> LazyStats:
    LazyStats(
        total_created: lazy_total_created,
        total_forced: lazy_total_forced,
        cache_hits: lazy_cache_hits,
        cache_misses: lazy_cache_misses
    )

# --- Lazy ---

class Lazy:
    state_tag: LazyStatus
    cached_value: i64
    thunk: fn()
    error_msg: text

    fn is_evaluated() -> bool:
        self.state_tag == LazyStatus.Ready

    fn is_pending() -> bool:
        self.state_tag == LazyStatus.Pending

    fn is_failed() -> bool:
        self.state_tag == LazyStatus.Failed

    fn get():
        if self.state_tag == LazyStatus.Ready:
            return self.cached_value
        nil

    me force():
        if self.state_tag == LazyStatus.Ready:
            lazy_cache_hits = lazy_cache_hits + 1
            return self.cached_value
        if self.state_tag == LazyStatus.Failed:
            return nil
        if self.state_tag == LazyStatus.Evaluating:
            self.state_tag = LazyStatus.Failed
            self.error_msg = "Cycle detected"
            return nil
        # Pending — evaluate
        self.state_tag = LazyStatus.Evaluating
        val result = self.thunk()
        self.state_tag = LazyStatus.Ready
        self.cached_value = result
        lazy_total_forced = lazy_total_forced + 1
        lazy_cache_misses = lazy_cache_misses + 1
        result

    me force_or_default(default_val):
        val result = self.force()
        if self.state_tag == LazyStatus.Failed:
            return default_val
        if result == nil:
            if self.state_tag == LazyStatus.Ready:
                return result
            return default_val
        result

    fn map(f: fn()) -> Lazy:
        val original = self
        val thunk = fn():
            var orig = original
            val v = orig.force()
            f(v)
        Lazy__new(thunk)

    fn flat_map(f: fn()) -> Lazy:
        val original = self
        val thunk = fn():
            var orig = original
            val v = orig.force()
            var inner = f(v)
            inner.force()
        Lazy__new(thunk)

    fn zip(other: Lazy) -> Lazy:
        val self_ref = self
        val thunk = fn():
            var s = self_ref
            var o = other
            val a = s.force()
            val b = o.force()
            [a, b]
        Lazy__new(thunk)

    fn filter(pred: fn()) -> Lazy:
        val original = self
        val thunk = fn():
            var orig = original
            val v = orig.force()
            if pred(v):
                return v
            nil
        Lazy__new(thunk)

    fn fmt() -> text:
        if self.state_tag == "pending":
            return "Lazy(pending)"
        if self.state_tag == "ready":
            return "Lazy(ready: {self.cached_value})"
        if self.state_tag == "failed":
            return "Lazy(failed: {self.error_msg})"
        "Lazy(evaluating)"

    fn state() -> LazyState:
        if self.state_tag == "pending":
            return LazyState__Pending()
        if self.state_tag == "ready":
            return LazyState__Ready(self.cached_value)
        if self.state_tag == "evaluating":
            return LazyState__Evaluating()
        LazyState__Failed(self.error_msg)

fn Lazy__new(thunk: fn()) -> Lazy:
    lazy_total_created = lazy_total_created + 1
    Lazy(state_tag: "pending", cached_value: 0, thunk: thunk, error_msg: "")

fn Lazy__of(value) -> Lazy:
    lazy_total_created = lazy_total_created + 1
    Lazy(state_tag: "ready", cached_value: value, thunk: fn(): value, error_msg: "")

fn Lazy__failed(msg: text) -> Lazy:
    lazy_total_created = lazy_total_created + 1
    Lazy(state_tag: "failed", cached_value: 0, thunk: fn(): 0, error_msg: msg)

fn lazy(thunk: fn()) -> Lazy:
    Lazy__new(thunk)

# --- Memo ---

class MemoStats:
    total_lookups: i64
    cache_hits: i64
    cache_misses: i64

    fn hit_rate() -> f64:
        if self.total_lookups == 0:
            return 0.0
        self.cache_hits * 1.0 / self.total_lookups

class Memo:
    memo_keys: [i64]
    memo_values: []
    stats_lookups: i64
    stats_hits: i64
    stats_misses: i64

    me get_or_compute(key, compute_fn: fn()):
        self.stats_lookups = self.stats_lookups + 1
        var idx = 0
        for k in self.memo_keys:
            if k == key:
                self.stats_hits = self.stats_hits + 1
                return self.memo_values[idx]
            idx = idx + 1
        # Not found — compute
        self.stats_misses = self.stats_misses + 1
        val result = compute_fn()
        self.memo_keys.push(key)
        self.memo_values.push(result)
        result

    fn get(key):
        var idx = 0
        for k in self.memo_keys:
            if k == key:
                return self.memo_values[idx]
            idx = idx + 1
        nil

    fn contains(key) -> bool:
        for k in self.memo_keys:
            if k == key:
                return true
        false

    me clear():
        self.memo_keys = []
        self.memo_values = []

    fn size() -> i64:
        self.memo_keys.len()

    fn get_stats() -> MemoStats:
        MemoStats(
            total_lookups: self.stats_lookups,
            cache_hits: self.stats_hits,
            cache_misses: self.stats_misses
        )

fn Memo__new() -> Memo:
    Memo(memo_keys: [], memo_values: [], stats_lookups: 0, stats_hits: 0, stats_misses: 0)

export LazyState, LazyState__Pending, LazyState__Evaluating, LazyState__Ready, LazyState__Failed
export lazy_state_is_pending, lazy_state_is_ready, lazy_state_is_evaluating, lazy_state_is_failed
export LazyError, LazyError__CycleDetected, LazyError__EvaluationFailed, lazy_error_message
export LazyStats, reset_lazy_stats, get_lazy_stats
export Lazy, Lazy__new, Lazy__of, Lazy__failed, lazy
export MemoStats, Memo, Memo__new
