# MCP Lazy Handler Registry (v2)
#
# Uses parallel arrays instead of structs with function fields
# Workaround for runtime limitation: can't store/call functions in struct fields

# Handler metadata (registered at startup, no imports)
class HandlerMetadata:
    name: text
    category: text

# Registry state - parallel arrays
var HANDLER_NAMES: [text] = []
var HANDLER_CATEGORIES: [text] = []
var LOADED_CATEGORIES: [text] = []

# Note: We can't store function references in arrays at runtime
# So category loaders will use direct dispatch instead

# Initialize registry
fn init_registry():
    HANDLER_NAMES = []
    HANDLER_CATEGORIES = []
    LOADED_CATEGORIES = []

# Register handler metadata
fn register_handler_metadata(name: text, category: text):
    HANDLER_NAMES = HANDLER_NAMES + [name]
    HANDLER_CATEGORIES = HANDLER_CATEGORIES + [category]

# Get category for a tool name
fn get_tool_category(tool_name: text) -> text:
    var i = 0
    for name in HANDLER_NAMES:
        if name == tool_name:
            return HANDLER_CATEGORIES[i]
        i = i + 1
    "unknown"

# Check if category is loaded
fn is_category_loaded(category: text) -> bool:
    for cat in LOADED_CATEGORIES:
        if cat == category:
            return true
    false

# Mark category as loaded
fn mark_category_loaded(category: text):
    if not is_category_loaded(category):
        LOADED_CATEGORIES = LOADED_CATEGORIES + [category]

# Get registry stats
fn get_registry_stats() -> text:
    var total = 0
    for name in HANDLER_NAMES:
        total = total + 1

    var loaded_cats = 0
    for cat in LOADED_CATEGORIES:
        loaded_cats = loaded_cats + 1

    "Registry: {total} handlers, {loaded_cats} categories loaded"

# Export
export init_registry
export register_handler_metadata, get_tool_category
export is_category_loaded, mark_category_loaded
export get_registry_stats
