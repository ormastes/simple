# MCP Library - Core Types & State Management
#
# Provides core MCP types, state management, and factory functions.
# Extracted from app.mcp to enable reuse across tools.

# Core MCP state
class McpState:
    protocol_version: text
    capabilities: text
    initialized: bool
    client_info: text

# Tool handler definition (for lazy loading)
class ToolHandler:
    name: text
    description: text
    schema: text           # Pre-computed JSON schema
    handler_module: text   # Module path (for lazy loading)
    handler_fn: text       # Function name in module
    loaded: bool           # Whether handler has been loaded

# Resource handler definition
class ResourceHandler:
    uri_pattern: text
    handler_module: text
    handler_fn: text
    loaded: bool

# Prompt handler definition
class PromptHandler:
    name: text
    handler_module: text
    handler_fn: text
    loaded: bool

# Factory: Create empty MCP state
fn create_mcp_state() -> McpState:
    McpState(
        protocol_version: "",
        capabilities: "",
        initialized: false,
        client_info: ""
    )

# Factory: Create tool handler definition
fn create_tool_handler(name: text, description: text, schema: text, module: text, fn_name: text) -> ToolHandler:
    ToolHandler(
        name: name,
        description: description,
        schema: schema,
        handler_module: module,
        handler_fn: fn_name,
        loaded: false
    )

# Factory: Create resource handler definition
fn create_resource_handler(pattern: text, module: text, fn_name: text) -> ResourceHandler:
    ResourceHandler(
        uri_pattern: pattern,
        handler_module: module,
        handler_fn: fn_name,
        loaded: false
    )

# Factory: Create prompt handler definition
fn create_prompt_handler(name: text, module: text, fn_name: text) -> PromptHandler:
    PromptHandler(
        name: name,
        handler_module: module,
        handler_fn: fn_name,
        loaded: false
    )

# Session management for stateful operations
class SessionManager:
    sessions: [text]       # Active session IDs
    next_id: i64

fn create_session_manager() -> SessionManager:
    SessionManager(
        sessions: [],
        next_id: 1
    )

me add_session(sm: SessionManager) -> text:
    val id = "session_{sm.next_id}"
    sm.sessions = sm.sessions + [id]
    sm.next_id = sm.next_id + 1
    id

me remove_session(sm: SessionManager, id: text):
    var filtered = []
    for session in sm.sessions:
        if session != id:
            filtered = filtered + [session]
    sm.sessions = filtered

fn session_exists(sm: SessionManager, id: text) -> bool:
    for session in sm.sessions:
        if session == id:
            return true
    false
