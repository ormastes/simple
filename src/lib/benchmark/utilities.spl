# Benchmark Utility Functions

# ============================================================================
# Utilities
# ============================================================================

fn benchmark_count(suite):
    """Get count of benchmarks in suite.

    Example:
        val count = benchmark_count(suite)
    """
    val (_, benchmarks, _) = suite
    benchmarks.len()

fn get_benchmark_names(suite):
    """Get list of benchmark names.

    Returns: Array of names
    """
    val (_, benchmarks, _) = suite
    var names = []

    for benchmark in benchmarks:
        val (name, _, _, _) = benchmark
        names.push(name)

    names

fn find_fastest_result(results):
    """Find result with lowest mean time.

    Returns: Fastest result tuple
    """
    if results.len() == 0:
        return nil

    var fastest = results[0]
    var fastest_mean = get_stat_mean(get_result_stats(fastest))

    var i = 1
    while i < results.len():
        val current = results[i]
        val current_stats = get_result_stats(current)
        val current_mean = get_stat_mean(current_stats)

        if current_mean < fastest_mean:
            fastest = current
            fastest_mean = current_mean

        i = i + 1

    fastest

fn find_slowest_result(results):
    """Find result with highest mean time.

    Returns: Slowest result tuple
    """
    if results.len() == 0:
        return nil

    var slowest = results[0]
    var slowest_mean = get_stat_mean(get_result_stats(slowest))

    var i = 1
    while i < results.len():
        val current = results[i]
        val current_stats = get_result_stats(current)
        val current_mean = get_stat_mean(current_stats)

        if current_mean > slowest_mean:
            slowest = current
            slowest_mean = current_mean

        i = i + 1

    slowest

# ============================================================================
# Advanced Benchmarking
# ============================================================================

fn benchmark_convergence(bench_fn, max_iterations: i64, convergence_threshold: i64):
    """Run benchmark until results converge.

    Runs until coefficient of variation is below threshold.

    Returns: Benchmark result
    """
    var all_timings = []
    var iterations = 0
    var converged = false

    while iterations < max_iterations and not converged:
        val timing = time_function(bench_fn)
        all_timings.push(timing)
        iterations = iterations + 1

        if iterations >= 10:
            val cv = coefficient_of_variation(all_timings)
            if cv < convergence_threshold:
                converged = true

    create_result("convergence", all_timings)

fn benchmark_adaptive(bench_fn, target_time: i64):
    """Run benchmark adaptively to reach target total time.

    Automatically determines iteration count.

    Returns: Benchmark result
    """
    # Quick sampling to estimate iteration time
    val sample_timing = time_function(bench_fn)

    var estimated_iterations = 100
    if sample_timing > 0:
        estimated_iterations = target_time / sample_timing

    if estimated_iterations < 10:
        estimated_iterations = 10
    if estimated_iterations > 10000:
        estimated_iterations = 10000

    run_benchmark(bench_fn, estimated_iterations)

# ============================================================================
