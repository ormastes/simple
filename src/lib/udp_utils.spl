# UDP Socket Utilities Module
# Comprehensive UDP datagram operations and socket management
#
# This module provides UDP socket utilities focusing on protocol logic
# and datagram operations without actual system socket implementation.

# ============================================================================
# Core Data Structures
# ============================================================================

# UDP Socket representation
# Fields: address (text), port (i64), state (text), broadcast_enabled (i64),
#         recv_buffer_size (i64), send_buffer_size (i64)
class UdpSocket:
    address: text
    port: i64
    state: text
    broadcast_enabled: i64
    recv_buffer_size: i64
    send_buffer_size: i64
    multicast_ttl: i64
    multicast_groups: text

# Datagram representation (tuple-based for runtime compatibility)
# Format: (src_addr, src_port, dst_addr, dst_port, payload)
# Using class for better structure
class Datagram:
    src_addr: text
    src_port: i64
    dst_addr: text
    dst_port: i64
    payload: text

# Socket state constants
fn socket_state_unbound() -> text:
    "UNBOUND"

fn socket_state_bound() -> text:
    "BOUND"

fn socket_state_closed() -> text:
    "CLOSED"

# Maximum datagram size (65,507 bytes: 65,535 - 8 byte UDP header - 20 byte IP header)
fn max_datagram_size() -> i64:
    65507

# Maximum port number
fn max_port_number() -> i64:
    65535

# Minimum port number (well-known ports start at 0)
fn min_port_number() -> i64:
    0

# Default buffer sizes
fn default_recv_buffer_size() -> i64:
    65536

fn default_send_buffer_size() -> i64:
    65536

# Default multicast TTL
fn default_multicast_ttl() -> i64:
    1

# ============================================================================
# Socket Creation and Initialization
# ============================================================================

fn create_udp_socket() -> UdpSocket:
    # Create a new UDP socket in unbound state
    val socket = UdpSocket(
        address: "",
        port: 0,
        state: socket_state_unbound(),
        broadcast_enabled: 0,
        recv_buffer_size: default_recv_buffer_size(),
        send_buffer_size: default_send_buffer_size(),
        multicast_ttl: default_multicast_ttl(),
        multicast_groups: ""
    )
    socket

fn create_udp_socket_with_buffer_sizes(recv_size: i64, send_size: i64) -> UdpSocket:
    # Create a new UDP socket with custom buffer sizes
    val socket = UdpSocket(
        address: "",
        port: 0,
        state: socket_state_unbound(),
        broadcast_enabled: 0,
        recv_buffer_size: recv_size,
        send_buffer_size: send_size,
        multicast_ttl: default_multicast_ttl(),
        multicast_groups: ""
    )
    socket

# ============================================================================
# Socket Operations
# ============================================================================

fn bind_socket(socket: UdpSocket, address: text, port: i64) -> UdpSocket:
    # Bind socket to address and port
    val new_state = socket_state_bound()
    val bound_socket = UdpSocket(
        address: address,
        port: port,
        state: new_state,
        broadcast_enabled: socket.broadcast_enabled,
        recv_buffer_size: socket.recv_buffer_size,
        send_buffer_size: socket.send_buffer_size,
        multicast_ttl: socket.multicast_ttl,
        multicast_groups: socket.multicast_groups
    )
    bound_socket

fn close_socket(socket: UdpSocket) -> UdpSocket:
    # Close the socket
    val new_state = socket_state_closed()
    val closed_socket = UdpSocket(
        address: socket.address,
        port: socket.port,
        state: new_state,
        broadcast_enabled: 0,
        recv_buffer_size: socket.recv_buffer_size,
        send_buffer_size: socket.send_buffer_size,
        multicast_ttl: socket.multicast_ttl,
        multicast_groups: ""
    )
    closed_socket

fn is_socket_bound(socket: UdpSocket) -> i64:
    # Check if socket is bound
    val bound_state = socket_state_bound()
    val result = socket.state == bound_state
    if result:
        1
    else:
        0

fn is_socket_closed(socket: UdpSocket) -> i64:
    # Check if socket is closed
    val closed_state = socket_state_closed()
    val result = socket.state == closed_state
    if result:
        1
    else:
        0

fn get_socket_address(socket: UdpSocket) -> text:
    # Get socket's bound address
    socket.address

fn get_socket_port(socket: UdpSocket) -> i64:
    # Get socket's bound port
    socket.port

# ============================================================================
# Datagram Creation and Access
# ============================================================================

fn create_datagram(src_addr: text, src_port: i64, dst_addr: text, dst_port: i64, payload: text) -> Datagram:
    # Create a new datagram
    val datagram = Datagram(
        src_addr: src_addr,
        src_port: src_port,
        dst_addr: dst_addr,
        dst_port: dst_port,
        payload: payload
    )
    datagram

fn get_datagram_src_addr(datagram: Datagram) -> text:
    # Get source address from datagram
    datagram.src_addr

fn get_datagram_src_port(datagram: Datagram) -> i64:
    # Get source port from datagram
    datagram.src_port

fn get_datagram_dst_addr(datagram: Datagram) -> text:
    # Get destination address from datagram
    datagram.dst_addr

fn get_datagram_dst_port(datagram: Datagram) -> i64:
    # Get destination port from datagram
    datagram.dst_port

fn get_datagram_payload(datagram: Datagram) -> text:
    # Get payload from datagram
    datagram.payload

fn get_datagram_size(datagram: Datagram) -> i64:
    # Calculate datagram size (payload length + 8 byte UDP header)
    val payload_size = datagram.payload.len()
    val total_size = payload_size + 8
    total_size

# ============================================================================
# Port Validation
# ============================================================================

fn is_valid_port(port: i64) -> i64:
    # Check if port number is valid (0-65535)
    val min_port = min_port_number()
    val max_port = max_port_number()
    val is_valid = port >= min_port and port <= max_port
    if is_valid:
        1
    else:
        0

fn is_well_known_port(port: i64) -> i64:
    # Check if port is in well-known range (0-1023)
    val is_valid = port >= 0 and port <= 1023
    if is_valid:
        1
    else:
        0

fn is_registered_port(port: i64) -> i64:
    # Check if port is in registered range (1024-49151)
    val is_valid = port >= 1024 and port <= 49151
    if is_valid:
        1
    else:
        0

fn is_dynamic_port(port: i64) -> i64:
    # Check if port is in dynamic/private range (49152-65535)
    val is_valid = port >= 49152 and port <= 65535
    if is_valid:
        1
    else:
        0

# ============================================================================
# Address Validation
# ============================================================================

fn is_ipv4_address(address: text) -> i64:
    # Simple IPv4 address validation (contains dots)
    val has_dots = address.contains(".")
    if has_dots:
        1
    else:
        0

fn is_ipv6_address(address: text) -> i64:
    # Simple IPv6 address validation (contains colons)
    val has_colons = address.contains(":")
    if has_colons:
        1
    else:
        0

fn is_multicast_ipv4(address: text) -> i64:
    # Check if IPv4 address is multicast (224.0.0.0 to 239.255.255.255)
    val starts_with_224 = address.starts_with("224.")
    val starts_with_239 = address.starts_with("239.")
    val starts_with_225 = address.starts_with("225.")
    val starts_with_226 = address.starts_with("226.")
    val starts_with_227 = address.starts_with("227.")
    val starts_with_228 = address.starts_with("228.")
    val starts_with_229 = address.starts_with("229.")
    val starts_with_230 = address.starts_with("230.")
    val starts_with_231 = address.starts_with("231.")
    val starts_with_232 = address.starts_with("232.")
    val starts_with_233 = address.starts_with("233.")
    val starts_with_234 = address.starts_with("234.")
    val starts_with_235 = address.starts_with("235.")
    val starts_with_236 = address.starts_with("236.")
    val starts_with_237 = address.starts_with("237.")
    val starts_with_238 = address.starts_with("238.")

    val is_multicast = starts_with_224 or starts_with_225 or starts_with_226 or starts_with_227
    val is_multicast2 = is_multicast or starts_with_228 or starts_with_229 or starts_with_230
    val is_multicast3 = is_multicast2 or starts_with_231 or starts_with_232 or starts_with_233
    val is_multicast4 = is_multicast3 or starts_with_234 or starts_with_235 or starts_with_236
    val is_multicast5 = is_multicast4 or starts_with_237 or starts_with_238 or starts_with_239

    if is_multicast5:
        1
    else:
        0

fn is_broadcast_address(address: text) -> i64:
    # Check if address is broadcast address (255.255.255.255)
    val is_broadcast = address == "255.255.255.255"
    if is_broadcast:
        1
    else:
        0

fn is_loopback_address(address: text) -> i64:
    # Check if address is loopback (127.x.x.x for IPv4, ::1 for IPv6)
    val is_ipv4_loopback = address.starts_with("127.")
    val is_ipv6_loopback = address == "::1"
    val is_loopback = is_ipv4_loopback or is_ipv6_loopback
    if is_loopback:
        1
    else:
        0

fn is_any_address(address: text) -> i64:
    # Check if address is any address (0.0.0.0 for IPv4, :: for IPv6)
    val is_ipv4_any = address == "0.0.0.0"
    val is_ipv6_any = address == "::"
    val is_any = is_ipv4_any or is_ipv6_any
    if is_any:
        1
    else:
        0

# ============================================================================
# Datagram Validation
# ============================================================================

fn is_valid_datagram_size(size: i64) -> i64:
    # Check if datagram size is within limits
    val max_size = max_datagram_size()
    val is_valid = size > 0 and size <= max_size
    if is_valid:
        1
    else:
        0

fn validate_datagram(datagram: Datagram) -> i64:
    # Validate datagram structure and size
    val size = get_datagram_size(datagram)
    val size_valid = is_valid_datagram_size(size)
    val src_port_valid = is_valid_port(datagram.src_port)
    val dst_port_valid = is_valid_port(datagram.dst_port)
    val all_valid = size_valid == 1 and src_port_valid == 1 and dst_port_valid == 1
    if all_valid:
        1
    else:
        0

fn calculate_datagram_checksum(datagram: Datagram) -> i64:
    # Calculate simple checksum for datagram (sum of payload bytes mod 65536)
    val payload = datagram.payload
    val payload_len = payload.len()
    var checksum = 0
    var i = 0

    while i < payload_len:
        val byte_val = payload.char_code_at(i)
        checksum = checksum + byte_val
        i = i + 1

    val final_checksum = checksum % 65536
    final_checksum

# ============================================================================
# Socket Options
# ============================================================================

fn enable_broadcast(socket: UdpSocket) -> UdpSocket:
    # Enable broadcast on socket
    val new_socket = UdpSocket(
        address: socket.address,
        port: socket.port,
        state: socket.state,
        broadcast_enabled: 1,
        recv_buffer_size: socket.recv_buffer_size,
        send_buffer_size: socket.send_buffer_size,
        multicast_ttl: socket.multicast_ttl,
        multicast_groups: socket.multicast_groups
    )
    new_socket

fn disable_broadcast(socket: UdpSocket) -> UdpSocket:
    # Disable broadcast on socket
    val new_socket = UdpSocket(
        address: socket.address,
        port: socket.port,
        state: socket.state,
        broadcast_enabled: 0,
        recv_buffer_size: socket.recv_buffer_size,
        send_buffer_size: socket.send_buffer_size,
        multicast_ttl: socket.multicast_ttl,
        multicast_groups: socket.multicast_groups
    )
    new_socket

fn is_broadcast_enabled(socket: UdpSocket) -> i64:
    # Check if broadcast is enabled
    socket.broadcast_enabled

fn set_recv_buffer_size(socket: UdpSocket, size: i64) -> UdpSocket:
    # Set receive buffer size
    val new_socket = UdpSocket(
        address: socket.address,
        port: socket.port,
        state: socket.state,
        broadcast_enabled: socket.broadcast_enabled,
        recv_buffer_size: size,
        send_buffer_size: socket.send_buffer_size,
        multicast_ttl: socket.multicast_ttl,
        multicast_groups: socket.multicast_groups
    )
    new_socket

fn set_send_buffer_size(socket: UdpSocket, size: i64) -> UdpSocket:
    # Set send buffer size
    val new_socket = UdpSocket(
        address: socket.address,
        port: socket.port,
        state: socket.state,
        broadcast_enabled: socket.broadcast_enabled,
        recv_buffer_size: socket.recv_buffer_size,
        send_buffer_size: size,
        multicast_ttl: socket.multicast_ttl,
        multicast_groups: socket.multicast_groups
    )
    new_socket

fn get_recv_buffer_size(socket: UdpSocket) -> i64:
    # Get receive buffer size
    socket.recv_buffer_size

fn get_send_buffer_size(socket: UdpSocket) -> i64:
    # Get send buffer size
    socket.send_buffer_size

# ============================================================================
# Multicast Operations
# ============================================================================

fn set_multicast_ttl(socket: UdpSocket, ttl: i64) -> UdpSocket:
    # Set multicast TTL
    val new_socket = UdpSocket(
        address: socket.address,
        port: socket.port,
        state: socket.state,
        broadcast_enabled: socket.broadcast_enabled,
        recv_buffer_size: socket.recv_buffer_size,
        send_buffer_size: socket.send_buffer_size,
        multicast_ttl: ttl,
        multicast_groups: socket.multicast_groups
    )
    new_socket

fn get_multicast_ttl(socket: UdpSocket) -> i64:
    # Get multicast TTL
    socket.multicast_ttl

fn join_multicast_group(socket: UdpSocket, group_addr: text) -> UdpSocket:
    # Join a multicast group
    val current_groups = socket.multicast_groups
    val new_groups = current_groups + group_addr + ","
    val new_socket = UdpSocket(
        address: socket.address,
        port: socket.port,
        state: socket.state,
        broadcast_enabled: socket.broadcast_enabled,
        recv_buffer_size: socket.recv_buffer_size,
        send_buffer_size: socket.send_buffer_size,
        multicast_ttl: socket.multicast_ttl,
        multicast_groups: new_groups
    )
    new_socket

fn leave_multicast_group(socket: UdpSocket, group_addr: text) -> UdpSocket:
    # Leave a multicast group
    val current_groups = socket.multicast_groups
    val search_pattern = group_addr + ","
    val new_groups = current_groups.replace(search_pattern, "")
    val new_socket = UdpSocket(
        address: socket.address,
        port: socket.port,
        state: socket.state,
        broadcast_enabled: socket.broadcast_enabled,
        recv_buffer_size: socket.recv_buffer_size,
        send_buffer_size: socket.send_buffer_size,
        multicast_ttl: socket.multicast_ttl,
        multicast_groups: new_groups
    )
    new_socket

fn is_in_multicast_group(socket: UdpSocket, group_addr: text) -> i64:
    # Check if socket is in multicast group
    val groups = socket.multicast_groups
    val search_pattern = group_addr + ","
    val is_member = groups.contains(search_pattern)
    if is_member:
        1
    else:
        0

fn get_multicast_groups(socket: UdpSocket) -> text:
    # Get list of multicast groups
    socket.multicast_groups

# ============================================================================
# Message Fragmentation
# ============================================================================

fn needs_fragmentation(payload: text) -> i64:
    # Check if payload needs fragmentation
    val payload_size = payload.len()
    val max_size = max_datagram_size()
    val header_size = 8
    val max_payload_size = max_size - header_size
    val needs_frag = payload_size > max_payload_size
    if needs_frag:
        1
    else:
        0

fn calculate_fragment_count(payload: text, fragment_size: i64) -> i64:
    # Calculate number of fragments needed
    val payload_size = payload.len()
    val count = payload_size / fragment_size
    val remainder = payload_size % fragment_size
    val has_remainder = remainder > 0
    if has_remainder:
        count + 1
    else:
        count

fn create_fragment(payload: text, offset: i64, length: i64) -> text:
    # Create a fragment from payload
    val fragment = payload.substring(offset, offset + length)
    fragment

fn get_max_payload_size() -> i64:
    # Get maximum payload size for single datagram
    val max_size = max_datagram_size()
    val header_size = 8
    val max_payload = max_size - header_size
    max_payload

# ============================================================================
# Utility Functions
# ============================================================================

fn format_socket_info(socket: UdpSocket) -> text:
    # Format socket information as string
    val addr_part = "Address: " + socket.address
    val port_part = "Port: " + socket.port.to_text()
    val state_part = "State: " + socket.state
    val broadcast_text = if socket.broadcast_enabled == 1: "enabled" else: "disabled"
    val broadcast_part = "Broadcast: " + broadcast_text
    val info = addr_part + ", " + port_part + ", " + state_part + ", " + broadcast_part
    info

fn format_datagram_info(datagram: Datagram) -> text:
    # Format datagram information as string
    val src_part = "Source: " + datagram.src_addr + ":" + datagram.src_port.to_text()
    val dst_part = "Destination: " + datagram.dst_addr + ":" + datagram.dst_port.to_text()
    val size = get_datagram_size(datagram)
    val size_part = "Size: " + size.to_text()
    val info = src_part + ", " + dst_part + ", " + size_part
    info

fn parse_address_port(address_port: text) -> text:
    # Parse address:port string and return address part
    val parts = address_port.split(":")
    val addr = parts.get(0)
    addr

fn parse_port_from_address(address_port: text) -> i64:
    # Parse address:port string and return port part
    val parts = address_port.split(":")
    val port_text = parts.get(1)
    val port = port_text.to_int()
    port

fn create_address_port(address: text, port: i64) -> text:
    # Create address:port string
    val port_text = port.to_text()
    val address_port = address + ":" + port_text
    address_port

# ============================================================================
# Send and Receive Simulation
# ============================================================================

fn can_send_datagram(socket: UdpSocket, datagram: Datagram) -> i64:
    # Check if socket can send datagram
    val is_bound = is_socket_bound(socket)
    val is_valid = validate_datagram(datagram)
    val size = get_datagram_size(datagram)
    val send_buf_size = socket.send_buffer_size
    val fits_in_buffer = size <= send_buf_size
    val can_send = is_bound == 1 and is_valid == 1 and fits_in_buffer
    if can_send:
        1
    else:
        0

fn can_receive_datagram(socket: UdpSocket, datagram: Datagram) -> i64:
    # Check if socket can receive datagram
    val is_bound = is_socket_bound(socket)
    val is_valid = validate_datagram(datagram)
    val size = get_datagram_size(datagram)
    val recv_buf_size = socket.recv_buffer_size
    val fits_in_buffer = size <= recv_buf_size
    val can_recv = is_bound == 1 and is_valid == 1 and fits_in_buffer
    if can_recv:
        1
    else:
        0

fn can_send_broadcast(socket: UdpSocket, datagram: Datagram) -> i64:
    # Check if socket can send broadcast datagram
    val dst_addr = datagram.dst_addr
    val is_broadcast_addr = is_broadcast_address(dst_addr)
    val broadcast_enabled = socket.broadcast_enabled
    val can_send_bc = is_broadcast_addr == 1 and broadcast_enabled == 1
    if can_send_bc:
        1
    else:
        0

fn can_send_multicast(socket: UdpSocket, datagram: Datagram) -> i64:
    # Check if socket can send multicast datagram
    val dst_addr = datagram.dst_addr
    val is_multicast = is_multicast_ipv4(dst_addr)
    val is_bound = is_socket_bound(socket)
    val can_send_mc = is_multicast == 1 and is_bound == 1
    if can_send_mc:
        1
    else:
        0

# ============================================================================
# Additional Utility Functions
# ============================================================================

fn get_socket_endpoint(socket: UdpSocket) -> text:
    # Get socket endpoint as address:port
    val endpoint = create_address_port(socket.address, socket.port)
    endpoint

fn get_datagram_source(datagram: Datagram) -> text:
    # Get datagram source as address:port
    val source = create_address_port(datagram.src_addr, datagram.src_port)
    source

fn get_datagram_destination(datagram: Datagram) -> text:
    # Get datagram destination as address:port
    val destination = create_address_port(datagram.dst_addr, datagram.dst_port)
    destination

fn create_reply_datagram(original: Datagram, reply_payload: text) -> Datagram:
    # Create a reply datagram by swapping source and destination
    val reply = Datagram(
        src_addr: original.dst_addr,
        src_port: original.dst_port,
        dst_addr: original.src_addr,
        dst_port: original.src_port,
        payload: reply_payload
    )
    reply

fn get_payload_size(datagram: Datagram) -> i64:
    # Get payload size only (without UDP header)
    val payload_size = datagram.payload.len()
    payload_size

fn is_empty_payload(datagram: Datagram) -> i64:
    # Check if datagram has empty payload
    val payload_size = get_payload_size(datagram)
    val is_empty = payload_size == 0
    if is_empty:
        1
    else:
        0

fn compare_datagrams(datagram1: Datagram, datagram2: Datagram) -> i64:
    # Compare two datagrams for equality
    val src_addr_eq = datagram1.src_addr == datagram2.src_addr
    val src_port_eq = datagram1.src_port == datagram2.src_port
    val dst_addr_eq = datagram1.dst_addr == datagram2.dst_addr
    val dst_port_eq = datagram1.dst_port == datagram2.dst_port
    val payload_eq = datagram1.payload == datagram2.payload

    val eq1 = src_addr_eq and src_port_eq
    val eq2 = eq1 and dst_addr_eq
    val eq3 = eq2 and dst_port_eq
    val eq4 = eq3 and payload_eq

    if eq4:
        1
    else:
        0

fn clone_datagram(datagram: Datagram) -> Datagram:
    # Create a copy of datagram
    val clone = Datagram(
        src_addr: datagram.src_addr,
        src_port: datagram.src_port,
        dst_addr: datagram.dst_addr,
        dst_port: datagram.dst_port,
        payload: datagram.payload
    )
    clone

fn clone_socket(socket: UdpSocket) -> UdpSocket:
    # Create a copy of socket
    val clone = UdpSocket(
        address: socket.address,
        port: socket.port,
        state: socket.state,
        broadcast_enabled: socket.broadcast_enabled,
        recv_buffer_size: socket.recv_buffer_size,
        send_buffer_size: socket.send_buffer_size,
        multicast_ttl: socket.multicast_ttl,
        multicast_groups: socket.multicast_groups
    )
    clone
