# Concurrent Collections Module - Thread-Safe Data Structures
# @tag:stdlib
# @tag:api
#
# Provides lock-free concurrent collections for multi-threaded access.
# All collections use Rust's concurrent data structures via FFI.
#
# Collections:
#   - HashMap: Hash-based key-value map (unordered, O(1) average)
#   - HashSet: Hash-based unique value set (unordered, O(1) average)
#   - BTreeMap: Sorted key-value map (ordered, O(log n))
#   - BTreeSet: Sorted unique value set (ordered, O(log n))
#
# Thread Safety:
#   - All operations are atomic and thread-safe
#   - Multiple threads can read/write concurrently
#   - Lock-free implementation - no explicit locking needed
#   - Internally synchronized using CAS (compare-and-swap)
#
# Key Characteristics:
#   - HashMap/HashSet: Fast insert/lookup, no ordering guarantees
#   - BTreeMap/BTreeSet: Slower insert/lookup, maintains sorted order
#   - All use text keys/values currently (generic types not yet supported)
#   - Collections grow dynamically - no capacity limits
#
# SDoctest Examples:
#
# Example 1: HashMap Basic Operations
# ```simple
# use std.concurrent.collections.{hashmap_new}
#
# val map = hashmap_new()
# map.insert("name", "Alice")
# map.insert("age", 30)
# val name = map.get("name")
# val exists = map.contains_key("age")
# print name   # Prints: Alice
# print exists # Prints: true
# ```
#
# Example 2: HashSet Operations
# ```simple
# use std.concurrent.collections.{hashset_new}
#
# val set = hashset_new()
# set.insert("apple")
# set.insert("banana")
# val has_apple = set.contains("apple")
# val has_grape = set.contains("grape")
# print has_apple  # Prints: true
# print has_grape  # Prints: false
# ```
#
# Example 3: BTreeMap Sorted Iteration
# ```simple
# use std.concurrent.collections.{btreemap_new}
#
# val map = btreemap_new()
# map.insert("z", 1)
# map.insert("a", 2)
# map.insert("m", 3)
# val first = map.first_key()
# val last = map.last_key()
# print first  # Prints: a
# print last   # Prints: z
# ```
#
# Example 4: Set Operations
# ```simple
# use std.concurrent.collections.{hashset_new}
#
# val set1 = hashset_new()
# set1.insert("a")
# set1.insert("b")
# val set2 = hashset_new()
# set2.insert("b")
# set2.insert("c")
# val inter = set1.intersection(set2)
# val diff = set1.difference(set2)
# print (inter.contains("b"))  # Prints: true
# print (diff.contains("a"))   # Prints: true
# ```
#
# Performance Notes:
#   - HashMap insert/get: ~50-100ns (lock-free CAS)
#   - BTreeMap insert/get: ~100-200ns (tree traversal)
#   - HashSet operations: Same as HashMap
#   - BTreeSet operations: Same as BTreeMap
#   - Set operations (intersection, union): O(n) where n is set size
#
# Common Patterns:
#   - Shared Cache: Multiple threads read/update cache concurrently
#   - Configuration Store: Thread-safe key-value config
#   - Unique ID Tracking: HashSet for deduplication
#   - Sorted Indexes: BTreeMap for range queries
#
# Limitations:
#   - Keys and values must be text (no generic types yet)
#   - No iterators - use keys()/values()/entries() to get arrays
#   - No atomic multi-key operations
#   - No capacity control - collections grow unbounded

# --- HashMap extern FFI (runtime uses __rt_ prefix) ---
extern fn __rt_hashmap_new() -> i64
extern fn __rt_hashmap_insert(handle: i64, key: text, value: Any) -> bool
extern fn __rt_hashmap_get(handle: i64, key: text) -> Any
extern fn __rt_hashmap_contains_key(handle: i64, key: text) -> bool
extern fn __rt_hashmap_remove(handle: i64, key: text) -> Any
extern fn __rt_hashmap_len(handle: i64) -> i64
extern fn __rt_hashmap_keys(handle: i64) -> Any
extern fn __rt_hashmap_values(handle: i64) -> Any
extern fn __rt_hashmap_entries(handle: i64) -> Any

# --- HashSet extern FFI ---
extern fn __rt_hashset_new() -> i64
extern fn __rt_hashset_insert(handle: i64, value: text) -> bool
extern fn __rt_hashset_contains(handle: i64, value: text) -> bool
extern fn __rt_hashset_remove(handle: i64, value: text) -> bool
extern fn __rt_hashset_len(handle: i64) -> i64
extern fn __rt_hashset_to_array(handle: i64) -> Any
extern fn __rt_hashset_intersection(a: i64, b: i64) -> i64
extern fn __rt_hashset_difference(a: i64, b: i64) -> i64
extern fn __rt_hashset_symmetric_difference(a: i64, b: i64) -> i64
extern fn __rt_hashset_is_subset(a: i64, b: i64) -> bool
extern fn __rt_hashset_is_superset(a: i64, b: i64) -> bool
extern fn __rt_hashset_drop(handle: i64)

# --- BTreeMap extern FFI ---
extern fn __rt_btreemap_new() -> i64
extern fn __rt_btreemap_insert(handle: i64, key: text, value: Any) -> bool
extern fn __rt_btreemap_get(handle: i64, key: text) -> Any
extern fn __rt_btreemap_contains_key(handle: i64, key: text) -> bool
extern fn __rt_btreemap_remove(handle: i64, key: text) -> Any
extern fn __rt_btreemap_len(handle: i64) -> i64
extern fn __rt_btreemap_clear(handle: i64) -> bool
extern fn __rt_btreemap_keys(handle: i64) -> Any
extern fn __rt_btreemap_values(handle: i64) -> Any
extern fn __rt_btreemap_entries(handle: i64) -> Any
extern fn __rt_btreemap_first_key(handle: i64) -> Any
extern fn __rt_btreemap_last_key(handle: i64) -> Any

# --- BTreeSet extern FFI ---
extern fn __rt_btreeset_new() -> i64
extern fn __rt_btreeset_insert(handle: i64, value: text) -> bool
extern fn __rt_btreeset_contains(handle: i64, value: text) -> bool
extern fn __rt_btreeset_remove(handle: i64, value: text) -> bool
extern fn __rt_btreeset_len(handle: i64) -> i64
extern fn __rt_btreeset_clear(handle: i64) -> bool
extern fn __rt_btreeset_to_array(handle: i64) -> Any
extern fn __rt_btreeset_first(handle: i64) -> Any
extern fn __rt_btreeset_last(handle: i64) -> Any
extern fn __rt_btreeset_union(a: i64, b: i64) -> i64
extern fn __rt_btreeset_intersection(a: i64, b: i64) -> i64
extern fn __rt_btreeset_difference(a: i64, b: i64) -> i64
extern fn __rt_btreeset_symmetric_difference(a: i64, b: i64) -> i64
extern fn __rt_btreeset_is_subset(a: i64, b: i64) -> bool
extern fn __rt_btreeset_is_superset(a: i64, b: i64) -> bool

# --- HashMap wrapper ---
# @tag:api
#
# Thread-safe hash map with unordered key-value pairs.
# All operations are lock-free and atomic.

class HashMap:
    _handle: i64  # Rust HashMap handle (opaque)

    # Inserts key-value pair, returns true if new key, false if updated.
    # Thread-safe - multiple threads can insert concurrently.
    # @tag:api
    fn insert(key: text, value: Any) -> bool:
        __rt_hashmap_insert(self._handle, key, value)

    # Returns value for key, or nil if key not found.
    # Thread-safe - concurrent with inserts/removes.
    # @tag:api
    fn get(key: text) -> Any:
        __rt_hashmap_get(self._handle, key)

    # Checks if key exists in map.
    # Thread-safe - returns snapshot of key existence.
    # @tag:api
    fn contains_key(key: text) -> bool:
        __rt_hashmap_contains_key(self._handle, key)

    # Removes key and returns its value, or nil if not found.
    # Thread-safe - atomically removes entry.
    # @tag:api
    fn remove(key: text) -> Any:
        __rt_hashmap_remove(self._handle, key)

    # Returns current number of entries.
    # Thread-safe - returns approximate count (may change immediately).
    # @tag:api
    fn len() -> i64:
        __rt_hashmap_len(self._handle)

    # Returns array of all keys (snapshot).
    # Order is arbitrary and may differ between calls.
    # @tag:api
    fn keys() -> Any:
        __rt_hashmap_keys(self._handle)

    # Returns array of all values (snapshot).
    # Order matches keys() at snapshot time.
    # @tag:api
    fn values() -> Any:
        __rt_hashmap_values(self._handle)

    # Returns array of [key, value] pairs (snapshot).
    # Provides consistent key-value pairing.
    # @tag:api
    fn entries() -> Any:
        __rt_hashmap_entries(self._handle)

# --- HashSet wrapper ---
# @tag:api
#
# Thread-safe hash set of unique values.
# All operations are lock-free and atomic.

class HashSet:
    _handle: i64  # Rust HashSet handle (opaque)

    # Inserts value, returns true if new, false if already present.
    # Thread-safe - concurrent inserts supported.
    # @tag:api
    fn insert(value: text) -> bool:
        __rt_hashset_insert(self._handle, value)

    # Checks if value exists in set.
    # Thread-safe - returns snapshot of membership.
    # @tag:api
    fn contains(value: text) -> bool:
        __rt_hashset_contains(self._handle, value)

    # Removes value, returns true if was present, false if not found.
    # Thread-safe - atomically removes element.
    # @tag:api
    fn remove(value: text) -> bool:
        __rt_hashset_remove(self._handle, value)

    # Returns current number of elements.
    # Thread-safe - approximate count (may change immediately).
    # @tag:api
    fn len() -> i64:
        __rt_hashset_len(self._handle)

    # Returns array of all values (snapshot).
    # Order is arbitrary and may differ between calls.
    # @tag:api
    fn to_array() -> Any:
        __rt_hashset_to_array(self._handle)

    # Returns new set containing elements in both sets.
    # Creates snapshot - original sets unchanged.
    # @tag:api
    fn intersection(other: HashSet) -> HashSet:
        val h = __rt_hashset_intersection(self._handle, other._handle)
        HashSet(_handle: h)

    # Returns new set containing elements in self but not other.
    # Creates snapshot - original sets unchanged.
    # @tag:api
    fn difference(other: HashSet) -> HashSet:
        val h = __rt_hashset_difference(self._handle, other._handle)
        HashSet(_handle: h)

    # Returns new set containing elements in either set but not both.
    # Creates snapshot - original sets unchanged.
    # @tag:api
    fn symmetric_difference(other: HashSet) -> HashSet:
        val h = __rt_hashset_symmetric_difference(self._handle, other._handle)
        HashSet(_handle: h)

    # Checks if all elements of self are in other.
    # Thread-safe - returns snapshot comparison.
    # @tag:api
    fn is_subset(other: HashSet) -> bool:
        __rt_hashset_is_subset(self._handle, other._handle)

    # Checks if all elements of other are in self.
    # Thread-safe - returns snapshot comparison.
    # @tag:api
    fn is_superset(other: HashSet) -> bool:
        __rt_hashset_is_superset(self._handle, other._handle)

    # Explicitly releases set resources.
    # Called automatically on handle drop in most cases.
    # @tag:internal
    fn drop():
        __rt_hashset_drop(self._handle)

# --- BTreeMap wrapper ---
# @tag:api
#
# Thread-safe sorted map maintaining keys in lexicographic order.
# All operations are lock-free and atomic.

class BTreeMap:
    _handle: i64  # Rust BTreeMap handle (opaque)

    # Inserts key-value pair, returns true if new key, false if updated.
    # Keys maintained in sorted order automatically.
    # @tag:api
    fn insert(key: text, value: Any) -> bool:
        __rt_btreemap_insert(self._handle, key, value)

    # Returns value for key, or nil if key not found.
    # Thread-safe - concurrent with inserts/removes.
    # @tag:api
    fn get(key: text) -> Any:
        __rt_btreemap_get(self._handle, key)

    # Checks if key exists in map.
    # Thread-safe - returns snapshot of key existence.
    # @tag:api
    fn contains_key(key: text) -> bool:
        __rt_btreemap_contains_key(self._handle, key)

    # Removes key and returns its value, or nil if not found.
    # Thread-safe - atomically removes entry.
    # @tag:api
    fn remove(key: text) -> Any:
        __rt_btreemap_remove(self._handle, key)

    # Returns current number of entries.
    # Thread-safe - returns approximate count.
    # @tag:api
    fn len() -> i64:
        __rt_btreemap_len(self._handle)

    # Removes all entries from map.
    # Thread-safe - atomically clears all keys.
    # @tag:api
    fn clear() -> bool:
        __rt_btreemap_clear(self._handle)

    # Returns array of all keys in sorted order.
    # Keys sorted lexicographically (a < b < z).
    # @tag:api
    fn keys() -> Any:
        __rt_btreemap_keys(self._handle)

    # Returns array of values in key-sorted order.
    # Order matches keys() at snapshot time.
    # @tag:api
    fn values() -> Any:
        __rt_btreemap_values(self._handle)

    # Returns array of [key, value] pairs in sorted order.
    # Provides consistent sorted key-value pairing.
    # @tag:api
    fn entries() -> Any:
        __rt_btreemap_entries(self._handle)

    # Returns lexicographically smallest key, or nil if empty.
    # Thread-safe - returns snapshot of first key.
    # @tag:api
    fn first_key() -> Any:
        __rt_btreemap_first_key(self._handle)

    # Returns lexicographically largest key, or nil if empty.
    # Thread-safe - returns snapshot of last key.
    # @tag:api
    fn last_key() -> Any:
        __rt_btreemap_last_key(self._handle)

# --- BTreeSet wrapper ---
# @tag:api
#
# Thread-safe sorted set maintaining values in lexicographic order.
# All operations are lock-free and atomic.

class BTreeSet:
    _handle: i64  # Rust BTreeSet handle (opaque)

    # Inserts value, returns true if new, false if already present.
    # Values maintained in sorted order automatically.
    # @tag:api
    fn insert(value: text) -> bool:
        __rt_btreeset_insert(self._handle, value)

    # Checks if value exists in set.
    # Thread-safe - returns snapshot of membership.
    # @tag:api
    fn contains(value: text) -> bool:
        __rt_btreeset_contains(self._handle, value)

    # Removes value, returns true if was present, false if not found.
    # Thread-safe - atomically removes element.
    # @tag:api
    fn remove(value: text) -> bool:
        __rt_btreeset_remove(self._handle, value)

    # Returns current number of elements.
    # Thread-safe - approximate count.
    # @tag:api
    fn len() -> i64:
        __rt_btreeset_len(self._handle)

    # Removes all elements from set.
    # Thread-safe - atomically clears all values.
    # @tag:api
    fn clear() -> bool:
        __rt_btreeset_clear(self._handle)

    # Returns array of all values in sorted order.
    # Values sorted lexicographically (a < b < z).
    # @tag:api
    fn to_array() -> Any:
        __rt_btreeset_to_array(self._handle)

    # Returns lexicographically smallest value, or nil if empty.
    # Thread-safe - returns snapshot of first element.
    # @tag:api
    fn first() -> Any:
        __rt_btreeset_first(self._handle)

    # Returns lexicographically largest value, or nil if empty.
    # Thread-safe - returns snapshot of last element.
    # @tag:api
    fn last() -> Any:
        __rt_btreeset_last(self._handle)

    # Returns new set containing all elements in either set.
    # Creates sorted snapshot - original sets unchanged.
    # @tag:api
    fn union(other: BTreeSet) -> BTreeSet:
        val h = __rt_btreeset_union(self._handle, other._handle)
        BTreeSet(_handle: h)

    # Returns new set containing elements in both sets.
    # Creates sorted snapshot - original sets unchanged.
    # @tag:api
    fn intersection(other: BTreeSet) -> BTreeSet:
        val h = __rt_btreeset_intersection(self._handle, other._handle)
        BTreeSet(_handle: h)

    # Returns new set containing elements in self but not other.
    # Creates sorted snapshot - original sets unchanged.
    # @tag:api
    fn difference(other: BTreeSet) -> BTreeSet:
        val h = __rt_btreeset_difference(self._handle, other._handle)
        BTreeSet(_handle: h)

    # Returns new set containing elements in either set but not both.
    # Creates sorted snapshot - original sets unchanged.
    # @tag:api
    fn symmetric_difference(other: BTreeSet) -> BTreeSet:
        val h = __rt_btreeset_symmetric_difference(self._handle, other._handle)
        BTreeSet(_handle: h)

    # Checks if all elements of self are in other.
    # Thread-safe - returns snapshot comparison.
    # @tag:api
    fn is_subset(other: BTreeSet) -> bool:
        __rt_btreeset_is_subset(self._handle, other._handle)

    # Checks if all elements of other are in self.
    # Thread-safe - returns snapshot comparison.
    # @tag:api
    fn is_superset(other: BTreeSet) -> bool:
        __rt_btreeset_is_superset(self._handle, other._handle)

# --- Factories ---

# Creates a new thread-safe hash map (unordered).
# Map starts empty and grows dynamically as entries added.
# Use for fast lookups when order doesn't matter.
# @tag:api
fn hashmap_new() -> HashMap:
    HashMap(_handle: __rt_hashmap_new())

# Creates a new thread-safe hash set (unordered).
# Set starts empty and grows dynamically as elements added.
# Use for fast membership tests and deduplication.
# @tag:api
fn hashset_new() -> HashSet:
    HashSet(_handle: __rt_hashset_new())

# Creates a new thread-safe sorted map.
# Map starts empty with keys maintained in lexicographic order.
# Use when sorted iteration or first/last key access needed.
# @tag:api
fn btreemap_new() -> BTreeMap:
    BTreeMap(_handle: __rt_btreemap_new())

# Creates a new thread-safe sorted set.
# Set starts empty with values maintained in lexicographic order.
# Use when sorted iteration or first/last element access needed.
# @tag:api
fn btreeset_new() -> BTreeSet:
    BTreeSet(_handle: __rt_btreeset_new())
