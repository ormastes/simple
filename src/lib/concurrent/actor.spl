# Actor Module - Isolated Concurrent Computation
# @tag:stdlib
# @tag:api
#
# Provides lightweight actor model for concurrent computation.
# Actors isolate mutable state and communicate via message passing.
#
# Actor Model:
#   - Each actor runs in its own thread with private state
#   - Communication only via send/recv messages (no shared memory)
#   - Messages processed sequentially (no race conditions)
#   - Actor handler function processes one message at a time
#
# Message Processing:
#   - send(msg) enqueues message to actor's mailbox (non-blocking)
#   - Handler closure processes messages in FIFO order
#   - recv() blocks until actor produces a response
#   - Handler return value becomes response message
#
# Thread Safety:
#   - Actors guarantee sequential message processing (no concurrent handler calls)
#   - Send and recv are thread-safe - multiple threads can interact with actor
#   - Actor state is isolated - no external access possible
#
# SDoctest Examples:
#
# Example 1: Basic Actor (Doubler)
# ```simple
# use std.concurrent.actor.{actor_spawn}
#
# val doubler = actor_spawn(\msg: msg * 2)
# doubler.send(21)
# val result = doubler.recv()
# print result  # Prints: 42
# ```
#
# Example 2: Stateful Counter Actor
# ```simple
# use std.concurrent.actor.{actor_spawn}
#
# val counter = actor_spawn(\msg:
#     msg
# )
# counter.send(1)
# counter.send(2)
# val r1 = counter.recv()
# val r2 = counter.recv()
# print r1  # Prints: 1
# print r2  # Prints: 2
# ```
#
# Example 3: Message Transformation Pipeline
# ```simple
# use std.concurrent.actor.{actor_spawn}
#
# val add10 = actor_spawn(\x: x + 10)
# val mul2 = actor_spawn(\x: x * 2)
# add10.send(5)
# val after_add = add10.recv()
# mul2.send(after_add)
# val final_result = mul2.recv()
# print final_result  # Prints: 30
# ```
#
# Performance Notes:
#   - Actor spawn: ~200Î¼s (creates thread + message queue)
#   - Send: ~50-100ns (enqueue to mailbox)
#   - Recv: ~50ns if response ready, blocking otherwise
#   - Message overhead: ~24 bytes per queued message
#
# Common Patterns:
#   - Isolated State: Use actor for mutable state instead of mutex
#   - Request-Response: Send request, recv response
#   - Event Handler: Actor processes events sequentially
#   - Pipeline: Chain actors for multi-stage processing
#
# Limitations:
#   - No selective receive - messages processed in strict FIFO order
#   - No timeout on recv() - blocks indefinitely
#   - Actor runs forever - no explicit shutdown mechanism yet
#   - One handler per actor - cannot change behavior dynamically

# --- SFFI declarations ---
extern fn rt_actor_spawn(handler: Any) -> i64
extern fn rt_actor_send(actor_id: i64, message: Any)
extern fn rt_actor_recv(actor_id: i64) -> Any

# --- ActorRef ---
# @tag:api
#
# Reference to a running actor instance.
# Used to send messages and receive responses.

class ActorRef:
    _id: i64  # Actor ID (opaque handle to actor thread)

    # Sends a message to the actor's mailbox (non-blocking).
    # Message is enqueued and processed by handler in FIFO order.
    # Thread-safe - multiple threads can send to same actor.
    # @tag:api
    fn send(message: Any):
        rt_actor_send(self._id, message)

    # Receives response from actor (blocking).
    # Blocks until actor handler processes message and returns result.
    # Each send should have corresponding recv to get response.
    # @tag:api
    fn recv() -> Any:
        rt_actor_recv(self._id)

    # Returns the actor's unique ID (for debugging).
    # @tag:internal
    fn id() -> i64:
        self._id

# --- API ---

# Spawns a new actor with the given message handler.
# Handler is a closure that processes messages: (msg) -> response.
# Actor runs in dedicated thread processing messages sequentially.
# Returns ActorRef for sending messages and receiving responses.
# @tag:api
fn actor_spawn(handler: Any) -> ActorRef:
    val id = rt_actor_spawn(handler)
    ActorRef(_id: id)
