# HTML Utility Functions
#
# Higher-level utilities for HTML processing: extraction, validation, statistics.

# =============================================================================
# Content Extraction
# =============================================================================

fn strip_html_tags(html: text) -> text:
    val tree = parse_html(html)
    get_text_content(tree)

fn extract_links(node: tuple) -> list:
    val anchors = find_by_tag(node, "a")
    var links = []
    var i = 0
    while i < anchors.length():
        val anchor = anchors[i]
        val href = get_element_attr(anchor, "href")
        if href != nil:
            links = links.append(href)
        i = i + 1
    links

fn extract_images(node: tuple) -> list:
    val imgs = find_by_tag(node, "img")
    var images = []
    var i = 0
    while i < imgs.length():
        val img = imgs[i]
        val src = get_element_attr(img, "src")
        val alt = get_element_attr(img, "alt")
        if src != nil:
            images = images.append((src, alt))
        i = i + 1
    images

fn get_title(node: tuple) -> text:
    val titles = find_by_tag(node, "title")
    var result = nil
    if titles.length() > 0:
        val title_node = titles[0]
        result = get_text_content(title_node).trim()
    result

fn get_meta_content(node: tuple, name: text) -> text:
    val metas = find_by_tag(node, "meta")
    var result = nil
    var i = 0
    while i < metas.length():
        if result == nil:
            val meta = metas[i]
            val meta_name = get_element_attr(meta, "name")
            if meta_name != nil:
                if meta_name == name:
                    result = get_element_attr(meta, "content")
        i = i + 1
    result

# =============================================================================
# Table Utilities
# =============================================================================

fn get_table_rows(table: tuple) -> list:
    find_by_tag(table, "tr")

fn get_table_cells(row: tuple) -> list:
    var cells = find_by_tag(row, "td")
    val headers = find_by_tag(row, "th")
    cells.concat(headers)

fn get_table_headers(table: tuple) -> list:
    find_by_tag(table, "th")

fn extract_table_data(table: tuple) -> list:
    var data = []
    val rows = get_table_rows(table)
    var i = 0
    while i < rows.length():
        val row = rows[i]
        val cells = get_table_cells(row)
        var row_data = []
        var j = 0
        while j < cells.length():
            val cell = cells[j]
            val cell_text = get_text_content(cell).trim()
            row_data = row_data.append(cell_text)
            j = j + 1
        data = data.append(row_data)
        i = i + 1
    data

# =============================================================================
# Form Utilities
# =============================================================================

fn get_form_inputs(form: tuple) -> list:
    find_by_tag(form, "input")

fn get_form_field_value(form: tuple, field_name: text) -> text:
    val inputs = get_form_inputs(form)
    var result = nil
    var i = 0
    while i < inputs.length():
        if result == nil:
            val input = inputs[i]
            val name = get_element_attr(input, "name")
            if name != nil:
                if name == field_name:
                    result = get_element_attr(input, "value")
        i = i + 1
    result

fn get_form_action(form: tuple) -> text:
    get_element_attr(form, "action")

fn get_form_method(form: tuple) -> text:
    val method = get_element_attr(form, "method")
    var result = "get"
    if method != nil:
        result = method.to_lowercase()
    result

# =============================================================================
# List Utilities
# =============================================================================

fn get_list_items(list_node: tuple) -> list:
    find_by_tag(list_node, "li")

fn extract_list_text(list_node: tuple) -> list:
    val items = get_list_items(list_node)
    var texts = []
    var i = 0
    while i < items.length():
        val item = items[i]
        val text = get_text_content(item).trim()
        texts = texts.append(text)
        i = i + 1
    texts

# =============================================================================
# Statistics and Analysis
# =============================================================================

fn count_elements(node: tuple) -> i64:
    var count = 0
    val ntype = node_type(node)
    if ntype == NODE_ELEMENT:
        count = 1
    val children = node_children(node)
    var i = 0
    while i < children.length():
        val child = children[i]
        count = count + count_elements(child)
        i = i + 1
    count

fn count_text_nodes(node: tuple) -> i64:
    var count = 0
    val ntype = node_type(node)
    if ntype == NODE_TEXT:
        count = 1
    val children = node_children(node)
    var i = 0
    while i < children.length():
        val child = children[i]
        count = count + count_text_nodes(child)
        i = i + 1
    count

fn count_all_nodes(node: tuple) -> i64:
    var count = 1
    val children = node_children(node)
    var i = 0
    while i < children.length():
        val child = children[i]
        count = count + count_all_nodes(child)
        i = i + 1
    count

fn count_comments(node: tuple) -> i64:
    var count = 0
    val ntype = node_type(node)
    if ntype == NODE_COMMENT:
        count = 1
    val children = node_children(node)
    var i = 0
    while i < children.length():
        val child = children[i]
        count = count + count_comments(child)
        i = i + 1
    count

fn get_max_depth(node: tuple) -> i64:
    var max = 0
    val children = node_children(node)
    var i = 0
    while i < children.length():
        val child = children[i]
        val child_depth = get_max_depth(child)
        if child_depth > max:
            max = child_depth
        i = i + 1
    max + 1

fn get_total_text_length(node: tuple) -> i64:
    val text = get_text_content(node)
    text.length()

fn get_attr_count(node: tuple) -> i64:
    val attrs = node_attrs(node)
    attrs.length()

fn get_total_attrs(node: tuple) -> i64:
    var count = get_attr_count(node)
    val children = node_children(node)
    var i = 0
    while i < children.length():
        val child = children[i]
        count = count + get_total_attrs(child)
        i = i + 1
    count

# =============================================================================
# HTML Structure Validation
# =============================================================================

fn has_doctype(node: tuple) -> bool:
    val children = node_children(node)
    var result = false
    var i = 0
    while i < children.length():
        val child = children[i]
        val ntype = node_type(child)
        if ntype == NODE_DOCTYPE:
            result = true
            i = children.length()
        else:
            i = i + 1
    result

fn has_html_tag(node: tuple) -> bool:
    has_tag(node, "html")

fn has_head_tag(node: tuple) -> bool:
    has_tag(node, "head")

fn has_body_tag(node: tuple) -> bool:
    has_tag(node, "body")

fn is_well_formed_document(node: tuple) -> bool:
    var result = has_html_tag(node)
    if result:
        result = has_head_tag(node)
    if result:
        result = has_body_tag(node)
    result

# =============================================================================
# Debugging and Inspection
# =============================================================================

fn node_to_string(node: tuple) -> text:
    val ntype = node_type(node)
    var result = "Node("

    if ntype == NODE_ELEMENT:
        val tag = node_tag(node)
        val attrs = node_attrs(node)
        val children = node_children(node)
        result = result + "ELEMENT, " + tag + ", " + attrs.length().to_text() + " attrs, " + children.length().to_text() + " children"
    else:
        if ntype == NODE_TEXT:
            val text = node_text(node)
            var preview = text
            if preview.length() > 30:
                preview = preview.substring(0, 30) + "..."
            result = result + "TEXT, \"" + preview + "\""
        else:
            if ntype == NODE_COMMENT:
                val text = node_text(node)
                var preview = text
                if preview.length() > 30:
                    preview = preview.substring(0, 30) + "..."
                result = result + "COMMENT, \"" + preview + "\""
            else:
                if ntype == NODE_DOCTYPE:
                    val text = node_text(node)
                    result = result + "DOCTYPE, \"" + text + "\""
                else:
                    result = result + ntype

    result = result + ")"
    result

fn print_tree(node: tuple, indent: i64):
    val indent_str = create_indent(indent)
    print indent_str + node_to_string(node)

    val children = node_children(node)
    var i = 0
    while i < children.length():
        val child = children[i]
        print_tree(child, indent + 1)
        i = i + 1

fn get_tree_summary(node: tuple) -> text:
    val total_nodes = count_all_nodes(node)
    val elements = count_elements(node)
    val text_nodes = count_text_nodes(node)
    val comments = count_comments(node)
    val depth = get_max_depth(node)

    var result = "Tree Summary:\n"
    result = result + "  Total nodes: " + total_nodes.to_text() + "\n"
    result = result + "  Elements: " + elements.to_text() + "\n"
    result = result + "  Text nodes: " + text_nodes.to_text() + "\n"
    result = result + "  Comments: " + comments.to_text() + "\n"
    result = result + "  Max depth: " + depth.to_text()
    result

# =============================================================================
# Dependencies (from other modules)
# =============================================================================

val NODE_ELEMENT = "element"
val NODE_TEXT = "text"
val NODE_COMMENT = "comment"
val NODE_DOCTYPE = "doctype"

fn node_type(node: tuple) -> text:
    node[0]

fn node_tag(node: tuple) -> text:
    node[1]

fn node_attrs(node: tuple) -> list:
    node[2]

fn node_children(node: tuple) -> list:
    node[3]

fn node_text(node: tuple) -> text:
    node[4]

# Placeholder imports - will be resolved by facade
fn parse_html(html: text) -> tuple:
    (NODE_ELEMENT, "root", [], [], nil)

fn get_text_content(node: tuple) -> text:
    ""

fn find_by_tag(node: tuple, tag_name: text) -> list:
    []

fn get_element_attr(node: tuple, attr_name: text) -> text:
    nil

fn has_tag(node: tuple, tag_name: text) -> bool:
    false

fn create_indent(level: i64) -> text:
    ""
