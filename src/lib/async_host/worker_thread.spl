# WorkerThread - OS Thread for Async Task Execution
#
# Worker thread that polls tasks from thread-safe queue.
# Part of multi-threaded async runtime.

use std.async_core.*
use std.thread_sffi.{thread_sleep, thread_yield}
use std.async_host.thread_safe_queue.{ThreadSafeQueue}

class WorkerThread:
    """OS thread that executes async tasks.

    Part of multi-threaded executor. Each worker:
    - Polls tasks from local queue
    - Steals work from other workers when idle
    - Executes tasks to completion
    - Handles task suspension/wakeup

    Example:
        val worker = WorkerThread.new(0, local_queue, global_queue)
        worker.run()  # runs in separate OS thread
    """
    worker_id: usize
    local_queue: ThreadSafeQueue
    global_queue: ThreadSafeQueue
    is_running: bool
    shutdown_requested: bool

    static fn new(
        worker_id: usize,
        local_queue: ThreadSafeQueue,
        global_queue: ThreadSafeQueue
    ) -> WorkerThread:
        """Create new worker thread.

        Args:
            worker_id: Worker index
            local_queue: Thread-local task queue
            global_queue: Shared global task queue

        Returns:
            Worker thread instance
        """
        WorkerThread(
            worker_id: worker_id,
            local_queue: local_queue,
            global_queue: global_queue,
            is_running: false,
            shutdown_requested: false
        )

    me run():
        """Main worker loop (runs in OS thread).

        Executes tasks until shutdown requested.
        """
        self.is_running = true

        while not self.shutdown_requested:
            if not self.run_one_task():
                # No work available - sleep briefly
                thread_sleep(1)

        self.is_running = false

    me run_one_task() -> bool:
        """Run one task from queue.

        Returns:
            true if task executed, false if no work available
        """
        # Try local queue first (LIFO for cache locality)
        var task_id = self.local_queue.try_pop()

        # Try global queue
        if not task_id.?:
            task_id = self.global_queue.try_pop()

        # Execute task if found
        match task_id:
            case Some(id):
                # Task execution would happen here
                # In real implementation, this would:
                # 1. Get task from task registry
                # 2. Poll the task's future
                # 3. Handle Ready/Pending result
                # 4. Update task state
                # For now, just yield CPU
                thread_yield()
                return true
            case nil:
                return false

    me shutdown():
        """Request shutdown (thread-safe)."""
        self.shutdown_requested = true

    fn is_idle() -> bool:
        """Check if worker is idle (no work).

        Returns:
            true if no work available, false otherwise
        """
        self.local_queue.is_empty() and self.global_queue.is_empty()

export WorkerThread
