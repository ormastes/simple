# ThreadSafeQueue - Lock-Protected Task Queue
#
# Multi-producer, multi-consumer queue with mutex protection.
# Used for work-stealing across OS threads.

use std.thread_sffi.{MutexHandle, CondVarHandle, mutex_create, condvar_create}

class ThreadSafeQueue:
    """Thread-safe queue with mutex protection.

    Multi-producer, multi-consumer queue for cross-thread communication.

    Features:
    - Push/pop with mutex protection
    - Blocking wait with condition variable
    - Non-blocking try_pop
    - Thread-safe size checking

    Example:
        val queue = ThreadSafeQueue.new()

        # Producer thread
        queue.push(42)

        # Consumer thread
        match queue.pop_blocking(1000):
            case Some(item): process(item)
            case nil: # timeout
    """
    items: [usize]
    mutex: MutexHandle
    not_empty: CondVarHandle

    static fn new() -> ThreadSafeQueue:
        """Create new thread-safe queue."""
        ThreadSafeQueue(
            items: [],
            mutex: mutex_create(),
            not_empty: condvar_create()
        )

    me push(item: usize):
        """Push item to queue (thread-safe).

        Args:
            item: Item to push
        """
        self.mutex.lock()

        self.items = self.items.push(item)

        self.not_empty.signal()
        self.mutex.unlock()

    me try_pop() -> usize:
        """Try to pop item (non-blocking, thread-safe).

        Returns:
            Item if available, 0 if empty (0 = sentinel for empty queue)

        Note: Task IDs must be non-zero for this to work correctly.
        """
        if not self.mutex.lock():
            return 0

        var result = 0
        if not self.items.is_empty():
            result = self.items[0]
            self.items = self.items[1:]

        self.mutex.unlock()
        result

    me pop_blocking(timeout_ms: i64) -> usize:
        """Pop item with timeout (blocking, thread-safe).

        Waits until item available or timeout expires.

        Args:
            timeout_ms: Timeout in milliseconds (0 = wait forever)

        Returns:
            Item if available, 0 on timeout (0 = sentinel for timeout/empty)

        Note: Task IDs must be non-zero for this to work correctly.
        """
        if not self.mutex.lock():
            return 0

        var result = 0

        # Wait for item
        if self.items.is_empty():
            if timeout_ms == 0:
                # Wait forever
                self.not_empty.wait(self.mutex)
            else:
                # Wait with timeout
                if not self.not_empty.wait_timeout(self.mutex, timeout_ms):
                    # Timeout - return 0
                    self.mutex.unlock()
                    return 0

        # Item available
        if not self.items.is_empty():
            result = self.items[0]
            self.items = self.items[1:]

        self.mutex.unlock()
        result

    fn len() -> usize:
        """Get queue size (thread-safe).

        Returns:
            Number of items in queue
        """
        if not self.mutex.lock():
            return 0

        val size = self.items.len()
        self.mutex.unlock()
        size

    fn is_empty() -> bool:
        """Check if queue is empty (thread-safe).

        Returns:
            true if empty, false otherwise
        """
        if not self.mutex.lock():
            return true

        val empty = self.items.is_empty()
        self.mutex.unlock()
        empty

    me clear():
        """Clear all items (thread-safe)."""
        self.mutex.lock()
        self.items = []
        self.mutex.unlock()

    me destroy():
        """Destroy queue and free resources."""
        self.mutex.destroy()
        self.not_empty.destroy()

export ThreadSafeQueue
