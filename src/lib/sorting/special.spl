# Sorting - Special and Non-Comparison Sorts

use sorting.simple.{insertion_sort, insertion_sort_range}
use sorting.advanced.{copy_range, lomuto_partition, merge_in_place}

# Counting Sort
fn counting_sort(arr: List<i64>, max_val: i64) -> List<i64>:
    val len = arr.len()

    var counts = []
    var i = 0
    while i <= max_val:
        counts = counts.push(0)
        i = i + 1

    var j = 0
    while j < len:
        val val = arr.get(j)
        val old_count = counts.get(val)
        counts.set(val, old_count + 1)
        j = j + 1

    var result = []
    var k = 0
    while k <= max_val:
        val count = counts.get(k)
        var m = 0
        while m < count:
            result = result.push(k)
            m = m + 1
        k = k + 1

    result

fn counting_sort_stable(arr: List<i64>, max_val: i64) -> List<i64>:
    val len = arr.len()

    var counts = []
    var i = 0
    while i <= max_val:
        counts = counts.push(0)
        i = i + 1

    var j = 0
    while j < len:
        val val = arr.get(j)
        val old_count = counts.get(val)
        counts.set(val, old_count + 1)
        j = j + 1

    var k = 1
    while k <= max_val:
        val prev = counts.get(k - 1)
        val curr = counts.get(k)
        counts.set(k, prev + curr)
        k = k + 1

    var result = []
    var m = 0
    while m < len:
        result = result.push(0)
        m = m + 1

    var n = len - 1
    while n >= 0:
        val val = arr.get(n)
        val pos = counts.get(val)
        result.set(pos - 1, val)
        counts.set(val, pos - 1)
        n = n - 1

    result

# Radix Sort
fn get_digit(num: i64, exp: i64) -> i64:
    (num / exp) % 10

fn radix_sort_lsd(arr: List<i64>, max_digits: i64) -> List<i64>:
    var result = arr.copy()

    var exp = 1
    var digit = 0
    while digit < max_digits:
        result = radix_sort_lsd_pass(result, exp)
        exp = exp * 10
        digit = digit + 1

    result

fn radix_sort_lsd_pass(arr: List<i64>, exp: i64) -> List<i64>:
    val len = arr.len()

    var counts = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]

    var i = 0
    while i < len:
        val val = arr.get(i)
        val digit = get_digit(val, exp)
        val old_count = counts.get(digit)
        counts.set(digit, old_count + 1)
        i = i + 1

    var j = 1
    while j < 10:
        val prev = counts.get(j - 1)
        val curr = counts.get(j)
        counts.set(j, prev + curr)
        j = j + 1

    var result = []
    var k = 0
    while k < len:
        result = result.push(0)
        k = k + 1

    var m = len - 1
    while m >= 0:
        val val = arr.get(m)
        val digit = get_digit(val, exp)
        val pos = counts.get(digit)
        result.set(pos - 1, val)
        counts.set(digit, pos - 1)
        m = m - 1

    result

fn radix_sort_msd(arr: List<i64>, max_val: i64) -> List<i64>:
    var result = arr.copy()

    var max_exp = 1
    var temp = max_val
    while temp >= 10:
        max_exp = max_exp * 10
        temp = temp / 10

    radix_sort_msd_helper(result, 0, result.len() - 1, max_exp)
    result

fn radix_sort_msd_helper(arr: List<i64>, low: i64, high: i64, exp: i64):
    if low >= high or exp < 1:
        return ()

    val size = high - low + 1
    if size < 10:
        insertion_sort_range(arr, low, high)
        return ()

    var counts = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
    var i = low
    while i <= high:
        val val = arr.get(i)
        val digit = get_digit(val, exp)
        val old_count = counts.get(digit + 1)
        counts.set(digit + 1, old_count + 1)
        i = i + 1

    var j = 1
    while j < 11:
        val prev = counts.get(j - 1)
        val curr = counts.get(j)
        counts.set(j, prev + curr)
        j = j + 1

    var temp = []
    var k = 0
    val range_size = high - low + 1
    while k < range_size:
        temp = temp.push(0)
        k = k + 1

    var m = low
    while m <= high:
        val val = arr.get(m)
        val digit = get_digit(val, exp)
        val pos = counts.get(digit)
        temp.set(pos, val)
        counts.set(digit, pos + 1)
        m = m + 1

    var n = 0
    while n < range_size:
        val val = temp.get(n)
        arr.set(low + n, val)
        n = n + 1

    var digit_idx = 0
    while digit_idx < 10:
        val bucket_start = counts.get(digit_idx)
        val bucket_end = counts.get(digit_idx + 1) - 1
        if bucket_start < bucket_end:
            radix_sort_msd_helper(arr, low + bucket_start, low + bucket_end, exp / 10)
        digit_idx = digit_idx + 1

# Bucket Sort
fn bucket_sort(arr: List<i64>, bucket_count: i64, max_val: i64) -> List<i64>:
    val len = arr.len()

    var buckets = []
    var i = 0
    while i < bucket_count:
        buckets = buckets.push([])
        i = i + 1

    var j = 0
    while j < len:
        val val = arr.get(j)
        val bucket_idx = (val * bucket_count) / (max_val + 1)
        val bucket = buckets.get(bucket_idx)
        val new_bucket = bucket.push(val)
        buckets.set(bucket_idx, new_bucket)
        j = j + 1

    var result = []
    var k = 0
    while k < bucket_count:
        val bucket = buckets.get(k)
        val sorted_bucket = insertion_sort(bucket)

        var m = 0
        val bucket_len = sorted_bucket.len()
        while m < bucket_len:
            val val = sorted_bucket.get(m)
            result = result.push(val)
            m = m + 1

        k = k + 1

    result

# Selection algorithms
fn partial_sort(arr: List<i64>, k: i64) -> List<i64>:
    var result = arr.copy()
    val len = result.len()
    val limit = if k < len: k else: len

    var i = 0
    while i < limit:
        var min_idx = i
        var j = i + 1
        while j < len:
            val curr_min = result.get(min_idx)
            val candidate = result.get(j)
            if candidate < curr_min:
                min_idx = j
            j = j + 1

        if min_idx != i:
            val temp = result.get(i)
            result.set(i, result.get(min_idx))
            result.set(min_idx, temp)
        i = i + 1

    result

fn quickselect(arr: List<i64>, k: i64) -> i64:
    var working = arr.copy()
    quickselect_helper(working, 0, working.len() - 1, k)

fn quickselect_helper(arr: List<i64>, low: i64, high: i64, k: i64) -> i64:
    if low == high:
        return arr.get(low)

    val pi = lomuto_partition(arr, low, high)

    if k == pi:
        arr.get(k)
    else if k < pi:
        quickselect_helper(arr, low, pi - 1, k)
    else:
        quickselect_helper(arr, pi + 1, high, k)

fn median(arr: List<i64>) -> i64:
    val len = arr.len()
    val mid = len / 2
    quickselect(arr, mid)

fn kth_smallest(arr: List<i64>, k: i64) -> i64:
    quickselect(arr, k - 1)

fn kth_largest(arr: List<i64>, k: i64) -> i64:
    val len = arr.len()
    quickselect(arr, len - k)

# Custom comparator sorts
fn sort_with_comparator(arr: List<i64>, cmp: fn(i64, i64) -> i64) -> List<i64>:
    mergesort_with_comparator(arr, cmp)

fn mergesort_with_comparator(arr: List<i64>, cmp: fn(i64, i64) -> i64) -> List<i64>:
    val len = arr.len()
    if len <= 1:
        return arr

    val mid = len / 2
    val left = copy_range(arr, 0, mid - 1)
    val right = copy_range(arr, mid, len - 1)

    val sorted_left = mergesort_with_comparator(left, cmp)
    val sorted_right = mergesort_with_comparator(right, cmp)
    merge_with_comparator(sorted_left, sorted_right, cmp)

fn merge_with_comparator(left: List<i64>, right: List<i64>, cmp: fn(i64, i64) -> i64) -> List<i64>:
    var result = []
    var i = 0
    var j = 0
    val left_len = left.len()
    val right_len = right.len()

    while i < left_len and j < right_len:
        val left_val = left.get(i)
        val right_val = right.get(j)
        val comparison = cmp(left_val, right_val)

        if comparison <= 0:
            result = result.push(left_val)
            i = i + 1
        else:
            result = result.push(right_val)
            j = j + 1

    while i < left_len:
        val val = left.get(i)
        result = result.push(val)
        i = i + 1

    while j < right_len:
        val val = right.get(j)
        result = result.push(val)
        j = j + 1

    result

export counting_sort, counting_sort_stable
export get_digit, radix_sort_lsd, radix_sort_msd
export bucket_sort
export partial_sort, quickselect, median, kth_smallest, kth_largest
export sort_with_comparator, mergesort_with_comparator, merge_with_comparator
