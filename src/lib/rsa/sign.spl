# RSA Signing and Verification
#
# Digital signature operations with PKCS#1 v1.5

import src.std.array as array
import src.std.rsa.types as types
import src.std.rsa.modular as modular
import src.std.rsa.key_gen as key_gen
import src.std.rsa.byte_conversion as byte_conversion
import src.std.rsa.padding as padding
import src.std.rsa.encrypt as encrypt

# RSA sign message (PKCS#1 v1.5)
fn rsa_sign(message: text, private_key: list) -> list:
    val key_bits = key_gen.get_key_bits(private_key)
    val key_bytes = key_bits / 8

    val message_bytes = byte_conversion.text_to_bytes(message)
    val hash = padding.simple_hash(message_bytes)

    val padded = padding.pkcs1_pad_type1(hash, key_bytes)

    val padded_bi = byte_conversion.bytes_to_bigint(padded)

    val signature_bi = encrypt.rsa_raw_decrypt_crt(padded_bi, private_key)

    val signature_bytes = byte_conversion.bigint_to_bytes(signature_bi, key_bytes)

    return signature_bytes

# RSA verify signature (PKCS#1 v1.5)
fn rsa_verify(message: text, signature: list, public_key: list) -> bool:
    val key_bits = key_gen.get_key_bits(public_key)
    val key_bytes = key_bits / 8

    val message_bytes = byte_conversion.text_to_bytes(message)
    val hash = padding.simple_hash(message_bytes)

    val expected_padded = padding.pkcs1_pad_type1(hash, key_bytes)

    val signature_bi = byte_conversion.bytes_to_bigint(signature)

    val padded_bi = encrypt.rsa_raw_encrypt(signature_bi, public_key)

    val padded_bytes = byte_conversion.bigint_to_bytes(padded_bi, key_bytes)

    val len_expected = array.length(expected_padded)
    val len_actual = array.length(padded_bytes)

    if len_expected != len_actual:
        return false

    var i = 0
    while i < len_expected:
        val expected_byte = array.get(expected_padded, i)
        val actual_byte = array.get(padded_bytes, i)
        if expected_byte != actual_byte:
            return false
        i = i + 1

    return true

# Sign bytes directly
fn rsa_sign_bytes(message: list, private_key: list) -> list:
    val key_bits = key_gen.get_key_bits(private_key)
    val key_bytes = key_bits / 8

    val hash = padding.simple_hash(message)

    val padded = padding.pkcs1_pad_type1(hash, key_bytes)

    val padded_bi = byte_conversion.bytes_to_bigint(padded)

    val signature_bi = encrypt.rsa_raw_decrypt_crt(padded_bi, private_key)

    val signature_bytes = byte_conversion.bigint_to_bytes(signature_bi, key_bytes)

    return signature_bytes

# Verify signature on bytes
fn rsa_verify_bytes(message: list, signature: list, public_key: list) -> bool:
    val key_bits = key_gen.get_key_bits(public_key)
    val key_bytes = key_bits / 8

    val hash = padding.simple_hash(message)

    val expected_padded = padding.pkcs1_pad_type1(hash, key_bytes)

    val signature_bi = byte_conversion.bytes_to_bigint(signature)

    val padded_bi = encrypt.rsa_raw_encrypt(signature_bi, public_key)

    val padded_bytes = byte_conversion.bigint_to_bytes(padded_bi, key_bytes)

    val len_expected = array.length(expected_padded)
    val len_actual = array.length(padded_bytes)

    if len_expected != len_actual:
        return false

    var i = 0
    while i < len_expected:
        val expected_byte = array.get(expected_padded, i)
        val actual_byte = array.get(padded_bytes, i)
        if expected_byte != actual_byte:
            return false
        i = i + 1

    return true
