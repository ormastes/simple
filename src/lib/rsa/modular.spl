# RSA Modular Arithmetic Operations
#
# Modular exponentiation, GCD, and modular inverse

import src.std.array as array
import src.std.rsa.types as types

# Modular exponentiation: (base^exp) mod m
# Uses binary exponentiation for efficiency
fn bigint_mod_exp(base: list, exp: list, m: list) -> list:
    if types.bigint_is_zero(m):
        return types.bigint_zero()
    if types.bigint_is_one(m):
        return types.bigint_zero()

    var result = types.bigint_one()
    var base_mod = types.bigint_mod(base, m)
    var exp_copy = exp

    while !types.bigint_is_zero(exp_copy):
        val divmod_2 = types.bigint_divmod_i64(exp_copy, 2)
        val remainder = array.get(divmod_2, 1)

        val is_odd = !types.bigint_is_zero(remainder)
        if is_odd:
            val temp = types.bigint_mul(result, base_mod)
            result = types.bigint_mod(temp, m)

        exp_copy = array.get(divmod_2, 0)

        val temp2 = types.bigint_mul(base_mod, base_mod)
        base_mod = types.bigint_mod(temp2, m)

    return result

# Greatest Common Divisor using Euclidean algorithm
fn bigint_gcd(a: list, b: list) -> list:
    var x = a
    var y = b

    while !types.bigint_is_zero(y):
        val divmod_result = types.bigint_divmod(x, y)
        val remainder = array.get(divmod_result, 1)
        x = y
        y = remainder

    return x

# Extended Euclidean algorithm: returns (gcd, x, y) where ax + by = gcd
# Note: x and y might be negative, represented as (value, is_negative)
fn bigint_extended_gcd(a: list, b: list) -> list:
    if types.bigint_is_zero(b):
        return [a, types.bigint_one(), false, types.bigint_zero(), false]

    var old_r = a
    var r = b
    var old_s = types.bigint_one()
    var old_s_neg = false
    var s = types.bigint_zero()
    var s_neg = false
    var old_t = types.bigint_zero()
    var old_t_neg = false
    var t = types.bigint_one()
    var t_neg = false

    while !types.bigint_is_zero(r):
        val divmod_result = types.bigint_divmod(old_r, r)
        val quotient = array.get(divmod_result, 0)
        val remainder = array.get(divmod_result, 1)

        old_r = r
        r = remainder

        val q_times_s = types.bigint_mul(quotient, s)
        var new_s = types.bigint_zero()
        var new_s_neg = false

        if old_s_neg == s_neg:
            val cmp = types.bigint_compare(old_s, q_times_s)
            if cmp >= 0:
                new_s = types.bigint_sub(old_s, q_times_s)
                new_s_neg = old_s_neg
            else:
                new_s = types.bigint_sub(q_times_s, old_s)
                new_s_neg = !old_s_neg
        else:
            new_s = types.bigint_add(old_s, q_times_s)
            new_s_neg = old_s_neg

        old_s = s
        old_s_neg = s_neg
        s = new_s
        s_neg = new_s_neg

        val q_times_t = types.bigint_mul(quotient, t)
        var new_t = types.bigint_zero()
        var new_t_neg = false

        if old_t_neg == t_neg:
            val cmp2 = types.bigint_compare(old_t, q_times_t)
            if cmp2 >= 0:
                new_t = types.bigint_sub(old_t, q_times_t)
                new_t_neg = old_t_neg
            else:
                new_t = types.bigint_sub(q_times_t, old_t)
                new_t_neg = !old_t_neg
        else:
            new_t = types.bigint_add(old_t, q_times_t)
            new_t_neg = old_t_neg

        old_t = t
        old_t_neg = t_neg
        t = new_t
        t_neg = new_t_neg

    return [old_r, old_s, old_s_neg, old_t, old_t_neg]

# Modular multiplicative inverse: a^(-1) mod m
fn bigint_mod_inverse(a: list, m: list) -> list:
    val egcd_result = bigint_extended_gcd(a, m)
    val gcd = array.get(egcd_result, 0)

    if !types.bigint_is_one(gcd):
        return types.bigint_zero()

    val x = array.get(egcd_result, 1)
    val x_neg = array.get(egcd_result, 2)

    if x_neg:
        return types.bigint_mod(types.bigint_sub(m, x), m)
    else:
        return types.bigint_mod(x, m)

# Least Common Multiple
fn bigint_lcm(a: list, b: list) -> list:
    val gcd = bigint_gcd(a, b)
    val product = types.bigint_mul(a, b)
    val divmod_result = types.bigint_divmod(product, gcd)
    return array.get(divmod_result, 0)

# Jacobi symbol (used in some primality tests)
fn jacobi_symbol(a: list, n: list) -> i64:
    if types.bigint_is_zero(a):
        return 0

    val gcd = bigint_gcd(a, n)
    if !types.bigint_is_one(gcd):
        return 0

    return 1
