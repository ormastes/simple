# Avro Schema Constructors
#
# Provides constructors for complex Avro types including records, enums,
# arrays, maps, unions, and fixed-size byte arrays.

# ============================================================================
# Complex Type Constructors
# ============================================================================

fn avro_record_schema(name: text, fields: [tuple]):
    """Create an Avro record schema.
    fields: list of field tuples from avro_field()"""
    (
        type: avro_type_record(),
        name: name,
        fields: fields,
        namespace: nil,
        doc: nil,
        aliases: []
    )

fn avro_record_schema_full(name: text, fields: [tuple], namespace, doc, aliases):
    """Create an Avro record schema with full metadata.
    namespace: optional namespace string
    doc: optional documentation string
    aliases: list of alias strings"""
    (
        type: avro_type_record(),
        name: name,
        fields: fields,
        namespace: namespace,
        doc: doc,
        aliases: aliases
    )

fn avro_field(name: text, field_type, default_val, doc):
    """Create an Avro field descriptor.
    field_type: Avro type tuple
    default_val: optional default value tuple (default: value)
    doc: optional documentation string"""
    (
        name: name,
        type: field_type,
        default: default_val,
        doc: doc,
        order: "ascending",
        aliases: []
    )

fn avro_field_with_aliases(name: text, field_type, default_val, doc, aliases: [text]):
    """Create an Avro field with aliases for schema evolution."""
    (
        name: name,
        type: field_type,
        default: default_val,
        doc: doc,
        order: "ascending",
        aliases: aliases
    )

fn avro_enum_schema(name: text, symbols: [text]):
    """Create an Avro enum schema.
    symbols: list of valid symbol strings"""
    (
        type: avro_type_enum(),
        name: name,
        symbols: symbols,
        namespace: nil,
        doc: nil,
        aliases: [],
        default: nil
    )

fn avro_enum_schema_full(name: text, symbols: [text], namespace, doc, default_symbol):
    """Create an Avro enum schema with full metadata."""
    (
        type: avro_type_enum(),
        name: name,
        symbols: symbols,
        namespace: namespace,
        doc: doc,
        aliases: [],
        default: default_symbol
    )

fn avro_array_schema(items):
    """Create an Avro array schema.
    items: Avro type tuple for array elements"""
    (
        type: avro_type_array(),
        items: items
    )

fn avro_map_schema(values):
    """Create an Avro map schema.
    values: Avro type tuple for map values (keys are always strings)"""
    (
        type: avro_type_map(),
        values: values
    )

fn avro_union_schema(types: [tuple]):
    """Create an Avro union schema.
    types: list of Avro type tuples"""
    (
        type: avro_type_union(),
        types: types
    )

fn avro_fixed_schema(name: text, size: i64):
    """Create an Avro fixed-size bytes schema.
    size: number of bytes"""
    (
        type: avro_type_fixed(),
        name: name,
        size: size,
        namespace: nil,
        aliases: []
    )

# ============================================================================
# Schema Helper Functions
# ============================================================================

fn avro_get_field_schema(record_schema, field_name: text):
    """Get field schema from record schema by name."""
    val fields = record_schema.fields
    var i = 0
    while i < fields.len():
        val field = fields[i]
        if field.name == field_name:
            return field.type
        i = i + 1
    nil

fn avro_find_field(schema, field_name: text):
    """Find field in record schema by name."""
    val fields = schema.fields
    var i = 0
    while i < fields.len():
        val field = fields[i]
        if field.name == field_name:
            return field
        i = i + 1
    nil

fn avro_get_field_value(record_data, field_name: text):
    """Extract field value from record tuple by name.
    Returns nil if field not found."""
    # This is a simplified version - in real use, would need reflection
    # For now, assume record_data is a list of (name, value) pairs
    if record_data == nil:
        return nil

    # Try to access as property (runtime limitation workaround)
    var error = nil
    # Would need runtime support for dynamic field access
    # Return nil as fallback
    nil

fn avro_enum_symbol_to_index(schema, symbol: text) -> i64:
    """Get index of symbol in enum schema. Returns -1 if not found."""
    val symbols = schema.symbols
    var i = 0
    while i < symbols.len():
        if symbols[i] == symbol:
            return i
        i = i + 1
    -1

fn avro_enum_index_to_symbol(schema, index: i64):
    """Get symbol from index. Returns nil if index out of bounds."""
    val symbols = schema.symbols
    if index < 0:
        return nil
    if index >= symbols.len():
        return nil
    symbols[index]
