# Encoding & Hashing Library
#
# Unified module for all encoding, decoding, and hashing operations.
# Consolidated from: encoding_utils.spl, hash_utils.spl
#
# Pure Simple implementation - no external dependencies.
#
# Sections:
# 1. Base Encoding (Base64, Hex, URL, Binary, Octal)
# 2. String Escaping (general, HTML, CSV, Unicode)
# 3. Character Encoding (ROT13, Caesar cipher)
# 4. Hash Functions (string hashing: DJB2, SDBM, FNV, simple)
# 5. Integer Hashing (hash_int, hash_combine)
# 6. Collection Hashing (arrays, tuples)
# 7. Checksums (additive, XOR, Luhn, CRC)
# 8. Hash Table Utilities (buckets, capacity, primes, collisions)
# 9. Advanced Hashing (rolling hash, consistent hashing)
#
# Note: Hash functions are NOT cryptographically secure - for hash tables, checksums only.

use std.text.{NL}

# ============================================================================
# Section 1: Base Encoding
# ============================================================================

# Base64 Encoding
# ------------------------------------------------------------------------------

fn base64_encode(data):
    """Encode byte array to base64 string.

    Example:
        base64_encode([72, 101, 108, 108, 111])  # "SGVsbG8="
    """
    val alphabet = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"
    var result = ""

    var i = 0
    while i < data.len():
        val b1 = data[i]
        val b2 = if i + 1 < data.len(): data[i + 1] else: 0
        val b3 = if i + 2 < data.len(): data[i + 2] else: 0

        val n = (b1 << 16) | (b2 << 8) | b3

        result = result + alphabet[(n >> 18) & 63]
        result = result + alphabet[(n >> 12) & 63]
        result = result + if i + 1 < data.len(): alphabet[(n >> 6) & 63] else: '='
        result = result + if i + 2 < data.len(): alphabet[n & 63] else: '='

        i = i + 3

    result

fn base64_decode(encoded: text):
    """Decode base64 string to byte array.

    Returns nil if invalid base64.

    Example:
        base64_decode("SGVsbG8=")  # [72, 101, 108, 108, 111]
    """
    val alphabet = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"

    # Create lookup table
    var lookup = []
    var i = 0
    while i < 256:
        lookup.push(-1)
        i = i + 1

    i = 0
    while i < alphabet.len():
        lookup[alphabet[i].ord()] = i
        i = i + 1

    var result = []
    i = 0

    while i < encoded.len():
        if encoded[i] == '=':
            break

        val c1 = if i < encoded.len(): lookup[encoded[i].ord()] else: -1
        val c2 = if i + 1 < encoded.len(): lookup[encoded[i + 1].ord()] else: -1
        val c3 = if i + 2 < encoded.len() and encoded[i + 2] != '=': lookup[encoded[i + 2].ord()] else: -1
        val c4 = if i + 3 < encoded.len() and encoded[i + 3] != '=': lookup[encoded[i + 3].ord()] else: -1

        if c1 < 0 or c2 < 0:
            return nil

        val n = (c1 << 18) | (c2 << 12) | (if c3 >= 0: c3 << 6 else: 0) | (if c4 >= 0: c4 else: 0)

        result.push((n >> 16) & 255)
        if c3 >= 0:
            result.push((n >> 8) & 255)
        if c4 >= 0:
            result.push(n & 255)

        i = i + 4

    result

fn base64_encode_string(s: text):
    """Encode string to base64.

    Example:
        base64_encode_string("Hello")  # "SGVsbG8="
    """
    var bytes = []
    var i = 0

    while i < s.len():
        bytes.push(s[i].ord())
        i = i + 1

    base64_encode(bytes)

fn base64_decode_string(encoded: text):
    """Decode base64 to string.

    Example:
        base64_decode_string("SGVsbG8=")  # "Hello"
    """
    val bytes = base64_decode(encoded)
    if not bytes.?:
        return nil

    var result = ""
    for byte in bytes:
        result = result + byte.chr()

    result

# Hexadecimal Encoding
# ------------------------------------------------------------------------------

fn hex_encode(data):
    """Encode byte array to hex string.

    Example:
        hex_encode([72, 101, 108, 108, 111])  # "48656c6c6f"
    """
    val hex_chars = "0123456789abcdef"
    var result = ""

    for byte in data:
        result = result + hex_chars[(byte >> 4) & 15]
        result = result + hex_chars[byte & 15]

    result

fn hex_decode(hex: text):
    """Decode hex string to byte array.

    Returns nil if invalid hex.

    Example:
        hex_decode("48656c6c6f")  # [72, 101, 108, 108, 111]
    """
    if hex.len() % 2 != 0:
        return nil

    var result = []
    var i = 0

    while i < hex.len():
        val h1 = hex_digit_value(hex[i])
        val h2 = hex_digit_value(hex[i + 1])

        if h1 < 0 or h2 < 0:
            return nil

        result.push(h1 * 16 + h2)
        i = i + 2

    result

fn hex_digit_value(c):
    """Convert hex character to value.

    Example:
        hex_digit_value('A')  # 10
    """
    val code = c.ord()

    if code >= '0'.ord() and code <= '9'.ord():
        return code - '0'.ord()
    elif code >= 'a'.ord() and code <= 'f'.ord():
        return code - 'a'.ord() + 10
    elif code >= 'A'.ord() and code <= 'F'.ord():
        return code - 'A'.ord() + 10
    else:
        return -1

fn hex_encode_string(s: text):
    """Encode string to hex.

    Example:
        hex_encode_string("Hello")  # "48656c6c6f"
    """
    var bytes = []
    var i = 0

    while i < s.len():
        bytes.push(s[i].ord())
        i = i + 1

    hex_encode(bytes)

fn hex_decode_string(hex: text):
    """Decode hex to string.

    Example:
        hex_decode_string("48656c6c6f")  # "Hello"
    """
    val bytes = hex_decode(hex)
    if not bytes.?:
        return nil

    var result = ""
    for byte in bytes:
        result = result + byte.chr()

    result

fn hex_dump(data, bytes_per_line: i64):
    """Format hex dump with addresses.

    Example:
        hex_dump([1, 2, 3, 4, 5, 6], 4)
        # "0000: 01 02 03 04\n0004: 05 06"
    """
    var result = ""
    val hex_chars = "0123456789abcdef"

    var i = 0
    while i < data.len():
        # Address
        var addr = i
        var addr_str = ""
        var j = 0
        while j < 4:
            addr_str = hex_chars[addr & 15] + addr_str
            addr = addr >> 4
            j = j + 1
        result = result + addr_str + ": "

        # Hex bytes
        var k = 0
        while k < bytes_per_line and i + k < data.len():
            val byte = data[i + k]
            result = result + hex_chars[(byte >> 4) & 15]
            result = result + hex_chars[byte & 15]
            result = result + " "
            k = k + 1

        result = result + NL
        i = i + bytes_per_line

    result

# URL Encoding
# ------------------------------------------------------------------------------

fn url_encode(s: text):
    """URL encode string (percent encoding).

    Example:
        url_encode("hello world")  # "hello%20world"
    """
    val hex_chars = "0123456789ABCDEF"
    var result = ""

    var i = 0
    while i < s.len():
        val c = s[i]
        val code = c.ord()

        # Check if safe character
        if is_url_safe(c):
            result = result + c
        else:
            # Percent encode
            result = result + '%'
            result = result + hex_chars[(code >> 4) & 15]
            result = result + hex_chars[code & 15]

        i = i + 1

    result

fn url_decode(s: text):
    """URL decode string.

    Returns nil if invalid encoding.

    Example:
        url_decode("hello%20world")  # "hello world"
    """
    var result = ""
    var i = 0

    while i < s.len():
        if s[i] == '%':
            if i + 2 >= s.len():
                return nil

            val h1 = hex_digit_value(s[i + 1])
            val h2 = hex_digit_value(s[i + 2])

            if h1 < 0 or h2 < 0:
                return nil

            result = result + (h1 * 16 + h2).chr()
            i = i + 3
        elif s[i] == '+':
            result = result + ' '
            i = i + 1
        else:
            result = result + s[i]
            i = i + 1

    result

fn is_url_safe(c):
    """Check if character is URL-safe (doesn't need encoding).

    Example:
        is_url_safe('a')  # true
        is_url_safe(' ')  # false
    """
    val code = c.ord()

    # A-Z, a-z, 0-9, -, _, ., ~
    if code >= 'A'.ord() and code <= 'Z'.ord():
        return true
    if code >= 'a'.ord() and code <= 'z'.ord():
        return true
    if code >= '0'.ord() and code <= '9'.ord():
        return true
    if c == '-' or c == '_' or c == '.' or c == '~':
        return true

    false

# Binary & Octal Encoding
# ------------------------------------------------------------------------------

fn binary_encode(n: i64, bits: i64):
    """Encode integer as binary string.

    Example:
        binary_encode(5, 8)  # "00000101"
    """
    var result = ""
    var i = bits - 1

    while i >= 0:
        if (n & (1 << i)) != 0:
            result = result + '1'
        else:
            result = result + '0'
        i = i - 1

    result

fn binary_decode(s: text) -> i64:
    """Decode binary string to integer.

    Example:
        binary_decode("00000101")  # 5
    """
    var result = 0
    var i = 0

    while i < s.len():
        result = result << 1
        if s[i] == '1':
            result = result | 1
        i = i + 1

    result

fn octal_encode(n: i64):
    """Encode integer as octal string.

    Example:
        octal_encode(64)  # "100"
    """
    if n == 0:
        return "0"

    var result = ""
    var num = n

    while num > 0:
        val digit = num % 8
        result = digit.chr() + result
        num = num / 8

    result

fn octal_decode(s: text) -> i64:
    """Decode octal string to integer.

    Example:
        octal_decode("100")  # 64
    """
    var result = 0
    var i = 0

    while i < s.len():
        result = result * 8 + (s[i].ord() - '0'.ord())
        i = i + 1

    result

# ============================================================================
# Section 2: String Escaping
# ============================================================================

fn escape_string(s: text):
    """Escape special characters in string.

    Escapes: \\n, \\t, \\r, \\\\, \\"

    Example:
        escape_string("hello\\nworld")  # "hello\\\\nworld"
    """
    var result = ""
    var i = 0

    while i < s.len():
        val c = s[i]

        if c == '\n':
            result = result + "\\n"
        elif c == '\t':
            result = result + "\\t"
        elif c == '\r':
            result = result + "\\r"
        elif c == '\\':
            result = result + "\\\\"
        elif c == '"':
            result = result + "\\\""
        else:
            result = result + c

        i = i + 1

    result

fn unescape_string(s: text):
    """Unescape string.

    Example:
        unescape_string("hello\\\\nworld")  # "hello\\nworld"
    """
    var result = ""
    var i = 0

    while i < s.len():
        if s[i] == '\\' and i + 1 < s.len():
            val next = s[i + 1]

            if next == 'n':
                result = result + '\n'
                i = i + 2
            elif next == 't':
                result = result + '\t'
                i = i + 2
            elif next == 'r':
                result = result + '\r'
                i = i + 2
            elif next == '\\':
                result = result + '\\'
                i = i + 2
            elif next == '"':
                result = result + '"'
                i = i + 2
            else:
                result = result + s[i]
                i = i + 1
        else:
            result = result + s[i]
            i = i + 1

    result

fn escape_html(s: text):
    """Escape HTML special characters.

    Example:
        escape_html("<div>text</div>")  # "&lt;div&gt;text&lt;/div&gt;"
    """
    var result = ""
    var i = 0

    while i < s.len():
        val c = s[i]

        if c == '<':
            result = result + "&lt;"
        elif c == '>':
            result = result + "&gt;"
        elif c == '&':
            result = result + "&amp;"
        elif c == '"':
            result = result + "&quot;"
        elif c == '\'':
            result = result + "&#39;"
        else:
            result = result + c

        i = i + 1

    result

fn escape_csv(s: text):
    """Escape string for CSV.

    Quotes string if contains comma, quote, or newline.

    Example:
        escape_csv("hello, world")  # "\"hello, world\""
    """
    var needs_quoting = false
    var i = 0

    while i < s.len():
        val nl_char = NL[0:1]
        if s[i] == ',' or s[i] == '"' or s[i] == nl_char:
            needs_quoting = true
            break
        i = i + 1

    if not needs_quoting:
        return s

    var result = "\""
    i = 0

    while i < s.len():
        if s[i] == '"':
            result = result + "\"\""  # Double quote
        else:
            result = result + s[i]
        i = i + 1

    result + "\""

fn char_to_unicode_escape(c) -> text:
    """Convert character to \\uXXXX escape.

    Example:
        char_to_unicode_escape('A')  # "\\u0041"
    """
    val code = c.ord()
    val hex_chars = "0123456789ABCDEF"

    "\\u" +
    hex_chars[(code >> 12) & 15] +
    hex_chars[(code >> 8) & 15] +
    hex_chars[(code >> 4) & 15] +
    hex_chars[code & 15]

fn is_printable(c):
    """Check if character is printable.

    Example:
        is_printable('A')  # true
        is_printable('\n')  # false
    """
    val code = c.ord()
    code >= 32 and code <= 126

fn filter_printable(s: text):
    """Keep only printable characters.

    Example:
        filter_printable("hello\\nworld")  # "helloworld"
    """
    var result = ""
    var i = 0

    while i < s.len():
        if is_printable(s[i]):
            result = result + s[i]
        i = i + 1

    result

# ============================================================================
# Section 3: Character Encoding (ROT13, Caesar)
# ============================================================================

fn rot13_encode(s: text):
    """ROT13 encoding (Caesar cipher with shift 13).

    Example:
        rot13_encode("hello")  # "uryyb"
    """
    var result = ""
    var i = 0

    while i < s.len():
        val c = s[i]
        val code = c.ord()

        if code >= 'a'.ord() and code <= 'z'.ord():
            val shifted = ((code - 'a'.ord() + 13) % 26) + 'a'.ord()
            result = result + shifted.chr()
        elif code >= 'A'.ord() and code <= 'Z'.ord():
            val shifted = ((code - 'A'.ord() + 13) % 26) + 'A'.ord()
            result = result + shifted.chr()
        else:
            result = result + c

        i = i + 1

    result

fn rot13_decode(s: text):
    """ROT13 decoding (same as encoding).

    Example:
        rot13_decode("uryyb")  # "hello"
    """
    rot13_encode(s)

fn caesar_encode(s: text, shift: i64):
    """Caesar cipher with custom shift.

    Example:
        caesar_encode("hello", 3)  # "khoor"
    """
    var result = ""
    var i = 0

    while i < s.len():
        val c = s[i]
        val code = c.ord()

        if code >= 'a'.ord() and code <= 'z'.ord():
            val shifted = ((code - 'a'.ord() + shift) % 26) + 'a'.ord()
            result = result + shifted.chr()
        elif code >= 'A'.ord() and code <= 'Z'.ord():
            val shifted = ((code - 'A'.ord() + shift) % 26) + 'A'.ord()
            result = result + shifted.chr()
        else:
            result = result + c

        i = i + 1

    result

fn caesar_decode(s: text, shift: i64):
    """Decode Caesar cipher.

    Example:
        caesar_decode("khoor", 3)  # "hello"
    """
    caesar_encode(s, 26 - shift)

# ============================================================================
# Section 4: Hash Functions (String Hashing)
# ============================================================================

fn hash_string_djb2(s: text) -> i64:
    """DJB2 hash algorithm for strings.

    Simple and fast hash function.
    Good distribution for hash tables.

    Example:
        hash_string_djb2("hello")  # 210714636441
    """
    var hash = 5381

    var i = 0
    while i < s.len():
        # hash * 33 + c
        hash = ((hash << 5) + hash) + s[i].ord()
        i = i + 1

    hash

fn hash_string_sdbm(s: text) -> i64:
    """SDBM hash algorithm for strings.

    Alternative to DJB2.

    Example:
        hash_string_sdbm("hello")  # Different from DJB2
    """
    var hash = 0

    var i = 0
    while i < s.len():
        # hash = hash * 65599 + c
        hash = s[i].ord() + (hash << 6) + (hash << 16) - hash
        i = i + 1

    hash

fn hash_string_fnv(s: text) -> i64:
    """FNV-1a hash algorithm for strings.

    Good distribution, widely used.

    Example:
        hash_string_fnv("hello")
    """
    var hash = 2166136261  # FNV offset basis (32-bit)

    var i = 0
    while i < s.len():
        hash = hash ^ s[i].ord()
        hash = hash * 16777619  # FNV prime
        i = i + 1

    hash

fn hash_string_simple(s: text) -> i64:
    """Simple polynomial rolling hash.

    Example:
        hash_string_simple("test")
    """
    var hash = 0
    val prime = 31

    var i = 0
    while i < s.len():
        hash = hash * prime + s[i].ord()
        i = i + 1

    hash

# ============================================================================
# Section 5: Integer Hashing
# ============================================================================

fn hash_int(n: i64) -> i64:
    """Hash an integer.

    Uses integer mixing.

    Example:
        hash_int(12345)
    """
    var hash = n

    # Integer mixing
    hash = hash ^ (hash >> 16)
    hash = hash * 0x85ebca6b
    hash = hash ^ (hash >> 13)
    hash = hash * 0xc2b2ae35
    hash = hash ^ (hash >> 16)

    hash

fn hash_combine(hash1: i64, hash2: i64) -> i64:
    """Combine two hash values.

    Useful for hashing composite objects.

    Example:
        hash_combine(hash_int(1), hash_int(2))
    """
    # Based on boost::hash_combine
    hash1 ^ (hash2 + 0x9e3779b9 + (hash1 << 6) + (hash1 >> 2))

fn hash_combine_all(hashes):
    """Combine multiple hash values.

    Example:
        hash_combine_all([hash1, hash2, hash3])
    """
    if hashes.len() == 0:
        return 0

    var result = hashes[0]
    var i = 1

    while i < hashes.len():
        result = hash_combine(result, hashes[i])
        i = i + 1

    result

# ============================================================================
# Section 6: Collection Hashing
# ============================================================================

fn hash_array(arr):
    """Hash an array of integers.

    Example:
        hash_array([1, 2, 3, 4, 5])
    """
    var hash = 0

    for elem in arr:
        hash = hash_combine(hash, hash_int(elem))

    hash

fn hash_string_array(arr):
    """Hash an array of strings.

    Example:
        hash_string_array(["hello", "world"])
    """
    var hash = 0

    for s in arr:
        hash = hash_combine(hash, hash_string_djb2(s))

    hash

fn hash_tuple2(pair):
    """Hash a 2-tuple.

    Example:
        hash_tuple2((1, 2))
    """
    val (a, b) = pair
    hash_combine(hash_int(a), hash_int(b))

fn hash_tuple3(triple):
    """Hash a 3-tuple.

    Example:
        hash_tuple3((1, 2, 3))
    """
    val (a, b, c) = triple
    hash_combine_all([hash_int(a), hash_int(b), hash_int(c)])

# ============================================================================
# Section 7: Checksums
# ============================================================================

fn checksum_add(arr) -> i64:
    """Simple additive checksum.

    Example:
        checksum_add([1, 2, 3, 4])  # 10
    """
    var sum = 0
    for x in arr:
        sum = sum + x
    sum

fn checksum_xor(arr) -> i64:
    """XOR checksum.

    Example:
        checksum_xor([1, 2, 3, 4])  # 1^2^3^4 = 4
    """
    var result = 0
    for x in arr:
        result = result ^ x
    result

fn checksum_string_add(s: text) -> i64:
    """Additive checksum of string.

    Example:
        checksum_string_add("hello")
    """
    var sum = 0
    var i = 0

    while i < s.len():
        sum = sum + s[i].ord()
        i = i + 1

    sum

fn checksum_string_xor(s: text) -> i64:
    """XOR checksum of string.

    Example:
        checksum_string_xor("hello")
    """
    var result = 0
    var i = 0

    while i < s.len():
        result = result ^ s[i].ord()
        i = i + 1

    result

fn luhn_checksum(digits):
    """Calculate Luhn checksum.

    Used for credit card validation.

    Example:
        luhn_checksum([1, 2, 3, 4, 5, 6, 7, 8, 9])
    """
    var sum = 0
    var alternate = false

    var i = digits.len() - 1
    while i >= 0:
        var digit = digits[i]

        if alternate:
            digit = digit * 2
            if digit > 9:
                digit = digit - 9

        sum = sum + digit
        alternate = not alternate
        i = i - 1

    sum % 10

fn luhn_is_valid(digits):
    """Check if digits pass Luhn check.

    Example:
        luhn_is_valid([4, 5, 3, 9, 1, 4, 0, 8, 0, 0, 0, 0, 0, 0, 0, 3])  # Visa
    """
    luhn_checksum(digits) == 0

fn luhn_generate_check_digit(digits):
    """Generate Luhn check digit.

    Returns digit that makes sequence valid.

    Example:
        luhn_generate_check_digit([1, 2, 3, 4, 5, 6, 7, 8, 9])
    """
    var with_zero = digits
    with_zero.push(0)

    val sum_mod = luhn_checksum(with_zero)
    if sum_mod == 0:
        return 0

    10 - sum_mod

fn crc8_simple(data):
    """Simple 8-bit CRC.

    Not standard CRC-8, but simple implementation.

    Example:
        crc8_simple([1, 2, 3, 4, 5])
    """
    var crc = 0

    for byte in data:
        crc = crc ^ byte

        var i = 0
        while i < 8:
            if (crc & 0x80) != 0:
                crc = (crc << 1) ^ 0x07  # Polynomial
            else:
                crc = crc << 1

            crc = crc & 0xFF  # Keep 8 bits
            i = i + 1

    crc

fn crc16_simple(data):
    """Simple 16-bit CRC.

    Example:
        crc16_simple([1, 2, 3, 4, 5])
    """
    var crc = 0xFFFF

    for byte in data:
        crc = crc ^ byte

        var i = 0
        while i < 8:
            if (crc & 0x0001) != 0:
                crc = (crc >> 1) ^ 0xA001  # Polynomial
            else:
                crc = crc >> 1
            i = i + 1

    crc

fn crc_string(s: text) -> i64:
    """CRC of string bytes.

    Example:
        crc_string("hello")
    """
    var bytes = []
    var i = 0

    while i < s.len():
        bytes.push(s[i].ord())
        i = i + 1

    crc16_simple(bytes)

fn verify_checksum(data, expected_checksum: i64):
    """Verify checksum matches data.

    Example:
        verify_checksum([1, 2, 3], 6)  # true for additive
    """
    checksum_add(data) == expected_checksum

# ============================================================================
# Section 8: Hash Table Utilities
# ============================================================================

fn hash_bucket(hash_value: i64, num_buckets: i64) -> i64:
    """Map hash value to bucket index.

    Example:
        hash_bucket(12345, 100)  # 0-99
    """
    val abs_hash = if hash_value < 0: -hash_value else: hash_value
    abs_hash % num_buckets

fn hash_with_capacity(value, capacity: i64) -> i64:
    """Hash value for hash table with given capacity.

    For integer values.

    Example:
        hash_with_capacity(42, 1000)
    """
    hash_bucket(hash_int(value), capacity)

fn hash_string_with_capacity(s: text, capacity: i64) -> i64:
    """Hash string for hash table.

    Example:
        hash_string_with_capacity("key", 1000)
    """
    hash_bucket(hash_string_djb2(s), capacity)

fn find_next_prime(n: i64) -> i64:
    """Find next prime >= n (for hash table sizing).

    Simple trial division.

    Example:
        find_next_prime(100)  # 101
    """
    if n <= 2:
        return 2

    var candidate = if n % 2 == 0: n + 1 else: n

    while true:
        var is_prime = true
        var i = 3

        while i * i <= candidate:
            if candidate % i == 0:
                is_prime = false
                break
            i = i + 2

        if is_prime:
            return candidate

        candidate = candidate + 2

fn good_hash_capacity(expected_size: i64) -> i64:
    """Recommend good hash table capacity.

    Returns prime number ~1.5x expected size.

    Example:
        good_hash_capacity(100)  # ~150, prime
    """
    val target = expected_size + expected_size / 2
    find_next_prime(target)

fn count_collisions(hash_values, capacity: i64) -> i64:
    """Count hash collisions for given capacity.

    Example:
        count_collisions([hash1, hash2, hash3, ...], 100)
    """
    var buckets = []
    var i = 0
    while i < capacity:
        buckets.push(0)
        i = i + 1

    # Count items per bucket
    for hash_val in hash_values:
        val bucket = hash_bucket(hash_val, capacity)
        buckets[bucket] = buckets[bucket] + 1

    # Count collisions
    var collisions = 0
    for count in buckets:
        if count > 1:
            collisions = collisions + (count - 1)

    collisions

fn hash_distribution_score(hash_values, capacity: i64) -> i64:
    """Score hash distribution quality (lower is better).

    Returns sum of squared bucket sizes.

    Example:
        hash_distribution_score(hashes, 100)
    """
    var buckets = []
    var i = 0
    while i < capacity:
        buckets.push(0)
        i = i + 1

    for hash_val in hash_values:
        val bucket = hash_bucket(hash_val, capacity)
        buckets[bucket] = buckets[bucket] + 1

    var score = 0
    for count in buckets:
        score = score + count * count

    score

# ============================================================================
# Section 9: Advanced Hashing (Rolling, Consistent Hashing)
# ============================================================================

fn rolling_hash_init(s: text, window_size: i64):
    """Initialize rolling hash.

    Returns (hash, base, first_char_code).

    Example:
        val (hash, base, first) = rolling_hash_init("hello", 3)
    """
    val base = 31
    var hash = 0
    var power = 1

    var i = 0
    while i < window_size and i < s.len():
        hash = hash * base + s[i].ord()
        if i < window_size - 1:
            power = power * base
        i = i + 1

    (hash, power, if s.len() > 0: s[0].ord() else: 0)

fn rolling_hash_slide(current_hash: i64, power: i64, old_char: i64, new_char: i64) -> i64:
    """Slide rolling hash window.

    Example:
        val new_hash = rolling_hash_slide(hash, power, 'h', 'o')
    """
    val base = 31
    (current_hash - old_char * power) * base + new_char

fn consistent_hash(key: i64, num_servers: i64) -> i64:
    """Simple consistent hashing.

    Maps key to server with minimal disruption on server changes.

    Example:
        consistent_hash(12345, 10)  # Server 0-9
    """
    var h = hash_int(key)
    h = h % (num_servers * 100)  # Create more hash points

    h / 100  # Map to server

fn jump_consistent_hash(key: i64, num_buckets: i64) -> i64:
    """Jump consistent hash algorithm.

    Better than simple consistent hashing.

    Example:
        jump_consistent_hash(12345, 10)
    """
    var k = key
    var b = -1
    var j = 0

    while j < num_buckets:
        b = j
        k = k * 2862933555777941757 + 1
        j = ((b + 1) * (4294967296 / ((k >> 33) + 1)))

    b

fn hash_equals(h1: i64, h2: i64):
    """Check if two hash values are equal.

    Example:
        hash_equals(hash1, hash2)
    """
    h1 == h2

fn hash_compare(h1: i64, h2: i64) -> i64:
    """Compare two hash values.

    Returns: -1 if h1 < h2, 0 if equal, 1 if h1 > h2.

    Example:
        hash_compare(hash1, hash2)
    """
    if h1 < h2:
        return -1
    elif h1 > h2:
        return 1
    else:
        return 0
