# Standard Library — GenStatem OTP Behaviour
#
# @tag:api
# @tag:stdlib
#
# GenStatem behaviour for state machine processes.
# Inspired by Erlang/OTP gen_statem.
#
# Implement handle_event for your state transitions.
# init and terminate have clear contracts; callback_mode has a default.
#
# Usage:
#   @behaviour(GenStatem)
#   class TrafficLight:
#       fn init(args: text) -> text: "red"
#       fn handle_event(event_type: text, event: text,
#                       state_name: text, data: text) -> text:
#           if state_name == "red": "green"
#           elif state_name == "green": "yellow"
#           else: "red"

# Callback mode constants
val CALLBACK_STATE_FUNCTIONS = "state_functions"  # separate fn per state
val CALLBACK_HANDLE_EVENT = "handle_event"         # single handle_event fn

# GenStatem behaviour trait.
# Required: init, handle_event
# Optional (have defaults): callback_mode, terminate
trait GenStatem:
    # Called at startup. Returns the initial state name.
    fn init(args: text) -> text

    # Handle an event in the given state. Returns the new state name.
    fn handle_event(event_type: text, event: text,
                    state_name: text, data: text) -> text

    # Returns the callback mode. Default: handle_event (single dispatch).
    fn callback_mode() -> text:
        CALLBACK_HANDLE_EVENT

    # Called on termination.
    fn terminate(reason: text, state_name: text, data: text):
        pass_do_nothing

# GenStatemRunner — wraps a GenStatem impl and runs transitions.
struct GenStatemRunner:
    state_name: text
    data: text
    name: text
    running: bool

fn gen_statem_runner(name: text, initial_state: text, initial_data: text) -> GenStatemRunner:
    GenStatemRunner(state_name: initial_state, data: initial_data, name: name, running: false)

fn gen_statem_start(runner: GenStatemRunner):
    runner.running = true

fn gen_statem_stop(runner: GenStatemRunner):
    runner.running = false

fn gen_statem_is_running(runner: GenStatemRunner) -> bool:
    runner.running

fn gen_statem_current_state(runner: GenStatemRunner) -> text:
    runner.state_name

# Send an event to the state machine and transition.
fn gen_statem_send_event(runner: GenStatemRunner, event_type: text, event: text,
                         handler: fn(text, text, text, text) -> text):
    val new_state = handler(event_type, event, runner.state_name, runner.data)
    runner.state_name = new_state

export GenStatem, GenStatemRunner
export CALLBACK_STATE_FUNCTIONS, CALLBACK_HANDLE_EVENT
export gen_statem_runner, gen_statem_start, gen_statem_stop
export gen_statem_is_running, gen_statem_current_state, gen_statem_send_event
