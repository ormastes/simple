# Macro Import Model
#
# Macro auto-import semantics with proven invariants (Lean 4 theorems).
# Glob imports include non-macros + auto-imported macros only.
# Explicit imports always work for any public symbol.
#
# Port of rust/dependency_tracker/src/macro_import.rs

from symbol import {SymbolKind}

# ============================================================================
# Symbol Types
# ============================================================================

enum SymKind:
    """Distinguishes macros from other symbols."""
    ValueOrType
    Macro

fn sym_kind_of(kind: SymbolKind) -> SymKind:
    """Map SymbolKind to SymKind."""
    match kind:
        case Macro: SymKind.Macro
        case _: SymKind.ValueOrType

# ============================================================================
# Macro Symbol
# ============================================================================

struct MacroSymbol:
    """A fully-qualified symbol with module path."""
    module_path: text
    name: text
    kind: SymKind

impl MacroSymbol:
    fn is_macro() -> bool:
        match self.kind:
            case Macro: true
            case _: false

    fn qualified_name() -> text:
        "{self.module_path}.{self.name}"

# ============================================================================
# Auto Import
# ============================================================================

struct AutoImport:
    """An auto-import declaration from __init__.spl."""
    name: text
    kind: SymKind

fn is_auto_imported(symbol: MacroSymbol, auto_imports: [AutoImport]) -> bool:
    """Check if a macro symbol is in the auto-import list."""
    if not symbol.is_macro():
        return false
    auto_imports.any(\ai: ai.name == symbol.name and ai.kind == SymKind.Macro)

fn auto_imported_macros(symbols: [MacroSymbol], auto_imports: [AutoImport]) -> [MacroSymbol]:
    """Filter to only macros that are auto-imported."""
    symbols.filter(\s: is_auto_imported(s, auto_imports))

# ============================================================================
# Macro Exports
# ============================================================================

struct MacroExports:
    """Separates public non-macros from public macros."""
    non_macros: [MacroSymbol]
    macros: [MacroSymbol]

fn partition_exports(symbols: [MacroSymbol]) -> MacroExports:
    """Partition symbols into non-macros and macros."""
    MacroExports(
        non_macros: symbols.filter(\s: not s.is_macro()),
        macros: symbols.filter(\s: s.is_macro())
    )

# ============================================================================
# Import Operations
# ============================================================================

fn glob_import(symbols: [MacroSymbol], auto_imports: [AutoImport]) -> [MacroSymbol]:
    """Glob import: returns non-macros + auto-imported macros only.

    This is the key semantic: glob imports do NOT bring in all macros,
    only those explicitly listed in auto-import declarations.
    """
    val exports = partition_exports(symbols)
    val auto_macros = auto_imported_macros(exports.macros, auto_imports)
    exports.non_macros.merge(auto_macros)

fn explicit_import(symbols: [MacroSymbol], name: text) -> MacroSymbol?:
    """Explicit import: always works for any public symbol by name."""
    symbols.filter(\s: s.name == name).first

# ============================================================================
# Directory Manifest
# ============================================================================

struct MacroDirManifest:
    """Directory manifest with auto-import declarations."""
    module_path: text
    auto_imports: [AutoImport]
    public_symbols: [MacroSymbol]

impl MacroDirManifest:
    fn glob_exports() -> [MacroSymbol]:
        """Symbols available via glob import."""
        glob_import(self.public_symbols, self.auto_imports)

    fn explicit_export(name: text) -> MacroSymbol?:
        """Look up a symbol by explicit name."""
        explicit_import(self.public_symbols, name)

# ============================================================================
# Combine Exports
# ============================================================================

fn combine_exports(a: [MacroSymbol], b: [MacroSymbol]) -> [MacroSymbol]:
    """Combine exports from two modules, deduplicating by qualified name."""
    var seen: Dict<text, bool> = {}
    var result: [MacroSymbol] = []
    for sym in a.merge(b):
        val qname = sym.qualified_name()
        if not seen.contains(qname):
            seen[qname] = true
            result = result.push(sym)
    result

export SymKind, sym_kind_of
export MacroSymbol, AutoImport, MacroExports
export is_auto_imported, auto_imported_macros, partition_exports
export glob_import, explicit_import, combine_exports
export MacroDirManifest
