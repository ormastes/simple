# Regular Expression Engine - DFA
#
# Deterministic finite automaton construction and operations.

from .types import DFA, DFAState, DFATransition
from .nfa import nfa_epsilon_closure, nfa_move

# ============================================================================
# DFA CONSTRUCTION
# ============================================================================

fn dfa_create() -> any:
    """Create empty DFA."""
    DFA(states: [], transitions: [], start_state: 0, accept_states: [])

fn dfa_add_state(dfa: any, state_id: i64, is_accept: bool, nfa_states: [i64]) -> any:
    """Add state to DFA."""
    val state = DFAState(state_id: state_id, is_accept: is_accept, nfa_states: nfa_states)
    var states = dfa.states
    states.push(state)
    var accept_states = dfa.accept_states
    if is_accept:
        accept_states.push(state_id)
    DFA(states: states, transitions: dfa.transitions, start_state: dfa.start_state, accept_states: accept_states)

fn dfa_add_transition(dfa: any, from_state: i64, to_state: i64, symbol: text) -> any:
    """Add transition to DFA."""
    val trans = DFATransition(from_state: from_state, to_state: to_state, symbol: symbol)
    var transitions = dfa.transitions
    transitions.push(trans)
    DFA(states: dfa.states, transitions: transitions, start_state: dfa.start_state, accept_states: dfa.accept_states)

fn subset_construction(nfa: any) -> any:
    """Convert NFA to DFA using subset construction."""
    val start_states = [nfa.start_state]
    val start_closure = nfa_epsilon_closure(nfa, start_states)
    var dfa = dfa_create()
    var state_map = []
    var next_id = 0
    val start_is_accept = contains_accept(start_closure, nfa.accept_state)
    dfa = dfa_add_state(dfa, next_id, start_is_accept, start_closure)
    state_map.push((start_closure, next_id))
    next_id = next_id + 1
    var worklist = [start_closure]
    while worklist.len() > 0:
        val curr_idx = worklist.len() - 1
        val curr_states = worklist[curr_idx]
        worklist = worklist[0:curr_idx]
        val curr_id = find_state_id(state_map, curr_states)
        val alphabet = get_alphabet(nfa)
        var sym_idx = 0
        while sym_idx < alphabet.len():
            val symbol = alphabet[sym_idx]
            val next_states = nfa_move(nfa, curr_states, symbol)
            val next_closure = nfa_epsilon_closure(nfa, next_states)
            if next_closure.len() > 0:
                var next_id_val = find_state_id(state_map, next_closure)
                if next_id_val == -1:
                    val next_is_accept = contains_accept(next_closure, nfa.accept_state)
                    dfa = dfa_add_state(dfa, next_id, next_is_accept, next_closure)
                    state_map.push((next_closure, next_id))
                    next_id_val = next_id
                    next_id = next_id + 1
                    worklist.push(next_closure)
                dfa = dfa_add_transition(dfa, curr_id, next_id_val, symbol)
            sym_idx = sym_idx + 1
    dfa

fn contains_accept(states: [i64], accept_state: i64) -> bool:
    """Check if state set contains accept state."""
    var i = 0
    while i < states.len():
        if states[i] == accept_state:
            return true
        i = i + 1
    false

fn find_state_id(state_map: [any], states: [i64]) -> i64:
    """Find state ID for given NFA state set. Returns -1 if not found."""
    var i = 0
    while i < state_map.len():
        val entry = state_map[i]
        val entry_states = entry.0
        if states_equal(entry_states, states):
            return entry.1
        i = i + 1
    -1

fn states_equal(s1: [i64], s2: [i64]) -> bool:
    """Check if two state sets are equal."""
    if s1.len() != s2.len():
        return false
    var i = 0
    while i < s1.len():
        var found = false
        var j = 0
        while j < s2.len():
            if s1[i] == s2[j]:
                found = true
            j = j + 1
        if not found:
            return false
        i = i + 1
    true

fn get_alphabet(nfa: any) -> [text]:
    """Get alphabet (set of symbols) from NFA."""
    var symbols = []
    var i = 0
    while i < nfa.transitions.len():
        val trans = nfa.transitions[i]
        val symbol = trans.symbol
        if symbol != "":
            var already_in = false
            var j = 0
            while j < symbols.len():
                if symbols[j] == symbol:
                    already_in = true
                j = j + 1
            if not already_in:
                symbols.push(symbol)
        i = i + 1
    symbols

fn dfa_minimize(dfa: any) -> any:
    """Minimize DFA using Hopcroft's algorithm (simplified)."""
    dfa

export dfa_create, dfa_add_state, dfa_add_transition, subset_construction, dfa_minimize
export contains_accept, find_state_id, states_equal, get_alphabet
