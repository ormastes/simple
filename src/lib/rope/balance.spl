# Rope Balancing Module
# Functions for rebalancing rope trees

fn rope_needs_rebalancing(node: any) -> bool:
    # Check if rope needs rebalancing
    if node == nil or rope_is_leaf(node):
        return false

    var depth = rope_depth(node)
    var len = rope_length(node)

    # Calculate ideal depth: log2(len)
    var ideal_depth = 1
    var temp = len
    while temp > 1:
        temp = temp / 2
        ideal_depth = ideal_depth + 1

    # Needs rebalancing if depth exceeds ideal by ratio
    var max_depth = ideal_depth * ROPE_REBALANCE_RATIO
    var needs_it = depth > max_depth
    needs_it

fn rope_to_leaf_list(node: any) -> any:
    # Convert rope to list of leaf nodes
    if node == nil:
        return []

    if rope_is_leaf(node):
        return [node]

    var left = node.2
    var right = node.3
    var left_leaves = rope_to_leaf_list(left)
    var right_leaves = rope_to_leaf_list(right)

    left_leaves.concat(right_leaves)

fn rope_from_leaf_list(leaves: any) -> any:
    # Build balanced rope from list of leaves
    if leaves == nil or leaves.length() == 0:
        return rope_create_empty()

    if leaves.length() == 1:
        return leaves[0]

    # Build balanced tree bottom-up
    var current_level = leaves

    while current_level.length() > 1:
        var next_level = []
        var i = 0

        while i < current_level.length():
            if i + 1 < current_level.length():
                var left = current_level[i]
                var right = current_level[i + 1]
                var concat_node = rope_create_concat(left, right)
                next_level = next_level.append(concat_node)
                i = i + 2
            else:
                next_level = next_level.append(current_level[i])
                i = i + 1

        current_level = next_level

    current_level[0]

fn rope_rebalance(node: any) -> any:
    # Rebalance rope tree
    if node == nil or rope_is_leaf(node):
        return node

    var leaves = rope_to_leaf_list(node)

    # Merge small adjacent leaves
    var merged_leaves = []
    var i = 0

    while i < leaves.length():
        var leaf = leaves[i]
        var leaf_len = rope_length(leaf)

        # Try to merge with next leaf if both are small
        var can_merge = i + 1 < leaves.length()
        if can_merge:
            var next_leaf = leaves[i + 1]
            var next_len = rope_length(next_leaf)
            var total = leaf_len + next_len

            if total <= ROPE_MAX_LEAF_SIZE:
                var val1 = leaf.4
                var val2 = next_leaf.4
                var merged_val = "{val1}{val2}"
                var merged_leaf = rope_create_leaf(merged_val)
                merged_leaves = merged_leaves.append(merged_leaf)
                i = i + 2
            else:
                merged_leaves = merged_leaves.append(leaf)
                i = i + 1
        else:
            merged_leaves = merged_leaves.append(leaf)
            i = i + 1

    rope_from_leaf_list(merged_leaves)

fn rope_force_rebalance(node: any) -> any:
    # Force rebalancing regardless of threshold
    if node == nil or rope_is_empty(node):
        return node

    var leaves = rope_to_leaf_list(node)
    rope_from_leaf_list(leaves)

fn rope_is_balanced(node: any) -> bool:
    # Check if rope is balanced
    if node == nil or rope_is_leaf(node):
        return true

    var left = node.2
    var right = node.3
    var left_depth = rope_depth(left)
    var right_depth = rope_depth(right)

    var diff = left_depth - right_depth
    if diff < 0:
        diff = 0 - diff

    var is_bal = diff <= 1
    if not is_bal:
        return false

    var left_bal = rope_is_balanced(left)
    var right_bal = rope_is_balanced(right)

    left_bal and right_bal

fn rope_compact(node: any) -> any:
    # Compact rope by merging all leaves into minimal number
    var s = rope_to_string(node)
    rope_create_from_string(s)

fn rope_optimize_for_append(node: any) -> any:
    # Optimize rope structure for append operations
    # Right-heavy tree is better for appending
    if node == nil or rope_is_leaf(node):
        return node

    var leaves = rope_to_leaf_list(node)
    if leaves.length() <= 1:
        return node

    # Build right-heavy tree
    var result = leaves[0]
    var i = 1

    while i < leaves.length():
        result = rope_create_concat(result, leaves[i])
        i = i + 1

    result

fn rope_optimize_for_prepend(node: any) -> any:
    # Optimize rope structure for prepend operations
    # Left-heavy tree is better for prepending
    if node == nil or rope_is_leaf(node):
        return node

    var leaves = rope_to_leaf_list(node)
    if leaves.length() <= 1:
        return node

    # Build left-heavy tree
    var i = leaves.length() - 1
    var result = leaves[i]
    i = i - 1

    while i >= 0:
        result = rope_create_concat(leaves[i], result)
        i = i - 1

    result
