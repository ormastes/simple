# Rope Splitting Module
# Functions for splitting ropes into segments

fn rope_split_at(node: any, index: i64) -> any:
    # Split rope at index, return (left, right) tuple
    if node == nil:
        return (rope_create_empty(), rope_create_empty())

    var len = rope_length(node)
    if index <= 0:
        return (rope_create_empty(), node)
    if index >= len:
        return (node, rope_create_empty())

    if rope_is_leaf(node):
        var value = node.4
        var left_str = value.substring(0, index)
        var right_str = value.substring(index, len)
        var left = rope_create_leaf(left_str)
        var right = rope_create_leaf(right_str)
        return (left, right)

    # Concat node: split recursively
    var weight = node.1
    var left = node.2
    var right = node.3

    if index < weight:
        var left_parts = rope_split_at(left, index)
        var new_left = left_parts.0
        var left_remainder = left_parts.1
        var new_right = rope_concat(left_remainder, right)
        return (new_left, new_right)

    if index == weight:
        return (left, right)

    var right_index = index - weight
    var right_parts = rope_split_at(right, right_index)
    var right_left = right_parts.0
    var right_right = right_parts.1
    var new_left = rope_concat(left, right_left)
    (new_left, right_right)

fn rope_split_at_multiple(node: any, indices: any) -> any:
    # Split rope at multiple indices
    # Returns list of rope segments
    if indices == nil or indices.length() == 0:
        return [node]

    var result = []
    var current = node
    var prev_index = 0

    var i = 0
    while i < indices.length():
        var index = indices[i]
        if index > prev_index:
            var adjusted_index = index - prev_index
            var parts = rope_split_at(current, adjusted_index)
            var segment = parts.0
            result = result.append(segment)
            current = parts.1
            prev_index = index
        i = i + 1

    # Add final segment
    if not rope_is_empty(current):
        result = result.append(current)

    result

fn rope_split_into_chunks(node: any, chunk_size: i64) -> any:
    # Split rope into chunks of specified size
    var result = []
    var len = rope_length(node)
    var pos = 0

    while pos < len:
        var end = pos + chunk_size
        if end > len:
            end = len

        var chunk_str = rope_substring(node, pos, end)
        var chunk = rope_create_from_string(chunk_str)
        result = result.append(chunk)
        pos = end

    result
