# cuda Simple API (Tier 3)
# Auto-generated API scaffold
#
# This provides an idiomatic Simple API wrapping the FFI bindings.
# Feel free to customize and extend this code.

use std.nogc_async_mut.cuda.ffi.*

# ============================================================================
# Backend Detection
# ============================================================================

fn cuda_available() -> bool:
    rt_cuda_available()

fn cuda_version() -> text:
    rt_cuda_version()

# ============================================================================
# CudaStream Wrapper Class
# ============================================================================

class CudaStreamWrapper:
    """High-level wrapper for CudaStream.

    Automatically manages memory via RAII pattern.
    """

    handle: i64  # Opaque FFI handle (pointer)

    # Static factory methods
    static fn cuda_stream_create() -> CudaStreamWrapper:
        val handle = rt_cuda_cuda_stream_create()
        CudaStreamWrapper(handle: handle)

    static fn cuda_stream_create_with_flags(flags: i32) -> CudaStreamWrapper:
        val handle = rt_cuda_cuda_stream_create_with_flags(flags)
        CudaStreamWrapper(handle: handle)


    fn drop():
        """Automatically free memory when object goes out of scope."""
        rt_cuda_stream_destroy(self.handle)

    # Methods
    fn synchronize() -> bool:
        rt_cuda_cudastream_synchronize(self.handle)

    fn query() -> bool:
        rt_cuda_cudastream_query(self.handle)

    fn wait_event(event: i64) -> bool:
        rt_cuda_cudastream_wait_event(self.handle, event)


# ============================================================================
# CudaEvent Wrapper Class
# ============================================================================

class CudaEventWrapper:
    """High-level wrapper for CudaEvent.

    Automatically manages memory via RAII pattern.
    """

    handle: i64  # Opaque FFI handle (pointer)

    # Static factory methods
    static fn cuda_event_create() -> CudaEventWrapper:
        val handle = rt_cuda_cuda_event_create()
        CudaEventWrapper(handle: handle)


    fn drop():
        """Automatically free memory when object goes out of scope."""
        rt_cuda_event_destroy(self.handle)

    # Methods
    fn synchronize() -> bool:
        rt_cuda_cudaevent_synchronize(self.handle)

    fn query() -> bool:
        rt_cuda_cudaevent_query(self.handle)

    fn elapsed_time(end_event: i64) -> f32:
        rt_cuda_cudaevent_elapsed_time(self.handle, end_event)


# ============================================================================
# CudaDeviceMem Wrapper Class
# ============================================================================

class CudaDeviceMemWrapper:
    """High-level wrapper for CudaDeviceMem.

    Automatically manages memory via RAII pattern.
    """

    handle: i64  # Opaque FFI handle (pointer)

    # Static factory methods
    static fn cuda_malloc(size_bytes: i64) -> CudaDeviceMemWrapper:
        val handle = rt_cuda_cuda_malloc(size_bytes)
        CudaDeviceMemWrapper(handle: handle)


    fn drop():
        """Automatically free memory when object goes out of scope."""
        rt_cuda_free(self.handle)

    # Methods
    fn is_null() -> bool:
        rt_cuda_cudadevicemem_is_null(self.handle)


# ============================================================================
# Exports
# ============================================================================

export CudaStreamWrapper
export CudaEventWrapper
export CudaDeviceMemWrapper
export cuda_available
export cuda_version
