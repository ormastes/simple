# Off-Heap Message Queue (Mailbox)
#
# Provides actor mailbox with priority support.

use types.{Capacity, MessageId, SenderId, ByteSize, Timestamp, Count}

# --- MessagePriority enum ---

enum MessagePriority:
    High
    Normal
    Low

fn MessagePriority__to_i64(p: MessagePriority) -> i64:
    if p == MessagePriority.High: return 0
    if p == MessagePriority.Normal: return 1
    2

# --- SendResult enum ---

enum SendResult:
    Success
    QueueFull
    MailboxClosed

val SEND_SUCCESS = SendResult.Success
val SEND_QUEUE_FULL = SendResult.QueueFull
val SEND_MAILBOX_CLOSED = SendResult.MailboxClosed

# --- MailboxConfig ---

class MailboxConfig:
    capacity: Capacity
    off_heap: bool
    priority_enabled: bool
    high_priority_reserve: Capacity

fn MailboxConfig__default() -> MailboxConfig:
    MailboxConfig(capacity: Capacity(value: 1000), off_heap: true, priority_enabled: false, high_priority_reserve: Capacity(value: 100))

fn MailboxConfig__bounded(cap: Capacity) -> MailboxConfig:
    MailboxConfig(capacity: cap, off_heap: true, priority_enabled: false, high_priority_reserve: Capacity(value: 0))

fn MailboxConfig__unbounded() -> MailboxConfig:
    MailboxConfig(capacity: Capacity(value: 0), off_heap: true, priority_enabled: false, high_priority_reserve: Capacity(value: 0))

fn MailboxConfig__with_priority() -> MailboxConfig:
    MailboxConfig(capacity: Capacity(value: 1000), off_heap: true, priority_enabled: true, high_priority_reserve: Capacity(value: 100))

# --- MessageRef ---

class MessageRef:
    id: MessageId
    sender_id: SenderId
    has_sender: bool
    priority: MessagePriority
    size_bytes: ByteSize
    timestamp_ms: Timestamp

    fn age_ms() -> i64:
        0

    fn is_stale(threshold_ms: i64) -> bool:
        self.age_ms() > threshold_ms

fn MessageRef__new(msg_id: i64, sender, priority: MessagePriority, size_bytes: i64, timestamp: i64) -> MessageRef:
    var sid = 0
    var has_s = false
    if sender.?:
        sid = sender
        has_s = true
    MessageRef(id: MessageId(value: msg_id), sender_id: SenderId(value: sid), has_sender: has_s, priority: priority, size_bytes: ByteSize(value: size_bytes), timestamp_ms: Timestamp(value: timestamp))

# --- MailboxStats ---

class MailboxStats:
    current_size: Count
    total_received: Count
    total_processed: Count
    total_dropped: Count
    off_heap_bytes: ByteSize
    peak_size: Count
    high_priority_count: Count

    fn throughput() -> f64:
        if self.total_received.value == 0:
            return 0.0
        self.total_processed.value * 1.0 / self.total_received.value

    fn drop_rate() -> f64:
        if self.total_received.value == 0:
            return 0.0
        self.total_dropped.value * 100.0 / self.total_received.value

    fn fmt() -> text:
        "MailboxStats(received={self.total_received.value}, processed={self.total_processed.value})"

fn MailboxStats__new() -> MailboxStats:
    MailboxStats(current_size: Count(value: 0), total_received: Count(value: 0), total_processed: Count(value: 0), total_dropped: Count(value: 0), off_heap_bytes: ByteSize(value: 0), peak_size: Count(value: 0), high_priority_count: Count(value: 0))

# --- Mailbox ---

class Mailbox:
    config: MailboxConfig
    messages: [MessageRef]
    high_messages: [MessageRef]
    next_id: i64
    is_closed: bool
    stats: MailboxStats

    me send_normal(data_ref: i64, size_bytes: i64, sender) -> SendResult:
        self.send_with_priority(data_ref, size_bytes, sender, MessagePriority.Normal)

    me send_high(data_ref: i64, size_bytes: i64, sender) -> SendResult:
        self.send_with_priority(data_ref, size_bytes, sender, MessagePriority.High)

    me send_with_priority(data_ref: i64, size_bytes: i64, sender, priority: MessagePriority) -> SendResult:
        if self.is_closed:
            return SEND_MAILBOX_CLOSED
        val total = self.total_size()
        val is_high = priority == MessagePriority.High
        if self.config.capacity.value > 0:
            if not is_high:
                # Normal: respect capacity minus reserve
                val effective_cap = self.config.capacity.value - self.config.high_priority_reserve.value
                if total >= effective_cap:
                    self.stats.total_dropped = Count(value: self.stats.total_dropped.value + 1)
                    self.stats.total_received = Count(value: self.stats.total_received.value + 1)
                    return SEND_QUEUE_FULL
            else:
                # High priority: use full capacity
                if total >= self.config.capacity.value:
                    self.stats.total_dropped = Count(value: self.stats.total_dropped.value + 1)
                    self.stats.total_received = Count(value: self.stats.total_received.value + 1)
                    return SEND_QUEUE_FULL
        val msg = MessageRef__new(self.next_id, sender, priority, size_bytes, 0)
        self.next_id = self.next_id + 1
        if is_high:
            self.high_messages.push(msg)
            self.stats.high_priority_count = Count(value: self.stats.high_priority_count.value + 1)
        else:
            self.messages.push(msg)
        self.stats.current_size = Count(value: self.stats.current_size.value + 1)
        self.stats.total_received = Count(value: self.stats.total_received.value + 1)
        self.stats.off_heap_bytes = ByteSize(value: self.stats.off_heap_bytes.value + size_bytes)
        if self.stats.current_size.value > self.stats.peak_size.value:
            self.stats.peak_size = self.stats.current_size
        SEND_SUCCESS

    me receive():
        # High priority first
        if self.high_messages.len() > 0:
            val msg = self.high_messages[0]
            self.high_messages.remove(0)
            self.stats.current_size = Count(value: self.stats.current_size.value - 1)
            self.stats.total_processed = Count(value: self.stats.total_processed.value + 1)
            self.stats.off_heap_bytes = ByteSize(value: self.stats.off_heap_bytes.value - msg.size_bytes.value)
            return msg
        if self.messages.len() > 0:
            val msg = self.messages[0]
            self.messages.remove(0)
            self.stats.current_size = Count(value: self.stats.current_size.value - 1)
            self.stats.total_processed = Count(value: self.stats.total_processed.value + 1)
            self.stats.off_heap_bytes = ByteSize(value: self.stats.off_heap_bytes.value - msg.size_bytes.value)
            return msg
        nil

    me select(pred: fn()):
        var idx = 0
        for msg in self.messages:
            if pred(msg):
                self.messages.remove(idx)
                self.stats.current_size = Count(value: self.stats.current_size.value - 1)
                return msg
            idx = idx + 1
        nil

    me select_by_sender(sid: i64):
        self.select(fn(m): m.sender_id.value == sid)

    fn total_size() -> i64:
        self.messages.len() + self.high_messages.len()

    fn is_empty() -> bool:
        self.total_size() == 0

    fn is_full() -> bool:
        if self.config.capacity.value == 0:
            return false
        self.total_size() >= self.config.capacity.value

    me clear():
        self.messages = []
        self.high_messages = []
        self.stats.current_size = Count(value: 0)
        self.stats.off_heap_bytes = ByteSize(value: 0)

    me drop_stale(threshold_ms: i64) -> i64:
        var dropped = 0
        var new_msgs = []
        for msg in self.messages:
            if msg.is_stale(threshold_ms):
                dropped = dropped + 1
            else:
                new_msgs.push(msg)
        self.messages = new_msgs
        var new_high = []
        for msg in self.high_messages:
            if msg.is_stale(threshold_ms):
                dropped = dropped + 1
            else:
                new_high.push(msg)
        self.high_messages = new_high
        self.stats.current_size = Count(value: self.stats.current_size.value - dropped)
        dropped

    me close():
        self.is_closed = true

    fn get_stats() -> MailboxStats:
        MailboxStats(
            current_size: self.stats.current_size,
            total_received: self.stats.total_received,
            total_processed: self.stats.total_processed,
            total_dropped: self.stats.total_dropped,
            off_heap_bytes: self.stats.off_heap_bytes,
            peak_size: self.stats.peak_size,
            high_priority_count: self.stats.high_priority_count
        )

    fn fmt() -> text:
        "Mailbox(size={self.total_size()}, closed={self.is_closed})"

fn Mailbox__new(config: MailboxConfig) -> Mailbox:
    Mailbox(
        config: config,
        messages: [],
        high_messages: [],
        next_id: 0,
        is_closed: false,
        stats: MailboxStats__new()
    )

fn Mailbox__default() -> Mailbox:
    Mailbox__new(MailboxConfig__default())

fn Mailbox__unbounded() -> Mailbox:
    Mailbox__new(MailboxConfig__unbounded())

export MessagePriority, MessagePriority__to_i64
export SendResult, SEND_SUCCESS, SEND_QUEUE_FULL, SEND_MAILBOX_CLOSED
export MailboxConfig, MailboxConfig__default, MailboxConfig__bounded, MailboxConfig__unbounded, MailboxConfig__with_priority
export MessageRef, MessageRef__new
export MailboxStats, MailboxStats__new
export Mailbox, Mailbox__new, Mailbox__default, Mailbox__unbounded
