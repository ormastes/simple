# File I/O MCP Server - JSON Helpers
#
# JSON helper functions: building, parsing, formatting, and escaping
# JSON values for MCP protocol messages.

fn LB() -> text:
    "{"

fn RB() -> text:
    "}"

fn Q() -> text:
    "\""

fn jp(key: text, value: text) -> text:
    Q() + key + Q() + ":" + value

fn jo2(p1: text, p2: text) -> text:
    LB() + p1 + "," + p2 + RB()

fn escape_json(s: text) -> text:
    var out = s.replace("\\", "\\\\")
    out = out.replace("\"", "\\\"")
    out = out.replace("\n", "\\n")
    out = out.replace("\r", "\\r")
    out = out.replace("\t", "\\t")
    out

fn js(value: text) -> text:
    Q() + escape_json(value) + Q()

fn make_result_response(id: text, result: text) -> text:
    var use_id = id
    if use_id == "":
        use_id = "null"
    LB() + jp("jsonrpc", js("2.0")) + "," + jp("id", use_id) + "," + jp("result", result) + RB()

fn make_error_response(id: text, code: i64, message: text) -> text:
    var use_id = id
    if use_id == "":
        use_id = "null"
    val err = LB() + jp("code", str(code)) + "," + jp("message", js(message)) + RB()
    LB() + jp("jsonrpc", js("2.0")) + "," + jp("id", use_id) + "," + jp("error", err) + RB()

fn make_tool_result(id: text, text_value: text) -> text:
    val content = "[" + LB() + jp("type", js("text")) + "," + jp("text", js(text_value)) + RB() + "]"
    val result = LB() + jp("content", content) + RB()
    make_result_response(id, result)

fn extract_json_string_v2(json: text, key: text) -> text:
    val pattern = Q() + key + Q() + ":"
    val idx = json.index_of(pattern)
    if not idx.?:
        return ""
    val after = json[idx.unwrap() + pattern.len():]
    var i = 0
    while i < after.len():
        if after[i:i+1] == Q():
            break
        i = i + 1
    if i >= after.len():
        return ""
    val start = i + 1
    var j = start
    while j < after.len():
        if after[j:j+1] == Q():
            return after[start:j]
        j = j + 1
    ""

fn extract_json_value(json: text, key: text) -> text:
    val pattern = Q() + key + Q() + ":"
    val idx = json.index_of(pattern)
    if not idx.?:
        return "null"
    val after = json[idx.unwrap() + pattern.len():].trim()
    if after == "":
        return "null"
    if after.starts_with(Q()):
        var i = 1
        while i < after.len():
            if after[i:i+1] == Q():
                return Q() + after[1:i] + Q()
            i = i + 1
        return "null"
    var i = 0
    while i < after.len():
        val ch = after[i:i+1]
        if ch == "," or ch == "}" or ch == "]":
            break
        i = i + 1
    after[0:i].trim()

fn extract_nested_string(json: text, parent: text, key: text) -> text:
    if parent != "params":
        return ""
    val params = parse_params_json(json)
    extract_json_string_v2(params, key)

fn bool_text(v: bool) -> text:
    if v: "true" else: "false"

fn make_prop(name: text, description: text) -> text:
    jp(name, jo2(jp("type", js("string")), jp("description", js(description))))

fn make_tool_schema_multi(name: text, description: text, props: text, required_json: text, read_only: bool, destructive: bool, idempotent: bool) -> text:
    val input_schema = LB() + jp("type", js("object")) + "," + jp("properties", props) + "," + jp("required", required_json) + RB()
    val annotations = LB() + jp("readOnlyHint", bool_text(read_only)) + "," + jp("destructiveHint", bool_text(destructive)) + "," + jp("idempotentHint", bool_text(idempotent)) + "," + jp("openWorldHint", "false") + RB()
    LB() + jp("name", js(name)) + "," + jp("description", js(description)) + "," + jp("inputSchema", input_schema) + "," + jp("annotations", annotations) + RB()

fn parse_params_json(json: text) -> text:
    val search = "\"params\""
    val idx = json.index_of(search)
    if not idx.?:
        return "{}"

    val start = idx.unwrap() + search.len()
    val rest = json[start:]
    val brace_idx = rest.index_of("{")
    if not brace_idx.?:
        return "{}"

    # Simple brace matching
    var depth = 0
    var result = ""
    for i in brace_idx.unwrap()..rest.len():
        val ch = rest[i:i+1]
        result = result + ch
        if ch == "{":
            depth = depth + 1
        else if ch == "}":
            depth = depth - 1
            if depth == 0:
                break

    result
