# MCP Debug Tools - Handler implementations
#
# All handle_debug_* functions for debug tool execution.
# Split from debug_tools.spl for file size management.

use std.mcp.helpers.{LB, RB, jp, js, parse_int, extract_nested_string, make_tool_result, make_error_response}
use app.io.mod (rt_debug_set_active, rt_debug_add_breakpoint_at, rt_debug_remove_breakpoint_at, rt_debug_continue_exec, rt_debug_pause_exec, rt_debug_set_step_mode_val, rt_debug_stack_trace_lines, rt_debug_local_vars, rt_debug_get_current_file, rt_debug_get_current_line, rt_debug_add_breakpoint_rich, rt_debug_add_function_breakpoint, rt_debug_set_breakpoint_enabled, rt_debug_get_breakpoint_info, rt_debug_list_breakpoints, rt_debug_get_source_lines, rt_debug_add_watch, rt_debug_remove_watch, rt_debug_list_watches, rt_debug_set_variable, rt_debug_terminate, rt_debug_select_frame, rt_debug_get_selected_frame, rt_debug_frame_locals)

# Sub-module imports
use std.nogc_async_mut.mcp.debug_session.{SessionState, TargetType, SessionBreakpoint, SessionDataBreakpoint, DebugSession, SessionManager}
use std.nogc_async_mut.mcp.debug_eval.{EvalResult, eval_expression, eval_get_type, eval_get_value}
use std.nogc_async_mut.mcp.debug_parse.{parse_var_entry, parse_stack_frame, step_mode_to_int}

# --- Handler Functions ---

fn handle_debug_create_session(id: String, body: String, mgr: SessionManager) -> String:
    val program = extract_nested_string(body, "arguments", "program")
    if program == "":
        return make_error_response(id, -32602, "Missing required parameter: program")
    var target_type = extract_nested_string(body, "arguments", "target_type")
    if target_type == "":
        target_type = "interpreter"
    val session = mgr.create_session(program, target_type)
    # Activate debug mode in backend
    rt_debug_set_active(true)
    var result_json = LB()
    result_json = result_json + jp("session_id", js(session.id))
    result_json = result_json + ","
    result_json = result_json + jp("program", js(session.program))
    result_json = result_json + ","
    result_json = result_json + jp("target_type", js(session.target_type))
    result_json = result_json + ","
    result_json = result_json + jp("state", js(session.state))
    result_json = result_json + RB()
    make_tool_result(id, result_json)

fn handle_debug_list_sessions(id: String, mgr: SessionManager) -> String:
    val sessions = mgr.list_sessions()
    var arr = "["
    var first = true
    for s in sessions:
        if not first:
            arr = arr + ","
        first = false
        var obj = LB()
        obj = obj + jp("session_id", js(s.id))
        obj = obj + ","
        obj = obj + jp("program", js(s.program))
        obj = obj + ","
        obj = obj + jp("target_type", js(s.target_type))
        obj = obj + ","
        obj = obj + jp("state", js(s.state))
        obj = obj + RB()
        arr = arr + obj
    arr = arr + "]"
    make_tool_result(id, arr)

fn handle_debug_close_session(id: String, body: String, mgr: SessionManager) -> String:
    val session_id = extract_nested_string(body, "arguments", "session_id")
    if session_id == "":
        return make_error_response(id, -32602, "Missing required parameter: session_id")
    val removed = mgr.remove_session(session_id)
    if not removed:
        return make_error_response(id, -32602, "Session not found: " + session_id)
    # Deactivate debug mode if no sessions remain
    val remaining = mgr.list_sessions()
    if remaining.len() == 0:
        rt_debug_set_active(false)
    var result_json = LB()
    result_json = result_json + jp("closed", js(session_id))
    result_json = result_json + ","
    result_json = result_json + jp("status", js("ok"))
    result_json = result_json + RB()
    make_tool_result(id, result_json)

fn handle_debug_set_breakpoint(id: String, body: String, mgr: SessionManager) -> String:
    val session_id = extract_nested_string(body, "arguments", "session_id")
    if session_id == "":
        return make_error_response(id, -32602, "Missing required parameter: session_id")
    val file = extract_nested_string(body, "arguments", "file")
    if file == "":
        return make_error_response(id, -32602, "Missing required parameter: file")
    val line_str = extract_nested_string(body, "arguments", "line")
    if line_str == "":
        return make_error_response(id, -32602, "Missing required parameter: line")
    val line_result = parse_int(line_str)
    var line = 0
    match line_result:
        Ok(v): line = v
        Err(e): return make_error_response(id, -32602, "Invalid line number: " + line_str)
    val condition = extract_nested_string(body, "arguments", "condition")
    val bp_id_str = mgr.add_breakpoint(session_id, file, line, condition)
    if bp_id_str == "":
        return make_error_response(id, -32602, "Session not found: " + session_id)
    # Register breakpoint in debug backend
    rt_debug_add_breakpoint_at(file, line)
    var result_json = LB()
    result_json = result_json + jp("breakpoint_id", bp_id_str)
    result_json = result_json + ","
    result_json = result_json + jp("session_id", js(session_id))
    result_json = result_json + ","
    result_json = result_json + jp("file", js(file))
    result_json = result_json + ","
    result_json = result_json + jp("line", line.to_string())
    result_json = result_json + ","
    result_json = result_json + jp("verified", "true")
    result_json = result_json + RB()
    make_tool_result(id, result_json)

fn handle_debug_remove_breakpoint(id: String, body: String, mgr: SessionManager) -> String:
    val session_id = extract_nested_string(body, "arguments", "session_id")
    if session_id == "":
        return make_error_response(id, -32602, "Missing required parameter: session_id")
    val bp_id = extract_nested_string(body, "arguments", "breakpoint_id")
    if bp_id == "":
        return make_error_response(id, -32602, "Missing required parameter: breakpoint_id")
    # Look up breakpoint file/line before removing from session
    val sess_idx = mgr.find_session(session_id)
    if sess_idx >= 0:
        val session = mgr.sessions[sess_idx]
        val bp_id_result = parse_int(bp_id)
        var bp_id_int = -1
        match bp_id_result:
            Ok(v): bp_id_int = v
            Err(_): pass
        for bp in session.breakpoints:
            if bp.id == bp_id_int:
                rt_debug_remove_breakpoint_at(bp.file, bp.line)
    val removed = mgr.remove_breakpoint(session_id, bp_id)
    if not removed:
        return make_error_response(id, -32602, "Breakpoint not found: " + bp_id)
    var result_json = LB()
    result_json = result_json + jp("removed", js(bp_id))
    result_json = result_json + ","
    result_json = result_json + jp("status", js("ok"))
    result_json = result_json + RB()
    make_tool_result(id, result_json)

fn handle_debug_continue(id: String, body: String, mgr: SessionManager) -> String:
    val session_id = extract_nested_string(body, "arguments", "session_id")
    if session_id == "":
        return make_error_response(id, -32602, "Missing required parameter: session_id")
    val found = mgr.set_state(session_id, "running")
    if not found:
        return make_error_response(id, -32602, "Session not found: " + session_id)
    # Tell backend to continue execution
    rt_debug_continue_exec()
    var result_json = LB()
    result_json = result_json + jp("session_id", js(session_id))
    result_json = result_json + ","
    result_json = result_json + jp("state", js("running"))
    result_json = result_json + RB()
    make_tool_result(id, result_json)

fn handle_debug_step(id: String, body: String, mgr: SessionManager) -> String:
    val session_id = extract_nested_string(body, "arguments", "session_id")
    if session_id == "":
        return make_error_response(id, -32602, "Missing required parameter: session_id")
    val mode = extract_nested_string(body, "arguments", "mode")
    if mode == "":
        return make_error_response(id, -32602, "Missing required parameter: mode")
    val step_int = step_mode_to_int(mode)
    if step_int == 0:
        return make_error_response(id, -32602, "Invalid step mode: " + mode + ". Must be over, in, or out")
    val found = mgr.set_state(session_id, "paused")
    if not found:
        return make_error_response(id, -32602, "Session not found: " + session_id)
    # Send step command to backend
    rt_debug_set_step_mode_val(step_int)
    var result_json = LB()
    result_json = result_json + jp("session_id", js(session_id))
    result_json = result_json + ","
    result_json = result_json + jp("mode", js(mode))
    result_json = result_json + ","
    result_json = result_json + jp("state", js("paused"))
    result_json = result_json + RB()
    make_tool_result(id, result_json)

fn handle_debug_get_variables(id: String, body: String, mgr: SessionManager) -> String:
    val session_id = extract_nested_string(body, "arguments", "session_id")
    if session_id == "":
        return make_error_response(id, -32602, "Missing required parameter: session_id")
    val idx = mgr.find_session(session_id)
    if idx < 0:
        return make_error_response(id, -32602, "Session not found: " + session_id)
    # Query backend for local variables
    val raw_vars = rt_debug_local_vars()
    var vars_arr = "["
    var first = true
    for raw in raw_vars:
        if not first:
            vars_arr = vars_arr + ","
        first = false
        vars_arr = vars_arr + parse_var_entry(raw)
    vars_arr = vars_arr + "]"
    var result_json = LB()
    result_json = result_json + jp("session_id", js(session_id))
    result_json = result_json + ","
    result_json = result_json + jp("variables", vars_arr)
    result_json = result_json + RB()
    make_tool_result(id, result_json)

fn handle_debug_stack_trace(id: String, body: String, mgr: SessionManager) -> String:
    val session_id = extract_nested_string(body, "arguments", "session_id")
    if session_id == "":
        return make_error_response(id, -32602, "Missing required parameter: session_id")
    val idx = mgr.find_session(session_id)
    if idx < 0:
        return make_error_response(id, -32602, "Session not found: " + session_id)
    val session = mgr.sessions[idx]
    # Query backend for stack trace
    val raw_frames = rt_debug_stack_trace_lines()
    var frames_arr = "["
    if raw_frames.len() > 0:
        var first = true
        var frame_idx = 0
        for raw in raw_frames:
            if not first:
                frames_arr = frames_arr + ","
            first = false
            frames_arr = frames_arr + parse_stack_frame(frame_idx, raw)
            frame_idx = frame_idx + 1
    else:
        # Fallback: use current location from backend
        val cur_file = rt_debug_get_current_file()
        val cur_line = rt_debug_get_current_line()
        var source = session.program
        if cur_file != "":
            source = cur_file
        var line_num = 1
        if cur_line > 0:
            line_num = cur_line
        var frame = LB()
        frame = frame + jp("id", "0")
        frame = frame + ","
        frame = frame + jp("name", js("main"))
        frame = frame + ","
        frame = frame + jp("source", js(source))
        frame = frame + ","
        frame = frame + jp("line", line_num.to_string())
        frame = frame + RB()
        frames_arr = frames_arr + frame
    frames_arr = frames_arr + "]"
    # Count frames
    var total = raw_frames.len()
    if total == 0:
        total = 1
    var result_json = LB()
    result_json = result_json + jp("session_id", js(session_id))
    result_json = result_json + ","
    result_json = result_json + jp("frames", frames_arr)
    result_json = result_json + ","
    result_json = result_json + jp("total_frames", total.to_string())
    result_json = result_json + RB()
    make_tool_result(id, result_json)

fn handle_debug_evaluate(id: String, body: String, mgr: SessionManager) -> String:
    val session_id = extract_nested_string(body, "arguments", "session_id")
    if session_id == "":
        return make_error_response(id, -32602, "Missing required parameter: session_id")
    val expression = extract_nested_string(body, "arguments", "expression")
    if expression == "":
        return make_error_response(id, -32602, "Missing required parameter: expression")
    val idx = mgr.find_session(session_id)
    if idx < 0:
        return make_error_response(id, -32602, "Session not found: " + session_id)
    val frame_str = extract_nested_string(body, "arguments", "frame_index")
    var frame_idx = 0
    if frame_str != "":
        val fr = parse_int(frame_str)
        match fr:
            Ok(v): frame_idx = v
            Err(_): pass
    # Evaluate using Pure Simple evaluator (works in interpreter mode)
    val vars_list = rt_debug_local_vars()
    val eval_typed = eval_expression(expression, vars_list)
    val eval_type = eval_get_type(eval_typed)
    val display_result = eval_get_value(eval_typed)
    var result_json = LB()
    result_json = result_json + jp("session_id", js(session_id))
    result_json = result_json + ","
    result_json = result_json + jp("expression", js(expression))
    result_json = result_json + ","
    result_json = result_json + jp("result", js(display_result))
    result_json = result_json + ","
    result_json = result_json + jp("type", js(eval_type))
    result_json = result_json + RB()
    make_tool_result(id, result_json)

# --- New Handler Functions (Phase 1.5) ---

fn handle_debug_set_function_breakpoint(id: String, body: String, mgr: SessionManager) -> String:
    val session_id = extract_nested_string(body, "arguments", "session_id")
    if session_id == "":
        return make_error_response(id, -32602, "Missing required parameter: session_id")
    val func_name = extract_nested_string(body, "arguments", "function_name")
    if func_name == "":
        return make_error_response(id, -32602, "Missing required parameter: function_name")
    val idx = mgr.find_session(session_id)
    if idx < 0:
        return make_error_response(id, -32602, "Session not found: " + session_id)
    val condition = extract_nested_string(body, "arguments", "condition")
    val bp_id = rt_debug_add_function_breakpoint(func_name, condition)
    var result_json = LB()
    result_json = result_json + jp("breakpoint_id", bp_id.to_string())
    result_json = result_json + "," + jp("session_id", js(session_id))
    result_json = result_json + "," + jp("function_name", js(func_name))
    result_json = result_json + "," + jp("type", js("function"))
    result_json = result_json + "," + jp("verified", "true")
    result_json = result_json + RB()
    make_tool_result(id, result_json)

fn handle_debug_enable_breakpoint(id: String, body: String, mgr: SessionManager) -> String:
    val session_id = extract_nested_string(body, "arguments", "session_id")
    if session_id == "":
        return make_error_response(id, -32602, "Missing required parameter: session_id")
    val bp_id_str = extract_nested_string(body, "arguments", "breakpoint_id")
    if bp_id_str == "":
        return make_error_response(id, -32602, "Missing required parameter: breakpoint_id")
    val enabled_str = extract_nested_string(body, "arguments", "enabled")
    if enabled_str == "":
        return make_error_response(id, -32602, "Missing required parameter: enabled")
    val idx = mgr.find_session(session_id)
    if idx < 0:
        return make_error_response(id, -32602, "Session not found: " + session_id)
    val bp_id_result = parse_int(bp_id_str)
    var bp_id = -1
    match bp_id_result:
        Ok(v): bp_id = v
        Err(_): return make_error_response(id, -32602, "Invalid breakpoint_id: " + bp_id_str)
    var enabled_val = 1
    if enabled_str == "false" or enabled_str == "0":
        enabled_val = 0
    rt_debug_set_breakpoint_enabled(bp_id, enabled_val)
    var result_json = LB()
    result_json = result_json + jp("breakpoint_id", bp_id.to_string())
    result_json = result_json + "," + jp("enabled", enabled_str)
    result_json = result_json + "," + jp("status", js("ok"))
    result_json = result_json + RB()
    make_tool_result(id, result_json)

fn handle_debug_get_source(id: String, body: String, mgr: SessionManager) -> String:
    val session_id = extract_nested_string(body, "arguments", "session_id")
    if session_id == "":
        return make_error_response(id, -32602, "Missing required parameter: session_id")
    val src_file = extract_nested_string(body, "arguments", "file")
    if src_file == "":
        return make_error_response(id, -32602, "Missing required parameter: file")
    val idx = mgr.find_session(session_id)
    if idx < 0:
        return make_error_response(id, -32602, "Session not found: " + session_id)
    val start_str = extract_nested_string(body, "arguments", "start_line")
    var start_line = 1
    if start_str != "":
        val sr = parse_int(start_str)
        match sr:
            Ok(v): start_line = v
            Err(_): pass
    val count_str = extract_nested_string(body, "arguments", "count")
    var line_count = 20
    if count_str != "":
        val cr = parse_int(count_str)
        match cr:
            Ok(v): line_count = v
            Err(_): pass
    val source_text = rt_debug_get_source_lines(src_file, start_line, line_count)
    var result_json = LB()
    result_json = result_json + jp("session_id", js(session_id))
    result_json = result_json + "," + jp("file", js(src_file))
    result_json = result_json + "," + jp("start_line", start_line.to_string())
    result_json = result_json + "," + jp("source", js(source_text))
    result_json = result_json + RB()
    make_tool_result(id, result_json)

fn handle_debug_watch(id: String, body: String, mgr: SessionManager) -> String:
    val session_id = extract_nested_string(body, "arguments", "session_id")
    if session_id == "":
        return make_error_response(id, -32602, "Missing required parameter: session_id")
    val action = extract_nested_string(body, "arguments", "action")
    if action == "":
        return make_error_response(id, -32602, "Missing required parameter: action")
    val idx = mgr.find_session(session_id)
    if idx < 0:
        return make_error_response(id, -32602, "Session not found: " + session_id)
    if action == "add":
        val expr = extract_nested_string(body, "arguments", "expression")
        if expr == "":
            return make_error_response(id, -32602, "Missing expression for add")
        val added = rt_debug_add_watch(expr)
        var result_json = LB()
        result_json = result_json + jp("action", js("add"))
        result_json = result_json + "," + jp("expression", js(expr))
        var ok_str = "true"
        if added == 0:
            ok_str = "false"
        result_json = result_json + "," + jp("success", ok_str)
        result_json = result_json + RB()
        return make_tool_result(id, result_json)
    elif action == "remove":
        val expr = extract_nested_string(body, "arguments", "expression")
        if expr == "":
            return make_error_response(id, -32602, "Missing expression for remove")
        val removed = rt_debug_remove_watch(expr)
        var result_json = LB()
        result_json = result_json + jp("action", js("remove"))
        result_json = result_json + "," + jp("expression", js(expr))
        var ok_str = "true"
        if removed == 0:
            ok_str = "false"
        result_json = result_json + "," + jp("success", ok_str)
        result_json = result_json + RB()
        return make_tool_result(id, result_json)
    elif action == "list":
        val watches = rt_debug_list_watches()
        var result_json = LB()
        result_json = result_json + jp("action", js("list"))
        result_json = result_json + "," + jp("watches", watches)
        result_json = result_json + RB()
        return make_tool_result(id, result_json)
    else:
        return make_error_response(id, -32602, "Invalid action: " + action + ". Must be add, remove, or list")

fn handle_debug_set_variable(id: String, body: String, mgr: SessionManager) -> String:
    val session_id = extract_nested_string(body, "arguments", "session_id")
    if session_id == "":
        return make_error_response(id, -32602, "Missing required parameter: session_id")
    val var_name = extract_nested_string(body, "arguments", "name")
    if var_name == "":
        return make_error_response(id, -32602, "Missing required parameter: name")
    val var_value = extract_nested_string(body, "arguments", "value")
    if var_value == "":
        return make_error_response(id, -32602, "Missing required parameter: value")
    val idx = mgr.find_session(session_id)
    if idx < 0:
        return make_error_response(id, -32602, "Session not found: " + session_id)
    var session = mgr.sessions[idx]
    val frame_str = extract_nested_string(body, "arguments", "frame_index")
    var frame_idx = 0
    if frame_str != "":
        val fr = parse_int(frame_str)
        match fr:
            Ok(v): frame_idx = v
            Err(_): pass
    val ok = rt_debug_set_variable(var_name, var_value, frame_idx)
    var hit_ids = "["
    var first_hit = true
    var hit_count = 0
    var updated_data_bps: [SessionDataBreakpoint] = []
    for dbp in session.data_breakpoints:
        var nd = dbp
        if dbp.enabled and dbp.name == var_name:
            val access = dbp.access_type
            if access == "" or access == "write" or access == "readWrite" or access == "readwrite":
                if dbp.last_value != var_value:
                    nd.last_value = var_value
                    if not first_hit:
                        hit_ids = hit_ids + ","
                    first_hit = false
                    hit_ids = hit_ids + dbp.id.to_string()
                    hit_count = hit_count + 1
        updated_data_bps = updated_data_bps + [nd]
    hit_ids = hit_ids + "]"
    session.data_breakpoints = updated_data_bps
    mgr.sessions[idx] = session
    var result_json = LB()
    result_json = result_json + jp("name", js(var_name))
    result_json = result_json + "," + jp("value", js(var_value))
    result_json = result_json + "," + jp("frame_index", frame_idx.to_string())
    var ok_str = "true"
    if ok == 0:
        ok_str = "false"
    result_json = result_json + "," + jp("success", ok_str)
    var hit_str = "false"
    if hit_count > 0:
        hit_str = "true"
    result_json = result_json + "," + jp("data_breakpoint_hit", hit_str)
    result_json = result_json + "," + jp("hit_breakpoint_ids", hit_ids)
    result_json = result_json + RB()
    make_tool_result(id, result_json)

fn handle_debug_set_data_breakpoint(id: String, body: String, mgr: SessionManager) -> String:
    val session_id = extract_nested_string(body, "arguments", "session_id")
    if session_id == "":
        return make_error_response(id, -32602, "Missing required parameter: session_id")
    val name = extract_nested_string(body, "arguments", "name")
    if name == "":
        return make_error_response(id, -32602, "Missing required parameter: name")
    val idx = mgr.find_session(session_id)
    if idx < 0:
        return make_error_response(id, -32602, "Session not found: " + session_id)

    val session = mgr.sessions[idx]
    val limit = data_breakpoint_limit_for_target(session.target_type)
    if session.data_breakpoints.len() >= limit:
        return make_error_response(id, -32602, "Data breakpoint capacity reached for target " + session.target_type + " (limit=" + limit.to_string() + ")")

    var access_type = extract_nested_string(body, "arguments", "access_type")
    if access_type == "":
        access_type = "write"
    if access_type != "write" and access_type != "read" and access_type != "readWrite":
        return make_error_response(id, -32602, "Invalid access_type: " + access_type)
    val condition = extract_nested_string(body, "arguments", "condition")

    val bp_id = mgr.add_data_breakpoint(session_id, name, access_type, condition)
    if bp_id == "":
        return make_error_response(id, -32602, "Session not found: " + session_id)

    var result_json = LB()
    result_json = result_json + jp("breakpoint_id", bp_id)
    result_json = result_json + "," + jp("session_id", js(session_id))
    result_json = result_json + "," + jp("name", js(name))
    result_json = result_json + "," + jp("access_type", js(access_type))
    result_json = result_json + "," + jp("verified", "true")
    result_json = result_json + "," + jp("limit", limit.to_string())
    result_json = result_json + RB()
    make_tool_result(id, result_json)

fn handle_debug_list_data_breakpoints(id: String, body: String, mgr: SessionManager) -> String:
    val session_id = extract_nested_string(body, "arguments", "session_id")
    if session_id == "":
        return make_error_response(id, -32602, "Missing required parameter: session_id")
    val idx = mgr.find_session(session_id)
    if idx < 0:
        return make_error_response(id, -32602, "Session not found: " + session_id)
    val session = mgr.sessions[idx]

    var arr = "["
    var first = true
    for dbp in session.data_breakpoints:
        if not first:
            arr = arr + ","
        first = false
        var obj = LB()
        obj = obj + jp("id", dbp.id.to_string())
        obj = obj + "," + jp("name", js(dbp.name))
        obj = obj + "," + jp("access_type", js(dbp.access_type))
        var enabled_str = "false"
        if dbp.enabled:
            enabled_str = "true"
        obj = obj + "," + jp("enabled", enabled_str)
        obj = obj + "," + jp("last_value", js(dbp.last_value))
        obj = obj + RB()
        arr = arr + obj
    arr = arr + "]"

    var result_json = LB()
    result_json = result_json + jp("session_id", js(session_id))
    result_json = result_json + "," + jp("breakpoints", arr)
    result_json = result_json + "," + jp("count", session.data_breakpoints.len().to_string())
    result_json = result_json + RB()
    make_tool_result(id, result_json)

fn handle_debug_remove_data_breakpoint(id: String, body: String, mgr: SessionManager) -> String:
    val session_id = extract_nested_string(body, "arguments", "session_id")
    if session_id == "":
        return make_error_response(id, -32602, "Missing required parameter: session_id")
    val bp_id = extract_nested_string(body, "arguments", "breakpoint_id")
    if bp_id == "":
        return make_error_response(id, -32602, "Missing required parameter: breakpoint_id")
    val removed = mgr.remove_data_breakpoint(session_id, bp_id)
    if not removed:
        return make_error_response(id, -32602, "Data breakpoint not found: " + bp_id)

    var result_json = LB()
    result_json = result_json + jp("removed", js(bp_id))
    result_json = result_json + "," + jp("status", js("ok"))
    result_json = result_json + "," + jp("kind", js("data_breakpoint"))
    result_json = result_json + RB()
    make_tool_result(id, result_json)

fn handle_debug_terminate(id: String, body: String, mgr: SessionManager) -> String:
    val session_id = extract_nested_string(body, "arguments", "session_id")
    if session_id == "":
        return make_error_response(id, -32602, "Missing required parameter: session_id")
    val found = mgr.set_state(session_id, "terminated")
    if not found:
        return make_error_response(id, -32602, "Session not found: " + session_id)
    rt_debug_terminate()
    var result_json = LB()
    result_json = result_json + jp("session_id", js(session_id))
    result_json = result_json + "," + jp("state", js("terminated"))
    result_json = result_json + "," + jp("status", js("ok"))
    result_json = result_json + RB()
    make_tool_result(id, result_json)
