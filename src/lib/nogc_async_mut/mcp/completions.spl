# MCP Completions - Argument auto-completion handler
#
# Handles completion/complete requests for prompt and resource arguments.
# Returns matching suggestions based on reference type and current input.

use std.nogc_async_mut.mcp.helpers.{LB, RB, jp, js, jo1, jo2, jo3, escape_json, min_int, make_result_response}
use std.nogc_async_mut.mcp.resources
use std.nogc_async_mut.mcp.prompts

# Handle completion/complete request
fn handle_completion(id: String, ref_type: String, ref_name: String, arg_name: String, arg_value: String, resource_mgr: resources.ResourceManager, prompt_mgr: prompts.PromptManager) -> String:
    var values: [String] = []

    if ref_type == "ref/prompt":
        values = get_prompt_completions(ref_name, arg_name, arg_value, prompt_mgr)
    elif ref_type == "ref/resource":
        values = get_resource_completions(ref_name, arg_value, resource_mgr)

    # Limit to 100 values
    val total = values.len()
    val max_count = 100
    val count = min_int(total, max_count)
    val has_more = total > max_count

    # Build values array
    var vals_json = "["
    var first = true
    var i = 0
    while i < count:
        if not first:
            vals_json = vals_json + ","
        first = false
        vals_json = vals_json + js(escape_json(values[i]))
        i = i + 1
    vals_json = vals_json + "]"

    # Build completion result
    var completion = LB()
    completion = completion + jp("values", vals_json)
    completion = completion + "," + jp("total", total.to_string())
    var hm = "false"
    if has_more:
        hm = "true"
    completion = completion + "," + jp("hasMore", hm)
    completion = completion + RB()

    val result = jo1(jp("completion", completion))
    make_result_response(id, result)

# Get completions for prompt arguments
fn get_prompt_completions(prompt_name: String, arg_name: String, arg_value: String, prompt_mgr: prompts.PromptManager) -> [String]:
    var results: [String] = []

    # If arg_name is empty, complete prompt names
    if arg_name == "":
        val all_prompts = prompt_mgr.list_prompts()
        for p in all_prompts:
            if arg_value == "" or p.name.starts_with(arg_value):
                results.push(p.name)
        return results

    # Complete based on known argument patterns
    if arg_name == "language" or arg_name == "lang":
        val langs = ["simple", "python", "rust", "javascript", "typescript", "go", "java"]
        for lang in langs:
            if arg_value == "" or lang.starts_with(arg_value):
                results.push(lang)
    elif arg_name == "style" or arg_name == "format":
        val styles = ["concise", "detailed", "tutorial", "reference"]
        for s in styles:
            if arg_value == "" or s.starts_with(arg_value):
                results.push(s)

    results

# Get completions for resource URI template parameters
fn get_resource_completions(uri_template: String, arg_value: String, resource_mgr: resources.ResourceManager) -> [String]:
    var results: [String] = []

    # Complete based on URI scheme
    if uri_template.starts_with("file://"):
        val files = ["src/", "test/", "doc/", "examples/"]
        for f in files:
            if arg_value == "" or f.starts_with(arg_value):
                results.push(f)
    elif uri_template.starts_with("bugdb://"):
        val queries = ["all", "open", "critical", "stats"]
        for q in queries:
            if arg_value == "" or q.starts_with(arg_value):
                results.push(q)
    elif uri_template.starts_with("symbol://") or uri_template.starts_with("type://"):
        val types = ["String", "Int", "Bool", "Option", "Result", "List"]
        for t in types:
            if arg_value == "" or t.starts_with(arg_value):
                results.push(t)

    results

export handle_completion
