# Feature Database MCP Resource
#
# Provides MCP access to the unified feature database
# Supports both read and write operations via JSON API

use std.database.feature.{create_feature_database, FeatureDatabase, Feature, FeatureStatus, FeatureMode}
use app.mcp.resource_utils.{
    JsonBuilder, JsonArrayBuilder, escape_json,
    extract_json_string,
    current_timestamp, error_json, success_json, items_to_json
}

export get_all_features, get_features_by_category, get_features_by_status
export get_feature_stats, get_feature_by_id, add_feature_from_json, update_feature_from_json

# ============================================================================
# Read Operations
# ============================================================================

# Get all features from database
fn get_all_features(db_path: text) -> text:
    var featuredb = create_feature_database(db_path)
    val features = featuredb.all_features()
    features_to_json(features)

# Get features by category
fn get_features_by_category(db_path: text, category: text) -> text:
    var featuredb = create_feature_database(db_path)
    val features = featuredb.features_by_category(category)

    val arr = JsonArrayBuilder__new()
    for feature in features:
        arr.item_raw(feature_to_json(feature))

    JsonBuilder__object()
        .field("category", category)
        .field_int("total", features.len())
        .field_array_raw("features", arr)
        .build()

# Get features by status
fn get_features_by_status(db_path: text, status: text) -> text:
    var featuredb = create_feature_database(db_path)
    val parsed_status = parse_feature_status(status)
    val features = featuredb.features_by_status(parsed_status)

    val arr = JsonArrayBuilder__new()
    for feature in features:
        arr.item_raw(feature_to_json(feature))

    JsonBuilder__object()
        .field("status", status)
        .field_int("total", features.len())
        .field_array_raw("features", arr)
        .build()

# Get feature statistics
fn get_feature_stats(db_path: text) -> text:
    var featuredb = create_feature_database(db_path)
    val stats = featuredb.stats()

    JsonBuilder__object()
        .field_int("total", stats.total)
        .field_int("done", stats.done)
        .field_int("in_progress", stats.in_progress)
        .field_int("planned", stats.planned)
        .field_int("failed", stats.failed)
        .field_float("completion_rate", stats.completion_rate)
        .build()

# Get feature by ID
fn get_feature_by_id(db_path: text, feature_id: text) -> text:
    var featuredb = create_feature_database(db_path)
    val feature_opt = featuredb.get_feature(feature_id)

    if not feature_opt.?:
        return error_json("Feature not found: {feature_id}")

    val feature = feature_opt.unwrap()
    feature_to_json(feature)

# ============================================================================
# Write Operations
# ============================================================================

# Add a new feature from JSON
fn add_feature_from_json(db_path: text, json: text) -> text:
    var featuredb = create_feature_database(db_path)

    val id = extract_json_string(json, "id")
    val category = extract_json_string(json, "category")
    val name = extract_json_string(json, "name")
    val description = extract_json_string(json, "description")
    val spec_file = extract_json_string(json, "spec_file")
    val pure_status = extract_json_string(json, "pure_status")
    val hybrid_status = extract_json_string(json, "hybrid_status")
    val llvm_status = extract_json_string(json, "llvm_status")

    if id == "":
        return error_json("Missing required field: id")
    if name == "":
        return error_json("Missing required field: name")

    val feature = Feature(
        id: id,
        category: category,
        name: name,
        description: description,
        spec_file: spec_file,
        pure_status: parse_feature_status(pure_status),
        hybrid_status: parse_feature_status(hybrid_status),
        llvm_status: parse_feature_status(llvm_status),
        created_at: current_timestamp(),
        updated_at: current_timestamp(),
        valid: true
    )

    val added = featuredb.add_feature(feature)
    if not added:
        return error_json("Failed to add feature")

    val saved = featuredb.save()
    if not saved:
        return error_json("Failed to save database")

    success_json(id)

# Update an existing feature from JSON
fn update_feature_from_json(db_path: text, feature_id: text, json: text) -> text:
    var featuredb = create_feature_database(db_path)

    val existing_opt = featuredb.get_feature(feature_id)
    if not existing_opt.?:
        return error_json("Feature not found: {feature_id}")

    val existing = existing_opt.unwrap()

    val pure_status = extract_json_string(json, "pure_status")
    val hybrid_status = extract_json_string(json, "hybrid_status")
    val llvm_status = extract_json_string(json, "llvm_status")
    val name = extract_json_string(json, "name")
    val description = extract_json_string(json, "description")

    val updated_feature = Feature(
        id: feature_id,
        category: existing.category,
        name: if name != "": name else: existing.name,
        description: if description != "": description else: existing.description,
        spec_file: existing.spec_file,
        pure_status: if pure_status != "": parse_feature_status(pure_status) else: existing.pure_status,
        hybrid_status: if hybrid_status != "": parse_feature_status(hybrid_status) else: existing.hybrid_status,
        llvm_status: if llvm_status != "": parse_feature_status(llvm_status) else: existing.llvm_status,
        created_at: existing.created_at,
        updated_at: current_timestamp(),
        valid: true
    )

    val updated = featuredb.update_feature(feature_id, updated_feature)
    if not updated:
        return error_json("Failed to update feature")

    val saved = featuredb.save()
    if not saved:
        return error_json("Failed to save database")

    success_json(feature_id)

# ============================================================================
# JSON Conversion Helpers
# ============================================================================

# Convert list of features to JSON
fn features_to_json(features: [Feature]) -> text:
    items_to_json(features, "features", feature_to_json)

# Convert single feature to JSON
fn feature_to_json(feature: Feature) -> text:
    JsonBuilder__object()
        .field("id", feature.id)
        .field("category", feature.category)
        .field("name", feature.name)
        .field("description", feature.description)
        .field("spec_file", feature.spec_file)
        .field("pure_status", status_to_string(feature.pure_status))
        .field("hybrid_status", status_to_string(feature.hybrid_status))
        .field("llvm_status", status_to_string(feature.llvm_status))
        .build()

# ============================================================================
# Status Conversion Helpers
# ============================================================================

fn status_to_string(status: FeatureStatus) -> text:
    match status:
        case FeatureStatus.Done: "Done"
        case FeatureStatus.InProgress: "InProgress"
        case FeatureStatus.Planned: "Planned"
        case FeatureStatus.Failed: "Failed"
        case FeatureStatus.Blocked: "Blocked"

fn parse_feature_status(s: text) -> FeatureStatus:
    match s:
        case "Done" | "done": FeatureStatus.Done
        case "InProgress" | "in_progress": FeatureStatus.InProgress
        case "Planned" | "planned": FeatureStatus.Planned
        case "Failed" | "failed": FeatureStatus.Failed
        case "Blocked" | "blocked": FeatureStatus.Blocked
        case _: FeatureStatus.Planned
