# MCP Diagnostic VCS Tools - jj integration with diagnostics
#
# Tools:
#   simple_diff   - jj diff with diagnostic annotations on changed lines
#   simple_log    - jj log with per-revision error counts
#   simple_squash - jj squash with pre-check diagnostics
#   simple_new    - jj new with baseline diagnostic snapshot

use app.io.file_ops.{file_read}
use app.io.process_ops.{shell}
use app.io.env_ops.{cwd}
use std.nogc_async_mut.mcp.helpers.{LB, RB, Q, jp, js, jo1, jo2, jo3, parse_int, min_int, extract_arg, make_tool_result, make_error_response, make_tool_schema_multi}
use std.nogc_async_mut.mcp.helpers.{escape_json}
use std.nogc_async_mut.mcp.diag_core.{DiagEntry, DiagResult, run_diagnostics, severity_tag, diag_entries_to_json}
use std.text.{NL}

# ============================================================================
# Tool Schemas
# ============================================================================

fn schema_simple_diff() -> text:
    val rev_prop = jo2(jp("type", js("string")), jp("description", js("Revision to diff (default: @)")))
    val paths_prop = jo2(jp("type", js("string")), jp("description", js("Comma-separated file paths to limit diff")))
    var props = LB()
    props = props + jp("revision", rev_prop)
    props = props + "," + jp("paths", paths_prop)
    props = props + RB()
    make_tool_schema_multi("simple_diff", "Show jj diff with inline diagnostic annotations on changed lines", props, "[]", true, false, true)

fn schema_simple_log() -> text:
    val limit_prop = jo2(jp("type", js("string")), jp("description", js("Max revisions to show (default: 10)")))
    val revsets_prop = jo2(jp("type", js("string")), jp("description", js("Revset expression to filter")))
    var props = LB()
    props = props + jp("limit", limit_prop)
    props = props + "," + jp("revsets", revsets_prop)
    props = props + RB()
    make_tool_schema_multi("simple_log", "Show jj log with diagnostic error counts per changed file", props, "[]", true, false, true)

fn schema_simple_squash() -> text:
    val rev_prop = jo2(jp("type", js("string")), jp("description", js("Revision to squash (default: @)")))
    val msg_prop = jo2(jp("type", js("string")), jp("description", js("Commit message")))
    var props = LB()
    props = props + jp("revision", rev_prop)
    props = props + "," + jp("message", msg_prop)
    props = props + RB()
    make_tool_schema_multi("simple_squash", "Squash jj revision with pre-check diagnostics warning", props, "[]", false, false, false)

fn schema_simple_new() -> text:
    val rev_prop = jo2(jp("type", js("string")), jp("description", js("Parent revision (default: @)")))
    val msg_prop = jo2(jp("type", js("string")), jp("description", js("Description for new revision")))
    var props = LB()
    props = props + jp("revision", rev_prop)
    props = props + "," + jp("message", msg_prop)
    props = props + RB()
    make_tool_schema_multi("simple_new", "Create new jj revision with baseline diagnostic snapshot", props, "[]", false, false, false)

# ============================================================================
# Local jj runner (same pattern as mcp_jj/jj_runner.spl)
# ============================================================================

fn jj_cmd(args_str: text) -> text:
    val cmd = "jj --no-pager --color never " + args_str + " 2>&1"
    val result = shell(cmd)
    result.stdout ?? ""

fn jj_cmd_exit(args_str: text) -> i64:
    val cmd = "jj --no-pager --color never " + args_str + " 2>&1"
    val result = shell(cmd)
    result.exit_code ?? 1

# ============================================================================
# Handlers
# ============================================================================

fn handle_simple_diff(id: text, body: text) -> text:
    val revision = extract_arg(body, "revision")
    val paths_str = extract_arg(body, "paths")

    var rev = "@"
    if revision != "":
        rev = revision

    # Get diff
    var diff_cmd = "diff -r " + rev
    if paths_str != "":
        val path_parts = paths_str.split(",")
        for pp in path_parts:
            val pt = pp.trim()
            if pt != "":
                diff_cmd = diff_cmd + " " + pt
    val diff_output = jj_cmd(diff_cmd)

    # Get changed .spl files from stat
    var stat_cmd = "diff -r " + rev + " --stat"
    val stat_output = jj_cmd(stat_cmd)
    val changed_files = extract_spl_files_from_stat(stat_output)

    # Run diagnostics on changed files
    var file_diags: [text] = []
    var file_diag_entries: [text] = []
    for fpath in changed_files:
        val diag = run_diagnostics(fpath)
        if diag.error_count > 0 or diag.warning_count > 0:
            file_diags.push(fpath + ": " + diag.error_count.to_string() + "E " + diag.warning_count.to_string() + "W")
        # Collect entries as line annotations
        for entry in diag.entries:
            if entry.line_num > 0:
                val tag = severity_tag(entry.severity)
                file_diag_entries.push(fpath + ":" + entry.line_num.to_string() + " " + tag + " " + entry.message)

    # Annotate diff output with diagnostics
    var output = "-- simple_diff -r " + rev + " --{NL}"
    output = output + diff_output

    if file_diags.len() > 0:
        output = output + "{NL}-- diagnostics on changed files --{NL}"
        for fd in file_diags:
            output = output + "  " + fd + NL

    if file_diag_entries.len() > 0:
        output = output + "{NL}-- inline diagnostics --{NL}"
        for fde in file_diag_entries:
            output = output + "  " + fde + NL

    make_tool_result(id, output)

fn handle_simple_log(id: text, body: text) -> text:
    val limit_str = extract_arg(body, "limit")
    val revsets = extract_arg(body, "revsets")

    var limit = 10
    if limit_str != "":
        val lr = parse_int(limit_str)
        match lr:
            Ok(v): limit = v
            Err(_): pass

    # Get log
    var log_cmd = "log --limit " + limit.to_string()
    if revsets != "":
        log_cmd = log_cmd + " -r " + revsets
    val log_output = jj_cmd(log_cmd)

    # Get changed files in current working copy for diagnostic counts
    val stat_output = jj_cmd("diff -r @ --stat")
    val changed_files = extract_spl_files_from_stat(stat_output)

    var total_errors = 0
    var total_warnings = 0
    var file_summaries: [text] = []
    for fpath in changed_files:
        val diag = run_diagnostics(fpath)
        total_errors = total_errors + diag.error_count
        total_warnings = total_warnings + diag.warning_count
        if diag.error_count > 0 or diag.warning_count > 0:
            file_summaries.push("  " + fpath + " " + diag.error_count.to_string() + "E " + diag.warning_count.to_string() + "W")

    var output = "-- simple_log --{NL}"
    output = output + log_output

    if file_summaries.len() > 0:
        output = output + "{NL}-- working copy diagnostics [" + total_errors.to_string() + "E " + total_warnings.to_string() + "W] --{NL}"
        for fs in file_summaries:
            output = output + fs + NL
    else:
        output = output + "{NL}-- working copy: clean --{NL}"

    make_tool_result(id, output)

fn handle_simple_squash(id: text, body: text) -> text:
    val revision = extract_arg(body, "revision")
    val message = extract_arg(body, "message")

    # Pre-check diagnostics on changed files
    val stat_output = jj_cmd("diff -r @ --stat")
    val changed_files = extract_spl_files_from_stat(stat_output)

    var total_errors = 0
    var file_warnings: [text] = []
    for fpath in changed_files:
        val diag = run_diagnostics(fpath)
        total_errors = total_errors + diag.error_count
        if diag.error_count > 0:
            file_warnings.push(fpath + ": " + diag.error_count.to_string() + " error(s)")

    # Run squash
    var squash_cmd = "squash"
    if revision != "":
        squash_cmd = squash_cmd + " -r " + revision
    if message != "":
        squash_cmd = squash_cmd + " -m '" + message + "'"
    val squash_output = jj_cmd(squash_cmd)
    val squash_exit = jj_cmd_exit(squash_cmd)

    var output = "-- simple_squash --{NL}"

    if total_errors > 0:
        output = output + "WARNING: " + total_errors.to_string() + " error(s) in changed files:{NL}"
        for fw in file_warnings:
            output = output + "  " + fw + NL
        output = output + NL

    output = output + squash_output

    if squash_exit == 0:
        output = output + "{NL}Squash completed successfully."
    else:
        output = output + "{NL}Squash failed (exit code " + squash_exit.to_string() + ")."

    make_tool_result(id, output)

fn handle_simple_new(id: text, body: text) -> text:
    val revision = extract_arg(body, "revision")
    val message = extract_arg(body, "message")

    # Create new revision
    var new_cmd = "new"
    if revision != "":
        new_cmd = new_cmd + " " + revision
    if message != "":
        new_cmd = new_cmd + " -m '" + message + "'"
    val new_output = jj_cmd(new_cmd)
    val new_exit = jj_cmd_exit(new_cmd)

    # Get baseline diagnostics for changed files
    val stat_output = jj_cmd("diff -r @ --stat")
    val changed_files = extract_spl_files_from_stat(stat_output)

    var total_errors = 0
    var total_warnings = 0
    var baseline_entries: [text] = []
    for fpath in changed_files:
        val diag = run_diagnostics(fpath)
        total_errors = total_errors + diag.error_count
        total_warnings = total_warnings + diag.warning_count
        if diag.error_count > 0 or diag.warning_count > 0:
            baseline_entries.push("  " + fpath + " " + diag.error_count.to_string() + "E " + diag.warning_count.to_string() + "W")

    # Get revision info
    val rev_info = jj_cmd("log -r @ --limit 1")

    var output = "-- simple_new --{NL}"
    output = output + new_output + NL
    output = output + rev_info

    if baseline_entries.len() > 0:
        output = output + "{NL}-- baseline diagnostics [" + total_errors.to_string() + "E " + total_warnings.to_string() + "W] --{NL}"
        for be in baseline_entries:
            output = output + be + NL
    else:
        output = output + "{NL}-- baseline: clean --{NL}"

    make_tool_result(id, output)

# ============================================================================
# Helpers
# ============================================================================

fn extract_spl_files_from_stat(stat_output: text) -> [text]:
    var files: [text] = []
    val lines = stat_output.split(NL)
    for line in lines:
        val t = line.trim()
        # Format: "path/file.spl | N +++---"
        val pipe_idx = t.index_of(" |") ?? -1
        if pipe_idx > 0:
            val fname = t.substring(0, pipe_idx).trim()
            if fname.ends_with(".spl"):
                files.push(fname)
        elif t.ends_with(".spl"):
            files.push(t)
    files

# extract_arg now imported from lib.mcp

# ============================================================================
# Exports
# ============================================================================

export handle_simple_diff, handle_simple_log, handle_simple_squash, handle_simple_new
export schema_simple_diff, schema_simple_log, schema_simple_squash, schema_simple_new
