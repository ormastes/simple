# MCP Debug Tools - Schema definitions
#
# All schema_debug_* functions for debug tool registration.
# Split from debug_tools.spl for file size management.

use std.nogc_async_mut.mcp.helpers.{LB, RB, Q, jp, js, jo1, jo2, make_tool_schema_multi}

# --- Tool Schema Functions ---

fn schema_debug_create_session() -> String:
    # properties: program (string, required), target_type (string, optional)
    val p1 = jo2(jp("type", js("string")), jp("description", js("Path to the Simple program to debug")))
    val p2 = jo2(jp("type", js("string")), jp("description", js("Target type: interpreter, smf, native, remote")))
    var props = LB()
    props = props + jp("program", p1)
    props = props + ","
    props = props + jp("target_type", p2)
    props = props + RB()
    val req = "[" + js("program") + "]"
    make_tool_schema_multi("debug_create_session", "Create a new debug session for a Simple program", props, req, false, false, false)

fn schema_debug_list_sessions() -> String:
    val props = jo1("")
    make_tool_schema_multi("debug_list_sessions", "List all active debug sessions", props, "[]", true, false, true)

fn schema_debug_close_session() -> String:
    val p1 = jo2(jp("type", js("string")), jp("description", js("ID of the debug session to close")))
    val props = jo1(jp("session_id", p1))
    val req = "[" + js("session_id") + "]"
    make_tool_schema_multi("debug_close_session", "Close and clean up a debug session", props, req, false, true, true)

fn schema_debug_set_breakpoint() -> String:
    val p1 = jo2(jp("type", js("string")), jp("description", js("Debug session ID")))
    val p2 = jo2(jp("type", js("string")), jp("description", js("Source file path")))
    val p3 = jo2(jp("type", js("string")), jp("description", js("Line number")))
    val p4 = jo2(jp("type", js("string")), jp("description", js("Optional condition expression")))
    var props = LB()
    props = props + jp("session_id", p1)
    props = props + ","
    props = props + jp("file", p2)
    props = props + ","
    props = props + jp("line", p3)
    props = props + ","
    props = props + jp("condition", p4)
    props = props + RB()
    val req = "[" + js("session_id") + "," + js("file") + "," + js("line") + "]"
    make_tool_schema_multi("debug_set_breakpoint", "Set a breakpoint in a debug session", props, req, false, false, true)

fn schema_debug_remove_breakpoint() -> String:
    val p1 = jo2(jp("type", js("string")), jp("description", js("Debug session ID")))
    val p2 = jo2(jp("type", js("string")), jp("description", js("Breakpoint ID to remove")))
    var props = LB()
    props = props + jp("session_id", p1)
    props = props + ","
    props = props + jp("breakpoint_id", p2)
    props = props + RB()
    val req = "[" + js("session_id") + "," + js("breakpoint_id") + "]"
    make_tool_schema_multi("debug_remove_breakpoint", "Remove a breakpoint from a debug session", props, req, false, true, true)

fn schema_debug_continue() -> String:
    val p1 = jo2(jp("type", js("string")), jp("description", js("Debug session ID")))
    val props = jo1(jp("session_id", p1))
    val req = "[" + js("session_id") + "]"
    make_tool_schema_multi("debug_continue", "Continue execution of a paused debug session", props, req, false, false, false)

fn schema_debug_step() -> String:
    val p1 = jo2(jp("type", js("string")), jp("description", js("Debug session ID")))
    val p2 = jo2(jp("type", js("string")), jp("description", js("Step mode: over, in, out")))
    var props = LB()
    props = props + jp("session_id", p1)
    props = props + ","
    props = props + jp("mode", p2)
    props = props + RB()
    val req = "[" + js("session_id") + "," + js("mode") + "]"
    make_tool_schema_multi("debug_step", "Step execution in a debug session", props, req, false, false, false)

fn schema_debug_get_variables() -> String:
    val p1 = jo2(jp("type", js("string")), jp("description", js("Debug session ID")))
    val props = jo1(jp("session_id", p1))
    val req = "[" + js("session_id") + "]"
    make_tool_schema_multi("debug_get_variables", "Get variables in the current scope of a debug session", props, req, true, false, true)

fn schema_debug_stack_trace() -> String:
    val p1 = jo2(jp("type", js("string")), jp("description", js("Debug session ID")))
    val props = jo1(jp("session_id", p1))
    val req = "[" + js("session_id") + "]"
    make_tool_schema_multi("debug_stack_trace", "Get the call stack of a debug session", props, req, true, false, true)

fn schema_debug_evaluate() -> String:
    val p1 = jo2(jp("type", js("string")), jp("description", js("Debug session ID")))
    val p2 = jo2(jp("type", js("string")), jp("description", js("Expression to evaluate")))
    var props = LB()
    props = props + jp("session_id", p1)
    props = props + ","
    props = props + jp("expression", p2)
    props = props + RB()
    val req = "[" + js("session_id") + "," + js("expression") + "]"
    make_tool_schema_multi("debug_evaluate", "Evaluate an expression in the context of a debug session", props, req, true, false, true)

# --- New Tool Schemas (Phase 1.5) ---

fn schema_debug_set_function_breakpoint() -> String:
    val p1 = jo2(jp("type", js("string")), jp("description", js("Debug session ID")))
    val p2 = jo2(jp("type", js("string")), jp("description", js("Function name to break on")))
    val p3 = jo2(jp("type", js("string")), jp("description", js("Optional condition expression")))
    var props = LB()
    props = props + jp("session_id", p1)
    props = props + ","
    props = props + jp("function_name", p2)
    props = props + ","
    props = props + jp("condition", p3)
    props = props + RB()
    val req = "[" + js("session_id") + "," + js("function_name") + "]"
    make_tool_schema_multi("debug_set_function_breakpoint", "Set a breakpoint on a function name", props, req, false, false, true)

fn schema_debug_enable_breakpoint() -> String:
    val p1 = jo2(jp("type", js("string")), jp("description", js("Debug session ID")))
    val p2 = jo2(jp("type", js("string")), jp("description", js("Breakpoint ID")))
    val p3 = jo2(jp("type", js("string")), jp("description", js("true to enable, false to disable")))
    var props = LB()
    props = props + jp("session_id", p1)
    props = props + ","
    props = props + jp("breakpoint_id", p2)
    props = props + ","
    props = props + jp("enabled", p3)
    props = props + RB()
    val req = "[" + js("session_id") + "," + js("breakpoint_id") + "," + js("enabled") + "]"
    make_tool_schema_multi("debug_enable_breakpoint", "Enable or disable a breakpoint", props, req, false, false, true)

fn schema_debug_get_source() -> String:
    val p1 = jo2(jp("type", js("string")), jp("description", js("Debug session ID")))
    val p2 = jo2(jp("type", js("string")), jp("description", js("Source file path")))
    val p3 = jo2(jp("type", js("string")), jp("description", js("Start line number")))
    val p4 = jo2(jp("type", js("string")), jp("description", js("Number of lines to read")))
    var props = LB()
    props = props + jp("session_id", p1)
    props = props + ","
    props = props + jp("file", p2)
    props = props + ","
    props = props + jp("start_line", p3)
    props = props + ","
    props = props + jp("count", p4)
    props = props + RB()
    val req = "[" + js("session_id") + "," + js("file") + "]"
    make_tool_schema_multi("debug_get_source", "Read source lines from a file", props, req, true, false, true)

fn schema_debug_watch() -> String:
    val p1 = jo2(jp("type", js("string")), jp("description", js("Debug session ID")))
    val p2 = jo2(jp("type", js("string")), jp("description", js("Action: add, remove, list")))
    val p3 = jo2(jp("type", js("string")), jp("description", js("Watch expression (for add/remove)")))
    var props = LB()
    props = props + jp("session_id", p1)
    props = props + ","
    props = props + jp("action", p2)
    props = props + ","
    props = props + jp("expression", p3)
    props = props + RB()
    val req = "[" + js("session_id") + "," + js("action") + "]"
    make_tool_schema_multi("debug_watch", "Manage watch expressions (add/remove/list)", props, req, false, false, true)

fn schema_debug_set_variable() -> String:
    val p1 = jo2(jp("type", js("string")), jp("description", js("Debug session ID")))
    val p2 = jo2(jp("type", js("string")), jp("description", js("Variable name")))
    val p3 = jo2(jp("type", js("string")), jp("description", js("New value as string")))
    val p4 = jo2(jp("type", js("string")), jp("description", js("Frame index (-1 for globals)")))
    var props = LB()
    props = props + jp("session_id", p1)
    props = props + ","
    props = props + jp("name", p2)
    props = props + ","
    props = props + jp("value", p3)
    props = props + ","
    props = props + jp("frame_index", p4)
    props = props + RB()
    val req = "[" + js("session_id") + "," + js("name") + "," + js("value") + "]"
    make_tool_schema_multi("debug_set_variable", "Set a variable value in a specific frame", props, req, false, false, false)

fn schema_debug_set_data_breakpoint() -> String:
    val p1 = jo2(jp("type", js("string")), jp("description", js("Debug session ID")))
    val p2 = jo2(jp("type", js("string")), jp("description", js("Variable name to watch")))
    val p3 = jo2(jp("type", js("string")), jp("description", js("Access type: write, read, readWrite")))
    val p4 = jo2(jp("type", js("string")), jp("description", js("Optional condition expression")))
    var props = LB()
    props = props + jp("session_id", p1)
    props = props + ","
    props = props + jp("name", p2)
    props = props + ","
    props = props + jp("access_type", p3)
    props = props + ","
    props = props + jp("condition", p4)
    props = props + RB()
    val req = "[" + js("session_id") + "," + js("name") + "]"
    make_tool_schema_multi("debug_set_data_breakpoint", "Set variable-change data breakpoint", props, req, false, false, false)

fn schema_debug_list_data_breakpoints() -> String:
    val p1 = jo2(jp("type", js("string")), jp("description", js("Debug session ID")))
    val props = jo1(jp("session_id", p1))
    val req = "[" + js("session_id") + "]"
    make_tool_schema_multi("debug_list_data_breakpoints", "List variable-change data breakpoints", props, req, true, false, true)

fn schema_debug_remove_data_breakpoint() -> String:
    val p1 = jo2(jp("type", js("string")), jp("description", js("Debug session ID")))
    val p2 = jo2(jp("type", js("string")), jp("description", js("Data breakpoint ID")))
    var props = LB()
    props = props + jp("session_id", p1)
    props = props + ","
    props = props + jp("breakpoint_id", p2)
    props = props + RB()
    val req = "[" + js("session_id") + "," + js("breakpoint_id") + "]"
    make_tool_schema_multi("debug_remove_data_breakpoint", "Remove variable-change data breakpoint", props, req, false, true, true)

fn schema_debug_terminate() -> String:
    val p1 = jo2(jp("type", js("string")), jp("description", js("Debug session ID")))
    val props = jo1(jp("session_id", p1))
    val req = "[" + js("session_id") + "]"
    make_tool_schema_multi("debug_terminate", "Terminate a debug session and stop execution", props, req, false, true, false)
