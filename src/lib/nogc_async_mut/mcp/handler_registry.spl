# MCP Library - Handler Registry (Lazy Loading)
#
# Manages lazy loading of tool/resource/prompt handlers.
# Handlers are loaded on first use to minimize startup time.

use std.nogc_async_mut.mcp.core.{ToolHandler, ResourceHandler, PromptHandler}
use std.nogc_async_mut.mcp.helpers.{make_error_response, make_tool_result}

# Global handler registries
var TOOL_HANDLERS: [ToolHandler] = []
var RESOURCE_HANDLERS: [ResourceHandler] = []
var PROMPT_HANDLERS: [PromptHandler] = []

# Global handler function cache (simulates dynamic loading)
# In a real implementation, this would use module imports
# For now, we'll populate this with handler references during initialization
var TOOL_HANDLER_FNS: [text] = []  # Handler module paths

# Register a tool handler
fn register_tool_handler(handler: ToolHandler):
    TOOL_HANDLERS = TOOL_HANDLERS + [handler]

# Register a resource handler
fn register_resource_handler(handler: ResourceHandler):
    RESOURCE_HANDLERS = RESOURCE_HANDLERS + [handler]

# Register a prompt handler
fn register_prompt_handler(handler: PromptHandler):
    PROMPT_HANDLERS = PROMPT_HANDLERS + [handler]

# Find tool handler by name
fn find_tool_handler(name: text) -> ToolHandler:
    for handler in TOOL_HANDLERS:
        if handler.name == name:
            return handler
    # Return empty handler if not found
    ToolHandler(
        name: "",
        description: "",
        schema: "",
        handler_module: "",
        handler_fn: "",
        loaded: false
    )

# Find resource handler by URI
fn find_resource_handler(uri: text) -> ResourceHandler:
    for handler in RESOURCE_HANDLERS:
        if uri.starts_with(handler.uri_pattern):
            return handler
    # Return empty handler if not found
    ResourceHandler(
        uri_pattern: "",
        handler_module: "",
        handler_fn: "",
        loaded: false
    )

# Find prompt handler by name
fn find_prompt_handler(name: text) -> PromptHandler:
    for handler in PROMPT_HANDLERS:
        if handler.name == name:
            return handler
    # Return empty handler if not found
    PromptHandler(
        name: "",
        handler_module: "",
        handler_fn: "",
        loaded: false
    )

# Dispatch tool call (lazy load handler if needed)
# NOTE: This is a simplified version - Phase 3 will implement actual lazy loading
fn dispatch_tool(name: text, arguments: text) -> text:
    val handler = find_tool_handler(name)

    if handler.name == "":
        return make_error_response("null", -32601, "Tool not found: " + name)

    # For now, return placeholder - actual dispatching happens in main.spl
    # Phase 3 will implement true lazy loading via dynamic imports
    make_tool_result("Handler dispatch for: " + name)

# Get all registered tool names
fn get_registered_tools() -> [text]:
    var names = []
    for handler in TOOL_HANDLERS:
        names = names + [handler.name]
    names

# Get handler count
fn get_tool_handler_count() -> i64:
    TOOL_HANDLERS.len()

fn get_resource_handler_count() -> i64:
    RESOURCE_HANDLERS.len()

fn get_prompt_handler_count() -> i64:
    PROMPT_HANDLERS.len()

# Clear all registries (for testing)
fn clear_registries():
    TOOL_HANDLERS = []
    RESOURCE_HANDLERS = []
    PROMPT_HANDLERS = []
