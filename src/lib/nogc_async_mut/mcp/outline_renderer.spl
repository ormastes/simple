# MCP Outline Renderer - Block-mark format for folded code view
#
# Generates collapsed code views for token-efficient LLM consumption.
# Block-mark format:
#   F> fn name(params) -> type { ... }  - collapsed function
#   C> class Name { field1, field2, N methods }  - collapsed class
#   S> struct Name { field1: type, field2: type }  - collapsed struct
#   E> enum Name { Variant1, Variant2 }  - collapsed enum
#   V* [E]:N message  - virtual error line
#   V* [W]:N message  - virtual warning line
#   V* [H] hint  - virtual hint line

use std.nogc_async_mut.mcp.diag_core.{DiagEntry}
use std.text.{NL}

# ============================================================================
# Types
# ============================================================================

struct OutlineSym:
    kind: text       # "fn", "class", "struct", "enum"
    name: text
    signature: text  # Declaration header (trimmed, colon stripped)
    start_line: i64
    end_line: i64    # Inclusive last line of symbol body

# ============================================================================
# Main Entry Point
# ============================================================================

fn render_outline(source: text, entries: [DiagEntry], mode: text) -> text:
    if source == "":
        return ""

    val lines = source.split(NL)
    val syms = scan_source_symbols(lines)

    if syms.len() == 0:
        return source

    var output = ""

    for sym in syms:
        val marker = sym_marker(sym.kind)
        val is_short = sym.end_line <= sym.start_line

        var sym_text = ""
        if is_short:
            sym_text = marker + " " + sym.signature
        else:
            sym_text = marker + " " + sym.signature + " { ... }"

        if output != "":
            output = output + NL
        output = output + sym_text

        if mode == "outline":
            val diag_text = render_diag_virtual(entries, sym.start_line, sym.end_line)
            if diag_text != "":
                output = output + NL + diag_text

    if mode == "compact":
        val err_count = count_severity(entries, "error")
        val warn_count = count_severity(entries, "warning")
        if err_count > 0 or warn_count > 0:
            output = output + NL + "V* [" + err_count.to_string() + "E " + warn_count.to_string() + "W in file]"

    output

# ============================================================================
# Symbol Scanner
# ============================================================================

fn scan_source_symbols(lines: [text]) -> [OutlineSym]:
    var raw: [OutlineSym] = []
    var line_num = 0

    for line in lines:
        line_num = line_num + 1
        val trimmed = line.trim()

        if trimmed == "":
            continue
        if trimmed.starts_with("#"):
            continue

        val indent = count_indent(line)
        if indent > 0:
            continue

        var kind = ""
        var name = ""
        var sig = ""

        if trimmed.starts_with("fn "):
            kind = "fn"
            val rest = trimmed.substring(3)
            name = extract_sym_name(rest)
            sig = strip_colon(trimmed)
        elif trimmed.starts_with("me "):
            kind = "fn"
            val rest = trimmed.substring(3)
            name = extract_sym_name(rest)
            sig = strip_colon(trimmed)
        elif trimmed.starts_with("static fn "):
            kind = "fn"
            val rest = trimmed.substring(10)
            name = extract_sym_name(rest)
            sig = strip_colon(trimmed)
        elif trimmed.starts_with("async fn "):
            kind = "fn"
            val rest = trimmed.substring(9)
            name = extract_sym_name(rest)
            sig = strip_colon(trimmed)
        elif trimmed.starts_with("class "):
            kind = "class"
            val rest = trimmed.substring(6)
            name = extract_sym_name(rest)
            sig = strip_colon(trimmed)
        elif trimmed.starts_with("struct "):
            kind = "struct"
            val rest = trimmed.substring(7)
            name = extract_sym_name(rest)
            sig = strip_colon(trimmed)
        elif trimmed.starts_with("enum "):
            kind = "enum"
            val rest = trimmed.substring(5)
            name = extract_sym_name(rest)
            sig = strip_colon(trimmed)
        elif trimmed.starts_with("trait "):
            kind = "trait"
            val rest = trimmed.substring(6)
            name = extract_sym_name(rest)
            sig = strip_colon(trimmed)
        elif trimmed.starts_with("impl "):
            kind = "impl"
            val rest = trimmed.substring(5)
            name = extract_sym_name(rest)
            sig = strip_colon(trimmed)
        elif trimmed.starts_with("extern fn "):
            kind = "fn"
            val rest = trimmed.substring(10)
            name = extract_sym_name(rest)
            sig = strip_colon(trimmed)

        if kind != "" and name != "":
            raw.push(OutlineSym(kind: kind, name: name, signature: sig, start_line: line_num, end_line: line_num))

    compute_end_lines(raw, lines)

fn compute_end_lines(raw: [OutlineSym], lines: [text]) -> [OutlineSym]:
    val total = lines.len()
    val raw_count = raw.len()
    var result: [OutlineSym] = []
    var si = 0

    for sym in raw:
        var end_ln = total
        if si + 1 < raw_count:
            val next = raw[si + 1]
            val next_start = next.start_line
            end_ln = next_start - 1
        result.push(OutlineSym(kind: sym.kind, name: sym.name, signature: sym.signature, start_line: sym.start_line, end_line: end_ln))
        si = si + 1

    result

# ============================================================================
# Diagnostic Virtual Lines
# ============================================================================

fn render_diag_virtual(entries: [DiagEntry], start_ln: i64, end_ln: i64) -> text:
    var out = ""
    for entry in entries:
        val in_range = entry.line_num >= start_ln and entry.line_num <= end_ln
        if not in_range:
            continue
        val sev = diag_severity_tag(entry.severity)
        var line = "V* [" + sev + "]:" + entry.line_num.to_string() + "  " + entry.message
        if out != "":
            out = out + NL
        out = out + line
        if entry.easyfix != "":
            out = out + NL + "V* [H]  " + entry.easyfix
    out

fn count_severity(entries: [DiagEntry], sev: text) -> i64:
    var count = 0
    for entry in entries:
        if entry.severity == sev:
            count = count + 1
    count

fn diag_severity_tag(severity: text) -> text:
    if severity == "error":
        return "E"
    if severity == "warning":
        return "W"
    if severity == "hint":
        return "H"
    severity.substring(0, 1).to_upper()

# ============================================================================
# expand_at: Expand single symbol by name or line
# ============================================================================

fn expand_at_source(source: text, selector: text, what: text) -> text:
    if source == "":
        return ""

    val lines = source.split(NL)
    val syms = scan_source_symbols(lines)

    # Find matching symbol
    var found_sym = nil
    for sym in syms:
        val by_name = sym.name == selector
        var by_line = false
        if selector.starts_with("line:"):
            val line_str = selector.substring(5)
            val target_line = int(line_str)
            by_line = target_line >= sym.start_line and target_line <= sym.end_line
        if by_name or by_line:
            found_sym = sym
            break

    if found_sym == nil:
        return "-- Symbol not found: " + selector + " --"

    val sym = found_sym
    val expanded_marker = expanded_sym_marker(sym.kind)

    if what == "signature":
        return expanded_marker + " " + sym.signature

    # Extract body lines
    var body_lines: [text] = []
    var li = 0
    for line in lines:
        li = li + 1
        if li >= sym.start_line and li <= sym.end_line:
            body_lines.push(line)

    var body = ""
    var first = true
    for bl in body_lines:
        if not first:
            body = body + NL
        first = false
        body = body + bl

    if what == "body":
        return body

    expanded_marker + " " + sym.signature + NL + body

# ============================================================================
# Helpers
# ============================================================================

fn sym_marker(kind: text) -> text:
    if kind == "fn":
        return "F>"
    if kind == "class":
        return "C>"
    if kind == "struct":
        return "S>"
    if kind == "enum":
        return "E>"
    if kind == "trait":
        return "T>"
    if kind == "impl":
        return "I>"
    "?>"

fn expanded_sym_marker(kind: text) -> text:
    if kind == "fn":
        return "F_"
    if kind == "class":
        return "C_"
    if kind == "struct":
        return "S_"
    if kind == "enum":
        return "E_"
    if kind == "trait":
        return "T_"
    if kind == "impl":
        return "I_"
    "?_"

fn extract_sym_name(rest: text) -> text:
    var name = ""
    for ch in rest:
        val is_delim = ch == "(" or ch == ":" or ch == " " or ch == "<"
        if is_delim:
            break
        name = name + ch
    name

fn strip_colon(sig: text) -> text:
    val trimmed = sig.trim()
    if trimmed.ends_with(":"):
        return trimmed.substring(0, trimmed.len() - 1)
    trimmed

fn count_indent(line: text) -> i64:
    var count = 0
    for ch in line:
        if ch == " ":
            count = count + 1
        elif ch == "\t":
            count = count + 4
        else:
            break
    count

# ============================================================================
# Exports
# ============================================================================

export render_outline, expand_at_source, scan_source_symbols, OutlineSym
export render_diag_virtual, count_severity
export sym_marker, expanded_sym_marker, diag_severity_tag
