# MCP Resource Manager
#
# Manages resources (read-only contextual data) for the MCP server.
# Resources provide context to LLMs about the codebase, including:
# - File contents
# - Symbol information
# - Type information
# - Documentation
# - Project structure
#
# Supports both static resources and dynamic resource templates.

use app.io.mod (file_read, file_exists, dir_list, is_dir, shell)
use std.nogc_async_mut.mcp.bugdb_resource (get_all_bugs, get_open_bugs, get_critical_bugs, get_bug_stats)
use std.nogc_async_mut.mcp.debug_log_tools.{handle_debuglog_resource}
use std.nogc_async_mut.mcp.featuredb_resource (get_all_features, get_features_by_category, get_features_by_status, get_feature_stats)
use std.nogc_async_mut.mcp.testdb_resource (get_all_runs, get_recent_runs, get_test_stats, get_flaky_tests)
use std.text.{NL}

# --- Resource Types ---

# Resource information returned by resources/list
struct ResourceInfo:
    uri: text                    # Resource URI (e.g., "file:///path/to/file.spl")
    name: text                   # Human-readable name
    description: Option<text>    # Optional description
    mime_type: Option<text>      # MIME type (e.g., "text/plain", "application/json")

# Resource template for dynamic resources
struct ResourceTemplate:
    uri_template: text           # URI pattern (e.g., "symbol:///{symbol_name}")
    name: text
    description: Option<text>
    mime_type: Option<text>

# Resource content returned by resources/read
struct ResourceContent:
    uri: text
    contents: text               # Resource contents (may be large)
    mime_type: Option<text>

# --- Resource Manager ---

class ResourceManager:
    # Project root directory
    project_root: text
    resources_cache: Option<[ResourceInfo]>
    templates_cache: Option<[ResourceTemplate]>
    project_info_cache: Option<text>
    bug_cache: Dict<text, text>
    feature_cache: Dict<text, text>
    test_cache: Dict<text, text>

    # Create a new resource manager
    static fn create(project_root: text) -> ResourceManager:
        ResourceManager(
            project_root: project_root,
            resources_cache: nil,
            templates_cache: nil,
            project_info_cache: nil,
            bug_cache: {},
            feature_cache: {},
            test_cache: {}
        )

    # --- List Resources ---

    # List all available resources
    fn list_resources() -> [ResourceInfo]:
        match self.resources_cache:
            case Some(r): return r
            case nil: ()

        var resources = []

        # Static resource: project info
        resources.push(ResourceInfo(
            uri: "project:///info",
            name: "Project Information",
            description: Some("Project metadata and manifest"),
            mime_type: Some("text/plain")
        ))

        # Dynamic resource templates as examples
        resources.push(ResourceInfo(
            uri: "file:///*",
            name: "File Contents",
            description: Some("Read file contents"),
            mime_type: Some("text/plain")
        ))

        resources.push(ResourceInfo(
            uri: "symbol:///*",
            name: "Symbol Information",
            description: Some("Get symbol details"),
            mime_type: Some("application/json")
        ))

        resources.push(ResourceInfo(
            uri: "type:///*",
            name: "Type Information",
            description: Some("Get type details"),
            mime_type: Some("application/json")
        ))

        resources.push(ResourceInfo(
            uri: "docs:///*",
            name: "Documentation",
            description: Some("Get documentation"),
            mime_type: Some("text/markdown")
        ))

        resources.push(ResourceInfo(
            uri: "tree:///*",
            name: "Directory Tree",
            description: Some("Get directory structure"),
            mime_type: Some("text/plain")
        ))

        resources.push(ResourceInfo(
            uri: "bugdb:///all",
            name: "All Bugs",
            description: Some("Get all bugs from bug database"),
            mime_type: Some("application/json")
        ))

        resources.push(ResourceInfo(
            uri: "bugdb:///open",
            name: "Open Bugs",
            description: Some("Get open bugs from bug database"),
            mime_type: Some("application/json")
        ))

        resources.push(ResourceInfo(
            uri: "bugdb:///critical",
            name: "Critical Bugs",
            description: Some("Get critical bugs (P0/P1) from bug database"),
            mime_type: Some("application/json")
        ))

        resources.push(ResourceInfo(
            uri: "bugdb:///stats",
            name: "Bug Statistics",
            description: Some("Get bug database statistics"),
            mime_type: Some("application/json")
        ))

        # Feature Database resources
        resources.push(ResourceInfo(
            uri: "featuredb:///all",
            name: "All Features",
            description: Some("Get all features from feature database"),
            mime_type: Some("application/json")
        ))

        resources.push(ResourceInfo(
            uri: "featuredb:///stats",
            name: "Feature Statistics",
            description: Some("Get feature database statistics"),
            mime_type: Some("application/json")
        ))

        # Test Database resources
        resources.push(ResourceInfo(
            uri: "testdb:///runs",
            name: "Test Runs",
            description: Some("Get all test runs"),
            mime_type: Some("application/json")
        ))

        resources.push(ResourceInfo(
            uri: "testdb:///stats",
            name: "Test Statistics",
            description: Some("Get test statistics"),
            mime_type: Some("application/json")
        ))

        resources.push(ResourceInfo(
            uri: "testdb:///flaky",
            name: "Flaky Tests",
            description: Some("Get flaky tests"),
            mime_type: Some("application/json")
        ))

        # Debug Log resources
        resources.push(ResourceInfo(
            uri: "debuglog:///tree",
            name: "Debug Log Tree",
            description: Some("Collapsible call tree from AOP debug logger"),
            mime_type: Some("application/json")
        ))

        resources.push(ResourceInfo(
            uri: "debuglog:///entries",
            name: "Debug Log Entries",
            description: Some("All debug log entries as JSON array"),
            mime_type: Some("application/json")
        ))

        resources.push(ResourceInfo(
            uri: "debuglog:///status",
            name: "Debug Log Status",
            description: Some("Current debug logging status"),
            mime_type: Some("application/json")
        ))

        resources.push(ResourceInfo(
            uri: "debuglog:///text",
            name: "Debug Log Text",
            description: Some("Plain text call tree from debug logger"),
            mime_type: Some("text/plain")
        ))

        # API search resource
        resources.push(ResourceInfo(
            uri: "api:///*",
            name: "Module API",
            description: Some("Search module API with visibility-aware filtering (use api:///{path}?from={location}&visibility={filter})"),
            mime_type: Some("text/plain")
        ))

        self.resources_cache = Some(resources)
        resources

    # List resource templates
    fn list_templates() -> [ResourceTemplate]:
        match self.templates_cache:
            case Some(t): return t
            case nil: ()

        var templates = []

        templates.push(ResourceTemplate(
            uri_template: r"file:///{path}",
            name: "File Contents",
            description: Some("Read file contents by path"),
            mime_type: Some("text/plain")
        ))

        templates.push(ResourceTemplate(
            uri_template: r"symbol:///{name}",
            name: "Symbol Information",
            description: Some("Get symbol details by name"),
            mime_type: Some("application/json")
        ))

        templates.push(ResourceTemplate(
            uri_template: r"type:///{name}",
            name: "Type Information",
            description: Some("Get type details by name"),
            mime_type: Some("application/json")
        ))

        templates.push(ResourceTemplate(
            uri_template: r"docs:///{path}",
            name: "Documentation",
            description: Some("Get documentation by path"),
            mime_type: Some("text/markdown")
        ))

        templates.push(ResourceTemplate(
            uri_template: r"tree:///{path}",
            name: "Directory Tree",
            description: Some("Get directory structure"),
            mime_type: Some("text/plain")
        ))

        templates.push(ResourceTemplate(
            uri_template: r"bugdb:///{query}",
            name: "Bug Database",
            description: Some("Query bug database (all, open, critical, stats)"),
            mime_type: Some("application/json")
        ))

        templates.push(ResourceTemplate(
            uri_template: r"debuglog:///{view}",
            name: "Debug Log",
            description: Some("AOP debug log views (tree, entries, status, text)"),
            mime_type: Some("application/json")
        ))

        templates.push(ResourceTemplate(
            uri_template: r"api:///{path}",
            name: "Module API",
            description: Some("Module API with visibility filtering. Optional query params: ?from={location}&visibility={public|friend|package|all}"),
            mime_type: Some("text/plain")
        ))

        self.templates_cache = Some(templates)
        templates

    # --- Read Resources ---

    # Helper: Convert Result<text, text> to Result<ResourceContent, text>
    fn result_to_resource_content(uri: text, result: Result<text, text>, mime_type: Option<text>) -> Result<ResourceContent, text>:
        """Convert a text Result to ResourceContent Result.

        Common pattern in resource providers: check error, wrap success in ResourceContent.
        Eliminates 7-line duplication across all read_resource handlers.
        """
        if not result.is_ok():
            return Err(result.err.unwrap())
        return Ok(ResourceContent(
            uri: uri,
            contents: result.unwrap(),
            mime_type: mime_type
        ))

    # Read a resource by URI
    fn read_resource(uri: text) -> Result<ResourceContent, text>:
        # Static resources
        if uri == "project:///info":
            val result = self.provide_project_info()
            return self.result_to_resource_content(uri, result, Some("text/plain"))

        # Dynamic resources - match by prefix
        if uri.starts_with("file://"):
            val path = uri.substring(7)  # Remove "file://"
            val result = self.provide_file_contents(path)
            return self.result_to_resource_content(uri, result, self.get_mime_type_for_uri(uri))

        if uri.starts_with("symbol://"):
            val symbol_name = uri.substring(9)  # Remove "symbol://"
            val result = self.provide_symbol_info(symbol_name)
            return self.result_to_resource_content(uri, result, Some("application/json"))

        if uri.starts_with("type://"):
            val type_name = uri.substring(7)  # Remove "type://"
            val result = self.provide_type_info(type_name)
            return self.result_to_resource_content(uri, result, Some("application/json"))

        if uri.starts_with("docs://"):
            val path = uri.substring(7)  # Remove "docs://"
            val result = self.provide_documentation(path)
            return self.result_to_resource_content(uri, result, Some("text/markdown"))

        if uri.starts_with("tree://"):
            val path = uri.substring(7)  # Remove "tree://"
            val result = self.provide_directory_tree(path)
            return self.result_to_resource_content(uri, result, Some("text/plain"))

        if uri.starts_with("bugdb://"):
            val query = uri.substring(8)  # Remove "bugdb://"
            val result = self.provide_bugdb_query(query)
            return self.result_to_resource_content(uri, result, Some("application/json"))

        if uri.starts_with("debuglog://"):
            val query = uri.substring(11)  # Remove "debuglog://"
            val content = handle_debuglog_resource(query)
            var mime = Some("application/json")
            if query == "/text" or query == "text":
                mime = Some("text/plain")
            return Ok(ResourceContent(uri: uri, contents: content, mime_type: mime))

        if uri.starts_with("featuredb://"):
            val query = uri.substring(12)  # Remove "featuredb://"
            val result = self.provide_featuredb_query(query)
            return self.result_to_resource_content(uri, result, Some("application/json"))

        if uri.starts_with("testdb://"):
            val query = uri.substring(9)  # Remove "testdb://"
            val result = self.provide_testdb_query(query)
            return self.result_to_resource_content(uri, result, Some("application/json"))

        if uri.starts_with("api://"):
            val path = uri.substring(6)  # Remove "api://"
            # Strip leading slashes
            var clean_path = path
            if clean_path.starts_with("/"):
                clean_path = clean_path.substring(1)
            val result = self.provide_api_info(clean_path)
            return self.result_to_resource_content(uri, result, Some("text/plain"))

        Err("Resource not found: " + uri)

    # Get MIME type for URI
    fn get_mime_type_for_uri(uri: text) -> Option<text>:
        if uri.starts_with("file://"):
            if uri.ends_with(".spl") or uri.ends_with(".ssh"):
                return Some("text/x-simple")
            if uri.ends_with(".json"):
                return Some("application/json")
            if uri.ends_with(".md"):
                return Some("text/markdown")
            return Some("text/plain")

        if uri.starts_with("symbol://") or uri.starts_with("type://"):
            return Some("application/json")

        if uri.starts_with("docs://"):
            return Some("text/markdown")

        if uri.starts_with("tree://"):
            return Some("text/plain")

        nil

    # --- Resource Providers ---

    # Provide file contents
    fn provide_file_contents(path: text) -> Result<text, text>:
        val full_path = if path.starts_with("/"):
            path
        else:
            self.project_root + "/" + path

        if not file_exists(full_path):
            return Err("File not found: " + path)

        val contents = file_read(full_path)
        Ok(contents)

    # Provide symbol information via grep-based search
    fn provide_symbol_info(symbol_name: text) -> Result<text, text>:
        # Strip leading slashes from URI path
        var name = symbol_name
        if name.starts_with("/"):
            name = name.substring(1)
        if name == "":
            return Err("Symbol name is required")

        # Search for function definitions matching the name
        val fn_result = shell("grep -rn 'fn " + name + "(' --include='*.spl' " + self.project_root + "/src/ 2>/dev/null | head -20")
        val fn_output = fn_result.stdout ?? ""

        # Search for method definitions
        val me_result = shell("grep -rn 'me " + name + "(' --include='*.spl' " + self.project_root + "/src/ 2>/dev/null | head -20")
        val me_output = me_result.stdout ?? ""

        var info = "Symbol: " + name + "{NL}{NL}"

        if fn_output.trim() != "":
            info = info + "Function definitions:{NL}" + fn_output + NL
        if me_output.trim() != "":
            info = info + "Method definitions:{NL}" + me_output + NL
        if fn_output.trim() == "" and me_output.trim() == "":
            info = info + "No definitions found for: " + name + NL

        Ok(info)

    # Provide type information via grep-based search
    fn provide_type_info(type_name: text) -> Result<text, text>:
        # Strip leading slashes from URI path
        var name = type_name
        if name.starts_with("/"):
            name = name.substring(1)
        if name == "":
            return Err("Type name is required")

        # Search for class definitions
        val class_result = shell("grep -rn 'class " + name + "' --include='*.spl' " + self.project_root + "/src/ 2>/dev/null | head -20")
        val class_output = class_result.stdout ?? ""

        # Search for struct definitions
        val struct_result = shell("grep -rn 'struct " + name + "' --include='*.spl' " + self.project_root + "/src/ 2>/dev/null | head -20")
        val struct_output = struct_result.stdout ?? ""

        # Search for enum definitions
        val enum_result = shell("grep -rn 'enum " + name + "' --include='*.spl' " + self.project_root + "/src/ 2>/dev/null | head -20")
        val enum_output = enum_result.stdout ?? ""

        var info = "Type: " + name + "{NL}{NL}"

        if class_output.trim() != "":
            info = info + "Class definitions:{NL}" + class_output + NL
        if struct_output.trim() != "":
            info = info + "Struct definitions:{NL}" + struct_output + NL
        if enum_output.trim() != "":
            info = info + "Enum definitions:{NL}" + enum_output + NL
        if class_output.trim() == "" and struct_output.trim() == "" and enum_output.trim() == "":
            info = info + "No type definitions found for: " + name + NL

        Ok(info)

    # Provide documentation
    fn provide_documentation(path: text) -> Result<text, text>:
        # Look for .md files in doc/
        val doc_path = self.project_root + "/doc/" + path

        if not path.ends_with(".md"):
            val md_path = doc_path + ".md"
            if file_exists(md_path):
                return Ok(file_read(md_path))

        if file_exists(doc_path):
            return Ok(file_read(doc_path))

        Err("Documentation not found: " + path)

    # Provide directory tree
    fn provide_directory_tree(path: text) -> Result<text, text>:
        val full_path = if path.starts_with("/"):
            path
        else:
            self.project_root + "/" + path

        if not dir_exists(full_path):
            return Err("Directory not found: " + path)

        val tree = self.build_tree(full_path, 0, 3)
        Ok(tree)

    # Build directory tree recursively
    fn build_tree(path: text, indent: i64, max_depth: i64) -> text:
        if max_depth <= 0:
            return ""

        var result = ""
        val entries = dir_list(path)

        for entry in entries:
            # Skip hidden files and common build directories
            if entry.starts_with(".") or entry == "node_modules" or entry == "target":
                continue

            val full_entry = path + "/" + entry
            val prefix = repeat_string("  ", indent)

            if dir_exists(full_entry):
                result = result + prefix + entry + "/{NL}"
                result = result + self.build_tree(full_entry, indent + 1, max_depth - 1)
            else:
                result = result + prefix + entry + NL

        result

    # Provide project information
    fn provide_project_info() -> Result<text, text>:
        match self.project_info_cache:
            case Some(info): return Ok(info)
            case nil: ()

        # Read simple.sdn or simple.toml
        val sdn_path = self.project_root + "/simple.sdn"
        val toml_path = self.project_root + "/simple.toml"

        var project_info = "Project Root: " + self.project_root + "{NL}{NL}"

        if file_exists(sdn_path):
            project_info = project_info + "Manifest: simple.sdn{NL}"
            project_info = project_info + file_read(sdn_path)
            self.project_info_cache = Some(project_info)
            return Ok(project_info)

        if file_exists(toml_path):
            project_info = project_info + "Manifest: simple.toml{NL}"
            project_info = project_info + file_read(toml_path)
            self.project_info_cache = Some(project_info)
            return Ok(project_info)

        project_info = project_info + "No manifest found"
        self.project_info_cache = Some(project_info)
        Ok(project_info)

    # Provide bug database query results
    fn provide_bugdb_query(query: text) -> Result<text, text>:
        val db_path = self.project_root + "/doc/bug/bug_db.sdn"

        # Database library has runtime compat issues with ? operator
        # Read file directly and return raw content
        val valid_queries = query == "/all" or query == "all" or query == "/open" or query == "open"
        val valid_queries2 = query == "/critical" or query == "critical" or query == "/stats" or query == "stats"
        if not valid_queries and not valid_queries2:
            return Err("Unknown bug database query: " + query + ". Valid queries: all, open, critical, stats")

        match self.bug_cache.get(query):
            case Some(cached): return Ok(cached)
            case nil: ()

        val content = file_read(db_path)
        if content == "":
            return Err("Bug database file not found: " + db_path)
        self.bug_cache[query] = content
        return Ok(content)

    # Provide feature database query results
    fn provide_featuredb_query(query: text) -> Result<text, text>:
        val db_path = self.project_root + "/doc/feature/feature_db.sdn"

        match self.feature_cache.get(query):
            case Some(cached): return Ok(cached)
            case nil: ()

        if query == "/all" or query == "all":
            val r = get_all_features(db_path)
            self.feature_cache[query] = r
            return Ok(r)
        elif query == "/stats" or query == "stats":
            val r = get_feature_stats(db_path)
            self.feature_cache[query] = r
            return Ok(r)
        elif query.starts_with("/category/"):
            val category = query.substring(10)
            val r = get_features_by_category(db_path, category)
            self.feature_cache[query] = r
            return Ok(r)
        elif query.starts_with("/status/"):
            val status = query.substring(8)
            val r = get_features_by_status(db_path, status)
            self.feature_cache[query] = r
            return Ok(r)
        else:
            return Err("Unknown feature database query: " + query + ". Valid queries: all, stats, category/<name>, status/<name>")

    # Provide test database query results
    fn provide_testdb_query(query: text) -> Result<text, text>:
        val db_path = self.project_root + "/doc/test/test_db.sdn"

        match self.test_cache.get(query):
            case Some(cached): return Ok(cached)
            case nil: ()

        if query == "/runs" or query == "runs":
            val r = get_all_runs(db_path)
            self.test_cache[query] = r
            return Ok(r)
        elif query == "/recent" or query == "recent":
            val r = get_recent_runs(db_path, 10)
            self.test_cache[query] = r
            return Ok(r)
        elif query == "/stats" or query == "stats":
            val r = get_test_stats(db_path)
            self.test_cache[query] = r
            return Ok(r)
        elif query == "/flaky" or query == "flaky":
            val r = get_flaky_tests(db_path)
            self.test_cache[query] = r
            return Ok(r)
        else:
            return Err("Unknown test database query: " + query + ". Valid queries: runs, recent, stats, flaky")

    # Provide API info for a module path
    fn provide_api_info(path: text) -> Result<text, text>:
        """Return API symbols for a module path.

        Parses the target file using line-by-line heuristic and returns
        formatted symbol list with visibility markers.
        """
        # Parse query parameters if present
        var module_path = path
        var from_module = ""
        var vis_filter = "all"

        val q_idx = path.index_of("?")
        if q_idx.?:
            module_path = path.substring(0, q_idx ?? 0)
            val query_str = path.substring((q_idx ?? 0) + 1)
            # Simple query param parsing
            val params = query_str.split("&")
            for param in params:
                if param.starts_with("from="):
                    from_module = param.substring(5)
                elif param.starts_with("visibility="):
                    vis_filter = param.substring(11)

        # Resolve module path to file
        val file_path = self.resolve_module_to_file(module_path)
        if file_path == "":
            return Err("Cannot resolve module: " + module_path)

        val source = file_read(file_path)
        if source == "":
            return Err("Cannot read file: " + file_path)

        # Extract symbols using simple heuristic
        var output = "# API: {module_path}\n"
        output = output + "# File: {file_path}\n"
        output = output + "# Filter: visibility={vis_filter}\n"
        output = output + "#\n"

        val lines = source.split("\n")
        for line in lines:
            val trimmed = line.trim()
            if trimmed.starts_with("pub fn ") or trimmed.starts_with("pub me "):
                output = output + "P  F> " + trimmed.substring(4) + "\n"
            elif trimmed.starts_with("pub(friend) fn ") or trimmed.starts_with("pub(friend) me "):
                if vis_filter != "public":
                    output = output + "F  F> " + trimmed.substring(12) + "\n"
            elif trimmed.starts_with("pub(package) fn ") or trimmed.starts_with("pub(package) me "):
                if vis_filter == "all" or vis_filter == "package":
                    output = output + "I  F> " + trimmed.substring(13) + "\n"
            elif trimmed.starts_with("pub struct "):
                output = output + "P  S> " + trimmed.substring(4) + "\n"
            elif trimmed.starts_with("pub class "):
                output = output + "P  C> " + trimmed.substring(4) + "\n"
            elif trimmed.starts_with("pub enum "):
                output = output + "P  E> " + trimmed.substring(4) + "\n"
            elif trimmed.starts_with("pub trait "):
                output = output + "P  T> " + trimmed.substring(4) + "\n"

        Ok(output)

    fn resolve_module_to_file(module_path: text) -> text:
        """Resolve a dotted module path to a file path."""
        # If it already looks like a file path
        if module_path.contains("/") or module_path.ends_with(".spl"):
            val full = self.project_root + "/" + module_path
            if file_exists(full):
                return full
            if file_exists(module_path):
                return module_path
            return ""

        # Dotted path
        val parts = module_path.split(".")
        val rel = parts.join("/")
        val spl_path = self.project_root + "/src/" + rel + ".spl"
        if file_exists(spl_path):
            return spl_path
        val init_path = self.project_root + "/src/" + rel + "/__init__.spl"
        if file_exists(init_path):
            return init_path
        ""

# --- Helper Functions ---

# Check if directory exists
fn dir_exists(path: text) -> bool:
    # Use is_dir from io module which uses test -d
    is_dir(path)

# String repetition (for indentation)
fn repeat_string(s: text, count: i64) -> text:
    var result = ""
    for i in 0..count:
        result = result + s
    result
