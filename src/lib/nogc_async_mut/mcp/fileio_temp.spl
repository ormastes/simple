# Temporary File Manager
# Manages session-based temporary directories for file I/O redirection

use app.io.mod.{shell_output}
use std.path.{basename}

val NL = "\n"

export TempManager, TempSession, create_temp_manager

# Bound in-memory temp file tracking to avoid unbounded growth in long-lived MCP sessions.
val MAX_TRACKED_SESSION_FILES = 1024

# Temporary session
struct TempSession:
    session_id: text
    base_dir: text
    created_at: i64
    files: [text]

# Temporary file manager
class TempManager:
    base_dir: text
    session_prefix: text
    cleanup_on_exit: bool
    max_age_hours: i64
    current_session: TempSession?

    # Create a new temp session
    me create_session() -> TempSession:
        val timestamp = self.get_timestamp()
        val session_id = self.session_prefix + timestamp.to_string()
        val session_dir = self.base_dir + "/" + session_id

        # Create session directory
        self.ensure_dir(session_dir)

        val session = TempSession(
            session_id: session_id,
            base_dir: session_dir,
            created_at: timestamp,
            files: []
        )

        self.current_session = Some(session)
        session

    # Get current session or create new one
    me get_session() -> TempSession:
        if self.current_session.?:
            self.current_session.unwrap()
        else:
            self.create_session()

    # Get temp directory for current session
    fn get_temp_dir() -> text:
        val session = self.get_session()
        session.base_dir

    # Get temp path for a file
    me get_temp_path(original_path: text) -> text:
        val session = self.get_session()
        val filename = basename(original_path)
        val temp_path = session.base_dir + "/" + filename

        # Track file in session
        if not session.files.contains(temp_path):
            session.files.push(temp_path)
            # Keep only the most recent entries to prevent memory growth.
            if session.files.len() > MAX_TRACKED_SESSION_FILES:
                var trimmed: [text] = []
                var i = 1
                while i < session.files.len():
                    trimmed.push(session.files[i])
                    i = i + 1
                session.files = trimmed

        temp_path

    # List all temp files in current session
    fn list_temp_files() -> [text]:
        if not self.current_session.?:
            return []

        val session = self.current_session.unwrap()
        session.files

    # Cleanup current session
    me cleanup_session():
        if not self.current_session.?:
            return

        val session = self.current_session.unwrap()

        # Remove session directory
        self.remove_dir(session.base_dir)

        self.current_session = nil

    # Cleanup old sessions based on max age
    me cleanup_old_sessions():
        val now = self.get_timestamp()
        val max_age_seconds = self.max_age_hours * 3600

        # List all session directories
        val sessions = self.list_sessions()

        for session_dir in sessions:
            # Get session creation time from directory name
            val parts = session_dir.split("_")
            if parts.len() < 2:
                continue

            val timestamp_str = parts[parts.len() - 1]
            val timestamp = parse_i64_safe(timestamp_str)

            if timestamp == 0:
                continue
            val age_seconds = now - timestamp

            # Remove old session
            if age_seconds > max_age_seconds:
                self.remove_dir(self.base_dir + "/" + session_dir)

    # List all session directories
    fn list_sessions() -> [text]:
        if not self.dir_exists(self.base_dir):
            return []

        val output = shell_output("ls -1 '{self.base_dir}' 2>/dev/null || echo ''", "")
        if output.len() == 0:
            return []

        output.split(NL).filter(\line: line.trim().len() > 0)

    # Ensure directory exists
    me ensure_dir(path: text):
        shell_output("mkdir -p '{path}'", "")

    # Check if directory exists
    fn dir_exists(path: text) -> bool:
        val result = shell_output("test -d '{path}' && echo yes || echo no", "no")
        result == "yes"

    # Remove directory recursively
    me remove_dir(path: text):
        shell_output("rm -rf '{path}'", "")

    # Get current timestamp (seconds since epoch)
    fn get_timestamp() -> i64:
        val output = shell_output("date +%s", "0")
        parse_i64_safe(output.trim())

# Create temp manager from config
fn create_temp_manager(base_dir: text, session_prefix: text, cleanup_on_exit: bool, max_age_hours: i64) -> TempManager:
    val manager = TempManager(
        base_dir: base_dir,
        session_prefix: session_prefix,
        cleanup_on_exit: cleanup_on_exit,
        max_age_hours: max_age_hours,
        current_session: nil
    )

    # Ensure base directory exists
    manager.ensure_dir(base_dir)

    # Cleanup old sessions
    manager.cleanup_old_sessions()

    manager

fn shell(cmd: text) -> text:
    shell_output(cmd, "")

fn parse_i64_safe(s: text) -> i64:
    val trimmed = s.trim()
    if trimmed == "":
        return 0
    to_int(trimmed)
