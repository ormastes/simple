# MCP Debug Log Tools - 6 MCP tools for AOP debug logging
#
# Tools:
#   debug_log_enable   - Start logging with optional filter pattern
#   debug_log_disable  - Stop logging
#   debug_log_clear    - Clear log buffer
#   debug_log_query    - Query entries with filters
#   debug_log_tree     - Collapsible call tree (JSON or text)
#   debug_log_status   - Current logging status

use std.aop_debug_log.{DebugLogEntry, debug_log_enable, debug_log_disable, debug_log_clear, debug_log_get_entries, debug_log_get_entries_since, debug_log_get_status, debug_log_is_enabled}
use std.nogc_async_mut.mcp.log_store.{log_entry_to_json, log_entries_to_json, log_tree_to_json, format_log_tree_text, log_status_to_json}
use std.nogc_async_mut.mcp.helpers.{LB, RB, Q, jp, js, jo1, jo2, jo3, parse_int, extract_arg, extract_nested_string, make_tool_result, make_error_response, make_tool_schema_multi}
use std.nogc_async_mut.mcp.helpers.{escape_json}

export handle_debug_log_enable, handle_debug_log_disable, handle_debug_log_clear
export handle_debug_log_query, handle_debug_log_tree, handle_debug_log_status
export schema_debug_log_enable, schema_debug_log_disable, schema_debug_log_clear
export schema_debug_log_query, schema_debug_log_tree, schema_debug_log_status
export handle_debuglog_resource

# ============================================================================
# Tool Schemas
# ============================================================================

fn schema_debug_log_enable() -> text:
    val pat_prop = jo2(jp("type", js("string")), jp("description", js("Glob pattern to filter functions (default: * for all)")))
    val props = jo1(jp("pattern", pat_prop))
    val schema = jo3(jp("type", js("object")), jp("properties", props), jp("required", "[]"))
    var annot = LB()
    annot = annot + jp("readOnlyHint", "false")
    annot = annot + "," + jp("destructiveHint", "false")
    annot = annot + "," + jp("idempotentHint", "true")
    annot = annot + "," + jp("openWorldHint", "false")
    annot = annot + RB()
    var r = LB()
    r = r + jp("name", js("debug_log_enable"))
    r = r + "," + jp("description", js("Enable AOP debug logging with optional filter pattern"))
    r = r + "," + jp("inputSchema", schema)
    r = r + "," + jp("annotations", annot)
    r = r + RB()
    r

fn schema_debug_log_disable() -> text:
    val schema = jo3(jp("type", js("object")), jp("properties", LB() + RB()), jp("required", "[]"))
    var annot = LB()
    annot = annot + jp("readOnlyHint", "false")
    annot = annot + "," + jp("destructiveHint", "false")
    annot = annot + "," + jp("idempotentHint", "true")
    annot = annot + "," + jp("openWorldHint", "false")
    annot = annot + RB()
    var r = LB()
    r = r + jp("name", js("debug_log_disable"))
    r = r + "," + jp("description", js("Disable AOP debug logging"))
    r = r + "," + jp("inputSchema", schema)
    r = r + "," + jp("annotations", annot)
    r = r + RB()
    r

fn schema_debug_log_clear() -> text:
    val schema = jo3(jp("type", js("object")), jp("properties", LB() + RB()), jp("required", "[]"))
    var annot = LB()
    annot = annot + jp("readOnlyHint", "false")
    annot = annot + "," + jp("destructiveHint", "true")
    annot = annot + "," + jp("idempotentHint", "true")
    annot = annot + "," + jp("openWorldHint", "false")
    annot = annot + RB()
    var r = LB()
    r = r + jp("name", js("debug_log_clear"))
    r = r + "," + jp("description", js("Clear all debug log entries"))
    r = r + "," + jp("inputSchema", schema)
    r = r + "," + jp("annotations", annot)
    r = r + RB()
    r

fn schema_debug_log_query() -> text:
    val since_prop = jo2(jp("type", js("integer")), jp("description", js("Return entries with ID greater than this")))
    val type_prop = jo2(jp("type", js("string")), jp("description", js("Filter by entry_type: enter or exit")))
    val max_prop = jo2(jp("type", js("integer")), jp("description", js("Maximum number of results (default: 100)")))
    val func_prop = jo2(jp("type", js("string")), jp("description", js("Filter by function name pattern (glob)")))
    var props = LB()
    props = props + jp("since_id", since_prop)
    props = props + "," + jp("entry_type", type_prop)
    props = props + "," + jp("max_results", max_prop)
    props = props + "," + jp("function_pattern", func_prop)
    props = props + RB()
    val schema = jo3(jp("type", js("object")), jp("properties", props), jp("required", "[]"))
    var annot = LB()
    annot = annot + jp("readOnlyHint", "true")
    annot = annot + "," + jp("destructiveHint", "false")
    annot = annot + "," + jp("idempotentHint", "true")
    annot = annot + "," + jp("openWorldHint", "false")
    annot = annot + RB()
    var r = LB()
    r = r + jp("name", js("debug_log_query"))
    r = r + "," + jp("description", js("Query debug log entries with optional filters"))
    r = r + "," + jp("inputSchema", schema)
    r = r + "," + jp("annotations", annot)
    r = r + RB()
    r

fn schema_debug_log_tree() -> text:
    val fmt_prop = jo2(jp("type", js("string")), jp("description", js("Output format: json or text (default: text)")))
    val depth_prop = jo2(jp("type", js("integer")), jp("description", js("Maximum tree depth to show")))
    val since_prop = jo2(jp("type", js("integer")), jp("description", js("Show entries since this ID")))
    val expand_prop = jo2(jp("type", js("string")), jp("description", js("Comma-separated group IDs to expand (show params)")))
    var props = LB()
    props = props + jp("format", fmt_prop)
    props = props + "," + jp("max_depth", depth_prop)
    props = props + "," + jp("since_id", since_prop)
    props = props + "," + jp("expanded_groups", expand_prop)
    props = props + RB()
    val schema = jo3(jp("type", js("object")), jp("properties", props), jp("required", "[]"))
    var annot = LB()
    annot = annot + jp("readOnlyHint", "true")
    annot = annot + "," + jp("destructiveHint", "false")
    annot = annot + "," + jp("idempotentHint", "true")
    annot = annot + "," + jp("openWorldHint", "false")
    annot = annot + RB()
    var r = LB()
    r = r + jp("name", js("debug_log_tree"))
    r = r + "," + jp("description", js("Get collapsible call tree from debug log"))
    r = r + "," + jp("inputSchema", schema)
    r = r + "," + jp("annotations", annot)
    r = r + RB()
    r

fn schema_debug_log_status() -> text:
    val schema = jo3(jp("type", js("object")), jp("properties", LB() + RB()), jp("required", "[]"))
    var annot = LB()
    annot = annot + jp("readOnlyHint", "true")
    annot = annot + "," + jp("destructiveHint", "false")
    annot = annot + "," + jp("idempotentHint", "true")
    annot = annot + "," + jp("openWorldHint", "false")
    annot = annot + RB()
    var r = LB()
    r = r + jp("name", js("debug_log_status"))
    r = r + "," + jp("description", js("Get current debug logging status"))
    r = r + "," + jp("inputSchema", schema)
    r = r + "," + jp("annotations", annot)
    r = r + RB()
    r

# ============================================================================
# Tool Handlers
# ============================================================================

fn handle_debug_log_enable(id: text, body: text) -> text:
    val pattern = extract_nested_string(body, "arguments", "pattern")
    debug_log_enable(pattern)
    val (en, pat, cnt, dep) = debug_log_get_status()
    var r = LB()
    r = r + jp("status", js("enabled"))
    r = r + "," + jp("filter_pattern", js(escape_json(pat)))
    r = r + RB()
    make_tool_result(id, r)

fn handle_debug_log_disable(id: text) -> text:
    debug_log_disable()
    var r = LB()
    r = r + jp("status", js("disabled"))
    r = r + RB()
    make_tool_result(id, r)

fn handle_debug_log_clear(id: text) -> text:
    debug_log_clear()
    var r = LB()
    r = r + jp("status", js("cleared"))
    r = r + "," + jp("entry_count", "0")
    r = r + RB()
    make_tool_result(id, r)

fn handle_debug_log_query(id: text, body: text) -> text:
    val since_str = extract_nested_string(body, "arguments", "since_id")
    val entry_type_filter = extract_nested_string(body, "arguments", "entry_type")
    val max_str = extract_nested_string(body, "arguments", "max_results")
    val func_pattern = extract_nested_string(body, "arguments", "function_pattern")

    var since_id = 0
    if since_str != "":
        val pr = parse_int(since_str)
        match pr:
            Ok(v): since_id = v
            Err(_): pass

    var max_results = 100
    if max_str != "":
        val pr = parse_int(max_str)
        match pr:
            Ok(v): max_results = v
            Err(_): pass

    # Get entries
    var entries = debug_log_get_entries()
    if since_id > 0:
        entries = debug_log_get_entries_since(since_id)

    # Apply entry_type filter
    if entry_type_filter != "":
        var filtered: [DebugLogEntry] = []
        for e in entries:
            if e.entry_type == entry_type_filter:
                filtered = filtered + [e]
        entries = filtered

    # Apply function_pattern filter
    if func_pattern != "":
        var filtered: [DebugLogEntry] = []
        for e in entries:
            if _simple_glob(func_pattern, e.function_name):
                filtered = filtered + [e]
        entries = filtered

    # Apply max_results limit
    if entries.len() > max_results:
        var limited: [DebugLogEntry] = []
        for i in range(0, max_results):
            limited = limited + [entries[i]]
        entries = limited

    val json = log_entries_to_json(entries)
    var r = LB()
    r = r + jp("count", entries.len().to_string())
    r = r + "," + jp("entries", json)
    r = r + RB()
    make_tool_result(id, r)

fn handle_debug_log_tree(id: text, body: text) -> text:
    val fmt = extract_nested_string(body, "arguments", "format")
    val depth_str = extract_nested_string(body, "arguments", "max_depth")
    val since_str = extract_nested_string(body, "arguments", "since_id")
    val expand_str = extract_nested_string(body, "arguments", "expanded_groups")

    var since_id = 0
    if since_str != "":
        val pr = parse_int(since_str)
        match pr:
            Ok(v): since_id = v
            Err(_): pass

    var max_depth = 999
    if depth_str != "":
        val pr = parse_int(depth_str)
        match pr:
            Ok(v): max_depth = v
            Err(_): pass

    # Parse expanded_groups (comma-separated IDs)
    var expanded: [i64] = []
    if expand_str != "":
        val parts = expand_str.split(",")
        for part in parts:
            val trimmed = part.trim()
            if trimmed != "":
                val pr = parse_int(trimmed)
                match pr:
                    Ok(v): expanded = expanded + [v]
                    Err(_): pass

    # Get entries
    var entries = debug_log_get_entries()
    if since_id > 0:
        entries = debug_log_get_entries_since(since_id)

    # Apply max_depth filter
    if max_depth < 999:
        var filtered: [DebugLogEntry] = []
        for e in entries:
            if e.depth <= max_depth:
                filtered = filtered + [e]
        entries = filtered

    var output_format = "text"
    if fmt == "json":
        output_format = "json"

    if output_format == "json":
        val tree_json = log_tree_to_json(entries)
        var r = LB()
        r = r + jp("format", js("json"))
        # Keep JSON tree as escaped text for compatibility with strict MCP serializers.
        r = r + "," + jp("tree", js(escape_json(tree_json)))
        r = r + RB()
        return make_tool_result(id, r)
    else:
        val tree_text = format_log_tree_text(entries, expanded)
        var r = LB()
        r = r + jp("format", js("text"))
        r = r + "," + jp("tree", js(escape_json(tree_text)))
        r = r + RB()
        return make_tool_result(id, r)

fn handle_debug_log_status(id: text) -> text:
    val (en, pat, cnt, dep) = debug_log_get_status()
    val status_json = log_status_to_json(en, pat, cnt, dep)
    make_tool_result(id, status_json)

# ============================================================================
# Debug Log Resource Handler
# ============================================================================

fn handle_debuglog_resource(query: text) -> text:
    # Handle debuglog:// resource URIs
    # /tree  - collapsible tree (text)
    # /entries - all entries (JSON)
    # /status - current status (JSON)
    # /text - plain text tree
    if query == "/tree" or query == "tree":
        val entries = debug_log_get_entries()
        return log_tree_to_json(entries)
    elif query == "/entries" or query == "entries":
        val entries = debug_log_get_entries()
        return log_entries_to_json(entries)
    elif query == "/status" or query == "status":
        val (en, pat, cnt, dep) = debug_log_get_status()
        return log_status_to_json(en, pat, cnt, dep)
    elif query == "/text" or query == "text":
        val entries = debug_log_get_entries()
        var expanded: [i64] = []
        return format_log_tree_text(entries, expanded)
    else:
        return "Unknown debuglog query: " + query + ". Valid: tree, entries, status, text"

# ============================================================================
# Internal Helpers
# ============================================================================

fn _simple_glob(pattern: text, name: text) -> bool:
    if pattern == "*":
        return true
    if pattern.ends_with("*"):
        val prefix = pattern[0:pattern.len() - 1]
        return name.starts_with(prefix)
    if pattern.starts_with("*"):
        val suffix = pattern[1:]
        return name.ends_with(suffix)
    pattern == name
