# MCP Tasks - Task lifecycle management
#
# Implements the MCP tasks capability for tracking long-running operations.
# For stdio transport, tasks run synchronously but clients can still use
# the task polling API pattern.

use std.nogc_async_mut.mcp.helpers.{LB, RB, jp, js, jo1, jo2, jo3, escape_json}

# Task state
enum TaskState:
    Pending
    Running
    Completed
    Failed
    Cancelled

# Convert TaskState to string
fn task_state_to_string(state: TaskState) -> String:
    match state:
        TaskState.Pending: "pending"
        TaskState.Running: "running"
        TaskState.Completed: "completed"
        TaskState.Failed: "failed"
        TaskState.Cancelled: "cancelled"

# Task information
class TaskInfo:
    id: String
    method: String
    params_json: String
    state: TaskState
    progress: Int
    total: Int
    result_json: String
    error_msg: String

    static fn create(id: String, method: String, params_json: String) -> TaskInfo:
        TaskInfo(
            id: id,
            method: method,
            params_json: params_json,
            state: TaskState.Pending,
            progress: 0,
            total: 100,
            result_json: "",
            error_msg: ""
        )

    fn to_json() -> String:
        var r = LB()
        r = r + jp("id", js(escape_json(self.id)))
        r = r + "," + jp("method", js(escape_json(self.method)))
        r = r + "," + jp("state", js(task_state_to_string(self.state)))
        r = r + "," + jp("progress", self.progress.to_string())
        r = r + "," + jp("total", self.total.to_string())
        if self.result_json != "":
            r = r + "," + jp("result", self.result_json)
        if self.error_msg != "":
            r = r + "," + jp("error", js(escape_json(self.error_msg)))
        r = r + RB()
        r

# Task Manager
class TaskManager:
    tasks: Dict<String, TaskInfo>
    next_id: Int

    static fn create() -> TaskManager:
        TaskManager(
            tasks: {},
            next_id: 1
        )

impl TaskManager:
    # Create and enqueue a task (runs synchronously in stdio mode)
    me enqueue(method: String, params_json: String) -> String:
        val id = "task-" + self.next_id.to_string()
        self.next_id = self.next_id + 1
        val task = TaskInfo.create(id, method, params_json)
        self.tasks[id] = task
        id

    # List all tasks
    fn list_tasks() -> [TaskInfo]:
        var result: [TaskInfo] = []
        for (_, task) in self.tasks.items():
            result.push(task)
        result

    # Get a task by ID
    fn get_task(id: String) -> Option<TaskInfo>:
        self.tasks.get(id)

    # Cancel a task
    me cancel_task(id: String) -> Bool:
        match self.tasks.get(id):
            Some(task):
                task.state = TaskState.Cancelled
                true
            nil:
                false

    # Mark a task as running
    me start_task(id: String):
        match self.tasks.get(id):
            Some(task):
                task.state = TaskState.Running
            nil:
                pass

    # Complete a task with result
    me complete_task(id: String, result_json: String):
        match self.tasks.get(id):
            Some(task):
                task.state = TaskState.Completed
                task.result_json = result_json
                task.progress = task.total
            nil:
                pass

    # Fail a task with error
    me fail_task(id: String, error_msg: String):
        match self.tasks.get(id):
            Some(task):
                task.state = TaskState.Failed
                task.error_msg = error_msg
            nil:
                pass

    # Update task progress
    me update_progress(id: String, progress: Int, total: Int):
        match self.tasks.get(id):
            Some(task):
                task.progress = progress
                task.total = total
            nil:
                pass

    # Build JSON for task list
    fn list_tasks_json() -> String:
        var arr = "["
        var first = true
        for (_, task) in self.tasks.items():
            if not first:
                arr = arr + ","
            first = false
            arr = arr + task.to_json()
        arr + "]"

export TaskState, TaskInfo, TaskManager, task_state_to_string
