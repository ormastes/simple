# MCP Debug Log Store - JSON serialization and tree rendering
#
# Converts DebugLogEntry arrays into JSON and collapsible tree text.
# Used by debug_log_tools.spl for MCP tool responses.

use std.aop_debug_log.{DebugLogEntry}
use std.nogc_async_mut.mcp.helpers.{LB, RB, Q, jp, js, jo1, jo2, escape_json}
use std.text.{NL}
use std.string_builder.{StringBuilder}

export log_entry_to_json, log_entries_to_json
export log_tree_to_json, format_log_tree_text
export log_status_to_json

# ============================================================================
# Single Entry JSON
# ============================================================================

fn log_entry_to_json(entry: DebugLogEntry) -> text:
    val sb = StringBuilder(parts: [])
    sb.push(LB())
    sb.push(jp("entry_id", entry.entry_id.to_string()))
    sb.push(",")
    sb.push(jp("group_id", entry.group_id.to_string()))
    sb.push(",")
    sb.push(jp("parent_group_id", entry.parent_group_id.to_string()))
    sb.push(",")
    sb.push(jp("depth", entry.depth.to_string()))
    sb.push(",")
    sb.push(jp("entry_type", js(entry.entry_type)))
    sb.push(",")
    sb.push(jp("package_path", js(escape_json(entry.package_path))))
    sb.push(",")
    sb.push(jp("class_name", js(escape_json(entry.class_name))))
    sb.push(",")
    sb.push(jp("function_name", js(escape_json(entry.function_name))))
    sb.push(",")
    sb.push(jp("line_number", entry.line_number.to_string()))
    sb.push(",")
    sb.push(jp("timestamp_ms", entry.timestamp_ms.to_string()))
    sb.push(",")
    sb.push(jp("duration_ms", entry.duration_ms.to_string()))
    sb.push(",")
    sb.push(jp("params_text", js(escape_json(entry.params_text))))
    sb.push(",")
    sb.push(jp("message", js(escape_json(entry.message))))
    sb.push(RB())
    sb.to_text()

# ============================================================================
# Entry Array JSON
# ============================================================================

fn log_entries_to_json(entries: [DebugLogEntry]) -> text:
    val sb = StringBuilder(parts: [])
    sb.push("[")
    var first = true
    for entry in entries:
        if not first:
            sb.push(",")
        first = false
        sb.push(log_entry_to_json(entry))
    sb.push("]")
    sb.to_text()

# ============================================================================
# Tree JSON - Hierarchical by group_id/parent
# ============================================================================

fn log_tree_to_json(entries: [DebugLogEntry]) -> text:
    # Build tree nodes from enter entries, attach exit data
    # Root nodes have parent_group_id == 0

    # First pass: collect enter entries and their exit durations
    var enter_map_gids: [i64] = []
    var enter_map_entries: [DebugLogEntry] = []
    var duration_map_gids: [i64] = []
    var duration_map_vals: [i64] = []

    for entry in entries:
        if entry.entry_type == "enter":
            enter_map_gids.push(entry.group_id)
            enter_map_entries.push(entry)
        elif entry.entry_type == "exit":
            duration_map_gids.push(entry.group_id)
            duration_map_vals.push(entry.duration_ms)

    # Build JSON tree recursively via parent_group_id
    val sb = StringBuilder(parts: [])
    sb.push("[")
    var first_root = true
    for i in range(0, enter_map_gids.len()):
        val e = enter_map_entries[i]
        if e.parent_group_id == 0:
            if not first_root:
                sb.push(",")
            first_root = false
            _build_tree_node_sb(sb, e, enter_map_gids, enter_map_entries, duration_map_gids, duration_map_vals)
    sb.push("]")
    sb.to_text()

fn _build_tree_node_sb(sb: StringBuilder, entry: DebugLogEntry, all_gids: [i64], all_entries: [DebugLogEntry], dur_gids: [i64], dur_vals: [i64]):
    # Find duration for this group
    var dur = 0
    for i in range(0, dur_gids.len()):
        if dur_gids[i] == entry.group_id:
            dur = dur_vals[i]

    # Find children (entries whose parent_group_id == this group_id)
    val children_sb = StringBuilder(parts: [])
    children_sb.push("[")
    var first_child = true
    for i in range(0, all_gids.len()):
        val child = all_entries[i]
        if child.parent_group_id == entry.group_id:
            if not first_child:
                children_sb.push(",")
            first_child = false
            _build_tree_node_sb(children_sb, child, all_gids, all_entries, dur_gids, dur_vals)
    children_sb.push("]")
    val children = children_sb.to_text()

    sb.push(LB())
    sb.push(jp("group_id", entry.group_id.to_string()))
    sb.push(",")
    sb.push(jp("parent_group_id", entry.parent_group_id.to_string()))
    sb.push(",")
    sb.push(jp("function_name", js(escape_json(entry.function_name))))
    sb.push(",")
    sb.push(jp("package_path", js(escape_json(entry.package_path))))
    sb.push(",")
    sb.push(jp("class_name", js(escape_json(entry.class_name))))
    sb.push(",")
    sb.push(jp("line_number", entry.line_number.to_string()))
    sb.push(",")
    sb.push(jp("params_text", js(escape_json(entry.params_text))))
    sb.push(",")
    sb.push(jp("depth", entry.depth.to_string()))
    sb.push(",")
    sb.push(jp("duration_ms", dur.to_string()))
    sb.push(",")
    sb.push(jp("children", children))
    sb.push(RB())

# ============================================================================
# Text Tree - Indented with folding markers
# ============================================================================

fn format_log_tree_text(entries: [DebugLogEntry], expanded_groups: [i64]) -> text:
    val sb = StringBuilder(parts: [])
    for entry in entries:
        val indent = _make_indent(entry.depth)
        if entry.entry_type == "enter":
            val is_expanded = _is_group_expanded(entry.group_id, expanded_groups)
            val label_sb = StringBuilder(parts: [])
            label_sb.push(entry.package_path)
            if entry.class_name != "":
                label_sb.push("::")
                label_sb.push(entry.class_name)
            label_sb.push("::")
            label_sb.push(entry.function_name)
            val label = label_sb.to_text()
            val line_info = " (line {entry.line_number})"

            if is_expanded:
                sb.push(indent)
                sb.push("v> ")
                sb.push(label)
                sb.push(line_info)
                sb.push(NL)
                if entry.params_text != "":
                    sb.push(indent)
                    sb.push("    params: ")
                    sb.push(entry.params_text)
                    sb.push(NL)
            else:
                sb.push(indent)
                sb.push(">> ")
                sb.push(label)
                sb.push(line_info)
                if entry.params_text != "":
                    sb.push(" > (...)")
                sb.push(NL)
        elif entry.entry_type == "exit":
            sb.push(indent)
            sb.push("<< ")
            sb.push(entry.package_path)
            sb.push("::")
            sb.push(entry.function_name)
            sb.push(" [")
            sb.push(entry.duration_ms.to_string())
            sb.push("ms]")
            sb.push(NL)
    sb.to_text()

fn _make_indent(depth: i64) -> text:
    val sb = StringBuilder(parts: [])
    for i in range(0, depth):
        sb.push("  ")
    sb.to_text()

fn _is_group_expanded(group_id: i64, expanded_groups: [i64]) -> bool:
    for gid in expanded_groups:
        if gid == group_id:
            return true
    false

# ============================================================================
# Status JSON
# ============================================================================

fn log_status_to_json(enabled: bool, filter_pattern: text, entry_count: i64, current_depth: i64) -> text:
    var en_str = "false"
    if enabled:
        en_str = "true"
    val sb = StringBuilder(parts: [])
    sb.push(LB())
    sb.push(jp("enabled", en_str))
    sb.push(",")
    sb.push(jp("filter_pattern", js(escape_json(filter_pattern))))
    sb.push(",")
    sb.push(jp("entry_count", entry_count.to_string()))
    sb.push(",")
    sb.push(jp("current_depth", current_depth.to_string()))
    sb.push(RB())
    sb.to_text()
