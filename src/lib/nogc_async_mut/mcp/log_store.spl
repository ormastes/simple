# MCP Debug Log Store - JSON serialization and tree rendering
#
# Converts DebugLogEntry arrays into JSON and collapsible tree text.
# Used by debug_log_tools.spl for MCP tool responses.

use compiler.core.aop_debug_log.{DebugLogEntry}
use std.nogc_async_mut.mcp.helpers.{LB, RB, Q, jp, js, jo1, jo2, escape_json}
use std.text.{NL}

export log_entry_to_json, log_entries_to_json
export log_tree_to_json, format_log_tree_text
export log_status_to_json

# ============================================================================
# Single Entry JSON
# ============================================================================

fn log_entry_to_json(entry: DebugLogEntry) -> text:
    var r = LB()
    r = r + jp("entry_id", entry.entry_id.to_string())
    r = r + "," + jp("group_id", entry.group_id.to_string())
    r = r + "," + jp("parent_group_id", entry.parent_group_id.to_string())
    r = r + "," + jp("depth", entry.depth.to_string())
    r = r + "," + jp("entry_type", js(entry.entry_type))
    r = r + "," + jp("package_path", js(escape_json(entry.package_path)))
    r = r + "," + jp("class_name", js(escape_json(entry.class_name)))
    r = r + "," + jp("function_name", js(escape_json(entry.function_name)))
    r = r + "," + jp("line_number", entry.line_number.to_string())
    r = r + "," + jp("timestamp_ms", entry.timestamp_ms.to_string())
    r = r + "," + jp("duration_ms", entry.duration_ms.to_string())
    r = r + "," + jp("params_text", js(escape_json(entry.params_text)))
    r = r + "," + jp("message", js(escape_json(entry.message)))
    r = r + RB()
    r

# ============================================================================
# Entry Array JSON
# ============================================================================

fn log_entries_to_json(entries: [DebugLogEntry]) -> text:
    var r = "["
    var first = true
    for entry in entries:
        if not first:
            r = r + ","
        first = false
        r = r + log_entry_to_json(entry)
    r = r + "]"
    r

# ============================================================================
# Tree JSON - Hierarchical by group_id/parent
# ============================================================================

fn log_tree_to_json(entries: [DebugLogEntry]) -> text:
    # Build tree nodes from enter entries, attach exit data
    # Each node: {group_id, parent_group_id, function_name, package_path, line_number,
    #             params_text, duration_ms, depth, children: [...]}
    # Root nodes have parent_group_id == 0

    # First pass: collect enter entries and their exit durations
    var enter_map_gids: [i64] = []
    var enter_map_entries: [DebugLogEntry] = []
    var duration_map_gids: [i64] = []
    var duration_map_vals: [i64] = []

    for entry in entries:
        if entry.entry_type == "enter":
            enter_map_gids = enter_map_gids + [entry.group_id]
            enter_map_entries = enter_map_entries + [entry]
        elif entry.entry_type == "exit":
            duration_map_gids = duration_map_gids + [entry.group_id]
            duration_map_vals = duration_map_vals + [entry.duration_ms]

    # Build JSON tree recursively via parent_group_id
    var root_nodes = "["
    var first_root = true
    for i in range(0, enter_map_gids.len()):
        val e = enter_map_entries[i]
        if e.parent_group_id == 0:
            if not first_root:
                root_nodes = root_nodes + ","
            first_root = false
            root_nodes = root_nodes + _build_tree_node(e, enter_map_gids, enter_map_entries, duration_map_gids, duration_map_vals)
    root_nodes = root_nodes + "]"
    root_nodes

fn _build_tree_node(entry: DebugLogEntry, all_gids: [i64], all_entries: [DebugLogEntry], dur_gids: [i64], dur_vals: [i64]) -> text:
    # Find duration for this group
    var dur = 0
    for i in range(0, dur_gids.len()):
        if dur_gids[i] == entry.group_id:
            dur = dur_vals[i]

    # Find children (entries whose parent_group_id == this group_id)
    var children = "["
    var first_child = true
    for i in range(0, all_gids.len()):
        val child = all_entries[i]
        if child.parent_group_id == entry.group_id:
            if not first_child:
                children = children + ","
            first_child = false
            children = children + _build_tree_node(child, all_gids, all_entries, dur_gids, dur_vals)
    children = children + "]"

    var r = LB()
    r = r + jp("group_id", entry.group_id.to_string())
    r = r + "," + jp("parent_group_id", entry.parent_group_id.to_string())
    r = r + "," + jp("function_name", js(escape_json(entry.function_name)))
    r = r + "," + jp("package_path", js(escape_json(entry.package_path)))
    r = r + "," + jp("class_name", js(escape_json(entry.class_name)))
    r = r + "," + jp("line_number", entry.line_number.to_string())
    r = r + "," + jp("params_text", js(escape_json(entry.params_text)))
    r = r + "," + jp("depth", entry.depth.to_string())
    r = r + "," + jp("duration_ms", dur.to_string())
    r = r + "," + jp("children", children)
    r = r + RB()
    r

# ============================================================================
# Text Tree - Indented with folding markers
# ============================================================================

fn format_log_tree_text(entries: [DebugLogEntry], expanded_groups: [i64]) -> text:
    # Format:
    #   >> module.path::function_name (line N) > (...)       <- collapsed
    #   v> module.path::function_name (line N)               <- expanded
    #       params: key=value, key2=value2
    #   << module.path::function_name [Xms]
    var result = ""
    for entry in entries:
        val indent = _make_indent(entry.depth)
        if entry.entry_type == "enter":
            val is_expanded = _is_group_expanded(entry.group_id, expanded_groups)
            var label = entry.package_path
            if entry.class_name != "":
                label = label + "::" + entry.class_name
            label = label + "::" + entry.function_name
            val line_info = " (line " + entry.line_number.to_string() + ")"

            if is_expanded:
                result = result + indent + "v> " + label + line_info + NL
                if entry.params_text != "":
                    result = result + indent + "    params: " + entry.params_text + NL
            else:
                var params_hint = ""
                if entry.params_text != "":
                    params_hint = " > (...)"
                result = result + indent + ">> " + label + line_info + params_hint + NL
        elif entry.entry_type == "exit":
            var label = entry.package_path
            label = label + "::" + entry.function_name
            result = result + indent + "<< " + label + " [" + entry.duration_ms.to_string() + "ms]" + NL
    result

fn _make_indent(depth: i64) -> text:
    var result = ""
    for i in range(0, depth):
        result = result + "  "
    result

fn _is_group_expanded(group_id: i64, expanded_groups: [i64]) -> bool:
    for gid in expanded_groups:
        if gid == group_id:
            return true
    false

# ============================================================================
# Status JSON
# ============================================================================

fn log_status_to_json(enabled: bool, filter_pattern: text, entry_count: i64, current_depth: i64) -> text:
    var en_str = "false"
    if enabled:
        en_str = "true"
    var r = LB()
    r = r + jp("enabled", en_str)
    r = r + "," + jp("filter_pattern", js(escape_json(filter_pattern)))
    r = r + "," + jp("entry_count", entry_count.to_string())
    r = r + "," + jp("current_depth", current_depth.to_string())
    r = r + RB()
    r
