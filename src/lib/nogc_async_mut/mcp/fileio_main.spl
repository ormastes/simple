#!/usr/bin/env simple
# File I/O Protection MCP Server
# Provides protected file operations with rule-based access control
#
# Split into modules:
#   fileio_json.spl   — JSON helper functions
#   fileio_server.spl — FileIOServer class + tool schemas

use std.nogc_async_mut.mcp.fileio_json (LB, extract_json_string_v2, extract_json_value, extract_nested_string, make_result_response, make_error_response, make_tool_result, parse_params_json)
use std.nogc_async_mut.mcp.fileio_server (FileIOServer, get_all_tools)
use app.io.mod (cli_get_args, env_get, shell)

extern fn rt_gc_collect()

# Protocol framing auto-detection
var USE_JSON_LINES = false
val GC_COLLECT_EVERY = 100
val NL = "\n"
var TOOLS_LIST_CACHE = ""

# --- Main entry point ---

fn main():
    val raw_args = cli_get_args()
    var has_server = false
    for arg in raw_args:
        if arg == "server":
            has_server = true

    if not has_server:
        print "Usage: fileio_main.spl server"
        return

    run_server()

# --- Server loop ---

fn run_server():
    val ultra_isolate_mode = (env_get("SIMPLE_MCP_LEAK_ULTRA") ?? "") == "1"
    if ultra_isolate_mode:
        run_ultra_minimal_server()
        return

    val config_path = env_get("SIMPLE_FILEIO_CONFIG") ?? ""
    val config = if config_path.len() > 0:
        config_path
    else:
        "fileio_protection.sdn"

    val server = FileIOServer.init(config)
    val isolate_mode = (env_get("SIMPLE_MCP_LEAK_ISOLATE") ?? "") == "1"
    var request_count = 0

    var running = true
    for _iter in range(0, 999999):
        if not running:
            break
        val line = read_stdin_message()
        if line == "":
            running = false
        else:
            request_count = request_count + 1
            val method = extract_json_string_v2(line, "method")
            val id = extract_json_value(line, "id")
            var response = ""

            if method == "initialize":
                response = make_fileio_init_response(id)
            elif method == "initialized" or method == "notifications/initialized":
                response = ""
            elif method == "tools/list":
                if isolate_mode:
                    response = make_result_response(id, "{\"tools\":[]}")
                else:
                    response = make_fileio_tools_list_response(id)
            elif method == "resources/list":
                response = make_result_response(id, "{\"resources\":[]}")
            elif method == "prompts/list":
                response = make_result_response(id, "{\"prompts\":[]}")
            elif method == "tools/call":
                if isolate_mode:
                    response = make_tool_result(id, "leak-isolate: tool execution disabled")
                else:
                    val tool_name = extract_nested_string(line, "params", "name")
                    if tool_name == "":
                        response = make_error_response(id, -32602, "Missing tool name")
                    else:
                        val args = parse_params_json(line)
                        val result = server.handle_tool(tool_name, args)
                        response = make_tool_result(id, result)
            elif method == "ping":
                response = make_result_response(id, "{}")
            elif method == "shutdown":
                response = make_result_response(id, "null")
            elif method == "exit":
                running = false
                response = ""
            else:
                if id != "" and id != "null":
                    response = make_error_response(id, -32601, "Method not found: " + method)

            if response != "":
                write_stdout_message(response)

            # Periodic collection reduces long-session heap growth under heavy MCP traffic.
            if request_count % GC_COLLECT_EVERY == 0:
                rt_gc_collect()

    server.shutdown()

fn make_fileio_init_response(id: text) -> text:
    val result = "{\"protocolVersion\":\"2025-06-18\",\"capabilities\":{\"tools\":{\"listChanged\":false},\"resources\":{\"listChanged\":false},\"prompts\":{\"listChanged\":false},\"logging\":{},\"completions\":{}},\"serverInfo\":{\"name\":\"simple-fileio\",\"version\":\"1.0.0\",\"instructions\":\"Protected file operations MCP server.\"}}}"
    make_result_response(id, result)

fn make_fileio_tools_list_response(id: text) -> text:
    if TOOLS_LIST_CACHE == "":
        TOOLS_LIST_CACHE = "{\"tools\":[" + get_all_tools().join(",") + "]}"
    make_result_response(id, TOOLS_LIST_CACHE)

fn run_ultra_minimal_server():
    var running = true
    for _iter in range(0, 999999):
        if not running:
            break
        val line = read_stdin_message()
        if line == "":
            running = false
        else:
            val method = extract_json_string_v2(line, "method")
            val id = extract_json_value(line, "id")
            var response = ""

            if method == "initialize":
                val result = "{\"protocolVersion\":\"2025-06-18\",\"capabilities\":{},\"serverInfo\":{\"name\":\"simple-fileio\",\"version\":\"1.0.0\"}}"
                response = make_result_response(id, result)
            elif method == "initialized":
                response = ""
            elif method == "tools/list":
                response = make_result_response(id, "{\"tools\":[]}")
            elif method == "resources/list":
                response = make_result_response(id, "{\"resources\":[]}")
            elif method == "prompts/list":
                response = make_result_response(id, "{\"prompts\":[]}")
            elif method == "tools/call":
                response = make_tool_result(id, "leak-ultra-isolate: noop")
            elif method == "ping":
                response = make_result_response(id, "{}")
            elif method == "shutdown":
                response = make_result_response(id, "null")
            elif method == "exit":
                running = false
                response = ""
            else:
                if id != "" and id != "null":
                    response = make_error_response(id, -32601, "Method not found: " + method)

            if response != "":
                write_stdout_message(response)

# --- Protocol I/O ---

fn read_stdin_message() -> String:
    var line = input()
    if line == "":
        return ""
    if line.ends_with("\r"):
        line = line.substring(0, line.len() - 1)
    if line.starts_with(LB()):
        USE_JSON_LINES = true
        return line
    if line.starts_with("Content-Length:"):
        var len_str = line.replace("Content-Length:", "")
        len_str = len_str.trim()
        val content_length = int(len_str)
        if content_length == 0:
            return ""
        input()
        var body = input()
        return body
    ""

fn write_stdout_message(body: String):
    if USE_JSON_LINES:
        print_raw(body + NL)
    else:
        var header = "Content-Length: " + str(body.len()) + "\r" + NL + "\r" + NL
        print_raw(header)
        print_raw(body)

extern fn rt_process_run(cmd: text, args: [text]) -> (text, text, i64)

fn get_args() -> [text]:
    cli_get_args()

fn read_line() -> text:
    input("")

fn print(msg: text):
    print_raw(msg)
    print_raw(NL)

main()
