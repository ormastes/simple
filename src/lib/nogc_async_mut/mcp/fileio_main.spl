#!/usr/bin/env simple
# File I/O Protection MCP Server
# Provides protected file operations with rule-based access control

use std.nogc_async_mut.mcp.fileio_protection (ProtectionEngine, RuleType, RuleAction, ProtectionResult, create_engine)
use std.nogc_async_mut.mcp.fileio_temp (TempManager, create_temp_manager)
use app.io.mod (cli_get_args, env_get, shell)

extern fn rt_gc_collect()

# Protocol framing auto-detection
var USE_JSON_LINES = false
val GC_COLLECT_EVERY = 100
val NL = "\n"
var TOOLS_LIST_CACHE = ""

fn LB() -> text:
    "{"

fn RB() -> text:
    "}"

fn Q() -> text:
    "\""

fn jp(key: text, value: text) -> text:
    Q() + key + Q() + ":" + value

fn jo2(p1: text, p2: text) -> text:
    LB() + p1 + "," + p2 + RB()

fn escape_json(s: text) -> text:
    var out = s.replace("\\", "\\\\")
    out = out.replace("\"", "\\\"")
    out = out.replace("\n", "\\n")
    out = out.replace("\r", "\\r")
    out = out.replace("\t", "\\t")
    out

fn js(value: text) -> text:
    Q() + escape_json(value) + Q()

fn make_result_response(id: text, result: text) -> text:
    var use_id = id
    if use_id == "":
        use_id = "null"
    LB() + jp("jsonrpc", js("2.0")) + "," + jp("id", use_id) + "," + jp("result", result) + RB()

fn make_error_response(id: text, code: i64, message: text) -> text:
    var use_id = id
    if use_id == "":
        use_id = "null"
    val err = LB() + jp("code", str(code)) + "," + jp("message", js(message)) + RB()
    LB() + jp("jsonrpc", js("2.0")) + "," + jp("id", use_id) + "," + jp("error", err) + RB()

fn make_tool_result(id: text, text_value: text) -> text:
    val content = "[" + LB() + jp("type", js("text")) + "," + jp("text", js(text_value)) + RB() + "]"
    val result = LB() + jp("content", content) + RB()
    make_result_response(id, result)

fn extract_json_string_v2(json: text, key: text) -> text:
    val pattern = Q() + key + Q() + ":"
    val idx = json.index_of(pattern)
    if not idx.?:
        return ""
    val after = json[idx.unwrap() + pattern.len():]
    var i = 0
    while i < after.len():
        if after[i:i+1] == Q():
            break
        i = i + 1
    if i >= after.len():
        return ""
    val start = i + 1
    var j = start
    while j < after.len():
        if after[j:j+1] == Q():
            return after[start:j]
        j = j + 1
    ""

fn extract_json_value(json: text, key: text) -> text:
    val pattern = Q() + key + Q() + ":"
    val idx = json.index_of(pattern)
    if not idx.?:
        return "null"
    val after = json[idx.unwrap() + pattern.len():].trim()
    if after == "":
        return "null"
    if after.starts_with(Q()):
        var i = 1
        while i < after.len():
            if after[i:i+1] == Q():
                return Q() + after[1:i] + Q()
            i = i + 1
        return "null"
    var i = 0
    while i < after.len():
        val ch = after[i:i+1]
        if ch == "," or ch == "}" or ch == "]":
            break
        i = i + 1
    after[0:i].trim()

fn extract_nested_string(json: text, parent: text, key: text) -> text:
    if parent != "params":
        return ""
    val params = parse_params(json)
    extract_json_string_v2(params, key)

fn bool_text(v: bool) -> text:
    if v: "true" else: "false"

fn make_prop(name: text, description: text) -> text:
    jp(name, jo2(jp("type", js("string")), jp("description", js(description))))

fn make_tool_schema_multi(name: text, description: text, props: text, required_json: text, read_only: bool, destructive: bool, idempotent: bool) -> text:
    val input_schema = LB() + jp("type", js("object")) + "," + jp("properties", props) + "," + jp("required", required_json) + RB()
    val annotations = LB() + jp("readOnlyHint", bool_text(read_only)) + "," + jp("destructiveHint", bool_text(destructive)) + "," + jp("idempotentHint", bool_text(idempotent)) + "," + jp("openWorldHint", "false") + RB()
    LB() + jp("name", js(name)) + "," + jp("description", js(description)) + "," + jp("inputSchema", input_schema) + "," + jp("annotations", annotations) + RB()

# MCP Server state
class FileIOServer:
    engine: Option<ProtectionEngine>
    temp_manager: Option<TempManager>
    config_path: text
    temp_base: text

    # Initialize server with lazy engine/temp creation to keep startup fast
    static fn init(config_path: text) -> FileIOServer:
        FileIOServer(
            engine: nil,
            temp_manager: nil,
            config_path: config_path,
            temp_base: "/tmp/fileio_temp"
        )

    # Lazily construct the protection engine
    me ensure_engine() -> ProtectionEngine:
        match self.engine:
            case Some(e): e
            case nil:
                val eng = create_engine(self.config_path, self.temp_base)
                self.engine = Some(eng)
                eng

    # Lazily construct the temp manager
    me ensure_temp_manager() -> TempManager:
        match self.temp_manager:
            case Some(t): t
            case nil:
                val tm = create_temp_manager(self.temp_base, "session_", true, 24)
                self.temp_manager = Some(tm)
                tm

    # Handle MCP tool request
    fn handle_tool(tool_name: text, arguments: text) -> text:
        match tool_name:
            "safe_read": self.tool_safe_read(arguments)
            "safe_write": self.tool_safe_write(arguments)
            "safe_delete": self.tool_safe_delete(arguments)
            "safe_copy": self.tool_safe_copy(arguments)
            "safe_move": self.tool_safe_move(arguments)
            "safe_atomic_write": self.tool_safe_atomic_write(arguments)
            "safe_append": self.tool_safe_append(arguments)
            "list_protected_files": self.tool_list_protected_files(arguments)
            "check_protection": self.tool_check_protection(arguments)
            "add_protection_rule": self.tool_add_protection_rule(arguments)
            "list_temp_files": self.tool_list_temp_files(arguments)
            "cleanup_temp": self.tool_cleanup_temp(arguments)
            "get_temp_dir": self.tool_get_temp_dir(arguments)
            _: self.error_response("Unknown tool: " + tool_name)

    # Cleanup temp session state on server shutdown.
    me shutdown():
        if self.temp_manager.?:
            val tm = self.temp_manager.unwrap()
            if tm.cleanup_on_exit:
                tm.cleanup_session()
        self.temp_manager = nil
        self.engine = nil

    # Tool: safe_read
    fn tool_safe_read(arguments: text) -> text:
        val path = self.parse_path_arg(arguments)
        if path.len() == 0:
            return self.error_response("Missing 'path' argument")

        # Check protection
        val result = self.ensure_engine().check_path(path, "read")
        match result:
            ProtectionResult.Allowed:
                # Read file
                val content = self.read_file(path)
                self.success_response(content)

            ProtectionResult.Redirected(new_path):
                # Read from temp
                val content = self.read_file(new_path)
                self.success_response(content)

            ProtectionResult.Denied(reason):
                self.error_response("Read denied: " + reason)

            ProtectionResult.RequiresAtomic:
                # Atomic doesn't affect reads
                val content = self.read_file(path)
                self.success_response(content)

    # Tool: safe_write
    fn tool_safe_write(arguments: text) -> text:
        val path = self.parse_path_arg(arguments)
        val content = self.parse_content_arg(arguments)

        if path.len() == 0:
            return self.error_response("Missing 'path' argument")

        # Check protection
        val result = self.ensure_engine().check_path(path, "write")
        match result:
            ProtectionResult.Allowed:
                # Write file
                self.write_file(path, content)
                self.success_response("File written: " + path)

            ProtectionResult.Redirected(new_path):
                # Write to temp
                val actual_path = self.ensure_temp_manager().get_temp_path(path)
                self.write_file(actual_path, content)
                self.success_response("File written to temp: " + actual_path)

            ProtectionResult.Denied(reason):
                self.error_response("Write denied: " + reason)

            ProtectionResult.RequiresAtomic:
                self.error_response("Atomic write required (use safe_atomic_write)")

    # Tool: safe_delete
    fn tool_safe_delete(arguments: text) -> text:
        val path = self.parse_path_arg(arguments)
        if path.len() == 0:
            return self.error_response("Missing 'path' argument")

        # Check protection
        val result = self.ensure_engine().check_path(path, "delete")
        match result:
            ProtectionResult.Allowed:
                # Delete file
                self.delete_file(path)
                self.success_response("File deleted: " + path)

            ProtectionResult.Redirected(new_path):
                # Delete from temp
                val actual_path = self.ensure_temp_manager().get_temp_path(path)
                self.delete_file(actual_path)
                self.success_response("Temp file deleted: " + actual_path)

            ProtectionResult.Denied(reason):
                self.error_response("Delete denied: " + reason)

            ProtectionResult.RequiresAtomic:
                self.error_response("Cannot delete atomic-protected file")

    # Tool: safe_copy
    fn tool_safe_copy(arguments: text) -> text:
        val src = self.parse_arg(arguments, "src")
        val dest = self.parse_arg(arguments, "dest")

        if src.len() == 0 or dest.len() == 0:
            return self.error_response("Missing 'src' or 'dest' argument")

        # Check read permission on source
        val src_result = self.ensure_engine().check_path(src, "read")
        match src_result:
            ProtectionResult.Denied(reason):
                return self.error_response("Source read denied: " + reason)
            _: ()

        # Check write permission on destination
        val dest_result = self.ensure_engine().check_path(dest, "write")
        match dest_result:
            ProtectionResult.Allowed:
                self.copy_file(src, dest)
                self.success_response("File copied: {src} -> {dest}")

            ProtectionResult.Redirected(new_path):
                val actual_dest = self.ensure_temp_manager().get_temp_path(dest)
                self.copy_file(src, actual_dest)
                self.success_response("File copied to temp: {src} -> {actual_dest}")

            ProtectionResult.Denied(reason):
                self.error_response("Destination write denied: " + reason)

            ProtectionResult.RequiresAtomic:
                self.error_response("Atomic write required for destination")

    # Tool: safe_move
    fn tool_safe_move(arguments: text) -> text:
        val src = self.parse_arg(arguments, "src")
        val dest = self.parse_arg(arguments, "dest")

        if src.len() == 0 or dest.len() == 0:
            return self.error_response("Missing 'src' or 'dest' argument")

        # Check delete permission on source
        val src_result = self.ensure_engine().check_path(src, "delete")
        match src_result:
            ProtectionResult.Denied(reason):
                return self.error_response("Source delete denied: " + reason)
            _: ()

        # Check write permission on destination
        val dest_result = self.ensure_engine().check_path(dest, "write")
        match dest_result:
            ProtectionResult.Allowed:
                self.move_file(src, dest)
                self.success_response("File moved: {src} -> {dest}")

            ProtectionResult.Redirected(new_path):
                val actual_dest = self.ensure_temp_manager().get_temp_path(dest)
                self.move_file(src, actual_dest)
                self.success_response("File moved to temp: {src} -> {actual_dest}")

            ProtectionResult.Denied(reason):
                self.error_response("Destination write denied: " + reason)

            ProtectionResult.RequiresAtomic:
                self.error_response("Atomic write required for destination")

    # Tool: safe_atomic_write
    fn tool_safe_atomic_write(arguments: text) -> text:
        val path = self.parse_path_arg(arguments)
        val content = self.parse_content_arg(arguments)

        if path.len() == 0:
            return self.error_response("Missing 'path' argument")

        # Perform atomic write (write to temp, then rename)
        val temp_path = path + ".tmp"
        self.write_file(temp_path, content)
        self.move_file(temp_path, path)
        self.success_response("File written atomically: " + path)

    # Tool: safe_append
    fn tool_safe_append(arguments: text) -> text:
        val path = self.parse_path_arg(arguments)
        val content = self.parse_content_arg(arguments)

        if path.len() == 0:
            return self.error_response("Missing 'path' argument")

        # Check protection
        val result = self.ensure_engine().check_path(path, "write")
        match result:
            ProtectionResult.Allowed:
                self.append_file(path, content)
                self.success_response("Content appended: " + path)

            ProtectionResult.Redirected(new_path):
                val actual_path = self.ensure_temp_manager().get_temp_path(path)
                self.append_file(actual_path, content)
                self.success_response("Content appended to temp: " + actual_path)

            ProtectionResult.Denied(reason):
                self.error_response("Append denied: " + reason)

            ProtectionResult.RequiresAtomic:
                self.error_response("Atomic write required")

    # Tool: list_protected_files
    fn tool_list_protected_files(arguments: text) -> text:
        val pattern = self.parse_arg(arguments, "pattern")
        val search = if pattern.len() > 0: pattern else: "*"

        val files = self.ensure_engine().list_protected_files(search)
        val json = self.files_to_json(files)
        self.success_response(json)

    # Tool: check_protection
    fn tool_check_protection(arguments: text) -> text:
        val path = self.parse_path_arg(arguments)
        if path.len() == 0:
            return self.error_response("Missing 'path' argument")

        val info = self.ensure_engine().get_protection_info(path)
        self.success_response(info)

    # Tool: add_protection_rule
    fn tool_add_protection_rule(arguments: text) -> text:
        val pattern = self.parse_arg(arguments, "pattern")
        val rule_type = self.parse_arg(arguments, "type")
        val action = self.parse_arg(arguments, "action")
        val reason = self.parse_arg(arguments, "reason")

        if pattern.len() == 0:
            return self.error_response("Missing 'pattern' argument")

        val type_enum = match rule_type:
            "exact": RuleType.Exact
            "glob": RuleType.Glob
            "regex": RuleType.Regex
            _: RuleType.Exact

        val action_enum = match action:
            "deny": RuleAction.Deny
            "protect": RuleAction.Protect
            "redirect": RuleAction.Redirect
            "atomic": RuleAction.Atomic
            "allow": RuleAction.Allow
            _: RuleAction.Allow

        self.ensure_engine().add_rule(pattern, type_enum, action_enum, reason)
        self.success_response("Protection rule added: " + pattern)

    # Tool: list_temp_files
    fn tool_list_temp_files(arguments: text) -> text:
        val files = self.ensure_temp_manager().list_temp_files()
        val json = self.files_to_json(files)
        self.success_response(json)

    # Tool: cleanup_temp
    fn tool_cleanup_temp(arguments: text) -> text:
        self.ensure_temp_manager().cleanup_session()
        self.success_response("Temp files cleaned up")

    # Tool: get_temp_dir
    fn tool_get_temp_dir(arguments: text) -> text:
        val temp_dir = self.ensure_temp_manager().get_temp_dir()
        self.success_response(temp_dir)

    # Parse path argument from JSON
    fn parse_path_arg(arguments: text) -> text:
        self.parse_arg(arguments, "path")

    # Parse content argument from JSON
    fn parse_content_arg(arguments: text) -> text:
        self.parse_arg(arguments, "content")

    # Parse generic argument from JSON (simple implementation)
    fn parse_arg(arguments: text, key: text) -> text:
        # Simple JSON parsing: find "key": "value"
        val search = "\"" + key + "\""
        val idx = arguments.index_of(search)

        if not idx.?:
            return ""

        val start = idx.unwrap() + search.len()
        val rest = arguments[start:]

        # Find opening quote
        val quote_idx = rest.index_of("\"")
        if not quote_idx.?:
            return ""

        val value_start = quote_idx.unwrap() + 1
        val value_rest = rest[value_start:]

        # Find closing quote
        val close_idx = value_rest.index_of("\"")
        if not close_idx.?:
            return ""

        value_rest[0:close_idx.unwrap()]

    # Convert file list to JSON array
    fn files_to_json(files: [text]) -> text:
        if files.len() == 0:
            return "[]"

        var result = "["
        for i in 0..files.len():
            if i > 0:
                result = result + ", "
            result = result + "\"" + files[i] + "\""
        result + "]"

    # File operations
    fn read_file(path: text) -> text:
        shell("cat '{path}' 2>/dev/null || echo ''")

    fn write_file(path: text, content: text):
        # Escape content for shell
        val escaped = content.replace("'", "'\\''")
        shell("echo '{escaped}' > '{path}'")

    fn delete_file(path: text):
        shell("rm -f '{path}'")

    fn copy_file(src: text, dest: text):
        shell("cp '{src}' '{dest}'")

    fn move_file(src: text, dest: text):
        shell("mv '{src}' '{dest}'")

    fn append_file(path: text, content: text):
        val escaped = content.replace("'", "'\\''")
        shell("echo '{escaped}' >> '{path}'")

    # Response helpers
    fn success_response(data: text) -> text:
        "{\"status\": \"success\", \"data\": \"" + data + "\"}"

    fn error_response(message: text) -> text:
        "{\"status\": \"error\", \"message\": \"" + message + "\"}"

# --- Tool schema definitions ---

fn get_all_tools() -> [String]:
    [
        schema_safe_read(),
        schema_safe_write(),
        schema_safe_delete(),
        schema_safe_copy(),
        schema_safe_move(),
        schema_safe_atomic_write(),
        schema_safe_append(),
        schema_list_protected_files(),
        schema_check_protection(),
        schema_add_protection_rule(),
        schema_list_temp_files(),
        schema_cleanup_temp(),
        schema_get_temp_dir()
    ]

fn schema_safe_read() -> String:
    val props = LB() + make_prop("path", "Path to read") + RB()
    make_tool_schema_multi("safe_read", "Read a file with protection checks", props, "[" + js("path") + "]", true, false, true)

fn schema_safe_write() -> String:
    var props = LB()
    props = props + make_prop("path", "Path to write")
    props = props + "," + make_prop("content", "Content to write")
    props = props + RB()
    make_tool_schema_multi("safe_write", "Write a file with protection checks", props, "[" + js("path") + "," + js("content") + "]", false, false, false)

fn schema_safe_delete() -> String:
    val props = LB() + make_prop("path", "Path to delete") + RB()
    make_tool_schema_multi("safe_delete", "Delete a file with protection checks", props, "[" + js("path") + "]", false, true, false)

fn schema_safe_copy() -> String:
    var props = LB()
    props = props + make_prop("src", "Source path")
    props = props + "," + make_prop("dest", "Destination path")
    props = props + RB()
    make_tool_schema_multi("safe_copy", "Copy a file with protection checks", props, "[" + js("src") + "," + js("dest") + "]", false, false, false)

fn schema_safe_move() -> String:
    var props = LB()
    props = props + make_prop("src", "Source path")
    props = props + "," + make_prop("dest", "Destination path")
    props = props + RB()
    make_tool_schema_multi("safe_move", "Move a file with protection checks", props, "[" + js("src") + "," + js("dest") + "]", false, true, false)

fn schema_safe_atomic_write() -> String:
    var props = LB()
    props = props + make_prop("path", "Path to write atomically")
    props = props + "," + make_prop("content", "Content to write")
    props = props + RB()
    make_tool_schema_multi("safe_atomic_write", "Write a file atomically with protection checks", props, "[" + js("path") + "," + js("content") + "]", false, false, false)

fn schema_safe_append() -> String:
    var props = LB()
    props = props + make_prop("path", "Path to append to")
    props = props + "," + make_prop("content", "Content to append")
    props = props + RB()
    make_tool_schema_multi("safe_append", "Append to a file with protection checks", props, "[" + js("path") + "," + js("content") + "]", false, false, false)

fn schema_list_protected_files() -> String:
    val props = LB() + make_prop("pattern", "Optional filter pattern") + RB()
    make_tool_schema_multi("list_protected_files", "List protected files or rules", props, "[]", true, false, true)

fn schema_check_protection() -> String:
    val props = LB() + make_prop("path", "Path to check") + RB()
    make_tool_schema_multi("check_protection", "Check protection status for a path", props, "[" + js("path") + "]", true, false, true)

fn schema_add_protection_rule() -> String:
    var props = LB()
    props = props + make_prop("pattern", "Path pattern")
    props = props + "," + make_prop("type", "Rule type: exact|glob|regex")
    props = props + "," + make_prop("action", "Action: allow|deny|protect|redirect|atomic")
    props = props + "," + make_prop("reason", "Optional reason")
    props = props + RB()
    make_tool_schema_multi("add_protection_rule", "Add a protection rule", props, "[" + js("pattern") + "]", false, true, false)

fn schema_list_temp_files() -> String:
    make_tool_schema_multi("list_temp_files", "List temp files created by the file I/O server", LB() + RB(), "[]", true, false, true)

fn schema_cleanup_temp() -> String:
    make_tool_schema_multi("cleanup_temp", "Clean up temp files created by the file I/O server", LB() + RB(), "[]", false, true, false)

fn schema_get_temp_dir() -> String:
    make_tool_schema_multi("get_temp_dir", "Get temp directory path", LB() + RB(), "[]", true, false, true)

# --- Main entry point ---

fn main():
    val raw_args = cli_get_args()
    var has_server = false
    for arg in raw_args:
        if arg == "server":
            has_server = true

    if not has_server:
        print "Usage: fileio_main.spl server"
        return

    run_server()

# --- Server loop ---

fn run_server():
    val ultra_isolate_mode = (env_get("SIMPLE_MCP_LEAK_ULTRA") ?? "") == "1"
    if ultra_isolate_mode:
        run_ultra_minimal_server()
        return

    val config_path = env_get("SIMPLE_FILEIO_CONFIG") ?? ""
    val config = if config_path.len() > 0:
        config_path
    else:
        "fileio_protection.sdn"

    val server = FileIOServer.init(config)
    val isolate_mode = (env_get("SIMPLE_MCP_LEAK_ISOLATE") ?? "") == "1"
    var request_count = 0

    var running = true
    for _iter in range(0, 999999):
        if not running:
            break
        val line = read_stdin_message()
        if line == "":
            running = false
        else:
            request_count = request_count + 1
            val method = extract_json_string_v2(line, "method")
            val id = extract_json_value(line, "id")
            var response = ""

            if method == "initialize":
                response = make_fileio_init_response(id)
            elif method == "initialized" or method == "notifications/initialized":
                response = ""
            elif method == "tools/list":
                if isolate_mode:
                    response = make_result_response(id, "{\"tools\":[]}")
                else:
                    response = make_fileio_tools_list_response(id)
            elif method == "resources/list":
                response = make_result_response(id, "{\"resources\":[]}")
            elif method == "prompts/list":
                response = make_result_response(id, "{\"prompts\":[]}")
            elif method == "tools/call":
                if isolate_mode:
                    response = make_tool_result(id, "leak-isolate: tool execution disabled")
                else:
                    val tool_name = extract_nested_string(line, "params", "name")
                    if tool_name == "":
                        response = make_error_response(id, -32602, "Missing tool name")
                    else:
                        val args = parse_params(line)
                        val result = server.handle_tool(tool_name, args)
                        response = make_tool_result(id, result)
            elif method == "ping":
                response = make_result_response(id, "{}")
            elif method == "shutdown":
                response = make_result_response(id, "null")
            elif method == "exit":
                running = false
                response = ""
            else:
                if id != "" and id != "null":
                    response = make_error_response(id, -32601, "Method not found: " + method)

            if response != "":
                write_stdout_message(response)

            # Periodic collection reduces long-session heap growth under heavy MCP traffic.
            if request_count % GC_COLLECT_EVERY == 0:
                rt_gc_collect()

    server.shutdown()

fn make_fileio_init_response(id: text) -> text:
    val result = "{\"protocolVersion\":\"2025-06-18\",\"capabilities\":{\"tools\":{\"listChanged\":false},\"resources\":{\"listChanged\":false},\"prompts\":{\"listChanged\":false},\"logging\":{},\"completions\":{}},\"serverInfo\":{\"name\":\"simple-fileio\",\"version\":\"1.0.0\",\"instructions\":\"Protected file operations MCP server.\"}}}"
    make_result_response(id, result)

fn make_fileio_tools_list_response(id: text) -> text:
    if TOOLS_LIST_CACHE == "":
        TOOLS_LIST_CACHE = "{\"tools\":[" + get_all_tools().join(",") + "]}"
    make_result_response(id, TOOLS_LIST_CACHE)

fn run_ultra_minimal_server():
    var running = true
    for _iter in range(0, 999999):
        if not running:
            break
        val line = read_stdin_message()
        if line == "":
            running = false
        else:
            val method = extract_json_string_v2(line, "method")
            val id = extract_json_value(line, "id")
            var response = ""

            if method == "initialize":
                val result = "{\"protocolVersion\":\"2025-06-18\",\"capabilities\":{},\"serverInfo\":{\"name\":\"simple-fileio\",\"version\":\"1.0.0\"}}"
                response = make_result_response(id, result)
            elif method == "initialized":
                response = ""
            elif method == "tools/list":
                response = make_result_response(id, "{\"tools\":[]}")
            elif method == "resources/list":
                response = make_result_response(id, "{\"resources\":[]}")
            elif method == "prompts/list":
                response = make_result_response(id, "{\"prompts\":[]}")
            elif method == "tools/call":
                response = make_tool_result(id, "leak-ultra-isolate: noop")
            elif method == "ping":
                response = make_result_response(id, "{}")
            elif method == "shutdown":
                response = make_result_response(id, "null")
            elif method == "exit":
                running = false
                response = ""
            else:
                if id != "" and id != "null":
                    response = make_error_response(id, -32601, "Method not found: " + method)

            if response != "":
                write_stdout_message(response)

# --- Protocol I/O ---

fn read_stdin_message() -> String:
    var line = input()
    if line == "":
        return ""
    if line.ends_with("\r"):
        line = line.substring(0, line.len() - 1)
    if line.starts_with(LB()):
        USE_JSON_LINES = true
        return line
    if line.starts_with("Content-Length:"):
        var len_str = line.replace("Content-Length:", "")
        len_str = len_str.trim()
        val content_length = int(len_str)
        if content_length == 0:
            return ""
        input()
        var body = input()
        return body
    ""

fn write_stdout_message(body: String):
    if USE_JSON_LINES:
        print_raw(body + NL)
    else:
        var header = "Content-Length: " + str(body.len()) + "\r" + NL + "\r" + NL
        print_raw(header)
        print_raw(body)

# --- Params parser ---

fn parse_params(json: text) -> text:
    val search = "\"params\""
    val idx = json.index_of(search)
    if not idx.?:
        return "{}"

    val start = idx.unwrap() + search.len()
    val rest = json[start:]
    val brace_idx = rest.index_of("{")
    if not brace_idx.?:
        return "{}"

    # Simple brace matching
    var depth = 0
    var result = ""
    for i in brace_idx.unwrap()..rest.len():
        val ch = rest[i:i+1]
        result = result + ch
        if ch == "{":
            depth = depth + 1
        else if ch == "}":
            depth = depth - 1
            if depth == 0:
                break

    result

extern fn rt_process_run(cmd: text, args: [text]) -> (text, text, i64)

fn get_args() -> [text]:
    cli_get_args()

fn read_line() -> text:
    input("")

fn print(msg: text):
    print_raw(msg)
    print_raw(NL)

main()
