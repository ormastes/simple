# LLM Caret - OpenAI-Compatible API
#
# Generic OpenAI-compatible endpoint for Ollama, LM Studio, vLLM, LocalAI, etc.
# Same protocol as OpenAI but configurable base URL and optional API key.

extern fn rt_http_request(method: text, url: text, headers: text, body: text) -> (i64, text, text)

# ============================================================================
# JSON helpers (inlined)
# ============================================================================

fn _LB() -> text:
    (123 as char).to_text()

fn _RB() -> text:
    (125 as char).to_text()

fn _Q() -> text:
    "\""

fn _unwrap_idx(opt) -> i64:
    match opt:
        Some(i): return i
        nil: return -1

fn _escape_json(s: text) -> text:
    var result = ""
    var i = 0
    while i < s.len():
        val ch = s[i]
        if ch == "\\":
            result = result + "\\\\"
        elif ch == "\"":
            result = result + "\\\""
        elif ch == "\n":
            result = result + "\\n"
        elif ch == "\r":
            result = result + "\\r"
        elif ch == "\t":
            result = result + "\\t"
        else:
            result = result + ch
        i = i + 1
    result

fn _extract_json_string(json: text, key: text) -> text:
    val quote = "\""
    val search = quote + key + quote + ":"
    val idx = _unwrap_idx(json.index_of(search))
    if idx < 0:
        return ""
    val slen = search.len()
    val start = idx + slen
    val after = json.substring(start)
    val trimmed = after.trim()
    if trimmed.starts_with(quote):
        val rest = trimmed.substring(1)
        var end = 0
        var escaped = false
        while end < rest.len():
            val ch = rest[end]
            if escaped:
                escaped = false
            elif ch == "\\":
                escaped = true
            elif ch == "\"":
                return rest.substring(0, end)
            end = end + 1
    ""

fn _extract_json_value(json: text, key: text) -> text:
    val search = _Q() + key + _Q() + ":"
    val idx = _unwrap_idx(json.index_of(search))
    if idx < 0:
        return "null"
    val slen = search.len()
    val start = idx + slen
    val after = json.substring(start)
    val trimmed = after.trim()
    var end = 0
    while end < trimmed.len():
        val ch = trimmed[end]
        if ch == "," or ch == _RB() or ch == "]":
            break
        end = end + 1
    trimmed.substring(0, end).trim()

fn _extract_json_int(json: text, key: text) -> i64:
    val raw = _extract_json_value(json, key)
    if raw == "null" or raw == "":
        return 0
    int(raw)

# ============================================================================
# Response struct
# ============================================================================

struct CompatResponse:
    content: text
    model: text
    finish_reason: text
    prompt_tokens: i64
    completion_tokens: i64
    error: text
    is_error: bool
    raw: text

# ============================================================================
# Request building
# ============================================================================

fn build_compat_body(model: text, messages_json: text, max_tokens: i64, temperature: f64) -> text:
    var parts: [text] = []
    parts = parts + [_Q() + "model" + _Q() + ":" + _Q() + model + _Q()]
    parts = parts + [_Q() + "messages" + _Q() + ":" + messages_json]
    if max_tokens > 0:
        parts = parts + [_Q() + "max_tokens" + _Q() + ":" + max_tokens.to_text()]
    if temperature >= 0.0:
        parts = parts + [_Q() + "temperature" + _Q() + ":" + temperature.to_text()]
    var body = _LB()
    var i = 0
    for part in parts:
        if i > 0:
            body = body + ","
        body = body + part
        i = i + 1
    body = body + _RB()
    body

fn build_compat_headers(api_key: text) -> text:
    var h = "Content-Type: application/json"
    if api_key != "":
        h = "Authorization: Bearer " + api_key + "\n" + h
    h

# ============================================================================
# Response parsing
# ============================================================================

fn parse_compat_response(raw: text) -> CompatResponse:
    if raw.trim() == "":
        return CompatResponse(
            content: "",
            model: "",
            finish_reason: "",
            prompt_tokens: 0,
            completion_tokens: 0,
            error: "empty response",
            is_error: true,
            raw: ""
        )
    val error_msg = _extract_json_string(raw, "message")
    val has_content = _extract_json_string(raw, "content")
    if error_msg != "" and has_content == "":
        return CompatResponse(
            content: "",
            model: "",
            finish_reason: "error",
            prompt_tokens: 0,
            completion_tokens: 0,
            error: error_msg,
            is_error: true,
            raw: raw
        )
    val content_text = _extract_json_string(raw, "content")
    val model_val = _extract_json_string(raw, "model")
    val finish = _extract_json_string(raw, "finish_reason")
    val p_tok = _extract_json_int(raw, "prompt_tokens")
    val c_tok = _extract_json_int(raw, "completion_tokens")
    var final_finish = finish
    if final_finish == "":
        final_finish = "stop"
    CompatResponse(
        content: content_text,
        model: model_val,
        finish_reason: final_finish,
        prompt_tokens: p_tok,
        completion_tokens: c_tok,
        error: "",
        is_error: false,
        raw: raw
    )

# ============================================================================
# Send request
# ============================================================================

fn compat_send(base_url: text, api_key: text, model: text, messages_json: text, max_tokens: i64, temperature: f64) -> CompatResponse:
    val url = base_url + "/v1/chat/completions"
    val headers = build_compat_headers(api_key)
    val body = build_compat_body(model, messages_json, max_tokens, temperature)
    val result = rt_http_request("POST", url, headers, body)
    val resp_body = result.1 ?? ""
    val http_error = result.2 ?? ""
    if http_error != "":
        return CompatResponse(
            content: "",
            model: "",
            finish_reason: "error",
            prompt_tokens: 0,
            completion_tokens: 0,
            error: "HTTP error: " + http_error,
            is_error: true,
            raw: resp_body
        )
    parse_compat_response(resp_body)
