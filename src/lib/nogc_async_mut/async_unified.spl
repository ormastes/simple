# Async Unified - Runtime-Agnostic Interface
#
# This module provides a unified API that works with both embedded and host runtimes.
# Currently defaults to host runtime.
#
# Usage:
#   use std.async_unified.*
#
#   val runtime = Runtime.new()
#   val handle = runtime.run_task(\: compute())
#   val result = runtime.block_on(handle.join())
#
# For embedded, use std.async_embedded directly.
# For host, use std.async_host directly or this module.
#
# Compile-time runtime selection requires conditional compilation (not yet implemented).
# Currently defaults to host runtime. When conditional compilation is available:
#   @config(runtime: "host" | "embedded")
#   #if config.runtime == "embedded": use std.async_embedded
#   #else: use std.async_host
# Note: Using default host runtime until compile-time selection is available.

use std.async_core.*
use std.async_host.*

# ============================================================================
# Type Aliases - Unified Names
# ============================================================================

# Re-export host types with unified names
# (Users can switch to embedded by changing imports)

# Note: These would be type aliases if Simple supported them:
#   type Future<T> = HostFuture<T>
#   type Runtime = HostRuntime
# For now, just use HostFuture, HostRuntime directly

# ============================================================================
# Re-exports for Unified API
# ============================================================================

# Core types (from async_core)
export Poll
export TaskState
export Priority
export AsyncError
export CancellationToken
export WakeReason

# Host runtime (default)
export HostFuture
export HostPromise
export HostTaskHandle
export HostJoinSet
export HostFuturesUnordered
export HostScheduler
export HostRuntime
export Waker
export Context

# Combinators
export join_all
export select
export race
export timeout

# ============================================================================
# Usage Examples
# ============================================================================

# Example 1: Simple task execution
fn example_simple():
    var runtime = HostRuntime.new()
    val handle = runtime.run_task(\: 42)
    val result = runtime.block_on(handle.join())
    print "Result: {result}"

# Example 2: JoinSet with streaming completion
fn example_joinset():
    var runtime = HostRuntime.new()
    var set = HostJoinSet.new()

    for i in 0..10:
        set.add_task(\: compute(i))

    while val Some((id, result)) = set.try_join_next():
        print "Task {id} completed: {result}"

fn compute(x: i64) -> i64:
    x * 2

# Example 3: FuturesUnordered
fn example_futures():
    var futs = HostFuturesUnordered.new()

    futs.push(HostFuture.ready(1))
    futs.push(HostFuture.ready(2))
    futs.push(HostFuture.ready(3))

    var sum: i64 = 0
    while val Some(value) = futs.try_next():
        sum = sum + value

    print "Sum: {sum}"

# Example 4: Priority scheduling
fn example_priority():
    var runtime = HostRuntime.new()

    val low = runtime.run_task_with_priority(\: slow_work(), Priority.Low)
    val high = runtime.run_task_with_priority(\: urgent_work(), Priority.High)

    # High priority task runs first
    runtime.run()

fn slow_work() -> i64:
    100

fn urgent_work() -> i64:
    200

# Example 5: Combinators
fn example_combinators():
    val futures = [
        HostFuture.ready(1),
        HostFuture.ready(2),
        HostFuture.ready(3)
    ]

    # Wait for all
    val all = join_all(futures)

    # Or race for first
    val first = race(futures)

# ============================================================================
# Migration Guide
# ============================================================================
#
# From std.async (old single runtime) to async_unified:
#
# Before:
#   use std.async.*
#   val future = Future.from_value(42)
#   val task = Task.new(\\: compute())
#
# After (unified):
#   use std.async_unified.*
#   val future = HostFuture.ready(42)
#   val runtime = HostRuntime.new()
#   val handle = runtime.run_task(\\: compute())
#
# After (embedded):
#   use std.async_embedded.*
#   val future = EmbeddedFuture.ready(42)
#   var scheduler = EmbeddedScheduler.new()
#   scheduler.schedule(Priority.Normal, \\: Poll.Ready(()))
