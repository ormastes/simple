# Thread SFFI - Simple FFI Bindings for Threading
#
# SFFI pattern for cross-platform threading primitives.
# Tier 1: C runtime (seed/runtime_thread.c)
# Tier 2: Simple wrappers (this file)
#
# Design: All handles are i64 (opaque), errors use Option pattern.

# ============================================================================
# External FFI Declarations
# ============================================================================

# Thread Management
extern fn spl_thread_create(entry_point: i64, arg: i64) -> i64
extern fn spl_thread_join(handle: i64) -> bool
extern fn spl_thread_detach(handle: i64) -> bool
extern fn spl_thread_current_id() -> i64
extern fn spl_thread_sleep(millis: i64)
extern fn spl_thread_yield()

# Mutex
extern fn spl_mutex_create() -> i64
extern fn spl_mutex_lock(handle: i64) -> bool
extern fn spl_mutex_try_lock(handle: i64) -> bool
extern fn spl_mutex_unlock(handle: i64) -> bool
extern fn spl_mutex_destroy(handle: i64)

# Condition Variable
extern fn spl_condvar_create() -> i64
extern fn spl_condvar_wait(cv_handle: i64, mutex_handle: i64) -> bool
extern fn spl_condvar_wait_timeout(cv_handle: i64, mutex_handle: i64, timeout_ms: i64) -> bool
extern fn spl_condvar_signal(handle: i64) -> bool
extern fn spl_condvar_broadcast(handle: i64) -> bool
extern fn spl_condvar_destroy(handle: i64)

# Platform
extern fn spl_thread_cpu_count() -> i64

# ============================================================================
# Thread Handle
# ============================================================================

class ThreadHandle:
    """Handle to a spawned OS thread.

    Opaque wrapper around platform-specific thread handle.
    """
    handle: i64

    static fn invalid() -> ThreadHandle:
        """Create invalid handle."""
        ThreadHandle(handle: 0)

    fn is_valid() -> bool:
        """Check if handle is valid."""
        self.handle > 0

    fn join() -> bool:
        """Wait for thread to complete.

        Returns:
            true if joined successfully, false on error

        Note: Consumes the handle (can only join once).
        """
        if not self.is_valid():
            return false
        spl_thread_join(self.handle)

    fn detach() -> bool:
        """Detach thread (no join required).

        Returns:
            true if detached successfully, false on error
        """
        if not self.is_valid():
            return false
        spl_thread_detach(self.handle)

# ============================================================================
# Thread Functions
# ============================================================================

fn thread_current_id() -> i64:
    """Get current thread ID.

    Returns:
        Platform-specific thread ID
    """
    spl_thread_current_id()

fn thread_sleep(millis: i64):
    """Sleep current thread.

    Args:
        millis: Sleep duration in milliseconds
    """
    if millis > 0:
        spl_thread_sleep(millis)

fn thread_yield():
    """Yield CPU to other threads."""
    spl_thread_yield()

fn thread_cpu_count() -> i64:
    """Get number of available CPU cores.

    Returns:
        Number of logical CPU cores
    """
    spl_thread_cpu_count()

# ============================================================================
# Mutex Handle
# ============================================================================

class MutexHandle:
    """Mutual exclusion lock.

    Cross-platform mutex wrapper.

    Example:
        val mutex = mutex_create()
        mutex.lock()
        # critical section
        mutex.unlock()
        mutex.destroy()
    """
    handle: i64

    fn is_valid() -> bool:
        """Check if handle is valid."""
        self.handle > 0

    fn lock() -> bool:
        """Lock mutex (blocking).

        Returns:
            true if locked, false on error
        """
        if not self.is_valid():
            return false
        spl_mutex_lock(self.handle)

    fn try_lock() -> bool:
        """Try to lock mutex (non-blocking).

        Returns:
            true if locked, false if already locked or error
        """
        if not self.is_valid():
            return false
        spl_mutex_try_lock(self.handle)

    fn unlock() -> bool:
        """Unlock mutex.

        Returns:
            true if unlocked, false on error
        """
        if not self.is_valid():
            return false
        spl_mutex_unlock(self.handle)

    fn destroy():
        """Destroy mutex and free resources."""
        if self.is_valid():
            spl_mutex_destroy(self.handle)

fn mutex_create() -> MutexHandle:
    """Create new mutex.

    Returns:
        Mutex handle (check is_valid())
    """
    val handle = spl_mutex_create()
    MutexHandle(handle: handle)

# ============================================================================
# Condition Variable Handle
# ============================================================================

class CondVarHandle:
    """Condition variable for thread synchronization.

    Cross-platform condvar wrapper.

    Example:
        val cv = condvar_create()
        val mutex = mutex_create()

        mutex.lock()
        cv.wait(mutex)  # releases mutex, reacquires on wake
        mutex.unlock()

        cv.destroy()
        mutex.destroy()
    """
    handle: i64

    fn is_valid() -> bool:
        """Check if handle is valid."""
        self.handle > 0

    fn wait(mutex: MutexHandle) -> bool:
        """Wait on condition variable.

        Releases mutex and blocks until signaled.
        Reacquires mutex before returning.

        Args:
            mutex: Locked mutex

        Returns:
            true if woken, false on error
        """
        if not self.is_valid():
            return false
        if not mutex.is_valid():
            return false
        spl_condvar_wait(self.handle, mutex.handle)

    fn wait_timeout(mutex: MutexHandle, timeout_ms: i64) -> bool:
        """Wait with timeout.

        Args:
            mutex: Locked mutex
            timeout_ms: Timeout in milliseconds

        Returns:
            true if woken, false on timeout or error
        """
        if not self.is_valid():
            return false
        if not mutex.is_valid():
            return false
        spl_condvar_wait_timeout(self.handle, mutex.handle, timeout_ms)

    fn signal() -> bool:
        """Wake one waiting thread.

        Returns:
            true on success, false on error
        """
        if not self.is_valid():
            return false
        spl_condvar_signal(self.handle)

    fn broadcast() -> bool:
        """Wake all waiting threads.

        Returns:
            true on success, false on error
        """
        if not self.is_valid():
            return false
        spl_condvar_broadcast(self.handle)

    fn destroy():
        """Destroy condition variable and free resources."""
        if self.is_valid():
            spl_condvar_destroy(self.handle)

fn condvar_create() -> CondVarHandle:
    """Create new condition variable.

    Returns:
        Condvar handle (check is_valid())
    """
    val handle = spl_condvar_create()
    CondVarHandle(handle: handle)

# ============================================================================
# Exports
# ============================================================================

export ThreadHandle
export MutexHandle
export CondVarHandle
export thread_current_id
export thread_sleep
export thread_yield
export thread_cpu_count
export mutex_create
export condvar_create
