"""
# Async UDP I/O

Epoll-driven async UDP socket.
Non-blocking datagram send/receive using the event loop.

## Components

| Type | Traits | Description |
|------|--------|-------------|
| AsyncUdpSocket | AsyncClose | Non-blocking UDP socket (epoll) |

## Async Datagram Exchange

```simple
# val socket = await AsyncUdpSocket.bind("127.0.0.1:0")?
# await socket.send_to([72, 105], "127.0.0.1:9001")?
# val (data, sender) = await socket.recv_from(1024)?
# await socket.close()?
```

## Sync vs Async

```simple
# Sync:
#   val socket = UdpSocket.bind("127.0.0.1:0")?
#   socket.send_to(data, addr)?
#
# Async â€” same names, just add await:
#   val socket = await AsyncUdpSocket.bind("127.0.0.1:0")?
#   await socket.send_to(data, addr)?
```
"""

use std.common.io.async_traits.{AsyncClose}
use std.common.io.types.{IoError, IoErrorKind, Interest}
use std.nogc_async_mut.io.event_loop.{EventLoop, Waker}
use std.async.future.{Future}

# ============================================================================
# Shared Event Loop
# ============================================================================

var global_loop: EventLoop? = nil

fn get_loop() -> EventLoop:
    """Get or create the global event loop."""
    if not global_loop.?:
        val loop = EventLoop.new()
        match loop:
            case Ok(l):
                global_loop = Some(l)
            case Err(e):
                panic("failed to create event loop: {e.to_string()}")
    global_loop.unwrap()

# ============================================================================
# AsyncUdpSocket - Non-Blocking UDP Socket
# ============================================================================

class AsyncUdpSocket with AsyncClose:
    """Non-blocking UDP datagram socket using epoll.

    Example:
        val socket = await AsyncUdpSocket.bind("0.0.0.0:9000")?
        val (data, sender) = await socket.recv_from(1024)?
        await socket.send_to(data, sender)?
        await socket.close()?
    """
    fd: i64
    loop: EventLoop
    open: bool

    static fn bind(addr: text) -> Future<Result<AsyncUdpSocket, IoError>>:
        """Bind to address (non-blocking).

        Args:
            addr: Address in "host:port" format

        Returns:
            Future with Result containing AsyncUdpSocket
        """
        val loop = get_loop()
        val fd = rt_io_udp_bind(addr)
        if fd < 0:
            return Future.from_value(Err(IoError.new(IoErrorKind.AddrInUse, "udp bind failed: {addr}")))
        val ok = rt_socket_set_nonblocking(fd, true)
        if not ok:
            rt_io_udp_close(fd)
            return Future.from_value(Err(IoError.new(IoErrorKind.Other, "set_nonblocking failed")))
        Future.from_value(Ok(AsyncUdpSocket(fd: fd, loop: loop, open: true)))

    # --- Datagram operations (epoll-driven) ---

    fn recv_from(size: i64) -> Future<Result<([u8], text), IoError>>:
        """Receive datagram with sender address (non-blocking).

        Args:
            size: Maximum bytes to receive

        Returns:
            Future with (data, sender_address) tuple
        """
        if not self.open:
            return Future.from_value(Err(IoError.new(IoErrorKind.Other, "socket is closed")))
        rt_async_udp_recv_from(self.fd, size, self.loop)

    fn send_to(data: [u8], addr: text) -> Future<Result<i64, IoError>>:
        """Send datagram to address (non-blocking).

        Args:
            data: Bytes to send
            addr: Destination address

        Returns:
            Future with bytes sent
        """
        if not self.open:
            return Future.from_value(Err(IoError.new(IoErrorKind.Other, "socket is closed")))
        rt_async_udp_send_to(self.fd, data, addr, self.loop)

    fn connect(addr: text) -> Result<(), IoError>:
        """Set default peer address (sync).

        Args:
            addr: Remote address

        Returns:
            Result or error
        """
        if not self.open:
            return Err(IoError.new(IoErrorKind.Other, "socket is closed"))
        val ok = rt_io_udp_connect(self.fd, addr)
        if not ok:
            return Err(IoError.new(IoErrorKind.Other, "udp connect failed: {addr}"))
        Ok(())

    fn send(data: [u8]) -> Future<Result<i64, IoError>>:
        """Send to connected peer (non-blocking).

        Args:
            data: Bytes to send

        Returns:
            Future with bytes sent
        """
        if not self.open:
            return Future.from_value(Err(IoError.new(IoErrorKind.Other, "socket is closed")))
        rt_async_udp_send(self.fd, data, self.loop)

    fn recv(size: i64) -> Future<Result<[u8], IoError>>:
        """Receive from connected peer (non-blocking).

        Args:
            size: Maximum bytes to receive

        Returns:
            Future with bytes
        """
        if not self.open:
            return Future.from_value(Err(IoError.new(IoErrorKind.Other, "socket is closed")))
        rt_async_udp_recv(self.fd, size, self.loop)

    fn local_addr() -> Result<text, IoError>:
        """Get local bound address (sync)."""
        val addr = rt_io_udp_local_addr(self.fd)
        if addr == nil:
            return Err(IoError.new(IoErrorKind.Other, "local_addr failed"))
        Ok(addr)

    fn set_broadcast(enabled: bool) -> Result<(), IoError>:
        """Enable/disable broadcast (sync)."""
        val ok = rt_io_udp_set_broadcast(self.fd, enabled)
        if not ok:
            return Err(IoError.new(IoErrorKind.Other, "set_broadcast failed"))
        Ok(())

    # --- AsyncClose trait ---

    me close() -> Future<Result<(), IoError>>:
        """Close socket."""
        if not self.open:
            return Future.from_value(Ok(()))
        self.loop.deregister(self.fd)?
        val ok = rt_io_udp_close(self.fd)
        self.open = false
        if not ok:
            return Future.from_value(Err(IoError.new(IoErrorKind.Other, "close failed")))
        Future.from_value(Ok(()))

    fn is_open() -> bool:
        """Check if socket is open."""
        self.open

# ============================================================================
# FFI Functions
# ============================================================================

# Sync helpers
extern fn rt_io_udp_bind(addr: text) -> i64
extern fn rt_io_udp_connect(fd: i64, addr: text) -> bool
extern fn rt_io_udp_local_addr(fd: i64) -> text?
extern fn rt_io_udp_set_broadcast(fd: i64, enabled: bool) -> bool
extern fn rt_io_udp_close(fd: i64) -> bool
extern fn rt_socket_set_nonblocking(fd: i64, enabled: bool) -> bool

# Async operations (return Future via runtime)
extern fn rt_async_udp_recv_from(fd: i64, size: i64, loop: EventLoop) -> Future<Result<([u8], text), IoError>>
extern fn rt_async_udp_send_to(fd: i64, data: [u8], addr: text, loop: EventLoop) -> Future<Result<i64, IoError>>
extern fn rt_async_udp_send(fd: i64, data: [u8], loop: EventLoop) -> Future<Result<i64, IoError>>
extern fn rt_async_udp_recv(fd: i64, size: i64, loop: EventLoop) -> Future<Result<[u8], IoError>>

# ============================================================================
# Exports
# ============================================================================

export AsyncUdpSocket
