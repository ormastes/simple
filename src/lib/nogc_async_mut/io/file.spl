"""
# Async File I/O

Async file handle using thread pool offload (files don't support epoll).
Wraps sync FileHandle and dispatches operations to a thread pool.

## Components

| Type | Traits | Description |
|------|--------|-------------|
| AsyncFileHandle | AsyncRead, AsyncWrite, AsyncSeek, AsyncClose | Thread-pool async file |
| AsyncFile | (static) | One-shot async convenience methods |
| ThreadPool | — | Worker thread pool for blocking offload |

## Handle-Based Usage

```simple
# val fh = await AsyncFileHandle.open("data.txt", FileMode.ReadOnly)?
# val content = await fh.read_text()?
# await fh.close()?
```

## Static Convenience

```simple
# val text = await AsyncFile.read("config.sdn")?
# await AsyncFile.write("output.txt", text)?
```

## Async Mirrors Sync

```simple
# Sync:
#   val fh = FileHandle.open("data.txt", FileMode.ReadOnly)?
#   val text = fh.read_text()?
#   fh.close()?
#
# Async — same names, just add await:
#   val fh = await AsyncFileHandle.open("data.txt", FileMode.ReadOnly)?
#   val text = await fh.read_text()?
#   await fh.close()?
```

## Thread Pool

```simple
# val pool = ThreadPool.new(4)
# val result = await pool.spawn(\\: expensive_computation())
```
"""

use std.common.io.async_traits.{AsyncRead, AsyncWrite, AsyncSeek, AsyncClose}
use std.common.io.error.{IoError, IoErrorKind, SeekFrom}
use std.nogc_sync_mut.io.file.{FileHandle, FileMode, FileMetadata}
use std.async.future.{Future}

# ============================================================================
# ThreadPool - Minimal Thread Pool for File I/O
# ============================================================================

class ThreadPool:
    """Thread pool for offloading blocking file I/O.

    Example:
        val pool = ThreadPool.new(4)
        val result = await pool.spawn(\: heavy_computation())
    """
    size: i64

    static fn new(size: i64) -> ThreadPool:
        """Create thread pool.

        Args:
            size: Number of worker threads

        Returns:
            ThreadPool
        """
        rt_thread_pool_create(size)
        ThreadPool(size: size)

    static fn default() -> ThreadPool:
        """Create default thread pool (4 threads)."""
        ThreadPool.new(4)

    fn spawn<T>(task: fn() -> T) -> Future<T>:
        """Submit task to thread pool.

        Args:
            task: Closure to run on pool thread

        Returns:
            Future that resolves when task completes
        """
        rt_thread_pool_spawn(task)

# Default global pool
var global_pool: ThreadPool? = nil

fn get_pool() -> ThreadPool:
    """Get or create the global thread pool."""
    if not global_pool.?:
        global_pool = Some(ThreadPool.default())
    global_pool.unwrap()

# ============================================================================
# AsyncFileHandle - Async File Handle
# ============================================================================

class AsyncFileHandle with AsyncRead, AsyncWrite, AsyncSeek, AsyncClose:
    """Async file handle with thread pool offload.

    All operations are dispatched to a thread pool since
    regular files don't support epoll/non-blocking I/O.

    Example:
        val fh = await AsyncFileHandle.open("data.txt", FileMode.ReadOnly)?
        val text = await fh.read_text()?
        await fh.close()?
    """
    inner: FileHandle
    pool: ThreadPool

    # --- Factory ---

    static fn open(path: text, mode: FileMode) -> Future<Result<AsyncFileHandle, IoError>>:
        """Open file asynchronously.

        Args:
            path: File path
            mode: Open mode

        Returns:
            Future with Result containing AsyncFileHandle
        """
        val pool = get_pool()
        pool.spawn(\:
            val inner = FileHandle.open(path, mode)?
            Ok(AsyncFileHandle(inner: inner, pool: pool))
        )

    static fn read_file(path: text) -> Future<Result<AsyncFileHandle, IoError>>:
        """Open file for reading asynchronously."""
        AsyncFileHandle.open(path, FileMode.ReadOnly)

    static fn create(path: text) -> Future<Result<AsyncFileHandle, IoError>>:
        """Create file for writing asynchronously."""
        AsyncFileHandle.open(path, FileMode.WriteOnly)

    # --- AsyncRead (thread pool offload) ---

    fn read(size: i64) -> Future<Result<[u8], IoError>>:
        """Read up to size bytes asynchronously."""
        self.pool.spawn(\: self.inner.read(size))

    fn read_exact(size: i64) -> Future<Result<[u8], IoError>>:
        """Read exactly size bytes asynchronously."""
        self.pool.spawn(\: self.inner.read_exact(size))

    fn read_all() -> Future<Result<[u8], IoError>>:
        """Read all remaining bytes asynchronously."""
        self.pool.spawn(\: self.inner.read_all())

    fn read_text() -> Future<Result<text, IoError>>:
        """Read all content as text asynchronously."""
        self.pool.spawn(\: self.inner.read_text())

    fn read_line() -> Future<Result<text, IoError>>:
        """Read a single line asynchronously."""
        self.pool.spawn(\: self.inner.read_line())

    # --- AsyncWrite (thread pool offload) ---

    fn write(data: [u8]) -> Future<Result<i64, IoError>>:
        """Write bytes asynchronously."""
        self.pool.spawn(\: self.inner.write(data))

    fn write_all(data: [u8]) -> Future<Result<(), IoError>>:
        """Write all bytes asynchronously."""
        self.pool.spawn(\: self.inner.write_all(data))

    fn write_text(s: text) -> Future<Result<(), IoError>>:
        """Write text asynchronously."""
        self.pool.spawn(\: self.inner.write_text(s))

    fn flush() -> Future<Result<(), IoError>>:
        """Flush to disk asynchronously."""
        self.pool.spawn(\: self.inner.flush())

    # --- AsyncSeek (thread pool offload) ---

    fn seek(pos: SeekFrom) -> Future<Result<i64, IoError>>:
        """Seek to position asynchronously."""
        self.pool.spawn(\: self.inner.seek(pos))

    fn position() -> Future<Result<i64, IoError>>:
        """Get current position asynchronously."""
        self.pool.spawn(\: self.inner.position())

    fn rewind() -> Future<Result<(), IoError>>:
        """Seek to beginning asynchronously."""
        self.pool.spawn(\: self.inner.rewind())

    # --- AsyncClose (thread pool offload) ---

    me close() -> Future<Result<(), IoError>>:
        """Close file handle asynchronously."""
        self.pool.spawn(\: self.inner.close())

    fn is_open() -> bool:
        """Check if file handle is open (sync)."""
        self.inner.is_open()

    # --- File-specific ---

    fn metadata() -> Future<Result<FileMetadata, IoError>>:
        """Get file metadata asynchronously."""
        self.pool.spawn(\: self.inner.metadata())

    fn size() -> Future<Result<i64, IoError>>:
        """Get file size asynchronously."""
        self.pool.spawn(\: self.inner.size())

# ============================================================================
# AsyncFile - Static Convenience
# ============================================================================

class AsyncFile:
    """One-shot async file operations.

    Example:
        val text = await AsyncFile.read("config.sdn")?
        await AsyncFile.write("output.txt", text)?
    """

    static fn read(path: text) -> Future<Result<text, IoError>>:
        """Read entire file as text asynchronously."""
        val pool = get_pool()
        pool.spawn(\:
            val fh = FileHandle.read_file(path)?
            val content = fh.read_text()?
            fh.close()?
            Ok(content)
        )

    static fn read_bytes(path: text) -> Future<Result<[u8], IoError>>:
        """Read entire file as bytes asynchronously."""
        val pool = get_pool()
        pool.spawn(\:
            val fh = FileHandle.read_file(path)?
            val data = fh.read_all()?
            fh.close()?
            Ok(data)
        )

    static fn write(path: text, content: text) -> Future<Result<(), IoError>>:
        """Write text to file asynchronously."""
        val pool = get_pool()
        pool.spawn(\:
            val fh = FileHandle.create(path)?
            fh.write_text(content)?
            fh.close()?
            Ok(())
        )

    static fn write_bytes(path: text, data: [u8]) -> Future<Result<(), IoError>>:
        """Write bytes to file asynchronously."""
        val pool = get_pool()
        pool.spawn(\:
            val fh = FileHandle.create(path)?
            fh.write_all(data)?
            fh.close()?
            Ok(())
        )

    static fn exists(path: text) -> Future<bool>:
        """Check if file exists asynchronously."""
        val pool = get_pool()
        pool.spawn(\: rt_io_file_exists(path))

    static fn delete(path: text) -> Future<Result<(), IoError>>:
        """Delete file asynchronously."""
        val pool = get_pool()
        pool.spawn(\:
            val ok = rt_io_file_delete(path)
            if not ok:
                return Err(IoError.new(IoErrorKind.NotFound, "delete failed: {path}"))
            Ok(())
        )

# ============================================================================
# FFI Functions
# ============================================================================

extern fn rt_thread_pool_create(size: i64)
extern fn rt_thread_pool_spawn<T>(task: fn() -> T) -> Future<T>
extern fn rt_io_file_exists(path: text) -> bool
extern fn rt_io_file_delete(path: text) -> bool

# ============================================================================
# Exports
# ============================================================================

export ThreadPool
export AsyncFileHandle
export AsyncFile
