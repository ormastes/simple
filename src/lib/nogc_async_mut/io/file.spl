# Async file I/O stub for bootstrap
#
# The Rust seed compiler used during bootstrap cannot parse the full async
# file implementation (generic extern signatures). For bootstrap purposes we
# provide a minimal, synchronous stub that preserves the public surface used
# by the compiler and stdlib. Once the final self-hosted compiler is built,
# the full implementation can replace this stub.

use std.async.future.{Future}

class ThreadPool:
    size: i64

    static fn new(size: i64) -> ThreadPool:
        ThreadPool(size: size)

    static fn default() -> ThreadPool:
        ThreadPool.new(4)

    fn exec(task: fn() -> i64) -> Future<i64>:
        # Execute synchronously for bootstrap; wrap result in ready future.
        Future.from_value(task())

class AsyncFileHandle:
    fd: i64

    static fn open(path: text, mode: i64) -> Future<AsyncFileHandle>:
        # Stub: always fail (fd = -1)
        Future.from_value(AsyncFileHandle(fd: -1))

    me close() -> Future<i64>:
        Future.from_value(0)

class AsyncFile:
    static fn read(path: text) -> Future<text>:
        Future.from_value("")

    static fn write(path: text, content: text) -> Future<bool>:
        Future.from_value(false)

export ThreadPool, AsyncFileHandle, AsyncFile
