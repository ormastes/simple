# Pure Simple AST
# Abstract Syntax Tree definitions

export Expr, Stmt, Pattern, TypeExpr, Module
export BinOp, UnaryOp, Literal

# Binary operators
enum BinOp:
    # Arithmetic
    Add
    Sub
    Mul
    Div
    Mod
    Pow
    # Comparison
    Eq
    NotEq
    Lt
    Gt
    LtEq
    GtEq
    # Logical
    And
    Or
    # Bitwise
    BitAnd
    BitOr
    BitXor
    BitShl
    BitShr
    # Pipeline
    Pipe
    ComposeForward
    ComposeBackward
    LayerConnect
    Parallel
    # Optional
    OptionalChain
    Coalesce
    # Broadcast
    BroadcastAdd
    BroadcastSub
    BroadcastMul
    BroadcastDiv
    BroadcastPow
    # Other
    MatMul
    Range
    RangeInclusive

# Unary operators
enum UnaryOp:
    Neg
    Not

# Literals
enum Literal:
    Int(i64)
    Float(text)
    String(text)
    Bool(bool)
    Unit

# Expressions
enum Expr:
    Literal(Literal)
    Identifier(text)
    Binary(BinOp, Expr, Expr)
    Unary(UnaryOp, Expr)
    Call(Expr, [Expr])
    Lambda([text], Expr)
    List([Expr])
    Tuple([Expr])
    Index(Expr, Expr)
    Slice(Expr, Expr?, Expr?, Expr?)  # obj[start:end:step]
    Field(Expr, text)
    Method(Expr, text, [Expr])  # obj.method(args)
    StringInterpolation([Expr])  # "Hello {name}" as parts
    If(Expr, Expr, Expr)
    MatchCase(Expr, [(Pattern, Expr)])
    Block([Stmt])

# Patterns
enum Pattern:
    Wildcard
    Identifier(text)
    Literal(Literal)
    Tuple([Pattern])
    Constructor(text, [Pattern])

# Type expressions
enum TypeExpr:
    Named(text)
    Generic(text, [TypeExpr])
    Function([TypeExpr], TypeExpr)
    Tuple([TypeExpr])

# Statements
enum Stmt:
    Expr(Expr)
    Let(text, TypeExpr?, Expr)
    Assign(text, Expr)
    Return(Expr?)
    While(Expr, [Stmt])
    For(text, Expr, [Stmt])
    Function(text, [text], TypeExpr?, [Stmt])
    Struct(text, [(text, TypeExpr)])
    Enum(text, [(text, [TypeExpr])])
    Import(text, [text])  # use module.{name1, name2}
    Export([text])  # export name1, name2

# Module
struct Module:
    statements: [Stmt]
