# Pure Simple Model Serialization
#
# Serialize and deserialize tensors and model checkpoints
# to a simple text-based format for saving/loading.
#
# Format:
#   Single tensor: "SHAPE:d1,d2,...\nDATA:v1,v2,..."
#   Multiple tensors: separated by "---\n"
#   Checkpoint: "EPOCH:N\nLR:X.Y\n" header followed by tensor data
#
# NOTE: This module uses generics (PureTensor<f64>) and will only work
# in compiled mode, not in the interpreter (runtime parser limitation).

use std.pure.tensor.{PureTensor, tensor_from_data}

extern fn rt_file_write_text(path: text, content: text) -> text
extern fn rt_file_read_text(path: text) -> text

# ============================================================================
# Helpers: Float/Text conversion
# ============================================================================

fn _ser_float_to_text(v: f64) -> text:
    """Convert f64 to text using string interpolation."""
    "{v}"

fn _ser_text_to_float(s: text) -> f64:
    """Parse text to f64 using manual decimal parsing.

    Handles: integers, decimals, negative numbers.
    Returns 0.0 for unparseable input.
    """
    val trimmed = s.trim()
    if trimmed.len() == 0:
        return 0.0

    var negative = false
    var start = 0
    if trimmed[0:1] == "-":
        negative = true
        start = 1

    var int_part = 0.0
    var frac_part = 0.0
    var frac_divisor = 1.0
    var in_frac = false
    var i = start
    while i < trimmed.len():
        val ch = trimmed[i:i + 1]
        if ch == ".":
            in_frac = true
        else:
            val d = _ser_digit_value(ch)
            if d < 0:
                return 0.0
            if in_frac:
                frac_divisor = frac_divisor * 10.0
                frac_part = frac_part + d / frac_divisor
            else:
                int_part = int_part * 10.0 + d
        i = i + 1

    val result = int_part + frac_part
    if negative: -result else: result

fn _ser_digit_value(ch: text) -> f64:
    """Get numeric value of a digit character. Returns -1.0 for non-digits."""
    if ch == "0": return 0.0
    if ch == "1": return 1.0
    if ch == "2": return 2.0
    if ch == "3": return 3.0
    if ch == "4": return 4.0
    if ch == "5": return 5.0
    if ch == "6": return 6.0
    if ch == "7": return 7.0
    if ch == "8": return 8.0
    if ch == "9": return 9.0
    return -1.0

# ============================================================================
# Single Tensor Serialization
# ============================================================================

fn serialize_tensor(t: PureTensor<f64>) -> text:
    """Serialize a single tensor to text format.

    Format: "SHAPE:d1,d2,...\\nDATA:v1,v2,..."

    Args:
        t - Tensor to serialize

    Returns:
        Text representation of tensor
    """
    # Build shape string
    var shape_str = "SHAPE:"
    var i = 0
    while i < t.shape.len():
        if i > 0:
            shape_str = shape_str + ","
        shape_str = shape_str + "{t.shape[i]}"
        i = i + 1

    # Build data string
    var data_str = "DATA:"
    i = 0
    while i < t.data.len():
        if i > 0:
            data_str = data_str + ","
        data_str = data_str + _ser_float_to_text(t.data[i])
        i = i + 1

    shape_str + "\n" + data_str

fn deserialize_tensor(s: text) -> PureTensor<f64>:
    """Deserialize a single tensor from text format.

    Args:
        s - Text representation (SHAPE:..\\nDATA:..)

    Returns:
        Reconstructed tensor
    """
    # Split on newline to get SHAPE and DATA lines
    var shape_line = ""
    var data_line = ""
    var current = ""
    var found_newline = false
    var i = 0
    while i < s.len():
        val ch = s[i:i + 1]
        if ch == "\n" and found_newline == false:
            shape_line = current
            current = ""
            found_newline = true
        else:
            current = current + ch
        i = i + 1
    data_line = current

    # Parse shape: remove "SHAPE:" prefix, split on comma
    val shape_content = shape_line[6:shape_line.len()]
    var shape: [i64] = []
    var num_str = ""
    i = 0
    while i < shape_content.len():
        val ch = shape_content[i:i + 1]
        if ch == ",":
            shape.push(int(num_str))
            num_str = ""
        else:
            num_str = num_str + ch
        i = i + 1
    if num_str.len() > 0:
        shape.push(int(num_str))

    # Parse data: remove "DATA:" prefix, split on comma
    val data_content = data_line[5:data_line.len()]
    var data: [f64] = []
    num_str = ""
    i = 0
    while i < data_content.len():
        val ch = data_content[i:i + 1]
        if ch == ",":
            data.push(_ser_text_to_float(num_str))
            num_str = ""
        else:
            num_str = num_str + ch
        i = i + 1
    if num_str.len() > 0:
        data.push(_ser_text_to_float(num_str))

    tensor_from_data(data, shape)

# ============================================================================
# Multiple Tensor Serialization
# ============================================================================

fn serialize_tensors(tensors: [PureTensor<f64>]) -> text:
    """Serialize multiple tensors to text, separated by '---'.

    Args:
        tensors - List of tensors to serialize

    Returns:
        Text with tensors separated by ---
    """
    var result = ""
    var i = 0
    while i < tensors.len():
        if i > 0:
            result = result + "\n---\n"
        result = result + serialize_tensor(tensors[i])
        i = i + 1
    result

fn deserialize_tensors(s: text) -> [PureTensor<f64>]:
    """Deserialize multiple tensors from text.

    Args:
        s - Text with tensors separated by ---

    Returns:
        List of reconstructed tensors
    """
    var tensors: [PureTensor<f64>] = []
    var current = ""
    var i = 0
    while i < s.len():
        # Check for "\n---\n" separator (5 chars)
        if (i + 4 < s.len() and
            s[i:i + 5] == "\n---\n"):
            tensors.push(deserialize_tensor(current))
            current = ""
            i = i + 5
        else:
            current = current + s[i:i + 1]
            i = i + 1
    if current.len() > 0:
        tensors.push(deserialize_tensor(current))
    tensors

# ============================================================================
# File I/O
# ============================================================================

fn save_parameters(tensors: [PureTensor<f64>], path: text):
    """Save model parameters to file.

    Args:
        tensors - List of parameter tensors
        path - File path to save to
    """
    val content = serialize_tensors(tensors)
    rt_file_write_text(path, content)

fn load_parameters(path: text) -> [PureTensor<f64>]:
    """Load model parameters from file.

    Args:
        path - File path to load from

    Returns:
        List of parameter tensors
    """
    val content = rt_file_read_text(path)
    deserialize_tensors(content)

# ============================================================================
# Checkpoint Support
# ============================================================================

fn save_checkpoint(tensors: [PureTensor<f64>], lr: f64, epoch: i64, path: text):
    """Save training checkpoint with metadata.

    Format: EPOCH:N\\nLR:X.Y\\n followed by serialized tensors.

    Args:
        tensors - Model parameter tensors
        lr - Current learning rate
        epoch - Current epoch number
        path - File path to save to
    """
    var header = "EPOCH:{epoch}\nLR:{lr}\n"
    val tensor_data = serialize_tensors(tensors)
    val content = header + tensor_data
    rt_file_write_text(path, content)

fn load_checkpoint_epoch(s: text) -> i64:
    """Extract epoch number from checkpoint text.

    Args:
        s - Checkpoint text content

    Returns:
        Epoch number
    """
    # Find EPOCH: line
    var i = 0
    while i < s.len():
        if i + 6 <= s.len() and s[i:i + 6] == "EPOCH:":
            # Read until newline
            var num_str = ""
            var j = i + 6
            while j < s.len():
                val ch = s[j:j + 1]
                if ch == "\n":
                    return int(num_str)
                num_str = num_str + ch
                j = j + 1
            return int(num_str)
        i = i + 1
    return 0

fn load_checkpoint_lr(s: text) -> f64:
    """Extract learning rate from checkpoint text.

    Args:
        s - Checkpoint text content

    Returns:
        Learning rate value
    """
    # Find LR: line
    var i = 0
    while i < s.len():
        if i + 3 <= s.len() and s[i:i + 3] == "LR:":
            # Read until newline
            var num_str = ""
            var j = i + 3
            while j < s.len():
                val ch = s[j:j + 1]
                if ch == "\n":
                    return _ser_text_to_float(num_str)
                num_str = num_str + ch
                j = j + 1
            return _ser_text_to_float(num_str)
        i = i + 1
    return 0.0

# ============================================================================
# Exports
# ============================================================================

export serialize_tensor, deserialize_tensor
export serialize_tensors, deserialize_tensors
export save_parameters, load_parameters
export save_checkpoint, load_checkpoint_epoch, load_checkpoint_lr
export _ser_float_to_text, _ser_text_to_float
