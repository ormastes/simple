# Tests for Pure Simple Tensor Implementation

use std.pure.tensor (PureTensor, compute_strides, broadcast_shapes, zeros_like, ones_like, total_elements)

describe "Pure Simple Tensors":
    describe "Creation":
        it "creates tensor with zeros":
            val t = PureTensor.zeros([2, 3])
            assert t.shape == [2, 3]
            assert t.numel() == 6
            assert t.data.len() == 6
            assert t.data.all(\x: x == 0.0)

        it "creates tensor with ones":
            val t = PureTensor.ones([3, 2])
            assert t.shape == [3, 2]
            assert t.numel() == 6
            assert t.data.all(\x: x == 1.0)

        it "creates tensor from data":
            val data = [1.0, 2.0, 3.0, 4.0]
            val t = PureTensor.from_data(data, [2, 2])
            assert t.shape == [2, 2]
            assert t.numel() == 4
            assert t.data == [1.0, 2.0, 3.0, 4.0]

        it "creates 1D tensor":
            val t = PureTensor.zeros([5])
            assert t.shape == [5]
            assert t.numel() == 5

        it "creates 3D tensor":
            val t = PureTensor.zeros([2, 3, 4])
            assert t.shape == [2, 3, 4]
            assert t.numel() == 24

    describe "Indexing":
        it "gets element from 1D tensor":
            val t = PureTensor.from_data([1.0, 2.0, 3.0], [3])
            assert t.get([0]) == 1.0
            assert t.get([1]) == 2.0
            assert t.get([2]) == 3.0

        it "gets element from 2D tensor":
            val t = PureTensor.from_data([1.0, 2.0, 3.0, 4.0], [2, 2])
            assert t.get([0, 0]) == 1.0
            assert t.get([0, 1]) == 2.0
            assert t.get([1, 0]) == 3.0
            assert t.get([1, 1]) == 4.0

        it "sets element in 2D tensor":
            val t = PureTensor.zeros([2, 2])
            t.set([0, 0], 5.0)
            t.set([1, 1], 7.0)
            assert t.get([0, 0]) == 5.0
            assert t.get([1, 1]) == 7.0
            assert t.get([0, 1]) == 0.0

        it "indexes 3D tensor":
            val t = PureTensor.from_data([1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0], [2, 2, 2])
            assert t.get([0, 0, 0]) == 1.0
            assert t.get([0, 0, 1]) == 2.0
            assert t.get([0, 1, 0]) == 3.0
            assert t.get([1, 1, 1]) == 8.0

    describe "Shape Operations":
        it "computes strides for 2D tensor":
            val strides = compute_strides([3, 4])
            assert strides == [4, 1]

        it "computes strides for 3D tensor":
            val strides = compute_strides([2, 3, 4])
            assert strides == [12, 4, 1]

        it "computes strides for 1D tensor":
            val strides = compute_strides([5])
            assert strides == [1]

        it "reshapes tensor":
            val t = PureTensor.from_data([1.0, 2.0, 3.0, 4.0, 5.0, 6.0], [2, 3])
            val reshaped = t.reshape([3, 2])
            assert reshaped.shape == [3, 2]
            assert reshaped.numel() == 6
            assert reshaped.data == t.data

        it "reshapes to 1D":
            val t = PureTensor.from_data([1.0, 2.0, 3.0, 4.0], [2, 2])
            val flat = t.reshape([4])
            assert flat.shape == [4]
            assert flat.numel() == 4

        it "transposes 2D tensor":
            val t = PureTensor.from_data([1.0, 2.0, 3.0, 4.0, 5.0, 6.0], [2, 3])
            # Original: [[1, 2, 3], [4, 5, 6]]
            # Transposed: [[1, 4], [2, 5], [3, 6]]
            val transposed = t.transpose()
            assert transposed.shape == [3, 2]
            assert transposed.get([0, 0]) == 1.0
            assert transposed.get([0, 1]) == 4.0
            assert transposed.get([1, 0]) == 2.0
            assert transposed.get([2, 1]) == 6.0

    describe "Broadcasting":
        it "broadcasts same shape":
            val result = broadcast_shapes([3, 4], [3, 4])
            assert result == [3, 4]

        it "broadcasts with trailing 1":
            val result = broadcast_shapes([3, 1], [3, 4])
            assert result == [3, 4]

        it "broadcasts with leading 1":
            val result = broadcast_shapes([1, 4], [3, 4])
            assert result == [3, 4]

        it "broadcasts different ranks":
            val result = broadcast_shapes([2, 3, 4], [4])
            assert result == [2, 3, 4]

        it "broadcasts scalar":
            val result = broadcast_shapes([1], [3, 4])
            assert result == [3, 4]

    describe "Utility Functions":
        it "creates zeros_like":
            val t = PureTensor.from_data([1.0, 2.0, 3.0, 4.0], [2, 2])
            val zeros = zeros_like(t)
            assert zeros.shape == [2, 2]
            assert zeros.data.all(\x: x == 0.0)

        it "creates ones_like":
            val t = PureTensor.from_data([1.0, 2.0, 3.0, 4.0], [2, 2])
            val ones = ones_like(t)
            assert ones.shape == [2, 2]
            assert ones.data.all(\x: x == 1.0)

        it "computes total elements":
            assert total_elements([2, 3]) == 6
            assert total_elements([2, 3, 4]) == 24
            assert total_elements([5]) == 5

    describe "String Representation":
        it "shows 1D tensor":
            val t = PureTensor.from_data([1.0, 2.0, 3.0], [3])
            val s = t.to_string()
            assert s.contains("1.0")
            assert s.contains("2.0")

        it "shows 2D tensor":
            val t = PureTensor.from_data([1.0, 2.0, 3.0, 4.0], [2, 2])
            val s = t.to_string()
            assert s.contains("1.0")
            assert s.contains("4.0")

        it "shows 3D tensor shape":
            val t = PureTensor.zeros([2, 3, 4])
            val s = t.to_string()
            assert s.contains("shape")
