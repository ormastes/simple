# Pure Simple Collection Utilities
# Advanced collection operations

export range, take, drop, chunk, flatten
export unique, group_by, partition
export zip, unzip, cartesian_product
export find, find_index, all_match, any_match

# Generate range of numbers
fn range(start: i64, end: i64) -> [i64]:
    var result: [i64] = []
    var i = start
    while i < end:
        result.push(i)
        i = i + 1
    result

# Take first n elements
fn take<T>(list: [T], n: i64) -> [T]:
    if n >= list.len():
        list
    else:
        list[0:n]

# Drop first n elements
fn drop<T>(list: [T], n: i64) -> [T]:
    if n >= list.len():
        []
    else:
        list[n:]

# Split list into chunks
fn chunk<T>(list: [T], size: i64) -> [[T]]:
    var result: [[T]] = []
    var i = 0
    while i < list.len():
        val end = if i + size < list.len(): i + size else: list.len()
        result.push(list[i:end])
        i = i + size
    result

# Flatten nested list
fn flatten<T>(nested: [[T]]) -> [T]:
    var result: [T] = []
    var i = 0
    while i < nested.len():
        var j = 0
        while j < nested[i].len():
            result.push(nested[i][j])
            j = j + 1
        i = i + 1
    result

# Get unique elements
fn unique<T>(list: [T]) -> [T]:
    var result: [T] = []
    var i = 0
    while i < list.len():
        val item = list[i]
        var found = false
        var j = 0
        while j < result.len():
            if result[j] == item:
                found = true
                break
            j = j + 1
        if not found:
            result.push(item)
        i = i + 1
    result

# Group elements by key function
fn group_by<T, K>(list: [T], key_fn: fn(T) -> K) -> [(K, [T])]:
    var groups: [(K, [T])] = []
    var i = 0
    while i < list.len():
        val item = list[i]
        val key = key_fn(item)

        # Find or create group
        var found = false
        var j = 0
        while j < groups.len():
            if groups[j].0 == key:
                groups[j].1.push(item)
                found = true
                break
            j = j + 1

        if not found:
            groups.push((key, [item]))

        i = i + 1
    groups

# Partition list by predicate
fn partition<T>(list: [T], predicate: fn(T) -> bool) -> ([T], [T]):
    var true_list: [T] = []
    var false_list: [T] = []
    var i = 0
    while i < list.len():
        if predicate(list[i]):
            true_list.push(list[i])
        else:
            false_list.push(list[i])
        i = i + 1
    (true_list, false_list)

# Zip two lists together
fn zip<A, B>(list_a: [A], list_b: [B]) -> [(A, B)]:
    var result: [(A, B)] = []
    val min_len = if list_a.len() < list_b.len(): list_a.len() else: list_b.len()
    var i = 0
    while i < min_len:
        result.push((list_a[i], list_b[i]))
        i = i + 1
    result

# Unzip list of pairs
fn unzip<A, B>(pairs: [(A, B)]) -> ([A], [B]):
    var list_a: [A] = []
    var list_b: [B] = []
    var i = 0
    while i < pairs.len():
        list_a.push(pairs[i].0)
        list_b.push(pairs[i].1)
        i = i + 1
    (list_a, list_b)

# Cartesian product
fn cartesian_product<A, B>(list_a: [A], list_b: [B]) -> [(A, B)]:
    var result: [(A, B)] = []
    var i = 0
    while i < list_a.len():
        var j = 0
        while j < list_b.len():
            result.push((list_a[i], list_b[j]))
            j = j + 1
        i = i + 1
    result

# Find first element matching predicate
fn find<T>(list: [T], predicate: fn(T) -> bool) -> T?:
    var i = 0
    while i < list.len():
        if predicate(list[i]):
            return Some(list[i])
        i = i + 1
    nil

# Find index of first matching element
fn find_index<T>(list: [T], predicate: fn(T) -> bool) -> i64?:
    var i = 0
    while i < list.len():
        if predicate(list[i]):
            return Some(i)
        i = i + 1
    nil

# Check if all elements match predicate
fn all_match<T>(list: [T], predicate: fn(T) -> bool) -> bool:
    var i = 0
    while i < list.len():
        if not predicate(list[i]):
            return false
        i = i + 1
    true

# Check if any element matches predicate
fn any_match<T>(list: [T], predicate: fn(T) -> bool) -> bool:
    var i = 0
    while i < list.len():
        if predicate(list[i]):
            return true
        i = i + 1
    false
