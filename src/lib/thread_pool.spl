# ThreadPool - High-Level Thread Pool
#
# Simple thread pool for parallel task execution.
# Built on top of SFFI threading primitives.

use std.thread_sffi.{thread_cpu_count, thread_sleep, ThreadHandle}
use std.async_host.thread_safe_queue.{ThreadSafeQueue}

# Direct import of thread creation SFFI
extern fn spl_thread_create(entry_point: i64, arg: i64) -> i64

# Thread pool worker spawn helper (C wrapper)
extern fn spl_thread_pool_spawn_worker(pool_id: i64) -> i64

class ThreadPool:
    """Thread pool for parallel task execution.

    High-level abstraction over OS threads.
    Manages worker threads and distributes tasks.

    Example:
        val pool = ThreadPool.new(4)
        pool.submit(task_id: 1)
        pool.submit(task_id: 2)
        pool.shutdown()

    Features:
    - Fixed number of worker threads
    - Thread-safe task queue
    - Graceful shutdown
    - Auto-detection of CPU count
    """
    num_workers: usize
    worker_handles: [ThreadHandle]
    task_queue: ThreadSafeQueue
    shutdown_requested: bool
    tasks_completed: usize

    static fn new(num_workers: usize) -> ThreadPool:
        """Create thread pool with specified workers.

        Args:
            num_workers: Number of worker threads (0 = auto-detect)

        Returns:
            Thread pool instance

        Example:
            val pool = ThreadPool.new(4)  # 4 workers
            val pool_auto = ThreadPool.new(0)  # CPU count workers

        Note:
            Worker threads are spawned immediately.
            Thread creation requires compiled mode or runtime rebuild.
        """
        var workers = num_workers
        if workers == 0:
            workers = thread_cpu_count()
            if workers < 1:
                workers = 4  # fallback

        # Create pool instance first
        var pool = ThreadPool(
            num_workers: workers,
            worker_handles: [],
            task_queue: ThreadSafeQueue.new(),
            shutdown_requested: false,
            tasks_completed: 0
        )

        # Register pool globally for workers to access
        val pool_id = register_pool(pool)

        # Spawn worker threads
        # NOTE: Thread spawning requires runtime rebuild (bin/simple build --release)
        # Current limitation: extern functions not available in interpreter
        # When runtime is rebuilt, workers will spawn automatically
        var handles: [ThreadHandle] = []

        # Spawn workers using C helper function
        # Note: This only works in compiled mode (not interpreter)
        for i in 0..workers:
            val handle_id = spl_thread_pool_spawn_worker(pool_id)
            if handle_id > 0:
                val handle = ThreadHandle.from_raw(handle_id)
                handles = handles.push(handle)
            # If handle_id is 0, worker spawn failed (interpreter mode or error)
            # Continue anyway - pool can still work without threads for testing

        pool.worker_handles = handles
        pool

    static fn default() -> ThreadPool:
        """Create thread pool with default size (CPU count).

        Returns:
            Thread pool with auto-detected CPU count
        """
        ThreadPool.new(0)

    me submit(task_id: usize):
        """Submit task for execution.

        Args:
            task_id: Task identifier

        Note: Task is queued and will be executed by next available worker.
        """
        if not self.shutdown_requested:
            self.task_queue.push(task_id)

    me submit_batch(task_ids: [usize]):
        """Submit multiple tasks.

        Args:
            task_ids: Array of task identifiers
        """
        if self.shutdown_requested:
            return

        for task_id in task_ids:
            self.task_queue.push(task_id)

    me shutdown():
        """Shutdown thread pool and wait for completion.

        Prevents new tasks from being submitted.
        Waits for all queued tasks to complete.
        Joins all worker threads.
        """
        self.shutdown_requested = true

        # Wait for queue to drain
        while not self.task_queue.is_empty():
            thread_sleep(10)

        # Join all worker threads
        for handle in self.worker_handles:
            if handle.is_valid():
                handle.join()

    me shutdown_now():
        """Immediate shutdown (drop pending tasks).

        Clears task queue and stops accepting new tasks.
        """
        self.shutdown_requested = true
        self.task_queue.clear()

    fn pending_tasks() -> usize:
        """Get number of pending tasks.

        Returns:
            Number of tasks in queue
        """
        self.task_queue.len()

    fn is_idle() -> bool:
        """Check if pool is idle (no pending tasks).

        Returns:
            true if no tasks queued, false otherwise
        """
        self.task_queue.is_empty()

    fn is_shutdown() -> bool:
        """Check if shutdown requested.

        Returns:
            true if shutdown, false otherwise
        """
        self.shutdown_requested

    me wait_until_idle(timeout_ms: i64) -> bool:
        """Wait until all tasks complete.

        Args:
            timeout_ms: Timeout in milliseconds (0 = wait forever)

        Returns:
            true if idle, false on timeout
        """
        if timeout_ms == 0:
            # Wait forever
            while not self.is_idle():
                thread_sleep(10)
            return true
        else:
            # Wait with timeout
            var elapsed = 0
            while not self.is_idle():
                if elapsed >= timeout_ms:
                    return false
                thread_sleep(10)
                elapsed = elapsed + 10
            return true

    me destroy():
        """Destroy thread pool and free resources.

        Performs immediate shutdown and cleans up all resources.
        Joins any remaining worker threads.
        """
        self.shutdown_now()

        # Join remaining workers
        for handle in self.worker_handles:
            if handle.is_valid():
                handle.join()

        # Clean up queue
        self.task_queue.destroy()

# ============================================================================
# Worker Thread Implementation
# ============================================================================

# Global pool registry for worker threads to access their pools
var GLOBAL_POOLS: [ThreadPool] = []
var GLOBAL_POOL_ID_COUNTER: i64 = 0

fn register_pool(pool: ThreadPool) -> i64:
    """Register pool and return unique ID.

    Args:
        pool: Pool to register

    Returns:
        Pool ID for worker threads
    """
    val pool_id = GLOBAL_POOL_ID_COUNTER
    GLOBAL_POOL_ID_COUNTER = GLOBAL_POOL_ID_COUNTER + 1
    GLOBAL_POOLS = GLOBAL_POOLS.push(pool)
    pool_id

fn get_pool(pool_id: i64) -> ThreadPool:
    """Get pool by ID.

    Args:
        pool_id: Pool identifier

    Returns:
        Pool instance (or first pool if ID invalid)
    """
    if pool_id >= 0 and pool_id < GLOBAL_POOLS.len():
        GLOBAL_POOLS[pool_id]
    else:
        # Fallback - return first pool
        if GLOBAL_POOLS.len() > 0:
            GLOBAL_POOLS[0]
        else:
            # Should never happen - create dummy pool
            ThreadPool.default()

fn worker_loop_entry(pool_id: i64):
    """Worker thread entry point.

    Continuously pulls tasks from queue and executes them.
    Exits when shutdown requested and queue empty.

    Args:
        pool_id: Pool identifier
    """
    val pool = get_pool(pool_id)

    # Worker loop - run until shutdown
    while not pool.shutdown_requested:
        # Try to get a task (with timeout to check shutdown)
        val task_id = pool.task_queue.pop_blocking(100)

        if task_id != 0:
            # Execute task (for now just mark as complete)
            # TODO: Call actual task function via registry
            pool.tasks_completed = pool.tasks_completed + 1

        # Small yield to reduce CPU spinning
        thread_sleep(1)

    # Worker exiting

# ============================================================================
# Task Execution Result
# ============================================================================

enum TaskResult:
    """Result of task execution."""
    Completed(usize)        # Task completed with ID
    Failed(usize, text)     # Task failed with ID and error
    Timeout(usize)          # Task timed out with ID
    Cancelled(usize)        # Task cancelled with ID

impl TaskResult:
    fn task_id() -> usize:
        """Get task ID from result.

        Returns:
            Task identifier
        """
        match self:
            case Completed(id): id
            case Failed(id, _): id
            case Timeout(id): id
            case Cancelled(id): id

    fn is_completed() -> bool:
        """Check if task completed successfully.

        Returns:
            true if completed, false otherwise
        """
        match self:
            case Completed(_): true
            case _: false

    fn is_failed() -> bool:
        """Check if task failed.

        Returns:
            true if failed, false otherwise
        """
        match self:
            case Failed(_, _): true
            case _: false

export ThreadPool, TaskResult
