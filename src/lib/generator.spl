# Standard Library â€” Generator Protocol
#
# @tag:api
# @tag:stdlib
#
# Wraps the existing iterator infrastructure to provide a generator protocol.
# Users write explicit state machines; generators are lazy by default.
#
# Usage:
#   val naturals = generator(0, fn(n): (n + 1, true))
#   take(naturals, 5)  # [0, 1, 2, 3, 4]
#
#   val fib = generator([0, 1], fn(state):
#       val next = [state[1], state[0] + state[1]]
#       (next, true)
#   )
#   take(fib, 5)  # [[0,1], [1,1], [1,2], [2,3], [3,5]]

use std.iterator.create.{iter_from_function}
use std.iterator.transform.{iter_take}
use std.iterator.reduce.{iter_collect}

# Create a generator from an initial state and a step function.
# step_fn receives current state, returns (next_state, should_continue).
fn generator(initial, step_fn):
    iter_from_function(initial, step_fn)

# Create a generator that yields integers from start up to (not including) end_val.
fn generate_range(start, end_val):
    generator(start, fn(n): (n + 1, n < end_val))

# Create an infinite generator that always yields the same value.
fn generate_repeat(value):
    generator(value, fn(v): (v, true))

# Collect the first n values from a generator into an array.
fn take(gen, n):
    iter_collect(iter_take(gen, n))

export generator, generate_range, generate_repeat, take
