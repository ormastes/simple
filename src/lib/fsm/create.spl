# FSM Creation Functions

fn create_fsm() -> FSM:
    """Create a new empty finite state machine."""
    FSM(
        states: [],
        transitions: [],
        initial_state: "",
        current: "",
        alphabet: [],
        deterministic: true
    )

fn add_state(fsm: FSM, name: text, accepting: bool) -> FSM:
    """Add a new state to the FSM. Returns updated FSM."""
    var new_state = FSMState(name: name, accepting: accepting, data: "")
    var new_states = fsm.states

    # Check if state already exists
    var found = false
    for i in 0..new_states.len():
        if new_states[i].name == name:
            found = true

    if not found:
        new_states = new_states + [new_state]

    FSM(
        states: new_states,
        transitions: fsm.transitions,
        initial_state: fsm.initial_state,
        current: fsm.current,
        alphabet: fsm.alphabet,
        deterministic: fsm.deterministic
    )

fn add_state_with_data(fsm: FSM, name: text, accepting: bool, data: text) -> FSM:
    """Add a new state with metadata to the FSM."""
    var new_state = FSMState(name: name, accepting: accepting, data: data)
    var new_states = fsm.states

    # Check if state already exists
    var found = false
    var found_idx = -1
    for i in 0..new_states.len():
        if new_states[i].name == name:
            found = true
            found_idx = i

    if found:
        # Replace existing state
        var temp_states: [FSMState] = []
        for i in 0..new_states.len():
            if i == found_idx:
                temp_states = temp_states + [new_state]
            else:
                temp_states = temp_states + [new_states[i]]
        new_states = temp_states
    else:
        new_states = new_states + [new_state]

    FSM(
        states: new_states,
        transitions: fsm.transitions,
        initial_state: fsm.initial_state,
        current: fsm.current,
        alphabet: fsm.alphabet,
        deterministic: fsm.deterministic
    )

fn set_initial_state(fsm: FSM, state_name: text) -> FSM:
    """Set the initial state of the FSM."""
    FSM(
        states: fsm.states,
        transitions: fsm.transitions,
        initial_state: state_name,
        current: state_name,
        alphabet: fsm.alphabet,
        deterministic: fsm.deterministic
    )

fn add_transition(fsm: FSM, from_state: text, to_state: text, symbol: text) -> FSM:
    """Add a transition between two states on a given symbol."""
    var new_transition = FSMTransition(
        from_state: from_state,
        to_state: to_state,
        symbol: symbol,
        priority: 0
    )

    var new_transitions = fsm.transitions + [new_transition]

    # Update alphabet if symbol is not epsilon
    var new_alphabet = fsm.alphabet
    if symbol != "epsilon" and symbol != "":
        var symbol_exists = false
        for i in 0..new_alphabet.len():
            if new_alphabet[i] == symbol:
                symbol_exists = true
        if not symbol_exists:
            new_alphabet = new_alphabet + [symbol]

    # Check if still deterministic
    var still_det = fsm.deterministic
    if still_det and symbol != "epsilon" and symbol != "":
        # Check if there's already a transition from from_state on symbol
        for i in 0..fsm.transitions.len():
            var trans = fsm.transitions[i]
            if trans.from_state == from_state and trans.symbol == symbol:
                still_det = false

    FSM(
        states: fsm.states,
        transitions: new_transitions,
        initial_state: fsm.initial_state,
        current: fsm.current,
        alphabet: new_alphabet,
        deterministic: still_det
    )

fn add_transition_with_priority(fsm: FSM, from_state: text, to_state: text, symbol: text, priority: i64) -> FSM:
    """Add a transition with explicit priority for disambiguation."""
    var new_transition = FSMTransition(
        from_state: from_state,
        to_state: to_state,
        symbol: symbol,
        priority: priority
    )

    var new_transitions = fsm.transitions + [new_transition]
    var new_alphabet = fsm.alphabet

    if symbol != "epsilon" and symbol != "":
        var symbol_exists = false
        for i in 0..new_alphabet.len():
            if new_alphabet[i] == symbol:
                symbol_exists = true
        if not symbol_exists:
            new_alphabet = new_alphabet + [symbol]

    FSM(
        states: fsm.states,
        transitions: new_transitions,
        initial_state: fsm.initial_state,
        current: fsm.current,
        alphabet: new_alphabet,
        deterministic: false  # Explicit priorities suggest non-determinism
    )

# State Query Functions

fn get_state_by_name(fsm: FSM, name: text) -> FSMState:
    """Get state by name. Returns dummy state if not found."""
    for i in 0..fsm.states.len():
        if fsm.states[i].name == name:
            return fsm.states[i]
    FSMState(name: "", accepting: false, data: "")

fn get_all_states(fsm: FSM) -> [text]:
    """Get list of all state names."""
    var names: [text] = []
    for i in 0..fsm.states.len():
        names = names + [fsm.states[i].name]
    names

fn get_alphabet(fsm: FSM) -> [text]:
    """Get the alphabet (set of input symbols)."""
    fsm.alphabet

fn get_accepting_states(fsm: FSM) -> [text]:
    """Get list of all accepting state names."""
    var accepting: [text] = []
    for i in 0..fsm.states.len():
        if fsm.states[i].accepting:
            accepting = accepting + [fsm.states[i].name]
    accepting
