# Simple Libraries Module
# @tag:api
#
# Provides shared libraries for the Simple compiler, tools, and applications.
# Includes databases, JSON utilities, testing frameworks, and FFI helpers.
#
# This module serves as the central entry point for all library functionality
# in the Simple compiler ecosystem. It re-exports commonly used types and
# functions to minimize import boilerplate in client code.
#
# Public API:
#   - Database types (BugDB, TestDB, FeatureDB) - tracking bugs, tests, features
#   - JSON building utilities - safe JSON generation for MCP and tools
#   - QEMU testing infrastructure - cross-platform RISC-V testing
#   - Parser utilities - shared parsing helpers for DSLs
#   - PyTorch FFI wrappers - neural network integration
#   - Pure utility functions - 28 files of functional helpers
#
# Internal Implementation:
#   - Execution runtime helpers - async/actor runtime support
#   - CUDA/GPU runtime - GPU kernel execution
#   - Hook detectors - test framework hooks
#   - Memory utilities - allocation tracking
#   - Advanced collections - persistent data structures
#
# Example: Using BugDatabase to track compiler issues
#
#     use lib.{BugDatabase, create_bug_database, BugSeverity}
#
#     val db = create_bug_database()
#     db.add_bug("BUG-001", "Parser fails on nested generics", BugSeverity.Critical)
#     db.add_bug("BUG-002", "Lexer slowdown on large files", BugSeverity.Minor)
#
#     val critical = db.query_by_severity(BugSeverity.Critical)
#     print "Found {critical.len()} critical bugs"
#     # Output: Found 1 critical bugs
#
# Example: Building JSON for MCP responses
#
#     use lib.{JsonBuilder}
#
#     val builder = JsonBuilder()
#     builder.add_string("jsonrpc", "2.0")
#     builder.add_number("id", 1)
#
#     val result = JsonBuilder()
#     result.add_string("status", "success")
#     result.add_array("items", ["foo", "bar", "baz"])
#     builder.add_object("result", result.build())
#
#     val json = builder.build()
#     # Output: {"jsonrpc":"2.0","id":1,"result":{"status":"success","items":["foo","bar","baz"]}}
#
# Example: Testing with QEMU RISC-V emulation
#
#     use lib.{QemuArch, QemuConfig, is_qemu_available}
#
#     if is_qemu_available():
#         val config = QemuConfig()
#         config.arch = QemuArch.RV32
#         config.enable_gdb = false
#         config.timeout_seconds = 30
#
#         # Run test binary in RISC-V emulator
#         val result = interpret_exit_code(run_in_qemu(config, "test.elf"))
#         print "Test result: {result.status}"
#
# Example: Feature database for tracking implementation status
#
#     use lib.{FeatureDatabase, create_feature_database, FeatureStatus}
#
#     val db = create_feature_database()
#     db.add_feature("generics", FeatureStatus.InProgress, "Type parameter support")
#     db.add_feature("async", FeatureStatus.Completed, "Async/await syntax")
#
#     val pending = db.query_by_status(FeatureStatus.InProgress)
#     print "Features in progress: {pending.len()}"
#     # Output: Features in progress: 1
#
# Example: Test database for tracking test results
#
#     use lib.{TestDatabase, create_test_database, TestStatus}
#
#     val db = create_test_database()
#     db.add_test_result("test/unit/parser_spec.spl", TestStatus.Passed, 0.125)
#     db.add_test_result("test/unit/lexer_spec.spl", TestStatus.Failed, 0.089)
#
#     val stats = db.get_statistics()
#     print "Pass rate: {stats.pass_percentage}%"

# ============================================================================
# Public Modules
# @tag:api
# ============================================================================

# Database systems - BugDB, TestDB, FeatureDB for tracking compiler metadata
# Used by: test runner, bug tracker, feature planner, documentation generators
pub mod database

# JSON utilities - Safe JSON builder for MCP protocol and tool output
# Used by: MCP servers, CLI commands, code intelligence tools
pub mod json

# Testing infrastructure - QEMU emulation for cross-platform RISC-V testing
# Used by: test runner, CI pipeline, embedded target validation
pub mod qemu

# Parser utilities - Shared parsing helpers for DSLs and configuration files
# Used by: SDN parser, CLI parser, configuration loaders
pub mod parser

# PyTorch FFI wrappers - Neural network integration for ML features
# Used by: ML compiler passes, tensor analysis, GPU code generation
pub mod torch

# Pure functional utilities - 28 files of utility functions (map, filter, fold, etc.)
# Used by: All compiler passes, stdlib implementations, tools
pub mod pure

# Advanced collections - Persistent data structures (immutable trees, tries)
# Used by: Type checker, symbol tables, optimization passes
pub mod collections

# ============================================================================
# Internal Modules (Implementation Details)
# @tag:internal
# ============================================================================

# Runtime execution helpers - process spawning, environment management
# INTERNAL: Not part of public API, subject to change
mod execution

# CUDA/GPU runtime - kernel execution, device memory management
# INTERNAL: Used by GPU backend, wrapped by higher-level APIs
mod cuda

# Hook detection system - test framework before_each/after_each support
# INTERNAL: Used by SSpec, not directly accessible to tests
mod hooks

# Memory utilities - allocation tracking, leak detection
# INTERNAL: Used by runtime profiler and debugger
mod memory

# Actor system components - async/await runtime implementation
# INTERNAL: All actor modules are implementation details of async runtime
# Users should use async/await syntax, not actor primitives directly
mod actor_heap          # Actor heap allocation and lifecycle
mod actor_scheduler     # Task scheduling and work stealing
mod mailbox             # Message queues for actor communication
mod message_transfer    # Zero-copy message passing
mod lazy_val            # Lazy evaluation for actor futures
mod symbol              # Symbol table for actor names
mod perf                # Performance monitoring and metrics

# ============================================================================
# Re-export Common Types
# @tag:api
#
# These types are re-exported at the top level to minimize import boilerplate.
# Instead of: use lib.database.bug.{BugDatabase, create_bug_database}
# You can write: use lib.{BugDatabase, create_bug_database}
# ============================================================================

# ---- Bug Database ----
# Track compiler bugs, issues, and defects with severity/status metadata
#
# Types:
#   - BugDatabase: Main database handle for querying and persistence
#   - Bug: Individual bug record (ID, title, severity, status, description)
#   - BugSeverity: Critical | High | Medium | Low | Trivial
#   - BugStatus: Open | InProgress | Fixed | Wontfix | Duplicate
#
# Functions:
#   - create_bug_database(): Create new empty database
#   - load_bug_database(path): Load from SDN file
#   - parse_severity(text): Convert string to BugSeverity enum
#   - parse_status(text): Convert string to BugStatus enum
#
# @tag:api
pub use .database.bug.{
    BugDatabase, Bug, BugSeverity, BugStatus,
    create_bug_database, load_bug_database,
    parse_severity, parse_status
}

# ---- Test Database ----
# Track test execution results, run history, and pass/fail statistics
#
# Types:
#   - TestDatabase: Main database handle for test result tracking
#   - TestRun: Single test execution (timestamp, duration, status)
#   - TestResult: Individual test case result (name, status, message)
#   - RunStatus: Success | Failure | Error | Skipped | Timeout
#   - TestStatus: Passed | Failed | Skipped | Pending
#
# Functions:
#   - create_test_database(): Create new empty database
#   - load_test_database(path): Load from SDN file
#
# @tag:api
pub use .database.test.{
    TestDatabase, TestRun, TestResult, RunStatus, TestStatus,
    create_test_database, load_test_database
}

# ---- Feature Database ----
# Track feature implementation status, milestones, and progress
#
# Types:
#   - FeatureDatabase: Main database for feature tracking
#   - Feature: Individual feature (name, status, mode, description)
#   - FeatureStatus: Planned | InProgress | Completed | Deprecated
#   - FeatureMode: Experimental | Stable | Legacy
#
# Functions:
#   - create_feature_database(): Create new empty database
#   - load_feature_database(path): Load from SDN file
#
# @tag:api
pub use .database.feature.{
    FeatureDatabase, Feature, FeatureStatus, FeatureMode,
    create_feature_database, load_feature_database
}

# ---- JSON Builder ----
# Safe JSON construction without string interpolation (prevents injection)
# Heavily used in MCP protocol handlers and CLI output formatting
#
# Types:
#   - JsonBuilder: Object builder (key-value pairs)
#   - JsonArrayBuilder: Array builder (ordered elements)
#
# Functions:
#   - escape_json(text): Escape special characters for JSON strings
#
# Methods on JsonBuilder:
#   - add_string(key, value): Add string field
#   - add_number(key, value): Add numeric field (int or float)
#   - add_bool(key, value): Add boolean field
#   - add_null(key): Add null field
#   - add_object(key, obj): Add nested object
#   - add_array(key, items): Add array field
#   - build(): Serialize to JSON string
#
# @tag:api
pub use .json.builder.{
    JsonBuilder, JsonArrayBuilder, escape_json
}

# ---- QEMU Testing ----
# RISC-V emulation for cross-platform testing (RV32, RV64, RV128)
# Used by test runner to validate code on embedded targets
#
# Types:
#   - QemuArch: RV32 | RV64 | RV128 | ARM | X86_64
#   - QemuConfig: Configuration (arch, memory, timeout, GDB)
#   - QemuInstance: Running emulator instance handle
#   - ExitCodeResult: Success | Failure | Timeout | Crash
#
# Functions:
#   - is_qemu_available(): Check if QEMU is installed
#   - is_gdb_available(): Check if GDB is available for debugging
#   - find_rv32_gcc(): Locate RISC-V cross-compiler
#   - build_rv32_binary(source, output): Compile for RV32
#   - interpret_exit_code(code): Convert exit code to result enum
#
# @tag:api
pub use .qemu.{
    QemuArch, QemuConfig, QemuInstance,
    ExitCodeResult, interpret_exit_code,
    is_qemu_available, is_gdb_available,
    find_rv32_gcc, build_rv32_binary
}

# ---- Parser Utilities ----
# Shared parsing helpers for DSLs and configuration files
# Used by SDN parser, CLI argument parser, and custom language frontends
#
# Functions:
#   - parse(source): Parse full source file into AST
#   - parse_expr(text): Parse single expression
#
# @tag:api
pub use .parser.parser.{parse, parse_expr}

# ---- PyTorch Wrappers ----
# Neural network FFI bindings for ML compiler features
# Provides Simple-idiomatic wrappers around PyTorch C++ API
#
# Types:
#   - TorchTensorWrapper: Wrapper for torch::Tensor
#   - TorchStream: CUDA stream handle
#
# Functions:
#   - torch_available(): Check if PyTorch is available
#   - torch_cuda_available(): Check if CUDA is available
#
# @tag:api
pub use .torch.{
    TorchTensorWrapper, TorchStream,
    torch_available, torch_cuda_available
}
