# Simple Standard Library
#
# @tag:stdlib
# @tag:api
#
# The standard library for the Simple programming language.
# Provides common utilities, data structures, I/O, networking,
# testing frameworks, and platform abstractions.
#
# This is the root module for all standard library functionality.
# Most commonly used modules are available as root-level .spl files,
# while specialized features are in subdirectories.
#
# Most Commonly Used Modules:
#   1. spec/sspec     - Testing frameworks (describe, it, expect)
#   2. io_runtime     - File I/O, shell, process (file_read, shell)
#   3. platform       - OS/arch detection (host_os, is_windows)
#   4. string         - String utilities (split, join, trim)
#   5. array          - Array operations (map, filter, sort)
#   6. path           - Path utilities (join_path, basename)
#   7. math           - Math functions (sqrt, sin, abs)
#
# Root-level modules (*.spl files in src/lib/):
#   - spec/sspec: Testing frameworks
#   - io_runtime: File I/O, shell, process operations
#   - platform: OS/arch detection, path utilities
#   - string, math, array: Core utilities
#   - async, concurrent: Async/concurrency primitives
#   - net, fs: Networking and filesystem
#   - json, sdn: Data format parsing
#
# Subdirectories:
#   - report/: Diagnostic reporting system
#   - common/: Shared utilities
#   - type/: Type system utilities
#   - mcp/: Model Context Protocol
#   - compute/: Computation primitives
#   - gpu/: GPU operations
#
# Examples:
#
# Basic string operations:
# ```simple
# use std.text.{split, join, trim}
#
# val text = "  hello, world  "
# val cleaned = trim(text)
# print cleaned
# # Output: hello, world
#
# val parts = split(cleaned, ", ")
# print parts[0]
# # Output: hello
#
# val joined = join(parts, " ")
# print joined
# # Output: hello world
# ```
#
# File I/O operations:
# ```simple
# use std.io_runtime.{file_write, file_read}
# use std.path.{join_path}
#
# val tmp_dir = "/tmp"
# val filename = "test.txt"
# val path = join_path(tmp_dir, filename)
#
# val content = "Hello, Simple!"
# file_write(path, content)
#
# val data = file_read(path)
# print data
# # Output: Hello, Simple!
# ```
#
# Platform detection:
# ```simple
# use std.platform.{host_os, host_arch, is_windows}
#
# val os_name = host_os()
# print os_name
# # Output: linux (or windows, macos)
#
# val arch_name = host_arch()
# print arch_name
# # Output: x86_64 (or aarch64)
#
# val is_win = is_windows()
# if is_win:
#     print "Running on Windows"
# else:
#     print "Running on Unix-like OS"
# # Output: Running on Unix-like OS
# ```
#
# Array operations:
# ```simple
# use std.array.{map, filter, sum}
#
# val numbers = [1, 2, 3, 4, 5]
#
# val doubled = map(numbers, fn(x): x * 2)
# print doubled[0]
# # Output: 2
#
# val evens = filter(numbers, fn(x): x % 2 == 0)
# print evens.len()
# # Output: 2
#
# val total = sum(numbers)
# print total
# # Output: 15
# ```
#
# Math functions:
# ```simple
# use std.math.{sqrt, abs, max, min}
#
# val num = -42.0
# val positive = abs(num)
# print positive
# # Output: 42.0
#
# val root = sqrt(16.0)
# print root
# # Output: 4.0
#
# val larger = max(10, 20)
# print larger
# # Output: 20
# ```

#[warn(primitive_api)]

# ============================================================================
# Public Modules (Subdirectories with stable APIs)
# @tag:api
# ============================================================================

# Note: Most std modules are available as both root-level .spl files
# and subdirectories. The module system automatically resolves these.
# We only declare pub mod for subdirectories that need explicit exports.

# Diagnostic reporting - compiler/runtime diagnostics, error formatting
pub mod report      # Error messages, easy fixes, severity levels

# Common utilities - shared helpers used across stdlib
pub mod common      # Target architecture, build config, shared types

# Type system utilities - type introspection and manipulation
pub mod type        # Type checking, conversion, validation

# Data formats - parsers for configuration and data files
pub mod sdn         # SDN format parser (Simple Data Notation)

# Model Context Protocol - MCP server implementation
pub mod mcp         # MCP tools, resources, prompts

# Source utilities - source code processing and analysis
pub mod src         # Source location, parsing, AST utilities

# ============================================================================
# Internal Modules (Implementation Details)
# @tag:internal
# ============================================================================

# These modules are private implementation details and should not be used
# directly by external code. They may change without notice.

mod failsafe            # Failsafe system internals - error recovery, fallback
mod dependency_tracker  # Dependency tracking internals - module loading order

# ============================================================================
# Re-export Common Utilities from Root-Level Files
# @tag:api
# ============================================================================

# Note: std has many root-level .spl files (spec.spl, platform.spl, etc.)
# These are automatically available as std.spec, std.platform, etc.
# We re-export commonly used functions here for convenience.

# Category 1: Testing Framework - most commonly used stdlib feature
# Import: use std.spec.{describe, it, expect}
# Functions: describe, it, expect, before_each, after_each, slow_it, skip_it
# (Actual exports defined in spec.spl and sspec.spl)

# Category 2: Platform Utilities - very common for cross-platform code
# Import: use std.platform.{host_os, host_arch, is_windows}
# Functions: host_os, host_arch, is_windows, is_linux, is_macos, normalize_path
# (Actual exports defined in platform.spl)

# Category 3: I/O Runtime - heavily used for file operations
# Import: use std.io_runtime.{file_read, file_write, shell}
# Functions: file_read, file_write, file_append, shell, process_run, env_get
# (Actual exports defined in io_runtime.spl)

# Category 4: Path Utilities - common for file path manipulation
# Import: use std.path.{join_path, normalize_path, basename}
# Functions: join_path, normalize_path, basename, dirname, path_exists, is_absolute
# (Actual exports defined in path.spl)

# Category 5: String Utilities - common for text processing
# Import: use std.text.{split, join, trim}
# Functions: split, join, trim, starts_with, ends_with, replace, to_lower, to_upper
# (Actual exports defined in text.spl)

# Category 6: Array Utilities - common for collection operations
# Import: use std.array.{map, filter, sum}
# Functions: map, filter, reduce, sum, any, all, sort, unique, flatten
# (Actual exports defined in array.spl)

# Category 7: Math Functions - common for numeric operations
# Import: use std.math.{sqrt, abs, max}
# Functions: sqrt, abs, max, min, sin, cos, tan, pow, floor, ceil, round
# (Actual exports defined in math.spl)

# ============================================================================
# Usage Notes
# @tag:api
# ============================================================================

# Root-level files are imported directly (most common pattern):
#   use std.spec.{describe, it, expect}           # Testing
#   use std.platform.{host_os, is_windows}        # Platform detection
#   use std.io_runtime.{file_read, file_write}    # File I/O, shell
#   use std.text.{split, join, trim}            # String utilities
#   use std.path.{join_path, basename}            # Path utilities
#   use std.math.{sqrt, abs, max}                 # Math functions
#   use std.array.{map, filter, sum}              # Array operations
#
# Subdirectories use the module path (advanced features):
#   use std.report.easy_fix.{EasyFix}             # Diagnostic easy-fix
#   use std.sdn.parser.{parse_sdn}                # SDN parsing
#   use std.common.target.{get_target_triple}     # Target architecture
#   use std.type.checker.{check_type}             # Type checking
#
# Wildcard imports from subdirectories may need __init__.spl:
#   use std.async.*             # Async runtime (needs async/__init__.spl)
#   use std.concurrent.*        # Concurrency (needs concurrent/__init__.spl)
#
# Import Best Practices:
#   1. Use explicit imports: use std.text.{split, join}
#      NOT: use std.text.* (wildcard can cause name conflicts)
#
#   2. Group imports by category:
#      # I/O operations
#      use std.io_runtime.{file_read, file_write}
#      use std.path.{join_path}
#
#   3. Import only what you need (reduces namespace pollution)
#
#   4. For testing, import spec functions at the top:
#      use std.spec.{describe, it, expect}
#
# Examples:
#
# Testing framework usage:
# ```simple
# use std.spec.{describe, it, expect}
#
# describe "Calculator":
#     it "adds two numbers":
#         val result = 2 + 2
#         expect(result).to_equal(4)
#
#     it "multiplies correctly":
#         val result = 3 * 4
#         expect(result).to_equal(12)
# ```
#
# Shell command execution:
# ```simple
# use std.io_runtime.{shell}
#
# val output = shell("echo 'Hello from shell'")
# print output
# # Output: Hello from shell
# ```
#
# Path manipulation:
# ```simple
# use std.path.{join_path, basename, dirname}
#
# val full_path = "/home/user/projects/simple/src/main.spl"
# val file = basename(full_path)
# print file
# # Output: main.spl
#
# val directory = dirname(full_path)
# print directory
# # Output: /home/user/projects/simple/src
#
# val new_path = join_path(directory, "test.spl")
# print new_path
# # Output: /home/user/projects/simple/src/test.spl
# ```
#
# Combining multiple stdlib modules:
# ```simple
# use std.io_runtime.{file_read}
# use std.text.{split, trim}
# use std.array.{filter}
#
# val content = file_read("/etc/hosts")
# val lines = split(content, "\n")
#
# val non_empty = filter(lines, fn(line):
#     val trimmed = trim(line)
#     trimmed.len() > 0
# )
#
# print non_empty.len()
# # Output: (number of non-empty lines)
# ```
