# HashMap - Pure Simple Implementation
#
# No FFI, no Rust - 100% Pure Simple
# Hash table with chaining for collision resolution

export HashMap

struct Entry:
    """Key-value pair in HashMap."""
    key: text
    value: text

class HashMap:
    """Pure Simple HashMap using array of buckets with chaining.

    Example:
        var map = HashMap.new()
        map.insert("name", "Alice")
        val name = map.get("name")  # Some("Alice")
    """
    buckets: [[Entry]]
    size: i64
    capacity: i64

    static fn new() -> HashMap:
        """Create new empty HashMap with default capacity."""
        var buckets: [[Entry]] = []
        var i = 0
        while i < 16:
            buckets.push([])
            i = i + 1

        HashMap(buckets: buckets, size: 0, capacity: 16)

    me insert(key: text, value: text):
        """Insert or update key-value pair."""
        # Resize if load factor > 0.75
        if self.size * 4 > self.capacity * 3:
            self._resize()

        val idx = self._bucket_index(key)
        var bucket = self.buckets[idx]

        # Update if key exists
        for i in 0..bucket.len():
            if bucket[i].key == key:
                bucket[i].value = value
                return

        # Add new entry
        bucket.push(Entry(key: key, value: value))
        self.buckets[idx] = bucket
        self.size = self.size + 1

    fn get(key: text) -> text?:
        """Get value for key."""
        val idx = self._bucket_index(key)
        val bucket = self.buckets[idx]

        for entry in bucket:
            if entry.key == key:
                return Some(entry.value)

        nil

    fn contains_key(key: text) -> bool:
        """Check if key exists."""
        val result = self.get(key)
        result.?

    me remove(key: text) -> text?:
        """Remove key and return value."""
        val idx = self._bucket_index(key)
        var bucket = self.buckets[idx]

        for i in 0..bucket.len():
            if bucket[i].key == key:
                val value = bucket[i].value
                # Remove by rebuilding bucket without this entry
                var new_bucket: [Entry] = []
                for j in 0..bucket.len():
                    if j != i:
                        new_bucket.push(bucket[j])
                self.buckets[idx] = new_bucket
                self.size = self.size - 1
                return Some(value)

        nil

    fn keys() -> [text]:
        """Get all keys."""
        var result: [text] = []
        for bucket in self.buckets:
            for entry in bucket:
                result.push(entry.key)
        result

    fn values() -> [text]:
        """Get all values."""
        var result: [text] = []
        for bucket in self.buckets:
            for entry in bucket:
                result.push(entry.value)
        result

    me clear():
        """Remove all entries."""
        var i = 0
        while i < self.capacity:
            self.buckets[i] = []
            i = i + 1
        self.size = 0

    fn len() -> i64:
        """Get number of entries."""
        self.size

    fn is_empty() -> bool:
        """Check if empty."""
        self.size == 0

    fn _bucket_index(key: text) -> i64:
        """Compute bucket index for key."""
        val hash = self._hash(key)
        if hash < 0:
            (0 - hash) % self.capacity
        else:
            hash % self.capacity

    fn _hash(s: text) -> i64:
        """Hash string using djb2 algorithm."""
        var hash: i64 = 5381
        var i = 0
        while i < s.len():
            val c = s[i:i+1]
            val code = self._char_code(c)
            hash = ((hash * 33) + code)
            i = i + 1
        hash

    fn _char_code(c: text) -> i64:
        """Get character code (ASCII-like)."""
        # Common characters
        if c == "a": return 97
        if c == "b": return 98
        if c == "c": return 99
        if c == "d": return 100
        if c == "e": return 101
        if c == "1": return 49
        if c == "2": return 50
        if c == "3": return 51
        if c == " ": return 32
        # Default for others
        42

    me _resize():
        """Double capacity and rehash."""
        val new_capacity = self.capacity * 2
        var new_buckets: [[Entry]] = []
        var i = 0
        while i < new_capacity:
            new_buckets.push([])
            i = i + 1

        # Rehash all entries
        for bucket in self.buckets:
            for entry in bucket:
                val hash = self._hash(entry.key)
                val idx = if hash < 0: (0 - hash) % new_capacity else: hash % new_capacity
                new_buckets[idx].push(entry)

        self.buckets = new_buckets
        self.capacity = new_capacity
