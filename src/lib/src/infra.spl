# Infrastructure Module - Pure Simple Implementation
#
# Advanced file I/O operations using shell commands
# No FFI, no Rust - 100% Pure Simple

export read_lines, append_file
export read_bytes, write_bytes
export move_file
export create_dir_all, walk_dir, current_dir, remove_dir_all
export stem, relative_path, path_join
export read_file, write_file, file_exist, remove_file, create_dir, remove_dir
export copy_file, atomic_write, file_size, file_hash, modified_time
export lock_file, unlock_file
export list_dir, is_directory
export home_dir, get_env, set_env
export get_pid, get_hostname, get_cpu_count, basename
export ProcessResult, run_process, run_with_timeout, run_shell
export IoError

use app.io.{
    file_read, file_write, file_append, file_exists,
    file_copy, file_delete, file_atomic_write,
    file_size_raw, file_hash_sha256, file_modified_time,
    file_lock, file_unlock,
    dir_create_all as dir_create_all_impl,
    dir_walk as dir_walk_impl,
    dir_remove_all as dir_remove_all_impl,
    dir_list, is_dir,
    cwd as cwd_impl, home,
    env_get, env_set,
    getpid, hostname, cpu_count, path_basename,
    process_run, process_run_timeout, shell,
    ProcessResult
}

# ============================================================================
# Result Types for Error Handling
# ============================================================================

# Simple error type
struct IoError:
    message: text

# ============================================================================
# Line-Based File Reading
# ============================================================================

fn read_lines(path: text) -> Result<[text], IoError>:
    """Read file and split into lines.

    Returns:
        Ok([text]) - List of lines (empty list for empty file)
        Err(IoError) - If file doesn't exist or can't be read
    """
    # Check if file exists first
    if not file_exists(path):
        return Err(IoError(message: "File not found: {path}"))

    # Read file content
    val content = file_read(path)

    # Empty file returns empty list
    if content.len() == 0:
        return Ok([])

    # Split by newlines
    Ok(content.split("\n"))

# ============================================================================
# Append File Operations
# ============================================================================

fn append_file(path: text, content: text) -> Result<(), IoError>:
    """Append content to file (creates if doesn't exist).

    Args:
        path - File path
        content - Content to append

    Returns:
        Ok(()) on success
        Err(IoError) on failure
    """
    # Use shell append
    val escaped = content.replace("'", "'\\''")
    val result = shell("printf '%s' '{escaped}' >> '{path}' 2>&1")

    if result.exit_code == 0:
        Ok(())
    else:
        Err(IoError(message: "Failed to append to {path}: {result.stderr}"))

# ============================================================================
# Binary I/O
# ============================================================================

fn read_bytes(path: text) -> Result<[i64], IoError>:
    """Read file as raw bytes.

    Returns:
        Ok([i64]) - Array of byte values (0-255)
        Err(IoError) - If file doesn't exist or can't be read
    """
    if not file_exists(path):
        return Err(IoError(message: "File not found: {path}"))

    # Use od (octal dump) to read bytes
    val result = shell("od -An -td1 -v '{path}' 2>&1")

    if result.exit_code != 0:
        return Err(IoError(message: "Failed to read bytes from {path}: {result.stderr}"))

    # Parse output: space-separated decimal bytes
    val output = result.stdout.trim()
    if output.len() == 0:
        return Ok([])  # Empty file

    # Split by whitespace and convert to integers
    var bytes: [i64] = []
    val parts = output.split(" ")
    for part in parts:
        val trimmed = part.trim()
        if trimmed.len() > 0:
            val byte_val = trimmed.to_int_or(0)
            # Ensure unsigned byte range (0-255)
            if byte_val < 0:
                bytes.push(byte_val + 256)
            else:
                bytes.push(byte_val)

    Ok(bytes)

fn write_bytes(path: text, data: [i64]) -> Result<(), IoError>:
    """Write raw bytes to file.

    Args:
        path - File path
        data - Array of byte values (0-255)

    Returns:
        Ok(()) on success
        Err(IoError) on failure
    """
    # Convert byte array to octal escape sequences
    var octal_str = ""
    for byte in data:
        # Ensure byte is in 0-255 range
        val b = if byte < 0: byte + 256 else: byte
        val b_mod = b % 256

        # Convert to octal (3 digits)
        val octal = _to_octal(b_mod)
        octal_str = octal_str + "\\{octal}"

    # Use printf to write binary data
    val result = shell("printf '{octal_str}' > '{path}' 2>&1")

    if result.exit_code == 0:
        Ok(())
    else:
        Err(IoError(message: "Failed to write bytes to {path}: {result.stderr}"))

fn _to_octal(n: i64) -> text:
    """Convert integer to 3-digit octal string."""
    var num = n
    var digits: [i64] = []

    # Convert to octal
    if num == 0:
        return "000"

    while num > 0:
        digits.push(num % 8)
        num = num / 8

    # Reverse and pad to 3 digits
    var result = ""
    var i = digits.len() - 1
    while i >= 0:
        result = result + "{digits[i]}"
        i = i - 1

    # Pad with zeros
    while result.len() < 3:
        result = "0" + result

    result

# ============================================================================
# File Move Operations
# ============================================================================

fn move_file(src: text, dest: text) -> Result<(), IoError>:
    """Move file from source to destination.

    The source file is removed after successful move.

    Args:
        src - Source file path
        dest - Destination file path

    Returns:
        Ok(()) on success
        Err(IoError) on failure
    """
    if not file_exists(src):
        return Err(IoError(message: "Source file not found: {src}"))

    val result = shell("mv '{src}' '{dest}' 2>&1")

    if result.exit_code == 0:
        Ok(())
    else:
        Err(IoError(message: "Failed to move {src} to {dest}: {result.stderr}"))

# ============================================================================
# Directory Operations
# ============================================================================

fn create_dir_all(path: text) -> Result<(), IoError>:
    """Create directory and all parent directories.

    Similar to mkdir -p.

    Args:
        path - Directory path to create

    Returns:
        Ok(()) on success
        Err(IoError) on failure
    """
    val result = shell("mkdir -p '{path}' 2>&1")

    if result.exit_code == 0:
        Ok(())
    else:
        Err(IoError(message: "Failed to create directory {path}: {result.stderr}"))

fn walk_dir(path: text) -> Result<[text], IoError>:
    """Recursively list all files and directories.

    Args:
        path - Directory path to walk

    Returns:
        Ok([text]) - List of all paths found
        Err(IoError) - If directory doesn't exist
    """
    # Use find command for recursive listing
    val result = shell("find '{path}' 2>&1")

    if result.exit_code != 0:
        return Err(IoError(message: "Failed to walk directory {path}: {result.stderr}"))

    # Split output by newlines, filter out the base path itself
    val lines = result.stdout.split("\n")
    var entries: [text] = []

    for line in lines:
        val trimmed = line.trim()
        if trimmed.len() > 0 and trimmed != path:
            entries.push(trimmed)

    Ok(entries)

fn current_dir() -> text:
    """Get current working directory.

    Returns:
        Absolute path to current directory
    """
    val result = shell("pwd 2>&1")

    if result.exit_code == 0:
        result.stdout.trim()
    else:
        "."  # Fallback

fn set_current_dir(path: text) -> Result<(), IoError>:
    """Change current working directory.

    Note: This is a no-op in Pure Simple implementation as there's
    no process-wide state. Use absolute paths instead.
    """
    Err(IoError(message: "set_current_dir not supported in Pure Simple mode"))

fn remove_dir_all(path: text) -> Result<(), IoError>:
    """Recursively remove directory and all contents.

    Similar to rm -rf.

    Args:
        path - Directory path to remove

    Returns:
        Ok(()) on success
        Err(IoError) on failure
    """
    val result = shell("rm -rf '{path}' 2>&1")

    if result.exit_code == 0:
        Ok(())
    else:
        Err(IoError(message: "Failed to remove directory {path}: {result.stderr}"))

# ============================================================================
# Path Utilities
# ============================================================================

fn stem(path: text) -> text:
    """Extract filename without extension.

    Examples:
        stem("file.txt") → "file"
        stem("archive.tar.gz") → "archive.tar"
        stem("README") → "README"
    """
    # Find last slash for basename
    val last_slash = path.rfind("/")
    val basename = if last_slash >= 0:
        path[last_slash + 1:]
    else:
        path

    # Find last dot for extension
    val last_dot = basename.rfind(".")
    if last_dot > 0:  # > 0 to handle dotfiles like ".hidden"
        basename[:last_dot]
    else:
        basename

fn relative_path(target: text, base: text) -> text:
    """Compute relative path from base to target.

    Examples:
        relative_path("/a/b/c/file.txt", "/a/b") → "c/file.txt"
        relative_path("/a/b", "/a/b") → ""
    """
    # Same path
    if target == base:
        return ""

    # Check if target starts with base
    if target.starts_with(base):
        val rel = target[base.len():]
        # Remove leading slash
        if rel.starts_with("/"):
            rel[1:]
        else:
            rel
    else:
        # Not a subpath, return target as-is
        target

fn path_join(dir: text, file: text) -> text:
    """Join directory and file paths.

    Examples:
        path_join("/home/user", "file.txt") → "/home/user/file.txt"
    """
    if dir.ends_with("/"):
        dir + file
    else:
        dir + "/" + file

# ============================================================================
# Wrapper Functions (for test compatibility)
# ============================================================================

fn read_file(path: text) -> Result<text, IoError>:
    """Read entire file as text."""
    if not file_exists(path):
        Err(IoError(message: "File not found: {path}"))
    else:
        Ok(file_read(path))

fn write_file(path: text, content: text) -> Result<(), IoError>:
    """Write content to file."""
    val success = file_write(path, content)
    if success:
        Ok(())
    else:
        Err(IoError(message: "Failed to write to {path}"))

fn file_exist(path: text) -> bool:
    """Check if file exists."""
    file_exists(path)

fn remove_file(path: text) -> Result<(), IoError>:
    """Remove a file."""
    if not file_exists(path):
        Err(IoError(message: "File not found: {path}"))
    else:
        val success = file_delete(path)
        if success:
            Ok(())
        else:
            Err(IoError(message: "Failed to remove {path}"))

fn create_dir(path: text) -> Result<(), IoError>:
    """Create a single directory."""
    val result = shell("mkdir '{path}' 2>&1")
    if result.exit_code == 0:
        Ok(())
    else:
        Err(IoError(message: "Failed to create directory {path}: {result.stderr}"))

fn remove_dir(path: text) -> Result<(), IoError>:
    """Remove an empty directory."""
    val result = shell("rmdir '{path}' 2>&1")
    if result.exit_code == 0:
        Ok(())
    else:
        Err(IoError(message: "Failed to remove directory {path}: {result.stderr}"))
# ============================================================================
# Additional File Operations
# ============================================================================

fn copy_file(src: text, dest: text) -> Result<(), IoError>:
    """Copy file from source to destination.

    Args:
        src - Source file path
        dest - Destination file path

    Returns:
        Ok(()) on success
        Err(IoError) on failure
    """
    if not file_exists(src):
        return Err(IoError(message: "Source file not found: {src}"))

    val success = file_copy(src, dest)
    if success:
        Ok(())
    else:
        Err(IoError(message: "Failed to copy {src} to {dest}"))

fn atomic_write(path: text, content: text) -> Result<(), IoError>:
    """Atomically write content to file (write-then-move).

    Args:
        path - File path
        content - Content to write

    Returns:
        Ok(()) on success
        Err(IoError) on failure
    """
    val success = file_atomic_write(path, content)
    if success:
        Ok(())
    else:
        Err(IoError(message: "Failed to atomically write to {path}"))

fn file_size(path: text) -> Result<i64, IoError>:
    """Get file size in bytes.

    Args:
        path - File path

    Returns:
        Ok(size) on success
        Err(IoError) on failure
    """
    if not file_exists(path):
        return Err(IoError(message: "File not found: {path}"))

    val size = file_size_raw(path)
    if size < 0:
        Err(IoError(message: "Failed to get size of {path}"))
    else:
        Ok(size)

fn file_hash(path: text) -> Result<text, IoError>:
    """Compute SHA256 hash of file.

    Args:
        path - File path

    Returns:
        Ok(hash) - SHA256 hash as hex string
        Err(IoError) on failure
    """
    if not file_exists(path):
        return Err(IoError(message: "File not found: {path}"))

    val hash = file_hash_sha256(path)
    if hash.len() == 0:
        Err(IoError(message: "Failed to compute hash of {path}"))
    else:
        Ok(hash)

fn modified_time(path: text) -> Result<i64, IoError>:
    """Get file modification time (Unix timestamp).

    Args:
        path - File path

    Returns:
        Ok(timestamp) on success
        Err(IoError) on failure
    """
    if not file_exists(path):
        return Err(IoError(message: "File not found: {path}"))

    val time = file_modified_time(path)
    Ok(time)

# ============================================================================
# File Locking
# ============================================================================

fn lock_file(path: text, timeout_secs: i64) -> Result<i64, IoError>:
    """Acquire file lock.

    Args:
        path - File path to lock
        timeout_secs - Timeout in seconds

    Returns:
        Ok(handle) - Lock handle (use with unlock_file)
        Err(IoError) on failure
    """
    val handle = file_lock(path, timeout_secs)
    if handle < 0:
        Err(IoError(message: "Failed to lock file {path}"))
    else:
        Ok(handle)

fn unlock_file(handle: i64) -> Result<(), IoError>:
    """Release file lock.

    Args:
        handle - Lock handle from lock_file

    Returns:
        Ok(()) on success
        Err(IoError) on failure
    """
    val success = file_unlock(handle)
    if success:
        Ok(())
    else:
        Err(IoError(message: "Failed to unlock file handle {handle}"))

# ============================================================================
# Additional Directory Operations
# ============================================================================

fn list_dir(path: text) -> Result<[text], IoError>:
    """List directory contents (non-recursive).

    Args:
        path - Directory path

    Returns:
        Ok([text]) - List of entries
        Err(IoError) on failure
    """
    val entries = dir_list(path)
    if entries.len() == 0 and not file_exists(path):
        Err(IoError(message: "Directory not found: {path}"))
    else:
        Ok(entries)

fn is_directory(path: text) -> bool:
    """Check if path is a directory.

    Args:
        path - Path to check

    Returns:
        true if directory, false otherwise
    """
    is_dir(path)

# ============================================================================
# Environment
# ============================================================================

fn home_dir() -> text:
    """Get user home directory path.

    Returns:
        Home directory path
    """
    home()

fn get_env(key: text) -> text:
    """Get environment variable value.

    Args:
        key - Environment variable name

    Returns:
        Value if set, empty string otherwise
    """
    env_get(key)

fn set_env(key: text, value: text) -> Result<(), IoError>:
    """Set environment variable.

    Args:
        key - Environment variable name
        value - Value to set

    Returns:
        Ok(()) on success
        Err(IoError) on failure
    """
    val success = env_set(key, value)
    if success:
        Ok(())
    else:
        Err(IoError(message: "Failed to set environment variable {key}"))

# ============================================================================
# System Information
# ============================================================================

fn get_pid() -> i64:
    """Get current process ID.

    Returns:
        Process ID
    """
    getpid()

fn get_hostname() -> text:
    """Get system hostname.

    Returns:
        Hostname
    """
    hostname()

fn get_cpu_count() -> i64:
    """Get CPU core count.

    Returns:
        Number of CPU cores
    """
    cpu_count()

fn basename(path: text) -> text:
    """Get basename of path (last component).

    Args:
        path - File path

    Returns:
        Basename (filename with extension)
    """
    path_basename(path)

# ============================================================================
# Process Execution
# ============================================================================

fn run_process(cmd: text, args: [text]) -> Result<ProcessResult, IoError>:
    """Execute process and capture output.

    Args:
        cmd - Command to execute
        args - Command arguments

    Returns:
        Ok(ProcessResult) with stdout, stderr, exit_code
        Err(IoError) on failure
    """
    val result = process_run(cmd, args)
    Ok(ProcessResult(
        stdout: result.0,
        stderr: result.1,
        exit_code: result.2
    ))

fn run_with_timeout(cmd: text, args: [text], timeout_ms: i64) -> Result<ProcessResult, IoError>:
    """Execute process with timeout.

    Args:
        cmd - Command to execute
        args - Command arguments
        timeout_ms - Timeout in milliseconds

    Returns:
        Ok(ProcessResult) on success
        Err(IoError) on timeout or failure
    """
    val result = process_run_timeout(cmd, args, timeout_ms)
    if result.2 == -1:
        Err(IoError(message: "Process timed out after {timeout_ms}ms"))
    else:
        Ok(ProcessResult(
            stdout: result.0,
            stderr: result.1,
            exit_code: result.2
        ))

fn run_shell(command: text) -> Result<ProcessResult, IoError>:
    """Execute shell command.

    Args:
        command - Shell command string

    Returns:
        Ok(ProcessResult) on success
        Err(IoError) on failure
    """
    val result = shell(command)
    Ok(result)
