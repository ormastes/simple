# Complex Exponential and Root Functions
#
# Purpose: Exponential, logarithmic, and root operations
#
# Contains:
# - exp, log
# - sqrt, cbrt, nth_root, roots

# ============================================================================
# Exponential and Logarithm
# ============================================================================

fn exp(z):
    """Compute e^z.

    e^(a + bi) = e^a · (cos(b) + i·sin(b))

    Example:
        exp((0.0, PI))  # (-1.0, 0.0) ≈ e^(iπ)
    """
    val a = z.0
    val b = z.1

    val exp_a = exp_approx(a)
    val cos_b = cos_approx(b)
    val sin_b = sin_approx(b)

    (exp_a * cos_b, exp_a * sin_b)

fn log(z):
    """Compute natural logarithm (principal branch).

    log(z) = log|z| + i·arg(z)

    Example:
        log((1.0, 0.0))  # (0.0, 0.0)
    """
    val r = magnitude(z)
    val theta = argument(z)

    if r < EPSILON:
        return (-999999999999.0, 0.0)

    (log_approx(r), theta)

# ============================================================================
# Roots
# ============================================================================

fn sqrt(z):
    """Compute principal square root of complex number.

    Uses formula: sqrt(a + bi) = ±(sqrt((r + a)/2) + i·sgn(b)·sqrt((r - a)/2))
    where r = |z|

    Example:
        sqrt((-1.0, 0.0))  # (0.0, 1.0) = i
    """
    val a = z.0
    val b = z.1

    if abs_f64(b) < EPSILON:
        if a >= 0.0:
            return (sqrt_approx(a), 0.0)
        else:
            return (0.0, sqrt_approx(-a))

    val r = magnitude(z)
    val real = sqrt_approx((r + a) / 2.0)
    val imag_abs = sqrt_approx((r - a) / 2.0)

    if b >= 0.0:
        (real, imag_abs)
    else:
        (real, -imag_abs)

fn cbrt(z):
    """Compute principal cube root of complex number.

    Example:
        cbrt((8.0, 0.0))  # (2.0, 0.0)
    """
    val r = magnitude(z)
    val theta = argument(z)

    val new_r = pow_approx(r, 1.0 / 3.0)
    val new_theta = theta / 3.0

    from_polar(new_r, new_theta)

fn nth_root(z, n: i64):
    """Compute principal nth root of complex number.

    Example:
        nth_root((16.0, 0.0), 4)  # (2.0, 0.0)
    """
    if n == 0:
        return one()

    val r = magnitude(z)
    val theta = argument(z)

    val new_r = pow_approx(r, 1.0 / to_f64(n))
    val new_theta = theta / to_f64(n)

    from_polar(new_r, new_theta)

fn roots(z, n: i64):
    """Compute all n-th roots of complex number.

    Returns array of n complex numbers.

    Example:
        roots((-1.0, 0.0), 2)  # [(0, 1), (0, -1)]
    """
    if n <= 0:
        return []

    val r = magnitude(z)
    val theta = argument(z)
    val new_r = pow_approx(r, 1.0 / to_f64(n))

    var result = []
    var k = 0

    while k < n:
        val new_theta = (theta + 2.0 * PI * to_f64(k)) / to_f64(n)
        val root = from_polar(new_r, new_theta)
        result.push(root)
        k = k + 1

    result

# ============================================================================
# Helper functions (stubs)
# ============================================================================

val EPSILON = 0.0000000001
val PI = 3.141592653589793

fn exp_approx(x: f64) -> f64:
    """Stub - implemented in utilities."""
    1.0

fn cos_approx(x: f64) -> f64:
    """Stub - implemented in utilities."""
    1.0

fn sin_approx(x: f64) -> f64:
    """Stub - implemented in utilities."""
    0.0

fn log_approx(x: f64) -> f64:
    """Stub - implemented in utilities."""
    0.0

fn magnitude(z) -> f64:
    """Stub - implemented in arithmetic."""
    1.0

fn argument(z) -> f64:
    """Stub - implemented in arithmetic."""
    0.0

fn abs_f64(x: f64) -> f64:
    if x < 0.0:
        -x
    else:
        x

fn sqrt_approx(x: f64) -> f64:
    """Stub - implemented in utilities."""
    x

fn pow_approx(base: f64, exp: f64) -> f64:
    """Stub - implemented in utilities."""
    base

fn from_polar(r: f64, theta: f64):
    """Stub - implemented in types."""
    (r, 0.0)

fn one():
    """Return complex one 1 + 0i."""
    (1.0, 0.0)

fn to_f64(n: i64) -> f64:
    """Convert integer to float (simple coercion)."""
    n * 1.0

export exp, log
export sqrt, cbrt, nth_root, roots
