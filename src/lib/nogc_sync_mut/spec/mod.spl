"""
SSpec Testing Framework - Comprehensive Skip/Ignore System

@tag:stdlib
@tag:api

This module provides the entry point for the SSpec BDD testing framework's
advanced skip/ignore system. It aggregates environment detection, conditional
test execution, decorator functions, and feature documentation capabilities.

## Architecture

The spec module is organized into four submodules:

1. **env_detect** - Environment detection (platform, runtime, architecture, hardware)
2. **condition** - Conditional evaluation for skip/ignore logic
3. **decorators** - High-level decorator functions (skip, ignore, only_on, skip_if)
4. **feature_doc** - Feature metadata registry and documentation generation

## Core Framework

For basic testing with describe/it blocks, matchers, and hooks, use:
    use std.spec  # Main framework from std/spec.spl

For advanced skip/ignore functionality, use:
    use std.spec.decorators.{skip, ignore, only_on, skip_if}
    use std.spec.env_detect.{is_windows, is_interpreter, has_gpu}

## Skip vs Ignore Semantics

- **skip()** - "Will implement in future" (TODO item, counted in test totals)
- **ignore()** - "Fundamentally not supported" (completely silent, not counted)
- **only_on()** - "Run ONLY on specified conditions" (inverse skip logic)
- **skip_if()** - "Custom condition evaluation" (user-defined predicate)

## Usage Examples

### Basic Platform-Based Skip

```simple
use std.spec.decorators.{skip}

describe "File permissions":
    val skip_win = skip(
        platforms: ["windows"],
        runtimes: [],
        profiles: [],
        architectures: [],
        features: [],
        version: "",
        hardware: [],
        dependencies: [],
        env_vars: {},
        fs_features: [],
        network: false,
        tags: [],
        reason: "Unix permissions not supported on Windows"
    )

    skip_win "chmod 0644":
        expect(chmod("/tmp/file", 0o644)).to_equal(0)
```

### Runtime Mode Detection

```simple
use std.spec.decorators.{skip}

describe "JIT Compiler Tests":
    val skip_interp = skip(
        platforms: [],
        runtimes: ["interpreter"],
        profiles: [],
        architectures: [],
        features: [],
        version: "",
        hardware: [],
        dependencies: [],
        env_vars: {},
        fs_features: [],
        network: false,
        tags: [],
        reason: "Requires compiled or JIT mode"
    )

    skip_interp "optimize hot loop":
        expect(benchmark_jit()).to_be_greater_than(1000)
```

### Hardware Capability Detection

```simple
use std.spec.decorators.{skip}
use std.spec.env_detect.{has_gpu}

describe "GPU Acceleration":
    val skip_no_gpu = skip(
        platforms: [],
        runtimes: [],
        profiles: [],
        architectures: [],
        features: [],
        version: "",
        hardware: ["gpu"],
        dependencies: [],
        env_vars: {},
        fs_features: [],
        network: false,
        tags: ["slow", "gpu"],
        reason: "Requires NVIDIA or AMD GPU"
    )

    skip_no_gpu "matrix multiply CUDA":
        val result = gpu_matmul(a, b)
        expect(result.shape).to_equal([1024, 1024])
```

### Custom Condition with skip_if

```simple
use std.spec.decorators.{skip_if}
use std.spec.env_detect.{get_env}

describe "CI-Only Tests":
    val skip_no_ci = skip_if(
        fn(): get_env("CI") == "",
        "Only runs in CI environment"
    )

    skip_no_ci "full regression suite":
        expect(run_all_tests()).to_equal(true)
```

## Environment Detection API

Platform detection:
    is_windows(), is_linux(), is_macos(), is_unix(), is_bsd()

Runtime mode:
    is_interpreter(), is_compiled(), is_jit()
    get_runtime_mode() -> "interpreter" | "compiled" | "jit"

Architecture:
    is_x86_64(), is_aarch64(), is_64bit(), is_32bit()
    get_architecture() -> "x86_64" | "aarch64" | "arm64" | ...

Hardware capabilities:
    has_gpu(), has_cuda(), has_simd(), has_avx2(), has_neon()
    get_cpu_cores() -> i64, is_multi_core() -> bool

Feature flags:
    has_generics(), has_async(), has_macros(), has_effects()
    has_feature(name: text) -> bool

File system:
    has_symlinks(), has_permissions(), is_case_sensitive(), has_xattr()

Network:
    has_network() -> bool, can_reach(host: text) -> bool

Version checking:
    get_compiler_version() -> text
    check_version_constraint(">= 0.5.0") -> bool

## Simplified Decorators

For common cases, use simplified decorator functions:

```simple
use std.spec.decorators.{skip_on_windows, skip_on_interpreter}

describe "Quick Tests":
    skip_on_windows "Unix fork()":
        expect(fork()).to_be_greater_than(0)

    skip_on_interpreter "Inline assembly":
        expect(asm_add(3, 4)).to_equal(7)
```

## Feature Documentation System

Register and document features using the feature_doc module:

```simple
use std.spec.feature_doc.{
    register_feature, FeatureMetadata,
    generate_feature_doc, generate_master_index
}

val meta = FeatureMetadata(
    id: 42,
    name: "Async/Await",
    category: "Concurrency",
    difficulty: 4,
    status: "In Progress",
    impl_type: "Compiler",
    spec_ref: "RFC-007",
    files: ["src/compiler/async.spl"],
    tests: ["test/unit/async_spec.spl"],
    description: "Async/await syntax for non-blocking I/O",
    code_examples: [],
    dependencies: [15, 22],
    required_by: [50],
    notes: "Requires runtime support"
)

register_feature(meta)
val doc = generate_feature_doc(42)
```

## Implementation Notes

- All detection functions use FFI calls (rt_env_get, rt_process_run)
- No global state caching due to runtime module variable limitation
- Detection happens at test execution time (dynamic evaluation)
- Decorator functions return closures that wrap test execution
- Skipped tests are counted and reported with reason
- Ignored tests are completely silent (not counted)

## See Also

- Main SSpec framework: src/std/spec.spl
- Test runner: src/app/test_runner_new/
- SSpec skill: .claude/skills/sspec.md
- Testing guide: doc/guide/testing.md
"""

# Re-export all modules
use env_detect
use condition
use decorators
use feature_doc

# Re-export all public functions
export env_detect
export condition
export decorators
export feature_doc
