# Unified Database Library - Core Module
#
# ⚠️ WARNING: DO NOT MANUALLY EDIT DATABASE FILES
# ⚠️ All database updates MUST use this library's atomic operations
# ⚠️ Direct file writes to .sdn files will cause race conditions and data corruption
#
# Provides shared infrastructure for Bug DB, Test DB, and Feature DB:
# - StringInterner: Efficient string deduplication
# - SdnTable/SdnRow: In-memory SDN table representation
# - SdnDatabase: Base class for all databases
#
# CORRECT USAGE:
#   use std.database.bug (create_bug_database)
#   var db = create_bug_database("doc/bug/bug_db.sdn")
#   db.add_bug(bug)
#   db.save()  // Atomic operation with locking
#
# INCORRECT USAGE (FORBIDDEN):
#   use app.io (file_write)
#   file_write("doc/bug/bug_db.sdn", content)  // ❌ Race condition!

use std.database.atomic (atomic_write, atomic_read)
# Minimal StringId definition (avoids external dependency during bootstrap)
struct StringId:
    value: i32

# Direct extern declarations for bootstrap runtime compatibility
# (use app.io.{...} import doesn't resolve reliably in bootstrap interpreter)
extern fn rt_file_read_text(path: text) -> text
extern fn rt_file_write_text(path: text, content: text) -> bool
extern fn rt_file_exists(path: text) -> bool
extern fn rt_file_rename(from: text, to: text) -> bool

fn file_read(path: text) -> text:
    # Bootstrap runtime wraps rt_file_read_text result in Option
    val result = rt_file_read_text(path)
    result ?? ""
fn file_write(path: text, content: text) -> bool:
    rt_file_write_text(path, content)
fn file_exists(path: text) -> bool:
    rt_file_exists(path)

# ============================================================================
# StringInterner - Efficient string deduplication
# ============================================================================

class StringInterner:
    str_to_id: Dict<text, i32>    # string -> id mapping
    id_to_str: Dict<i32, text>    # id -> string mapping
    next_id: StringId

    # Create empty interner
    static fn empty() -> StringInterner:
        StringInterner(str_to_id: {}, id_to_str: {}, next_id: StringId(value: 0))

    # Intern a string, return its ID
    me intern(s: text) -> i32:
        if self.str_to_id.contains_key(s):
            self.str_to_id[s]
        else:
            val id = self.next_id.value
            self.str_to_id[s] = id
            self.id_to_str[id] = s
            self.next_id = StringId(value: self.next_id.value + 1)
            id

    # Get string by ID
    fn get(id: i32) -> text?:
        if self.id_to_str.contains_key(id):
            Some(self.id_to_str[id])
        else:
            nil

    # Lookup string by ID (alias for get)
    fn lookup(id: i32) -> text?:
        self.get(id)

    # Get ID by string (forward lookup)
    fn get_id(s: text) -> i32?:
        if self.str_to_id.contains_key(s):
            Some(self.str_to_id[s])
        else:
            nil

    # Get all (id, string) pairs
    fn all_strings() -> Dict<i32, text>:
        self.id_to_str

    # Load from SDN table
    static fn from_sdn(table: SdnTable) -> StringInterner:
        val interner = StringInterner(str_to_id: {}, id_to_str: {}, next_id: StringId(value: 0))
        for row in table.rows:
            if val Some(id_str) = row.get("id"):
                if val Some(value) = row.get("value"):
                    val id = id_str.to_int()
                    if id > 0:
                        interner.str_to_id[value] = id
                        interner.id_to_str[id] = value
                        if id >= interner.next_id.value:
                            interner.next_id = StringId(value: id + 1)
        interner

    # Export to SDN table
    fn to_sdn() -> SdnTable:
        val table = SdnTable(name: "strings", columns: ["id", "value"], rows: [], index: {})
        for (id, value) in self.id_to_str:
            val row = SdnRow(fields: {})
            row.set("id", "{id}")
            row.set("value", value)
            table.add_row(row)
        table

# ============================================================================
# SdnRow - Single row in SDN table
# ============================================================================

struct SdnRow:
    fields: Dict<text, text>

    # Create empty row
    static fn empty() -> SdnRow:
        SdnRow(fields: {})

    # Get field value
    fn get(column: text) -> text?:
        if self.fields.contains_key(column):
            Some(self.fields[column])
        else:
            nil

    # Get as i32
    fn get_i32(column: text) -> i32?:
        val value = self.get(column)?
        Some(value.to_int())

    # Get as i64
    fn get_i64(column: text) -> i64?:
        val value = self.get(column)?
        Some(value.to_int())

    # Get as f64
    fn get_f64(column: text) -> f64?:
        val value = self.get(column)?
        Some(value.to_float())

    # Get as bool
    fn get_bool(column: text) -> bool?:
        val value = self.get(column)?
        if value == "true":
            Some(true)
        elif value == "false":
            Some(false)
        else:
            nil

    # Set field value
    me set(column: text, value: text):
        self.fields[column] = value

    # Check if has column
    fn has(column: text) -> bool:
        self.fields.contains_key(column)

# ============================================================================
# SdnTable - In-memory representation of SDN table
# ============================================================================

class SdnTable:
    name: text
    columns: [text]
    rows: [SdnRow]
    index: Dict<text, i64>      # Primary key -> row index

    # Create new table
    static fn new(name: text, columns: [text]) -> SdnTable:
        SdnTable(name: name, columns: columns, rows: [], index: {})

    # Parse from SDN format
    static fn parse(content: text) -> SdnTable?:
        val lines = content.split("\n")
        if lines.len() == 0:
            return nil

        # Find table header line (format: "table_name |col1, col2, col3|")
        var header_idx = -1
        var table_name = ""
        var columns = []

        for (i, line) in lines.enumerate():
            val trimmed = line.trim()
            if trimmed.contains("|") and not trimmed.starts_with("#"):
                # Parse header
                val parts = trimmed.split("|")
                if parts.len() >= 3:
                    table_name = parts[0].trim()
                    val col_part = parts[1].trim()
                    # NOTE: Cannot chain .split().map() - bootstrap runtime bug
                    val raw_cols = col_part.split(",")
                    columns = raw_cols.map(\c: c.trim())
                    header_idx = i
                    break

        if header_idx == -1:
            return nil

        # Parse rows
        val table = SdnTable(name: table_name, columns: columns, rows: [], index: {})
        for i in (header_idx + 1)..lines.len():
            val line = lines[i].trim()
            if line == "" or line.starts_with("#"):
                continue

            # Parse row with quote-aware CSV splitting
            # Handles quoted values that contain commas
            val parts = split_sdn_row(line)
            if parts.len() != columns.len():
                continue

            val row = SdnRow(fields: {})
            for (j, col) in columns.enumerate():
                val value = parts[j].trim()
                # Strip surrounding quotes if present
                val unquoted = strip_quotes(value)
                row.set(col, unquoted)

            table.add_row(row)

        Some(table)

    # Export to SDN format
    fn to_sdn() -> text:
        var result = "{self.name} |"
        result = result + self.columns.join(", ")
        result = result + "|\n"

        for row in self.rows:
            result = result + "    "
            var values = []
            for col in self.columns:
                val value = row.get(col) ?? ""
                # Quote values that contain commas to preserve round-trip safety
                val formatted = quote_if_needed(value)
                values.push(formatted)
            result = result + values.join(", ")
            result = result + "\n"

        result

    # Add row
    me add_row(row: SdnRow) -> bool:
        # If has primary key (id field), add to index
        if row.has("id"):
            val id = row.get("id")?
            self.index[id] = self.rows.len()

        self.rows.push(row)
        true

    # Update row by primary key
    me update_row(key: text, row: SdnRow) -> bool:
        if not self.index.contains_key(key):
            return false

        val idx = self.index[key]
        self.rows[idx] = row
        true

    # Get row by primary key
    fn get_row(key: text) -> SdnRow?:
        if not self.index.contains_key(key):
            return nil

        val idx = self.index[key]
        Some(self.rows[idx])

    # Soft delete (set valid=false)
    me mark_deleted(key: text) -> bool:
        if not self.index.contains_key(key):
            return false

        val idx = self.index[key]
        # NOTE: self.rows[idx].set() modifies a copy in bootstrap runtime
        # Must read, modify, write back
        var row = self.rows[idx]
        row.set("valid", "false")
        self.rows[idx] = row
        true

    # Delete row by primary key (alias for mark_deleted)
    me delete_row(key: text) -> bool:
        self.mark_deleted(key)

    # Get all valid rows (where valid=true or no valid field)
    fn valid_rows() -> [SdnRow]:
        self.rows.filter(\r:
            val valid_opt = r.get("valid")
            if val Some(valid_str) = valid_opt:
                valid_str != "false"
            else:
                true
        )

    # Clear all rows and index
    me clear():
        self.rows.clear()
        self.index.clear()

    # Rebuild index after loading
    me rebuild_index():
        self.index.clear()
        for (i, row) in self.rows.enumerate():
            if row.has("id"):
                if val Some(id_value) = row.get("id"):
                    self.index[id_value] = i

# ============================================================================
# SdnDatabase - Base class for all databases
# ============================================================================

class SdnDatabase:
    path: text
    interner: StringInterner
    tables: Dict<text, SdnTable>
    modified: bool

    # Create new database
    static fn new(path: text) -> SdnDatabase:
        SdnDatabase(
            path: path,
            interner: StringInterner(str_to_id: {}, id_to_str: {}, next_id: StringId(value: 0)),
            tables: {},
            modified: false
        )

    # Load existing database
    static fn load(path: text) -> SdnDatabase?:
        if not file_exists(path):
            return nil

        val content = file_read(path)
        if content == "":
            return nil

        val db = SdnDatabase(path: path, tables: {}, interner: StringInterner(str_to_id: {}, id_to_str: {}, next_id: StringId(value: 0)), modified: false)

        # Parse all tables from file
        # Format: multiple tables separated by blank lines
        val sections = content.split("\n\n")
        for section in sections:
            if section.trim() == "":
                continue

            val table = parse_sdn_table(section)?

            # Special handling for strings table
            if table.name == "strings":
                db.interner = interner_from_sdn(table)
            else:
                table.rebuild_index()
                db.tables[table.name] = table

        db.modified = false
        Some(db)

    # Save to disk (atomic with file locking)
    me save() -> bool:
        var content = ""

        # Write strings table first
        val strings_table = self.interner.to_sdn()
        content = content + strings_table.to_sdn() + "\n\n"

        # Write all other tables
        for (name, table) in self.tables:
            content = content + table.to_sdn() + "\n\n"

        # Use atomic_write with FileLock to prevent race conditions
        # This acquires lock, writes temp file, renames, then releases lock
        if not atomic_write(self.path, content):
            return false

        self.modified = false
        true

    # Get table by name
    fn get_table(name: text) -> SdnTable?:
        if self.tables.contains_key(name):
            Some(self.tables[name])
        else:
            nil

    # Get mutable table reference
    me get_table_mut(name: text) -> SdnTable?:
        if self.tables.contains_key(name):
            Some(self.tables[name])
        else:
            nil

    # Add or update table
    me set_table(name: text, table: SdnTable):
        self.tables[name] = table
        self.modified = true

    # Add row to table (helper for common pattern)
    me add_row_to_table(table_name: text, row: SdnRow) -> bool:
        var table_opt = self.get_table_mut(table_name)
        if not table_opt.?:
            return false

        var table = table_opt.unwrap()
        table.add_row(row)
        self.set_table(table_name, table)
        true

    # Export a table to SDN text
    fn export_table_sdn(name: text) -> text?:
        if not self.tables.contains_key(name):
            return nil
        val table = self.tables[name]
        Some(table.to_sdn())

    # Import a table from SDN text
    me import_table_sdn(content: text) -> bool:
        val table = parse_sdn_table(content)
        if not table.?:
            return false
        val t = table.unwrap()
        t.rebuild_index()
        self.tables[t.name] = t
        self.modified = true
        true

    # String interning helpers
    me intern(s: text) -> i32:
        self.modified = true
        self.interner.intern(s)

    fn resolve(id: i32) -> text?:
        self.interner.get(id)

    # Validation - base checks applicable to all databases
    # Returns list of issue descriptions. Subclasses should call this
    # and add domain-specific checks.
    fn validate() -> [text]:
        var errors: [text] = []

        # Check interner consistency
        for (id, value) in self.interner.id_to_str:
            if id < 0 or id >= self.interner.next_id.value:
                errors.push("String interner: ID {id} out of bounds (max: {self.interner.next_id.value})")

        # Check valid column in all tables
        for (name, table) in self.tables:
            for row in table.rows:
                val valid_opt = row.get("valid")
                if val Some(valid_str) = valid_opt:
                    if valid_str != "true" and valid_str != "false":
                        val id = row.get("id") ?? "unknown"
                        errors.push("Table '{name}' row '{id}': invalid valid value '{valid_str}'")

        errors

# ============================================================================
# SDN Row Parsing Helpers (quote-aware CSV splitting)
# ============================================================================

# Split an SDN row line respecting quoted strings that may contain commas.
# For example: '1, "hello, world", true' -> ["1", '"hello, world"', "true"]
fn split_sdn_row(line: text) -> [text]:
    var parts = []
    var current = ""
    var in_quotes = false
    var i = 0

    while i < line.len():
        val ch = line[i]
        if ch == '"':
            in_quotes = not in_quotes
            current = current + ch
        elif ch == ',' and not in_quotes:
            parts = parts + [current]
            current = ""
        else:
            current = current + ch
        i = i + 1

    # Add last field
    if current != "" or parts.len() > 0:
        parts = parts + [current]

    parts

# Strip surrounding double quotes from a value.
# '"hello"' -> 'hello', 'plain' -> 'plain'
fn strip_quotes(value: text) -> text:
    if value.len() >= 2 and value.starts_with('"') and value.ends_with('"'):
        return value[1..(value.len() - 1)]
    value

# Quote a value if it contains commas (for SDN export).
fn quote_if_needed(value: text) -> text:
    if value.contains(","):
        return '"' + value + '"'
    value

# ============================================================================
# Standalone wrappers for static methods (bootstrap runtime compatibility)
# ============================================================================

fn parse_sdn_table(content: text) -> SdnTable?:
    SdnTable.parse(content)

fn interner_from_sdn(table: SdnTable) -> StringInterner:
    StringInterner.from_sdn(table)

fn new_sdn_database(path: text) -> SdnDatabase:
    SdnDatabase.new(path)

fn load_sdn_database(path: text) -> SdnDatabase?:
    SdnDatabase.load(path)

# ============================================================================
# Exports
# ============================================================================

export StringInterner
export SdnRow, SdnTable, SdnDatabase
export parse_sdn_table, interner_from_sdn, new_sdn_database, load_sdn_database
export split_sdn_row, strip_quotes, quote_if_needed
