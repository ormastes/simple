# Fail-Safe Framework Core
# Pure Simple implementation - no FFI dependencies

use compiler.core.*

# ============================================================================
# ERROR TYPES
# ============================================================================

pub enum ErrorSeverity:
    Debug
    Info
    Warning
    Error
    Critical
    Fatal

    pub fn to_string() -> text:
        match self:
            case Debug: "debug"
            case Info: "info"
            case Warning: "warning"
            case Error: "error"
            case Critical: "critical"
            case Fatal: "fatal"

    pub fn to_level() -> i64:
        match self:
            case Debug: 0
            case Info: 1
            case Warning: 2
            case Error: 3
            case Critical: 4
            case Fatal: 5

pub enum ErrorCategory:
    Network
    Timeout
    Validation
    Internal
    RateLimit
    TooManyRequests
    Panic
    Overflow
    DivisionByZero
    ResourceExhausted
    Exhausted

    pub fn to_string() -> text:
        match self:
            case Network: "network"
            case Timeout: "timeout"
            case Validation: "validation"
            case Internal: "internal"
            case RateLimit: "rate_limit"
            case TooManyRequests: "too_many_requests"
            case Panic: "panic"
            case Overflow: "overflow"
            case DivisionByZero: "division_by_zero"
            case ResourceExhausted: "resource_exhausted"
            case Exhausted: "exhausted"

    pub fn is_recoverable() -> bool:
        match self:
            case Network: true
            case Timeout: true
            case RateLimit: true
            case TooManyRequests: true
            case Panic: false
            case Internal: false
            case _: true

# ============================================================================
# FAIL-SAFE ERROR
# ============================================================================

pub class FailSafeError:
    pub category: ErrorCategory
    pub severity: ErrorSeverity
    pub message: text
    pub recoverable: bool
    pub retry_after_ms: i64

    static fn new(category: ErrorCategory, message: text) -> FailSafeError:
        return FailSafeError(
            category,
            ErrorSeverity.Error,
            message,
            category.is_recoverable(),
            0
        )

    pub fn with_severity(severity: ErrorSeverity) -> FailSafeError:
        return FailSafeError(
            self.category,
            severity,
            self.message,
            self.recoverable,
            self.retry_after_ms
        )

    pub fn with_retry(retry_after_ms: i64) -> FailSafeError:
        return FailSafeError(
            self.category,
            self.severity,
            self.message,
            true,
            retry_after_ms
        )

    pub fn as_unrecoverable() -> FailSafeError:
        return FailSafeError(
            self.category,
            self.severity,
            self.message,
            false,
            0
        )

    pub fn to_string() -> text:
        return "[{self.severity.to_string()}] {self.category.to_string()}: {self.message}"

# ============================================================================
# FAIL-SAFE RESULT
# ============================================================================

pub enum FailSafeResult<T>:
    Ok(T)
    Err(FailSafeError)

    pub fn is_ok() -> bool:
        match self:
            case Ok(_): true
            case Err(_): false

    pub fn is_err() -> bool:
        return not self.is_ok()

    pub fn unwrap() -> T:
        match self:
            case Ok(v): v
            case Err(e): panic("unwrap on Err: {e.message}")

    pub fn unwrap_or(default: T) -> T:
        match self:
            case Ok(v): v
            case Err(_): default

# ============================================================================
# HEALTH STATUS
# ============================================================================

pub enum HealthStatus:
    Healthy
    Degraded
    Unhealthy

    pub fn to_string() -> text:
        match self:
            case Healthy: "healthy"
            case Degraded: "degraded"
            case Unhealthy: "unhealthy"

    pub fn is_healthy() -> bool:
        match self:
            case Healthy: true
            case _: false

# ============================================================================
# METRICS
# ============================================================================

pub class Counter:
    pub name: text
    pub value: i64

    static fn new(name: text) -> Counter:
        return Counter(name, 0)

    pub me inc():
        self.value = self.value + 1

    pub me add(n: i64):
        self.value = self.value + n

    pub me reset():
        self.value = 0

pub class Gauge:
    pub name: text
    pub value: f64

    static fn new(name: text) -> Gauge:
        return Gauge(name, 0.0)

    pub me set(v: f64):
        self.value = v

    pub me inc():
        self.value = self.value + 1.0

    pub me dec():
        self.value = self.value - 1.0

    pub me add(n: f64):
        self.value = self.value + n

    pub me sub(n: f64):
        self.value = self.value - n

pub class MetricsRegistry:
    pub counters: Dict<text, Counter>
    pub gauges: Dict<text, Gauge>

    static fn new() -> MetricsRegistry:
        return MetricsRegistry({}, {})

    pub me get_counter(name: text) -> Counter:
        match self.counters.get(name):
            case Some(c): return c
            case nil:
                val c = Counter.new(name)
                self.counters.set(name, c)
                return c

    pub me get_gauge(name: text) -> Gauge:
        match self.gauges.get(name):
            case Some(g): return g
            case nil:
                val g = Gauge.new(name)
                self.gauges.set(name, g)
                return g

# ============================================================================
# LOGGING
# ============================================================================

pub enum LogLevel:
    Debug
    Info
    Warn
    Error

    pub fn to_string() -> text:
        match self:
            case Debug: "DEBUG"
            case Info: "INFO"
            case Warn: "WARN"
            case Error: "ERROR"

    pub fn to_i64() -> i64:
        match self:
            case Debug: 0
            case Info: 1
            case Warn: 2
            case Error: 3

pub class ConsoleLogger:
    pub min_level: LogLevel

    static fn new(min_level: LogLevel) -> ConsoleLogger:
        return ConsoleLogger(min_level)

    pub fn is_enabled(level: LogLevel) -> bool:
        return level.to_i64() >= self.min_level.to_i64()

    pub fn log(level: LogLevel, message: text):
        if self.is_enabled(level):
            print "[{level.to_string()}] {message}"
