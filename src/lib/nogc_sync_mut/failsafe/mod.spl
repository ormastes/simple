# Fail-Safe Framework
# Pure Simple implementation - no FFI dependencies

use compiler_core.*
use std.failsafe.core.*
use std.failsafe.panic.*
use std.failsafe.ratelimit.*
use std.failsafe.circuit.*
use std.failsafe.timeout.*
use std.failsafe.resource_monitor.*

# ============================================================================
# UNIFIED FAIL-SAFE CONTEXT
# ============================================================================

pub class FailSafeContext:
    pub name: text
    pub panic_handler: PanicHandler
    pub rate_limiter: RateLimiter
    pub circuit_breaker: CircuitBreaker
    pub timeout_manager: TimeoutManager
    pub resource_monitor: ResourceMonitor
    pub metrics: MetricsRegistry
    pub enabled: bool

    static fn new(name: text) -> FailSafeContext:
        return FailSafeContext(
            name,
            PanicHandler__new(),
            RateLimiter__default(),
            CircuitBreaker__default(name),
            TimeoutManager__default(),
            ResourceMonitor__default(),
            MetricsRegistry__new(),
            true
        )

    pub me execute<T>(
        operation_name: text,
        client_id: text,
        operation: fn() -> T
    ) -> FailSafeResult<T>:
        if not self.enabled:
            return FailSafeResult.Ok(operation())

        # Rate limiting
        match self.rate_limiter.check(client_id):
            case RateLimitDecision.Deny(retry_after):
                self.metrics.get_counter("requests_rate_limited").inc()
                return FailSafeResult.Err(
                    FailSafeError__new(ErrorCategory.TooManyRequests, "Rate limit exceeded")
                        .with_retry(retry_after)
                )
            case _:
                pass

        # Circuit breaker
        if not self.circuit_breaker.allow_request():
            self.metrics.get_counter("requests_circuit_open").inc()
            return FailSafeResult.Err(
                FailSafeError__new(ErrorCategory.RateLimit, "Circuit breaker open")
                    .with_retry(1000)
            )

        # Execute
        val token = self.timeout_manager.start_timeout(operation_name)
        val result = operation()
        self.timeout_manager.complete_timeout(token.id)
        self.circuit_breaker.record_success()
        self.metrics.get_counter("requests_succeeded").inc()
        return FailSafeResult.Ok(result)

    pub fn get_health() -> HealthStatus:
        if self.circuit_breaker.is_open():
            return HealthStatus.Degraded

        val alerts = self.resource_monitor.get_unacknowledged_alerts()
        for alert in alerts:
            match alert.level:
                case AlertLevel.Critical: return HealthStatus.Unhealthy
                case AlertLevel.Emergency: return HealthStatus.Unhealthy
                case _: pass

        return HealthStatus.Healthy

    pub me reset():
        self.panic_handler.reset()
        self.rate_limiter.reset()
        self.circuit_breaker.reset()
        self.resource_monitor.reset()

    pub me enable():
        self.enabled = true
        self.rate_limiter.enable()
        self.resource_monitor.enable()

    pub me disable():
        self.enabled = false
        self.rate_limiter.disable()
        self.resource_monitor.disable()

# ============================================================================
# PROTOCOL-SPECIFIC CONFIGS
# ============================================================================

pub class McpFailSafeConfig:
    pub rate_limit: RateLimitConfig
    pub circuit_breaker: CircuitBreakerConfig
    pub timeout: TimeoutConfig
    pub resource_limits: ResourceLimits

    static fn default() -> McpFailSafeConfig:
        return McpFailSafeConfig(
            RateLimitConfig__default(),
            CircuitBreakerConfig__default(),
            TimeoutConfig__default(),
            ResourceLimits__default()
        )

pub class LspFailSafeConfig:
    pub rate_limit: RateLimitConfig
    pub circuit_breaker: CircuitBreakerConfig
    pub timeout: TimeoutConfig
    pub resource_limits: ResourceLimits

    static fn default() -> LspFailSafeConfig:
        return LspFailSafeConfig(
            RateLimitConfig(200.0, 100, 500),
            CircuitBreakerConfig(10, 3, 5),
            TimeoutConfig(10000, 60000),
            ResourceLimits__default()
        )

pub class DapFailSafeConfig:
    pub rate_limit: RateLimitConfig
    pub circuit_breaker: CircuitBreakerConfig
    pub timeout: TimeoutConfig
    pub resource_limits: ResourceLimits

    static fn default() -> DapFailSafeConfig:
        return DapFailSafeConfig(
            RateLimitConfig(100.0, 50, 1000),
            CircuitBreakerConfig(5, 3, 3),
            TimeoutConfig(30000, 120000),
            ResourceLimits(2 * 1024 * 1024 * 1024, 2048, 128, 200, 0.80, 0.95)
        )

# ============================================================================
# FACTORY FUNCTIONS
# ============================================================================

pub fn create_mcp_context(name: text, config: McpFailSafeConfig) -> FailSafeContext:
    return FailSafeContext(
        name,
        PanicHandler__new(),
        RateLimiter__new(config.rate_limit),
        CircuitBreaker__new(name, config.circuit_breaker),
        TimeoutManager__new(config.timeout),
        ResourceMonitor__new(config.resource_limits),
        MetricsRegistry__new(),
        true
    )

pub fn create_lsp_context(name: text, config: LspFailSafeConfig) -> FailSafeContext:
    return FailSafeContext(
        name,
        PanicHandler__new(),
        RateLimiter__new(config.rate_limit),
        CircuitBreaker__new(name, config.circuit_breaker),
        TimeoutManager__new(config.timeout),
        ResourceMonitor__new(config.resource_limits),
        MetricsRegistry__new(),
        true
    )

pub fn create_dap_context(name: text, config: DapFailSafeConfig) -> FailSafeContext:
    return FailSafeContext(
        name,
        PanicHandler__new(),
        RateLimiter__new(config.rate_limit),
        CircuitBreaker__new(name, config.circuit_breaker),
        TimeoutManager__new(config.timeout),
        ResourceMonitor__new(config.resource_limits),
        MetricsRegistry__new(),
        true
    )
