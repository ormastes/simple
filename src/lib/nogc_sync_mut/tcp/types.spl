# TCP Types and Constants
#
# Type definitions and constants for TCP socket operations

# Connection State Constants
val TCP_STATE_CLOSED = 0
val TCP_STATE_LISTEN = 1
val TCP_STATE_SYN_SENT = 2
val TCP_STATE_SYN_RECEIVED = 3
val TCP_STATE_ESTABLISHED = 4
val TCP_STATE_FIN_WAIT_1 = 5
val TCP_STATE_FIN_WAIT_2 = 6
val TCP_STATE_CLOSE_WAIT = 7
val TCP_STATE_CLOSING = 8
val TCP_STATE_LAST_ACK = 9
val TCP_STATE_TIME_WAIT = 10

# Socket Option Constants
val TCP_OPT_KEEPALIVE = 1
val TCP_OPT_NODELAY = 2
val TCP_OPT_QUICKACK = 3
val TCP_OPT_CORK = 4
val TCP_OPT_LINGER = 5
val TCP_OPT_REUSEADDR = 6
val TCP_OPT_REUSEPORT = 7

# Buffer Size Constants
val TCP_DEFAULT_RECV_BUFFER = 65536
val TCP_DEFAULT_SEND_BUFFER = 65536
val TCP_MAX_BUFFER_SIZE = 2097152
val TCP_MIN_BUFFER_SIZE = 1024

# Port Range Constants
val TCP_MIN_PORT = 1
val TCP_MAX_PORT = 65535
val TCP_EPHEMERAL_START = 49152
val TCP_EPHEMERAL_END = 65535
val TCP_WELL_KNOWN_END = 1023
val TCP_REGISTERED_END = 49151

# Timeout Constants (milliseconds)
val TCP_DEFAULT_CONNECT_TIMEOUT = 30000
val TCP_DEFAULT_READ_TIMEOUT = 60000
val TCP_DEFAULT_WRITE_TIMEOUT = 60000
val TCP_KEEPALIVE_INTERVAL = 75000

# Connection Pool Constants
val TCP_POOL_DEFAULT_SIZE = 10
val TCP_POOL_MAX_SIZE = 100
val TCP_POOL_IDLE_TIMEOUT = 300000

# Error Constants
val TCP_ERR_INVALID_ADDRESS = -1
val TCP_ERR_INVALID_PORT = -2
val TCP_ERR_CONNECTION_REFUSED = -3
val TCP_ERR_TIMEOUT = -4
val TCP_ERR_BUFFER_FULL = -5
val TCP_ERR_INVALID_STATE = -6
val TCP_ERR_POOL_FULL = -7

# Create a new TCP connection tuple
fn tcp_connection_create(address: text, port: i64) -> (text, i64, i64, text, text, list, i64):
    val empty_buffer = ""
    val empty_options = []
    val timestamp = 0
    (address, port, TCP_STATE_CLOSED, empty_buffer, empty_buffer, empty_options, timestamp)

# Get connection address
fn tcp_connection_get_address(conn: (text, i64, i64, text, text, list, i64)) -> text:
    val addr = conn.0
    addr

# Get connection port
fn tcp_connection_get_port(conn: (text, i64, i64, text, text, list, i64)) -> i64:
    val port = conn.1
    port

# Get connection state
fn tcp_connection_get_state(conn: (text, i64, i64, text, text, list, i64)) -> i64:
    val state = conn.2
    state

# Get receive buffer
fn tcp_connection_get_recv_buffer(conn: (text, i64, i64, text, text, list, i64)) -> text:
    val buffer = conn.3
    buffer

# Get send buffer
fn tcp_connection_get_send_buffer(conn: (text, i64, i64, text, text, list, i64)) -> text:
    val buffer = conn.4
    buffer

# Get connection options
fn tcp_connection_get_options(conn: (text, i64, i64, text, text, list, i64)) -> list:
    val opts = conn.5
    opts

# Get connection timestamp
fn tcp_connection_get_timestamp(conn: (text, i64, i64, text, text, list, i64)) -> i64:
    val ts = conn.6
    ts

# Set connection state
fn tcp_connection_set_state(conn: (text, i64, i64, text, text, list, i64), state: i64) -> (text, i64, i64, text, text, list, i64):
    val addr = conn.0
    val port = conn.1
    val recv_buf = conn.3
    val send_buf = conn.4
    val opts = conn.5
    val ts = conn.6
    (addr, port, state, recv_buf, send_buf, opts, ts)

# Set receive buffer
fn tcp_connection_set_recv_buffer(conn: (text, i64, i64, text, text, list, i64), buffer: text) -> (text, i64, i64, text, text, list, i64):
    val addr = conn.0
    val port = conn.1
    val state = conn.2
    val send_buf = conn.4
    val opts = conn.5
    val ts = conn.6
    (addr, port, state, buffer, send_buf, opts, ts)

# Set send buffer
fn tcp_connection_set_send_buffer(conn: (text, i64, i64, text, text, list, i64), buffer: text) -> (text, i64, i64, text, text, list, i64):
    val addr = conn.0
    val port = conn.1
    val state = conn.2
    val recv_buf = conn.3
    val opts = conn.5
    val ts = conn.6
    (addr, port, state, recv_buf, buffer, opts, ts)

# Set connection options
fn tcp_connection_set_options(conn: (text, i64, i64, text, text, list, i64), options: list) -> (text, i64, i64, text, text, list, i64):
    val addr = conn.0
    val port = conn.1
    val state = conn.2
    val recv_buf = conn.3
    val send_buf = conn.4
    val ts = conn.6
    (addr, port, state, recv_buf, send_buf, options, ts)

# Set connection timestamp
fn tcp_connection_set_timestamp(conn: (text, i64, i64, text, text, list, i64), timestamp: i64) -> (text, i64, i64, text, text, list, i64):
    val addr = conn.0
    val port = conn.1
    val state = conn.2
    val recv_buf = conn.3
    val send_buf = conn.4
    val opts = conn.5
    (addr, port, state, recv_buf, send_buf, opts, timestamp)

# Get state name from state code
fn tcp_state_to_string(state: i64) -> text:
    if state == TCP_STATE_CLOSED:
        "CLOSED"
    else:
        if state == TCP_STATE_LISTEN:
            "LISTEN"
        else:
            if state == TCP_STATE_SYN_SENT:
                "SYN_SENT"
            else:
                if state == TCP_STATE_SYN_RECEIVED:
                    "SYN_RECEIVED"
                else:
                    if state == TCP_STATE_ESTABLISHED:
                        "ESTABLISHED"
                    else:
                        if state == TCP_STATE_FIN_WAIT_1:
                            "FIN_WAIT_1"
                        else:
                            if state == TCP_STATE_FIN_WAIT_2:
                                "FIN_WAIT_2"
                            else:
                                if state == TCP_STATE_CLOSE_WAIT:
                                    "CLOSE_WAIT"
                                else:
                                    if state == TCP_STATE_CLOSING:
                                        "CLOSING"
                                    else:
                                        if state == TCP_STATE_LAST_ACK:
                                            "LAST_ACK"
                                        else:
                                            if state == TCP_STATE_TIME_WAIT:
                                                "TIME_WAIT"
                                            else:
                                                "UNKNOWN"

# Check if state is valid
fn tcp_state_is_valid(state: i64) -> bool:
    val valid = state >= TCP_STATE_CLOSED
    if valid:
        state <= TCP_STATE_TIME_WAIT
    else:
        false

# Check if connection can send data
fn tcp_state_can_send(state: i64) -> bool:
    val established = state == TCP_STATE_ESTABLISHED
    if established:
        true
    else:
        state == TCP_STATE_CLOSE_WAIT

# Check if connection can receive data
fn tcp_state_can_receive(state: i64) -> bool:
    val established = state == TCP_STATE_ESTABLISHED
    if established:
        true
    else:
        val fin_wait = state == TCP_STATE_FIN_WAIT_1
        if fin_wait:
            true
        else:
            state == TCP_STATE_FIN_WAIT_2

# Check if connection is closed
fn tcp_state_is_closed(state: i64) -> bool:
    state == TCP_STATE_CLOSED

# Check if connection is established
fn tcp_state_is_established(state: i64) -> bool:
    state == TCP_STATE_ESTABLISHED

# Check if connection is listening
fn tcp_state_is_listening(state: i64) -> bool:
    state == TCP_STATE_LISTEN

# Validate state transition
fn tcp_state_transition_valid(from_state: i64, to_state: i64) -> bool:
    if from_state == TCP_STATE_CLOSED:
        val listen = to_state == TCP_STATE_LISTEN
        if listen:
            true
        else:
            to_state == TCP_STATE_SYN_SENT
    else:
        if from_state == TCP_STATE_LISTEN:
            val syn_recv = to_state == TCP_STATE_SYN_RECEIVED
            if syn_recv:
                true
            else:
                to_state == TCP_STATE_CLOSED
        else:
            if from_state == TCP_STATE_SYN_SENT:
                val established = to_state == TCP_STATE_ESTABLISHED
                if established:
                    true
                else:
                    val syn_recv = to_state == TCP_STATE_SYN_RECEIVED
                    if syn_recv:
                        true
                    else:
                        to_state == TCP_STATE_CLOSED
            else:
                if from_state == TCP_STATE_ESTABLISHED:
                    val fin_wait = to_state == TCP_STATE_FIN_WAIT_1
                    if fin_wait:
                        true
                    else:
                        to_state == TCP_STATE_CLOSE_WAIT
                else:
                    true

export TCP_STATE_CLOSED
export TCP_STATE_LISTEN
export TCP_STATE_SYN_SENT
export TCP_STATE_SYN_RECEIVED
export TCP_STATE_ESTABLISHED
export TCP_STATE_FIN_WAIT_1
export TCP_STATE_FIN_WAIT_2
export TCP_STATE_CLOSE_WAIT
export TCP_STATE_CLOSING
export TCP_STATE_LAST_ACK
export TCP_STATE_TIME_WAIT
export TCP_OPT_KEEPALIVE
export TCP_OPT_NODELAY
export TCP_OPT_QUICKACK
export TCP_OPT_CORK
export TCP_OPT_LINGER
export TCP_OPT_REUSEADDR
export TCP_OPT_REUSEPORT
export TCP_DEFAULT_RECV_BUFFER
export TCP_DEFAULT_SEND_BUFFER
export TCP_MAX_BUFFER_SIZE
export TCP_MIN_BUFFER_SIZE
export TCP_MIN_PORT
export TCP_MAX_PORT
export TCP_EPHEMERAL_START
export TCP_EPHEMERAL_END
export TCP_WELL_KNOWN_END
export TCP_REGISTERED_END
export TCP_DEFAULT_CONNECT_TIMEOUT
export TCP_DEFAULT_READ_TIMEOUT
export TCP_DEFAULT_WRITE_TIMEOUT
export TCP_KEEPALIVE_INTERVAL
export TCP_POOL_DEFAULT_SIZE
export TCP_POOL_MAX_SIZE
export TCP_POOL_IDLE_TIMEOUT
export TCP_ERR_INVALID_ADDRESS
export TCP_ERR_INVALID_PORT
export TCP_ERR_CONNECTION_REFUSED
export TCP_ERR_TIMEOUT
export TCP_ERR_BUFFER_FULL
export TCP_ERR_INVALID_STATE
export TCP_ERR_POOL_FULL
export tcp_connection_create
export tcp_connection_get_address
export tcp_connection_get_port
export tcp_connection_get_state
export tcp_connection_get_recv_buffer
export tcp_connection_get_send_buffer
export tcp_connection_get_options
export tcp_connection_get_timestamp
export tcp_connection_set_state
export tcp_connection_set_recv_buffer
export tcp_connection_set_send_buffer
export tcp_connection_set_options
export tcp_connection_set_timestamp
export tcp_state_to_string
export tcp_state_is_valid
export tcp_state_can_send
export tcp_state_can_receive
export tcp_state_is_closed
export tcp_state_is_established
export tcp_state_is_listening
export tcp_state_transition_valid
