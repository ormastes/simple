# Table - DataFrame-like tabular data structure
#
# Provides:
# - Table type for columnar data
# - Column type with typed data
# - SQL-like operations (select, where, group_by, join)
# - Statistical operations on columns
# - Integration with tensor operations
#
# Inspired by: R data.frame, pandas DataFrame, Julia DataFrames

use tensor.*

# ============================================================================
# Column Type
# ============================================================================

enum ColumnType:
    """Data type of a column."""
    Int
    Float
    Bool
    Text
    Tensor

struct Column:
    """A single column of typed data."""
    name: text
    dtype: ColumnType
    data: [Any]

impl Column:
    static fn from_ints(name: text, values: [i64]) -> Column:
        """Create column from integer array."""
        Column(name: name, dtype: ColumnType.Int, data: values)

    static fn from_floats(name: text, values: [f64]) -> Column:
        """Create column from float array."""
        Column(name: name, dtype: ColumnType.Float, data: values)

    static fn from_bools(name: text, values: [bool]) -> Column:
        """Create column from boolean array."""
        Column(name: name, dtype: ColumnType.Bool, data: values)

    static fn from_texts(name: text, values: [text]) -> Column:
        """Create column from text array."""
        Column(name: name, dtype: ColumnType.Text, data: values)

    # ========================================================================
    # Properties
    # ========================================================================

    fn len() -> i64:
        """Number of elements in column."""
        self.data.len()

    fn is_empty() -> bool:
        """True if column has no elements."""
        self.data.is_empty()

    # ========================================================================
    # Indexing
    # ========================================================================

    fn get(index: i64) -> Any:
        """Get element at index."""
        self.data[index]

    fn slice(start: i64, end: i64) -> Column:
        """Get slice of column."""
        Column(name: self.name, dtype: self.dtype, data: self.data[start:end])

    # ========================================================================
    # Reductions (for numeric columns)
    # ========================================================================

    fn sum() -> f64:
        """Sum of all elements (numeric columns only)."""
        var total = 0.0
        for val in self.data:
            total = total + val as f64
        total

    fn mean() -> f64:
        """Mean of all elements (numeric columns only)."""
        self.sum() / self.len() as f64

    fn min() -> Any:
        """Minimum element."""
        var result = self.data[0]
        for val in self.data:
            if val < result:
                result = val
        result

    fn max() -> Any:
        """Maximum element."""
        var result = self.data[0]
        for val in self.data:
            if val > result:
                result = val
        result

    fn std() -> f64:
        """Standard deviation (numeric columns only)."""
        val mu = self.mean()
        var sum_sq = 0.0
        for val in self.data:
            val diff = val as f64 - mu
            sum_sq = sum_sq + diff * diff
        (sum_sq / self.len() as f64).sqrt()

    fn var() -> f64:
        """Variance (numeric columns only)."""
        val s = self.std()
        s * s

    fn median() -> f64:
        """Median value (numeric columns only)."""
        var sorted = self.data.sorted()
        val n = sorted.len()
        if n % 2 == 1:
            sorted[n / 2] as f64
        else:
            (sorted[n / 2 - 1] as f64 + sorted[n / 2] as f64) / 2.0

    # ========================================================================
    # Transformations
    # ========================================================================

    fn map<U>(f: fn(Any) -> U) -> Column:
        """Apply function to each element."""
        var result: [Any] = []
        for val in self.data:
            result = result.push(f(val))
        Column(name: self.name, dtype: self.dtype, data: result)

    fn filter(predicate: fn(Any) -> bool) -> Column:
        """Keep elements matching predicate."""
        var result: [Any] = []
        for val in self.data:
            if predicate(val):
                result = result.push(val)
        Column(name: self.name, dtype: self.dtype, data: result)

    # ========================================================================
    # Type Conversions
    # ========================================================================

    fn as_ints() -> [i64]:
        """Convert to integer array."""
        var result: [i64] = []
        for val in self.data:
            result = result.push(val as i64)
        result

    fn as_floats() -> [f64]:
        """Convert to float array."""
        var result: [f64] = []
        for val in self.data:
            result = result.push(val as f64)
        result

    fn as_tensor() -> Vector<f64>:
        """Convert to 1D tensor."""
        @ffi("torch.tensor", self.as_floats())

    # ========================================================================
    # Unique and Counts
    # ========================================================================

    fn unique() -> Column:
        """Get unique values."""
        var seen: Set<Any> = Set.new()
        var result: [Any] = []
        for val in self.data:
            if not seen.has(val):
                seen.insert(val)
                result = result.push(val)
        Column(name: self.name, dtype: self.dtype, data: result)

    fn value_counts() -> Table:
        """Count occurrences of each value."""
        var counts: Dict<Any, i64> = {}
        for val in self.data:
            if counts.has(val):
                counts[val] = counts[val] + 1
            else:
                counts[val] = 1

        var values: [Any] = []
        var count_vals: [i64] = []
        for val, count in counts:
            values = values.push(val)
            count_vals = count_vals.push(count)

        Table.from_columns([
            Column(name: self.name, dtype: self.dtype, data: values),
            Column.from_ints("count", count_vals)
        ])


# ============================================================================
# Table Type
# ============================================================================

struct Table:
    """Tabular data structure with named columns."""
    columns: Dict<text, Column>
    column_order: [text]
    row_count: i64

impl Table:
    # ========================================================================
    # Construction
    # ========================================================================

    static fn new() -> Table:
        """Create empty table."""
        Table(columns: {}, column_order: [], row_count: 0)

    static fn from_columns(cols: [Column]) -> Table:
        """Create table from list of columns."""
        var columns: Dict<text, Column> = {}
        var order: [text] = []
        var row_count = 0

        for col in cols:
            columns[col.name] = col
            order = order.push(col.name)
            if col.len() > row_count:
                row_count = col.len()

        Table(columns: columns, column_order: order, row_count: row_count)

    static fn from_dict(data: Dict<text, [Any]>) -> Table:
        """Create table from dictionary of arrays."""
        var cols: [Column] = []
        for name, values in data:
            # Infer column type from first element
            val dtype = if values.is_empty():
                ColumnType.Text
            else:
                match values[0]:
                    case i64: ColumnType.Int
                    case f64: ColumnType.Float
                    case bool: ColumnType.Bool
                    case text: ColumnType.Text
                    case _: ColumnType.Text
            cols = cols.push(Column(name: name, dtype: dtype, data: values))
        Table.from_columns(cols)

    # ========================================================================
    # Properties
    # ========================================================================

    fn shape() -> (i64, i64):
        """Get (rows, columns) shape."""
        (self.row_count, self.column_order.len())

    fn nrows() -> i64:
        """Number of rows."""
        self.row_count

    fn ncols() -> i64:
        """Number of columns."""
        self.column_order.len()

    fn column_names() -> [text]:
        """Get list of column names."""
        self.column_order

    fn dtypes() -> Dict<text, ColumnType>:
        """Get column types."""
        var result: Dict<text, ColumnType> = {}
        for name in self.column_order:
            result[name] = self.columns[name].dtype
        result

    # ========================================================================
    # Column Access
    # ========================================================================

    fn get(name: text) -> Column:
        """Get column by name."""
        self.columns[name]

    fn has_column(name: text) -> bool:
        """Check if column exists."""
        self.columns.has(name)

    # Dot syntax for column access (via __getattr__)
    fn __getattr__(name: text) -> Column:
        """Access column via dot syntax: table.column_name"""
        self.get(name)

    # ========================================================================
    # Row Access
    # ========================================================================

    fn row(index: i64) -> Dict<text, Any>:
        """Get row as dictionary."""
        var result: Dict<text, Any> = {}
        for name in self.column_order:
            result[name] = self.columns[name].get(index)
        result

    fn head(n: i64 = 5) -> Table:
        """Get first n rows."""
        var cols: [Column] = []
        for name in self.column_order:
            cols = cols.push(self.columns[name].slice(0, min(n, self.row_count)))
        Table.from_columns(cols)

    fn tail(n: i64 = 5) -> Table:
        """Get last n rows."""
        val start = max(0, self.row_count - n)
        var cols: [Column] = []
        for name in self.column_order:
            cols = cols.push(self.columns[name].slice(start, self.row_count))
        Table.from_columns(cols)

    # ========================================================================
    # Selection
    # ========================================================================

    fn select(names: [text]) -> Table:
        """Select specific columns."""
        var cols: [Column] = []
        for name in names:
            if self.has_column(name):
                cols = cols.push(self.columns[name])
        Table.from_columns(cols)

    fn drop(names: [text]) -> Table:
        """Drop specific columns."""
        var cols: [Column] = []
        for name in self.column_order:
            if not names.contains(name):
                cols = cols.push(self.columns[name])
        Table.from_columns(cols)

    fn rename(old_name: text, new_name: text) -> Table:
        """Rename a column."""
        var cols: [Column] = []
        for name in self.column_order:
            val col = self.columns[name]
            if name == old_name:
                cols = cols.push(Column(name: new_name, dtype: col.dtype, data: col.data))
            else:
                cols = cols.push(col)
        Table.from_columns(cols)

    # ========================================================================
    # Filtering
    # ========================================================================

    fn where(predicate: fn(Dict<text, Any>) -> bool) -> Table:
        """Filter rows matching predicate.

        Example:
            table.where(\row: row["age"] > 30)
        """
        var indices: [i64] = []
        for i in 0..self.row_count:
            val row = self.row(i)
            if predicate(row):
                indices = indices.push(i)

        var cols: [Column] = []
        for name in self.column_order:
            val col = self.columns[name]
            var data: [Any] = []
            for idx in indices:
                data = data.push(col.get(idx))
            cols = cols.push(Column(name: name, dtype: col.dtype, data: data))

        Table.from_columns(cols)

    fn filter_by(column: text, predicate: fn(Any) -> bool) -> Table:
        """Filter rows by column value.

        Example:
            table.filter_by("age", \v: v > 30)
        """
        self.where(\row: predicate(row[column]))

    # ========================================================================
    # Sorting
    # ========================================================================

    fn sort_by(column: text, ascending: bool = true) -> Table:
        """Sort by column values."""
        val col = self.columns[column]

        # Get sorted indices
        var indices: [i64] = []
        for i in 0..self.row_count:
            indices = indices.push(i)

        # Sort indices by column values
        indices = indices.sorted_by(\i, j:
            val a = col.get(i)
            val b = col.get(j)
            if ascending:
                a < b
            else:
                a > b
        )

        # Reorder all columns
        var cols: [Column] = []
        for name in self.column_order:
            val c = self.columns[name]
            var data: [Any] = []
            for idx in indices:
                data = data.push(c.get(idx))
            cols = cols.push(Column(name: name, dtype: c.dtype, data: data))

        Table.from_columns(cols)

    # ========================================================================
    # Grouping and Aggregation
    # ========================================================================

    fn group_by(columns: [text]) -> GroupedTable:
        """Group by one or more columns."""
        GroupedTable(table: self, group_columns: columns)

    # ========================================================================
    # Joins
    # ========================================================================

    fn join(other: Table, on: text, how: text = "inner") -> Table:
        """Join with another table.

        Args:
            other: Table to join with
            on: Column name to join on
            how: Join type ("inner", "left", "right", "outer")
        """
        # Build index for right table
        var right_index: Dict<Any, [i64]> = {}
        for i in 0..other.row_count:
            val key = other.columns[on].get(i)
            if right_index.has(key):
                right_index[key] = right_index[key].push(i)
            else:
                right_index[key] = [i]

        # Collect matching pairs
        var left_indices: [i64] = []
        var right_indices: [i64] = []

        for i in 0..self.row_count:
            val key = self.columns[on].get(i)
            if right_index.has(key):
                for j in right_index[key]:
                    left_indices = left_indices.push(i)
                    right_indices = right_indices.push(j)

        # Build result columns
        var cols: [Column] = []

        # Add left table columns
        for name in self.column_order:
            val col = self.columns[name]
            var data: [Any] = []
            for idx in left_indices:
                data = data.push(col.get(idx))
            cols = cols.push(Column(name: name, dtype: col.dtype, data: data))

        # Add right table columns (except join key)
        for name in other.column_order:
            if name != on:
                val col = other.columns[name]
                var data: [Any] = []
                for idx in right_indices:
                    data = data.push(col.get(idx))
                cols = cols.push(Column(name: name, dtype: col.dtype, data: data))

        Table.from_columns(cols)

    fn left_join(other: Table, on: text) -> Table:
        """Left join with another table."""
        self.join(other, on, "left")

    fn right_join(other: Table, on: text) -> Table:
        """Right join with another table."""
        self.join(other, on, "right")

    # ========================================================================
    # Mutation
    # ========================================================================

    me add_column(col: Column):
        """Add a new column."""
        self.columns[col.name] = col
        self.column_order = self.column_order.push(col.name)
        if col.len() > self.row_count:
            self.row_count = col.len()

    fn with_column(name: text, values: [Any]) -> Table:
        """Return new table with added/replaced column."""
        var cols: [Column] = []
        var found = false

        for n in self.column_order:
            if n == name:
                cols = cols.push(Column(name: name, dtype: ColumnType.Float, data: values))
                found = true
            else:
                cols = cols.push(self.columns[n])

        if not found:
            cols = cols.push(Column(name: name, dtype: ColumnType.Float, data: values))

        Table.from_columns(cols)

    fn with_computed(name: text, f: fn(Dict<text, Any>) -> Any) -> Table:
        """Add computed column.

        Example:
            table.with_computed("total", \row: row["price"] * row["quantity"])
        """
        var values: [Any] = []
        for i in 0..self.row_count:
            values = values.push(f(self.row(i)))
        self.with_column(name, values)

    # ========================================================================
    # Aggregation
    # ========================================================================

    fn agg(aggregations: Dict<text, text>) -> Table:
        """Aggregate columns.

        Args:
            aggregations: Dict of column_name -> aggregation_type
                         Types: "sum", "mean", "min", "max", "count", "std"

        Example:
            table.agg({"age": "mean", "salary": "sum"})
        """
        var result_cols: [Column] = []

        for col_name, agg_type in aggregations:
            val col = self.columns[col_name]
            val value = match agg_type:
                case "sum": col.sum()
                case "mean": col.mean()
                case "min": col.min() as f64
                case "max": col.max() as f64
                case "count": col.len() as f64
                case "std": col.std()
                case _: 0.0

            result_cols = result_cols.push(
                Column.from_floats("{col_name}_{agg_type}", [value])
            )

        Table.from_columns(result_cols)

    # ========================================================================
    # Display
    # ========================================================================

    fn to_string() -> text:
        """Convert to string representation."""
        var lines: [text] = []

        # Header
        lines = lines.push(self.column_order.join(" | "))
        lines = lines.push("-".repeat(lines[0].len()))

        # Rows
        for i in 0..min(10, self.row_count):
            var row_strs: [text] = []
            for name in self.column_order:
                row_strs = row_strs.push(self.columns[name].get(i).to_string())
            lines = lines.push(row_strs.join(" | "))

        if self.row_count > 10:
            lines = lines.push("... ({self.row_count - 10} more rows)")

        lines.join("\n")


# ============================================================================
# Grouped Table
# ============================================================================

struct GroupedTable:
    """Table grouped by one or more columns."""
    table: Table
    group_columns: [text]

impl GroupedTable:
    fn agg(aggregations: Dict<text, text>) -> Table:
        """Aggregate each group.

        Example:
            table.group_by(["dept"]).agg({"salary": "mean"})
        """
        # Build groups
        var groups: Dict<text, [i64]> = {}

        for i in 0..self.table.row_count:
            # Build group key
            var key_parts: [text] = []
            for col_name in self.group_columns:
                key_parts = key_parts.push(self.table.columns[col_name].get(i).to_string())
            val key = key_parts.join("|")

            if groups.has(key):
                groups[key] = groups[key].push(i)
            else:
                groups[key] = [i]

        # Build result
        var result_cols: Dict<text, [Any]> = {}

        # Initialize group columns
        for col_name in self.group_columns:
            result_cols[col_name] = []

        # Initialize aggregation columns
        for col_name, agg_type in aggregations:
            result_cols["{col_name}_{agg_type}"] = []

        # Process each group
        for key, indices in groups:
            # Add group column values (from first row in group)
            for col_name in self.group_columns:
                result_cols[col_name] = result_cols[col_name].push(
                    self.table.columns[col_name].get(indices[0])
                )

            # Compute aggregations
            for col_name, agg_type in aggregations:
                val col = self.table.columns[col_name]
                var values: [f64] = []
                for idx in indices:
                    values = values.push(col.get(idx) as f64)

                val agg_value = match agg_type:
                    case "sum": values.sum()
                    case "mean": values.sum() / values.len() as f64
                    case "min": values.min()
                    case "max": values.max()
                    case "count": values.len() as f64
                    case _: 0.0

                result_cols["{col_name}_{agg_type}"] = result_cols["{col_name}_{agg_type}"].push(agg_value)

        Table.from_dict(result_cols)

    fn count() -> Table:
        """Count rows in each group."""
        self.agg({"_row": "count"})

    fn sum(columns: [text]) -> Table:
        """Sum columns for each group."""
        var aggs: Dict<text, text> = {}
        for col in columns:
            aggs[col] = "sum"
        self.agg(aggs)

    fn mean(columns: [text]) -> Table:
        """Mean of columns for each group."""
        var aggs: Dict<text, text> = {}
        for col in columns:
            aggs[col] = "mean"
        self.agg(aggs)


# ============================================================================
# Exports
# ============================================================================

export Column, ColumnType
export Table, GroupedTable
