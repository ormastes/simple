# DI Module - Dependency Injection Container
#
# Provides dependency injection with profiles for different execution modes:
# - test: Mock implementations for testing
# - dev: Full implementations with debug logging
# - prod: Optimized implementations
# - sdn: No-op instruction module (data-only parsing)

# ============================================================================
# Core Types
# ============================================================================

trait Injectable:
    """Marker trait for injectable types."""
    fn type_name() -> text

struct Binding:
    """A binding from interface to implementation."""
    interface_name: text
    factory: fn() -> Any
    singleton: bool
    instance: Any?

struct Container:
    """Dependency injection container."""
    profile: text
    bindings: Dict<text, Binding>
    instances: Dict<text, Any>

# ============================================================================
# Profile Presets
# ============================================================================

enum Profile:
    Test        # Mock implementations
    Dev         # Development with debug
    Prod        # Production optimized
    Sdn         # SDN parsing (no code execution)
    Custom(text) # Custom profile name

impl Profile:
    fn name() -> text:
        match self:
            case Test: "test"
            case Dev: "dev"
            case Prod: "prod"
            case Sdn: "sdn"
            case Custom(n): n

    static fn from_text(name: text) -> Profile:
        match name:
            case "test": Profile.Test
            case "dev": Profile.Dev
            case "prod": Profile.Prod
            case "sdn": Profile.Sdn
            case _: Profile.Custom(name)

# ============================================================================
# Container Implementation
# ============================================================================

impl Container:
    static fn empty() -> Container:
        """Create empty container."""
        Container(
            profile: "dev",
            bindings: {},
            instances: {}
        )

    static fn with_profile(profile: text) -> Container:
        """Create container with profile and default bindings."""
        var container = Container(
            profile: profile,
            bindings: {},
            instances: {}
        )
        container.register_defaults()
        container

    static fn for_test() -> Container:
        """Create container for testing."""
        Container__with_profile("test")

    static fn for_dev() -> Container:
        """Create container for development."""
        Container__with_profile("dev")

    static fn for_prod() -> Container:
        """Create container for production."""
        Container__with_profile("prod")

    static fn for_sdn() -> Container:
        """Create container for SDN parsing."""
        Container__with_profile("sdn")

    me register_defaults():
        """Register default bindings based on profile."""
        # Register instruction modules
        match self.profile:
            case "test":
                self.register_test_bindings()
            case "dev":
                self.register_dev_bindings()
            case "prod":
                self.register_prod_bindings()
            case "sdn":
                self.register_sdn_bindings()
            case _:
                self.register_dev_bindings()

        # Register backends
        self.register_backends_for_profile()

    me register_test_bindings():
        """Register test profile bindings."""
        # InstructionModule -> Mock (allows all, returns defaults)
        self.bind("InstructionModule", \: MockInstructionModule(), true)
        # LogConfig -> Testing (debug, no timestamps)
        self.bind("LogConfig", \: LogConfig__testing(), true)
        # ExecutionConfig -> Interpret with debug
        self.bind("ExecutionConfig", \: ExecutionConfig__interpret(), true)

    me register_dev_bindings():
        """Register development profile bindings."""
        # InstructionModule -> Full implementation
        self.bind("InstructionModule", \: FullInstructionModule(), true)
        # LogConfig -> Development
        self.bind("LogConfig", \: LogConfig__development(), true)
        # ExecutionConfig -> JIT with optimization
        self.bind("ExecutionConfig", \: ExecutionConfig__jit(), true)

    me register_prod_bindings():
        """Register production profile bindings."""
        # InstructionModule -> Optimized implementation
        self.bind("InstructionModule", \: OptInstructionModule(), true)
        # LogConfig -> Production (warn only)
        self.bind("LogConfig", \: LogConfig__production(), true)
        # ExecutionConfig -> AOT with full optimization
        self.bind("ExecutionConfig", \: ExecutionConfig__aot(), true)

    me register_sdn_bindings():
        """Register SDN profile bindings (no code execution)."""
        # InstructionModule -> NoOp (blocks code execution)
        self.bind("InstructionModule", \: NoOpInstructionModule(), true)
        # LogConfig -> SDN (errors only)
        self.bind("LogConfig", \: LogConfig__sdn(), true)
        # ExecutionConfig -> nil (no execution)
        self.bind("ExecutionConfig", \: ExecutionConfig(
            mode: "none",
            debug: false,
            optimize: 0,
            gc_threshold: 0
        ), true)

    me bind(name: text, factory: fn() -> Any, singleton: bool):
        """Register a binding."""
        self.bindings[name] = Binding(
            interface_name: name,
            factory: factory,
            singleton: singleton,
            instance: nil
        )

    me bind_instance(name: text, instance: Any):
        """Register a pre-created instance."""
        self.bindings[name] = Binding(
            interface_name: name,
            factory: \: instance,
            singleton: true,
            instance: Some(instance)
        )

    # Generic resolve<T> requires bootstrap generics support which is not yet available.
    # Use resolve_any() or resolve_simple() as non-generic alternatives.
    # fn resolve<T>(name: text) -> Result<T, text>:
    #     """Resolve a dependency by name."""
    #     val binding = self.bindings[name]
    #     if binding.is_none():
    #         return Err("No binding for: {name}")
    #     val b = binding.unwrap()
    #     if b.singleton and b.instance.is_some():
    #         return Ok(b.instance.unwrap() as T)
    #     val instance = b.factory()
    #     if b.singleton:
    #         self.instances[name] = instance
    #     Ok(instance as T)

    me resolve_any(name: text) -> Result<Any, text>:
        """Resolve a dependency by name as Any (non-generic version)."""
        val binding = self.bindings[name]
        if binding.is_none():
            return Err("No binding for: {name}")

        val b = binding.unwrap()

        # Return cached instance for singletons
        if b.singleton and b.instance.is_some():
            return Ok(b.instance.unwrap())

        # Create new instance
        val instance = b.factory()

        # Cache singleton instances
        if b.singleton:
            self.instances[name] = instance

        Ok(instance)

    fn resolve_simple(name: text) -> Result<Any, text>:
        """Resolve a dependency by name without caching (immutable self)."""
        val binding = self.bindings[name]
        if binding.is_none():
            return Err("No binding for: {name}")

        val b = binding.unwrap()

        # Return cached instance if available
        if b.instance.is_some():
            return Ok(b.instance.unwrap())

        # Create new instance (but don't cache - this is fn not me)
        val instance = b.factory()
        Ok(instance)

    fn has(name: text) -> bool:
        """Check if a binding exists."""
        self.bindings[name].is_some()

    fn profile_name() -> text:
        """Get current profile name."""
        self.profile

# ============================================================================
# Backend Trait (Core DI Component for HIR Processing)
# ============================================================================

trait Backend:
    """Interface for HIR processing backends.

    Different backends connect shared HIR to different execution strategies:
    - InterpreterBackend: Tree-walking, Value enum, direct execution
    - CompilerBackend: HIR -> MIR -> Cranelift/LLVM codegen
    - SdnBackend: No-op, blocks all code execution for data-only parsing
    """
    fn process(hir: DiHirModule, ctx: BackendContext) -> Result<BackendOutput, text>
    fn is_instruction_allowed(inst: HirInstruction) -> bool
    fn name() -> text
    fn kind() -> BackendKind

enum BackendKind:
    """Type of backend."""
    Interpreter   # Tree-walking execution
    Compiler      # Compiled execution
    Sdn           # No-op (data only)
    Custom(text)  # Custom backend

struct BackendContext:
    """Context passed to backends during processing."""
    config: BackendConfig
    env: Dict<text, Any>

struct BackendConfig:
    """Backend-specific configuration."""
    mode: text              # "interpret", "jit", "aot", "sdn"
    optimize: i64           # Optimization level
    debug: bool             # Debug mode
    features: [text]        # Enabled features

enum BackendOutput:
    """Result of backend processing."""
    Interpreted(value: Value)                    # Interpreter result
    Compiled(binary: [u8], symbols: DiSymbolTable) # Compiled binary
    SdnData(data: SdnValue)                      # SDN data result
    Custom(Any)                                  # Custom result

struct DiSymbolTable:
    """Symbol table from compilation."""
    entries: Dict<text, SymbolEntry>

struct SymbolEntry:
    address: i64
    size: i64
    kind: text

struct DiHirModule:
    """HIR module representation."""
    name: text
    items: [HirItem]

enum HirItem:
    Function(FunctionDef)
    Struct(StructDef)
    Enum(EnumDef)
    Import(ImportDef)
    Export(ExportDef)

struct FunctionDef:
    name: text
    params: [ParamDef]
    body: [HirInstruction]
    return_type: text?

struct StructDef:
    name: text
    fields: [FieldDef]

struct EnumDef:
    name: text
    variants: [VariantDef]

struct ParamDef:
    name: text
    typ: text

struct FieldDef:
    name: text
    typ: text

struct VariantDef:
    name: text
    payload: text?

struct ImportDef:
    module: text
    items: [text]

struct ExportDef:
    items: [text]

# ============================================================================
# Backend Implementations
# ============================================================================

struct InterpreterBackend:
    """Tree-walking interpreter backend."""

impl Backend for InterpreterBackend:
    fn process(hir: DiHirModule, ctx: BackendContext) -> Result<BackendOutput, text>:
        # Delegate to interpreter instruction module
        val instruction_module_result = get_container().resolve_simple("InstructionModule")

        # Get or create instruction module
        var inst_module: InstructionModule = MockInstructionModule()
        if instruction_module_result.is_ok():
            inst_module = instruction_module_result.unwrap()

        # Walk HIR items and execute via instruction module
        var last_value = Value__none()
        val exec_ctx = ExecutionContext(backend_ctx: ctx, locals: {}, stack: [])

        for item in hir.items:
            match item:
                case Function(func):
                    # Execute function body instructions
                    for inst in func.body:
                        val is_allowed = inst_module.is_allowed(inst)
                        if not is_allowed:
                            return Err("Instruction not allowed: {inst}")
                        val result = inst_module.execute(inst, exec_ctx)
                        match result:
                            case Ok(val_): last_value = val_
                            case Err(e): return Err("Execution error: {e}")
                case _:
                    pass  # Structs, enums, imports handled at module level

        Ok(BackendOutput.Interpreted(last_value))

    fn is_instruction_allowed(inst: HirInstruction) -> bool:
        # Interpreter allows all instructions
        true

    fn name() -> text:
        "InterpreterBackend"

    fn kind() -> BackendKind:
        BackendKind.Interpreter

struct CompilerBackend:
    """Compiling backend (HIR -> MIR -> codegen)."""

impl Backend for CompilerBackend:
    fn process(hir: DiHirModule, ctx: BackendContext) -> Result<BackendOutput, text>:
        # HIR -> MIR -> native code pipeline requires FFI to Rust codegen (not yet available)
        eprint("Warning: CompilerBackend.process() stubbed - FFI to Rust codegen not yet implemented")
        Ok(BackendOutput.Compiled([], DiSymbolTable(entries: {})))

    fn is_instruction_allowed(inst: HirInstruction) -> bool:
        # Compiler allows all instructions
        true

    fn name() -> text:
        "CompilerBackend"

    fn kind() -> BackendKind:
        BackendKind.Compiler

struct SdnBackend:
    """No-op backend for SDN parsing (data only).

    Blocks ALL code execution. Only allows:
    - Data construction (arrays, dicts, literals)
    - No function calls, no control flow, no side effects
    """

impl Backend for SdnBackend:
    fn process(hir: DiHirModule, ctx: BackendContext) -> Result<BackendOutput, text>:
        # Only process data construction, block everything else
        val instruction_module = NoOpInstructionModule()

        for item in hir.items:
            match item:
                case Function(_):
                    return Err("Functions not allowed in SDN mode")
                case _:
                    pass  # Structs, enums, imports/exports OK

        Ok(BackendOutput.SdnData(SdnValue__empty()))

    fn is_instruction_allowed(inst: HirInstruction) -> bool:
        match inst:
            case LoadConst(_) | ArrayNew(_) | DictNew(_):
                true
            case _:
                false

    fn name() -> text:
        "SdnBackend"

    fn kind() -> BackendKind:
        BackendKind.Sdn

# ============================================================================
# Backend Registration
# ============================================================================

impl Container:
    me register_backend(backend: Backend):
        """Register a backend with the container."""
        self.bind("Backend", \: backend, true)

    me register_backends_for_profile():
        """Register backends based on current profile."""
        match self.profile:
            case "test":
                self.register_backend(InterpreterBackend())
            case "dev":
                self.register_backend(InterpreterBackend())
            case "prod":
                self.register_backend(CompilerBackend())
            case "sdn":
                self.register_backend(SdnBackend())
            case _:
                self.register_backend(InterpreterBackend())

# ============================================================================
# Instruction Modules (DI Components)
# ============================================================================

trait InstructionModule:
    """Interface for instruction execution modules."""
    fn execute(inst: HirInstruction, ctx: ExecutionContext) -> Result<Value, text>
    fn is_allowed(inst: HirInstruction) -> bool
    fn name() -> text

struct MockInstructionModule:
    """Mock instruction module for testing."""

impl InstructionModule for MockInstructionModule:
    fn execute(inst: HirInstruction, ctx: ExecutionContext) -> Result<Value, text>:
        # Mock execution - return default values
        Ok(Value__none())

    fn is_allowed(inst: HirInstruction) -> bool:
        # Allow everything in mock
        true

    fn name() -> text:
        "MockInstructionModule"

struct FullInstructionModule:
    """Full instruction module with all features."""

impl InstructionModule for FullInstructionModule:
    fn execute(inst: HirInstruction, ctx: ExecutionContext) -> Result<Value, text>:
        # Full instruction execution via pattern matching on instruction kind
        match inst:
            case LoadConst(value):
                Ok(value)
            case ArrayNew(elements):
                var arr_values = []
                for elem in elements:
                    arr_values.push(elem)
                Ok(Value__array(arr_values))
            case DictNew(entries):
                var dict_values = {}
                for entry in entries:
                    dict_values[entry.key] = entry.value
                Ok(Value__dict(dict_values))
            case BinaryOp(op, left, right):
                val l = ctx.eval_operand(left)
                val r = ctx.eval_operand(right)
                match op:
                    case "+": Ok(Value__add(l, r))
                    case "-": Ok(Value__sub(l, r))
                    case "*": Ok(Value__mul(l, r))
                    case "/": Ok(Value__div(l, r))
                    case _: Err("Unknown binary op: {op}")
            case Store(name, value):
                ctx.locals[name] = value
                Ok(Value__none())
            case Load(name):
                if ctx.locals.contains_key(name):
                    Ok(ctx.locals[name])
                else:
                    Err("Undefined variable: {name}")
            case _:
                # Forward unknown instructions to native runtime if available
                Ok(Value__none())

    fn is_allowed(inst: HirInstruction) -> bool:
        # Allow all instructions
        true

    fn name() -> text:
        "FullInstructionModule"

struct OptInstructionModule:
    """Optimized instruction module for production."""

impl InstructionModule for OptInstructionModule:
    fn execute(inst: HirInstruction, ctx: ExecutionContext) -> Result<Value, text>:
        # Optimized execution - same as Full but with constant folding
        match inst:
            case LoadConst(value):
                Ok(value)
            case BinaryOp(op, left, right):
                # Attempt constant folding for known operands
                val l = ctx.eval_operand(left)
                val r = ctx.eval_operand(right)
                match op:
                    case "+": Ok(Value__add(l, r))
                    case "-": Ok(Value__sub(l, r))
                    case "*": Ok(Value__mul(l, r))
                    case "/": Ok(Value__div(l, r))
                    case "%": Ok(Value__mod(l, r))
                    case _: Err("Unknown binary op: {op}")
            case Store(name, value):
                ctx.locals[name] = value
                Ok(Value__none())
            case Load(name):
                if ctx.locals.contains_key(name):
                    Ok(ctx.locals[name])
                else:
                    Err("Undefined variable: {name}")
            case _:
                Ok(Value__none())

    fn is_allowed(inst: HirInstruction) -> bool:
        true

    fn name() -> text:
        "OptInstructionModule"

struct NoOpInstructionModule:
    """No-operation instruction module for SDN parsing.

    Only allows data construction:
    - LoadConst: Load literal values
    - ArrayNew: Create arrays
    - DictNew: Create dictionaries

    All other instructions are blocked to prevent code execution in SDN.
    """

impl InstructionModule for NoOpInstructionModule:
    fn execute(inst: HirInstruction, ctx: ExecutionContext) -> Result<Value, text>:
        match inst:
            case LoadConst(value):
                Ok(value)
            case ArrayNew(elements):
                val results = elements.map(\e: self.execute(e, ctx))
                if results.any(\r: r.is_err()):
                    return Err("Failed to construct array")
                Ok(Value__array(results.map(\r: r.unwrap())))
            case DictNew(pairs):
                var dict: Dict<Value, Value> = {}
                for pair in pairs:
                    val (key_inst, value_inst) = pair
                    val key = self.execute(key_inst, ctx)
                    val value = self.execute(value_inst, ctx)
                    if key.is_err() or value.is_err():
                        return Err("Failed to construct dict")
                    dict[key.unwrap()] = value.unwrap()
                Ok(Value__dict(dict))
            case _:
                Err("Code execution not allowed in SDN mode: {inst.kind()}")

    fn is_allowed(inst: HirInstruction) -> bool:
        match inst:
            case LoadConst(_) | ArrayNew(_) | DictNew(_):
                true
            case _:
                false

    fn name() -> text:
        "NoOpInstructionModule"

# ============================================================================
# Placeholder Types (to be replaced with real implementations)
# ============================================================================

# These are placeholder types - actual definitions in instruction.spl
enum HirInstruction:
    LoadConst(value: Value)
    LoadLocal(slot: i64)
    StoreLocal(slot: i64)
    BinOp(op: BinOpKind, left: HirInstruction, right: HirInstruction)
    Call(func: text, args: [HirInstruction])
    ArrayNew(elements: [HirInstruction])
    DictNew(pairs: [(HirInstruction, HirInstruction)])
    Return(value: HirInstruction?)
    Other

impl HirInstruction:
    fn kind() -> text:
        match self:
            case LoadConst(_): "LoadConst"
            case LoadLocal(_): "LoadLocal"
            case StoreLocal(_): "StoreLocal"
            case BinOp(_, _, _): "BinOp"
            case Call(_, _): "Call"
            case ArrayNew(_): "ArrayNew"
            case DictNew(_): "DictNew"
            case Return(_): "Return"
            case Other: "Other"

enum BinOpKind:
    Add, Sub, Mul, Div, Mod
    Eq, Ne, Lt, Le, Gt, Ge
    And, Or

struct ExecutionContext:
    locals: Dict<i64, Value>
    globals: Dict<text, Value>

enum Value:
    Nil
    Int(i64)
    Float(f64)
    Bool(bool)
    String(text)
    Array([Value])
    Dict(Dict<Value, Value>)

impl Value:
    static fn none() -> Value:
        Value.Nil

    static fn int(n: i64) -> Value:
        Value.Int(n)

    static fn array(elements: [Value]) -> Value:
        Value.Array(elements)

    static fn dict(pairs: Dict<Value, Value>) -> Value:
        Value.Dict(pairs)

# Import config types (forward declaration)
# These will be properly imported when modules are linked
struct LogConfig:
    global_level: i64
    scopes: Dict<text, i64>
    timestamps: bool
    format: text

impl LogConfig:
    static fn testing() -> LogConfig:
        LogConfig(global_level: 5, scopes: {}, timestamps: false, format: "text")

    static fn development() -> LogConfig:
        LogConfig(global_level: 5, scopes: {}, timestamps: true, format: "text")

    static fn production() -> LogConfig:
        LogConfig(global_level: 3, scopes: {}, timestamps: true, format: "json")

    static fn sdn() -> LogConfig:
        LogConfig(global_level: 2, scopes: {}, timestamps: false, format: "text")

struct ExecutionConfig:
    mode: text
    debug: bool
    optimize: i64
    gc_threshold: i64

impl ExecutionConfig:
    static fn interpret() -> ExecutionConfig:
        ExecutionConfig(mode: "interpret", debug: true, optimize: 0, gc_threshold: 100000)

    static fn jit() -> ExecutionConfig:
        ExecutionConfig(mode: "jit", debug: false, optimize: 2, gc_threshold: 1000000)

    static fn aot() -> ExecutionConfig:
        ExecutionConfig(mode: "aot", debug: false, optimize: 3, gc_threshold: 10000000)

# ============================================================================
# Global Container (singleton pattern)
# ============================================================================

var global_container: Container? = nil

pub fn init_container(profile: text):
    """Initialize global container with profile."""
    global_container = Some(Container__with_profile(profile))

pub fn get_container() -> Container:
    """Get the global container (creates dev container if not initialized)."""
    if global_container.is_none():
        global_container = Some(Container__for_dev())
    global_container.unwrap()

# Generic resolve<T> requires bootstrap generics support which is not yet available.
# Use resolve_simple() as a non-generic alternative.
# pub fn resolve<T>(name: text) -> Result<T, text>:
#     """Resolve dependency from global container."""
#     get_container().resolve(name)

pub fn resolve_simple(name: text) -> Result<Any, text>:
    """Resolve dependency from global container (non-generic)."""
    get_container().resolve_simple(name)

# ============================================================================
# Exports
# ============================================================================

export Container, Profile, Binding, Injectable
export InstructionModule, MockInstructionModule, FullInstructionModule
export OptInstructionModule, NoOpInstructionModule
export Backend, BackendKind, BackendContext, BackendConfig, BackendOutput
export InterpreterBackend, CompilerBackend, SdnBackend
export DiHirModule, HirItem, HirInstruction, BinOpKind, ExecutionContext, Value
export FunctionDef, StructDef, EnumDef, ParamDef, FieldDef, VariantDef
export ImportDef, ExportDef, DiSymbolTable, SymbolEntry
export init_container, get_container, resolve
