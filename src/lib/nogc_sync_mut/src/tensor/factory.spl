# Tensor Factory Functions
#
# Unified tensor creation using DLConfig defaults.
# These functions automatically use the global `dl` config for
# dtype, device, and backend unless overridden.

import ..tensor.{Tensor, Device as TensorDevice, DType as TensorDType}
import ..dl.config.{dl, DType, Device, Backend}

# ============================================================================
# Config-Aware Factory Functions
# ============================================================================

fn zeros(shape: [i64]) -> Tensor:
    """Create a tensor filled with zeros using config defaults.

    Uses dl.default_dtype and dl.default_device from global config.

    Example:
        config_training()
        val z = zeros([3, 4])  # Creates f32 tensor on GPU
    """
    val dtype = dl.default_dtype
    val device = dl.default_device
    create_tensor_zeros(shape, dtype, device)

fn ones(shape: [i64]) -> Tensor:
    """Create a tensor filled with ones using config defaults.

    Example:
        use_f64()
        val o = ones([100])  # Creates f64 tensor
    """
    val dtype = dl.default_dtype
    val device = dl.default_device
    create_tensor_ones(shape, dtype, device)

fn full(shape: [i64], value: f64) -> Tensor:
    """Create a tensor filled with a constant value.

    Example:
        val t = full([3, 3], 3.14)  # 3x3 tensor of pi
    """
    val dtype = dl.default_dtype
    val device = dl.default_device
    create_tensor_full(shape, value, dtype, device)

fn randn(shape: [i64]) -> Tensor:
    """Create a tensor with standard normal random values.

    Example:
        config_training()
        val W = randn([784, 256])  # Random weight matrix on GPU
    """
    val dtype = dl.default_dtype
    val device = dl.default_device
    create_tensor_randn(shape, dtype, device)

fn rand(shape: [i64]) -> Tensor:
    """Create a tensor with uniform random values in [0, 1).

    Example:
        val r = rand([10, 10])  # Random 10x10 matrix
    """
    val dtype = dl.default_dtype
    val device = dl.default_device
    create_tensor_rand(shape, dtype, device)

fn eye(n: i64, m: i64? = nil) -> Tensor:
    """Create an identity matrix.

    Example:
        val I = eye(4)      # 4x4 identity
        val I2 = eye(3, 4)  # 3x4 identity (non-square)
    """
    val dtype = dl.default_dtype
    val device = dl.default_device
    val cols = m ?? n
    create_tensor_eye(n, cols, dtype, device)

fn arange(start: f64, end: f64, step: f64 = 1.0) -> Tensor:
    """Create a 1D tensor with values from start to end (exclusive).

    Example:
        val x = arange(0, 10)     # [0, 1, 2, ..., 9]
        val y = arange(0, 1, 0.1) # [0.0, 0.1, 0.2, ..., 0.9]
    """
    val dtype = dl.default_dtype
    val device = dl.default_device
    create_tensor_arange(start, end, step, dtype, device)

fn linspace(start: f64, end: f64, steps: i64) -> Tensor:
    """Create a 1D tensor with evenly spaced values.

    Example:
        val x = linspace(0, 1, 100)  # 100 points from 0 to 1
    """
    val dtype = dl.default_dtype
    val device = dl.default_device
    create_tensor_linspace(start, end, steps, dtype, device)

fn logspace(start: f64, end: f64, steps: i64, base: f64 = 10.0) -> Tensor:
    """Create a 1D tensor with logarithmically spaced values.

    Example:
        val x = logspace(0, 2, 3)  # [1, 10, 100]
    """
    val dtype = dl.default_dtype
    val device = dl.default_device
    create_tensor_logspace(start, end, steps, base, dtype, device)

fn empty(shape: [i64]) -> Tensor:
    """Create an uninitialized tensor (faster than zeros).

    WARNING: Contents are undefined. Use only when you will
    immediately overwrite all values.

    Example:
        val t = empty([1000, 1000])  # Fast allocation
        t[:] = compute_values()       # Immediately fill
    """
    val dtype = dl.default_dtype
    val device = dl.default_device
    create_tensor_empty(shape, dtype, device)

# ============================================================================
# Trainable Tensor Factories
# ============================================================================

fn zeros_tr(shape: [i64]) -> Tensor:
    """Create a trainable (requires_grad=True) zeros tensor.

    Equivalent to zeros(shape) with requires_grad=True.
    """
    val t = zeros(shape)
    t.requires_grad = true
    t

fn ones_tr(shape: [i64]) -> Tensor:
    """Create a trainable ones tensor."""
    val t = ones(shape)
    t.requires_grad = true
    t

fn randn_tr(shape: [i64]) -> Tensor:
    """Create a trainable random normal tensor.

    Common pattern for initializing neural network weights.
    """
    val t = randn(shape)
    t.requires_grad = true
    t

fn rand_tr(shape: [i64]) -> Tensor:
    """Create a trainable uniform random tensor."""
    val t = rand(shape)
    t.requires_grad = true
    t

# ============================================================================
# Device-Specific Factories
# ============================================================================

fn zeros_gpu(shape: [i64]) -> Tensor:
    """Create zeros tensor on GPU."""
    create_tensor_zeros(shape, dl.default_dtype, Device.CUDA(0))

fn ones_gpu(shape: [i64]) -> Tensor:
    """Create ones tensor on GPU."""
    create_tensor_ones(shape, dl.default_dtype, Device.CUDA(0))

fn randn_gpu(shape: [i64]) -> Tensor:
    """Create random normal tensor on GPU."""
    create_tensor_randn(shape, dl.default_dtype, Device.CUDA(0))

fn zeros_cpu(shape: [i64]) -> Tensor:
    """Create zeros tensor on CPU."""
    create_tensor_zeros(shape, dl.default_dtype, Device.CPU)

fn ones_cpu(shape: [i64]) -> Tensor:
    """Create ones tensor on CPU."""
    create_tensor_ones(shape, dl.default_dtype, Device.CPU)

fn randn_cpu(shape: [i64]) -> Tensor:
    """Create random normal tensor on CPU."""
    create_tensor_randn(shape, dl.default_dtype, Device.CPU)

# ============================================================================
# From Data Factories
# ============================================================================

fn tensor(data: [any]) -> Tensor:
    """Create a tensor from data.

    Infers shape from nested array structure.

    Example:
        val t = tensor([[1, 2, 3], [4, 5, 6]])  # 2x3 tensor
    """
    val dtype = dl.default_dtype
    val device = dl.default_device
    create_tensor_from_data(data, dtype, device)

fn tensor_like(other: Tensor) -> Tensor:
    """Create an empty tensor with the same shape/dtype/device as another.

    Example:
        val t2 = tensor_like(t1)  # Same shape/dtype/device
    """
    empty_like(other)

fn zeros_like(other: Tensor) -> Tensor:
    """Create a zeros tensor with the same shape/dtype/device as another."""
    create_tensor_zeros(other.shape(), other.dtype(), other.device())

fn ones_like(other: Tensor) -> Tensor:
    """Create a ones tensor with the same shape/dtype/device as another."""
    create_tensor_ones(other.shape(), other.dtype(), other.device())

fn randn_like(other: Tensor) -> Tensor:
    """Create a random normal tensor with same shape/dtype/device as another."""
    create_tensor_randn(other.shape(), other.dtype(), other.device())

fn empty_like(other: Tensor) -> Tensor:
    """Create an uninitialized tensor with same shape/dtype/device as another."""
    create_tensor_empty(other.shape(), other.dtype(), other.device())

# ============================================================================
# Internal Backend Dispatch
# ============================================================================

fn create_tensor_zeros(shape: [i64], dtype: DType, device: Device) -> Tensor:
    """Create zeros tensor with specified dtype and device."""
    match dl.default_backend:
        case Backend.Native:
            # Native backend tensor operations not yet implemented
            eprint("Warning: Native backend create_tensor_zeros stubbed - falling back to NativeTensor.zeros")
            NativeTensor.zeros(shape, dtype, device)
        case Backend.PyTorch:
            TorchTensor.zeros(shape, dtype, device)

fn create_tensor_ones(shape: [i64], dtype: DType, device: Device) -> Tensor:
    """Create ones tensor with specified dtype and device."""
    match dl.default_backend:
        case Backend.Native:
            NativeTensor.ones(shape, dtype, device)
        case Backend.PyTorch:
            TorchTensor.ones(shape, dtype, device)

fn create_tensor_full(shape: [i64], value: f64, dtype: DType, device: Device) -> Tensor:
    """Create tensor filled with value."""
    match dl.default_backend:
        case Backend.Native:
            NativeTensor.full(shape, value, dtype, device)
        case Backend.PyTorch:
            TorchTensor.full(shape, value, dtype, device)

fn create_tensor_randn(shape: [i64], dtype: DType, device: Device) -> Tensor:
    """Create tensor with standard normal random values."""
    match dl.default_backend:
        case Backend.Native:
            NativeTensor.randn(shape, dtype, device)
        case Backend.PyTorch:
            TorchTensor.randn(shape, dtype, device)

fn create_tensor_rand(shape: [i64], dtype: DType, device: Device) -> Tensor:
    """Create tensor with uniform random values in [0, 1)."""
    match dl.default_backend:
        case Backend.Native:
            NativeTensor.rand(shape, dtype, device)
        case Backend.PyTorch:
            TorchTensor.rand(shape, dtype, device)

fn create_tensor_eye(n: i64, m: i64, dtype: DType, device: Device) -> Tensor:
    """Create identity matrix."""
    match dl.default_backend:
        case Backend.Native:
            NativeTensor.eye(n, m, dtype, device)
        case Backend.PyTorch:
            TorchTensor.eye(n, m, dtype, device)

fn create_tensor_arange(start: f64, end: f64, step: f64, dtype: DType, device: Device) -> Tensor:
    """Create 1D tensor with range values."""
    match dl.default_backend:
        case Backend.Native:
            NativeTensor.arange(start, end, step, dtype, device)
        case Backend.PyTorch:
            TorchTensor.arange(start, end, step, dtype, device)

fn create_tensor_linspace(start: f64, end: f64, steps: i64, dtype: DType, device: Device) -> Tensor:
    """Create 1D tensor with evenly spaced values."""
    match dl.default_backend:
        case Backend.Native:
            NativeTensor.linspace(start, end, steps, dtype, device)
        case Backend.PyTorch:
            TorchTensor.linspace(start, end, steps, dtype, device)

fn create_tensor_logspace(start: f64, end: f64, steps: i64, base: f64, dtype: DType, device: Device) -> Tensor:
    """Create 1D tensor with logarithmically spaced values."""
    match dl.default_backend:
        case Backend.Native:
            NativeTensor.logspace(start, end, steps, base, dtype, device)
        case Backend.PyTorch:
            TorchTensor.logspace(start, end, steps, base, dtype, device)

fn create_tensor_empty(shape: [i64], dtype: DType, device: Device) -> Tensor:
    """Create uninitialized tensor."""
    match dl.default_backend:
        case Backend.Native:
            NativeTensor.empty(shape, dtype, device)
        case Backend.PyTorch:
            TorchTensor.empty(shape, dtype, device)

fn create_tensor_from_data(data: [any], dtype: DType, device: Device) -> Tensor:
    """Create tensor from data."""
    match dl.default_backend:
        case Backend.Native:
            NativeTensor.from_data(data, dtype, device)
        case Backend.PyTorch:
            TorchTensor.from_data(data, dtype, device)

# ============================================================================
# Exports
# ============================================================================

export zeros, ones, full, randn, rand, eye, arange, linspace, logspace, empty
export zeros_tr, ones_tr, randn_tr, rand_tr
export zeros_gpu, ones_gpu, randn_gpu, zeros_cpu, ones_cpu, randn_cpu
export tensor, tensor_like, zeros_like, ones_like, randn_like, empty_like
