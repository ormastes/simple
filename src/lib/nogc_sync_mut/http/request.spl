# HTTP Request Handling
#
# Provides HTTP request parsing and building functionality.

import common from "std/http/common"

# ============================================================================
# HTTP Request Parsing
# ============================================================================

# Parse complete HTTP request into tuple structure
# Returns: (method, path, version, headers, body)
fn parse_request(text: text) -> tuple:
    val lines = text.split("\r\n")

    # Parse request line (first line)
    val request_line = lines[0]
    val request_parts = parse_request_line(request_line)
    val method = request_parts[0]
    val path = request_parts[1]
    val version = request_parts[2]

    # Find empty line separating headers from body
    var header_end = 1
    var i = 1
    while i < lines.length():
        val line = lines[i]
        if line == "":
            header_end = i
            break
        i = i + 1

    # Parse headers
    var header_lines = []
    var j = 1
    while j < header_end:
        header_lines = header_lines.append(lines[j])
        j = j + 1

    val headers = common.parse_headers(header_lines)

    # Parse body (everything after empty line)
    var body_lines = []
    var k = header_end + 1
    while k < lines.length():
        body_lines = body_lines.append(lines[k])
        k = k + 1

    val body = "\r\n".join(body_lines)

    return (method, path, version, headers, body)

# Parse HTTP request line
# Example: "GET /path HTTP/1.1" -> ("GET", "/path", "HTTP/1.1")
fn parse_request_line(line: text) -> tuple:
    val parts = line.split(" ")

    if parts.length() < 3:
        return ("GET", "/", "HTTP/1.1")

    val method = parts[0]
    val path = parts[1]
    val version = parts[2]

    return (method, path, version)

# Extract HTTP method from request line
fn parse_method(text: text) -> text:
    val parts = text.split(" ")
    if parts.length() > 0:
        return parts[0]
    return "GET"

# Extract path from request line
fn parse_path(text: text) -> text:
    val parts = text.split(" ")
    if parts.length() > 1:
        return parts[1]
    return "/"

# Extract HTTP version from request line
fn parse_version(text: text) -> text:
    val parts = text.split(" ")
    if parts.length() > 2:
        return parts[2]
    return "HTTP/1.1"

# ============================================================================
# HTTP Request Building
# ============================================================================

# Build complete HTTP request from components
# headers: list of (name, value) tuples
fn build_request(method: text, path: text, headers: list, body: text) -> text:
    var result = method
    result = result + " "
    result = result + path
    result = result + " HTTP/1.1\r\n"

    val headers_text = common.format_headers(headers)
    result = result + headers_text

    result = result + "\r\n"
    result = result + body

    return result

# Create GET request with headers
fn create_get_request(url: text, headers: list) -> text:
    return build_request("GET", url, headers, "")

# Create POST request with headers and body
fn create_post_request(url: text, headers: list, body: text) -> text:
    return build_request("POST", url, headers, body)

# Create PUT request with headers and body
fn create_put_request(url: text, headers: list, body: text) -> text:
    return build_request("PUT", url, headers, body)

# Create DELETE request with headers
fn create_delete_request(url: text, headers: list) -> text:
    return build_request("DELETE", url, headers, "")

# Create PATCH request with headers and body
fn create_patch_request(url: text, headers: list, body: text) -> text:
    return build_request("PATCH", url, headers, body)

# Create HEAD request with headers
fn create_head_request(url: text, headers: list) -> text:
    return build_request("HEAD", url, headers, "")

# Create OPTIONS request with headers
fn create_options_request(url: text, headers: list) -> text:
    return build_request("OPTIONS", url, headers, "")
