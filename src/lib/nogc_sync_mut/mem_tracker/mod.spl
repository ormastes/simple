# Memory Tracker — Simple API
#
# Wraps the C runtime memtrack functions for use from Simple code.
# Near-zero overhead when disabled (single branch in C, predicted not-taken).
#
# Usage:
#     mem_enable()
#     val snap_id = mem_snapshot()
#     # ... run code that allocates ...
#     mem_dump_leaks(snap_id, "/tmp/leaks.txt")
#     val leaks = parse_leak_dump("/tmp/leaks.txt")
#     mem_disable()
#
# Phase-based usage (test runner integration):
#     mem_enable()
#     val before = mem_phase("before-load")
#     # ... load modules ...
#     val after = mem_phase("after-unload")
#     val diff = mem_diff(before.snapshot, after.snapshot, "/tmp/leaks.txt")
#     val report = mem_build_report([before, after], [diff])
#     mem_print_report(report)
#     mem_disable()

use types.{MemSnapshot, MemLeakEntry, MemDiff, MemPhaseSnapshot, MemTagGroup, MemLeakReport}

# FFI declarations — map to C functions in runtime_memtrack.c
extern fn spl_memtrack_enable()
extern fn spl_memtrack_disable()
extern fn spl_memtrack_is_enabled() -> i64
extern fn spl_memtrack_snapshot() -> i64
extern fn spl_memtrack_dump_since(snapshot_id: i64, out_path: text)
extern fn spl_memtrack_live_count() -> i64
extern fn spl_memtrack_live_bytes() -> i64
extern fn spl_memtrack_reset()
extern fn spl_memtrack_count_since(snapshot_id: i64) -> i64
extern fn spl_memtrack_bytes_since(snapshot_id: i64) -> i64

# =========================================================================
# Core control
# =========================================================================

fn mem_enable():
    spl_memtrack_enable()

fn mem_disable():
    spl_memtrack_disable()

fn mem_is_enabled() -> bool:
    spl_memtrack_is_enabled() != 0

fn mem_snapshot() -> i64:
    spl_memtrack_snapshot()

fn mem_capture_snapshot() -> MemSnapshot:
    MemSnapshot(
        id: spl_memtrack_snapshot(),
        live_count: spl_memtrack_live_count(),
        live_bytes: spl_memtrack_live_bytes()
    )

fn mem_dump_leaks(snapshot_id: i64, path: text):
    spl_memtrack_dump_since(snapshot_id, path)

fn mem_live_count() -> i64:
    spl_memtrack_live_count()

fn mem_live_bytes() -> i64:
    spl_memtrack_live_bytes()

fn mem_reset():
    spl_memtrack_reset()

# =========================================================================
# In-memory snapshot comparison (no file I/O)
# =========================================================================

fn mem_count_since(snapshot_id: i64) -> i64:
    spl_memtrack_count_since(snapshot_id)

fn mem_bytes_since(snapshot_id: i64) -> i64:
    spl_memtrack_bytes_since(snapshot_id)

# =========================================================================
# Named phase snapshots
# =========================================================================

fn mem_phase(name: text) -> MemPhaseSnapshot:
    MemPhaseSnapshot(
        name: name,
        snapshot: mem_capture_snapshot()
    )

# =========================================================================
# Snapshot diff — compare two snapshots, find leaked allocations
# =========================================================================

fn mem_diff(before: MemSnapshot, after: MemSnapshot, dump_path: text) -> MemDiff:
    # Dump all allocations since before snapshot
    spl_memtrack_dump_since(before.id, dump_path)
    val leaked = parse_leak_dump(dump_path)
    val added_count = spl_memtrack_count_since(before.id)
    val added_bytes = spl_memtrack_bytes_since(before.id)
    MemDiff(
        before_id: before.id,
        before_count: before.live_count,
        before_bytes: before.live_bytes,
        after_id: after.id,
        after_count: after.live_count,
        after_bytes: after.live_bytes,
        added_count: added_count,
        added_bytes: added_bytes,
        leaked_entries: leaked
    )

fn mem_diff_quick(before: MemSnapshot, after: MemSnapshot) -> MemDiff:
    # Fast diff without dumping leak entries (no file I/O)
    val added_count = spl_memtrack_count_since(before.id)
    val added_bytes = spl_memtrack_bytes_since(before.id)
    var empty_entries: [MemLeakEntry] = []
    MemDiff(
        before_id: before.id,
        before_count: before.live_count,
        before_bytes: before.live_bytes,
        after_id: after.id,
        after_count: after.live_count,
        after_bytes: after.live_bytes,
        added_count: added_count,
        added_bytes: added_bytes,
        leaked_entries: empty_entries
    )

# =========================================================================
# Tag grouping — group leaked entries by tag for triage
# =========================================================================

fn mem_group_by_tag(entries: [MemLeakEntry]) -> [MemTagGroup]:
    var tags: [text] = []
    var counts: [i64] = []
    var bytes: [i64] = []
    for entry in entries:
        val idx = tags.index_of(entry.tag)
        if idx >= 0:
            counts[idx] = counts[idx] + 1
            bytes[idx] = bytes[idx] + entry.size
        else:
            tags.push(entry.tag)
            counts.push(1)
            bytes.push(entry.size)
    var groups: [MemTagGroup] = []
    var i = 0
    while i < tags.len():
        groups.push(MemTagGroup(tag: tags[i], count: counts[i], total_bytes: bytes[i]))
        i = i + 1
    groups

# =========================================================================
# Build full leak report from phases and diffs
# =========================================================================

fn mem_build_report(phases: [MemPhaseSnapshot], diffs: [MemDiff]) -> MemLeakReport:
    var total_count: i64 = 0
    var total_bytes: i64 = 0
    var all_entries: [MemLeakEntry] = []
    for diff in diffs:
        total_count = total_count + diff.added_count
        total_bytes = total_bytes + diff.added_bytes
        for entry in diff.leaked_entries:
            all_entries.push(entry)
    val tag_groups = mem_group_by_tag(all_entries)
    MemLeakReport(
        phases: phases,
        diffs: diffs,
        tag_groups: tag_groups,
        total_leaked_count: total_count,
        total_leaked_bytes: total_bytes
    )

# =========================================================================
# Report printing
# =========================================================================

fn mem_print_report(report: MemLeakReport):
    print ""
    print "=== Memory Leak Report ==="
    print ""
    # Phase snapshots
    print "Phases:"
    for phase in report.phases:
        print "  {phase.name}: snap#{phase.snapshot.id} ({phase.snapshot.live_count} allocs, {phase.snapshot.live_bytes} bytes)"
    print ""
    # Diffs
    var di = 0
    while di < report.diffs.len():
        val diff = report.diffs[di]
        if diff.added_count > 0:
            print "Diff (snap#{diff.before_id} -> snap#{diff.after_id}):"
            print "  Added: {diff.added_count} allocations, {diff.added_bytes} bytes"
            if diff.leaked_entries.len() > 0:
                print "  Entries:"
                for entry in diff.leaked_entries:
                    print "    #{entry.alloc_id} {entry.size} bytes [{entry.tag}]"
        di = di + 1
    # Tag groups
    if report.tag_groups.len() > 0:
        print ""
        print "By tag:"
        for tg in report.tag_groups:
            print "  [{tg.tag}] {tg.count} allocs, {tg.total_bytes} bytes"
    print ""
    if report.total_leaked_count > 0:
        print "TOTAL LEAKED: {report.total_leaked_count} allocations, {report.total_leaked_bytes} bytes"
    else:
        print "No memory leaks detected."
    print "==========================="

# =========================================================================
# Parse a leak dump file into structured entries
# =========================================================================

fn parse_leak_dump(path: text) -> [MemLeakEntry]:
    extern fn rt_file_read_text(p: text) -> text
    var entries: [MemLeakEntry] = []
    val content = rt_file_read_text(path) ?? ""
    if content == "":
        return entries
    val lines = content.split("\n")
    for line in lines:
        val trimmed = line.trim()
        if trimmed == "":
            continue
        val parts = trimmed.split(" ")
        if parts.len() >= 3:
            val alloc_id = to_int(parts[0])
            val size = to_int(parts[1])
            val tag = parts[2]
            entries.push(MemLeakEntry(alloc_id: alloc_id, size: size, tag: tag))
    entries

export mem_enable, mem_disable, mem_is_enabled
export mem_snapshot, mem_capture_snapshot
export mem_dump_leaks, mem_live_count, mem_live_bytes, mem_reset
export mem_count_since, mem_bytes_since
export mem_phase
export mem_diff, mem_diff_quick
export mem_group_by_tag
export mem_build_report, mem_print_report
export parse_leak_dump
