# Platform Conversion Functions
#
# send/recv pattern for converting values between platforms
# (host format â†’ remote format and vice versa).
#
# When host == remote endianness, these are identity (no-op).

use std.platform.config.{PlatformConfig, needs_swap}

export send_u16, send_u32, send_u64, recv_u16, recv_u32, recv_u64
export send_text, recv_text
export send_bytes_u32, recv_bytes_u32

# ============================================================
# Byte swap primitives (internal)
# ============================================================

fn swap16(v: i64) -> i64:
    val b0 = v & 0xFF
    val b1 = (v / 256) & 0xFF
    val result = b0 * 256 + b1
    result

fn swap32(v: i64) -> i64:
    val b0 = v & 0xFF
    val b1 = (v / 256) & 0xFF
    val b2 = (v / 65536) & 0xFF
    val b3 = (v / 16777216) & 0xFF
    val result = b0 * 16777216 + b1 * 65536
    val result2 = result + b2 * 256
    val final_result = result2 + b3
    final_result

fn swap64(v: i64) -> i64:
    # 8-byte swap
    val b0 = v & 0xFF
    val b1 = (v / 256) & 0xFF
    val b2 = (v / 65536) & 0xFF
    val b3 = (v / 16777216) & 0xFF
    val b4 = (v / 4294967296) & 0xFF
    val b5 = (v / 1099511627776) & 0xFF
    val b6 = (v / 281474976710656) & 0xFF
    val b7 = (v / 72057594037927936) & 0xFF

    val part1 = b0 * 72057594037927936
    val part2 = b1 * 281474976710656
    val part3 = b2 * 1099511627776
    val part4 = b3 * 4294967296
    val part5 = b4 * 16777216
    val part6 = b5 * 65536
    val part7 = b6 * 256
    val part8 = b7

    val sum1 = part1 + part2
    val sum2 = sum1 + part3
    val sum3 = sum2 + part4
    val sum4 = sum3 + part5
    val sum5 = sum4 + part6
    val sum6 = sum5 + part7
    val final_result = sum6 + part8
    final_result

# ============================================================
# send_* : convert value FROM host format TO remote format
# recv_* : convert value FROM remote format TO host format
# ============================================================
# When host == remote endianness, these are identity (no-op).

fn send_u16(host: PlatformConfig, remote: PlatformConfig, value: i64) -> i64:
    if needs_swap(host, remote): swap16(value) else: value

fn send_u32(host: PlatformConfig, remote: PlatformConfig, value: i64) -> i64:
    if needs_swap(host, remote): swap32(value) else: value

fn send_u64(host: PlatformConfig, remote: PlatformConfig, value: i64) -> i64:
    if needs_swap(host, remote): swap64(value) else: value

fn recv_u16(host: PlatformConfig, remote: PlatformConfig, value: i64) -> i64:
    if needs_swap(remote, host): swap16(value) else: value

fn recv_u32(host: PlatformConfig, remote: PlatformConfig, value: i64) -> i64:
    if needs_swap(remote, host): swap32(value) else: value

fn recv_u64(host: PlatformConfig, remote: PlatformConfig, value: i64) -> i64:
    if needs_swap(remote, host): swap64(value) else: value

# ============================================================
# Text conversion (newlines)
# ============================================================

fn send_text(host: PlatformConfig, remote: PlatformConfig, content: text) -> text:
    # Convert from host newline convention to remote newline convention
    if host.newline == remote.newline:
        content  # No-op: same convention
    else:
        # Normalize to LF first, then convert to remote
        var normalized = content.replace("\r\n", "\n")
        normalized = normalized.replace("\r", "\n")
        if remote.newline == "\r\n":
            normalized.replace("\n", "\r\n")
        else:
            normalized

fn recv_text(host: PlatformConfig, remote: PlatformConfig, content: text) -> text:
    # Convert from remote newline convention to host newline convention
    send_text(remote, host, content)

# ============================================================
# Byte array conversion (multi-byte values in byte arrays)
# ============================================================

fn send_bytes_u32(host: PlatformConfig, remote: PlatformConfig, value: i64) -> [i64]:
    val converted = send_u32(host, remote, value)
    # Write in remote's byte order
    if remote.endian.name() == "little":
        val b0 = converted & 0xFF
        val b1 = (converted / 256) & 0xFF
        val b2 = (converted / 65536) & 0xFF
        val b3 = (converted / 16777216) & 0xFF
        [b0, b1, b2, b3]
    else:
        val b0 = (converted / 16777216) & 0xFF
        val b1 = (converted / 65536) & 0xFF
        val b2 = (converted / 256) & 0xFF
        val b3 = converted & 0xFF
        [b0, b1, b2, b3]

fn recv_bytes_u32(host: PlatformConfig, remote: PlatformConfig, bytes: [i64]) -> i64:
    # Read from remote's byte order
    var raw = 0
    if remote.endian.name() == "little":
        val v0 = bytes[0]
        val v1 = bytes[1] * 256
        val v2 = bytes[2] * 65536
        val v3 = bytes[3] * 16777216
        raw = v0 + v1
        raw = raw + v2
        raw = raw + v3
    else:
        val v0 = bytes[0] * 16777216
        val v1 = bytes[1] * 65536
        val v2 = bytes[2] * 256
        val v3 = bytes[3]
        raw = v0 + v1
        raw = raw + v2
        raw = raw + v3
    recv_u32(host, remote, raw)
