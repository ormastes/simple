# Platform Configuration
#
# Core PlatformConfig struct that describes any platform's properties
# (host, remote target, network peer, cross-compilation target).
#
# Auto-detects host platform using existing std.common.target and std.platform.

use std.common.target.{TargetArch, TargetOS, Endian}
use std.platform.{get_host_os, get_host_arch}

export PlatformConfig, host_config, make_config, network_config
export needs_swap, same_platform

# A PlatformConfig describes any platform's properties
struct PlatformConfig:
    arch: TargetArch
    os: TargetOS
    endian: Endian
    pointer_bytes: i64     # 2, 4, or 8
    newline: text          # "\n" or "\r\n"

impl PlatformConfig:
    fn to_text() -> text:
        "{self.arch.name()}-{self.os.name()} ({self.endian.name()}, ptr={self.pointer_bytes}, nl={self.newline.len()})"

# Auto-detect host platform (called once, cached)
fn host_config() -> PlatformConfig:
    val arch = TargetArch__host()
    val os = TargetOS__host()
    val nl = if os.name() == "windows": "\r\n" else: "\n"
    PlatformConfig(
        arch: arch,
        os: os,
        endian: arch.endianness(),
        pointer_bytes: arch.pointer_bytes(),
        newline: nl
    )

# Create config for a known target (cross-compilation, remote peer)
fn make_config(arch: TargetArch, os: TargetOS) -> PlatformConfig:
    val nl = if os.name() == "windows": "\r\n" else: "\n"
    PlatformConfig(
        arch: arch,
        os: os,
        endian: arch.endianness(),
        pointer_bytes: arch.pointer_bytes(),
        newline: nl
    )

# Network config (always big-endian, no OS, LF newlines)
fn network_config() -> PlatformConfig:
    PlatformConfig(
        arch: TargetArch.X86_64,   # doesn't matter for network
        os: TargetOS.Any,
        endian: Endian.Big,         # network byte order = big-endian
        pointer_bytes: 8,
        newline: "\n"
    )

# Check if two configs need byte swapping
fn needs_swap(from_cfg: PlatformConfig, to_cfg: PlatformConfig) -> bool:
    from_cfg.endian.name() != to_cfg.endian.name()

# Check if two configs are effectively the same (send/recv = no-op)
fn same_platform(a: PlatformConfig, b: PlatformConfig) -> bool:
    val same_endian = a.endian.name() == b.endian.name()
    val same_nl = a.newline == b.newline
    val same_ptr = a.pointer_bytes == b.pointer_bytes
    val result = same_endian and same_nl
    val final_result = result and same_ptr
    final_result
