# TLS Cipher Suite Management Module
#
# Provides cipher suite information, security assessment, key derivation,
# and cryptographic primitives (HMAC, PRF).

# Get cipher suite information
# Parameters:
#   cipher_id: Cipher suite ID
# Returns: (id, name, key_exchange, cipher, mac, secure) tuple
fn parse_cipher_suite(cipher_id):
    val CIPHER_TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256 = 0xC02F
    val CIPHER_TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384 = 0xC030
    val CIPHER_TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305_SHA256 = 0xCCA8
    val CIPHER_TLS_RSA_WITH_AES_128_GCM_SHA256 = 0x009C
    val CIPHER_TLS_RSA_WITH_AES_256_GCM_SHA384 = 0x009D
    val CIPHER_TLS_RSA_WITH_AES_128_CBC_SHA256 = 0x003C
    val CIPHER_TLS_RSA_WITH_AES_256_CBC_SHA256 = 0x003D

    if cipher_id == CIPHER_TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256:
        (cipher_id, "TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256", "ECDHE_RSA", "AES_128_GCM", "SHA256", true)
    else if cipher_id == CIPHER_TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384:
        (cipher_id, "TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384", "ECDHE_RSA", "AES_256_GCM", "SHA384", true)
    else if cipher_id == CIPHER_TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305_SHA256:
        (cipher_id, "TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305_SHA256", "ECDHE_RSA", "CHACHA20_POLY1305", "SHA256", true)
    else if cipher_id == CIPHER_TLS_RSA_WITH_AES_128_GCM_SHA256:
        (cipher_id, "TLS_RSA_WITH_AES_128_GCM_SHA256", "RSA", "AES_128_GCM", "SHA256", false)
    else if cipher_id == CIPHER_TLS_RSA_WITH_AES_256_GCM_SHA384:
        (cipher_id, "TLS_RSA_WITH_AES_256_GCM_SHA384", "RSA", "AES_256_GCM", "SHA384", false)
    else if cipher_id == CIPHER_TLS_RSA_WITH_AES_128_CBC_SHA256:
        (cipher_id, "TLS_RSA_WITH_AES_128_CBC_SHA256", "RSA", "AES_128_CBC", "SHA256", false)
    else if cipher_id == CIPHER_TLS_RSA_WITH_AES_256_CBC_SHA256:
        (cipher_id, "TLS_RSA_WITH_AES_256_CBC_SHA256", "RSA", "AES_256_CBC", "SHA256", false)
    else:
        (cipher_id, "UNKNOWN", "UNKNOWN", "UNKNOWN", "UNKNOWN", false)

# Get cipher suite name
# Parameters:
#   cipher_id: Cipher suite ID
# Returns: Human-readable name
fn get_cipher_name(cipher_id):
    val suite = parse_cipher_suite(cipher_id)
    suite[1]

# Check if cipher suite is considered secure
# Parameters:
#   cipher_id: Cipher suite ID
# Returns: true if secure (ECDHE + AEAD), false otherwise
fn is_cipher_suite_secure(cipher_id):
    val suite = parse_cipher_suite(cipher_id)
    suite[5]

# Check if cipher provides forward secrecy
# Parameters:
#   cipher_id: Cipher suite ID
# Returns: true if provides forward secrecy (ECDHE/DHE)
fn has_forward_secrecy(cipher_id):
    val suite = parse_cipher_suite(cipher_id)
    val kex = suite[2]
    val starts_ecdhe = starts_with(kex, "ECDHE")
    val starts_dhe = starts_with(kex, "DHE")
    starts_ecdhe or starts_dhe

# Check if cipher uses AEAD mode
# Parameters:
#   cipher_id: Cipher suite ID
# Returns: true if AEAD (GCM, ChaCha20-Poly1305)
fn is_aead_cipher(cipher_id):
    val suite = parse_cipher_suite(cipher_id)
    val cipher = suite[3]
    val has_gcm = contains(cipher, "GCM")
    val has_poly1305 = contains(cipher, "POLY1305")
    has_gcm or has_poly1305

# Get cipher key size in bits
# Parameters:
#   cipher_id: Cipher suite ID
# Returns: Key size in bits
fn get_cipher_key_size(cipher_id):
    val suite = parse_cipher_suite(cipher_id)
    val cipher = suite[3]

    if contains(cipher, "AES_128"):
        128
    else if contains(cipher, "AES_256"):
        256
    else if contains(cipher, "CHACHA20"):
        256
    else:
        0

# Get hash algorithm for cipher suite
# Parameters:
#   cipher_id: Cipher suite ID
# Returns: Hash algorithm name
fn get_hash_algorithm(cipher_id):
    val suite = parse_cipher_suite(cipher_id)
    suite[4]

# Get list of supported cipher suites (ordered by preference)
# Returns: List of cipher suite IDs
fn get_supported_ciphers():
    val CIPHER_TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384 = 0xC030
    val CIPHER_TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256 = 0xC02F
    val CIPHER_TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305_SHA256 = 0xCCA8
    val CIPHER_TLS_RSA_WITH_AES_256_GCM_SHA384 = 0x009D
    val CIPHER_TLS_RSA_WITH_AES_128_GCM_SHA256 = 0x009C

    [
        CIPHER_TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384,
        CIPHER_TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256,
        CIPHER_TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305_SHA256,
        CIPHER_TLS_RSA_WITH_AES_256_GCM_SHA384,
        CIPHER_TLS_RSA_WITH_AES_128_GCM_SHA256
    ]

# Get list of secure cipher suites only
# Returns: List of secure cipher suite IDs
fn get_secure_ciphers():
    val CIPHER_TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384 = 0xC030
    val CIPHER_TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256 = 0xC02F
    val CIPHER_TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305_SHA256 = 0xCCA8

    [
        CIPHER_TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384,
        CIPHER_TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256,
        CIPHER_TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305_SHA256
    ]

# Filter cipher suites by security level
# Parameters:
#   cipher_list: List of cipher suite IDs
# Returns: List of only secure ciphers
fn filter_secure_ciphers(cipher_list):
    var result = []
    for cipher in cipher_list:
        if is_cipher_suite_secure(cipher):
            result = append(result, cipher)
        else:
            pass
    result

# TLS PRF (Pseudorandom Function) - TLS 1.2 version
# Parameters:
#   secret: Secret value for PRF
#   label: ASCII label string
#   seed: Seed value
#   output_length: Desired output length in bytes
# Returns: PRF output bytes
#
# TLS 1.2 PRF uses HMAC-SHA256:
# PRF(secret, label, seed) = P_SHA256(secret, label + seed)
fn tls_prf(secret, label, seed, output_length):
    val label_bytes = to_bytes(label)
    val combined_seed = concat_bytes(label_bytes, seed)
    tls_prf_sha256(secret, combined_seed, output_length)

# P_SHA256 expansion function
# Parameters:
#   secret: Secret key
#   seed: Seed value
#   output_length: Desired output length
# Returns: Expanded key material
#
# P_SHA256(secret, seed) = HMAC_SHA256(secret, A(1) + seed) +
#                          HMAC_SHA256(secret, A(2) + seed) + ...
# where A(0) = seed
#       A(i) = HMAC_SHA256(secret, A(i-1))
fn tls_prf_sha256(secret, seed, output_length):
    var result = []
    var a_value = seed  # A(0) = seed
    var current_length = 0
    var iteration = 0
    var max_iterations = 20

    var continue_loop = current_length < output_length
    while continue_loop and (iteration < max_iterations):
        iteration = iteration + 1

        # A(i) = HMAC_SHA256(secret, A(i-1))
        a_value = hmac_sha256(secret, a_value)

        # Output = HMAC_SHA256(secret, A(i) + seed)
        val a_plus_seed = concat_bytes(a_value, seed)
        val hmac_output = hmac_sha256(secret, a_plus_seed)

        result = concat_bytes(result, hmac_output)
        current_length = len(result)

        if current_length >= output_length:
            continue_loop = false
        else:
            pass

    # Truncate to desired length
    slice(result, 0, output_length)

# Compute master secret from pre-master secret
# Parameters:
#   pre_master_secret: Pre-master secret (48 bytes for RSA)
#   client_random: Client random (32 bytes)
#   server_random: Server random (32 bytes)
# Returns: Master secret (48 bytes)
#
# master_secret = PRF(pre_master_secret, "master secret",
#                     ClientHello.random + ServerHello.random)[0..47]
fn compute_master_secret(pre_master_secret, client_random, server_random):
    val combined_random = concat_bytes(client_random, server_random)
    tls_prf(pre_master_secret, "master secret", combined_random, 48)

# Derive session keys from master secret
# Parameters:
#   master_secret: Master secret (48 bytes)
#   client_random: Client random (32 bytes)
#   server_random: Server random (32 bytes)
#   mac_key_length: MAC key length in bytes
#   enc_key_length: Encryption key length in bytes
#   iv_length: IV length in bytes
# Returns: (client_mac, server_mac, client_key, server_key, client_iv, server_iv) tuple
#
# key_block = PRF(master_secret, "key expansion",
#                 server_random + client_random)
fn derive_keys(master_secret, client_random, server_random, mac_key_length, enc_key_length, iv_length):
    val combined_random = concat_bytes(server_random, client_random)
    val key_material_length = (2 * mac_key_length) + (2 * enc_key_length) + (2 * iv_length)
    val key_block = tls_prf(master_secret, "key expansion", combined_random, key_material_length)

    # Split key block into individual keys
    var offset = 0
    val client_mac = slice(key_block, offset, offset + mac_key_length)
    offset = offset + mac_key_length

    val server_mac = slice(key_block, offset, offset + mac_key_length)
    offset = offset + mac_key_length

    val client_key = slice(key_block, offset, offset + enc_key_length)
    offset = offset + enc_key_length

    val server_key = slice(key_block, offset, offset + enc_key_length)
    offset = offset + enc_key_length

    val client_iv = slice(key_block, offset, offset + iv_length)
    offset = offset + iv_length

    val server_iv = slice(key_block, offset, offset + iv_length)

    (client_mac, server_mac, client_key, server_key, client_iv, server_iv)

# HMAC-SHA256 (simplified implementation)
# Parameters:
#   key: HMAC key
#   data: Data to authenticate
# Returns: HMAC output (32 bytes for SHA-256)
#
# HMAC(K, m) = H((K' ⊕ opad) || H((K' ⊕ ipad) || m))
# where K' = K if len(K) = block_size, else H(K) padded to block_size
fn hmac_sha256(key, data):
    val block_size = 64  # SHA-256 block size

    # Prepare key
    var key_prime = key
    val key_len = len(key)

    if key_len > block_size:
        key_prime = sha256(key)
    else if key_len < block_size:
        key_prime = pad_to_length(key, block_size)
    else:
        pass

    # Create ipad and opad
    val ipad = xor_with_byte(key_prime, 0x36)
    val opad = xor_with_byte(key_prime, 0x5C)

    # Inner hash: H((K' ⊕ ipad) || m)
    val inner_input = concat_bytes(ipad, data)
    val inner_hash = sha256(inner_input)

    # Outer hash: H((K' ⊕ opad) || inner_hash)
    val outer_input = concat_bytes(opad, inner_hash)
    sha256(outer_input)

# HMAC-SHA384 (for cipher suites using SHA-384)
# Parameters:
#   key: HMAC key
#   data: Data to authenticate
# Returns: HMAC output (48 bytes for SHA-384)
fn hmac_sha384(key, data):
    val block_size = 128  # SHA-384 block size

    var key_prime = key
    val key_len = len(key)

    if key_len > block_size:
        key_prime = sha384(key)
    else if key_len < block_size:
        key_prime = pad_to_length(key, block_size)
    else:
        pass

    val ipad = xor_with_byte(key_prime, 0x36)
    val opad = xor_with_byte(key_prime, 0x5C)

    val inner_input = concat_bytes(ipad, data)
    val inner_hash = sha384(inner_input)

    val outer_input = concat_bytes(opad, inner_hash)
    sha384(outer_input)
