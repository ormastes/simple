# UPX Compression Library
#
# Provides UPX (Ultimate Packer for eXecutables) compression for binary files.
# UPX is automatically downloaded if not found in system PATH.
#
# Usage:
#   import compress.upx
#
#   # Compress a binary (auto-downloads UPX if needed)
#   upx.compress("myapp", level: "best")
#
#   # Compress to different file
#   upx.compress("myapp", "myapp.compressed", level: "ultra-brute")
#
#   # Decompress
#   upx.decompress("myapp.compressed", "myapp.restored")
#
#   # Check if compressed
#   if upx.is_compressed("myapp"):
#       print "Binary is UPX-compressed"
#
#   # Ensure UPX is available
#   upx.ensure_upx()
#
#   # Get UPX binary path
#   val upx_path = upx.get_upx_path()
#   print "UPX installed at: {upx_path}"

## Check if UPX is available on the system (or can be auto-downloaded)
##
## Returns: true if UPX is installed or can be obtained, false otherwise
fn is_available() -> bool:
    extern fn upx_is_available() -> i32
    upx_is_available() == 1

## Ensure UPX is available (auto-download if needed)
##
## This function checks if UPX is available in PATH or cache.
## If not found, it automatically downloads UPX from GitHub releases.
##
## Returns: Result<(), text> - Ok on success, Err with error message on failure
##
## Example:
##   match upx.ensure_upx():
##       Ok(_): print "UPX is ready"
##       Err(msg): print "Failed to get UPX: {msg}"
fn ensure_upx() -> Result<(), text>:
    extern fn upx_ensure_available() -> i32

    val result = upx_ensure_available()
    if result == 0:
        Ok(())
    else:
        Err("Failed to ensure UPX is available. Check network connection or install manually.")

## Get path to UPX binary
##
## Returns path to UPX binary (system PATH or cached version).
## Auto-downloads if not found.
##
## Returns: Option<text> - Some(path) on success, nil on failure
##
## Example:
##   match upx.get_upx_path():
##       Some(path): print "UPX at: {path}"
##       nil: print "Failed to get UPX"
fn get_upx_path() -> text?:
    extern fn upx_get_path(buffer: &mut [u8], size: i32) -> i32

    # Allocate buffer for path
    var buffer = [0u8; 4096]
    val result = upx_get_path(buffer, 4096)

    if result < 0:
        nil
    else:
        # Convert buffer to text
        val path_bytes = buffer[0..result]
        Some(text.from_utf8(path_bytes))

## Compress a binary file using UPX
##
## Arguments:
##   input: Path to input binary file
##   output: Optional path to output file (if nil, compresses in-place)
##   level: Compression level - "fast", "best" (default), or "ultra-brute"
##
## Returns: Result<text, text> - Ok(output_path) or Err(error_message)
##
## Examples:
##   # Compress in-place with best compression
##   upx.compress("myapp", level: "best")
##
##   # Compress to different file with maximum compression
##   upx.compress("myapp", "myapp.upx", level: "ultra-brute")
##
##   # Fast compression
##   upx.compress("myapp", level: "fast")
fn compress(input: text, output: text? = nil, level: text = "best") -> Result<text, text>:
    extern fn upx_compress_file(input: text, output: text, level: i32) -> i32

    if not is_available():
        return Err("UPX is not installed. Install with: sudo apt-get install upx")

    # Map level string to integer
    val level_code = match level:
        "fast": 1
        "best": 2
        "ultra-brute": 3
        "ultrabrute": 3  # Alternative spelling
        _:
            return Err("Invalid compression level. Use 'fast', 'best', or 'ultra-brute'")

    # Determine output path
    val actual_output = match output:
        Some(out): out
        nil: input  # In-place compression

    # Call FFI function
    val result = upx_compress_file(input, actual_output, level_code)

    if result == 0:
        Ok(actual_output)
    else:
        Err("UPX compression failed. Check that the file exists and is a valid executable.")

## Decompress a UPX-compressed file
##
## Arguments:
##   input: Path to compressed binary file
##   output: Path to output file
##
## Returns: Result<text, text> - Ok(output_path) or Err(error_message)
##
## Example:
##   upx.decompress("myapp.upx", "myapp.restored")
fn decompress(input: text, output: text) -> Result<text, text>:
    extern fn upx_decompress_file(input: text, output: text) -> i32

    if not is_available():
        return Err("UPX is not installed")

    val result = upx_decompress_file(input, output)

    if result == 0:
        Ok(output)
    else:
        Err("UPX decompression failed. Check that the file is UPX-compressed.")

## Check if a file is UPX-compressed
##
## Arguments:
##   file: Path to file to check
##
## Returns: true if file is UPX-compressed, false otherwise
##
## Example:
##   if upx.is_compressed("myapp"):
##       print "File is compressed"
fn is_compressed(file: text) -> bool:
    extern fn upx_is_compressed(file: text) -> i32
    upx_is_compressed(file) == 1

## Get compression ratio of a file
##
## Arguments:
##   file: Path to compressed file
##
## Returns: Compression ratio (original_size / compressed_size) or 1.0 if not compressed
##
## Example:
##   val ratio = upx.get_ratio("myapp.upx")
##   print "Compression ratio: {ratio}x"
fn get_ratio(file: text) -> f64:
    extern fn upx_get_ratio(file: text) -> f64
    val ratio = upx_get_ratio(file)
    if ratio < 0.0:
        1.0  # Return 1.0 on error (no compression)
    else:
        ratio

## Get compression percentage
##
## Arguments:
##   file: Path to compressed file
##
## Returns: Compression percentage (0-100) or 0 if not compressed
##
## Example:
##   val pct = upx.get_compression_pct("myapp.upx")
##   print "Reduced by {pct}%"
fn get_compression_pct(file: text) -> f64:
    val ratio = get_ratio(file)
    if ratio <= 1.0:
        0.0
    else:
        (1.0 - (1.0 / ratio)) * 100.0

# ============================================================================
# Self-Extracting Executables (Pure Rust LZMA, no UPX needed)
# ============================================================================

## Create a self-extracting executable
fn create_self_extracting(input: text, output: text, level: i32 = 6) -> Result<(), text>:
    extern fn self_extract_create(input: text, output: text, level: i32) -> i32
    val result = self_extract_create(input, output, level)
    if result == 0:
        Ok(())
    else:
        Err("Failed to create self-extracting executable")

## Check if a file is a self-extracting executable
fn is_self_extracting(file: text) -> bool:
    extern fn self_extract_is_compressed(file: text) -> i32
    self_extract_is_compressed(file) == 1

## Get compression ratio of a self-extracting executable
fn get_self_extract_ratio(file: text) -> f64:
    extern fn self_extract_get_ratio(file: text) -> f64
    val ratio = self_extract_get_ratio(file)
    if ratio < 0.0:
        1.0
    else:
        ratio
