# CLI Formatting Module
# Text formatting and color output utilities

# =============================================================================
# Text Formatting Utilities
# =============================================================================

# Pad text to the right with spaces
fn pad_right(text: text, width: i64) -> text:
    val current_len = len(text)
    if current_len >= width:
        return text
    val spaces_needed = width - current_len
    var result = text
    var i = 0
    while i < spaces_needed:
        result = "{result} "
        i = i + 1
    result

# Pad text to the left with spaces
fn pad_left(text: text, width: i64) -> text:
    val current_len = len(text)
    if current_len >= width:
        return text
    val spaces_needed = width - current_len
    var result = ""
    var i = 0
    while i < spaces_needed:
        result = "{result} "
        i = i + 1
    "{result}{text}"

# Align text left within width
fn align_left(text: text, width: i64) -> text:
    pad_right(text, width)

# Align text right within width
fn align_right(text: text, width: i64) -> text:
    pad_left(text, width)

# Align text center within width
fn align_center(text: text, width: i64) -> text:
    val current_len = len(text)
    if current_len >= width:
        return text
    val spaces_needed = width - current_len
    val left_spaces = spaces_needed / 2
    val right_spaces = spaces_needed - left_spaces

    var result = ""
    var i = 0
    while i < left_spaces:
        result = "{result} "
        i = i + 1
    result = "{result}{text}"
    var j = 0
    while j < right_spaces:
        result = "{result} "
        j = j + 1
    result

# Wrap text to specified width
fn wrap_text(text: text, width: i64) -> text:
    if len(text) <= width:
        return text

    var result = ""
    var current_line = ""
    var words = split_by_space(text)
    var i = 0

    while i < len(words):
        val word = words[i]
        val test_line = "{current_line} {word}"
        val trimmed = trim(test_line)

        if len(trimmed) <= width:
            current_line = trimmed
        else:
            if current_line != "":
                if result == "":
                    result = current_line
                else:
                    result = "{result}\n{current_line}"
            current_line = word
        i = i + 1

    if current_line != "":
        if result == "":
            result = current_line
        else:
            result = "{result}\n{current_line}"

    result

# Truncate text to width with ellipsis
fn truncate(text: text, width: i64) -> text:
    if len(text) <= width:
        return text
    if width <= 3:
        return substring(text, 0, width)
    val truncated = substring(text, 0, width - 3)
    "{truncated}..."

# Pad text to exact width (truncate if too long)
fn pad(text: text, width: i64) -> text:
    val current_len = len(text)
    if current_len == width:
        return text
    if current_len > width:
        return truncate(text, width)
    pad_right(text, width)

fn split_by_space(text: text) -> list:
    var result = []
    var current_word = ""
    var i = 0

    while i < len(text):
        val ch = substring(text, i, i + 1)
        if ch == " ":
            if current_word != "":
                result.push(current_word)
                current_word = ""
        else:
            current_word = "{current_word}{ch}"
        i = i + 1

    if current_word != "":
        result.push(current_word)

    result

fn trim(text: text) -> text:
    var start = 0
    var end = len(text)

    # Trim from start
    while start < end:
        val ch = substring(text, start, start + 1)
        if ch != " ":
            start = len(text)
        else:
            start = start + 1

    # Trim from end
    while end > start:
        val ch = substring(text, end - 1, end)
        if ch != " ":
            end = 0
        else:
            end = end - 1

    substring(text, start, end)

# =============================================================================
# Color Output
# =============================================================================

val ANSI_RESET = "\033[0m"
val ANSI_RED = "\033[31m"
val ANSI_GREEN = "\033[32m"
val ANSI_YELLOW = "\033[33m"
val ANSI_BLUE = "\033[34m"
val ANSI_MAGENTA = "\033[35m"
val ANSI_CYAN = "\033[36m"
val ANSI_WHITE = "\033[37m"
val ANSI_BOLD = "\033[1m"
val ANSI_DIM = "\033[2m"
val ANSI_UNDERLINE = "\033[4m"

# Apply ANSI color code to text
fn colorize(text: text, color_code: text) -> text:
    "{color_code}{text}{ANSI_RESET}"

# Color text red
fn red(text: text) -> text:
    colorize(text, ANSI_RED)

# Color text green
fn green(text: text) -> text:
    colorize(text, ANSI_GREEN)

# Color text yellow
fn yellow(text: text) -> text:
    colorize(text, ANSI_YELLOW)

# Color text blue
fn blue(text: text) -> text:
    colorize(text, ANSI_BLUE)

# Color text magenta
fn magenta(text: text) -> text:
    colorize(text, ANSI_MAGENTA)

# Color text cyan
fn cyan(text: text) -> text:
    colorize(text, ANSI_CYAN)

# Color text white
fn white(text: text) -> text:
    colorize(text, ANSI_WHITE)

# Make text bold
fn bold(text: text) -> text:
    "{ANSI_BOLD}{text}{ANSI_RESET}"

# Make text dim
fn dim(text: text) -> text:
    "{ANSI_DIM}{text}{ANSI_RESET}"

# Make text underlined
fn underline(text: text) -> text:
    "{ANSI_UNDERLINE}{text}{ANSI_RESET}"

# =============================================================================
# Formatted Output
# =============================================================================

# Print success message (green)
fn print_success(message: text):
    val formatted = green("[SUCCESS] {message}")
    print formatted

# Print error message (red)
fn print_error(message: text):
    val formatted = red("[ERROR] {message}")
    print formatted

# Print warning message (yellow)
fn print_warning(message: text):
    val formatted = yellow("[WARNING] {message}")
    print formatted

# Print info message (blue)
fn print_info(message: text):
    val formatted = blue("[INFO] {message}")
    print formatted

# Print debug message (dim)
fn print_debug(message: text):
    val formatted = dim("[DEBUG] {message}")
    print formatted

# =============================================================================
# Advanced Formatting
# =============================================================================

# Create a horizontal line
fn horizontal_line(width: i64) -> text:
    var line = ""
    var i = 0
    while i < width:
        line = "{line}-"
        i = i + 1
    line

# Create a box around text
fn box_text(text: text) -> text:
    val width = len(text) + 4
    val top = horizontal_line(width)
    val middle = "| {text} |"
    val bottom = horizontal_line(width)
    "{top}\n{middle}\n{bottom}"

# Create a section header
fn section_header(title: text) -> text:
    val line = horizontal_line(50)
    "{line}\n{title}\n{line}"

# Format a key-value pair
fn format_key_value(key: text, value: text) -> text:
    val padded_key = pad_right(key, 20)
    "{padded_key}: {value}"

# Format a list item
fn format_list_item(text: text, number: i64) -> text:
    "  {number}. {text}"

# Format a bullet item
fn format_bullet_item(text: text) -> text:
    "  * {text}"

# =============================================================================
# Table Formatting
# =============================================================================

# Create a table with headers
fn create_table(headers: list) -> tuple:
    val rows = []
    val column_widths = calculate_widths_from_headers(headers)
    (headers, rows, column_widths)

# Add a row to the table
fn add_row(table: tuple, values: list) -> tuple:
    val headers = table[0]
    val rows = table[1]
    val widths = table[2]

    val new_rows = rows + [values]
    val new_widths = update_widths(widths, values)
    (headers, new_rows, new_widths)

# Format table for display
fn format_table(table: tuple) -> text:
    val headers = table[0]
    val rows = table[1]
    val widths = table[2]

    var result = ""

    # Header row
    var header_line = "|"
    var i = 0
    while i < len(headers):
        val header = headers[i]
        val width = widths[i]
        val padded = pad_right(header, width)
        header_line = "{header_line} {padded} |"
        i = i + 1
    result = "{result}{header_line}\n"

    # Separator
    var separator = "|"
    var j = 0
    while j < len(headers):
        val width = widths[j]
        var dashes = ""
        var k = 0
        while k < width + 2:
            dashes = "{dashes}-"
            k = k + 1
        separator = "{separator}{dashes}|"
        j = j + 1
    result = "{result}{separator}\n"

    # Data rows
    var m = 0
    while m < len(rows):
        val row = rows[m]
        var row_line = "|"
        var n = 0
        while n < len(row):
            val cell = row[n]
            val width = widths[n]
            val padded = pad_right(cell, width)
            row_line = "{row_line} {padded} |"
            n = n + 1
        result = "{result}{row_line}\n"
        m = m + 1

    result

fn calculate_widths_from_headers(headers: list) -> list:
    var widths = []
    var i = 0
    while i < len(headers):
        val header = headers[i]
        widths.push(len(header))
        i = i + 1
    widths

fn update_widths(widths: list, values: list) -> list:
    var new_widths = []
    var i = 0
    while i < len(widths):
        val current_width = widths[i]
        var new_width = current_width
        if i < len(values):
            val value = values[i]
            val value_len = len(value)
            if value_len > current_width:
                new_width = value_len
        new_widths.push(new_width)
        i = i + 1
    new_widths

# =============================================================================
# Progress Indicators
# =============================================================================

# Create a progress bar
fn create_progress_bar(total: i64) -> tuple:
    val current = 0
    val width = 50
    val prefix = ""
    val suffix = ""
    (total, current, width, prefix, suffix)

# Update progress bar
fn update_progress(bar: tuple, current: i64):
    val total = bar[0]
    val width = bar[2]
    val prefix = bar[3]
    val suffix = bar[4]

    val percentage = current * 100 / total
    val filled = current * width / total

    var bar_str = "["
    var i = 0
    while i < width:
        if i < filled:
            bar_str = "{bar_str}="
        else:
            bar_str = "{bar_str} "
        i = i + 1
    bar_str = "{bar_str}]"

    print "\r{prefix}{bar_str} {percentage}% {suffix}"

# Show a simple spinner
fn show_spinner(message: text):
    print "{message}..."
