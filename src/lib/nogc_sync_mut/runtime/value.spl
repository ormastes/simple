# Runtime Value - Pure Simple Implementation
#
# Provides dynamic value types for the Simple runtime.
# This replaces the Rust RuntimeValue with a native Simple implementation.

# Value types (matching Rust enum discriminants)
enum ValueKind:
    Nil
    Bool
    Int
    Float
    String
    Array
    Dict
    Object
    Function

# Dynamic value wrapper
class RuntimeValue:
    kind: ValueKind
    data: any  # Holds the actual value

    # Constructors
    static fn make_nil() -> RuntimeValue:
        RuntimeValue(kind: ValueKind.Nil, data: nil)

    static fn make_bool(value: bool) -> RuntimeValue:
        RuntimeValue(kind: ValueKind.Bool, data: value)

    static fn make_int(value: i64) -> RuntimeValue:
        RuntimeValue(kind: ValueKind.Int, data: value)

    static fn make_float(value: f64) -> RuntimeValue:
        RuntimeValue(kind: ValueKind.Float, data: value)

    static fn make_string(value: text) -> RuntimeValue:
        RuntimeValue(kind: ValueKind.String, data: value)

    static fn make_array(values: list) -> RuntimeValue:
        RuntimeValue(kind: ValueKind.Array, data: values)

    static fn make_dict(entries: list) -> RuntimeValue:
        RuntimeValue(kind: ValueKind.Dict, data: entries)

    # Type checking
    fn is_nil() -> bool:
        self.kind == ValueKind.Nil

    fn is_bool() -> bool:
        self.kind == ValueKind.Bool

    fn is_int() -> bool:
        self.kind == ValueKind.Int

    fn is_float() -> bool:
        self.kind == ValueKind.Float

    fn is_string() -> bool:
        self.kind == ValueKind.String

    fn is_array() -> bool:
        self.kind == ValueKind.Array

    fn is_dict() -> bool:
        self.kind == ValueKind.Dict

    # Type conversions
    fn as_bool() -> bool:
        match self.kind:
            ValueKind.Bool:
                self.data
            ValueKind.Nil:
                false
            _:
                true

    fn as_int() -> i64:
        match self.kind:
            ValueKind.Int:
                self.data
            _:
                0

    fn as_float() -> f64:
        match self.kind:
            ValueKind.Float:
                self.data
            _:
                0.0

    fn as_string() -> text:
        match self.kind:
            ValueKind.String:
                self.data
            ValueKind.Nil:
                "nil"
            _:
                "<value>"

    # Arithmetic operations
    fn add(other: RuntimeValue) -> RuntimeValue:
        # Int + Int
        if self.is_int() and other.is_int():
            return RuntimeValue.make_int(self.as_int() + other.as_int())

        # Float + Float or mixed
        if self.is_float() or other.is_float():
            return RuntimeValue.make_float(self.as_float() + other.as_float())

        # String + String
        if self.is_string() and other.is_string():
            return RuntimeValue.make_string(self.as_string() + other.as_string())

        RuntimeValue.make_nil()

    fn sub(other: RuntimeValue) -> RuntimeValue:
        if self.is_float() or other.is_float():
            return RuntimeValue.make_float(self.as_float() - other.as_float())
        RuntimeValue.make_int(self.as_int() - other.as_int())

    fn mul(other: RuntimeValue) -> RuntimeValue:
        if self.is_float() or other.is_float():
            return RuntimeValue.make_float(self.as_float() * other.as_float())
        RuntimeValue.make_int(self.as_int() * other.as_int())

    fn div(other: RuntimeValue) -> RuntimeValue:
        if self.is_float() or other.is_float():
            return RuntimeValue.make_float(self.as_float() / other.as_float())

        val divisor = other.as_int()
        if divisor == 0:
            return RuntimeValue.make_nil()

        RuntimeValue.make_int(self.as_int() / divisor)

    # Comparison
    fn eq(other: RuntimeValue) -> bool:
        if self.kind != other.kind:
            return false

        match self.kind:
            ValueKind.Nil:
                true
            ValueKind.Bool:
                self.as_bool() == other.as_bool()
            ValueKind.Int:
                self.as_int() == other.as_int()
            ValueKind.Float:
                self.as_float() == other.as_float()
            ValueKind.String:
                self.as_string() == other.as_string()
            _:
                false

    fn lt(other: RuntimeValue) -> bool:
        # Numeric comparison (supports mixed int/float)
        if (self.is_int() or self.is_float()) and (other.is_int() or other.is_float()):
            return self.as_float() < other.as_float()

        # String comparison
        if self.is_string() and other.is_string():
            return self.as_string() < other.as_string()

        false

    # Display
    fn display():
        match self.kind:
            ValueKind.Nil:
                print "nil"
            ValueKind.Bool:
                print self.as_bool()
            ValueKind.Int:
                print self.as_int()
            ValueKind.Float:
                print self.as_float()
            ValueKind.String:
                print self.as_string()
            ValueKind.Array:
                print "[Array]"
            ValueKind.Dict:
                print "[Dict]"
            _:
                print "<value>"

    fn display_ln():
        self.display()
        print ""
