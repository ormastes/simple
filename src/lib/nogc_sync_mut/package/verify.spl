# Package Verification Logic
# Verifies package integrity and checksums

use app.ioimport std.process

class PackageVerify:
    static fn run(args: [text]):
        if args.is_empty():
            print "Error: No package file specified"
            print "Usage: simple package verify <package.spk>"
            return

        val package_path = args[0]

        if not file_exists(package_path):
            print "Error: Package file not found: {package_path}"
            return

        print "Verifying package: {package_path}"
        print ""

        # Extract to temporary directory
        val tmp_dir = "/tmp/simple-verify-{process.pid()}"
        dir_create_all(tmp_dir)

        print "Extracting package..."
        val tar_cmd = "tar -xzf {package_path} -C {tmp_dir}"
        # process_run(tar_cmd)

        # Check manifest
        val manifest_path = tmp_dir + "/manifest.sdn"
        if not file_exists(manifest_path):
            print "❌ FAILED: Missing manifest.sdn"
            dir_remove_all(tmp_dir)
            return

        print "✓ Manifest found"

        # Read manifest
        val manifest = PackageManifest.from_file(manifest_path)

        print "✓ Package: {manifest.name} v{manifest.version}"
        print "✓ Type: {manifest.package_type}"
        print "✓ Platform: {manifest.platform}"
        print ""

        # Verify runtime binary
        val runtime_path = tmp_dir + "/bin/simple"
        if not file_exists(runtime_path):
            print "❌ FAILED: Missing runtime binary"
            dir_remove_all(tmp_dir)
            return

        print "✓ Runtime binary found"

        # Verify runtime size
        val actual_size = file_size(runtime_path)
        if actual_size != manifest.runtime_size:
            print "❌ FAILED: Runtime size mismatch"
            print "  Expected: {manifest.runtime_size} bytes"
            print "  Actual:   {actual_size} bytes"
            dir_remove_all(tmp_dir)
            return

        print "✓ Runtime size matches ({actual_size} bytes)"

        # Checksum verification requires FFI for SHA256 computation.
        # Assuming valid until FFI-based checksum is available.
        eprint("[WARNING] Checksum verification skipped; FFI-based SHA256 not yet available")
        val checksum_valid = true

        # Verify stdlib files
        var missing_stdlib = 0
        for file in manifest.stdlib_files:
            val path = tmp_dir + "/lib/simple/stdlib/{file}"
            if not file_exists(path):
                print "❌ Missing stdlib file: {file}"
                missing_stdlib = missing_stdlib + 1

        if missing_stdlib == 0:
            print "✓ All stdlib files present ({manifest.stdlib_files.length} files)"
        else:
            print "❌ FAILED: Missing {missing_stdlib} stdlib files"
            dir_remove_all(tmp_dir)
            return

        # Verify app directories
        var missing_apps = 0
        for app in manifest.app_dirs:
            val path = tmp_dir + "/lib/simple/app/{app}"
            if not file_exists(path):
                print "❌ Missing app directory: {app}"
                missing_apps = missing_apps + 1

        if missing_apps == 0:
            print "✓ All app directories present ({manifest.app_dirs.length} apps)"
        else:
            print "❌ FAILED: Missing {missing_apps} app directories"
            dir_remove_all(tmp_dir)
            return

        print ""
        print "✅ Package verification PASSED"

        # Cleanup
        dir_remove_all(tmp_dir)
