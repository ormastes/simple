# compression/snappy.spl - Advanced compression utilities
#
# Additional compression algorithms and transformations:
# - Dictionary-based compression
# - Move-to-front encoding
# - Burrows-Wheeler Transform

# Dictionary-based compression - build dictionary of common patterns
fn dict_compress(text, dict_size):
    if text == nil:
        return nil

    # Build dictionary of most common substrings
    var dict = []
    val len = text.length()

    # Find common 2-char sequences
    var i = 0
    loop:
        if i + 1 >= len:
            break

        val pattern = text[i] + text[i + 1]
        dict = dict_add_pattern(dict, pattern, dict_size)

        i = i + 1

    # Encode using dictionary
    var encoded = []
    var pos = 0

    loop:
        if pos >= len:
            break

        # Try to match dictionary entry
        var matched = false
        var dict_idx = 0

        loop:
            if dict_idx >= dict.length():
                break

            val entry = dict[dict_idx]
            val pattern = entry[0]
            val pat_len = pattern.length()

            if pos + pat_len <= len:
                var matches = true
                var k = 0

                loop:
                    if k >= pat_len:
                        break

                    if text[pos + k] != pattern[k]:
                        matches = false
                        break

                    k = k + 1

                if matches:
                    encoded = encoded + [["dict", dict_idx]]
                    pos = pos + pat_len
                    matched = true
                    break

            dict_idx = dict_idx + 1

        if matched == false:
            # Literal character
            encoded = encoded + [["lit", text[pos]]]
            pos = pos + 1

    return [encoded, dict]

# Add pattern to dictionary if not full
fn dict_add_pattern(dict, pattern, max_size):
    # Check if already in dictionary
    var i = 0
    loop:
        if i >= dict.length():
            break

        val entry = dict[i]
        val pat = entry[0]

        if pat == pattern:
            # Increment count
            val count = entry[1]
            var new_dict = []
            var j = 0

            loop:
                if j >= dict.length():
                    break

                if j == i:
                    new_dict = new_dict + [[pat, count + 1]]
                else:
                    new_dict = new_dict + [dict[j]]

                j = j + 1

            return new_dict

        i = i + 1

    # Add new pattern if room
    if dict.length() < max_size:
        return dict + [[pattern, 1]]

    return dict

# Move-to-front encoding
fn mtf_encode(text):
    if text == nil:
        return []

    # Initialize alphabet
    var alphabet = ["a", "b", "c", "d", "e", "f", "g", "h", "i", "j"]
    var encoded = []
    var i = 0

    loop:
        if i >= text.length():
            break

        val ch = text[i]

        # Find position in alphabet
        var pos = 0
        var j = 0

        loop:
            if j >= alphabet.length():
                break

            if alphabet[j] == ch:
                pos = j
                break

            j = j + 1

        encoded = encoded + [pos]

        # Move to front
        var new_alphabet = [ch]
        var k = 0

        loop:
            if k >= alphabet.length():
                break

            if k != pos:
                new_alphabet = new_alphabet + [alphabet[k]]

            k = k + 1

        alphabet = new_alphabet
        i = i + 1

    return encoded

# Burrows-Wheeler Transform (simplified)
fn bwt_encode(text):
    if text == nil:
        return nil

    val len = text.length()
    if len == 0:
        return ["", 0]

    # Create all rotations
    var rotations = []
    var i = 0

    loop:
        if i >= len:
            break

        val rotation = text.substring(i, len) + text.substring(0, i)
        rotations = rotations + [rotation]

        i = i + 1

    # Sort rotations (simple bubble sort)
    rotations = sort_strings(rotations)

    # Extract last column
    var result = ""
    var original_idx = 0
    var j = 0

    loop:
        if j >= rotations.length():
            break

        val rot = rotations[j]
        val last_char = rot[len - 1]
        result = result + last_char

        if rot == text:
            original_idx = j

        j = j + 1

    return [result, original_idx]

# Sort array of strings (simple bubble sort)
fn sort_strings(strings):
    if strings == nil:
        return []

    val len = strings.length()
    if len <= 1:
        return strings

    var sorted = strings
    var i = 0

    loop:
        if i >= len:
            break

        var j = 0
        loop:
            if j >= len - i - 1:
                break

            val curr = sorted[j]
            val next = sorted[j + 1]

            if string_compare(curr, next) > 0:
                # Swap
                var new_sorted = []
                var k = 0

                loop:
                    if k >= sorted.length():
                        break

                    if k == j:
                        new_sorted = new_sorted + [next]
                    else:
                        if k == j + 1:
                            new_sorted = new_sorted + [curr]
                        else:
                            new_sorted = new_sorted + [sorted[k]]

                    k = k + 1

                sorted = new_sorted

            j = j + 1

        i = i + 1

    return sorted

# Compare two strings (lexicographic)
fn string_compare(s1, s2):
    if s1 == nil:
        return -1
    if s2 == nil:
        return 1

    val len1 = s1.length()
    val len2 = s2.length()

    var min_len = len1
    if len2 < len1:
        min_len = len2

    var i = 0
    loop:
        if i >= min_len:
            break

        val c1 = s1[i]
        val c2 = s2[i]

        if c1 < c2:
            return -1
        if c1 > c2:
            return 1

        i = i + 1

    if len1 < len2:
        return -1
    if len1 > len2:
        return 1

    return 0
