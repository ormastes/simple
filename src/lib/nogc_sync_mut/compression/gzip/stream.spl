# GZIP Stream Operations
#
# Purpose: Streaming compression for large data
#
# Contains:
# - Stream state initialization
# - Chunked data updates
# - Stream finalization
# - Multi-chunk compression
# - Bit packing/unpacking utilities
# - Text/byte conversion utilities

mod compression.gzip.types
mod compression.gzip.crc
mod compression.gzip.header
mod compression.gzip.lz77
mod compression.gzip.deflate

# =============================================================================
# STREAM OPERATIONS
# =============================================================================

# Stream state: (crc, size, pending_data, level)
fn gzip_stream_init(level):
    return [0xffffffff, 0, [], level]

# Update stream with new data chunk
fn gzip_stream_update(state, chunk):
    if state == nil:
        return nil

    if chunk == nil:
        return state

    val crc = state[0]
    val size = state[1]
    val pending = state[2]
    val level = state[3]

    # Update CRC
    val new_crc = crc32_update(crc, chunk)

    # Update size
    val new_size = size + chunk.length()

    # Append to pending data
    var new_pending = pending
    var i = 0
    loop:
        if i >= chunk.length():
            break
        new_pending = new_pending + [chunk[i]]
        i = i + 1

    return [new_crc, new_size, new_pending, level]

# Finalize stream and get compressed output
fn gzip_stream_finalize(state):
    if state == nil:
        return nil

    val crc = state[0]
    val size = state[1]
    val pending = state[2]
    val level = state[3]

    # Finalize CRC
    val final_crc = crc32_finalize(crc)

    # Compress pending data
    return gzip_compress(pending, level)

# Stream compress multiple chunks
fn gzip_stream_compress(chunks, level):
    if chunks == nil:
        return nil

    var state = gzip_stream_init(level)

    var i = 0
    loop:
        if i >= chunks.length():
            break

        state = gzip_stream_update(state, chunks[i])

        i = i + 1

    return gzip_stream_finalize(state)

# =============================================================================
# BIT PACKING UTILITIES
# =============================================================================

# Pack bits into bytes
fn pack_bits_to_bytes(bits):
    if bits == nil:
        return []

    var bytes = []
    var current = 0
    var bit_count = 0
    var i = 0

    loop:
        if i >= bits.length():
            break

        val bit = bits[i]
        current = (current << 1) | bit
        bit_count = bit_count + 1

        if bit_count == 8:
            bytes = bytes + [current]
            current = 0
            bit_count = 0

        i = i + 1

    # Add remaining bits with padding
    if bit_count > 0:
        current = current << (8 - bit_count)
        bytes = bytes + [current]

    return bytes

# Unpack bytes into bits
fn unpack_bytes_to_bits(bytes):
    if bytes == nil:
        return []

    var bits = []
    var i = 0

    loop:
        if i >= bytes.length():
            break

        val byte = bytes[i]
        var j = 7

        loop:
            if j < 0:
                break

            val bit = (byte >> j) & 1
            bits = bits + [bit]

            j = j - 1

        i = i + 1

    return bits

# =============================================================================
# TEXT/BYTE CONVERSION UTILITIES
# =============================================================================

# Convert byte to character
fn byte_to_char(byte):
    if byte == 97:
        return "a"
    if byte == 122:
        return "z"
    if byte == 65:
        return "A"
    if byte == 90:
        return "Z"
    if byte == 48:
        return "0"
    if byte == 57:
        return "9"
    if byte == 46:
        return "."
    if byte == 47:
        return "/"
    return "?"

# Convert text to bytes
fn text_to_bytes(text):
    if text == nil:
        return []

    var bytes = []
    var i = 0

    loop:
        if i >= text.length():
            break

        val ch = text[i]
        bytes = bytes + [char_to_byte(ch)]

        i = i + 1

    return bytes

# Convert bytes to text
fn bytes_to_text(bytes):
    if bytes == nil:
        return ""

    var parts = []
    var i = 0

    loop:
        if i >= bytes.length():
            break

        val byte = bytes[i]
        parts.append(byte_to_char(byte))

        i = i + 1

    return parts.join("")

# =============================================================================
# BLOCK OPERATIONS
# =============================================================================

# Detect optimal block size for compression
fn gzip_optimal_block_size(data):
    if data == nil:
        return 0

    val size = data.length()

    if size < 1024:
        return size

    if size < 16384:
        return 4096

    if size < 131072:
        return 16384

    return 32768

# Split data into optimal blocks
fn gzip_split_blocks(data):
    if data == nil:
        return []

    val block_size = gzip_optimal_block_size(data)
    var blocks = []
    var offset = 0

    loop:
        if offset >= data.length():
            break

        var end = offset + block_size
        if end > data.length():
            end = data.length()

        var block = []
        var i = offset
        loop:
            if i >= end:
                break
            block = block + [data[i]]
            i = i + 1

        blocks = blocks + [block]
        offset = end

    return blocks

# Merge compressed blocks
fn gzip_merge_blocks(blocks):
    if blocks == nil:
        return []

    var result = []
    var i = 0

    loop:
        if i >= blocks.length():
            break

        val block = blocks[i]
        var j = 0
        loop:
            if j >= block.length():
                break
            result = result + [block[j]]
            j = j + 1

        i = i + 1

    return result

export *
