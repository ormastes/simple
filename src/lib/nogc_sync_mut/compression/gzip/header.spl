# GZIP Header and Footer Operations
#
# Purpose: GZIP header/footer parsing and creation (RFC 1952)
#
# Contains:
# - Header creation with filename and metadata
# - Header parsing and validation
# - Footer creation with CRC32 and size
# - Footer parsing
# - Footer validation

mod compression.gzip.types

# =============================================================================
# GZIP HEADER
# =============================================================================

# Create GZIP header
# Returns: array of header bytes
fn gzip_header_create(filename, timestamp, extra_flags, os_type):
    var header = []

    # Magic bytes
    header = header + [GZIP_MAGIC1, GZIP_MAGIC2]

    # Compression method (8 = DEFLATE)
    header = header + [CM_DEFLATE]

    # Flags
    var flags = 0
    if filename != nil:
        flags = flags | FLAG_NAME
    header = header + [flags]

    # Timestamp (4 bytes, little-endian)
    val ts = timestamp
    header = header + [ts & 0xff]
    header = header + [(ts >> 8) & 0xff]
    header = header + [(ts >> 16) & 0xff]
    header = header + [(ts >> 24) & 0xff]

    # Extra flags
    header = header + [extra_flags]

    # OS type
    header = header + [os_type]

    # Optional filename
    if filename != nil:
        var i = 0
        loop:
            if i >= filename.length():
                break
            val ch = filename[i]
            header = header + [char_to_byte(ch)]
            i = i + 1
        # Null terminator
        header = header + [0]

    return header

# Parse GZIP header
# Returns: (flags, timestamp, extra_flags, os, header_size) or nil
fn gzip_header_parse(data):
    if data == nil:
        return nil

    if data.length() < 10:
        return nil

    # Check magic bytes
    if data[0] != GZIP_MAGIC1:
        return nil
    if data[1] != GZIP_MAGIC2:
        return nil

    # Check compression method
    if data[2] != CM_DEFLATE:
        return nil

    val flags = data[3]
    val timestamp = data[4] | (data[5] << 8) | (data[6] << 16) | (data[7] << 24)
    val extra_flags = data[8]
    val os = data[9]

    var offset = 10

    # Skip extra field
    if (flags & FLAG_EXTRA) != 0:
        if offset + 2 > data.length():
            return nil
        val xlen = data[offset] | (data[offset + 1] << 8)
        offset = offset + 2 + xlen

    # Skip filename
    if (flags & FLAG_NAME) != 0:
        loop:
            if offset >= data.length():
                return nil
            if data[offset] == 0:
                offset = offset + 1
                break
            offset = offset + 1

    # Skip comment
    if (flags & FLAG_COMMENT) != 0:
        loop:
            if offset >= data.length():
                return nil
            if data[offset] == 0:
                offset = offset + 1
                break
            offset = offset + 1

    # Skip header CRC
    if (flags & FLAG_HCRC) != 0:
        offset = offset + 2

    return [flags, timestamp, extra_flags, os, offset]

# Get header size from parsed header info
fn gzip_header_size(header_info):
    if header_info == nil:
        return 0
    return header_info[4]

# =============================================================================
# GZIP FOOTER
# =============================================================================

# Create GZIP footer (CRC32 + uncompressed size)
fn gzip_footer_create(crc32, size):
    var footer = []

    # CRC32 (4 bytes, little-endian)
    footer = footer + [crc32 & 0xff]
    footer = footer + [(crc32 >> 8) & 0xff]
    footer = footer + [(crc32 >> 16) & 0xff]
    footer = footer + [(crc32 >> 24) & 0xff]

    # Uncompressed size modulo 2^32 (4 bytes, little-endian)
    val size_mod = size & 0xffffffff
    footer = footer + [size_mod & 0xff]
    footer = footer + [(size_mod >> 8) & 0xff]
    footer = footer + [(size_mod >> 16) & 0xff]
    footer = footer + [(size_mod >> 24) & 0xff]

    return footer

# Parse GZIP footer
# Returns: (crc32, size) or nil
fn gzip_footer_parse(data, offset):
    if data == nil:
        return nil

    if offset + 8 > data.length():
        return nil

    val crc = data[offset] | (data[offset + 1] << 8) | (data[offset + 2] << 16) | (data[offset + 3] << 24)
    val size = data[offset + 4] | (data[offset + 5] << 8) | (data[offset + 6] << 16) | (data[offset + 7] << 24)

    return [crc, size]

# Validate GZIP footer
fn gzip_footer_validate(footer_info, data, expected_size):
    if footer_info == nil:
        return false

    val crc = footer_info[0]
    val size = footer_info[1]

    # Verify CRC32
    val calculated_crc = crc32_calculate(data)
    if calculated_crc != crc:
        return false

    # Verify size (modulo 2^32)
    val size_mod = expected_size & 0xffffffff
    if size != size_mod:
        return false

    return true

# =============================================================================
# UTILITY FUNCTIONS
# =============================================================================

# Convert character to byte value
fn char_to_byte(ch):
    if ch == "a":
        return 97
    if ch == "b":
        return 98
    if ch == "z":
        return 122
    if ch == "A":
        return 65
    if ch == "Z":
        return 90
    if ch == "0":
        return 48
    if ch == "9":
        return 57
    if ch == ".":
        return 46
    if ch == "/":
        return 47
    return 0

export *
