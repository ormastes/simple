# compression/zlib.spl - LZ77 compression implementation
#
# LZ77 (Lempel-Ziv 1977) compression
# LZ77 Token: (offset, length, next_char)
# Example: (5, 3, 'x') means "copy 3 chars from 5 positions back, then add 'x'"

# Find longest match in sliding window
fn lz77_find_match(text, pos, window_size, lookahead_size):
    if text == nil:
        return [0, 0]

    val len = text.length()
    if pos >= len:
        return [0, 0]

    var best_offset = 0
    var best_length = 0

    val search_start = 0
    var search_start_adj = pos - window_size
    if search_start_adj < 0:
        search_start_adj = 0

    val search_end = pos

    # Search for matches in the window
    var i = search_start_adj

    loop:
        if i >= search_end:
            break

        # Try to match starting at position i
        var match_len = 0
        var j = 0

        loop:
            if j >= lookahead_size:
                break
            if pos + j >= len:
                break
            if i + j >= pos:
                break

            if text[i + j] == text[pos + j]:
                match_len = match_len + 1
            else:
                break

            j = j + 1

        if match_len > best_length:
            best_length = match_len
            best_offset = pos - i

        i = i + 1

    return [best_offset, best_length]

# Compress text using LZ77
fn lz77_compress(text):
    if text == nil:
        return nil

    val len = text.length()
    if len == 0:
        return []

    val window_size = 4096
    val lookahead_size = 18

    var tokens = []
    var pos = 0

    loop:
        if pos >= len:
            break

        val match = lz77_find_match(text, pos, window_size, lookahead_size)
        val offset = match[0]
        val length = match[1]

        if length >= 3:
            # Encode as reference
            var next_char = ""
            if pos + length < len:
                next_char = text[pos + length]

            val token = [offset, length, next_char]
            tokens = tokens + [token]
            pos = pos + length + 1
        else:
            # Encode as literal
            val token = [0, 0, text[pos]]
            tokens = tokens + [token]
            pos = pos + 1

    return tokens

# Decompress LZ77 tokens
fn lz77_decompress(tokens):
    if tokens == nil:
        return nil

    var result = ""
    var i = 0

    loop:
        if i >= tokens.length():
            break

        val token = tokens[i]
        val offset = token[0]
        val length = token[1]
        val next_char = token[2]

        if length > 0:
            # Copy from window
            val copy_start = result.length() - offset
            var j = 0

            loop:
                if j >= length:
                    break

                val idx = copy_start + j
                if idx >= 0:
                    if idx < result.length():
                        result = result + result[idx]

                j = j + 1

        if next_char != "":
            result = result + next_char

        i = i + 1

    return result

# Compress with custom window size
fn lz77_compress_windowed(text, window_size, lookahead_size):
    if text == nil:
        return nil

    val len = text.length()
    if len == 0:
        return []

    var tokens = []
    var pos = 0

    loop:
        if pos >= len:
            break

        val match = lz77_find_match(text, pos, window_size, lookahead_size)
        val offset = match[0]
        val length = match[1]

        if length >= 3:
            var next_char = ""
            if pos + length < len:
                next_char = text[pos + length]

            val token = [offset, length, next_char]
            tokens = tokens + [token]
            pos = pos + length + 1
        else:
            val token = [0, 0, text[pos]]
            tokens = tokens + [token]
            pos = pos + 1

    return tokens
