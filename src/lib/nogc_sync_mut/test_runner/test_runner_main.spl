# Test Runner Main Orchestration
#
# Main test runner entry point and orchestration logic.
# Supports DB writes, parallel execution, feature DB, and doc generation.
#
# Split into:
#   - test_runner_config.spl: CLI args, env propagation, mode conversion, run management
#   - test_runner_modes.spl: Execution modes (doctest, combined, parallel, container),
#                            result parsing, categorization, warnings, database updates

use app.io.env_ops.{env_set, env_get}
use app.io.time_ops.{time_now_unix_micros}
use app.io.dir_ops.{dir_create_all}
use app.io.file_ops.{file_write, file_read, file_exists}
use app.io.cli_ops.{cli_get_args}

use test_runner_types.*
use test_runner_args.parse_test_args
use test_config.{TestConfig, TestConfig__load}
use test_runner_files.{discover_test_files, print_discovery_summary, strip_ansi, file_has_di_test_tag}
use test_runner_execute.{run_test_file_interpreter, run_test_file_smf, run_test_file_native, run_test_file_safe_mode, run_test_file_composite}
use test_runner_output.{print_result, print_summary}
use test_runner_config.{report_free_mem, mode_to_str, propagate_env_vars, get_cli_args, get_flag_value, handle_run_management, has_run_management_flag}
# MEMORY DEBUG: groups 3-9 commented out to isolate memory usage
# GROUP 3: Container & coverage
# use sequential_container.{SequentialContainerConfig, sequential_container_run_all_tests}
# use test_runner_container.container_detect_runtime
# use test_runner_coverage.{setup_coverage, collect_coverage, print_coverage_summary, generate_coverage_reports, check_coverage_threshold, get_coverage_threshold, print_coverage_delta}
# GROUP 4: Database & feature tracking
# use test_db_compat.{TestDatabase, load_test_db_compat, micros_to_rfc3339}  # Using compatibility layer
# use test_db_types.*
# use std.database.feature.{FeatureDatabase, load_feature_database, create_feature_database, FeatureStatus}
# GROUP 5: Doc generation & sdoctest
# use doc_generator.generate_all_docs
# use rust_test_runner.{run_rust_tests, RustTestResult}
# use sdoctest.config.load_sdoctest_config
# use sdoctest.runner.{run_sdoctest_mode, print_sdoctest_summary}
# use sdoctest.types.{SdoctestRunResult, SdoctestFileResult, BlockStatus}
# use doctest_runner.{run_spl_doctests_same_file, discover_spl_doctest_files}
# use sdoctest.result_db.write_sdoctest_db
# use sdoctest.doc_gen.generate_sdoctest_report
# GROUP 6: Self-protection imports
# use app.test_runner_new.checkpoint.{checkpoint_load, checkpoint_exists, checkpoint_skip_completed, checkpoint_save, checkpoint_delete}
# use app.test_runner_new.system_monitor.{system_exceeds_threshold}
# use app.test_runner_new.shutdown.{shutdown_graceful}
# GROUP 7: Parallel execution imports
# use app.test_runner_new.test_runner_async.{run_tests_parallel_with_monitoring, get_cpu_count}
# GROUP 7: Lifecycle imports
# use app.test_runner_new.runner_lifecycle.{cleanup_all_children, lifecycle_enable_heartbeat, lifecycle_send_heartbeat}
# GROUP 8: Signal handler imports (with fallback)
# use app.io.signal_handlers.{install_signal_handlers, create_signal_cleanup_handler, signal_handlers_available}
# use app.test_runner_new.process_tracker.{tracker_kill_all_children, tracker_stop_all_containers}
# GROUP 9: Closure warnings
# use compiler.core.closure_analysis.{closure_warnings_get, closure_warnings_has}
# GROUP 9: Call graph warnings
# use compiler.core.call_graph.{call_graph_warnings_get, call_graph_warnings_has}

# =========================================================================
# Runner
# =========================================================================

fn run_tests(options: TestOptions) -> TestRunResult:
    # Load test configuration
    val config = TestConfig__load()

    # Apply CI mode overrides
    var updated_options = options
    if config.ci_mode or options.ci_mode:
        updated_options.run_all = true
        updated_options.fail_fast = false
        updated_options.verbose = true
        if config.ci_mode:
            print "CI mode detected (via CI environment variable)"
        else:
            print "CI mode enabled (via --ci flag)"
        print ""

    # MEMORY DEBUG: checkpoint disabled (GROUP 6)
    # Load checkpoint if resuming
    # var ckpt_loaded = false
    var ckpt_passed = 0
    var ckpt_failed = 0
    var ckpt_skipped = 0

    val all_files = discover_test_files(options.path, updated_options)

    # MEMORY DEBUG: checkpoint filtering disabled (GROUP 6)
    var files = all_files
    # if options.resume and checkpoint_exists():
    #     val ckpt = checkpoint_load()
    #     ckpt_loaded = true
    #     ckpt_passed = ckpt.total_passed
    #     ckpt_failed = ckpt.total_failed
    #     ckpt_skipped = ckpt.total_skipped
    #     files = checkpoint_skip_completed(all_files, ckpt)
    #     print "Resuming from checkpoint (reason: {ckpt.shutdown_reason})"
    #     print "Previous progress: {ckpt_passed} passed, {ckpt_failed} failed, {ckpt_skipped} skipped"
    #     print ""

    if options.list:
        print_discovery_summary(files, options)
        return TestRunResult(files: [], total_passed: 0, total_failed: 0, total_skipped: 0, total_pending: 0, total_timed_out: 0, total_duration_ms: 0)

    if files.len() == 0:
        print "No test files found in {options.path}"
        return TestRunResult(files: [], total_passed: 0, total_failed: 0, total_skipped: 0, total_pending: 0, total_timed_out: 0, total_duration_ms: 0)

    # MEMORY DEBUG: coverage disabled (GROUP 3)
    # if options.coverage:
    #     setup_coverage()

    # Propagate env vars
    propagate_env_vars(options)

    # MEMORY DEBUG: container mode disabled (GROUP 3)
    # val exec_mode = options.execution_mode
    # val is_container_seq1 = exec_mode == "container-seq"
    # val is_container_seq2 = exec_mode == "container_seq"
    # val is_container_seq3 = exec_mode == "container-sequential"
    # val is_container_seq = is_container_seq1 or is_container_seq2 or is_container_seq3
    # if is_container_seq or options.container_sequential:
    #     return run_tests_sequential_containers(files, options)

    # Parallel execution disabled - always run one by one
    # if options.parallel:
    #     return run_tests_parallel_mode(files, options, ckpt_passed, ckpt_failed, ckpt_skipped)

    report_free_mem("BEFORE_TEST_LOOP")
    val mode_name = mode_to_str(options.mode)
    print "Running {files.len()} test file(s) [mode: {mode_name}]..."
    if options.has_seed:
        print "Seed: {options.seed}"
    if options.self_protect:
        print "Self-protection enabled (CPU: {options.cpu_threshold}%, Memory: {options.mem_threshold}%)"
    if options.max_mem_gb > 0 and not options.no_limits:
        print "  Max memory per test: {options.max_mem_gb}GB"
    print ""

    var results: [TestFileResult] = []
    var total_passed = ckpt_passed
    var total_failed = ckpt_failed
    var total_skipped = ckpt_skipped
    var total_pending = 0
    var total_timed_out = 0
    var total_duration_ms = 0
    var completed_files: [text] = []
    var tests_run = 0

    for file_path in files:
        # MEMORY DEBUG: self-protect disabled (GROUP 6)
        # if options.self_protect:
        #     val (violated, reason) = system_exceeds_threshold(options.cpu_threshold, options.mem_threshold)
        #     if violated:
        #         # Graceful shutdown - never returns
        #         shutdown_graceful(reason, completed_files, total_passed, total_failed, total_skipped)

        # MEMORY DEBUG: checkpoint disabled (GROUP 6)
        # if options.self_protect and tests_run % 10 == 0 and tests_run > 0:
        #     checkpoint_save(completed_files, total_passed, total_failed, total_skipped, "periodic")

        # Run test
        val rss_before = current_rss_kb_main()
        val result = run_single_test(file_path, options)
        print_result(result, options.format)
        val rss_after = current_rss_kb_main()
        val rss_delta = rss_after - rss_before
        if rss_delta != 0:
            print "  [MEMDIFF] {file_path}: {rss_delta} kB (rss={rss_after})"

        total_passed = total_passed + result.passed
        total_failed = total_failed + result.failed
        total_skipped = total_skipped + result.skipped
        total_pending = total_pending + result.pending
        if result.timed_out:
            total_timed_out = total_timed_out + 1
        total_duration_ms = total_duration_ms + result.duration_ms
        results.push(result)
        completed_files.push(file_path)
        tests_run = tests_run + 1

        if tests_run % 50 == 0:
            print "  [MEMCHK] after {tests_run} tests: rss={rss_after} kB"

        if options.fail_fast and (result.failed > 0 or result.timed_out):
            print ""
            print "Stopping early (--fail-fast)"
            break

    # MEMORY DEBUG: checkpoint cleanup disabled (GROUP 6)
    # if options.resume and checkpoint_exists():
    #     checkpoint_delete()

    TestRunResult(
        files: results,
        total_passed: total_passed,
        total_failed: total_failed,
        total_skipped: total_skipped,
        total_pending: total_pending,
        total_timed_out: total_timed_out,
        total_duration_ms: total_duration_ms
    )

fn run_single_test(file_path: text, options: TestOptions) -> TestFileResult:
    # Set runtime mode env var so skip_it/skip_on_interpreter can detect mode
    val mode_str = mode_to_str(options.mode)
    env_set("SIMPLE_RUNTIME_MODE", mode_str)

    # DI system test lock: block DI modifications in system tests unless @di_test
    val is_system = file_path.contains("/system/") or file_path.contains("/feature/")
    if is_system:
        env_set("SIMPLE_SYSTEM_TEST", "1")
    else:
        env_set("SIMPLE_SYSTEM_TEST", "0")
    if is_system and file_has_di_test_tag(file_path):
        env_set("SIMPLE_DI_TEST", "1")
    else:
        env_set("SIMPLE_DI_TEST", "0")

    # Override timeout for advanced testing modes
    var effective_options = options
    if options.fuzz_mode:
        val fuzz_timeout = options.fuzz_time_secs + 30
        if fuzz_timeout > effective_options.timeout:
            effective_options.timeout = fuzz_timeout
    if options.chaos_mode:
        var chaos_timeout = options.chaos_trials * 2
        if chaos_timeout < 300:
            chaos_timeout = 300
        if chaos_timeout > effective_options.timeout:
            effective_options.timeout = chaos_timeout

    # G1: Use safe mode with resource limits when enabled
    if effective_options.safe_mode:
        return run_test_file_safe_mode(file_path, effective_options)
    match effective_options.mode:
        case TestExecutionMode.Interpreter:
            run_test_file_interpreter(file_path, effective_options)
        case TestExecutionMode.Smf:
            run_test_file_smf(file_path, effective_options)
        case TestExecutionMode.Native:
            run_test_file_native(file_path, effective_options)
        case TestExecutionMode.Composite(spec):
            run_test_file_composite(file_path, effective_options, spec)

# =========================================================================
# Main Entry Point
# =========================================================================

fn main() -> i64:
    report_free_mem("START")

    val all_args = get_cli_args()
    var args: [str] = []
    var skip_first = all_args.len() > 0 and all_args[0] == "test"
    var i = 0
    if skip_first:
        i = 1
    while i < all_args.len():
        args.push(all_args[i])
        i = i + 1

    val options = parse_test_args(args)
    report_free_mem("AFTER_PARSE_ARGS")

    propagate_env_vars(options)

    val files = discover_test_files(options.path, options)
    report_free_mem("AFTER_DISCOVER_{files.len()}_files")

    print "Running {files.len()} test files with memory tracking..."
    var idx = 0
    var total_passed = 0
    var total_failed = 0
    for f in files:
        val result = run_single_test(f, options)
        print_result(result, options.format)
        total_passed = total_passed + result.passed
        total_failed = total_failed + result.failed
        idx = idx + 1
        # MEMORY TRACKING: report every 10 tests (was 50) to catch leaks faster
        if idx % 10 == 0:
            report_free_mem("AFTER_TEST_{idx}")
        if options.fail_fast and result.failed > 0:
            print "Stopping early (--fail-fast)"
            break

    report_free_mem("DONE_{idx}_tests")
    print ""
    print "Total: {total_passed} passed, {total_failed} failed"
    return 0

    # MEMORY DEBUG: original main() body commented out below
    # # Set recursion guard so child processes use Rust runner
    # env_set("SIMPLE_TEST_RUNNER_RUST", "1")
    #
    # # Handle run management commands
    # if has_run_management_flag(args):
    #     return handle_run_management(args)
    #
    # # Load test configuration to determine what to run
    # val config = TestConfig__load()
    #
    # # Determine which test types to run
    # var run_spec = config.run_spec_tests
    # var run_sdoc = config.run_sdoctests
    #
    # # MEMORY DEBUG: spl-doctest disabled (GROUP 5)
    # # if options.spl_doctest:
    # #     ...
    #
    # # MEMORY DEBUG: sdoctest disabled (GROUP 5)
    # # if options.sdoctest:
    # #     run_spec = false
    # #     run_sdoc = true
    #
    # # MEMORY DEBUG: sdoctest-only mode disabled (GROUP 5)
    # # if run_sdoc and not run_spec:
    # #     ...
    #
    # # MEMORY DEBUG: combined mode disabled (GROUP 4, 5)
    # # if run_spec and run_sdoc:
    # #     return run_combined_mode(options, config)
    #
    # # Handle spec-only mode (default)
    # if run_spec:
    #     print "Simple Test Runner v0.4.0"
    #     print ""
    #
    #     val run_start = time_now_unix_micros()
    #     val result = run_tests(options)
    #     val run_end = time_now_unix_micros()
    #
    #     print_summary(result, options.format)
    #
    #     # MEMORY DEBUG: closure warnings disabled (GROUP 9)
    #     # if options.closure_warnings:
    #     #     display_closure_warnings()
    #     #     display_call_graph_warnings()
    #
    #     # MEMORY DEBUG: coverage disabled (GROUP 3)
    #     var coverage_passed = true
    #     # if options.coverage:
    #     #     ...
    #
    #     # MEMORY DEBUG: test DB disabled (GROUP 4)
    #     # if not options.list and not options.no_db and result.files.len() > 0:
    #     #     update_test_database(result, run_start, run_end)
    #
    #     if result.is_ok() and coverage_passed:
    #         return 0
    #     return 1
    #
    # # If neither spec nor sdoc is enabled, print error
    # print "Error: No test types enabled. Check config/simple.test.sdn configuration."
    # print "  run_spec_tests: {config.run_spec_tests}"
    # print "  run_sdoctests: {config.run_sdoctests}"
    # return 1

# =========================================================================
# Exports
# =========================================================================

# Functions defined in this file
export run_tests, run_single_test
export main
