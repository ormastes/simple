# Apache Kafka Types Module
# Type definitions and constants

# ============================================================================
# Constants and Type Definitions
# ============================================================================

# Kafka API Keys
fn API_KEY_PRODUCE() -> i64: 0
fn API_KEY_FETCH() -> i64: 1
fn API_KEY_LIST_OFFSETS() -> i64: 2
fn API_KEY_METADATA() -> i64: 3
fn API_KEY_LEADER_AND_ISR() -> i64: 4
fn API_KEY_STOP_REPLICA() -> i64: 5
fn API_KEY_UPDATE_METADATA() -> i64: 6
fn API_KEY_CONTROLLED_SHUTDOWN() -> i64: 7
fn API_KEY_OFFSET_COMMIT() -> i64: 8
fn API_KEY_OFFSET_FETCH() -> i64: 9
fn API_KEY_FIND_COORDINATOR() -> i64: 10
fn API_KEY_JOIN_GROUP() -> i64: 11
fn API_KEY_HEARTBEAT() -> i64: 12
fn API_KEY_LEAVE_GROUP() -> i64: 13
fn API_KEY_SYNC_GROUP() -> i64: 14
fn API_KEY_DESCRIBE_GROUPS() -> i64: 15
fn API_KEY_LIST_GROUPS() -> i64: 16
fn API_KEY_SASL_HANDSHAKE() -> i64: 17
fn API_KEY_API_VERSIONS() -> i64: 18
fn API_KEY_CREATE_TOPICS() -> i64: 19
fn API_KEY_DELETE_TOPICS() -> i64: 20
fn API_KEY_DELETE_RECORDS() -> i64: 21
fn API_KEY_INIT_PRODUCER_ID() -> i64: 22
fn API_KEY_OFFSET_FOR_LEADER_EPOCH() -> i64: 23
fn API_KEY_ADD_PARTITIONS_TO_TXN() -> i64: 24
fn API_KEY_ADD_OFFSETS_TO_TXN() -> i64: 25
fn API_KEY_END_TXN() -> i64: 26
fn API_KEY_WRITE_TXN_MARKERS() -> i64: 27
fn API_KEY_TXN_OFFSET_COMMIT() -> i64: 28
fn API_KEY_DESCRIBE_ACLS() -> i64: 29
fn API_KEY_CREATE_ACLS() -> i64: 30
fn API_KEY_DELETE_ACLS() -> i64: 31
fn API_KEY_DESCRIBE_CONFIGS() -> i64: 32
fn API_KEY_ALTER_CONFIGS() -> i64: 33

# Kafka Error Codes
fn ERROR_NONE() -> i64: 0
fn ERROR_OFFSET_OUT_OF_RANGE() -> i64: 1
fn ERROR_CORRUPT_MESSAGE() -> i64: 2
fn ERROR_UNKNOWN_TOPIC_OR_PARTITION() -> i64: 3
fn ERROR_INVALID_FETCH_SIZE() -> i64: 4
fn ERROR_LEADER_NOT_AVAILABLE() -> i64: 5
fn ERROR_NOT_LEADER_FOR_PARTITION() -> i64: 6
fn ERROR_REQUEST_TIMED_OUT() -> i64: 7
fn ERROR_BROKER_NOT_AVAILABLE() -> i64: 8
fn ERROR_REPLICA_NOT_AVAILABLE() -> i64: 9
fn ERROR_MESSAGE_TOO_LARGE() -> i64: 10
fn ERROR_STALE_CONTROLLER_EPOCH() -> i64: 11
fn ERROR_OFFSET_METADATA_TOO_LARGE() -> i64: 12
fn ERROR_NETWORK_EXCEPTION() -> i64: 13
fn ERROR_COORDINATOR_LOAD_IN_PROGRESS() -> i64: 14
fn ERROR_COORDINATOR_NOT_AVAILABLE() -> i64: 15
fn ERROR_NOT_COORDINATOR() -> i64: 16
fn ERROR_INVALID_TOPIC_EXCEPTION() -> i64: 17
fn ERROR_RECORD_LIST_TOO_LARGE() -> i64: 18
fn ERROR_NOT_ENOUGH_REPLICAS() -> i64: 19
fn ERROR_NOT_ENOUGH_REPLICAS_AFTER_APPEND() -> i64: 20
fn ERROR_INVALID_REQUIRED_ACKS() -> i64: 21
fn ERROR_ILLEGAL_GENERATION() -> i64: 22
fn ERROR_INCONSISTENT_GROUP_PROTOCOL() -> i64: 23
fn ERROR_INVALID_GROUP_ID() -> i64: 24
fn ERROR_UNKNOWN_MEMBER_ID() -> i64: 25
fn ERROR_INVALID_SESSION_TIMEOUT() -> i64: 26
fn ERROR_REBALANCE_IN_PROGRESS() -> i64: 27
fn ERROR_INVALID_COMMIT_OFFSET_SIZE() -> i64: 28
fn ERROR_TOPIC_AUTHORIZATION_FAILED() -> i64: 29
fn ERROR_GROUP_AUTHORIZATION_FAILED() -> i64: 30
fn ERROR_CLUSTER_AUTHORIZATION_FAILED() -> i64: 31
fn ERROR_INVALID_TIMESTAMP() -> i64: 32
fn ERROR_UNSUPPORTED_SASL_MECHANISM() -> i64: 33
fn ERROR_ILLEGAL_SASL_STATE() -> i64: 34
fn ERROR_UNSUPPORTED_VERSION() -> i64: 35
fn ERROR_TOPIC_ALREADY_EXISTS() -> i64: 36
fn ERROR_INVALID_PARTITIONS() -> i64: 37
fn ERROR_INVALID_REPLICATION_FACTOR() -> i64: 38
fn ERROR_INVALID_REPLICA_ASSIGNMENT() -> i64: 39
fn ERROR_INVALID_CONFIG() -> i64: 40
fn ERROR_NOT_CONTROLLER() -> i64: 41
fn ERROR_INVALID_REQUEST() -> i64: 42
fn ERROR_UNSUPPORTED_FOR_MESSAGE_FORMAT() -> i64: 43
fn ERROR_POLICY_VIOLATION() -> i64: 44
fn ERROR_OUT_OF_ORDER_SEQUENCE_NUMBER() -> i64: 45
fn ERROR_DUPLICATE_SEQUENCE_NUMBER() -> i64: 46
fn ERROR_INVALID_PRODUCER_EPOCH() -> i64: 47
fn ERROR_INVALID_TXN_STATE() -> i64: 48
fn ERROR_INVALID_PRODUCER_ID_MAPPING() -> i64: 49
fn ERROR_INVALID_TRANSACTION_TIMEOUT() -> i64: 50

# Compression Codec Types
fn COMPRESSION_NONE() -> i64: 0
fn COMPRESSION_GZIP() -> i64: 1
fn COMPRESSION_SNAPPY() -> i64: 2
fn COMPRESSION_LZ4() -> i64: 3
fn COMPRESSION_ZSTD() -> i64: 4

# ============================================================================
# Error Handling
# ============================================================================

fn error_code_to_string(code: i64) -> text:
    if code == 0:
        return "NONE"
    if code == 1:
        return "OFFSET_OUT_OF_RANGE"
    if code == 2:
        return "CORRUPT_MESSAGE"
    if code == 3:
        return "UNKNOWN_TOPIC_OR_PARTITION"
    if code == 4:
        return "INVALID_FETCH_SIZE"
    if code == 5:
        return "LEADER_NOT_AVAILABLE"
    if code == 6:
        return "NOT_LEADER_FOR_PARTITION"
    if code == 7:
        return "REQUEST_TIMED_OUT"
    if code == 8:
        return "BROKER_NOT_AVAILABLE"
    if code == 9:
        return "REPLICA_NOT_AVAILABLE"
    if code == 10:
        return "MESSAGE_TOO_LARGE"
    if code == 11:
        return "STALE_CONTROLLER_EPOCH"
    if code == 12:
        return "OFFSET_METADATA_TOO_LARGE"
    if code == 13:
        return "NETWORK_EXCEPTION"
    if code == 14:
        return "COORDINATOR_LOAD_IN_PROGRESS"
    if code == 15:
        return "COORDINATOR_NOT_AVAILABLE"
    if code == 16:
        return "NOT_COORDINATOR"
    if code == 17:
        return "INVALID_TOPIC_EXCEPTION"
    if code == 18:
        return "RECORD_LIST_TOO_LARGE"
    if code == 19:
        return "NOT_ENOUGH_REPLICAS"
    if code == 20:
        return "NOT_ENOUGH_REPLICAS_AFTER_APPEND"
    if code == 21:
        return "INVALID_REQUIRED_ACKS"
    if code == 22:
        return "ILLEGAL_GENERATION"
    if code == 23:
        return "INCONSISTENT_GROUP_PROTOCOL"
    if code == 24:
        return "INVALID_GROUP_ID"
    if code == 25:
        return "UNKNOWN_MEMBER_ID"
    if code == 26:
        return "INVALID_SESSION_TIMEOUT"
    if code == 27:
        return "REBALANCE_IN_PROGRESS"
    if code == 28:
        return "INVALID_COMMIT_OFFSET_SIZE"
    if code == 29:
        return "TOPIC_AUTHORIZATION_FAILED"
    if code == 30:
        return "GROUP_AUTHORIZATION_FAILED"
    if code == 31:
        return "CLUSTER_AUTHORIZATION_FAILED"
    if code == 32:
        return "INVALID_TIMESTAMP"
    if code == 33:
        return "UNSUPPORTED_SASL_MECHANISM"
    if code == 34:
        return "ILLEGAL_SASL_STATE"
    if code == 35:
        return "UNSUPPORTED_VERSION"
    if code == 36:
        return "TOPIC_ALREADY_EXISTS"
    if code == 37:
        return "INVALID_PARTITIONS"
    if code == 38:
        return "INVALID_REPLICATION_FACTOR"
    if code == 39:
        return "INVALID_REPLICA_ASSIGNMENT"
    if code == 40:
        return "INVALID_CONFIG"
    if code == 41:
        return "NOT_CONTROLLER"
    if code == 42:
        return "INVALID_REQUEST"
    if code == 43:
        return "UNSUPPORTED_FOR_MESSAGE_FORMAT"
    if code == 44:
        return "POLICY_VIOLATION"
    if code == 45:
        return "OUT_OF_ORDER_SEQUENCE_NUMBER"
    if code == 46:
        return "DUPLICATE_SEQUENCE_NUMBER"
    if code == 47:
        return "INVALID_PRODUCER_EPOCH"
    if code == 48:
        return "INVALID_TXN_STATE"
    if code == 49:
        return "INVALID_PRODUCER_ID_MAPPING"
    if code == 50:
        return "INVALID_TRANSACTION_TIMEOUT"
    "UNKNOWN_ERROR"

fn is_error(code: i64) -> bool:
    code != 0

fn is_retriable_error(code: i64) -> bool:
    var retriable = code == 5
    if code == 6:
        retriable = true
    if code == 7:
        retriable = true
    if code == 14:
        retriable = true
    if code == 15:
        retriable = true
    retriable

# ============================================================================
# Request/Response Structure
# ============================================================================

# Request header: (api_key, version, correlation_id, client_id)
fn create_request_header(api_key: i64, version: i64, correlation_id: i64, client_id: text) -> list:
    [api_key, version, correlation_id, client_id]

fn get_request_api_key(header: list) -> i64:
    header[0]

fn get_request_version(header: list) -> i64:
    header[1]

fn get_request_correlation_id(header: list) -> i64:
    header[2]

fn get_request_client_id(header: list) -> text:
    header[3]

# Response header: (correlation_id)
fn create_response_header(correlation_id: i64) -> list:
    [correlation_id]

fn get_response_correlation_id(header: list) -> i64:
    header[0]

# Full request: (header, body)
fn create_request(header: list, body: list) -> list:
    [header, body]

fn get_request_header(request: list) -> list:
    request[0]

fn get_request_body(request: list) -> list:
    request[1]

# Full response: (header, body)
fn create_response(header: list, body: list) -> list:
    [header, body]

fn get_response_header(response: list) -> list:
    response[0]

fn get_response_body(response: list) -> list:
    response[1]

# ============================================================================
# Topic and Partition Structures
# ============================================================================

# Topic: (name, partitions)
fn create_topic(name: text, partitions: list) -> list:
    [name, partitions]

fn get_topic_name(topic: list) -> text:
    topic[0]

fn get_topic_partitions(topic: list) -> list:
    topic[1]

# Partition: (partition_id, leader, replicas, isr)
fn create_partition(partition_id: i64, leader: i64, replicas: list, isr: list) -> list:
    [partition_id, leader, replicas, isr]

fn get_partition_id(partition: list) -> i64:
    partition[0]

fn get_partition_leader(partition: list) -> i64:
    partition[1]

fn get_partition_replicas(partition: list) -> list:
    partition[2]

fn get_partition_isr(partition: list) -> list:
    partition[3]

# Partition metadata: (partition_id, error_code, leader, replicas, isr)
fn create_partition_metadata(partition_id: i64, error_code: i64, leader: i64, replicas: list, isr: list) -> list:
    [partition_id, error_code, leader, replicas, isr]

fn get_partition_metadata_id(metadata: list) -> i64:
    metadata[0]

fn get_partition_metadata_error(metadata: list) -> i64:
    metadata[1]

fn get_partition_metadata_leader(metadata: list) -> i64:
    metadata[2]

fn get_partition_metadata_replicas(metadata: list) -> list:
    metadata[3]

fn get_partition_metadata_isr(metadata: list) -> list:
    metadata[4]

# Broker: (node_id, host, port)
fn create_broker(node_id: i64, host: text, port: i64) -> list:
    [node_id, host, port]

fn get_broker_node_id(broker: list) -> i64:
    broker[0]

fn get_broker_host(broker: list) -> text:
    broker[1]

fn get_broker_port(broker: list) -> i64:
    broker[2]

# ============================================================================
# Record Format
# ============================================================================

# Record: (key, value, headers, timestamp, offset)
fn create_record(key: text, value: text, headers: list, timestamp: i64, offset: i64) -> list:
    [key, value, headers, timestamp, offset]

fn get_record_key(record: list) -> text:
    record[0]

fn get_record_value(record: list) -> text:
    record[1]

fn get_record_headers(record: list) -> list:
    record[2]

fn get_record_timestamp(record: list) -> i64:
    record[3]

fn get_record_offset(record: list) -> i64:
    record[4]

# Record header: (key, value)
fn create_record_header(key: text, value: text) -> list:
    [key, value]

fn get_record_header_key(header: list) -> text:
    header[0]

fn get_record_header_value(header: list) -> text:
    header[1]

# Record batch: (base_offset, partition_leader_epoch, attributes, records, last_offset_delta, compression)
fn create_record_batch(base_offset: i64, partition_leader_epoch: i64, attributes: i64, records: list, last_offset_delta: i64, compression: i64) -> list:
    [base_offset, partition_leader_epoch, attributes, records, last_offset_delta, compression]

fn get_record_batch_base_offset(batch: list) -> i64:
    batch[0]

fn get_record_batch_partition_leader_epoch(batch: list) -> i64:
    batch[1]

fn get_record_batch_attributes(batch: list) -> i64:
    batch[2]

fn get_record_batch_records(batch: list) -> list:
    batch[3]

fn get_record_batch_last_offset_delta(batch: list) -> i64:
    batch[4]

fn get_record_batch_compression(batch: list) -> i64:
    batch[5]

# Metadata response body: (throttle_time_ms, brokers, cluster_id, controller_id, topic_metadata)
# brokers: [(node_id, host, port, rack)]
# topic_metadata: [(error_code, topic_name, is_internal, partition_metadata)]
fn create_metadata_response_body(throttle_time_ms: i64, brokers: list, cluster_id: text, controller_id: i64, topic_metadata: list) -> list:
    [throttle_time_ms, brokers, cluster_id, controller_id, topic_metadata]

fn get_metadata_response_throttle_time(body: list) -> i64:
    body[0]

fn get_metadata_response_brokers(body: list) -> list:
    body[1]

fn get_metadata_response_cluster_id(body: list) -> text:
    body[2]

fn get_metadata_response_controller_id(body: list) -> i64:
    body[3]

fn get_metadata_response_topic_metadata(body: list) -> list:
    body[4]

# Topic metadata: (error_code, topic_name, is_internal, partition_metadata)
fn create_topic_metadata(error_code: i64, topic_name: text, is_internal: bool, partition_metadata: list) -> list:
    [error_code, topic_name, is_internal, partition_metadata]

fn get_topic_metadata_error_code(metadata: list) -> i64:
    metadata[0]

fn get_topic_metadata_name(metadata: list) -> text:
    metadata[1]

fn get_topic_metadata_is_internal(metadata: list) -> bool:
    metadata[2]

fn get_topic_metadata_partition_metadata(metadata: list) -> list:
    metadata[3]
