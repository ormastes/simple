# @alloc
# Array Extension Methods
#
# Provides array utility functions as standalone functions.
# These complement the built-in array methods (.sort(), .reverse(), etc.).
# Core math functions delegated to math.spl for consistency.
# Advanced collection utilities are in array_advanced.spl

# Import from math.spl
use std.math.{sum_i64, median_i64}
use std.array_advanced.{*}
#
# Built-in methods available on arrays:
#   .push(item), .merge(other), .len(), .map(fn), .filter(fn)
#   .contains(item), .join(sep), .sort(), .reverse(), .first(), .last()
#   .index_of(item), .flatten(), .unique(), .zip(other), .enumerate()
#   .reduce(init, fn), .take(n), .drop(n)
#
# Functions in this module (standalone utilities):
# - array_position: Find index of first element matching predicate
# - array_find: Find first element matching predicate
# - array_find_or: Find first match or return default
# - array_enumerate: Enumerate with indices (standalone version)
# - array_zip: Zip two arrays (standalone version)
# - array_sort_by: Sort with custom comparator
# - array_chunk: Split array into chunks of size n
# - array_group_by: Group elements by key function
# - array_count: Count elements matching predicate
# - array_any: True if any element matches predicate
# - array_all: True if all elements match predicate
# - array_sum: Sum numeric array
# - array_max: Find maximum element
# - array_min: Find minimum element
# - array_flat_map: Map then flatten
# - array_take_while: Take elements while predicate is true
# - array_drop_while: Drop elements while predicate is true

# ============================================================================
# Search Functions
# ============================================================================

fn array_position(arr, predicate):
    """Find index of first element matching predicate. Returns -1 if not found."""
    var i = 0
    while i < arr.len():
        if predicate(arr[i]):
            return i
        i = i + 1
    -1

fn array_find(arr, predicate):
    """Find first element matching predicate. Returns nil if not found."""
    var i = 0
    while i < arr.len():
        if predicate(arr[i]):
            return arr[i]
        i = i + 1
    nil

fn array_find_or(arr, predicate, default_val):
    """Find first element matching predicate. Returns default_val if not found."""
    var i = 0
    while i < arr.len():
        if predicate(arr[i]):
            return arr[i]
        i = i + 1
    default_val

# ============================================================================
# Transformation Functions
# ============================================================================

fn array_enumerate(arr):
    """Return array of (index, element) tuples."""
    var result = []
    var i = 0
    while i < arr.len():
        result.push((i, arr[i]))
        i = i + 1
    result

fn array_zip(arr1, arr2):
    """Zip two arrays into array of tuples. Truncates to shorter length."""
    var result = []
    var min_len = arr1.len()
    if arr2.len() < min_len:
        min_len = arr2.len()
    var i = 0
    while i < min_len:
        result.push((arr1[i], arr2[i]))
        i = i + 1
    result

fn array_chunk(arr, size):
    """Split array into chunks of given size. Last chunk may be smaller."""
    var result = []
    var i = 0
    while i < arr.len():
        var end_idx = i + size
        if end_idx > arr.len():
            end_idx = arr.len()
        result.push(arr[i:end_idx])
        i = i + size
    result

fn array_flat_map(arr, mapper):
    """Map each element then flatten the results."""
    var result = []
    for item in arr:
        val mapped = mapper(item)
        for sub in mapped:
            result.push(sub)
    result

fn array_take_while(arr, predicate):
    """Take elements from the start while predicate is true."""
    var result = []
    var i = 0
    while i < arr.len():
        if not predicate(arr[i]):
            return result
        result.push(arr[i])
        i = i + 1
    result

fn array_drop_while(arr, predicate):
    """Drop elements from the start while predicate is true."""
    var i = 0
    while i < arr.len():
        if not predicate(arr[i]):
            return arr[i:]
        i = i + 1
    []

# ============================================================================
# Sorting
# ============================================================================

fn array_sort_by(arr, comparator):
    """Sort array with custom comparator function.
    comparator(a, b) should return negative if a < b, 0 if equal, positive if a > b.
    Uses quicksort (O(n log n) average case)."""
    if arr.len() <= 1:
        return arr

    # Use insertion sort for small arrays (faster due to low overhead)
    if arr.len() < 10:
        var sorted = []
        for item in arr:
            var inserted = false
            var i = 0
            while i < sorted.len() and not inserted:
                if comparator(item, sorted[i]) < 0:
                    val before = sorted[0:i]
                    val after = sorted[i:]
                    var combined = before
                    combined.push(item)
                    for a in after:
                        combined.push(a)
                    sorted = combined
                    inserted = true
                i = i + 1
            if not inserted:
                sorted.push(item)
        return sorted

    # Quicksort for larger arrays
    val pivot = arr[arr.len() / 2]
    var less = []
    var equal = []
    var greater = []

    for item in arr:
        val cmp = comparator(item, pivot)
        if cmp < 0:
            less.push(item)
        elif cmp == 0:
            equal.push(item)
        else:
            greater.push(item)

    # Recursively sort and combine
    val sorted_less = array_sort_by(less, comparator)
    val sorted_greater = array_sort_by(greater, comparator)

    var result = sorted_less
    for e in equal:
        result.push(e)
    for g in sorted_greater:
        result.push(g)
    result

# ============================================================================
# Grouping
# ============================================================================

fn array_group_by(arr, key_fn):
    """Group elements by key function. Returns dict of key -> [elements]."""
    var groups = {}
    for item in arr:
        val key = key_fn(item)
        if groups.contains_key(key):
            var group = groups[key]
            group.push(item)
            groups[key] = group
        else:
            groups[key] = [item]
    groups

# ============================================================================
# Aggregation Functions
# ============================================================================

fn array_count(arr, predicate):
    """Count elements matching predicate."""
    var count = 0
    for item in arr:
        if predicate(item):
            count = count + 1
    count

fn array_any(arr, predicate):
    """True if any element matches predicate."""
    for item in arr:
        if predicate(item):
            return true
    false

fn array_all(arr, predicate):
    """True if all elements match predicate."""
    for item in arr:
        if not predicate(item):
            return false
    true

fn array_sum(arr):
    """Sum all elements in array. Delegates to sum_i64 from math.spl."""
    sum_i64(arr)

fn array_max(arr):
    """Find maximum element. Returns nil for empty array."""
    if arr.len() == 0:
        return nil
    var best = arr[0]
    var i = 1
    while i < arr.len():
        if arr[i] > best:
            best = arr[i]
        i = i + 1
    best

fn array_min(arr):
    """Find minimum element. Returns nil for empty array."""
    if arr.len() == 0:
        return nil
    var best = arr[0]
    var i = 1
    while i < arr.len():
        if arr[i] < best:
            best = arr[i]
        i = i + 1
    best

# ============================================================================
# Creation Functions
# ============================================================================

fn array_range(start: i64, end_val: i64) -> [i64]:
    """Create array from start (inclusive) to end (exclusive)."""
    var result = []
    var i = start
    while i < end_val:
        result.push(i)
        i = i + 1
    result

fn array_repeat(item, count: i64):
    """Create array with item repeated count times."""
    var result = []
    var i = 0
    while i < count:
        result.push(item)
        i = i + 1
    result

# ============================================================================
# Additional Array Operations
# ============================================================================

fn array_append_all(arr1, arr2):
    """Append all elements from arr2 to arr1. Returns new array."""
    var result = []
    for item in arr1:
        result.push(item)
    for item in arr2:
        result.push(item)
    result

fn array_partition(arr, predicate):
    """Partition array into two arrays based on predicate.
    Returns (matching, non_matching) as tuple."""
    var matching = []
    var non_matching = []
    for item in arr:
        if predicate(item):
            matching.push(item)
        else:
            non_matching.push(item)
    (matching, non_matching)

fn array_concat(arrays):
    """Concatenate multiple arrays into one."""
    var result = []
    for arr in arrays:
        for item in arr:
            result.push(item)
    result

fn array_flatten(nested_arr):
    """Flatten one level of nesting in an array."""
    var result = []
    for arr in nested_arr:
        for item in arr:
            result.push(item)
    result

fn array_uniq(arr):
    """Remove duplicates from array (alias for .unique())."""
    var seen = {}
    var result = []
    for item in arr:
        val key = "{item}"
        if not seen.contains_key(key):
            seen[key] = true
            result.push(item)
    result

fn array_compact(arr):
    """Remove nil values from array."""
    var result = []
    for item in arr:
        if item != nil:
            result.push(item)
    result

fn array_reverse(arr):
    """Reverse an array."""
    var result = []
    var i = arr.len() - 1
    while i >= 0:
        result.push(arr[i])
        i = i - 1
    result

# ============================================================================
# List Utilities (from list_utils.spl)
# ============================================================================

fn array_take(arr, n):
    """Take first n elements from array.

    Example:
        array_take([1, 2, 3, 4, 5], 3)  # [1, 2, 3]
    """
    var result = []
    val count = if n < arr.len(): n else: arr.len()
    var i = 0
    while i < count:
        result.push(arr[i])
        i = i + 1
    result

fn array_drop(arr, n):
    """Drop first n elements from array.

    Example:
        array_drop([1, 2, 3, 4, 5], 2)  # [3, 4, 5]
    """
    if n >= arr.len():
        return []
    var result = []
    var i = n
    while i < arr.len():
        result.push(arr[i])
        i = i + 1
    result

fn array_windows(arr, size):
    """Create sliding windows of given size over the array.

    Example:
        array_windows([1, 2, 3, 4], 2)  # [[1, 2], [2, 3], [3, 4]]
    """
    if size > arr.len() or size <= 0:
        return []
    var result = []
    var i = 0
    while i <= arr.len() - size:
        var window = []
        var j = 0
        while j < size:
            window.push(arr[i + j])
            j = j + 1
        result.push(window)
        i = i + 1
    result

fn array_interleave(arr1, arr2):
    """Interleave two arrays, alternating elements.

    Example:
        array_interleave([1, 2, 3], [4, 5, 6])  # [1, 4, 2, 5, 3, 6]
    """
    var result = []
    val max_len = if arr1.len() > arr2.len(): arr1.len() else: arr2.len()
    var i = 0
    while i < max_len:
        if i < arr1.len():
            result.push(arr1[i])
        if i < arr2.len():
            result.push(arr2[i])
        i = i + 1
    result

fn array_intersperse(arr, separator):
    """Insert separator between all elements.

    Example:
        array_intersperse([1, 2, 3], 0)  # [1, 0, 2, 0, 3]
    """
    if arr.len() <= 1:
        return arr
    var result = [arr[0]]
    var i = 1
    while i < arr.len():
        result.push(separator)
        result.push(arr[i])
        i = i + 1
    result

fn array_rotate_left(arr, n):
    """Rotate array left by n positions.

    Example:
        array_rotate_left([1, 2, 3, 4, 5], 2)  # [3, 4, 5, 1, 2]
    """
    if arr.len() == 0:
        return []
    val shift = n % arr.len()
    val dropped = array_drop(arr, shift)
    val taken = array_take(arr, shift)
    array_append_all(dropped, taken)

fn array_rotate_right(arr, n):
    """Rotate array right by n positions.

    Example:
        array_rotate_right([1, 2, 3, 4, 5], 2)  # [4, 5, 1, 2, 3]
    """
    if arr.len() == 0:
        return []
    val shift = n % arr.len()
    array_rotate_left(arr, arr.len() - shift)

fn array_dedup(arr):
    """Remove consecutive duplicate elements.

    Example:
        array_dedup([1, 1, 2, 2, 3, 3])  # [1, 2, 3]
        array_dedup([1, 2, 1, 2])        # [1, 2, 1, 2] (non-consecutive kept)
    """
    if arr.len() == 0:
        return []
    var result = [arr[0]]
    var i = 1
    while i < arr.len():
        if arr[i] != arr[i - 1]:
            result.push(arr[i])
        i = i + 1
    result

fn array_dedup_all(arr):
    """Remove all duplicate elements, keeping first occurrence.

    Example:
        array_dedup_all([1, 2, 1, 3, 2])  # [1, 2, 3]
    """
    var result = []
    for x in arr:
        var found = false
        for y in result:
            if x == y:
                found = true
                break
        if not found:
            result.push(x)
    result

fn array_is_sorted(arr):
    """Check if array is sorted in ascending order.

    Example:
        array_is_sorted([1, 2, 3, 4])  # true
        array_is_sorted([1, 3, 2])     # false
    """
    if arr.len() <= 1:
        return true
    var i = 0
    while i < arr.len() - 1:
        if arr[i] > arr[i + 1]:
            return false
        i = i + 1
    true

fn array_equals(arr1, arr2):
    """Check if two arrays are equal element-wise.

    Example:
        array_equals([1, 2, 3], [1, 2, 3])  # true
        array_equals([1, 2], [1, 2, 3])     # false
    """
    if arr1.len() != arr2.len():
        return false
    var i = 0
    while i < arr1.len():
        if arr1[i] != arr2[i]:
            return false
        i = i + 1
    true

# ============================================================================
# Exports
# ============================================================================

export array_position, array_find, array_find_or
export array_enumerate, array_zip, array_chunk
export array_flat_map, array_take_while, array_drop_while, array_reverse
export array_sort_by, array_group_by
export array_count, array_any, array_all
export array_sum, array_max, array_min
export array_range, array_repeat
export array_append_all, array_partition, array_concat, array_flatten
export array_uniq, array_compact
export array_take, array_drop, array_windows
export array_interleave, array_intersperse
export array_rotate_left, array_rotate_right
export array_dedup, array_dedup_all
export array_is_sorted, array_equals
export array_group_consecutive, array_transpose, array_cartesian_product
export array_frequencies, array_mode, array_median
export array_intersect, array_difference, array_union, array_is_subset
export array_starts_with, array_ends_with
export array_index_of_subarray, array_contains_subarray
