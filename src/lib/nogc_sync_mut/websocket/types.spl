# WebSocket Types and Constants Module
# Defines all constants, opcodes, bit masks, and type-related functions

# ==============================================================================
# WebSocket Opcodes
# ==============================================================================

val OPCODE_CONTINUATION = 0x0
val OPCODE_TEXT = 0x1
val OPCODE_BINARY = 0x2
val OPCODE_CLOSE = 0x8
val OPCODE_PING = 0x9
val OPCODE_PONG = 0xA

# ==============================================================================
# Frame Bit Masks
# ==============================================================================

val FIN_BIT = 0x80
val RSV1_BIT = 0x40
val RSV2_BIT = 0x20
val RSV3_BIT = 0x10
val OPCODE_MASK = 0x0F
val MASK_BIT = 0x80
val PAYLOAD_LEN_MASK = 0x7F

# ==============================================================================
# Payload Length Thresholds
# ==============================================================================

val PAYLOAD_LEN_EXTENDED_16 = 126
val PAYLOAD_LEN_EXTENDED_64 = 127

# ==============================================================================
# WebSocket GUID for Handshake
# ==============================================================================

val WEBSOCKET_GUID = "258EAFA5-E914-47DA-95CA-C5AB0DC85B11"

# ==============================================================================
# Base64 Encoding Table
# ==============================================================================

val BASE64_CHARS = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"

# ==============================================================================
# Close Status Codes
# ==============================================================================

val CLOSE_NORMAL = 1000
val CLOSE_GOING_AWAY = 1001
val CLOSE_PROTOCOL_ERROR = 1002
val CLOSE_UNSUPPORTED_DATA = 1003
val CLOSE_NO_STATUS = 1005
val CLOSE_ABNORMAL = 1006
val CLOSE_INVALID_PAYLOAD = 1007
val CLOSE_POLICY_VIOLATION = 1008
val CLOSE_MESSAGE_TOO_BIG = 1009
val CLOSE_MANDATORY_EXTENSION = 1010
val CLOSE_INTERNAL_ERROR = 1011

# ==============================================================================
# Opcode Type Checks
# ==============================================================================

fn is_text_frame(opcode: i64) -> i64:
    if opcode == OPCODE_TEXT: 1 else: 0

fn is_binary_frame(opcode: i64) -> i64:
    if opcode == OPCODE_BINARY: 1 else: 0

fn is_continuation_frame(opcode: i64) -> i64:
    if opcode == OPCODE_CONTINUATION: 1 else: 0

fn is_control_frame(opcode: i64) -> i64:
    if opcode >= OPCODE_CLOSE: 1 else: 0

fn is_close_frame(opcode: i64) -> i64:
    if opcode == OPCODE_CLOSE: 1 else: 0

fn is_ping_frame(opcode: i64) -> i64:
    if opcode == OPCODE_PING: 1 else: 0

fn is_pong_frame(opcode: i64) -> i64:
    if opcode == OPCODE_PONG: 1 else: 0

fn is_data_frame(opcode: i64) -> i64:
    if opcode == OPCODE_TEXT: return 1
    if opcode == OPCODE_BINARY: return 1
    if opcode == OPCODE_CONTINUATION: return 1
    0

# ==============================================================================
# Opcode Name Functions
# ==============================================================================

fn opcode_name(opcode: i64) -> text:
    if opcode == OPCODE_CONTINUATION:
        "Continuation"
    else:
        if opcode == OPCODE_TEXT:
            "Text"
        else:
            if opcode == OPCODE_BINARY:
                "Binary"
            else:
                if opcode == OPCODE_CLOSE:
                    "Close"
                else:
                    if opcode == OPCODE_PING:
                        "Ping"
                    else:
                        if opcode == OPCODE_PONG:
                            "Pong"
                        else:
                            "Unknown"

fn frame_type_category(opcode: i64) -> text:
    if is_data_frame(opcode) == 1:
        "Data"
    else:
        if is_control_frame(opcode) == 1:
            "Control"
        else:
            "Unknown"

# ==============================================================================
# Validation Functions
# ==============================================================================

fn is_valid_opcode(opcode: i64) -> i64:
    if opcode == OPCODE_CONTINUATION: return 1
    if opcode == OPCODE_TEXT: return 1
    if opcode == OPCODE_BINARY: return 1
    if opcode == OPCODE_CLOSE: return 1
    if opcode == OPCODE_PING: return 1
    if opcode == OPCODE_PONG: return 1
    0

fn is_valid_control_frame(opcode: i64, payload_length: i64) -> i64:
    val is_control = is_control_frame(opcode)
    if is_control == 0:
        return 1

    if payload_length > 125:
        0
    else:
        1

fn is_valid_control_payload_length(payload_length: i64) -> i64:
    if payload_length <= 125: 1 else: 0

fn max_control_payload_size() -> i64:
    125

fn validate_frame_structure(fin: i64, opcode: i64, payload_length: i64) -> i64:
    val valid_opcode = is_valid_opcode(opcode)
    if valid_opcode == 0:
        return 0

    val valid_control = is_valid_control_frame(opcode, payload_length)
    if valid_control == 0:
        return 0

    1

# ==============================================================================
# Frame State Checks
# ==============================================================================

fn is_final_frame(fin: i64) -> i64:
    if fin == 1: 1 else: 0

fn is_fragmented_frame(fin: i64) -> i64:
    if fin == 0: 1 else: 0

# ==============================================================================
# RSV Bit Functions
# ==============================================================================

fn has_rsv_bits(byte1: i64) -> i64:
    val rsv = byte1 & (RSV1_BIT | RSV2_BIT | RSV3_BIT)
    if rsv != 0: 1 else: 0

fn get_rsv1(byte1: i64) -> i64:
    if (byte1 & RSV1_BIT) != 0: 1 else: 0

fn get_rsv2(byte1: i64) -> i64:
    if (byte1 & RSV2_BIT) != 0: 1 else: 0

fn get_rsv3(byte1: i64) -> i64:
    if (byte1 & RSV3_BIT) != 0: 1 else: 0

# ==============================================================================
# Length Checks
# ==============================================================================

fn requires_extended_length(payload_length: i64) -> i64:
    if payload_length >= PAYLOAD_LEN_EXTENDED_16: 1 else: 0

fn requires_64bit_length(payload_length: i64) -> i64:
    if payload_length >= 65536: 1 else: 0

fn get_header_size(payload_length: i64, is_masked: i64) -> i64:
    var size = 2

    if payload_length < PAYLOAD_LEN_EXTENDED_16:
        size = size + 0
    else:
        if payload_length < 65536:
            size = size + 2
        else:
            size = size + 8

    if is_masked == 1:
        size = size + 4

    size

fn calculate_frame_size(payload_length: i64, is_masked: i64) -> i64:
    var size = 2

    if payload_length < PAYLOAD_LEN_EXTENDED_16:
        size = size + 0
    else:
        if payload_length < 65536:
            size = size + 2
        else:
            size = size + 8

    if is_masked == 1:
        size = size + 4

    size + payload_length
