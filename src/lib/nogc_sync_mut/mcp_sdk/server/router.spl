# MCP SDK - Server Router
#
# Dispatches JSON-RPC methods to handlers and runs the main server loop.
# The user provides a tool handler callback; built-in methods (initialize,
# tools/list, resources/list, prompts/list, ping) are handled automatically.

use std.mcp_sdk.core.json.{LB, RB, Q, jp, js, jo1, extract_json_value, extract_nested_string}
use std.mcp_sdk.core.jsonrpc.{jsonrpc_result, jsonrpc_error}
use std.mcp_sdk.transport.stdio.{read_stdin_message, write_stdout_message}
use std.mcp_sdk.server.builder.{ServerConfig, server_build_init_result, server_build_tools_list, server_build_resources_list, server_build_prompts_list}

# --- Caches ---
var ROUTER_INIT_CACHE = ""
var ROUTER_TOOLS_CACHE = ""
var ROUTER_RESOURCES_CACHE = ""
var ROUTER_PROMPTS_CACHE = ""

# Dispatch a single MCP method, returning the response JSON.
# tool_handler is called for tools/call with (id, tool_name, body) -> response.
# resource_handler is called for resources/read with (id, uri) -> response.
# prompt_handler is called for prompts/get with (id, prompt_name, body) -> response.
# Returns "EXIT" to signal shutdown, "" for notifications (no response needed).
fn dispatch_method(cfg: ServerConfig, method: text, id: text, body: text, tool_handler_fn: text, resource_handler_fn: text, prompt_handler_fn: text) -> text:
    if method == "initialize":
        if ROUTER_INIT_CACHE == "":
            ROUTER_INIT_CACHE = server_build_init_result(cfg)
        return jsonrpc_result(id, ROUTER_INIT_CACHE)
    elif method == "initialized":
        return ""
    elif method == "tools/list":
        if ROUTER_TOOLS_CACHE == "":
            ROUTER_TOOLS_CACHE = server_build_tools_list(cfg)
        return jsonrpc_result(id, ROUTER_TOOLS_CACHE)
    elif method == "resources/list":
        if ROUTER_RESOURCES_CACHE == "":
            ROUTER_RESOURCES_CACHE = server_build_resources_list(cfg)
        return jsonrpc_result(id, ROUTER_RESOURCES_CACHE)
    elif method == "resources/templates/list":
        val result = jo1_local(jp("resourceTemplates", "[]"))
        return jsonrpc_result(id, result)
    elif method == "prompts/list":
        if ROUTER_PROMPTS_CACHE == "":
            ROUTER_PROMPTS_CACHE = server_build_prompts_list(cfg)
        return jsonrpc_result(id, ROUTER_PROMPTS_CACHE)
    elif method == "ping":
        return jsonrpc_result(id, LB() + RB())
    elif method == "shutdown":
        return jsonrpc_result(id, "null")
    elif method == "exit":
        return "EXIT"
    elif method.starts_with("notifications/"):
        return ""
    # For tools/call, resources/read, prompts/get: return marker for external dispatch
    elif method == "tools/call":
        return "DISPATCH_TOOL"
    elif method == "resources/read":
        return "DISPATCH_RESOURCE"
    elif method == "prompts/get":
        return "DISPATCH_PROMPT"
    jsonrpc_error(id, -32601, "Method not found: " + method)

fn jo1_local(pair: text) -> text:
    var r = LB()
    r = r + pair
    r = r + RB()
    r

# Run the server loop, reading from stdin and writing to stdout.
# tool_handler: fn(id: text, tool_name: text, body: text) -> text
# This is a simplified loop; the caller passes a dispatch function.
fn server_loop(cfg: ServerConfig, dispatch_fn_marker: text):
    for _iter in range(0, 999999):
        val line = read_stdin_message()
        if line == "":
            return
        val method = extract_json_value(line, "method")
        # Remove surrounding quotes if present
        var clean_method = method
        if clean_method.starts_with("\""):
            clean_method = clean_method.substring(1)
        if clean_method.ends_with("\""):
            clean_method = clean_method.substring(0, clean_method.len() - 1)

        val id = extract_json_value(line, "id")
        val response = dispatch_method(cfg, clean_method, id, line, "", "", "")
        if response == "EXIT":
            return
        if response != "":
            write_stdout_message(response)

# Clear all router caches (useful for dynamic tool registration)
fn router_clear_caches():
    ROUTER_INIT_CACHE = ""
    ROUTER_TOOLS_CACHE = ""
    ROUTER_RESOURCES_CACHE = ""
    ROUTER_PROMPTS_CACHE = ""

# Simplified method dispatcher with cleaner sentinel names.
# Returns full response for builtins, sentinel strings for custom dispatch:
#   "TOOLS_CALL"    — caller should handle tools/call
#   "RESOURCES_READ" — caller should handle resources/read
#   "PROMPTS_GET"   — caller should handle prompts/get
#   "COMPLETION"    — caller should handle completion/complete
#   "EXIT"          — caller should exit
#   ""              — notification, no response needed
fn handle_method(cfg: ServerConfig, method: text, id: text, body: text) -> text:
    if method == "initialize":
        if ROUTER_INIT_CACHE == "":
            ROUTER_INIT_CACHE = server_build_init_result(cfg)
        return jsonrpc_result(id, ROUTER_INIT_CACHE)
    elif method == "initialized":
        return ""
    elif method == "tools/list":
        if ROUTER_TOOLS_CACHE == "":
            ROUTER_TOOLS_CACHE = server_build_tools_list(cfg)
        return jsonrpc_result(id, ROUTER_TOOLS_CACHE)
    elif method == "resources/list":
        if ROUTER_RESOURCES_CACHE == "":
            ROUTER_RESOURCES_CACHE = server_build_resources_list(cfg)
        return jsonrpc_result(id, ROUTER_RESOURCES_CACHE)
    elif method == "resources/templates/list":
        val result = jo1_local(jp("resourceTemplates", "[]"))
        return jsonrpc_result(id, result)
    elif method == "prompts/list":
        if ROUTER_PROMPTS_CACHE == "":
            ROUTER_PROMPTS_CACHE = server_build_prompts_list(cfg)
        return jsonrpc_result(id, ROUTER_PROMPTS_CACHE)
    elif method == "ping":
        return jsonrpc_result(id, LB() + RB())
    elif method == "shutdown":
        return jsonrpc_result(id, "null")
    elif method == "exit":
        return "EXIT"
    elif method.starts_with("notifications/"):
        return ""
    elif method == "tools/call":
        return "TOOLS_CALL"
    elif method == "resources/read":
        return "RESOURCES_READ"
    elif method == "prompts/get":
        return "PROMPTS_GET"
    elif method == "completion/complete":
        return "COMPLETION"
    jsonrpc_error(id, -32601, "Method not found: " + method)

# Paginated tools/list response. Parses cursor from "offset:N" format.
# Returns full JSON-RPC response with tools array and optional nextCursor.
fn handle_tools_list_paginated(cfg: ServerConfig, id: text, cursor: text, page_size: i64) -> text:
    var offset = 0
    if cursor != "":
        if cursor.starts_with("offset:"):
            val cursor_value = cursor.substring(7)
            # Parse offset integer
            var parsed = 0
            var valid = true
            var ci = 0
            while ci < cursor_value.len():
                val ch = cursor_value[ci]
                if ch >= '0' and ch <= '9':
                    parsed = parsed * 10 + (ch as int - '0' as int)
                else:
                    valid = false
                ci = ci + 1
            if valid and cursor_value.len() > 0:
                offset = parsed

    val total = cfg.tool_schemas.len()
    var end_idx = offset + page_size
    if end_idx > total:
        end_idx = total
    val has_more = end_idx < total

    var parts = []
    var ti = offset
    while ti < end_idx:
        parts.append(cfg.tool_schemas[ti])
        ti = ti + 1
    val tools = "[" + parts.join(",") + "]"

    var result_parts = []
    result_parts.append(LB())
    result_parts.append(jp("tools", tools))
    if has_more:
        val next_cursor = "offset:" + end_idx.to_string()
        result_parts.append("," + jp("nextCursor", js(next_cursor)))
    result_parts.append(RB())
    val result = result_parts.join("")
    jsonrpc_result(id, result)

# --- Exports ---

export dispatch_method, server_loop, router_clear_caches
export handle_method, handle_tools_list_paginated
