# Debug/Stub Functions - Pure Simple I/O
# Extracted from mod.spl for modularity
#
# C++ backend available: libsimple_debug.so (SFFI external library pattern)
# Native: .build/rust/ffi_debug/ (C++ bridge, 499K .so)
# SFFI: src/lib/ffi/debug.spl (extern fn declarations for compiled mode)
# Spec: examples/debug.wrapper_spec
# Interpreter mode: delegates to debug_state module (in-memory state)
# Compiled mode: links against libsimple_debug.so via Tier 2 extern fn

use lib.nogc_sync_mut.io.debug_state

extern fn rt_process_run(cmd: text, args: [text]) -> (text, text, i64)

# --- Shell helper (local copy to avoid circular imports) ---

fn _debug_shell_bool(command: text) -> bool:
    val (out, err, code) = rt_process_run("/bin/sh", ["-c", command])
    code == 0

# ============================================================================
# Debug/Hook Functions â€” delegate to debug_state
# ============================================================================

fn rt_debug_set_active(active: bool):
    ds_set_active(active)

fn rt_hook_enable_debugging(enable: bool):
    ds_set_active(enable)

fn rt_debug_add_breakpoint_at(bp_file: text, bp_line: i64) -> i64:
    ds_add_breakpoint(bp_file, bp_line)

fn rt_debug_remove_breakpoint_at(bp_file: text, bp_line: i64):
    ds_remove_breakpoint(bp_file, bp_line)

fn rt_debug_continue_exec():
    ds_continue_exec()

fn rt_debug_pause_exec():
    ds_pause_exec()

fn rt_debug_set_step_mode_val(mode: i64):
    ds_set_step_mode(mode)

fn rt_debug_stack_trace_lines() -> [text]:
    ds_stack_trace()

fn rt_debug_local_vars() -> [text]:
    ds_local_vars()

fn rt_debug_get_current_file() -> text:
    ds_get_current_file()

fn rt_debug_get_current_line() -> i64:
    ds_get_current_line()

fn rt_debug_run_file_debug(path: text, debug_mode: bool) -> i64:
    0

# --- Rich Breakpoints (Phase 1.5) ---
fn rt_debug_add_breakpoint_rich(bp_file: text, bp_line: i64, condition: text, hit_condition: text, log_message: text, is_temporary: i64) -> i64:
    ds_add_breakpoint_rich(bp_file, bp_line, condition, hit_condition, log_message, is_temporary)

fn rt_debug_add_function_breakpoint(func_name: text, condition: text) -> i64:
    ds_add_function_breakpoint(func_name, condition)

fn rt_debug_set_breakpoint_enabled(bp_id: i64, enabled: i64):
    ds_set_breakpoint_enabled(bp_id, enabled)

fn rt_debug_get_breakpoint_info(bp_id: i64) -> text:
    ds_get_breakpoint_info(bp_id)

fn rt_debug_list_breakpoints() -> text:
    ds_list_breakpoints()

fn rt_debug_get_pending_condition() -> text:
    ""

fn rt_debug_report_condition_result(cond_result: i64):
    pass

# --- Frame Navigation ---
fn rt_debug_select_frame(index: i64) -> i64:
    ds_select_frame(index)

fn rt_debug_get_selected_frame() -> i64:
    ds_get_selected_frame()

fn rt_debug_frame_locals(frame_index: i64) -> text:
    ds_frame_locals(frame_index)

# --- Source File Reading ---
fn rt_debug_get_source_lines(src_file: text, start_line: i64, line_count: i64) -> text:
    ds_get_source_lines(src_file, start_line, line_count)

# --- Watch Expressions ---
fn rt_debug_add_watch(expr: text) -> i64:
    ds_add_watch(expr)

fn rt_debug_remove_watch(expr: text) -> i64:
    ds_remove_watch(expr)

fn rt_debug_list_watches() -> text:
    ds_list_watches()

# --- Variable Modification ---
fn rt_debug_set_variable(var_name: text, value_str: text, frame_index: i64) -> i64:
    ds_set_variable(var_name, value_str, frame_index)

# --- Expression Evaluation ---
fn rt_debug_eval_expression(expr: text, frame_index: i64) -> text:
    ds_eval_expression(expr, frame_index)

# --- Terminate ---
fn rt_debug_terminate():
    ds_terminate()

# ============================================================================
# Fault Detection Functions (stubs)
# ============================================================================

fn rt_fault_set_stack_overflow_detection(enabled: bool) -> bool:
    true

fn rt_fault_set_max_recursion_depth(depth: i64) -> bool:
    true

fn rt_fault_set_timeout(timeout_ms: i64) -> bool:
    true

fn rt_fault_set_execution_limit(limit: i64) -> bool:
    true

# ============================================================================
# Atomic Operations (stubs)
# ============================================================================

fn atomic_i64_new(value: i64) -> i64:
    value

fn atomic_bool_new(value: bool) -> bool:
    value

# ============================================================================
# Hardware/Feature Detection (stubs)
# ============================================================================

fn rt_vulkan_is_available() -> bool:
    false

fn upx_is_available() -> bool:
    _debug_shell_bool("command -v upx >/dev/null 2>&1")

# ============================================================================
# Exports
# ============================================================================

export rt_debug_set_active, rt_hook_enable_debugging
export rt_debug_add_breakpoint_at, rt_debug_remove_breakpoint_at
export rt_debug_continue_exec, rt_debug_pause_exec, rt_debug_set_step_mode_val
export rt_debug_stack_trace_lines, rt_debug_local_vars
export rt_debug_get_current_file, rt_debug_get_current_line, rt_debug_run_file_debug
export rt_debug_add_breakpoint_rich, rt_debug_add_function_breakpoint
export rt_debug_set_breakpoint_enabled, rt_debug_get_breakpoint_info
export rt_debug_list_breakpoints, rt_debug_get_pending_condition, rt_debug_report_condition_result
export rt_debug_select_frame, rt_debug_get_selected_frame, rt_debug_frame_locals
export rt_debug_get_source_lines
export rt_debug_add_watch, rt_debug_remove_watch, rt_debug_list_watches
export rt_debug_set_variable, rt_debug_eval_expression, rt_debug_terminate
export rt_fault_set_stack_overflow_detection, rt_fault_set_max_recursion_depth
export rt_fault_set_timeout, rt_fault_set_execution_limit
export atomic_i64_new, atomic_bool_new
export rt_vulkan_is_available, upx_is_available
