#!/usr/bin/env simple
# HTTP Client/Server SFFI Wrapper
#
# SFFI pattern for HTTP client and server functionality.
# Provides REST API client, HTTP server, and WebSocket support.
#
# Documentation:
# - reqwest (client): https://docs.rs/reqwest/
# - hyper (server): https://docs.rs/hyper/
# - tokio-tungstenite (websocket): https://docs.rs/tokio-tungstenite/

# ============================================================================
# Tier 1: Extern Declarations (Raw FFI)
# ============================================================================

# --- HTTP Client ---

extern fn rt_http_get(url: text) -> (i64, text, text)  # (status, body, error)
extern fn rt_http_post(url: text, body: text, content_type: text) -> (i64, text, text)
extern fn rt_http_put(url: text, body: text, content_type: text) -> (i64, text, text)
extern fn rt_http_delete(url: text) -> (i64, text, text)
extern fn rt_http_patch(url: text, body: text, content_type: text) -> (i64, text, text)
extern fn rt_http_head(url: text) -> (i64, text, text)

# Advanced request with headers
extern fn rt_http_request(
    method: text,
    url: text,
    headers: [text],  # ["Key: Value", "Key2: Value2"]
    body: text
) -> (i64, text, text)

# Download file
extern fn rt_http_download(url: text, output_path: text) -> (i64, i64, text)  # (status, bytes, error)

# Upload file
extern fn rt_http_upload(url: text, file_path: text, field_name: text) -> (i64, text, text)

# --- HTTP Client Configuration ---

extern fn rt_http_client_create() -> i64
extern fn rt_http_client_set_timeout(client: i64, timeout_ms: i64) -> bool
extern fn rt_http_client_set_header(client: i64, key: text, value: text) -> bool
extern fn rt_http_client_request(
    client: i64,
    method: text,
    url: text,
    headers: [text],
    body: text
) -> (i64, text, text)
extern fn rt_http_client_destroy(client: i64)

# --- HTTP Server ---

extern fn rt_http_server_create(port: i64) -> i64
extern fn rt_http_server_route(server: i64, method: text, path: text, handler: text) -> bool
extern fn rt_http_server_static(server: i64, path: text, dir: text) -> bool
extern fn rt_http_server_start(server: i64) -> bool
extern fn rt_http_server_stop(server: i64) -> bool
extern fn rt_http_server_destroy(server: i64)

# --- Request/Response Handling ---

extern fn rt_http_request_method(request: i64) -> text
extern fn rt_http_request_path(request: i64) -> text
extern fn rt_http_request_header(request: i64, key: text) -> text
extern fn rt_http_request_body(request: i64) -> text
extern fn rt_http_request_query(request: i64, key: text) -> text

extern fn rt_http_response_create(status: i64, body: text) -> i64
extern fn rt_http_response_set_header(response: i64, key: text, value: text) -> bool
extern fn rt_http_response_json(response: i64, json: text) -> bool

# --- WebSocket (Optional) ---

extern fn rt_ws_connect(url: text) -> i64
extern fn rt_ws_send(ws: i64, message: text) -> bool
extern fn rt_ws_receive(ws: i64) -> text
extern fn rt_ws_close(ws: i64) -> bool

# --- Utilities ---

extern fn rt_http_url_encode(text: text) -> text
extern fn rt_http_url_decode(text: text) -> text
extern fn rt_http_parse_json(json: text) -> i64  # Returns handle to JSON object
extern fn rt_http_stringify_json(obj: i64) -> text

# ============================================================================
# Tier 2: Simple-Friendly Wrapper Functions
# ============================================================================

# --- Core Types ---

enum HttpMethod:
    GET
    POST
    PUT
    DELETE
    PATCH
    HEAD
    OPTIONS

fn method_to_string(method: HttpMethod) -> text:
    if method == HttpMethod.GET: "GET"
    elif method == HttpMethod.POST: "POST"
    elif method == HttpMethod.PUT: "PUT"
    elif method == HttpMethod.DELETE: "DELETE"
    elif method == HttpMethod.PATCH: "PATCH"
    elif method == HttpMethod.HEAD: "HEAD"
    elif method == HttpMethod.OPTIONS: "OPTIONS"
    else: "GET"

enum HttpStatus:
    OK                  # 200
    Created             # 201
    Accepted            # 202
    NoContent           # 204
    BadRequest          # 400
    Unauthorized        # 401
    Forbidden           # 403
    NotFound            # 404
    MethodNotAllowed    # 405
    InternalError       # 500
    BadGateway          # 502
    ServiceUnavailable  # 503
    Unknown

fn status_to_code(status: HttpStatus) -> i64:
    if status == HttpStatus.OK: 200
    elif status == HttpStatus.Created: 201
    elif status == HttpStatus.Accepted: 202
    elif status == HttpStatus.NoContent: 204
    elif status == HttpStatus.BadRequest: 400
    elif status == HttpStatus.Unauthorized: 401
    elif status == HttpStatus.Forbidden: 403
    elif status == HttpStatus.NotFound: 404
    elif status == HttpStatus.MethodNotAllowed: 405
    elif status == HttpStatus.InternalError: 500
    elif status == HttpStatus.BadGateway: 502
    elif status == HttpStatus.ServiceUnavailable: 503
    else: 0

fn code_to_status(code: i64) -> HttpStatus:
    if code == 200: HttpStatus.OK
    elif code == 201: HttpStatus.Created
    elif code == 202: HttpStatus.Accepted
    elif code == 204: HttpStatus.NoContent
    elif code == 400: HttpStatus.BadRequest
    elif code == 401: HttpStatus.Unauthorized
    elif code == 403: HttpStatus.Forbidden
    elif code == 404: HttpStatus.NotFound
    elif code == 405: HttpStatus.MethodNotAllowed
    elif code == 500: HttpStatus.InternalError
    elif code == 502: HttpStatus.BadGateway
    elif code == 503: HttpStatus.ServiceUnavailable
    else: HttpStatus.Unknown

struct HttpResponse:
    status_code: i64
    status: HttpStatus
    body: text
    error: text
    is_ok: bool

fn make_http_response(result: (i64, text, text)) -> HttpResponse:
    """
    Helper to construct HttpResponse from rt_http_* result tuple.

    Common pattern: All rt_http_* functions return (status_code, body, error).
    This helper eliminates 6-line duplication across all HTTP wrapper functions.
    """
    val status_code = result.0
    val body = result.1
    val error = result.2

    HttpResponse(
        status_code: status_code,
        status: code_to_status(status_code),
        body: body,
        error: error,
        is_ok: status_code >= 200 and status_code < 300
    )

struct HttpClient:
    handle: i64
    is_valid: bool

struct HttpServer:
    handle: i64
    port: i64
    is_valid: bool

struct WebSocket:
    handle: i64
    is_valid: bool

# --- HTTP Client Functions ---

fn http_get(url: text) -> HttpResponse:
    """
    Perform HTTP GET request.

    Example:
        val response = http_get("https://api.example.com/users")
        if response.is_ok:
            print response.body
    """
    make_http_response(rt_http_get(url))

fn http_post(url: text, body: text) -> HttpResponse:
    """
    Perform HTTP POST request with JSON body.

    Example:
        val json = '{"name": "Alice", "age": 30}'
        val response = http_post("https://api.example.com/users", json)
    """
    make_http_response(rt_http_post(url, body, "application/json"))

fn http_post_form(url: text, body: text) -> HttpResponse:
    """
    Perform HTTP POST request with form data.

    Example:
        val form = "name=Alice&age=30"
        val response = http_post_form("https://api.example.com/submit", form)
    """
    make_http_response(rt_http_post(url, body, "application/x-www-form-urlencoded"))

fn http_put(url: text, body: text) -> HttpResponse:
    """Perform HTTP PUT request."""
    make_http_response(rt_http_put(url, body, "application/json"))

fn http_delete(url: text) -> HttpResponse:
    """Perform HTTP DELETE request."""
    make_http_response(rt_http_delete(url))

fn http_patch(url: text, body: text) -> HttpResponse:
    """Perform HTTP PATCH request."""
    make_http_response(rt_http_patch(url, body, "application/json"))

fn http_head(url: text) -> HttpResponse:
    """Perform HTTP HEAD request (headers only)."""
    make_http_response(rt_http_head(url))

fn http_request(method: HttpMethod, url: text, headers: [text], body: text) -> HttpResponse:
    """
    Perform HTTP request with custom method and headers.

    Example:
        val headers = ["Authorization: Bearer token123", "Accept: application/json"]
        val response = http_request(HttpMethod.POST, "https://api.example.com/data", headers, body)
    """
    val method_str = method_to_string(method)
    make_http_response(rt_http_request(method_str, url, headers, body))

fn http_download(url: text, output_path: text) -> HttpResponse:
    """
    Download file from URL to local path.

    Example:
        val response = http_download("https://example.com/file.zip", "/tmp/file.zip")
        if response.is_ok:
            print "Downloaded {response.status_code} bytes"
    """
    val result = rt_http_download(url, output_path)
    val status_code = result.0
    val bytes = result.1
    val error = result.2

    HttpResponse(
        status_code: status_code,
        status: code_to_status(status_code),
        body: "{bytes}",
        error: error,
        is_ok: status_code >= 200 and status_code < 300
    )

fn http_upload(url: text, file_path: text, field_name: text) -> HttpResponse:
    """
    Upload file via multipart/form-data.

    Example:
        val response = http_upload("https://api.example.com/upload", "/tmp/image.jpg", "file")
    """
    make_http_response(rt_http_upload(url, file_path, field_name))

# --- HTTP Client with Configuration ---

fn http_client_new() -> HttpClient:
    """
    Create a new HTTP client with custom configuration.
    Allows setting timeouts, default headers, etc.
    """
    val handle = rt_http_client_create()
    HttpClient(handle: handle, is_valid: handle != 0)

fn http_client_set_timeout(client: HttpClient, timeout_ms: i64) -> bool:
    """Set request timeout in milliseconds."""
    if not client.is_valid:
        false
    else:
        rt_http_client_set_timeout(client.handle, timeout_ms)

fn http_client_set_header(client: HttpClient, key: text, value: text) -> bool:
    """Set default header for all requests."""
    if not client.is_valid:
        false
    else:
        rt_http_client_set_header(client.handle, key, value)

fn http_client_request(client: HttpClient, method: HttpMethod, url: text, headers: [text], body: text) -> HttpResponse:
    """Perform request using configured client."""
    if not client.is_valid:
        HttpResponse(
            status_code: 0,
            status: HttpStatus.Unknown,
            body: "",
            error: "Invalid HTTP client",
            is_ok: false
        )
    else:
        val method_str = method_to_string(method)
        make_http_response(rt_http_client_request(client.handle, method_str, url, headers, body))

fn http_client_destroy(client: HttpClient):
    """Release HTTP client resources."""
    if client.is_valid:
        rt_http_client_destroy(client.handle)

# --- HTTP Server Functions ---

fn http_server_new(port: i64) -> HttpServer:
    """
    Create HTTP server on specified port.

    Example:
        val server = http_server_new(8080)
        http_server_route(server, "GET", "/", "handle_index")
        http_server_start(server)
    """
    val handle = rt_http_server_create(port)
    HttpServer(handle: handle, port: port, is_valid: handle != 0)

fn http_server_route(server: HttpServer, method: text, path: text, handler: text) -> bool:
    """
    Register route handler.
    Handler is a function name that will be called with (request, response).
    """
    if not server.is_valid:
        false
    else:
        rt_http_server_route(server.handle, method, path, handler)

fn http_server_static(server: HttpServer, path: text, dir: text) -> bool:
    """
    Serve static files from directory.

    Example:
        http_server_static(server, "/static", "./public")
    """
    if not server.is_valid:
        false
    else:
        rt_http_server_static(server.handle, path, dir)

fn http_server_start(server: HttpServer) -> bool:
    """Start HTTP server (blocking)."""
    if not server.is_valid:
        false
    else:
        rt_http_server_start(server.handle)

fn http_server_stop(server: HttpServer) -> bool:
    """Stop HTTP server."""
    if server.is_valid:
        rt_http_server_stop(server.handle)
    else:
        true

fn http_server_destroy(server: HttpServer):
    """Release server resources."""
    if server.is_valid:
        rt_http_server_destroy(server.handle)

# --- WebSocket Functions ---

fn ws_connect(url: text) -> WebSocket:
    """Connect to WebSocket server."""
    val handle = rt_ws_connect(url)
    WebSocket(handle: handle, is_valid: handle != 0)

fn ws_send(ws: WebSocket, message: text) -> bool:
    """Send message over WebSocket."""
    if not ws.is_valid:
        false
    else:
        rt_ws_send(ws.handle, message)

fn ws_receive(ws: WebSocket) -> text:
    """Receive message from WebSocket (blocking)."""
    if not ws.is_valid:
        ""
    else:
        rt_ws_receive(ws.handle)

fn ws_close(ws: WebSocket) -> bool:
    """Close WebSocket connection."""
    if ws.is_valid:
        rt_ws_close(ws.handle)
    else:
        true

# --- Utility Functions ---

fn url_encode(text: text) -> text:
    """URL-encode string (e.g., 'hello world' -> 'hello%20world')."""
    rt_http_url_encode(text)

fn url_decode(text: text) -> text:
    """URL-decode string."""
    rt_http_url_decode(text)

# --- Higher-Level Helpers ---

fn http_get_json(url: text) -> HttpResponse:
    """GET request expecting JSON response."""
    val headers = ["Accept: application/json"]
    http_request(HttpMethod.GET, url, headers, "")

fn http_post_json(url: text, json: text) -> HttpResponse:
    """POST request with JSON body."""
    val headers = ["Content-Type: application/json"]
    http_request(HttpMethod.POST, url, headers, json)

fn http_is_success(response: HttpResponse) -> bool:
    """Check if response is successful (2xx)."""
    response.status_code >= 200 and response.status_code < 300

fn http_is_redirect(response: HttpResponse) -> bool:
    """Check if response is redirect (3xx)."""
    response.status_code >= 300 and response.status_code < 400

fn http_is_client_error(response: HttpResponse) -> bool:
    """Check if response is client error (4xx)."""
    response.status_code >= 400 and response.status_code < 500

fn http_is_server_error(response: HttpResponse) -> bool:
    """Check if response is server error (5xx)."""
    response.status_code >= 500 and response.status_code < 600

# ============================================================================
# Exports
# ============================================================================

export HttpMethod, method_to_string
export HttpStatus, status_to_code, code_to_status
export HttpResponse, HttpClient, HttpServer, WebSocket

export http_get, http_post, http_post_form, http_put, http_delete, http_patch, http_head
export http_request, http_download, http_upload

export http_client_new, http_client_set_timeout, http_client_set_header
export http_client_request, http_client_destroy

export http_server_new, http_server_route, http_server_static
export http_server_start, http_server_stop, http_server_destroy

export ws_connect, ws_send, ws_receive, ws_close

export url_encode, url_decode

export http_get_json, http_post_json
export http_is_success, http_is_redirect, http_is_client_error, http_is_server_error
