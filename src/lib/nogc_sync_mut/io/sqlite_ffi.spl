# SQLite Database SFFI Wrapper
# SFFI pattern for embedded database operations
# Dependencies: rusqlite (Rust crate with bundled SQLite)

use std.nogc_sync_mut.io.sffi_common.{is_valid_handle, is_invalid_handle, is_empty_string}

# ============================================================================
# Tier 1: Extern Function Declarations (Raw FFI)
# ============================================================================

# --- Connection Management ---

extern fn rt_sqlite_open(path: text) -> i64
extern fn rt_sqlite_open_memory() -> i64
extern fn rt_sqlite_close(handle: i64) -> i64

# --- Basic Execution ---

extern fn rt_sqlite_execute(conn: i64, sql: text) -> i64
extern fn rt_sqlite_execute_batch(conn: i64, sql: text) -> i64

# --- Query Execution ---

extern fn rt_sqlite_query(conn: i64, sql: text) -> i64
extern fn rt_sqlite_query_next(stmt: i64) -> i64
extern fn rt_sqlite_query_done(stmt: i64)

# --- Column Access ---

extern fn rt_sqlite_column_count(stmt: i64) -> i64
extern fn rt_sqlite_column_name(stmt: i64, idx: i64) -> text
extern fn rt_sqlite_column_text(stmt: i64, idx: i64) -> text
extern fn rt_sqlite_column_int(stmt: i64, idx: i64) -> i64
extern fn rt_sqlite_column_float(stmt: i64, idx: i64) -> f64
extern fn rt_sqlite_column_type(stmt: i64, idx: i64) -> text

# --- Prepared Statements ---

extern fn rt_sqlite_prepare(conn: i64, sql: text) -> i64
extern fn rt_sqlite_bind_text(stmt: i64, idx: i64, value: text) -> i64
extern fn rt_sqlite_bind_int(stmt: i64, idx: i64, value: i64) -> i64
extern fn rt_sqlite_bind_float(stmt: i64, idx: i64, value: f64) -> i64
extern fn rt_sqlite_bind_null(stmt: i64, idx: i64) -> i64
extern fn rt_sqlite_reset(stmt: i64) -> i64
extern fn rt_sqlite_finalize(stmt: i64)

# --- Transactions ---

extern fn rt_sqlite_begin(conn: i64) -> i64
extern fn rt_sqlite_commit(conn: i64) -> i64
extern fn rt_sqlite_rollback(conn: i64) -> i64

# --- Metadata ---

extern fn rt_sqlite_last_insert_rowid(conn: i64) -> i64
extern fn rt_sqlite_changes(conn: i64) -> i64
extern fn rt_sqlite_error_message(conn: i64) -> text

# ============================================================================
# Tier 2: Simple-Friendly Wrapper Functions
# ============================================================================

# --- Core Types ---

struct SqliteConnection:
    handle: i64
    path: text
    is_valid: bool

struct SqliteStatement:
    handle: i64
    sql: text
    is_valid: bool

struct SqliteRow:
    values: [text]
    column_names: [text]

enum SqliteType:
    Integer
    Float
    Text
    Blob
    Null

# --- Connection Management ---

fn sqlite_open(path: text) -> SqliteConnection:
    """Open SQLite database file

    Args:
        path: Path to database file (will be created if doesn't exist)

    Returns: Database connection (check is_valid field)

    Example:
        db = sqlite_open("data.db")
        if db.is_valid:
            # Use database
            sqlite_close(db)
    """
    val handle = rt_sqlite_open(path)
    SqliteConnection(handle: handle, path: path, is_valid: is_valid_handle(handle))

fn sqlite_open_memory() -> SqliteConnection:
    """Open in-memory SQLite database

    Returns: Database connection

    Example:
        db = sqlite_open_memory()
        # Fast temporary database
    """
    val handle = rt_sqlite_open_memory()
    SqliteConnection(handle: handle, path: ":memory:", is_valid: is_valid_handle(handle))

fn sqlite_close(conn: SqliteConnection) -> bool:
    """Close database connection

    Returns: true on success
    """
    if is_invalid_handle(conn.handle):
        return false

    val result = rt_sqlite_close(conn.handle)
    result == 1

# --- Basic Execution ---

fn sqlite_execute(conn: SqliteConnection, sql: text) -> bool:
    """Execute SQL statement without returning results

    Args:
        conn: Database connection
        sql: SQL statement (CREATE, INSERT, UPDATE, DELETE)

    Returns: true on success, false on error

    Example:
        db = sqlite_open("data.db")
        sqlite_execute(db, "CREATE TABLE users (id INTEGER PRIMARY KEY, name TEXT)")
        sqlite_execute(db, "INSERT INTO users (name) VALUES ('Alice')")
    """
    if is_invalid_handle(conn.handle):
        return false

    val result = rt_sqlite_execute(conn.handle, sql)
    result == 1

fn sqlite_execute_batch(conn: SqliteConnection, sql: text) -> bool:
    """Execute multiple SQL statements

    Args:
        conn: Database connection
        sql: Multiple SQL statements separated by semicolons

    Returns: true on success

    Example:
        db = sqlite_open("data.db")
        sqlite_execute_batch(db, \"\"\"
            CREATE TABLE users (id INTEGER PRIMARY KEY, name TEXT);
            CREATE TABLE posts (id INTEGER PRIMARY KEY, user_id INTEGER);
        \"\"\")
    """
    if is_invalid_handle(conn.handle):
        return false

    val result = rt_sqlite_execute_batch(conn.handle, sql)
    result == 1

# --- Query Execution (Simple API) ---

fn sqlite_query_all(conn: SqliteConnection, sql: text) -> [SqliteRow]:
    """Execute query and return all rows

    Args:
        conn: Database connection
        sql: SELECT query

    Returns: Array of rows

    Example:
        db = sqlite_open("data.db")
        rows = sqlite_query_all(db, "SELECT * FROM users")
        for row in rows:
            print row.values[0]
    """
    if is_invalid_handle(conn.handle):
        return []

    val stmt_handle = rt_sqlite_query(conn.handle, sql)
    if is_invalid_handle(stmt_handle):
        return []

    var rows = []

    # Get column names
    val col_count = rt_sqlite_column_count(stmt_handle)
    var column_names = []
    for i in 0..col_count:
        val name = rt_sqlite_column_name(stmt_handle, i)
        column_names = column_names + [name]

    # Fetch all rows
    var has_row = rt_sqlite_query_next(stmt_handle)
    while has_row == 1:
        var values = []
        for i in 0..col_count:
            val value = rt_sqlite_column_text(stmt_handle, i)
            values = values + [value]

        val row = SqliteRow(values: values, column_names: column_names)
        rows = rows + [row]

        has_row = rt_sqlite_query_next(stmt_handle)

    rt_sqlite_query_done(stmt_handle)
    rows

fn sqlite_query_one(conn: SqliteConnection, sql: text) -> SqliteRow:
    """Execute query and return first row

    Returns: First row, or empty row if no results

    Example:
        db = sqlite_open("data.db")
        row = sqlite_query_one(db, "SELECT * FROM users WHERE id = 1")
        if row.values.len() > 0:
            print row.values[0]
    """
    val rows = sqlite_query_all(conn, sql)
    if rows.len() > 0:
        rows[0]
    else:
        SqliteRow(values: [], column_names: [])

fn sqlite_query_value(conn: SqliteConnection, sql: text) -> text:
    """Execute query and return single value

    Returns: First column of first row, empty string if no results

    Example:
        db = sqlite_open("data.db")
        count = sqlite_query_value(db, "SELECT COUNT(*) FROM users")
    """
    val row = sqlite_query_one(conn, sql)
    if row.values.len() > 0:
        row.values[0]
    else:
        ""

# --- Prepared Statements ---

fn sqlite_prepare(conn: SqliteConnection, sql: text) -> SqliteStatement:
    """Prepare SQL statement with placeholders

    Args:
        conn: Database connection
        sql: SQL with ? placeholders

    Returns: Prepared statement (check is_valid)

    Example:
        db = sqlite_open("data.db")
        stmt = sqlite_prepare(db, "INSERT INTO users (name, age) VALUES (?, ?)")
        if stmt.is_valid:
            sqlite_bind_text(stmt, 1, "Alice")
            sqlite_bind_int(stmt, 2, 30)
    """
    if is_invalid_handle(conn.handle):
        return SqliteStatement(handle: 0, sql: sql, is_valid: false)

    val handle = rt_sqlite_prepare(conn.handle, sql)
    SqliteStatement(handle: handle, sql: sql, is_valid: is_valid_handle(handle))

fn sqlite_bind_text(stmt: SqliteStatement, idx: i64, value: text) -> bool:
    """Bind text value to prepared statement

    Args:
        stmt: Prepared statement
        idx: Parameter index (1-based)
        value: Text value

    Returns: true on success
    """
    if is_invalid_handle(stmt.handle):
        return false

    val result = rt_sqlite_bind_text(stmt.handle, idx, value)
    result == 1

fn sqlite_bind_int(stmt: SqliteStatement, idx: i64, value: i64) -> bool:
    """Bind integer value to prepared statement"""
    if is_invalid_handle(stmt.handle):
        return false

    val result = rt_sqlite_bind_int(stmt.handle, idx, value)
    result == 1

fn sqlite_bind_float(stmt: SqliteStatement, idx: i64, value: f64) -> bool:
    """Bind float value to prepared statement"""
    if is_invalid_handle(stmt.handle):
        return false

    val result = rt_sqlite_bind_float(stmt.handle, idx, value)
    result == 1

fn sqlite_bind_null(stmt: SqliteStatement, idx: i64) -> bool:
    """Bind NULL value to prepared statement"""
    if is_invalid_handle(stmt.handle):
        return false

    val result = rt_sqlite_bind_null(stmt.handle, idx)
    result == 1

fn sqlite_reset(stmt: SqliteStatement) -> bool:
    """Reset prepared statement for reuse

    Returns: true on success
    """
    if is_invalid_handle(stmt.handle):
        return false

    val result = rt_sqlite_reset(stmt.handle)
    result == 1

fn sqlite_finalize(stmt: SqliteStatement):
    """Finalize prepared statement and free resources"""
    if stmt.is_valid:
        rt_sqlite_finalize(stmt.handle)

# --- Transactions ---

fn sqlite_begin(conn: SqliteConnection) -> bool:
    """Begin transaction

    Returns: true on success

    Example:
        db = sqlite_open("data.db")
        if sqlite_begin(db):
            sqlite_execute(db, "INSERT INTO users ...")
            sqlite_execute(db, "INSERT INTO posts ...")
            sqlite_commit(db)
    """
    if is_invalid_handle(conn.handle):
        return false

    val result = rt_sqlite_begin(conn.handle)
    result == 1

fn sqlite_commit(conn: SqliteConnection) -> bool:
    """Commit transaction

    Returns: true on success
    """
    if is_invalid_handle(conn.handle):
        return false

    val result = rt_sqlite_commit(conn.handle)
    result == 1

fn sqlite_rollback(conn: SqliteConnection) -> bool:
    """Rollback transaction

    Returns: true on success
    """
    if is_invalid_handle(conn.handle):
        return false

    val result = rt_sqlite_rollback(conn.handle)
    result == 1

# --- Metadata ---

fn sqlite_last_insert_rowid(conn: SqliteConnection) -> i64:
    """Get last inserted row ID

    Returns: Row ID from last INSERT, or 0

    Example:
        sqlite_execute(db, "INSERT INTO users (name) VALUES ('Alice')")
        user_id = sqlite_last_insert_rowid(db)
    """
    if is_invalid_handle(conn.handle):
        return 0

    rt_sqlite_last_insert_rowid(conn.handle)

fn sqlite_changes(conn: SqliteConnection) -> i64:
    """Get number of rows affected by last statement

    Returns: Number of rows changed

    Example:
        sqlite_execute(db, "UPDATE users SET active = 1")
        updated_count = sqlite_changes(db)
    """
    if is_invalid_handle(conn.handle):
        return 0

    rt_sqlite_changes(conn.handle)

fn sqlite_error_message(conn: SqliteConnection) -> text:
    """Get last error message

    Returns: Error message, or empty string if no error
    """
    if is_invalid_handle(conn.handle):
        return "Invalid connection"

    rt_sqlite_error_message(conn.handle)

# --- Helper Functions ---

fn sqlite_table_exists(conn: SqliteConnection, table_name: text) -> bool:
    """Check if table exists

    Returns: true if table exists
    """
    val sql = "SELECT COUNT(*) FROM sqlite_master WHERE type='table' AND name='{table_name}'"
    val count = sqlite_query_value(conn, sql)
    count == "1"

fn sqlite_count(conn: SqliteConnection, table: text) -> i64:
    """Count rows in table

    Returns: Number of rows
    """
    val sql = "SELECT COUNT(*) FROM {table}"
    val count_str = sqlite_query_value(conn, sql)
    if count_str == "":
        return 0

    # Convert string to int
    val count = int(count_str)
    count

fn sqlite_insert(conn: SqliteConnection, table: text, columns: [text], values: [text]) -> i64:
    """Insert row into table

    Args:
        conn: Database connection
        table: Table name
        columns: Column names
        values: Column values

    Returns: Inserted row ID, or 0 on error

    Example:
        user_id = sqlite_insert(db, "users", ["name", "email"], ["Alice", "alice@example.com"])
    """
    val cols = columns.join(", ")
    val placeholders = values.map(\v: "?").join(", ")
    val sql = "INSERT INTO {table} ({cols}) VALUES ({placeholders})"

    val stmt = sqlite_prepare(conn, sql)
    if not stmt.is_valid:
        return 0

    for i in 0..values.len():
        sqlite_bind_text(stmt, i + 1, values[i])

    val result = rt_sqlite_query_next(stmt.handle)
    sqlite_finalize(stmt)

    if result == 1:
        sqlite_last_insert_rowid(conn)
    else:
        0

# --- SqliteRow Helpers ---

fn sqlite_row_get(row: SqliteRow, column: text) -> text:
    """Get column value by name

    Returns: Column value, or empty string if not found

    Example:
        row = sqlite_query_one(db, "SELECT * FROM users WHERE id = 1")
        name = sqlite_row_get(row, "name")
    """
    for i in 0..row.column_names.len():
        if row.column_names[i] == column:
            return row.values[i]

    ""

fn sqlite_row_get_int(row: SqliteRow, column: text) -> i64:
    """Get integer column value by name

    Returns: Integer value, or 0 if not found
    """
    val value = sqlite_row_get(row, column)
    if value == "":
        return 0

    int(value)

# ============================================================================
# Export Functions
# ============================================================================

export SqliteConnection, SqliteStatement, SqliteRow, SqliteType
export sqlite_open, sqlite_open_memory, sqlite_close
export sqlite_execute, sqlite_execute_batch
export sqlite_query_all, sqlite_query_one, sqlite_query_value
export sqlite_prepare, sqlite_bind_text, sqlite_bind_int, sqlite_bind_float, sqlite_bind_null
export sqlite_reset, sqlite_finalize
export sqlite_begin, sqlite_commit, sqlite_rollback
export sqlite_last_insert_rowid, sqlite_changes, sqlite_error_message
export sqlite_table_exists, sqlite_count, sqlite_insert
export sqlite_row_get, sqlite_row_get_int
