# Process Limit Enforcer
#
# Helper functions for building ulimit commands and detecting violations.
# Used by process_run_with_limits() for resource enforcement.

use std.process_limits.{ResourceProfile}

# ============================================================================
# Ulimit Command Builder
# ============================================================================

fn build_ulimit_command(profile: ResourceProfile) -> text:
    """
    Build ulimit command string from ResourceProfile.

    Args:
        profile: ResourceProfile with resource limits

    Returns:
        Shell command string with ulimit directives

    Example:
        val cmd = build_ulimit_command(profile_fast())
        # Returns: "ulimit -v 131072; ulimit -t 1; ulimit -n 100; ulimit -u 10; "
    """
    var cmd = ""

    val memory_kb = profile.mem_mb * 1024
    if memory_kb > 0:
        cmd = cmd + "ulimit -v {memory_kb}; "

    val cpu_sec = profile.cpu_ms / 1000
    if cpu_sec > 0:
        cmd = cmd + "ulimit -t {cpu_sec}; "

    if profile.max_fds > 0:
        cmd = cmd + "ulimit -n {profile.max_fds}; "

    if profile.max_procs > 0:
        cmd = cmd + "ulimit -u {profile.max_procs}; "

    cmd

fn build_timeout_wrapper(timeout_ms: i64, command: text) -> text:
    """
    Wrap command with timeout enforcement.

    Args:
        timeout_ms: Wall-clock timeout in milliseconds
        command: Command to wrap

    Returns:
        Command wrapped with timeout
    """
    val timeout_sec = if timeout_ms > 0: timeout_ms / 1000 else: 120
    val buffer_sec = timeout_sec + 5
    "timeout --kill-after=5s {buffer_sec}s {command}"

# ============================================================================
# Violation Detection
# ============================================================================

fn detect_violation(exit_code: i64, stderr: text) -> (bool, text):
    """
    Detect resource limit violation from exit code and stderr.

    Args:
        exit_code: Process exit code
        stderr: Process stderr output

    Returns:
        Tuple of (limit_exceeded: bool, limit_type: text)

    Violation types:
        - "timeout": Wall-clock timeout (exit code 124)
        - "timeout_hard": Hard kill after timeout (exit code 137)
        - "memory": Memory limit or SIGSEGV (exit code 139)
        - "cpu": CPU time limit exceeded
        - "fds": File descriptor limit
        - "procs": Process limit
        - "": No violation
    """
    var limit_exceeded = false
    var limit_type = ""

    if exit_code == 124:
        limit_exceeded = true
        limit_type = "timeout"
        return (limit_exceeded, limit_type)

    if exit_code == 137:
        limit_exceeded = true
        limit_type = "timeout_hard"
        return (limit_exceeded, limit_type)

    if exit_code == 139:
        limit_exceeded = true
        limit_type = "memory"
        return (limit_exceeded, limit_type)

    val stderr_lower = stderr.lower()

    if stderr_lower.contains("cpu time limit exceeded"):
        limit_exceeded = true
        limit_type = "cpu"
    elif stderr_lower.contains("cannot allocate memory"):
        limit_exceeded = true
        limit_type = "memory"
    elif stderr_lower.contains("too many open files"):
        limit_exceeded = true
        limit_type = "fds"
    elif stderr_lower.contains("resource temporarily unavailable"):
        limit_exceeded = true
        limit_type = "procs"

    (limit_exceeded, limit_type)

fn detect_violation_from_profile(exit_code: i64, stderr: text, profile: ResourceProfile) -> (bool, text):
    """
    Detect violation with profile context for better diagnostics.

    Same as detect_violation() but includes profile name in diagnostics.
    """
    detect_violation(exit_code, stderr)

fn format_violation_message(limit_type: text, profile: ResourceProfile) -> text:
    """
    Format human-readable violation message.

    Args:
        limit_type: Type of violation
        profile: ResourceProfile that was exceeded

    Returns:
        Formatted error message
    """
    match limit_type:
        case "timeout":
            val timeout_sec = profile.timeout_ms / 1000
            "Process exceeded wall-clock timeout ({timeout_sec}s)"
        case "timeout_hard":
            val timeout_sec = profile.timeout_ms / 1000
            "Process killed after timeout ({timeout_sec}s)"
        case "cpu":
            val cpu_sec = profile.cpu_ms / 1000
            "Process exceeded CPU time limit ({cpu_sec}s)"
        case "memory":
            "Process exceeded memory limit ({profile.mem_mb} MB)"
        case "fds":
            "Process exceeded file descriptor limit ({profile.max_fds})"
        case "procs":
            "Process exceeded process count limit ({profile.max_procs})"
        case _:
            "Unknown resource violation: {limit_type}"

# ============================================================================
# Platform Helpers
# ============================================================================

fn supports_ulimit() -> bool:
    """
    Check if current platform supports ulimit.

    Returns:
        true on Unix/Linux/macOS, false on Windows
    """
    extern fn rt_env_get(key: text) -> text
    val os_env = rt_env_get("OS")
    if os_env == nil:
        return true
    not os_env.lower().contains("windows")

fn get_ulimit_flags() -> text:
    """
    Get platform-specific ulimit flags.

    Returns string describing available flags for diagnostics.
    """
    "-v (virtual memory), -t (CPU time), -n (file descriptors), -u (processes)"

# ============================================================================
# Limit Conversion Helpers
# ============================================================================

fn bytes_to_kb(bytes: i64) -> i64:
    """Convert bytes to kilobytes"""
    bytes / 1024

fn ms_to_seconds(ms: i64) -> i64:
    """Convert milliseconds to seconds"""
    ms / 1000

fn profile_to_ulimit_params(profile: ResourceProfile) -> (i64, i64, i64, i64):
    """
    Convert ResourceProfile to ulimit parameters.

    Returns:
        Tuple of (memory_kb, cpu_sec, max_fds, max_procs)
    """
    val memory_kb = profile.mem_mb * 1024
    val cpu_sec = profile.cpu_ms / 1000
    (memory_kb, cpu_sec, profile.max_fds, profile.max_procs)

# ============================================================================
# Exports
# ============================================================================

export build_ulimit_command, build_timeout_wrapper
export detect_violation, detect_violation_from_profile, format_violation_message
export supports_ulimit, get_ulimit_flags
export bytes_to_kb, ms_to_seconds, profile_to_ulimit_params
