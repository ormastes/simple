"""
# Standard I/O Pipes

Stdin, Stdout, Stderr wrappers implementing Read/Write traits.

## Components

| Type | Traits | Description |
|------|--------|-------------|
| Stdin | Read | Standard input stream |
| Stdout | Write | Standard output stream |
| Stderr | Write | Standard error stream |

## Writing to Stdout

```simple
val out = Stdout.new()
out.write_text("Hello, world!\\n")?
out.flush()?
```

## Writing to Stderr

```simple
val err = Stderr.new()
err.write_text("error: something failed\\n")?
```

## Reading from Stdin

```simple
# val input = Stdin.new()
# val line = input.read_line()?
# print "You typed: {line}"
```

## Using Pipes with BufferedWriter

```simple
# val writer = BufferedWriter.new(Stdout.new())
# writer.write_text("buffered output\\n")?
# writer.flush()?
```
"""

use std.common.io.traits.{Read, Write}
use std.common.io.error.{IoError, IoErrorKind}

# ============================================================================
# Stdin - Standard Input
# ============================================================================

class Stdin with Read:
    """Standard input stream.

    Example:
        val input = Stdin.new()
        val line = input.read_line()?
    """

    static fn new() -> Stdin:
        """Create stdin reader."""
        Stdin()

    # --- Read trait ---

    fn read(size: i64) -> Result<[u8], IoError>:
        """Read up to size bytes from stdin."""
        val data = rt_stdin_read(size)
        Ok(data)

    fn read_exact(size: i64) -> Result<[u8], IoError>:
        """Read exactly size bytes from stdin."""
        var buf: [u8] = []
        var remaining = size
        while remaining > 0:
            val chunk = rt_stdin_read(remaining)
            if chunk.len() == 0:
                return Err(IoError.new(IoErrorKind.UnexpectedEof, "stdin: unexpected eof"))
            buf = buf + chunk
            remaining = remaining - chunk.len()
        Ok(buf)

    fn read_all() -> Result<[u8], IoError>:
        """Read all bytes from stdin until EOF."""
        val data = rt_stdin_read_all()
        Ok(data)

    fn read_text() -> Result<text, IoError>:
        """Read all stdin as text."""
        val data = self.read_all()?
        Ok(rt_bytes_to_text(data))

    fn read_line() -> Result<text, IoError>:
        """Read a single line from stdin."""
        val line = rt_stdin_read_line()
        if line == nil:
            return Err(IoError.new(IoErrorKind.UnexpectedEof, "stdin: eof"))
        Ok(line)

# ============================================================================
# Stdout - Standard Output
# ============================================================================

class Stdout with Write:
    """Standard output stream.

    Example:
        val out = Stdout.new()
        out.write_text("Hello!\n")?
        out.flush()?
    """

    static fn new() -> Stdout:
        """Create stdout writer."""
        Stdout()

    # --- Write trait ---

    fn write(data: [u8]) -> Result<i64, IoError>:
        """Write bytes to stdout."""
        val written = rt_stdout_write(data)
        Ok(written)

    fn write_all(data: [u8]) -> Result<(), IoError>:
        """Write all bytes to stdout."""
        rt_stdout_write(data)
        Ok(())

    fn write_text(s: text) -> Result<(), IoError>:
        """Write text to stdout."""
        val bytes = rt_text_to_bytes(s)
        self.write_all(bytes)

    fn flush() -> Result<(), IoError>:
        """Flush stdout."""
        rt_stdout_flush()
        Ok(())

# ============================================================================
# Stderr - Standard Error
# ============================================================================

class Stderr with Write:
    """Standard error stream.

    Example:
        val err = Stderr.new()
        err.write_text("error: something failed\n")?
    """

    static fn new() -> Stderr:
        """Create stderr writer."""
        Stderr()

    # --- Write trait ---

    fn write(data: [u8]) -> Result<i64, IoError>:
        """Write bytes to stderr."""
        val written = rt_stderr_write(data)
        Ok(written)

    fn write_all(data: [u8]) -> Result<(), IoError>:
        """Write all bytes to stderr."""
        rt_stderr_write(data)
        Ok(())

    fn write_text(s: text) -> Result<(), IoError>:
        """Write text to stderr."""
        val bytes = rt_text_to_bytes(s)
        self.write_all(bytes)

    fn flush() -> Result<(), IoError>:
        """Flush stderr."""
        rt_stderr_flush()
        Ok(())

# ============================================================================
# FFI Functions
# ============================================================================

extern fn rt_stdin_read(size: i64) -> [u8]
extern fn rt_stdin_read_all() -> [u8]
extern fn rt_stdin_read_line() -> text?
extern fn rt_stdout_write(data: [u8]) -> i64
extern fn rt_stdout_flush()
extern fn rt_stderr_write(data: [u8]) -> i64
extern fn rt_stderr_flush()
extern fn rt_bytes_to_text(data: [u8]) -> text
extern fn rt_text_to_bytes(s: text) -> [u8]

# ============================================================================
# Exports
# ============================================================================

export Stdin
export Stdout
export Stderr
