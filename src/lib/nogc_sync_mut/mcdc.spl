# std.mcdc - Modified Condition/Decision Coverage Module
#
# Provides MC/DC coverage tracking and analysis for Simple language.
# MC/DC is required for safety-critical systems (DO-178C, ISO 26262).

extern fn rt_env_get(key: text) -> text
extern fn rt_file_exists(path: text) -> bool
extern fn rt_file_read(path: text) -> text

struct SourceLoc:
    file: text
    line: i64
    column: i64

struct Condition:
    id: i64
    expression: text
    location: SourceLoc

struct Decision:
    id: i64
    expression: text
    conditions: [Condition]
    operator: text
    location: SourceLoc

struct ConditionEval:
    condition_id: i64
    value: bool
    evaluated: bool
    masked_by: i64

struct DecisionEval:
    decision_id: i64
    test_id: i64
    conditions: [ConditionEval]
    outcome: bool
    timestamp: i64

struct IndependencePair:
    condition_id: i64
    eval_a_idx: i64
    eval_b_idx: i64
    condition_values_a: [bool]
    condition_values_b: [bool]
    outcome_a: bool
    outcome_b: bool

struct ConditionMCDCResult:
    condition_id: i64
    expression: text
    is_covered: bool
    independence_pair: IndependencePair?
    coverage_note: text

struct DecisionMCDCResult:
    decision_id: i64
    expression: text
    location: SourceLoc
    condition_count: i64
    conditions_covered: i64
    mcdc_percent: f64
    is_covered: bool
    condition_results: [ConditionMCDCResult]
    evaluation_count: i64

struct MCDCCoverageResult:
    passed: bool
    threshold: f64
    overall_percent: f64
    decisions_total: i64
    decisions_covered: i64
    conditions_total: i64
    conditions_covered: i64
    details: [DecisionMCDCResult]
    files_matched: i64

var _mcdc_tag_enabled: bool = false
var _decisions: [Decision] = []
var _evaluations: [DecisionEval] = []
var _current_test_id: i64 = 0
var _mcdc_data_loaded: bool = false
var _mcdc_last_error: text = ""

fn enable_mcdc_tag():
    _mcdc_tag_enabled = true

fn disable_mcdc_tag():
    _mcdc_tag_enabled = false

fn is_mcdc_tag_enabled() -> bool:
    _mcdc_tag_enabled

fn _validate_mcdc_access():
    if not _mcdc_tag_enabled:
        _mcdc_error("MCDCNotEnabledException: MC/DC API requires @mcdc tag.")

fn _mcdc_error(msg: text):
    _mcdc_last_error = msg

fn get_mcdc_error() -> text:
    _mcdc_last_error

fn clear_mcdc_error():
    _mcdc_last_error = ""

fn register_decision(expression: text, conditions: [text], operator: text, file: text, line: i64) -> i64:
    val decision_id = _decisions.len()
    var condition_list: [Condition] = []
    for i in 0..conditions.len():
        val cond = Condition { id: i, expression: conditions[i], location: SourceLoc { file: file, line: line, column: 0 } }
        condition_list.push(cond)
    val decision = Decision { id: decision_id, expression: expression, conditions: condition_list, operator: operator, location: SourceLoc { file: file, line: line, column: 0 } }
    _decisions.push(decision)
    decision_id

fn get_decision(id: i64) -> Decision?:
    if id >= 0 and id < _decisions.len():
        return _decisions[id]
    nil

fn start_test(test_name: text):
    _current_test_id = _current_test_id + 1

fn record_evaluation(decision_id: i64, condition_values: [bool], condition_evaluated: [bool], outcome: bool):
    if not _mcdc_tag_enabled:
        return
    var cond_evals: [ConditionEval] = []
    for i in 0..condition_values.len():
        val mask = if condition_evaluated[i]: -1 else: 0
        val cond_eval = ConditionEval { condition_id: i, value: condition_values[i], evaluated: condition_evaluated[i], masked_by: mask }
        cond_evals.push(cond_eval)
    val eval = DecisionEval { decision_id: decision_id, test_id: _current_test_id, conditions: cond_evals, outcome: outcome, timestamp: 0 }
    _evaluations.push(eval)

fn analyze_mcdc(decision_id: i64) -> DecisionMCDCResult:
    val decision = get_decision(decision_id)
    if decision == nil:
        return DecisionMCDCResult { decision_id: decision_id, expression: "unknown", location: SourceLoc { file: "", line: 0, column: 0 }, condition_count: 0, conditions_covered: 0, mcdc_percent: 0.0, is_covered: false, condition_results: [], evaluation_count: 0 }
    val evals = _evaluations.filter(\e: e.decision_id == decision_id)
    val condition_count = decision.conditions.len()
    var condition_results: [ConditionMCDCResult] = []
    var conditions_covered = 0
    for cond_idx in 0..condition_count:
        val cond = decision.conditions[cond_idx]
        val pair = _find_independence_pair(cond_idx, evals)
        val is_covered = pair != nil
        if is_covered:
            conditions_covered = conditions_covered + 1
        val note = if is_covered: "Independence proven" else: "Missing pair"
        val result = ConditionMCDCResult { condition_id: cond_idx, expression: cond.expression, is_covered: is_covered, independence_pair: pair, coverage_note: note }
        condition_results.push(result)
    val mcdc_pct = if condition_count > 0: (conditions_covered as f64 / condition_count as f64) * 100.0 else: 100.0
    DecisionMCDCResult { decision_id: decision_id, expression: decision.expression, location: decision.location, condition_count: condition_count, conditions_covered: conditions_covered, mcdc_percent: mcdc_pct, is_covered: conditions_covered == condition_count, condition_results: condition_results, evaluation_count: evals.len() }

fn _find_independence_pair(cond_idx: i64, evals: [DecisionEval]) -> IndependencePair?:
    for i in 0..evals.len():
        for j in (i+1)..evals.len():
            val eval_a = evals[i]
            val eval_b = evals[j]
            if eval_a.outcome == eval_b.outcome:
                continue
            var only_target_differs = true
            var target_differs = false
            for k in 0..eval_a.conditions.len():
                val cond_a = eval_a.conditions[k]
                val cond_b = eval_b.conditions[k]
                if k == cond_idx:
                    if cond_a.evaluated and cond_b.evaluated:
                        if cond_a.value != cond_b.value:
                            target_differs = true
                        else:
                            only_target_differs = false
                            break
                    else:
                        target_differs = true
                else:
                    if cond_a.evaluated and cond_b.evaluated:
                        if cond_a.value != cond_b.value:
                            only_target_differs = false
                            break
            if only_target_differs and target_differs:
                return IndependencePair { condition_id: cond_idx, eval_a_idx: i, eval_b_idx: j, condition_values_a: eval_a.conditions.map(\c: c.value), condition_values_b: eval_b.conditions.map(\c: c.value), outcome_a: eval_a.outcome, outcome_b: eval_b.outcome }
    nil

fn check_mcdc_coverage(pattern: text, minimum: f64 = 100.0) -> MCDCCoverageResult:
    _validate_mcdc_access()
    if _mcdc_last_error != "":
        return MCDCCoverageResult { passed: false, threshold: minimum, overall_percent: 0.0, decisions_total: 0, decisions_covered: 0, conditions_total: 0, conditions_covered: 0, details: [], files_matched: 0 }
    val matched = _decisions.filter(\d: _match_pattern(pattern, d.location.file))
    if matched.len() == 0:
        _mcdc_error("NoDecisionsMatchedException")
        return MCDCCoverageResult { passed: false, threshold: minimum, overall_percent: 0.0, decisions_total: 0, decisions_covered: 0, conditions_total: 0, conditions_covered: 0, details: [], files_matched: 0 }
    var details: [DecisionMCDCResult] = []
    var decisions_covered = 0
    var conditions_total = 0
    var conditions_covered = 0
    for decision in matched:
        val result = analyze_mcdc(decision.id)
        details.push(result)
        if result.is_covered:
            decisions_covered = decisions_covered + 1
        conditions_total = conditions_total + result.condition_count
        conditions_covered = conditions_covered + result.conditions_covered
    val overall = if conditions_total > 0: (conditions_covered as f64 / conditions_total as f64) * 100.0 else: 100.0
    val passed = overall >= minimum
    var files: [text] = []
    for d in matched:
        if not files.contains(d.location.file):
            files.push(d.location.file)
    MCDCCoverageResult { passed: passed, threshold: minimum, overall_percent: overall, decisions_total: matched.len(), decisions_covered: decisions_covered, conditions_total: conditions_total, conditions_covered: conditions_covered, details: details, files_matched: files.len() }

fn _match_pattern(pattern: text, path: text) -> bool:
    if pattern.contains("**"):
        return true
    if pattern.contains("*"):
        return path.ends_with(".spl")
    pattern == path

fn mcdc_describe(name: text, block: fn()):
    enable_mcdc_tag()
    print "{name}"
    block()
    disable_mcdc_tag()

fn mcdc_it(name: text, block: fn()):
    enable_mcdc_tag()
    start_test(name)
    clear_mcdc_error()
    block()
    if _mcdc_last_error != "":
        print "  it {name} ... FAILED: {_mcdc_last_error}"
    else:
        print "  it {name} ... ok"
    disable_mcdc_tag()

fn print_mcdc_report(pattern: text):
    enable_mcdc_tag()
    val result = check_mcdc_coverage(pattern, minimum: 0.0)
    print "MC/DC: {result.overall_percent:.1f}% ({result.conditions_covered}/{result.conditions_total})"
    disable_mcdc_tag()
    clear_mcdc_error()

fn get_mcdc_summary() -> text:
    enable_mcdc_tag()
    val result = check_mcdc_coverage("**/*.spl", minimum: 0.0)
    disable_mcdc_tag()
    clear_mcdc_error()
    "MC/DC: {result.overall_percent:.1f}%"

fn clear_mcdc_data():
    _decisions = []
    _evaluations = []
    _current_test_id = 0
    _mcdc_data_loaded = false

fn get_registered_decisions() -> [Decision]:
    _decisions

fn get_recorded_evaluations() -> [DecisionEval]:
    _evaluations

fn track_mcdc_and(decision_id: i64, a: bool, b: bool) -> bool:
    val result = a and b
    record_evaluation(decision_id, [a, b], [true, a], result)
    result

fn track_mcdc_or(decision_id: i64, a: bool, b: bool) -> bool:
    val result = a or b
    record_evaluation(decision_id, [a, b], [true, not a], result)
    result

fn track_mcdc_and3(decision_id: i64, a: bool, b: bool, c: bool) -> bool:
    val result = a and b and c
    record_evaluation(decision_id, [a, b, c], [true, a, a and b], result)
    result

fn track_mcdc_or3(decision_id: i64, a: bool, b: bool, c: bool) -> bool:
    val result = a or b or c
    record_evaluation(decision_id, [a, b, c], [true, not a, not a and not b], result)
    result
