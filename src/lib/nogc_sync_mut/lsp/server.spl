# LSP Server Implementation
# Handles LSP requests and maintains server state

use compiler.treesitter.{TreeSitter, OutlineModule}

# Server state
enum ServerState:
    Uninitialized
    Initialized
    ShuttingDown

# Document cache entry
struct DocumentInfo:
    uri: text
    version: i64
    content: text

# LSP Server
class LspServer:
    state: ServerState
    doc_uris: [text]
    doc_versions: [i64]
    doc_contents: [text]
    project_root: text

    static fn create() -> LspServer:
        LspServer(
            state: ServerState.Uninitialized,
            doc_uris: [],
            doc_versions: [],
            doc_contents: [],
            project_root: ""
        )

    fn find_doc(self, uri: text) -> i64:
        """Find document index by URI, returns -1 if not found"""
        var i = 0
        while i < self.doc_uris.len():
            if self.doc_uris[i] == uri:
                return i
            i = i + 1
        -1

    fn get_doc(self, uri: text) -> DocumentInfo:
        """Get document info by URI"""
        val idx = self.find_doc(uri)
        if idx >= 0:
            return DocumentInfo(uri: self.doc_uris[idx], version: self.doc_versions[idx], content: self.doc_contents[idx])
        DocumentInfo(uri: uri, version: 0, content: "")

    me open_doc(uri: text, version: i64, content: text):
        """Open/cache a document"""
        val idx = self.find_doc(uri)
        if idx >= 0:
            self.doc_versions[idx] = version
            self.doc_contents[idx] = content
        else:
            self.doc_uris.push(uri)
            self.doc_versions.push(version)
            self.doc_contents.push(content)

    me close_doc(uri: text):
        """Remove document from cache"""
        val idx = self.find_doc(uri)
        if idx >= 0:
            # Remove by replacing with last element
            val last = self.doc_uris.len() - 1
            if idx != last:
                self.doc_uris[idx] = self.doc_uris[last]
                self.doc_versions[idx] = self.doc_versions[last]
                self.doc_contents[idx] = self.doc_contents[last]
            self.doc_uris.pop()
            self.doc_versions.pop()
            self.doc_contents.pop()

    me update_doc(uri: text, version: i64, content: text):
        """Update document content"""
        val idx = self.find_doc(uri)
        if idx >= 0:
            self.doc_versions[idx] = version
            self.doc_contents[idx] = content

# Helper: Convert URI to file path
fn uri_to_file_path(uri: text) -> text:
    # Remove file:// prefix
    if uri.starts_with("file://"):
        return uri.substring(7, uri.len())
    uri

# Helper: Convert file path to URI
fn file_path_to_uri(file_path: text) -> text:
    # Add file:// prefix
    "file://" + file_path

# Compute folding ranges from source text using line-based heuristic
fn compute_folding_ranges(source: text) -> list:
    val lines = source.split("\n")
    var ranges = []
    var line_num = 0

    # Track symbol start lines with their indent level
    var sym_start_lines = []
    var sym_start_indents = []

    for line in lines:
        val trimmed = line.trim()
        val indent = count_leading_spaces(line)

        # Detect top-level symbol starts (indent == 0, keyword line)
        var found_sym = false
        if (trimmed.starts_with("fn ") or trimmed.starts_with("me ") or trimmed.starts_with("static fn ") or trimmed.starts_with("async fn ") or trimmed.starts_with("class ") or trimmed.starts_with("struct ") or trimmed.starts_with("enum ") or trimmed.starts_with("trait ") or trimmed.starts_with("impl ")):
            found_sym = true

        if found_sym and indent == 0 and trimmed != "":
            sym_start_lines.push(line_num)
            sym_start_indents.push(indent)

        line_num = line_num + 1

    # Convert starts to ranges: each sym ends just before the next
    val total_lines = lines.len()
    val sym_count = sym_start_lines.len()
    var si = 0

    while si < sym_count:
        val start_ln = sym_start_lines[si]
        var end_ln = total_lines - 1
        if si + 1 < sym_count:
            end_ln = sym_start_lines[si + 1] - 1
        if end_ln > start_ln:
            ranges.push([start_ln, end_ln])
        si = si + 1

    ranges

fn count_leading_spaces(line: text) -> i64:
    var count = 0
    var i = 0
    while i < line.len():
        val ch = line.char_at(i)
        if ch == " ":
            count = count + 1
        elif ch == "\t":
            count = count + 4
        else:
            return count
        i = i + 1
    count

# Export classes and types
export LspServer
export ServerState
export DocumentInfo
