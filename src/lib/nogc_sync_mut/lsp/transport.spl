# LSP JSON-RPC Transport Layer
# Delegates to shared protocol transport for Content-Length I/O

import sys
import io.stdio as stdio
import core.json as json
import core.string as str
use app.protocol.transport.{read_message, write_message, log_debug_with_prefix, log_error_with_prefix}

# Re-export shared functions
export read_message, write_message

# Write a JSON-RPC response
fn write_response(id: Int, result: Dict) -> Result<Nil, String>:
    val response = {
        "jsonrpc": "2.0",
        "id": id,
        "result": result
    }
    write_message(response)

# Write a JSON-RPC error response
fn write_error(id: Int, code: Int, message: String) -> Result<Nil, String>:
    val response = {
        "jsonrpc": "2.0",
        "id": id,
        "error": {
            "code": code,
            "message": message
        }
    }
    write_message(response)

# Write a JSON-RPC notification
fn write_notification(method: String, params: Dict) -> Result<Nil, String>:
    val notification = {
        "jsonrpc": "2.0",
        "method": method,
        "params": params
    }
    write_message(notification)

# Parse message type from raw JSON-RPC message
fn parse_message_type(data: Dict) -> Result<String, String>:
    if data.contains_key("id") and data.contains_key("method"):
        return Ok("request")

    if data.contains_key("id"):
        if data.contains_key("result") or data.contains_key("error"):
            return Ok("response")

    if data.contains_key("method") and not data.contains_key("id"):
        return Ok("notification")

    Err("Unknown message type")

# Helper: Log a message to stderr for debugging
fn log_debug(message: String):
    log_debug_with_prefix("SIMPLE_LSP_DEBUG", "LSP", message)

# Helper: Log an error to stderr
fn log_error(message: String):
    log_error_with_prefix("LSP", message)
