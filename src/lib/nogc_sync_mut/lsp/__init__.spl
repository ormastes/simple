"""
Language Server Protocol (LSP) Implementation for Simple

This module provides a complete LSP server for the Simple programming language,
enabling IDE features like code completion, diagnostics, go-to-definition,
hover information, and semantic syntax highlighting.

The LSP implementation is fully self-hosted in Simple and follows the
Language Server Protocol specification 3.17. It communicates via JSON-RPC 2.0
over stdin/stdout, making it compatible with any LSP client.

## Architecture

The module is organized into three main components:

1. **server** - Core LSP server that handles requests, maintains state, and
   coordinates document parsing. Implements the main request/response loop
   and dispatches to specialized handlers for each LSP capability.

2. **protocol** - LSP message types and JSON-RPC protocol definitions.
   Includes Position, Range, Location, Diagnostic, and all other LSP data
   structures with bidirectional JSON serialization.

3. **transport** - JSON-RPC transport layer for reading/writing messages over
   stdin/stdout using Content-Length headers. Handles message framing and
   protocol-level encoding/decoding.

## Features

- **Diagnostics** - Real-time syntax and semantic error reporting
- **Hover** - Type information and documentation on hover
- **Go-to-Definition** - Navigate to symbol definitions
- **Find References** - Find all references to a symbol
- **Code Completion** - Context-aware completions
- **Semantic Tokens** - Syntax highlighting with semantic information
- **Document Symbols** - Outline view of functions, classes, and types

## SDoctest Examples

Basic LSP server usage:

    use std.nogc_sync_mut.lsp.server.{LspServer}

    fn main():
        val server = LspServer.new()
        match server.run():
            case Ok(_):
                print "LSP server exited normally"
            case Err(error):
                print "LSP server error: {error}"

Protocol message handling:

    use std.nogc_sync_mut.lsp.protocol.{Position, Range, Location}
    use std.nogc_sync_mut.lsp.transport.{write_response, write_notification}

    # Create a position (line 10, column 5)
    val pos = Position.new(line: 10, character: 5)

    # Create a range from position to position+3
    val end_pos = Position.new(line: 10, character: 8)
    val range = Range.new(start: pos, end: end_pos)

    # Send a notification to the client
    val params = {"uri": "file:///path/to/file.spl", "range": range.to_json()}
    write_notification("textDocument/publishDiagnostics", params)

## Integration with Editor/IDE

To use this LSP server with your editor:

1. **VS Code** - Add to settings.json:
   ```json
   {
     "simple.lsp.serverPath": "/path/to/simple_lsp"
   }
   ```

2. **Neovim** - Use nvim-lspconfig:
   ```lua
   require('lspconfig').simple_lsp.setup{
     cmd = {"/path/to/simple_lsp"}
   }
   ```

3. **Emacs** - Use lsp-mode:
   ```elisp
   (add-to-list 'lsp-language-id-configuration '(simple-mode . "simple"))
   (lsp-register-client
    (make-lsp-client :new-connection (lsp-stdio-connection "/path/to/simple_lsp")
                     :major-modes '(simple-mode)))
   ```

## Module Exports

@tag:api
@tag:tool
"""

# Re-export main modules for public API

# LSP server implementation - handles requests and maintains state
export server

# Protocol types and message definitions (Position, Range, etc.)
export protocol

# JSON-RPC transport layer for stdin/stdout communication
export transport
