# WASI-Compatible LSP Server Entry Point
#
# Thin wrapper for running the Simple LSP server under WASI.
# Uses WASI-compatible I/O (stdin/stdout via fd_read/fd_write)
# and the core Simple parser (no tree-sitter FFI).
#
# This entry point is compiled to wasm32-wasi for use in:
# - VSCode Web (vscode.dev)
# - Browser-based editors
# - Any WASI-compatible runtime
#
# Usage:
#   simple build --target wasm32-wasi --release src/app/lsp/main_wasi.spl -o simple-lsp.wasm
#   wasmtime simple-lsp.wasm

use app.io.mod.{env_get, env_set}
use std.nogc_sync_mut.lsp.parser_adapter.{ParserAdapter, ParserAdapter__create_core}

# ============================================================================
# WASI I/O Helpers
# ============================================================================

extern fn rt_stdin_read_line() -> text
extern fn rt_stdout_write(data: text)
extern fn rt_stderr_write(data: text)

fn wasi_read_line() -> text:
    """Read a line from stdin (WASI fd_read)."""
    rt_stdin_read_line()

fn wasi_write(data: text):
    """Write to stdout (WASI fd_write)."""
    rt_stdout_write(data)

fn wasi_log(msg: text):
    """Write debug log to stderr."""
    rt_stderr_write(msg)
    rt_stderr_write("\n")

# ============================================================================
# LSP Message I/O (Content-Length framing)
# ============================================================================

fn read_lsp_message() -> text?:
    """Read a complete LSP message from stdin.

    LSP uses Content-Length headers followed by JSON body:
        Content-Length: 123\r\n
        \r\n
        {"jsonrpc": "2.0", ...}
    """
    # Read Content-Length header
    var content_length = 0
    var found_header = false

    var header_line = wasi_read_line()
    while header_line != "" and header_line != "\r\n" and header_line != "\n":
        val trimmed = header_line.replace("\r\n", "").replace("\n", "")
        if trimmed.starts_with("Content-Length: "):
            val len_str = trimmed[16:]
            content_length = int(len_str)
            found_header = true
        header_line = wasi_read_line()

    if not found_header or content_length <= 0:
        return nil

    # Read body (content_length bytes)
    var body = ""
    var remaining = content_length
    while remaining > 0:
        val chunk = wasi_read_line()
        body = body + chunk
        remaining = remaining - chunk.len()

    Some(body)

fn write_lsp_message(content: text):
    """Write a complete LSP message to stdout."""
    val length = content.len()
    wasi_write("Content-Length: {length}\r\n\r\n{content}")

# ============================================================================
# WASI LSP Server
# ============================================================================

fn run_wasi_lsp():
    """Run the LSP server in WASI mode.

    This is a simplified LSP server loop that:
    1. Reads JSON-RPC messages from stdin
    2. Dispatches to handlers
    3. Writes responses to stdout
    """
    # Set runtime mode for WASI
    env_set("SIMPLE_RUNTIME_MODE", "wasi")

    # Create parser adapter (core parser, no tree-sitter)
    val parser = ParserAdapter__create_core()

    wasi_log("[simple-lsp-wasi] Starting WASI LSP server")

    # Main message loop
    var running = true
    while running:
        val msg = read_lsp_message()
        if not msg.?:
            running = false
            continue

        val content = msg ?? ""
        if content == "":
            continue

        # Simple JSON-RPC dispatch
        # Full implementation would parse JSON and dispatch to handlers
        if content.contains("\"method\":\"initialize\""):
            val response = make_initialize_response(content)
            write_lsp_message(response)
        elif content.contains("\"method\":\"initialized\""):
            # No response needed for notification
            wasi_log("[simple-lsp-wasi] Initialized")
        elif content.contains("\"method\":\"shutdown\""):
            val id = extract_id(content)
            write_lsp_message("{\"jsonrpc\":\"2.0\",\"id\":{id},\"result\":null}")
        elif content.contains("\"method\":\"exit\""):
            running = false
        elif content.contains("\"method\":\"textDocument/didOpen\""):
            # Parse the document and send diagnostics
            wasi_log("[simple-lsp-wasi] Document opened")
        elif content.contains("\"method\":\"textDocument/didChange\""):
            # Re-parse and update diagnostics
            wasi_log("[simple-lsp-wasi] Document changed")
        elif content.contains("\"method\":\"textDocument/hover\""):
            val id = extract_id(content)
            write_lsp_message("{\"jsonrpc\":\"2.0\",\"id\":{id},\"result\":null}")
        elif content.contains("\"method\":\"textDocument/completion\""):
            val id = extract_id(content)
            write_lsp_message("{\"jsonrpc\":\"2.0\",\"id\":{id},\"result\":[]}")

    wasi_log("[simple-lsp-wasi] Server stopped")

fn extract_id(json_str: text) -> text:
    """Extract the 'id' field from a JSON-RPC message."""
    val idx = json_str.index_of("\"id\":")
    if idx < 0:
        return "0"
    val after = json_str[idx + 5:]
    var end_idx = 0
    for i in 0..after.len():
        val ch = after[i:i + 1]
        if ch == "," or ch == "}":
            end_idx = i
            break
    after[0:end_idx].trim()

fn make_initialize_response(request: text) -> text:
    """Create initialize response with server capabilities."""
    val id = extract_id(request)
    "{\"jsonrpc\":\"2.0\",\"id\":{id},\"result\":{\"capabilities\":{\"textDocumentSync\":1,\"hoverProvider\":true,\"completionProvider\":{\"triggerCharacters\":[\".\"]},\"definitionProvider\":true,\"referencesProvider\":true},\"serverInfo\":{\"name\":\"simple-lsp-wasi\",\"version\":\"0.1.0\"}}}"

# ============================================================================
# Entry Point
# ============================================================================

fn main():
    run_wasi_lsp()
