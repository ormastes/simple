# PINGREQ/PINGRESP Packet Functions
# ============================================================================

fn mqtt_create_pingreq_packet():
    """Create a PINGREQ packet."""
    mqtt_create_packet(PACKET_TYPE_PINGREQ, 0, nil, nil)

fn mqtt_create_pingresp_packet():
    """Create a PINGRESP packet."""
    mqtt_create_packet(PACKET_TYPE_PINGRESP, 0, nil, nil)

# ============================================================================
# DISCONNECT Packet Functions
# ============================================================================

fn mqtt_create_disconnect_packet():
    """Create a DISCONNECT packet (v3.1.1)."""
    mqtt_create_packet(PACKET_TYPE_DISCONNECT, 0, nil, nil)

fn mqtt_create_disconnect_packet_v5(reason_code):
    """Create a DISCONNECT packet (v5.0) with reason code."""
    val headers = (reason_code, nil)
    mqtt_create_packet(PACKET_TYPE_DISCONNECT, 0, headers, nil)

fn mqtt_disconnect_get_reason_code(packet):
    """Get reason code from DISCONNECT packet (v5.0)."""
    val headers = mqtt_packet_headers(packet)
    if headers == nil:
        return REASON_NORMAL_DISCONNECTION

    val parts = headers
    parts[0]

# ============================================================================
# AUTH Packet Functions (MQTT v5.0)
# ============================================================================

fn mqtt_create_auth_packet(reason_code, auth_method, auth_data):
    """Create an AUTH packet (v5.0)."""
    val headers = (reason_code, auth_method, auth_data, nil)
    mqtt_create_packet(PACKET_TYPE_AUTH, 0, headers, nil)

fn mqtt_auth_get_reason_code(packet):
    """Get reason code from AUTH packet."""
    val headers = mqtt_packet_headers(packet)
    val parts = headers
    parts[0]

fn mqtt_auth_get_method(packet):
    """Get authentication method from AUTH packet."""
    val headers = mqtt_packet_headers(packet)
    val parts = headers
    parts[1]

fn mqtt_auth_get_data(packet):
    """Get authentication data from AUTH packet."""
    val headers = mqtt_packet_headers(packet)
    val parts = headers
    parts[2]

# ============================================================================
# Topic Matching and Validation Functions
# ============================================================================

fn mqtt_topic_is_valid(topic):
    """Check if topic is valid according to MQTT rules."""
    if topic == nil:
        return false

    val length = topic.length()
    if length == 0 or length > MAX_TOPIC_LENGTH:
        return false

    # Check for null characters
    var i = 0
    while i < length:
        val char = topic[i]
        if char == "\0":
            return false
        i = i + 1

    true

fn mqtt_topic_filter_is_valid(filter):
    """Check if topic filter is valid (can contain wildcards)."""
    if not mqtt_topic_is_valid(filter):
        return false

    val length = filter.length()
    var i = 0

    while i < length:
        val char = filter[i]

        # Check multi-level wildcard
        if char == "#":
            # Must be at end and preceded by / or be the only character
            var is_at_end = i == length - 1
            if not is_at_end:
                return false

            if i > 0:
                val prev = filter[i - 1]
                if prev != "/":
                    return false

        # Check single-level wildcard
        if char == "+":
            # Must be at start or preceded by /
            if i > 0:
                val prev = filter[i - 1]
                if prev != "/":
                    return false

            # Must be at end or followed by /
            if i < length - 1:
                val next = filter[i + 1]
                if next != "/":
                    return false

        i = i + 1

    true

fn mqtt_topic_matches_filter(topic, filter):
    """Check if a topic matches a topic filter (with wildcards)."""
    if not mqtt_topic_is_valid(topic):
        return false

    if not mqtt_topic_filter_is_valid(filter):
        return false

    # Split into levels
    val topic_levels = topic.split("/")
    val filter_levels = filter.split("/")

    var topic_idx = 0
    var filter_idx = 0

    while filter_idx < filter_levels.length():
        val filter_level = filter_levels[filter_idx]

        # Multi-level wildcard matches rest of topic
        if filter_level == "#":
            return true

        # Need more topic levels
        if topic_idx >= topic_levels.length():
            return false

        val topic_level = topic_levels[topic_idx]

        # Single-level wildcard or exact match
        var matches = filter_level == "+" or filter_level == topic_level
        if not matches:
            return false

        topic_idx = topic_idx + 1
        filter_idx = filter_idx + 1

    # All filter levels matched, check if all topic levels consumed
    topic_idx == topic_levels.length()

fn mqtt_topic_has_wildcard(filter):
    """Check if topic filter contains wildcards."""
    val has_plus = filter.contains("+")
    val has_hash = filter.contains("#")
    has_plus or has_hash

fn mqtt_topic_split_levels(topic):
    """Split topic into levels."""
    topic.split("/")

fn mqtt_topic_join_levels(levels):
    """Join topic levels into a topic string."""
    levels.join("/")

fn mqtt_topic_get_level(topic, level):
    """Get a specific level from a topic (0-indexed)."""
    val levels = mqtt_topic_split_levels(topic)
    if level < 0 or level >= levels.length():
        return nil
    levels[level]

fn mqtt_topic_level_count(topic):
    """Count the number of levels in a topic."""
    val levels = mqtt_topic_split_levels(topic)
    levels.length()

# ============================================================================
# QoS and Session Functions
# ============================================================================

fn mqtt_qos_is_valid(qos):
    """Check if QoS level is valid."""
    qos == 0 or qos == 1 or qos == 2

fn mqtt_qos_to_string(qos):
    """Convert QoS level to string."""
    if qos == QOS_AT_MOST_ONCE:
        return "at most once"

    if qos == QOS_AT_LEAST_ONCE:
        return "at least once"

    if qos == QOS_EXACTLY_ONCE:
        return "exactly once"

    "invalid"

fn mqtt_packet_type_to_string(packet_type):
    """Convert packet type to string."""
    if packet_type == PACKET_TYPE_CONNECT:
        return "CONNECT"
    if packet_type == PACKET_TYPE_CONNACK:
        return "CONNACK"
    if packet_type == PACKET_TYPE_PUBLISH:
        return "PUBLISH"
    if packet_type == PACKET_TYPE_PUBACK:
        return "PUBACK"
    if packet_type == PACKET_TYPE_PUBREC:
        return "PUBREC"
    if packet_type == PACKET_TYPE_PUBREL:
        return "PUBREL"
    if packet_type == PACKET_TYPE_PUBCOMP:
        return "PUBCOMP"
    if packet_type == PACKET_TYPE_SUBSCRIBE:
        return "SUBSCRIBE"
    if packet_type == PACKET_TYPE_SUBACK:
        return "SUBACK"
    if packet_type == PACKET_TYPE_UNSUBSCRIBE:
        return "UNSUBSCRIBE"
    if packet_type == PACKET_TYPE_UNSUBACK:
        return "UNSUBACK"
    if packet_type == PACKET_TYPE_PINGREQ:
        return "PINGREQ"
    if packet_type == PACKET_TYPE_PINGRESP:
        return "PINGRESP"
    if packet_type == PACKET_TYPE_DISCONNECT:
        return "DISCONNECT"
    if packet_type == PACKET_TYPE_AUTH:
        return "AUTH"

    "UNKNOWN"

fn mqtt_reason_code_to_string(reason_code):
    """Convert reason code (v5.0) to string."""
    if reason_code == REASON_SUCCESS:
        return "Success"
    if reason_code == REASON_GRANTED_QOS_1:
        return "Granted QoS 1"
    if reason_code == REASON_GRANTED_QOS_2:
        return "Granted QoS 2"
    if reason_code == REASON_DISCONNECT_WILL:
        return "Disconnect with Will"
    if reason_code == REASON_NO_MATCHING_SUBSCRIBERS:
        return "No matching subscribers"
    if reason_code == REASON_UNSPECIFIED_ERROR:
        return "Unspecified error"
    if reason_code == REASON_MALFORMED_PACKET:
        return "Malformed packet"
    if reason_code == REASON_PROTOCOL_ERROR:
        return "Protocol error"
    if reason_code == REASON_IMPLEMENTATION_ERROR:
        return "Implementation error"
    if reason_code == REASON_UNSUPPORTED_PROTOCOL:
        return "Unsupported protocol"
    if reason_code == REASON_CLIENT_IDENTIFIER_NOT_VALID:
        return "Client identifier not valid"
    if reason_code == REASON_BAD_CREDENTIALS:
        return "Bad credentials"
    if reason_code == REASON_NOT_AUTHORIZED:
        return "Not authorized"
    if reason_code == REASON_SERVER_UNAVAILABLE:
        return "Server unavailable"
    if reason_code == REASON_SERVER_BUSY:
        return "Server busy"
    if reason_code == REASON_BANNED:
        return "Banned"
    if reason_code == REASON_BAD_AUTHENTICATION:
        return "Bad authentication"
    if reason_code == REASON_TOPIC_NAME_INVALID:
        return "Topic name invalid"
    if reason_code == REASON_PACKET_TOO_LARGE:
        return "Packet too large"
    if reason_code == REASON_QUOTA_EXCEEDED:
        return "Quota exceeded"
    if reason_code == REASON_PAYLOAD_FORMAT_INVALID:
        return "Payload format invalid"
    if reason_code == REASON_RETAIN_NOT_SUPPORTED:
        return "Retain not supported"
    if reason_code == REASON_QOS_NOT_SUPPORTED:
        return "QoS not supported"
    if reason_code == REASON_USE_ANOTHER_SERVER:
        return "Use another server"
    if reason_code == REASON_SERVER_MOVED:
        return "Server moved"
    if reason_code == REASON_CONNECTION_RATE_EXCEEDED:
        return "Connection rate exceeded"

    "Unknown reason"

# ============================================================================
# Validation Functions
