# Performance Module
#
# Unified performance configuration, statistics, and benchmarks.

use types.{Reductions, Count, ByteSize, Capacity, Nanos}

# --- OptimizationLevel enum ---

enum OptimizationLevel:
    Minimal
    Balanced
    Aggressive

val OPT_MINIMAL = OptimizationLevel.Minimal
val OPT_BALANCED = OptimizationLevel.Balanced
val OPT_AGGRESSIVE = OptimizationLevel.Aggressive

fn OptimizationLevel__Minimal__description() -> text:
    "Minimal optimizations for debugging"

fn OptimizationLevel__Balanced__description() -> text:
    "Balanced optimizations for general use"

fn OptimizationLevel__Aggressive__description() -> text:
    "Maximum optimizations for production"

# --- SchedulerConfigPerf (local copy to avoid circular imports) ---

class SchedulerConfigPerf:
    reductions_per_timeslice: Reductions
    scheduler_count: Count

fn SchedulerConfigPerf__default() -> SchedulerConfigPerf:
    SchedulerConfigPerf(reductions_per_timeslice: Reductions(value: 2000), scheduler_count: Count(value: 4))

# --- HeapConfigPerf (local copy) ---

class HeapConfigPerf:
    initial_size: ByteSize
    max_size: ByteSize

fn HeapConfigPerf__default() -> HeapConfigPerf:
    HeapConfigPerf(initial_size: ByteSize(value: 2048), max_size: ByteSize(value: 16777216))

# --- MailboxConfigPerf (local copy) ---

class MailboxConfigPerf:
    capacity: Capacity

fn MailboxConfigPerf__default() -> MailboxConfigPerf:
    MailboxConfigPerf(capacity: Capacity(value: 1000))

# --- PerfConfig ---

class PerfConfig:
    level: OptimizationLevel
    symbol_interning_enabled: bool
    persistent_collections_enabled: bool
    per_actor_gc_enabled: bool
    lazy_evaluation_enabled: bool
    stats_collection_enabled: bool
    detailed_stats: bool
    large_binary_threshold: i64
    scheduler_config: SchedulerConfigPerf
    actor_heap_config: HeapConfigPerf
    mailbox_config: MailboxConfigPerf

    fn with_optimization_level(lv: OptimizationLevel) -> PerfConfig:
        PerfConfig(level: lv, symbol_interning_enabled: self.symbol_interning_enabled, persistent_collections_enabled: self.persistent_collections_enabled, per_actor_gc_enabled: self.per_actor_gc_enabled, lazy_evaluation_enabled: self.lazy_evaluation_enabled, stats_collection_enabled: self.stats_collection_enabled, detailed_stats: self.detailed_stats, large_binary_threshold: self.large_binary_threshold, scheduler_config: self.scheduler_config, actor_heap_config: self.actor_heap_config, mailbox_config: self.mailbox_config)

    fn with_actor_heap_size(size: i64) -> PerfConfig:
        val new_heap = HeapConfigPerf(initial_size: ByteSize(value: size), max_size: self.actor_heap_config.max_size)
        PerfConfig(level: self.level, symbol_interning_enabled: self.symbol_interning_enabled, persistent_collections_enabled: self.persistent_collections_enabled, per_actor_gc_enabled: self.per_actor_gc_enabled, lazy_evaluation_enabled: self.lazy_evaluation_enabled, stats_collection_enabled: self.stats_collection_enabled, detailed_stats: self.detailed_stats, large_binary_threshold: self.large_binary_threshold, scheduler_config: self.scheduler_config, actor_heap_config: new_heap, mailbox_config: self.mailbox_config)

    fn with_reductions(r: i64) -> PerfConfig:
        val new_sched = SchedulerConfigPerf(reductions_per_timeslice: Reductions(value: r), scheduler_count: self.scheduler_config.scheduler_count)
        PerfConfig(level: self.level, symbol_interning_enabled: self.symbol_interning_enabled, persistent_collections_enabled: self.persistent_collections_enabled, per_actor_gc_enabled: self.per_actor_gc_enabled, lazy_evaluation_enabled: self.lazy_evaluation_enabled, stats_collection_enabled: self.stats_collection_enabled, detailed_stats: self.detailed_stats, large_binary_threshold: self.large_binary_threshold, scheduler_config: new_sched, actor_heap_config: self.actor_heap_config, mailbox_config: self.mailbox_config)

    fn with_stats_enabled(enabled: bool) -> PerfConfig:
        PerfConfig(level: self.level, symbol_interning_enabled: self.symbol_interning_enabled, persistent_collections_enabled: self.persistent_collections_enabled, per_actor_gc_enabled: self.per_actor_gc_enabled, lazy_evaluation_enabled: self.lazy_evaluation_enabled, stats_collection_enabled: enabled, detailed_stats: self.detailed_stats, large_binary_threshold: self.large_binary_threshold, scheduler_config: self.scheduler_config, actor_heap_config: self.actor_heap_config, mailbox_config: self.mailbox_config)

    fn with_large_binary_threshold(t: i64) -> PerfConfig:
        PerfConfig(level: self.level, symbol_interning_enabled: self.symbol_interning_enabled, persistent_collections_enabled: self.persistent_collections_enabled, per_actor_gc_enabled: self.per_actor_gc_enabled, lazy_evaluation_enabled: self.lazy_evaluation_enabled, stats_collection_enabled: self.stats_collection_enabled, detailed_stats: self.detailed_stats, large_binary_threshold: t, scheduler_config: self.scheduler_config, actor_heap_config: self.actor_heap_config, mailbox_config: self.mailbox_config)

fn PerfConfig__default() -> PerfConfig:
    PerfConfig(level: OPT_BALANCED, symbol_interning_enabled: true, persistent_collections_enabled: true, per_actor_gc_enabled: true, lazy_evaluation_enabled: true, stats_collection_enabled: true, detailed_stats: false, large_binary_threshold: 64, scheduler_config: SchedulerConfigPerf__default(), actor_heap_config: HeapConfigPerf__default(), mailbox_config: MailboxConfigPerf__default())

fn PerfConfig__development() -> PerfConfig:
    PerfConfig(level: OPT_MINIMAL, symbol_interning_enabled: true, persistent_collections_enabled: false, per_actor_gc_enabled: true, lazy_evaluation_enabled: true, stats_collection_enabled: true, detailed_stats: true, large_binary_threshold: 64, scheduler_config: SchedulerConfigPerf__default(), actor_heap_config: HeapConfigPerf__default(), mailbox_config: MailboxConfigPerf__default())

fn PerfConfig__testing() -> PerfConfig:
    val sched = SchedulerConfigPerf(reductions_per_timeslice: Reductions(value: 2000), scheduler_count: Count(value: 1))
    PerfConfig(level: OPT_MINIMAL, symbol_interning_enabled: true, persistent_collections_enabled: true, per_actor_gc_enabled: true, lazy_evaluation_enabled: true, stats_collection_enabled: true, detailed_stats: true, large_binary_threshold: 64, scheduler_config: sched, actor_heap_config: HeapConfigPerf__default(), mailbox_config: MailboxConfigPerf__default())

fn PerfConfig__production() -> PerfConfig:
    PerfConfig(level: OPT_BALANCED, symbol_interning_enabled: true, persistent_collections_enabled: true, per_actor_gc_enabled: true, lazy_evaluation_enabled: true, stats_collection_enabled: false, detailed_stats: false, large_binary_threshold: 64, scheduler_config: SchedulerConfigPerf__default(), actor_heap_config: HeapConfigPerf__default(), mailbox_config: MailboxConfigPerf__default())

# --- PerfProfile ---

fn PerfProfile__Development__to_config() -> PerfConfig:
    PerfConfig__development()

fn PerfProfile__Production__to_config() -> PerfConfig:
    PerfConfig__production()

fn PerfProfile__LowLatency__to_config() -> PerfConfig:
    val sched = SchedulerConfigPerf(reductions_per_timeslice: Reductions(value: 500), scheduler_count: Count(value: 4))
    PerfConfig(level: OPT_BALANCED, symbol_interning_enabled: true, persistent_collections_enabled: true, per_actor_gc_enabled: true, lazy_evaluation_enabled: true, stats_collection_enabled: true, detailed_stats: false, large_binary_threshold: 64, scheduler_config: sched, actor_heap_config: HeapConfigPerf__default(), mailbox_config: MailboxConfigPerf__default())

fn PerfProfile__HighThroughput__to_config() -> PerfConfig:
    val sched = SchedulerConfigPerf(reductions_per_timeslice: Reductions(value: 8000), scheduler_count: Count(value: 4))
    PerfConfig(level: OPT_AGGRESSIVE, symbol_interning_enabled: true, persistent_collections_enabled: true, per_actor_gc_enabled: true, lazy_evaluation_enabled: true, stats_collection_enabled: true, detailed_stats: false, large_binary_threshold: 128, scheduler_config: sched, actor_heap_config: HeapConfigPerf__default(), mailbox_config: MailboxConfigPerf__default())

fn PerfProfile__MemoryConstrained__to_config() -> PerfConfig:
    val mb = MailboxConfigPerf(capacity: Capacity(value: 50))
    val heap = HeapConfigPerf(initial_size: ByteSize(value: 512), max_size: ByteSize(value: 4096))
    PerfConfig(level: OPT_BALANCED, symbol_interning_enabled: true, persistent_collections_enabled: false, per_actor_gc_enabled: true, lazy_evaluation_enabled: false, stats_collection_enabled: false, detailed_stats: false, large_binary_threshold: 32, scheduler_config: SchedulerConfigPerf__default(), actor_heap_config: heap, mailbox_config: mb)

fn PerfProfile__Development__description() -> text:
    "Development: Full debugging and stats"

fn PerfProfile__Production__description() -> text:
    "Production: Optimized for production workloads"

# --- Global config ---

var g_perf_config = PerfConfig__default()

fn get_config() -> PerfConfig:
    g_perf_config

fn set_config(config: PerfConfig):
    g_perf_config = config

# --- ComponentStats ---

class ComponentStats:
    name: text
    enabled: bool
    metric_names: [text]
    metric_values: [f64]

    fn metric_count() -> i64:
        self.metric_names.len()

    me add_metric(metric_name: text, metric_val: f64):
        self.metric_names.push(metric_name)
        self.metric_values.push(metric_val)

    fn get_metric(metric_name: text):
        var idx = 0
        for n in self.metric_names:
            if n == metric_name:
                return self.metric_values[idx]
            idx = idx + 1
        nil

    fn fmt() -> text:
        if not self.enabled:
            return "{self.name}: disabled"
        var s = "{self.name}:"
        var idx = 0
        for n in self.metric_names:
            s = "{s} {n}={self.metric_values[idx]}"
            idx = idx + 1
        s

fn ComponentStats__new(name: text, enabled: bool) -> ComponentStats:
    ComponentStats(name: name, enabled: enabled, metric_names: [], metric_values: [])

# --- PerfStats ---

class PerfStats:
    total_memory_bytes: ByteSize
    total_gc_count: Count
    components: [ComponentStats]

    fn component_names():
        var names = []
        for c in self.components:
            names.push(c.name)
        names

    fn get_component(name: text):
        for c in self.components:
            if c.name == name:
                return c
        nil

    fn summary() -> text:
        var s = "Performance Statistics\n"
        s = "{s}======================\n"
        for c in self.components:
            s = "{s}{c.fmt()}\n"
        s

fn PerfStats__empty() -> PerfStats:
    var components = []
    var sym = ComponentStats__new("symbols", true)
    sym.add_metric("total_interned", 0.0)
    components.push(sym)
    var lazy = ComponentStats__new("lazy", true)
    lazy.add_metric("total_created", 0.0)
    lazy.add_metric("cache_hits", 0.0)
    components.push(lazy)
    var heap = ComponentStats__new("shared_heap", true)
    heap.add_metric("used_bytes", 0.0)
    components.push(heap)
    PerfStats(total_memory_bytes: ByteSize(value: 0), total_gc_count: Count(value: 0), components: components)

fn collect_stats() -> PerfStats:
    PerfStats__empty()

fn reset_all_stats():
    ()

# --- Formatting Utilities ---

fn format_bytes(bytes: i64) -> text:
    if bytes < 1024:
        return "{bytes} B"
    val kb = bytes / 1024
    if kb < 1024:
        return "{kb} KB"
    val mb = kb / 1024
    if mb < 1024:
        return "{mb} MB"
    val gb = mb / 1024
    "{gb} GB"

fn format_duration(ns: i64) -> text:
    if ns < 1000:
        return "{ns} ns"
    val us = ns / 1000
    if us < 1000:
        return "{us} Âµs"
    val ms = us / 1000
    if ms < 1000:
        return "{ms} ms"
    val s = ms / 1000
    "{s} s"

# --- BenchmarkConfig ---

class BenchmarkConfig:
    warmup_iterations: Count
    iterations: Count
    name: text

fn BenchmarkConfig__default() -> BenchmarkConfig:
    BenchmarkConfig(warmup_iterations: Count(value: 10), iterations: Count(value: 100), name: "default")

fn BenchmarkConfig__quick() -> BenchmarkConfig:
    BenchmarkConfig(warmup_iterations: Count(value: 3), iterations: Count(value: 20), name: "quick")

fn BenchmarkConfig__thorough() -> BenchmarkConfig:
    BenchmarkConfig(warmup_iterations: Count(value: 50), iterations: Count(value: 1000), name: "thorough")

# --- BenchmarkResult ---

class BenchmarkResult:
    name: text
    iterations: Count
    mean_time_ns: Nanos
    min_time_ns: Nanos
    max_time_ns: Nanos
    stddev_ns: Nanos

    fn ops_per_second() -> f64:
        if self.mean_time_ns.value == 0: return 0.0
        1000000000.0 / self.mean_time_ns.value

    fn mean_time_us() -> f64:
        self.mean_time_ns.value * 1.0 / 1000.0

    fn mean_time_ms() -> f64:
        self.mean_time_ns.value * 1.0 / 1000000.0

    fn coefficient_of_variation() -> f64:
        if self.mean_time_ns.value == 0: return 0.0
        self.stddev_ns.value * 1.0 / self.mean_time_ns.value

    fn compare_to(other: BenchmarkResult) -> BenchmarkComparison:
        var speedup = 0.0
        if other.mean_time_ns.value > 0:
            speedup = self.mean_time_ns.value * 1.0 / other.mean_time_ns.value
        BenchmarkComparison(baseline_name: self.name, candidate_name: other.name, speedup: speedup, baseline_ns: self.mean_time_ns, candidate_ns: other.mean_time_ns)

    fn summary() -> text:
        var s = "Benchmark: {self.name}\n"
        s = "{s}  Iterations: {self.iterations.value}\n"
        s = "{s}  Mean: {self.mean_time_ns.value} ns\n"
        s = "{s}  Min: {self.min_time_ns.value} ns\n"
        s = "{s}  Max: {self.max_time_ns.value} ns\n"
        s

fn BenchmarkResult__new(name: text) -> BenchmarkResult:
    BenchmarkResult(name: name, iterations: Count(value: 0), mean_time_ns: Nanos(value: 0), min_time_ns: Nanos(value: 0), max_time_ns: Nanos(value: 0), stddev_ns: Nanos(value: 0))

# --- BenchmarkComparison ---

class BenchmarkComparison:
    baseline_name: text
    candidate_name: text
    speedup: f64
    baseline_ns: Nanos
    candidate_ns: Nanos

    fn is_faster() -> bool:
        self.speedup > 1.0

    fn is_slower() -> bool:
        self.speedup < 1.0

    fn summary() -> text:
        var direction = "same"
        if self.is_faster():
            direction = "faster"
        if self.is_slower():
            direction = "slower"
        "{self.candidate_name} vs {self.baseline_name}: {self.speedup}x ({direction})"

# --- Benchmark ---

class Benchmark:
    name: text
    run_fn: fn()
    setup_fn: fn()
    teardown_fn: fn()
    has_setup: bool
    has_teardown: bool
    description_text: text

    fn setup():
        if self.has_setup:
            self.setup_fn()

    fn teardown():
        if self.has_teardown:
            self.teardown_fn()

    fn with_setup(f: fn()) -> Benchmark:
        Benchmark(name: self.name, run_fn: self.run_fn, setup_fn: f, teardown_fn: self.teardown_fn, has_setup: true, has_teardown: self.has_teardown, description_text: self.description_text)

    fn with_teardown(f: fn()) -> Benchmark:
        Benchmark(name: self.name, run_fn: self.run_fn, setup_fn: self.setup_fn, teardown_fn: f, has_setup: self.has_setup, has_teardown: true, description_text: self.description_text)

    fn with_description(desc: text) -> Benchmark:
        Benchmark(name: self.name, run_fn: self.run_fn, setup_fn: self.setup_fn, teardown_fn: self.teardown_fn, has_setup: self.has_setup, has_teardown: self.has_teardown, description_text: desc)

fn Benchmark__new(name: text, f: fn()) -> Benchmark:
    Benchmark(name: name, run_fn: f, setup_fn: fn(): (), teardown_fn: fn(): (), has_setup: false, has_teardown: false, description_text: "")

# --- BenchmarkSuite ---

class BenchmarkSuite:
    name: text
    benchmarks: [Benchmark]
    config: BenchmarkConfig

    me add_fn(bench_name: text, f: fn()):
        val b = Benchmark__new(bench_name, f)
        self.benchmarks.push(b)

    fn with_config(c: BenchmarkConfig) -> BenchmarkSuite:
        BenchmarkSuite(name: self.name, benchmarks: self.benchmarks, config: c)

fn BenchmarkSuite__new(name: text) -> BenchmarkSuite:
    BenchmarkSuite(name: name, benchmarks: [], config: BenchmarkConfig__default())

# --- run_benchmark ---

fn run_benchmark(name: text, iters: i64, f: fn()) -> BenchmarkResult:
    # Warmup
    for _ in 0..3:
        f()
    # Run
    for _ in 0..iters:
        f()
    # Without real timing, return zero-based result
    var result = BenchmarkResult__new(name)
    result.iterations = Count(value: iters)
    result.mean_time_ns = Nanos(value: 0)
    result.min_time_ns = Nanos(value: 0)
    result.max_time_ns = Nanos(value: 0)
    result

export OptimizationLevel
export PerfConfig, PerfConfig__default, PerfConfig__development, PerfConfig__testing, PerfConfig__production
export PerfProfile__Development__to_config, PerfProfile__Production__to_config
export PerfProfile__LowLatency__to_config, PerfProfile__HighThroughput__to_config, PerfProfile__MemoryConstrained__to_config
export PerfProfile__Development__description, PerfProfile__Production__description
export OptimizationLevel__Minimal__description, OptimizationLevel__Balanced__description, OptimizationLevel__Aggressive__description
export OPT_MINIMAL, OPT_BALANCED, OPT_AGGRESSIVE
export get_config, set_config
export ComponentStats, ComponentStats__new
export PerfStats, PerfStats__empty, collect_stats, reset_all_stats
export format_bytes, format_duration
export BenchmarkConfig, BenchmarkConfig__default, BenchmarkConfig__quick, BenchmarkConfig__thorough
export BenchmarkResult, BenchmarkResult__new
export BenchmarkComparison
export Benchmark, Benchmark__new
export BenchmarkSuite, BenchmarkSuite__new
export run_benchmark
export SchedulerConfigPerf, HeapConfigPerf, MailboxConfigPerf
