# Full MCP Server with Inline Tool Handlers
#
# All 34 tools implemented inline with zero module imports.
# Uses only extern fn calls for I/O — no subprocess dispatch, no hangs.
#
# Architecture:
#   - Zero imports: all JSON helpers and tool logic inlined
#   - Fast startup (~100ms), fast tool calls (<1s)
#   - Direct extern fn calls: rt_file_read_text, rt_process_run, rt_env_get, rt_file_write_text
#
# Split into multiple files:
#   - main_lazy_json.spl       — JSON helpers, tool result helpers, shell helpers
#   - main_lazy_protocol.spl   — Protocol I/O, initialize, tools list, schemas, resources, prompts
#   - main_lazy_diag_tools.spl — Diagnostic tool handlers (read, check, symbols, status, edit, run, api)
#   - main_lazy_vcs_tools.spl  — VCS tool handlers (diff, log, squash, new)
#   - main_lazy_debug_tools.spl — Debug session/breakpoint/variable handlers
#   - main_lazy_debug_log_tools.spl — Debug log tool handlers

extern fn rt_file_read_text(path: text) -> text
extern fn rt_process_run(cmd: text, args: [text]) -> (text, text, i64)
extern fn rt_env_get(name: text) -> text
extern fn rt_file_write_text(path: text, content: text) -> bool

# Load split module implementations referenced below.
use app.mcp.main_lazy_json
use app.mcp.main_lazy_protocol
use app.mcp.main_lazy_diag_tools
use app.mcp.main_lazy_vcs_tools
use app.mcp.main_lazy_debug_tools
use app.mcp.main_lazy_debug_log_tools

val SERVER_NAME = "simple-mcp-full"
val SERVER_VERSION = "3.1.0"
val NL = "\n"

# Protocol auto-detection
var USE_JSON_LINES = false

# Caches
var TOOLS_CACHE = ""
var INIT_CACHE = ""

# Debug session state (lightweight in-process implementation)
class LazyBreakpoint:
    id: i64
    file: text
    line: i64
    function_name: text
    condition: text
    enabled: bool

class LazyDataBreakpoint:
    id: i64
    name: text
    access_type: text
    condition: text
    last_value: text
    enabled: bool
    hardware_slot: i64

class LazySession:
    id: text
    program: text
    target_type: text
    state: text
    breakpoints: [LazyBreakpoint]
    data_breakpoints: [LazyDataBreakpoint]
    watches: [text]
    next_bp_id: i64
    next_data_bp_id: i64

var DEBUG_SESSIONS: [LazySession] = []
var DEBUG_NEXT_SESSION_ID: i64 = 1

# Debug log state
var DEBUG_LOG_ENABLED = false
var DEBUG_LOG_PATTERN = "*"
var DEBUG_LOG_NEXT_ID: i64 = 1
var DEBUG_LOG_ENTRIES: [text] = []
var MCP_LOG_LEVEL = "info"

# --- Server loop ---

start_server()

fn start_server():
    var running = true
    for _iter in range(0, 999999):
        if not running:
            return
        var line = read_stdin_message()
        if line == "":
            running = false
        else:
            var method = extract_field(line, "method")
            var id = extract_id(line)
            var response = ""
            if method == "initialize":
                response = make_init_response(id)
            elif method == "initialized" or method == "notifications/initialized":
                response = ""
            elif method == "shutdown":
                response = make_json_result(id, "null")
            elif method == "tools/list":
                response = make_tools_list(id)
            elif method == "tools/call":
                var tool_name = extract_nested(line, "name")
                response = dispatch_tool(id, tool_name, line)
            elif method == "resources/list":
                response = handle_resources_list(id)
            elif method == "resources/templates/list":
                response = handle_resource_templates_list(id)
            elif method == "resources/read":
                val uri = extract_nested(line, "uri")
                response = handle_resources_read(id, uri)
            elif method == "prompts/list":
                response = handle_prompts_list(id)
            elif method == "prompts/get":
                val prompt_name = extract_nested(line, "name")
                response = handle_prompts_get(id, prompt_name, line)
            elif method == "completion/complete" or method == "completions/complete":
                response = handle_completion_req(id, line)
            elif method == "logging/setLevel":
                val level = extract_nested(line, "level")
                if level != "":
                    MCP_LOG_LEVEL = level
                response = make_json_result(id, jo1(jp("level", js(MCP_LOG_LEVEL))))
            elif method == "roots/list":
                val cwd = get_cwd()
                var root = LB()
                root = root + jp("uri", js("file://" + cwd))
                root = root + "," + jp("name", js("workspace"))
                root = root + RB()
                response = make_json_result(id, jo1(jp("roots", "[" + root + "]")))
            elif method == "ping":
                response = make_json_result(id, LB() + RB())
            elif method == "notifications/cancelled" or method == "notifications/roots/list_changed":
                response = ""
            else:
                if id != "" and id != "null":
                    response = make_error(id, -32601, "Method not found: " + method)
            if response != "":
                write_stdout_message(response)

# ============================================================================
# Tool dispatch — inline implementations (no subprocess, no module imports)
# ============================================================================

fn dispatch_tool(id: text, tool_name: text, body: text) -> text:
    if tool_name == "":
        return make_tool_error(id, -32602, "Missing tool name")

    # Diagnostic read tools
    if tool_name == "simple_read":
        return handle_simple_read(id, body)
    elif tool_name == "simple_check":
        return handle_simple_check(id, body)
    elif tool_name == "simple_symbols":
        return handle_simple_symbols(id, body)
    elif tool_name == "simple_status":
        return handle_simple_status(id, body)

    # Diagnostic edit tools
    elif tool_name == "simple_edit":
        return handle_simple_edit(id, body)
    elif tool_name == "simple_multi_edit":
        return handle_simple_multi_edit(id, body)
    elif tool_name == "simple_run":
        return handle_simple_run(id, body)

    # VCS tools
    elif tool_name == "simple_diff":
        return handle_simple_diff(id, body)
    elif tool_name == "simple_log":
        return handle_simple_log(id, body)
    elif tool_name == "simple_squash":
        return handle_simple_squash(id, body)
    elif tool_name == "simple_new":
        return handle_simple_new(id, body)

    # API search
    elif tool_name == "simple_api":
        return handle_simple_api(id, body)

    # Debug tools
    elif tool_name == "debug_create_session":
        return handle_debug_create_session(id, body)
    elif tool_name == "debug_list_sessions":
        return handle_debug_list_sessions(id)
    elif tool_name == "debug_close_session":
        return handle_debug_close_session(id, body)
    elif tool_name == "debug_set_breakpoint":
        return handle_debug_set_breakpoint(id, body)
    elif tool_name == "debug_remove_breakpoint":
        return handle_debug_remove_breakpoint(id, body)
    elif tool_name == "debug_continue":
        return handle_debug_continue(id, body)
    elif tool_name == "debug_step":
        return handle_debug_step(id, body)
    elif tool_name == "debug_get_variables":
        return handle_debug_get_variables(id, body)
    elif tool_name == "debug_stack_trace":
        return handle_debug_stack_trace(id, body)
    elif tool_name == "debug_evaluate":
        return handle_debug_evaluate(id, body)
    elif tool_name == "debug_set_function_breakpoint":
        return handle_debug_set_function_breakpoint(id, body)
    elif tool_name == "debug_enable_breakpoint":
        return handle_debug_enable_breakpoint(id, body)
    elif tool_name == "debug_get_source":
        return handle_debug_get_source(id, body)
    elif tool_name == "debug_watch":
        return handle_debug_watch(id, body)
    elif tool_name == "debug_set_variable":
        return handle_debug_set_variable(id, body)
    elif tool_name == "debug_set_data_breakpoint":
        return handle_debug_set_data_breakpoint(id, body)
    elif tool_name == "debug_list_data_breakpoints":
        return handle_debug_list_data_breakpoints(id, body)
    elif tool_name == "debug_remove_data_breakpoint":
        return handle_debug_remove_data_breakpoint(id, body)
    elif tool_name == "debug_terminate":
        return handle_debug_terminate(id, body)
    elif tool_name == "debug_log_enable":
        return handle_debug_log_enable(id, body)
    elif tool_name == "debug_log_disable":
        return handle_debug_log_disable(id)
    elif tool_name == "debug_log_clear":
        return handle_debug_log_clear(id)
    elif tool_name == "debug_log_query":
        return handle_debug_log_query(id, body)
    elif tool_name == "debug_log_tree":
        return handle_debug_log_tree(id, body)
    elif tool_name == "debug_log_status":
        return handle_debug_log_status(id)

    make_tool_error(id, -32601, "Unknown tool: " + tool_name)
