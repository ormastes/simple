# Debug Tool Handler Adapter - In-process dispatch for debug_* tools
#
# Replaces subprocess dispatch with direct function calls.
# SessionManager persists across calls (fixes state loss from subprocess model).
#
# Usage:
#   val handler = create_debug_handler()
#   val response = handler.handle_fn("debug_create_session", id, body)

use std.mcp.helpers.{make_error_response}
use std.nogc_async_mut.mcp.debug_tools.{SessionManager, handle_debug_create_session, handle_debug_list_sessions, handle_debug_close_session, handle_debug_set_breakpoint, handle_debug_remove_breakpoint, handle_debug_continue, handle_debug_step, handle_debug_get_variables, handle_debug_stack_trace, handle_debug_evaluate, handle_debug_set_function_breakpoint, handle_debug_enable_breakpoint, handle_debug_get_source, handle_debug_watch, handle_debug_set_variable, handle_debug_set_data_breakpoint, handle_debug_list_data_breakpoints, handle_debug_remove_data_breakpoint, handle_debug_terminate}
use std.nogc_async_mut.mcp.services.{DebugToolHandler}

export create_debug_handler

# Module-level session manager (persists across all calls within the process)
var SESSION_MGR_INIT = false
var SESSION_MGR = nil

fn get_session_mgr() -> SessionManager:
    if SESSION_MGR_INIT:
        return SESSION_MGR
    val mgr = SessionManager.empty()
    SESSION_MGR = mgr
    SESSION_MGR_INIT = true
    mgr

fn create_debug_handler() -> DebugToolHandler:
    val handler_fn = fn(tool_name, id, body): dispatch_debug(tool_name, id, body)
    DebugToolHandler(handle_fn: handler_fn)

fn dispatch_debug(tool_name: text, id: text, body: text) -> text:
    val mgr = get_session_mgr()
    if tool_name == "debug_create_session":
        return handle_debug_create_session(id, body, mgr)
    elif tool_name == "debug_list_sessions":
        return handle_debug_list_sessions(id, mgr)
    elif tool_name == "debug_close_session":
        return handle_debug_close_session(id, body, mgr)
    elif tool_name == "debug_set_breakpoint":
        return handle_debug_set_breakpoint(id, body, mgr)
    elif tool_name == "debug_remove_breakpoint":
        return handle_debug_remove_breakpoint(id, body, mgr)
    elif tool_name == "debug_continue":
        return handle_debug_continue(id, body, mgr)
    elif tool_name == "debug_step":
        return handle_debug_step(id, body, mgr)
    elif tool_name == "debug_get_variables":
        return handle_debug_get_variables(id, body, mgr)
    elif tool_name == "debug_stack_trace":
        return handle_debug_stack_trace(id, body, mgr)
    elif tool_name == "debug_evaluate":
        return handle_debug_evaluate(id, body, mgr)
    elif tool_name == "debug_set_function_breakpoint":
        return handle_debug_set_function_breakpoint(id, body, mgr)
    elif tool_name == "debug_enable_breakpoint":
        return handle_debug_enable_breakpoint(id, body, mgr)
    elif tool_name == "debug_get_source":
        return handle_debug_get_source(id, body, mgr)
    elif tool_name == "debug_watch":
        return handle_debug_watch(id, body, mgr)
    elif tool_name == "debug_set_variable":
        return handle_debug_set_variable(id, body, mgr)
    elif tool_name == "debug_set_data_breakpoint":
        return handle_debug_set_data_breakpoint(id, body, mgr)
    elif tool_name == "debug_list_data_breakpoints":
        return handle_debug_list_data_breakpoints(id, body, mgr)
    elif tool_name == "debug_remove_data_breakpoint":
        return handle_debug_remove_data_breakpoint(id, body, mgr)
    elif tool_name == "debug_terminate":
        return handle_debug_terminate(id, body, mgr)
    make_error_response(id, -32601, "Unknown debug tool: " + tool_name)
