# MCP Lazy Server - JSON helpers
# Extracted from main_lazy.spl

# --- JSON helpers (inlined for zero-import startup) ---

fn Q() -> text:
    "\""

fn LB() -> text:
    "{"

fn RB() -> text:
    "}"

fn SB_L() -> text:
    "["

fn SB_R() -> text:
    "]"

fn escape_json(s: text) -> text:
    var parts: [text] = []
    for ch in s:
        if ch == "\"":
            parts.push("\\\"")
        elif ch == "\\":
            parts.push("\\\\")
        elif ch == "\n":
            parts.push("\\n")
        elif ch == "\r":
            parts.push("\\r")
        elif ch == "\t":
            parts.push("\\t")
        else:
            parts.push(ch)
    parts.join("")

fn js(s: text) -> text:
    Q() + escape_json(s) + Q()

fn jp(key: text, value: text) -> text:
    Q() + key + Q() + ":" + value

fn jo1(p1: text) -> text:
    LB() + p1 + RB()

fn jo2(p1: text, p2: text) -> text:
    LB() + p1 + "," + p2 + RB()

fn jo3(p1: text, p2: text, p3: text) -> text:
    LB() + p1 + "," + p2 + "," + p3 + RB()

fn extract_field(json: text, key: text) -> text:
    val search = Q() + key + Q() + ":"
    val idx_result = json.index_of(search)
    var idx = -1
    match idx_result:
        Some(i): idx = i
        nil: return ""
    if idx < 0:
        return ""
    val start = idx + search.len()
    val after = json.substring(start)
    val trimmed = after.trim()
    if trimmed.starts_with(Q()):
        val after_quote = trimmed.substring(1)
        val end_idx_result = after_quote.index_of(Q())
        var end_idx = -1
        match end_idx_result:
            Some(i): end_idx = i
            nil: return ""
        if end_idx < 0:
            return ""
        return trimmed.substring(1, end_idx + 1)
    else:
        var parts: [text] = []
        for ch in trimmed:
            if ch == "," or ch == RB() or ch == SB_R() or ch == " " or ch == "\n":
                break
            parts.push(ch)
        return parts.join("")

fn extract_field_raw(json: text, key: text) -> text:
    val search = Q() + key + Q() + ":"
    val idx_result = json.index_of(search)
    var idx = -1
    match idx_result:
        Some(i): idx = i
        nil: return "null"
    if idx < 0:
        return "null"
    var start = idx + search.len()
    if start >= json.len():
        return "null"
    var rest = json.substring(start)
    rest = rest.trim()
    if rest == "":
        return "null"
    if rest.starts_with(Q()):
        var out: [text] = [Q()]
        var escaped = false
        var pos = 1
        for _i in range(0, 100000):
            if pos >= rest.len():
                break
            val ch = rest.substring(pos, pos + 1)
            out.push(ch)
            if escaped:
                escaped = false
            elif ch == "\\":
                escaped = true
            elif ch == Q():
                break
            pos = pos + 1
        return out.join("")
    var parts: [text] = []
    for ch in rest:
        if ch == "," or ch == RB() or ch == SB_R() or ch == " " or ch == "\n":
            break
        parts.push(ch)
    val raw = parts.join("")
    if raw == "":
        return "null"
    raw

fn extract_id(json: text) -> text:
    extract_field_raw(json, "id")

fn extract_nested(json: text, key: text) -> text:
    val params_search = Q() + "params" + Q() + ":"
    val params_idx_result = json.index_of(params_search)
    var params_idx = -1
    match params_idx_result:
        Some(i): params_idx = i
        nil: return ""
    if params_idx < 0:
        return ""
    val params_start = params_idx + params_search.len()
    val params = json.substring(params_start)
    extract_field(params, key)

fn make_json_result(id: text, result: text) -> text:
    jo3(jp("jsonrpc", js("2.0")), jp("id", id), jp("result", result))

fn make_error(id: text, code: i64, message: text) -> text:
    val err = jo2(jp("code", str(code)), jp("message", js(message)))
    jo3(jp("jsonrpc", js("2.0")), jp("id", id), jp("error", err))

# --- MCP Tool Result helpers ---

fn infer_json_value_type(raw: text) -> text:
    val t = raw.trim()
    if t == "":
        return "empty"
    if t.starts_with("{"):
        return "object"
    if t.starts_with("["):
        return "array"
    if t.starts_with(Q()):
        return "string"
    if t == "true" or t == "false":
        return "boolean"
    if t == "null":
        return "null"
    var has_digit = false
    var all_num = true
    for ch in t:
        if ch >= "0" and ch <= "9":
            has_digit = true
        elif ch == "." or ch == "-" or ch == "+":
            pass
        else:
            all_num = false
            break
    if has_digit and all_num:
        return "number"
    "text"

fn top_level_item_count(raw: text) -> i64:
    val t = raw.trim()
    if t == "":
        return 0
    if not t.starts_with("[") and not t.starts_with("{"):
        return 1
    var depth = 0
    var in_string = false
    var escaped = false
    var count = 0
    var saw_value = false
    for ch in t:
        if in_string:
            if escaped:
                escaped = false
            elif ch == "\\":
                escaped = true
            elif ch == Q():
                in_string = false
            continue
        if ch == Q():
            in_string = true
            if depth == 1:
                saw_value = true
        elif ch == "[" or ch == "{":
            depth = depth + 1
            if depth == 2:
                saw_value = true
        elif ch == "]" or ch == "}":
            if depth == 1 and saw_value:
                count = count + 1
                saw_value = false
            depth = depth - 1
        elif ch == "," and depth == 1:
            count = count + 1
            saw_value = false
        elif depth == 1 and ch != " " and ch != "\n" and ch != "\r" and ch != "\t":
            saw_value = true
    if t.starts_with("[") or t.starts_with("{"):
        if count < 0:
            return 0
    count

fn summarize_json_shape(raw: text, depth: i64) -> text:
    val value_type = infer_json_value_type(raw)
    if depth <= 0:
        return value_type
    if value_type == "array":
        var inner = raw.trim()
        if inner.len() >= 2:
            inner = inner.substring(1, inner.len() - 1).trim()
        var first = ""
        var d = 0
        var in_s = false
        var esc = false
        var parts: [text] = []
        for ch in inner:
            if in_s:
                parts.push(ch)
                if esc:
                    esc = false
                elif ch == "\\":
                    esc = true
                elif ch == Q():
                    in_s = false
                continue
            if ch == Q():
                in_s = true
                parts.push(ch)
            elif ch == "[" or ch == "{":
                d = d + 1
                parts.push(ch)
            elif ch == "]" or ch == "}":
                d = d - 1
                parts.push(ch)
            elif ch == "," and d == 0:
                first = parts.join("").trim()
                break
            else:
                parts.push(ch)
        if first == "":
            first = parts.join("").trim()
        var elem_shape = "unknown"
        if first != "":
            elem_shape = summarize_json_shape(first, depth - 1)
        return "array<" + elem_shape + ">"
    if value_type == "object":
        var pair_count = 0
        var in_s = false
        var esc = false
        for ch in raw:
            if in_s:
                if esc:
                    esc = false
                elif ch == "\\":
                    esc = true
                elif ch == Q():
                    in_s = false
                continue
            if ch == Q():
                in_s = true
            elif ch == ":":
                pair_count = pair_count + 1
        return "object{pairs=" + str(pair_count) + "}"
    value_type

fn make_tool_result(id: text, output: text) -> text:
    val content = SB_L() + jo2(jp("type", js("text")), jp("text", js(output))) + SB_R()
    val inferred = infer_json_value_type(output)
    val shape = summarize_json_shape(output, 2)
    val structured = jo3(
        jp("rawText", js(output)),
        jp("inferredType", js(inferred)),
        jp("shape", js(shape))
    )
    var result = jo1(jp("content", content))
    result = result.substring(0, result.len() - 1) + "," + jp("structuredContent", structured) + RB()
    make_json_result(id, result)

fn make_tool_error(id: text, code: i64, msg: text) -> text:
    val content = SB_L() + jo2(jp("type", js("text")), jp("text", js("ERROR " + str(code) + ": " + msg))) + SB_R()
    val structured = jo2(jp("code", str(code)), jp("message", js(msg)))
    var result = jo1(jp("content", content))
    result = result.substring(0, result.len() - 1) + "," + jp("isError", "true") + "," + jp("structuredContent", structured) + RB()
    make_json_result(id, result)

# --- Shell helper ---

fn shell_cmd(command: text) -> (text, i64):
    val (stdout, stderr, code) = rt_process_run("/bin/sh", ["-c", command])
    (stdout, code)

fn file_read(path: text) -> text:
    rt_file_read_text(path) ?? ""

fn file_write(path: text, content: text) -> bool:
    rt_file_write_text(path, content) ?? false
