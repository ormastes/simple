# Debug Tools Handler - Loaded on-demand
#
# Handles: 19 debug_* tools
#
# This script is invoked as a subprocess, so imports only load when needed.

use std.mcp.helpers.{make_error_response}
use std.nogc_async_mut.mcp.debug_tools.{SessionManager, handle_debug_create_session, handle_debug_list_sessions, handle_debug_close_session, handle_debug_set_breakpoint, handle_debug_remove_breakpoint, handle_debug_continue, handle_debug_step, handle_debug_get_variables, handle_debug_stack_trace, handle_debug_evaluate, handle_debug_set_function_breakpoint, handle_debug_enable_breakpoint, handle_debug_get_source, handle_debug_watch, handle_debug_set_variable, handle_debug_set_data_breakpoint, handle_debug_list_data_breakpoints, handle_debug_remove_data_breakpoint, handle_debug_terminate}

extern fn rt_cli_get_args() -> [text]

# Session manager (singleton for this handler invocation)
var SESSION_MGR_INIT = false
var SESSION_MGR = nil

fn get_session_mgr() -> SessionManager:
    if SESSION_MGR_INIT:
        return SESSION_MGR
    val mgr = SessionManager.empty()
    SESSION_MGR = mgr
    SESSION_MGR_INIT = true
    mgr

val args = rt_cli_get_args()
if args.len() < 4:
    print "ERROR: Usage: debug_handler.spl <tool_name> <id> <request_body>"
else:
    val tool_name = args[1]
    val id = args[2]
    val body = args[3]
    val mgr = get_session_mgr()

    var response = ""
    if tool_name == "debug_create_session":
        response = handle_debug_create_session(id, body, mgr)
    elif tool_name == "debug_list_sessions":
        response = handle_debug_list_sessions(id, mgr)
    elif tool_name == "debug_close_session":
        response = handle_debug_close_session(id, body, mgr)
    elif tool_name == "debug_set_breakpoint":
        response = handle_debug_set_breakpoint(id, body, mgr)
    elif tool_name == "debug_remove_breakpoint":
        response = handle_debug_remove_breakpoint(id, body, mgr)
    elif tool_name == "debug_continue":
        response = handle_debug_continue(id, body, mgr)
    elif tool_name == "debug_step":
        response = handle_debug_step(id, body, mgr)
    elif tool_name == "debug_get_variables":
        response = handle_debug_get_variables(id, body, mgr)
    elif tool_name == "debug_stack_trace":
        response = handle_debug_stack_trace(id, body, mgr)
    elif tool_name == "debug_evaluate":
        response = handle_debug_evaluate(id, body, mgr)
    elif tool_name == "debug_set_function_breakpoint":
        response = handle_debug_set_function_breakpoint(id, body, mgr)
    elif tool_name == "debug_enable_breakpoint":
        response = handle_debug_enable_breakpoint(id, body, mgr)
    elif tool_name == "debug_get_source":
        response = handle_debug_get_source(id, body, mgr)
    elif tool_name == "debug_watch":
        response = handle_debug_watch(id, body, mgr)
    elif tool_name == "debug_set_variable":
        response = handle_debug_set_variable(id, body, mgr)
    elif tool_name == "debug_set_data_breakpoint":
        response = handle_debug_set_data_breakpoint(id, body, mgr)
    elif tool_name == "debug_list_data_breakpoints":
        response = handle_debug_list_data_breakpoints(id, body, mgr)
    elif tool_name == "debug_remove_data_breakpoint":
        response = handle_debug_remove_data_breakpoint(id, body, mgr)
    elif tool_name == "debug_terminate":
        response = handle_debug_terminate(id, body, mgr)
    else:
        response = make_error_response(id, -32601, "Unknown debug tool: " + tool_name)

    print_raw(response)
