# Session Manager for MCP Debug Server
# Manages multiple debug sessions, each targeting a different backend.
# Also tracks MCP protocol state: progress tokens, cancellations, subscriptions.

use compiler.core.*

# Session state enum
enum SessionState:
    Created
    Running
    Paused
    Terminated

# Target type for debug sessions
enum TargetType:
    Interpreter    # Tree-walking interpreter
    Smf            # SMF bytecode format
    Native         # Native binary (ELF/Mach-O)
    Remote         # Remote target via GDB/Trace32

# A debug session
class DebugSession:
    id: String
    target_type: TargetType
    program_path: String
    state: SessionState
    breakpoints: [SessionBreakpoint]
    args: [String]

    static fn create(id: String, target_type: TargetType, program_path: String) -> DebugSession:
        DebugSession(
            id: id,
            target_type: target_type,
            program_path: program_path,
            state: SessionState.Created,
            breakpoints: [],
            args: []
        )

# Breakpoint within a session
class SessionBreakpoint:
    id: Int
    file: String
    line: Int
    condition: Option<String>
    enabled: Bool
    hit_count: Int

    static fn at_line(id: Int, file: String, line: Int) -> SessionBreakpoint:
        SessionBreakpoint(
            id: id,
            file: file,
            line: line,
            condition: nil,
            enabled: true,
            hit_count: 0
        )

# MCP Protocol State - tracks progress, cancellation, subscriptions, log level
class McpState:
    # Progress tokens: maps progressToken -> requestId
    progress_tokens: Dict<String, String>
    # Cancelled request IDs
    cancelled_requests: Dict<String, String>
    # In-flight request IDs (maps requestId -> method)
    in_flight: Dict<String, String>
    # Resource subscriptions (set of URIs)
    subscriptions: Dict<String, Bool>
    # Current minimum log level (numeric, -1 = no emission)
    log_level: Int
    # Next server-to-client request ID
    next_request_id: Int

    static fn create() -> McpState:
        McpState(
            progress_tokens: {},
            cancelled_requests: {},
            in_flight: {},
            subscriptions: {},
            log_level: -1,
            next_request_id: 1
        )

impl McpState:
    # --- Progress token management ---

    me register_progress_token(token: String, request_id: String):
        self.progress_tokens[token] = request_id

    me remove_progress_token(token: String):
        self.progress_tokens.remove(token)

    fn has_progress_token(token: String) -> Bool:
        self.progress_tokens.get(token).?

    # --- In-flight request tracking ---

    me register_request(request_id: String, method: String):
        self.in_flight[request_id] = method

    me complete_request(request_id: String):
        self.in_flight.remove(request_id)

    fn is_in_flight(request_id: String) -> Bool:
        self.in_flight.get(request_id).?

    # --- Cancellation ---

    me cancel_request(request_id: String, reason: String):
        self.cancelled_requests[request_id] = reason

    fn is_cancelled(request_id: String) -> Bool:
        self.cancelled_requests.get(request_id).?

    me clear_cancelled(request_id: String):
        self.cancelled_requests.remove(request_id)

    # --- Resource subscriptions ---

    me subscribe(uri: String):
        self.subscriptions[uri] = true

    me unsubscribe(uri: String):
        self.subscriptions.remove(uri)

    fn is_subscribed(uri: String) -> Bool:
        self.subscriptions.get(uri).?

    fn get_subscribed_uris() -> [String]:
        var result: [String] = []
        for (uri, _) in self.subscriptions.items():
            result.push(uri)
        result

    # --- Log level ---

    me set_log_level(level: Int):
        self.log_level = level

    fn should_emit_log(msg_level: Int) -> Bool:
        if self.log_level < 0:
            return false
        msg_level >= self.log_level

    # --- Server request ID generation ---

    me next_server_request_id() -> String:
        val id = "srv-" + self.next_request_id.to_string()
        self.next_request_id = self.next_request_id + 1
        id

# Session Manager
class SessionManager:
    sessions: Dict<String, DebugSession>
    next_session_id: Int
    next_bp_id: Int

    static fn empty() -> SessionManager:
        SessionManager(
            sessions: {},
            next_session_id: 1,
            next_bp_id: 1
        )

impl SessionManager:
    # Create a new debug session
    me create_session(target_type: TargetType, program_path: String) -> String:
        val id = "session_{self.next_session_id}"
        self.next_session_id = self.next_session_id + 1
        val session = DebugSession.create(id, target_type, program_path)
        self.sessions[id] = session
        id

    # Get a session by id
    fn get_session(id: String) -> Option<DebugSession>:
        self.sessions.get(id)

    # List all sessions
    fn list_sessions() -> [DebugSession]:
        var result: [DebugSession] = []
        for (_, session) in self.sessions.items():
            result.push(session)
        result

    # Remove a session
    me remove_session(id: String) -> Bool:
        match self.sessions.get(id):
            case Some(_):
                self.sessions.remove(id)
                true
            case nil:
                false

    # Add breakpoint to session
    me add_breakpoint(session_id: String, file: String, line: Int) -> Option<Int>:
        match self.sessions.get(session_id):
            case Some(session):
                val bp_id = self.next_bp_id
                self.next_bp_id = self.next_bp_id + 1
                val bp = SessionBreakpoint.at_line(bp_id, file, line)
                session.breakpoints.push(bp)
                Some(bp_id)
            case nil:
                nil

    # Remove breakpoint from session
    fn remove_breakpoint(session_id: String, bp_id: Int) -> Bool:
        match self.sessions.get(session_id):
            case Some(session):
                val initial_len = session.breakpoints.len()
                session.breakpoints = session.breakpoints.filter(\bp: bp.id != bp_id)
                session.breakpoints.len() < initial_len
            case nil:
                false

    # Update session state
    me set_state(session_id: String, new_state: SessionState):
        match self.sessions.get(session_id):
            case Some(session):
                session.state = new_state
            case nil:
                pass
