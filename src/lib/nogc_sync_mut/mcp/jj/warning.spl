# warning.spl - Git compatibility warning generator
#
# Every git_* tool response is prefixed with a warning explaining
# that the repo uses jj, not git.

use app.io.mod (env_get)
use app.mcp.helpers.{make_tool_result, make_error_response}
use jj_runner.{JjResult}
use std.text.{NL}

fn git_compat_warning(git_tool: String, jj_command: String, jj_tool: String) -> String:
    "[jj-mcp: use " + jj_tool + " for native output]{NL}"

fn git_compat_warning_no_equiv(git_tool: String, explanation: String) -> String:
    "[jj-mcp: " + explanation + "]{NL}"

fn show_warnings() -> Bool:
    val env_val = env_get("JJ_MCP_SHOW_WARNINGS")
    if env_val == "false" or env_val == "0":
        return false
    true

fn handle_git_result_simple(
    id: String,
    result: JjResult,
    git_tool: String,
    jj_command: String,
    jj_tool: String
) -> String:
    """Handle git compatibility result with simple warning + stdout pattern.
    
    Use this for simple git commands where output is just warning + stdout.
    For commands with additional notes, use custom handling.
    
    Args:
        id: Request ID
        result: Result from jj_run
        git_tool: Git command name (e.g., "git_status")
        jj_command: JJ equivalent command (e.g., "jj status")
        jj_tool: Native JJ tool name (e.g., "jj_status")
    
    Returns:
        MCP response with warning + output
    """
    if result.success:
        val warning = git_compat_warning(git_tool, jj_command, jj_tool)
        make_tool_result(id, warning + result.stdout)
    else:
        make_error_response(id, -32603, result.stderr)

export git_compat_warning, git_compat_warning_no_equiv, show_warnings, handle_git_result_simple
