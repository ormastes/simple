# Pure Simple Acceleration Layer
#
# Provides seamless fallback between Pure Simple and optional FFI acceleration
# Philosophy: Pure Simple First, FFI Optional

# ============================================================================
# Acceleration Mode
# ============================================================================

enum AccelMode:
    """Acceleration mode for tensor operations."""
    PureSimple      # Pure Simple only (default, no FFI)
    PyTorchFFI      # Always use PyTorch FFI if available
    Auto            # Automatic based on operation size (threshold-based)

# ============================================================================
# Configuration
# ============================================================================

var current_mode = AccelMode.PureSimple
var ffi_available = false

# Threshold values (number of elements)
val MATMUL_THRESHOLD = 1_000_000      # 1M elements (e.g., 1000x1000)
val ELEMENTWISE_THRESHOLD = 10_000_000 # 10M elements (rarely use FFI)
val REDUCTION_THRESHOLD = 5_000_000    # 5M elements

# ============================================================================
# Configuration Functions
# ============================================================================

fn set_acceleration(mode: AccelMode):
    """Configure acceleration mode.
    
    Modes:
    - PureSimple: Never use FFI (default)
    - PyTorchFFI: Always use FFI if available
    - Auto: Use FFI only for large operations
    
    Example:
        set_acceleration(AccelMode.Auto)
    """
    current_mode = mode
    print "[ACCEL] Acceleration mode: {mode_to_string(mode)}"

fn get_acceleration() -> AccelMode:
    """Get current acceleration mode."""
    current_mode

fn set_ffi_available(available: bool):
    """Set whether FFI is available (for testing)."""
    ffi_available = available
    print "[ACCEL] FFI available: {available}"

fn is_ffi_available() -> bool:
    """Check if FFI is available."""
    ffi_available

fn mode_to_string(mode: AccelMode) -> text:
    """Convert AccelMode to string."""
    match mode:
        case PureSimple: "PureSimple"
        case PyTorchFFI: "PyTorchFFI"
        case Auto: "Auto"

# ============================================================================
# Decision Logic
# ============================================================================

fn should_use_ffi(op: text, numel: i64) -> bool:
    """Decide whether to use FFI for this operation.
    
    Args:
        op: Operation name ("matmul", "add", "relu", etc.)
        numel: Total number of elements involved
        
    Returns:
        true if should use FFI, false for Pure Simple
        
    Decision process:
    1. Check mode (PureSimple -> always false)
    2. Check FFI availability
    3. Check operation threshold
    
    Example:
        if should_use_ffi("matmul", 4_000_000):
            # Use FFI
        else:
            # Use Pure Simple
    """
    # Mode check
    match current_mode:
        case PureSimple:
            # Never use FFI in PureSimple mode
            return false
        case PyTorchFFI:
            # Always try FFI if available
            return ffi_available
        case Auto:
            # Use FFI only if available AND threshold met
            if not ffi_available:
                return false
            
            # Check operation-specific threshold
            val threshold = get_threshold(op)
            return numel > threshold

fn get_threshold(op: text) -> i64:
    """Get threshold for operation.
    
    Different operations have different thresholds:
    - matmul: 1M elements (FFI overhead ~1ms, savings 10s+)
    - add/mul: 10M elements (element-wise is fast in Pure Simple)
    - relu/sigmoid: Never use FFI (Pure Simple is adequate)
    """
    if op == "matmul":
        MATMUL_THRESHOLD
    elif op == "add" or op == "sub" or op == "mul" or op == "div":
        ELEMENTWISE_THRESHOLD
    elif op == "sum" or op == "mean" or op == "max" or op == "min":
        REDUCTION_THRESHOLD
    elif op == "relu" or op == "sigmoid" or op == "tanh":
        999_999_999_999  # Effectively never (too high threshold)
    else:
        MATMUL_THRESHOLD  # Default

# ============================================================================
# Statistics Tracking
# ============================================================================

var stats_pure_simple_count = 0
var stats_ffi_count = 0
var stats_ffi_fallback_count = 0

fn record_pure_simple():
    """Record Pure Simple operation."""
    stats_pure_simple_count = stats_pure_simple_count + 1

fn record_ffi():
    """Record FFI operation."""
    stats_ffi_count = stats_ffi_count + 1

fn record_ffi_fallback():
    """Record FFI fallback to Pure Simple."""
    stats_ffi_fallback_count = stats_ffi_fallback_count + 1

fn get_stats() -> (i64, i64, i64):
    """Get acceleration statistics.
    
    Returns: (pure_simple_count, ffi_count, ffi_fallback_count)
    """
    (stats_pure_simple_count, stats_ffi_count, stats_ffi_fallback_count)

fn reset_stats():
    """Reset statistics."""
    stats_pure_simple_count = 0
    stats_ffi_count = 0
    stats_ffi_fallback_count = 0

fn print_stats():
    """Print acceleration statistics."""
    val total = stats_pure_simple_count + stats_ffi_count
    print "[ACCEL] Statistics:"
    print "  Pure Simple: {stats_pure_simple_count} operations"
    print "  FFI:         {stats_ffi_count} operations"
    print "  FFI->Pure:   {stats_ffi_fallback_count} fallbacks"
    if total > 0:
        val pure_pct = (stats_pure_simple_count * 100) / total
        val ffi_pct = (stats_ffi_count * 100) / total
        print "  Pure Simple: {pure_pct}%"
        print "  FFI:         {ffi_pct}%"

# ============================================================================
# Exports
# ============================================================================

export AccelMode
export set_acceleration, get_acceleration
export set_ffi_available, is_ffi_available
export should_use_ffi, get_threshold
export record_pure_simple, record_ffi, record_ffi_fallback
export get_stats, reset_stats, print_stats
export MATMUL_THRESHOLD, ELEMENTWISE_THRESHOLD, REDUCTION_THRESHOLD
