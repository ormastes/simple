# Pure Simple Evaluator â€” Broadcast Operations
#
# Extracted from evaluator.spl. Contains element-wise broadcast
# operations for scalar+list and list+list arithmetic.

use std.pure.ast (Expr, Stmt, Pattern, Module, BinOp, UnaryOp, Literal)
use std.nogc_sync_mut.pure.evaluator.{Value, EvalError, _int_pow}

# Broadcast add: element-wise addition between scalar+list or list+list
fn broadcast_add(left: Value, right: Value) -> Result<Value, EvalError>:
    match (left, right):
        case (Value.Int(s), Value.List(items)):
            var result: [Value] = []
            val n = items.len()
            var i = 0
            while i < n:
                match items[i]:
                    case Value.Int(v): result.push(Value.Int(s + v))
                    case _: return Err(EvalError(message: "BroadcastAdd: elements must be numeric"))
                i = i + 1
            Ok(Value.List(result))
        case (Value.List(items), Value.Int(s)):
            var result: [Value] = []
            val n = items.len()
            var i = 0
            while i < n:
                match items[i]:
                    case Value.Int(v): result.push(Value.Int(v + s))
                    case _: return Err(EvalError(message: "BroadcastAdd: elements must be numeric"))
                i = i + 1
            Ok(Value.List(result))
        case (Value.List(a), Value.List(b)):
            val n = a.len()
            if n != b.len():
                return Err(EvalError(message: "BroadcastAdd: lists must have same length"))
            var result: [Value] = []
            var i = 0
            while i < n:
                match (a[i], b[i]):
                    case (Value.Int(x), Value.Int(y)): result.push(Value.Int(x + y))
                    case _: return Err(EvalError(message: "BroadcastAdd: elements must be numeric"))
                i = i + 1
            Ok(Value.List(result))
        case _:
            Err(EvalError(message: "BroadcastAdd: requires list or scalar operands"))

fn broadcast_sub(left: Value, right: Value) -> Result<Value, EvalError>:
    match (left, right):
        case (Value.Int(s), Value.List(items)):
            var result: [Value] = []
            val n = items.len()
            var i = 0
            while i < n:
                match items[i]:
                    case Value.Int(v): result.push(Value.Int(s - v))
                    case _: return Err(EvalError(message: "BroadcastSub: elements must be numeric"))
                i = i + 1
            Ok(Value.List(result))
        case (Value.List(items), Value.Int(s)):
            var result: [Value] = []
            val n = items.len()
            var i = 0
            while i < n:
                match items[i]:
                    case Value.Int(v): result.push(Value.Int(v - s))
                    case _: return Err(EvalError(message: "BroadcastSub: elements must be numeric"))
                i = i + 1
            Ok(Value.List(result))
        case (Value.List(a), Value.List(b)):
            val n = a.len()
            if n != b.len():
                return Err(EvalError(message: "BroadcastSub: lists must have same length"))
            var result: [Value] = []
            var i = 0
            while i < n:
                match (a[i], b[i]):
                    case (Value.Int(x), Value.Int(y)): result.push(Value.Int(x - y))
                    case _: return Err(EvalError(message: "BroadcastSub: elements must be numeric"))
                i = i + 1
            Ok(Value.List(result))
        case _:
            Err(EvalError(message: "BroadcastSub: requires list or scalar operands"))

fn broadcast_mul(left: Value, right: Value) -> Result<Value, EvalError>:
    match (left, right):
        case (Value.Int(s), Value.List(items)):
            var result: [Value] = []
            val n = items.len()
            var i = 0
            while i < n:
                match items[i]:
                    case Value.Int(v): result.push(Value.Int(s * v))
                    case _: return Err(EvalError(message: "BroadcastMul: elements must be numeric"))
                i = i + 1
            Ok(Value.List(result))
        case (Value.List(items), Value.Int(s)):
            var result: [Value] = []
            val n = items.len()
            var i = 0
            while i < n:
                match items[i]:
                    case Value.Int(v): result.push(Value.Int(v * s))
                    case _: return Err(EvalError(message: "BroadcastMul: elements must be numeric"))
                i = i + 1
            Ok(Value.List(result))
        case (Value.List(a), Value.List(b)):
            val n = a.len()
            if n != b.len():
                return Err(EvalError(message: "BroadcastMul: lists must have same length"))
            var result: [Value] = []
            var i = 0
            while i < n:
                match (a[i], b[i]):
                    case (Value.Int(x), Value.Int(y)): result.push(Value.Int(x * y))
                    case _: return Err(EvalError(message: "BroadcastMul: elements must be numeric"))
                i = i + 1
            Ok(Value.List(result))
        case _:
            Err(EvalError(message: "BroadcastMul: requires list or scalar operands"))

fn broadcast_div(left: Value, right: Value) -> Result<Value, EvalError>:
    match (left, right):
        case (Value.Int(s), Value.List(items)):
            var result: [Value] = []
            val n = items.len()
            var i = 0
            while i < n:
                match items[i]:
                    case Value.Int(v): result.push(Value.Int(s / v))
                    case _: return Err(EvalError(message: "BroadcastDiv: elements must be numeric"))
                i = i + 1
            Ok(Value.List(result))
        case (Value.List(items), Value.Int(s)):
            var result: [Value] = []
            val n = items.len()
            var i = 0
            while i < n:
                match items[i]:
                    case Value.Int(v): result.push(Value.Int(v / s))
                    case _: return Err(EvalError(message: "BroadcastDiv: elements must be numeric"))
                i = i + 1
            Ok(Value.List(result))
        case (Value.List(a), Value.List(b)):
            val n = a.len()
            if n != b.len():
                return Err(EvalError(message: "BroadcastDiv: lists must have same length"))
            var result: [Value] = []
            var i = 0
            while i < n:
                match (a[i], b[i]):
                    case (Value.Int(x), Value.Int(y)): result.push(Value.Int(x / y))
                    case _: return Err(EvalError(message: "BroadcastDiv: elements must be numeric"))
                i = i + 1
            Ok(Value.List(result))
        case _:
            Err(EvalError(message: "BroadcastDiv: requires list or scalar operands"))

fn broadcast_pow(left: Value, right: Value) -> Result<Value, EvalError>:
    match (left, right):
        case (Value.Int(s), Value.List(items)):
            var result: [Value] = []
            val n = items.len()
            var i = 0
            while i < n:
                match items[i]:
                    case Value.Int(v): result.push(Value.Int(_int_pow(s, v)))
                    case _: return Err(EvalError(message: "BroadcastPow: elements must be numeric"))
                i = i + 1
            Ok(Value.List(result))
        case (Value.List(items), Value.Int(s)):
            var result: [Value] = []
            val n = items.len()
            var i = 0
            while i < n:
                match items[i]:
                    case Value.Int(v): result.push(Value.Int(_int_pow(v, s)))
                    case _: return Err(EvalError(message: "BroadcastPow: elements must be numeric"))
                i = i + 1
            Ok(Value.List(result))
        case (Value.List(a), Value.List(b)):
            val n = a.len()
            if n != b.len():
                return Err(EvalError(message: "BroadcastPow: lists must have same length"))
            var result: [Value] = []
            var i = 0
            while i < n:
                match (a[i], b[i]):
                    case (Value.Int(x), Value.Int(y)): result.push(Value.Int(_int_pow(x, y)))
                    case _: return Err(EvalError(message: "BroadcastPow: elements must be numeric"))
                i = i + 1
            Ok(Value.List(result))
        case _:
            Err(EvalError(message: "BroadcastPow: requires list or scalar operands"))

export broadcast_add, broadcast_sub, broadcast_mul, broadcast_div, broadcast_pow
