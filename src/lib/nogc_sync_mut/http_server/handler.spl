# HTTP Server Handler Module
# Request parsing and handling utilities

# =============================================================================
# Request Parsing
# =============================================================================

# Parse HTTP request line: "GET /path HTTP/1.1"
fn parse_request_line(line: text) -> list:
    var parts = line.split(" ")
    var method = ""
    var path = "/"
    var version = "HTTP/1.1"

    if parts.length() >= 1:
        method = parts.at(0)
    if parts.length() >= 2:
        path = parts.at(1)
    if parts.length() >= 3:
        version = parts.at(2)

    [method, path, version]

# Parse header line: "Content-Type: application/json"
fn parse_header(line: text) -> list:
    var name = ""
    var value = ""

    var colon_idx = line.index_of(":")
    if colon_idx > 0:
        name = line.substring(0, colon_idx).trim().to_lower()
        var rest_start = colon_idx + 1
        value = line.substring(rest_start, line.length()).trim()

    [name, value]

# Extract query string from path: "/api/users?page=1&limit=10"
fn extract_query_string(path: text) -> list:
    var clean_path = path
    var query = ""

    var question_idx = path.index_of("?")
    if question_idx >= 0:
        clean_path = path.substring(0, question_idx)
        var query_start = question_idx + 1
        query = path.substring(query_start, path.length())

    [clean_path, query]

# Parse query parameters: "page=1&limit=10&sort=name"
# Returns list of [key, value] pairs
fn parse_query_params(query: text) -> list:
    var params = []

    if query.length() == 0:
        return params

    var pairs = query.split("&")
    var i = 0
    while i < pairs.length():
        var pair = pairs.at(i)
        var eq_idx = pair.index_of("=")

        if eq_idx > 0:
            var key = pair.substring(0, eq_idx)
            var vstart = eq_idx + 1
            var value = pair.substring(vstart, pair.length())
            var decoded_key = url_decode(key)
            var decoded_value = url_decode(value)
            params.append([decoded_key, decoded_value])

        i = i + 1

    params

# URL decode: "%20" -> " "
fn url_decode(encoded: text) -> text:
    var result = encoded
    result = result.replace("%20", " ")
    result = result.replace("%21", "!")
    result = result.replace("%22", "\"")
    result = result.replace("%23", "#")
    result = result.replace("%24", "$")
    result = result.replace("%25", "%")
    result = result.replace("%26", "&")
    result = result.replace("%27", "'")
    result = result.replace("%28", "(")
    result = result.replace("%29", ")")
    result = result.replace("%2B", "+")
    result = result.replace("%2C", ",")
    result = result.replace("%2F", "/")
    result = result.replace("%3A", ":")
    result = result.replace("%3B", ";")
    result = result.replace("%3D", "=")
    result = result.replace("%3F", "?")
    result = result.replace("%40", "@")
    result

# URL encode: " " -> "%20"
fn url_encode(decoded: text) -> text:
    var result = decoded
    result = result.replace("%", "%25")
    result = result.replace(" ", "%20")
    result = result.replace("!", "%21")
    result = result.replace("\"", "%22")
    result = result.replace("#", "%23")
    result = result.replace("$", "%24")
    result = result.replace("&", "%26")
    result = result.replace("'", "%27")
    result = result.replace("(", "%28")
    result = result.replace(")", "%29")
    result = result.replace("+", "%2B")
    result = result.replace(",", "%2C")
    result = result.replace("/", "%2F")
    result = result.replace(":", "%3A")
    result = result.replace(";", "%3B")
    result = result.replace("=", "%3D")
    result = result.replace("?", "%3F")
    result = result.replace("@", "%40")
    result

# =============================================================================
# Request Validation
# =============================================================================

# Validate HTTP method
fn is_valid_method(method: text) -> bool:
    var valid = false

    if method == "GET":
        valid = true
    if method == "POST":
        valid = true
    if method == "PUT":
        valid = true
    if method == "DELETE":
        valid = true
    if method == "PATCH":
        valid = true
    if method == "HEAD":
        valid = true
    if method == "OPTIONS":
        valid = true
    if method == "TRACE":
        valid = true
    if method == "CONNECT":
        valid = true

    valid

# Validate Content-Type for method
fn requires_content_type(method: text) -> bool:
    var needs_content = false

    if method == "POST":
        needs_content = true
    if method == "PUT":
        needs_content = true
    if method == "PATCH":
        needs_content = true

    needs_content

# =============================================================================
# Multipart Form Data Parsing
# =============================================================================

# Parse multipart boundary from Content-Type header
fn parse_multipart_boundary(content_type: text) -> text:
    var boundary = ""
    var boundary_prefix = "boundary="
    var idx = content_type.index_of(boundary_prefix)

    if idx >= 0:
        var start = idx + boundary_prefix.length()
        boundary = content_type.substring(start, content_type.length())

    boundary

# Parse form field from multipart part
fn parse_form_field(part: text) -> list:
    var name = ""
    var value = ""

    var lines = part.split("\r\n")
    var in_headers = true
    var body_lines = []

    var i = 0
    while i < lines.length():
        var line = lines.at(i)

        if in_headers:
            if line.length() == 0:
                in_headers = false

            var has_disposition = line.starts_with("Content-Disposition:")
            if has_disposition:
                var name_idx = line.index_of("name=\"")
                if name_idx >= 0:
                    var name_start = name_idx + 6
                    var name_end = line.index_of("\"", name_start)
                    if name_end > name_start:
                        name = line.substring(name_start, name_end)

        if in_headers == false:
            if line.length() > 0:
                body_lines.append(line)

        i = i + 1

    value = body_lines.join("\n")
    [name, value]

# =============================================================================
# Cookie Handling
# =============================================================================

# Parse cookie header: "session=abc123; theme=dark"
fn parse_cookies(cookie_header: text) -> list:
    var cookies = []

    if cookie_header.length() == 0:
        return cookies

    var pairs = cookie_header.split(";")
    var i = 0
    while i < pairs.length():
        var pair = pairs.at(i).trim()
        var eq_idx = pair.index_of("=")

        if eq_idx > 0:
            var name = pair.substring(0, eq_idx)
            var vstart = eq_idx + 1
            var value = pair.substring(vstart, pair.length())
            cookies.append([name, value])

        i = i + 1

    cookies

# Create Set-Cookie header value
fn create_cookie(name: text, value: text, max_age: i64, path: text, http_only: bool) -> text:
    var cookie = "{name}={value}"

    if max_age > 0:
        cookie = cookie + "; Max-Age={max_age}"

    if path.length() > 0:
        cookie = cookie + "; Path={path}"

    if http_only:
        cookie = cookie + "; HttpOnly"

    cookie

# =============================================================================
# Session Management
# =============================================================================

# Generate session ID (simple implementation)
fn generate_session_id(timestamp: i64, random_seed: i64) -> text:
    var combined = timestamp * 1000 + random_seed
    var id_str = combined.to_string()
    "session_{id_str}"

# Create session: [id, data, expires]
fn create_session(session_id: text, expires: i64) -> list:
    var data = []
    [session_id, data, expires]

# Add data to session
fn session_add_data(session: list, key: text, value: text) -> list:
    var session_id = session.at(0)
    var data = session.at(1)
    var expires = session.at(2)

    var new_data = data
    new_data.append([key, value])

    [session_id, new_data, expires]

# Get data from session
fn session_get_data(session: list, key: text) -> text:
    var data = session.at(1)
    var result = ""

    var i = 0
    while i < data.length():
        var pair = data.at(i)
        var data_key = pair.at(0)
        var data_value = pair.at(1)

        if data_key == key:
            result = data_value
            break

        i = i + 1

    result

# Check if session is expired
fn is_session_expired(session: list, current_time: i64) -> bool:
    var expires = session.at(2)
    current_time >= expires

# =============================================================================
# Authentication Utilities
# =============================================================================

# Parse Basic Auth header: "Basic dXNlcjpwYXNz"
fn parse_basic_auth(auth_header: text) -> list:
    var username = ""
    var password = ""

    var basic_prefix = "Basic "
    if auth_header.starts_with(basic_prefix):
        var encoded_start = basic_prefix.length()
        var encoded = auth_header.substring(encoded_start, auth_header.length())
        var decoded = base64_decode_simple(encoded)
        var colon_idx = decoded.index_of(":")

        if colon_idx > 0:
            username = decoded.substring(0, colon_idx)
            var pass_start = colon_idx + 1
            password = decoded.substring(pass_start, decoded.length())


    [username, password]

# Parse Bearer token: "Bearer abc123xyz"
fn parse_bearer_token(auth_header: text) -> text:
    var token = ""

    var bearer_prefix = "Bearer "
    if auth_header.starts_with(bearer_prefix):
        var token_start = bearer_prefix.length()
        token = auth_header.substring(token_start, auth_header.length())

    token

# Simple base64 decode (limited character set)
fn base64_decode_simple(encoded: text) -> text:
    var result = encoded
    result
