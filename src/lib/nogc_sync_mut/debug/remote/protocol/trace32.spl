# Trace32 Protocol Client
# Communicates with Lauterbach Trace32 via t32rem CLI.
# Returns parsed data structs (VarInfo, FrameInfo, etc.) matching GdbMiClient.

use app.io.{shell, ProcessResult}
use app.debug.coordinator.{VarInfo, FrameInfo, LocationInfo}
use app.debug.remote.types.{DebugConfig, DebugError}

# Trace32 client controlling a Trace32 PowerView session via t32rem
class Trace32Client:
    host: text
    port: i32
    t32rem_path: text
    connected: bool
    program: text
    bp_counter: i32

impl Trace32Client:
    # Connect to an existing Trace32 PowerView session
    static fn connect(config: DebugConfig) -> Result<Trace32Client, text>:
        val t32rem = Trace32Client.find_t32rem()
        if t32rem.len() == 0:
            return Err("t32rem not found - install Trace32 or set T32_PATH")

        var client = Trace32Client(
            host: config.host,
            port: config.port,
            t32rem_path: t32rem,
            connected: false,
            program: config.program,
            bp_counter: 0
        )

        # Ping Trace32 to verify connectivity
        val ping = client.run_command("PING")
        match ping:
            Ok(_):
                client.connected = true
                Ok(client)
            Err(e):
                Err("Trace32 connection failed: {e}")

    # Find t32rem binary
    static fn find_t32rem() -> text:
        # Check T32_PATH env var first
        val env_check = shell("echo $T32_PATH")
        val t32_path = env_check.stdout.trim()
        if t32_path.len() > 0:
            val candidate = "{t32_path}/bin/pc_linux64/t32rem"
            val exists = shell("test -x {candidate} && echo yes")
            if exists.stdout.trim() == "yes":
                return candidate

        # Try system PATH
        val which = shell("which t32rem 2>/dev/null")
        if which.exit_code == 0:
            return which.stdout.trim()

        ""

    # Execute a t32rem command and return raw output
    fn run_command(cmd: text) -> Result<text, text>:
        val full_cmd = "{self.t32rem_path} {self.host}:{self.port} {cmd}"
        val result = shell(full_cmd)
        if result.exit_code != 0:
            return Err("t32rem error: {result.stderr}")
        Ok(result.stdout.trim())

    # --- Execution Control ---

    fn halt() -> Result<text, text>:
        self.run_command("Break")

    fn resume() -> Result<text, text>:
        self.run_command("Go")

    fn single_step() -> Result<text, text>:
        self.run_command("Step")

    fn step_over() -> Result<text, text>:
        self.run_command("Step.Over")

    fn step_out() -> Result<text, text>:
        self.run_command("Step.Out")

    # --- Variable Inspection (returns parsed structs) ---

    fn read_locals() -> Result<[VarInfo], text>:
        val raw = self.run_command("Var.View %Local")?
        Ok(Trace32Parser.parse_variables(raw))

    fn read_arguments() -> Result<[VarInfo], text>:
        val raw = self.run_command("Var.View %Argument")?
        Ok(Trace32Parser.parse_variables(raw))

    fn read_globals() -> Result<[VarInfo], text>:
        val raw = self.run_command("Var.View %Global")?
        Ok(Trace32Parser.parse_variables(raw))

    fn evaluate(expr: text) -> Result<text, text>:
        self.run_command("Var.VALUE({expr})")

    # --- Stack Inspection (returns parsed structs) ---

    fn stack_trace() -> Result<[FrameInfo], text>:
        val raw = self.run_command("Frame.View /Caller")?
        Ok(Trace32Parser.parse_stack_trace(raw))

    fn stack_depth() -> Result<i32, text>:
        val frames = self.stack_trace()?
        Ok(frames.len())

    fn select_frame(level: i32) -> Result<text, text>:
        self.run_command("Frame.Select {level}")

    fn current_location() -> Result<LocationInfo, text>:
        val frames = self.stack_trace()?
        if frames.len() > 0:
            val f = frames[0]
            Ok(LocationInfo.at(f.file, f.line, f.function_name))
        else:
            Err("no frames available")

    # --- Memory Access (returns parsed data) ---

    fn read_memory(addr: i64, size: i32) -> Result<[i32], text>:
        val hex_addr = Trace32Parser.to_hex(addr)
        val raw = self.run_command("Data.dump {hex_addr}--+{size} /Byte")?
        Ok(Trace32Parser.parse_memory_dump(raw))

    fn write_memory(addr: i64, data: [i32]) -> Result<text, text>:
        val hex_addr = Trace32Parser.to_hex(addr)
        var hex_bytes: [text] = []
        for b in data:
            hex_bytes.push(Trace32Parser.byte_to_hex(b))
        val hex_str = hex_bytes.join(" ")
        self.run_command("Data.Set {hex_addr} %Byte {hex_str}")

    # --- Register Access (returns parsed data) ---

    fn read_register(name: text) -> Result<i64, text>:
        val raw = self.run_command("Register({name})")?
        Trace32Parser.parse_register_value(raw)

    fn read_all_registers() -> Result<Dict<text, i64>, text>:
        val raw = self.run_command("Register /All")?
        Ok(Trace32Parser.parse_register_list(raw))

    fn write_register(name: text, value: i64) -> Result<text, text>:
        val hex_val = Trace32Parser.to_hex(value)
        self.run_command("Register.Set {name} {hex_val}")

    # --- Breakpoint Management ---

    me set_breakpoint(location: text) -> Result<i32, text>:
        self.run_command("Break.Set {location}")?
        self.bp_counter = self.bp_counter + 1
        Ok(self.bp_counter)

    fn set_breakpoint_at_addr(addr: i64) -> Result<i32, text>:
        val hex_addr = Trace32Parser.to_hex(addr)
        self.set_breakpoint(hex_addr)

    fn delete_breakpoint(id: i32) -> Result<text, text>:
        self.run_command("Break.Delete {id}")

    fn set_watchpoint(expr: text, access: text) -> Result<i32, text>:
        val flag = match access:
            "read": "/Read"
            "write": "/Write"
            _: "/ReadWrite"
        self.run_command("Break.Set {expr} {flag}")?
        self.bp_counter = self.bp_counter + 1
        Ok(self.bp_counter)

    # --- Trace32-Unique Operations ---

    # Capture trace data for a given duration
    fn trace_capture(duration_ms: i32) -> Result<text, text>:
        self.run_command("Trace.Init")?
        self.run_command("Trace.Method Analyzer")?
        self.run_command("Trace.Size 8192.")?
        self.run_command("Trace.Arm")?
        self.run_command("Go")?
        shell("sleep 0.{duration_ms}")
        self.run_command("Break")?
        self.run_command("Trace.List")

    # Collect code coverage data for a module
    fn coverage_collect(module: text) -> Result<text, text>:
        self.run_command("COVerage.Reset")?
        self.run_command("COVerage.Add {module}")?
        self.run_command("Go")?
        shell("sleep 1")
        self.run_command("Break")?
        self.run_command("COVerage.ListFunc")

    # Program flash memory with an ELF binary
    fn flash_program(elf_path: text) -> Result<text, text>:
        self.run_command("SYStem.Up")?
        self.run_command("FLASH.ReProgram ALL")?
        self.run_command("Data.LOAD.Elf {elf_path}")?
        self.run_command("FLASH.ReProgram OFF")?
        Ok("flashed {elf_path}")

    # System reset via Trace32 (native, rank 0)
    fn system_reset() -> Result<text, text>:
        self.run_command("SYStem.Up")

    # --- Cleanup ---

    fn disconnect():
        if self.connected:
            self.connected = false


# Parser for Trace32 output formats
# Converts t32rem text output into typed data structures
class Trace32Parser:

    # Parse variable list output into [VarInfo]
    # Format: "name  type  value" (whitespace-separated columns)
    static fn parse_variables(raw: text) -> [VarInfo]:
        var result: [VarInfo] = []
        val lines = raw.split("\n")
        for line in lines:
            val trimmed = line.trim()
            if trimmed.len() == 0:
                continue
            # Skip header lines
            if trimmed.starts_with("---"):
                continue
            if trimmed.starts_with("name"):
                continue

            # Parse: "varname  type  value"
            val parts = Trace32Parser.split_whitespace(trimmed)
            if parts.len() >= 3:
                val name = parts[0]
                val type_name = parts[1]
                val value = parts[2]
                result.push(VarInfo.of(name, value, type_name))
            else if parts.len() == 2:
                result.push(VarInfo.of(parts[0], parts[1], ""))
        result

    # Parse stack trace output into [FrameInfo]
    # Format: "  #N  addr  function  file:line"
    static fn parse_stack_trace(raw: text) -> [FrameInfo]:
        var result: [FrameInfo] = []
        val lines = raw.split("\n")
        var idx = 0
        for line in lines:
            val trimmed = line.trim()
            if trimmed.len() == 0:
                continue
            if trimmed.starts_with("---"):
                continue

            val parts = Trace32Parser.split_whitespace(trimmed)
            if parts.len() >= 3:
                # Try to parse "#N" prefix
                var func_name = parts[1]
                var file = ""
                var line_num = 0

                if parts.len() >= 4:
                    func_name = parts[2]
                    # Parse "file:line" from last part
                    val loc = parts[3]
                    val colon_parts = loc.split(":")
                    if colon_parts.len() >= 2:
                        file = colon_parts[0]
                        line_num = colon_parts[1].parse_int() ?? 0
                    else:
                        file = loc

                result.push(FrameInfo.of(idx, func_name, file, line_num))
                idx = idx + 1
        result

    # Parse memory dump output into [i32] bytes
    # Format: "ADDR: XX XX XX XX ..."
    static fn parse_memory_dump(raw: text) -> [i32]:
        var result: [i32] = []
        val lines = raw.split("\n")
        for line in lines:
            val trimmed = line.trim()
            if trimmed.len() == 0:
                continue
            # Skip address prefix (before colon)
            val colon_idx = trimmed.index_of(":")
            var data_part = trimmed
            if colon_idx != nil:
                val after = colon_idx + 1
                if after < trimmed.len():
                    data_part = trimmed.slice(after, trimmed.len())

            val parts = Trace32Parser.split_whitespace(data_part.trim())
            for part in parts:
                if part.len() == 2:
                    val byte_val = Trace32Parser.parse_hex_byte(part)
                    if byte_val >= 0:
                        result.push(byte_val)
        result

    # Parse a single register value from output
    # Format: "0xHEXVALUE" or decimal
    static fn parse_register_value(raw: text) -> Result<i64, text>:
        val trimmed = raw.trim()
        if trimmed.starts_with("0x") or trimmed.starts_with("0X"):
            val hex_str = trimmed.slice(2, trimmed.len())
            var value: i64 = 0
            for ch in hex_str:
                val digit = Trace32Parser.hex_char_to_int(ch)
                if digit < 0:
                    return Err("invalid hex digit: {ch}")
                value = (value * 16) + digit
            Ok(value)
        else:
            val parsed = trimmed.parse_int()
            if parsed != nil:
                Ok(parsed ?? 0)
            else:
                Err("cannot parse register value: {trimmed}")

    # Parse "Register /All" output into Dict<text, i64>
    # Format: "R0=0x00000000  R1=0x12345678 ..."
    static fn parse_register_list(raw: text) -> Dict<text, i64>:
        var result: Dict<text, i64> = {}
        val lines = raw.split("\n")
        for line in lines:
            val trimmed = line.trim()
            if trimmed.len() == 0:
                continue
            val tokens = Trace32Parser.split_whitespace(trimmed)
            for token in tokens:
                val eq_parts = token.split("=")
                if eq_parts.len() == 2:
                    val name = eq_parts[0]
                    val raw_val = eq_parts[1]
                    val parsed = Trace32Parser.parse_register_value(raw_val)
                    match parsed:
                        Ok(v): result[name] = v
                        Err(_): pass
        result

    # --- Hex utility methods ---

    static fn to_hex(value: i64) -> text:
        if value == 0:
            return "0x0"
        var result = ""
        var v = value
        while v > 0:
            val digit = v % 16
            val ch = Trace32Parser.int_to_hex_char(digit)
            result = "{ch}{result}"
            v = v / 16
        "0x{result}"

    static fn byte_to_hex(value: i32) -> text:
        val hi = (value / 16) % 16
        val lo = value % 16
        val h = Trace32Parser.int_to_hex_char(hi)
        val l = Trace32Parser.int_to_hex_char(lo)
        "{h}{l}"

    static fn parse_hex_byte(hex: text) -> i32:
        if hex.len() != 2:
            return -1
        val hi = Trace32Parser.hex_char_to_int(hex[0])
        val lo = Trace32Parser.hex_char_to_int(hex[1])
        if hi < 0 or lo < 0:
            return -1
        (hi * 16) + lo

    static fn hex_char_to_int(ch: text) -> i32:
        match ch:
            "0": 0
            "1": 1
            "2": 2
            "3": 3
            "4": 4
            "5": 5
            "6": 6
            "7": 7
            "8": 8
            "9": 9
            "a": 10
            "b": 11
            "c": 12
            "d": 13
            "e": 14
            "f": 15
            "A": 10
            "B": 11
            "C": 12
            "D": 13
            "E": 14
            "F": 15
            _: -1

    static fn int_to_hex_char(value: i64) -> text:
        match value:
            0: "0"
            1: "1"
            2: "2"
            3: "3"
            4: "4"
            5: "5"
            6: "6"
            7: "7"
            8: "8"
            9: "9"
            10: "a"
            11: "b"
            12: "c"
            13: "d"
            14: "e"
            15: "f"
            _: "?"

    # Split text on whitespace (multiple spaces treated as one delimiter)
    static fn split_whitespace(input: text) -> [text]:
        var result: [text] = []
        var current = ""
        var in_word = false
        for ch in input:
            if ch == " " or ch == "\t":
                if in_word:
                    result.push(current)
                    current = ""
                    in_word = false
            else:
                current = current + ch
                in_word = true
        if in_word:
            result.push(current)
        result
