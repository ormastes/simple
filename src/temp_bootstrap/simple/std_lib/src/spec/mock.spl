# Mock Library - Stubs, Spies, and Call Verification
# Provides test double functionality for isolation and verification

# Call information - tracks each call to a mock
export class CallInfo:
    args: List[Any]
    return_value: Any
    threw_error: Bool
    error_message: String

    fn new(args: List[Any], return_value: Any) -> CallInfo:
        return CallInfo {
            args: args,
            return_value: return_value,
            threw_error: false,
            error_message: ""
        }

    fn with_error(args: List[Any], error_msg: String) -> CallInfo:
        return CallInfo {
            args: args,
            return_value: nil,
            threw_error: true,
            error_message: error_msg
        }

# Mock object - tracks calls and can return configured values
export class Mock[T]:
    call_history: List[CallInfo]
    return_value: T
    should_throw: Bool
    throw_message: String

    fn new(return_value: T) -> Mock[T]:
        return Mock {
            call_history: [],
            return_value: return_value,
            should_throw: false,
            throw_message: ""
        }

    # Record a call with arguments
    fn call(self, args: List[Any]) -> T:
        let call_info = CallInfo.new(args, self.return_value)
        self.call_history.push(call_info)

        if self.should_throw:
            call_info.threw_error = true
            call_info.error_message = self.throw_message
            panic(self.throw_message)
        else:
            return self.return_value

    # Set return value
    fn returns(mut self, value: T) -> Mock[T]:
        self.return_value = value
        return self

    # Configure to throw error on next call
    fn throws(mut self, message: String) -> Mock[T]:
        self.should_throw = true
        self.throw_message = message
        return self

    # Clear throw configuration (restore normal behavior)
    fn clear_throws(mut self) -> Mock[T]:
        self.should_throw = false
        self.throw_message = ""
        return self

    # Get all calls made to this mock
    fn calls(self) -> List[CallInfo]:
        return self.call_history

    # Check if mock was called
    fn called(self) -> Bool:
        return self.call_history.len() > 0

    # Get number of times called
    fn call_count(self) -> Int:
        return self.call_history.len()

    # Get last call arguments
    fn last_call_args(self) -> List[Any]:
        if self.call_history.is_empty():
            return []
        else:
            return self.call_history[self.call_history.len() - 1].args

    # Get call by index
    fn call_at(self, index: Int) -> CallInfo:
        return self.call_history[index]

    # Check if mock was called with specific arguments
    fn called_with(self, expected_args: List[Any]) -> Bool:
        for call in self.call_history:
            if call.args.len() == expected_args.len():
                let match = true
                for i in 0..(call.args.len()):
                    if call.args[i] != expected_args[i]:
                        match = false
                        break
                if match:
                    return true
        return false

    # Clear call history
    fn reset(mut self):
        self.call_history = []

# Spy - wraps real function and tracks calls
export class Spy[T]:
    real_fn: Fn(List[Any]) -> T
    call_history: List[CallInfo]

    fn new(real_fn: Fn(List[Any]) -> T) -> Spy[T]:
        return Spy {
            real_fn: real_fn,
            call_history: []
        }

    # Call the real function and track the call
    fn call(self, args: List[Any]) -> T:
        let result = self.real_fn(args)
        let call_info = CallInfo.new(args, result)
        self.call_history.push(call_info)
        return result

    # Get all recorded calls
    fn calls(self) -> List[CallInfo]:
        return self.call_history

    # Check if spy was called
    fn called(self) -> Bool:
        return self.call_history.len() > 0

    # Get number of times called
    fn call_count(self) -> Int:
        return self.call_history.len()

    # Get last call arguments
    fn last_call_args(self) -> List[Any]:
        if self.call_history.is_empty():
            return []
        else:
            return self.call_history[self.call_history.len() - 1].args

    # Get call by index
    fn call_at(self, index: Int) -> CallInfo:
        return self.call_history[index]

    # Check if spy was called with specific arguments
    fn called_with(self, expected_args: List[Any]) -> Bool:
        for call in self.call_history:
            if call.args.len() == expected_args.len():
                let match = true
                for i in 0..(call.args.len()):
                    if call.args[i] != expected_args[i]:
                        match = false
                        break
                if match:
                    return true
        return false

    # Clear call history
    fn reset(mut self):
        self.call_history = []

# Stub - simple replacement with no tracking
export class Stub[T]:
    return_value: T

    fn new(return_value: T) -> Stub[T]:
        return Stub { return_value: return_value }

    fn call(self) -> T:
        return self.return_value

    fn returns(mut self, value: T) -> Stub[T]:
        self.return_value = value
        return self

# Call verifier - assertions about mock calls
export class CallVerifier:
    fn verify_called(call_count: Int, expected: Int, mock_name: String):
        if call_count != expected:
            panic("Expected ${mock_name} to be called ${expected} times, but was called ${call_count} times")

    fn verify_called_with(call_args: List[Any], expected_args: List[Any], mock_name: String):
        if call_args.len() != expected_args.len():
            panic("Expected ${mock_name} to be called with ${expected_args.len()} args, got ${call_args.len()}")

        for i in 0..(call_args.len()):
            if call_args[i] != expected_args[i]:
                panic("Expected arg ${i} to be ${expected_args[i]}, got ${call_args[i]}")

    fn verify_not_called(call_count: Int, mock_name: String):
        if call_count > 0:
            panic("Expected ${mock_name} to not be called, but was called ${call_count} times")

    fn verify_called_at_least(call_count: Int, min_times: Int, mock_name: String):
        if call_count < min_times:
            panic("Expected ${mock_name} to be called at least ${min_times} times, but was called ${call_count} times")
