# x86 Global Descriptor Table (GDT)
#
# Sets up a flat memory model with code and data segments
# covering the entire 4GB address space.
#
# Segment Layout:
#   0x00 - Null descriptor (required)
#   0x08 - Code segment (ring 0)
#   0x10 - Data segment (ring 0)
#   0x18 - Code segment (ring 3, user mode)
#   0x20 - Data segment (ring 3, user mode)
#   0x28 - TSS descriptor

export GdtEntry, GdtDescriptor, gdt_init, gdt_load
export KERNEL_CODE_SELECTOR, KERNEL_DATA_SELECTOR
export USER_CODE_SELECTOR, USER_DATA_SELECTOR

# Segment selector values
val KERNEL_CODE_SELECTOR: u16 = 0x08
val KERNEL_DATA_SELECTOR: u16 = 0x10
val USER_CODE_SELECTOR: u16 = 0x18 | 3  # RPL = 3
val USER_DATA_SELECTOR: u16 = 0x20 | 3  # RPL = 3
val TSS_SELECTOR: u16 = 0x28

# GDT access byte flags
val GDT_ACCESS_PRESENT: u8 = 1 << 7     # Segment is present
val GDT_ACCESS_RING0: u8 = 0 << 5       # Ring 0 (kernel)
val GDT_ACCESS_RING3: u8 = 3 << 5       # Ring 3 (user)
val GDT_ACCESS_CODE_DATA: u8 = 1 << 4   # Code/data segment (not system)
val GDT_ACCESS_EXEC: u8 = 1 << 3        # Executable (code segment)
val GDT_ACCESS_DIRECTION: u8 = 1 << 2   # Direction/conforming
val GDT_ACCESS_RW: u8 = 1 << 1          # Readable (code) / Writable (data)
val GDT_ACCESS_ACCESSED: u8 = 1 << 0    # Accessed bit

# GDT flags (high nibble of granularity byte)
val GDT_FLAG_GRANULARITY: u8 = 1 << 7   # 4KB granularity (vs 1 byte)
val GDT_FLAG_32BIT: u8 = 1 << 6         # 32-bit protected mode
val GDT_FLAG_64BIT: u8 = 1 << 5         # 64-bit mode (long mode)

# GDT entry structure (8 bytes)
@repr("C")
@packed
struct GdtEntry:
    limit_low: u16       # Segment limit (bits 0-15)
    base_low: u16        # Base address (bits 0-15)
    base_middle: u8      # Base address (bits 16-23)
    access: u8           # Access flags
    granularity: u8      # Flags + limit (bits 16-19)
    base_high: u8        # Base address (bits 24-31)

impl GdtEntry:
    # Create a null descriptor
    static fn null() -> GdtEntry:
        GdtEntry(
            limit_low: 0,
            base_low: 0,
            base_middle: 0,
            access: 0,
            granularity: 0,
            base_high: 0
        )

    # Create a code/data segment descriptor
    static fn segment(base: u32, limit: u32, access: u8, flags: u8) -> GdtEntry:
        GdtEntry(
            limit_low: (limit & 0xFFFF) as u16,
            base_low: (base & 0xFFFF) as u16,
            base_middle: ((base >> 16) & 0xFF) as u8,
            access: access,
            granularity: ((limit >> 16) & 0x0F) as u8 | flags,
            base_high: ((base >> 24) & 0xFF) as u8
        )

    # Create a kernel code segment (flat, 4GB)
    static fn kernel_code() -> GdtEntry:
        val access = GDT_ACCESS_PRESENT | GDT_ACCESS_RING0 | GDT_ACCESS_CODE_DATA
                   | GDT_ACCESS_EXEC | GDT_ACCESS_RW
        val flags = GDT_FLAG_GRANULARITY | GDT_FLAG_32BIT
        GdtEntry.segment(0, 0xFFFFF, access, flags)

    # Create a kernel data segment (flat, 4GB)
    static fn kernel_data() -> GdtEntry:
        val access = GDT_ACCESS_PRESENT | GDT_ACCESS_RING0 | GDT_ACCESS_CODE_DATA
                   | GDT_ACCESS_RW
        val flags = GDT_FLAG_GRANULARITY | GDT_FLAG_32BIT
        GdtEntry.segment(0, 0xFFFFF, access, flags)

    # Create a user code segment (flat, 4GB, ring 3)
    static fn user_code() -> GdtEntry:
        val access = GDT_ACCESS_PRESENT | GDT_ACCESS_RING3 | GDT_ACCESS_CODE_DATA
                   | GDT_ACCESS_EXEC | GDT_ACCESS_RW
        val flags = GDT_FLAG_GRANULARITY | GDT_FLAG_32BIT
        GdtEntry.segment(0, 0xFFFFF, access, flags)

    # Create a user data segment (flat, 4GB, ring 3)
    static fn user_data() -> GdtEntry:
        val access = GDT_ACCESS_PRESENT | GDT_ACCESS_RING3 | GDT_ACCESS_CODE_DATA
                   | GDT_ACCESS_RW
        val flags = GDT_FLAG_GRANULARITY | GDT_FLAG_32BIT
        GdtEntry.segment(0, 0xFFFFF, access, flags)

# GDT descriptor (6 bytes) - passed to LGDT instruction
@repr("C")
@packed
struct GdtDescriptor:
    limit: u16           # Size of GDT - 1
    base: u32            # Linear address of GDT

# The actual GDT (6 entries)
@align(8)
var gdt: [GdtEntry; 6] = [
    GdtEntry.null(),      # 0x00: Null descriptor
    GdtEntry.null(),      # 0x08: Kernel code (filled in gdt_init)
    GdtEntry.null(),      # 0x10: Kernel data
    GdtEntry.null(),      # 0x18: User code
    GdtEntry.null(),      # 0x20: User data
    GdtEntry.null()       # 0x28: TSS (filled when TSS is set up)
]

# GDT descriptor
var gdt_desc: GdtDescriptor = GdtDescriptor(
    limit: 0,
    base: 0
)

# Initialize the GDT
fn gdt_init():
    # Set up segment descriptors
    gdt[1] = GdtEntry.kernel_code()
    gdt[2] = GdtEntry.kernel_data()
    gdt[3] = GdtEntry.user_code()
    gdt[4] = GdtEntry.user_data()

    # Set up GDT descriptor
    gdt_desc.limit = (size_of<[GdtEntry; 6]>() - 1) as u16
    gdt_desc.base = addr_of(gdt) as u32

    # Load GDT
    gdt_load()

# Load GDT and reload segment registers
fn gdt_load():
    asm """
        # Load GDT descriptor
        lgdt [gdt_desc]

        # Reload code segment by far jump
        jmp $KERNEL_CODE_SELECTOR, $.reload_cs
    .reload_cs:
        # Reload data segments
        mov ax, $KERNEL_DATA_SELECTOR
        mov ds, ax
        mov es, ax
        mov fs, ax
        mov gs, ax
        mov ss, ax
    """

# Task State Segment (TSS) structure for hardware task switching
# Used primarily for setting kernel stack on interrupt from user mode
@repr("C")
@packed
struct Tss:
    prev_tss: u32        # Previous TSS link (unused)
    esp0: u32            # Stack pointer for ring 0
    ss0: u32             # Stack segment for ring 0
    esp1: u32            # Stack pointer for ring 1 (unused)
    ss1: u32
    esp2: u32            # Stack pointer for ring 2 (unused)
    ss2: u32
    cr3: u32             # Page directory base
    eip: u32
    eflags: u32
    eax: u32
    ecx: u32
    edx: u32
    ebx: u32
    esp: u32
    ebp: u32
    esi: u32
    edi: u32
    es: u32
    cs: u32
    ss: u32
    ds: u32
    fs: u32
    gs: u32
    ldt: u32
    trap: u16
    iomap_base: u16

# Global TSS instance
var tss: Tss = Tss(
    prev_tss: 0,
    esp0: 0,
    ss0: KERNEL_DATA_SELECTOR as u32,
    esp1: 0, ss1: 0,
    esp2: 0, ss2: 0,
    cr3: 0,
    eip: 0, eflags: 0,
    eax: 0, ecx: 0, edx: 0, ebx: 0,
    esp: 0, ebp: 0, esi: 0, edi: 0,
    es: 0, cs: 0, ss: 0, ds: 0, fs: 0, gs: 0,
    ldt: 0,
    trap: 0,
    iomap_base: size_of<Tss>() as u16
)

# Set the kernel stack for ring 0 (used on interrupts from user mode)
fn tss_set_kernel_stack(stack_top: u32):
    tss.esp0 = stack_top
    tss.ss0 = KERNEL_DATA_SELECTOR as u32

# Initialize and load TSS
fn tss_init(kernel_stack: u32):
    tss_set_kernel_stack(kernel_stack)

    # Create TSS descriptor in GDT
    val tss_addr = addr_of(tss) as u32
    val tss_size = size_of<Tss>() as u32

    # TSS descriptor: present, ring 0, system segment, type = 0x9 (available TSS)
    val access: u8 = 0x89  # Present + DPL 0 + TSS type
    gdt[5] = GdtEntry.segment(tss_addr, tss_size - 1, access, 0)

    # Load TSS
    asm """
        mov ax, $TSS_SELECTOR
        ltr ax
    """
