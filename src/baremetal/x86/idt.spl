# x86 Interrupt Descriptor Table (IDT)
#
# Sets up and loads the Interrupt Descriptor Table for x86 protected mode.
# Handles CPU exceptions and hardware interrupts.
#
# IDT Structure:
#   - 256 entries (vectors 0-255)
#   - Vectors 0-31: CPU exceptions
#   - Vectors 32-255: Hardware/software interrupts
#
# Usage:
#   idt_init()
#   idt_set_handler(32, timer_isr_wrapper)
#   idt_load()

from io import {outb}

export IdtEntry, IdtDescriptor, idt_init, idt_load, idt_set_handler
export KERNEL_CODE_SELECTOR

# Code segment selector (from GDT)
val KERNEL_CODE_SELECTOR: u16 = 0x08

# IDT entry types
val IDT_INTERRUPT_GATE: u8 = 0x8E  # P=1, DPL=0, 32-bit interrupt gate
val IDT_TRAP_GATE: u8 = 0x8F       # P=1, DPL=0, 32-bit trap gate
val IDT_USER_INT: u8 = 0xEE        # P=1, DPL=3, 32-bit interrupt gate (user-callable)

# Maximum interrupt vectors
val IDT_ENTRIES: i64 = 256

# IDT entry structure (8 bytes for 32-bit mode)
@repr("C")
@packed
struct IdtEntry:
    offset_low: u16      # Offset bits 0-15
    selector: u16        # Code segment selector
    zero: u8             # Unused, set to 0
    type_attr: u8        # Type and attributes
    offset_high: u16     # Offset bits 16-31

impl IdtEntry:
    # Create a null (empty) IDT entry
    static fn null() -> IdtEntry:
        IdtEntry(
            offset_low: 0,
            selector: 0,
            zero: 0,
            type_attr: 0,
            offset_high: 0
        )

    # Create an interrupt gate entry
    static fn interrupt_gate(handler: u32, selector: u16, type_attr: u8) -> IdtEntry:
        IdtEntry(
            offset_low: (handler & 0xFFFF) as u16,
            selector: selector,
            zero: 0,
            type_attr: type_attr,
            offset_high: ((handler >> 16) & 0xFFFF) as u16
        )

    # Check if entry is present
    fn is_present() -> bool:
        (self.type_attr & 0x80) != 0

# IDT descriptor (6 bytes) - passed to LIDT instruction
@repr("C")
@packed
struct IdtDescriptor:
    limit: u16           # Size of IDT - 1
    base: u32            # Linear address of IDT

# The actual IDT (256 entries)
@align(8)
var idt: [IdtEntry; IDT_ENTRIES]

# IDT descriptor
var idt_desc: IdtDescriptor = IdtDescriptor(limit: 0, base: 0)

# Default handlers for unhandled interrupts
var default_handlers: [fn(); IDT_ENTRIES]

# Initialize the IDT with default handlers
fn idt_init():
    # Clear all entries
    for i in 0..IDT_ENTRIES:
        idt[i] = IdtEntry.null()

    # Set up exception handlers (vectors 0-31)
    setup_exception_handlers()

    # Set up IDT descriptor
    idt_desc.limit = (size_of<[IdtEntry; IDT_ENTRIES]>() - 1) as u16
    idt_desc.base = addr_of(idt) as u32

# Load the IDT
fn idt_load():
    asm """
        lidt [idt_desc]
    """

# Set a handler for a specific interrupt vector
fn idt_set_handler(vector: i64, handler: u32):
    if vector < 0 or vector >= IDT_ENTRIES:
        return
    idt[vector] = IdtEntry.interrupt_gate(
        handler,
        KERNEL_CODE_SELECTOR,
        IDT_INTERRUPT_GATE
    )

# Set a user-callable handler (can be invoked from ring 3)
fn idt_set_user_handler(vector: i64, handler: u32):
    if vector < 0 or vector >= IDT_ENTRIES:
        return
    idt[vector] = IdtEntry.interrupt_gate(
        handler,
        KERNEL_CODE_SELECTOR,
        IDT_USER_INT
    )

# Setup exception handlers (vectors 0-31)
fn setup_exception_handlers():
    # These would be set to actual handler addresses
    # For now, they point to a generic exception handler
    #
    # idt_set_handler(0, exception_divide_error)
    # idt_set_handler(1, exception_debug)
    # idt_set_handler(2, exception_nmi)
    # idt_set_handler(3, exception_breakpoint)
    # ... etc
    pass

# Interrupt stack frame (pushed by CPU)
@repr("C")
struct InterruptFrame:
    # Pushed by interrupt stub
    gs: u32
    fs: u32
    es: u32
    ds: u32
    edi: u32
    esi: u32
    ebp: u32
    esp_: u32   # Placeholder (pusha pushes esp but it's not useful)
    ebx: u32
    edx: u32
    ecx: u32
    eax: u32

    # Pushed by stub or CPU
    int_no: u32
    error_code: u32

    # Pushed by CPU
    eip: u32
    cs: u32
    eflags: u32
    # These are only present on privilege level change
    user_esp: u32
    user_ss: u32

# Generic exception handler (called from assembly stubs)
fn generic_exception_handler(frame: ptr<InterruptFrame>):
    val int_no = frame.int_no
    val error = frame.error_code

    # Handle specific exceptions
    match int_no:
        case 0:
            panic("Division by zero")
        case 6:
            panic("Invalid opcode at EIP={frame.eip:#x}")
        case 8:
            panic("Double fault!")
        case 13:
            panic("General protection fault: error={error:#x}")
        case 14:
            # Page fault - get faulting address from CR2
            var cr2: u32 = 0
            asm """
                mov eax, cr2
                mov {cr2}, eax
            """
            panic("Page fault at {cr2:#x}, error={error:#x}")
        case _:
            panic("Unhandled exception {int_no}")

# PIC (8259) constants
val PIC1: u16 = 0x20         # Master PIC command port
val PIC1_DATA: u16 = 0x21    # Master PIC data port
val PIC2: u16 = 0xA0         # Slave PIC command port
val PIC2_DATA: u16 = 0xA1    # Slave PIC data port
val PIC_EOI: u8 = 0x20       # End of interrupt

# Remap the PIC to vectors 32-47
# (Avoids conflict with CPU exceptions 0-31)
fn pic_remap():
    # Save masks
    val mask1 = inb(PIC1_DATA)
    val mask2 = inb(PIC2_DATA)

    # Start initialization sequence
    outb(PIC1, 0x11)  # ICW1: Initialize + ICW4 needed
    outb(PIC2, 0x11)
    io_wait()

    # Set vector offsets
    outb(PIC1_DATA, 0x20)  # ICW2: Master PIC vector offset (32)
    outb(PIC2_DATA, 0x28)  # ICW2: Slave PIC vector offset (40)
    io_wait()

    # Configure cascading
    outb(PIC1_DATA, 0x04)  # ICW3: Tell master about slave at IRQ2
    outb(PIC2_DATA, 0x02)  # ICW3: Tell slave its cascade identity
    io_wait()

    # Set 8086 mode
    outb(PIC1_DATA, 0x01)  # ICW4: 8086 mode
    outb(PIC2_DATA, 0x01)
    io_wait()

    # Restore masks
    outb(PIC1_DATA, mask1)
    outb(PIC2_DATA, mask2)

# Send end-of-interrupt signal
fn pic_send_eoi(irq: i64):
    if irq >= 8:
        outb(PIC2, PIC_EOI)  # Slave PIC
    outb(PIC1, PIC_EOI)      # Master PIC

# I/O wait (short delay)
fn io_wait():
    outb(0x80, 0)

# Read byte from port
fn inb(port: u16) -> u8:
    var result: u8 = 0
    asm """
        mov dx, {port}
        in al, dx
        mov {result}, al
    """
    result

# Panic function (halts system)
fn panic(message: text):
    # Disable interrupts
    asm """
        cli
    """

    # Print message (if serial available)
    # serial_println("PANIC: {message}")

    # Halt
    loop:
        asm """
            hlt
        """
