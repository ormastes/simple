# StringIntern SMF Section Support
#
# Implements the StringIntern section (type 0x10) for SMF files.
# Stores interned print strings with handles and format metadata.
#
# This module provides:
# - StringInternEntry: Individual interned string entry
# - StringInternTable: Collection of interned strings
# - Writer/Reader for SMF StringIntern section

export StringInternEntry, StringInternTable, FormatType
export write_string_intern_section, read_string_intern_section

# Re-export FormatType from system_api
from baremetal.system_api import FormatType

# ============================================================================
# StringIntern Entry Structure
# ============================================================================

# Represents a single interned string entry
struct StringInternEntry:
    handle: u32               # Unique handle ID
    text: text                # The format string (with {} placeholders)
    format_types: [FormatType] # Type of each placeholder
    source_file: text?        # Optional: source file where string originated
    source_line: u32          # Optional: source line number

impl StringInternEntry:
    # Create a new entry
    static fn new(handle: u32, format_text: text, types: [FormatType]) -> StringInternEntry:
        StringInternEntry(
            handle: handle,
            text: format_text,
            format_types: types,
            source_file: None,
            source_line: 0
        )

    # Create entry with source location
    static fn with_source(handle: u32, format_text: text, types: [FormatType], file: text, line: u32) -> StringInternEntry:
        StringInternEntry(
            handle: handle,
            text: format_text,
            format_types: types,
            source_file: Some(file),
            source_line: line
        )

    # Get number of format parameters
    fn param_count() -> u32:
        self.format_types.len() as u32

    # Check if entry has parameters
    fn has_params() -> bool:
        self.format_types.len() > 0

# ============================================================================
# StringIntern Table
# ============================================================================

# Collection of interned strings for a module
class StringInternTable:
    entries: [StringInternEntry]
    handle_map: Dict<u32, u32>   # handle -> index in entries
    text_map: Dict<text, u32>     # text -> handle (for dedup)
    next_handle: u32

impl StringInternTable:
    # Create empty table
    static fn new() -> StringInternTable:
        StringInternTable(
            entries: [],
            handle_map: {},
            text_map: {},
            next_handle: 1  # Start from 1, 0 reserved
        )

    # Create with reserved handles for test protocol
    static fn with_test_handles() -> StringInternTable:
        var table = StringInternTable.new()
        # Reserve handles for test protocol (0xFFFF0001 - 0xFFFF0004)
        table.add_reserved(0xFFFF0001, "[TEST START]", [])
        table.add_reserved(0xFFFF0002, "[PASS] {}", [FormatType.Text])
        table.add_reserved(0xFFFF0003, "[FAIL] {}: {}", [FormatType.Text, FormatType.Text])
        table.add_reserved(0xFFFF0004, "[TEST END] passed={} failed={}", [FormatType.Int64, FormatType.Int64])
        table

    # Add a reserved entry with specific handle
    me add_reserved(handle: u32, format_text: text, types: [FormatType]):
        val entry = StringInternEntry.new(handle, format_text, types)
        val idx = self.entries.len() as u32
        self.entries.push(entry)
        self.handle_map[handle] = idx
        self.text_map[format_text] = handle

    # Intern a string, returning its handle
    # Deduplicates identical strings
    me intern(format_text: text, types: [FormatType]) -> u32:
        # Check if already interned
        if self.text_map.contains(format_text):
            return self.text_map[format_text]

        # Allocate new handle
        val handle = self.next_handle
        self.next_handle = self.next_handle + 1

        # Create and store entry
        val entry = StringInternEntry.new(handle, format_text, types)
        val idx = self.entries.len() as u32
        self.entries.push(entry)
        self.handle_map[handle] = idx
        self.text_map[format_text] = handle

        handle

    # Intern with source location
    me intern_with_source(format_text: text, types: [FormatType], file: text, line: u32) -> u32:
        # Check if already interned (ignore source for dedup)
        if self.text_map.contains(format_text):
            return self.text_map[format_text]

        val handle = self.next_handle
        self.next_handle = self.next_handle + 1

        val entry = StringInternEntry.with_source(handle, format_text, types, file, line)
        val idx = self.entries.len() as u32
        self.entries.push(entry)
        self.handle_map[handle] = idx
        self.text_map[format_text] = handle

        handle

    # Get entry by handle
    fn get(handle: u32) -> StringInternEntry?:
        if not self.handle_map.contains(handle):
            return None
        val idx = self.handle_map[handle]
        Some(self.entries[idx as i64])

    # Get all entries
    fn all_entries() -> [StringInternEntry]:
        self.entries

    # Get entry count
    fn count() -> u32:
        self.entries.len() as u32

# ============================================================================
# SMF Section Binary Format
# ============================================================================

# Section type ID
const SECTION_TYPE_STRING_INTERN: u8 = 0x10

# Binary layout:
#
# Header (16 bytes):
#   entry_count: u32
#   string_data_size: u32
#   format_data_size: u32
#   reserved: u32
#
# Entry Table (12 bytes Ã— entry_count):
#   handle: u32
#   string_offset: u32
#   format_offset: u32
#
# String Data (variable):
#   null-terminated UTF-8 strings
#
# Format Data (variable):
#   For each entry: count (u8) + types (FormatType[])

struct StringInternHeader:
    entry_count: u32
    string_data_size: u32
    format_data_size: u32
    reserved: u32

struct StringInternEntryBinary:
    handle: u32
    string_offset: u32
    format_offset: u32

# ============================================================================
# Writer
# ============================================================================

# Write StringIntern section to binary buffer
fn write_string_intern_section(table: StringInternTable) -> [u8]:
    var buffer: [u8] = []
    var string_data: [u8] = []
    var format_data: [u8] = []
    var entry_table: [StringInternEntryBinary] = []

    # Build string data and format data
    for entry in table.all_entries():
        val string_offset = string_data.len() as u32
        val format_offset = format_data.len() as u32

        # Add string (null-terminated UTF-8)
        for byte in entry.text.as_bytes():
            string_data.push(byte)
        string_data.push(0)  # Null terminator

        # Add format data
        format_data.push(entry.format_types.len() as u8)
        for ft in entry.format_types:
            format_data.push(ft as u8)

        # Add entry
        entry_table.push(StringInternEntryBinary(
            handle: entry.handle,
            string_offset: string_offset,
            format_offset: format_offset
        ))

    # Write header
    write_u32(buffer, table.count())
    write_u32(buffer, string_data.len() as u32)
    write_u32(buffer, format_data.len() as u32)
    write_u32(buffer, 0)  # reserved

    # Write entry table
    for entry in entry_table:
        write_u32(buffer, entry.handle)
        write_u32(buffer, entry.string_offset)
        write_u32(buffer, entry.format_offset)

    # Write string data
    for byte in string_data:
        buffer.push(byte)

    # Write format data
    for byte in format_data:
        buffer.push(byte)

    buffer

# ============================================================================
# Reader
# ============================================================================

# Read StringIntern section from binary buffer
fn read_string_intern_section(data: [u8]) -> Result<StringInternTable, text>:
    if data.len() < 16:
        return Err("StringIntern section too small")

    var offset: u64 = 0

    # Read header
    val entry_count = read_u32(data, offset)
    offset = offset + 4
    val string_data_size = read_u32(data, offset)
    offset = offset + 4
    val format_data_size = read_u32(data, offset)
    offset = offset + 4
    offset = offset + 4  # skip reserved

    # Validate sizes
    val expected_size = 16 + entry_count * 12 + string_data_size + format_data_size
    if data.len() < expected_size as i64:
        return Err("StringIntern section truncated")

    # Calculate section offsets
    val entry_table_offset = 16
    val string_data_offset = entry_table_offset + entry_count * 12
    val format_data_offset = string_data_offset + string_data_size

    # Read entries
    var table = StringInternTable.new()
    offset = entry_table_offset as u64

    for i in 0..entry_count:
        val handle = read_u32(data, offset)
        offset = offset + 4
        val string_offset = read_u32(data, offset)
        offset = offset + 4
        val format_offset = read_u32(data, offset)
        offset = offset + 4

        # Read string
        val string_start = string_data_offset + string_offset
        val text_str = read_null_terminated_string(data, string_start as u64)

        # Read format types
        val format_start = format_data_offset + format_offset
        val format_count = data[format_start as i64]
        var format_types: [FormatType] = []
        for j in 0..format_count:
            val ft_byte = data[(format_start + 1 + j as u32) as i64]
            format_types.push(byte_to_format_type(ft_byte))

        # Add to table (using reserved to preserve handle)
        table.add_reserved(handle, text_str, format_types)

    Ok(table)

# ============================================================================
# Binary Helpers
# ============================================================================

fn write_u32(buffer: var [u8], val: u32):
    buffer.push((val & 0xFF) as u8)
    buffer.push(((val >> 8) & 0xFF) as u8)
    buffer.push(((val >> 16) & 0xFF) as u8)
    buffer.push(((val >> 24) & 0xFF) as u8)

fn read_u32(data: [u8], offset: u64) -> u32:
    val b0 = data[offset as i64] as u32
    val b1 = data[(offset + 1) as i64] as u32
    val b2 = data[(offset + 2) as i64] as u32
    val b3 = data[(offset + 3) as i64] as u32
    b0 | (b1 << 8) | (b2 << 16) | (b3 << 24)

fn read_null_terminated_string(data: [u8], offset: u64) -> text:
    var bytes: [u8] = []
    var i = offset
    while i < data.len() as u64 and data[i as i64] != 0:
        bytes.push(data[i as i64])
        i = i + 1
    text.from_utf8(bytes)

fn byte_to_format_type(b: u8) -> FormatType:
    match b:
        case 0: FormatType.None
        case 1: FormatType.Int8
        case 2: FormatType.Int16
        case 3: FormatType.Int32
        case 4: FormatType.Int64
        case 5: FormatType.UInt8
        case 6: FormatType.UInt16
        case 7: FormatType.UInt32
        case 8: FormatType.UInt64
        case 9: FormatType.Float32
        case 10: FormatType.Float64
        case 11: FormatType.Bool
        case 12: FormatType.Char
        case 13: FormatType.Hex8
        case 14: FormatType.Hex16
        case 15: FormatType.Hex32
        case 16: FormatType.Hex64
        case 17: FormatType.Binary
        case 18: FormatType.Pointer
        case 19: FormatType.Text
        case _: FormatType.None
