# Semihosting System API for Bare-Metal Targets
#
# Minimal system API using semihosting for bare-metal execution.
# Key innovation: Compile-time string interning for 89%+ print size reduction.
#
# Design: doc/design/semihosting_system_api_design.md
#
# Usage:
#   # In bare-metal code:
#   semi_print(HANDLE_HELLO)           # Print interned string
#   semi_print1(HANDLE_COUNT, count)   # Print with 1 parameter
#   semi_exit(0)                       # Exit with status

export SemihostOp, FormatType
export semi_print, semi_print1, semi_print2, semi_print3, semi_print_n
export semi_open, semi_close, semi_read, semi_write
export semi_exit, semi_clock, semi_time
export semi_host_call

# ============================================================================
# Semihosting Operation Codes
# ============================================================================

# Standard ARM/RISC-V Semihosting Operations (0x00-0x3F)
enum SemihostOp: u32:
    # File operations
    SYS_OPEN = 0x01
    SYS_CLOSE = 0x02
    SYS_WRITEC = 0x03
    SYS_WRITE0 = 0x04
    SYS_WRITE = 0x05
    SYS_READ = 0x06
    SYS_READC = 0x07
    SYS_ISERROR = 0x08
    SYS_ISTTY = 0x09
    SYS_SEEK = 0x0A
    SYS_FLEN = 0x0C
    SYS_TMPNAM = 0x0D
    SYS_REMOVE = 0x0E
    SYS_RENAME = 0x0F

    # Time operations
    SYS_CLOCK = 0x10
    SYS_TIME = 0x11

    # System operations
    SYS_SYSTEM = 0x12
    SYS_ERRNO = 0x13
    SYS_GET_CMDLINE = 0x15
    SYS_HEAPINFO = 0x16
    SYS_EXIT = 0x18
    SYS_EXIT_EXTENDED = 0x20
    SYS_ELAPSED = 0x30
    SYS_TICKFREQ = 0x31

    # Simple Extensions (0x100+) - Interned string printing
    SYS_WRITE_HANDLE = 0x100      # Print interned string by handle
    SYS_WRITE_HANDLE_P1 = 0x101   # Print with 1 parameter
    SYS_WRITE_HANDLE_P2 = 0x102   # Print with 2 parameters
    SYS_WRITE_HANDLE_P3 = 0x103   # Print with 3 parameters
    SYS_WRITE_HANDLE_PN = 0x104   # Print with N parameters (array)

# ============================================================================
# Format Type IDs (for string table metadata)
# ============================================================================

enum FormatType: u8:
    None = 0        # No formatting (literal text)
    Int8 = 1
    Int16 = 2
    Int32 = 3
    Int64 = 4
    UInt8 = 5
    UInt16 = 6
    UInt32 = 7
    UInt64 = 8
    Float32 = 9
    Float64 = 10
    Bool = 11
    Char = 12
    Hex8 = 13       # {:x} format
    Hex16 = 14
    Hex32 = 15
    Hex64 = 16
    Binary = 17     # {:b} format
    Pointer = 18    # {:p} format
    Text = 19       # String (via handle)

# ============================================================================
# Print API (Compile-Time Interned Strings)
# ============================================================================

# Print interned string by handle (no parameters)
# The handle is resolved at compile time from the format string
@inline
fn semi_print(handle: u32):
    semi_host_call(SemihostOp.SYS_WRITE_HANDLE as u32, handle as i64, 0)

# Print interned string with 1 i64 parameter
@inline
fn semi_print1(handle: u32, p0: i64):
    semi_host_call(SemihostOp.SYS_WRITE_HANDLE_P1 as u32, handle as i64, p0)

# Print interned string with 2 i64 parameters
# Params are packed: p0 in arg1, p1 via param block
@inline
fn semi_print2(handle: u32, p0: i64, p1: i64):
    # Pack params into stack-allocated array
    var params: [i64; 2] = [p0, p1]
    semi_host_call_block(SemihostOp.SYS_WRITE_HANDLE_P2 as u32, handle as i64, params.as_ptr() as i64)

# Print interned string with 3 i64 parameters
@inline
fn semi_print3(handle: u32, p0: i64, p1: i64, p2: i64):
    var params: [i64; 3] = [p0, p1, p2]
    semi_host_call_block(SemihostOp.SYS_WRITE_HANDLE_P3 as u32, handle as i64, params.as_ptr() as i64)

# Print interned string with N i64 parameters (dynamic)
@inline
fn semi_print_n(handle: u32, params: [i64]):
    # Param block: [count, param0, param1, ...]
    var block: [i64] = [params.len() as i64]
    for p in params:
        block.push(p)
    semi_host_call_block(SemihostOp.SYS_WRITE_HANDLE_PN as u32, handle as i64, block.as_ptr() as i64)

# ============================================================================
# File I/O API (Limited - Host Filesystem via Semihosting)
# ============================================================================

# File open modes
const MODE_READ: u8 = 0      # "r"
const MODE_READ_BINARY: u8 = 1   # "rb"
const MODE_READ_PLUS: u8 = 2     # "r+"
const MODE_READ_PLUS_BINARY: u8 = 3  # "r+b"
const MODE_WRITE: u8 = 4     # "w"
const MODE_WRITE_BINARY: u8 = 5  # "wb"
const MODE_WRITE_PLUS: u8 = 6    # "w+"
const MODE_WRITE_PLUS_BINARY: u8 = 7 # "w+b"
const MODE_APPEND: u8 = 8    # "a"
const MODE_APPEND_BINARY: u8 = 9 # "ab"
const MODE_APPEND_PLUS: u8 = 10  # "a+"
const MODE_APPEND_PLUS_BINARY: u8 = 11 # "a+b"

# Open file on host filesystem
# Returns file descriptor (>= 0) or -1 on error
fn semi_open(path: rawptr<u8>, path_len: u32, mode: u8) -> i32:
    # SYS_OPEN param block: [path_ptr, mode, path_len]
    var params: [i64; 3] = [path as i64, mode as i64, path_len as i64]
    semi_host_call_block(SemihostOp.SYS_OPEN as u32, 0, params.as_ptr() as i64) as i32

# Close file
fn semi_close(fd: i32) -> bool:
    semi_host_call(SemihostOp.SYS_CLOSE as u32, fd as i64, 0) == 0

# Read bytes from file into buffer
# Returns number of bytes NOT read (0 = success, >0 = partial read, -1 = error)
fn semi_read(fd: i32, buf: rawptr<u8>, len: u32) -> i32:
    # SYS_READ param block: [fd, buf_ptr, len]
    var params: [i64; 3] = [fd as i64, buf as i64, len as i64]
    semi_host_call_block(SemihostOp.SYS_READ as u32, 0, params.as_ptr() as i64) as i32

# Write bytes from buffer to file
# Returns number of bytes NOT written (0 = success)
fn semi_write(fd: i32, buf: rawptr<u8>, len: u32) -> i32:
    # SYS_WRITE param block: [fd, buf_ptr, len]
    var params: [i64; 3] = [fd as i64, buf as i64, len as i64]
    semi_host_call_block(SemihostOp.SYS_WRITE as u32, 0, params.as_ptr() as i64) as i32

# ============================================================================
# System Control API
# ============================================================================

# Exit with status code
@noreturn
fn semi_exit(code: i32):
    # SYS_EXIT_EXTENDED for proper exit code handling
    # Param block: [reason, subcode]
    # reason: 0x20026 = ADP_Stopped_ApplicationExit
    var params: [i64; 2] = [0x20026, code as i64]
    semi_host_call_block(SemihostOp.SYS_EXIT_EXTENDED as u32, 0, params.as_ptr() as i64)
    # Unreachable - halt loop as fallback
    while true:
        pass

# Get elapsed time in centiseconds (hundredths of a second)
fn semi_clock() -> i64:
    semi_host_call(SemihostOp.SYS_CLOCK as u32, 0, 0)

# Get current time in seconds since Unix epoch
fn semi_time() -> i64:
    semi_host_call(SemihostOp.SYS_TIME as u32, 0, 0)

# ============================================================================
# Low-Level Semihosting Call Interface
# ============================================================================

# Architecture-specific semihosting call
# This is implemented differently per target architecture:
# - ARM: BKPT #0xAB (Thumb) or SVC #0x123456 (ARM)
# - RISC-V: EBREAK with magic sequence
# - x86/QEMU: Serial protocol or port I/O
#
# The actual implementation is in:
# - src/baremetal/arm/semihost.spl
# - src/baremetal/riscv/semihost.spl
# - src/baremetal/x86/semihost.spl

# Simple call with two i64 arguments
@inline
fn semi_host_call(op: u32, arg0: i64, arg1: i64) -> i64:
    # Dispatch to architecture-specific implementation
    arch_semi_host_call(op, arg0, arg1)

# Call with parameter block pointer
@inline
fn semi_host_call_block(op: u32, arg0: i64, block_ptr: i64) -> i64:
    arch_semi_host_call_block(op, arg0, block_ptr)

# ============================================================================
# Architecture-Specific Dispatch (Compile-Time Selected)
# ============================================================================

# These functions are implemented in architecture-specific modules
# The compiler selects the appropriate implementation based on target

# Default fallback (error if called on unsupported architecture)
fn arch_semi_host_call(op: u32, arg0: i64, arg1: i64) -> i64:
    # This should be overridden by architecture-specific module
    # If we reach here, semihosting is not supported
    -1

fn arch_semi_host_call_block(op: u32, arg0: i64, block_ptr: i64) -> i64:
    # This should be overridden by architecture-specific module
    -1

# ============================================================================
# Convenience Macros (Compile-Time String Interning)
# ============================================================================

# These would be compiler intrinsics that:
# 1. Extract format string at compile time
# 2. Intern it in StringIntern section
# 3. Replace with semi_print*(handle, args...) call
#
# Example transformation:
#   semi_println!("Hello {name}, count={count}", name, count)
# Becomes:
#   semi_print2(0x0042, name_as_i64, count)
#
# Where 0x0042 is the interned handle for "Hello {}, count={}"
# and format types [Text, Int64] are stored in StringIntern section

# ============================================================================
# Test Output Protocol (SSpec Compatible)
# ============================================================================

# For bare-metal test harness, output follows this format:
# [TEST START]
# [PASS] test_name
# [FAIL] test_name: error message
# [TEST END] passed=N failed=M

# Test result handles (pre-defined, always interned)
const HANDLE_TEST_START: u32 = 0xFFFF0001
const HANDLE_TEST_PASS: u32 = 0xFFFF0002
const HANDLE_TEST_FAIL: u32 = 0xFFFF0003
const HANDLE_TEST_END: u32 = 0xFFFF0004

fn test_start():
    semi_print(HANDLE_TEST_START)

fn test_pass(name_handle: u32):
    semi_print1(HANDLE_TEST_PASS, name_handle as i64)

fn test_fail(name_handle: u32, msg_handle: u32):
    semi_print2(HANDLE_TEST_FAIL, name_handle as i64, msg_handle as i64)

fn test_end(passed: i64, failed: i64):
    semi_print2(HANDLE_TEST_END, passed, failed)
