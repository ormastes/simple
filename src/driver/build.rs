//! Build script that generates Rust test wrappers for Simple stdlib tests.
//!
//! This script:
//! 1. Discovers all .spl test files in `simple/std_lib/test/`
//! 2. Generates a Rust test function for each test file
//! 3. Each test function calls `run_test_file()` and asserts success
//!
//! The generated tests integrate with `cargo test` and show up alongside
//! native Rust tests.

use std::env;
use std::fs;
use std::path::Path;

use walkdir::WalkDir;

fn main() {
    let out_dir = env::var("OUT_DIR").unwrap();
    let dest_path = Path::new(&out_dir).join("simple_stdlib_tests.rs");

    // Find test root - navigate from src/driver to simple/std_lib/test
    let manifest_dir = env::var("CARGO_MANIFEST_DIR").unwrap();
    let test_root = Path::new(&manifest_dir)
        .parent() // src
        .and_then(|p| p.parent()) // project root
        .map(|p| p.join("simple/std_lib/test"))
        .unwrap_or_else(|| Path::new("simple/std_lib/test").to_path_buf());

    let mut generated = String::new();
    generated.push_str("// Auto-generated tests for Simple standard library.\n");
    generated.push_str("// DO NOT EDIT - generated by build.rs\n");
    generated.push_str("\n");
    generated.push_str("use std::path::Path;\n");
    generated.push_str("use simple_driver::simple_test::{run_test_file, SimpleTestResult};\n");
    generated.push_str("\n");

    if !test_root.exists() {
        // No test directory - generate empty module
        generated.push_str("// No test directory found at: ");
        generated.push_str(&test_root.display().to_string());
        generated.push_str("\n");
        generated.push_str("// Tests will be generated when simple/std_lib/test/ is populated.\n");
    } else {
        let mut test_count = 0;

        // Helper to check if a path is a test file
        let is_test_file = |path: &Path| -> bool {
            // Only .spl files
            if path.extension().map_or(true, |ext| ext != "spl") {
                return false;
            }
            // Must end with _spec.spl or _test.spl
            let file_name = path.file_name().and_then(|n| n.to_str()).unwrap_or("");
            if !file_name.ends_with("_spec.spl") && !file_name.ends_with("_test.spl") {
                return false;
            }
            // Skip fixture files
            if path.to_string_lossy().contains("fixture") {
                return false;
            }
            true
        };

        for entry in WalkDir::new(&test_root)
            .follow_links(true)
            .into_iter()
            .filter_map(|e| e.ok())
            .filter(|e| is_test_file(e.path()))
        {
            let path = entry.path();

            // Generate test name from path
            let relative = path
                .strip_prefix(&test_root)
                .unwrap_or(path)
                .to_string_lossy();
            let test_name = sanitize_test_name(&relative);
            let path_str = path.display().to_string().replace('\\', "/");

            generated.push_str(&format!(
                r#"
#[test]
fn simple_stdlib_{test_name}() {{
    let path = Path::new("{path_str}");
    let result = run_test_file(path);
    match result {{
        SimpleTestResult::Pass {{ .. }} => (),
        SimpleTestResult::Skipped {{ .. }} => (),
        SimpleTestResult::Fail {{ failures, stdout, .. }} => {{
            let failure_details: Vec<String> = failures
                .iter()
                .map(|f| format!("  - {{}}: {{}}", f.test_name, f.message))
                .collect();
            panic!(
                "Simple test failed:\n{{}}\n\nOutput:\n{{}}",
                failure_details.join("\n"),
                stdout
            );
        }}
        SimpleTestResult::CompileError {{ error, .. }} => {{
            panic!("Failed to compile Simple test:\n{{}}", error);
        }}
        SimpleTestResult::RuntimeError {{ error, stdout, .. }} => {{
            panic!("Runtime error in Simple test:\n{{}}\n\nOutput:\n{{}}", error, stdout);
        }}
    }}
}}
"#,
                test_name = test_name,
                path_str = path_str
            ));

            test_count += 1;
        }

        generated.push_str(&format!(
            "\n// Generated {} test(s) from {}\n",
            test_count,
            test_root.display()
        ));
    }

    fs::write(&dest_path, generated).unwrap();

    // Tell Cargo to rerun if test directory changes
    println!("cargo:rerun-if-changed={}", test_root.display());

    // Also rerun if any .spl file in the test directory changes
    if test_root.exists() {
        for entry in WalkDir::new(&test_root)
            .follow_links(true)
            .into_iter()
            .filter_map(|e| e.ok())
        {
            if entry.path().extension().map_or(false, |ext| ext == "spl") {
                println!("cargo:rerun-if-changed={}", entry.path().display());
            }
        }
    }
}

/// Convert a file path to a valid Rust test function name.
///
/// "unit/doctest/parser_spec.spl" -> "unit_doctest_parser_spec"
fn sanitize_test_name(path: &str) -> String {
    path.trim_end_matches(".spl")
        .chars()
        .map(|c| match c {
            '/' | '\\' | '-' | '.' | ' ' => '_',
            c if c.is_ascii_alphanumeric() || c == '_' => c,
            _ => '_',
        })
        .collect()
}
