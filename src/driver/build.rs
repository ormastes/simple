//! Build script that generates Rust test wrappers for Simple language tests.
//!
//! This script:
//! 1. Discovers all .spl test files in `simple/std_lib/test/` and `simple/test/`
//! 2. Generates a Rust test function for each test file
//! 3. Each test function calls `run_test_file()` and asserts success
//!
//! The generated tests integrate with `cargo test` and show up alongside
//! native Rust tests.

use std::env;
use std::fs;
use std::path::Path;

use walkdir::WalkDir;

fn main() {
    let out_dir = env::var("OUT_DIR").unwrap();
    let manifest_dir = env::var("CARGO_MANIFEST_DIR").unwrap();
    let project_root = Path::new(&manifest_dir)
        .parent() // src
        .and_then(|p| p.parent()) // project root
        .unwrap();

    // Generate tests for stdlib
    let stdlib_test_root = project_root.join("simple/std_lib/test");
    let stdlib_dest = Path::new(&out_dir).join("simple_stdlib_tests.rs");
    generate_test_file(&stdlib_test_root, &stdlib_dest, "simple_stdlib");

    // Generate tests for simple/test (system tests)
    let simple_test_root = project_root.join("simple/test");
    let simple_dest = Path::new(&out_dir).join("simple_tests.rs");
    generate_test_file(&simple_test_root, &simple_dest, "simple_test");
}

/// Generate a test file for a given test directory
fn generate_test_file(test_root: &Path, dest_path: &Path, prefix: &str) {
    let mut generated = String::new();
    generated.push_str(&format!(
        "// Auto-generated tests for Simple language tests from {}\n",
        test_root.display()
    ));
    generated.push_str("// DO NOT EDIT - generated by build.rs\n");
    generated.push('\n');
    generated.push_str("use std::path::Path;\n");
    generated.push_str("use simple_driver::simple_test::{run_test_file, SimpleTestResult};\n");
    generated.push_str(
        "use simple_compiler::{init_coverage, is_coverage_enabled, save_global_coverage, get_coverage_output_path};\n",
    );
    generated.push('\n');
    generated.push_str("// Initialize coverage once at module load if enabled\n");
    generated.push_str("#[cfg(test)]\n");
    generated.push_str("#[ctor::ctor]\n");
    generated.push_str("fn init_test_coverage() {\n");
    generated.push_str("    if is_coverage_enabled() {\n");
    generated.push_str("        init_coverage();\n");
    generated.push_str("        eprintln!(\"Coverage tracking initialized for Simple tests\");\n");
    generated.push_str("    }\n");
    generated.push_str("}\n");
    generated.push('\n');
    generated.push_str("// Save coverage at module unload if enabled\n");
    generated.push_str("#[cfg(test)]\n");
    generated.push_str("#[ctor::dtor]\n");
    generated.push_str("fn save_test_coverage() {\n");
    generated.push_str("    if is_coverage_enabled() {\n");
    generated.push_str("        if let Err(e) = save_global_coverage() {\n");
    generated.push_str("            eprintln!(\"Warning: Failed to save coverage: {}\", e);\n");
    generated.push_str("        } else {\n");
    generated.push_str("            let path = get_coverage_output_path();\n");
    generated.push_str("            eprintln!(\"Coverage data saved to: {}\", path.display());\n");
    generated.push_str("        }\n");
    generated.push_str("    }\n");
    generated.push_str("}\n");
    generated.push('\n');

    if !test_root.exists() {
        // No test directory - generate empty module
        generated.push_str(&format!("// No test directory found at: {}\n", test_root.display()));
        generated.push_str("// Tests will be generated when the directory is populated.\n");
    } else {
        let mut test_count = 0;

        // Helper to check if a path is a test file
        let is_test_file = |path: &Path| -> bool {
            // Only Simple source files (.spl, .simple, .sscript)
            let ext = path.extension().and_then(|e| e.to_str()).unwrap_or("");
            if !matches!(ext, "spl" | "simple" | "sscript") {
                return false;
            }
            // Must contain _spec. or _test. in filename
            let file_name = path.file_name().and_then(|n| n.to_str()).unwrap_or("");
            if !file_name.contains("_spec.") && !file_name.contains("_test.") {
                return false;
            }
            // Skip fixture files
            if path.to_string_lossy().contains("fixture") {
                return false;
            }
            // Skip language/ directory (contains unimplemented syntax specs)
            if path.to_string_lossy().contains("/language/") || path.to_string_lossy().contains("\\language\\") {
                return false;
            }

            // Skip specific unimplemented feature specs
            let file_name = path.file_name().and_then(|n| n.to_str()).unwrap_or("");
            let unimplemented_specs = [
                "strings_spec.spl",          // Uses ellipsis (...) syntax
                "generators_spec.spl",       // Generator features not implemented
                "hir_spec.spl",              // HIR features not implemented
                "parser_spec.spl",           // Parser features not implemented
                "sets_spec.spl",             // Set operations not implemented
                "each_method_spec.spl",      // Each method not implemented
                "integer_iteration_spec.spl", // Integer iteration not implemented
                "empty_predicate_spec.spl",  // Empty predicate not implemented
                "number_trait_spec.spl",     // Number trait not implemented
                "sorting_algorithms_spec.spl", // Sorting algorithms not implemented
                "brevity_syntax_spec.spl",   // Brevity syntax not implemented
                "custom_blocks_spec.spl",    // Custom blocks not implemented
            ];

            if unimplemented_specs.contains(&file_name) {
                return false;
            }

            true
        };

        for entry in WalkDir::new(test_root)
            .follow_links(true)
            .into_iter()
            .filter_map(|e| e.ok())
            .filter(|e| is_test_file(e.path()))
        {
            let path = entry.path();

            // Generate test name from path
            let relative = path.strip_prefix(test_root).unwrap_or(path).to_string_lossy();
            let test_name = sanitize_test_name(&relative);
            let path_str = path.display().to_string().replace('\\', "/");

            // Use a larger stack size (8MB) for Simple interpreter tests
            // The interpreter uses recursive evaluation which can overflow the default 2MB stack
            generated.push_str(&format!(
                r#"
#[test]
fn {prefix}_{test_name}() {{
    // Run in a thread with larger stack to handle deep recursion in interpreter
    let result = std::thread::Builder::new()
        .stack_size(8 * 1024 * 1024) // 8MB stack
        .spawn(|| {{
            let path = Path::new("{path_str}");
            run_test_file(path)
        }})
        .expect("Failed to spawn test thread")
        .join()
        .expect("Test thread panicked");

    match result {{
        SimpleTestResult::Pass {{ .. }} => (),
        SimpleTestResult::Skipped {{ .. }} => (),
        SimpleTestResult::Fail {{ failures, stdout, .. }} => {{
            let failure_details: Vec<String> = failures
                .iter()
                .map(|f| format!("  - {{}}: {{}}", f.test_name, f.message))
                .collect();
            panic!(
                "Simple test failed:\n{{}}\n\nOutput:\n{{}}",
                failure_details.join("\n"),
                stdout
            );
        }}
        SimpleTestResult::CompileError {{ error, .. }} => {{
            panic!("Failed to compile Simple test:\n{{}}", error);
        }}
        SimpleTestResult::RuntimeError {{ error, stdout, .. }} => {{
            panic!("Runtime error in Simple test:\n{{}}\n\nOutput:\n{{}}", error, stdout);
        }}
    }}
}}
"#,
                prefix = prefix,
                test_name = test_name,
                path_str = path_str
            ));

            test_count += 1;
        }

        generated.push_str(&format!(
            "\n// Generated {} test(s) from {}\n",
            test_count,
            test_root.display()
        ));
    }

    fs::write(dest_path, generated).unwrap();

    // Tell Cargo to rerun if test directory changes
    println!("cargo:rerun-if-changed={}", test_root.display());

    // Also rerun if any .spl file in the test directory changes
    if test_root.exists() {
        for entry in WalkDir::new(test_root)
            .follow_links(true)
            .into_iter()
            .filter_map(|e| e.ok())
        {
            if entry.path().extension().is_some_and(|ext| ext == "spl") {
                println!("cargo:rerun-if-changed={}", entry.path().display());
            }
        }
    }
}

/// Convert a file path to a valid Rust test function name.
///
/// "unit/doctest/parser_spec.spl" -> "unit_doctest_parser_spec"
fn sanitize_test_name(path: &str) -> String {
    path.trim_end_matches(".spl")
        .trim_end_matches(".simple")
        .trim_end_matches(".sscript")
        .chars()
        .map(|c| match c {
            '/' | '\\' | '-' | '.' | ' ' => '_',
            c if c.is_ascii_alphanumeric() || c == '_' => c,
            _ => '_',
        })
        .collect()
}
