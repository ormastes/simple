//! Build script that generates Rust test wrappers for Simple language tests.
//!
//! This script:
//! 1. Discovers all .spl test files in `simple/std_lib/test/` and `simple/test/`
//! 2. Generates a Rust test function for each test file
//! 3. Each test function calls `run_test_file()` and asserts success
//!
//! The generated tests integrate with `cargo test` and show up alongside
//! native Rust tests.

use std::env;
use std::fs;
use std::path::{Path, PathBuf};

use walkdir::WalkDir;

fn main() {
    let out_dir = env::var("OUT_DIR").unwrap();
    let manifest_dir = env::var("CARGO_MANIFEST_DIR").unwrap();
    let project_root = Path::new(&manifest_dir)
        .parent() // src
        .and_then(|p| p.parent()) // project root
        .unwrap();

    // Generate tests for stdlib
    let stdlib_test_root = project_root.join("simple/std_lib/test");
    let stdlib_dest = Path::new(&out_dir).join("simple_stdlib_tests.rs");
    generate_test_file(&stdlib_test_root, &stdlib_dest, "simple_stdlib");

    // Generate tests for simple/test (system tests)
    let simple_test_root = project_root.join("simple/test");
    let simple_dest = Path::new(&out_dir).join("simple_tests.rs");
    generate_test_file(&simple_test_root, &simple_dest, "simple_test");
}

/// Generate a test file for a given test directory
fn generate_test_file(test_root: &Path, dest_path: &Path, prefix: &str) {
    let mut generated = String::new();
    generated.push_str(&format!(
        "// Auto-generated tests for Simple language tests from {}\n",
        test_root.display()
    ));
    generated.push_str("// DO NOT EDIT - generated by build.rs\n");
    generated.push_str("\n");
    generated.push_str("use std::path::Path;\n");
    generated.push_str("use simple_driver::simple_test::{run_test_file, SimpleTestResult};\n");
    generated.push_str("\n");

    if !test_root.exists() {
        // No test directory - generate empty module
        generated.push_str(&format!("// No test directory found at: {}\n", test_root.display()));
        generated.push_str("// Tests will be generated when the directory is populated.\n");
    } else {
        let mut test_count = 0;

        // Helper to check if a path is a test file
        let is_test_file = |path: &Path| -> bool {
            // Only .spl files
            if path.extension().map_or(true, |ext| ext != "spl") {
                return false;
            }
            // Must end with _spec.spl or _test.spl
            let file_name = path.file_name().and_then(|n| n.to_str()).unwrap_or("");
            if !file_name.ends_with("_spec.spl") && !file_name.ends_with("_test.spl") {
                return false;
            }
            // Skip fixture files
            if path.to_string_lossy().contains("fixture") {
                return false;
            }
            true
        };

        for entry in WalkDir::new(test_root)
            .follow_links(true)
            .into_iter()
            .filter_map(|e| e.ok())
            .filter(|e| is_test_file(e.path()))
        {
            let path = entry.path();

            // Generate test name from path
            let relative = path
                .strip_prefix(test_root)
                .unwrap_or(path)
                .to_string_lossy();
            let test_name = sanitize_test_name(&relative);
            let path_str = path.display().to_string().replace('\\', "/");

            // Use a larger stack size (8MB) for Simple interpreter tests
            // The interpreter uses recursive evaluation which can overflow the default 2MB stack
            generated.push_str(&format!(
                r#"
#[test]
fn {prefix}_{test_name}() {{
    // Run in a thread with larger stack to handle deep recursion in interpreter
    let result = std::thread::Builder::new()
        .stack_size(8 * 1024 * 1024) // 8MB stack
        .spawn(|| {{
            let path = Path::new("{path_str}");
            run_test_file(path)
        }})
        .expect("Failed to spawn test thread")
        .join()
        .expect("Test thread panicked");

    match result {{
        SimpleTestResult::Pass {{ .. }} => (),
        SimpleTestResult::Skipped {{ .. }} => (),
        SimpleTestResult::Fail {{ failures, stdout, .. }} => {{
            let failure_details: Vec<String> = failures
                .iter()
                .map(|f| format!("  - {{}}: {{}}", f.test_name, f.message))
                .collect();
            panic!(
                "Simple test failed:\n{{}}\n\nOutput:\n{{}}",
                failure_details.join("\n"),
                stdout
            );
        }}
        SimpleTestResult::CompileError {{ error, .. }} => {{
            panic!("Failed to compile Simple test:\n{{}}", error);
        }}
        SimpleTestResult::RuntimeError {{ error, stdout, .. }} => {{
            panic!("Runtime error in Simple test:\n{{}}\n\nOutput:\n{{}}", error, stdout);
        }}
    }}
}}
"#,
                prefix = prefix,
                test_name = test_name,
                path_str = path_str
            ));

            test_count += 1;
        }

        generated.push_str(&format!(
            "\n// Generated {} test(s) from {}\n",
            test_count,
            test_root.display()
        ));
    }

    fs::write(dest_path, generated).unwrap();

    // Tell Cargo to rerun if test directory changes
    println!("cargo:rerun-if-changed={}", test_root.display());

    // Also rerun if any .spl file in the test directory changes
    if test_root.exists() {
        for entry in WalkDir::new(test_root)
            .follow_links(true)
            .into_iter()
            .filter_map(|e| e.ok())
        {
            if entry.path().extension().map_or(false, |ext| ext == "spl") {
                println!("cargo:rerun-if-changed={}", entry.path().display());
            }
        }
    }
}

/// Convert a file path to a valid Rust test function name.
///
/// "unit/doctest/parser_spec.spl" -> "unit_doctest_parser_spec"
fn sanitize_test_name(path: &str) -> String {
    path.trim_end_matches(".spl")
        .chars()
        .map(|c| match c {
            '/' | '\\' | '-' | '.' | ' ' => '_',
            c if c.is_ascii_alphanumeric() || c == '_' => c,
            _ => '_',
        })
        .collect()
}
