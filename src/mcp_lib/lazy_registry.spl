# MCP Lazy Handler Registry
#
# Manages lazy loading of MCP tool handlers
# Handlers are loaded on first use by category

# Handler metadata (registered at startup, no imports)
class HandlerMetadata:
    name: text
    category: text
    module_path: text
    function_name: text

# Cached handler after loading
class CachedHandler:
    name: text
    handler_fn: fn(text, text) -> text  # (id, body) -> response

# Registry state (module-level)
# NOTE: These work because they're accessed by functions in THIS module
# Imported functions in OTHER modules can't modify these (runtime limitation)
var HANDLER_METADATA: [HandlerMetadata] = []
var LOADED_CATEGORIES: [text] = []
var CACHED_HANDLERS: [CachedHandler] = []

# Initialize registry (called once at startup)
fn init_registry():
    HANDLER_METADATA = []
    LOADED_CATEGORIES = []
    CACHED_HANDLERS = []

# Register handler metadata (no imports, just bookkeeping)
fn register_handler_metadata(name: text, category: text, module: text, fn_name: text):
    HANDLER_METADATA = HANDLER_METADATA + [HandlerMetadata(
        name: name,
        category: category,
        module_path: module,
        function_name: fn_name
    )]

# Get category for a tool name
fn get_tool_category(tool_name: text) -> text:
    for meta in HANDLER_METADATA:
        if meta.name == tool_name:
            return meta.category
    "unknown"

# Check if category is already loaded
fn is_category_loaded(category: text) -> bool:
    for cat in LOADED_CATEGORIES:
        if cat == category:
            return true
    false

# Mark category as loaded
fn mark_category_loaded(category: text):
    if not is_category_loaded(category):
        LOADED_CATEGORIES = LOADED_CATEGORIES + [category]

# Register a cached handler (after loading)
fn register_cached_handler(name: text, handler_fn: fn(text, text) -> text):
    CACHED_HANDLERS = CACHED_HANDLERS + [CachedHandler(
        name: name,
        handler_fn: handler_fn
    )]

# Get cached handler function
fn get_cached_handler(name: text) -> text:
    # Returns "found" or "not_found" (can't return Option<fn> due to runtime limits)
    for handler in CACHED_HANDLERS:
        if handler.name == name:
            return "found"
    "not_found"

# Call cached handler
fn call_cached_handler(name: text, id: text, body: text) -> text:
    for handler in CACHED_HANDLERS:
        if handler.name == name:
            return handler.handler_fn(id, body)
    ""

# Get registry stats
fn get_registry_stats() -> text:
    # Count manually to avoid .len() on module var
    var total = 0
    for meta in HANDLER_METADATA:
        total = total + 1

    var loaded_cats = 0
    for cat in LOADED_CATEGORIES:
        loaded_cats = loaded_cats + 1

    var cached = 0
    for handler in CACHED_HANDLERS:
        cached = cached + 1

    "Registry: {total} handlers, {loaded_cats} categories loaded, {cached} cached"

# Export public API
export init_registry
export register_handler_metadata, get_tool_category
export is_category_loaded, mark_category_loaded
export register_cached_handler, get_cached_handler, call_cached_handler
export get_registry_stats
