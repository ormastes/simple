# MCP Library - Helper Utilities
#
# JSON building, string escaping, parsing utilities.
# Extracted from app.mcp.helpers to enable library reuse.

use std.text.{NL}

# --- JSON String Escaping ---
fn escape_json(s: text) -> text:
    var result = ""
    var i = 0
    while i < s.len():
        val ch = s[i]
        if ch == '"':
            result = result + "\\\""
        elif ch == '\\':
            result = result + "\\\\"
        elif ch == '\n':
            result = result + "\\n"
        elif ch == '\r':
            result = result + "\\r"
        elif ch == '\t':
            result = result + "\\t"
        else:
            result = result + ch.to_string()
        i = i + 1
    result

# --- Brace helpers (avoid f-string interpolation issues) ---
fn LB() -> text:
    (123 as char).to_string()

fn RB() -> text:
    (125 as char).to_string()

fn Q() -> text:
    "\""

# --- Integer parsing ---
fn parse_int(s: text) -> i64:
    var result = 0
    var i = 0
    while i < s.len():
        val ch = s[i]
        if ch >= '0' and ch <= '9':
            result = result * 10 + (ch as i64 - '0' as i64)
        i = i + 1
    result

# --- Math helpers ---
fn min_int(a: i64, b: i64) -> i64:
    if a < b: a else: b

# --- Option unwrap helpers ---
fn unwrap_idx(opt_idx: i64) -> i64:
    if opt_idx == -1: -1 else: opt_idx

fn unwrap_str(s: text) -> text:
    s

# --- Argument processing ---
fn get_clean_args(args: [text]) -> [text]:
    # Filter out runtime-specific args
    var clean = []
    var skip_next = false
    for arg in args:
        if skip_next:
            skip_next = false
        elif arg.starts_with("--jit"):
            skip_next = true
        elif arg.starts_with("--backend"):
            skip_next = true
        elif not arg.starts_with("--"):
            clean = clean + [arg]
    clean

fn has_flag(args: [text], flag: text) -> bool:
    for arg in args:
        if arg == flag:
            return true
    false

# --- JSON Pair Building ---
fn jp(key: text, value: text) -> text:
    Q() + key + Q() + ":" + value

fn js(value: text) -> text:
    Q() + escape_json(value) + Q()

fn jo1(p1: text) -> text:
    LB() + p1 + RB()

fn jo2(p1: text, p2: text) -> text:
    LB() + p1 + "," + p2 + RB()

fn jo3(p1: text, p2: text, p3: text) -> text:
    LB() + p1 + "," + p2 + "," + p3 + RB()

fn jo4(p1: text, p2: text, p3: text, p4: text) -> text:
    LB() + p1 + "," + p2 + "," + p3 + "," + p4 + RB()

fn jo5(p1: text, p2: text, p3: text, p4: text, p5: text) -> text:
    LB() + p1 + "," + p2 + "," + p3 + "," + p4 + "," + p5 + RB()

# --- JSON String Extraction (simple parser) ---
fn extract_json_string_v2(json: text, key: text) -> text:
    val pattern = Q() + key + Q() + ":"
    val idx = json.index_of(pattern) ?? -1
    if idx == -1:
        return ""

    val after_colon = json.substring(idx + pattern.len())
    var start = -1
    var i = 0

    # Skip whitespace
    while i < after_colon.len():
        val ch = after_colon[i]
        if ch == '"':
            start = i + 1
            break
        i = i + 1

    if start == -1:
        return ""

    # Find closing quote
    i = start
    while i < after_colon.len():
        val ch = after_colon[i]
        if ch == '"':
            return after_colon.substring(start, i)
        i = i + 1

    ""

fn extract_json_string(json: text, key: text) -> text:
    extract_json_string_v2(json, key)

# Extract JSON value (numeric or string ID)
fn extract_json_value(json: text, key: text) -> text:
    val pattern = Q() + key + Q() + ":"
    val idx = json.index_of(pattern) ?? -1
    if idx == -1:
        return "null"

    val after_colon = json.substring(idx + pattern.len())
    var start = -1
    var i = 0

    # Skip whitespace
    while i < after_colon.len():
        val ch = after_colon[i]
        if ch != ' ' and ch != '\t' and ch != '\n':
            start = i
            break
        i = i + 1

    if start == -1:
        return "null"

    # Extract until comma or brace
    i = start
    var value = ""
    while i < after_colon.len():
        val ch = after_colon[i]
        if ch == ',' or ch == '}' or ch == '\n':
            break
        value = value + ch.to_string()
        i = i + 1

    value.trim()

# Extract nested string: params.key
fn extract_nested_string(json: text, parent: text, key: text) -> text:
    val parent_pattern = Q() + parent + Q() + ":"
    val idx = json.index_of(parent_pattern) ?? -1
    if idx == -1:
        return ""

    val after_parent = json.substring(idx + parent_pattern.len())
    extract_json_string_v2(after_parent, key)

# Extract arguments dict from tools/call
fn extract_arguments_dict(json: text) -> text:
    val pattern = Q() + "arguments" + Q() + ":"
    val idx = json.index_of(pattern) ?? -1
    if idx == -1:
        return "{}"

    val after_colon = json.substring(idx + pattern.len())
    var start = -1
    var i = 0

    # Skip whitespace, find opening brace
    while i < after_colon.len():
        val ch = after_colon[i]
        if ch == '{':
            start = i
            break
        i = i + 1

    if start == -1:
        return "{}"

    # Find matching closing brace
    var depth = 1
    i = start + 1
    while i < after_colon.len():
        val ch = after_colon[i]
        if ch == '{':
            depth = depth + 1
        elif ch == '}':
            depth = depth - 1
            if depth == 0:
                return after_colon.substring(start, i + 1)
        i = i + 1

    "{}"

# --- Argument Extraction ---
fn extract_arg(body: text, key: text) -> text:
    # Extract string argument from MCP request body
    val search = Q() + key + Q() + ":"
    val idx = body.index_of(search) ?? -1
    if idx == -1:
        return ""
    val start = idx + search.len()
    val rest = body.substring(start).trim()
    if not rest.starts_with(Q()):
        return ""
    val after_quote = rest.substring(1)
    val end_idx = after_quote.index_of(Q()) ?? -1
    if end_idx == -1:
        return ""
    after_quote.substring(0, end_idx)

# --- MCP Response Builders ---
fn make_result_response(id: text, result: text) -> text:
    jo3(jp("jsonrpc", js("2.0")), jp("id", id), jp("result", result))

fn make_error_response(id: text, code: i64, message: text) -> text:
    val error = jo2(jp("code", code.to_string()), jp("message", js(message)))
    jo3(jp("jsonrpc", js("2.0")), jp("id", id), jp("error", error))

fn make_tool_result(id: text, content_text: text) -> text:
    val content_obj = jo2(jp("type", js("text")), jp("text", js(content_text)))
    val result = jo2(jp("content", "[" + content_obj + "]"), jp("isError", "false"))
    jo3(jp("jsonrpc", js("2.0")), jp("id", id), jp("result", result))

fn make_notification(method: text, params: text) -> text:
    jo3(jp("jsonrpc", js("2.0")), jp("method", js(method)), jp("params", params))

fn make_notification_no_params(method: text) -> text:
    jo2(jp("jsonrpc", js("2.0")), jp("method", js(method)))

# --- Log level conversion ---
fn log_level_to_int(level: text) -> i64:
    if level == "debug": 0
    elif level == "info": 1
    elif level == "warning": 2
    elif level == "error": 3
    elif level == "critical": 4
    else: 1

# --- Tool schema builders ---
fn make_tool_schema_multi(
    name: text,
    description: text,
    required_params: [text],
    param_types: [text],
    param_descs: [text]
) -> text:
    var props = ""
    var i = 0
    while i < required_params.len():
        if i > 0:
            props = props + ","
        val param_name = required_params[i]
        val param_type = param_types[i]
        val param_desc = param_descs[i]
        val prop = jo2(jp("type", js(param_type)), jp("description", js(param_desc)))
        props = props + Q() + param_name + Q() + ":" + prop
        i = i + 1

    var req_array = "["
    i = 0
    while i < required_params.len():
        if i > 0:
            req_array = req_array + ","
        req_array = req_array + js(required_params[i])
        i = i + 1
    req_array = req_array + "]"

    val props_obj = LB() + props + RB()
    val input_schema = jo3(
        jp("type", js("object")),
        jp("properties", props_obj),
        jp("required", req_array)
    )

    jo3(
        jp("name", js(name)),
        jp("description", js(description)),
        jp("inputSchema", input_schema)
    )
