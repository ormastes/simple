# Built-in Functions
#
# Core built-in functions always available without import:
# print, len, type, range, abs, min, max, str, int, etc.
# Port of rust/compiler/src/interpreter_call/builtins.rs

from ..core import {Interpreter, Value, InterpreterError}

export eval_builtin, is_builtin

# Set of built-in function names
val builtin_names = [
    "print", "print_raw", "eprint", "eprint_raw", "dprint",
    "println", "eprintln",  # deprecated aliases
    "input",
    "len", "type", "isinstance", "id", "hash",
    "range", "enumerate", "zip", "reversed", "sorted",
    "abs", "min", "max", "sum", "pow", "sqrt", "floor", "ceil",
    "round",
    "str", "int", "float", "bool",
    "to_string", "to_int",
    "assert", "panic", "exit",
    "Some", "None", "Ok", "Err",
    "memory_usage", "memory_limit", "memory_usage_percent",
    "is_memory_limited", "default_memory_limit",
    "format_bytes", "parse_memory_size",
]

fn is_builtin(name: text) -> bool:
    builtin_names.contains(name)

# Evaluate a built-in function call
fn eval_builtin(interp: Interpreter, name: text, args: [Value]) -> Result<Value, InterpreterError>:
    match name:
        # I/O
        case "print" | "println":
            val text = args.map(\a: a.to_display_string()).join(" ")
            print(text)
            Ok(Value.nil())

        case "print_raw":
            val text = args.map(\a: a.to_display_string()).join(" ")
            print_raw(text)
            Ok(Value.nil())

        case "eprint" | "eprintln":
            val text = args.map(\a: a.to_display_string()).join(" ")
            eprint(text)
            Ok(Value.nil())

        case "eprint_raw":
            val text = args.map(\a: a.to_display_string()).join(" ")
            eprint_raw(text)
            Ok(Value.nil())

        case "dprint":
            if interp.debug:
                val text = args.map(\a: a.to_display_string()).join(" ")
                eprint("[debug] {text}")
            Ok(Value.nil())

        case "input":
            val prompt = if args.len() > 0: args[0].to_display_string() else: ""
            if prompt.len() > 0:
                print_raw(prompt)
            val line = read_line()
            Ok(Value.string(line))

        # Introspection
        case "len":
            if args.len() != 1:
                return Err(InterpreterError.ArityError("len() takes 1 argument"))
            Ok(Value.int(args[0].len()))

        case "type":
            if args.len() != 1:
                return Err(InterpreterError.ArityError("type() takes 1 argument"))
            Ok(Value.string(args[0].type_name()))

        case "isinstance":
            if args.len() != 2:
                return Err(InterpreterError.ArityError("isinstance() takes 2 arguments"))
            val type_name = args[1].as_string() ?? args[1].to_display_string()
            Ok(Value.bool(args[0].matches_type(type_name)))

        case "id":
            if args.len() != 1:
                return Err(InterpreterError.ArityError("id() takes 1 argument"))
            Ok(Value.int(args[0].identity_hash()))

        case "hash":
            if args.len() != 1:
                return Err(InterpreterError.ArityError("hash() takes 1 argument"))
            Ok(Value.int(args[0].hash_value()))

        # Iterators
        case "range":
            eval_range_builtin(args)

        case "enumerate":
            if args.len() != 1:
                return Err(InterpreterError.ArityError("enumerate() takes 1 argument"))
            val items = args[0].to_iterable()?
            val enumerated = items.enumerate().map(\pair: Value.tuple([Value.int(pair.0), pair.1]))
            Ok(Value.array(enumerated))

        case "zip":
            if args.len() != 2:
                return Err(InterpreterError.ArityError("zip() takes 2 arguments"))
            val a = args[0].to_iterable()?
            val b = args[1].to_iterable()?
            val zipped = a.zip(b).map(\pair: Value.tuple([pair.0, pair.1]))
            Ok(Value.array(zipped))

        case "reversed":
            if args.len() != 1:
                return Err(InterpreterError.ArityError("reversed() takes 1 argument"))
            Ok(args[0].reversed())

        case "sorted":
            if args.len() != 1:
                return Err(InterpreterError.ArityError("sorted() takes 1 argument"))
            Ok(args[0].sorted())

        # Math
        case "abs":
            if args.len() != 1:
                return Err(InterpreterError.ArityError("abs() takes 1 argument"))
            args[0].abs_value()

        case "min":
            if args.len() == 0:
                return Err(InterpreterError.ArityError("min() requires at least 1 argument"))
            if args.len() == 1 and args[0].is_iterable():
                args[0].min_value()
            else:
                args.min_of()

        case "max":
            if args.len() == 0:
                return Err(InterpreterError.ArityError("max() requires at least 1 argument"))
            if args.len() == 1 and args[0].is_iterable():
                args[0].max_value()
            else:
                args.max_of()

        case "sum":
            if args.len() != 1:
                return Err(InterpreterError.ArityError("sum() takes 1 argument"))
            args[0].sum_value()

        case "pow":
            if args.len() != 2:
                return Err(InterpreterError.ArityError("pow() takes 2 arguments"))
            args[0].pow_value(args[1])

        case "sqrt":
            if args.len() != 1:
                return Err(InterpreterError.ArityError("sqrt() takes 1 argument"))
            args[0].sqrt_value()

        case "floor":
            if args.len() != 1:
                return Err(InterpreterError.ArityError("floor() takes 1 argument"))
            args[0].floor_value()

        case "ceil":
            if args.len() != 1:
                return Err(InterpreterError.ArityError("ceil() takes 1 argument"))
            args[0].ceil_value()

        case "round":
            if args.len() < 1 or args.len() > 2:
                return Err(InterpreterError.ArityError("round() takes 1-2 arguments"))
            val digits = if args.len() > 1: args[1].as_int() ?? 0 else: 0
            args[0].round_value(digits)

        # Conversions
        case "str" | "to_string":
            if args.len() != 1:
                return Err(InterpreterError.ArityError("str() takes 1 argument"))
            Ok(Value.string(args[0].to_display_string()))

        case "int" | "to_int":
            if args.len() != 1:
                return Err(InterpreterError.ArityError("int() takes 1 argument"))
            args[0].to_int_value()

        case "float":
            if args.len() != 1:
                return Err(InterpreterError.ArityError("float() takes 1 argument"))
            args[0].to_float_value()

        case "bool":
            if args.len() != 1:
                return Err(InterpreterError.ArityError("bool() takes 1 argument"))
            Ok(Value.bool(args[0].is_truthy()))

        # Option/Result constructors
        case "Some":
            if args.len() != 1:
                return Err(InterpreterError.ArityError("Some() takes 1 argument"))
            Ok(Value.enum_value("Option", "Some", Some(args[0])))

        case "None":
            Ok(Value.nil())

        case "Ok":
            if args.len() != 1:
                return Err(InterpreterError.ArityError("Ok() takes 1 argument"))
            Ok(Value.enum_value("Result", "Ok", Some(args[0])))

        case "Err":
            if args.len() != 1:
                return Err(InterpreterError.ArityError("Err() takes 1 argument"))
            Ok(Value.enum_value("Result", "Err", Some(args[0])))

        # Process control
        case "assert":
            if args.len() < 1:
                return Err(InterpreterError.ArityError("assert() requires at least 1 argument"))
            if not args[0].is_truthy():
                val msg = if args.len() > 1: args[1].to_display_string() else: "assertion failed"
                return Err(InterpreterError.AssertionError(msg))
            Ok(Value.nil())

        case "panic":
            val msg = if args.len() > 0: args[0].to_display_string() else: "explicit panic"
            Err(InterpreterError.Panic(msg))

        case "exit":
            val code = if args.len() > 0: args[0].as_int() ?? 0 else: 0
            Err(InterpreterError.Exit(code))

        case _:
            Err(InterpreterError.NotImplemented("builtin '{name}'"))

# Range builtin: range(end), range(start, end), range(start, end, step)
fn eval_range_builtin(args: [Value]) -> Result<Value, InterpreterError>:
    match args.len():
        case 1:
            val end = args[0].as_int() ?? return Err(InterpreterError.TypeError("range() requires integer arguments"))
            Ok(Value.range(0, end, false))
        case 2:
            val start = args[0].as_int() ?? return Err(InterpreterError.TypeError("range() requires integer arguments"))
            val end = args[1].as_int() ?? return Err(InterpreterError.TypeError("range() requires integer arguments"))
            Ok(Value.range(start, end, false))
        case 3:
            val start = args[0].as_int() ?? return Err(InterpreterError.TypeError("range() requires integer arguments"))
            val end = args[1].as_int() ?? return Err(InterpreterError.TypeError("range() requires integer arguments"))
            val step = args[2].as_int() ?? return Err(InterpreterError.TypeError("range() requires integer arguments"))
            Ok(Value.range_with_step(start, end, step))
        case _:
            Err(InterpreterError.ArityError("range() takes 1-3 arguments"))
