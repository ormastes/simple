# Text parsing utilities for extracting structured data
# Useful for parsing documentation, logs, and configuration files

use app.io
use std.string.{NL}

export extract_section, extract_sections, parse_key_value, parse_table
export split_lines, trim_lines, filter_empty, filter_comments
export indent_level, strip_indent, normalize_indent

# Extract a named section from text (between headers)
fn extract_section(text: text, section_name: text) -> text:
    """Extract section between '## Section' and next '##' or end"""
    val lines = text.split(NL)
    var in_section = false
    var result_lines = []

    for line in lines:
        # Check for section start
        if line.starts_with("## ") and line.contains(section_name):
            in_section = true
            continue

        # Check for next section (end of current section)
        if in_section and line.starts_with("## "):
            break

        if in_section:
            result_lines = result_lines + [line]

    result_lines.join(NL)

# Extract all sections as (name, content) pairs
fn extract_sections(text: text) -> [(text, text)]:
    """Extract all ## sections as (name, content) tuples"""
    val lines = text.split(NL)
    var sections = []
    var current_name = ""
    var current_lines = []

    for line in lines:
        if line.starts_with("## "):
            # Save previous section if exists
            if current_name.len() > 0:
                val content = current_lines.join(NL)
                sections = sections + [(current_name, content)]

            # Start new section
            current_name = line.substring(3, line.len()).trim()
            current_lines = []
        else:
            current_lines = current_lines + [line]

    # Save last section
    if current_name.len() > 0:
        val content = current_lines.join(NL)
        sections = sections + [(current_name, content)]

    sections

# Parse key: value lines
fn parse_key_value(text: text, separator: text) -> [(text, text)]:
    """Parse 'key: value' or 'key = value' lines"""
    val lines = split_lines(text)
    var pairs = []

    for line in lines:
        val trimmed = line.trim()
        if trimmed.len() == 0 or trimmed.starts_with("#"):
            continue

        val sep_idx = trimmed.find(separator)
        if sep_idx > 0:
            val key = trimmed.substring(0, sep_idx).trim()
            val value = trimmed.substring(sep_idx + separator.len(), trimmed.len()).trim()
            pairs = pairs + [(key, value)]

    pairs

# Parse simple table format (space/tab separated)
fn parse_table(text: text) -> [[text]]:
    """Parse table with rows of space-separated values"""
    val lines = split_lines(text)
    var rows = []

    for line in lines:
        val trimmed = line.trim()
        if trimmed.len() == 0 or trimmed.starts_with("#"):
            continue

        # Split on whitespace (simple approach)
        val cells = trimmed.split(" ")
        var filtered_cells = []
        for cell in cells:
            val c = cell.trim()
            if c.len() > 0:
                filtered_cells = filtered_cells + [c]

        if filtered_cells.len() > 0:
            rows = rows + [filtered_cells]

    rows

# Split text into lines
fn split_lines(text: text) -> [text]:
    """Split text into lines, handling different line endings"""
    # Simple approach: split on {NL}
    text.split(NL)

# Trim whitespace from all lines
fn trim_lines(lines: [text]) -> [text]:
    """Trim whitespace from each line"""
    var result = []
    for line in lines:
        result = result + [line.trim()]
    result

# Filter out empty lines
fn filter_empty(lines: [text]) -> [text]:
    """Remove empty lines"""
    var result = []
    for line in lines:
        if line.trim().len() > 0:
            result = result + [line]
    result

# Filter out comment lines
fn filter_comments(lines: [text], comment_prefix: text) -> [text]:
    """Remove lines starting with comment prefix"""
    var result = []
    for line in lines:
        if not line.trim().starts_with(comment_prefix):
            result = result + [line]
    result

# Get indentation level (number of leading spaces)
fn indent_level(line: text) -> i64:
    """Count leading spaces in line"""
    var count = 0
    for i in 0..line.len():
        if line[i] == ' ':
            count = count + 1
        else:
            break
    count

# Remove common leading whitespace
fn strip_indent(text: text) -> text:
    """Remove common indentation from all lines"""
    val lines = split_lines(text)
    if lines.len() == 0:
        return ""

    # Find minimum indent (ignoring empty lines)
    var min_indent = 999999
    for line in lines:
        if line.trim().len() > 0:
            val level = indent_level(line)
            if level < min_indent:
                min_indent = level

    # Strip that many spaces from each line
    var result_lines = []
    for line in lines:
        if line.len() >= min_indent:
            result_lines = result_lines + [line.substring(min_indent, line.len())]
        else:
            result_lines = result_lines + [line]

    result_lines.join(NL)

# Normalize indentation to use N spaces
fn normalize_indent(text: text, spaces: i64) -> text:
    """Convert tabs to spaces and normalize indentation"""
    val lines = split_lines(text)
    var result_lines = []

    for line in lines:
        # Replace tabs with spaces
        var normalized = replace_all(line, "\t", "    ")
        result_lines = result_lines + [normalized]

    result_lines.join(NL)

fn replace_all(text: text, pattern: text, replacement: text) -> text:
    """Replace all occurrences (simple helper)"""
    var result = text
    var modified = true
    while modified:
        val new_result = result.replace(pattern, replacement)
        modified = new_result != result
        result = new_result
    result
