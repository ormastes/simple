# Tag Classification System for Documentation Items
#
# Assigns hierarchical tags to documentation items based on:
# - Documentation status (complete, documented, partial, missing)
# - SDoctest quality (comprehensive, basic, missing, insufficient)
# - Visibility (public, internal, private)
# - Item kind (function, struct, class, enum, constant)
# - Priority (critical, high, medium, low)
# - Module category (stdlib, core, compiler, app, lib)

use doc_coverage.types.doc_item.{DocItem, DocKind}

# Main classification function - assigns all relevant tags to a DocItem
fn classify_doc_item(item: DocItem, sdoctest_blocks: [text]) -> [text]:
    var tags: [text] = []

    # Doc status tag
    val doc_status_tag = _classify_doc_status(item)
    tags.push(doc_status_tag)

    # SDoctest quality tag
    val sdoctest_tag = _classify_sdoctest_quality(item, sdoctest_blocks)
    tags.push(sdoctest_tag)

    # Visibility tag
    val visibility_tag = _classify_visibility(item)
    tags.push(visibility_tag)

    # Item kind tag
    val kind_tag = _classify_item_kind(item)
    tags.push(kind_tag)

    # Priority tag
    val priority_tag = compute_priority(item)
    tags.push(priority_tag)

    # Module category tag
    val module_tag = infer_module_tag(item.file)
    tags.push(module_tag)

    tags

# Classify documentation status
fn _classify_doc_status(item: DocItem) -> text:
    val has_inline = item.has_inline_comment
    val has_docstring = item.has_docstring
    val has_sdoc = item.has_sdoctest

    # Complete: all three types of documentation
    val has_all = has_inline and has_docstring
    if has_all:
        if has_sdoc:
            return "doc_status:complete"

    # Documented: has inline + docstring but no sdoctest
    if has_inline:
        if has_docstring:
            return "doc_status:documented"

    # Partial: has only inline OR docstring
    val has_partial = has_inline or has_docstring
    if has_partial:
        return "doc_status:partial"

    # Missing: no documentation at all
    "doc_status:missing"

# Classify SDoctest quality based on example count
fn _classify_sdoctest_quality(item: DocItem, sdoctest_blocks: [text]) -> text:
    val example_count = count_sdoctest_examples(item.name, sdoctest_blocks)

    # Comprehensive: 3+ examples
    if example_count >= 3:
        return "sdoctest:comprehensive"

    # Basic: 1-2 examples
    if example_count >= 1:
        return "sdoctest:basic"

    # Missing: no examples
    "sdoctest:missing"

# Count how many sdoctest blocks mention this item
fn count_sdoctest_examples(func_name: text, sdoctest_blocks: [text]) -> i64:
    var count = 0
    var i = 0
    while i < sdoctest_blocks.len():
        val block = sdoctest_blocks[i]
        val contains_name = block.contains(func_name)
        if contains_name:
            count = count + 1
        i = i + 1
    count

# Classify visibility level
fn _classify_visibility(item: DocItem) -> text:
    # Public: explicitly exported or marked public
    if item.is_exported:
        return "visibility:public"

    # Internal: public visibility but not exported
    val is_pub_vis = item.visibility == "pub"
    if is_pub_vis:
        return "visibility:internal"

    # Private: implementation detail
    "visibility:private"

# Classify item kind
fn _classify_item_kind(item: DocItem) -> text:
    val kind_str = item.kind_str()
    "item_kind:{kind_str}"

# Compute priority based on visibility and documentation status
fn compute_priority(item: DocItem) -> text:
    val is_public = item.is_exported
    val has_inline = item.has_inline_comment
    val has_docstring = item.has_docstring
    val has_sdoc = item.has_sdoctest

    # Public items get higher priority
    if is_public:
        # Critical: public API with no docs at all
        val has_no_docs = not has_inline
        val also_no_docstring = not has_docstring
        if has_no_docs:
            if also_no_docstring:
                return "priority:critical"

        # High: public API with partial docs
        val has_partial = has_inline or has_docstring
        val not_both = not (has_inline and has_docstring)
        if has_partial:
            if not_both:
                return "priority:high"

        # Medium: public API needs sdoctest
        if not has_sdoc:
            return "priority:medium"

        # Low: public API fully documented
        return "priority:low"

    # Internal/private items are low priority
    "priority:low"

# Infer module category from file path
fn infer_module_tag(file_path: text) -> text:
    # Standard library
    val is_stdlib = file_path.contains("/src/std/")
    if is_stdlib:
        return "module:stdlib"

    # Core compiler
    val is_core = file_path.contains("/src/core/")
    if is_core:
        return "module:core"

    # Compiler infrastructure
    val is_compiler = file_path.contains("/src/compiler/")
    if is_compiler:
        return "module:compiler"

    # Application code
    val is_app = file_path.contains("/src/app/")
    if is_app:
        return "module:app"

    # Library code
    val is_lib = file_path.contains("/src/lib/")
    if is_lib:
        return "module:lib"

    # Default to app for unknown paths
    "module:app"

# Extract module name from file path for sub-categorization
fn extract_module_name(file_path: text) -> text:
    # Handle different path patterns
    var name = file_path

    # Remove .spl extension
    val has_ext = name.ends_with(".spl")
    if has_ext:
        val len_without_ext = name.len() - 4
        name = name[0:len_without_ext]

    # Handle mod.spl case - use parent directory
    val is_mod = name.ends_with("/mod")
    if is_mod:
        val len_without_mod = name.len() - 4
        name = name[0:len_without_mod]

    # Get last path component
    val has_slash = name.contains("/")
    if has_slash:
        val last_slash_idx = name.last_index_of("/") ?? -1
        if last_slash_idx >= 0:
            val after_slash = last_slash_idx + 1
            name = name[after_slash:]

    name

# Batch classify multiple items
fn classify_all_items(items: [DocItem], sdoctest_blocks: [text]) -> [[text]]:
    var all_tags: [[text]] = []
    var i = 0
    while i < items.len():
        val item = items[i]
        val item_tags = classify_doc_item(item, sdoctest_blocks)
        all_tags.push(item_tags)
        i = i + 1
    all_tags

# Filter items by tag
fn filter_by_tag(items: [DocItem], all_tags: [[text]], filter_tag: text) -> [DocItem]:
    var filtered: [DocItem] = []
    var i = 0
    while i < items.len():
        val item = items[i]
        val tags = all_tags[i]
        val has_tag = _contains_tag(tags, filter_tag)
        if has_tag:
            filtered.push(item)
        i = i + 1
    filtered

fn _contains_tag(tags: [text], target: text) -> bool:
    var i = 0
    while i < tags.len():
        val tag = tags[i]
        if tag == target:
            return true
        i = i + 1
    false

# Get items by priority level
fn get_priority_items(items: [DocItem], all_tags: [[text]], priority: text) -> [DocItem]:
    val priority_tag = "priority:{priority}"
    filter_by_tag(items, all_tags, priority_tag)

# Get items by module
fn get_module_items(items: [DocItem], all_tags: [[text]], module: text) -> [DocItem]:
    val module_tag = "module:{module}"
    filter_by_tag(items, all_tags, module_tag)

# Get items by doc status
fn get_doc_status_items(items: [DocItem], all_tags: [[text]], status: text) -> [DocItem]:
    val status_tag = "doc_status:{status}"
    filter_by_tag(items, all_tags, status_tag)

export classify_doc_item
export count_sdoctest_examples
export infer_module_tag
export compute_priority
export extract_module_name
export classify_all_items
export filter_by_tag
export get_priority_items
export get_module_items
export get_doc_status_items
