# Simple to C Code Generator - Expression Translation
#
# Helpers, condition, method call, and expression translation:
#   - Type-check helpers (is_c_expr_string_result, extract_fn_names, etc.)
#   - Condition translation (and/or/not, nil, string equality)
#   - Method call translation (.contains, .starts_with, .len, etc.)
#   - Full expression translation (literals, operators, structs, enums)

use app.compile.c_helpers.{find_close_paren, find_top_level_plus, find_outside_strings, is_string_array_var, is_int_array_var, is_str_arr_arr_var, is_int_arr_arr_var, is_text_var, is_fn_returning_text, is_fn_returning_struct, is_struct_field_text, is_struct_field_str_array, is_struct_field_int_array, simple_type_to_c, translate_params, is_struct_type_var, is_known_struct, is_known_method, is_me_method, is_static_fn, is_dict_var, is_option_var, is_enum_variant, resolve_enum_variant, parse_generic_type, is_struct_array_var, is_struct_field_struct_array, is_fn_returning_struct_arr, is_fn_returning_int_arr, is_fn_returning_str_arr}

# --- Translation Functions ---
# Functions that only READ types receive `types: text` parameter.
# Functions that ADD type entries return "code<|TYPE|>;entry1;entry2;" with <|TYPE|> separator.

# Check if a C expression returns a string result based on known function patterns
fn is_c_expr_string_result(c_expr: text) -> bool:
    # These runtime functions return int/long long, NOT strings
    if c_expr.starts_with("simple_contains("):
        return false
    if c_expr.starts_with("simple_starts_with("):
        return false
    if c_expr.starts_with("simple_ends_with("):
        return false
    if c_expr.starts_with("simple_index_of("):
        return false
    if c_expr.starts_with("simple_last_index_of("):
        return false
    if c_expr.starts_with("simple_strlen("):
        return false
    val is1 = c_expr.starts_with("\"") or c_expr.starts_with("r\"") or c_expr.contains("simple_substring(")
    val is2 = c_expr.contains("simple_trim(") or c_expr.contains("simple_replace(")
    val is3 = c_expr.contains("simple_string_join(") or c_expr.contains("simple_str_concat(")
    val is4 = c_expr.contains("simple_char_at(") or c_expr.contains("simple_file_read(")
    val is5 = c_expr.contains("simple_dict_get(") or c_expr.contains("simple_option_unwrap_str(")
    val is6 = find_outside_strings(c_expr, "!= NULL ?") >= 0
    is1 or is2 or is3 or is4 or is5 or is6

# Extract function names from raw rhs and translated c_rhs (before first paren)
fn extract_fn_names(rhs: text, c_rhs: text) -> [text]:
    var names: [text] = []
    val p1 = rhs.index_of("(") ?? -1
    if p1 >= 0:
        names.push(rhs.substring(0, p1).trim())
    val p2 = c_rhs.index_of("(") ?? -1
    if p2 >= 0:
        names.push(c_rhs.substring(0, p2).trim())
    names

# Translate a simple method call: obj.method(args) -> c_func(obj, args)
fn translate_simple_method(expr: text, paren_pos: i64, obj: text, c_func: text, do_translate: bool, ref_obj: bool, types: text) -> text:
    val arg_end = find_close_paren(expr, paren_pos)
    if arg_end >= 0:
        val arg = expr.substring(paren_pos + 1, arg_end)
        var c_arg = arg
        if do_translate:
            c_arg = translate_expr(arg, types)
        val c_obj_base = translate_expr(obj, types)
        var c_obj = c_obj_base
        if ref_obj:
            c_obj = "&" + c_obj_base
        return c_func + r"(" + c_obj + r", " + c_arg + r")"
    ""

# Check if a base expression is an items-indexed array (produces base.items[idx])
fn is_items_indexed_array(base: text, types: text) -> bool:
    if is_string_array_var(base, types):
        return true
    if is_int_array_var(base, types):
        return true
    if is_str_arr_arr_var(base, types):
        return true
    if is_int_arr_arr_var(base, types):
        return true
    if base.contains("."):
        if is_struct_field_str_array(base, types) or is_struct_field_int_array(base, types):
            return true
    false

# Resolve .len() for a base expression based on its type, returns "" if unresolved
fn resolve_len(base: text, types: text) -> text:
    if is_dict_var(base, types):
        return r"simple_dict_len(" + base + r")"
    val base_is_text = is_text_var(base, types) or base.starts_with("\"") or base.starts_with("r\"")
    if base_is_text:
        return r"simple_strlen(" + base + r")"
    if is_struct_field_text(base, types):
        return r"simple_strlen(" + base + r")"
    if is_string_array_var(base, types) or is_int_array_var(base, types):
        return base + r".len"
    if is_str_arr_arr_var(base, types) or is_int_arr_arr_var(base, types):
        return base + r".len"
    if is_struct_array_var(base, types) != "":
        return base + r".len"
    if is_struct_field_str_array(base, types) or is_struct_field_int_array(base, types):
        return base + r".len"
    if is_struct_field_struct_array(base, types) != "":
        return base + r".len"
    ""

# Generate a C for-loop over an array variable
fn gen_array_for_loop(loop_var: text, iterable: text, elem_type: text, is_text_elem: bool) -> text:
    var result = "for (long long _idx_" + loop_var + " = 0; _idx_" + loop_var + " < " + iterable + ".len; _idx_" + loop_var + "++) \{ " + elem_type + " " + loop_var + " = " + iterable + ".items[_idx_" + loop_var + "];"
    if is_text_elem:
        result = result + "<|TYPE|>;text:" + loop_var + ";"
    result

# Try to translate a compound assignment operator (-=, *=, /=), returns "" if not found
fn try_translate_compound_assign(trimmed: text, op: text, types: text) -> text:
    val pos = trimmed.index_of(op) ?? -1
    if pos >= 0:
        val lhs = trimmed.substring(0, pos).trim()
        val rhs = trimmed.substring(pos + op.len()).trim()
        val c_rhs = translate_expr(rhs, types)
        return lhs + op + c_rhs + r";"
    ""

# Try to translate a binary comparison operator, returns "" if not found
fn try_translate_binary_cmp(result: text, op: text, types: text) -> text:
    val pos = find_outside_strings(result, op)
    if pos >= 0:
        val left = result.substring(0, pos).trim()
        val right = result.substring(pos + op.len()).trim()
        val c_left = translate_expr(left, types)
        val c_right = translate_expr(right, types)
        return c_left + op + c_right
    ""

# Translate a Simple condition to C
fn translate_condition(cond: text, types: text) -> text:
    var result = cond
    # Handle "not" prefix
    if result.starts_with("not "):
        result = "!(" + translate_condition(result.substring(4), types) + ")"
        return result
    # Handle compound "or" (lower precedence - split first, translate each part recursively)
    val or_pos = find_outside_strings(result, " or ")
    if or_pos >= 0:
        val or_left = result.substring(0, or_pos).trim()
        val or_right = result.substring(or_pos + 4).trim()
        return translate_condition(or_left, types) + " || " + translate_condition(or_right, types)
    # Handle compound "and" (higher precedence - split and translate each part recursively)
    val and_pos = find_outside_strings(result, " and ")
    if and_pos >= 0:
        val and_left = result.substring(0, and_pos).trim()
        val and_right = result.substring(and_pos + 5).trim()
        return translate_condition(and_left, types) + " && " + translate_condition(and_right, types)
    # Handle "!= nil" and "== nil" - use NULL for text, < 0 for integers
    val nil_neq_pos = find_outside_strings(result, " != nil")
    if nil_neq_pos >= 0:
        val nil_var = result.substring(0, nil_neq_pos).trim()
        # Strip leading !( if present
        var clean_nil_var = nil_var
        if clean_nil_var.starts_with("!("):
            clean_nil_var = clean_nil_var.substring(2)
        if is_text_var(clean_nil_var, types):
            result = result.replace(" != nil", " != NULL")
        elif is_struct_type_var(clean_nil_var, types) != "":
            result = "1"
        elif is_string_array_var(clean_nil_var, types) or is_int_array_var(clean_nil_var, types):
            result = "1"
        elif is_struct_field_str_array(clean_nil_var, types) or is_struct_field_int_array(clean_nil_var, types):
            result = "1"
        else:
            result = result.replace(" != nil", " >= 0")
    val nil_eq_pos = find_outside_strings(result, " == nil")
    if nil_eq_pos >= 0:
        val nil_var = result.substring(0, nil_eq_pos).trim()
        if is_text_var(nil_var, types):
            result = result.replace(" == nil", " == NULL")
        elif is_struct_type_var(nil_var, types) != "":
            result = "0"
        elif is_string_array_var(nil_var, types) or is_int_array_var(nil_var, types):
            result = "0"
        elif is_struct_field_str_array(nil_var, types) or is_struct_field_int_array(nil_var, types):
            result = "0"
        else:
            result = result.replace(" == nil", " < 0")
    # Handle string equality: a == "str" or a == b where both are text
    # But NOT a == nil (which is a NULL check, handled above)
    val eq_pos = find_outside_strings(result, " == ")
    if eq_pos >= 0:
        val eq_left = result.substring(0, eq_pos).trim()
        val eq_right = result.substring(eq_pos + 4).trim()
        # Skip nil/NULL/0 comparisons (also handles "NULL || ..." after or-replacement)
        val skip_nil = eq_right == "NULL" or eq_right.starts_with("NULL ") or eq_right == "0" or eq_left == "NULL" or eq_left == "0"
        if not skip_nil:
            val left_is_text = is_text_var(eq_left, types)
            val right_is_text = is_text_var(eq_right, types)
            val left_is_str = eq_left.starts_with("\"") or eq_left.starts_with("r\"")
            val right_is_str = eq_right.starts_with("\"") or eq_right.starts_with("r\"")
            val left_is_arr_item = eq_left.contains(".items[")
            val str_cmp = left_is_text or right_is_text or left_is_str or right_is_str or left_is_arr_item
            if str_cmp:
                val c_left = translate_expr(eq_left, types)
                val c_right = translate_expr(eq_right, types)
                return r"strcmp(" + c_left + r", " + c_right + r") == 0"

    # Handle string inequality: a != "str"
    val neq_pos = find_outside_strings(result, " != ")
    if neq_pos >= 0:
        val neq_left = result.substring(0, neq_pos).trim()
        val neq_right = result.substring(neq_pos + 4).trim()
        # Skip NULL/nil/0 comparisons
        val skip_null = neq_right == "NULL" or neq_right == "0" or neq_left == "NULL" or neq_left == "0"
        if not skip_null:
            val neq_l_text = is_text_var(neq_left, types)
            val neq_r_text = is_text_var(neq_right, types)
            val neq_l_str = neq_left.starts_with("\"") or neq_left.starts_with("r\"")
            val neq_r_str = neq_right.starts_with("\"") or neq_right.starts_with("r\"")
            val neq_l_item = neq_left.contains(".items[")
            val str_neq = neq_l_text or neq_r_text or neq_l_str or neq_r_str or neq_l_item
            if str_neq:
                val c_left = translate_expr(neq_left, types)
                val c_right = translate_expr(neq_right, types)
                return r"strcmp(" + c_left + r", " + c_right + r") != 0"

    # Handle comparison operators by translating each side individually
    # This ensures .len() and other method calls are properly translated
    val cmp_ops: [text] = [" == ", " >= ", " <= ", " > ", " < "]
    for op in cmp_ops:
        val cmp_result = try_translate_binary_cmp(result, op, types)
        if cmp_result != "":
            return cmp_result

    # Translate method calls in conditions
    result = translate_expr(result, types)
    result

# Translate a method call expression to C
# Returns the original expression if no method call is detected
fn translate_method_expr(expr: text, types: text) -> text:
    # Extract method name once with a single scan instead of 15+ serial index_of() calls.
    # Find the last '.' before the first '(' to get: obj.method(args)
    val paren_pos = expr.index_of("(") ?? -1
    if paren_pos > 0:
        # Find the last '.' before '(' by scanning backward
        var method_dot = -1
        var scan_i = paren_pos - 1
        for scan_i in 0..paren_pos:
            val ch = expr.substring(paren_pos - 1 - scan_i, paren_pos - scan_i)
            if ch == ".":
                method_dot = paren_pos - 1 - scan_i
                # Found the last dot before paren - stop
                scan_i = paren_pos
        if method_dot >= 0:
            val method_name = expr.substring(method_dot + 1, paren_pos)
            val obj = expr.substring(0, method_dot)

            # Dispatch on extracted method name (O(1) string comparisons on short names)
            if method_name == "contains":
                val arg_end = find_close_paren(expr, paren_pos)
                if arg_end >= 0:
                    val arg = expr.substring(paren_pos + 1, arg_end)
                    if is_dict_var(obj, types):
                        return r"simple_dict_contains(" + obj + r", " + translate_expr(arg, types) + r")"
                    if is_string_array_var(obj, types):
                        return r"simple_str_array_contains(" + obj + r", " + translate_expr(arg, types) + r")"
                    if is_struct_field_str_array(obj, types):
                        return r"simple_str_array_contains(" + obj + r", " + translate_expr(arg, types) + r")"
                    return r"simple_contains(" + obj + r", " + translate_expr(arg, types) + r")"

            elif method_name == "starts_with":
                val r = translate_simple_method(expr, paren_pos, obj, "simple_starts_with", true, false, types)
                if r != "": return r

            elif method_name == "ends_with":
                val r = translate_simple_method(expr, paren_pos, obj, "simple_ends_with", true, false, types)
                if r != "": return r

            elif method_name == "substring":
                val arg_end = find_close_paren(expr, paren_pos)
                if arg_end >= 0:
                    val sub_arg = expr.substring(paren_pos + 1, arg_end)
                    # Check if single-arg form (no comma) -> add strlen as end
                    if sub_arg.contains(","):
                        return r"simple_substring(" + obj + r", " + sub_arg + r")"
                    return r"simple_substring(" + obj + r", " + sub_arg + r", simple_strlen(" + obj + r"))"

            elif method_name == "trim":
                return r"simple_trim(" + translate_expr(obj, types) + r")"

            elif method_name == "split":
                val r = translate_simple_method(expr, paren_pos, obj, "simple_split", false, false, types)
                if r != "": return r

            elif method_name == "replace":
                val r = translate_simple_method(expr, paren_pos, obj, "simple_replace", false, false, types)
                if r != "": return r

            elif method_name == "index_of":
                val r = translate_simple_method(expr, paren_pos, obj, "simple_index_of", false, false, types)
                if r != "": return r

            elif method_name == "last_index_of":
                val r = translate_simple_method(expr, paren_pos, obj, "simple_last_index_of", false, false, types)
                if r != "": return r

            elif method_name == "join":
                val r = translate_simple_method(expr, paren_pos, obj, "simple_string_join", false, true, types)
                if r != "": return r

            elif method_name == "len":
                val base = obj
                val len_resolved = resolve_len(base, types)
                if len_resolved != "":
                    return len_resolved
                # Check if base contains bracket indexing (e.g., arr[idx].len())
                val base_bracket = base.index_of("[") ?? -1
                if base_bracket >= 0:
                    val c_base = translate_expr(base, types)
                    return c_base + r".len"
                return base + r".len"

            elif method_name == "to_int":
                return r"atoll(" + obj + r")"

            elif method_name == "pop":
                val base = obj
                if is_int_array_var(base, types):
                    return r"simple_int_pop(&" + base + r")"
                return r"simple_string_pop(&" + base + r")"

            elif method_name == "keys":
                if is_dict_var(obj, types):
                    return r"simple_dict_keys(" + obj + r")"

            elif method_name == "remove":
                if is_dict_var(obj, types):
                    val arg_end = find_close_paren(expr, paren_pos)
                    if arg_end >= 0:
                        val arg = expr.substring(paren_pos + 1, arg_end)
                        return r"simple_dict_remove(" + obj + r", " + arg + r")"

            else:
                pass

    # Struct method call: obj.method(args) where obj is a known struct variable
    val dot_pos = expr.index_of(".") ?? -1
    if dot_pos >= 0:
        val obj = expr.substring(0, dot_pos).trim()
        val after_dot = expr.substring(dot_pos + 1)
        val m_paren = after_dot.index_of("(") ?? -1
        if m_paren >= 0:
            val method_name = after_dot.substring(0, m_paren).trim()
            val class_name = is_struct_type_var(obj, types)
            if class_name != "":
                if is_known_method(class_name, method_name, types):
                    val m_close = find_close_paren(after_dot, m_paren)
                    var m_args = ""
                    if m_close > m_paren + 1:
                        m_args = after_dot.substring(m_paren + 1, m_close)
                    if is_me_method(class_name, method_name, types):
                        if m_args != "":
                            return class_name + r"__" + method_name + r"(&" + obj + r", " + m_args + r")"
                        return class_name + r"__" + method_name + r"(&" + obj + r")"
                    else:
                        if m_args != "":
                            return class_name + r"__" + method_name + r"(&" + obj + r", " + m_args + r")"
                        return class_name + r"__" + method_name + r"(&" + obj + r")"
            # Check if obj is a class name (static method call)
            if is_known_struct(obj, types):
                if is_static_fn(obj, method_name, types):
                    val m_close = find_close_paren(after_dot, m_paren)
                    var m_args = ""
                    if m_close > m_paren + 1:
                        m_args = after_dot.substring(m_paren + 1, m_close)
                    if m_args != "":
                        return obj + r"__" + method_name + r"(" + m_args + r")"
                    return obj + r"__" + method_name + r"()"
        else:
            # Field access: obj.field (no parens)
            val class_name = is_struct_type_var(obj, types)
            if class_name != "":
                val field_name = after_dot.trim()
                return obj + r"." + field_name

    # No method call detected
    expr

# Translate a Simple expression to C
fn translate_expr(expr: text, types: text) -> text:
    # Handle nil
    if expr == "nil":
        return "NULL"
    if expr == "true":
        return "1"
    if expr == "false":
        return "0"
    if expr == "()":
        return "/* unit */"
    # Handle 'not' prefix in expressions
    if expr.starts_with("not "):
        val not_inner = expr.substring(4).trim()
        return r"!(" + translate_expr(not_inner, types) + r")"
    if expr == "None":
        return "simple_none()"

    # Handle numeric literals: octal 0o prefix -> 0, remove underscores
    if expr.starts_with("0o"):
        val oct_rest = expr.substring(2)
        val oct_parts = oct_rest.split("_")
        val oct_clean = oct_parts.join("")
        return "0" + oct_clean
    if expr.contains("_"):
        val first_ch = expr.substring(0, 1)
        val is_digit = first_ch >= "0" and first_ch <= "9"
        if is_digit:
            val num_parts = expr.split("_")
            return num_parts.join("")

    # Handle raw string literals: r"..." -> "..." (strip r prefix)
    # Only match complete literals (no top-level + operators)
    if expr.starts_with("r\"") and expr.ends_with("\""):
        val raw_plus = find_top_level_plus(expr.substring(1))
        if raw_plus < 0:
            return expr.substring(1)

    # Handle enum variant access: EnumName.Variant -> EnumName_Variant
    val ev_dot = expr.index_of(".") ?? -1
    if ev_dot >= 0:
        val ev_name = expr.substring(0, ev_dot).trim()
        val ev_after = expr.substring(ev_dot + 1).trim()
        # No further dots or parens = simple variant access
        val ev_has_paren = ev_after.contains("(")
        val ev_has_dot = ev_after.contains(".")
        if not ev_has_paren and not ev_has_dot:
            if is_enum_variant(expr, types):
                return ev_name + r"_" + ev_after

    # Handle inline ternary: if cond: expr1 else: expr2 -> cond ? expr1 : expr2
    if expr.starts_with("if ") and expr.contains(" else: "):
        val else_pos = expr.index_of(" else: ") ?? -1
        if else_pos >= 0:
            val if_part = expr.substring(3, else_pos).trim()
            val else_expr = expr.substring(else_pos + 7).trim()
            val colon_pos = if_part.index_of(":") ?? -1
            if colon_pos >= 0:
                val cond = if_part.substring(0, colon_pos).trim()
                val then_expr = if_part.substring(colon_pos + 1).trim()
                val c_cond = translate_condition(cond, types)
                val c_then = translate_expr(then_expr, types)
                val c_else = translate_expr(else_expr, types)
                return r"(" + c_cond + r" ? " + c_then + r" : " + c_else + r")"

    # Handle Some(v)
    if expr.starts_with("Some(") and expr.ends_with(")"):
        val inner = expr.substring(5, expr.len() - 1).trim()
        val c_inner = translate_expr(inner, types)
        # Detect type for Some
        val is_str = inner.starts_with("\"") or inner.starts_with("r\"")
        val is_text = is_text_var(inner, types)
        if is_str or is_text:
            return "simple_some_str(" + c_inner + ")"
        return "simple_some_int(" + c_inner + ")"

    # Handle int(x) builtin -> atoll(x)
    if expr.starts_with("int(") and expr.ends_with(")"):
        val int_inner = expr.substring(4, expr.len() - 1).trim()
        val c_int_inner = translate_expr(int_inner, types)
        return r"atoll(" + c_int_inner + r")"

    # Handle ?? (null coalescing) - use find_outside_strings to skip string literals
    val nq_pos = find_outside_strings(expr, " ?? ")
    if nq_pos >= 0:
        val left = expr.substring(0, nq_pos).trim()
        val right = expr.substring(nq_pos + 4).trim()
        val c_left = translate_expr(left, types)
        val c_right = translate_expr(right, types)
        # For index_of ?? -1, index_of already returns -1 on not found
        if c_right == "-1":
            val has_iof = c_left.contains("simple_index_of") or c_left.contains("simple_last_index_of")
            if has_iof:
                return c_left
        # String coalescing: use NULL check
        val left_is_text = is_text_var(left, types)
        val right_is_str = right.starts_with("\"") or right.starts_with("r\"")
        val right_is_text = is_text_var(right, types)
        if left_is_text or right_is_str or right_is_text:
            return r"(" + c_left + r" != NULL ? " + c_left + r" : " + c_right + r")"
        # General integer coalescing
        return r"(" + c_left + r" >= 0 ? " + c_left + r" : " + c_right + r")"

    # Handle pipe operator: expr |> func
    val pipe_pos = find_outside_strings(expr, " |> ")
    if pipe_pos >= 0:
        val left = expr.substring(0, pipe_pos).trim()
        val right = expr.substring(pipe_pos + 4).trim()
        val c_left = translate_expr(left, types)
        return right + r"(" + c_left + r")"

    # Handle "key in dict" -> simple_dict_contains(dict, key)
    val in_pos = find_outside_strings(expr, " in ")
    if in_pos >= 0:
        val left = expr.substring(0, in_pos).trim()
        val right = expr.substring(in_pos + 4).trim()
        if is_dict_var(right, types):
            return r"simple_dict_contains(" + right + r", " + translate_expr(left, types) + r")"

    # Handle complete string literals (starts and ends with quote, no unquoted +)
    # Also handle raw string literals: r"..." -> "..."
    if expr.starts_with("r\"") and expr.ends_with("\""):
        val raw_inner = expr.substring(1)
        val has_concat = find_top_level_plus(raw_inner) >= 0
        if not has_concat:
            return raw_inner
    if expr.starts_with("\"") and expr.ends_with("\""):
        val has_concat = find_top_level_plus(expr) >= 0
        if not has_concat:
            return expr

    # Handle empty dict literal
    if expr == "{}":
        return "simple_dict_new()"

    # Handle string concatenation with +
    val plus_pos = find_top_level_plus(expr)
    if plus_pos >= 0:
        val left = expr.substring(0, plus_pos).trim()
        val right = expr.substring(plus_pos + 3).trim()
        val left_is_str = left.starts_with("\"") or left.starts_with("r\"")
        val right_is_str = right.starts_with("\"") or right.starts_with("r\"")
        val left_is_text = is_text_var(left, types)
        val right_is_text = is_text_var(right, types)
        val left_is_method = left.contains("simple_")
        val right_is_method = right.contains("simple_")
        val either_str = left_is_str or right_is_str
        val either_text = left_is_text or right_is_text
        val either_method = left_is_method or right_is_method
        val is_string_concat = either_str or either_text or either_method
        if is_string_concat:
            val c_left = translate_expr(left, types)
            val c_right = translate_expr(right, types)
            # Auto-convert integer to string in string context
            # If right is not a string/text/function-returning-string, wrap with simple_int_to_str
            # Exclude function calls (contain "(") and array element accesses (.items[) to avoid wrapping text-returning expressions
            val right_needs_int_conv = (left_is_str or left_is_text) and not right_is_str and not right_is_text and not right_is_method and not c_right.contains("simple_") and not c_right.contains(".items[") and not c_right.starts_with("\"") and not c_right.starts_with("(") and not right.contains("(")
            val left_needs_int_conv = (right_is_str or right_is_text) and not left_is_str and not left_is_text and not left_is_method and not c_left.contains("simple_") and not c_left.contains(".items[") and not c_left.starts_with("\"") and not c_left.starts_with("(") and not left.contains("(")
            var final_left = c_left
            var final_right = c_right
            if right_needs_int_conv:
                final_right = r"simple_int_to_str(" + c_right + r")"
            if left_needs_int_conv:
                final_left = r"simple_int_to_str(" + c_left + r")"
            return r"simple_str_concat(" + final_left + r", " + final_right + r")"
        # Array concat: arr + [elem]
        if right.starts_with("[") and right.ends_with("]"):
            val arr_elem = right.substring(1, right.len() - 1).trim()
            val c_left = translate_expr(left, types)
            val c_arr_elem = translate_expr(arr_elem, types)
            # Check struct array variable
            val sa_elem_type = is_struct_array_var(left, types)
            if sa_elem_type != "":
                return "(\{ " + sa_elem_type + "* _cp = malloc(sizeof(" + sa_elem_type + ")); *_cp = " + c_arr_elem + "; simple_struct_array_copy_push(" + c_left + ", (void*)_cp); })"
            # Check struct field that is a struct array
            val sf_elem_type = is_struct_field_struct_array(left, types)
            if sf_elem_type != "":
                return "(\{ " + sf_elem_type + "* _cp = malloc(sizeof(" + sf_elem_type + ")); *_cp = " + c_arr_elem + "; simple_struct_array_copy_push(" + c_left + ", (void*)_cp); })"
            # Check int array
            if is_int_array_var(left, types):
                return r"simple_int_array_copy_push(" + c_left + r", " + c_arr_elem + r")"
            # Check string array
            if is_string_array_var(left, types):
                return r"simple_string_array_copy_push(" + c_left + r", " + c_arr_elem + r")"

    # Pre-process: replace .len() within complex expressions
    # This handles cases like arr.len() - 1 inside brackets
    # Use find_outside_strings to avoid matching .len() inside string literals
    if find_outside_strings(expr, ".len()") >= 0:
        var processed = expr
        # Find and replace each .len() occurrence (outside string literals)
        var len_pos = find_outside_strings(processed, ".len()")
        if len_pos >= 0:
            val len_full_base = processed.substring(0, len_pos)
            val len_rest = processed.substring(len_pos + 6)
            # Extract just the variable/field part (after last comma, space, or paren)
            var len_base = len_full_base
            var len_prefix = ""
            var lscan = len_full_base.len() - 1
            var lfound = false
            while lscan >= 0 and not lfound:
                val lch = len_full_base[lscan]
                val is_sep = lch == "," or lch == " " or lch == "(" or lch == "["
                if is_sep:
                    len_prefix = len_full_base.substring(0, lscan + 1)
                    len_base = len_full_base.substring(lscan + 1).trim()
                    lfound = true
                lscan = lscan - 1
            # Directly resolve .len() based on type
            var len_replacement = resolve_len(len_base, types)
            if len_replacement == "":
                # Fallback: try translate_method_expr
                val len_result = translate_method_expr(len_base + ".len()", types)
                val len_orig = len_base + ".len()"
                if len_result != len_orig and not len_result.ends_with(".len"):
                    len_replacement = len_result
            if len_replacement != "":
                processed = len_prefix + len_replacement + len_rest
                return translate_expr(processed, types)

    # Handle method calls
    val method_result = translate_method_expr(expr, types)
    if method_result != expr:
        return method_result

    # Handle dict indexing: d[key] where d is a known dict
    val bracket_pos = expr.index_of("[") ?? -1
    if bracket_pos >= 0:
        val base = expr.substring(0, bracket_pos)
        if is_dict_var(base, types):
            val idx_end = expr.index_of("]") ?? -1
            if idx_end >= 0:
                val idx_expr = expr.substring(bracket_pos + 1, idx_end)
                return r"simple_dict_get(" + base + r", " + translate_expr(idx_expr, types) + r")"

    # Handle string indexing and slicing: s[idx] or s[start:end]
    if bracket_pos >= 0:
        val base = expr.substring(0, bracket_pos)
        val base_is_text_var = is_text_var(base, types)
        val base_is_field_text = is_struct_field_text(base, types)
        if base_is_text_var or base_is_field_text:
            val idx_end = expr.index_of("]") ?? -1
            if idx_end >= 0:
                val idx_expr = expr.substring(bracket_pos + 1, idx_end)
                # Check for slice syntax: s[start:end]
                val colon_pos = idx_expr.index_of(":") ?? -1
                if colon_pos >= 0:
                    val start_expr = idx_expr.substring(0, colon_pos).trim()
                    val end_expr = idx_expr.substring(colon_pos + 1).trim()
                    # Handle open-ended slice: s[start:] -> s[start:len]
                    if end_expr == "":
                        return r"simple_substring(" + base + r", " + translate_expr(start_expr, types) + r", simple_strlen(" + base + r"))"
                    return r"simple_substring(" + base + r", " + translate_expr(start_expr, types) + r", " + translate_expr(end_expr, types) + r")"
                return r"simple_char_at(" + base + r", " + translate_expr(idx_expr, types) + r")"

    # Handle items-indexed array indexing: arr[i] -> arr.items[i]
    if bracket_pos >= 0:
        val base = expr.substring(0, bracket_pos)
        if is_items_indexed_array(base, types):
            val idx_end = expr.index_of("]") ?? -1
            if idx_end >= 0:
                val idx_expr = expr.substring(bracket_pos + 1, idx_end)
                return base + r".items[" + translate_expr(idx_expr, types) + r"]"

    # Handle struct array indexing: arr[i] -> *(ElementType*)arr.items[i]
    if bracket_pos >= 0:
        val base = expr.substring(0, bracket_pos)
        val sa_elem = is_struct_array_var(base, types)
        if sa_elem != "":
            val idx_end = expr.index_of("]") ?? -1
            if idx_end >= 0:
                val idx_expr = expr.substring(bracket_pos + 1, idx_end)
                val c_idx = translate_expr(idx_expr, types)
                val after_bracket = expr.substring(idx_end + 1)
                if after_bracket.starts_with("."):
                    # Chained field access: arr[i].field -> (*(Type*)arr.items[i]).field
                    return r"(*(" + sa_elem + r"*)" + base + r".items[" + c_idx + r"])" + after_bracket
                return r"*(" + sa_elem + r"*)" + base + r".items[" + c_idx + r"]"

    # Handle optional chaining: expr.? -> simple_option_has(expr)
    if expr.ends_with(".?"):
        val base = expr.substring(0, expr.len() - 2).trim()
        return r"simple_option_has(" + translate_expr(base, types) + r")"

    # Handle optional chaining: obj?.field -> temp var pattern
    val opt_chain_pos = expr.index_of("?.") ?? -1
    if opt_chain_pos >= 0:
        # Skip if ?. is inside a string literal
        val before_opt = expr.substring(0, opt_chain_pos)
        val quote_parts_opt = before_opt.split("\"")
        val quote_count_opt = quote_parts_opt.len() - 1
        val opt_in_str = quote_count_opt % 2 == 1
        if not opt_in_str:
            val left = expr.substring(0, opt_chain_pos).trim()
            val right = expr.substring(opt_chain_pos + 2).trim()
            val c_left = translate_expr(left, types)
            return r"(" + c_left + r" != NULL ? " + c_left + r"->" + right + r" : NULL)"

    # Handle struct construction: ClassName(field: val, field2: val2)
    val ctor_paren = expr.index_of("(") ?? -1
    if ctor_paren >= 0 and expr.ends_with(")"):
        val ctor_name = expr.substring(0, ctor_paren).trim()
        if is_known_struct(ctor_name, types):
            val ctor_args = expr.substring(ctor_paren + 1, expr.len() - 1).trim()
            if ctor_args.contains(":"):
                # Named construction: Point(x: 3, y: 4) -> (Point){.x = 3, .y = 4}
                val cparts = ctor_args.split(",")
                var designated: [text] = []
                for cp in cparts:
                    val cpt = cp.trim()
                    val ccolon = cpt.index_of(":") ?? -1
                    if ccolon >= 0:
                        val fname = cpt.substring(0, ccolon).trim()
                        val fval = cpt.substring(ccolon + 1).trim()
                        # Handle [] in struct field init - use correct type based on field
                        var c_fval = ""
                        if fval == "[]":
                            val field_arr_marker = ";field_arr:" + ctor_name + "." + fname + ";"
                            val field_int_arr_marker = ";field_int_arr:" + ctor_name + "." + fname + ";"
                            val field_struct_arr_prefix = ";field_struct_arr:" + ctor_name + "." + fname + "="
                            if types.contains(field_arr_marker):
                                c_fval = "simple_new_string_array()"
                            elif types.contains(field_int_arr_marker):
                                c_fval = "simple_new_int_array()"
                            elif types.contains(field_struct_arr_prefix):
                                c_fval = "simple_new_struct_array()"
                            else:
                                c_fval = "simple_new_int_array()"
                        else:
                            c_fval = translate_expr(fval, types)
                        designated.push(r"." + fname + r" = " + c_fval)
                val desig_str = designated.join(", ")
                return "(" + ctor_name + ")\{" + desig_str + "}"
            # Enum variant construction: EnumName.Variant(args) is handled in method_expr
            # Positional construction fallback
            val args_c = translate_expr(ctor_args, types)
            return ctor_name + r"__" + ctor_name + r"(" + args_c + r")"

    # Handle enum variant: EnumName.Variant or EnumName.Variant(args)
    val edot_pos = expr.index_of(".") ?? -1
    if edot_pos >= 0:
        val ename = expr.substring(0, edot_pos).trim()
        val erest = expr.substring(edot_pos + 1).trim()
        if is_known_struct(ename, types):
            val ev_paren = erest.index_of("(") ?? -1
            if ev_paren >= 0:
                val ev_name = erest.substring(0, ev_paren).trim()
                val ev_close = erest.index_of(")") ?? -1
                if ev_close > ev_paren + 1:
                    val ev_args = erest.substring(ev_paren + 1, ev_close).trim()
                    return ename + r"__" + ev_name + r"(" + translate_expr(ev_args, types) + r")"
                return ename + r"__" + ev_name + r"()"
            else:
                # Simple enum variant or field access
                return ename + r"__" + erest

    # Handle general function calls: translate each argument individually
    # This ensures string concat and other patterns inside arguments get translated
    if ctor_paren >= 0 and expr.ends_with(")"):
        val fc_name = expr.substring(0, ctor_paren).trim()
        val fc_has_dot = fc_name.contains(".")
        val fc_is_struct = is_known_struct(fc_name, types)
        if not fc_has_dot and not fc_is_struct and fc_name.len() > 0:
            val fc_close = find_close_paren(expr, ctor_paren)
            if fc_close >= 0:
                val fc_args_str = expr.substring(ctor_paren + 1, fc_close)
                # Split args by top-level commas using char-by-char scanning
                # Handles escaped quotes and nested parens correctly
                var fc_args: [text] = []
                var fc_depth = 0
                var fc_in_str = false
                var fc_arg_start = 0
                var fc_si = 0
                val fc_slen = fc_args_str.len()
                while fc_si < fc_slen:
                    val fc_ch = fc_args_str.substring(fc_si, fc_si + 1)
                    if fc_in_str:
                        if fc_ch == "\\" and fc_si + 1 < fc_slen:
                            fc_si = fc_si + 2
                            continue
                        if fc_ch == "\"":
                            fc_in_str = false
                        fc_si = fc_si + 1
                        continue
                    if fc_ch == "\"":
                        fc_in_str = true
                        fc_si = fc_si + 1
                        continue
                    if fc_ch == "(":
                        fc_depth = fc_depth + 1
                    elif fc_ch == ")":
                        fc_depth = fc_depth - 1
                    elif fc_ch == "," and fc_depth == 0:
                        fc_args.push(fc_args_str.substring(fc_arg_start, fc_si))
                        fc_arg_start = fc_si + 1
                    fc_si = fc_si + 1
                # Push last arg
                if fc_arg_start < fc_slen:
                    fc_args.push(fc_args_str.substring(fc_arg_start, fc_slen))
                elif fc_slen == 0:
                    0
                var fc_translated: [text] = []
                for fc_a in fc_args:
                    fc_translated.push(translate_expr(fc_a.trim(), types))
                val fc_result = fc_translated.join(", ")
                val fc_after = expr.substring(fc_close + 1)
                if fc_after == "":
                    return fc_name + r"(" + fc_result + r")"
                return fc_name + r"(" + fc_result + r")" + fc_after

    # Handle tuple construction: (a, b)
    if expr.starts_with("(") and expr.ends_with(")"):
        val inner = expr.substring(1, expr.len() - 1).trim()
        if inner.contains(","):
            val tparts = inner.split(",")
            if tparts.len() == 2:
                val t0 = translate_expr(tparts[0].trim(), types)
                val t1 = translate_expr(tparts[1].trim(), types)
                return "(SimpleTuple2)\{._0 = (void*)(long long)(" + t0 + "), ._1 = (void*)(long long)(" + t1 + ")}"
            if tparts.len() == 3:
                val t0 = translate_expr(tparts[0].trim(), types)
                val t1 = translate_expr(tparts[1].trim(), types)
                val t2 = translate_expr(tparts[2].trim(), types)
                return "(SimpleTuple3)\{._0 = (void*)(long long)(" + t0 + "), ._1 = (void*)(long long)(" + t1 + "), ._2 = (void*)(long long)(" + t2 + ")}"

    expr

export is_c_expr_string_result, extract_fn_names
export translate_simple_method, is_items_indexed_array, resolve_len
export gen_array_for_loop, try_translate_compound_assign, try_translate_binary_cmp
export translate_condition, translate_method_expr, translate_expr
