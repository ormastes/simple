# Native Compilation Pipeline
#
# C code generation from Simple source -> clang/gcc compilation -> mold linking.
# This bridges the gap until the full LLVM IR pipeline (MIR -> LLVM IR) is functional.
#
# Supports:
#   - print statements (with string interpolation)
#   - val/var declarations (integers, strings, arrays)
#   - fn main(): wrapping
#   - Function declarations and calls (fn name(args) -> type:)
#   - if/elif/else
#   - return statements
#   - while loops
#   - for i in range(start, end): loops
#   - for item in array: loops
#   - match value: / case X: / case _: (strings and integers)
#   - Array literals and indexing (arr[i])
#   - break / continue
#   - Compound assignment (+=, -=, *=, /=)
#   - Comments
#
# Usage: simple compile --native -o hello hello.spl
#
# Can be run as standalone: bin/release/simple src/app/compile/native.spl <source> <output> [--verbose]

# Direct extern declarations to avoid module closure limitations
extern fn rt_file_read_text(path: text) -> text
extern fn rt_file_write_text(path: text, content: text) -> bool
extern fn rt_file_exists(path: text) -> bool
extern fn rt_cli_get_args() -> [str]

use app.io.file_shell.{shell, shell_output, file_write, file_delete, file_size}
use app.compile.c_codegen.{generate_c_code}
use std.log.{error, warn, info, debug}

# ============================================================================
# Platform Detection
# ============================================================================

fn detect_platform() -> text:
    val uname = shell_output("uname -s 2>/dev/null")
    if uname.starts_with("Linux"):
        return "linux"
    if uname.starts_with("Darwin"):
        return "macos"
    if uname.starts_with("FreeBSD"):
        return "freebsd"
    if uname.starts_with("MINGW") or uname.starts_with("MSYS") or uname.starts_with("CYGWIN"):
        return "windows"
    if uname == "":
        # uname failed - likely Windows without MSYS
        val win_check = shell_output("cmd /c ver 2>NUL")
        if win_check.contains("Windows"):
            return "windows"
    "unknown"

# ============================================================================
# Compiler Detection
# ============================================================================

fn find_c_compiler() -> text:
    val compilers: [text] = ["clang", "gcc", "cc"]
    for compiler in compilers:
        val check = shell_output("which {compiler} 2>/dev/null")
        if check.len() > 0:
            return compiler
    ""

# ============================================================================
# Mold Detection
# ============================================================================

fn find_mold_for_native() -> text:
    # mold is Linux-only
    val platform = detect_platform()
    if platform != "linux":
        return ""
    val current_dir = shell_output("pwd")
    val local_mold = current_dir + "/bin/mold/mold"
    if rt_file_exists(local_mold):
        return local_mold
    val which_result = shell_output("which mold 2>/dev/null")
    if which_result.len() > 0:
        return which_result
    ""

# ============================================================================
# Multi-File Dependency Collection
# ============================================================================

fn get_dir_of_file(path: text) -> text:
    val last_slash = path.last_index_of("/") ?? -1
    if last_slash >= 0:
        return path.substring(0, last_slash)
    "."

fn extract_use_modules(source: text) -> [text]:
    var modules: [text] = []
    val lines = source.split("\n")
    for line in lines:
        val trimmed = line.trim()
        if trimmed.starts_with("use "):
            val rest = trimmed.substring(4).trim()
            # Skip compiler internals (no local files to bundle)
            if rest.starts_with("compiler."):
                continue
            # Extract module path (before { or .)
            var module_path = rest
            val brace_idx = rest.index_of("\{") ?? -1
            if brace_idx >= 0:
                module_path = rest.substring(0, brace_idx).trim()
                if module_path.ends_with("."):
                    module_path = module_path.substring(0, module_path.len() - 1)
            if module_path.ends_with(".*"):
                # Wildcard import: strip .* and include the base module
                module_path = module_path.substring(0, module_path.len() - 2)
            elif module_path.ends_with("*"):
                continue
            if module_path.len() > 0:
                modules.push(module_path)
    modules

fn resolve_module_file(module_path: text, base_dir: text) -> text:
    val rel_path = module_path.replace(".", "/")
    val spl_path = base_dir + "/" + rel_path + ".spl"
    if rt_file_exists(spl_path):
        return spl_path
    val init_path = base_dir + "/" + rel_path + "/__init__.spl"
    if rt_file_exists(init_path):
        return init_path
    # Handle app.X.Y imports - resolve to src/app/X/Y.spl from project root
    if module_path.starts_with("app."):
        val parts = module_path.substring(4)
        val app_rel = parts.replace(".", "/")
        val app_path = "src/app/" + app_rel + ".spl"
        if rt_file_exists(app_path):
            return app_path
        val app_init = "src/app/" + app_rel + "/__init__.spl"
        if rt_file_exists(app_init):
            return app_init
    # Handle std.X.Y imports - resolve to src/lib/X/Y.spl from project root
    if module_path.starts_with("std."):
        val parts = module_path.substring(4)
        val lib_rel = parts.replace(".", "/")
        val lib_path = "src/lib/" + lib_rel + ".spl"
        if rt_file_exists(lib_path):
            return lib_path
        val lib_init = "src/lib/" + lib_rel + "/__init__.spl"
        if rt_file_exists(lib_init):
            return lib_init
    # Fallback: strip leading package prefix if it matches the base dir name
    # Handles intra-package imports like "use compiler.core.tokens" when base_dir is src/core
    val dot_pos = module_path.index_of(".") ?? -1
    if dot_pos >= 0:
        val pkg_prefix = module_path.substring(0, dot_pos)
        val last_slash = base_dir.last_index_of("/") ?? -1
        var dir_name = base_dir
        if last_slash >= 0:
            dir_name = base_dir.substring(last_slash + 1)
        if pkg_prefix == dir_name:
            val stripped_mod = module_path.substring(dot_pos + 1)
            val stripped = stripped_mod.replace(".", "/")
            val stripped_path = base_dir + "/" + stripped + ".spl"
            if rt_file_exists(stripped_path):
                return stripped_path
            val stripped_init = base_dir + "/" + stripped + "/__init__.spl"
            if rt_file_exists(stripped_init):
                return stripped_init
    ""

fn collect_all_sources(source_file: text, source: text, verbose: bool) -> text:
    val base_dir = get_dir_of_file(source_file)
    var visited: [text] = [source_file]
    var dep_sources: [text] = []
    var queue: [text] = []

    # Seed queue with main file's use imports
    val main_modules = extract_use_modules(source)
    for mod_path in main_modules:
        val file_path = resolve_module_file(mod_path, base_dir)
        if file_path != "" and not visited.contains(file_path):
            visited.push(file_path)
            queue.push(file_path)

    # BFS over dependency files
    var qi = 0
    var combined_size = source.len()
    while qi < queue.len():
        val dep_file = queue[qi]
        qi = qi + 1
        val dep_source = rt_file_read_text(dep_file) ?? ""
        if dep_source == "":
            if verbose:
                warn("compile", "cannot read dependency: {dep_file}")
            continue
        # Skip if combined source would exceed 500KB
        if combined_size + dep_source.len() > 500000:
            if verbose:
                debug("compile", "Skipping dependency (size limit): {dep_file}")
            continue
        if verbose:
            debug("compile", "Including dependency: {dep_file}")
        dep_sources.push(dep_source)
        combined_size = combined_size + dep_source.len()

        # Discover transitive dependencies
        val dep_dir = get_dir_of_file(dep_file)
        val sub_modules = extract_use_modules(dep_source)
        for sub_mod in sub_modules:
            val sub_file = resolve_module_file(sub_mod, dep_dir)
            if sub_file != "" and not visited.contains(sub_file):
                visited.push(sub_file)
                queue.push(sub_file)

    if dep_sources.len() == 0:
        return source

    var combined = ""
    for dep_src in dep_sources:
        combined = combined + dep_src + "\n"
    combined + source

# ============================================================================
# Compilation Pipeline
# ============================================================================

fn compile_native(source_file: text, output_file: text, verbose: bool, compiler_override: text, sanitize: bool) -> i64:
    if verbose:
        info("compile", "Compiling {source_file} to native binary...")

    # Step 1: Read source file
    val source_raw = rt_file_read_text(source_file)
    val source_single = source_raw ?? ""
    if source_single == "":
        error("compile", "Cannot read source file: {source_file}")
        return 1

    # Step 1b: Collect dependencies (multi-file support)
    val source = collect_all_sources(source_file, source_single, verbose)

    # Step 2: Generate C code
    val c_code = generate_c_code(source)
    if verbose:
        debug("compile", "Generated C code ({c_code.len()} bytes)")

    # Step 3: Write to temp file
    val temp_c = shell_output("mktemp /tmp/simple_native_XXXXXX.c")
    if temp_c == "":
        error("compile", "Failed to create temp file")
        return 1

    if not file_write(temp_c, c_code):
        error("compile", "Failed to write temp C file: {temp_c}")
        return 1

    if verbose:
        debug("compile", "Wrote temp C file: {temp_c}")

    # Step 4: Find compiler and mold, then compile
    val cc = if compiler_override != "": compiler_override else: find_c_compiler()
    if cc == "":
        error("compile", "No C compiler found (tried clang, gcc, cc)")
        file_delete(temp_c)
        return 1

    val mold_path = find_mold_for_native()
    var gcc_cmd = ""
    var used_mold = false

    var sanitize_flags = ""
    if sanitize:
        sanitize_flags = "-fsanitize=address,leak -fno-omit-frame-pointer -g "

    if mold_path != "":
        var mold_dir = "."
        val last_slash = mold_path.last_index_of("/") ?? -1
        if last_slash >= 0:
            mold_dir = mold_path.substring(0, last_slash)
        gcc_cmd = "{cc} {sanitize_flags}-fuse-ld=mold -B {mold_dir}/ -o '{output_file}' '{temp_c}'"
        used_mold = true
        if verbose:
            debug("compile", "Using mold linker at: {mold_path}")
    else:
        gcc_cmd = "{cc} {sanitize_flags}-o '{output_file}' '{temp_c}'"
        if verbose:
            debug("compile", "No mold found, using system linker")

    if verbose:
        debug("compile", "Running: {gcc_cmd}")

    val (gcc_out, gcc_err, gcc_exit) = shell(gcc_cmd)

    # Step 5: Cleanup temp file
    file_delete(temp_c)

    # Step 6: Report results
    if gcc_exit != 0:
        error("compile", "Compilation failed (exit code {gcc_exit})")
        if gcc_err != "":
            error("compile", gcc_err)
        return 1

    if rt_file_exists(output_file):
        val size = file_size(output_file)
        info("compile", "Compiled: {output_file} ({size} bytes)")
        if verbose:
            var linker_name = "system"
            if used_mold:
                linker_name = "mold"
            debug("compile", "Linker: {linker_name}")
    else:
        error("compile", "Output file not created: {output_file}")
        return 1

    0

# ============================================================================
# Multi-File Linked Compilation (separate compile + link via mold/gcc)
# ============================================================================

fn compile_c_to_object(c_file: text, obj_file: text, verbose: bool, cc: text, sanitize: bool) -> bool:
    var san_flags = ""
    if sanitize:
        san_flags = "-fsanitize=address,leak -fno-omit-frame-pointer -g "
    val cmd = "{cc} {san_flags}-c -fPIE -o '{obj_file}' '{c_file}'"
    if verbose:
        debug("compile", "{cc} -c: {c_file} -> {obj_file}")
    val (out, err, exit_code) = shell(cmd)
    if exit_code != 0:
        error("compile", "compile failed for {c_file}")
        if err != "":
            error("compile", err)
        return false
    true

fn link_objects(obj_files: [text], output_file: text, verbose: bool, cc: text) -> bool:
    # Build link command: use mold if available, else system linker
    val mold_path = find_mold_for_native()
    var link_cmd = cc
    if mold_path != "":
        var mold_dir = "."
        val last_slash = mold_path.last_index_of("/") ?? -1
        if last_slash >= 0:
            mold_dir = mold_path.substring(0, last_slash)
        link_cmd = "{cc} -fuse-ld=mold -B {mold_dir}/"
        if verbose:
            debug("compile", "Using mold linker at: {mold_path}")
    else:
        if verbose:
            debug("compile", "Using system linker ({cc})")

    # Add object files
    for obj in obj_files:
        link_cmd = link_cmd + " '{obj}'"
    link_cmd = link_cmd + " -o '{output_file}'"

    if verbose:
        debug("compile", "Link: {link_cmd}")

    val (out, err, exit_code) = shell(link_cmd)
    if exit_code != 0:
        error("compile", "Linking failed (exit code {exit_code})")
        if err != "":
            error("compile", err)
        return false
    true

fn compile_native_linked(source_file: text, output_file: text, verbose: bool, compiler_override: text, sanitize: bool) -> i64:
    if verbose:
        info("compile", "Compiling {source_file} to native binary (separate compile+link)...")

    # Step 1: Read main source
    val source_raw = rt_file_read_text(source_file)
    val source_single = source_raw ?? ""
    if source_single == "":
        error("compile", "Cannot read source file: {source_file}")
        return 1

    # Step 2: Discover dependency files via BFS
    val base_dir = get_dir_of_file(source_file)
    var dep_sources: [text] = []
    var visited: [text] = [source_file]
    var queue: [text] = []

    val main_modules = extract_use_modules(source_single)
    for mod_path in main_modules:
        val file_path = resolve_module_file(mod_path, base_dir)
        if file_path != "" and not visited.contains(file_path):
            visited.push(file_path)
            queue.push(file_path)

    var qi = 0
    while qi < queue.len():
        val dep_file = queue[qi]
        qi = qi + 1
        val dep_source = rt_file_read_text(dep_file) ?? ""
        if dep_source == "":
            if verbose:
                warn("compile", "cannot read dependency: {dep_file}")
            continue
        if verbose:
            debug("compile", "Found dependency: {dep_file}")
        dep_sources.push(dep_source)

        val dep_dir = get_dir_of_file(dep_file)
        val sub_modules = extract_use_modules(dep_source)
        for sub_mod in sub_modules:
            val sub_file = resolve_module_file(sub_mod, dep_dir)
            if sub_file != "" and not visited.contains(sub_file):
                visited.push(sub_file)
                queue.push(sub_file)

    # Step 3: Combine sources and generate C code
    var combined = ""
    for dep_src in dep_sources:
        combined = combined + dep_src + "\n"
    combined = combined + source_single

    val c_code = generate_c_code(combined)
    if verbose:
        debug("compile", "Generated C code ({c_code.len()} bytes)")

    # Step 4: Write C, compile to .o, then link separately
    val temp_dir = shell_output("mktemp -d /tmp/simple_linked_XXXXXX")
    if temp_dir == "":
        error("compile", "Failed to create temp directory")
        return 1

    val temp_c = temp_dir + "/combined.c"
    if not file_write(temp_c, c_code):
        error("compile", "Failed to write temp C file")
        shell("rm -rf '{temp_dir}'")
        return 1

    val cc = if compiler_override != "": compiler_override else: find_c_compiler()
    if cc == "":
        error("compile", "No C compiler found (tried clang, gcc, cc)")
        shell("rm -rf '{temp_dir}'")
        return 1

    val temp_o = temp_dir + "/combined.o"
    if not compile_c_to_object(temp_c, temp_o, verbose, cc, sanitize):
        shell("rm -rf '{temp_dir}'")
        return 1

    # Step 5: Link object file(s) to binary
    var obj_files: [text] = [temp_o]
    if verbose:
        debug("compile", "Linking {obj_files.len()} object file(s)...")

    val link_ok = link_objects(obj_files, output_file, verbose, cc)

    # Step 6: Cleanup
    shell("rm -rf '{temp_dir}'")

    if not link_ok:
        return 1

    if rt_file_exists(output_file):
        val size = file_size(output_file)
        info("compile", "Compiled: {output_file} ({size} bytes) [linked]")
    else:
        error("compile", "Output file not created: {output_file}")
        return 1

    0

# ============================================================================
# Generate C Only (for cross-compilation workflows)
# ============================================================================

fn compile_gen_c_only(source_file: text, output_file: text, verbose: bool) -> i64:
    if verbose:
        info("compile", "Generating C code only for {source_file}...")

    val source_raw = rt_file_read_text(source_file)
    val source_single = source_raw ?? ""
    if source_single == "":
        error("compile", "Cannot read source file: {source_file}")
        return 1

    val source = collect_all_sources(source_file, source_single, verbose)
    val c_code = generate_c_code(source)

    # If output is "-", print to stdout for shell redirection
    if output_file == "-":
        print c_code
        return 0

    if not rt_file_write_text(output_file, c_code):
        error("compile", "Failed to write C file: {output_file}")
        return 1

    info("compile", "Generated C: {output_file} ({c_code.len()} bytes)")
    0

# ============================================================================
# CLI Entry Point (when run as standalone script)
# ============================================================================

fn main() -> i64:
    val args = rt_cli_get_args()
    # args[0] = binary, args[1] = script path, args[2..] = user args
    # Usage: native.spl <source_file> <output_file> [--verbose] [--linked] [--gen-c-only] [--compiler=X]
    if args.len() < 4:
        print "Usage: native.spl <source.spl> <output> [--verbose] [--linked] [--gen-c-only] [--compiler=X]"
        return 1

    val source_file = args[2]
    val output_file = args[3]
    var verbose = false
    var use_linked = false
    var gen_c_only = false
    var compiler_override = ""
    var sanitize = false
    for ai in range(4, args.len()):
        if args[ai] == "--verbose":
            verbose = true
        if args[ai] == "--linked":
            use_linked = true
        if args[ai] == "--gen-c-only":
            gen_c_only = true
        if args[ai] == "--sanitize":
            sanitize = true
        if args[ai].starts_with("--compiler="):
            compiler_override = args[ai].substring(11)

    if gen_c_only:
        return compile_gen_c_only(source_file, output_file, verbose)
    if use_linked:
        return compile_native_linked(source_file, output_file, verbose, compiler_override, sanitize)
    compile_native(source_file, output_file, verbose, compiler_override, sanitize)

# export compile_native, compile_native_linked, compile_gen_c_only, generate_c_code
# export find_c_compiler, detect_platform
