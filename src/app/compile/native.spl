# Native Compilation Pipeline
#
# C code generation from Simple source -> gcc compilation -> mold linking.
# This bridges the gap until the full LLVM IR pipeline (MIR -> LLVM IR) is functional.
#
# Supports:
#   - print statements (with string interpolation)
#   - val/var declarations (integers, strings, arrays)
#   - fn main(): wrapping
#   - Function declarations and calls (fn name(args) -> type:)
#   - if/elif/else
#   - return statements
#   - while loops
#   - for i in range(start, end): loops
#   - for item in array: loops
#   - match value: / case X: / case _: (strings and integers)
#   - Array literals and indexing (arr[i])
#   - break / continue
#   - Compound assignment (+=, -=, *=, /=)
#   - Comments
#
# Usage: simple compile --native -o hello hello.spl
#
# Can be run as standalone: bin/bootstrap/simple src/app/compile/native.spl <source> <output> [--verbose]

# Direct extern declarations to avoid module closure limitations
extern fn rt_file_read_text(path: text) -> text
extern fn rt_file_exists(path: text) -> bool
extern fn rt_cli_get_args() -> [str]

use app.io.file_shell.{shell, shell_output, file_write, file_delete, file_size}
use app.compile.c_codegen.{generate_c_code}

# ============================================================================
# Mold Detection
# ============================================================================

fn find_mold_for_native() -> text:
    val current_dir = shell_output("pwd")
    val local_mold = current_dir + "/bin/mold/mold"
    if rt_file_exists(local_mold):
        return local_mold
    val which_result = shell_output("which mold 2>/dev/null")
    if which_result.len() > 0:
        return which_result
    ""

# ============================================================================
# Compilation Pipeline
# ============================================================================

fn compile_native(source_file: text, output_file: text, verbose: bool) -> i64:
    if verbose:
        print "[native] Compiling {source_file} to native binary..."

    # Step 1: Read source file
    val source_raw = rt_file_read_text(source_file)
    val source = source_raw ?? ""
    if source == "":
        print "Error: Cannot read source file: {source_file}"
        return 1

    # Step 2: Generate C code
    val c_code = generate_c_code(source)
    if verbose:
        print "[native] Generated C code ({c_code.len()} bytes)"

    # Step 3: Write to temp file
    val temp_c = shell_output("mktemp /tmp/simple_native_XXXXXX.c")
    if temp_c == "":
        print "Error: Failed to create temp file"
        return 1

    if not file_write(temp_c, c_code):
        print "Error: Failed to write temp C file: {temp_c}"
        return 1

    if verbose:
        print "[native] Wrote temp C file: {temp_c}"

    # Step 4: Find mold and compile with gcc
    val mold_path = find_mold_for_native()
    var gcc_cmd = ""
    var used_mold = false

    if mold_path != "":
        var mold_dir = "."
        val last_slash = mold_path.last_index_of("/") ?? -1
        if last_slash >= 0:
            mold_dir = mold_path.substring(0, last_slash)
        gcc_cmd = "gcc -fuse-ld=mold -B {mold_dir}/ -o '{output_file}' '{temp_c}'"
        used_mold = true
        if verbose:
            print "[native] Using mold linker at: {mold_path}"
    else:
        gcc_cmd = "gcc -o '{output_file}' '{temp_c}'"
        if verbose:
            print "[native] No mold found, using system linker"

    if verbose:
        print "[native] Running: {gcc_cmd}"

    val (gcc_out, gcc_err, gcc_exit) = shell(gcc_cmd)

    # Step 5: Cleanup temp file
    file_delete(temp_c)

    # Step 6: Report results
    if gcc_exit != 0:
        print "Error: Compilation failed (exit code {gcc_exit})"
        if gcc_err != "":
            print gcc_err
        return 1

    if rt_file_exists(output_file):
        val size = file_size(output_file)
        print "Compiled: {output_file} ({size} bytes)"
        if verbose:
            var linker_name = "system"
            if used_mold:
                linker_name = "mold"
            print "[native] Linker: {linker_name}"
    else:
        print "Error: Output file not created: {output_file}"
        return 1

    0

# ============================================================================
# CLI Entry Point (when run as standalone script)
# ============================================================================

fn main() -> i64:
    val args = rt_cli_get_args()
    # args[0] = binary, args[1] = script path, args[2..] = user args
    # Usage: native.spl <source_file> <output_file> [--verbose]
    if args.len() < 4:
        print "Usage: native.spl <source.spl> <output> [--verbose]"
        return 1

    val source_file = args[2]
    val output_file = args[3]
    var verbose = false
    if args.len() > 4:
        if args[4] == "--verbose":
            verbose = true
    compile_native(source_file, output_file, verbose)

export compile_native, generate_c_code
