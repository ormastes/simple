# Simple to C Code Generator (Enhanced)
#
# Shared C code generation logic used by both native and LLVM direct compilation paths.
# Translates Simple language to C code for bootstrapping.
#
# Supported features:
#   - Functions (fn, return), variables (val/var), control flow
#   - Arrays (integer and string), string interpolation in print
#   - String methods: .contains, .starts_with, .ends_with, .substring, .trim,
#     .split, .replace, .index_of, .len
#   - Dynamic string arrays: .push, .join, .pop
#   - Struct definitions and construction
#   - Enum definitions
#   - Nil/NULL, ?? (null coalescing)
#   - use/export/import (skipped gracefully)
#   - String concatenation with +
#
# Type tracking: Functions receive a `types` text parameter containing a registry string.
# Format: ";text:name;arr:name;fn_text:funcname;" (semicolon-delimited entries)
# Functions that add type entries return "code|||new_entries" separated by |||.
# The caller (generate_c_code) maintains and threads the registry through the main loop.
#
# Module structure:
#   - c_helpers.spl: Indentation, type conversion, signature parsing, type registry queries
#   - c_translate.spl: Expression/statement/control-flow translation to C
#   - c_runtime.spl: C runtime generation, struct parsing, result splitting

use app.compile.c_helpers.{get_indent_level, get_c_indent, simple_type_to_c, translate_params, parse_fn_signature, find_close_paren, is_string_array_var, is_int_array_var, is_str_arr_arr_var, is_int_arr_arr_var, is_text_var, is_fn_returning_text, is_fn_returning_struct, is_struct_type_var, is_known_struct, is_known_method, is_me_method, is_static_fn, is_dict_var, is_option_var, parse_method_signature, parse_generic_type, is_struct_array_var, is_struct_field_struct_array, is_fn_returning_struct_arr, is_fn_returning_int_arr, is_fn_returning_str_arr}
use app.compile.c_translate.{translate_condition, translate_method_expr, translate_expr, translate_interpolated_print, translate_print, translate_array_decl, translate_var_decl, translate_for_loop, translate_case, translate_statement, close_blocks, build_function}
use app.compile.c_runtime.{generate_c_runtime, parse_struct_fields, split_result}
use app.compile.c_codegen_defs.{cg_process_enum, cg_track_field_types, cg_track_fn_types}

# Generate C code from Simple source
fn generate_c_code(source_text: text) -> text:
    # Type registry - tracks variable types and function return types
    # Format: ";text:name;arr:name;fn_text:funcname;struct:StructName;"
    var types = ";"

    # Pre-seed well-known cross-module variables (used by parser, lexer, etc.)
    types = types + "text:par_text;text:par_current;text:lex_cur_text;text:lex_cur_suffix;"
    types = types + "text:g_log_filter_pattern;"

    val raw_lines = source_text.split("\n")
    # Pre-process: join multi-line expressions (unclosed parentheses)
    var lines_arr: [text] = []
    var pending_line = ""
    var paren_depth = 0
    for li in range(0, raw_lines.len()):
        val rline = raw_lines[li]
        if pending_line != "":
            pending_line = pending_line + " " + rline.trim()
        else:
            pending_line = rline
        # Count parens outside string literals, handling escaped quotes
        val has_paren = rline.contains("(") or rline.contains(")")
        if has_paren:
            var pp_in_str = false
            var pp_opens = 0
            var pp_closes = 0
            var pp_i = 0
            val pp_len = rline.len()
            while pp_i < pp_len:
                val pp_ch = rline.substring(pp_i, pp_i + 1)
                if pp_in_str:
                    if pp_ch == "\\" and pp_i + 1 < pp_len:
                        pp_i = pp_i + 2
                        continue
                    if pp_ch == "\"":
                        pp_in_str = false
                    pp_i = pp_i + 1
                    continue
                if pp_ch == "\"":
                    pp_in_str = true
                    pp_i = pp_i + 1
                    continue
                if pp_ch == "(":
                    pp_opens = pp_opens + 1
                elif pp_ch == ")":
                    pp_closes = pp_closes + 1
                pp_i = pp_i + 1
            paren_depth = paren_depth + pp_opens - pp_closes
        if paren_depth <= 0:
            lines_arr.push(pending_line)
            pending_line = ""
            paren_depth = 0
    if pending_line != "":
        lines_arr.push(pending_line)

    var forward_decls: [text] = []
    var func_defs: [text] = []
    var struct_defs: [text] = []
    var enum_defs: [text] = []
    var global_defs: [text] = []
    var main_body: [text] = []
    var current_fn_name = ""
    var current_fn_lines: [text] = []
    var current_fn_sig = ""
    var types_before_fn = ""
    var in_main = false
    var in_func = false
    var in_struct = false
    var in_enum = false
    var skip_until_unindent = false
    var current_impl_class = ""
    var in_impl = false
    var in_impl_method = false
    var impl_method_name = ""
    var impl_method_sig = ""
    var impl_method_lines: [text] = []
    var impl_method_is_me = false
    var lambda_counter = 0
    var skip_until_close_brace = false

    # Pre-pass: collect all struct/class/enum names and field types
    # This resolves forward references (e.g., impl using struct defined later)
    var pre_skip = false
    for pi in range(0, lines_arr.len()):
        val pline = lines_arr[pi]
        val ptrim = pline.trim()
        if ptrim == "":
            continue
        val p_is_struct = ptrim.starts_with("struct ") and ptrim.ends_with(":")
        val p_is_class = ptrim.starts_with("class ") and ptrim.ends_with(":")
        val p_is_enum = ptrim.starts_with("enum ") and ptrim.ends_with(":")
        if p_is_struct or p_is_class:
            var p_name = ""
            if p_is_struct:
                p_name = ptrim.substring(7, ptrim.len() - 1).trim()
            else:
                p_name = ptrim.substring(6, ptrim.len() - 1).trim()
            types = types + "struct:" + p_name + ";"
            # Scan fields
            for pfi in range(pi + 1, lines_arr.len()):
                val pfline = lines_arr[pfi]
                val pftrim = pfline.trim()
                if pftrim == "":
                    continue
                val pf_ind = pfline.starts_with("    ") or pfline.starts_with("\t")
                if not pf_ind:
                    break
                if pftrim.starts_with("fn ") or pftrim.starts_with("me ") or pftrim.starts_with("static fn "):
                    break
                if pftrim.starts_with("#"):
                    continue
                # Strip inline comments
                var pf_clean = pftrim
                val pf_hash = pftrim.index_of(" #") ?? -1
                if pf_hash >= 0:
                    pf_clean = pftrim.substring(0, pf_hash).trim()
                val pf_colon = pf_clean.index_of(":") ?? -1
                if pf_colon >= 0:
                    val pf_fname = pf_clean.substring(0, pf_colon).trim()
                    val pf_ftype = pf_clean.substring(pf_colon + 1).trim()
                    if pf_ftype == "text" or pf_ftype == "str":
                        types = types + "field_text:" + p_name + "." + pf_fname + ";"
                    if pf_ftype == "[text]" or pf_ftype == "[str]":
                        types = types + "field_arr:" + p_name + "." + pf_fname + ";"
                    if pf_ftype == "[i64]" or pf_ftype == "[int]" or pf_ftype == "[bool]":
                        types = types + "field_int_arr:" + p_name + "." + pf_fname + ";"
                    # Struct array field: [StructName]
                    if pf_ftype.starts_with("[") and pf_ftype.ends_with("]"):
                        val pf_elem = pf_ftype.substring(1, pf_ftype.len() - 1).trim()
                        if pf_elem.len() > 0:
                            val pf_ef = pf_elem[0]
                            if pf_ef >= "A" and pf_ef <= "Z":
                                types = types + "field_struct_arr:" + p_name + "." + pf_fname + "=" + pf_elem + ";"
        if p_is_enum:
            val pe_name = ptrim.substring(5, ptrim.len() - 1).trim()
            # Scan variants
            for pei in range(pi + 1, lines_arr.len()):
                val peline = lines_arr[pei]
                val petrim = peline.trim()
                if petrim == "":
                    continue
                val pe_ind = peline.starts_with("    ") or peline.starts_with("\t")
                if not pe_ind:
                    break
                if petrim.starts_with("#") or petrim.starts_with("fn ") or petrim.starts_with("me "):
                    continue
                val pe_paren = petrim.index_of("(") ?? -1
                var pe_vname = petrim
                if pe_paren >= 0:
                    pe_vname = petrim.substring(0, pe_paren).trim()
                types = types + "enum_variant:" + pe_name + "." + pe_vname + ";"

    for line_idx in range(0, lines_arr.len()):
        val line = lines_arr[line_idx]
        var trimmed = line.trim()

        if trimmed == "":
            continue

        # Skip lines inside multi-line import blocks (pub use ... { ... })
        if skip_until_close_brace:
            if trimmed == "}" or trimmed.ends_with("}"):
                skip_until_close_brace = false
            continue

        # Strip inline comments: code # comment (but not inside strings)
        # Handle both "code  # comment" and "code # comment"
        if trimmed.contains(" #") and not trimmed.starts_with("#"):
            val inline_hash = trimmed.index_of(" #") ?? -1
            if inline_hash >= 0:
                # Make sure it's not inside a string literal
                val before_hash = trimmed.substring(0, inline_hash)
                val quote_count = before_hash.split("\"").len() - 1
                val is_inside_str = quote_count % 2 == 1
                # Also check it's not a #[ decorator or #! shebang
                val after_hash = trimmed.substring(inline_hash + 2).trim()
                val is_decorator = after_hash.starts_with("[")
                if not is_inside_str and not is_decorator:
                    trimmed = before_hash.trim()
        if trimmed.starts_with("#!"):
            continue
        if trimmed.starts_with("#"):
            val comment_text = trimmed.substring(1).trim()
            val comment_indented = line.starts_with("    ") or line.starts_with("\t")
            if in_main and comment_indented:
                main_body.push("    // {comment_text}")
            elif in_func and comment_indented:
                current_fn_lines.push("    // {comment_text}")
            elif in_func and not comment_indented:
                # Top-level comment while in_func - end the function
                val fn_code = build_function(current_fn_name, current_fn_sig, current_fn_lines)
                func_defs.push(fn_code)
                current_fn_lines = []
                in_func = false
                types = types_before_fn
            continue

        # Handle impl block methods - indented lines inside impl
        if in_impl:
            val still_indented = line.starts_with("    ")
            val is_tab = line.starts_with("\t")
            if not still_indented and not is_tab:
                # End of impl block - flush any pending method
                if in_impl_method:
                    val method_code = build_function(current_impl_class + "__" + impl_method_name, impl_method_sig, impl_method_lines)
                    func_defs.push(method_code)
                    impl_method_lines = []
                    in_impl_method = false
                in_impl = false
                current_impl_class = ""
                # Fall through to process current line normally
            else:
                # Inside impl block
                val impl_indent = get_indent_level(line)
                if impl_indent == 1:
                    # Top-level impl member (fn, me, static fn)
                    if in_impl_method:
                        val method_code = build_function(current_impl_class + "__" + impl_method_name, impl_method_sig, impl_method_lines)
                        func_defs.push(method_code)
                        impl_method_lines = []
                        in_impl_method = false

                    if trimmed.starts_with("fn ") and trimmed.ends_with(":"):
                        val parsed = parse_method_signature(trimmed, current_impl_class, false)
                        impl_method_name = parsed[0]
                        impl_method_sig = parsed[1]
                        val fwd = parsed[2]
                        forward_decls.push(fwd)
                        in_impl_method = true
                        impl_method_is_me = false
                        types = types + "method:" + current_impl_class + "." + impl_method_name + ";"
                        types = types + "struct_var:self=" + current_impl_class + ";"
                        types = types + cg_track_fn_types(trimmed, current_impl_class + "__" + impl_method_name)
                        continue
                    elif trimmed.starts_with("me ") and trimmed.ends_with(":"):
                        val parsed = parse_method_signature(trimmed, current_impl_class, true)
                        impl_method_name = parsed[0]
                        impl_method_sig = parsed[1]
                        val fwd = parsed[2]
                        forward_decls.push(fwd)
                        in_impl_method = true
                        impl_method_is_me = true
                        types = types + "me_method:" + current_impl_class + "." + impl_method_name + ";"
                        types = types + "struct_var:self=" + current_impl_class + ";"
                        types = types + cg_track_fn_types(trimmed, current_impl_class + "__" + impl_method_name)
                        continue
                    elif trimmed.starts_with("static fn ") and trimmed.ends_with(":"):
                        # Static method - no self parameter
                        val static_trimmed = "fn " + trimmed.substring(10)
                        val parsed = parse_fn_signature(static_trimmed)
                        val static_method_name = parsed[0]
                        val mangled_name = current_impl_class + "__" + static_method_name
                        # Re-parse with mangled name
                        val static_sig_trimmed = static_trimmed.replace(static_method_name + "(", mangled_name + "(")
                        val parsed2 = parse_fn_signature(static_sig_trimmed)
                        impl_method_name = static_method_name
                        impl_method_sig = parsed2[1]
                        forward_decls.push(parsed2[2])
                        in_impl_method = true
                        impl_method_is_me = false
                        types = types + "static_fn:" + current_impl_class + "." + static_method_name + ";"
                        types = types + cg_track_fn_types(trimmed, mangled_name)
                        continue
                    else:
                        # Skip other impl-level lines (comments etc)
                        continue
                elif impl_indent >= 2 and in_impl_method:
                    # Method body line - translate with self context
                    val raw_result = translate_statement(trimmed, types)
                    val parts = split_result(raw_result)
                    var code = parts[0]
                    val new_types = parts[1]
                    if new_types != "":
                        types = types + new_types
                    # Replace self.method(args) calls before generic self. replacement
                    if code.contains("self."):
                        var sm_pos = code.index_of("self.") ?? -1
                        if sm_pos >= 0:
                            val sm_after = code.substring(sm_pos + 5)
                            val sm_paren = sm_after.index_of("(") ?? -1
                            val sm_dot2 = sm_after.index_of(".") ?? -1
                            val sm_space = sm_after.index_of(" ") ?? -1
                            val sm_eq = sm_after.index_of("=") ?? -1
                            # Is this a method call? (paren comes before dot/space/eq)
                            var sm_is_call = sm_paren >= 0
                            if sm_is_call and sm_dot2 >= 0 and sm_dot2 < sm_paren:
                                sm_is_call = false
                            if sm_is_call and sm_space >= 0 and sm_space < sm_paren:
                                sm_is_call = false
                            if sm_is_call and sm_eq >= 0 and sm_eq < sm_paren:
                                sm_is_call = false
                            if sm_is_call:
                                val sm_name = sm_after.substring(0, sm_paren).trim()
                                val sm_close = find_close_paren(sm_after, sm_paren)
                                if sm_close >= 0:
                                    var sm_args = ""
                                    if sm_close > sm_paren + 1:
                                        sm_args = sm_after.substring(sm_paren + 1, sm_close)
                                    var sm_rest = ""
                                    if sm_close + 1 < sm_after.len():
                                        sm_rest = sm_after.substring(sm_close + 1)
                                    val sm_before = code.substring(0, sm_pos)
                                    if sm_args != "":
                                        code = "{sm_before}{current_impl_class}__{sm_name}(&self, {sm_args}){sm_rest}"
                                    else:
                                        code = "{sm_before}{current_impl_class}__{sm_name}(&self){sm_rest}"
                    # Replace self.field access/assignment inside method bodies
                    if code.contains("self."):
                        code = code.replace("self.", "self->")
                    if code != "":
                        var padding = ""
                        for pi in range(0, impl_indent - 1):
                            padding = padding + "    "
                        impl_method_lines.push("{padding}{code}")
                    continue
                else:
                    continue

        # Skip indented lines after struct/enum/class (not impl - handled above)
        if skip_until_unindent:
            val still_indented = line.starts_with("    ")
            val is_tab = line.starts_with("\t")
            if still_indented or is_tab:
                continue
            skip_until_unindent = false

        # Module directives - skip at top level
        if trimmed.starts_with("use "):
            # Extract cross-module variable names from use imports
            # Generate global declarations for known patterns (lex_cur_*, etc.)
            val use_brace = trimmed.index_of("\{") ?? -1
            val use_brace_end = trimmed.last_index_of("}") ?? -1
            if use_brace >= 0 and use_brace_end > use_brace:
                val use_names_str = trimmed.substring(use_brace + 1, use_brace_end)
                val use_names = use_names_str.split(",")
                for use_name_raw in use_names:
                    val use_name = use_name_raw.trim()
                    # Detect external globals: lowercase names that start with known prefixes
                    if use_name.starts_with("lex_cur_") or use_name.starts_with("par_"):
                        # Check if already declared (avoid duplicates)
                        val use_decl_marker = ";use_decl:" + use_name + ";"
                        if not types.contains(use_decl_marker):
                            types = types + use_decl_marker
                            # Determine type from types registry
                            val is_text_glob = types.contains(";text:" + use_name + ";")
                            if is_text_glob:
                                global_defs.push("static const char* {use_name} = \"\";")
                            else:
                                global_defs.push("static long long {use_name} = 0;")
            continue
        if trimmed.starts_with("import "):
            continue
        if trimmed.starts_with("export "):
            continue
        if trimmed.starts_with("from "):
            continue
        if trimmed.starts_with("pub mod "):
            continue
        if trimmed.starts_with("mod "):
            continue
        if trimmed.starts_with("export use "):
            continue
        if trimmed.starts_with("pub use "):
            if trimmed.ends_with("\{"):
                skip_until_close_brace = true
            continue
        if trimmed.starts_with("common use "):
            continue

        # Extern function - generate forward declaration instead of skipping
        if trimmed.starts_with("extern fn "):
            val extern_rest = trimmed.substring(10).trim()
            # Parse: name(params) -> ret
            val ep_idx = extern_rest.index_of("(") ?? -1
            if ep_idx >= 0:
                val extern_name = extern_rest.substring(0, ep_idx).trim()
                val eclose = extern_rest.index_of(")") ?? -1
                if eclose >= 0:
                    var eparams_str = ""
                    if eclose > ep_idx + 1:
                        eparams_str = extern_rest.substring(ep_idx + 1, eclose).trim()
                    val earrow = extern_rest.index_of("->") ?? -1
                    var eret_type = "void"
                    if earrow >= 0:
                        eret_type = simple_type_to_c(extern_rest.substring(earrow + 2).trim())
                    var ec_params = "void"
                    if eparams_str.len() > 0:
                        ec_params = translate_params(eparams_str)
                    forward_decls.push("{eret_type} {extern_name}({ec_params});")
                    # Track extern fn return types for type inference
                    if eret_type == "const char*":
                        types = types + "fn_text:" + extern_name + ";"
                    # Track struct and array return types
                    if earrow >= 0:
                        val eret_raw = extern_rest.substring(earrow + 2).trim()
                        if eret_raw.len() > 0:
                            val eret_first = eret_raw[0]
                            if eret_first >= "A" and eret_first <= "Z":
                                types = types + "fn_struct:" + extern_name + "=" + eret_raw + ";"
                            if eret_raw.starts_with("[") and eret_raw.ends_with("]"):
                                val ext_arr_elem = eret_raw.substring(1, eret_raw.len() - 1).trim()
                                if ext_arr_elem == "i64" or ext_arr_elem == "int":
                                    types = types + "fn_int_arr:" + extern_name + ";"
                                elif ext_arr_elem == "text" or ext_arr_elem == "str":
                                    types = types + "fn_str_arr:" + extern_name + ";"
            continue

        # Type alias - skip
        if trimmed.starts_with("type ") and trimmed.contains(" = "):
            continue

        # Docstrings - skip
        if trimmed.starts_with("\"\"\""):
            continue

        # Decorator attributes - skip
        if trimmed.starts_with("#["):
            continue

        # Struct definition
        if trimmed.starts_with("struct ") and trimmed.ends_with(":"):
            val struct_name = trimmed.substring(7, trimmed.len() - 1).trim()
            types = types + "struct:" + struct_name + ";"
            val field_result = parse_struct_fields(lines_arr, line_idx)
            val field_body = field_result[1]
            var sdef = "typedef struct \{" + "\n"
            sdef = sdef + field_body + "\n"
            sdef = sdef + "} " + struct_name + ";"
            struct_defs.push(sdef)
            types = types + cg_track_field_types(lines_arr, line_idx, struct_name)
            skip_until_unindent = true
            continue

        # Enum definition - detect data variants vs simple enums
        if trimmed.starts_with("enum ") and trimmed.ends_with(":"):
            val enum_result = cg_process_enum(lines_arr, line_idx, trimmed)
            val enum_parts = enum_result.split("|||")
            enum_defs.push(enum_parts[0])
            types = types + enum_parts[1]
            skip_until_unindent = true
            continue

        # Class definition - treat like struct
        if trimmed.starts_with("class ") and trimmed.ends_with(":"):
            val class_name = trimmed.substring(6, trimmed.len() - 1).trim()
            types = types + "struct:" + class_name + ";"
            val field_result = parse_struct_fields(lines_arr, line_idx)
            val field_body = field_result[1]
            var cdef = "typedef struct \{" + "\n"
            cdef = cdef + field_body + "\n"
            cdef = cdef + "} " + class_name + ";"
            struct_defs.push(cdef)
            types = types + cg_track_field_types(lines_arr, line_idx, class_name)
            skip_until_unindent = true
            continue

        # Impl block - parse methods
        if trimmed.starts_with("impl ") and trimmed.ends_with(":"):
            current_impl_class = trimmed.substring(5, trimmed.len() - 1).trim()
            in_impl = true
            in_impl_method = false
            continue

        # Function definition
        if trimmed.starts_with("fn ") and trimmed.ends_with(":"):
            if in_func:
                val fn_code = build_function(current_fn_name, current_fn_sig, current_fn_lines)
                func_defs.push(fn_code)
                current_fn_lines = []
                # Restore types to before function (clear local var types)
                types = types_before_fn
            if trimmed == "fn main():" or trimmed.starts_with("fn main()"):
                in_main = true
                in_func = false
                types_before_fn = types
                continue
            val parsed = parse_fn_signature(trimmed)
            current_fn_name = parsed[0]
            current_fn_sig = parsed[1]
            val fwd = parsed[2]
            forward_decls.push(fwd)
            in_func = true
            in_main = false
            # Track function return type and parameter types
            types = types + cg_track_fn_types(trimmed, current_fn_name)
            types_before_fn = types
            continue

        # Static fn at top level - skip (only valid inside impl)
        if trimmed.starts_with("static fn ") and trimmed.ends_with(":"):
            skip_until_unindent = true
            continue

        # Mutable method at top level - skip (only valid inside impl)
        if trimmed.starts_with("me ") and trimmed.ends_with(":"):
            skip_until_unindent = true
            continue

        var is_indented = line.starts_with("    ")
        if not is_indented:
            is_indented = line.starts_with("\t")

        if in_main and is_indented:
            val indent = get_indent_level(line)
            val raw_result = translate_statement(trimmed, types)
            val parts = split_result(raw_result)
            var code = parts[0]
            val new_types = parts[1]
            if new_types != "":
                types = types + new_types
            if code != "":
                var padding = ""
                for pi in range(0, indent):
                    padding = padding + "    "
                main_body.push("{padding}{code}")
            continue

        if in_func and is_indented:
            val indent = get_indent_level(line)
            val raw_result = translate_statement(trimmed, types)
            val parts = split_result(raw_result)
            var code = parts[0]
            val new_types = parts[1]
            if new_types != "":
                types = types + new_types
            if code != "":
                var padding = ""
                for pi in range(0, indent):
                    padding = padding + "    "
                current_fn_lines.push("{padding}{code}")
            continue

        if in_main:
            in_main = false
            types = types_before_fn
        if in_func:
            val fn_code = build_function(current_fn_name, current_fn_sig, current_fn_lines)
            func_defs.push(fn_code)
            current_fn_lines = []
            in_func = false
            types = types_before_fn

        # Module-level statement - check if it's a val/var declaration (-> global)
        val is_module_val = trimmed.starts_with("val ")
        val is_module_var = trimmed.starts_with("var ")
        if is_module_val or is_module_var:
            val raw_result = translate_statement(trimmed, types)
            val parts = split_result(raw_result)
            var code = parts[0]
            val new_types = parts[1]
            if new_types != "":
                types = types + new_types
            if code != "":
                # Convert to global: remove const for val (use static), add static for var
                var global_code = code
                if global_code.starts_with("long long "):
                    global_code = "static " + global_code
                elif global_code.starts_with("const char* "):
                    # Check if init uses a function call (can't do at global scope)
                    val str_eq = global_code.index_of(" = ") ?? -1
                    if str_eq >= 0:
                        val str_init = global_code.substring(str_eq + 3).trim()
                        val str_has_call = str_init.contains("(")
                        if str_has_call:
                            val str_decl = global_code.substring(0, str_eq)
                            global_defs.push("static {str_decl} = NULL;")
                            val str_name = str_decl.substring(12).trim()
                            val str_semi = str_init.index_of(";") ?? -1
                            var str_val = str_init
                            if str_semi >= 0:
                                str_val = str_init.substring(0, str_semi).trim()
                            main_body.push("    {str_name} = {str_val};")
                            continue
                    global_code = "static " + global_code
                elif global_code.starts_with("int "):
                    global_code = "static " + global_code
                elif global_code.starts_with("SimpleStringArray "):
                    # Arrays need special init - can't call functions in global init
                    # Extract name and emit as uninitialized, init in main
                    val arr_eq = global_code.index_of(" = ") ?? -1
                    if arr_eq >= 0:
                        val arr_decl = global_code.substring(0, arr_eq)
                        global_defs.push("static {arr_decl};")
                        # Add init to main_body
                        val arr_name = arr_decl.substring(18).trim()
                        val arr_semi = arr_name.index_of(";") ?? -1
                        var clean_name = arr_name
                        if arr_semi >= 0:
                            clean_name = arr_name.substring(0, arr_semi).trim()
                        main_body.push("    {clean_name} = simple_new_string_array();")
                        continue
                    global_code = "static " + global_code
                elif global_code.starts_with("SimpleIntArray "):
                    # Int arrays need deferred init too
                    val arr_eq = global_code.index_of(" = ") ?? -1
                    if arr_eq >= 0:
                        val arr_decl = global_code.substring(0, arr_eq)
                        global_defs.push("static {arr_decl};")
                        val arr_name = arr_decl.substring(15).trim()
                        val arr_semi = arr_name.index_of(";") ?? -1
                        var clean_name = arr_name
                        if arr_semi >= 0:
                            clean_name = arr_name.substring(0, arr_semi).trim()
                        main_body.push("    {clean_name} = simple_new_int_array();")
                        continue
                    global_code = "static " + global_code
                elif global_code.starts_with("SimpleStringArrayArray "):
                    val arr_eq = global_code.index_of(" = ") ?? -1
                    if arr_eq >= 0:
                        val arr_decl = global_code.substring(0, arr_eq)
                        global_defs.push("static {arr_decl};")
                        val arr_name = arr_decl.substring(23).trim()
                        val arr_semi = arr_name.index_of(";") ?? -1
                        var clean_name = arr_name
                        if arr_semi >= 0:
                            clean_name = arr_name.substring(0, arr_semi).trim()
                        main_body.push("    {clean_name} = simple_new_string_array_array();")
                        continue
                    global_code = "static " + global_code
                elif global_code.starts_with("SimpleIntArrayArray "):
                    val arr_eq = global_code.index_of(" = ") ?? -1
                    if arr_eq >= 0:
                        val arr_decl = global_code.substring(0, arr_eq)
                        global_defs.push("static {arr_decl};")
                        val arr_name = arr_decl.substring(20).trim()
                        val arr_semi = arr_name.index_of(";") ?? -1
                        var clean_name = arr_name
                        if arr_semi >= 0:
                            clean_name = arr_name.substring(0, arr_semi).trim()
                        main_body.push("    {clean_name} = simple_new_int_array_array();")
                        continue
                    global_code = "static " + global_code
                elif global_code.starts_with("SimpleStructArray "):
                    # Struct arrays need deferred init
                    val sarr_eq = global_code.index_of(" = ") ?? -1
                    if sarr_eq >= 0:
                        val sarr_decl = global_code.substring(0, sarr_eq)
                        global_defs.push("static {sarr_decl};")
                        val sarr_name = sarr_decl.substring(18).trim()
                        val sarr_semi = sarr_name.index_of(";") ?? -1
                        var clean_sarr = sarr_name
                        if sarr_semi >= 0:
                            clean_sarr = sarr_name.substring(0, sarr_semi).trim()
                        main_body.push("    {clean_sarr} = simple_new_struct_array();")
                        continue
                    global_code = "static " + global_code
                elif global_code.starts_with("SimpleDict* "):
                    val dict_eq = global_code.index_of(" = ") ?? -1
                    if dict_eq >= 0:
                        val dict_decl = global_code.substring(0, dict_eq)
                        global_defs.push("static {dict_decl} = NULL;")
                        val dict_name_start = dict_decl.index_of("* ") ?? -1
                        if dict_name_start >= 0:
                            val dict_name = dict_decl.substring(dict_name_start + 2).trim()
                            main_body.push("    {dict_name} = simple_dict_new();")
                        continue
                    global_code = "static " + global_code
                else:
                    global_code = "static " + global_code
                global_defs.push(global_code)
        else:
            val raw_result = translate_statement(trimmed, types)
            val parts = split_result(raw_result)
            var code = parts[0]
            val new_types = parts[1]
            if new_types != "":
                types = types + new_types
            if code != "":
                val mod_indent = get_indent_level(line)
                var mod_padding = "    "
                for mpi in range(0, mod_indent):
                    mod_padding = mod_padding + "    "
                main_body.push("{mod_padding}{code}")

    # Flush pending impl method
    if in_impl and in_impl_method:
        val method_code = build_function(current_impl_class + "__" + impl_method_name, impl_method_sig, impl_method_lines)
        func_defs.push(method_code)

    if in_func:
        val fn_code = build_function(current_fn_name, current_fn_sig, current_fn_lines)
        func_defs.push(fn_code)

    main_body = close_blocks(main_body)

    # Build final C code
    var c_code = "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n"
    c_code = c_code + "#include <stdint.h>\n"
    c_code = c_code + "#ifdef _MSC_VER\n#define strdup _strdup\n#endif\n"

    # Add C runtime helpers
    c_code = c_code + generate_c_runtime()

    # Add enum definitions first (structs may reference enum types)
    if enum_defs.len() > 0:
        c_code = c_code + "\n// --- Enum Definitions ---\n"
        for edef in enum_defs:
            c_code = c_code + edef + "\n\n"

    # Add struct definitions
    if struct_defs.len() > 0:
        c_code = c_code + "\n// --- Struct Definitions ---\n"
        for sdef in struct_defs:
            c_code = c_code + sdef + "\n\n"

    # Add global variable definitions
    if global_defs.len() > 0:
        c_code = c_code + "\n// --- Global Variables ---\n"
        for gdef in global_defs:
            c_code = c_code + gdef + "\n"
        c_code = c_code + "\n"

    # Add forward declarations
    if forward_decls.len() > 0:
        c_code = c_code + "\n// --- Forward Declarations ---\n"
        for fwd in forward_decls:
            c_code = c_code + fwd + "\n"
        c_code = c_code + "\n"

    # Add function definitions
    for func in func_defs:
        c_code = c_code + func + "\n\n"

    # Add main
    c_code = c_code + "int main(void) \{" + "\n"
    for body_line in main_body:
        c_code = c_code + body_line + "\n"
    c_code = c_code + "    return 0;\n}\n"
    c_code

export generate_c_code, close_blocks, translate_statement, translate_print
export translate_interpolated_print, translate_var_decl, translate_array_decl
export translate_for_loop, translate_case, translate_condition, translate_expr
export build_function, parse_fn_signature, translate_params, simple_type_to_c
export get_indent_level, get_c_indent
export generate_c_runtime, translate_method_expr, find_close_paren
export is_string_array_var, is_int_array_var, is_str_arr_arr_var, is_int_arr_arr_var, is_text_var, is_fn_returning_text, is_fn_returning_struct, split_result
export is_struct_type_var, is_known_struct, is_known_method, is_me_method, is_static_fn
export is_dict_var, is_option_var, parse_method_signature, parse_generic_type
