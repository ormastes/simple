# Simple to C Code Generator (Enhanced)
#
# Shared C code generation logic used by both native and LLVM direct compilation paths.
# Translates Simple language to C code for bootstrapping.
#
# Supported features:
#   - Functions (fn, return), variables (val/var), control flow
#   - Arrays (integer and string), string interpolation in print
#   - String methods: .contains, .starts_with, .ends_with, .substring, .trim,
#     .split, .replace, .index_of, .len
#   - Dynamic string arrays: .push, .join, .pop
#   - Struct definitions and construction
#   - Enum definitions
#   - Nil/NULL, ?? (null coalescing)
#   - use/export/import (skipped gracefully)
#   - String concatenation with +
#
# Type tracking: Functions receive a `types` text parameter containing a registry string.
# Format: ";text:name;arr:name;fn_text:funcname;" (semicolon-delimited entries)
# Functions that add type entries return "code|||new_entries" separated by |||.
# The caller (generate_c_code) maintains and threads the registry through the main loop.

extern fn rt_file_read_text(path: text) -> text
extern fn rt_file_exists(path: text) -> bool

# Get indentation level (counts leading spaces/tabs)
fn get_indent_level(line: text) -> i64:
    var spaces = 0
    for idx in range(0, line.len()):
        val ch = line[idx]
        if ch == " ":
            spaces = spaces + 1
        elif ch == "\t":
            spaces = spaces + 4
        else:
            break
    spaces / 4

# Get C-style indentation (spaces only, no tab expansion)
fn get_c_indent(line: text) -> i64:
    var spaces = 0
    for idx in range(0, line.len()):
        val ch = line[idx]
        if ch == " ":
            spaces = spaces + 1
        else:
            break
    spaces / 4

# Convert Simple type to C type
fn simple_type_to_c(stype: text) -> text:
    if stype == "i64" or stype == "int":
        return "long"
    if stype == "i32":
        return "int"
    if stype == "f64" or stype == "float":
        return "double"
    if stype == "f32":
        return "float"
    if stype == "bool":
        return "int"
    if stype == "text" or stype == "str":
        return "const char*"
    if stype == "[text]" or stype == "[str]":
        return "SimpleStringArray"
    if stype == "[i64]" or stype == "[int]":
        return "long*"
    "long"

# Translate Simple parameter list to C
fn translate_params(params_str: text) -> text:
    val params = params_str.split(",")
    var c_parts: [text] = []
    for param in params:
        val p = param.trim()
        val colon_idx = p.index_of(":") ?? -1
        if colon_idx >= 0:
            val pname = p.substring(0, colon_idx).trim()
            val ptype = p.substring(colon_idx + 1).trim()
            val ctype = simple_type_to_c(ptype)
            c_parts.push("{ctype} {pname}")
        else:
            c_parts.push("long {p}")
    c_parts.join(", ")

# Parse a Simple function signature into [name, c_signature_body, forward_decl]
fn parse_fn_signature(trimmed: text) -> [text]:
    val without_fn = trimmed.substring(3)  # remove "fn "
    val colon_pos = without_fn.len() - 1  # trailing colon
    val sig = without_fn.substring(0, colon_pos).trim()

    # Find function name (up to first paren)
    val paren_idx = sig.index_of("(") ?? -1
    if paren_idx < 0:
        return [sig, "long {sig}(void)", "long {sig}(void);"]

    val name = sig.substring(0, paren_idx).trim()

    # Find return type
    val arrow_idx = sig.index_of("->") ?? -1
    var ret_type = "long"
    if arrow_idx >= 0:
        val ret_str = sig.substring(arrow_idx + 2).trim()
        ret_type = simple_type_to_c(ret_str)

    # Parse parameters
    val close_paren_idx = sig.index_of(")") ?? -1
    var params_str = ""
    if close_paren_idx > paren_idx + 1:
        params_str = sig.substring(paren_idx + 1, close_paren_idx).trim()

    var c_params = "void"
    if params_str.len() > 0:
        c_params = translate_params(params_str)

    val c_sig = "{ret_type} {name}({c_params})"
    [name, c_sig, "{c_sig};"]

# Find matching close paren starting from open_pos (exclusive)
fn find_close_paren(expr: text, open_pos: i64) -> i64:
    var depth = 1
    for idx in range(open_pos + 1, expr.len()):
        val ch = expr[idx]
        if ch == "(":
            depth = depth + 1
        elif ch == ")":
            depth = depth - 1
            if depth == 0:
                return idx
    return -1

# --- Type Registry Functions ---
# Registry format: ";text:name;arr:name;fn_text:funcname;"

fn is_string_array_var(name: text, types: text) -> bool:
    val marker = ";arr:" + name + ";"
    types.contains(marker)

fn is_text_var(name: text, types: text) -> bool:
    val marker = ";text:" + name + ";"
    types.contains(marker)

fn is_fn_returning_text(name: text, types: text) -> bool:
    val marker = ";fn_text:" + name + ";"
    types.contains(marker)

# --- Translation Functions ---
# Functions that only READ types receive `types: text` parameter.
# Functions that ADD type entries return "code|||;entry1;entry2;" with ||| separator.

# Translate a Simple condition to C
fn translate_condition(cond: text, types: text) -> text:
    var result = cond
    # Handle "not" prefix
    if result.starts_with("not "):
        result = "!(" + translate_condition(result.substring(4), types) + ")"
        return result
    # Handle "and" / "or"
    if result.contains(" and "):
        result = result.replace(" and ", " && ")
    if result.contains(" or "):
        result = result.replace(" or ", " || ")
    # Handle "!= nil" and "== nil"
    if result.contains(" != nil"):
        result = result.replace(" != nil", " != NULL")
    if result.contains(" == nil"):
        result = result.replace(" == nil", " == NULL")
    # Translate method calls in conditions
    result = translate_expr(result, types)
    result

# Translate a method call expression to C
# Returns the original expression if no method call is detected
fn translate_method_expr(expr: text, types: text) -> text:
    # .contains(
    val contains_pos = expr.index_of(".contains(") ?? -1
    if contains_pos >= 0:
        val obj = expr.substring(0, contains_pos)
        val arg_start = contains_pos + 10
        val arg_end = find_close_paren(expr, arg_start - 1)
        if arg_end >= 0:
            val arg = expr.substring(arg_start, arg_end)
            return "simple_contains({obj}, {arg})"

    # .starts_with(
    val sw_pos = expr.index_of(".starts_with(") ?? -1
    if sw_pos >= 0:
        val obj = expr.substring(0, sw_pos)
        val arg_start = sw_pos + 13
        val arg_end = find_close_paren(expr, arg_start - 1)
        if arg_end >= 0:
            val arg = expr.substring(arg_start, arg_end)
            return "simple_starts_with({obj}, {arg})"

    # .ends_with(
    val ew_pos = expr.index_of(".ends_with(") ?? -1
    if ew_pos >= 0:
        val obj = expr.substring(0, ew_pos)
        val arg_start = ew_pos + 11
        val arg_end = find_close_paren(expr, arg_start - 1)
        if arg_end >= 0:
            val arg = expr.substring(arg_start, arg_end)
            return "simple_ends_with({obj}, {arg})"

    # .substring(
    val sub_pos = expr.index_of(".substring(") ?? -1
    if sub_pos >= 0:
        val obj = expr.substring(0, sub_pos)
        val arg_start = sub_pos + 11
        val arg_end = find_close_paren(expr, arg_start - 1)
        if arg_end >= 0:
            val args = expr.substring(arg_start, arg_end)
            return "simple_substring({obj}, {args})"

    # .trim()
    val trim_pos = expr.index_of(".trim()") ?? -1
    if trim_pos >= 0:
        val obj = expr.substring(0, trim_pos)
        return "simple_trim({obj})"

    # .split(
    val split_pos = expr.index_of(".split(") ?? -1
    if split_pos >= 0:
        val obj = expr.substring(0, split_pos)
        val arg_start = split_pos + 7
        val arg_end = find_close_paren(expr, arg_start - 1)
        if arg_end >= 0:
            val arg = expr.substring(arg_start, arg_end)
            return "simple_split({obj}, {arg})"

    # .replace(
    val repl_pos = expr.index_of(".replace(") ?? -1
    if repl_pos >= 0:
        val obj = expr.substring(0, repl_pos)
        val arg_start = repl_pos + 9
        val arg_end = find_close_paren(expr, arg_start - 1)
        if arg_end >= 0:
            val args = expr.substring(arg_start, arg_end)
            return "simple_replace({obj}, {args})"

    # .index_of(
    val iof_pos = expr.index_of(".index_of(") ?? -1
    if iof_pos >= 0:
        val obj = expr.substring(0, iof_pos)
        val arg_start = iof_pos + 10
        val arg_end = find_close_paren(expr, arg_start - 1)
        if arg_end >= 0:
            val arg = expr.substring(arg_start, arg_end)
            return "simple_index_of({obj}, {arg})"

    # .join(
    val join_pos = expr.index_of(".join(") ?? -1
    if join_pos >= 0:
        val obj = expr.substring(0, join_pos)
        val arg_start = join_pos + 6
        val arg_end = find_close_paren(expr, arg_start - 1)
        if arg_end >= 0:
            val arg = expr.substring(arg_start, arg_end)
            return "simple_string_join(&{obj}, {arg})"

    # .len() - context-dependent
    if expr.ends_with(".len()"):
        val base = expr.substring(0, expr.len() - 6)
        if is_string_array_var(base, types):
            return "{base}.len"
        val base_is_text = is_text_var(base, types)
        val base_is_literal = base.starts_with("\"")
        if base_is_text or base_is_literal:
            return "simple_strlen({base})"
        return "{base}_len"

    # .pop()
    if expr.ends_with(".pop()"):
        val base = expr.substring(0, expr.len() - 6)
        return "simple_string_pop(&{base})"

    # No method call detected
    expr

# Translate a Simple expression to C
fn translate_expr(expr: text, types: text) -> text:
    # Handle nil
    if expr == "nil":
        return "NULL"
    if expr == "true":
        return "1"
    if expr == "false":
        return "0"
    if expr == "()":
        return "/* unit */"

    # Handle ?? (null coalescing)
    val nq_pos = expr.index_of(" ?? ") ?? -1
    if nq_pos >= 0:
        val left = expr.substring(0, nq_pos).trim()
        val right = expr.substring(nq_pos + 4).trim()
        val c_left = translate_expr(left, types)
        val c_right = translate_expr(right, types)
        # For index_of ?? -1, index_of already returns -1 on not found
        if c_right == "-1":
            val has_iof = c_left.contains("simple_index_of")
            if has_iof:
                return c_left
        # General integer coalescing
        return "({c_left} >= 0 ? {c_left} : {c_right})"

    # Handle string literals
    if expr.starts_with("\""):
        return expr

    # Handle string concatenation with +
    val plus_pos = expr.index_of(" + ") ?? -1
    if plus_pos >= 0:
        val left = expr.substring(0, plus_pos).trim()
        val right = expr.substring(plus_pos + 3).trim()
        # Check if either side is a string
        val left_is_str = left.starts_with("\"")
        val right_is_str = right.starts_with("\"")
        val left_is_text = is_text_var(left, types)
        val right_is_text = is_text_var(right, types)
        val left_is_method = left.contains("simple_")
        val right_is_method = right.contains("simple_")
        val either_str = left_is_str or right_is_str
        val either_text = left_is_text or right_is_text
        val either_method = left_is_method or right_is_method
        val is_string_concat = either_str or either_text or either_method
        if is_string_concat:
            return "simple_str_concat({translate_expr(left, types)}, {translate_expr(right, types)})"

    # Handle method calls
    val method_result = translate_method_expr(expr, types)
    if method_result != expr:
        return method_result

    # Handle string indexing: s[idx]
    val bracket_pos = expr.index_of("[") ?? -1
    if bracket_pos >= 0:
        val base = expr.substring(0, bracket_pos)
        if is_text_var(base, types):
            val idx_end = expr.index_of("]") ?? -1
            if idx_end >= 0:
                val idx_expr = expr.substring(bracket_pos + 1, idx_end)
                return "simple_char_at({base}, {translate_expr(idx_expr, types)})"

    expr

# Translate interpolated print statement - enhanced with %s for string exprs
fn translate_interpolated_print(inner: text, types: text) -> text:
    var fmt = ""
    var interp_args: [text] = []
    var i = 0
    var inner_len = inner.len()

    for idx in range(0, inner_len):
        val ch = inner[idx]
        if ch == "{":
            var end_idx = idx + 1
            for j in range(idx + 1, inner_len):
                if inner[j] == "}":
                    end_idx = j
                    break
            val raw_expr = inner.substring(idx + 1, end_idx)
            val c_expr = translate_expr(raw_expr, types)
            # Determine format specifier based on expression type
            val is_str_expr = c_expr.contains("simple_substring")
            val is_trim_expr = c_expr.contains("simple_trim")
            val is_replace_expr = c_expr.contains("simple_replace")
            val is_join_expr = c_expr.contains("simple_string_join")
            val is_concat_expr = c_expr.contains("simple_str_concat")
            val is_char_expr = c_expr.contains("simple_char_at")
            val is_file_expr = c_expr.contains("simple_file_read")
            val is_text = is_text_var(raw_expr, types)
            val is_string1 = is_str_expr or is_trim_expr or is_replace_expr
            val is_string2 = is_join_expr or is_concat_expr or is_char_expr
            val is_string3 = is_file_expr or is_text
            val is_string4 = c_expr.starts_with("\"")
            val any_string = is_string1 or is_string2 or is_string3 or is_string4
            if any_string:
                fmt = fmt + "%s"
                interp_args.push(c_expr)
            else:
                fmt = fmt + "%ld"
                interp_args.push("(long)(" + c_expr + ")")
            i = end_idx + 1
        elif idx >= i:
            fmt = fmt + ch

    var args_str = ""
    for current_arg in interp_args:
        args_str = args_str + ", " + current_arg
    "printf(\"{fmt}\\n\"{args_str});"

# Translate print statement
fn translate_print(arg: text, types: text) -> text:
    if arg.len() < 2:
        return "puts(\"\");"
    if arg.starts_with("\"") and arg.ends_with("\""):
        val inner = arg.substring(1, arg.len() - 1)
        if inner.contains("{"):
            return translate_interpolated_print(inner, types)
        return "puts(\"{inner}\");"
    # Print a variable
    if is_text_var(arg, types):
        return "printf(\"%s\\n\", {arg});"
    "printf(\"%ld\\n\", (long){arg});"

# Translate array declaration
# Returns "code|||;arr:name;" if a string array is declared
fn translate_array_decl(name: text, rhs: text, type_hint: text, types: text) -> text:
    # Check for string array type
    if type_hint == "[text]" or type_hint == "[str]":
        if rhs == "[]":
            return "SimpleStringArray {name} = simple_new_string_array();|||;arr:{name};"
        # Non-empty string array init: ["a", "b", "c"]
        val inner = rhs.substring(1, rhs.len() - 1).trim()
        val elements = inner.split(",")
        var init_code = "SimpleStringArray {name} = simple_new_string_array();"
        for elem in elements:
            val trimmed_elem = elem.trim()
            init_code = init_code + " simple_string_push(&{name}, {trimmed_elem});"
        return init_code + "|||;arr:{name};"

    val inner = rhs.substring(1, rhs.len() - 1).trim()
    if inner == "":
        return "long {name}[] = {{}}; long {name}_len = 0;"
    val elements = inner.split(",")
    var c_elems: [text] = []
    for elem in elements:
        c_elems.push(translate_expr(elem.trim(), types))
    val arr_init = c_elems.join(", ")
    val arr_len = c_elems.len()
    "long {name}[] = {{{arr_init}}}; long {name}_len = {arr_len};"

# Translate variable declaration
# Returns "code|||;type_entries;" if new types are registered
fn translate_var_decl(stmt: text, types: text) -> text:
    val is_val = stmt.starts_with("val ")
    val eq_idx = stmt.index_of("=") ?? -1
    if eq_idx < 0:
        return "/* unsupported decl: {stmt} */"
    val lhs = stmt.substring(4, eq_idx).trim()
    val rhs = stmt.substring(eq_idx + 1).trim()
    var name = lhs
    var type_hint = ""
    val colon_idx = lhs.index_of(":") ?? -1
    if colon_idx >= 0:
        name = lhs.substring(0, colon_idx).trim()
        type_hint = lhs.substring(colon_idx + 1).trim()

    # Handle nil
    if rhs == "nil":
        return "const char* {name} = NULL;|||;text:{name};"

    # Handle string literal
    if rhs.starts_with("\""):
        return "const char* {name} = {rhs};|||;text:{name};"

    # Handle boolean
    if rhs == "true" or rhs == "false":
        var c_bval = "0"
        if rhs == "true":
            c_bval = "1"
        return "int {name} = {c_bval};"

    # Handle array literal
    if rhs.starts_with("[") and rhs.ends_with("]"):
        return translate_array_decl(name, rhs, type_hint, types)

    # Handle empty array with type hint
    if rhs == "[]":
        if type_hint == "[text]" or type_hint == "[str]":
            return "SimpleStringArray {name} = simple_new_string_array();|||;arr:{name};"
        return "long {name}[] = {{}}; long {name}_len = 0;"

    # Handle method call results
    val c_rhs = translate_expr(rhs, types)
    val rhs_is_str1 = c_rhs.contains("simple_substring")
    val rhs_is_str2 = c_rhs.contains("simple_trim")
    val rhs_is_str3 = c_rhs.contains("simple_replace")
    val rhs_is_str4 = c_rhs.contains("simple_string_join")
    val rhs_is_str5 = c_rhs.contains("simple_str_concat")
    val rhs_is_str6 = c_rhs.contains("simple_char_at")
    val rhs_is_str7 = c_rhs.contains("simple_file_read")
    val rhs_is_split = c_rhs.contains("simple_split")
    val any_str1 = rhs_is_str1 or rhs_is_str2 or rhs_is_str3 or rhs_is_str4
    val any_str2 = rhs_is_str5 or rhs_is_str6 or rhs_is_str7
    val rhs_returns_str = any_str1 or any_str2
    if rhs_returns_str:
        return "const char* {name} = {c_rhs};|||;text:{name};"

    if rhs_is_split:
        return "SimpleStringArray {name} = {c_rhs};|||;arr:{name};"

    # Handle text type hint
    if type_hint == "text" or type_hint == "str":
        return "const char* {name} = {c_rhs};|||;text:{name};"

    # Check if RHS is a function call that returns text
    val paren_pos = rhs.index_of("(") ?? -1
    if paren_pos >= 0:
        val fn_name = rhs.substring(0, paren_pos).trim()
        if is_fn_returning_text(fn_name, types):
            return "const char* {name} = {c_rhs};|||;text:{name};"

    # Default: long
    "long {name} = {c_rhs};"

# Translate for loop
# Returns "code|||;type_entries;" if loop var is registered as text
fn translate_for_loop(trimmed: text, types: text) -> text:
    val body = trimmed.substring(4, trimmed.len() - 1).trim()
    val in_idx = body.index_of(" in ") ?? -1
    if in_idx < 0:
        return "/* unsupported for: {trimmed} */"
    val loop_var = body.substring(0, in_idx).trim()
    val iterable = body.substring(in_idx + 4).trim()

    # range(start, end)
    if iterable.starts_with("range(") and iterable.ends_with(")"):
        val range_args = iterable.substring(6, iterable.len() - 1).trim()
        val comma_idx = range_args.index_of(",") ?? -1
        if comma_idx >= 0:
            val start_expr = range_args.substring(0, comma_idx).trim()
            val end_expr = range_args.substring(comma_idx + 1).trim()
            return "for (long {loop_var} = {translate_expr(start_expr, types)}; {loop_var} < {translate_expr(end_expr, types)}; {loop_var}++) {"
        else:
            return "for (long {loop_var} = 0; {loop_var} < {translate_expr(range_args, types)}; {loop_var}++) {"

    # start..end range
    val dotdot_idx = iterable.index_of("..") ?? -1
    if dotdot_idx >= 0:
        val start_expr = iterable.substring(0, dotdot_idx).trim()
        val end_expr = iterable.substring(dotdot_idx + 2).trim()
        return "for (long {loop_var} = {translate_expr(start_expr, types)}; {loop_var} < {translate_expr(end_expr, types)}; {loop_var}++) {"

    # for item in string_array (SimpleStringArray)
    if is_string_array_var(iterable, types):
        return "for (long _idx_{loop_var} = 0; _idx_{loop_var} < {iterable}.len; _idx_{loop_var}++) {{ const char* {loop_var} = {iterable}.items[_idx_{loop_var}];|||;text:{loop_var};"

    # for item in split result - detect .split( in iterable
    if iterable.contains(".split("):
        val c_split = translate_expr(iterable, types)
        return "{{ SimpleStringArray _split_{loop_var} = {c_split}; for (long _idx_{loop_var} = 0; _idx_{loop_var} < _split_{loop_var}.len; _idx_{loop_var}++) {{ const char* {loop_var} = _split_{loop_var}.items[_idx_{loop_var}];|||;text:{loop_var};"

    # Default: integer array iteration
    "for (long _idx_{loop_var} = 0; _idx_{loop_var} < {iterable}_len; _idx_{loop_var}++) {{ long {loop_var} = {iterable}[_idx_{loop_var}];"

# Translate case statement
fn translate_case(trimmed: text, types: text) -> text:
    val case_body = trimmed.substring(5, trimmed.len() - 1).trim()
    if case_body == "_":
        return "/* default: */"
    if case_body.starts_with("\""):
        return "if (strcmp(_match_val, {case_body}) == 0) {"
    "if (_match_val == {case_body}) {"

# Translate Simple statement to C
# Returns "code|||;type_entries;" if new types are registered
fn translate_statement(trimmed: text, types: text) -> text:
    # Skip module-system directives
    if trimmed.starts_with("use "):
        return "/* {trimmed} */"
    if trimmed.starts_with("import "):
        return "/* {trimmed} */"
    if trimmed.starts_with("export "):
        return "/* {trimmed} */"
    if trimmed.starts_with("extern fn "):
        return "/* {trimmed} */"

    # Print
    if trimmed.starts_with("print "):
        val rest = trimmed.substring(6).trim()
        return translate_print(rest, types)
    if trimmed == "print":
        return "puts(\"\");"

    # Variable declarations
    if trimmed.starts_with("val ") or trimmed.starts_with("var "):
        return translate_var_decl(trimmed, types)

    # Return
    if trimmed.starts_with("return "):
        val expr = trimmed.substring(7).trim()
        if expr == "()":
            return "return;"
        return "return {translate_expr(expr, types)};"
    if trimmed == "return":
        return "return;"
    if trimmed == "return ()":
        return "return;"

    # Control flow
    if trimmed.starts_with("if ") and trimmed.ends_with(":"):
        val cond = trimmed.substring(3, trimmed.len() - 1).trim()
        return "if ({translate_condition(cond, types)}) {"
    if trimmed.starts_with("elif ") and trimmed.ends_with(":"):
        val cond = trimmed.substring(5, trimmed.len() - 1).trim()
        return "} else if ({translate_condition(cond, types)}) {"
    if trimmed == "else:":
        return "} else {"

    # Loops
    if trimmed.starts_with("for ") and trimmed.ends_with(":"):
        return translate_for_loop(trimmed, types)

    # Match/case
    if trimmed.starts_with("match ") and trimmed.ends_with(":"):
        val match_expr = trimmed.substring(6, trimmed.len() - 1).trim()
        val c_match_expr = translate_expr(match_expr, types)
        # Detect string vs integer match
        if is_text_var(match_expr, types):
            return "{{ const char* _match_val = {c_match_expr};"
        return "{{ long _match_val = {c_match_expr};"
    if trimmed.starts_with("case ") and trimmed.ends_with(":"):
        return translate_case(trimmed, types)

    if trimmed == "break":
        return "break;"
    if trimmed == "continue":
        return "continue;"
    if trimmed == "pass" or trimmed == "()":
        return "/* pass */;"

    # Method calls as statements (e.g., arr.push("x"))
    val push_pos = trimmed.index_of(".push(") ?? -1
    if push_pos >= 0:
        val obj = trimmed.substring(0, push_pos).trim()
        val arg_start = push_pos + 6
        val arg_end = find_close_paren(trimmed, arg_start - 1)
        if arg_end >= 0:
            val arg = trimmed.substring(arg_start, arg_end)
            if is_string_array_var(obj, types):
                return "simple_string_push(&{obj}, {translate_expr(arg, types)});"
            return "/* {trimmed} */;"

    # .pop() as statement
    if trimmed.ends_with(".pop()"):
        val obj = trimmed.substring(0, trimmed.len() - 6).trim()
        if is_string_array_var(obj, types):
            return "simple_string_pop(&{obj});"

    # Compound assignment
    val plus_eq = trimmed.index_of(" += ") ?? -1
    if plus_eq >= 0:
        val lhs = trimmed.substring(0, plus_eq).trim()
        val rhs = trimmed.substring(plus_eq + 4).trim()
        # String concatenation assignment
        if is_text_var(lhs, types):
            return "{lhs} = simple_str_concat({lhs}, {translate_expr(rhs, types)});"
        return "{lhs} += {translate_expr(rhs, types)};"
    val minus_eq = trimmed.index_of(" -= ") ?? -1
    if minus_eq >= 0:
        val lhs = trimmed.substring(0, minus_eq).trim()
        val rhs = trimmed.substring(minus_eq + 4).trim()
        return "{lhs} -= {translate_expr(rhs, types)};"
    val times_eq = trimmed.index_of(" *= ") ?? -1
    if times_eq >= 0:
        val lhs = trimmed.substring(0, times_eq).trim()
        val rhs = trimmed.substring(times_eq + 4).trim()
        return "{lhs} *= {translate_expr(rhs, types)};"
    val div_eq = trimmed.index_of(" /= ") ?? -1
    if div_eq >= 0:
        val lhs = trimmed.substring(0, div_eq).trim()
        val rhs = trimmed.substring(div_eq + 4).trim()
        return "{lhs} /= {translate_expr(rhs, types)};"

    # Variable assignment
    val eq_idx = trimmed.index_of(" = ") ?? -1
    if eq_idx >= 0:
        val lhs = trimmed.substring(0, eq_idx).trim()
        val rhs = trimmed.substring(eq_idx + 3).trim()
        val no_space = not lhs.contains(" ")
        val no_paren = not lhs.starts_with("(")
        if no_space and no_paren:
            val c_rhs = translate_expr(rhs, types)
            # Track if assigning a string to a var (e.g., name = "Alice")
            val rhs_is_str = rhs.starts_with("\"")
            val rhs_is_text = c_rhs.contains("simple_")
            if rhs_is_str or rhs_is_text:
                return "{lhs} = {c_rhs};|||;text:{lhs};"
            return "{lhs} = {c_rhs};"

    # While loop
    if trimmed.starts_with("while ") and trimmed.ends_with(":"):
        val cond = trimmed.substring(6, trimmed.len() - 1).trim()
        return "while ({translate_condition(cond, types)}) {"

    # Function call (fallback)
    val paren_pos = trimmed.index_of("(") ?? -1
    if paren_pos >= 0 and trimmed.ends_with(")"):
        return "{translate_expr(trimmed, types)};"
    "/* unsupported: {trimmed} */"

# Close unclosed braces by tracking indentation levels
fn close_blocks(body_lines: [text]) -> [text]:
    var result: [text] = []
    var brace_indents: [i64] = []

    for idx in range(0, body_lines.len()):
        val line = body_lines[idx]
        val trimmed = line.trim()
        val current_indent = get_c_indent(line)

        if trimmed.starts_with("} else"):
            result.push(line)
            continue

        var close_count = 0
        for bi in range(0, brace_indents.len()):
            val stack_idx = brace_indents.len() - 1 - bi
            if stack_idx < 0:
                break
            if current_indent <= brace_indents[stack_idx]:
                close_count = close_count + 1
            else:
                break

        for ci in range(0, close_count):
            val pop_idx = brace_indents.len() - 1
            val close_indent = brace_indents[pop_idx]
            brace_indents.pop()
            var close_padding = ""
            for pi in range(0, close_indent):
                close_padding = close_padding + "    "
            result.push("{close_padding}}")

        result.push(line)

        if trimmed.ends_with("{"):
            brace_indents.push(current_indent)

    for ci in range(0, brace_indents.len()):
        val pop_idx = brace_indents.len() - 1 - ci
        val close_indent = brace_indents[pop_idx]
        var close_padding = ""
        for pi in range(0, close_indent):
            close_padding = close_padding + "    "
        result.push("{close_padding}}")

    result

# Build a C function definition
fn build_function(name: text, sig: text, body_lines: [text]) -> text:
    val closed_lines = close_blocks(body_lines)
    var result = "{sig} {\n"
    for body_line in closed_lines:
        result = result + body_line + "\n"
    result = result + "}"
    result

# Generate the C runtime helper code
fn generate_c_runtime() -> text:
    # Try to read from file first
    val runtime_path = "src/app/compile/c_runtime.c"
    if rt_file_exists(runtime_path):
        val raw = rt_file_read_text(runtime_path)
        val content = raw ?? ""
        return "\n" + content + "\n"
    # Fallback: minimal runtime
    print "Warning: C runtime not found at {runtime_path}"
    print "Using minimal embedded runtime."
    var rt = "\n// === Minimal Simple Runtime ===\n"
    rt = rt + "static long simple_strlen(const char* s) {{ return s ? (long)strlen(s) : 0; }}\n"
    rt = rt + "static int simple_contains(const char* s, const char* n) {{ return s && n && strstr(s, n) != NULL; }}\n"
    rt = rt + "static int simple_starts_with(const char* s, const char* p) {{ return s && p && strncmp(s, p, strlen(p)) == 0; }}\n"
    rt = rt + "static int simple_ends_with(const char* s, const char* x) {{ long sl = strlen(s), xl = strlen(x); return xl <= sl && strcmp(s+sl-xl, x) == 0; }}\n"
    rt = rt + "static long simple_index_of(const char* s, const char* n) {{ const char* f = strstr(s, n); return f ? (long)(f-s) : -1; }}\n"
    rt

# Parse struct definition lines into a C typedef
fn parse_struct_fields(lines_arr: [text], start_idx: i64) -> [text]:
    # Returns [end_index, c_typedef]
    var fields: [text] = []
    var idx = start_idx + 1
    for i in range(start_idx + 1, lines_arr.len()):
        val line = lines_arr[i]
        val trimmed = line.trim()
        if trimmed == "":
            idx = i + 1
            continue
        # Check if still indented (part of struct body)
        val is_indented = line.starts_with("    ")
        if not is_indented:
            break
        # Parse field: name: type
        val field_colon = trimmed.index_of(":") ?? -1
        if field_colon >= 0:
            val field_name = trimmed.substring(0, field_colon).trim()
            val field_type = trimmed.substring(field_colon + 1).trim()
            val c_type = simple_type_to_c(field_type)
            fields.push("    {c_type} {field_name};")
        idx = i + 1

    var typedef_body = fields.join("\n")
    ["{idx}", typedef_body]

# Helper to extract code and type entries from a "code|||entries" result
# Returns [code, type_entries] where type_entries may be ""
fn split_result(raw: text) -> [text]:
    val sep_pos = raw.index_of("|||") ?? -1
    if sep_pos >= 0:
        val code = raw.substring(0, sep_pos)
        val entries = raw.substring(sep_pos + 3)
        return [code, entries]
    [raw, ""]

# Generate C code from Simple source
fn generate_c_code(source_text: text) -> text:
    # Type registry - tracks variable types and function return types
    # Format: ";text:name;arr:name;fn_text:funcname;struct:StructName;"
    var types = ";"

    val lines_arr = source_text.split("\n")
    var forward_decls: [text] = []
    var func_defs: [text] = []
    var struct_defs: [text] = []
    var enum_defs: [text] = []
    var main_body: [text] = []
    var current_fn_name = ""
    var current_fn_lines: [text] = []
    var current_fn_sig = ""
    var in_main = false
    var in_func = false
    var in_struct = false
    var in_enum = false
    var skip_until_unindent = false

    for line_idx in range(0, lines_arr.len()):
        val line = lines_arr[line_idx]
        val trimmed = line.trim()

        if trimmed == "":
            continue
        if trimmed.starts_with("#!"):
            continue
        if trimmed.starts_with("#"):
            val comment_text = trimmed.substring(1).trim()
            if in_main:
                main_body.push("    // {comment_text}")
            elif in_func:
                current_fn_lines.push("    // {comment_text}")
            continue

        # Skip indented lines after struct/enum/impl/class
        if skip_until_unindent:
            val still_indented = line.starts_with("    ")
            val is_tab = line.starts_with("\t")
            if still_indented or is_tab:
                continue
            skip_until_unindent = false

        # Module directives - skip at top level
        if trimmed.starts_with("use "):
            continue
        if trimmed.starts_with("import "):
            continue
        if trimmed.starts_with("export "):
            continue
        if trimmed.starts_with("extern fn "):
            continue

        # Struct definition
        if trimmed.starts_with("struct ") and trimmed.ends_with(":"):
            val struct_name = trimmed.substring(7, trimmed.len() - 1).trim()
            types = types + "struct:" + struct_name + ";"
            # Parse fields from subsequent indented lines
            val field_result = parse_struct_fields(lines_arr, line_idx)
            val field_body = field_result[1]
            var sdef = "typedef struct {\n"
            sdef = sdef + field_body + "\n"
            sdef = sdef + "} {struct_name};"
            struct_defs.push(sdef)
            skip_until_unindent = true
            continue

        # Enum definition
        if trimmed.starts_with("enum ") and trimmed.ends_with(":"):
            val enum_name = trimmed.substring(5, trimmed.len() - 1).trim()
            # Collect variants from subsequent indented lines
            var variants: [text] = []
            for vi in range(line_idx + 1, lines_arr.len()):
                val vline = lines_arr[vi]
                val vtrimmed = vline.trim()
                if vtrimmed == "":
                    continue
                val v_indented = vline.starts_with("    ")
                if not v_indented:
                    break
                variants.push("{enum_name}_{vtrimmed}")
            val variant_list = variants.join(", ")
            enum_defs.push("typedef enum {{ {variant_list} }} {enum_name};")
            skip_until_unindent = true
            continue

        # Class definition - treat like struct
        if trimmed.starts_with("class ") and trimmed.ends_with(":"):
            val class_name = trimmed.substring(6, trimmed.len() - 1).trim()
            types = types + "struct:" + class_name + ";"
            val field_result = parse_struct_fields(lines_arr, line_idx)
            val field_body = field_result[1]
            var cdef = "typedef struct {\n"
            cdef = cdef + field_body + "\n"
            cdef = cdef + "} {class_name};"
            struct_defs.push(cdef)
            skip_until_unindent = true
            continue

        # Impl block - skip (methods handled separately)
        if trimmed.starts_with("impl ") and trimmed.ends_with(":"):
            skip_until_unindent = true
            continue

        # Function definition
        if trimmed.starts_with("fn ") and trimmed.ends_with(":"):
            if in_func:
                val fn_code = build_function(current_fn_name, current_fn_sig, current_fn_lines)
                func_defs.push(fn_code)
                current_fn_lines = []
            if trimmed == "fn main():" or trimmed.starts_with("fn main()"):
                in_main = true
                in_func = false
                continue
            val parsed = parse_fn_signature(trimmed)
            current_fn_name = parsed[0]
            current_fn_sig = parsed[1]
            val fwd = parsed[2]
            forward_decls.push(fwd)
            in_func = true
            in_main = false
            # Track function return type
            val arrow_idx = trimmed.index_of("->") ?? -1
            if arrow_idx >= 0:
                val ret_str = trimmed.substring(arrow_idx + 2)
                # Remove trailing colon
                val colon_pos = ret_str.index_of(":") ?? -1
                var ret_type = ret_str.trim()
                if colon_pos >= 0:
                    ret_type = ret_str.substring(0, colon_pos).trim()
                val is_text_ret = ret_type == "text" or ret_type == "str"
                if is_text_ret:
                    types = types + "fn_text:" + current_fn_name + ";"
            continue

        # Static fn - skip (would need struct-qualified name)
        if trimmed.starts_with("static fn ") and trimmed.ends_with(":"):
            skip_until_unindent = true
            continue

        # Mutable method (me keyword) - skip
        if trimmed.starts_with("me ") and trimmed.ends_with(":"):
            skip_until_unindent = true
            continue

        var is_indented = line.starts_with("    ")
        if not is_indented:
            is_indented = line.starts_with("\t")

        if in_main and is_indented:
            val indent = get_indent_level(line)
            val raw_result = translate_statement(trimmed, types)
            val parts = split_result(raw_result)
            val code = parts[0]
            val new_types = parts[1]
            if new_types != "":
                types = types + new_types
            if code != "":
                var padding = ""
                for pi in range(0, indent):
                    padding = padding + "    "
                main_body.push("{padding}{code}")
            continue

        if in_func and is_indented:
            val indent = get_indent_level(line)
            val raw_result = translate_statement(trimmed, types)
            val parts = split_result(raw_result)
            val code = parts[0]
            val new_types = parts[1]
            if new_types != "":
                types = types + new_types
            if code != "":
                var padding = ""
                for pi in range(0, indent):
                    padding = padding + "    "
                current_fn_lines.push("{padding}{code}")
            continue

        if in_main:
            in_main = false
        if in_func:
            val fn_code = build_function(current_fn_name, current_fn_sig, current_fn_lines)
            func_defs.push(fn_code)
            current_fn_lines = []
            in_func = false

        val raw_result = translate_statement(trimmed, types)
        val parts = split_result(raw_result)
        val code = parts[0]
        val new_types = parts[1]
        if new_types != "":
            types = types + new_types
        if code != "":
            main_body.push("    {code}")

    if in_func:
        val fn_code = build_function(current_fn_name, current_fn_sig, current_fn_lines)
        func_defs.push(fn_code)

    main_body = close_blocks(main_body)

    # Build final C code
    var c_code = "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n"

    # Add C runtime helpers
    c_code = c_code + generate_c_runtime()

    # Add struct/enum definitions
    if struct_defs.len() > 0:
        c_code = c_code + "\n// --- Struct Definitions ---\n"
        for sdef in struct_defs:
            c_code = c_code + sdef + "\n\n"

    if enum_defs.len() > 0:
        c_code = c_code + "\n// --- Enum Definitions ---\n"
        for edef in enum_defs:
            c_code = c_code + edef + "\n\n"

    # Add forward declarations
    if forward_decls.len() > 0:
        c_code = c_code + "\n// --- Forward Declarations ---\n"
        for fwd in forward_decls:
            c_code = c_code + fwd + "\n"
        c_code = c_code + "\n"

    # Add function definitions
    for func in func_defs:
        c_code = c_code + func + "\n\n"

    # Add main
    c_code = c_code + "int main(void) {\n"
    for body_line in main_body:
        c_code = c_code + body_line + "\n"
    c_code = c_code + "    return 0;\n}\n"
    c_code

export generate_c_code, close_blocks, translate_statement, translate_print
export translate_interpolated_print, translate_var_decl, translate_array_decl
export translate_for_loop, translate_case, translate_condition, translate_expr
export build_function, parse_fn_signature, translate_params, simple_type_to_c
export get_indent_level, get_c_indent
export generate_c_runtime, translate_method_expr, find_close_paren
export is_string_array_var, is_text_var, is_fn_returning_text, split_result
