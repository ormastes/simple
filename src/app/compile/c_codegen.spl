# Simple to C Code Generator (Enhanced)
#
# Shared C code generation logic used by both native and LLVM direct compilation paths.
# Translates Simple language to C code for bootstrapping.
#
# Supported features:
#   - Functions (fn, return), variables (val/var), control flow
#   - Arrays (integer and string), string interpolation in print
#   - String methods: .contains, .starts_with, .ends_with, .substring, .trim,
#     .split, .replace, .index_of, .len
#   - Dynamic string arrays: .push, .join, .pop
#   - Struct definitions and construction
#   - Enum definitions
#   - Nil/NULL, ?? (null coalescing)
#   - use/export/import (skipped gracefully)
#   - String concatenation with +
#
# Type tracking: Functions receive a `types` text parameter containing a registry string.
# Format: ";text:name;arr:name;fn_text:funcname;" (semicolon-delimited entries)
# Functions that add type entries return "code|||new_entries" separated by |||.
# The caller (generate_c_code) maintains and threads the registry through the main loop.
#
# Module structure:
#   - c_helpers.spl: Indentation, type conversion, signature parsing, type registry queries
#   - c_translate.spl: Expression/statement/control-flow translation to C
#   - c_runtime.spl: C runtime generation, struct parsing, result splitting

use app.compile.c_helpers.{get_indent_level, get_c_indent, simple_type_to_c, translate_params, parse_fn_signature, find_close_paren, is_string_array_var, is_int_array_var, is_str_arr_arr_var, is_int_arr_arr_var, is_text_var, is_fn_returning_text, is_struct_type_var, is_known_struct, is_known_method, is_me_method, is_static_fn, is_dict_var, is_option_var, parse_method_signature, parse_generic_type}
use app.compile.c_translate.{translate_condition, translate_method_expr, translate_expr, translate_interpolated_print, translate_print, translate_array_decl, translate_var_decl, translate_for_loop, translate_case, translate_statement, close_blocks, build_function}
use app.compile.c_runtime.{generate_c_runtime, parse_struct_fields, split_result}

# Generate C code from Simple source
fn generate_c_code(source_text: text) -> text:
    # Type registry - tracks variable types and function return types
    # Format: ";text:name;arr:name;fn_text:funcname;struct:StructName;"
    var types = ";"

    val lines_arr = source_text.split("\n")
    var forward_decls: [text] = []
    var func_defs: [text] = []
    var struct_defs: [text] = []
    var enum_defs: [text] = []
    var global_defs: [text] = []
    var main_body: [text] = []
    var current_fn_name = ""
    var current_fn_lines: [text] = []
    var current_fn_sig = ""
    var in_main = false
    var in_func = false
    var in_struct = false
    var in_enum = false
    var skip_until_unindent = false
    var current_impl_class = ""
    var in_impl = false
    var in_impl_method = false
    var impl_method_name = ""
    var impl_method_sig = ""
    var impl_method_lines: [text] = []
    var impl_method_is_me = false
    var lambda_counter = 0

    for line_idx in range(0, lines_arr.len()):
        val line = lines_arr[line_idx]
        val trimmed = line.trim()

        if trimmed == "":
            continue
        if trimmed.starts_with("#!"):
            continue
        if trimmed.starts_with("#"):
            val comment_text = trimmed.substring(1).trim()
            if in_main:
                main_body.push("    // {comment_text}")
            elif in_func:
                current_fn_lines.push("    // {comment_text}")
            continue

        # Handle impl block methods - indented lines inside impl
        if in_impl:
            val still_indented = line.starts_with("    ")
            val is_tab = line.starts_with("\t")
            if not still_indented and not is_tab:
                # End of impl block - flush any pending method
                if in_impl_method:
                    val method_code = build_function(current_impl_class + "__" + impl_method_name, impl_method_sig, impl_method_lines)
                    func_defs.push(method_code)
                    impl_method_lines = []
                    in_impl_method = false
                in_impl = false
                current_impl_class = ""
                # Fall through to process current line normally
            else:
                # Inside impl block
                val impl_indent = get_indent_level(line)
                if impl_indent == 1:
                    # Top-level impl member (fn, me, static fn)
                    if in_impl_method:
                        val method_code = build_function(current_impl_class + "__" + impl_method_name, impl_method_sig, impl_method_lines)
                        func_defs.push(method_code)
                        impl_method_lines = []
                        in_impl_method = false

                    if trimmed.starts_with("fn ") and trimmed.ends_with(":"):
                        val parsed = parse_method_signature(trimmed, current_impl_class, false)
                        impl_method_name = parsed[0]
                        impl_method_sig = parsed[1]
                        val fwd = parsed[2]
                        forward_decls.push(fwd)
                        in_impl_method = true
                        impl_method_is_me = false
                        types = types + "method:" + current_impl_class + "." + impl_method_name + ";"
                        # Track return type
                        val arrow_idx = trimmed.index_of("->") ?? -1
                        if arrow_idx >= 0:
                            val ret_str = trimmed.substring(arrow_idx + 2)
                            val rcolon = ret_str.index_of(":") ?? -1
                            var ret_type = ret_str.trim()
                            if rcolon >= 0:
                                ret_type = ret_str.substring(0, rcolon).trim()
                            if ret_type == "text" or ret_type == "str":
                                types = types + "fn_text:" + current_impl_class + "__" + impl_method_name + ";"
                        continue
                    elif trimmed.starts_with("me ") and trimmed.ends_with(":"):
                        val parsed = parse_method_signature(trimmed, current_impl_class, true)
                        impl_method_name = parsed[0]
                        impl_method_sig = parsed[1]
                        val fwd = parsed[2]
                        forward_decls.push(fwd)
                        in_impl_method = true
                        impl_method_is_me = true
                        types = types + "me_method:" + current_impl_class + "." + impl_method_name + ";"
                        val arrow_idx = trimmed.index_of("->") ?? -1
                        if arrow_idx >= 0:
                            val ret_str = trimmed.substring(arrow_idx + 2)
                            val rcolon = ret_str.index_of(":") ?? -1
                            var ret_type = ret_str.trim()
                            if rcolon >= 0:
                                ret_type = ret_str.substring(0, rcolon).trim()
                            if ret_type == "text" or ret_type == "str":
                                types = types + "fn_text:" + current_impl_class + "__" + impl_method_name + ";"
                        continue
                    elif trimmed.starts_with("static fn ") and trimmed.ends_with(":"):
                        # Static method - no self parameter
                        val static_trimmed = "fn " + trimmed.substring(10)
                        val parsed = parse_fn_signature(static_trimmed)
                        val static_method_name = parsed[0]
                        val mangled_name = current_impl_class + "__" + static_method_name
                        # Re-parse with mangled name
                        val static_sig_trimmed = static_trimmed.replace(static_method_name + "(", mangled_name + "(")
                        val parsed2 = parse_fn_signature(static_sig_trimmed)
                        impl_method_name = static_method_name
                        impl_method_sig = parsed2[1]
                        forward_decls.push(parsed2[2])
                        in_impl_method = true
                        impl_method_is_me = false
                        types = types + "static_fn:" + current_impl_class + "." + static_method_name + ";"
                        val arrow_idx = trimmed.index_of("->") ?? -1
                        if arrow_idx >= 0:
                            val ret_str = trimmed.substring(arrow_idx + 2)
                            val rcolon = ret_str.index_of(":") ?? -1
                            var ret_type = ret_str.trim()
                            if rcolon >= 0:
                                ret_type = ret_str.substring(0, rcolon).trim()
                            if ret_type == "text" or ret_type == "str":
                                types = types + "fn_text:" + mangled_name + ";"
                        continue
                    else:
                        # Skip other impl-level lines (comments etc)
                        continue
                elif impl_indent >= 2 and in_impl_method:
                    # Method body line - translate with self context
                    val raw_result = translate_statement(trimmed, types)
                    val parts = split_result(raw_result)
                    var code = parts[0]
                    val new_types = parts[1]
                    if new_types != "":
                        types = types + new_types
                    # Replace self.field access/assignment inside method bodies
                    if code.contains("self."):
                        code = code.replace("self.", "self->")
                    if code != "":
                        var padding = ""
                        for pi in range(0, impl_indent - 1):
                            padding = padding + "    "
                        impl_method_lines.push("{padding}{code}")
                    continue
                else:
                    continue

        # Skip indented lines after struct/enum/class (not impl - handled above)
        if skip_until_unindent:
            val still_indented = line.starts_with("    ")
            val is_tab = line.starts_with("\t")
            if still_indented or is_tab:
                continue
            skip_until_unindent = false

        # Module directives - skip at top level
        if trimmed.starts_with("use "):
            continue
        if trimmed.starts_with("import "):
            continue
        if trimmed.starts_with("export "):
            continue
        if trimmed.starts_with("from "):
            continue
        if trimmed.starts_with("pub mod "):
            continue
        if trimmed.starts_with("mod "):
            continue
        if trimmed.starts_with("export use "):
            continue
        if trimmed.starts_with("common use "):
            continue

        # Extern function - generate forward declaration instead of skipping
        if trimmed.starts_with("extern fn "):
            val extern_rest = trimmed.substring(10).trim()
            # Parse: name(params) -> ret
            val ep_idx = extern_rest.index_of("(") ?? -1
            if ep_idx >= 0:
                val extern_name = extern_rest.substring(0, ep_idx).trim()
                val eclose = extern_rest.index_of(")") ?? -1
                if eclose >= 0:
                    var eparams_str = ""
                    if eclose > ep_idx + 1:
                        eparams_str = extern_rest.substring(ep_idx + 1, eclose).trim()
                    val earrow = extern_rest.index_of("->") ?? -1
                    var eret_type = "void"
                    if earrow >= 0:
                        eret_type = simple_type_to_c(extern_rest.substring(earrow + 2).trim())
                    var ec_params = "void"
                    if eparams_str.len() > 0:
                        ec_params = translate_params(eparams_str)
                    forward_decls.push("{eret_type} {extern_name}({ec_params});")
            continue

        # Type alias - skip
        if trimmed.starts_with("type ") and trimmed.contains(" = "):
            continue

        # Docstrings - skip
        if trimmed.starts_with("\"\"\""):
            continue

        # Decorator attributes - skip
        if trimmed.starts_with("#["):
            continue

        # Struct definition
        if trimmed.starts_with("struct ") and trimmed.ends_with(":"):
            val struct_name = trimmed.substring(7, trimmed.len() - 1).trim()
            types = types + "struct:" + struct_name + ";"
            val field_result = parse_struct_fields(lines_arr, line_idx)
            val field_body = field_result[1]
            var sdef = "typedef struct {\n"
            sdef = sdef + field_body + "\n"
            sdef = sdef + "} {struct_name};"
            struct_defs.push(sdef)
            # Track text fields
            for fi in range(line_idx + 1, lines_arr.len()):
                val fline = lines_arr[fi]
                val ftrimmed = fline.trim()
                if ftrimmed == "":
                    continue
                val f_indented = fline.starts_with("    ")
                if not f_indented:
                    break
                val fcolon = ftrimmed.index_of(":") ?? -1
                if fcolon >= 0:
                    val fname = ftrimmed.substring(0, fcolon).trim()
                    val ftype = ftrimmed.substring(fcolon + 1).trim()
                    if ftype == "text" or ftype == "str":
                        types = types + "field_text:" + struct_name + "." + fname + ";"
            skip_until_unindent = true
            continue

        # Enum definition - detect data variants vs simple enums
        if trimmed.starts_with("enum ") and trimmed.ends_with(":"):
            val enum_name = trimmed.substring(5, trimmed.len() - 1).trim()
            var variants: [text] = []
            var has_data_variant = false
            var data_variants: [text] = []
            var simple_variants: [text] = []
            for vi in range(line_idx + 1, lines_arr.len()):
                val vline = lines_arr[vi]
                val vtrimmed = vline.trim()
                if vtrimmed == "":
                    continue
                val v_indented = vline.starts_with("    ")
                if not v_indented:
                    break
                # Skip comments and method-like lines inside enum
                if vtrimmed.starts_with("#"):
                    continue
                if vtrimmed.starts_with("fn ") or vtrimmed.starts_with("me ") or vtrimmed.starts_with("static fn "):
                    continue
                # Check if data variant: Name(field: type) or Name(type)
                val vparen = vtrimmed.index_of("(") ?? -1
                if vparen >= 0:
                    has_data_variant = true
                    data_variants.push(vtrimmed)
                else:
                    simple_variants.push(vtrimmed)

            if has_data_variant:
                # Generate tagged union
                var tag_idx = 0
                var union_fields = ""
                var constructors = ""
                var tag_defines = ""
                for dv in data_variants:
                    val dv_paren = dv.index_of("(") ?? -1
                    val dv_name = dv.substring(0, dv_paren).trim()
                    val dv_close = dv.index_of(")") ?? -1
                    var dv_fields_str = ""
                    if dv_close > dv_paren + 1:
                        dv_fields_str = dv.substring(dv_paren + 1, dv_close).trim()
                    tag_defines = tag_defines + "#define {enum_name}_TAG_{dv_name} {tag_idx}\n"
                    # Parse fields
                    var struct_fields = ""
                    var ctor_params = ""
                    var ctor_assigns = ""
                    if dv_fields_str.len() > 0:
                        val dv_parts = dv_fields_str.split(",")
                        var fi = 0
                        for dvp in dv_parts:
                            val dvf = dvp.trim()
                            val dvf_colon = dvf.index_of(":") ?? -1
                            if dvf_colon >= 0:
                                val fname = dvf.substring(0, dvf_colon).trim()
                                val ftype = dvf.substring(dvf_colon + 1).trim()
                                val ctype = simple_type_to_c(ftype)
                                struct_fields = struct_fields + "            {ctype} {fname};\n"
                                if fi > 0:
                                    ctor_params = ctor_params + ", "
                                ctor_params = ctor_params + "{ctype} {fname}"
                                ctor_assigns = ctor_assigns + "    r.data.{dv_name}.{fname} = {fname};\n"
                            else:
                                # Positional: _0, _1, etc
                                val ctype = simple_type_to_c(dvf)
                                val pname = "_{fi}"
                                struct_fields = struct_fields + "            {ctype} {pname};\n"
                                if fi > 0:
                                    ctor_params = ctor_params + ", "
                                ctor_params = ctor_params + "{ctype} {pname}"
                                ctor_assigns = ctor_assigns + "    r.data.{dv_name}.{pname} = {pname};\n"
                            fi = fi + 1
                    union_fields = union_fields + "        struct {{\n{struct_fields}        }} {dv_name};\n"
                    constructors = constructors + "static {enum_name} {enum_name}__{dv_name}({ctor_params}) {{\n"
                    constructors = constructors + "    {enum_name} r;\n    r.tag = {enum_name}_TAG_{dv_name};\n"
                    constructors = constructors + ctor_assigns
                    constructors = constructors + "    return r;\n}}\n"
                    tag_idx = tag_idx + 1
                # Also add simple variants as tags
                for sv in simple_variants:
                    tag_defines = tag_defines + "#define {enum_name}_TAG_{sv} {tag_idx}\n"
                    constructors = constructors + "static {enum_name} {enum_name}__{sv}(void) {{\n"
                    constructors = constructors + "    {enum_name} r;\n    r.tag = {enum_name}_TAG_{sv};\n"
                    constructors = constructors + "    return r;\n}}\n"
                    tag_idx = tag_idx + 1
                var edef = tag_defines + "\n"
                edef = edef + "typedef struct {{\n    int tag;\n    union {{\n"
                edef = edef + union_fields
                edef = edef + "    }} data;\n}} {enum_name};\n\n"
                edef = edef + constructors
                enum_defs.push(edef)
                types = types + "struct:" + enum_name + ";"
            else:
                # Simple enum - existing behavior
                var variant_names: [text] = []
                for sv in simple_variants:
                    variant_names.push("{enum_name}_{sv}")
                val variant_list = variant_names.join(", ")
                enum_defs.push("typedef enum {{ {variant_list} }} {enum_name};")
            skip_until_unindent = true
            continue

        # Class definition - treat like struct
        if trimmed.starts_with("class ") and trimmed.ends_with(":"):
            val class_name = trimmed.substring(6, trimmed.len() - 1).trim()
            types = types + "struct:" + class_name + ";"
            val field_result = parse_struct_fields(lines_arr, line_idx)
            val field_body = field_result[1]
            var cdef = "typedef struct {\n"
            cdef = cdef + field_body + "\n"
            cdef = cdef + "} {class_name};"
            struct_defs.push(cdef)
            # Track text fields
            for fi in range(line_idx + 1, lines_arr.len()):
                val fline = lines_arr[fi]
                val ftrimmed = fline.trim()
                if ftrimmed == "":
                    continue
                val f_indented = fline.starts_with("    ")
                if not f_indented:
                    break
                # Skip methods
                if ftrimmed.starts_with("fn ") or ftrimmed.starts_with("me ") or ftrimmed.starts_with("static fn "):
                    break
                val fcolon = ftrimmed.index_of(":") ?? -1
                if fcolon >= 0:
                    val fname = ftrimmed.substring(0, fcolon).trim()
                    val ftype = ftrimmed.substring(fcolon + 1).trim()
                    if ftype == "text" or ftype == "str":
                        types = types + "field_text:" + class_name + "." + fname + ";"
            skip_until_unindent = true
            continue

        # Impl block - parse methods
        if trimmed.starts_with("impl ") and trimmed.ends_with(":"):
            current_impl_class = trimmed.substring(5, trimmed.len() - 1).trim()
            in_impl = true
            in_impl_method = false
            continue

        # Function definition
        if trimmed.starts_with("fn ") and trimmed.ends_with(":"):
            if in_func:
                val fn_code = build_function(current_fn_name, current_fn_sig, current_fn_lines)
                func_defs.push(fn_code)
                current_fn_lines = []
            if trimmed == "fn main():" or trimmed.starts_with("fn main()"):
                in_main = true
                in_func = false
                continue
            val parsed = parse_fn_signature(trimmed)
            current_fn_name = parsed[0]
            current_fn_sig = parsed[1]
            val fwd = parsed[2]
            forward_decls.push(fwd)
            in_func = true
            in_main = false
            # Track function return type
            val arrow_idx = trimmed.index_of("->") ?? -1
            if arrow_idx >= 0:
                val ret_str = trimmed.substring(arrow_idx + 2)
                val colon_pos = ret_str.index_of(":") ?? -1
                var ret_type = ret_str.trim()
                if colon_pos >= 0:
                    ret_type = ret_str.substring(0, colon_pos).trim()
                val is_text_ret = ret_type == "text" or ret_type == "str"
                if is_text_ret:
                    types = types + "fn_text:" + current_fn_name + ";"
            # Track parameter types (text/str params, string array params)
            val fn_paren_idx = trimmed.index_of("(") ?? -1
            val fn_close_idx = trimmed.index_of(")") ?? -1
            if fn_paren_idx >= 0 and fn_close_idx > fn_paren_idx + 1:
                val fn_params_str = trimmed.substring(fn_paren_idx + 1, fn_close_idx)
                val fn_params = fn_params_str.split(",")
                for fn_param in fn_params:
                    val fp = fn_param.trim()
                    val fp_colon = fp.index_of(":") ?? -1
                    if fp_colon >= 0:
                        val fp_name = fp.substring(0, fp_colon).trim()
                        val fp_type = fp.substring(fp_colon + 1).trim()
                        if fp_type == "text" or fp_type == "str":
                            types = types + "text:" + fp_name + ";"
                        if fp_type == "[text]" or fp_type == "[str]":
                            types = types + "arr:" + fp_name + ";"
                        if fp_type == "[i64]" or fp_type == "[int]" or fp_type == "[bool]":
                            types = types + "int_arr:" + fp_name + ";"
                        if fp_type == "[[text]]" or fp_type == "[[str]]":
                            types = types + "str_arr_arr:" + fp_name + ";"
                        if fp_type == "[[i64]]" or fp_type == "[[int]]":
                            types = types + "int_arr_arr:" + fp_name + ";"
            continue

        # Static fn at top level - skip (only valid inside impl)
        if trimmed.starts_with("static fn ") and trimmed.ends_with(":"):
            skip_until_unindent = true
            continue

        # Mutable method at top level - skip (only valid inside impl)
        if trimmed.starts_with("me ") and trimmed.ends_with(":"):
            skip_until_unindent = true
            continue

        var is_indented = line.starts_with("    ")
        if not is_indented:
            is_indented = line.starts_with("\t")

        if in_main and is_indented:
            val indent = get_indent_level(line)
            val raw_result = translate_statement(trimmed, types)
            val parts = split_result(raw_result)
            val code = parts[0]
            val new_types = parts[1]
            if new_types != "":
                types = types + new_types
            if code != "":
                var padding = ""
                for pi in range(0, indent):
                    padding = padding + "    "
                main_body.push("{padding}{code}")
            continue

        if in_func and is_indented:
            val indent = get_indent_level(line)
            val raw_result = translate_statement(trimmed, types)
            val parts = split_result(raw_result)
            val code = parts[0]
            val new_types = parts[1]
            if new_types != "":
                types = types + new_types
            if code != "":
                var padding = ""
                for pi in range(0, indent):
                    padding = padding + "    "
                current_fn_lines.push("{padding}{code}")
            continue

        if in_main:
            in_main = false
        if in_func:
            val fn_code = build_function(current_fn_name, current_fn_sig, current_fn_lines)
            func_defs.push(fn_code)
            current_fn_lines = []
            in_func = false

        # Module-level statement - check if it's a val/var declaration (-> global)
        val is_module_val = trimmed.starts_with("val ")
        val is_module_var = trimmed.starts_with("var ")
        if is_module_val or is_module_var:
            val raw_result = translate_statement(trimmed, types)
            val parts = split_result(raw_result)
            val code = parts[0]
            val new_types = parts[1]
            if new_types != "":
                types = types + new_types
            if code != "":
                # Convert to global: remove const for val (use static), add static for var
                var global_code = code
                if global_code.starts_with("long long "):
                    global_code = "static " + global_code
                elif global_code.starts_with("const char* "):
                    global_code = "static " + global_code
                elif global_code.starts_with("int "):
                    global_code = "static " + global_code
                elif global_code.starts_with("SimpleStringArray "):
                    # Arrays need special init - can't call functions in global init
                    # Extract name and emit as uninitialized, init in main
                    val arr_eq = global_code.index_of(" = ") ?? -1
                    if arr_eq >= 0:
                        val arr_decl = global_code.substring(0, arr_eq)
                        global_defs.push("static {arr_decl};")
                        # Add init to main_body
                        val arr_name = arr_decl.substring(18).trim()
                        val arr_semi = arr_name.index_of(";") ?? -1
                        var clean_name = arr_name
                        if arr_semi >= 0:
                            clean_name = arr_name.substring(0, arr_semi).trim()
                        main_body.push("    {clean_name} = simple_new_string_array();")
                        continue
                    global_code = "static " + global_code
                elif global_code.starts_with("SimpleIntArray "):
                    # Int arrays need deferred init too
                    val arr_eq = global_code.index_of(" = ") ?? -1
                    if arr_eq >= 0:
                        val arr_decl = global_code.substring(0, arr_eq)
                        global_defs.push("static {arr_decl};")
                        val arr_name = arr_decl.substring(15).trim()
                        val arr_semi = arr_name.index_of(";") ?? -1
                        var clean_name = arr_name
                        if arr_semi >= 0:
                            clean_name = arr_name.substring(0, arr_semi).trim()
                        main_body.push("    {clean_name} = simple_new_int_array();")
                        continue
                    global_code = "static " + global_code
                elif global_code.starts_with("SimpleStringArrayArray "):
                    val arr_eq = global_code.index_of(" = ") ?? -1
                    if arr_eq >= 0:
                        val arr_decl = global_code.substring(0, arr_eq)
                        global_defs.push("static {arr_decl};")
                        val arr_name = arr_decl.substring(23).trim()
                        val arr_semi = arr_name.index_of(";") ?? -1
                        var clean_name = arr_name
                        if arr_semi >= 0:
                            clean_name = arr_name.substring(0, arr_semi).trim()
                        main_body.push("    {clean_name} = simple_new_string_array_array();")
                        continue
                    global_code = "static " + global_code
                elif global_code.starts_with("SimpleIntArrayArray "):
                    val arr_eq = global_code.index_of(" = ") ?? -1
                    if arr_eq >= 0:
                        val arr_decl = global_code.substring(0, arr_eq)
                        global_defs.push("static {arr_decl};")
                        val arr_name = arr_decl.substring(20).trim()
                        val arr_semi = arr_name.index_of(";") ?? -1
                        var clean_name = arr_name
                        if arr_semi >= 0:
                            clean_name = arr_name.substring(0, arr_semi).trim()
                        main_body.push("    {clean_name} = simple_new_int_array_array();")
                        continue
                    global_code = "static " + global_code
                elif global_code.starts_with("SimpleDict* "):
                    val dict_eq = global_code.index_of(" = ") ?? -1
                    if dict_eq >= 0:
                        val dict_decl = global_code.substring(0, dict_eq)
                        global_defs.push("static {dict_decl} = NULL;")
                        val dict_name_start = dict_decl.index_of("* ") ?? -1
                        if dict_name_start >= 0:
                            val dict_name = dict_decl.substring(dict_name_start + 2).trim()
                            main_body.push("    {dict_name} = simple_dict_new();")
                        continue
                    global_code = "static " + global_code
                else:
                    global_code = "static " + global_code
                global_defs.push(global_code)
        else:
            val raw_result = translate_statement(trimmed, types)
            val parts = split_result(raw_result)
            val code = parts[0]
            val new_types = parts[1]
            if new_types != "":
                types = types + new_types
            if code != "":
                main_body.push("    {code}")

    # Flush pending impl method
    if in_impl and in_impl_method:
        val method_code = build_function(current_impl_class + "__" + impl_method_name, impl_method_sig, impl_method_lines)
        func_defs.push(method_code)

    if in_func:
        val fn_code = build_function(current_fn_name, current_fn_sig, current_fn_lines)
        func_defs.push(fn_code)

    main_body = close_blocks(main_body)

    # Build final C code
    var c_code = "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n"
    c_code = c_code + "#include <stdint.h>\n"
    c_code = c_code + "#ifdef _MSC_VER\n#define strdup _strdup\n#endif\n"

    # Add C runtime helpers
    c_code = c_code + generate_c_runtime()

    # Add struct/enum definitions
    if struct_defs.len() > 0:
        c_code = c_code + "\n// --- Struct Definitions ---\n"
        for sdef in struct_defs:
            c_code = c_code + sdef + "\n\n"

    if enum_defs.len() > 0:
        c_code = c_code + "\n// --- Enum Definitions ---\n"
        for edef in enum_defs:
            c_code = c_code + edef + "\n\n"

    # Add global variable definitions
    if global_defs.len() > 0:
        c_code = c_code + "\n// --- Global Variables ---\n"
        for gdef in global_defs:
            c_code = c_code + gdef + "\n"
        c_code = c_code + "\n"

    # Add forward declarations
    if forward_decls.len() > 0:
        c_code = c_code + "\n// --- Forward Declarations ---\n"
        for fwd in forward_decls:
            c_code = c_code + fwd + "\n"
        c_code = c_code + "\n"

    # Add function definitions
    for func in func_defs:
        c_code = c_code + func + "\n\n"

    # Add main
    c_code = c_code + "int main(void) {\n"
    for body_line in main_body:
        c_code = c_code + body_line + "\n"
    c_code = c_code + "    return 0;\n}\n"
    c_code

export generate_c_code, close_blocks, translate_statement, translate_print
export translate_interpolated_print, translate_var_decl, translate_array_decl
export translate_for_loop, translate_case, translate_condition, translate_expr
export build_function, parse_fn_signature, translate_params, simple_type_to_c
export get_indent_level, get_c_indent
export generate_c_runtime, translate_method_expr, find_close_paren
export is_string_array_var, is_int_array_var, is_str_arr_arr_var, is_int_arr_arr_var, is_text_var, is_fn_returning_text, split_result
export is_struct_type_var, is_known_struct, is_known_method, is_me_method, is_static_fn
export is_dict_var, is_option_var, parse_method_signature, parse_generic_type
