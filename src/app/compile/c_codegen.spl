# Simple to C Code Generator (Enhanced)
#
# Shared C code generation logic used by both native and LLVM direct compilation paths.
# Translates Simple language to C code for bootstrapping.
#
# Supported features:
#   - Functions (fn, return), variables (val/var), control flow
#   - Arrays (integer and string), string interpolation in print
#   - String methods: .contains, .starts_with, .ends_with, .substring, .trim,
#     .split, .replace, .index_of, .len
#   - Dynamic string arrays: .push, .join, .pop
#   - Struct definitions and construction
#   - Enum definitions
#   - Nil/NULL, ?? (null coalescing)
#   - use/export/import (skipped gracefully)
#   - String concatenation with +
#
# Type tracking: Functions receive a `types` text parameter containing a registry string.
# Format: ";text:name;arr:name;fn_text:funcname;" (semicolon-delimited entries)
# Functions that add type entries return "code|||new_entries" separated by |||.
# The caller (generate_c_code) maintains and threads the registry through the main loop.
#
# Module structure:
#   - c_helpers.spl: Indentation, type conversion, signature parsing, type registry queries
#   - c_translate.spl: Expression/statement/control-flow translation to C
#   - c_runtime.spl: C runtime generation, struct parsing, result splitting

use app.compile.c_helpers.{get_indent_level, get_c_indent, simple_type_to_c, translate_params, parse_fn_signature, find_close_paren, is_string_array_var, is_text_var, is_fn_returning_text}
use app.compile.c_translate.{translate_condition, translate_method_expr, translate_expr, translate_interpolated_print, translate_print, translate_array_decl, translate_var_decl, translate_for_loop, translate_case, translate_statement, close_blocks, build_function}
use app.compile.c_runtime.{generate_c_runtime, parse_struct_fields, split_result}

# Generate C code from Simple source
fn generate_c_code(source_text: text) -> text:
    # Type registry - tracks variable types and function return types
    # Format: ";text:name;arr:name;fn_text:funcname;struct:StructName;"
    var types = ";"

    val lines_arr = source_text.split("\n")
    var forward_decls: [text] = []
    var func_defs: [text] = []
    var struct_defs: [text] = []
    var enum_defs: [text] = []
    var main_body: [text] = []
    var current_fn_name = ""
    var current_fn_lines: [text] = []
    var current_fn_sig = ""
    var in_main = false
    var in_func = false
    var in_struct = false
    var in_enum = false
    var skip_until_unindent = false

    for line_idx in range(0, lines_arr.len()):
        val line = lines_arr[line_idx]
        val trimmed = line.trim()

        if trimmed == "":
            continue
        if trimmed.starts_with("#!"):
            continue
        if trimmed.starts_with("#"):
            val comment_text = trimmed.substring(1).trim()
            if in_main:
                main_body.push("    // {comment_text}")
            elif in_func:
                current_fn_lines.push("    // {comment_text}")
            continue

        # Skip indented lines after struct/enum/impl/class
        if skip_until_unindent:
            val still_indented = line.starts_with("    ")
            val is_tab = line.starts_with("\t")
            if still_indented or is_tab:
                continue
            skip_until_unindent = false

        # Module directives - skip at top level
        if trimmed.starts_with("use "):
            continue
        if trimmed.starts_with("import "):
            continue
        if trimmed.starts_with("export "):
            continue
        if trimmed.starts_with("extern fn "):
            continue

        # Struct definition
        if trimmed.starts_with("struct ") and trimmed.ends_with(":"):
            val struct_name = trimmed.substring(7, trimmed.len() - 1).trim()
            types = types + "struct:" + struct_name + ";"
            # Parse fields from subsequent indented lines
            val field_result = parse_struct_fields(lines_arr, line_idx)
            val field_body = field_result[1]
            var sdef = "typedef struct {\n"
            sdef = sdef + field_body + "\n"
            sdef = sdef + "} {struct_name};"
            struct_defs.push(sdef)
            skip_until_unindent = true
            continue

        # Enum definition
        if trimmed.starts_with("enum ") and trimmed.ends_with(":"):
            val enum_name = trimmed.substring(5, trimmed.len() - 1).trim()
            # Collect variants from subsequent indented lines
            var variants: [text] = []
            for vi in range(line_idx + 1, lines_arr.len()):
                val vline = lines_arr[vi]
                val vtrimmed = vline.trim()
                if vtrimmed == "":
                    continue
                val v_indented = vline.starts_with("    ")
                if not v_indented:
                    break
                variants.push("{enum_name}_{vtrimmed}")
            val variant_list = variants.join(", ")
            enum_defs.push("typedef enum {{ {variant_list} }} {enum_name};")
            skip_until_unindent = true
            continue

        # Class definition - treat like struct
        if trimmed.starts_with("class ") and trimmed.ends_with(":"):
            val class_name = trimmed.substring(6, trimmed.len() - 1).trim()
            types = types + "struct:" + class_name + ";"
            val field_result = parse_struct_fields(lines_arr, line_idx)
            val field_body = field_result[1]
            var cdef = "typedef struct {\n"
            cdef = cdef + field_body + "\n"
            cdef = cdef + "} {class_name};"
            struct_defs.push(cdef)
            skip_until_unindent = true
            continue

        # Impl block - skip (methods handled separately)
        if trimmed.starts_with("impl ") and trimmed.ends_with(":"):
            skip_until_unindent = true
            continue

        # Function definition
        if trimmed.starts_with("fn ") and trimmed.ends_with(":"):
            if in_func:
                val fn_code = build_function(current_fn_name, current_fn_sig, current_fn_lines)
                func_defs.push(fn_code)
                current_fn_lines = []
            if trimmed == "fn main():" or trimmed.starts_with("fn main()"):
                in_main = true
                in_func = false
                continue
            val parsed = parse_fn_signature(trimmed)
            current_fn_name = parsed[0]
            current_fn_sig = parsed[1]
            val fwd = parsed[2]
            forward_decls.push(fwd)
            in_func = true
            in_main = false
            # Track function return type
            val arrow_idx = trimmed.index_of("->") ?? -1
            if arrow_idx >= 0:
                val ret_str = trimmed.substring(arrow_idx + 2)
                # Remove trailing colon
                val colon_pos = ret_str.index_of(":") ?? -1
                var ret_type = ret_str.trim()
                if colon_pos >= 0:
                    ret_type = ret_str.substring(0, colon_pos).trim()
                val is_text_ret = ret_type == "text" or ret_type == "str"
                if is_text_ret:
                    types = types + "fn_text:" + current_fn_name + ";"
            # Track parameter types (text/str params, string array params)
            val fn_paren_idx = trimmed.index_of("(") ?? -1
            val fn_close_idx = trimmed.index_of(")") ?? -1
            if fn_paren_idx >= 0 and fn_close_idx > fn_paren_idx + 1:
                val fn_params_str = trimmed.substring(fn_paren_idx + 1, fn_close_idx)
                val fn_params = fn_params_str.split(",")
                for fn_param in fn_params:
                    val fp = fn_param.trim()
                    val fp_colon = fp.index_of(":") ?? -1
                    if fp_colon >= 0:
                        val fp_name = fp.substring(0, fp_colon).trim()
                        val fp_type = fp.substring(fp_colon + 1).trim()
                        if fp_type == "text" or fp_type == "str":
                            types = types + "text:" + fp_name + ";"
                        if fp_type == "[text]" or fp_type == "[str]":
                            types = types + "arr:" + fp_name + ";"
            continue

        # Static fn - skip (would need struct-qualified name)
        if trimmed.starts_with("static fn ") and trimmed.ends_with(":"):
            skip_until_unindent = true
            continue

        # Mutable method (me keyword) - skip
        if trimmed.starts_with("me ") and trimmed.ends_with(":"):
            skip_until_unindent = true
            continue

        var is_indented = line.starts_with("    ")
        if not is_indented:
            is_indented = line.starts_with("\t")

        if in_main and is_indented:
            val indent = get_indent_level(line)
            val raw_result = translate_statement(trimmed, types)
            val parts = split_result(raw_result)
            val code = parts[0]
            val new_types = parts[1]
            if new_types != "":
                types = types + new_types
            if code != "":
                var padding = ""
                for pi in range(0, indent):
                    padding = padding + "    "
                main_body.push("{padding}{code}")
            continue

        if in_func and is_indented:
            val indent = get_indent_level(line)
            val raw_result = translate_statement(trimmed, types)
            val parts = split_result(raw_result)
            val code = parts[0]
            val new_types = parts[1]
            if new_types != "":
                types = types + new_types
            if code != "":
                var padding = ""
                for pi in range(0, indent):
                    padding = padding + "    "
                current_fn_lines.push("{padding}{code}")
            continue

        if in_main:
            in_main = false
        if in_func:
            val fn_code = build_function(current_fn_name, current_fn_sig, current_fn_lines)
            func_defs.push(fn_code)
            current_fn_lines = []
            in_func = false

        val raw_result = translate_statement(trimmed, types)
        val parts = split_result(raw_result)
        val code = parts[0]
        val new_types = parts[1]
        if new_types != "":
            types = types + new_types
        if code != "":
            main_body.push("    {code}")

    if in_func:
        val fn_code = build_function(current_fn_name, current_fn_sig, current_fn_lines)
        func_defs.push(fn_code)

    main_body = close_blocks(main_body)

    # Build final C code
    var c_code = "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n"
    c_code = c_code + "#include <stdint.h>\n"
    c_code = c_code + "#ifdef _MSC_VER\n#define strdup _strdup\n#endif\n"

    # Add C runtime helpers
    c_code = c_code + generate_c_runtime()

    # Add struct/enum definitions
    if struct_defs.len() > 0:
        c_code = c_code + "\n// --- Struct Definitions ---\n"
        for sdef in struct_defs:
            c_code = c_code + sdef + "\n\n"

    if enum_defs.len() > 0:
        c_code = c_code + "\n// --- Enum Definitions ---\n"
        for edef in enum_defs:
            c_code = c_code + edef + "\n\n"

    # Add forward declarations
    if forward_decls.len() > 0:
        c_code = c_code + "\n// --- Forward Declarations ---\n"
        for fwd in forward_decls:
            c_code = c_code + fwd + "\n"
        c_code = c_code + "\n"

    # Add function definitions
    for func in func_defs:
        c_code = c_code + func + "\n\n"

    # Add main
    c_code = c_code + "int main(void) {\n"
    for body_line in main_body:
        c_code = c_code + body_line + "\n"
    c_code = c_code + "    return 0;\n}\n"
    c_code

export generate_c_code, close_blocks, translate_statement, translate_print
export translate_interpolated_print, translate_var_decl, translate_array_decl
export translate_for_loop, translate_case, translate_condition, translate_expr
export build_function, parse_fn_signature, translate_params, simple_type_to_c
export get_indent_level, get_c_indent
export generate_c_runtime, translate_method_expr, find_close_paren
export is_string_array_var, is_text_var, is_fn_returning_text, split_result
