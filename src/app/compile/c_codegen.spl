# Simple to C Code Generator (Enhanced)
#
# Shared C code generation logic used by both native and LLVM direct compilation paths.
# Translates Simple language to C code for bootstrapping.
#
# Supported features:
#   - Functions (fn, return), variables (val/var), control flow
#   - Arrays (integer and string), string interpolation in print
#   - String methods: .contains, .starts_with, .ends_with, .substring, .trim,
#     .split, .replace, .index_of, .len
#   - Dynamic string arrays: .push, .join, .pop
#   - Struct definitions and construction
#   - Enum definitions
#   - Nil/NULL, ?? (null coalescing)
#   - use/export/import (skipped gracefully)
#   - String concatenation with +
#
# Type tracking: Functions receive a `types` text parameter containing a registry string.
# Format: ";text:name;arr:name;fn_text:funcname;" (semicolon-delimited entries)
# Functions that add type entries return "code|||new_entries" separated by |||.
# The caller (generate_c_code) maintains and threads the registry through the main loop.
#
# Module structure:
#   - c_helpers.spl: Indentation, type conversion, signature parsing, type registry queries
#   - c_translate.spl: Expression/statement/control-flow translation to C
#   - c_runtime.spl: C runtime generation, struct parsing, result splitting

use app.compile.c_helpers.{get_indent_level, get_c_indent, simple_type_to_c, translate_params, parse_fn_signature, find_close_paren, is_string_array_var, is_int_array_var, is_str_arr_arr_var, is_int_arr_arr_var, is_text_var, is_fn_returning_text, is_fn_returning_struct, is_struct_type_var, is_known_struct, is_known_method, is_me_method, is_static_fn, is_dict_var, is_option_var, parse_method_signature, parse_generic_type, is_struct_array_var, is_struct_field_struct_array, is_fn_returning_struct_arr}
use app.compile.c_translate.{translate_condition, translate_method_expr, translate_expr, translate_interpolated_print, translate_print, translate_array_decl, translate_var_decl, translate_for_loop, translate_case, translate_statement, close_blocks, build_function}
use app.compile.c_runtime.{generate_c_runtime, parse_struct_fields, split_result}

# Generate C code from Simple source
fn generate_c_code(source_text: text) -> text:
    # Type registry - tracks variable types and function return types
    # Format: ";text:name;arr:name;fn_text:funcname;struct:StructName;"
    var types = ";"

    # Pre-seed well-known cross-module variables (used by parser, lexer, etc.)
    types = types + "text:par_text;text:par_current;text:lex_cur_text;"
    types = types + "text:g_log_filter_pattern;"

    val raw_lines = source_text.split("\n")
    # Pre-process: join multi-line expressions (unclosed parentheses)
    var lines_arr: [text] = []
    var pending_line = ""
    var paren_depth = 0
    for li in range(0, raw_lines.len()):
        val rline = raw_lines[li]
        if pending_line != "":
            pending_line = pending_line + " " + rline.trim()
        else:
            pending_line = rline
        # Count parens in this line using string methods (avoids char indexing with Unicode)
        val has_paren = rline.contains("(") or rline.contains(")")
        if has_paren:
            # Count open and close parens by splitting
            val open_count = rline.split("(").len() - 1
            val close_count = rline.split(")").len() - 1
            # Adjust for parens inside strings: if line has quotes, be more careful
            if rline.contains("\""):
                # Simple heuristic: count parens outside strings
                # Split by " and only count in even segments (outside strings)
                val segments = rline.split("\"")
                var seg_opens = 0
                var seg_closes = 0
                for si in range(0, segments.len()):
                    if si % 2 == 0:
                        seg_opens = seg_opens + segments[si].split("(").len() - 1
                        seg_closes = seg_closes + segments[si].split(")").len() - 1
                paren_depth = paren_depth + seg_opens - seg_closes
            else:
                paren_depth = paren_depth + open_count - close_count
        if paren_depth <= 0:
            lines_arr.push(pending_line)
            pending_line = ""
            paren_depth = 0
    if pending_line != "":
        lines_arr.push(pending_line)

    var forward_decls: [text] = []
    var func_defs: [text] = []
    var struct_defs: [text] = []
    var enum_defs: [text] = []
    var global_defs: [text] = []
    var main_body: [text] = []
    var current_fn_name = ""
    var current_fn_lines: [text] = []
    var current_fn_sig = ""
    var types_before_fn = ""
    var in_main = false
    var in_func = false
    var in_struct = false
    var in_enum = false
    var skip_until_unindent = false
    var current_impl_class = ""
    var in_impl = false
    var in_impl_method = false
    var impl_method_name = ""
    var impl_method_sig = ""
    var impl_method_lines: [text] = []
    var impl_method_is_me = false
    var lambda_counter = 0
    var skip_until_close_brace = false

    # Pre-pass: collect all struct/class/enum names and field types
    # This resolves forward references (e.g., impl using struct defined later)
    var pre_skip = false
    for pi in range(0, lines_arr.len()):
        val pline = lines_arr[pi]
        val ptrim = pline.trim()
        if ptrim == "":
            continue
        val p_is_struct = ptrim.starts_with("struct ") and ptrim.ends_with(":")
        val p_is_class = ptrim.starts_with("class ") and ptrim.ends_with(":")
        val p_is_enum = ptrim.starts_with("enum ") and ptrim.ends_with(":")
        if p_is_struct or p_is_class:
            var p_name = ""
            if p_is_struct:
                p_name = ptrim.substring(7, ptrim.len() - 1).trim()
            else:
                p_name = ptrim.substring(6, ptrim.len() - 1).trim()
            types = types + "struct:" + p_name + ";"
            # Scan fields
            for pfi in range(pi + 1, lines_arr.len()):
                val pfline = lines_arr[pfi]
                val pftrim = pfline.trim()
                if pftrim == "":
                    continue
                val pf_ind = pfline.starts_with("    ") or pfline.starts_with("\t")
                if not pf_ind:
                    break
                if pftrim.starts_with("fn ") or pftrim.starts_with("me ") or pftrim.starts_with("static fn "):
                    break
                if pftrim.starts_with("#"):
                    continue
                # Strip inline comments
                var pf_clean = pftrim
                val pf_hash = pftrim.index_of(" #") ?? -1
                if pf_hash >= 0:
                    pf_clean = pftrim.substring(0, pf_hash).trim()
                val pf_colon = pf_clean.index_of(":") ?? -1
                if pf_colon >= 0:
                    val pf_fname = pf_clean.substring(0, pf_colon).trim()
                    val pf_ftype = pf_clean.substring(pf_colon + 1).trim()
                    if pf_ftype == "text" or pf_ftype == "str":
                        types = types + "field_text:" + p_name + "." + pf_fname + ";"
                    if pf_ftype == "[text]" or pf_ftype == "[str]":
                        types = types + "field_arr:" + p_name + "." + pf_fname + ";"
                    if pf_ftype == "[i64]" or pf_ftype == "[int]" or pf_ftype == "[bool]":
                        types = types + "field_int_arr:" + p_name + "." + pf_fname + ";"
                    # Struct array field: [StructName]
                    if pf_ftype.starts_with("[") and pf_ftype.ends_with("]"):
                        val pf_elem = pf_ftype.substring(1, pf_ftype.len() - 1).trim()
                        if pf_elem.len() > 0:
                            val pf_ef = pf_elem[0]
                            if pf_ef >= "A" and pf_ef <= "Z":
                                types = types + "field_struct_arr:" + p_name + "." + pf_fname + "=" + pf_elem + ";"
        if p_is_enum:
            val pe_name = ptrim.substring(5, ptrim.len() - 1).trim()
            # Scan variants
            for pei in range(pi + 1, lines_arr.len()):
                val peline = lines_arr[pei]
                val petrim = peline.trim()
                if petrim == "":
                    continue
                val pe_ind = peline.starts_with("    ") or peline.starts_with("\t")
                if not pe_ind:
                    break
                if petrim.starts_with("#") or petrim.starts_with("fn ") or petrim.starts_with("me "):
                    continue
                val pe_paren = petrim.index_of("(") ?? -1
                var pe_vname = petrim
                if pe_paren >= 0:
                    pe_vname = petrim.substring(0, pe_paren).trim()
                types = types + "enum_variant:" + pe_name + "." + pe_vname + ";"

    for line_idx in range(0, lines_arr.len()):
        val line = lines_arr[line_idx]
        var trimmed = line.trim()

        if trimmed == "":
            continue

        # Skip lines inside multi-line import blocks (pub use ... { ... })
        if skip_until_close_brace:
            if trimmed == "}" or trimmed.ends_with("}"):
                skip_until_close_brace = false
            continue

        # Strip inline comments: code # comment (but not inside strings)
        # Handle both "code  # comment" and "code # comment"
        if trimmed.contains(" #") and not trimmed.starts_with("#"):
            val inline_hash = trimmed.index_of(" #") ?? -1
            if inline_hash >= 0:
                # Make sure it's not inside a string literal
                val before_hash = trimmed.substring(0, inline_hash)
                val quote_count = before_hash.split("\"").len() - 1
                val is_inside_str = quote_count % 2 == 1
                # Also check it's not a #[ decorator or #! shebang
                val after_hash = trimmed.substring(inline_hash + 2).trim()
                val is_decorator = after_hash.starts_with("[")
                if not is_inside_str and not is_decorator:
                    trimmed = before_hash.trim()
        if trimmed.starts_with("#!"):
            continue
        if trimmed.starts_with("#"):
            val comment_text = trimmed.substring(1).trim()
            val comment_indented = line.starts_with("    ") or line.starts_with("\t")
            if in_main and comment_indented:
                main_body.push("    // {comment_text}")
            elif in_func and comment_indented:
                current_fn_lines.push("    // {comment_text}")
            elif in_func and not comment_indented:
                # Top-level comment while in_func - end the function
                val fn_code = build_function(current_fn_name, current_fn_sig, current_fn_lines)
                func_defs.push(fn_code)
                current_fn_lines = []
                in_func = false
                types = types_before_fn
            continue

        # Handle impl block methods - indented lines inside impl
        if in_impl:
            val still_indented = line.starts_with("    ")
            val is_tab = line.starts_with("\t")
            if not still_indented and not is_tab:
                # End of impl block - flush any pending method
                if in_impl_method:
                    val method_code = build_function(current_impl_class + "__" + impl_method_name, impl_method_sig, impl_method_lines)
                    func_defs.push(method_code)
                    impl_method_lines = []
                    in_impl_method = false
                in_impl = false
                current_impl_class = ""
                # Fall through to process current line normally
            else:
                # Inside impl block
                val impl_indent = get_indent_level(line)
                if impl_indent == 1:
                    # Top-level impl member (fn, me, static fn)
                    if in_impl_method:
                        val method_code = build_function(current_impl_class + "__" + impl_method_name, impl_method_sig, impl_method_lines)
                        func_defs.push(method_code)
                        impl_method_lines = []
                        in_impl_method = false

                    if trimmed.starts_with("fn ") and trimmed.ends_with(":"):
                        val parsed = parse_method_signature(trimmed, current_impl_class, false)
                        impl_method_name = parsed[0]
                        impl_method_sig = parsed[1]
                        val fwd = parsed[2]
                        forward_decls.push(fwd)
                        in_impl_method = true
                        impl_method_is_me = false
                        types = types + "method:" + current_impl_class + "." + impl_method_name + ";"
                        types = types + "struct_var:self=" + current_impl_class + ";"
                        # Track return type
                        val arrow_idx = trimmed.index_of("->") ?? -1
                        if arrow_idx >= 0:
                            val ret_str = trimmed.substring(arrow_idx + 2)
                            val rcolon = ret_str.index_of(":") ?? -1
                            var ret_type = ret_str.trim()
                            if rcolon >= 0:
                                ret_type = ret_str.substring(0, rcolon).trim()
                            if ret_type == "text" or ret_type == "str":
                                types = types + "fn_text:" + current_impl_class + "__" + impl_method_name + ";"
                            if ret_type.len() > 0:
                                val rt_first = ret_type[0]
                                val rt_upper = rt_first >= "A" and rt_first <= "Z"
                                if rt_upper:
                                    types = types + "fn_struct:" + current_impl_class + "__" + impl_method_name + "=" + ret_type + ";"
                            if ret_type.starts_with("[") and ret_type.ends_with("]"):
                                val rt_sa_elem = ret_type.substring(1, ret_type.len() - 1).trim()
                                if rt_sa_elem.len() > 0:
                                    val rt_sa_f = rt_sa_elem[0]
                                    if rt_sa_f >= "A" and rt_sa_f <= "Z":
                                        types = types + "fn_struct_arr:" + current_impl_class + "__" + impl_method_name + "=" + rt_sa_elem + ";"
                        # Track method parameter types
                        val mp_open = trimmed.index_of("(") ?? -1
                        val mp_close = trimmed.index_of(")") ?? -1
                        if mp_open >= 0 and mp_close > mp_open + 1:
                            val mp_str = trimmed.substring(mp_open + 1, mp_close)
                            val mp_parts = mp_str.split(",")
                            for mp in mp_parts:
                                val mp_trim = mp.trim()
                                val mp_colon = mp_trim.index_of(":") ?? -1
                                if mp_colon >= 0:
                                    val mp_name = mp_trim.substring(0, mp_colon).trim()
                                    val mp_type = mp_trim.substring(mp_colon + 1).trim()
                                    if mp_type == "text" or mp_type == "str":
                                        types = types + "text:" + mp_name + ";"
                                    if mp_type == "[text]" or mp_type == "[str]":
                                        types = types + "arr:" + mp_name + ";"
                                    if mp_type == "[i64]" or mp_type == "[int]" or mp_type == "[bool]":
                                        types = types + "int_arr:" + mp_name + ";"
                                    if mp_type == "[[text]]" or mp_type == "[[str]]":
                                        types = types + "str_arr_arr:" + mp_name + ";"
                                    if mp_type == "[[i64]]" or mp_type == "[[int]]":
                                        types = types + "int_arr_arr:" + mp_name + ";"
                                    if mp_type.starts_with("[") and mp_type.ends_with("]"):
                                        val mp_elem = mp_type.substring(1, mp_type.len() - 1).trim()
                                        if mp_elem.len() > 0:
                                            val mp_ef = mp_elem[0]
                                            if mp_ef >= "A" and mp_ef <= "Z":
                                                types = types + "struct_arr_var:" + mp_name + "=" + mp_elem + ";"
                                    if mp_type.len() > 0:
                                        val mp_first = mp_type[0]
                                        val mp_is_upper = mp_first >= "A" and mp_first <= "Z"
                                        if mp_is_upper:
                                            types = types + "struct_var:" + mp_name + "=" + mp_type + ";"
                        continue
                    elif trimmed.starts_with("me ") and trimmed.ends_with(":"):
                        val parsed = parse_method_signature(trimmed, current_impl_class, true)
                        impl_method_name = parsed[0]
                        impl_method_sig = parsed[1]
                        val fwd = parsed[2]
                        forward_decls.push(fwd)
                        in_impl_method = true
                        impl_method_is_me = true
                        types = types + "me_method:" + current_impl_class + "." + impl_method_name + ";"
                        types = types + "struct_var:self=" + current_impl_class + ";"
                        val arrow_idx = trimmed.index_of("->") ?? -1
                        if arrow_idx >= 0:
                            val ret_str = trimmed.substring(arrow_idx + 2)
                            val rcolon = ret_str.index_of(":") ?? -1
                            var ret_type = ret_str.trim()
                            if rcolon >= 0:
                                ret_type = ret_str.substring(0, rcolon).trim()
                            if ret_type == "text" or ret_type == "str":
                                types = types + "fn_text:" + current_impl_class + "__" + impl_method_name + ";"
                            if ret_type.len() > 0:
                                val rt_first = ret_type[0]
                                val rt_upper = rt_first >= "A" and rt_first <= "Z"
                                if rt_upper:
                                    types = types + "fn_struct:" + current_impl_class + "__" + impl_method_name + "=" + ret_type + ";"
                        # Track me method parameter types
                        val mp_open = trimmed.index_of("(") ?? -1
                        val mp_close = trimmed.index_of(")") ?? -1
                        if mp_open >= 0 and mp_close > mp_open + 1:
                            val mp_str = trimmed.substring(mp_open + 1, mp_close)
                            val mp_parts = mp_str.split(",")
                            for mp in mp_parts:
                                val mp_trim = mp.trim()
                                val mp_colon = mp_trim.index_of(":") ?? -1
                                if mp_colon >= 0:
                                    val mp_name = mp_trim.substring(0, mp_colon).trim()
                                    val mp_type = mp_trim.substring(mp_colon + 1).trim()
                                    if mp_type == "text" or mp_type == "str":
                                        types = types + "text:" + mp_name + ";"
                                    if mp_type == "[text]" or mp_type == "[str]":
                                        types = types + "arr:" + mp_name + ";"
                                    if mp_type == "[i64]" or mp_type == "[int]" or mp_type == "[bool]":
                                        types = types + "int_arr:" + mp_name + ";"
                                    if mp_type == "[[text]]" or mp_type == "[[str]]":
                                        types = types + "str_arr_arr:" + mp_name + ";"
                                    if mp_type == "[[i64]]" or mp_type == "[[int]]":
                                        types = types + "int_arr_arr:" + mp_name + ";"
                                    if mp_type.starts_with("[") and mp_type.ends_with("]"):
                                        val mp_elem = mp_type.substring(1, mp_type.len() - 1).trim()
                                        if mp_elem.len() > 0:
                                            val mp_ef = mp_elem[0]
                                            if mp_ef >= "A" and mp_ef <= "Z":
                                                types = types + "struct_arr_var:" + mp_name + "=" + mp_elem + ";"
                                    if mp_type.len() > 0:
                                        val mp_first = mp_type[0]
                                        val mp_is_upper = mp_first >= "A" and mp_first <= "Z"
                                        if mp_is_upper:
                                            types = types + "struct_var:" + mp_name + "=" + mp_type + ";"
                        continue
                    elif trimmed.starts_with("static fn ") and trimmed.ends_with(":"):
                        # Static method - no self parameter
                        val static_trimmed = "fn " + trimmed.substring(10)
                        val parsed = parse_fn_signature(static_trimmed)
                        val static_method_name = parsed[0]
                        val mangled_name = current_impl_class + "__" + static_method_name
                        # Re-parse with mangled name
                        val static_sig_trimmed = static_trimmed.replace(static_method_name + "(", mangled_name + "(")
                        val parsed2 = parse_fn_signature(static_sig_trimmed)
                        impl_method_name = static_method_name
                        impl_method_sig = parsed2[1]
                        forward_decls.push(parsed2[2])
                        in_impl_method = true
                        impl_method_is_me = false
                        types = types + "static_fn:" + current_impl_class + "." + static_method_name + ";"
                        val arrow_idx = trimmed.index_of("->") ?? -1
                        if arrow_idx >= 0:
                            val ret_str = trimmed.substring(arrow_idx + 2)
                            val rcolon = ret_str.index_of(":") ?? -1
                            var ret_type = ret_str.trim()
                            if rcolon >= 0:
                                ret_type = ret_str.substring(0, rcolon).trim()
                            if ret_type == "text" or ret_type == "str":
                                types = types + "fn_text:" + mangled_name + ";"
                            if ret_type.len() > 0:
                                val rt_first = ret_type[0]
                                val rt_upper = rt_first >= "A" and rt_first <= "Z"
                                if rt_upper:
                                    types = types + "fn_struct:" + mangled_name + "=" + ret_type + ";"
                        # Track static method parameter types
                        val mp_open = trimmed.index_of("(") ?? -1
                        val mp_close = trimmed.index_of(")") ?? -1
                        if mp_open >= 0 and mp_close > mp_open + 1:
                            val mp_str = trimmed.substring(mp_open + 1, mp_close)
                            val mp_parts = mp_str.split(",")
                            for mp in mp_parts:
                                val mp_trim = mp.trim()
                                val mp_colon = mp_trim.index_of(":") ?? -1
                                if mp_colon >= 0:
                                    val mp_name = mp_trim.substring(0, mp_colon).trim()
                                    val mp_type = mp_trim.substring(mp_colon + 1).trim()
                                    if mp_type == "text" or mp_type == "str":
                                        types = types + "text:" + mp_name + ";"
                                    if mp_type == "[text]" or mp_type == "[str]":
                                        types = types + "arr:" + mp_name + ";"
                                    if mp_type == "[i64]" or mp_type == "[int]" or mp_type == "[bool]":
                                        types = types + "int_arr:" + mp_name + ";"
                                    if mp_type.starts_with("[") and mp_type.ends_with("]"):
                                        val mp_elem = mp_type.substring(1, mp_type.len() - 1).trim()
                                        if mp_elem.len() > 0:
                                            val mp_ef = mp_elem[0]
                                            if mp_ef >= "A" and mp_ef <= "Z":
                                                types = types + "struct_arr_var:" + mp_name + "=" + mp_elem + ";"
                                    if mp_type.len() > 0:
                                        val mp_first = mp_type[0]
                                        val mp_is_upper = mp_first >= "A" and mp_first <= "Z"
                                        if mp_is_upper:
                                            types = types + "struct_var:" + mp_name + "=" + mp_type + ";"
                        continue
                    else:
                        # Skip other impl-level lines (comments etc)
                        continue
                elif impl_indent >= 2 and in_impl_method:
                    # Method body line - translate with self context
                    val raw_result = translate_statement(trimmed, types)
                    val parts = split_result(raw_result)
                    var code = parts[0]
                    val new_types = parts[1]
                    if new_types != "":
                        types = types + new_types
                    # Replace self.method(args) calls before generic self. replacement
                    if code.contains("self."):
                        var sm_pos = code.index_of("self.") ?? -1
                        if sm_pos >= 0:
                            val sm_after = code.substring(sm_pos + 5)
                            val sm_paren = sm_after.index_of("(") ?? -1
                            val sm_dot2 = sm_after.index_of(".") ?? -1
                            val sm_space = sm_after.index_of(" ") ?? -1
                            val sm_eq = sm_after.index_of("=") ?? -1
                            # Is this a method call? (paren comes before dot/space/eq)
                            var sm_is_call = sm_paren >= 0
                            if sm_is_call and sm_dot2 >= 0 and sm_dot2 < sm_paren:
                                sm_is_call = false
                            if sm_is_call and sm_space >= 0 and sm_space < sm_paren:
                                sm_is_call = false
                            if sm_is_call and sm_eq >= 0 and sm_eq < sm_paren:
                                sm_is_call = false
                            if sm_is_call:
                                val sm_name = sm_after.substring(0, sm_paren).trim()
                                val sm_close = find_close_paren(sm_after, sm_paren)
                                if sm_close >= 0:
                                    var sm_args = ""
                                    if sm_close > sm_paren + 1:
                                        sm_args = sm_after.substring(sm_paren + 1, sm_close)
                                    var sm_rest = ""
                                    if sm_close + 1 < sm_after.len():
                                        sm_rest = sm_after.substring(sm_close + 1)
                                    val sm_before = code.substring(0, sm_pos)
                                    if sm_args != "":
                                        code = "{sm_before}{current_impl_class}__{sm_name}(&self, {sm_args}){sm_rest}"
                                    else:
                                        code = "{sm_before}{current_impl_class}__{sm_name}(&self){sm_rest}"
                    # Replace self.field access/assignment inside method bodies
                    if code.contains("self."):
                        code = code.replace("self.", "self->")
                    if code != "":
                        var padding = ""
                        for pi in range(0, impl_indent - 1):
                            padding = padding + "    "
                        impl_method_lines.push("{padding}{code}")
                    continue
                else:
                    continue

        # Skip indented lines after struct/enum/class (not impl - handled above)
        if skip_until_unindent:
            val still_indented = line.starts_with("    ")
            val is_tab = line.starts_with("\t")
            if still_indented or is_tab:
                continue
            skip_until_unindent = false

        # Module directives - skip at top level
        if trimmed.starts_with("use "):
            continue
        if trimmed.starts_with("import "):
            continue
        if trimmed.starts_with("export "):
            continue
        if trimmed.starts_with("from "):
            continue
        if trimmed.starts_with("pub mod "):
            continue
        if trimmed.starts_with("mod "):
            continue
        if trimmed.starts_with("export use "):
            continue
        if trimmed.starts_with("pub use "):
            if trimmed.ends_with("{"):
                skip_until_close_brace = true
            continue
        if trimmed.starts_with("common use "):
            continue

        # Extern function - generate forward declaration instead of skipping
        if trimmed.starts_with("extern fn "):
            val extern_rest = trimmed.substring(10).trim()
            # Parse: name(params) -> ret
            val ep_idx = extern_rest.index_of("(") ?? -1
            if ep_idx >= 0:
                val extern_name = extern_rest.substring(0, ep_idx).trim()
                val eclose = extern_rest.index_of(")") ?? -1
                if eclose >= 0:
                    var eparams_str = ""
                    if eclose > ep_idx + 1:
                        eparams_str = extern_rest.substring(ep_idx + 1, eclose).trim()
                    val earrow = extern_rest.index_of("->") ?? -1
                    var eret_type = "void"
                    if earrow >= 0:
                        eret_type = simple_type_to_c(extern_rest.substring(earrow + 2).trim())
                    var ec_params = "void"
                    if eparams_str.len() > 0:
                        ec_params = translate_params(eparams_str)
                    forward_decls.push("{eret_type} {extern_name}({ec_params});")
                    # Track extern fn return types for type inference
                    if eret_type == "const char*":
                        types = types + "fn_text:" + extern_name + ";"
                    # Track struct return types
                    if earrow >= 0:
                        val eret_raw = extern_rest.substring(earrow + 2).trim()
                        if eret_raw.len() > 0:
                            val eret_first = eret_raw[0]
                            if eret_first >= "A" and eret_first <= "Z":
                                types = types + "fn_struct:" + extern_name + "=" + eret_raw + ";"
            continue

        # Type alias - skip
        if trimmed.starts_with("type ") and trimmed.contains(" = "):
            continue

        # Docstrings - skip
        if trimmed.starts_with("\"\"\""):
            continue

        # Decorator attributes - skip
        if trimmed.starts_with("#["):
            continue

        # Struct definition
        if trimmed.starts_with("struct ") and trimmed.ends_with(":"):
            val struct_name = trimmed.substring(7, trimmed.len() - 1).trim()
            types = types + "struct:" + struct_name + ";"
            val field_result = parse_struct_fields(lines_arr, line_idx)
            val field_body = field_result[1]
            var sdef = "typedef struct {\n"
            sdef = sdef + field_body + "\n"
            sdef = sdef + "} {struct_name};"
            struct_defs.push(sdef)
            # Track field types
            for fi in range(line_idx + 1, lines_arr.len()):
                val fline = lines_arr[fi]
                val ftrimmed = fline.trim()
                if ftrimmed == "":
                    continue
                val f_indented = fline.starts_with("    ")
                if not f_indented:
                    break
                # Strip inline comments
                var fclean = ftrimmed
                val fhash = ftrimmed.index_of(" #") ?? -1
                if fhash >= 0:
                    fclean = ftrimmed.substring(0, fhash).trim()
                val fcolon = fclean.index_of(":") ?? -1
                if fcolon >= 0:
                    val fname = fclean.substring(0, fcolon).trim()
                    val ftype = fclean.substring(fcolon + 1).trim()
                    if ftype == "text" or ftype == "str":
                        types = types + "field_text:" + struct_name + "." + fname + ";"
                    if ftype == "[text]" or ftype == "[str]":
                        types = types + "field_arr:" + struct_name + "." + fname + ";"
                    if ftype == "[i64]" or ftype == "[int]" or ftype == "[bool]":
                        types = types + "field_int_arr:" + struct_name + "." + fname + ";"
                    # Struct array field: [StructName]
                    if ftype.starts_with("[") and ftype.ends_with("]"):
                        val sf_elem = ftype.substring(1, ftype.len() - 1).trim()
                        if sf_elem.len() > 0:
                            val sf_ef = sf_elem[0]
                            if sf_ef >= "A" and sf_ef <= "Z":
                                types = types + "field_struct_arr:" + struct_name + "." + fname + "=" + sf_elem + ";"
            skip_until_unindent = true
            continue

        # Enum definition - detect data variants vs simple enums
        if trimmed.starts_with("enum ") and trimmed.ends_with(":"):
            val enum_name = trimmed.substring(5, trimmed.len() - 1).trim()
            var variants: [text] = []
            var has_data_variant = false
            var data_variants: [text] = []
            var simple_variants: [text] = []
            for vi in range(line_idx + 1, lines_arr.len()):
                val vline = lines_arr[vi]
                val vtrimmed = vline.trim()
                if vtrimmed == "":
                    continue
                val v_indented = vline.starts_with("    ")
                if not v_indented:
                    break
                # Skip comments and method-like lines inside enum
                if vtrimmed.starts_with("#"):
                    continue
                if vtrimmed.starts_with("fn ") or vtrimmed.starts_with("me ") or vtrimmed.starts_with("static fn "):
                    continue
                # Check if data variant: Name(field: type) or Name(type)
                val vparen = vtrimmed.index_of("(") ?? -1
                if vparen >= 0:
                    has_data_variant = true
                    data_variants.push(vtrimmed)
                else:
                    simple_variants.push(vtrimmed)

            if has_data_variant:
                # Generate tagged union
                var tag_idx = 0
                var union_fields = ""
                var constructors = ""
                var tag_defines = ""
                for dv in data_variants:
                    val dv_paren = dv.index_of("(") ?? -1
                    val dv_name = dv.substring(0, dv_paren).trim()
                    val dv_close = dv.index_of(")") ?? -1
                    var dv_fields_str = ""
                    if dv_close > dv_paren + 1:
                        dv_fields_str = dv.substring(dv_paren + 1, dv_close).trim()
                    tag_defines = tag_defines + "#define {enum_name}_TAG_{dv_name} {tag_idx}\n"
                    types = types + "enum_variant:" + enum_name + "." + dv_name + ";"
                    # Parse fields
                    var struct_fields = ""
                    var ctor_params = ""
                    var ctor_assigns = ""
                    if dv_fields_str.len() > 0:
                        val dv_parts = dv_fields_str.split(",")
                        var fi = 0
                        for dvp in dv_parts:
                            val dvf = dvp.trim()
                            val dvf_colon = dvf.index_of(":") ?? -1
                            if dvf_colon >= 0:
                                val fname = dvf.substring(0, dvf_colon).trim()
                                val ftype = dvf.substring(dvf_colon + 1).trim()
                                val ctype = simple_type_to_c(ftype)
                                struct_fields = struct_fields + "            {ctype} {fname};\n"
                                if fi > 0:
                                    ctor_params = ctor_params + ", "
                                ctor_params = ctor_params + "{ctype} {fname}"
                                ctor_assigns = ctor_assigns + "    r.data.{dv_name}.{fname} = {fname};\n"
                            else:
                                # Positional: _0, _1, etc
                                val ctype = simple_type_to_c(dvf)
                                val pname = "_{fi}"
                                struct_fields = struct_fields + "            {ctype} {pname};\n"
                                if fi > 0:
                                    ctor_params = ctor_params + ", "
                                ctor_params = ctor_params + "{ctype} {pname}"
                                ctor_assigns = ctor_assigns + "    r.data.{dv_name}.{pname} = {pname};\n"
                            fi = fi + 1
                    union_fields = union_fields + "        struct {{\n{struct_fields}        }} {dv_name};\n"
                    constructors = constructors + "static {enum_name} {enum_name}__{dv_name}({ctor_params}) {{\n"
                    constructors = constructors + "    {enum_name} r;\n    r.tag = {enum_name}_TAG_{dv_name};\n"
                    constructors = constructors + ctor_assigns
                    constructors = constructors + "    return r;\n}}\n"
                    tag_idx = tag_idx + 1
                # Also add simple variants as tags
                for sv in simple_variants:
                    tag_defines = tag_defines + "#define {enum_name}_TAG_{sv} {tag_idx}\n"
                    constructors = constructors + "static {enum_name} {enum_name}__{sv}(void) {{\n"
                    constructors = constructors + "    {enum_name} r;\n    r.tag = {enum_name}_TAG_{sv};\n"
                    constructors = constructors + "    return r;\n}}\n"
                    tag_idx = tag_idx + 1
                var edef = tag_defines + "\n"
                edef = edef + "typedef struct {{\n    int tag;\n    union {{\n"
                edef = edef + union_fields
                edef = edef + "    }} data;\n}} {enum_name};\n\n"
                edef = edef + constructors
                enum_defs.push(edef)
                types = types + "struct:" + enum_name + ";"
            else:
                # Simple enum - existing behavior
                var variant_names: [text] = []
                for sv in simple_variants:
                    variant_names.push("{enum_name}_{sv}")
                    types = types + "enum_variant:" + enum_name + "." + sv + ";"
                val variant_list = variant_names.join(", ")
                enum_defs.push("typedef enum {{ {variant_list} }} {enum_name};")
            skip_until_unindent = true
            continue

        # Class definition - treat like struct
        if trimmed.starts_with("class ") and trimmed.ends_with(":"):
            val class_name = trimmed.substring(6, trimmed.len() - 1).trim()
            types = types + "struct:" + class_name + ";"
            val field_result = parse_struct_fields(lines_arr, line_idx)
            val field_body = field_result[1]
            var cdef = "typedef struct {\n"
            cdef = cdef + field_body + "\n"
            cdef = cdef + "} {class_name};"
            struct_defs.push(cdef)
            # Track field types
            for fi in range(line_idx + 1, lines_arr.len()):
                val fline = lines_arr[fi]
                val ftrimmed = fline.trim()
                if ftrimmed == "":
                    continue
                val f_indented = fline.starts_with("    ")
                if not f_indented:
                    break
                # Skip methods
                if ftrimmed.starts_with("fn ") or ftrimmed.starts_with("me ") or ftrimmed.starts_with("static fn "):
                    break
                # Strip inline comments
                var fclean = ftrimmed
                val fhash = ftrimmed.index_of(" #") ?? -1
                if fhash >= 0:
                    fclean = ftrimmed.substring(0, fhash).trim()
                val fcolon = fclean.index_of(":") ?? -1
                if fcolon >= 0:
                    val fname = fclean.substring(0, fcolon).trim()
                    val ftype = fclean.substring(fcolon + 1).trim()
                    if ftype == "text" or ftype == "str":
                        types = types + "field_text:" + class_name + "." + fname + ";"
                    if ftype == "[text]" or ftype == "[str]":
                        types = types + "field_arr:" + class_name + "." + fname + ";"
                    if ftype == "[i64]" or ftype == "[int]" or ftype == "[bool]":
                        types = types + "field_int_arr:" + class_name + "." + fname + ";"
                    # Struct array field: [StructName]
                    if ftype.starts_with("[") and ftype.ends_with("]"):
                        val cf_elem = ftype.substring(1, ftype.len() - 1).trim()
                        if cf_elem.len() > 0:
                            val cf_ef = cf_elem[0]
                            if cf_ef >= "A" and cf_ef <= "Z":
                                types = types + "field_struct_arr:" + class_name + "." + fname + "=" + cf_elem + ";"
            skip_until_unindent = true
            continue

        # Impl block - parse methods
        if trimmed.starts_with("impl ") and trimmed.ends_with(":"):
            current_impl_class = trimmed.substring(5, trimmed.len() - 1).trim()
            in_impl = true
            in_impl_method = false
            continue

        # Function definition
        if trimmed.starts_with("fn ") and trimmed.ends_with(":"):
            if in_func:
                val fn_code = build_function(current_fn_name, current_fn_sig, current_fn_lines)
                func_defs.push(fn_code)
                current_fn_lines = []
                # Restore types to before function (clear local var types)
                types = types_before_fn
            if trimmed == "fn main():" or trimmed.starts_with("fn main()"):
                in_main = true
                in_func = false
                types_before_fn = types
                continue
            val parsed = parse_fn_signature(trimmed)
            current_fn_name = parsed[0]
            current_fn_sig = parsed[1]
            val fwd = parsed[2]
            forward_decls.push(fwd)
            in_func = true
            in_main = false
            # Track function return type (before saving, so it persists across function boundaries)
            val arrow_idx = trimmed.index_of("->") ?? -1
            if arrow_idx >= 0:
                val ret_str = trimmed.substring(arrow_idx + 2)
                val colon_pos = ret_str.index_of(":") ?? -1
                var ret_type = ret_str.trim()
                if colon_pos >= 0:
                    ret_type = ret_str.substring(0, colon_pos).trim()
                val is_text_ret = ret_type == "text" or ret_type == "str"
                if is_text_ret:
                    types = types + "fn_text:" + current_fn_name + ";"
                # Track struct return type (uppercase names)
                if ret_type.len() > 0:
                    val ret_first = ret_type[0]
                    val ret_is_upper = ret_first >= "A" and ret_first <= "Z"
                    if ret_is_upper:
                        types = types + "fn_struct:" + current_fn_name + "=" + ret_type + ";"
                # Track struct array return type: [StructName]
                if ret_type.starts_with("[") and ret_type.ends_with("]"):
                    val ret_sa_elem = ret_type.substring(1, ret_type.len() - 1).trim()
                    if ret_sa_elem.len() > 0:
                        val ret_sa_f = ret_sa_elem[0]
                        if ret_sa_f >= "A" and ret_sa_f <= "Z":
                            types = types + "fn_struct_arr:" + current_fn_name + "=" + ret_sa_elem + ";"
            # Save types AFTER return type tracking so it persists
            types_before_fn = types
            # Track parameter types (text/str params, string array params)
            val fn_paren_idx = trimmed.index_of("(") ?? -1
            val fn_close_idx = trimmed.index_of(")") ?? -1
            if fn_paren_idx >= 0 and fn_close_idx > fn_paren_idx + 1:
                val fn_params_str = trimmed.substring(fn_paren_idx + 1, fn_close_idx)
                val fn_params = fn_params_str.split(",")
                for fn_param in fn_params:
                    val fp = fn_param.trim()
                    val fp_colon = fp.index_of(":") ?? -1
                    if fp_colon >= 0:
                        val fp_name = fp.substring(0, fp_colon).trim()
                        val fp_type = fp.substring(fp_colon + 1).trim()
                        if fp_type == "text" or fp_type == "str":
                            types = types + "text:" + fp_name + ";"
                        if fp_type == "[text]" or fp_type == "[str]":
                            types = types + "arr:" + fp_name + ";"
                        if fp_type == "[i64]" or fp_type == "[int]" or fp_type == "[bool]":
                            types = types + "int_arr:" + fp_name + ";"
                        if fp_type == "[[text]]" or fp_type == "[[str]]":
                            types = types + "str_arr_arr:" + fp_name + ";"
                        if fp_type == "[[i64]]" or fp_type == "[[int]]":
                            types = types + "int_arr_arr:" + fp_name + ";"
                        # Track struct array parameters: [StructName]
                        if fp_type.starts_with("[") and fp_type.ends_with("]"):
                            val fp_elem = fp_type.substring(1, fp_type.len() - 1).trim()
                            if fp_elem.len() > 0:
                                val fp_ef = fp_elem[0]
                                if fp_ef >= "A" and fp_ef <= "Z":
                                    types = types + "struct_arr_var:" + fp_name + "=" + fp_elem + ";"
                        # Track struct-typed parameters (uppercase type name)
                        if fp_type.len() > 0:
                            val fp_first = fp_type[0]
                            val fp_upper = fp_first >= "A" and fp_first <= "Z"
                            if fp_upper:
                                types = types + "struct_var:" + fp_name + "=" + fp_type + ";"
            continue

        # Static fn at top level - skip (only valid inside impl)
        if trimmed.starts_with("static fn ") and trimmed.ends_with(":"):
            skip_until_unindent = true
            continue

        # Mutable method at top level - skip (only valid inside impl)
        if trimmed.starts_with("me ") and trimmed.ends_with(":"):
            skip_until_unindent = true
            continue

        var is_indented = line.starts_with("    ")
        if not is_indented:
            is_indented = line.starts_with("\t")

        if in_main and is_indented:
            val indent = get_indent_level(line)
            val raw_result = translate_statement(trimmed, types)
            val parts = split_result(raw_result)
            var code = parts[0]
            val new_types = parts[1]
            if new_types != "":
                types = types + new_types
            if code != "":
                var padding = ""
                for pi in range(0, indent):
                    padding = padding + "    "
                main_body.push("{padding}{code}")
            continue

        if in_func and is_indented:
            val indent = get_indent_level(line)
            val raw_result = translate_statement(trimmed, types)
            val parts = split_result(raw_result)
            var code = parts[0]
            val new_types = parts[1]
            if new_types != "":
                types = types + new_types
            if code != "":
                var padding = ""
                for pi in range(0, indent):
                    padding = padding + "    "
                current_fn_lines.push("{padding}{code}")
            continue

        if in_main:
            in_main = false
            types = types_before_fn
        if in_func:
            val fn_code = build_function(current_fn_name, current_fn_sig, current_fn_lines)
            func_defs.push(fn_code)
            current_fn_lines = []
            in_func = false
            types = types_before_fn

        # Module-level statement - check if it's a val/var declaration (-> global)
        val is_module_val = trimmed.starts_with("val ")
        val is_module_var = trimmed.starts_with("var ")
        if is_module_val or is_module_var:
            val raw_result = translate_statement(trimmed, types)
            val parts = split_result(raw_result)
            var code = parts[0]
            val new_types = parts[1]
            if new_types != "":
                types = types + new_types
            if code != "":
                # Convert to global: remove const for val (use static), add static for var
                var global_code = code
                if global_code.starts_with("long long "):
                    global_code = "static " + global_code
                elif global_code.starts_with("const char* "):
                    # Check if init uses a function call (can't do at global scope)
                    val str_eq = global_code.index_of(" = ") ?? -1
                    if str_eq >= 0:
                        val str_init = global_code.substring(str_eq + 3).trim()
                        val str_has_call = str_init.contains("(")
                        if str_has_call:
                            val str_decl = global_code.substring(0, str_eq)
                            global_defs.push("static {str_decl} = NULL;")
                            val str_name = str_decl.substring(12).trim()
                            val str_semi = str_init.index_of(";") ?? -1
                            var str_val = str_init
                            if str_semi >= 0:
                                str_val = str_init.substring(0, str_semi).trim()
                            main_body.push("    {str_name} = {str_val};")
                            continue
                    global_code = "static " + global_code
                elif global_code.starts_with("int "):
                    global_code = "static " + global_code
                elif global_code.starts_with("SimpleStringArray "):
                    # Arrays need special init - can't call functions in global init
                    # Extract name and emit as uninitialized, init in main
                    val arr_eq = global_code.index_of(" = ") ?? -1
                    if arr_eq >= 0:
                        val arr_decl = global_code.substring(0, arr_eq)
                        global_defs.push("static {arr_decl};")
                        # Add init to main_body
                        val arr_name = arr_decl.substring(18).trim()
                        val arr_semi = arr_name.index_of(";") ?? -1
                        var clean_name = arr_name
                        if arr_semi >= 0:
                            clean_name = arr_name.substring(0, arr_semi).trim()
                        main_body.push("    {clean_name} = simple_new_string_array();")
                        continue
                    global_code = "static " + global_code
                elif global_code.starts_with("SimpleIntArray "):
                    # Int arrays need deferred init too
                    val arr_eq = global_code.index_of(" = ") ?? -1
                    if arr_eq >= 0:
                        val arr_decl = global_code.substring(0, arr_eq)
                        global_defs.push("static {arr_decl};")
                        val arr_name = arr_decl.substring(15).trim()
                        val arr_semi = arr_name.index_of(";") ?? -1
                        var clean_name = arr_name
                        if arr_semi >= 0:
                            clean_name = arr_name.substring(0, arr_semi).trim()
                        main_body.push("    {clean_name} = simple_new_int_array();")
                        continue
                    global_code = "static " + global_code
                elif global_code.starts_with("SimpleStringArrayArray "):
                    val arr_eq = global_code.index_of(" = ") ?? -1
                    if arr_eq >= 0:
                        val arr_decl = global_code.substring(0, arr_eq)
                        global_defs.push("static {arr_decl};")
                        val arr_name = arr_decl.substring(23).trim()
                        val arr_semi = arr_name.index_of(";") ?? -1
                        var clean_name = arr_name
                        if arr_semi >= 0:
                            clean_name = arr_name.substring(0, arr_semi).trim()
                        main_body.push("    {clean_name} = simple_new_string_array_array();")
                        continue
                    global_code = "static " + global_code
                elif global_code.starts_with("SimpleIntArrayArray "):
                    val arr_eq = global_code.index_of(" = ") ?? -1
                    if arr_eq >= 0:
                        val arr_decl = global_code.substring(0, arr_eq)
                        global_defs.push("static {arr_decl};")
                        val arr_name = arr_decl.substring(20).trim()
                        val arr_semi = arr_name.index_of(";") ?? -1
                        var clean_name = arr_name
                        if arr_semi >= 0:
                            clean_name = arr_name.substring(0, arr_semi).trim()
                        main_body.push("    {clean_name} = simple_new_int_array_array();")
                        continue
                    global_code = "static " + global_code
                elif global_code.starts_with("SimpleStructArray "):
                    # Struct arrays need deferred init
                    val sarr_eq = global_code.index_of(" = ") ?? -1
                    if sarr_eq >= 0:
                        val sarr_decl = global_code.substring(0, sarr_eq)
                        global_defs.push("static {sarr_decl};")
                        val sarr_name = sarr_decl.substring(18).trim()
                        val sarr_semi = sarr_name.index_of(";") ?? -1
                        var clean_sarr = sarr_name
                        if sarr_semi >= 0:
                            clean_sarr = sarr_name.substring(0, sarr_semi).trim()
                        main_body.push("    {clean_sarr} = simple_new_struct_array();")
                        continue
                    global_code = "static " + global_code
                elif global_code.starts_with("SimpleDict* "):
                    val dict_eq = global_code.index_of(" = ") ?? -1
                    if dict_eq >= 0:
                        val dict_decl = global_code.substring(0, dict_eq)
                        global_defs.push("static {dict_decl} = NULL;")
                        val dict_name_start = dict_decl.index_of("* ") ?? -1
                        if dict_name_start >= 0:
                            val dict_name = dict_decl.substring(dict_name_start + 2).trim()
                            main_body.push("    {dict_name} = simple_dict_new();")
                        continue
                    global_code = "static " + global_code
                else:
                    global_code = "static " + global_code
                global_defs.push(global_code)
        else:
            val raw_result = translate_statement(trimmed, types)
            val parts = split_result(raw_result)
            var code = parts[0]
            val new_types = parts[1]
            if new_types != "":
                types = types + new_types
            if code != "":
                val mod_indent = get_indent_level(line)
                var mod_padding = "    "
                for mpi in range(0, mod_indent):
                    mod_padding = mod_padding + "    "
                main_body.push("{mod_padding}{code}")

    # Flush pending impl method
    if in_impl and in_impl_method:
        val method_code = build_function(current_impl_class + "__" + impl_method_name, impl_method_sig, impl_method_lines)
        func_defs.push(method_code)

    if in_func:
        val fn_code = build_function(current_fn_name, current_fn_sig, current_fn_lines)
        func_defs.push(fn_code)

    main_body = close_blocks(main_body)

    # Build final C code
    var c_code = "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n"
    c_code = c_code + "#include <stdint.h>\n"
    c_code = c_code + "#ifdef _MSC_VER\n#define strdup _strdup\n#endif\n"

    # Add C runtime helpers
    c_code = c_code + generate_c_runtime()

    # Add enum definitions first (structs may reference enum types)
    if enum_defs.len() > 0:
        c_code = c_code + "\n// --- Enum Definitions ---\n"
        for edef in enum_defs:
            c_code = c_code + edef + "\n\n"

    # Add struct definitions
    if struct_defs.len() > 0:
        c_code = c_code + "\n// --- Struct Definitions ---\n"
        for sdef in struct_defs:
            c_code = c_code + sdef + "\n\n"

    # Add global variable definitions
    if global_defs.len() > 0:
        c_code = c_code + "\n// --- Global Variables ---\n"
        for gdef in global_defs:
            c_code = c_code + gdef + "\n"
        c_code = c_code + "\n"

    # Add forward declarations
    if forward_decls.len() > 0:
        c_code = c_code + "\n// --- Forward Declarations ---\n"
        for fwd in forward_decls:
            c_code = c_code + fwd + "\n"
        c_code = c_code + "\n"

    # Add function definitions
    for func in func_defs:
        c_code = c_code + func + "\n\n"

    # Add main
    c_code = c_code + "int main(void) {\n"
    for body_line in main_body:
        c_code = c_code + body_line + "\n"
    c_code = c_code + "    return 0;\n}\n"
    c_code

export generate_c_code, close_blocks, translate_statement, translate_print
export translate_interpolated_print, translate_var_decl, translate_array_decl
export translate_for_loop, translate_case, translate_condition, translate_expr
export build_function, parse_fn_signature, translate_params, simple_type_to_c
export get_indent_level, get_c_indent
export generate_c_runtime, translate_method_expr, find_close_paren
export is_string_array_var, is_int_array_var, is_str_arr_arr_var, is_int_arr_arr_var, is_text_var, is_fn_returning_text, is_fn_returning_struct, split_result
export is_struct_type_var, is_known_struct, is_known_method, is_me_method, is_static_fn
export is_dict_var, is_option_var, parse_method_signature, parse_generic_type
