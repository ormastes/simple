# Simple to C Code Generator - Statement Translation
#
# Print, for-loop, case, and statement dispatcher.
# Declaration translation (val/var, arrays) is in c_translate_decl.spl.
#
#   - Print statement translation (with interpolation)
#   - Control flow (for, match/case, while) translation
#   - Statement translation dispatcher

use app.compile.c_helpers.{find_close_paren, is_string_array_var, is_int_array_var, is_str_arr_arr_var, is_int_arr_arr_var, is_text_var, is_fn_returning_text, is_fn_returning_struct, is_struct_field_text, is_struct_field_str_array, is_struct_field_int_array, is_struct_type_var, is_known_struct, is_known_method, is_me_method, is_static_fn, is_dict_var, is_option_var, is_enum_variant, resolve_enum_variant, parse_generic_type, is_struct_array_var, is_struct_field_struct_array, is_fn_returning_struct_arr, is_fn_returning_int_arr, is_fn_returning_str_arr}
use app.compile.c_translate_expr.{translate_expr, translate_condition, is_c_expr_string_result, extract_fn_names, try_translate_compound_assign, gen_array_for_loop}
use app.compile.c_translate_decl.{*}

# Translate interpolated print statement - enhanced with %s for string exprs
fn translate_interpolated_print(inner: text, types: text) -> text:
    var fmt = ""
    var interp_args: [text] = []
    var i = 0
    var inner_len = inner.len()

    for idx in range(0, inner_len):
        val ch = inner[idx]
        if ch == "\{":
            var end_idx = idx + 1
            for j in range(idx + 1, inner_len):
                if inner[j] == "}":
                    end_idx = j
                    break
            val raw_expr = inner.substring(idx + 1, end_idx)
            val c_expr = translate_expr(raw_expr, types)
            # Determine format specifier based on expression type
            val is_text = is_text_var(raw_expr, types)
            val is_dict_keys = c_expr.contains("simple_dict_keys")
            # Check if raw expr is a struct field that returns text
            val raw_dot = raw_expr.index_of(".") ?? -1
            var is_struct_text_field = false
            if raw_dot >= 0:
                val sf_obj = raw_expr.substring(0, raw_dot).trim()
                val sf_field = raw_expr.substring(raw_dot + 1).trim()
                val sf_class = is_struct_type_var(sf_obj, types)
                if sf_class != "":
                    val field_text_marker = ";field_text:" + sf_class + "." + sf_field + ";"
                    is_struct_text_field = types.contains(field_text_marker)
            val any_string = is_c_expr_string_result(c_expr) or is_text or is_struct_text_field
            if any_string:
                fmt = fmt + "%s"
                interp_args.push(c_expr)
            else:
                fmt = fmt + "%lld"
                interp_args.push("(long long)(" + c_expr + ")")
            i = end_idx + 1
        elif idx >= i:
            fmt = fmt + ch

    var args_str = ""
    for current_arg in interp_args:
        args_str = args_str + ", " + current_arg
    "printf(\"{fmt}\\n\"{args_str});"

# Translate print statement
fn translate_print(arg: text, types: text) -> text:
    if arg.len() < 2:
        return "puts(\"\");"
    if arg.starts_with("\"") and arg.ends_with("\""):
        # Check for string concatenation: "str" + expr + "str"
        val has_concat = arg.contains("\" + ") or arg.contains(" + \"")
        if has_concat:
            val c_arg = translate_expr(arg, types)
            return "printf(\"%s\\n\",{c_arg});"
        # Check for interpolation: {expr} inside the string
        if arg.contains("\{"):
            # Extract inner text between quotes for interpolation
            var inner = arg.substring(1, arg.len() - 1)
            if inner.ends_with("\""):
                inner = inner.substring(0, inner.len() - 1)
            return translate_interpolated_print(inner, types)
        # Simple string literal - use arg directly (already has quotes)
        # Emit as puts(arg) with \n via puts
        # Use printf to append newline properly
        return "puts({arg});"
    # Print a variable
    if is_text_var(arg, types):
        return "printf(\"%s\\n\",{arg});"
    # Translate expression and check if it's a string result
    val c_arg = translate_expr(arg, types)
    if is_c_expr_string_result(c_arg):
        return "printf(\"%s\\n\",{c_arg});"
    "printf(\"%lld\\n\",(long long){c_arg});"

# Translate for loop
# Returns "code|||;type_entries;" if loop var is registered as text
fn translate_for_loop(trimmed: text, types: text) -> text:
    val body = trimmed.substring(4, trimmed.len() - 1).trim()
    val in_idx = body.index_of(" in ") ?? -1
    if in_idx < 0:
        return "/* unsupported for: {trimmed} */"
    val loop_var = body.substring(0, in_idx).trim()
    val iterable = body.substring(in_idx + 4).trim()

    # range(start, end)
    if iterable.starts_with("range(") and iterable.ends_with(")"):
        val range_args = iterable.substring(6, iterable.len() - 1).trim()
        val comma_idx = range_args.index_of(",") ?? -1
        if comma_idx >= 0:
            val start_expr = range_args.substring(0, comma_idx).trim()
            val end_expr = range_args.substring(comma_idx + 1).trim()
            return "for (long long {loop_var} = {translate_expr(start_expr, types)}; {loop_var} < {translate_expr(end_expr, types)}; {loop_var}++) " + "\{"
        else:
            return "for (long long {loop_var} = 0; {loop_var} < {translate_expr(range_args, types)}; {loop_var}++) " + "\{"

    # Inline array literal: [1, 2, 3, 4, 5]
    if iterable.starts_with("[") and iterable.ends_with("]"):
        val inner = iterable.substring(1, iterable.len() - 1).trim()
        val elements = inner.split(",")
        var init = "SimpleIntArray _arr_{loop_var} = simple_new_int_array();"
        for elem in elements:
            val e = translate_expr(elem.trim(), types)
            init = init + " simple_int_push(&_arr_{loop_var}, {e});"
        init = init + " for (long long _idx_" + loop_var + " = 0; _idx_" + loop_var + " < _arr_" + loop_var + ".len; _idx_" + loop_var + "++) \{ long long " + loop_var + " = _arr_" + loop_var + ".items[_idx_" + loop_var + "];"
        return init

    # start..end range
    val dotdot_idx = iterable.index_of("..") ?? -1
    if dotdot_idx >= 0:
        val start_expr = iterable.substring(0, dotdot_idx).trim()
        val end_expr = iterable.substring(dotdot_idx + 2).trim()
        return "for (long long {loop_var} = {translate_expr(start_expr, types)}; {loop_var} < {translate_expr(end_expr, types)}; {loop_var}++) " + "\{"

    # Inline array literal: for i in [1, 2, 3]:
    if iterable.starts_with("[") and iterable.ends_with("]"):
        val ia_inner = iterable.substring(1, iterable.len() - 1).trim()
        val ia_elements = ia_inner.split(",")
        var ia_init = "\{ SimpleIntArray _arr_" + loop_var + " = simple_new_int_array();"
        for ia_elem in ia_elements:
            val ia_e = translate_expr(ia_elem.trim(), types)
            ia_init = ia_init + " simple_int_push(&_arr_{loop_var}, {ia_e});"
        ia_init = ia_init + " for (long long _idx_" + loop_var + " = 0; _idx_" + loop_var + " < _arr_" + loop_var + ".len; _idx_" + loop_var + "++) \{ long long " + loop_var + " = _arr_" + loop_var + ".items[_idx_" + loop_var + "];"
        return ia_init

    # for item in string_array or struct.field string array
    if is_string_array_var(iterable, types) or is_struct_field_str_array(iterable, types):
        return gen_array_for_loop(loop_var, iterable, "const char*", true)

    # for item in int_array or struct.field int array
    if is_int_array_var(iterable, types) or is_struct_field_int_array(iterable, types):
        return gen_array_for_loop(loop_var, iterable, "long long", false)

    # for item in struct_array (SimpleStructArray)
    val sa_iter_elem = is_struct_array_var(iterable, types)
    if sa_iter_elem != "":
        return "for (long long _idx_" + loop_var + " = 0; _idx_" + loop_var + " < " + iterable + ".len; _idx_" + loop_var + "++) \{ " + sa_iter_elem + " " + loop_var + " = *(" + sa_iter_elem + "*)" + iterable + ".items[_idx_" + loop_var + "];|||;struct_var:" + loop_var + "=" + sa_iter_elem + ";"

    # for item in struct.field (struct array field)
    val sf_iter_elem = is_struct_field_struct_array(iterable, types)
    if sf_iter_elem != "":
        return "for (long long _idx_" + loop_var + " = 0; _idx_" + loop_var + " < " + iterable + ".len; _idx_" + loop_var + "++) \{ " + sf_iter_elem + " " + loop_var + " = *(" + sf_iter_elem + "*)" + iterable + ".items[_idx_" + loop_var + "];|||;struct_var:" + loop_var + "=" + sf_iter_elem + ";"

    # for item in split result - detect .split( in iterable
    if iterable.contains(".split("):
        val c_split = translate_expr(iterable, types)
        return "\{ SimpleStringArray _split_" + loop_var + " = " + c_split + "; for (long long _idx_" + loop_var + " = 0; _idx_" + loop_var + " < _split_" + loop_var + ".len; _idx_" + loop_var + "++) \{ const char* " + loop_var + " = _split_" + loop_var + ".items[_idx_" + loop_var + "];|||;text:" + loop_var + ";"

    # Default: integer array iteration
    "for (long long _idx_" + loop_var + " = 0; _idx_" + loop_var + " < " + iterable + "_len; _idx_" + loop_var + "++) \{ long long " + loop_var + " = " + iterable + "[_idx_" + loop_var + "];"

# Translate case statement
fn translate_case(trimmed: text, types: text) -> text:
    val case_body = trimmed.substring(5, trimmed.len() - 1).trim()
    if case_body == "_":
        return "/* default: */"
    if case_body == "nil":
        return "if (_match_val == NULL) \{"
    if case_body.starts_with("\""):
        return "if (strcmp(_match_val, {case_body}) == 0) " + "\{"

    # Check for destructuring pattern: Variant(field1, field2)
    val dp_pos = case_body.index_of("(") ?? -1
    if dp_pos >= 0:
        val variant_name = case_body.substring(0, dp_pos).trim()
        val dp_close = case_body.index_of(")") ?? -1
        if dp_close > dp_pos + 1:
            val fields_str = case_body.substring(dp_pos + 1, dp_close).trim()
            val fields = fields_str.split(",")
            # Generate tag check + field extraction
            var result = "if (_match_val.tag == _match_type_TAG_" + variant_name + ") \{"
            var fi = 0
            for field in fields:
                val fname = field.trim()
                # Check if named or positional
                val fc = fname.index_of(":") ?? -1
                if fc >= 0:
                    val fvar = fname.substring(0, fc).trim()
                    result = result + " const char* {fvar} = _match_val.data.{variant_name}.{fvar};"
                else:
                    result = result + " const char* {fname} = _match_val.data.{variant_name}._{fi};"
                fi = fi + 1
            return result
        # No fields - just tag check
        return "if (_match_val.tag == _match_type_TAG_" + variant_name + ") \{"

    # Check for Some(var) pattern
    if case_body.starts_with("Some("):
        val inner = case_body.substring(5, case_body.len() - 1).trim()
        return "if (simple_option_has(_match_val)) \{ const char* " + inner + " = _match_val.str_val;"

    # Check if case_body is an enum variant name
    val resolved = resolve_enum_variant(case_body, types)
    if resolved != "":
        return "if (_match_val == (long long){resolved}) " + "\{"
    "if (_match_val == (long long){case_body}) " + "\{"

# Translate Simple statement to C
# Returns "code|||;type_entries;" if new types are registered
fn translate_statement(trimmed: text, types: text) -> text:
    # Skip module-system directives
    if trimmed.starts_with("use "):
        return "/* {trimmed} */"
    if trimmed.starts_with("import "):
        return "/* {trimmed} */"
    if trimmed.starts_with("export "):
        return "/* {trimmed} */"
    if trimmed.starts_with("extern fn "):
        return "/* {trimmed} */"
    if trimmed.starts_with("from "):
        return "/* {trimmed} */"
    if trimmed.starts_with("pub mod "):
        return "/* {trimmed} */"
    if trimmed.starts_with("common use "):
        return "/* {trimmed} */"
    if trimmed.starts_with("export use "):
        return "/* {trimmed} */"
    if trimmed.starts_with("type ") and trimmed.contains(" = "):
        return "/* {trimmed} */"
    if trimmed == "pass" or trimmed == "()":
        return "/* pass */;"

    # Print
    if trimmed.starts_with("print "):
        val rest = trimmed.substring(6).trim()
        return translate_print(rest, types)
    if trimmed == "print":
        return "puts(\"\");"

    # eprint -> fprintf(stderr, ...)
    if trimmed.starts_with("eprint "):
        val rest = trimmed.substring(7).trim()
        if rest.starts_with("\"") and rest.ends_with("\""):
            val inner = rest.substring(1, rest.len() - 1)
            if inner.contains("\{"):
                # Reuse print interpolation logic but redirect to stderr
                val print_code = translate_interpolated_print(inner, types)
                return print_code.replace("printf(", "fprintf(stderr, ")
            return "fprintf(stderr, \"{inner}\\n\");"
        return "fprintf(stderr, \"%s\\n\",{translate_expr(rest, types)});"

    # Tuple destructuring: val (a, b) = expr
    if trimmed.starts_with("val (") or trimmed.starts_with("var ("):
        val eq_idx = trimmed.index_of(" = ") ?? -1
        if eq_idx >= 0:
            val lhs = trimmed.substring(4, eq_idx).trim()
            val rhs = trimmed.substring(eq_idx + 3).trim()
            if lhs.starts_with("(") and lhs.ends_with(")"):
                val inner = lhs.substring(1, lhs.len() - 1).trim()
                val tparts = inner.split(",")
                val c_rhs = translate_expr(rhs, types)
                if tparts.len() == 2:
                    val v0 = tparts[0].trim()
                    val v1 = tparts[1].trim()
                    return "SimpleTuple2 _tmp_tuple = {c_rhs}; long long {v0} = (long long)_tmp_tuple._0; long long {v1} = (long long)_tmp_tuple._1;"
                if tparts.len() == 3:
                    val v0 = tparts[0].trim()
                    val v1 = tparts[1].trim()
                    val v2 = tparts[2].trim()
                    return "SimpleTuple3 _tmp_tuple = {c_rhs}; long long {v0} = (long long)_tmp_tuple._0; long long {v1} = (long long)_tmp_tuple._1; long long {v2} = (long long)_tmp_tuple._2;"

    # Variable declarations
    if trimmed.starts_with("val ") or trimmed.starts_with("var "):
        return translate_var_decl(trimmed, types)

    # Return
    if trimmed.starts_with("return "):
        val expr = trimmed.substring(7).trim()
        if expr == "()":
            return "return;"
        if expr == "[]":
            return "return simple_new_struct_array();"
        # Use translate_condition for expressions with and/or/comparisons
        val has_and = expr.contains(" and ")
        val has_or = expr.contains(" or ")
        if has_and or has_or:
            return "return {translate_condition(expr, types)};"
        return "return {translate_expr(expr, types)};"
    if trimmed == "return":
        return "return;"
    if trimmed == "return ()":
        return "return;"

    # Control flow
    if trimmed.starts_with("if ") and trimmed.ends_with(":"):
        val cond = trimmed.substring(3, trimmed.len() - 1).trim()
        return "if ({translate_condition(cond, types)}) " + "\{"
    # Inline if: "if cond: statement" (single-line if)
    if trimmed.starts_with("if ") and not trimmed.ends_with(":"):
        val if_colon = trimmed.index_of(":") ?? -1
        if if_colon >= 0:
            val if_cond = trimmed.substring(3, if_colon).trim()
            val if_body = trimmed.substring(if_colon + 1).trim()
            val c_cond = translate_condition(if_cond, types)
            val body_result = translate_statement(if_body, types)
            # Don't include implicit return from body
            var c_body = body_result
            val pipe_pos = c_body.index_of("|||") ?? -1
            if pipe_pos >= 0:
                c_body = c_body.substring(0, pipe_pos)
            return "if (" + c_cond + ") \{ " + c_body + " }"
    if trimmed.starts_with("elif ") and trimmed.ends_with(":"):
        val cond = trimmed.substring(5, trimmed.len() - 1).trim()
        return "} else if ({translate_condition(cond, types)}) " + "\{"
    if trimmed == "else:":
        return "} else \{"

    # Loops
    if trimmed.starts_with("for ") and trimmed.ends_with(":"):
        return translate_for_loop(trimmed, types)

    # Match/case
    if trimmed.starts_with("match ") and trimmed.ends_with(":"):
        val match_expr = trimmed.substring(6, trimmed.len() - 1).trim()
        val c_match_expr = translate_expr(match_expr, types)
        # Detect string vs integer match
        if is_text_var(match_expr, types):
            return "\{ const char* _match_val = " + c_match_expr + ";"
        return "\{ long long _match_val = " + c_match_expr + ";"
    if trimmed.starts_with("case ") and trimmed.ends_with(":"):
        return translate_case(trimmed, types)
    # Inline case: case PATTERN: body_expr
    if trimmed.starts_with("case "):
        val case_colon = trimmed.index_of(":") ?? -1
        if case_colon >= 0:
            val case_pattern = trimmed.substring(5, case_colon).trim()
            val case_inline_body = trimmed.substring(case_colon + 1).trim()
            # Build the if-check for the pattern
            val case_check_trimmed = "case {case_pattern}:"
            val case_check = translate_case(case_check_trimmed, types)
            var case_if = case_check
            if case_if.ends_with("\{"):
                case_if = case_if.substring(0, case_if.len() - 1).trim()
            # Check if body is an assignment (statement) vs expression
            val body_eq_pos = case_inline_body.index_of(" = ") ?? -1
            val body_is_assignment = body_eq_pos >= 0 and not case_inline_body.starts_with("\"")
            if body_is_assignment:
                # Translate as statement (not expression)
                val case_stmt_raw = translate_statement(case_inline_body, types)
                # Extract code part only (strip type annotations after |||)
                val case_sep = case_stmt_raw.index_of("|||") ?? -1
                var case_stmt_code = case_stmt_raw
                if case_sep >= 0:
                    case_stmt_code = case_stmt_raw.substring(0, case_sep)
                return case_if + " \{ " + case_stmt_code + " }"
            # Translate the body expression
            val case_body_c = translate_expr(case_inline_body, types)
            return case_if + " \{ return " + case_body_c + "; }"

    if trimmed == "break":
        return "break;"
    if trimmed == "continue":
        return "continue;"
    if trimmed == "pass" or trimmed == "()":
        return "/* pass */;"

    # Method calls as statements (e.g., arr.push("x"))
    val push_pos = trimmed.index_of(".push(") ?? -1
    if push_pos >= 0:
        val obj = trimmed.substring(0, push_pos).trim()
        val arg_start = push_pos + 6
        val arg_end = find_close_paren(trimmed, arg_start - 1)
        if arg_end >= 0:
            val arg = trimmed.substring(arg_start, arg_end)
            if is_string_array_var(obj, types):
                return "simple_string_push(&{obj}, {translate_expr(arg, types)});"
            if is_int_array_var(obj, types):
                return "simple_int_push(&{obj}, {translate_expr(arg, types)});"
            if is_str_arr_arr_var(obj, types):
                var push_arg = translate_expr(arg, types)
                if arg == "[]":
                    push_arg = "simple_new_string_array()"
                return "simple_string_array_push(&{obj}, {push_arg});"
            if is_int_arr_arr_var(obj, types):
                var push_arg = translate_expr(arg, types)
                if arg == "[]":
                    push_arg = "simple_new_int_array()"
                return "simple_int_array_push(&{obj}, {push_arg});"
            # Check struct array: arr.push(item)
            val sa_push_elem = is_struct_array_var(obj, types)
            if sa_push_elem != "":
                val c_arg = translate_expr(arg, types)
                return "\{ " + sa_push_elem + "* _e = malloc(sizeof(" + sa_push_elem + ")); *_e = " + c_arg + "; simple_struct_push(&" + obj + ", (void*)_e); }"
            # Check struct field arrays: table.names.push(x)
            if is_struct_field_str_array(obj, types):
                return "simple_string_push(&{obj}, {translate_expr(arg, types)});"
            if is_struct_field_int_array(obj, types):
                return "simple_int_push(&{obj}, {translate_expr(arg, types)});"
            return "/* {trimmed} */;"

    # .pop() as statement
    if trimmed.ends_with(".pop()"):
        val obj = trimmed.substring(0, trimmed.len() - 6).trim()
        if is_string_array_var(obj, types):
            return "simple_string_pop(&{obj});"
        if is_int_array_var(obj, types):
            return "simple_int_pop(&{obj});"

    # Compound assignment
    val plus_eq = trimmed.index_of(" += ") ?? -1
    if plus_eq >= 0:
        val lhs = trimmed.substring(0, plus_eq).trim()
        val rhs = trimmed.substring(plus_eq + 4).trim()
        # String concatenation assignment
        if is_text_var(lhs, types):
            return "{lhs} = simple_str_concat({lhs}, {translate_expr(rhs, types)});"
        return "{lhs} += {translate_expr(rhs, types)};"
    val compound_ops: [text] = [" -= ", " *= ", " /= "]
    for cop in compound_ops:
        val cop_result = try_translate_compound_assign(trimmed, cop, types)
        if cop_result != "":
            return cop_result

    # Variable assignment
    val eq_idx = trimmed.index_of(" = ") ?? -1
    if eq_idx >= 0:
        val lhs = trimmed.substring(0, eq_idx).trim()
        val rhs = trimmed.substring(eq_idx + 3).trim()

        # Dict indexing assignment: d[key] = value
        val lhs_bracket = lhs.index_of("[") ?? -1
        if lhs_bracket >= 0:
            val dict_name = lhs.substring(0, lhs_bracket).trim()
            if is_dict_var(dict_name, types):
                val lhs_close = lhs.index_of("]") ?? -1
                if lhs_close > lhs_bracket + 1:
                    val key_expr = lhs.substring(lhs_bracket + 1, lhs_close).trim()
                    val c_rhs = translate_expr(rhs, types)
                    val c_key = translate_expr(key_expr, types)
                    # Detect value type
                    val rhs_is_str = rhs.starts_with("\"")
                    val rhs_text = is_text_var(rhs, types)
                    if rhs_is_str or rhs_text:
                        return "simple_dict_set_str({dict_name}, {c_key}, {c_rhs});"
                    return "simple_dict_set_int({dict_name}, {c_key}, {c_rhs});"

        # Array element assignment: arr[idx] = value -> arr.items[idx] = value
        if lhs_bracket >= 0:
            val arr_name = lhs.substring(0, lhs_bracket).trim()
            val arr_is_int = is_int_array_var(arr_name, types)
            val arr_is_str = is_string_array_var(arr_name, types)
            val arr_is_iaa = is_int_arr_arr_var(arr_name, types)
            val arr_is_saa = is_str_arr_arr_var(arr_name, types)
            val arr_is_any = arr_is_int or arr_is_str or arr_is_iaa or arr_is_saa
            if arr_is_any:
                val lhs_close = lhs.index_of("]") ?? -1
                if lhs_close > lhs_bracket + 1:
                    val idx_expr = lhs.substring(lhs_bracket + 1, lhs_close).trim()
                    val c_idx = translate_expr(idx_expr, types)
                    val c_rhs = translate_expr(rhs, types)
                    return "{arr_name}.items[{c_idx}] = {c_rhs};"

        # Struct field assignment: obj.field = value
        val lhs_dot = lhs.index_of(".") ?? -1
        if lhs_dot >= 0:
            val lhs_obj = lhs.substring(0, lhs_dot).trim()
            val lhs_field = lhs.substring(lhs_dot + 1).trim()
            val lhs_class = is_struct_type_var(lhs_obj, types)
            if lhs_class != "":
                val c_rhs = translate_expr(rhs, types)
                return "{lhs_obj}.{lhs_field} = {c_rhs};"

        val no_space = not lhs.contains(" ")
        val no_paren = not lhs.starts_with("(")
        if no_space and no_paren:
            # Handle array reset: arr = []
            if rhs == "[]":
                if is_str_arr_arr_var(lhs, types):
                    return "{lhs} = simple_new_string_array_array();"
                if is_int_arr_arr_var(lhs, types):
                    return "{lhs} = simple_new_int_array_array();"
                if is_string_array_var(lhs, types):
                    return "{lhs} = simple_new_string_array();"
                if is_int_array_var(lhs, types):
                    return "{lhs} = simple_new_int_array();"
                if is_struct_array_var(lhs, types) != "":
                    return "{lhs} = simple_new_struct_array();"
                return "{lhs} = simple_new_int_array();"
            # Handle array concat: arr = arr + [elem] -> direct push (optimization)
            val rhs_concat_pos = rhs.index_of(" + [") ?? -1
            if rhs_concat_pos >= 0 and rhs.ends_with("]"):
                val arr_part = rhs.substring(0, rhs_concat_pos).trim()
                val concat_elem = rhs.substring(rhs_concat_pos + 4, rhs.len() - 1).trim()
                if arr_part == lhs:
                    val sa_concat_type = is_struct_array_var(lhs, types)
                    if sa_concat_type != "":
                        val c_concat_elem = translate_expr(concat_elem, types)
                        return "\{ " + sa_concat_type + "* _e = malloc(sizeof(" + sa_concat_type + ")); *_e = " + c_concat_elem + "; simple_struct_push(&" + lhs + ", (void*)_e); }"
                    if is_int_array_var(lhs, types):
                        return "simple_int_push(&{lhs}, {translate_expr(concat_elem, types)});"
                    if is_string_array_var(lhs, types):
                        return "simple_string_push(&{lhs}, {translate_expr(concat_elem, types)});"
            val c_rhs = translate_expr(rhs, types)
            # Track if assigning a string to a var (e.g., name = "Alice")
            val rhs_is_str = rhs.starts_with("\"")
            val rhs_is_text = c_rhs.contains("simple_")
            if rhs_is_str or rhs_is_text:
                return "{lhs} = {c_rhs};|||;text:{lhs};"
            return "{lhs} = {c_rhs};"

    # While loop
    if trimmed.starts_with("while ") and trimmed.ends_with(":"):
        val cond = trimmed.substring(6, trimmed.len() - 1).trim()
        return "while ({translate_condition(cond, types)}) " + "\{"

    # Function call as statement - detect BEFORE comparison/logic check
    # to avoid treating comparison operators inside function arguments as bare comparisons
    # e.g., check_eq_bool("5 > 3", 5 > 3, true) should NOT be treated as a comparison
    val paren_pos = trimmed.index_of("(") ?? -1
    if paren_pos >= 0 and trimmed.ends_with(")"):
        val fn_part = trimmed.substring(0, paren_pos).trim()
        # If the part before ( is a simple name (no spaces = no operators), it's a function call
        val fn_has_space = fn_part.contains(" ")
        if not fn_has_space and fn_part.len() > 0:
            return "{translate_expr(trimmed, types)};"

    # Bare expression as implicit return (e.g., last line of function body)
    # Handle comparison/logical expressions: a == b, a and b, a or b, etc.
    val has_cmp = trimmed.contains(" == ") or trimmed.contains(" != ") or trimmed.contains(" < ") or trimmed.contains(" > ") or trimmed.contains(" <= ") or trimmed.contains(" >= ")
    val has_logic = trimmed.contains(" and ") or trimmed.contains(" or ") or trimmed.starts_with("not ")
    if has_cmp or has_logic:
        return "return {translate_condition(trimmed, types)};"

    val c_expr = translate_expr(trimmed, types)
    if c_expr != trimmed:
        # Expression was translated to something different - use as return
        return "return {c_expr};"
    # Simple variable reference or literal - implicit return
    val is_simple_var = not trimmed.contains(" ")
    val is_bracket = trimmed.contains("[")
    val is_dot = trimmed.contains(".")
    if is_simple_var or is_bracket or is_dot:
        return "return {c_expr};"
    # Arithmetic expressions with spaces (e.g., "a + b", "-1")
    val is_arith = trimmed.contains(" + ") or trimmed.contains(" - ") or trimmed.contains(" * ") or trimmed.contains(" / ") or trimmed.starts_with("-")
    if is_arith:
        return "return {c_expr};"
    "/* unsupported: {trimmed} */"

export translate_interpolated_print, translate_print
export translate_array_decl, translate_var_decl
export translate_for_loop, translate_case, translate_statement
