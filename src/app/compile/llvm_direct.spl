# LLVM IR Direct Emitter
#
# Simplified Simple -> LLVM IR translator that bypasses the full MIR pipeline.
# Compiles Simple programs to optimized native binaries via LLVM.
#
# Architecture:
#   Simple source -> C code (via c_codegen.spl) -> LLVM IR (via clang) -> optimized .o (via llc/opt) -> native binary
#   OR: Simple source -> C code -> gcc -> native binary (fallback)
#
# The key insight: reuse the proven C codegen, then use LLVM for optimization.
#
# Usage:
#   bin/bootstrap/simple src/app/compile/llvm_direct.spl <source.spl> <output> [--verbose] [--emit-ir] [-O0|-O2|-O3]

extern fn rt_file_read_text(path: text) -> text
extern fn rt_file_exists(path: text) -> bool
extern fn rt_cli_get_args() -> [str]
extern fn rt_getpid() -> i64

use app.io.file_shell.{shell, shell_output, file_write, file_delete, file_size}
use app.compile.c_codegen.{generate_c_code}

# ============================================================================
# LLVM Compilation Pipeline
# ============================================================================

fn find_mold_for_llvm() -> text:
    val current_dir = shell_output("pwd")
    val local_mold = current_dir + "/bin/mold/mold"
    if rt_file_exists(local_mold):
        return local_mold
    val which_result = shell_output("which mold 2>/dev/null")
    if which_result.len() > 0:
        return which_result
    ""

fn compile_llvm_direct(source_file: text, output_file: text, verbose: bool, emit_ir_only: bool, opt_level: text) -> i64:
    if verbose:
        print "[llvm-direct] Compiling " + source_file + " via LLVM..."

    # Step 1: Read source
    val source_raw = rt_file_read_text(source_file)
    val source = source_raw ?? ""
    if source == "":
        print "Error: Cannot read source file: " + source_file
        return 1

    # Step 2: Generate C code using the proven codegen
    val c_code = generate_c_code(source)
    if verbose:
        print "[llvm-direct] Generated C code (" + str(c_code.len()) + " bytes)"

    val pid = rt_getpid()
    val temp_c = "/tmp/simple_llvm_" + str(pid) + ".c"
    val temp_ll = "/tmp/simple_llvm_" + str(pid) + ".ll"
    val temp_opt_ll = "/tmp/simple_llvm_" + str(pid) + ".opt.ll"
    val temp_o = "/tmp/simple_llvm_" + str(pid) + ".o"

    if not file_write(temp_c, c_code):
        print "Error: Failed to write temp C file"
        return 1

    # Step 3: Generate LLVM IR from C using clang
    val clang_cmd = "clang -S -emit-llvm -o " + temp_ll + " " + temp_c + " 2>&1"
    if verbose:
        print "[llvm-direct] Generating LLVM IR via clang..."
    val (clang_out, clang_err, clang_exit) = shell(clang_cmd)
    file_delete(temp_c)

    if clang_exit != 0:
        # Fallback: try gcc if clang is not available
        if verbose:
            print "[llvm-direct] clang not available, falling back to gcc-only path"
        return compile_gcc_fallback(c_code, output_file, verbose)

    # If only emitting IR, output the IR file
    if emit_ir_only:
        if output_file != "":
            shell("cp " + temp_ll + " " + output_file)
            print "IR written to: " + output_file
        else:
            val (ir_content, _, _) = shell("cat " + temp_ll)
            print ir_content
        file_delete(temp_ll)
        return 0

    # Step 4: Optimize IR with opt (if available and optimization requested)
    var ir_to_compile = temp_ll
    if opt_level != "-O0":
        val opt_cmd = "opt " + opt_level + " -S -o " + temp_opt_ll + " " + temp_ll + " 2>&1"
        val (opt_out, opt_err, opt_exit) = shell(opt_cmd)
        if opt_exit == 0:
            ir_to_compile = temp_opt_ll
            if verbose:
                print "[llvm-direct] Applied LLVM optimization " + opt_level
        else:
            if verbose:
                print "[llvm-direct] opt not available, using unoptimized IR"

    # Step 5: Compile IR to object file via llc
    val llc_cmd = "llc " + opt_level + " --filetype=obj -o " + temp_o + " " + ir_to_compile + " 2>&1"
    if verbose:
        print "[llvm-direct] Compiling with llc..."
    val (llc_out, llc_err, llc_exit) = shell(llc_cmd)
    file_delete(temp_ll)
    file_delete(temp_opt_ll)

    if llc_exit != 0:
        print "Error: llc compilation failed"
        print llc_out
        return 1

    # Step 6: Link with gcc (+ mold if available)
    val mold_path = find_mold_for_llvm()
    var link_cmd = ""
    if mold_path != "":
        var mold_dir = "."
        val last_slash = mold_path.last_index_of("/") ?? -1
        if last_slash >= 0:
            mold_dir = mold_path.substring(0, last_slash)
        link_cmd = "gcc -fuse-ld=mold -B " + mold_dir + "/ -o " + output_file + " " + temp_o
        if verbose:
            print "[llvm-direct] Linking with mold..."
    else:
        link_cmd = "gcc -o " + output_file + " " + temp_o
        if verbose:
            print "[llvm-direct] Linking with system linker..."

    val (link_out, link_err, link_exit) = shell(link_cmd)
    file_delete(temp_o)

    if link_exit != 0:
        print "Error: Linking failed"
        if link_err != "":
            print link_err
        return 1

    val size = file_size(output_file)
    print "Compiled: " + output_file + " (" + str(size) + " bytes) [LLVM " + opt_level + "]"
    0

fn compile_gcc_fallback(c_code: text, output_file: text, verbose: bool) -> i64:
    val pid = rt_getpid()
    val temp_c = "/tmp/simple_llvm_" + str(pid) + ".c"
    if not file_write(temp_c, c_code):
        print "Error: Failed to write temp C file"
        return 1

    val mold_path = find_mold_for_llvm()
    var gcc_cmd = ""
    if mold_path != "":
        var mold_dir = "."
        val last_slash = mold_path.last_index_of("/") ?? -1
        if last_slash >= 0:
            mold_dir = mold_path.substring(0, last_slash)
        gcc_cmd = "gcc -O2 -fuse-ld=mold -B " + mold_dir + "/ -o " + output_file + " " + temp_c
    else:
        gcc_cmd = "gcc -O2 -o " + output_file + " " + temp_c

    val (out, err, code) = shell(gcc_cmd)
    file_delete(temp_c)

    if code != 0:
        print "Error: gcc compilation failed"
        if err != "":
            print err
        return 1

    val size = file_size(output_file)
    print "Compiled: " + output_file + " (" + str(size) + " bytes) [gcc -O2 fallback]"
    0

# ============================================================================
# CLI Entry Point
# ============================================================================

fn main() -> i64:
    val args = rt_cli_get_args()
    if args.len() < 4:
        print "Simple LLVM Direct Compiler"
        print ""
        print "Usage: llvm_direct.spl <source.spl> <output> [options]"
        print ""
        print "Options:"
        print "  --verbose     Verbose output"
        print "  --emit-ir     Output LLVM IR instead of binary"
        print "  -O0           No optimization (default)"
        print "  -O2           Standard optimization"
        print "  -O3           Aggressive optimization"
        print ""
        print "Pipeline: Simple -> C -> clang -> LLVM IR -> opt -> llc -> native"
        print "Fallback: Simple -> C -> gcc (if clang unavailable)"
        return 1

    val source_file = args[2]
    val output_file = args[3]
    var verbose = false
    var emit_ir = false
    var opt_level = "-O2"
    for i in range(4, args.len()):
        if args[i] == "--verbose":
            verbose = true
        if args[i] == "--emit-ir":
            emit_ir = true
        if args[i] == "-O0":
            opt_level = "-O0"
        if args[i] == "-O2":
            opt_level = "-O2"
        if args[i] == "-O3":
            opt_level = "-O3"

    compile_llvm_direct(source_file, output_file, verbose, emit_ir, opt_level)

export compile_llvm_direct, generate_c_code
