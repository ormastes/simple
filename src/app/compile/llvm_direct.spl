# LLVM IR Direct Emitter
#
# Simplified Simple -> LLVM IR translator that bypasses the full MIR pipeline.
# Compiles Simple programs to optimized native binaries via LLVM.
#
# Architecture:
#   Simple source -> C code (via c_codegen.spl) -> clang -O2 -> native binary
#   OR: Simple source -> C code -> gcc -> native binary (fallback)
#
# The key insight: reuse the proven C codegen, then use clang/LLVM for optimization.
#
# Usage:
#   bin/release/simple src/app/compile/llvm_direct.spl <source.spl> <output> [--verbose] [--emit-ir] [-O0|-O2|-O3]

extern fn rt_file_read_text(path: text) -> text
extern fn rt_file_exists(path: text) -> bool
extern fn rt_cli_get_args() -> [str]
extern fn rt_getpid() -> i64

use app.io.file_shell.{shell, shell_output, file_write, file_delete, file_size}
use app.compile.c_codegen.{generate_c_code}

# ============================================================================
# LLVM Compilation Pipeline
# ============================================================================

fn find_mold_linker() -> text:
    val current_dir = shell_output("pwd")
    val local_mold = current_dir + "/bin/mold/mold"
    if rt_file_exists(local_mold):
        return local_mold
    val which_result = shell_output("which mold 2>/dev/null")
    if which_result.len() > 0:
        return which_result
    ""

fn mold_flags() -> text:
    val mold_path = find_mold_linker()
    if mold_path == "":
        return ""
    var mold_dir = "."
    val last_slash = mold_path.last_index_of("/") ?? -1
    if last_slash >= 0:
        mold_dir = mold_path.substring(0, last_slash)
    "-fuse-ld=mold -B " + mold_dir + "/"

fn compile_llvm_direct(source_file: text, output_file: text, verbose: bool, emit_ir_only: bool, opt_level: text) -> i64:
    if verbose:
        print "[llvm-direct] Compiling " + source_file + " via LLVM..."

    # Step 1: Read source
    val source_raw = rt_file_read_text(source_file)
    val source = source_raw ?? ""
    if source == "":
        print "Error: Cannot read source file: " + source_file
        return 1

    # Step 2: Generate C code using the proven codegen
    val c_code = generate_c_code(source)
    if verbose:
        print "[llvm-direct] Generated C code (" + str(c_code.len()) + " bytes)"

    val pid = rt_getpid()
    val temp_c = "/tmp/simple_llvm_" + str(pid) + ".c"
    val temp_ll = "/tmp/simple_llvm_" + str(pid) + ".ll"

    if not file_write(temp_c, c_code):
        print "Error: Failed to write temp C file"
        return 1

    # Handle --emit-ir: generate LLVM IR only
    if emit_ir_only:
        val ir_cmd = "clang -S -emit-llvm -o " + temp_ll + " " + temp_c + " 2>&1"
        if verbose:
            print "[llvm-direct] Generating LLVM IR via clang..."
        val (ir_out, ir_err, ir_exit) = shell(ir_cmd)
        file_delete(temp_c)
        if ir_exit != 0:
            print "Error: clang IR generation failed"
            print ir_out
            return 1
        if output_file != "":
            shell("cp " + temp_ll + " " + output_file)
            print "IR written to: " + output_file
        else:
            val (ir_content, _, _) = shell("cat " + temp_ll)
            print ir_content
        file_delete(temp_ll)
        return 0

    # Primary path: use clang directly for compilation + optimization
    val mold = mold_flags()
    var clang_cmd = "clang " + opt_level + " "
    if mold != "":
        clang_cmd = clang_cmd + mold + " "
        if verbose:
            print "[llvm-direct] Using mold linker..."
    clang_cmd = clang_cmd + "-o " + output_file + " " + temp_c + " 2>&1"
    if verbose:
        print "[llvm-direct] Compiling with clang " + opt_level + "..."
    val (clang_out, clang_err, clang_exit) = shell(clang_cmd)
    file_delete(temp_c)

    if clang_exit != 0:
        # Fallback: try gcc if clang failed
        if verbose:
            print "[llvm-direct] clang failed, falling back to gcc"
        return compile_gcc_fallback(c_code, output_file, verbose)

    val size = file_size(output_file)
    print "Compiled: " + output_file + " (" + str(size) + " bytes) [LLVM " + opt_level + "]"
    0

fn compile_gcc_fallback(c_code: text, output_file: text, verbose: bool) -> i64:
    val pid = rt_getpid()
    val temp_c = "/tmp/simple_llvm_" + str(pid) + ".c"
    if not file_write(temp_c, c_code):
        print "Error: Failed to write temp C file"
        return 1

    val mold = mold_flags()
    var gcc_cmd = "gcc -O2 "
    if mold != "":
        gcc_cmd = gcc_cmd + mold + " "
    gcc_cmd = gcc_cmd + "-o " + output_file + " " + temp_c

    val (out, err, code) = shell(gcc_cmd)
    file_delete(temp_c)

    if code != 0:
        print "Error: gcc compilation failed"
        if err != "":
            print err
        return 1

    val size = file_size(output_file)
    print "Compiled: " + output_file + " (" + str(size) + " bytes) [gcc -O2 fallback]"
    0

# ============================================================================
# CLI Entry Point
# ============================================================================

fn main() -> i64:
    val args = rt_cli_get_args()
    if args.len() < 4:
        print "Simple LLVM Direct Compiler"
        print ""
        print "Usage: llvm_direct.spl <source.spl> <output> [options]"
        print ""
        print "Options:"
        print "  --verbose     Verbose output"
        print "  --emit-ir     Output LLVM IR instead of binary"
        print "  -O0           No optimization (default)"
        print "  -O2           Standard optimization"
        print "  -O3           Aggressive optimization"
        print ""
        print "Pipeline: Simple -> C -> clang -O2 -> native"
        print "Fallback: Simple -> C -> gcc (if clang unavailable)"
        return 1

    val source_file = args[2]
    val output_file = args[3]
    var verbose = false
    var emit_ir = false
    var opt_level = "-O2"
    for i in range(4, args.len()):
        if args[i] == "--verbose":
            verbose = true
        if args[i] == "--emit-ir":
            emit_ir = true
        if args[i] == "-O0":
            opt_level = "-O0"
        if args[i] == "-O2":
            opt_level = "-O2"
        if args[i] == "-O3":
            opt_level = "-O3"

    compile_llvm_direct(source_file, output_file, verbose, emit_ir, opt_level)

export compile_llvm_direct, generate_c_code
