# Simple to C Code Generator - Helper Functions
#
# Shared helper utilities for C code generation:
#   - Indentation tracking
#   - Type conversion (Simple -> C)
#   - Parameter translation
#   - Function signature parsing
#   - Type registry queries

extern fn rt_file_read_text(path: text) -> text
extern fn rt_file_exists(path: text) -> bool

# Get indentation level (counts leading spaces/tabs)
fn get_indent_level(line: text) -> i64:
    var spaces = 0
    for idx in range(0, line.len()):
        val ch = line[idx]
        if ch == " ":
            spaces = spaces + 1
        elif ch == "\t":
            spaces = spaces + 4
        else:
            break
    spaces / 4

# Get C-style indentation (spaces only, no tab expansion)
fn get_c_indent(line: text) -> i64:
    var spaces = 0
    for idx in range(0, line.len()):
        val ch = line[idx]
        if ch == " ":
            spaces = spaces + 1
        else:
            break
    spaces / 4

# Convert Simple type to C type
fn simple_type_to_c(stype: text) -> text:
    if stype == "i64" or stype == "int":
        return "long long"
    if stype == "i32":
        return "int"
    if stype == "f64" or stype == "float":
        return "double"
    if stype == "f32":
        return "float"
    if stype == "bool":
        return "int"
    if stype == "text" or stype == "str":
        return "const char*"
    if stype == "[text]" or stype == "[str]":
        return "SimpleStringArray"
    if stype == "[i64]" or stype == "[int]" or stype == "[bool]":
        return "SimpleIntArray"
    if stype == "[[text]]" or stype == "[[str]]":
        return "SimpleStringArrayArray"
    if stype == "[[i64]]" or stype == "[[int]]":
        return "SimpleIntArrayArray"
    # Struct array: [StructName] -> SimpleStructArray
    if stype.starts_with("[") and stype.ends_with("]"):
        val sa_inner = stype.substring(1, stype.len() - 1).trim()
        if sa_inner.len() > 0:
            val sa_first = sa_inner[0]
            if sa_first >= "A" and sa_first <= "Z":
                return "SimpleStructArray"
    # If the type starts with uppercase, treat it as a struct type name
    if stype.len() > 0:
        val first_char = stype[0]
        val is_upper = first_char >= "A" and first_char <= "Z"
        if is_upper:
            return stype
    "long long"

# Translate Simple parameter list to C
fn translate_params(params_str: text) -> text:
    val params = params_str.split(",")
    var c_parts: [text] = []
    for param in params:
        val p = param.trim()
        val colon_idx = p.index_of(":") ?? -1
        if colon_idx >= 0:
            val pname = p.substring(0, colon_idx).trim()
            val ptype = p.substring(colon_idx + 1).trim()
            val ctype = simple_type_to_c(ptype)
            c_parts.push(ctype + r" " + pname)
        else:
            c_parts.push(r"long long " + p)
    c_parts.join(", ")

# Parse a Simple function signature into [name, c_signature_body, forward_decl]
fn parse_fn_signature(trimmed: text) -> [text]:
    val without_fn = trimmed.substring(3)  # remove "fn "
    val colon_pos = without_fn.len() - 1  # trailing colon
    val sig = without_fn.substring(0, colon_pos).trim()

    # Find function name (up to first paren)
    val paren_idx = sig.index_of("(") ?? -1
    if paren_idx < 0:
        var fallback: [text] = []
        fallback.push(sig)
        fallback.push(r"long long " + sig + r"(void)")
        fallback.push(r"long long " + sig + r"(void);")
        return fallback

    val name = sig.substring(0, paren_idx).trim()

    # Find return type - default to void if no -> annotation
    val arrow_idx = sig.index_of("->") ?? -1
    var ret_type = "void"
    if arrow_idx >= 0:
        val ret_str = sig.substring(arrow_idx + 2).trim()
        ret_type = simple_type_to_c(ret_str)

    # Parse parameters
    val close_paren_idx = sig.index_of(")") ?? -1
    var params_str = ""
    if close_paren_idx > paren_idx + 1:
        params_str = sig.substring(paren_idx + 1, close_paren_idx).trim()

    var c_params = "void"
    if params_str.len() > 0:
        c_params = translate_params(params_str)

    val c_sig = ret_type + r" " + name + r"(" + c_params + r")"
    var result: [text] = []
    result.push(name)
    result.push(c_sig)
    result.push(c_sig + r";")
    result

# Find matching close paren starting from open_pos (exclusive)
fn find_close_paren(expr: text, open_pos: i64) -> i64:
    # Find matching close paren, skipping string literals and escaped quotes
    var depth = 1
    var in_str = false
    var i = open_pos + 1
    val elen = expr.len()
    while i < elen:
        val ch = expr.substring(i, i + 1)
        if in_str:
            if ch == "\\" and i + 1 < elen:
                # Skip escaped character (handles \" inside strings)
                i = i + 2
                continue
            if ch == "\"":
                in_str = false
            i = i + 1
            continue
        if ch == "\"":
            in_str = true
            i = i + 1
            continue
        if ch == "(":
            depth = depth + 1
        elif ch == ")":
            depth = depth - 1
            if depth == 0:
                return i
        i = i + 1
    return -1

# Find top-level " + " operator position, skipping strings and parens
fn find_top_level_plus(expr: text) -> i64:
    var in_str = false
    var depth = 0
    var i = 0
    val elen = expr.len()
    while i < elen:
        val ch = expr.substring(i, i + 1)
        if in_str:
            if ch == "\\" and i + 1 < elen:
                i = i + 2
                continue
            if ch == "\"":
                in_str = false
            i = i + 1
            continue
        if ch == "\"":
            in_str = true
            i = i + 1
            continue
        if ch == "(":
            depth = depth + 1
        elif ch == ")":
            depth = depth - 1
        elif ch == "+" and depth == 0:
            # Check for " + " pattern (space before and after)
            if i >= 1 and i + 1 < elen:
                val before = expr.substring(i - 1, i)
                val after = expr.substring(i + 1, i + 2)
                if before == " " and after == " ":
                    return i - 1
        i = i + 1
    return -1

# Find a keyword/substring only outside of string literals
# Returns position or -1 if not found (or only inside strings)
fn find_outside_strings(expr: text, needle: text) -> i64:
    var in_str = false
    var i = 0
    val elen = expr.len()
    val nlen = needle.len()
    while i < elen:
        val ch = expr.substring(i, i + 1)
        if in_str:
            if ch == "\\" and i + 1 < elen:
                i = i + 2
                continue
            if ch == "\"":
                in_str = false
            i = i + 1
            continue
        if ch == "\"":
            in_str = true
            i = i + 1
            continue
        if i + nlen <= elen:
            val candidate = expr.substring(i, i + nlen)
            if candidate == needle:
                return i
        i = i + 1
    return -1

# --- Type Registry Functions ---
# Registry format: ";text:name;arr:name;fn_text:funcname;struct:Name;struct_var:name=Class;method:Class.method;me_method:Class.method;static_fn:Class.method;dict:name;option:name;"

fn is_string_array_var(name: text, types: text) -> bool:
    val marker = ";arr:" + name + ";"
    types.contains(marker)

fn is_int_array_var(name: text, types: text) -> bool:
    val marker = ";int_arr:" + name + ";"
    types.contains(marker)

fn is_str_arr_arr_var(name: text, types: text) -> bool:
    val marker = ";str_arr_arr:" + name + ";"
    types.contains(marker)

fn is_int_arr_arr_var(name: text, types: text) -> bool:
    val marker = ";int_arr_arr:" + name + ";"
    types.contains(marker)

fn is_text_var(name: text, types: text) -> bool:
    val marker = ";text:" + name + ";"
    types.contains(marker)

fn is_fn_returning_text(name: text, types: text) -> bool:
    val marker = ";fn_text:" + name + ";"
    types.contains(marker)

fn is_fn_returning_i64(name: text, types: text) -> bool:
    val marker = ";fn_i64:" + name + ";"
    types.contains(marker)

# Check if a function returns a struct type, return struct name or ""
fn is_fn_returning_struct(name: text, types: text) -> text:
    val marker = ";fn_struct:" + name + "="
    val pos = types.index_of(marker) ?? -1
    if pos < 0:
        return ""
    val after = types.substring(pos + marker.len())
    val end_pos = after.index_of(";") ?? -1
    if end_pos < 0:
        return ""
    after.substring(0, end_pos)

# Check if a variable is a known struct type, return class name or ""
fn is_struct_type_var(name: text, types: text) -> text:
    val marker = ";struct_var:" + name + "="
    val pos = types.index_of(marker) ?? -1
    if pos < 0:
        return ""
    val after = types.substring(pos + marker.len())
    val end_pos = after.index_of(";") ?? -1
    if end_pos < 0:
        return ""
    after.substring(0, end_pos)

# Check if a struct type is known
fn is_known_struct(name: text, types: text) -> bool:
    val marker = ";struct:" + name + ";"
    types.contains(marker)

# Check if a method exists for a class (fn or me)
fn is_known_method(class_name: text, method_name: text, types: text) -> bool:
    val marker1 = ";method:" + class_name + "." + method_name + ";"
    val marker2 = ";me_method:" + class_name + "." + method_name + ";"
    val found1 = types.contains(marker1)
    val found2 = types.contains(marker2)
    found1 or found2

# Check if a method is a mutable (me) method
fn is_me_method(class_name: text, method_name: text, types: text) -> bool:
    val marker = ";me_method:" + class_name + "." + method_name + ";"
    types.contains(marker)

# Check if a static function exists for a class
fn is_static_fn(class_name: text, method_name: text, types: text) -> bool:
    val marker = ";static_fn:" + class_name + "." + method_name + ";"
    types.contains(marker)

# Check if a dotted name (e.g., "self.source") is a struct field that is text
fn is_struct_field_text(dotted: text, types: text) -> bool:
    val dot_pos = dotted.index_of(".") ?? -1
    if dot_pos < 0:
        return false
    val obj = dotted.substring(0, dot_pos).trim()
    val field = dotted.substring(dot_pos + 1).trim()
    val class_name = is_struct_type_var(obj, types)
    if class_name == "":
        return false
    val marker = ";field_text:" + class_name + "." + field + ";"
    types.contains(marker)

# Check if a dotted name (e.g., "table.names") is a struct field that is a string array
# Returns true if the struct has field_arr: marker for this field
fn is_struct_field_str_array(dotted: text, types: text) -> bool:
    val dot_pos = dotted.index_of(".") ?? -1
    if dot_pos < 0:
        return false
    val obj = dotted.substring(0, dot_pos).trim()
    val field = dotted.substring(dot_pos + 1).trim()
    val class_name = is_struct_type_var(obj, types)
    if class_name == "":
        return false
    val marker = ";field_arr:" + class_name + "." + field + ";"
    types.contains(marker)

# Check if a dotted name is a struct field that is an int array
fn is_struct_field_int_array(dotted: text, types: text) -> bool:
    val dot_pos = dotted.index_of(".") ?? -1
    if dot_pos < 0:
        return false
    val obj = dotted.substring(0, dot_pos).trim()
    val field = dotted.substring(dot_pos + 1).trim()
    val class_name = is_struct_type_var(obj, types)
    if class_name == "":
        return false
    val marker = ";field_int_arr:" + class_name + "." + field + ";"
    types.contains(marker)

# Check if variable is a dict
fn is_dict_var(name: text, types: text) -> bool:
    val marker = ";dict:" + name + ";"
    types.contains(marker)

# Check if variable is an option
fn is_option_var(name: text, types: text) -> bool:
    val marker = ";option:" + name + ";"
    types.contains(marker)

# Check if dotted name is a known enum variant (e.g., "PointcutKind.All")
fn is_enum_variant(dotted: text, types: text) -> bool:
    val marker = ";enum_variant:" + dotted + ";"
    types.contains(marker)

# Find the C name for an enum variant by its short name (e.g., "All" -> "PointcutKind_All")
# Returns "" if not found
fn resolve_enum_variant(short_name: text, types: text) -> text:
    val search = "." + short_name + ";"
    val pos = types.index_of(search) ?? -1
    if pos < 0:
        return ""
    # Walk backwards to find "enum_variant:"
    val before = types.substring(0, pos)
    val marker_pos = before.last_index_of(";enum_variant:") ?? -1
    if marker_pos < 0:
        return ""
    val entry = before.substring(marker_pos + 14)
    # entry is like "PointcutKind"
    entry + "_" + short_name

# Parse a method signature inside an impl block
# Returns [method_name, c_signature, forward_decl]
fn parse_method_signature(trimmed: text, class_name: text, is_me: bool) -> [text]:
    # trimmed is like "fn method_name(params) -> ret:" or "me method_name(params) -> ret:"
    var without_prefix = ""
    if is_me:
        without_prefix = trimmed.substring(3)
    else:
        without_prefix = trimmed.substring(3)
    # Remove trailing colon
    val colon_pos = without_prefix.len() - 1
    val sig = without_prefix.substring(0, colon_pos).trim()

    val paren_idx = sig.index_of("(") ?? -1
    if paren_idx < 0:
        val mangled = class_name + "__" + sig
        var mfallback: [text] = []
        mfallback.push(sig)
        mfallback.push(r"long long " + mangled + r"(void)")
        mfallback.push(r"long long " + mangled + r"(void);")
        return mfallback

    val method_name = sig.substring(0, paren_idx).trim()
    val mangled = class_name + "__" + method_name

    # Return type - default to void if no -> annotation
    val arrow_idx = sig.index_of("->") ?? -1
    var ret_type = "void"
    if arrow_idx >= 0:
        val ret_str = sig.substring(arrow_idx + 2).trim()
        ret_type = simple_type_to_c(ret_str)

    # Parameters
    val close_paren_idx = sig.index_of(")") ?? -1
    var params_str = ""
    if close_paren_idx > paren_idx + 1:
        params_str = sig.substring(paren_idx + 1, close_paren_idx).trim()

    # Build self parameter + user params
    var self_param = r"const " + class_name + r"* self"
    if is_me:
        self_param = class_name + r"* self"

    var c_params = self_param
    if params_str.len() > 0:
        val user_params = translate_params(params_str)
        c_params = self_param + ", " + user_params

    val c_sig = ret_type + r" " + mangled + r"(" + c_params + r")"
    var mresult: [text] = []
    mresult.push(method_name)
    mresult.push(c_sig)
    mresult.push(c_sig + r";")
    mresult

# Parse generic type annotation like Dict<text, i64> -> ["Dict", "text", "i64"]
# or Option<T> -> ["Option", "T"]
# Returns base type name for simple types
fn parse_generic_type(type_str: text) -> [text]:
    val lt_pos = type_str.index_of("<") ?? -1
    if lt_pos < 0:
        var gt_single: [text] = []
        gt_single.push(type_str)
        return gt_single
    val base = type_str.substring(0, lt_pos).trim()
    val gt_pos = type_str.index_of(">") ?? -1
    if gt_pos < 0:
        var gt_base: [text] = []
        gt_base.push(base)
        return gt_base
    val inner = type_str.substring(lt_pos + 1, gt_pos).trim()
    val parts = inner.split(",")
    var result: [text] = []
    result.push(base)
    for part in parts:
        result.push(part.trim())
    result

# Check if a variable is a struct array, return element type or ""
fn is_struct_array_var(name: text, types: text) -> text:
    val marker = ";struct_arr_var:" + name + "="
    val pos = types.index_of(marker) ?? -1
    if pos < 0:
        return ""
    val after = types.substring(pos + marker.len())
    val end_pos = after.index_of(";") ?? -1
    if end_pos < 0:
        return ""
    after.substring(0, end_pos)

# Check if a dotted name is a struct field that is a struct array, return element type or ""
fn is_struct_field_struct_array(dotted: text, types: text) -> text:
    val dot_pos = dotted.index_of(".") ?? -1
    if dot_pos < 0:
        return ""
    val obj = dotted.substring(0, dot_pos).trim()
    val field = dotted.substring(dot_pos + 1).trim()
    val class_name = is_struct_type_var(obj, types)
    if class_name == "":
        return ""
    val marker = ";field_struct_arr:" + class_name + "." + field + "="
    val pos = types.index_of(marker) ?? -1
    if pos < 0:
        return ""
    val after = types.substring(pos + marker.len())
    val end_pos = after.index_of(";") ?? -1
    if end_pos < 0:
        return ""
    after.substring(0, end_pos)

# Check if a function returns a struct array, return element type or ""
fn is_fn_returning_struct_arr(name: text, types: text) -> text:
    val marker = ";fn_struct_arr:" + name + "="
    val pos = types.index_of(marker) ?? -1
    if pos < 0:
        return ""
    val after = types.substring(pos + marker.len())
    val end_pos = after.index_of(";") ?? -1
    if end_pos < 0:
        return ""
    after.substring(0, end_pos)

fn is_fn_returning_int_arr(name: text, types: text) -> bool:
    types.contains(";fn_int_arr:" + name + ";")

fn is_fn_returning_str_arr(name: text, types: text) -> bool:
    types.contains(";fn_str_arr:" + name + ";")


export get_indent_level, get_c_indent, simple_type_to_c, translate_params
export parse_fn_signature, find_close_paren, find_top_level_plus, find_outside_strings
export is_string_array_var, is_int_array_var, is_str_arr_arr_var, is_int_arr_arr_var, is_text_var, is_fn_returning_text, is_fn_returning_i64, is_fn_returning_struct, is_struct_field_text, is_struct_field_str_array, is_struct_field_int_array
export is_struct_type_var, is_known_struct, is_known_method, is_me_method, is_static_fn
export is_dict_var, is_option_var, is_enum_variant, resolve_enum_variant
export parse_method_signature, parse_generic_type
export is_struct_array_var, is_struct_field_struct_array, is_fn_returning_struct_arr
export is_fn_returning_int_arr, is_fn_returning_str_arr
