# Simple to C Code Generator - Declaration Translation
#
# Extracted from c_translate_stmt.spl. Contains:
# - translate_array_decl: Array declaration translation
# - translate_var_decl: Variable declaration translation (val/var)

use app.compile.c_helpers.{find_close_paren, is_string_array_var, is_int_array_var, is_str_arr_arr_var, is_int_arr_arr_var, is_text_var, is_fn_returning_text, is_fn_returning_struct, is_struct_field_text, is_struct_field_str_array, is_struct_field_int_array, is_struct_type_var, is_known_struct, is_known_method, is_me_method, is_static_fn, is_dict_var, is_option_var, is_enum_variant, resolve_enum_variant, parse_generic_type, is_struct_array_var, is_struct_field_struct_array, is_fn_returning_struct_arr, is_fn_returning_int_arr, is_fn_returning_str_arr}
use app.compile.c_translate_expr.{translate_expr, translate_condition, is_c_expr_string_result, extract_fn_names, try_translate_compound_assign, gen_array_for_loop}

# Translate array declaration
# Returns "code|||;arr:name;" if a string array is declared
fn translate_array_decl(name: text, rhs: text, type_hint: text, types: text) -> text:
    # Check for nested array types first
    if type_hint == "[[text]]" or type_hint == "[[str]]":
        if rhs == "[]":
            return "SimpleStringArrayArray {name} = simple_new_string_array_array();|||;str_arr_arr:{name};"
        return "SimpleStringArrayArray {name} = simple_new_string_array_array();|||;str_arr_arr:{name};"
    if type_hint == "[[i64]]" or type_hint == "[[int]]":
        if rhs == "[]":
            return "SimpleIntArrayArray {name} = simple_new_int_array_array();|||;int_arr_arr:{name};"
        return "SimpleIntArrayArray {name} = simple_new_int_array_array();|||;int_arr_arr:{name};"
    # Check for string array type
    if type_hint == "[text]" or type_hint == "[str]":
        if rhs == "[]":
            return "SimpleStringArray {name} = simple_new_string_array();|||;arr:{name};"
        # Non-empty string array init: ["a", "b", "c"]
        val inner = rhs.substring(1, rhs.len() - 1).trim()
        val elements = inner.split(",")
        var init_code = "SimpleStringArray {name} = simple_new_string_array();"
        for elem in elements:
            val trimmed_elem = elem.trim()
            init_code = init_code + " simple_string_push(&{name}, {trimmed_elem});"
        return init_code + "|||;arr:{name};"

    # Check for integer array type
    if type_hint == "[i64]" or type_hint == "[int]" or type_hint == "[bool]":
        if rhs == "[]":
            return "SimpleIntArray {name} = simple_new_int_array();|||;int_arr:{name};"

    # Check for struct array type hint: [StructName]
    if type_hint.starts_with("[") and type_hint.ends_with("]"):
        val sa_elem = type_hint.substring(1, type_hint.len() - 1).trim()
        if sa_elem.len() > 0:
            val sa_fc = sa_elem[0]
            if sa_fc >= "A" and sa_fc <= "Z":
                if rhs == "[]":
                    return "SimpleStructArray {name} = simple_new_struct_array();|||;struct_arr_var:{name}={sa_elem};"
                # Non-empty struct array: [StructExpr, ...]
                val sa_inner = rhs.substring(1, rhs.len() - 1).trim()
                val sa_elements = sa_inner.split(",")
                var sa_init = "SimpleStructArray {name} = simple_new_struct_array();"
                for sa_e in sa_elements:
                    val sa_te = translate_expr(sa_e.trim(), types)
                    sa_init = sa_init + " \{ " + sa_elem + "* _e = malloc(sizeof(" + sa_elem + ")); *_e = " + sa_te + "; simple_struct_push(&" + name + ", (void*)_e); }"
                return sa_init + "|||;struct_arr_var:{name}={sa_elem};"

    # Default: infer array type from first element
    val inner = rhs.substring(1, rhs.len() - 1).trim()
    if inner == "":
        return "SimpleIntArray {name} = simple_new_int_array();|||;int_arr:{name};"
    val elements = inner.split(",")
    # Check first element to infer type
    val first_elem = elements[0].trim()
    val is_string_elem = first_elem.starts_with("\"")
    if is_string_elem:
        # String array
        var str_init = "SimpleStringArray {name} = simple_new_string_array();"
        for str_e in elements:
            val trimmed_str = str_e.trim()
            str_init = str_init + " simple_string_push(&{name}, {trimmed_str});"
        return str_init + "|||;arr:{name};"
    # Integer array (default)
    var init_code = "SimpleIntArray {name} = simple_new_int_array();"
    for elem in elements:
        val trimmed_elem = elem.trim()
        init_code = init_code + " simple_int_push(&{name}, {translate_expr(trimmed_elem, types)});"
    init_code + "|||;int_arr:{name};"

# Translate variable declaration
# Returns "code|||;type_entries;" if new types are registered
fn translate_var_decl(stmt: text, types: text) -> text:
    val is_val = stmt.starts_with("val ")
    val eq_idx = stmt.index_of("=") ?? -1
    if eq_idx < 0:
        return "/* unsupported decl: {stmt} */"
    val lhs = stmt.substring(4, eq_idx).trim()
    val rhs = stmt.substring(eq_idx + 1).trim()
    var name = lhs
    var type_hint = ""
    val colon_idx = lhs.index_of(":") ?? -1
    if colon_idx >= 0:
        name = lhs.substring(0, colon_idx).trim()
        type_hint = lhs.substring(colon_idx + 1).trim()

    # Handle nil
    if rhs == "nil":
        return "const char* {name} = NULL;|||;text:{name};"

    # Handle complete string literal (not concat like "foo" + bar)
    if rhs.starts_with("\"") and rhs.ends_with("\""):
        val has_str_concat = rhs.contains("\" + ") or rhs.contains(" + \"")
        if not has_str_concat:
            return "const char* {name} = {rhs};|||;text:{name};"

    # Handle string concat starting with literal: "prefix" + expr
    if rhs.starts_with("\""):
        val c_rhs = translate_expr(rhs, types)
        return "const char* {name} = {c_rhs};|||;text:{name};"

    # Handle boolean
    if rhs == "true" or rhs == "false":
        var c_bval = "0"
        if rhs == "true":
            c_bval = "1"
        return "int {name} = {c_bval};"

    # Handle boolean/logical expressions: val x = a or b, val x = a and b
    val rhs_has_logic = rhs.contains(" and ") or rhs.contains(" or ") or rhs.starts_with("not ")
    if rhs_has_logic:
        val c_logic = translate_condition(rhs, types)
        return "int {name} = {c_logic};"

    # Handle array literal
    if rhs.starts_with("[") and rhs.ends_with("]"):
        return translate_array_decl(name, rhs, type_hint, types)

    # Handle empty array with type hint
    if rhs == "[]":
        if type_hint == "[[text]]" or type_hint == "[[str]]":
            return "SimpleStringArrayArray {name} = simple_new_string_array_array();|||;str_arr_arr:{name};"
        if type_hint == "[[i64]]" or type_hint == "[[int]]":
            return "SimpleIntArrayArray {name} = simple_new_int_array_array();|||;int_arr_arr:{name};"
        if type_hint == "[text]" or type_hint == "[str]":
            return "SimpleStringArray {name} = simple_new_string_array();|||;arr:{name};"
        if type_hint == "[i64]" or type_hint == "[int]" or type_hint == "[bool]":
            return "SimpleIntArray {name} = simple_new_int_array();|||;int_arr:{name};"
        # Struct array type hint: [StructName]
        if type_hint.starts_with("[") and type_hint.ends_with("]"):
            val sa_elem_type = type_hint.substring(1, type_hint.len() - 1).trim()
            if sa_elem_type.len() > 0:
                val sa_f = sa_elem_type[0]
                if sa_f >= "A" and sa_f <= "Z":
                    return "SimpleStructArray {name} = simple_new_struct_array();|||;struct_arr_var:{name}={sa_elem_type};"
        return "SimpleIntArray {name} = simple_new_int_array();|||;int_arr:{name};"

    # Handle nested array indexing: val x = nested_arr[idx] -> inner array type
    val rhs_bracket = rhs.index_of("[") ?? -1
    if rhs_bracket >= 0:
        val rhs_base = rhs.substring(0, rhs_bracket).trim()
        if is_int_arr_arr_var(rhs_base, types):
            val c_rhs_idx = translate_expr(rhs, types)
            return "SimpleIntArray {name} = {c_rhs_idx};|||;int_arr:{name};"
        if is_str_arr_arr_var(rhs_base, types):
            val c_rhs_idx = translate_expr(rhs, types)
            return "SimpleStringArray {name} = {c_rhs_idx};|||;arr:{name};"
        # Handle simple string array indexing: val x = str_arr[i] -> const char*
        if is_string_array_var(rhs_base, types):
            val c_rhs_idx = translate_expr(rhs, types)
            return "const char* {name} = {c_rhs_idx};|||;text:{name};"
        # Handle simple int array indexing: val x = int_arr[i] -> long long
        if is_int_array_var(rhs_base, types):
            val c_rhs_idx = translate_expr(rhs, types)
            return "long long {name} = {c_rhs_idx};"

    # Handle Some/None -> SimpleOption
    if rhs.starts_with("Some(") or rhs == "None" or rhs == "nil":
        val c_rhs_opt = translate_expr(rhs, types)
        if c_rhs_opt.contains("simple_some") or c_rhs_opt.contains("simple_none"):
            return "SimpleOption {name} = {c_rhs_opt};|||;option:{name};"

    # Handle empty dict literal
    if rhs == "{}":
        return "SimpleDict* {name} = simple_dict_new();|||;dict:{name};"

    # Handle method call results
    val c_rhs = translate_expr(rhs, types)
    val rhs_is_split = c_rhs.contains("simple_split")
    if is_c_expr_string_result(c_rhs):
        return "const char* {name} = {c_rhs};|||;text:{name};"

    if rhs_is_split:
        return "SimpleStringArray {name} = {c_rhs};|||;arr:{name};"

    # Handle text type hint
    if type_hint == "text" or type_hint == "str":
        return "const char* {name} = {c_rhs};|||;text:{name};"

    # Check function return types using both raw and mangled names
    val fn_names = extract_fn_names(rhs, c_rhs)
    for fn_n in fn_names:
        if is_fn_returning_text(fn_n, types):
            return "const char* {name} = {c_rhs};|||;text:{name};"
    for fn_n in fn_names:
        val struct_ret = is_fn_returning_struct(fn_n, types)
        if struct_ret != "":
            return "{struct_ret} {name} = {c_rhs};|||;struct_var:{name}={struct_ret};"
    for fn_n in fn_names:
        val sa_ret_elem = is_fn_returning_struct_arr(fn_n, types)
        if sa_ret_elem != "":
            return "SimpleStructArray {name} = {c_rhs};|||;struct_arr_var:{name}={sa_ret_elem};"
    for fn_n in fn_names:
        if is_fn_returning_int_arr(fn_n, types):
            return "SimpleIntArray {name} = {c_rhs};|||;int_arr:{name};"
    for fn_n in fn_names:
        if is_fn_returning_str_arr(fn_n, types):
            return "SimpleStringArray {name} = {c_rhs};|||;arr:{name};"

    # Handle Dict type hint
    val gen_parts = parse_generic_type(type_hint)
    if gen_parts.len() > 0:
        val gen_base = gen_parts[0]
        if gen_base == "Dict":
            if rhs == "{}":
                return "SimpleDict* {name} = simple_dict_new();|||;dict:{name};"
            return "SimpleDict* {name} = {c_rhs};|||;dict:{name};"
        if gen_base == "Option":
            return "SimpleOption {name} = {c_rhs};|||;option:{name};"

    # Handle struct type hint - known struct
    if is_known_struct(type_hint, types):
        return "{type_hint} {name} = {c_rhs};|||;struct_var:{name}={type_hint};"

    # Handle struct construction on RHS: ClassName(field: val)
    val rhs_paren = rhs.index_of("(") ?? -1
    if rhs_paren >= 0:
        val rhs_ctor = rhs.substring(0, rhs_paren).trim()
        if is_known_struct(rhs_ctor, types):
            return "{rhs_ctor} {name} = {c_rhs};|||;struct_var:{name}={rhs_ctor};"
        # Check for enum variant construction: ClassName.Variant(args)
        # Only if it's NOT a known static fn (static fns return specific types, not the class itself)
        val cdot = rhs_ctor.index_of(".") ?? -1
        if cdot >= 0:
            val enum_name = rhs_ctor.substring(0, cdot).trim()
            val variant_part = rhs_ctor.substring(cdot + 1).trim()
            if is_known_struct(enum_name, types):
                val is_static = is_static_fn(enum_name, variant_part, types)
                if not is_static:
                    return "{enum_name} {name} = {c_rhs};|||;struct_var:{name}={enum_name};"

    # Handle Option<T> nullable pattern (check for ? in type)
    if type_hint.ends_with("?"):
        return "SimpleOption {name} = {c_rhs};|||;option:{name};"

    # Detect ternary expressions that return strings: (cond ? "str" : "str")
    val c_has_ternary_str = c_rhs.contains("? \"")
    if c_has_ternary_str:
        return "const char* {name} = {c_rhs};|||;text:{name};"

    # Detect inline if expression returning string
    if rhs.starts_with("if ") and rhs.contains(" else: "):
        val ternary_check = rhs.contains("\"")
        if ternary_check:
            return "const char* {name} = {c_rhs};|||;text:{name};"

    # Check if RHS is a known text variable
    if is_text_var(rhs, types):
        return "const char* {name} = {c_rhs};|||;text:{name};"
    # Check if RHS is a struct field that is text
    if is_struct_field_text(rhs, types):
        return "const char* {name} = {c_rhs};|||;text:{name};"
    # Check if RHS is a known struct variable (propagate struct type)
    val rhs_struct_type = is_struct_type_var(rhs, types)
    if rhs_struct_type != "":
        return "{rhs_struct_type} {name} = {c_rhs};|||;struct_var:{name}={rhs_struct_type};"
    # Check if RHS is a known string array (propagate array type)
    if is_string_array_var(rhs, types):
        return "SimpleStringArray {name} = {c_rhs};|||;arr:{name};"
    if is_int_array_var(rhs, types):
        return "SimpleIntArray {name} = {c_rhs};|||;int_arr:{name};"
    val rhs_sa_type = is_struct_array_var(rhs, types)
    if rhs_sa_type != "":
        return "SimpleStructArray {name} = {c_rhs};|||;struct_arr_var:{name}={rhs_sa_type};"
    # Check if RHS is a struct field that is a struct array
    val rhs_sf_sa = is_struct_field_struct_array(rhs, types)
    if rhs_sf_sa != "":
        return "SimpleStructArray {name} = {c_rhs};|||;struct_arr_var:{name}={rhs_sf_sa};"
    # Check if RHS is a struct field that is a string array
    if is_struct_field_str_array(rhs, types):
        return "SimpleStringArray {name} = {c_rhs};|||;arr:{name};"
    # Check if RHS is a struct field that is an int array
    if is_struct_field_int_array(rhs, types):
        return "SimpleIntArray {name} = {c_rhs};|||;int_arr:{name};"

    # Default: long long
    "long long {name} = {c_rhs};"

export translate_array_decl, translate_var_decl
