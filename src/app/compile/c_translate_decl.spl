# Simple to C Code Generator - Declaration Translation
#
# Extracted from c_translate_stmt.spl. Contains:
# - translate_array_decl: Array declaration translation
# - translate_var_decl: Variable declaration translation (val/var)

use app.compile.c_helpers.{find_close_paren, is_string_array_var, is_int_array_var, is_str_arr_arr_var, is_int_arr_arr_var, is_text_var, is_fn_returning_text, is_fn_returning_struct, is_struct_field_text, is_struct_field_str_array, is_struct_field_int_array, is_struct_type_var, is_known_struct, is_known_method, is_me_method, is_static_fn, is_dict_var, is_option_var, is_enum_variant, resolve_enum_variant, parse_generic_type, is_struct_array_var, is_struct_field_struct_array, is_fn_returning_struct_arr, is_fn_returning_int_arr, is_fn_returning_str_arr}
use app.compile.c_translate_expr.{translate_expr, translate_condition, is_c_expr_string_result, extract_fn_names, try_translate_compound_assign, gen_array_for_loop}

# Translate array declaration
# Returns "code<|TYPE|>;arr:name;" if a string array is declared
fn translate_array_decl(name: text, rhs: text, type_hint: text, types: text) -> text:
    # Check for nested array types first
    if type_hint == "[[text]]" or type_hint == "[[str]]":
        if rhs == "[]":
            return r"SimpleStringArrayArray " + name + r" = simple_new_string_array_array();<|TYPE|>;str_arr_arr:" + name + r";"
        return r"SimpleStringArrayArray " + name + r" = simple_new_string_array_array();<|TYPE|>;str_arr_arr:" + name + r";"
    if type_hint == "[[i64]]" or type_hint == "[[int]]":
        if rhs == "[]":
            return r"SimpleIntArrayArray " + name + r" = simple_new_int_array_array();<|TYPE|>;int_arr_arr:" + name + r";"
        return r"SimpleIntArrayArray " + name + r" = simple_new_int_array_array();<|TYPE|>;int_arr_arr:" + name + r";"
    # Check for string array type
    if type_hint == "[text]" or type_hint == "[str]":
        if rhs == "[]":
            return r"SimpleStringArray " + name + r" = simple_new_string_array();<|TYPE|>;arr:" + name + r";"
        # Non-empty string array init: ["a", "b", "c"]
        val inner = rhs.substring(1, rhs.len() - 1).trim()
        val elements = inner.split(",")
        var init_code = r"SimpleStringArray " + name + r" = simple_new_string_array();"
        for elem in elements:
            val trimmed_elem = elem.trim()
            init_code = init_code + r" simple_string_push(&" + name + r", " + trimmed_elem + r");"
        return init_code + r"<|TYPE|>;arr:" + name + r";"

    # Check for integer array type
    if type_hint == "[i64]" or type_hint == "[int]" or type_hint == "[bool]":
        if rhs == "[]":
            return r"SimpleIntArray " + name + r" = simple_new_int_array();<|TYPE|>;int_arr:" + name + r";"

    # Check for struct array type hint: [StructName]
    if type_hint.starts_with("[") and type_hint.ends_with("]"):
        val sa_elem = type_hint.substring(1, type_hint.len() - 1).trim()
        if sa_elem.len() > 0:
            val sa_fc = sa_elem[0]
            if sa_fc >= "A" and sa_fc <= "Z":
                if rhs == "[]":
                    return r"SimpleStructArray " + name + r" = simple_new_struct_array();<|TYPE|>;struct_arr_var:" + name + r"=" + sa_elem + r";"
                # Non-empty struct array: [StructExpr, ...]
                val sa_inner = rhs.substring(1, rhs.len() - 1).trim()
                val sa_elements = sa_inner.split(",")
                var sa_init = r"SimpleStructArray " + name + r" = simple_new_struct_array();"
                for sa_e in sa_elements:
                    val sa_te = translate_expr(sa_e.trim(), types)
                    sa_init = sa_init + " { " + sa_elem + "* _e = malloc(sizeof(" + sa_elem + ")); *_e = " + sa_te + "; simple_struct_push(&" + name + ", (void*)_e); }"
                return sa_init + r"<|TYPE|>;struct_arr_var:" + name + r"=" + sa_elem + r";"

    # Default: infer array type from first element
    val inner = rhs.substring(1, rhs.len() - 1).trim()
    if inner == "":
        return r"SimpleIntArray " + name + r" = simple_new_int_array();<|TYPE|>;int_arr:" + name + r";"
    val elements = inner.split(",")
    # Check first element to infer type
    val first_elem = elements[0].trim()
    val is_string_elem = first_elem.starts_with("\"")
    if is_string_elem:
        # String array
        var str_init = r"SimpleStringArray " + name + r" = simple_new_string_array();"
        for str_e in elements:
            val trimmed_str = str_e.trim()
            str_init = str_init + r" simple_string_push(&" + name + r", " + trimmed_str + r");"
        return str_init + r"<|TYPE|>;arr:" + name + r";"
    # Integer array (default)
    var init_code = r"SimpleIntArray " + name + r" = simple_new_int_array();"
    for elem in elements:
        val trimmed_elem = elem.trim()
        init_code = init_code + r" simple_int_push(&" + name + r", " + translate_expr(trimmed_elem, types) + r");"
    init_code + r"<|TYPE|>;int_arr:" + name + r";"

# Translate variable declaration
# Returns "code<|TYPE|>;type_entries;" if new types are registered
fn translate_var_decl(stmt: text, types: text) -> text:
    val is_val = stmt.starts_with("val ")
    val eq_idx = stmt.index_of("=") ?? -1
    if eq_idx < 0:
        return r"/* unsupported decl: " + stmt + r" */"
    val lhs = stmt.substring(4, eq_idx).trim()
    val rhs = stmt.substring(eq_idx + 1).trim()
    var name = lhs
    var type_hint = ""
    val colon_idx = lhs.index_of(":") ?? -1
    if colon_idx >= 0:
        name = lhs.substring(0, colon_idx).trim()
        type_hint = lhs.substring(colon_idx + 1).trim()

    # Handle nil
    if rhs == "nil":
        return r"const char* " + name + r" = NULL;<|TYPE|>;text:" + name + r";"

    # Handle complete string literal (not concat like "foo" + bar)
    if rhs.starts_with("\"") and rhs.ends_with("\""):
        val has_str_concat = rhs.contains("\" + ") or rhs.contains(" + \"")
        if not has_str_concat:
            return r"const char* " + name + r" = " + rhs + r";<|TYPE|>;text:" + name + r";"

    # Handle string concat starting with literal: "prefix" + expr
    if rhs.starts_with("\""):
        val c_rhs = translate_expr(rhs, types)
        return r"const char* " + name + r" = " + c_rhs + r";<|TYPE|>;text:" + name + r";"

    # Handle boolean
    if rhs == "true" or rhs == "false":
        var c_bval = "0"
        if rhs == "true":
            c_bval = "1"
        return r"int " + name + r" = " + c_bval + r";"

    # Handle boolean/logical expressions: val x = a or b, val x = a and b
    val rhs_has_logic = rhs.contains(" and ") or rhs.contains(" or ") or rhs.starts_with("not ")
    if rhs_has_logic:
        val c_logic = translate_condition(rhs, types)
        return r"int " + name + r" = " + c_logic + r";"

    # Handle array literal
    if rhs.starts_with("[") and rhs.ends_with("]"):
        return translate_array_decl(name, rhs, type_hint, types)

    # Handle empty array with type hint
    if rhs == "[]":
        if type_hint == "[[text]]" or type_hint == "[[str]]":
            return r"SimpleStringArrayArray " + name + r" = simple_new_string_array_array();<|TYPE|>;str_arr_arr:" + name + r";"
        if type_hint == "[[i64]]" or type_hint == "[[int]]":
            return r"SimpleIntArrayArray " + name + r" = simple_new_int_array_array();<|TYPE|>;int_arr_arr:" + name + r";"
        if type_hint == "[text]" or type_hint == "[str]":
            return r"SimpleStringArray " + name + r" = simple_new_string_array();<|TYPE|>;arr:" + name + r";"
        if type_hint == "[i64]" or type_hint == "[int]" or type_hint == "[bool]":
            return r"SimpleIntArray " + name + r" = simple_new_int_array();<|TYPE|>;int_arr:" + name + r";"
        # Struct array type hint: [StructName]
        if type_hint.starts_with("[") and type_hint.ends_with("]"):
            val sa_elem_type = type_hint.substring(1, type_hint.len() - 1).trim()
            if sa_elem_type.len() > 0:
                val sa_f = sa_elem_type[0]
                if sa_f >= "A" and sa_f <= "Z":
                    return r"SimpleStructArray " + name + r" = simple_new_struct_array();<|TYPE|>;struct_arr_var:" + name + r"=" + sa_elem_type + r";"
        return r"SimpleIntArray " + name + r" = simple_new_int_array();<|TYPE|>;int_arr:" + name + r";"

    # Handle nested array indexing: val x = nested_arr[idx] -> inner array type
    val rhs_bracket = rhs.index_of("[") ?? -1
    if rhs_bracket >= 0:
        val rhs_base = rhs.substring(0, rhs_bracket).trim()
        if is_int_arr_arr_var(rhs_base, types):
            val c_rhs_idx = translate_expr(rhs, types)
            return r"SimpleIntArray " + name + r" = " + c_rhs_idx + r";<|TYPE|>;int_arr:" + name + r";"
        if is_str_arr_arr_var(rhs_base, types):
            val c_rhs_idx = translate_expr(rhs, types)
            return r"SimpleStringArray " + name + r" = " + c_rhs_idx + r";<|TYPE|>;arr:" + name + r";"
        # Handle simple string array indexing: val x = str_arr[i] -> const char*
        if is_string_array_var(rhs_base, types):
            val c_rhs_idx = translate_expr(rhs, types)
            return r"const char* " + name + r" = " + c_rhs_idx + r";<|TYPE|>;text:" + name + r";"
        # Handle simple int array indexing: val x = int_arr[i] -> long long
        if is_int_array_var(rhs_base, types):
            val c_rhs_idx = translate_expr(rhs, types)
            return r"long long " + name + r" = " + c_rhs_idx + r";"

    # Handle Some/None -> SimpleOption
    if rhs.starts_with("Some(") or rhs == "None" or rhs == "nil":
        val c_rhs_opt = translate_expr(rhs, types)
        if c_rhs_opt.contains("simple_some") or c_rhs_opt.contains("simple_none"):
            return r"SimpleOption " + name + r" = " + c_rhs_opt + r";<|TYPE|>;option:" + name + r";"

    # Handle empty dict literal
    if rhs == "{}":
        return r"SimpleDict* " + name + r" = simple_dict_new();<|TYPE|>;dict:" + name + r";"

    # Handle method call results
    val c_rhs = translate_expr(rhs, types)
    val rhs_is_split = c_rhs.starts_with("simple_split(")
    if is_c_expr_string_result(c_rhs):
        return r"const char* " + name + r" = " + c_rhs + r";<|TYPE|>;text:" + name + r";"

    if rhs_is_split:
        return r"SimpleStringArray " + name + r" = " + c_rhs + r";<|TYPE|>;arr:" + name + r";"

    # Handle text type hint
    if type_hint == "text" or type_hint == "str":
        return r"const char* " + name + r" = " + c_rhs + r";<|TYPE|>;text:" + name + r";"

    # Check function return types using both raw and mangled names
    val fn_names = extract_fn_names(rhs, c_rhs)
    for fn_n in fn_names:
        if is_fn_returning_text(fn_n, types):
            return r"const char* " + name + r" = " + c_rhs + r";<|TYPE|>;text:" + name + r";"
    for fn_n in fn_names:
        val struct_ret = is_fn_returning_struct(fn_n, types)
        if struct_ret != "":
            return struct_ret + r" " + name + r" = " + c_rhs + r";<|TYPE|>;struct_var:" + name + r"=" + struct_ret + r";"
    for fn_n in fn_names:
        val sa_ret_elem = is_fn_returning_struct_arr(fn_n, types)
        if sa_ret_elem != "":
            return r"SimpleStructArray " + name + r" = " + c_rhs + r";<|TYPE|>;struct_arr_var:" + name + r"=" + sa_ret_elem + r";"
    for fn_n in fn_names:
        if is_fn_returning_int_arr(fn_n, types):
            return r"SimpleIntArray " + name + r" = " + c_rhs + r";<|TYPE|>;int_arr:" + name + r";"
    for fn_n in fn_names:
        if is_fn_returning_str_arr(fn_n, types):
            return r"SimpleStringArray " + name + r" = " + c_rhs + r";<|TYPE|>;arr:" + name + r";"

    # Handle Dict type hint
    val gen_parts = parse_generic_type(type_hint)
    if gen_parts.len() > 0:
        val gen_base = gen_parts[0]
        if gen_base == "Dict":
            if rhs == "{}":
                return r"SimpleDict* " + name + r" = simple_dict_new();<|TYPE|>;dict:" + name + r";"
            return r"SimpleDict* " + name + r" = " + c_rhs + r";<|TYPE|>;dict:" + name + r";"
        if gen_base == "Option":
            return r"SimpleOption " + name + r" = " + c_rhs + r";<|TYPE|>;option:" + name + r";"

    # Handle struct type hint - known struct
    if is_known_struct(type_hint, types):
        return type_hint + r" " + name + r" = " + c_rhs + r";<|TYPE|>;struct_var:" + name + r"=" + type_hint + r";"

    # Handle struct construction on RHS: ClassName(field: val)
    val rhs_paren = rhs.index_of("(") ?? -1
    if rhs_paren >= 0:
        val rhs_ctor = rhs.substring(0, rhs_paren).trim()
        if is_known_struct(rhs_ctor, types):
            return rhs_ctor + r" " + name + r" = " + c_rhs + r";<|TYPE|>;struct_var:" + name + r"=" + rhs_ctor + r";"
        # Check for enum variant construction: ClassName.Variant(args)
        # Only if it's NOT a known static fn (static fns return specific types, not the class itself)
        val cdot = rhs_ctor.index_of(".") ?? -1
        if cdot >= 0:
            val enum_name = rhs_ctor.substring(0, cdot).trim()
            val variant_part = rhs_ctor.substring(cdot + 1).trim()
            if is_known_struct(enum_name, types):
                val is_static = is_static_fn(enum_name, variant_part, types)
                if not is_static:
                    return enum_name + r" " + name + r" = " + c_rhs + r";<|TYPE|>;struct_var:" + name + r"=" + enum_name + r";"

    # Handle Option<T> nullable pattern (check for ? in type)
    if type_hint.ends_with("?"):
        return r"SimpleOption " + name + r" = " + c_rhs + r";<|TYPE|>;option:" + name + r";"

    # Detect ternary expressions that return strings: (cond ? "str" : "str")
    val c_has_ternary_str = c_rhs.contains("? \"")
    if c_has_ternary_str:
        return r"const char* " + name + r" = " + c_rhs + r";<|TYPE|>;text:" + name + r";"

    # Detect inline if expression returning string
    if rhs.starts_with("if ") and rhs.contains(" else: "):
        val ternary_check = rhs.contains("\"")
        if ternary_check:
            return r"const char* " + name + r" = " + c_rhs + r";<|TYPE|>;text:" + name + r";"

    # Check if RHS is a known text variable
    if is_text_var(rhs, types):
        return r"const char* " + name + r" = " + c_rhs + r";<|TYPE|>;text:" + name + r";"
    # Check if RHS is a struct field that is text
    if is_struct_field_text(rhs, types):
        return r"const char* " + name + r" = " + c_rhs + r";<|TYPE|>;text:" + name + r";"
    # Check if RHS is a known struct variable (propagate struct type)
    val rhs_struct_type = is_struct_type_var(rhs, types)
    if rhs_struct_type != "":
        return rhs_struct_type + r" " + name + r" = " + c_rhs + r";<|TYPE|>;struct_var:" + name + r"=" + rhs_struct_type + r";"
    # Check if RHS is a known string array (propagate array type)
    if is_string_array_var(rhs, types):
        return r"SimpleStringArray " + name + r" = " + c_rhs + r";<|TYPE|>;arr:" + name + r";"
    if is_int_array_var(rhs, types):
        return r"SimpleIntArray " + name + r" = " + c_rhs + r";<|TYPE|>;int_arr:" + name + r";"
    val rhs_sa_type = is_struct_array_var(rhs, types)
    if rhs_sa_type != "":
        return r"SimpleStructArray " + name + r" = " + c_rhs + r";<|TYPE|>;struct_arr_var:" + name + r"=" + rhs_sa_type + r";"
    # Check if RHS is a struct field that is a struct array
    val rhs_sf_sa = is_struct_field_struct_array(rhs, types)
    if rhs_sf_sa != "":
        return r"SimpleStructArray " + name + r" = " + c_rhs + r";<|TYPE|>;struct_arr_var:" + name + r"=" + rhs_sf_sa + r";"
    # Check if RHS is a struct field that is a string array
    if is_struct_field_str_array(rhs, types):
        return r"SimpleStringArray " + name + r" = " + c_rhs + r";<|TYPE|>;arr:" + name + r";"
    # Check if RHS is a struct field that is an int array
    if is_struct_field_int_array(rhs, types):
        return r"SimpleIntArray " + name + r" = " + c_rhs + r";<|TYPE|>;int_arr:" + name + r";"

    # Default: long long
    r"long long " + name + r" = " + c_rhs + r";"

export translate_array_decl, translate_var_decl
