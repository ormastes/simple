# Simple to C Code Generator - Translation Functions
#
# Core translation logic for converting Simple statements and expressions to C.
# Split into three modules:
#   - c_translate_expr.spl: Helpers, condition, method call, expression translation
#   - c_translate_stmt.spl: Print, declaration, for-loop, case, statement dispatcher
#   - c_translate.spl (this file): Block closing and function building

use app.compile.c_helpers.{get_c_indent}
use app.compile.c_translate_expr.{translate_condition, translate_method_expr, translate_expr}
use app.compile.c_translate_stmt.{translate_interpolated_print, translate_print, translate_array_decl, translate_var_decl, translate_for_loop, translate_case, translate_statement}

# Close unclosed braces by tracking indentation levels
fn close_blocks(body_lines: [text]) -> [text]:
    var result: [text] = []
    var brace_indents: [i64] = []

    for idx in range(0, body_lines.len()):
        val line = body_lines[idx]
        val trimmed = line.trim()
        val current_indent = get_c_indent(line)

        # Don't let comments trigger block closing
        if trimmed.starts_with("//") or trimmed.starts_with("/*"):
            result.push(line)
            continue

        if trimmed.starts_with("} else"):
            # Close any nested blocks at higher indent before the else
            var else_close = 0
            for ebi in range(0, brace_indents.len()):
                val esi = brace_indents.len() - 1 - ebi
                if esi < 0:
                    break
                if brace_indents[esi] > current_indent:
                    else_close = else_close + 1
                else:
                    break
            for eci in range(0, else_close):
                val epi = brace_indents.len() - 1
                val eclose_indent = brace_indents[epi]
                brace_indents.pop()
                var epad = ""
                for epi2 in range(0, eclose_indent):
                    epad = epad + "    "
                result.push(epad + "}")
            result.push(line)
            continue

        var close_count = 0
        for bi in range(0, brace_indents.len()):
            val stack_idx = brace_indents.len() - 1 - bi
            if stack_idx < 0:
                break
            if current_indent <= brace_indents[stack_idx]:
                close_count = close_count + 1
            else:
                break

        for ci in range(0, close_count):
            val pop_idx = brace_indents.len() - 1
            val close_indent = brace_indents[pop_idx]
            brace_indents.pop()
            var close_padding = ""
            for pi in range(0, close_indent):
                close_padding = close_padding + "    "
            result.push(close_padding + "}")

        result.push(line)

        if trimmed.ends_with("\{"):
            brace_indents.push(current_indent)
        elif trimmed.contains(") \{") and not trimmed.ends_with("}"):
            # Inline opening brace (e.g., for-loop with inline body start)
            brace_indents.push(current_indent)
        elif trimmed.starts_with("\{") and not trimmed.ends_with("}"):
            # Match block opening: { long long _match_val = ...;
            brace_indents.push(current_indent)

    for ci in range(0, brace_indents.len()):
        val pop_idx = brace_indents.len() - 1 - ci
        val close_indent = brace_indents[pop_idx]
        var close_padding = ""
        for pi in range(0, close_indent):
            close_padding = close_padding + "    "
        result.push(close_padding + "}")

    result

# Build a C function definition
fn build_function(name: text, sig: text, body_lines: [text]) -> text:
    val closed_lines = close_blocks(body_lines)
    # Check if the function has a non-void return type
    val is_void_fn = sig.starts_with("void ")
    # Find the last meaningful statement line (not a closing brace)
    var last_stmt_idx = -1
    if not is_void_fn:
        for li in range(0, closed_lines.len()):
            val check_idx = closed_lines.len() - 1 - li
            if check_idx < 0:
                break
            val check_line = closed_lines[check_idx].trim()
            if check_line == "}":
                continue
            if check_line == "":
                continue
            if check_line.starts_with("//"):
                continue
            if check_line.starts_with("/*"):
                continue
            last_stmt_idx = check_idx
            break

    # Deduplicate variable declarations: if a name is declared multiple times
    # (e.g., in different branches), convert subsequent declarations to assignments
    # Scope-aware: track indent level of each declaration so that variables in
    # sibling scopes (e.g., two if-blocks at the same indent) are not deduped
    var declared_vars: [text] = []
    var declared_indents: [i64] = []
    var deduped_lines: [text] = []
    val c_types_arr: [text] = ["const char* ", "long long ", "int ", "double ", "SimpleStringArray ", "SimpleIntArray ", "SimpleStringArrayArray ", "SimpleIntArrayArray ", "SimpleStructArray ", "SimpleDict* ", "SimpleOption "]
    for dl_idx in range(0, closed_lines.len()):
        val dl = closed_lines[dl_idx]
        val dl_trim = dl.trim()
        val dl_c_indent = get_c_indent(dl)
        # Scope cleanup: remove vars declared at indent > current indent
        # (they went out of scope when their block's } was processed)
        var scope_new_vars: [text] = []
        var scope_new_indents: [i64] = []
        for scope_vi in range(0, declared_vars.len()):
            if declared_indents[scope_vi] <= dl_c_indent:
                scope_new_vars.push(declared_vars[scope_vi])
                scope_new_indents.push(declared_indents[scope_vi])
        declared_vars = scope_new_vars
        declared_indents = scope_new_indents
        # Check if this line is a C variable declaration
        var found_type = ""
        var found_name = ""
        for ct in c_types_arr:
            if dl_trim.starts_with(ct) and dl_trim.contains(" = "):
                val after_type = dl_trim.substring(ct.len())
                val eq_pos = after_type.index_of(" = ") ?? -1
                if eq_pos >= 0:
                    found_type = ct
                    found_name = after_type.substring(0, eq_pos).trim()
                    break
        # Also check struct declarations: StructName varname = ...
        if found_type == "" and dl_trim.contains(" = ") and not dl_trim.starts_with("if ") and not dl_trim.starts_with("for ") and not dl_trim.starts_with("return ") and not dl_trim.starts_with("//") and not dl_trim.starts_with("/*"):
            val space_pos = dl_trim.index_of(" ") ?? -1
            if space_pos >= 0:
                val first_word = dl_trim.substring(0, space_pos)
                val fw_first = first_word[0]
                val fw_upper = fw_first >= "A" and fw_first <= "Z"
                if fw_upper and not first_word.starts_with("Simple"):
                    val after_struct = dl_trim.substring(space_pos + 1)
                    val eq_pos = after_struct.index_of(" = ") ?? -1
                    if eq_pos >= 0:
                        found_type = first_word + " "
                        found_name = after_struct.substring(0, eq_pos).trim()
        if found_name != "":
            # Check if already declared (only vars still in scope)
            var already = false
            for dv in declared_vars:
                if dv == found_name:
                    already = true
                    break
            if already:
                # Replace declaration with assignment: strip the type prefix
                val dl_indent = dl.substring(0, dl.len() - dl_trim.len())
                val assignment = dl_trim.substring(found_type.len())
                deduped_lines.push("{dl_indent}{assignment}")
            else:
                declared_vars.push(found_name)
                declared_indents.push(dl_c_indent)
                deduped_lines.push(dl)
        else:
            deduped_lines.push(dl)

    var result = "{sig} " + "\{" + "\n"
    for line_idx in range(0, deduped_lines.len()):
        val body_line = deduped_lines[line_idx]
        if line_idx == last_stmt_idx:
            val bl_trimmed = body_line.trim()
            # Add return if the last statement doesn't have one
            val has_ret = bl_trimmed.starts_with("return ")
            val is_control = bl_trimmed.starts_with("if ") or bl_trimmed.starts_with("} else") or bl_trimmed.starts_with("for ") or bl_trimmed.starts_with("while ")
            val is_comment = bl_trimmed.starts_with("//") or bl_trimmed.starts_with("/*")
            if not has_ret and not is_control and not is_comment:
                # Remove the trailing semicolon, wrap with return
                var stmt = bl_trimmed
                if stmt.ends_with(";"):
                    stmt = stmt.substring(0, stmt.len() - 1)
                val indent = body_line.substring(0, body_line.len() - bl_trimmed.len())
                result = result + "{indent}return {stmt};\n"
                continue
        result = result + body_line + "\n"
    result = result + "}"
    result

# Re-export all public functions for backward compatibility
export translate_condition, translate_method_expr, translate_expr
export translate_interpolated_print, translate_print
export translate_array_decl, translate_var_decl
export translate_for_loop, translate_case, translate_statement
export close_blocks, build_function
