# Simple to C Code Generator - Translation Functions
#
# Core translation logic for converting Simple statements and expressions to C:
#   - Condition, expression, and method call translation
#   - Print statement translation (with interpolation)
#   - Variable declaration and array declaration translation
#   - Control flow (for, match/case, while) translation
#   - Statement translation dispatcher
#   - Block closing and function building

use app.compile.c_helpers.{find_close_paren, is_string_array_var, is_text_var, is_fn_returning_text, simple_type_to_c, translate_params, get_c_indent, get_indent_level}

# --- Translation Functions ---
# Functions that only READ types receive `types: text` parameter.
# Functions that ADD type entries return "code|||;entry1;entry2;" with ||| separator.

# Translate a Simple condition to C
fn translate_condition(cond: text, types: text) -> text:
    var result = cond
    # Handle "not" prefix
    if result.starts_with("not "):
        result = "!(" + translate_condition(result.substring(4), types) + ")"
        return result
    # Handle "and" / "or"
    if result.contains(" and "):
        result = result.replace(" and ", " && ")
    if result.contains(" or "):
        result = result.replace(" or ", " || ")
    # Handle "!= nil" and "== nil"
    if result.contains(" != nil"):
        result = result.replace(" != nil", " != NULL")
    if result.contains(" == nil"):
        result = result.replace(" == nil", " == NULL")
    # Translate method calls in conditions
    result = translate_expr(result, types)
    result

# Translate a method call expression to C
# Returns the original expression if no method call is detected
fn translate_method_expr(expr: text, types: text) -> text:
    # .contains(
    val contains_pos = expr.index_of(".contains(") ?? -1
    if contains_pos >= 0:
        val obj = expr.substring(0, contains_pos)
        val arg_start = contains_pos + 10
        val arg_end = find_close_paren(expr, arg_start - 1)
        if arg_end >= 0:
            val arg = expr.substring(arg_start, arg_end)
            return "simple_contains({obj}, {arg})"

    # .starts_with(
    val sw_pos = expr.index_of(".starts_with(") ?? -1
    if sw_pos >= 0:
        val obj = expr.substring(0, sw_pos)
        val arg_start = sw_pos + 13
        val arg_end = find_close_paren(expr, arg_start - 1)
        if arg_end >= 0:
            val arg = expr.substring(arg_start, arg_end)
            return "simple_starts_with({obj}, {arg})"

    # .ends_with(
    val ew_pos = expr.index_of(".ends_with(") ?? -1
    if ew_pos >= 0:
        val obj = expr.substring(0, ew_pos)
        val arg_start = ew_pos + 11
        val arg_end = find_close_paren(expr, arg_start - 1)
        if arg_end >= 0:
            val arg = expr.substring(arg_start, arg_end)
            return "simple_ends_with({obj}, {arg})"

    # .substring(
    val sub_pos = expr.index_of(".substring(") ?? -1
    if sub_pos >= 0:
        val obj = expr.substring(0, sub_pos)
        val arg_start = sub_pos + 11
        val arg_end = find_close_paren(expr, arg_start - 1)
        if arg_end >= 0:
            val args = expr.substring(arg_start, arg_end)
            return "simple_substring({obj}, {args})"

    # .trim()
    val trim_pos = expr.index_of(".trim()") ?? -1
    if trim_pos >= 0:
        val obj = expr.substring(0, trim_pos)
        return "simple_trim({obj})"

    # .split(
    val split_pos = expr.index_of(".split(") ?? -1
    if split_pos >= 0:
        val obj = expr.substring(0, split_pos)
        val arg_start = split_pos + 7
        val arg_end = find_close_paren(expr, arg_start - 1)
        if arg_end >= 0:
            val arg = expr.substring(arg_start, arg_end)
            return "simple_split({obj}, {arg})"

    # .replace(
    val repl_pos = expr.index_of(".replace(") ?? -1
    if repl_pos >= 0:
        val obj = expr.substring(0, repl_pos)
        val arg_start = repl_pos + 9
        val arg_end = find_close_paren(expr, arg_start - 1)
        if arg_end >= 0:
            val args = expr.substring(arg_start, arg_end)
            return "simple_replace({obj}, {args})"

    # .index_of(
    val iof_pos = expr.index_of(".index_of(") ?? -1
    if iof_pos >= 0:
        val obj = expr.substring(0, iof_pos)
        val arg_start = iof_pos + 10
        val arg_end = find_close_paren(expr, arg_start - 1)
        if arg_end >= 0:
            val arg = expr.substring(arg_start, arg_end)
            return "simple_index_of({obj}, {arg})"

    # .join(
    val join_pos = expr.index_of(".join(") ?? -1
    if join_pos >= 0:
        val obj = expr.substring(0, join_pos)
        val arg_start = join_pos + 6
        val arg_end = find_close_paren(expr, arg_start - 1)
        if arg_end >= 0:
            val arg = expr.substring(arg_start, arg_end)
            return "simple_string_join(&{obj}, {arg})"

    # .len() - context-dependent
    if expr.ends_with(".len()"):
        val base = expr.substring(0, expr.len() - 6)
        if is_string_array_var(base, types):
            return "{base}.len"
        val base_is_text = is_text_var(base, types)
        val base_is_literal = base.starts_with("\"")
        if base_is_text or base_is_literal:
            return "simple_strlen({base})"
        return "{base}_len"

    # .pop()
    if expr.ends_with(".pop()"):
        val base = expr.substring(0, expr.len() - 6)
        return "simple_string_pop(&{base})"

    # No method call detected
    expr

# Translate a Simple expression to C
fn translate_expr(expr: text, types: text) -> text:
    # Handle nil
    if expr == "nil":
        return "NULL"
    if expr == "true":
        return "1"
    if expr == "false":
        return "0"
    if expr == "()":
        return "/* unit */"

    # Handle ?? (null coalescing)
    val nq_pos = expr.index_of(" ?? ") ?? -1
    if nq_pos >= 0:
        val left = expr.substring(0, nq_pos).trim()
        val right = expr.substring(nq_pos + 4).trim()
        val c_left = translate_expr(left, types)
        val c_right = translate_expr(right, types)
        # For index_of ?? -1, index_of already returns -1 on not found
        if c_right == "-1":
            val has_iof = c_left.contains("simple_index_of")
            if has_iof:
                return c_left
        # General integer coalescing
        return "({c_left} >= 0 ? {c_left} : {c_right})"

    # Handle complete string literals (starts and ends with quote)
    if expr.starts_with("\"") and expr.ends_with("\""):
        return expr

    # Handle string concatenation with +
    val plus_pos = expr.index_of(" + ") ?? -1
    if plus_pos >= 0:
        val left = expr.substring(0, plus_pos).trim()
        val right = expr.substring(plus_pos + 3).trim()
        # Check if either side is a string
        val left_is_str = left.starts_with("\"")
        val right_is_str = right.starts_with("\"")
        val left_is_text = is_text_var(left, types)
        val right_is_text = is_text_var(right, types)
        val left_is_method = left.contains("simple_")
        val right_is_method = right.contains("simple_")
        val either_str = left_is_str or right_is_str
        val either_text = left_is_text or right_is_text
        val either_method = left_is_method or right_is_method
        val is_string_concat = either_str or either_text or either_method
        if is_string_concat:
            return "simple_str_concat({translate_expr(left, types)}, {translate_expr(right, types)})"

    # Handle method calls
    val method_result = translate_method_expr(expr, types)
    if method_result != expr:
        return method_result

    # Handle string indexing: s[idx]
    val bracket_pos = expr.index_of("[") ?? -1
    if bracket_pos >= 0:
        val base = expr.substring(0, bracket_pos)
        if is_text_var(base, types):
            val idx_end = expr.index_of("]") ?? -1
            if idx_end >= 0:
                val idx_expr = expr.substring(bracket_pos + 1, idx_end)
                return "simple_char_at({base}, {translate_expr(idx_expr, types)})"

    expr

# Translate interpolated print statement - enhanced with %s for string exprs
fn translate_interpolated_print(inner: text, types: text) -> text:
    var fmt = ""
    var interp_args: [text] = []
    var i = 0
    var inner_len = inner.len()

    for idx in range(0, inner_len):
        val ch = inner[idx]
        if ch == "{":
            var end_idx = idx + 1
            for j in range(idx + 1, inner_len):
                if inner[j] == "}":
                    end_idx = j
                    break
            val raw_expr = inner.substring(idx + 1, end_idx)
            val c_expr = translate_expr(raw_expr, types)
            # Determine format specifier based on expression type
            val is_str_expr = c_expr.contains("simple_substring")
            val is_trim_expr = c_expr.contains("simple_trim")
            val is_replace_expr = c_expr.contains("simple_replace")
            val is_join_expr = c_expr.contains("simple_string_join")
            val is_concat_expr = c_expr.contains("simple_str_concat")
            val is_char_expr = c_expr.contains("simple_char_at")
            val is_file_expr = c_expr.contains("simple_file_read")
            val is_text = is_text_var(raw_expr, types)
            val is_string1 = is_str_expr or is_trim_expr or is_replace_expr
            val is_string2 = is_join_expr or is_concat_expr or is_char_expr
            val is_string3 = is_file_expr or is_text
            val is_string4 = c_expr.starts_with("\"")
            val any_string = is_string1 or is_string2 or is_string3 or is_string4
            if any_string:
                fmt = fmt + "%s"
                interp_args.push(c_expr)
            else:
                fmt = fmt + "%lld"
                interp_args.push("(long long)(" + c_expr + ")")
            i = end_idx + 1
        elif idx >= i:
            fmt = fmt + ch

    var args_str = ""
    for current_arg in interp_args:
        args_str = args_str + ", " + current_arg
    "printf(\"{fmt}\\n\"{args_str});"

# Translate print statement
fn translate_print(arg: text, types: text) -> text:
    if arg.len() < 2:
        return "puts(\"\");"
    if arg.starts_with("\"") and arg.ends_with("\""):
        val inner = arg.substring(1, arg.len() - 1)
        if inner.contains("{"):
            return translate_interpolated_print(inner, types)
        return "puts(\"{inner}\");"
    # Print a variable
    if is_text_var(arg, types):
        return "printf(\"%s\\n\", {arg});"
    # Translate expression and check if it's a string result
    val c_arg = translate_expr(arg, types)
    val c_is_str = c_arg.contains("simple_str_concat") or c_arg.contains("simple_substring")
    val c_is_str2 = c_arg.contains("simple_trim") or c_arg.contains("simple_replace")
    val c_is_str3 = c_arg.contains("simple_char_at") or c_arg.contains("simple_string_join")
    if c_is_str or c_is_str2 or c_is_str3:
        return "printf(\"%s\\n\", {c_arg});"
    "printf(\"%lld\\n\", (long long){c_arg});"

# Translate array declaration
# Returns "code|||;arr:name;" if a string array is declared
fn translate_array_decl(name: text, rhs: text, type_hint: text, types: text) -> text:
    # Check for string array type
    if type_hint == "[text]" or type_hint == "[str]":
        if rhs == "[]":
            return "SimpleStringArray {name} = simple_new_string_array();|||;arr:{name};"
        # Non-empty string array init: ["a", "b", "c"]
        val inner = rhs.substring(1, rhs.len() - 1).trim()
        val elements = inner.split(",")
        var init_code = "SimpleStringArray {name} = simple_new_string_array();"
        for elem in elements:
            val trimmed_elem = elem.trim()
            init_code = init_code + " simple_string_push(&{name}, {trimmed_elem});"
        return init_code + "|||;arr:{name};"

    val inner = rhs.substring(1, rhs.len() - 1).trim()
    if inner == "":
        return "long long {name}[] = {{}}; long long {name}_len = 0;"
    val elements = inner.split(",")
    var c_elems: [text] = []
    for elem in elements:
        c_elems.push(translate_expr(elem.trim(), types))
    val arr_init = c_elems.join(", ")
    val arr_len = c_elems.len()
    "long long {name}[] = {{{arr_init}}}; long long {name}_len = {arr_len};"

# Translate variable declaration
# Returns "code|||;type_entries;" if new types are registered
fn translate_var_decl(stmt: text, types: text) -> text:
    val is_val = stmt.starts_with("val ")
    val eq_idx = stmt.index_of("=") ?? -1
    if eq_idx < 0:
        return "/* unsupported decl: {stmt} */"
    val lhs = stmt.substring(4, eq_idx).trim()
    val rhs = stmt.substring(eq_idx + 1).trim()
    var name = lhs
    var type_hint = ""
    val colon_idx = lhs.index_of(":") ?? -1
    if colon_idx >= 0:
        name = lhs.substring(0, colon_idx).trim()
        type_hint = lhs.substring(colon_idx + 1).trim()

    # Handle nil
    if rhs == "nil":
        return "const char* {name} = NULL;|||;text:{name};"

    # Handle complete string literal (not concat like "foo" + bar)
    if rhs.starts_with("\"") and rhs.ends_with("\""):
        return "const char* {name} = {rhs};|||;text:{name};"

    # Handle string concat starting with literal: "prefix" + expr
    if rhs.starts_with("\""):
        val c_rhs = translate_expr(rhs, types)
        return "const char* {name} = {c_rhs};|||;text:{name};"

    # Handle boolean
    if rhs == "true" or rhs == "false":
        var c_bval = "0"
        if rhs == "true":
            c_bval = "1"
        return "int {name} = {c_bval};"

    # Handle array literal
    if rhs.starts_with("[") and rhs.ends_with("]"):
        return translate_array_decl(name, rhs, type_hint, types)

    # Handle empty array with type hint
    if rhs == "[]":
        if type_hint == "[text]" or type_hint == "[str]":
            return "SimpleStringArray {name} = simple_new_string_array();|||;arr:{name};"
        return "long long {name}[] = {{}}; long long {name}_len = 0;"

    # Handle method call results
    val c_rhs = translate_expr(rhs, types)
    val rhs_is_str1 = c_rhs.contains("simple_substring")
    val rhs_is_str2 = c_rhs.contains("simple_trim")
    val rhs_is_str3 = c_rhs.contains("simple_replace")
    val rhs_is_str4 = c_rhs.contains("simple_string_join")
    val rhs_is_str5 = c_rhs.contains("simple_str_concat")
    val rhs_is_str6 = c_rhs.contains("simple_char_at")
    val rhs_is_str7 = c_rhs.contains("simple_file_read")
    val rhs_is_split = c_rhs.contains("simple_split")
    val any_str1 = rhs_is_str1 or rhs_is_str2 or rhs_is_str3 or rhs_is_str4
    val any_str2 = rhs_is_str5 or rhs_is_str6 or rhs_is_str7
    val rhs_returns_str = any_str1 or any_str2
    if rhs_returns_str:
        return "const char* {name} = {c_rhs};|||;text:{name};"

    if rhs_is_split:
        return "SimpleStringArray {name} = {c_rhs};|||;arr:{name};"

    # Handle text type hint
    if type_hint == "text" or type_hint == "str":
        return "const char* {name} = {c_rhs};|||;text:{name};"

    # Check if RHS is a function call that returns text
    val paren_pos = rhs.index_of("(") ?? -1
    if paren_pos >= 0:
        val fn_name = rhs.substring(0, paren_pos).trim()
        if is_fn_returning_text(fn_name, types):
            return "const char* {name} = {c_rhs};|||;text:{name};"

    # Default: long long
    "long long {name} = {c_rhs};"

# Translate for loop
# Returns "code|||;type_entries;" if loop var is registered as text
fn translate_for_loop(trimmed: text, types: text) -> text:
    val body = trimmed.substring(4, trimmed.len() - 1).trim()
    val in_idx = body.index_of(" in ") ?? -1
    if in_idx < 0:
        return "/* unsupported for: {trimmed} */"
    val loop_var = body.substring(0, in_idx).trim()
    val iterable = body.substring(in_idx + 4).trim()

    # range(start, end)
    if iterable.starts_with("range(") and iterable.ends_with(")"):
        val range_args = iterable.substring(6, iterable.len() - 1).trim()
        val comma_idx = range_args.index_of(",") ?? -1
        if comma_idx >= 0:
            val start_expr = range_args.substring(0, comma_idx).trim()
            val end_expr = range_args.substring(comma_idx + 1).trim()
            return "for (long long {loop_var} = {translate_expr(start_expr, types)}; {loop_var} < {translate_expr(end_expr, types)}; {loop_var}++) {"
        else:
            return "for (long long {loop_var} = 0; {loop_var} < {translate_expr(range_args, types)}; {loop_var}++) {"

    # start..end range
    val dotdot_idx = iterable.index_of("..") ?? -1
    if dotdot_idx >= 0:
        val start_expr = iterable.substring(0, dotdot_idx).trim()
        val end_expr = iterable.substring(dotdot_idx + 2).trim()
        return "for (long long {loop_var} = {translate_expr(start_expr, types)}; {loop_var} < {translate_expr(end_expr, types)}; {loop_var}++) {"

    # for item in string_array (SimpleStringArray)
    if is_string_array_var(iterable, types):
        return "for (long long _idx_{loop_var} = 0; _idx_{loop_var} < {iterable}.len; _idx_{loop_var}++) {{ const char* {loop_var} = {iterable}.items[_idx_{loop_var}];|||;text:{loop_var};"

    # for item in split result - detect .split( in iterable
    if iterable.contains(".split("):
        val c_split = translate_expr(iterable, types)
        return "{{ SimpleStringArray _split_{loop_var} = {c_split}; for (long long _idx_{loop_var} = 0; _idx_{loop_var} < _split_{loop_var}.len; _idx_{loop_var}++) {{ const char* {loop_var} = _split_{loop_var}.items[_idx_{loop_var}];|||;text:{loop_var};"

    # Default: integer array iteration
    "for (long long _idx_{loop_var} = 0; _idx_{loop_var} < {iterable}_len; _idx_{loop_var}++) {{ long long {loop_var} = {iterable}[_idx_{loop_var}];"

# Translate case statement
fn translate_case(trimmed: text, types: text) -> text:
    val case_body = trimmed.substring(5, trimmed.len() - 1).trim()
    if case_body == "_":
        return "/* default: */"
    if case_body.starts_with("\""):
        return "if (strcmp(_match_val, {case_body}) == 0) {"
    "if (_match_val == (long long){case_body}) {"

# Translate Simple statement to C
# Returns "code|||;type_entries;" if new types are registered
fn translate_statement(trimmed: text, types: text) -> text:
    # Skip module-system directives
    if trimmed.starts_with("use "):
        return "/* {trimmed} */"
    if trimmed.starts_with("import "):
        return "/* {trimmed} */"
    if trimmed.starts_with("export "):
        return "/* {trimmed} */"
    if trimmed.starts_with("extern fn "):
        return "/* {trimmed} */"

    # Print
    if trimmed.starts_with("print "):
        val rest = trimmed.substring(6).trim()
        return translate_print(rest, types)
    if trimmed == "print":
        return "puts(\"\");"

    # Variable declarations
    if trimmed.starts_with("val ") or trimmed.starts_with("var "):
        return translate_var_decl(trimmed, types)

    # Return
    if trimmed.starts_with("return "):
        val expr = trimmed.substring(7).trim()
        if expr == "()":
            return "return;"
        return "return {translate_expr(expr, types)};"
    if trimmed == "return":
        return "return;"
    if trimmed == "return ()":
        return "return;"

    # Control flow
    if trimmed.starts_with("if ") and trimmed.ends_with(":"):
        val cond = trimmed.substring(3, trimmed.len() - 1).trim()
        return "if ({translate_condition(cond, types)}) {"
    if trimmed.starts_with("elif ") and trimmed.ends_with(":"):
        val cond = trimmed.substring(5, trimmed.len() - 1).trim()
        return "} else if ({translate_condition(cond, types)}) {"
    if trimmed == "else:":
        return "} else {"

    # Loops
    if trimmed.starts_with("for ") and trimmed.ends_with(":"):
        return translate_for_loop(trimmed, types)

    # Match/case
    if trimmed.starts_with("match ") and trimmed.ends_with(":"):
        val match_expr = trimmed.substring(6, trimmed.len() - 1).trim()
        val c_match_expr = translate_expr(match_expr, types)
        # Detect string vs integer match
        if is_text_var(match_expr, types):
            return "{{ const char* _match_val = {c_match_expr};"
        return "{{ long long _match_val = {c_match_expr};"
    if trimmed.starts_with("case ") and trimmed.ends_with(":"):
        return translate_case(trimmed, types)

    if trimmed == "break":
        return "break;"
    if trimmed == "continue":
        return "continue;"
    if trimmed == "pass" or trimmed == "()":
        return "/* pass */;"

    # Method calls as statements (e.g., arr.push("x"))
    val push_pos = trimmed.index_of(".push(") ?? -1
    if push_pos >= 0:
        val obj = trimmed.substring(0, push_pos).trim()
        val arg_start = push_pos + 6
        val arg_end = find_close_paren(trimmed, arg_start - 1)
        if arg_end >= 0:
            val arg = trimmed.substring(arg_start, arg_end)
            if is_string_array_var(obj, types):
                return "simple_string_push(&{obj}, {translate_expr(arg, types)});"
            return "/* {trimmed} */;"

    # .pop() as statement
    if trimmed.ends_with(".pop()"):
        val obj = trimmed.substring(0, trimmed.len() - 6).trim()
        if is_string_array_var(obj, types):
            return "simple_string_pop(&{obj});"

    # Compound assignment
    val plus_eq = trimmed.index_of(" += ") ?? -1
    if plus_eq >= 0:
        val lhs = trimmed.substring(0, plus_eq).trim()
        val rhs = trimmed.substring(plus_eq + 4).trim()
        # String concatenation assignment
        if is_text_var(lhs, types):
            return "{lhs} = simple_str_concat({lhs}, {translate_expr(rhs, types)});"
        return "{lhs} += {translate_expr(rhs, types)};"
    val minus_eq = trimmed.index_of(" -= ") ?? -1
    if minus_eq >= 0:
        val lhs = trimmed.substring(0, minus_eq).trim()
        val rhs = trimmed.substring(minus_eq + 4).trim()
        return "{lhs} -= {translate_expr(rhs, types)};"
    val times_eq = trimmed.index_of(" *= ") ?? -1
    if times_eq >= 0:
        val lhs = trimmed.substring(0, times_eq).trim()
        val rhs = trimmed.substring(times_eq + 4).trim()
        return "{lhs} *= {translate_expr(rhs, types)};"
    val div_eq = trimmed.index_of(" /= ") ?? -1
    if div_eq >= 0:
        val lhs = trimmed.substring(0, div_eq).trim()
        val rhs = trimmed.substring(div_eq + 4).trim()
        return "{lhs} /= {translate_expr(rhs, types)};"

    # Variable assignment
    val eq_idx = trimmed.index_of(" = ") ?? -1
    if eq_idx >= 0:
        val lhs = trimmed.substring(0, eq_idx).trim()
        val rhs = trimmed.substring(eq_idx + 3).trim()
        val no_space = not lhs.contains(" ")
        val no_paren = not lhs.starts_with("(")
        if no_space and no_paren:
            val c_rhs = translate_expr(rhs, types)
            # Track if assigning a string to a var (e.g., name = "Alice")
            val rhs_is_str = rhs.starts_with("\"")
            val rhs_is_text = c_rhs.contains("simple_")
            if rhs_is_str or rhs_is_text:
                return "{lhs} = {c_rhs};|||;text:{lhs};"
            return "{lhs} = {c_rhs};"

    # While loop
    if trimmed.starts_with("while ") and trimmed.ends_with(":"):
        val cond = trimmed.substring(6, trimmed.len() - 1).trim()
        return "while ({translate_condition(cond, types)}) {"

    # Function call (fallback)
    val paren_pos = trimmed.index_of("(") ?? -1
    if paren_pos >= 0 and trimmed.ends_with(")"):
        return "{translate_expr(trimmed, types)};"
    "/* unsupported: {trimmed} */"

# Close unclosed braces by tracking indentation levels
fn close_blocks(body_lines: [text]) -> [text]:
    var result: [text] = []
    var brace_indents: [i64] = []

    for idx in range(0, body_lines.len()):
        val line = body_lines[idx]
        val trimmed = line.trim()
        val current_indent = get_c_indent(line)

        if trimmed.starts_with("} else"):
            result.push(line)
            continue

        var close_count = 0
        for bi in range(0, brace_indents.len()):
            val stack_idx = brace_indents.len() - 1 - bi
            if stack_idx < 0:
                break
            if current_indent <= brace_indents[stack_idx]:
                close_count = close_count + 1
            else:
                break

        for ci in range(0, close_count):
            val pop_idx = brace_indents.len() - 1
            val close_indent = brace_indents[pop_idx]
            brace_indents.pop()
            var close_padding = ""
            for pi in range(0, close_indent):
                close_padding = close_padding + "    "
            result.push("{close_padding}}")

        result.push(line)

        if trimmed.ends_with("{"):
            brace_indents.push(current_indent)

    for ci in range(0, brace_indents.len()):
        val pop_idx = brace_indents.len() - 1 - ci
        val close_indent = brace_indents[pop_idx]
        var close_padding = ""
        for pi in range(0, close_indent):
            close_padding = close_padding + "    "
        result.push("{close_padding}}")

    result

# Build a C function definition
fn build_function(name: text, sig: text, body_lines: [text]) -> text:
    val closed_lines = close_blocks(body_lines)
    var result = "{sig} {\n"
    for body_line in closed_lines:
        result = result + body_line + "\n"
    result = result + "}"
    result

export translate_condition, translate_method_expr, translate_expr
export translate_interpolated_print, translate_print
export translate_array_decl, translate_var_decl
export translate_for_loop, translate_case, translate_statement
export close_blocks, build_function
