# Simple to C Code Generator - Translation Functions
#
# Core translation logic for converting Simple statements and expressions to C:
#   - Condition, expression, and method call translation
#   - Print statement translation (with interpolation)
#   - Variable declaration and array declaration translation
#   - Control flow (for, match/case, while) translation
#   - Statement translation dispatcher
#   - Block closing and function building

use app.compile.c_helpers.{find_close_paren, is_string_array_var, is_int_array_var, is_str_arr_arr_var, is_int_arr_arr_var, is_text_var, is_fn_returning_text, is_fn_returning_struct, is_struct_field_text, is_struct_field_str_array, is_struct_field_int_array, simple_type_to_c, translate_params, get_c_indent, get_indent_level, is_struct_type_var, is_known_struct, is_known_method, is_me_method, is_static_fn, is_dict_var, is_option_var, is_enum_variant, resolve_enum_variant, parse_generic_type, is_struct_array_var, is_struct_field_struct_array, is_fn_returning_struct_arr, is_fn_returning_int_arr, is_fn_returning_str_arr}
use std.string.{NL}

# --- Translation Functions ---
# Functions that only READ types receive `types: text` parameter.
# Functions that ADD type entries return "code|||;entry1;entry2;" with ||| separator.

# Translate a Simple condition to C
fn translate_condition(cond: text, types: text) -> text:
    var result = cond
    # Handle "not" prefix
    if result.starts_with("not "):
        result = "!(" + translate_condition(result.substring(4), types) + ")"
        return result
    # Handle compound "or" (lower precedence - split first, translate each part recursively)
    if result.contains(" or "):
        val or_pos = result.index_of(" or ") ?? -1
        if or_pos >= 0:
            val or_left = result.substring(0, or_pos).trim()
            val or_right = result.substring(or_pos + 4).trim()
            return translate_condition(or_left, types) + " || " + translate_condition(or_right, types)
    # Handle compound "and" (higher precedence - split and translate each part recursively)
    if result.contains(" and "):
        val and_pos = result.index_of(" and ") ?? -1
        if and_pos >= 0:
            val and_left = result.substring(0, and_pos).trim()
            val and_right = result.substring(and_pos + 5).trim()
            return translate_condition(and_left, types) + " && " + translate_condition(and_right, types)
    # Handle "!= nil" and "== nil" - use NULL for text, < 0 for integers
    if result.contains(" != nil"):
        val nil_neq_pos = result.index_of(" != nil") ?? -1
        if nil_neq_pos >= 0:
            val nil_var = result.substring(0, nil_neq_pos).trim()
            # Strip leading !( if present
            var clean_nil_var = nil_var
            if clean_nil_var.starts_with("!("):
                clean_nil_var = clean_nil_var.substring(2)
            if is_text_var(clean_nil_var, types):
                result = result.replace(" != nil", " != NULL")
            elif is_struct_type_var(clean_nil_var, types) != "":
                result = "1"
            elif is_string_array_var(clean_nil_var, types) or is_int_array_var(clean_nil_var, types):
                result = "1"
            elif is_struct_field_str_array(clean_nil_var, types) or is_struct_field_int_array(clean_nil_var, types):
                result = "1"
            else:
                result = result.replace(" != nil", " >= 0")
    if result.contains(" == nil"):
        val nil_eq_pos = result.index_of(" == nil") ?? -1
        if nil_eq_pos >= 0:
            val nil_var = result.substring(0, nil_eq_pos).trim()
            if is_text_var(nil_var, types):
                result = result.replace(" == nil", " == NULL")
            elif is_struct_type_var(nil_var, types) != "":
                result = "0"
            elif is_string_array_var(nil_var, types) or is_int_array_var(nil_var, types):
                result = "0"
            elif is_struct_field_str_array(nil_var, types) or is_struct_field_int_array(nil_var, types):
                result = "0"
            else:
                result = result.replace(" == nil", " < 0")
    # Handle string equality: a == "str" or a == b where both are text
    # But NOT a == nil (which is a NULL check, handled above)
    if result.contains(" == "):
        val eq_pos = result.index_of(" == ") ?? -1
        if eq_pos >= 0:
            val eq_left = result.substring(0, eq_pos).trim()
            val eq_right = result.substring(eq_pos + 4).trim()
            # Skip nil/NULL/0 comparisons (also handles "NULL || ..." after or-replacement)
            val skip_nil = eq_right == "NULL" or eq_right.starts_with("NULL ") or eq_right == "0" or eq_left == "NULL" or eq_left == "0"
            if not skip_nil:
                val left_is_text = is_text_var(eq_left, types)
                val right_is_text = is_text_var(eq_right, types)
                val left_is_str = eq_left.starts_with("\"")
                val right_is_str = eq_right.starts_with("\"")
                val left_is_arr_item = eq_left.contains(".items[")
                val str_cmp = left_is_text or right_is_text or left_is_str or right_is_str or left_is_arr_item
                if str_cmp:
                    val c_left = translate_expr(eq_left, types)
                    val c_right = translate_expr(eq_right, types)
                    return "strcmp({c_left}, {c_right}) == 0"

    # Handle string inequality: a != "str"
    if result.contains(" != "):
        val neq_pos = result.index_of(" != ") ?? -1
        if neq_pos >= 0:
            val neq_left = result.substring(0, neq_pos).trim()
            val neq_right = result.substring(neq_pos + 4).trim()
            # Skip NULL/nil/0 comparisons
            val skip_null = neq_right == "NULL" or neq_right == "0" or neq_left == "NULL" or neq_left == "0"
            if not skip_null:
                val neq_l_text = is_text_var(neq_left, types)
                val neq_r_text = is_text_var(neq_right, types)
                val neq_l_str = neq_left.starts_with("\"")
                val neq_r_str = neq_right.starts_with("\"")
                val neq_l_item = neq_left.contains(".items[")
                val str_neq = neq_l_text or neq_r_text or neq_l_str or neq_r_str or neq_l_item
                if str_neq:
                    val c_left = translate_expr(neq_left, types)
                    val c_right = translate_expr(neq_right, types)
                    return "strcmp({c_left}, {c_right}) != 0"

    # Handle == comparison by translating each side individually
    val eq2_pos = result.index_of(" == ") ?? -1
    if eq2_pos >= 0:
        val cmp_left = result.substring(0, eq2_pos).trim()
        val cmp_right = result.substring(eq2_pos + 4).trim()
        return "{translate_expr(cmp_left, types)} == {translate_expr(cmp_right, types)}"

    # Handle comparison operators by translating each side individually
    # This ensures .len() and other method calls are properly translated
    val gte_pos = result.index_of(" >= ") ?? -1
    if gte_pos >= 0:
        val cmp_left = result.substring(0, gte_pos).trim()
        val cmp_right = result.substring(gte_pos + 4).trim()
        return "{translate_expr(cmp_left, types)} >= {translate_expr(cmp_right, types)}"
    val lte_pos = result.index_of(" <= ") ?? -1
    if lte_pos >= 0:
        val cmp_left = result.substring(0, lte_pos).trim()
        val cmp_right = result.substring(lte_pos + 4).trim()
        return "{translate_expr(cmp_left, types)} <= {translate_expr(cmp_right, types)}"
    val gt_pos = result.index_of(" > ") ?? -1
    if gt_pos >= 0:
        val cmp_left = result.substring(0, gt_pos).trim()
        val cmp_right = result.substring(gt_pos + 3).trim()
        return "{translate_expr(cmp_left, types)} > {translate_expr(cmp_right, types)}"
    val lt_pos = result.index_of(" < ") ?? -1
    if lt_pos >= 0:
        val cmp_left = result.substring(0, lt_pos).trim()
        val cmp_right = result.substring(lt_pos + 3).trim()
        return "{translate_expr(cmp_left, types)} < {translate_expr(cmp_right, types)}"

    # Translate method calls in conditions
    result = translate_expr(result, types)
    result

# Translate a method call expression to C
# Returns the original expression if no method call is detected
fn translate_method_expr(expr: text, types: text) -> text:
    # .contains( - check dict first, then string array, then string
    val contains_pos = expr.index_of(".contains(") ?? -1
    if contains_pos >= 0:
        val obj = expr.substring(0, contains_pos)
        val arg_start = contains_pos + 10
        val arg_end = find_close_paren(expr, arg_start - 1)
        if arg_end >= 0:
            val arg = expr.substring(arg_start, arg_end)
            if is_dict_var(obj, types):
                return "simple_dict_contains({obj}, {translate_expr(arg, types)})"
            if is_string_array_var(obj, types):
                return "simple_str_array_contains({obj}, {translate_expr(arg, types)})"
            if is_struct_field_str_array(obj, types):
                return "simple_str_array_contains({obj}, {translate_expr(arg, types)})"
            return "simple_contains({obj}, {translate_expr(arg, types)})"

    # .starts_with(
    val sw_pos = expr.index_of(".starts_with(") ?? -1
    if sw_pos >= 0:
        val obj = expr.substring(0, sw_pos)
        val arg_start = sw_pos + 13
        val arg_end = find_close_paren(expr, arg_start - 1)
        if arg_end >= 0:
            val arg = expr.substring(arg_start, arg_end)
            return "simple_starts_with({obj}, {translate_expr(arg, types)})"

    # .ends_with(
    val ew_pos = expr.index_of(".ends_with(") ?? -1
    if ew_pos >= 0:
        val obj = expr.substring(0, ew_pos)
        val arg_start = ew_pos + 11
        val arg_end = find_close_paren(expr, arg_start - 1)
        if arg_end >= 0:
            val arg = expr.substring(arg_start, arg_end)
            return "simple_ends_with({obj}, {translate_expr(arg, types)})"

    # .substring(
    val sub_pos = expr.index_of(".substring(") ?? -1
    if sub_pos >= 0:
        val obj = expr.substring(0, sub_pos)
        val arg_start = sub_pos + 11
        val arg_end = find_close_paren(expr, arg_start - 1)
        if arg_end >= 0:
            val args = expr.substring(arg_start, arg_end)
            return "simple_substring({obj}, {args})"

    # .trim()
    val trim_pos = expr.index_of(".trim()") ?? -1
    if trim_pos >= 0:
        val obj = expr.substring(0, trim_pos)
        return "simple_trim({obj})"

    # .split(
    val split_pos = expr.index_of(".split(") ?? -1
    if split_pos >= 0:
        val obj = expr.substring(0, split_pos)
        val arg_start = split_pos + 7
        val arg_end = find_close_paren(expr, arg_start - 1)
        if arg_end >= 0:
            val arg = expr.substring(arg_start, arg_end)
            return "simple_split({obj}, {arg})"

    # .replace(
    val repl_pos = expr.index_of(".replace(") ?? -1
    if repl_pos >= 0:
        val obj = expr.substring(0, repl_pos)
        val arg_start = repl_pos + 9
        val arg_end = find_close_paren(expr, arg_start - 1)
        if arg_end >= 0:
            val args = expr.substring(arg_start, arg_end)
            return "simple_replace({obj}, {args})"

    # .index_of(
    val iof_pos = expr.index_of(".index_of(") ?? -1
    if iof_pos >= 0:
        val obj = expr.substring(0, iof_pos)
        val arg_start = iof_pos + 10
        val arg_end = find_close_paren(expr, arg_start - 1)
        if arg_end >= 0:
            val arg = expr.substring(arg_start, arg_end)
            return "simple_index_of({obj}, {arg})"

    # .last_index_of(
    val liof_pos = expr.index_of(".last_index_of(") ?? -1
    if liof_pos >= 0:
        val obj = expr.substring(0, liof_pos)
        val arg_start = liof_pos + 15
        val arg_end = find_close_paren(expr, arg_start - 1)
        if arg_end >= 0:
            val arg = expr.substring(arg_start, arg_end)
            return "simple_last_index_of({obj}, {arg})"

    # .join(
    val join_pos = expr.index_of(".join(") ?? -1
    if join_pos >= 0:
        val obj = expr.substring(0, join_pos)
        val arg_start = join_pos + 6
        val arg_end = find_close_paren(expr, arg_start - 1)
        if arg_end >= 0:
            val arg = expr.substring(arg_start, arg_end)
            return "simple_string_join(&{obj}, {arg})"

    # .len() - context-dependent
    if expr.ends_with(".len()"):
        val base = expr.substring(0, expr.len() - 6)
        if is_dict_var(base, types):
            return "simple_dict_len({base})"
        if is_string_array_var(base, types):
            return "{base}.len"
        if is_int_array_var(base, types):
            return "{base}.len"
        if is_str_arr_arr_var(base, types):
            return "{base}.len"
        if is_int_arr_arr_var(base, types):
            return "{base}.len"
        if is_struct_array_var(base, types) != "":
            return "{base}.len"
        val base_is_text = is_text_var(base, types)
        val base_is_literal = base.starts_with("\"")
        if base_is_text or base_is_literal:
            return "simple_strlen({base})"
        # Check if base is a struct field that is text (e.g., self.source.len())
        if is_struct_field_text(base, types):
            return "simple_strlen({base})"
        # Check if base is a struct field that is an array
        if is_struct_field_str_array(base, types):
            return "{base}.len"
        if is_struct_field_int_array(base, types):
            return "{base}.len"
        if is_struct_field_struct_array(base, types) != "":
            return "{base}.len"
        # Check if base contains bracket indexing (e.g., arr[idx].len())
        val base_bracket = base.index_of("[") ?? -1
        if base_bracket >= 0:
            val c_base = translate_expr(base, types)
            return "{c_base}.len"
        return "{base}.len"

    # .pop()
    if expr.ends_with(".pop()"):
        val base = expr.substring(0, expr.len() - 6)
        if is_int_array_var(base, types):
            return "simple_int_pop(&{base})"
        return "simple_string_pop(&{base})"

    # .keys() on dict
    val keys_pos = expr.index_of(".keys()") ?? -1
    if keys_pos >= 0:
        val obj = expr.substring(0, keys_pos)
        if is_dict_var(obj, types):
            return "simple_dict_keys({obj})"

    # .remove() on dict
    val remove_pos = expr.index_of(".remove(") ?? -1
    if remove_pos >= 0:
        val obj = expr.substring(0, remove_pos)
        if is_dict_var(obj, types):
            val arg_start = remove_pos + 8
            val arg_end = find_close_paren(expr, arg_start - 1)
            if arg_end >= 0:
                val arg = expr.substring(arg_start, arg_end)
                return "simple_dict_remove({obj}, {arg})"

    # Struct method call: obj.method(args) where obj is a known struct variable
    val dot_pos = expr.index_of(".") ?? -1
    if dot_pos >= 0:
        val obj = expr.substring(0, dot_pos).trim()
        val after_dot = expr.substring(dot_pos + 1)
        val m_paren = after_dot.index_of("(") ?? -1
        if m_paren >= 0:
            val method_name = after_dot.substring(0, m_paren).trim()
            val class_name = is_struct_type_var(obj, types)
            if class_name != "":
                if is_known_method(class_name, method_name, types):
                    val m_close = find_close_paren(after_dot, m_paren)
                    var m_args = ""
                    if m_close > m_paren + 1:
                        m_args = after_dot.substring(m_paren + 1, m_close)
                    if is_me_method(class_name, method_name, types):
                        if m_args != "":
                            return "{class_name}__{method_name}(&{obj}, {m_args})"
                        return "{class_name}__{method_name}(&{obj})"
                    else:
                        if m_args != "":
                            return "{class_name}__{method_name}(&{obj}, {m_args})"
                        return "{class_name}__{method_name}(&{obj})"
            # Check if obj is a class name (static method call)
            if is_known_struct(obj, types):
                if is_static_fn(obj, method_name, types):
                    val m_close = find_close_paren(after_dot, m_paren)
                    var m_args = ""
                    if m_close > m_paren + 1:
                        m_args = after_dot.substring(m_paren + 1, m_close)
                    if m_args != "":
                        return "{obj}__{method_name}({m_args})"
                    return "{obj}__{method_name}()"
        else:
            # Field access: obj.field (no parens)
            val class_name = is_struct_type_var(obj, types)
            if class_name != "":
                val field_name = after_dot.trim()
                return "{obj}.{field_name}"

    # No method call detected
    expr

# Translate a Simple expression to C
fn translate_expr(expr: text, types: text) -> text:
    # Handle nil
    if expr == "nil":
        return "NULL"
    if expr == "true":
        return "1"
    if expr == "false":
        return "0"
    if expr == "()":
        return "/* unit */"
    # Handle 'not' prefix in expressions
    if expr.starts_with("not "):
        val not_inner = expr.substring(4).trim()
        return "!({translate_expr(not_inner, types)})"
    if expr == "None":
        return "simple_none()"

    # Handle numeric literals: octal 0o prefix -> 0, remove underscores
    if expr.starts_with("0o"):
        val oct_rest = expr.substring(2)
        val oct_parts = oct_rest.split("_")
        val oct_clean = oct_parts.join("")
        return "0" + oct_clean
    if expr.contains("_"):
        val first_ch = expr.substring(0, 1)
        val is_digit = first_ch >= "0" and first_ch <= "9"
        if is_digit:
            val num_parts = expr.split("_")
            return num_parts.join("")

    # Handle enum variant access: EnumName.Variant -> EnumName_Variant
    val ev_dot = expr.index_of(".") ?? -1
    if ev_dot >= 0:
        val ev_name = expr.substring(0, ev_dot).trim()
        val ev_after = expr.substring(ev_dot + 1).trim()
        # No further dots or parens = simple variant access
        val ev_has_paren = ev_after.contains("(")
        val ev_has_dot = ev_after.contains(".")
        if not ev_has_paren and not ev_has_dot:
            if is_enum_variant(expr, types):
                return "{ev_name}_{ev_after}"

    # Handle inline ternary: if cond: expr1 else: expr2 -> cond ? expr1 : expr2
    if expr.starts_with("if ") and expr.contains(" else: "):
        val else_pos = expr.index_of(" else: ") ?? -1
        if else_pos >= 0:
            val if_part = expr.substring(3, else_pos).trim()
            val else_expr = expr.substring(else_pos + 7).trim()
            val colon_pos = if_part.index_of(":") ?? -1
            if colon_pos >= 0:
                val cond = if_part.substring(0, colon_pos).trim()
                val then_expr = if_part.substring(colon_pos + 1).trim()
                val c_cond = translate_condition(cond, types)
                val c_then = translate_expr(then_expr, types)
                val c_else = translate_expr(else_expr, types)
                return "({c_cond} ? {c_then} : {c_else})"

    # Handle Some(v)
    if expr.starts_with("Some(") and expr.ends_with(")"):
        val inner = expr.substring(5, expr.len() - 1).trim()
        val c_inner = translate_expr(inner, types)
        # Detect type for Some
        val is_str = inner.starts_with("\"")
        val is_text = is_text_var(inner, types)
        if is_str or is_text:
            return "simple_some_str({c_inner})"
        return "simple_some_int({c_inner})"

    # Handle int(x) builtin -> atoll(x)
    if expr.starts_with("int(") and expr.ends_with(")"):
        val int_inner = expr.substring(4, expr.len() - 1).trim()
        val c_int_inner = translate_expr(int_inner, types)
        return "atoll({c_int_inner})"

    # Handle ?? (null coalescing)
    val nq_pos = expr.index_of(" ?? ") ?? -1
    if nq_pos >= 0:
        val left = expr.substring(0, nq_pos).trim()
        val right = expr.substring(nq_pos + 4).trim()
        val c_left = translate_expr(left, types)
        val c_right = translate_expr(right, types)
        # For index_of ?? -1, index_of already returns -1 on not found
        if c_right == "-1":
            val has_iof = c_left.contains("simple_index_of")
            if has_iof:
                return c_left
        # String coalescing: use NULL check
        val left_is_text = is_text_var(left, types)
        val right_is_str = right.starts_with("\"")
        val right_is_text = is_text_var(right, types)
        if left_is_text or right_is_str or right_is_text:
            return "({c_left} != NULL ? {c_left} : {c_right})"
        # General integer coalescing
        return "({c_left} >= 0 ? {c_left} : {c_right})"

    # Handle pipe operator: expr |> func
    val pipe_pos = expr.index_of(" |> ") ?? -1
    if pipe_pos >= 0:
        val left = expr.substring(0, pipe_pos).trim()
        val right = expr.substring(pipe_pos + 4).trim()
        val c_left = translate_expr(left, types)
        return "{right}({c_left})"

    # Handle "key in dict" -> simple_dict_contains(dict, key)
    val in_pos = expr.index_of(" in ") ?? -1
    if in_pos >= 0:
        val left = expr.substring(0, in_pos).trim()
        val right = expr.substring(in_pos + 4).trim()
        if is_dict_var(right, types):
            return "simple_dict_contains({right}, {translate_expr(left, types)})"

    # Handle complete string literals (starts and ends with quote, no unquoted +)
    if expr.starts_with("\"") and expr.ends_with("\""):
        val has_concat = expr.contains("\" + ") or expr.contains(" + \"")
        if not has_concat:
            return expr

    # Handle empty dict literal
    if expr == "{}":
        return "simple_dict_new()"

    # Handle string concatenation with +
    val plus_pos = expr.index_of(" + ") ?? -1
    if plus_pos >= 0:
        val left = expr.substring(0, plus_pos).trim()
        val right = expr.substring(plus_pos + 3).trim()
        val left_is_str = left.starts_with("\"")
        val right_is_str = right.starts_with("\"")
        val left_is_text = is_text_var(left, types)
        val right_is_text = is_text_var(right, types)
        val left_is_method = left.contains("simple_")
        val right_is_method = right.contains("simple_")
        val either_str = left_is_str or right_is_str
        val either_text = left_is_text or right_is_text
        val either_method = left_is_method or right_is_method
        val is_string_concat = either_str or either_text or either_method
        if is_string_concat:
            return "simple_str_concat({translate_expr(left, types)}, {translate_expr(right, types)})"
        # Array concat: arr + [elem]
        if right.starts_with("[") and right.ends_with("]"):
            val arr_elem = right.substring(1, right.len() - 1).trim()
            val c_left = translate_expr(left, types)
            val c_arr_elem = translate_expr(arr_elem, types)
            # Check struct array variable
            val sa_elem_type = is_struct_array_var(left, types)
            if sa_elem_type != "":
                return "({{ {sa_elem_type}* _cp = malloc(sizeof({sa_elem_type})); *_cp = {c_arr_elem}; simple_struct_array_copy_push({c_left}, (void*)_cp); }})"
            # Check struct field that is a struct array
            val sf_elem_type = is_struct_field_struct_array(left, types)
            if sf_elem_type != "":
                return "({{ {sf_elem_type}* _cp = malloc(sizeof({sf_elem_type})); *_cp = {c_arr_elem}; simple_struct_array_copy_push({c_left}, (void*)_cp); }})"
            # Check int array
            if is_int_array_var(left, types):
                return "simple_int_array_copy_push({c_left}, {c_arr_elem})"
            # Check string array
            if is_string_array_var(left, types):
                return "simple_string_array_copy_push({c_left}, {c_arr_elem})"

    # Pre-process: replace .len() within complex expressions
    # This handles cases like arr.len() - 1 inside brackets
    if expr.contains(".len()"):
        var processed = expr
        # Find and replace each .len() occurrence
        var len_pos = processed.index_of(".len()") ?? -1
        if len_pos >= 0:
            val len_full_base = processed.substring(0, len_pos)
            val len_rest = processed.substring(len_pos + 6)
            # Extract just the variable/field part (after last comma, space, or paren)
            var len_base = len_full_base
            var len_prefix = ""
            var lscan = len_full_base.len() - 1
            var lfound = false
            while lscan >= 0 and not lfound:
                val lch = len_full_base[lscan]
                val is_sep = lch == "," or lch == " " or lch == "("
                if is_sep:
                    len_prefix = len_full_base.substring(0, lscan + 1)
                    len_base = len_full_base.substring(lscan + 1).trim()
                    lfound = true
                lscan = lscan - 1
            # Directly resolve .len() based on type
            var len_replacement = ""
            if is_text_var(len_base, types) or is_struct_field_text(len_base, types):
                len_replacement = "simple_strlen({len_base})"
            elif is_string_array_var(len_base, types) or is_int_array_var(len_base, types):
                len_replacement = "{len_base}.len"
            elif is_str_arr_arr_var(len_base, types) or is_int_arr_arr_var(len_base, types):
                len_replacement = "{len_base}.len"
            elif is_struct_field_str_array(len_base, types) or is_struct_field_int_array(len_base, types):
                len_replacement = "{len_base}.len"
            elif is_struct_array_var(len_base, types) != "":
                len_replacement = "{len_base}.len"
            elif is_struct_field_struct_array(len_base, types) != "":
                len_replacement = "{len_base}.len"
            else:
                # Fallback: try translate_method_expr
                val len_result = translate_method_expr(len_base + ".len()", types)
                val len_orig = len_base + ".len()"
                if len_result != len_orig and not len_result.ends_with(".len"):
                    len_replacement = len_result
            if len_replacement != "":
                processed = len_prefix + len_replacement + len_rest
                return translate_expr(processed, types)

    # Handle method calls
    val method_result = translate_method_expr(expr, types)
    if method_result != expr:
        return method_result

    # Handle dict indexing: d[key] where d is a known dict
    val bracket_pos = expr.index_of("[") ?? -1
    if bracket_pos >= 0:
        val base = expr.substring(0, bracket_pos)
        if is_dict_var(base, types):
            val idx_end = expr.index_of("]") ?? -1
            if idx_end >= 0:
                val idx_expr = expr.substring(bracket_pos + 1, idx_end)
                return "simple_dict_get({base}, {translate_expr(idx_expr, types)})"

    # Handle string indexing and slicing: s[idx] or s[start:end]
    if bracket_pos >= 0:
        val base = expr.substring(0, bracket_pos)
        val base_is_text_var = is_text_var(base, types)
        val base_is_field_text = is_struct_field_text(base, types)
        if base_is_text_var or base_is_field_text:
            val idx_end = expr.index_of("]") ?? -1
            if idx_end >= 0:
                val idx_expr = expr.substring(bracket_pos + 1, idx_end)
                # Check for slice syntax: s[start:end]
                val colon_pos = idx_expr.index_of(":") ?? -1
                if colon_pos >= 0:
                    val start_expr = idx_expr.substring(0, colon_pos).trim()
                    val end_expr = idx_expr.substring(colon_pos + 1).trim()
                    # Handle open-ended slice: s[start:] -> s[start:len]
                    if end_expr == "":
                        return "simple_substring({base}, {translate_expr(start_expr, types)}, simple_strlen({base}))"
                    return "simple_substring({base}, {translate_expr(start_expr, types)}, {translate_expr(end_expr, types)})"
                return "simple_char_at({base}, {translate_expr(idx_expr, types)})"

    # Handle string array indexing: arr[i] -> arr.items[i]
    if bracket_pos >= 0:
        val base = expr.substring(0, bracket_pos)
        if is_string_array_var(base, types):
            val idx_end = expr.index_of("]") ?? -1
            if idx_end >= 0:
                val idx_expr = expr.substring(bracket_pos + 1, idx_end)
                return "{base}.items[{translate_expr(idx_expr, types)}]"

    # Handle integer array indexing: arr[i] -> arr.items[i]
    if bracket_pos >= 0:
        val base = expr.substring(0, bracket_pos)
        if is_int_array_var(base, types):
            val idx_end = expr.index_of("]") ?? -1
            if idx_end >= 0:
                val idx_expr = expr.substring(bracket_pos + 1, idx_end)
                return "{base}.items[{translate_expr(idx_expr, types)}]"

    # Handle struct array indexing: arr[i] -> *(ElementType*)arr.items[i]
    if bracket_pos >= 0:
        val base = expr.substring(0, bracket_pos)
        val sa_elem = is_struct_array_var(base, types)
        if sa_elem != "":
            val idx_end = expr.index_of("]") ?? -1
            if idx_end >= 0:
                val idx_expr = expr.substring(bracket_pos + 1, idx_end)
                val c_idx = translate_expr(idx_expr, types)
                val after_bracket = expr.substring(idx_end + 1)
                if after_bracket.starts_with("."):
                    # Chained field access: arr[i].field -> (*(Type*)arr.items[i]).field
                    return "(*({sa_elem}*){base}.items[{c_idx}]){after_bracket}"
                return "*({sa_elem}*){base}.items[{c_idx}]"

    # Handle nested array indexing: arr[i] on [[text]] or [[i64]]
    if bracket_pos >= 0:
        val base = expr.substring(0, bracket_pos)
        if is_str_arr_arr_var(base, types):
            val idx_end = expr.index_of("]") ?? -1
            if idx_end >= 0:
                val idx_expr = expr.substring(bracket_pos + 1, idx_end)
                return "{base}.items[{translate_expr(idx_expr, types)}]"
        if is_int_arr_arr_var(base, types):
            val idx_end = expr.index_of("]") ?? -1
            if idx_end >= 0:
                val idx_expr = expr.substring(bracket_pos + 1, idx_end)
                return "{base}.items[{translate_expr(idx_expr, types)}]"

    # Handle struct field array indexing: struct.field[idx] -> struct.field.items[idx]
    if bracket_pos >= 0:
        val base = expr.substring(0, bracket_pos)
        if base.contains("."):
            val is_sf_str = is_struct_field_str_array(base, types)
            val is_sf_int = is_struct_field_int_array(base, types)
            if is_sf_str or is_sf_int:
                val idx_end = expr.index_of("]") ?? -1
                if idx_end >= 0:
                    val idx_expr = expr.substring(bracket_pos + 1, idx_end)
                    return "{base}.items[{translate_expr(idx_expr, types)}]"

    # Handle optional chaining: expr.? -> simple_option_has(expr)
    if expr.ends_with(".?"):
        val base = expr.substring(0, expr.len() - 2).trim()
        return "simple_option_has({translate_expr(base, types)})"

    # Handle optional chaining: obj?.field -> temp var pattern
    val opt_chain_pos = expr.index_of("?.") ?? -1
    if opt_chain_pos >= 0:
        # Skip if ?. is inside a string literal
        val before_opt = expr.substring(0, opt_chain_pos)
        val quote_count_opt = before_opt.split("\"").len() - 1
        val opt_in_str = quote_count_opt % 2 == 1
        if not opt_in_str:
            val left = expr.substring(0, opt_chain_pos).trim()
            val right = expr.substring(opt_chain_pos + 2).trim()
            val c_left = translate_expr(left, types)
            return "({c_left} != NULL ? {c_left}->{right} : NULL)"

    # Handle struct construction: ClassName(field: val, field2: val2)
    val ctor_paren = expr.index_of("(") ?? -1
    if ctor_paren >= 0 and expr.ends_with(")"):
        val ctor_name = expr.substring(0, ctor_paren).trim()
        if is_known_struct(ctor_name, types):
            val ctor_args = expr.substring(ctor_paren + 1, expr.len() - 1).trim()
            if ctor_args.contains(":"):
                # Named construction: Point(x: 3, y: 4) -> (Point){.x = 3, .y = 4}
                val cparts = ctor_args.split(",")
                var designated: [text] = []
                for cp in cparts:
                    val cpt = cp.trim()
                    val ccolon = cpt.index_of(":") ?? -1
                    if ccolon >= 0:
                        val fname = cpt.substring(0, ccolon).trim()
                        val fval = cpt.substring(ccolon + 1).trim()
                        # Handle [] in struct field init - use correct type based on field
                        var c_fval = ""
                        if fval == "[]":
                            val field_arr_marker = ";field_arr:" + ctor_name + "." + fname + ";"
                            val field_int_arr_marker = ";field_int_arr:" + ctor_name + "." + fname + ";"
                            val field_struct_arr_prefix = ";field_struct_arr:" + ctor_name + "." + fname + "="
                            if types.contains(field_arr_marker):
                                c_fval = "simple_new_string_array()"
                            elif types.contains(field_int_arr_marker):
                                c_fval = "simple_new_int_array()"
                            elif types.contains(field_struct_arr_prefix):
                                c_fval = "simple_new_struct_array()"
                            else:
                                c_fval = "simple_new_int_array()"
                        else:
                            c_fval = translate_expr(fval, types)
                        designated.push(".{fname} = {c_fval}")
                val desig_str = designated.join(", ")
                return "({ctor_name}){{{desig_str}}}"
            # Enum variant construction: EnumName.Variant(args) is handled in method_expr
            # Positional construction fallback
            val args_c = translate_expr(ctor_args, types)
            return "{ctor_name}__{ctor_name}({args_c})"

    # Handle enum variant: EnumName.Variant or EnumName.Variant(args)
    val edot_pos = expr.index_of(".") ?? -1
    if edot_pos >= 0:
        val ename = expr.substring(0, edot_pos).trim()
        val erest = expr.substring(edot_pos + 1).trim()
        if is_known_struct(ename, types):
            val ev_paren = erest.index_of("(") ?? -1
            if ev_paren >= 0:
                val ev_name = erest.substring(0, ev_paren).trim()
                val ev_close = erest.index_of(")") ?? -1
                if ev_close > ev_paren + 1:
                    val ev_args = erest.substring(ev_paren + 1, ev_close).trim()
                    return "{ename}__{ev_name}({translate_expr(ev_args, types)})"
                return "{ename}__{ev_name}()"
            else:
                # Simple enum variant or field access
                return "{ename}__{erest}"

    # Handle general function calls: translate each argument individually
    # This ensures string concat and other patterns inside arguments get translated
    if ctor_paren >= 0 and expr.ends_with(")"):
        val fc_name = expr.substring(0, ctor_paren).trim()
        val fc_has_dot = fc_name.contains(".")
        val fc_is_struct = is_known_struct(fc_name, types)
        if not fc_has_dot and not fc_is_struct and fc_name.len() > 0:
            val fc_close = find_close_paren(expr, ctor_paren)
            if fc_close >= 0:
                val fc_args_str = expr.substring(ctor_paren + 1, fc_close)
                # Split args by top-level commas (using find_close_paren for nesting)
                var fc_args: [text] = []
                var fc_start = 0
                var fc_i = 0
                var fc_pdepth = 0
                var fc_in_quotes = false
                val fc_parts = fc_args_str.split("\"")
                # Rebuild: replace top-level commas with separator
                var fc_rebuilt = ""
                for fc_si in range(0, fc_parts.len()):
                    if fc_si % 2 == 0:
                        val fc_seg = fc_parts[fc_si]
                        # Outside strings: replace commas at depth 0
                        # Count parens to track depth
                        val sub_segs = fc_seg.split(",")
                        for ss_i in range(0, sub_segs.len()):
                            val ss = sub_segs[ss_i]
                            val ss_open = ss.split("(").len() - 1
                            val ss_close_p = ss.split(")").len() - 1
                            fc_pdepth = fc_pdepth + ss_open - ss_close_p
                            if ss_i > 0:
                                if fc_pdepth == 0:
                                    fc_rebuilt = fc_rebuilt + "|||ASEP|||"
                                else:
                                    fc_rebuilt = fc_rebuilt + ","
                            fc_rebuilt = fc_rebuilt + ss
                    else:
                        fc_rebuilt = fc_rebuilt + "\"" + fc_parts[fc_si] + "\""
                fc_args = fc_rebuilt.split("|||ASEP|||")
                var fc_translated: [text] = []
                for fc_a in fc_args:
                    fc_translated.push(translate_expr(fc_a.trim(), types))
                val fc_result = fc_translated.join(", ")
                return "{fc_name}({fc_result})"

    # Handle tuple construction: (a, b)
    if expr.starts_with("(") and expr.ends_with(")"):
        val inner = expr.substring(1, expr.len() - 1).trim()
        if inner.contains(","):
            val tparts = inner.split(",")
            if tparts.len() == 2:
                val t0 = translate_expr(tparts[0].trim(), types)
                val t1 = translate_expr(tparts[1].trim(), types)
                return "(SimpleTuple2){{._0 = (void*)(long long)({t0}), ._1 = (void*)(long long)({t1})}}"
            if tparts.len() == 3:
                val t0 = translate_expr(tparts[0].trim(), types)
                val t1 = translate_expr(tparts[1].trim(), types)
                val t2 = translate_expr(tparts[2].trim(), types)
                return "(SimpleTuple3){{._0 = (void*)(long long)({t0}), ._1 = (void*)(long long)({t1}), ._2 = (void*)(long long)({t2})}}"

    expr

# Translate interpolated print statement - enhanced with %s for string exprs
fn translate_interpolated_print(inner: text, types: text) -> text:
    var fmt = ""
    var interp_args: [text] = []
    var i = 0
    var inner_len = inner.len()

    for idx in range(0, inner_len):
        val ch = inner[idx]
        if ch == "{":
            var end_idx = idx + 1
            for j in range(idx + 1, inner_len):
                if inner[j] == "}":
                    end_idx = j
                    break
            val raw_expr = inner.substring(idx + 1, end_idx)
            val c_expr = translate_expr(raw_expr, types)
            # Determine format specifier based on expression type
            val is_str_expr = c_expr.contains("simple_substring")
            val is_trim_expr = c_expr.contains("simple_trim")
            val is_replace_expr = c_expr.contains("simple_replace")
            val is_join_expr = c_expr.contains("simple_string_join")
            val is_concat_expr = c_expr.contains("simple_str_concat")
            val is_char_expr = c_expr.contains("simple_char_at")
            val is_file_expr = c_expr.contains("simple_file_read")
            val is_text = is_text_var(raw_expr, types)
            val is_dict_get = c_expr.contains("simple_dict_get")
            val is_dict_keys = c_expr.contains("simple_dict_keys")
            val is_option_str = c_expr.contains("simple_option_unwrap_str")
            val is_null_coal = c_expr.contains("!= NULL ?")
            # Check if raw expr is a struct field that returns text
            val raw_dot = raw_expr.index_of(".") ?? -1
            var is_struct_text_field = false
            if raw_dot >= 0:
                val sf_obj = raw_expr.substring(0, raw_dot).trim()
                val sf_field = raw_expr.substring(raw_dot + 1).trim()
                val sf_class = is_struct_type_var(sf_obj, types)
                if sf_class != "":
                    val field_text_marker = ";field_text:" + sf_class + "." + sf_field + ";"
                    is_struct_text_field = types.contains(field_text_marker)
            val is_string1 = is_str_expr or is_trim_expr or is_replace_expr
            val is_string2 = is_join_expr or is_concat_expr or is_char_expr
            val is_string3 = is_file_expr or is_text
            val is_string4 = c_expr.starts_with("\"")
            val is_string5 = is_dict_get or is_option_str or is_null_coal
            val is_string6 = is_struct_text_field
            val any_string = is_string1 or is_string2 or is_string3 or is_string4 or is_string5 or is_string6
            if any_string:
                fmt = fmt + "%s"
                interp_args.push(c_expr)
            else:
                fmt = fmt + "%lld"
                interp_args.push("(long long)(" + c_expr + ")")
            i = end_idx + 1
        elif idx >= i:
            fmt = fmt + ch

    var args_str = ""
    for current_arg in interp_args:
        args_str = args_str + ", " + current_arg
    "printf(\"{fmt}\{NL}\"{args_str});"

# Translate print statement
fn translate_print(arg: text, types: text) -> text:
    if arg.len() < 2:
        return "puts(\"\");"
    if arg.starts_with("\"") and arg.ends_with("\""):
        # Check for string concatenation: "str" + expr + "str"
        val has_concat = arg.contains("\" + ") or arg.contains(" + \"")
        if has_concat:
            val c_arg = translate_expr(arg, types)
            return "printf(\"%s\{NL}\", {c_arg});"
        # Check for interpolation: {expr} inside the string
        if arg.contains("{"):
            # Extract inner text between quotes for interpolation
            var inner = arg.substring(1, arg.len() - 1)
            if inner.ends_with("\""):
                inner = inner.substring(0, inner.len() - 1)
            return translate_interpolated_print(inner, types)
        # Simple string literal - use arg directly (already has quotes)
        # Emit as puts(arg) with {NL} via puts
        # Use printf to append newline properly
        return "puts({arg});"
    # Print a variable
    if is_text_var(arg, types):
        return "printf(\"%s\{NL}\", {arg});"
    # Translate expression and check if it's a string result
    val c_arg = translate_expr(arg, types)
    val c_is_str = c_arg.contains("simple_str_concat") or c_arg.contains("simple_substring")
    val c_is_str2 = c_arg.contains("simple_trim") or c_arg.contains("simple_replace")
    val c_is_str3 = c_arg.contains("simple_char_at") or c_arg.contains("simple_string_join")
    val c_is_str4 = c_arg.contains("simple_dict_get") or c_arg.contains("simple_option_unwrap_str")
    if c_is_str or c_is_str2 or c_is_str3 or c_is_str4:
        return "printf(\"%s\{NL}\", {c_arg});"
    "printf(\"%lld\{NL}\", (long long){c_arg});"

# Translate array declaration
# Returns "code|||;arr:name;" if a string array is declared
fn translate_array_decl(name: text, rhs: text, type_hint: text, types: text) -> text:
    # Check for nested array types first
    if type_hint == "[[text]]" or type_hint == "[[str]]":
        if rhs == "[]":
            return "SimpleStringArrayArray {name} = simple_new_string_array_array();|||;str_arr_arr:{name};"
        return "SimpleStringArrayArray {name} = simple_new_string_array_array();|||;str_arr_arr:{name};"
    if type_hint == "[[i64]]" or type_hint == "[[int]]":
        if rhs == "[]":
            return "SimpleIntArrayArray {name} = simple_new_int_array_array();|||;int_arr_arr:{name};"
        return "SimpleIntArrayArray {name} = simple_new_int_array_array();|||;int_arr_arr:{name};"
    # Check for string array type
    if type_hint == "[text]" or type_hint == "[str]":
        if rhs == "[]":
            return "SimpleStringArray {name} = simple_new_string_array();|||;arr:{name};"
        # Non-empty string array init: ["a", "b", "c"]
        val inner = rhs.substring(1, rhs.len() - 1).trim()
        val elements = inner.split(",")
        var init_code = "SimpleStringArray {name} = simple_new_string_array();"
        for elem in elements:
            val trimmed_elem = elem.trim()
            init_code = init_code + " simple_string_push(&{name}, {trimmed_elem});"
        return init_code + "|||;arr:{name};"

    # Check for integer array type
    if type_hint == "[i64]" or type_hint == "[int]" or type_hint == "[bool]":
        if rhs == "[]":
            return "SimpleIntArray {name} = simple_new_int_array();|||;int_arr:{name};"

    # Check for struct array type hint: [StructName]
    if type_hint.starts_with("[") and type_hint.ends_with("]"):
        val sa_elem = type_hint.substring(1, type_hint.len() - 1).trim()
        if sa_elem.len() > 0:
            val sa_fc = sa_elem[0]
            if sa_fc >= "A" and sa_fc <= "Z":
                if rhs == "[]":
                    return "SimpleStructArray {name} = simple_new_struct_array();|||;struct_arr_var:{name}={sa_elem};"
                # Non-empty struct array: [StructExpr, ...]
                val sa_inner = rhs.substring(1, rhs.len() - 1).trim()
                val sa_elements = sa_inner.split(",")
                var sa_init = "SimpleStructArray {name} = simple_new_struct_array();"
                for sa_e in sa_elements:
                    val sa_te = translate_expr(sa_e.trim(), types)
                    sa_init = sa_init + " {{ {sa_elem}* _e = malloc(sizeof({sa_elem})); *_e = {sa_te}; simple_struct_push(&{name}, (void*)_e); }}"
                return sa_init + "|||;struct_arr_var:{name}={sa_elem};"

    # Default: integer array using SimpleIntArray
    val inner = rhs.substring(1, rhs.len() - 1).trim()
    if inner == "":
        return "SimpleIntArray {name} = simple_new_int_array();|||;int_arr:{name};"
    val elements = inner.split(",")
    var init_code = "SimpleIntArray {name} = simple_new_int_array();"
    for elem in elements:
        val trimmed_elem = elem.trim()
        init_code = init_code + " simple_int_push(&{name}, {translate_expr(trimmed_elem, types)});"
    init_code + "|||;int_arr:{name};"

# Translate variable declaration
# Returns "code|||;type_entries;" if new types are registered
fn translate_var_decl(stmt: text, types: text) -> text:
    val is_val = stmt.starts_with("val ")
    val eq_idx = stmt.index_of("=") ?? -1
    if eq_idx < 0:
        return "/* unsupported decl: {stmt} */"
    val lhs = stmt.substring(4, eq_idx).trim()
    val rhs = stmt.substring(eq_idx + 1).trim()
    var name = lhs
    var type_hint = ""
    val colon_idx = lhs.index_of(":") ?? -1
    if colon_idx >= 0:
        name = lhs.substring(0, colon_idx).trim()
        type_hint = lhs.substring(colon_idx + 1).trim()

    # Handle nil
    if rhs == "nil":
        return "const char* {name} = NULL;|||;text:{name};"

    # Handle complete string literal (not concat like "foo" + bar)
    if rhs.starts_with("\"") and rhs.ends_with("\""):
        val has_str_concat = rhs.contains("\" + ") or rhs.contains(" + \"")
        if not has_str_concat:
            return "const char* {name} = {rhs};|||;text:{name};"

    # Handle string concat starting with literal: "prefix" + expr
    if rhs.starts_with("\""):
        val c_rhs = translate_expr(rhs, types)
        return "const char* {name} = {c_rhs};|||;text:{name};"

    # Handle boolean
    if rhs == "true" or rhs == "false":
        var c_bval = "0"
        if rhs == "true":
            c_bval = "1"
        return "int {name} = {c_bval};"

    # Handle boolean/logical expressions: val x = a or b, val x = a and b
    val rhs_has_logic = rhs.contains(" and ") or rhs.contains(" or ") or rhs.starts_with("not ")
    if rhs_has_logic:
        val c_logic = translate_condition(rhs, types)
        return "int {name} = {c_logic};"

    # Handle array literal
    if rhs.starts_with("[") and rhs.ends_with("]"):
        return translate_array_decl(name, rhs, type_hint, types)

    # Handle empty array with type hint
    if rhs == "[]":
        if type_hint == "[[text]]" or type_hint == "[[str]]":
            return "SimpleStringArrayArray {name} = simple_new_string_array_array();|||;str_arr_arr:{name};"
        if type_hint == "[[i64]]" or type_hint == "[[int]]":
            return "SimpleIntArrayArray {name} = simple_new_int_array_array();|||;int_arr_arr:{name};"
        if type_hint == "[text]" or type_hint == "[str]":
            return "SimpleStringArray {name} = simple_new_string_array();|||;arr:{name};"
        if type_hint == "[i64]" or type_hint == "[int]" or type_hint == "[bool]":
            return "SimpleIntArray {name} = simple_new_int_array();|||;int_arr:{name};"
        # Struct array type hint: [StructName]
        if type_hint.starts_with("[") and type_hint.ends_with("]"):
            val sa_elem_type = type_hint.substring(1, type_hint.len() - 1).trim()
            if sa_elem_type.len() > 0:
                val sa_f = sa_elem_type[0]
                if sa_f >= "A" and sa_f <= "Z":
                    return "SimpleStructArray {name} = simple_new_struct_array();|||;struct_arr_var:{name}={sa_elem_type};"
        return "SimpleIntArray {name} = simple_new_int_array();|||;int_arr:{name};"

    # Handle nested array indexing: val x = nested_arr[idx] -> inner array type
    val rhs_bracket = rhs.index_of("[") ?? -1
    if rhs_bracket >= 0:
        val rhs_base = rhs.substring(0, rhs_bracket).trim()
        if is_int_arr_arr_var(rhs_base, types):
            val c_rhs_idx = translate_expr(rhs, types)
            return "SimpleIntArray {name} = {c_rhs_idx};|||;int_arr:{name};"
        if is_str_arr_arr_var(rhs_base, types):
            val c_rhs_idx = translate_expr(rhs, types)
            return "SimpleStringArray {name} = {c_rhs_idx};|||;arr:{name};"

    # Handle Some/None -> SimpleOption
    if rhs.starts_with("Some(") or rhs == "None" or rhs == "nil":
        val c_rhs_opt = translate_expr(rhs, types)
        if c_rhs_opt.contains("simple_some") or c_rhs_opt.contains("simple_none"):
            return "SimpleOption {name} = {c_rhs_opt};|||;option:{name};"

    # Handle empty dict literal
    if rhs == "{}":
        return "SimpleDict* {name} = simple_dict_new();|||;dict:{name};"

    # Handle method call results
    val c_rhs = translate_expr(rhs, types)
    val rhs_is_str1 = c_rhs.contains("simple_substring")
    val rhs_is_str2 = c_rhs.contains("simple_trim")
    val rhs_is_str3 = c_rhs.contains("simple_replace")
    val rhs_is_str4 = c_rhs.contains("simple_string_join")
    val rhs_is_str5 = c_rhs.contains("simple_str_concat")
    val rhs_is_str6 = c_rhs.contains("simple_char_at")
    val rhs_is_str7 = c_rhs.contains("simple_file_read")
    val rhs_is_str8 = c_rhs.contains("simple_dict_get")
    val rhs_is_str9 = c_rhs.contains("simple_option_unwrap_str")
    val rhs_is_split = c_rhs.contains("simple_split")
    val any_str1 = rhs_is_str1 or rhs_is_str2 or rhs_is_str3 or rhs_is_str4
    val any_str2 = rhs_is_str5 or rhs_is_str6 or rhs_is_str7
    val rhs_is_str10 = c_rhs.contains("!= NULL ?")
    val any_str3 = rhs_is_str8 or rhs_is_str9 or rhs_is_str10
    val rhs_returns_str = any_str1 or any_str2 or any_str3
    if rhs_returns_str:
        return "const char* {name} = {c_rhs};|||;text:{name};"

    if rhs_is_split:
        return "SimpleStringArray {name} = {c_rhs};|||;arr:{name};"

    # Handle text type hint
    if type_hint == "text" or type_hint == "str":
        return "const char* {name} = {c_rhs};|||;text:{name};"

    # Check if RHS is a function call that returns text
    val paren_pos = rhs.index_of("(") ?? -1
    if paren_pos >= 0:
        val fn_name = rhs.substring(0, paren_pos).trim()
        if is_fn_returning_text(fn_name, types):
            return "const char* {name} = {c_rhs};|||;text:{name};"
    # Also check translated expression for mangled method names that return text
    val c_paren_pos = c_rhs.index_of("(") ?? -1
    if c_paren_pos >= 0:
        val c_fn_name = c_rhs.substring(0, c_paren_pos).trim()
        if is_fn_returning_text(c_fn_name, types):
            return "const char* {name} = {c_rhs};|||;text:{name};"

    # Check if function returns a struct type
    if paren_pos >= 0:
        val fn_name_s = rhs.substring(0, paren_pos).trim()
        val struct_ret = is_fn_returning_struct(fn_name_s, types)
        if struct_ret != "":
            return "{struct_ret} {name} = {c_rhs};|||;struct_var:{name}={struct_ret};"
    # Also check mangled name
    if c_paren_pos >= 0:
        val c_fn_name_s = c_rhs.substring(0, c_paren_pos).trim()
        val struct_ret = is_fn_returning_struct(c_fn_name_s, types)
        if struct_ret != "":
            return "{struct_ret} {name} = {c_rhs};|||;struct_var:{name}={struct_ret};"

    # Check if function returns a struct array
    if paren_pos >= 0:
        val fn_sa_name = rhs.substring(0, paren_pos).trim()
        val sa_ret_elem = is_fn_returning_struct_arr(fn_sa_name, types)
        if sa_ret_elem != "":
            return "SimpleStructArray {name} = {c_rhs};|||;struct_arr_var:{name}={sa_ret_elem};"
    if c_paren_pos >= 0:
        val c_fn_sa_name = c_rhs.substring(0, c_paren_pos).trim()
        val sa_ret_elem = is_fn_returning_struct_arr(c_fn_sa_name, types)
        if sa_ret_elem != "":
            return "SimpleStructArray {name} = {c_rhs};|||;struct_arr_var:{name}={sa_ret_elem};"

    # Check if function returns an int array
    if paren_pos >= 0:
        val fn_ia_name = rhs.substring(0, paren_pos).trim()
        if is_fn_returning_int_arr(fn_ia_name, types):
            return "SimpleIntArray {name} = {c_rhs};|||;int_arr:{name};"
    if c_paren_pos >= 0:
        val c_fn_ia_name = c_rhs.substring(0, c_paren_pos).trim()
        if is_fn_returning_int_arr(c_fn_ia_name, types):
            return "SimpleIntArray {name} = {c_rhs};|||;int_arr:{name};"

    # Check if function returns a string array
    if paren_pos >= 0:
        val fn_sar_name = rhs.substring(0, paren_pos).trim()
        if is_fn_returning_str_arr(fn_sar_name, types):
            return "SimpleStringArray {name} = {c_rhs};|||;arr:{name};"
    if c_paren_pos >= 0:
        val c_fn_sar_name = c_rhs.substring(0, c_paren_pos).trim()
        if is_fn_returning_str_arr(c_fn_sar_name, types):
            return "SimpleStringArray {name} = {c_rhs};|||;arr:{name};"

    # Handle Dict type hint
    val gen_parts = parse_generic_type(type_hint)
    if gen_parts.len() > 0:
        val gen_base = gen_parts[0]
        if gen_base == "Dict":
            if rhs == "{}":
                return "SimpleDict* {name} = simple_dict_new();|||;dict:{name};"
            return "SimpleDict* {name} = {c_rhs};|||;dict:{name};"
        if gen_base == "Option":
            return "SimpleOption {name} = {c_rhs};|||;option:{name};"

    # Handle struct type hint - known struct
    if is_known_struct(type_hint, types):
        return "{type_hint} {name} = {c_rhs};|||;struct_var:{name}={type_hint};"

    # Handle struct construction on RHS: ClassName(field: val)
    val rhs_paren = rhs.index_of("(") ?? -1
    if rhs_paren >= 0:
        val rhs_ctor = rhs.substring(0, rhs_paren).trim()
        if is_known_struct(rhs_ctor, types):
            return "{rhs_ctor} {name} = {c_rhs};|||;struct_var:{name}={rhs_ctor};"
        # Check for enum variant construction: ClassName.Variant(args)
        # Only if it's NOT a known static fn (static fns return specific types, not the class itself)
        val cdot = rhs_ctor.index_of(".") ?? -1
        if cdot >= 0:
            val enum_name = rhs_ctor.substring(0, cdot).trim()
            val variant_part = rhs_ctor.substring(cdot + 1).trim()
            if is_known_struct(enum_name, types):
                val is_static = is_static_fn(enum_name, variant_part, types)
                if not is_static:
                    return "{enum_name} {name} = {c_rhs};|||;struct_var:{name}={enum_name};"

    # Handle Option<T> nullable pattern (check for ? in type)
    if type_hint.ends_with("?"):
        return "SimpleOption {name} = {c_rhs};|||;option:{name};"

    # Detect ternary expressions that return strings: (cond ? "str" : "str")
    val c_has_ternary_str = c_rhs.contains("? \"")
    if c_has_ternary_str:
        return "const char* {name} = {c_rhs};|||;text:{name};"

    # Detect inline if expression returning string
    if rhs.starts_with("if ") and rhs.contains(" else: "):
        val ternary_check = rhs.contains("\"")
        if ternary_check:
            return "const char* {name} = {c_rhs};|||;text:{name};"

    # Check if RHS is a known text variable
    if is_text_var(rhs, types):
        return "const char* {name} = {c_rhs};|||;text:{name};"
    # Check if RHS is a struct field that is text
    if is_struct_field_text(rhs, types):
        return "const char* {name} = {c_rhs};|||;text:{name};"
    # Check if RHS is a known struct variable (propagate struct type)
    val rhs_struct_type = is_struct_type_var(rhs, types)
    if rhs_struct_type != "":
        return "{rhs_struct_type} {name} = {c_rhs};|||;struct_var:{name}={rhs_struct_type};"
    # Check if RHS is a known string array (propagate array type)
    if is_string_array_var(rhs, types):
        return "SimpleStringArray {name} = {c_rhs};|||;arr:{name};"
    if is_int_array_var(rhs, types):
        return "SimpleIntArray {name} = {c_rhs};|||;int_arr:{name};"
    val rhs_sa_type = is_struct_array_var(rhs, types)
    if rhs_sa_type != "":
        return "SimpleStructArray {name} = {c_rhs};|||;struct_arr_var:{name}={rhs_sa_type};"
    # Check if RHS is a struct field that is a struct array
    val rhs_sf_sa = is_struct_field_struct_array(rhs, types)
    if rhs_sf_sa != "":
        return "SimpleStructArray {name} = {c_rhs};|||;struct_arr_var:{name}={rhs_sf_sa};"
    # Check if RHS is a struct field that is a string array
    if is_struct_field_str_array(rhs, types):
        return "SimpleStringArray {name} = {c_rhs};|||;arr:{name};"
    # Check if RHS is a struct field that is an int array
    if is_struct_field_int_array(rhs, types):
        return "SimpleIntArray {name} = {c_rhs};|||;int_arr:{name};"

    # Default: long long
    "long long {name} = {c_rhs};"

# Translate for loop
# Returns "code|||;type_entries;" if loop var is registered as text
fn translate_for_loop(trimmed: text, types: text) -> text:
    val body = trimmed.substring(4, trimmed.len() - 1).trim()
    val in_idx = body.index_of(" in ") ?? -1
    if in_idx < 0:
        return "/* unsupported for: {trimmed} */"
    val loop_var = body.substring(0, in_idx).trim()
    val iterable = body.substring(in_idx + 4).trim()

    # range(start, end)
    if iterable.starts_with("range(") and iterable.ends_with(")"):
        val range_args = iterable.substring(6, iterable.len() - 1).trim()
        val comma_idx = range_args.index_of(",") ?? -1
        if comma_idx >= 0:
            val start_expr = range_args.substring(0, comma_idx).trim()
            val end_expr = range_args.substring(comma_idx + 1).trim()
            return "for (long long {loop_var} = {translate_expr(start_expr, types)}; {loop_var} < {translate_expr(end_expr, types)}; {loop_var}++) {"
        else:
            return "for (long long {loop_var} = 0; {loop_var} < {translate_expr(range_args, types)}; {loop_var}++) {"

    # Inline array literal: [1, 2, 3, 4, 5]
    if iterable.starts_with("[") and iterable.ends_with("]"):
        val inner = iterable.substring(1, iterable.len() - 1).trim()
        val elements = inner.split(",")
        var init = "SimpleIntArray _arr_{loop_var} = simple_new_int_array();"
        for elem in elements:
            val e = translate_expr(elem.trim(), types)
            init = init + " simple_int_push(&_arr_{loop_var}, {e});"
        init = init + " for (long long _idx_{loop_var} = 0; _idx_{loop_var} < _arr_{loop_var}.len; _idx_{loop_var}++) {{ long long {loop_var} = _arr_{loop_var}.items[_idx_{loop_var}];"
        return init

    # start..end range
    val dotdot_idx = iterable.index_of("..") ?? -1
    if dotdot_idx >= 0:
        val start_expr = iterable.substring(0, dotdot_idx).trim()
        val end_expr = iterable.substring(dotdot_idx + 2).trim()
        return "for (long long {loop_var} = {translate_expr(start_expr, types)}; {loop_var} < {translate_expr(end_expr, types)}; {loop_var}++) {"

    # Inline array literal: for i in [1, 2, 3]:
    if iterable.starts_with("[") and iterable.ends_with("]"):
        val ia_inner = iterable.substring(1, iterable.len() - 1).trim()
        val ia_elements = ia_inner.split(",")
        var ia_init = "{{ SimpleIntArray _arr_{loop_var} = simple_new_int_array();"
        for ia_elem in ia_elements:
            val ia_e = translate_expr(ia_elem.trim(), types)
            ia_init = ia_init + " simple_int_push(&_arr_{loop_var}, {ia_e});"
        ia_init = ia_init + " for (long long _idx_{loop_var} = 0; _idx_{loop_var} < _arr_{loop_var}.len; _idx_{loop_var}++) {{ long long {loop_var} = _arr_{loop_var}.items[_idx_{loop_var}];"
        return ia_init

    # for item in string_array (SimpleStringArray)
    if is_string_array_var(iterable, types):
        return "for (long long _idx_{loop_var} = 0; _idx_{loop_var} < {iterable}.len; _idx_{loop_var}++) {{ const char* {loop_var} = {iterable}.items[_idx_{loop_var}];|||;text:{loop_var};"

    # for item in int_array (SimpleIntArray)
    if is_int_array_var(iterable, types):
        return "for (long long _idx_{loop_var} = 0; _idx_{loop_var} < {iterable}.len; _idx_{loop_var}++) {{ long long {loop_var} = {iterable}.items[_idx_{loop_var}];"

    # for item in struct.field (string array field)
    if is_struct_field_str_array(iterable, types):
        return "for (long long _idx_{loop_var} = 0; _idx_{loop_var} < {iterable}.len; _idx_{loop_var}++) {{ const char* {loop_var} = {iterable}.items[_idx_{loop_var}];|||;text:{loop_var};"

    # for item in struct.field (int array field)
    if is_struct_field_int_array(iterable, types):
        return "for (long long _idx_{loop_var} = 0; _idx_{loop_var} < {iterable}.len; _idx_{loop_var}++) {{ long long {loop_var} = {iterable}.items[_idx_{loop_var}];"

    # for item in struct_array (SimpleStructArray)
    val sa_iter_elem = is_struct_array_var(iterable, types)
    if sa_iter_elem != "":
        return "for (long long _idx_{loop_var} = 0; _idx_{loop_var} < {iterable}.len; _idx_{loop_var}++) {{ {sa_iter_elem} {loop_var} = *({sa_iter_elem}*){iterable}.items[_idx_{loop_var}];|||;struct_var:{loop_var}={sa_iter_elem};"

    # for item in struct.field (struct array field)
    val sf_iter_elem = is_struct_field_struct_array(iterable, types)
    if sf_iter_elem != "":
        return "for (long long _idx_{loop_var} = 0; _idx_{loop_var} < {iterable}.len; _idx_{loop_var}++) {{ {sf_iter_elem} {loop_var} = *({sf_iter_elem}*){iterable}.items[_idx_{loop_var}];|||;struct_var:{loop_var}={sf_iter_elem};"

    # for item in split result - detect .split( in iterable
    if iterable.contains(".split("):
        val c_split = translate_expr(iterable, types)
        return "{{ SimpleStringArray _split_{loop_var} = {c_split}; for (long long _idx_{loop_var} = 0; _idx_{loop_var} < _split_{loop_var}.len; _idx_{loop_var}++) {{ const char* {loop_var} = _split_{loop_var}.items[_idx_{loop_var}];|||;text:{loop_var};"

    # Default: integer array iteration
    "for (long long _idx_{loop_var} = 0; _idx_{loop_var} < {iterable}_len; _idx_{loop_var}++) {{ long long {loop_var} = {iterable}[_idx_{loop_var}];"

# Translate case statement
fn translate_case(trimmed: text, types: text) -> text:
    val case_body = trimmed.substring(5, trimmed.len() - 1).trim()
    if case_body == "_":
        return "/* default: */"
    if case_body == "nil":
        return "if (_match_val == NULL) {"
    if case_body.starts_with("\""):
        return "if (strcmp(_match_val, {case_body}) == 0) {"

    # Check for destructuring pattern: Variant(field1, field2)
    val dp_pos = case_body.index_of("(") ?? -1
    if dp_pos >= 0:
        val variant_name = case_body.substring(0, dp_pos).trim()
        val dp_close = case_body.index_of(")") ?? -1
        if dp_close > dp_pos + 1:
            val fields_str = case_body.substring(dp_pos + 1, dp_close).trim()
            val fields = fields_str.split(",")
            # Generate tag check + field extraction
            var result = "if (_match_val.tag == _match_type_TAG_{variant_name}) {{"
            var fi = 0
            for field in fields:
                val fname = field.trim()
                # Check if named or positional
                val fc = fname.index_of(":") ?? -1
                if fc >= 0:
                    val fvar = fname.substring(0, fc).trim()
                    result = result + " const char* {fvar} = _match_val.data.{variant_name}.{fvar};"
                else:
                    result = result + " const char* {fname} = _match_val.data.{variant_name}._{fi};"
                fi = fi + 1
            return result
        # No fields - just tag check
        return "if (_match_val.tag == _match_type_TAG_{variant_name}) {{"

    # Check for Some(var) pattern
    if case_body.starts_with("Some("):
        val inner = case_body.substring(5, case_body.len() - 1).trim()
        return "if (simple_option_has(_match_val)) {{ const char* {inner} = _match_val.str_val;"

    # Check if case_body is an enum variant name
    val resolved = resolve_enum_variant(case_body, types)
    if resolved != "":
        return "if (_match_val == (long long){resolved}) {"
    "if (_match_val == (long long){case_body}) {"

# Translate Simple statement to C
# Returns "code|||;type_entries;" if new types are registered
fn translate_statement(trimmed: text, types: text) -> text:
    # Skip module-system directives
    if trimmed.starts_with("use "):
        return "/* {trimmed} */"
    if trimmed.starts_with("import "):
        return "/* {trimmed} */"
    if trimmed.starts_with("export "):
        return "/* {trimmed} */"
    if trimmed.starts_with("extern fn "):
        return "/* {trimmed} */"
    if trimmed.starts_with("from "):
        return "/* {trimmed} */"
    if trimmed.starts_with("pub mod "):
        return "/* {trimmed} */"
    if trimmed.starts_with("common use "):
        return "/* {trimmed} */"
    if trimmed.starts_with("export use "):
        return "/* {trimmed} */"
    if trimmed.starts_with("type ") and trimmed.contains(" = "):
        return "/* {trimmed} */"
    if trimmed == "pass" or trimmed == "()":
        return "/* pass */;"

    # Print
    if trimmed.starts_with("print "):
        val rest = trimmed.substring(6).trim()
        return translate_print(rest, types)
    if trimmed == "print":
        return "puts(\"\");"

    # eprint -> fprintf(stderr, ...)
    if trimmed.starts_with("eprint "):
        val rest = trimmed.substring(7).trim()
        if rest.starts_with("\"") and rest.ends_with("\""):
            val inner = rest.substring(1, rest.len() - 1)
            if inner.contains("{"):
                # Reuse print interpolation logic but redirect to stderr
                val print_code = translate_interpolated_print(inner, types)
                return print_code.replace("printf(", "fprintf(stderr, ")
            return "fprintf(stderr, \"{inner}\{NL}\");"
        return "fprintf(stderr, \"%s\{NL}\", {translate_expr(rest, types)});"

    # Tuple destructuring: val (a, b) = expr
    if trimmed.starts_with("val (") or trimmed.starts_with("var ("):
        val eq_idx = trimmed.index_of(" = ") ?? -1
        if eq_idx >= 0:
            val lhs = trimmed.substring(4, eq_idx).trim()
            val rhs = trimmed.substring(eq_idx + 3).trim()
            if lhs.starts_with("(") and lhs.ends_with(")"):
                val inner = lhs.substring(1, lhs.len() - 1).trim()
                val tparts = inner.split(",")
                val c_rhs = translate_expr(rhs, types)
                if tparts.len() == 2:
                    val v0 = tparts[0].trim()
                    val v1 = tparts[1].trim()
                    return "SimpleTuple2 _tmp_tuple = {c_rhs}; long long {v0} = (long long)_tmp_tuple._0; long long {v1} = (long long)_tmp_tuple._1;"
                if tparts.len() == 3:
                    val v0 = tparts[0].trim()
                    val v1 = tparts[1].trim()
                    val v2 = tparts[2].trim()
                    return "SimpleTuple3 _tmp_tuple = {c_rhs}; long long {v0} = (long long)_tmp_tuple._0; long long {v1} = (long long)_tmp_tuple._1; long long {v2} = (long long)_tmp_tuple._2;"

    # Variable declarations
    if trimmed.starts_with("val ") or trimmed.starts_with("var "):
        return translate_var_decl(trimmed, types)

    # Return
    if trimmed.starts_with("return "):
        val expr = trimmed.substring(7).trim()
        if expr == "()":
            return "return;"
        if expr == "[]":
            return "return simple_new_struct_array();"
        # Use translate_condition for expressions with and/or/comparisons
        val has_and = expr.contains(" and ")
        val has_or = expr.contains(" or ")
        if has_and or has_or:
            return "return {translate_condition(expr, types)};"
        return "return {translate_expr(expr, types)};"
    if trimmed == "return":
        return "return;"
    if trimmed == "return ()":
        return "return;"

    # Control flow
    if trimmed.starts_with("if ") and trimmed.ends_with(":"):
        val cond = trimmed.substring(3, trimmed.len() - 1).trim()
        return "if ({translate_condition(cond, types)}) {"
    # Inline if: "if cond: statement" (single-line if)
    if trimmed.starts_with("if ") and not trimmed.ends_with(":"):
        val if_colon = trimmed.index_of(":") ?? -1
        if if_colon >= 0:
            val if_cond = trimmed.substring(3, if_colon).trim()
            val if_body = trimmed.substring(if_colon + 1).trim()
            val c_cond = translate_condition(if_cond, types)
            val body_result = translate_statement(if_body, types)
            # Don't include implicit return from body
            var c_body = body_result
            val pipe_pos = c_body.index_of("|||") ?? -1
            if pipe_pos >= 0:
                c_body = c_body.substring(0, pipe_pos)
            return "if ({c_cond}) {{ {c_body} }}"
    if trimmed.starts_with("elif ") and trimmed.ends_with(":"):
        val cond = trimmed.substring(5, trimmed.len() - 1).trim()
        return "} else if ({translate_condition(cond, types)}) {"
    if trimmed == "else:":
        return "} else {"

    # Loops
    if trimmed.starts_with("for ") and trimmed.ends_with(":"):
        return translate_for_loop(trimmed, types)

    # Match/case
    if trimmed.starts_with("match ") and trimmed.ends_with(":"):
        val match_expr = trimmed.substring(6, trimmed.len() - 1).trim()
        val c_match_expr = translate_expr(match_expr, types)
        # Detect string vs integer match
        if is_text_var(match_expr, types):
            return "{{ const char* _match_val = {c_match_expr};"
        return "{{ long long _match_val = {c_match_expr};"
    if trimmed.starts_with("case ") and trimmed.ends_with(":"):
        return translate_case(trimmed, types)
    # Inline case: case PATTERN: body_expr
    if trimmed.starts_with("case "):
        val case_colon = trimmed.index_of(":") ?? -1
        if case_colon >= 0:
            val case_pattern = trimmed.substring(5, case_colon).trim()
            val case_inline_body = trimmed.substring(case_colon + 1).trim()
            # Build the if-check for the pattern
            val case_check_trimmed = "case {case_pattern}:"
            val case_check = translate_case(case_check_trimmed, types)
            var case_if = case_check
            if case_if.ends_with("{"):
                case_if = case_if.substring(0, case_if.len() - 1).trim()
            # Check if body is an assignment (statement) vs expression
            val body_eq_pos = case_inline_body.index_of(" = ") ?? -1
            val body_is_assignment = body_eq_pos >= 0 and not case_inline_body.starts_with("\"")
            if body_is_assignment:
                # Translate as statement (not expression)
                val case_stmt_raw = translate_statement(case_inline_body, types)
                # Extract code part only (strip type annotations after |||)
                val case_sep = case_stmt_raw.index_of("|||") ?? -1
                var case_stmt_code = case_stmt_raw
                if case_sep >= 0:
                    case_stmt_code = case_stmt_raw.substring(0, case_sep)
                return "{case_if} {{ {case_stmt_code} }}"
            # Translate the body expression
            val case_body_c = translate_expr(case_inline_body, types)
            return "{case_if} {{ return {case_body_c}; }}"

    if trimmed == "break":
        return "break;"
    if trimmed == "continue":
        return "continue;"
    if trimmed == "pass" or trimmed == "()":
        return "/* pass */;"

    # Method calls as statements (e.g., arr.push("x"))
    val push_pos = trimmed.index_of(".push(") ?? -1
    if push_pos >= 0:
        val obj = trimmed.substring(0, push_pos).trim()
        val arg_start = push_pos + 6
        val arg_end = find_close_paren(trimmed, arg_start - 1)
        if arg_end >= 0:
            val arg = trimmed.substring(arg_start, arg_end)
            if is_string_array_var(obj, types):
                return "simple_string_push(&{obj}, {translate_expr(arg, types)});"
            if is_int_array_var(obj, types):
                return "simple_int_push(&{obj}, {translate_expr(arg, types)});"
            if is_str_arr_arr_var(obj, types):
                var push_arg = translate_expr(arg, types)
                if arg == "[]":
                    push_arg = "simple_new_string_array()"
                return "simple_string_array_push(&{obj}, {push_arg});"
            if is_int_arr_arr_var(obj, types):
                var push_arg = translate_expr(arg, types)
                if arg == "[]":
                    push_arg = "simple_new_int_array()"
                return "simple_int_array_push(&{obj}, {push_arg});"
            # Check struct array: arr.push(item)
            val sa_push_elem = is_struct_array_var(obj, types)
            if sa_push_elem != "":
                val c_arg = translate_expr(arg, types)
                return "{{ {sa_push_elem}* _e = malloc(sizeof({sa_push_elem})); *_e = {c_arg}; simple_struct_push(&{obj}, (void*)_e); }}"
            # Check struct field arrays: table.names.push(x)
            if is_struct_field_str_array(obj, types):
                return "simple_string_push(&{obj}, {translate_expr(arg, types)});"
            if is_struct_field_int_array(obj, types):
                return "simple_int_push(&{obj}, {translate_expr(arg, types)});"
            return "/* {trimmed} */;"

    # .pop() as statement
    if trimmed.ends_with(".pop()"):
        val obj = trimmed.substring(0, trimmed.len() - 6).trim()
        if is_string_array_var(obj, types):
            return "simple_string_pop(&{obj});"
        if is_int_array_var(obj, types):
            return "simple_int_pop(&{obj});"

    # Compound assignment
    val plus_eq = trimmed.index_of(" += ") ?? -1
    if plus_eq >= 0:
        val lhs = trimmed.substring(0, plus_eq).trim()
        val rhs = trimmed.substring(plus_eq + 4).trim()
        # String concatenation assignment
        if is_text_var(lhs, types):
            return "{lhs} = simple_str_concat({lhs}, {translate_expr(rhs, types)});"
        return "{lhs} += {translate_expr(rhs, types)};"
    val minus_eq = trimmed.index_of(" -= ") ?? -1
    if minus_eq >= 0:
        val lhs = trimmed.substring(0, minus_eq).trim()
        val rhs = trimmed.substring(minus_eq + 4).trim()
        return "{lhs} -= {translate_expr(rhs, types)};"
    val times_eq = trimmed.index_of(" *= ") ?? -1
    if times_eq >= 0:
        val lhs = trimmed.substring(0, times_eq).trim()
        val rhs = trimmed.substring(times_eq + 4).trim()
        return "{lhs} *= {translate_expr(rhs, types)};"
    val div_eq = trimmed.index_of(" /= ") ?? -1
    if div_eq >= 0:
        val lhs = trimmed.substring(0, div_eq).trim()
        val rhs = trimmed.substring(div_eq + 4).trim()
        return "{lhs} /= {translate_expr(rhs, types)};"

    # Variable assignment
    val eq_idx = trimmed.index_of(" = ") ?? -1
    if eq_idx >= 0:
        val lhs = trimmed.substring(0, eq_idx).trim()
        val rhs = trimmed.substring(eq_idx + 3).trim()

        # Dict indexing assignment: d[key] = value
        val lhs_bracket = lhs.index_of("[") ?? -1
        if lhs_bracket >= 0:
            val dict_name = lhs.substring(0, lhs_bracket).trim()
            if is_dict_var(dict_name, types):
                val lhs_close = lhs.index_of("]") ?? -1
                if lhs_close > lhs_bracket + 1:
                    val key_expr = lhs.substring(lhs_bracket + 1, lhs_close).trim()
                    val c_rhs = translate_expr(rhs, types)
                    val c_key = translate_expr(key_expr, types)
                    # Detect value type
                    val rhs_is_str = rhs.starts_with("\"")
                    val rhs_text = is_text_var(rhs, types)
                    if rhs_is_str or rhs_text:
                        return "simple_dict_set_str({dict_name}, {c_key}, {c_rhs});"
                    return "simple_dict_set_int({dict_name}, {c_key}, {c_rhs});"

        # Array element assignment: arr[idx] = value -> arr.items[idx] = value
        if lhs_bracket >= 0:
            val arr_name = lhs.substring(0, lhs_bracket).trim()
            val arr_is_int = is_int_array_var(arr_name, types)
            val arr_is_str = is_string_array_var(arr_name, types)
            val arr_is_iaa = is_int_arr_arr_var(arr_name, types)
            val arr_is_saa = is_str_arr_arr_var(arr_name, types)
            val arr_is_any = arr_is_int or arr_is_str or arr_is_iaa or arr_is_saa
            if arr_is_any:
                val lhs_close = lhs.index_of("]") ?? -1
                if lhs_close > lhs_bracket + 1:
                    val idx_expr = lhs.substring(lhs_bracket + 1, lhs_close).trim()
                    val c_idx = translate_expr(idx_expr, types)
                    val c_rhs = translate_expr(rhs, types)
                    return "{arr_name}.items[{c_idx}] = {c_rhs};"

        # Struct field assignment: obj.field = value
        val lhs_dot = lhs.index_of(".") ?? -1
        if lhs_dot >= 0:
            val lhs_obj = lhs.substring(0, lhs_dot).trim()
            val lhs_field = lhs.substring(lhs_dot + 1).trim()
            val lhs_class = is_struct_type_var(lhs_obj, types)
            if lhs_class != "":
                val c_rhs = translate_expr(rhs, types)
                return "{lhs_obj}.{lhs_field} = {c_rhs};"

        val no_space = not lhs.contains(" ")
        val no_paren = not lhs.starts_with("(")
        if no_space and no_paren:
            # Handle array reset: arr = []
            if rhs == "[]":
                if is_str_arr_arr_var(lhs, types):
                    return "{lhs} = simple_new_string_array_array();"
                if is_int_arr_arr_var(lhs, types):
                    return "{lhs} = simple_new_int_array_array();"
                if is_string_array_var(lhs, types):
                    return "{lhs} = simple_new_string_array();"
                if is_int_array_var(lhs, types):
                    return "{lhs} = simple_new_int_array();"
                if is_struct_array_var(lhs, types) != "":
                    return "{lhs} = simple_new_struct_array();"
                return "{lhs} = simple_new_int_array();"
            # Handle array concat: arr = arr + [elem] -> direct push (optimization)
            val rhs_concat_pos = rhs.index_of(" + [") ?? -1
            if rhs_concat_pos >= 0 and rhs.ends_with("]"):
                val arr_part = rhs.substring(0, rhs_concat_pos).trim()
                val concat_elem = rhs.substring(rhs_concat_pos + 4, rhs.len() - 1).trim()
                if arr_part == lhs:
                    val sa_concat_type = is_struct_array_var(lhs, types)
                    if sa_concat_type != "":
                        val c_concat_elem = translate_expr(concat_elem, types)
                        return "{{ {sa_concat_type}* _e = malloc(sizeof({sa_concat_type})); *_e = {c_concat_elem}; simple_struct_push(&{lhs}, (void*)_e); }}"
                    if is_int_array_var(lhs, types):
                        return "simple_int_push(&{lhs}, {translate_expr(concat_elem, types)});"
                    if is_string_array_var(lhs, types):
                        return "simple_string_push(&{lhs}, {translate_expr(concat_elem, types)});"
            val c_rhs = translate_expr(rhs, types)
            # Track if assigning a string to a var (e.g., name = "Alice")
            val rhs_is_str = rhs.starts_with("\"")
            val rhs_is_text = c_rhs.contains("simple_")
            if rhs_is_str or rhs_is_text:
                return "{lhs} = {c_rhs};|||;text:{lhs};"
            return "{lhs} = {c_rhs};"

    # While loop
    if trimmed.starts_with("while ") and trimmed.ends_with(":"):
        val cond = trimmed.substring(6, trimmed.len() - 1).trim()
        return "while ({translate_condition(cond, types)}) {"

    # Function call as statement - detect BEFORE comparison/logic check
    # to avoid treating comparison operators inside function arguments as bare comparisons
    # e.g., check_eq_bool("5 > 3", 5 > 3, true) should NOT be treated as a comparison
    val paren_pos = trimmed.index_of("(") ?? -1
    if paren_pos >= 0 and trimmed.ends_with(")"):
        val fn_part = trimmed.substring(0, paren_pos).trim()
        # If the part before ( is a simple name (no spaces = no operators), it's a function call
        val fn_has_space = fn_part.contains(" ")
        if not fn_has_space and fn_part.len() > 0:
            return "{translate_expr(trimmed, types)};"

    # Bare expression as implicit return (e.g., last line of function body)
    # Handle comparison/logical expressions: a == b, a and b, a or b, etc.
    val has_cmp = trimmed.contains(" == ") or trimmed.contains(" != ") or trimmed.contains(" < ") or trimmed.contains(" > ") or trimmed.contains(" <= ") or trimmed.contains(" >= ")
    val has_logic = trimmed.contains(" and ") or trimmed.contains(" or ") or trimmed.starts_with("not ")
    if has_cmp or has_logic:
        return "return {translate_condition(trimmed, types)};"

    val c_expr = translate_expr(trimmed, types)
    if c_expr != trimmed:
        # Expression was translated to something different - use as return
        return "return {c_expr};"
    # Simple variable reference or literal - implicit return
    val is_simple_var = not trimmed.contains(" ")
    val is_bracket = trimmed.contains("[")
    val is_dot = trimmed.contains(".")
    if is_simple_var or is_bracket or is_dot:
        return "return {c_expr};"
    # Arithmetic expressions with spaces (e.g., "a + b", "-1")
    val is_arith = trimmed.contains(" + ") or trimmed.contains(" - ") or trimmed.contains(" * ") or trimmed.contains(" / ") or trimmed.starts_with("-")
    if is_arith:
        return "return {c_expr};"
    "/* unsupported: {trimmed} */"

# Close unclosed braces by tracking indentation levels
fn close_blocks(body_lines: [text]) -> [text]:
    var result: [text] = []
    var brace_indents: [i64] = []

    for idx in range(0, body_lines.len()):
        val line = body_lines[idx]
        val trimmed = line.trim()
        val current_indent = get_c_indent(line)

        # Don't let comments trigger block closing
        if trimmed.starts_with("//") or trimmed.starts_with("/*"):
            result.push(line)
            continue

        if trimmed.starts_with("} else"):
            # Close any nested blocks at higher indent before the else
            var else_close = 0
            for ebi in range(0, brace_indents.len()):
                val esi = brace_indents.len() - 1 - ebi
                if esi < 0:
                    break
                if brace_indents[esi] > current_indent:
                    else_close = else_close + 1
                else:
                    break
            for eci in range(0, else_close):
                val epi = brace_indents.len() - 1
                val eclose_indent = brace_indents[epi]
                brace_indents.pop()
                var epad = ""
                for epi2 in range(0, eclose_indent):
                    epad = epad + "    "
                result.push("{epad}}")
            result.push(line)
            continue

        var close_count = 0
        for bi in range(0, brace_indents.len()):
            val stack_idx = brace_indents.len() - 1 - bi
            if stack_idx < 0:
                break
            if current_indent <= brace_indents[stack_idx]:
                close_count = close_count + 1
            else:
                break

        for ci in range(0, close_count):
            val pop_idx = brace_indents.len() - 1
            val close_indent = brace_indents[pop_idx]
            brace_indents.pop()
            var close_padding = ""
            for pi in range(0, close_indent):
                close_padding = close_padding + "    "
            result.push("{close_padding}}")

        result.push(line)

        if trimmed.ends_with("{"):
            brace_indents.push(current_indent)
        elif trimmed.contains(") {") and not trimmed.ends_with("}"):
            # Inline opening brace (e.g., for-loop with inline body start)
            brace_indents.push(current_indent)
        elif trimmed.starts_with("{") and not trimmed.ends_with("}"):
            # Match block opening: { long long _match_val = ...;
            brace_indents.push(current_indent)

    for ci in range(0, brace_indents.len()):
        val pop_idx = brace_indents.len() - 1 - ci
        val close_indent = brace_indents[pop_idx]
        var close_padding = ""
        for pi in range(0, close_indent):
            close_padding = close_padding + "    "
        result.push("{close_padding}}")

    result

# Build a C function definition
fn build_function(name: text, sig: text, body_lines: [text]) -> text:
    val closed_lines = close_blocks(body_lines)
    # Check if the function has a non-void return type
    val is_void_fn = sig.starts_with("void ")
    # Find the last meaningful statement line (not a closing brace)
    var last_stmt_idx = -1
    if not is_void_fn:
        for li in range(0, closed_lines.len()):
            val check_idx = closed_lines.len() - 1 - li
            if check_idx < 0:
                break
            val check_line = closed_lines[check_idx].trim()
            if check_line == "}":
                continue
            if check_line == "":
                continue
            if check_line.starts_with("//"):
                continue
            if check_line.starts_with("/*"):
                continue
            last_stmt_idx = check_idx
            break

    # Deduplicate variable declarations: if a name is declared multiple times
    # (e.g., in different branches), convert subsequent declarations to assignments
    # Scope-aware: track indent level of each declaration so that variables in
    # sibling scopes (e.g., two if-blocks at the same indent) are not deduped
    var declared_vars: [text] = []
    var declared_indents: [i64] = []
    var deduped_lines: [text] = []
    val c_types_arr: [text] = ["const char* ", "long long ", "int ", "double ", "SimpleStringArray ", "SimpleIntArray ", "SimpleStringArrayArray ", "SimpleIntArrayArray ", "SimpleStructArray ", "SimpleDict* ", "SimpleOption "]
    for dl_idx in range(0, closed_lines.len()):
        val dl = closed_lines[dl_idx]
        val dl_trim = dl.trim()
        val dl_c_indent = get_c_indent(dl)
        # Scope cleanup: remove vars declared at indent > current indent
        # (they went out of scope when their block's } was processed)
        var scope_new_vars: [text] = []
        var scope_new_indents: [i64] = []
        for scope_vi in range(0, declared_vars.len()):
            if declared_indents[scope_vi] <= dl_c_indent:
                scope_new_vars.push(declared_vars[scope_vi])
                scope_new_indents.push(declared_indents[scope_vi])
        declared_vars = scope_new_vars
        declared_indents = scope_new_indents
        # Check if this line is a C variable declaration
        var found_type = ""
        var found_name = ""
        for ct in c_types_arr:
            if dl_trim.starts_with(ct) and dl_trim.contains(" = "):
                val after_type = dl_trim.substring(ct.len())
                val eq_pos = after_type.index_of(" = ") ?? -1
                if eq_pos >= 0:
                    found_type = ct
                    found_name = after_type.substring(0, eq_pos).trim()
                    break
        # Also check struct declarations: StructName varname = ...
        if found_type == "" and dl_trim.contains(" = ") and not dl_trim.starts_with("if ") and not dl_trim.starts_with("for ") and not dl_trim.starts_with("return ") and not dl_trim.starts_with("//") and not dl_trim.starts_with("/*"):
            val space_pos = dl_trim.index_of(" ") ?? -1
            if space_pos >= 0:
                val first_word = dl_trim.substring(0, space_pos)
                val fw_first = first_word[0]
                val fw_upper = fw_first >= "A" and fw_first <= "Z"
                if fw_upper and not first_word.starts_with("Simple"):
                    val after_struct = dl_trim.substring(space_pos + 1)
                    val eq_pos = after_struct.index_of(" = ") ?? -1
                    if eq_pos >= 0:
                        found_type = first_word + " "
                        found_name = after_struct.substring(0, eq_pos).trim()
        if found_name != "":
            # Check if already declared (only vars still in scope)
            var already = false
            for dv in declared_vars:
                if dv == found_name:
                    already = true
                    break
            if already:
                # Replace declaration with assignment: strip the type prefix
                val dl_indent = dl.substring(0, dl.len() - dl_trim.len())
                val assignment = dl_trim.substring(found_type.len())
                deduped_lines.push("{dl_indent}{assignment}")
            else:
                declared_vars.push(found_name)
                declared_indents.push(dl_c_indent)
                deduped_lines.push(dl)
        else:
            deduped_lines.push(dl)

    var result = "{sig} {{NL}"
    for line_idx in range(0, deduped_lines.len()):
        val body_line = deduped_lines[line_idx]
        if line_idx == last_stmt_idx:
            val bl_trimmed = body_line.trim()
            # Add return if the last statement doesn't have one
            val has_ret = bl_trimmed.starts_with("return ")
            val is_control = bl_trimmed.starts_with("if ") or bl_trimmed.starts_with("} else") or bl_trimmed.starts_with("for ") or bl_trimmed.starts_with("while ")
            val is_comment = bl_trimmed.starts_with("//") or bl_trimmed.starts_with("/*")
            if not has_ret and not is_control and not is_comment:
                # Remove the trailing semicolon, wrap with return
                var stmt = bl_trimmed
                if stmt.ends_with(";"):
                    stmt = stmt.substring(0, stmt.len() - 1)
                val indent = body_line.substring(0, body_line.len() - bl_trimmed.len())
                result = result + "{indent}return {stmt};{NL}"
                continue
        result = result + body_line + NL
    result = result + "}"
    result

export translate_condition, translate_method_expr, translate_expr
export translate_interpolated_print, translate_print
export translate_array_decl, translate_var_decl
export translate_for_loop, translate_case, translate_statement
export close_blocks, build_function
