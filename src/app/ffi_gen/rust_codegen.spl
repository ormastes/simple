# FFI Wrapper Generator - Rust Code Generation
#
# Generates Rust source code (lib.rs) with extern "C" wrappers
# for @Lib(lang: "rust") annotated extern classes.

use app.ffi_gen.parser*
use app.ffi_gen.type_mapping*
use std.text.{NL}

# ============================================================================
# Code Generation
# ============================================================================

# Generate complete lib.rs content for a set of Rust library specs
fn generate_rust_code(specs: [LibExternSpec]) -> text:
    var out = ""
    out = out + "// Auto-generated by Simple FFI wrapper generator{NL}"
    out = out + "// Do not edit manually.{NL}{NL}"

    # Collect unique crate imports
    var crate_imports: [text] = []
    for spec in specs:
        val import_line = "use {spec.lib_name};"
        if not crate_imports.contains(import_line):
            crate_imports.push(import_line)

    for imp in crate_imports:
        out = out + "{imp}{NL}"
    out = out + NL

    # Generate FfiString helper for string returns
    out = out + generate_ffi_string_helper()
    out = out + NL

    # Generate wrappers for each extern class
    for spec in specs:
        out = out + generate_class_wrappers(spec)
        out = out + NL

    out

# ============================================================================
# FfiString Helper
# ============================================================================

fn generate_ffi_string_helper() -> text:
    var out = ""
    out = out + "/// FFI-safe string representation{NL}"
    out = out + "#[repr(C)]{NL}"
    out = out + "pub struct FfiString {{NL}"
    out = out + "    pub ptr: *const u8,{NL}"
    out = out + "    pub len: u64,{NL}"
    out = out + "}{NL}{NL}"
    out = out + "impl FfiString {{NL}"
    out = out + "    fn from_string(s: String) -> Self {{NL}"
    out = out + "        let len = s.len() as u64;{NL}"
    out = out + "        let ptr = s.as_ptr();{NL}"
    out = out + "        std::mem::forget(s);{NL}"
    out = out + "        FfiString { ptr, len }{NL}"
    out = out + "    }{NL}"
    out = out + "}{NL}"
    out

# ============================================================================
# Per-Class Wrapper Generation
# ============================================================================

fn generate_class_wrappers(spec: LibExternSpec) -> text:
    var out = ""
    val cls = spec.class_name
    val rust_type = "{spec.lib_name}::{cls}"

    out = out + "// ---- {cls} wrappers ({spec.lib_name}) ----{NL}{NL}"

    # Generate destroy function
    out = out + generate_destroy(cls, rust_type)

    # Generate method wrappers
    for method in spec.methods:
        match method.kind:
            case "static":
                out = out + generate_static_method(cls, rust_type, method)
            case "immutable":
                out = out + generate_immutable_method(cls, rust_type, method)
            case "mutable":
                out = out + generate_mutable_method(cls, rust_type, method)
            case _:
                ()

    out

# ============================================================================
# Destroy Function
# ============================================================================

fn generate_destroy(cls: text, rust_type: text) -> text:
    var out = ""
    out = out + "#[no_mangle]{NL}"
    out = out + "pub unsafe extern \"C\" fn {cls}_destroy(ptr: *mut {rust_type}) {{{NL}"
    out = out + "    if !ptr.is_null() {{{NL}"
    out = out + "        drop(Box::from_raw(ptr));{NL}"
    out = out + "    }}{NL}"
    out = out + "}}{NL}{NL}"
    out

# ============================================================================
# Static Method Wrappers
# ============================================================================

fn generate_static_method(cls: text, rust_type: text, method: ExternMethodSpec) -> text:
    var out = ""
    val fn_name = "{cls}_{method.name}"

    # Build C parameter list
    val c_params = build_c_params(method.params)
    val ret_type = return_c_type(method.return_type)

    out = out + "#[no_mangle]{NL}"
    out = out + "pub unsafe extern \"C\" fn {fn_name}({c_params}) -> {ret_type} {{{NL}"

    # Generate parameter conversions
    out = out + generate_param_conversions(method.params)

    # Generate call
    val call_args = build_rust_call_args(method.params)
    val returns_object = is_object_handle(method.return_type)
    val returns_string = is_string(method.return_type)
    val returns_bool = method.return_type == "bool"

    if returns_object:
        out = out + "    let result = {rust_type}::{method.name}({call_args});{NL}"
        out = out + "    Box::into_raw(Box::new(result)){NL}"
    elif returns_string:
        out = out + "    let result = {rust_type}::{method.name}({call_args});{NL}"
        out = out + "    FfiString::from_string(result.to_string()){NL}"
    elif returns_bool:
        out = out + "    let result = {rust_type}::{method.name}({call_args});{NL}"
        out = out + "    result as u8{NL}"
    else:
        out = out + "    {rust_type}::{method.name}({call_args}){NL}"

    out = out + "}}{NL}{NL}"
    out

# ============================================================================
# Immutable Method Wrappers
# ============================================================================

fn generate_immutable_method(cls: text, rust_type: text, method: ExternMethodSpec) -> text:
    var out = ""
    val fn_name = "{cls}_{method.name}"

    # self pointer + other params
    val c_params = "ptr: *const {rust_type}"
    val extra_params = build_c_params(method.params)
    val full_params = if extra_params != "": "{c_params}, {extra_params}" else: c_params
    val ret_type = return_c_type(method.return_type)

    out = out + "#[no_mangle]{NL}"
    out = out + "pub unsafe extern \"C\" fn {fn_name}({full_params}) -> {ret_type} {{{NL}"
    out = out + "    let this = &*ptr;{NL}"

    # Generate parameter conversions
    out = out + generate_param_conversions(method.params)

    # Generate call
    val call_args = build_rust_call_args(method.params)
    val returns_object = is_object_handle(method.return_type)
    val returns_string = is_string(method.return_type)
    val returns_bool = method.return_type == "bool"

    if returns_object:
        out = out + "    let result = this.{method.name}({call_args});{NL}"
        out = out + "    Box::into_raw(Box::new(result)){NL}"
    elif returns_string:
        out = out + "    let result = this.{method.name}({call_args});{NL}"
        out = out + "    FfiString::from_string(result.to_string()){NL}"
    elif returns_bool:
        out = out + "    let result = this.{method.name}({call_args});{NL}"
        out = out + "    result as u8{NL}"
    elif method.return_type == "" or method.return_type == "()":
        out = out + "    this.{method.name}({call_args});{NL}"
    else:
        out = out + "    this.{method.name}({call_args}){NL}"

    out = out + "}}{NL}{NL}"
    out

# ============================================================================
# Mutable Method Wrappers
# ============================================================================

fn generate_mutable_method(cls: text, rust_type: text, method: ExternMethodSpec) -> text:
    var out = ""
    val fn_name = "{cls}_{method.name}"

    val c_params = "ptr: *mut {rust_type}"
    val extra_params = build_c_params(method.params)
    val full_params = if extra_params != "": "{c_params}, {extra_params}" else: c_params
    val ret_type = return_c_type(method.return_type)

    out = out + "#[no_mangle]{NL}"
    out = out + "pub unsafe extern \"C\" fn {fn_name}({full_params}) -> {ret_type} {{{NL}"
    out = out + "    let this = &mut *ptr;{NL}"

    out = out + generate_param_conversions(method.params)

    val call_args = build_rust_call_args(method.params)
    val returns_object = is_object_handle(method.return_type)
    val returns_string = is_string(method.return_type)
    val returns_bool = method.return_type == "bool"

    if returns_object:
        out = out + "    let result = this.{method.name}({call_args});{NL}"
        out = out + "    Box::into_raw(Box::new(result)){NL}"
    elif returns_string:
        out = out + "    let result = this.{method.name}({call_args});{NL}"
        out = out + "    FfiString::from_string(result.to_string()){NL}"
    elif returns_bool:
        out = out + "    let result = this.{method.name}({call_args});{NL}"
        out = out + "    result as u8{NL}"
    elif method.return_type == "" or method.return_type == "()":
        out = out + "    this.{method.name}({call_args});{NL}"
    else:
        out = out + "    this.{method.name}({call_args}){NL}"

    out = out + "}}{NL}{NL}"
    out

# ============================================================================
# Parameter Helpers
# ============================================================================

# Build C ABI parameter list string
fn build_c_params(params: [ParamSpec]) -> text:
    var parts: [text] = []
    for param in params:
        if is_string(param.type_name):
            parts.push("{param.name}_ptr: *const u8, {param.name}_len: u64")
        elif is_object_handle(param.type_name):
            val rust_type = simple_to_rust(param.type_name)
            parts.push("{param.name}: *const {rust_type}")
        elif param.type_name == "bool":
            parts.push("{param.name}: u8")
        else:
            val rust_type = simple_to_rust(param.type_name)
            parts.push("{param.name}: {rust_type}")

    parts.join(", ")

# Generate Rust code to convert C ABI params to Rust types
fn generate_param_conversions(params: [ParamSpec]) -> text:
    var out = ""
    for param in params:
        if is_string(param.type_name):
            out = out + "    let {param.name} = std::str::from_utf8_unchecked({NL}"
            out = out + "        std::slice::from_raw_parts({param.name}_ptr, {param.name}_len as usize){NL}"
            out = out + "    );{NL}"
        elif is_object_handle(param.type_name):
            out = out + "    let {param.name} = &*{param.name};{NL}"
        elif param.type_name == "bool":
            out = out + "    let {param.name} = {param.name} != 0;{NL}"
    out

# Build Rust call argument list (converted names)
fn build_rust_call_args(params: [ParamSpec]) -> text:
    var parts: [text] = []
    for param in params:
        parts.push(param.name)
    parts.join(", ")
