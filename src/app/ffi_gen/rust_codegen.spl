# FFI Wrapper Generator - Rust Code Generation
#
# Generates Rust source code (lib.rs) with extern "C" wrappers
# for @Lib(lang: "rust") annotated extern classes.

import parser
import type_mapping

# ============================================================================
# Code Generation
# ============================================================================

# Generate complete lib.rs content for a set of Rust library specs
fn generate_rust_code(specs: [parser.LibExternSpec]) -> text:
    var out = ""
    out = out + "// Auto-generated by Simple FFI wrapper generator\n"
    out = out + "// Do not edit manually.\n\n"

    # Collect unique crate imports
    var crate_imports: [text] = []
    for spec in specs:
        val import_line = "use {spec.lib_name};"
        if not crate_imports.contains(import_line):
            crate_imports.push(import_line)

    for imp in crate_imports:
        out = out + "{imp}\n"
    out = out + "\n"

    # Generate FfiString helper for string returns
    out = out + generate_ffi_string_helper()
    out = out + "\n"

    # Generate wrappers for each extern class
    for spec in specs:
        out = out + generate_class_wrappers(spec)
        out = out + "\n"

    out

# ============================================================================
# FfiString Helper
# ============================================================================

fn generate_ffi_string_helper() -> text:
    var out = ""
    out = out + "/// FFI-safe string representation\n"
    out = out + "#[repr(C)]\n"
    out = out + "pub struct FfiString {\n"
    out = out + "    pub ptr: *const u8,\n"
    out = out + "    pub len: u64,\n"
    out = out + "}\n\n"
    out = out + "impl FfiString {\n"
    out = out + "    fn from_string(s: String) -> Self {\n"
    out = out + "        let len = s.len() as u64;\n"
    out = out + "        let ptr = s.as_ptr();\n"
    out = out + "        std::mem::forget(s);\n"
    out = out + "        FfiString { ptr, len }\n"
    out = out + "    }\n"
    out = out + "}\n"
    out

# ============================================================================
# Per-Class Wrapper Generation
# ============================================================================

fn generate_class_wrappers(spec: parser.LibExternSpec) -> text:
    var out = ""
    val cls = spec.class_name
    val rust_type = "{spec.lib_name}::{cls}"

    out = out + "// ---- {cls} wrappers ({spec.lib_name}) ----\n\n"

    # Generate destroy function
    out = out + generate_destroy(cls, rust_type)

    # Generate method wrappers
    for method in spec.methods:
        match method.kind:
            case "static":
                out = out + generate_static_method(cls, rust_type, method)
            case "immutable":
                out = out + generate_immutable_method(cls, rust_type, method)
            case "mutable":
                out = out + generate_mutable_method(cls, rust_type, method)
            case _:
                ()

    out

# ============================================================================
# Destroy Function
# ============================================================================

fn generate_destroy(cls: text, rust_type: text) -> text:
    var out = ""
    out = out + "#[no_mangle]\n"
    out = out + "pub unsafe extern \"C\" fn {cls}_destroy(ptr: *mut {rust_type}) {{\n"
    out = out + "    if !ptr.is_null() {{\n"
    out = out + "        drop(Box::from_raw(ptr));\n"
    out = out + "    }}\n"
    out = out + "}}\n\n"
    out

# ============================================================================
# Static Method Wrappers
# ============================================================================

fn generate_static_method(cls: text, rust_type: text, method: parser.ExternMethodSpec) -> text:
    var out = ""
    val fn_name = "{cls}_{method.name}"

    # Build C parameter list
    val c_params = build_c_params(method.params)
    val ret_type = type_mapping.return_c_type(method.return_type)

    out = out + "#[no_mangle]\n"
    out = out + "pub unsafe extern \"C\" fn {fn_name}({c_params}) -> {ret_type} {{\n"

    # Generate parameter conversions
    out = out + generate_param_conversions(method.params)

    # Generate call
    val call_args = build_rust_call_args(method.params)
    val returns_object = type_mapping.is_object_handle(method.return_type)
    val returns_string = type_mapping.is_string(method.return_type)
    val returns_bool = method.return_type == "bool"

    if returns_object:
        out = out + "    let result = {rust_type}::{method.name}({call_args});\n"
        out = out + "    Box::into_raw(Box::new(result))\n"
    elif returns_string:
        out = out + "    let result = {rust_type}::{method.name}({call_args});\n"
        out = out + "    FfiString::from_string(result.to_string())\n"
    elif returns_bool:
        out = out + "    let result = {rust_type}::{method.name}({call_args});\n"
        out = out + "    result as u8\n"
    else:
        out = out + "    {rust_type}::{method.name}({call_args})\n"

    out = out + "}}\n\n"
    out

# ============================================================================
# Immutable Method Wrappers
# ============================================================================

fn generate_immutable_method(cls: text, rust_type: text, method: parser.ExternMethodSpec) -> text:
    var out = ""
    val fn_name = "{cls}_{method.name}"

    # self pointer + other params
    val c_params = "ptr: *const {rust_type}"
    val extra_params = build_c_params(method.params)
    val full_params = if extra_params != "": "{c_params}, {extra_params}" else: c_params
    val ret_type = type_mapping.return_c_type(method.return_type)

    out = out + "#[no_mangle]\n"
    out = out + "pub unsafe extern \"C\" fn {fn_name}({full_params}) -> {ret_type} {{\n"
    out = out + "    let this = &*ptr;\n"

    # Generate parameter conversions
    out = out + generate_param_conversions(method.params)

    # Generate call
    val call_args = build_rust_call_args(method.params)
    val returns_object = type_mapping.is_object_handle(method.return_type)
    val returns_string = type_mapping.is_string(method.return_type)
    val returns_bool = method.return_type == "bool"

    if returns_object:
        out = out + "    let result = this.{method.name}({call_args});\n"
        out = out + "    Box::into_raw(Box::new(result))\n"
    elif returns_string:
        out = out + "    let result = this.{method.name}({call_args});\n"
        out = out + "    FfiString::from_string(result.to_string())\n"
    elif returns_bool:
        out = out + "    let result = this.{method.name}({call_args});\n"
        out = out + "    result as u8\n"
    elif method.return_type == "" or method.return_type == "()":
        out = out + "    this.{method.name}({call_args});\n"
    else:
        out = out + "    this.{method.name}({call_args})\n"

    out = out + "}}\n\n"
    out

# ============================================================================
# Mutable Method Wrappers
# ============================================================================

fn generate_mutable_method(cls: text, rust_type: text, method: parser.ExternMethodSpec) -> text:
    var out = ""
    val fn_name = "{cls}_{method.name}"

    val c_params = "ptr: *mut {rust_type}"
    val extra_params = build_c_params(method.params)
    val full_params = if extra_params != "": "{c_params}, {extra_params}" else: c_params
    val ret_type = type_mapping.return_c_type(method.return_type)

    out = out + "#[no_mangle]\n"
    out = out + "pub unsafe extern \"C\" fn {fn_name}({full_params}) -> {ret_type} {{\n"
    out = out + "    let this = &mut *ptr;\n"

    out = out + generate_param_conversions(method.params)

    val call_args = build_rust_call_args(method.params)
    val returns_object = type_mapping.is_object_handle(method.return_type)
    val returns_string = type_mapping.is_string(method.return_type)
    val returns_bool = method.return_type == "bool"

    if returns_object:
        out = out + "    let result = this.{method.name}({call_args});\n"
        out = out + "    Box::into_raw(Box::new(result))\n"
    elif returns_string:
        out = out + "    let result = this.{method.name}({call_args});\n"
        out = out + "    FfiString::from_string(result.to_string())\n"
    elif returns_bool:
        out = out + "    let result = this.{method.name}({call_args});\n"
        out = out + "    result as u8\n"
    elif method.return_type == "" or method.return_type == "()":
        out = out + "    this.{method.name}({call_args});\n"
    else:
        out = out + "    this.{method.name}({call_args})\n"

    out = out + "}}\n\n"
    out

# ============================================================================
# Parameter Helpers
# ============================================================================

# Build C ABI parameter list string
fn build_c_params(params: [parser.ParamSpec]) -> text:
    var parts: [text] = []
    for param in params:
        if type_mapping.is_string(param.type_name):
            parts.push("{param.name}_ptr: *const u8, {param.name}_len: u64")
        elif type_mapping.is_object_handle(param.type_name):
            val rust_type = type_mapping.simple_to_rust(param.type_name)
            parts.push("{param.name}: *const {rust_type}")
        elif param.type_name == "bool":
            parts.push("{param.name}: u8")
        else:
            val rust_type = type_mapping.simple_to_rust(param.type_name)
            parts.push("{param.name}: {rust_type}")

    parts.join(", ")

# Generate Rust code to convert C ABI params to Rust types
fn generate_param_conversions(params: [parser.ParamSpec]) -> text:
    var out = ""
    for param in params:
        if type_mapping.is_string(param.type_name):
            out = out + "    let {param.name} = std::str::from_utf8_unchecked(\n"
            out = out + "        std::slice::from_raw_parts({param.name}_ptr, {param.name}_len as usize)\n"
            out = out + "    );\n"
        elif type_mapping.is_object_handle(param.type_name):
            out = out + "    let {param.name} = &*{param.name};\n"
        elif param.type_name == "bool":
            out = out + "    let {param.name} = {param.name} != 0;\n"
    out

# Build Rust call argument list (converted names)
fn build_rust_call_args(params: [parser.ParamSpec]) -> text:
    var parts: [text] = []
    for param in params:
        parts.push(param.name)
    parts.join(", ")
