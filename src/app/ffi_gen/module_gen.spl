# FFI Wrapper Generator - Complete Module Code Generation
#
# Generates complete Rust .rs files from ModuleSpec by combining
# imports, types, impl blocks, functions, and tests.
#
# Usage:
#   import app.ffi_gen.module_gen (generate_module_source)

use app.ffi_gen.types*
use app.ffi_gen.enum_gen (generate_enum)
use app.ffi_gen.struct_gen (generate_struct)
use app.ffi_gen.impl_gen (generate_impl)
use app.ffi_gen.fn_gen (generate_ffi_fn)
use app.ffi_gen.test_gen (generate_test_module)

# ============================================================================
# Module Generation
# ============================================================================

# Generate complete Rust module source from ModuleSpec
fn generate_module_source(spec: ModuleSpec) -> text:
    var out = ""

    # Module doc comment
    if spec.doc != "":
        out = out + "//! {spec.name} module\n"
        out = out + "//!\n"
        for line in spec.doc.split("\n"):
            out = out + "//! {line}\n"
        out = out + "\n"
    else:
        out = out + "//! Auto-generated module: {spec.name}\n"
        out = out + "//!\n"
        out = out + "//! Generated by: simple ffi-gen --gen-module\n"
        out = out + "//! Do not edit manually.\n"
        out = out + "\n"

    # Imports
    if spec.imports.len() > 0:
        out = out + generate_imports(spec.imports)
        out = out + "\n"

    # Raw code (constants, statics, type aliases)
    if spec.raw_code != "":
        out = out + spec.raw_code
        out = out + "\n"

    # Type definitions
    for type_spec in spec.types:
        if type_spec.kind == "enum":
            out = out + generate_enum(type_spec.enum_spec)
        elif type_spec.kind == "struct":
            out = out + generate_struct(type_spec.struct_spec)
        out = out + "\n"

    # Impl blocks
    for impl_spec in spec.impls:
        out = out + generate_impl(impl_spec)
        out = out + "\n"

    # Section comment for FFI functions
    if spec.functions.len() > 0:
        out = out + "// " + "=".repeat(78) + "\n"
        out = out + "// FFI Functions\n"
        out = out + "// " + "=".repeat(78) + "\n"
        out = out + "\n"

    # FFI functions
    for fn_spec in spec.functions:
        out = out + generate_ffi_fn(fn_spec)
        out = out + "\n"

    # Tests
    if spec.tests.len() > 0:
        out = out + generate_test_module(spec.tests)

    out

# Generate import statements
fn generate_imports(imports: [ImportSpec]) -> text:
    var out = ""
    for imp in imports:
        out = out + generate_import(imp)
    out

# Generate a single import statement
fn generate_import(imp: ImportSpec) -> text:
    if imp.glob:
        "use {imp.path}::*;\n"
    elif imp.items.len() > 0:
        if imp.items.len() == 1:
            "use {imp.path}::{imp.items[0]};\n"
        else:
            "use {imp.path}::{{{imp.items.join(\", \")}}};\n"
    elif imp.alias != "":
        "use {imp.path} as {imp.alias};\n"
    else:
        "use {imp.path};\n"

# ============================================================================
# Module Builder (Fluent API)
# ============================================================================

# Helper class for building ModuleSpec incrementally
# Note: Uses functional style - each method returns new builder with updated spec
class ModuleBuilder:
    spec: ModuleSpec

    static fn start(name: text) -> ModuleBuilder:
        ModuleBuilder(spec: ModuleSpec.empty(name))

    fn doc(new_doc: text) -> ModuleBuilder:
        var new_spec = self.spec
        new_spec.doc = new_doc
        ModuleBuilder(spec: new_spec)

    fn add_import(path: text) -> ModuleBuilder:
        var new_spec = self.spec
        new_spec.imports.push(ImportSpec.simple(path))
        ModuleBuilder(spec: new_spec)

    fn add_import_items(path: text, items: [text]) -> ModuleBuilder:
        var new_spec = self.spec
        new_spec.imports.push(ImportSpec.with_items(path, items))
        ModuleBuilder(spec: new_spec)

    fn add_enum(enum_spec: EnumSpec) -> ModuleBuilder:
        var new_spec = self.spec
        new_spec.types.push(RustTypeSpec.enum_type(enum_spec))
        ModuleBuilder(spec: new_spec)

    fn add_struct(struct_spec: StructSpec) -> ModuleBuilder:
        var new_spec = self.spec
        new_spec.types.push(RustTypeSpec.struct_type(struct_spec))
        ModuleBuilder(spec: new_spec)

    fn add_impl(impl_spec: ImplSpec) -> ModuleBuilder:
        var new_spec = self.spec
        new_spec.impls.push(impl_spec)
        ModuleBuilder(spec: new_spec)

    fn add_fn(fn_spec: FFIFnSpec) -> ModuleBuilder:
        var new_spec = self.spec
        new_spec.functions.push(fn_spec)
        ModuleBuilder(spec: new_spec)

    fn add_test(test_spec: TestSpec) -> ModuleBuilder:
        var new_spec = self.spec
        new_spec.tests.push(test_spec)
        ModuleBuilder(spec: new_spec)

    fn add_raw(code: text) -> ModuleBuilder:
        var new_spec = self.spec
        new_spec.raw_code = new_spec.raw_code + code + "\n"
        ModuleBuilder(spec: new_spec)

    fn build() -> ModuleSpec:
        self.spec

    fn generate() -> text:
        generate_module_source(self.spec)

# ============================================================================
# Section Helpers
# ============================================================================

# Generate a section comment
fn section_comment(title: text) -> text:
    var out = "// " + "=".repeat(78) + "\n"
    out = out + "// {title}\n"
    out = out + "// " + "=".repeat(78) + "\n"
    out
