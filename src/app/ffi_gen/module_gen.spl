# FFI Wrapper Generator - Complete Module Code Generation
#
# Generates complete Rust .rs files from ModuleSpec by combining
# imports, types, impl blocks, functions, and tests.
#
# Usage:
#   import app.ffi_gen.module_gen (generate_module_source)

use app.ffi_gen.types*
use app.ffi_gen.enum_gen (generate_enum)
use app.ffi_gen.struct_gen (generate_struct)
use app.ffi_gen.impl_gen (generate_impl)
use app.ffi_gen.fn_gen (generate_ffi_fn)
use app.ffi_gen.test_gen (generate_test_module)
use std.text.{NL}

# ============================================================================
# Module Generation
# ============================================================================

# Generate complete Rust module source from ModuleSpec
fn generate_module_source(spec: ModuleSpec) -> text:
    var out = ""

    # Module doc comment
    if spec.doc != "":
        out = out + "//! {spec.name} module{NL}"
        out = out + "//!{NL}"
        for line in spec.doc.split(NL):
            out = out + "//! {line}{NL}"
        out = out + NL
    else:
        out = out + "//! Auto-generated module: {spec.name}{NL}"
        out = out + "//!{NL}"
        out = out + "//! Generated by: simple ffi-gen --gen-module{NL}"
        out = out + "//! Do not edit manually.{NL}"
        out = out + NL

    # Imports
    if spec.imports.len() > 0:
        out = out + generate_imports(spec.imports)
        out = out + NL

    # Raw code (constants, statics, type aliases)
    if spec.raw_code != "":
        out = out + spec.raw_code
        out = out + NL

    # Type definitions
    for type_spec in spec.types:
        if type_spec.kind == "enum":
            out = out + generate_enum(type_spec.enum_spec)
        elif type_spec.kind == "struct":
            out = out + generate_struct(type_spec.struct_spec)
        out = out + NL

    # Impl blocks
    for impl_spec in spec.impls:
        out = out + generate_impl(impl_spec)
        out = out + NL

    # Section comment for FFI functions
    if spec.functions.len() > 0:
        out = out + "// " + "=".repeat(78) + NL
        out = out + "// FFI Functions{NL}"
        out = out + "// " + "=".repeat(78) + NL
        out = out + NL

    # FFI functions
    for fn_spec in spec.functions:
        out = out + generate_ffi_fn(fn_spec)
        out = out + NL

    # Tests
    if spec.tests.len() > 0:
        out = out + generate_test_module(spec.tests)

    out

# Generate import statements
fn generate_imports(imports: [ImportSpec]) -> text:
    var out = ""
    for imp in imports:
        out = out + generate_import(imp)
    out

# Generate a single import statement
fn generate_import(imp: ImportSpec) -> text:
    if imp.glob:
        "use {imp.path}::*;{NL}"
    elif imp.items.len() > 0:
        if imp.items.len() == 1:
            "use {imp.path}::{imp.items[0]};{NL}"
        else:
            "use {imp.path}::{{{imp.items.join(\", \")}}};{NL}"
    elif imp.alias != "":
        "use {imp.path} as {imp.alias};{NL}"
    else:
        "use {imp.path};{NL}"

# ============================================================================
# Module Builder (Fluent API)
# ============================================================================

# Helper class for building ModuleSpec incrementally
# Note: Uses functional style - each method returns new builder with updated spec
class ModuleBuilder:
    spec: ModuleSpec

    static fn start(name: text) -> ModuleBuilder:
        ModuleBuilder(spec: ModuleSpec.empty(name))

    fn doc(new_doc: text) -> ModuleBuilder:
        var new_spec = self.spec
        new_spec.doc = new_doc
        ModuleBuilder(spec: new_spec)

    fn add_import(path: text) -> ModuleBuilder:
        var new_spec = self.spec
        new_spec.imports.push(ImportSpec.simple(path))
        ModuleBuilder(spec: new_spec)

    fn add_import_items(path: text, items: [text]) -> ModuleBuilder:
        var new_spec = self.spec
        new_spec.imports.push(ImportSpec.with_items(path, items))
        ModuleBuilder(spec: new_spec)

    fn add_enum(enum_spec: EnumSpec) -> ModuleBuilder:
        var new_spec = self.spec
        new_spec.types.push(RustTypeSpec.enum_type(enum_spec))
        ModuleBuilder(spec: new_spec)

    fn add_struct(struct_spec: StructSpec) -> ModuleBuilder:
        var new_spec = self.spec
        new_spec.types.push(RustTypeSpec.struct_type(struct_spec))
        ModuleBuilder(spec: new_spec)

    fn add_impl(impl_spec: ImplSpec) -> ModuleBuilder:
        var new_spec = self.spec
        new_spec.impls.push(impl_spec)
        ModuleBuilder(spec: new_spec)

    fn add_fn(fn_spec: FFIFnSpec) -> ModuleBuilder:
        var new_spec = self.spec
        new_spec.functions.push(fn_spec)
        ModuleBuilder(spec: new_spec)

    fn add_test(test_spec: TestSpec) -> ModuleBuilder:
        var new_spec = self.spec
        new_spec.tests.push(test_spec)
        ModuleBuilder(spec: new_spec)

    fn add_raw(code: text) -> ModuleBuilder:
        var new_spec = self.spec
        new_spec.raw_code = new_spec.raw_code + code + NL
        ModuleBuilder(spec: new_spec)

    fn build() -> ModuleSpec:
        self.spec

    fn generate() -> text:
        generate_module_source(self.spec)

# ============================================================================
# Section Helpers
# ============================================================================

# Generate a section comment
fn section_comment(title: text) -> text:
    var out = "// " + "=".repeat(78) + NL
    out = out + "// {title}{NL}"
    out = out + "// " + "=".repeat(78) + NL
    out
