# FFI Wrapper Generator - Internal Interpreter Extern Codegen
#
# Generates Rust interpreter_extern module code from extern fn declarations.
# This reduces the ~15 lines of boilerplate per function to a single declaration.
#
# Input: list of InternFnSpec describing each extern function
# Output: Rust source code for interpreter_extern module + dispatch entries

# ============================================================================
# Data Structures
# ============================================================================

# Describes an internal extern function to generate a wrapper for
class InternFnSpec:
    # Function name as called from Simple (e.g. "rt_math_sin")
    name: text
    # Category for the module (e.g. "math", "file_io", "system")
    category: text
    # Parameter specs
    params: [InternParamSpec]
    # Return type: "i64", "f64", "bool", "text", "()"
    return_type: text
    # The underlying runtime FFI function to call (e.g. "rt_math_sin")
    # If empty, defaults to the name
    runtime_fn: text
    # Optional doc comment
    doc: text

class InternParamSpec:
    name: text
    # "i64", "f64", "bool", "text"
    value_type: text

# ============================================================================
# Rust Module Generation
# ============================================================================

# Generate a complete interpreter_extern module for a category
fn generate_module(category: text, specs: [InternFnSpec]) -> text:
    var out = ""
    out = out + "//! Auto-generated interpreter extern wrappers for {category}\n"
    out = out + "//!\n"
    out = out + "//! Generated by: simple ffi-gen --gen-intern\n"
    out = out + "//! Do not edit manually.\n\n"

    # Imports
    out = out + "use crate::error::{{codes, CompileError, ErrorContext}};\n"
    out = out + "use crate::value::Value;\n\n"

    # Collect runtime FFI imports
    var ffi_imports: [text] = []
    for spec in specs:
        val rt_fn = if spec.runtime_fn != "": spec.runtime_fn else: spec.name
        val ffi_import_line = "    {rt_fn} as ffi_{rt_fn}"
        if not ffi_imports.contains(ffi_import_line):
            ffi_imports.push(ffi_import_line)

    if ffi_imports.len() > 0:
        out = out + "use simple_runtime::value::ffi::{category}::{{\n"
        out = out + ffi_imports.join(",\n")
        out = out + ",\n}};\n\n"

    # Generate each wrapper function
    for spec in specs:
        out = out + generate_fn_wrapper(spec)
        out = out + "\n"

    out

# Generate a single function wrapper
fn generate_fn_wrapper(spec: InternFnSpec) -> text:
    var out = ""
    val rt_fn = if spec.runtime_fn != "": spec.runtime_fn else: spec.name

    # Doc comment
    if spec.doc != "":
        out = out + "/// {spec.doc}\n"
    else:
        out = out + "/// {spec.name} - auto-generated wrapper\n"

    out = out + "pub fn {spec.name}(args: &[Value]) -> Result<Value, CompileError> {{\n"

    # Extract parameters
    var call_args: [text] = []
    var i = 0
    for param in spec.params:
        val extractor = value_extractor(param.value_type)
        val error_msg = "{spec.name} expects {spec.params.len()} argument(s)"

        if spec.params.len() == 1:
            out = out + "    let {param.name} = args\n"
            out = out + "        .first()\n"
            out = out + "        .ok_or_else(|| {{\n"
            out = out + "            CompileError::semantic_with_context(\n"
            out = out + "                \"{error_msg}\".to_string(),\n"
            out = out + "                ErrorContext::new().with_code(codes::ARGUMENT_COUNT_MISMATCH),\n"
            out = out + "            )\n"
            out = out + "        }})?\n"
            out = out + "        .{extractor}?;\n"
        else:
            out = out + "    let {param.name} = args\n"
            out = out + "        .get({i})\n"
            out = out + "        .ok_or_else(|| {{\n"
            out = out + "            CompileError::semantic_with_context(\n"
            out = out + "                \"{error_msg}\".to_string(),\n"
            out = out + "                ErrorContext::new().with_code(codes::ARGUMENT_COUNT_MISMATCH),\n"
            out = out + "            )\n"
            out = out + "        }})?\n"
            out = out + "        .{extractor}?;\n"

        call_args.push(param.name)
        i = i + 1

    # Generate call and return
    val args_str = call_args.join(", ")
    val wrapper = value_wrapper(spec.return_type)

    if spec.params.len() == 0:
        # No-arg function
        out = out + "    Ok({wrapper}(ffi_{rt_fn}()))\n"
    else:
        out = out + "    Ok({wrapper}(ffi_{rt_fn}({args_str})))\n"

    out = out + "}}\n"
    out

# ============================================================================
# Dispatch Entry Generation
# ============================================================================

# Generate match arm entries for mod.rs dispatch
fn generate_dispatch_entries(specs: [InternFnSpec]) -> text:
    var out = ""
    for spec in specs:
        out = out + "        \"{spec.name}\" => {spec.category}::{spec.name}(&evaluated),\n"
    out

# ============================================================================
# Helpers
# ============================================================================

# ============================================================================
# Spec File Parser
# ============================================================================

# Parse intern specs from a .spl spec file.
# Looks for InternFnSpec(...) constructor calls and extracts fields.
# This is a text-based parser â€” it doesn't execute the Simple code.
fn parse_intern_specs(source: text) -> [InternFnSpec]:
    var specs: [InternFnSpec] = []
    val lines = source.split("\n")

    # Accumulate multi-line InternFnSpec blocks
    var in_spec = false
    var spec_text = ""

    for line in lines:
        val trimmed = line.trim()

        if trimmed.contains("InternFnSpec("):
            in_spec = true
            spec_text = trimmed

            # Check if it closes on the same line
            if spec_text.contains("))"):
                val spec = parse_single_spec(spec_text)
                if spec.name != "":
                    specs.push(spec)
                in_spec = false
                spec_text = ""
        elif in_spec:
            spec_text = spec_text + " " + trimmed
            if spec_text.contains("))"):
                val spec = parse_single_spec(spec_text)
                if spec.name != "":
                    specs.push(spec)
                in_spec = false
                spec_text = ""

    specs

# Parse a single InternFnSpec(...) text block
fn parse_single_spec(text_val: text) -> InternFnSpec:
    # Extract field values from named args
    val name = extract_field(text_val, "name")
    val category = extract_field(text_val, "category")
    val return_type = extract_field(text_val, "return_type")
    val runtime_fn = extract_field(text_val, "runtime_fn")
    val doc = extract_field(text_val, "doc")

    # Parse params: [InternParamSpec(name: "x", value_type: "f64")]
    var params: [InternParamSpec] = []
    val params_start = text_val.find("params:")
    if params_start >= 0:
        val after_params = text_val[params_start + 7:]
        val bracket_start = after_params.find("[")
        val bracket_end = after_params.find("]")
        if bracket_start >= 0 and bracket_end > bracket_start:
            val params_content = after_params[bracket_start + 1:bracket_end]
            # Split by InternParamSpec
            val param_parts = params_content.split("InternParamSpec(")
            for part in param_parts:
                val pt = part.trim()
                if pt != "" and pt.contains("name:"):
                    val pname = extract_field(pt, "name")
                    val ptype = extract_field(pt, "value_type")
                    if pname != "":
                        params.push(InternParamSpec(name: pname, value_type: ptype))

    InternFnSpec(
        name: name, category: category,
        params: params, return_type: return_type,
        runtime_fn: runtime_fn, doc: doc
    )

# Extract a quoted string field value: field_name: "value"
fn extract_field(text_val: text, field_name: text) -> text:
    val search = "{field_name}:"
    val pos = text_val.find(search)
    if pos < 0:
        return ""
    val after = text_val[pos + search.len():].trim()
    # Find first quote
    val q1 = after.find("\"")
    if q1 < 0:
        # Might be empty string ""
        return ""
    val rest = after[q1 + 1:]
    val q2 = rest.find("\"")
    if q2 < 0:
        return ""
    rest[:q2]

# ============================================================================
# Helpers
# ============================================================================

# Get the Value extractor method for a type
fn value_extractor(value_type: text) -> text:
    match value_type:
        case "i64":
            "as_int()"
        case "f64":
            "as_float()"
        case "bool":
            "as_bool()"
        case "text":
            "as_str()"
        case _:
            "as_int()"

# Get the Value wrapper constructor for a return type
fn value_wrapper(return_type: text) -> text:
    match return_type:
        case "i64":
            "Value::Int"
        case "f64":
            "Value::Float"
        case "bool":
            "Value::Bool"
        case "text":
            "Value::Str"
        case "()":
            "Value::Nil; let _ ="
        case _:
            "Value::Int"
