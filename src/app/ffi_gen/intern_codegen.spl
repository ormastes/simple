# FFI Wrapper Generator - Internal Interpreter Extern Codegen
#
# Generates Rust interpreter_extern module code from extern fn declarations.
# This reduces the ~15 lines of boilerplate per function to a single declaration.
#
# Input: list of InternFnSpec describing each extern function
# Output: Rust source code for interpreter_extern module + dispatch entries

# ============================================================================
# Data Structures
# ============================================================================

# Describes an internal extern function to generate a wrapper for
use std.text.{NL}

class InternFnSpec:
    # Function name as called from Simple (e.g. "rt_math_sin")
    name: text
    # Category for the module (e.g. "math", "file_io", "system")
    category: text
    # Parameter specs
    params: [InternParamSpec]
    # Return type: "i64", "f64", "bool", "text", "()"
    return_type: text
    # The underlying runtime FFI function to call (e.g. "rt_math_sin")
    # If empty, defaults to the name
    runtime_fn: text
    # Optional doc comment
    doc: text

class InternParamSpec:
    name: text
    # "i64", "f64", "bool", "text"
    value_type: text

# ============================================================================
# String Helpers (avoid .find() which returns Option in module context)
# ============================================================================

# Extract content after first occurrence of needle
fn after_first(s: text, needle: text) -> text:
    if not s.contains(needle):
        return ""
    val parts = s.split(needle)
    if parts.len() < 2:
        return ""
    # Rejoin everything after first occurrence
    var result = parts[1]
    var idx = 2
    while idx < parts.len():
        result = result + needle + parts[idx]
        idx = idx + 1
    result

# Get index of needle in string using split (returns -1 if not found)
fn index_of(s: text, needle: text) -> i64:
    if not s.contains(needle):
        return -1
    val parts = s.split(needle)
    parts[0].len()

# Get index of first occurrence from a certain offset
fn index_of_from(s: text, needle: text, start: i64) -> i64:
    if start >= s.len():
        return -1
    val sub = s[start:]
    val idx = index_of(sub, needle)
    if idx < 0:
        return -1
    start + idx

# ============================================================================
# Rust Module Generation
# ============================================================================

# Generate a complete interpreter_extern module for a category
fn generate_module(category: text, specs: [InternFnSpec]) -> text:
    var out = ""
    out = out + "//! Auto-generated interpreter extern wrappers for {category}{NL}"
    out = out + "//!{NL}"
    out = out + "//! Generated by: simple ffi-gen --gen-intern{NL}"
    out = out + "//! Do not edit manually.{NL}{NL}"

    # Imports
    out = out + "use crate::error::{{codes, CompileError, ErrorContext}};{NL}"
    out = out + "use crate::value::Value;{NL}{NL}"

    # Collect runtime FFI imports
    var ffi_imports: [text] = []
    for spec in specs:
        val rt_fn = if spec.runtime_fn != "": spec.runtime_fn else: spec.name
        val ffi_import_line = "    {rt_fn} as ffi_{rt_fn}"
        if not ffi_imports.contains(ffi_import_line):
            ffi_imports.push(ffi_import_line)

    if ffi_imports.len() > 0:
        out = out + "use simple_runtime::value::ffi::{category}::{{{NL}"
        out = out + ffi_imports.join(",{NL}")
        out = out + ",{NL}}};{NL}{NL}"

    # Generate each wrapper function
    for spec in specs:
        out = out + generate_fn_wrapper(spec)
        out = out + NL

    out

# Generate a single function wrapper
fn generate_fn_wrapper(spec: InternFnSpec) -> text:
    var out = ""
    val rt_fn = if spec.runtime_fn != "": spec.runtime_fn else: spec.name

    # Doc comment
    if spec.doc != "":
        out = out + "/// {spec.doc}{NL}"
    else:
        out = out + "/// {spec.name} - auto-generated wrapper{NL}"

    out = out + "pub fn {spec.name}(args: &[Value]) -> Result<Value, CompileError> {{{NL}"

    # Extract parameters
    var call_args: [text] = []
    var i = 0
    for param in spec.params:
        val extractor = value_extractor(param.value_type)
        val error_msg = "{spec.name} expects {spec.params.len()} argument(s)"

        if spec.params.len() == 1:
            out = out + "    let {param.name} = args{NL}"
            out = out + "        .first(){NL}"
            out = out + "        .ok_or_else(|| {{{NL}"
            out = out + "            CompileError::semantic_with_context({NL}"
            out = out + "                \"{error_msg}\".to_string(),{NL}"
            out = out + "                ErrorContext::new().with_code(codes::ARGUMENT_COUNT_MISMATCH),{NL}"
            out = out + "            ){NL}"
            out = out + "        }})?{NL}"
            out = out + "        .{extractor}?;{NL}"
        else:
            out = out + "    let {param.name} = args{NL}"
            out = out + "        .get({i}){NL}"
            out = out + "        .ok_or_else(|| {{{NL}"
            out = out + "            CompileError::semantic_with_context({NL}"
            out = out + "                \"{error_msg}\".to_string(),{NL}"
            out = out + "                ErrorContext::new().with_code(codes::ARGUMENT_COUNT_MISMATCH),{NL}"
            out = out + "            ){NL}"
            out = out + "        }})?{NL}"
            out = out + "        .{extractor}?;{NL}"

        call_args.push(param.name)
        i = i + 1

    # Generate call and return
    val args_str = call_args.join(", ")
    val wrapper = value_wrapper(spec.return_type)

    if spec.params.len() == 0:
        # No-arg function
        out = out + "    Ok({wrapper}(ffi_{rt_fn}())){NL}"
    else:
        out = out + "    Ok({wrapper}(ffi_{rt_fn}({args_str}))){NL}"

    out = out + "}}{NL}"
    out

# ============================================================================
# Dispatch Entry Generation
# ============================================================================

# Generate match arm entries for mod.rs dispatch
fn generate_dispatch_entries(specs: [InternFnSpec]) -> text:
    var out = ""
    for spec in specs:
        out = out + "        \"{spec.name}\" => {spec.category}::{spec.name}(&evaluated),{NL}"
    out

# ============================================================================
# Helpers
# ============================================================================

# ============================================================================
# Spec File Parser
# ============================================================================

# Parse intern specs from a .spl spec file.
# Looks for InternFnSpec(...) constructor calls and extracts fields.
# This is a text-based parser â€” it doesn't execute the Simple code.
fn parse_intern_specs(source: text) -> [InternFnSpec]:
    var specs: [InternFnSpec] = []
    val lines = source.split(NL)

    # Accumulate multi-line InternFnSpec blocks
    var in_spec = false
    var spec_text = ""

    for line in lines:
        val trimmed = line.trim()

        if trimmed.contains("InternFnSpec("):
            in_spec = true
            spec_text = trimmed

            # Check if it closes on the same line
            if spec_text.contains("))"):
                val spec = parse_single_spec(spec_text)
                if spec.name != "":
                    specs.push(spec)
                in_spec = false
                spec_text = ""
        elif in_spec:
            spec_text = spec_text + " " + trimmed
            if spec_text.contains("))"):
                val spec = parse_single_spec(spec_text)
                if spec.name != "":
                    specs.push(spec)
                in_spec = false
                spec_text = ""

    specs

# Parse a single InternFnSpec(...) text block
fn parse_single_spec(text_val: text) -> InternFnSpec:
    # Extract field values from named args
    val name = extract_field(text_val, "name")
    val category = extract_field(text_val, "category")
    val return_type = extract_field(text_val, "return_type")
    val runtime_fn = extract_field(text_val, "runtime_fn")
    val doc = extract_field(text_val, "doc")

    # Parse params: [InternParamSpec(name: "x", value_type: "f64")]
    var params: [InternParamSpec] = []
    val params_start = index_of(text_val, "params:")
    if params_start >= 0:
        val after_params = text_val[params_start + 7:]
        val bracket_start = index_of(after_params, "[")
        val bracket_end = index_of(after_params, "]")
        if bracket_start >= 0 and bracket_end > bracket_start:
            val params_content = after_params[bracket_start + 1:bracket_end]
            # Split by InternParamSpec
            val param_parts = params_content.split("InternParamSpec(")
            for part in param_parts:
                val pt = part.trim()
                if pt != "" and pt.contains("name:"):
                    val pname = extract_field(pt, "name")
                    val ptype = extract_field(pt, "value_type")
                    if pname != "":
                        params.push(InternParamSpec(name: pname, value_type: ptype))

    InternFnSpec(
        name: name, category: category,
        params: params, return_type: return_type,
        runtime_fn: runtime_fn, doc: doc
    )

# Extract a quoted string field value: field_name: "value"
fn extract_field(text_val: text, field_name: text) -> text:
    val search = "{field_name}:"
    val pos = index_of(text_val, search)
    if pos < 0:
        return ""
    val after = text_val[pos + search.len():].trim()
    # Find first quote
    val q1 = index_of(after, "\"")
    if q1 < 0:
        # Might be empty string ""
        return ""
    val rest = after[q1 + 1:]
    val q2 = index_of(rest, "\"")
    if q2 < 0:
        return ""
    rest[0:q2]

# ============================================================================
# Helpers
# ============================================================================

# Get the Value extractor method for a type
fn value_extractor(value_type: text) -> text:
    match value_type:
        case "i64":
            "as_int()"
        case "f64":
            "as_float()"
        case "bool":
            "as_bool()"
        case "text":
            "as_str()"
        case _:
            "as_int()"

# Get the Value wrapper constructor for a return type
fn value_wrapper(return_type: text) -> text:
    match return_type:
        case "i64":
            "Value::Int"
        case "f64":
            "Value::Float"
        case "bool":
            "Value::Bool"
        case "text":
            "Value::Str"
        case "()":
            "Value::Nil; let _ ="
        case _:
            "Value::Int"
