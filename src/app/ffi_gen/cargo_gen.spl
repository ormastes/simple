# FFI Wrapper Generator - Cargo.toml Generation
#
# Generates a Cargo.toml for the FFI wrapper crate with the correct
# dependencies from @Lib annotations.

import parser

# ============================================================================
# Cargo.toml Generation
# ============================================================================

# Generate Cargo.toml content for a set of @Lib specs
fn generate(specs: [parser.LibExternSpec]) -> text:
    var out = ""
    out = out + "# Auto-generated by Simple FFI wrapper generator\n"
    out = out + "# Do not edit manually.\n\n"
    out = out + "[package]\n"
    out = out + "name = \"simple-ffi-wrapper\"\n"
    out = out + "version = \"0.1.0\"\n"
    out = out + "edition = \"2021\"\n\n"
    out = out + "[lib]\n"
    out = out + "crate-type = [\"cdylib\"]\n\n"
    out = out + "[dependencies]\n"

    # Collect unique dependencies
    var seen: [text] = []
    for spec in specs:
        if seen.contains(spec.lib_name):
            pass
        else:
            seen.push(spec.lib_name)
            out = out + generate_dependency(spec)

    out = out + "\n"
    out = out + "[profile.release]\n"
    out = out + "opt-level = 3\n"
    out = out + "lto = true\n"
    out = out + "codegen-units = 1\n"

    out

# Generate a single dependency line
fn generate_dependency(spec: parser.LibExternSpec) -> text:
    val name = spec.lib_name
    val version = spec.lib_version
    val features = spec.lib_features

    if features.len() > 0:
        # Dependency with features
        var feat_str = features.map(\f: "\"{f}\"").join(", ")
        if version != "":
            "{name} = {{ version = \"{version}\", features = [{feat_str}] }}\n"
        else:
            "{name} = {{ features = [{feat_str}] }}\n"
    elif version != "":
        "{name} = \"{version}\"\n"
    else:
        "{name} = \"*\"\n"
