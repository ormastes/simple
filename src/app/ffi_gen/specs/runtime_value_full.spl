# Runtime Value Module - Full Specification
#
# Complete specification for generating runtime_value.rs with:
# - RuntimeValue enum
# - ValueType enum
# - All FFI functions with full implementations
# - Unit tests
#
# Usage: simple ffi-gen --gen-module specs/runtime_value_full.spl

use app.ffi_gen.types*
use app.ffi_gen.module_gen (ModuleBuilder)
use std.text.{NL}

# ============================================================================
# Module Specification
# ============================================================================

fn runtime_value_module() -> ModuleSpec:
    var builder = ModuleBuilder__start("runtime_value")
        .doc("Runtime Value FFI{NL}{NL}Full implementation of RuntimeValue for Simple language.{NL}Supports: nil, bool, int, float, string, array, dict, object, function")

    # Imports
    builder = builder
        .add_import("std::collections::HashMap")
        .add_import("std::ffi::CString")
        .add_import("std::os::raw::c_char")
        .add_import("std::sync::Arc")

    # ValueType enum
    builder = builder.add_enum(value_type_enum())

    # RuntimeValue enum
    builder = builder.add_enum(runtime_value_enum())

    # Impl block for RuntimeValue
    builder = builder.add_impl(runtime_value_impl())

    # Constructor functions
    builder = builder
        .add_fn(fn_rt_value_nil())
        .add_fn(fn_rt_value_bool())
        .add_fn(fn_rt_value_int())
        .add_fn(fn_rt_value_float())
        .add_fn(fn_rt_value_string())
        .add_fn(fn_rt_value_array_new())
        .add_fn(fn_rt_value_dict_new())

    # Type checking functions
    builder = builder
        .add_fn(fn_rt_value_type())
        .add_fn(fn_rt_value_is_nil())
        .add_fn(fn_rt_value_is_bool())
        .add_fn(fn_rt_value_is_int())
        .add_fn(fn_rt_value_is_float())
        .add_fn(fn_rt_value_is_string())
        .add_fn(fn_rt_value_is_array())
        .add_fn(fn_rt_value_is_dict())

    # Conversion functions
    builder = builder
        .add_fn(fn_rt_value_as_bool())
        .add_fn(fn_rt_value_as_int())
        .add_fn(fn_rt_value_as_float())
        .add_fn(fn_rt_value_as_string())

    # Arithmetic functions
    builder = builder
        .add_fn(fn_rt_value_add())
        .add_fn(fn_rt_value_sub())
        .add_fn(fn_rt_value_mul())
        .add_fn(fn_rt_value_div())

    # Comparison functions
    builder = builder
        .add_fn(fn_rt_value_eq())
        .add_fn(fn_rt_value_lt())

    # Printing functions
    builder = builder
        .add_fn(fn_rt_value_print())
        .add_fn(fn_rt_value_println())

    # Memory management functions
    builder = builder
        .add_fn(fn_rt_value_free())
        .add_fn(fn_rt_value_clone())

    # Tests
    builder = builder
        .add_test(test_value_nil())
        .add_test(test_value_int())
        .add_test(test_value_string())
        .add_test(test_arithmetic())
        .add_test(test_comparison())

    builder.build()

# ============================================================================
# Type Definitions
# ============================================================================

fn value_type_enum() -> EnumSpec:
    var spec = EnumSpec(
        name: "ValueType",
        generics: [],
        repr_attr: "C",
        derives: ["Debug", "Clone", "Copy", "PartialEq", "Eq"],
        variants: [
            EnumVariantSpec__unit_with_value("Nil", "0"),
            EnumVariantSpec__unit_with_value("Bool", "1"),
            EnumVariantSpec__unit_with_value("Int", "2"),
            EnumVariantSpec__unit_with_value("Float", "3"),
            EnumVariantSpec__unit_with_value("String", "4"),
            EnumVariantSpec__unit_with_value("Array", "5"),
            EnumVariantSpec__unit_with_value("Dict", "6"),
            EnumVariantSpec__unit_with_value("Object", "7"),
            EnumVariantSpec__unit_with_value("Function", "8")
        ],
        visibility: "pub",
        doc: "Value type tags"
    )
    spec

fn runtime_value_enum() -> EnumSpec:
    var spec = EnumSpec(
        name: "RuntimeValue",
        generics: [],
        repr_attr: "C",
        derives: [],
        variants: [
            EnumVariantSpec__unit("Nil"),
            EnumVariantSpec__tuple("Bool", ["bool"]),
            EnumVariantSpec__tuple("Int", ["i64"]),
            EnumVariantSpec__tuple("Float", ["f64"]),
            EnumVariantSpec__tuple("String", ["Arc<String>"]),
            EnumVariantSpec__tuple("Array", ["Arc<Vec<Box<RuntimeValue>>>"]),
            EnumVariantSpec__tuple("Dict", ["Arc<HashMap<String, Box<RuntimeValue>>>"]),
            EnumVariantSpec__tuple("Object", ["Arc<dyn std::any::Any + Send + Sync>"]),
            EnumVariantSpec__tuple("Function", ["usize"])
        ],
        visibility: "pub",
        doc: "Runtime Value - tagged union for Simple values"
    )
    spec

fn runtime_value_impl() -> ImplSpec:
    val type_tag_method = MethodSpec__method(
        "type_tag", "&self", [], "ValueType",
        "match self {{NL}" +
        "    RuntimeValue::Nil => ValueType::Nil,{NL}" +
        "    RuntimeValue::Bool(_) => ValueType::Bool,{NL}" +
        "    RuntimeValue::Int(_) => ValueType::Int,{NL}" +
        "    RuntimeValue::Float(_) => ValueType::Float,{NL}" +
        "    RuntimeValue::String(_) => ValueType::String,{NL}" +
        "    RuntimeValue::Array(_) => ValueType::Array,{NL}" +
        "    RuntimeValue::Dict(_) => ValueType::Dict,{NL}" +
        "    RuntimeValue::Object(_) => ValueType::Object,{NL}" +
        "    RuntimeValue::Function(_) => ValueType::Function,{NL}" +
        "}"
    )
    ImplSpec__inherent("RuntimeValue", [type_tag_method])

# ============================================================================
# Constructor Functions
# ============================================================================

fn fn_rt_value_nil() -> FFIFnSpec:
    FFIFnSpec__extern_c("rt_value_nil", [], "*mut RuntimeValue",
        "Box::into_raw(Box::new(RuntimeValue::Nil))"
    )

fn fn_rt_value_bool() -> FFIFnSpec:
    FFIFnSpec__extern_c("rt_value_bool",
        [FFIParamSpec__simple("value", "bool")],
        "*mut RuntimeValue",
        "Box::into_raw(Box::new(RuntimeValue::Bool(value)))"
    )

fn fn_rt_value_int() -> FFIFnSpec:
    FFIFnSpec__extern_c("rt_value_int",
        [FFIParamSpec__simple("value", "i64")],
        "*mut RuntimeValue",
        "Box::into_raw(Box::new(RuntimeValue::Int(value)))"
    )

fn fn_rt_value_float() -> FFIFnSpec:
    FFIFnSpec__extern_c("rt_value_float",
        [FFIParamSpec__simple("value", "f64")],
        "*mut RuntimeValue",
        "Box::into_raw(Box::new(RuntimeValue::Float(value)))"
    )

fn fn_rt_value_string() -> FFIFnSpec:
    FFIFnSpec__unsafe_extern_c("rt_value_string",
        [
            FFIParamSpec__simple("ptr", "*const c_char"),
            FFIParamSpec__simple("len", "usize")
        ],
        "*mut RuntimeValue",
        "if ptr.is_null() {{NL}" +
        "    return rt_value_nil();{NL}" +
        "}{NL}" +
        "{NL}" +
        "let bytes = std::slice::from_raw_parts(ptr as *const u8, len);{NL}" +
        "let s = String::from_utf8_lossy(bytes).into_owned();{NL}" +
        "Box::into_raw(Box::new(RuntimeValue::String(Arc::new(s))))"
    )

fn fn_rt_value_array_new() -> FFIFnSpec:
    FFIFnSpec__extern_c("rt_value_array_new", [], "*mut RuntimeValue",
        "Box::into_raw(Box::new(RuntimeValue::Array(Arc::new(Vec::new()))))"
    )

fn fn_rt_value_dict_new() -> FFIFnSpec:
    FFIFnSpec__extern_c("rt_value_dict_new", [], "*mut RuntimeValue",
        "Box::into_raw(Box::new(RuntimeValue::Dict(Arc::new(HashMap::new()))))"
    )

# ============================================================================
# Type Checking Functions
# ============================================================================

fn fn_rt_value_type() -> FFIFnSpec:
    FFIFnSpec__unsafe_extern_c("rt_value_type",
        [FFIParamSpec__simple("value", "*const RuntimeValue")],
        "ValueType",
        "if value.is_null() {{NL}" +
        "    return ValueType::Nil;{NL}" +
        "}{NL}" +
        "(*value).type_tag()"
    )

fn fn_rt_value_is_nil() -> FFIFnSpec:
    FFIFnSpec__unsafe_extern_c("rt_value_is_nil",
        [FFIParamSpec__simple("value", "*const RuntimeValue")],
        "bool",
        "value.is_null() || matches!(*value, RuntimeValue::Nil)"
    )

fn fn_rt_value_is_bool() -> FFIFnSpec:
    FFIFnSpec__unsafe_extern_c("rt_value_is_bool",
        [FFIParamSpec__simple("value", "*const RuntimeValue")],
        "bool",
        "!value.is_null() && matches!(*value, RuntimeValue::Bool(_))"
    )

fn fn_rt_value_is_int() -> FFIFnSpec:
    FFIFnSpec__unsafe_extern_c("rt_value_is_int",
        [FFIParamSpec__simple("value", "*const RuntimeValue")],
        "bool",
        "!value.is_null() && matches!(*value, RuntimeValue::Int(_))"
    )

fn fn_rt_value_is_float() -> FFIFnSpec:
    FFIFnSpec__unsafe_extern_c("rt_value_is_float",
        [FFIParamSpec__simple("value", "*const RuntimeValue")],
        "bool",
        "!value.is_null() && matches!(*value, RuntimeValue::Float(_))"
    )

fn fn_rt_value_is_string() -> FFIFnSpec:
    FFIFnSpec__unsafe_extern_c("rt_value_is_string",
        [FFIParamSpec__simple("value", "*const RuntimeValue")],
        "bool",
        "!value.is_null() && matches!(*value, RuntimeValue::String(_))"
    )

fn fn_rt_value_is_array() -> FFIFnSpec:
    FFIFnSpec__unsafe_extern_c("rt_value_is_array",
        [FFIParamSpec__simple("value", "*const RuntimeValue")],
        "bool",
        "!value.is_null() && matches!(*value, RuntimeValue::Array(_))"
    )

fn fn_rt_value_is_dict() -> FFIFnSpec:
    FFIFnSpec__unsafe_extern_c("rt_value_is_dict",
        [FFIParamSpec__simple("value", "*const RuntimeValue")],
        "bool",
        "!value.is_null() && matches!(*value, RuntimeValue::Dict(_))"
    )

# ============================================================================
# Conversion Functions
# ============================================================================

fn fn_rt_value_as_bool() -> FFIFnSpec:
    FFIFnSpec__unsafe_extern_c("rt_value_as_bool",
        [FFIParamSpec__simple("value", "*const RuntimeValue")],
        "bool",
        "if value.is_null() {{NL}" +
        "    return false;{NL}" +
        "}{NL}" +
        "match &*value {{NL}" +
        "    RuntimeValue::Bool(b) => *b,{NL}" +
        "    RuntimeValue::Nil => false,{NL}" +
        "    RuntimeValue::Int(i) => *i != 0,{NL}" +
        "    _ => true, // Everything else is truthy{NL}" +
        "}"
    )

fn fn_rt_value_as_int() -> FFIFnSpec:
    FFIFnSpec__unsafe_extern_c("rt_value_as_int",
        [FFIParamSpec__simple("value", "*const RuntimeValue")],
        "i64",
        "if value.is_null() {{NL}" +
        "    return 0;{NL}" +
        "}{NL}" +
        "match &*value {{NL}" +
        "    RuntimeValue::Int(i) => *i,{NL}" +
        "    RuntimeValue::Float(f) => *f as i64,{NL}" +
        "    RuntimeValue::Bool(b) => if *b {{ 1 }} else {{ 0 }},{NL}" +
        "    _ => 0,{NL}" +
        "}"
    )

fn fn_rt_value_as_float() -> FFIFnSpec:
    FFIFnSpec__unsafe_extern_c("rt_value_as_float",
        [FFIParamSpec__simple("value", "*const RuntimeValue")],
        "f64",
        "if value.is_null() {{NL}" +
        "    return 0.0;{NL}" +
        "}{NL}" +
        "match &*value {{NL}" +
        "    RuntimeValue::Float(f) => *f,{NL}" +
        "    RuntimeValue::Int(i) => *i as f64,{NL}" +
        "    _ => 0.0,{NL}" +
        "}"
    )

fn fn_rt_value_as_string() -> FFIFnSpec:
    var spec = FFIFnSpec__unsafe_extern_c("rt_value_as_string",
        [
            FFIParamSpec__simple("value", "*const RuntimeValue"),
            FFIParamSpec__simple("out_len", "*mut usize")
        ],
        "*const c_char",
        "if value.is_null() || out_len.is_null() {{NL}" +
        "    if !out_len.is_null() {{NL}" +
        "        *out_len = 0;{NL}" +
        "    }{NL}" +
        "    return std::ptr::null();{NL}" +
        "}{NL}" +
        "{NL}" +
        "match &*value {{NL}" +
        "    RuntimeValue::String(s) => {{NL}" +
        "        *out_len = s.len();{NL}" +
        "        s.as_ptr() as *const c_char{NL}" +
        "    }{NL}" +
        "    _ => {{NL}" +
        "        *out_len = 0;{NL}" +
        "        std::ptr::null(){NL}" +
        "    }{NL}" +
        "}"
    )
    spec.doc = "Get string from value (returns ptr and length){NL}Caller must NOT free the returned pointer - it's owned by the value"
    spec

# ============================================================================
# Arithmetic Functions
# ============================================================================

fn fn_rt_value_add() -> FFIFnSpec:
    FFIFnSpec__unsafe_extern_c("rt_value_add",
        [
            FFIParamSpec__simple("left", "*const RuntimeValue"),
            FFIParamSpec__simple("right", "*const RuntimeValue")
        ],
        "*mut RuntimeValue",
        "if left.is_null() || right.is_null() {{NL}" +
        "    return rt_value_nil();{NL}" +
        "}{NL}" +
        "{NL}" +
        "match (&*left, &*right) {{NL}" +
        "    (RuntimeValue::Int(a), RuntimeValue::Int(b)) => rt_value_int(a + b),{NL}" +
        "    (RuntimeValue::Float(a), RuntimeValue::Float(b)) => rt_value_float(a + b),{NL}" +
        "    (RuntimeValue::Int(a), RuntimeValue::Float(b)) => rt_value_float(*a as f64 + b),{NL}" +
        "    (RuntimeValue::Float(a), RuntimeValue::Int(b)) => rt_value_float(a + *b as f64),{NL}" +
        "    (RuntimeValue::String(a), RuntimeValue::String(b)) => {{NL}" +
        "        let result = format!(\"{}{}\", a, b);{NL}" +
        "        let c_str = CString::new(result).unwrap();{NL}" +
        "        rt_value_string(c_str.as_ptr(), c_str.as_bytes().len()){NL}" +
        "    }{NL}" +
        "    _ => rt_value_nil(),{NL}" +
        "}"
    )

fn fn_rt_value_sub() -> FFIFnSpec:
    FFIFnSpec__unsafe_extern_c("rt_value_sub",
        [
            FFIParamSpec__simple("left", "*const RuntimeValue"),
            FFIParamSpec__simple("right", "*const RuntimeValue")
        ],
        "*mut RuntimeValue",
        "if left.is_null() || right.is_null() {{NL}" +
        "    return rt_value_nil();{NL}" +
        "}{NL}" +
        "{NL}" +
        "match (&*left, &*right) {{NL}" +
        "    (RuntimeValue::Int(a), RuntimeValue::Int(b)) => rt_value_int(a - b),{NL}" +
        "    (RuntimeValue::Float(a), RuntimeValue::Float(b)) => rt_value_float(a - b),{NL}" +
        "    (RuntimeValue::Int(a), RuntimeValue::Float(b)) => rt_value_float(*a as f64 - b),{NL}" +
        "    (RuntimeValue::Float(a), RuntimeValue::Int(b)) => rt_value_float(a - *b as f64),{NL}" +
        "    _ => rt_value_nil(),{NL}" +
        "}"
    )

fn fn_rt_value_mul() -> FFIFnSpec:
    FFIFnSpec__unsafe_extern_c("rt_value_mul",
        [
            FFIParamSpec__simple("left", "*const RuntimeValue"),
            FFIParamSpec__simple("right", "*const RuntimeValue")
        ],
        "*mut RuntimeValue",
        "if left.is_null() || right.is_null() {{NL}" +
        "    return rt_value_nil();{NL}" +
        "}{NL}" +
        "{NL}" +
        "match (&*left, &*right) {{NL}" +
        "    (RuntimeValue::Int(a), RuntimeValue::Int(b)) => rt_value_int(a * b),{NL}" +
        "    (RuntimeValue::Float(a), RuntimeValue::Float(b)) => rt_value_float(a * b),{NL}" +
        "    (RuntimeValue::Int(a), RuntimeValue::Float(b)) => rt_value_float(*a as f64 * b),{NL}" +
        "    (RuntimeValue::Float(a), RuntimeValue::Int(b)) => rt_value_float(a * (*b as f64)),{NL}" +
        "    _ => rt_value_nil(),{NL}" +
        "}"
    )

fn fn_rt_value_div() -> FFIFnSpec:
    FFIFnSpec__unsafe_extern_c("rt_value_div",
        [
            FFIParamSpec__simple("left", "*const RuntimeValue"),
            FFIParamSpec__simple("right", "*const RuntimeValue")
        ],
        "*mut RuntimeValue",
        "if left.is_null() || right.is_null() {{NL}" +
        "    return rt_value_nil();{NL}" +
        "}{NL}" +
        "{NL}" +
        "match (&*left, &*right) {{NL}" +
        "    (RuntimeValue::Int(a), RuntimeValue::Int(b)) => {{NL}" +
        "        if *b == 0 {{NL}" +
        "            return rt_value_nil(); // Division by zero{NL}" +
        "        }{NL}" +
        "        rt_value_int(a / b){NL}" +
        "    }{NL}" +
        "    (RuntimeValue::Float(a), RuntimeValue::Float(b)) => rt_value_float(a / b),{NL}" +
        "    (RuntimeValue::Int(a), RuntimeValue::Float(b)) => rt_value_float(*a as f64 / b),{NL}" +
        "    (RuntimeValue::Float(a), RuntimeValue::Int(b)) => rt_value_float(a / (*b as f64)),{NL}" +
        "    _ => rt_value_nil(),{NL}" +
        "}"
    )

# ============================================================================
# Comparison Functions
# ============================================================================

fn fn_rt_value_eq() -> FFIFnSpec:
    FFIFnSpec__unsafe_extern_c("rt_value_eq",
        [
            FFIParamSpec__simple("left", "*const RuntimeValue"),
            FFIParamSpec__simple("right", "*const RuntimeValue")
        ],
        "bool",
        "if left.is_null() && right.is_null() {{NL}" +
        "    return true;{NL}" +
        "}{NL}" +
        "if left.is_null() || right.is_null() {{NL}" +
        "    return false;{NL}" +
        "}{NL}" +
        "{NL}" +
        "match (&*left, &*right) {{NL}" +
        "    (RuntimeValue::Nil, RuntimeValue::Nil) => true,{NL}" +
        "    (RuntimeValue::Bool(a), RuntimeValue::Bool(b)) => a == b,{NL}" +
        "    (RuntimeValue::Int(a), RuntimeValue::Int(b)) => a == b,{NL}" +
        "    (RuntimeValue::Float(a), RuntimeValue::Float(b)) => a == b,{NL}" +
        "    (RuntimeValue::String(a), RuntimeValue::String(b)) => a == b,{NL}" +
        "    _ => false,{NL}" +
        "}"
    )

fn fn_rt_value_lt() -> FFIFnSpec:
    FFIFnSpec__unsafe_extern_c("rt_value_lt",
        [
            FFIParamSpec__simple("left", "*const RuntimeValue"),
            FFIParamSpec__simple("right", "*const RuntimeValue")
        ],
        "bool",
        "if left.is_null() || right.is_null() {{NL}" +
        "    return false;{NL}" +
        "}{NL}" +
        "{NL}" +
        "match (&*left, &*right) {{NL}" +
        "    (RuntimeValue::Int(a), RuntimeValue::Int(b)) => a < b,{NL}" +
        "    (RuntimeValue::Float(a), RuntimeValue::Float(b)) => a < b,{NL}" +
        "    (RuntimeValue::Int(a), RuntimeValue::Float(b)) => (*a as f64) < *b,{NL}" +
        "    (RuntimeValue::Float(a), RuntimeValue::Int(b)) => *a < (*b as f64),{NL}" +
        "    (RuntimeValue::String(a), RuntimeValue::String(b)) => a < b,{NL}" +
        "    _ => false,{NL}" +
        "}"
    )

# ============================================================================
# Printing Functions
# ============================================================================

fn fn_rt_value_print() -> FFIFnSpec:
    FFIFnSpec__unsafe_extern_c("rt_value_print",
        [FFIParamSpec__simple("value", "*const RuntimeValue")],
        "()",
        "if value.is_null() {{NL}" +
        "    print!(\"nil\");{NL}" +
        "    return;{NL}" +
        "}{NL}" +
        "{NL}" +
        "match &*value {{NL}" +
        "    RuntimeValue::Nil => print!(\"nil\"),{NL}" +
        "    RuntimeValue::Bool(b) => print!(\"{}\", b),{NL}" +
        "    RuntimeValue::Int(i) => print!(\"{}\", i),{NL}" +
        "    RuntimeValue::Float(f) => print!(\"{}\", f),{NL}" +
        "    RuntimeValue::String(s) => print!(\"{}\", s),{NL}" +
        "    RuntimeValue::Array(_) => print!(\"[Array]\"),{NL}" +
        "    RuntimeValue::Dict(_) => print!(\"{{{{Dict}}}}\"),{NL}" +
        "    RuntimeValue::Object(_) => print!(\"<Object>\"),{NL}" +
        "    RuntimeValue::Function(_) => print!(\"<Function>\"),{NL}" +
        "}"
    )

fn fn_rt_value_println() -> FFIFnSpec:
    FFIFnSpec__unsafe_extern_c("rt_value_println",
        [FFIParamSpec__simple("value", "*const RuntimeValue")],
        "()",
        "rt_value_print(value);{NL}println!();"
    )

# ============================================================================
# Memory Management Functions
# ============================================================================

fn fn_rt_value_free() -> FFIFnSpec:
    FFIFnSpec__unsafe_extern_c("rt_value_free",
        [FFIParamSpec__simple("value", "*mut RuntimeValue")],
        "()",
        "if !value.is_null() {{NL}" +
        "    drop(Box::from_raw(value));{NL}" +
        "}"
    )

fn fn_rt_value_clone() -> FFIFnSpec:
    FFIFnSpec__unsafe_extern_c("rt_value_clone",
        [FFIParamSpec__simple("value", "*const RuntimeValue")],
        "*mut RuntimeValue",
        "if value.is_null() {{NL}" +
        "    return rt_value_nil();{NL}" +
        "}{NL}" +
        "{NL}" +
        "let cloned = match &*value {{NL}" +
        "    RuntimeValue::Nil => RuntimeValue::Nil,{NL}" +
        "    RuntimeValue::Bool(b) => RuntimeValue::Bool(*b),{NL}" +
        "    RuntimeValue::Int(i) => RuntimeValue::Int(*i),{NL}" +
        "    RuntimeValue::Float(f) => RuntimeValue::Float(*f),{NL}" +
        "    RuntimeValue::String(s) => RuntimeValue::String(Arc::clone(s)),{NL}" +
        "    RuntimeValue::Array(a) => RuntimeValue::Array(Arc::clone(a)),{NL}" +
        "    RuntimeValue::Dict(d) => RuntimeValue::Dict(Arc::clone(d)),{NL}" +
        "    RuntimeValue::Object(o) => RuntimeValue::Object(Arc::clone(o)),{NL}" +
        "    RuntimeValue::Function(f) => RuntimeValue::Function(*f),{NL}" +
        "};{NL}" +
        "{NL}" +
        "Box::into_raw(Box::new(cloned))"
    )

# ============================================================================
# Test Specifications
# ============================================================================

fn test_value_nil() -> TestSpec:
    TestSpec__test("test_value_nil",
        "unsafe {{NL}" +
        "    let val = rt_value_nil();{NL}" +
        "    assert!(!val.is_null());{NL}" +
        "    assert!(rt_value_is_nil(val));{NL}" +
        "    assert_eq!(rt_value_type(val), ValueType::Nil);{NL}" +
        "    rt_value_free(val);{NL}" +
        "}"
    )

fn test_value_int() -> TestSpec:
    TestSpec__test("test_value_int",
        "unsafe {{NL}" +
        "    let val = rt_value_int(42);{NL}" +
        "    assert!(!val.is_null());{NL}" +
        "    assert!(rt_value_is_int(val));{NL}" +
        "    assert_eq!(rt_value_as_int(val), 42);{NL}" +
        "    rt_value_free(val);{NL}" +
        "}"
    )

fn test_value_string() -> TestSpec:
    TestSpec__test("test_value_string",
        "unsafe {{NL}" +
        "    let s = CString::new(\"hello\").unwrap();{NL}" +
        "    let val = rt_value_string(s.as_ptr(), s.as_bytes().len());{NL}" +
        "    assert!(!val.is_null());{NL}" +
        "    assert!(rt_value_is_string(val));{NL}" +
        "{NL}" +
        "    let mut len = 0;{NL}" +
        "    let ptr = rt_value_as_string(val, &mut len);{NL}" +
        "    assert!(!ptr.is_null());{NL}" +
        "    assert_eq!(len, 5);{NL}" +
        "{NL}" +
        "    rt_value_free(val);{NL}" +
        "}"
    )

fn test_arithmetic() -> TestSpec:
    TestSpec__test("test_arithmetic",
        "unsafe {{NL}" +
        "    let a = rt_value_int(10);{NL}" +
        "    let b = rt_value_int(5);{NL}" +
        "{NL}" +
        "    let sum = rt_value_add(a, b);{NL}" +
        "    assert_eq!(rt_value_as_int(sum), 15);{NL}" +
        "{NL}" +
        "    let diff = rt_value_sub(a, b);{NL}" +
        "    assert_eq!(rt_value_as_int(diff), 5);{NL}" +
        "{NL}" +
        "    let prod = rt_value_mul(a, b);{NL}" +
        "    assert_eq!(rt_value_as_int(prod), 50);{NL}" +
        "{NL}" +
        "    let quot = rt_value_div(a, b);{NL}" +
        "    assert_eq!(rt_value_as_int(quot), 2);{NL}" +
        "{NL}" +
        "    rt_value_free(a);{NL}" +
        "    rt_value_free(b);{NL}" +
        "    rt_value_free(sum);{NL}" +
        "    rt_value_free(diff);{NL}" +
        "    rt_value_free(prod);{NL}" +
        "    rt_value_free(quot);{NL}" +
        "}"
    )

fn test_comparison() -> TestSpec:
    TestSpec__test("test_comparison",
        "unsafe {{NL}" +
        "    let a = rt_value_int(10);{NL}" +
        "    let b = rt_value_int(5);{NL}" +
        "    let c = rt_value_int(10);{NL}" +
        "{NL}" +
        "    assert!(!rt_value_eq(a, b));{NL}" +
        "    assert!(rt_value_eq(a, c));{NL}" +
        "    assert!(rt_value_lt(b, a));{NL}" +
        "    assert!(!rt_value_lt(a, b));{NL}" +
        "{NL}" +
        "    rt_value_free(a);{NL}" +
        "    rt_value_free(b);{NL}" +
        "    rt_value_free(c);{NL}" +
        "}"
    )
export runtime_value_module
