# Cranelift Advanced - Function Calls, Conversions, Block Params, JIT, AOT, Helpers
#
# Part of cranelift_core split: function calls, type conversions,
# block parameters, JIT execution, AOT compilation, and impl helpers.

use app.ffi_gen.types*
use app.ffi_gen.module_gen (ModuleBuilder)
use std.text.{NL}

# ============================================================================
# Function Call Functions
# ============================================================================

fn add_function_call_fns(builder: ModuleBuilder) -> ModuleBuilder:
    builder
        .add_fn(fn_rt_cranelift_call())
        .add_fn(fn_rt_cranelift_call_indirect())

fn fn_rt_cranelift_call() -> FFIFnSpec:
    var spec = FFIFnSpec__unsafe_extern_c("rt_cranelift_call",
        [FFIParamSpec__simple("ctx", "i64"),
         FFIParamSpec__simple("func", "i64"),
         FFIParamSpec__simple("args_ptr", "i64"),
         FFIParamSpec__simple("args_len", "i64")],
        "i64",
        CRANELIFT_VALUE_ID_BODY
    )
    spec.doc = "Direct function call"
    spec

fn fn_rt_cranelift_call_indirect() -> FFIFnSpec:
    var spec = FFIFnSpec__unsafe_extern_c("rt_cranelift_call_indirect",
        [FFIParamSpec__simple("ctx", "i64"),
         FFIParamSpec__simple("sig", "i64"),
         FFIParamSpec__simple("addr", "i64"),
         FFIParamSpec__simple("args_ptr", "i64"),
         FFIParamSpec__simple("args_len", "i64")],
        "i64",
        CRANELIFT_VALUE_ID_BODY
    )
    spec.doc = "Indirect function call"
    spec

# ============================================================================
# Type Conversion Functions
# ============================================================================

fn add_conversion_fns(builder: ModuleBuilder) -> ModuleBuilder:
    var result = builder
    val convs = [
        "rt_cranelift_sextend", "rt_cranelift_uextend", "rt_cranelift_ireduce",
        "rt_cranelift_fcvt_to_sint", "rt_cranelift_fcvt_to_uint",
        "rt_cranelift_fcvt_from_sint", "rt_cranelift_fcvt_from_uint",
        "rt_cranelift_bitcast"
    ]
    for conv in convs:
        result = result.add_fn(make_conversion_fn(conv))
    result

fn make_conversion_fn(name: text) -> FFIFnSpec:
    var spec = FFIFnSpec__unsafe_extern_c(name,
        [FFIParamSpec__simple("ctx", "i64"),
         FFIParamSpec__simple("to_type", "i64"),
         FFIParamSpec__simple("value", "i64")],
        "i64",
        CRANELIFT_VALUE_ID_BODY
    )
    spec.doc = "Type conversion operation"
    spec

# ============================================================================
# Block Parameter Functions
# ============================================================================

fn add_block_param_fns(builder: ModuleBuilder) -> ModuleBuilder:
    builder
        .add_fn(fn_rt_cranelift_append_block_param())
        .add_fn(fn_rt_cranelift_block_param())

fn fn_rt_cranelift_append_block_param() -> FFIFnSpec:
    var spec = FFIFnSpec__unsafe_extern_c("rt_cranelift_append_block_param",
        [FFIParamSpec__simple("ctx", "i64"),
         FFIParamSpec__simple("block", "i64"),
         FFIParamSpec__simple("type_", "i64")],
        "i64",
        CRANELIFT_VALUE_ID_BODY
    )
    spec.doc = "Append a block parameter"
    spec

fn fn_rt_cranelift_block_param() -> FFIFnSpec:
    var spec = FFIFnSpec__unsafe_extern_c("rt_cranelift_block_param",
        [FFIParamSpec__simple("ctx", "i64"),
         FFIParamSpec__simple("block", "i64"),
         FFIParamSpec__simple("index", "i64")],
        "i64",
        CRANELIFT_VALUE_ID_BODY
    )
    spec.doc = "Get a block parameter value"
    spec

# ============================================================================
# JIT Execution Functions
# ============================================================================

fn add_jit_execution_fns(builder: ModuleBuilder) -> ModuleBuilder:
    builder
        .add_fn(fn_rt_cranelift_get_function_ptr())

fn fn_rt_cranelift_get_function_ptr() -> FFIFnSpec:
    var spec = FFIFnSpec__unsafe_extern_c("rt_cranelift_get_function_ptr",
        [FFIParamSpec__simple("module", "i64"),
         FFIParamSpec__simple("name_ptr", "i64"),
         FFIParamSpec__simple("name_len", "i64")],
        "i64",
        "let name = string_from_ptr(name_ptr, name_len);{NL}" +
        "let mut modules = JIT_MODULES.lock().unwrap();{NL}" +
        "if let Some(ctx) = modules.get_mut(&module) {{NL}" +
        "    if let Some(func_id) = ctx.func_ids.get(&name) {{NL}" +
        "        return ctx.module.get_finalized_function(*func_id) as i64;{NL}" +
        "    }{NL}" +
        "}{NL}" +
        "0"
    )
    spec.doc = "Get function pointer for JIT-compiled function"
    spec

# ============================================================================
# AOT Functions
# ============================================================================

fn add_aot_fns(builder: ModuleBuilder) -> ModuleBuilder:
    builder
        .add_fn(fn_rt_cranelift_new_aot_module())
        .add_fn(fn_rt_cranelift_aot_define_function())
        .add_fn(fn_rt_cranelift_emit_object())

fn fn_rt_cranelift_new_aot_module() -> FFIFnSpec:
    var spec = FFIFnSpec__unsafe_extern_c("rt_cranelift_new_aot_module",
        [FFIParamSpec__simple("name_ptr", "i64"),
         FFIParamSpec__simple("name_len", "i64"),
         FFIParamSpec__simple("target", "i64")],
        "i64",
        "let name = string_from_ptr(name_ptr, name_len);{NL}" +
        "if name.is_empty() {{NL}" +
        "    return 0;{NL}" +
        "}{NL}" +
        "let handle = next_handle();{NL}" +
        "handle"
    )
    spec.doc = "Create a new AOT module for object file generation"
    spec

fn fn_rt_cranelift_aot_define_function() -> FFIFnSpec:
    var spec = FFIFnSpec__unsafe_extern_c("rt_cranelift_aot_define_function",
        [FFIParamSpec__simple("module", "i64"),
         FFIParamSpec__simple("func_id", "i64"),
         FFIParamSpec__simple("ctx", "i64")],
        "bool",
        "true"
    )
    spec.doc = "Define a function in AOT module"
    spec

fn fn_rt_cranelift_emit_object() -> FFIFnSpec:
    var spec = FFIFnSpec__unsafe_extern_c("rt_cranelift_emit_object",
        [FFIParamSpec__simple("module", "i64"),
         FFIParamSpec__simple("path_ptr", "i64"),
         FFIParamSpec__simple("path_len", "i64")],
        "bool",
        "let _path = string_from_ptr(path_ptr, path_len);{NL}" +
        "let modules = AOT_MODULES.lock().unwrap();{NL}" +
        "modules.contains_key(&module)"
    )
    spec.doc = "Emit object file from AOT module"
    spec

# ============================================================================
# Additional Helper: Implementation Function
# ============================================================================

fn add_impl_helpers(builder: ModuleBuilder) -> ModuleBuilder:
    # Add the implementation helper function that new_module uses
    builder.add_raw(
        "unsafe fn rt_cranelift_new_module_impl(name: &str, target: i64) -> i64 {{NL}" +
        "    if name.is_empty() {{NL}" +
        "        return 0;{NL}" +
        "    }{NL}" +
        "{NL}" +
        "    // Build settings and ISA{NL}" +
        "    let mut flag_builder = settings::builder();{NL}" +
        "    if flag_builder.set(\"opt_level\", \"speed\").is_err() {{NL}" +
        "        return 0;{NL}" +
        "    }{NL}" +
        "    if flag_builder.set(\"is_pic\", \"true\").is_err() {{NL}" +
        "        return 0;{NL}" +
        "    }{NL}" +
        "{NL}" +
        "    // Select target triple based on target code{NL}" +
        "    let triple = match target {{NL}" +
        "        CL_TARGET_X86_64 => \"x86_64-unknown-linux-gnu\"{NL}" +
        "            .parse::<Triple>(){NL}" +
        "            .unwrap_or_else(|_| Triple::host()),{NL}" +
        "        CL_TARGET_AARCH64 => \"aarch64-unknown-linux-gnu\"{NL}" +
        "            .parse::<Triple>(){NL}" +
        "            .unwrap_or_else(|_| Triple::host()),{NL}" +
        "        CL_TARGET_RISCV64 => \"riscv64gc-unknown-linux-gnu\"{NL}" +
        "            .parse::<Triple>(){NL}" +
        "            .unwrap_or_else(|_| Triple::host()),{NL}" +
        "        _ => Triple::host(),{NL}" +
        "    };{NL}" +
        "{NL}" +
        "    let flags = settings::Flags::new(flag_builder);{NL}" +
        "{NL}" +
        "    // Create ISA from triple{NL}" +
        "    let isa_builder = match cranelift_codegen::isa::lookup(triple) {{NL}" +
        "        Ok(b) => b,{NL}" +
        "        Err(_) => return 0,{NL}" +
        "    };{NL}" +
        "{NL}" +
        "    let isa = match isa_builder.finish(flags) {{NL}" +
        "        Ok(isa) => isa,{NL}" +
        "        Err(_) => return 0,{NL}" +
        "    };{NL}" +
        "{NL}" +
        "    // Create JIT module{NL}" +
        "    let builder = JITBuilder::with_isa(isa, cranelift_module::default_libcall_names());{NL}" +
        "{NL}" +
        "    let module = JITModule::new(builder);{NL}" +
        "    let handle = next_handle();{NL}" +
        "{NL}" +
        "    let ctx = JITModuleContext {{NL}" +
        "        module,{NL}" +
        "        func_ids: HashMap::new(),{NL}" +
        "    };{NL}" +
        "{NL}" +
        "    JIT_MODULES.lock().unwrap().insert(handle, ctx);{NL}" +
        "    handle{NL}" +
        "}{NL}"
    )

export add_function_call_fns, add_conversion_fns, add_block_param_fns
export add_jit_execution_fns, add_aot_fns, add_impl_helpers
