# Cranelift Core Module - Complete Specification
#
# Complete specification for generating cranelift_ffi.rs with:
# - Module management (JIT and AOT)
# - Function signatures and building
# - Block management and control flow
# - Value creation and arithmetic operations
# - Memory operations and stack management
# - Function calls and type conversions
#
# Refactored: Functions split into submodules:
# - cranelift_codegen.spl: Module mgmt, signatures, function building, blocks, values
# - cranelift_ops.spl: Arithmetic, comparison, memory, control flow
# - cranelift_advanced.spl: Function calls, conversions, block params, JIT, AOT, helpers
#
# Usage: simple ffi-gen --gen-module specs/cranelift_core.spl

use app.ffi_gen.types*
use app.ffi_gen.module_gen (ModuleBuilder)

# Import from submodules
use app.ffi_gen.specs.cranelift_codegen.{add_module_management_fns, add_signature_fns, add_function_building_fns, add_block_management_fns, add_value_creation_fns}
use app.ffi_gen.specs.cranelift_ops.{add_arithmetic_fns, add_comparison_fns, add_memory_fns, add_control_flow_fns}
use app.ffi_gen.specs.cranelift_advanced.{add_function_call_fns, add_conversion_fns, add_block_param_fns, add_jit_execution_fns, add_aot_fns, add_impl_helpers}
use std.text.{NL}

# ============================================================================
# Module Specification
# ============================================================================

fn cranelift_module() -> ModuleSpec:
    var builder = ModuleBuilder__start("cranelift_ffi")
        .doc("Cranelift FFI for Self-Hosting Simple Compiler{NL}{NL}This module provides FFI functions that expose Cranelift code generation{NL}capabilities to Simple code. This enables the self-hosting compiler{NL}(simple/compiler/*.spl) to generate native code.")

    # Imports
    builder = add_cranelift_imports(builder)

    # Constants and helper functions (raw code section)
    builder = builder.add_raw(generate_constants_and_helpers())

    # FFI functions by category (46 total)
    builder = add_module_management_fns(builder)      # 4 functions
    builder = add_signature_fns(builder)              # 3 functions
    builder = add_function_building_fns(builder)      # 4 functions
    builder = add_block_management_fns(builder)       # 4 functions
    builder = add_value_creation_fns(builder)         # 4 functions
    builder = add_arithmetic_fns(builder)             # 18 functions (17 binops + 1 unop)
    builder = add_comparison_fns(builder)             # 2 functions
    builder = add_memory_fns(builder)                 # 4 functions
    builder = add_control_flow_fns(builder)           # 5 functions
    builder = add_function_call_fns(builder)          # 3 functions
    builder = add_conversion_fns(builder)             # 8 functions
    builder = add_block_param_fns(builder)            # 2 functions
    builder = add_jit_execution_fns(builder)          # 2 functions
    builder = add_aot_fns(builder)                    # 3 functions

    builder.build()

# ============================================================================
# Imports
# ============================================================================

fn add_cranelift_imports(builder: ModuleBuilder) -> ModuleBuilder:
    builder
        .add_import_items("std::collections", ["HashMap"])
        .add_import_items("std::sync", ["Mutex"])
        .add_import_items("cranelift_codegen::ir", [
            "types", "AbiParam", "Block", "Function", "InstBuilder",
            "MemFlags", "Signature", "StackSlotData", "StackSlotKind", "Value"
        ])
        .add_import("cranelift_codegen::isa::CallConv")
        .add_import_items("cranelift_codegen::settings", ["self", "Configurable"])
        .add_import("cranelift_codegen::Context")
        .add_import_items("cranelift_frontend", ["FunctionBuilder", "FunctionBuilderContext", "Variable"])
        .add_import_items("cranelift_jit", ["JITBuilder", "JITModule"])
        .add_import_items("cranelift_module", ["Linkage", "Module"])
        .add_import_items("cranelift_object", ["ObjectBuilder", "ObjectModule"])
        .add_import("target_lexicon::Triple")
        .add_import("lazy_static::lazy_static")
        .add_import("simple_runtime::RuntimeValue")
        .add_import("simple_runtime::value::{rt_string_len, rt_string_data, rt_string_new}")

# ============================================================================
# Constants and Helper Functions
# ============================================================================

fn generate_constants_and_helpers() -> text:
    "// ============================================================================{NL}" +
    "// Handle Management{NL}" +
    "// ============================================================================{NL}" +
    "{NL}" +
    "/// Unique handle counter for resources{NL}" +
    "static HANDLE_COUNTER: std::sync::atomic::AtomicI64 = std::sync::atomic::AtomicI64::new(1);{NL}" +
    "{NL}" +
    "fn next_handle() -> i64 {{NL}" +
    "    HANDLE_COUNTER.fetch_add(1, std::sync::atomic::Ordering::Relaxed){NL}" +
    "}{NL}" +
    "{NL}" +
    "lazy_static! {{NL}" +
    "    /// Global registry of JIT modules{NL}" +
    "    static ref JIT_MODULES: Mutex<HashMap<i64, JITModuleContext>> = Mutex::new(HashMap::new());{NL}" +
    "{NL}" +
    "    /// Global registry of AOT modules{NL}" +
    "    static ref AOT_MODULES: Mutex<HashMap<i64, ObjectModuleContext>> = Mutex::new(HashMap::new());{NL}" +
    "{NL}" +
    "    /// Global registry of function builder contexts{NL}" +
    "    static ref FUNC_CONTEXTS: Mutex<HashMap<i64, FuncBuildContext>> = Mutex::new(HashMap::new());{NL}" +
    "{NL}" +
    "    /// Global registry of signatures{NL}" +
    "    static ref SIGNATURES: Mutex<HashMap<i64, Signature>> = Mutex::new(HashMap::new());{NL}" +
    "}{NL}" +
    "{NL}" +
    "// ============================================================================{NL}" +
    "// Module Context Types{NL}" +
    "// ============================================================================{NL}" +
    "{NL}" +
    "/// Context for JIT compilation{NL}" +
    "struct JITModuleContext {{NL}" +
    "    module: JITModule,{NL}" +
    "    func_ids: HashMap<String, cranelift_module::FuncId>,{NL}" +
    "}{NL}" +
    "{NL}" +
    "/// Context for AOT compilation{NL}" +
    "struct ObjectModuleContext {{NL}" +
    "    module: ObjectModule,{NL}" +
    "    func_ids: HashMap<String, cranelift_module::FuncId>,{NL}" +
    "}{NL}" +
    "{NL}" +
    "/// Context for building a single function{NL}" +
    "struct FuncBuildContext {{NL}" +
    "    module_handle: i64,{NL}" +
    "    is_jit: bool,{NL}" +
    "    ctx: Context,{NL}" +
    "    func_builder_ctx: FunctionBuilderContext,{NL}" +
    "    blocks: HashMap<i64, Block>,{NL}" +
    "    values: HashMap<i64, Value>,{NL}" +
    "    next_block_id: i64,{NL}" +
    "    next_value_id: i64,{NL}" +
    "}{NL}" +
    "{NL}" +
    "// ============================================================================{NL}" +
    "// Type Constants{NL}" +
    "// ============================================================================{NL}" +
    "{NL}" +
    "const CL_TYPE_I8: i64 = 1;{NL}" +
    "const CL_TYPE_I16: i64 = 2;{NL}" +
    "const CL_TYPE_I32: i64 = 3;{NL}" +
    "const CL_TYPE_I64: i64 = 4;{NL}" +
    "const CL_TYPE_F32: i64 = 5;{NL}" +
    "const CL_TYPE_F64: i64 = 6;{NL}" +
    "const CL_TYPE_B1: i64 = 7;{NL}" +
    "const CL_TYPE_PTR: i64 = 8;{NL}" +
    "{NL}" +
    "const CL_TARGET_X86_64: i64 = 0;{NL}" +
    "const CL_TARGET_AARCH64: i64 = 1;{NL}" +
    "const CL_TARGET_RISCV64: i64 = 2;{NL}" +
    "{NL}" +
    "const CL_CMP_EQ: i64 = 0;{NL}" +
    "const CL_CMP_NE: i64 = 1;{NL}" +
    "const CL_CMP_SLT: i64 = 2;{NL}" +
    "const CL_CMP_SLE: i64 = 3;{NL}" +
    "const CL_CMP_SGT: i64 = 4;{NL}" +
    "const CL_CMP_SGE: i64 = 5;{NL}" +
    "const CL_CMP_ULT: i64 = 6;{NL}" +
    "const CL_CMP_ULE: i64 = 7;{NL}" +
    "const CL_CMP_UGT: i64 = 8;{NL}" +
    "const CL_CMP_UGE: i64 = 9;{NL}" +
    "{NL}" +
    "fn type_from_code(code: i64) -> types::Type {{NL}" +
    "    match code {{NL}" +
    "        CL_TYPE_I8 => types::I8,{NL}" +
    "        CL_TYPE_I16 => types::I16,{NL}" +
    "        CL_TYPE_I32 => types::I32,{NL}" +
    "        CL_TYPE_I64 => types::I64,{NL}" +
    "        CL_TYPE_F32 => types::F32,{NL}" +
    "        CL_TYPE_F64 => types::F64,{NL}" +
    "        CL_TYPE_B1 => types::I8,   // Booleans as i8{NL}" +
    "        CL_TYPE_PTR => types::I64, // Pointers as i64{NL}" +
    "        _ => types::I64,{NL}" +
    "    }{NL}" +
    "}{NL}" +
    "{NL}" +
    "fn int_cc_from_code(code: i64) -> cranelift_codegen::ir::condcodes::IntCC {{NL}" +
    "    use cranelift_codegen::ir::condcodes::IntCC;{NL}" +
    "    match code {{NL}" +
    "        CL_CMP_EQ => IntCC::Equal,{NL}" +
    "        CL_CMP_NE => IntCC::NotEqual,{NL}" +
    "        CL_CMP_SLT => IntCC::SignedLessThan,{NL}" +
    "        CL_CMP_SLE => IntCC::SignedLessThanOrEqual,{NL}" +
    "        CL_CMP_SGT => IntCC::SignedGreaterThan,{NL}" +
    "        CL_CMP_SGE => IntCC::SignedGreaterThanOrEqual,{NL}" +
    "        CL_CMP_ULT => IntCC::UnsignedLessThan,{NL}" +
    "        CL_CMP_ULE => IntCC::UnsignedLessThanOrEqual,{NL}" +
    "        CL_CMP_UGT => IntCC::UnsignedGreaterThan,{NL}" +
    "        CL_CMP_UGE => IntCC::UnsignedGreaterThanOrEqual,{NL}" +
    "        _ => IntCC::Equal,{NL}" +
    "    }{NL}" +
    "}{NL}" +
    "{NL}" +
    "fn float_cc_from_code(code: i64) -> cranelift_codegen::ir::condcodes::FloatCC {{NL}" +
    "    use cranelift_codegen::ir::condcodes::FloatCC;{NL}" +
    "    match code {{NL}" +
    "        0 => FloatCC::Equal,{NL}" +
    "        1 => FloatCC::NotEqual,{NL}" +
    "        2 => FloatCC::LessThan,{NL}" +
    "        3 => FloatCC::LessThanOrEqual,{NL}" +
    "        4 => FloatCC::GreaterThan,{NL}" +
    "        5 => FloatCC::GreaterThanOrEqual,{NL}" +
    "        _ => FloatCC::Equal,{NL}" +
    "    }{NL}" +
    "}{NL}" +
    "{NL}" +
    "// ============================================================================{NL}" +
    "// Helper Functions{NL}" +
    "// ============================================================================{NL}" +
    "{NL}" +
    "unsafe fn string_from_ptr(ptr: i64, len: i64) -> String {{NL}" +
    "    if ptr == 0 || len <= 0 {{NL}" +
    "        return String::new();{NL}" +
    "    }{NL}" +
    "    let slice = std::slice::from_raw_parts(ptr as *const u8, len as usize);{NL}" +
    "    String::from_utf8_lossy(slice).to_string(){NL}" +
    "}{NL}" +
    "{NL}" +
    "/// Extract string from RuntimeValue{NL}" +
    "fn extract_string(val: RuntimeValue) -> Option<String> {{NL}" +
    "    let len = rt_string_len(val);{NL}" +
    "    if len <= 0 {{NL}" +
    "        return None;{NL}" +
    "    }{NL}" +
    "    let data = rt_string_data(val);{NL}" +
    "    if data.is_null() {{NL}" +
    "        return None;{NL}" +
    "    }{NL}" +
    "    unsafe {{NL}" +
    "        let slice = std::slice::from_raw_parts(data, len as usize);{NL}" +
    "        Some(String::from_utf8_lossy(slice).to_string()){NL}" +
    "    }{NL}" +
    "}{NL}" +
    "{NL}"

export cranelift_module
