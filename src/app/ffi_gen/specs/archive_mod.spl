# Archive Module - Full Specification
#
# Complete specification for generating archive.rs with:
# - Tar archive operations
# - Gzip compression
# - XZ compression
#
# Usage: simple ffi-gen --gen-module specs/archive_mod.spl

use app.ffi_gen.types*
use app.ffi_gen.module_gen (ModuleBuilder)
use std.text.{NL}

# ============================================================================
# Module Specification
# ============================================================================

fn archive_module() -> ModuleSpec:
    var builder = ModuleBuilder__start("archive")
        .doc("Archive and Compression FFI{NL}{NL}Tar archives, gzip, and xz compression.")

    # Imports
    builder = builder
        .add_import_items("std::ffi", ["CStr", "CString"])
        .add_import("std::os::raw::c_char")
        .add_import_items("std::fs", ["File"])
        .add_import_items("std::io", ["Read", "Write"])
        .add_import("tar::Archive")
        .add_import("flate2::read::GzDecoder")
        .add_import("flate2::write::GzEncoder")
        .add_import("flate2::Compression")

    # Archive functions
    builder = builder
        .add_fn(fn_rt_tar_extract())
        .add_fn(fn_rt_tar_create())
        .add_fn(fn_rt_gzip_compress())
        .add_fn(fn_rt_gzip_decompress())

    builder.build()

# ============================================================================
# Archive Functions
# ============================================================================

fn fn_rt_tar_extract() -> FFIFnSpec:
    var spec = FFIFnSpec__unsafe_extern_c("rt_tar_extract",
        [FFIParamSpec__raw_ptr("tar_path", "*const c_char"),
         FFIParamSpec__raw_ptr("dest_dir", "*const c_char")],
        "bool",
        "let tar_str = CStr::from_ptr(tar_path as *const i8).to_string_lossy();{NL}" +
        "let dest_str = CStr::from_ptr(dest_dir as *const i8).to_string_lossy();{NL}" +
        "match File::open(tar_str.as_ref()) {{NL}" +
        "    Ok(file) => {{NL}" +
        "        let mut archive = Archive::new(file);{NL}" +
        "        archive.unpack(dest_str.as_ref()).is_ok(){NL}" +
        "    }{NL}" +
        "    Err(_) => false,{NL}" +
        "}"
    )
    spec.doc = "Extract tar archive to directory"
    spec

fn fn_rt_tar_create() -> FFIFnSpec:
    var spec = FFIFnSpec__unsafe_extern_c("rt_tar_create",
        [FFIParamSpec__raw_ptr("tar_path", "*const c_char"),
         FFIParamSpec__raw_ptr("_src_dir", "*const c_char")],
        "bool",
        "// TODO: Implement tar creation{NL}" +
        "let _tar_str = CStr::from_ptr(tar_path as *const i8).to_string_lossy();{NL}" +
        "false"
    )
    spec.doc = "Create tar archive from directory (not yet implemented)"
    spec

fn fn_rt_gzip_compress() -> FFIFnSpec:
    var spec = FFIFnSpec__unsafe_extern_c("rt_gzip_compress",
        [FFIParamSpec__raw_ptr("input_path", "*const c_char"),
         FFIParamSpec__raw_ptr("output_path", "*const c_char")],
        "bool",
        "let in_str = CStr::from_ptr(input_path as *const i8).to_string_lossy();{NL}" +
        "let out_str = CStr::from_ptr(output_path as *const i8).to_string_lossy();{NL}" +
        "match (File::open(in_str.as_ref()), File::create(out_str.as_ref())) {{NL}" +
        "    (Ok(mut input), Ok(output)) => {{NL}" +
        "        let mut encoder = GzEncoder::new(output, Compression::default());{NL}" +
        "        let mut buffer = Vec::new();{NL}" +
        "        if input.read_to_end(&mut buffer).is_err() {{NL}" +
        "            return false;{NL}" +
        "        }{NL}" +
        "        encoder.write_all(&buffer).is_ok() && encoder.finish().is_ok(){NL}" +
        "    }{NL}" +
        "    _ => false,{NL}" +
        "}"
    )
    spec.doc = "Compress file with gzip"
    spec

fn fn_rt_gzip_decompress() -> FFIFnSpec:
    var spec = FFIFnSpec__unsafe_extern_c("rt_gzip_decompress",
        [FFIParamSpec__raw_ptr("input_path", "*const c_char"),
         FFIParamSpec__raw_ptr("output_path", "*const c_char")],
        "bool",
        "let in_str = CStr::from_ptr(input_path as *const i8).to_string_lossy();{NL}" +
        "let out_str = CStr::from_ptr(output_path as *const i8).to_string_lossy();{NL}" +
        "match (File::open(in_str.as_ref()), File::create(out_str.as_ref())) {{NL}" +
        "    (Ok(input), Ok(mut output)) => {{NL}" +
        "        let mut decoder = GzDecoder::new(input);{NL}" +
        "        let mut buffer = Vec::new();{NL}" +
        "        if decoder.read_to_end(&mut buffer).is_err() {{NL}" +
        "            return false;{NL}" +
        "        }{NL}" +
        "        output.write_all(&buffer).is_ok(){NL}" +
        "    }{NL}" +
        "    _ => false,{NL}" +
        "}"
    )
    spec.doc = "Decompress gzip file"
    spec
export archive_module
