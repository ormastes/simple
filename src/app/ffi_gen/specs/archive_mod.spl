# Archive Module - Full Specification
#
# Complete specification for generating archive.rs with:
# - Tar archive operations
# - Gzip compression
# - XZ compression
#
# Usage: simple ffi-gen --gen-module specs/archive_mod.spl

use app.ffi_gen.types*
use app.ffi_gen.module_gen (ModuleBuilder)

# ============================================================================
# Module Specification
# ============================================================================

fn archive_module() -> ModuleSpec:
    var builder = ModuleBuilder.start("archive")
        .doc("Archive and Compression FFI\n\nTar archives, gzip, and xz compression.")

    # Imports
    builder = builder
        .add_import_items("std::ffi", ["CStr", "CString"])
        .add_import("std::os::raw::c_char")
        .add_import_items("std::fs", ["File"])
        .add_import_items("std::io", ["Read", "Write"])
        .add_import("tar::Archive")
        .add_import("flate2::read::GzDecoder")
        .add_import("flate2::write::GzEncoder")
        .add_import("flate2::Compression")

    # Archive functions
    builder = builder
        .add_fn(fn_rt_tar_extract())
        .add_fn(fn_rt_tar_create())
        .add_fn(fn_rt_gzip_compress())
        .add_fn(fn_rt_gzip_decompress())

    builder.build()

# ============================================================================
# Archive Functions
# ============================================================================

fn fn_rt_tar_extract() -> FFIFnSpec:
    var spec = FFIFnSpec.unsafe_extern_c("rt_tar_extract",
        [FFIParamSpec.raw_ptr("tar_path", "*const c_char"),
         FFIParamSpec.raw_ptr("dest_dir", "*const c_char")],
        "bool",
        "let tar_str = CStr::from_ptr(tar_path as *const i8).to_string_lossy();\n" +
        "let dest_str = CStr::from_ptr(dest_dir as *const i8).to_string_lossy();\n" +
        "match File::open(tar_str.as_ref()) {\n" +
        "    Ok(file) => {\n" +
        "        let mut archive = Archive::new(file);\n" +
        "        archive.unpack(dest_str.as_ref()).is_ok()\n" +
        "    }\n" +
        "    Err(_) => false,\n" +
        "}"
    )
    spec.doc = "Extract tar archive to directory"
    spec

fn fn_rt_tar_create() -> FFIFnSpec:
    var spec = FFIFnSpec.unsafe_extern_c("rt_tar_create",
        [FFIParamSpec.raw_ptr("tar_path", "*const c_char"),
         FFIParamSpec.raw_ptr("_src_dir", "*const c_char")],
        "bool",
        "// TODO: Implement tar creation\n" +
        "let _tar_str = CStr::from_ptr(tar_path as *const i8).to_string_lossy();\n" +
        "false"
    )
    spec.doc = "Create tar archive from directory (not yet implemented)"
    spec

fn fn_rt_gzip_compress() -> FFIFnSpec:
    var spec = FFIFnSpec.unsafe_extern_c("rt_gzip_compress",
        [FFIParamSpec.raw_ptr("input_path", "*const c_char"),
         FFIParamSpec.raw_ptr("output_path", "*const c_char")],
        "bool",
        "let in_str = CStr::from_ptr(input_path as *const i8).to_string_lossy();\n" +
        "let out_str = CStr::from_ptr(output_path as *const i8).to_string_lossy();\n" +
        "match (File::open(in_str.as_ref()), File::create(out_str.as_ref())) {\n" +
        "    (Ok(mut input), Ok(output)) => {\n" +
        "        let mut encoder = GzEncoder::new(output, Compression::default());\n" +
        "        let mut buffer = Vec::new();\n" +
        "        if input.read_to_end(&mut buffer).is_err() {\n" +
        "            return false;\n" +
        "        }\n" +
        "        encoder.write_all(&buffer).is_ok() && encoder.finish().is_ok()\n" +
        "    }\n" +
        "    _ => false,\n" +
        "}"
    )
    spec.doc = "Compress file with gzip"
    spec

fn fn_rt_gzip_decompress() -> FFIFnSpec:
    var spec = FFIFnSpec.unsafe_extern_c("rt_gzip_decompress",
        [FFIParamSpec.raw_ptr("input_path", "*const c_char"),
         FFIParamSpec.raw_ptr("output_path", "*const c_char")],
        "bool",
        "let in_str = CStr::from_ptr(input_path as *const i8).to_string_lossy();\n" +
        "let out_str = CStr::from_ptr(output_path as *const i8).to_string_lossy();\n" +
        "match (File::open(in_str.as_ref()), File::create(out_str.as_ref())) {\n" +
        "    (Ok(input), Ok(mut output)) => {\n" +
        "        let mut decoder = GzDecoder::new(input);\n" +
        "        let mut buffer = Vec::new();\n" +
        "        if decoder.read_to_end(&mut buffer).is_err() {\n" +
        "            return false;\n" +
        "        }\n" +
        "        output.write_all(&buffer).is_ok()\n" +
        "    }\n" +
        "    _ => false,\n" +
        "}"
    )
    spec.doc = "Decompress gzip file"
    spec
export archive_module
