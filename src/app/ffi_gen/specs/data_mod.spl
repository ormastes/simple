# Data Module - Full Specification
#
# Complete specification for generating data.rs with:
# - Regex pattern matching
# - String interning
# - Data structures
#
# Usage: simple ffi-gen --gen-module specs/data_mod.spl

use app.ffi_gen.types*
use app.ffi_gen.module_gen (ModuleBuilder)
use std.string.{NL}

# ============================================================================
# Module Specification
# ============================================================================

fn data_module() -> ModuleSpec:
    var builder = ModuleBuilder__start("data")
        .doc("Data Structures FFI{NL}{NL}Regex, string interning, and data structures.")

    # Imports
    builder = builder
        .add_import_items("std::ffi", ["CStr", "CString"])
        .add_import("std::os::raw::c_char")
        .add_import("regex::Regex")

    # Data functions
    builder = builder
        .add_fn(fn_rt_regex_match())
        .add_fn(fn_rt_regex_find_all())
        .add_fn(fn_rt_regex_replace())

    builder.build()

# ============================================================================
# Data Functions
# ============================================================================

fn fn_rt_regex_match() -> FFIFnSpec:
    var spec = FFIFnSpec__unsafe_extern_c("rt_regex_match",
        [FFIParamSpec__raw_ptr("pattern", "*const c_char"),
         FFIParamSpec__raw_ptr("text", "*const c_char")],
        "bool",
        "let pattern_str = CStr::from_ptr(pattern as *const i8).to_string_lossy();{NL}" +
        "let text_str = CStr::from_ptr(text as *const i8).to_string_lossy();{NL}" +
        "match Regex::new(pattern_str.as_ref()) {{NL}" +
        "    Ok(re) => re.is_match(text_str.as_ref()),{NL}" +
        "    Err(_) => false,{NL}" +
        "}"
    )
    spec.doc = "Check if text matches regex pattern"
    spec

fn fn_rt_regex_find_all() -> FFIFnSpec:
    var spec = FFIFnSpec__unsafe_extern_c("rt_regex_find_all",
        [FFIParamSpec__raw_ptr("pattern", "*const c_char"),
         FFIParamSpec__raw_ptr("text", "*const c_char")],
        "*mut c_char",
        "let pattern_str = CStr::from_ptr(pattern as *const i8).to_string_lossy();{NL}" +
        "let text_str = CStr::from_ptr(text as *const i8).to_string_lossy();{NL}" +
        "match Regex::new(pattern_str.as_ref()) {{NL}" +
        "    Ok(re) => {{NL}" +
        "        let matches: Vec<String> = re.find_iter(text_str.as_ref()){NL}" +
        "            .map(|m| m.as_str().to_string()){NL}" +
        "            .collect();{NL}" +
        "        let joined = matches.join(\"\{NL}\");\n" +
        "        CString::new(joined).ok().map(|c| c.into_raw()).unwrap_or(std::ptr::null_mut()){NL}" +
        "    }{NL}" +
        "    Err(_) => std::ptr::null_mut(),{NL}" +
        "}"
    )
    spec.doc = "Find all regex matches (newline-separated)"
    spec

fn fn_rt_regex_replace() -> FFIFnSpec:
    var spec = FFIFnSpec__unsafe_extern_c("rt_regex_replace",
        [FFIParamSpec__raw_ptr("pattern", "*const c_char"),
         FFIParamSpec__raw_ptr("text", "*const c_char"),
         FFIParamSpec__raw_ptr("replacement", "*const c_char")],
        "*mut c_char",
        "let pattern_str = CStr::from_ptr(pattern as *const i8).to_string_lossy();{NL}" +
        "let text_str = CStr::from_ptr(text as *const i8).to_string_lossy();{NL}" +
        "let repl_str = CStr::from_ptr(replacement as *const i8).to_string_lossy();{NL}" +
        "match Regex::new(pattern_str.as_ref()) {{NL}" +
        "    Ok(re) => {{NL}" +
        "        let result = re.replace_all(text_str.as_ref(), repl_str.as_ref()).to_string();{NL}" +
        "        CString::new(result).ok().map(|c| c.into_raw()).unwrap_or(std::ptr::null_mut()){NL}" +
        "    }{NL}" +
        "    Err(_) => std::ptr::null_mut(),{NL}" +
        "}"
    )
    spec.doc = "Replace all regex matches"
    spec
export data_module
