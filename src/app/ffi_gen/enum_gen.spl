# FFI Wrapper Generator - Enum Code Generation
#
# Generates Rust enum definitions from EnumSpec.
#
# Usage:
#   import app.ffi_gen.enum_gen (generate_enum)

use app.ffi_gen.types*
use std.text.{NL}

# ============================================================================
# Enum Generation
# ============================================================================

# Generate a complete Rust enum definition
fn generate_enum(spec: EnumSpec) -> text:
    var out = ""

    # Doc comment
    if spec.doc != "":
        for line in spec.doc.split(NL):
            out = out + "/// {line}{NL}"

    # Attributes
    if spec.repr_attr != "":
        out = out + "#[repr({spec.repr_attr})]{NL}"

    if spec.derives.len() > 0:
        val derives_str = spec.derives.join(", ")
        out = out + "#[derive({derives_str})]{NL}"

    # Visibility and name
    val vis = if spec.visibility != "": "{spec.visibility} " else: ""
    val generics_str = if spec.generics.len() > 0: "<{spec.generics.join(\", \")}>" else: ""

    out = out + "{vis}enum {spec.name}{generics_str} {{{NL}"

    # Variants
    for variant in spec.variants:
        out = out + generate_enum_variant(variant)

    out = out + "}}{NL}"
    out

# Generate a single enum variant
fn generate_enum_variant(variant: EnumVariantSpec) -> text:
    var out = ""

    # Doc comment
    if variant.doc != "":
        for line in variant.doc.split(NL):
            out = out + "    /// {line}{NL}"

    # Variant body
    if variant.tuple_fields.len() > 0:
        # Tuple variant: Variant(T1, T2)
        val fields_str = variant.tuple_fields.join(", ")
        out = out + "    {variant.name}({fields_str})"
    elif variant.struct_fields.len() > 0:
        # Struct variant: Variant { field: Type }
        out = out + "    {variant.name} {{{NL}"
        for field in variant.struct_fields:
            val vis = if field.visibility != "": "{field.visibility} " else: ""
            out = out + "        {vis}{field.name}: {field.rust_type},{NL}"
        out = out + "    }}"
    else:
        # Unit variant
        out = out + "    {variant.name}"

    # Discriminant
    if variant.discriminant != "":
        out = out + " = {variant.discriminant}"

    out = out + ",{NL}"
    out

# ============================================================================
# Helper Functions
# ============================================================================

# Generate a simple C-repr enum with unit variants
fn generate_c_enum(name: text, variants: [text]) -> text:
    var variant_specs: [EnumVariantSpec] = []
    for v in variants:
        variant_specs.push(EnumVariantSpec.unit(v))

    val spec = EnumSpec.c_repr(name, variant_specs)
    generate_enum(spec)

# Generate a C-repr enum with explicit discriminant values
fn generate_c_enum_with_values(name: text, variants: [{text: text}]) -> text:
    var variant_specs: [EnumVariantSpec] = []
    for entry in variants:
        for vname in entry.keys():
            val value = entry[vname]
            variant_specs.push(EnumVariantSpec.unit_with_value(vname, value))

    val spec = EnumSpec.c_repr(name, variant_specs)
    generate_enum(spec)

# Generate a tagged union enum (like RuntimeValue)
fn generate_tagged_union(name: text, derives: [text], variants: [{text: [text]}]) -> text:
    var variant_specs: [EnumVariantSpec] = []

    for entry in variants:
        for vname in entry.keys():
            val types = entry[vname]
            if types.len() == 0:
                variant_specs.push(EnumVariantSpec.unit(vname))
            else:
                variant_specs.push(EnumVariantSpec.tuple(vname, types))

    val spec = EnumSpec.with_derives(name, derives, variant_specs)
    generate_enum(spec)
