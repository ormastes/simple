# FFI Wrapper Generator - Extended Type Definitions
#
# Defines data structures for full Rust code generation from Simple specs.
# This enables generating complete modules, not just function signatures.
#
# Usage:
#   import app.ffi_gen.types*

# ============================================================================
# Import Specifications
# ============================================================================

# Describes a Rust `use` statement
use std.text.{NL}

class ImportSpec:
    # The path to import (e.g. "std::collections::HashMap")
    path: text
    # Items to import (e.g. ["HashMap", "HashSet"]). Empty = import path itself
    items: [text]
    # Alias (e.g. "use path as alias")
    alias: text
    # Whether this is a glob import (use path::*)
    glob: bool

    static fn simple(path: text) -> ImportSpec:
        ImportSpec(path: path, items: [], alias: "", glob: false)

    static fn with_items(path: text, items: [text]) -> ImportSpec:
        ImportSpec(path: path, items: items, alias: "", glob: false)

    static fn glob_import(path: text) -> ImportSpec:
        ImportSpec(path: path, items: [], alias: "", glob: true)

# ============================================================================
# Type Specifications
# ============================================================================

# A field in a struct
class FieldSpec:
    name: text
    rust_type: text
    # Visibility: "" (private), "pub", "pub(crate)"
    visibility: text
    doc: text

    static fn pub_field(name: text, rust_type: text) -> FieldSpec:
        FieldSpec(name: name, rust_type: rust_type, visibility: "pub", doc: "")

    static fn private_field(name: text, rust_type: text) -> FieldSpec:
        FieldSpec(name: name, rust_type: rust_type, visibility: "", doc: "")

# A variant in an enum
class EnumVariantSpec:
    name: text
    # For tuple variants: list of types
    tuple_fields: [text]
    # For struct variants: list of FieldSpec
    struct_fields: [FieldSpec]
    # Explicit discriminant value (optional)
    discriminant: text
    doc: text

    static fn unit(name: text) -> EnumVariantSpec:
        EnumVariantSpec(name: name, tuple_fields: [], struct_fields: [], discriminant: "", doc: "")

    static fn unit_with_value(name: text, value: text) -> EnumVariantSpec:
        EnumVariantSpec(name: name, tuple_fields: [], struct_fields: [], discriminant: value, doc: "")

    static fn tuple(name: text, types: [text]) -> EnumVariantSpec:
        EnumVariantSpec(name: name, tuple_fields: types, struct_fields: [], discriminant: "", doc: "")

    static fn struct_variant(name: text, fields: [FieldSpec]) -> EnumVariantSpec:
        EnumVariantSpec(name: name, tuple_fields: [], struct_fields: fields, discriminant: "", doc: "")

# Describes a Rust enum
class EnumSpec:
    name: text
    # Generic parameters: ["T", "E"]
    generics: [text]
    # #[repr(...)]
    repr_attr: text
    # #[derive(...)]
    derives: [text]
    variants: [EnumVariantSpec]
    # Visibility: "" (private), "pub", "pub(crate)"
    visibility: text
    doc: text

    static fn c_repr(name: text, variants: [EnumVariantSpec]) -> EnumSpec:
        EnumSpec(
            name: name, generics: [], repr_attr: "C", derives: [],
            variants: variants, visibility: "pub", doc: ""
        )

    static fn with_derives(name: text, derives: [text], variants: [EnumVariantSpec]) -> EnumSpec:
        EnumSpec(
            name: name, generics: [], repr_attr: "C", derives: derives,
            variants: variants, visibility: "pub", doc: ""
        )

# Describes a Rust struct
class StructSpec:
    name: text
    # Generic parameters: ["T", "E"]
    generics: [text]
    # Where clause constraints: ["T: Clone", "E: Error"]
    where_clauses: [text]
    # #[repr(...)]
    repr_attr: text
    # #[derive(...)]
    derives: [text]
    fields: [FieldSpec]
    # Visibility: "" (private), "pub", "pub(crate)"
    visibility: text
    # Is this a tuple struct?
    is_tuple: bool
    doc: text

    static fn simple(name: text, fields: [FieldSpec]) -> StructSpec:
        StructSpec(
            name: name, generics: [], where_clauses: [], repr_attr: "",
            derives: [], fields: fields, visibility: "pub", is_tuple: false, doc: ""
        )

    static fn with_derives(name: text, derives: [text], fields: [FieldSpec]) -> StructSpec:
        StructSpec(
            name: name, generics: [], where_clauses: [], repr_attr: "",
            derives: derives, fields: fields, visibility: "pub", is_tuple: false, doc: ""
        )

# Container for either enum or struct
class RustTypeSpec:
    # "enum" or "struct"
    kind: text
    enum_spec: EnumSpec
    struct_spec: StructSpec

    static fn enum_type(spec: EnumSpec) -> RustTypeSpec:
        RustTypeSpec(kind: "enum", enum_spec: spec, struct_spec: StructSpec.simple("", []))

    static fn struct_type(spec: StructSpec) -> RustTypeSpec:
        RustTypeSpec(kind: "struct", enum_spec: EnumSpec.c_repr("", []), struct_spec: spec)

# ============================================================================
# Function Parameter Specifications
# ============================================================================

class FFIParamSpec:
    name: text
    rust_type: text
    # Is this a reference? (&T, &mut T)
    is_ref: bool
    # Is this mutable? (&mut T, *mut T)
    is_mut: bool
    doc: text

    static fn simple(name: text, rust_type: text) -> FFIParamSpec:
        FFIParamSpec(name: name, rust_type: rust_type, is_ref: false, is_mut: false, doc: "")

    static fn ref_param(name: text, rust_type: text) -> FFIParamSpec:
        FFIParamSpec(name: name, rust_type: rust_type, is_ref: true, is_mut: false, doc: "")

    static fn mut_ref(name: text, rust_type: text) -> FFIParamSpec:
        FFIParamSpec(name: name, rust_type: rust_type, is_ref: true, is_mut: true, doc: "")

    static fn raw_ptr(name: text, rust_type: text) -> FFIParamSpec:
        FFIParamSpec(name: name, rust_type: rust_type, is_ref: false, is_mut: false, doc: "")

    static fn mut_ptr(name: text, rust_type: text) -> FFIParamSpec:
        FFIParamSpec(name: name, rust_type: rust_type, is_ref: false, is_mut: true, doc: "")

# ============================================================================
# FFI Function Specifications (with full body)
# ============================================================================

class FFIFnSpec:
    name: text
    # ABI: "C", "Rust", "system"
    abi: text
    # Is this unsafe?
    unsafe_fn: bool
    # #[no_mangle]
    no_mangle: bool
    params: [FFIParamSpec]
    return_type: text
    # The actual Rust code body (raw text)
    body: text
    # Visibility: "" (private), "pub", "pub(crate)"
    visibility: text
    # Generic parameters
    generics: [text]
    # Where clause constraints
    where_clauses: [text]
    doc: text

    static fn extern_c(name: text, params: [FFIParamSpec], return_type: text, body: text) -> FFIFnSpec:
        FFIFnSpec(
            name: name, abi: "C", unsafe_fn: false, no_mangle: true,
            params: params, return_type: return_type, body: body,
            visibility: "pub", generics: [], where_clauses: [], doc: ""
        )

    static fn unsafe_extern_c(name: text, params: [FFIParamSpec], return_type: text, body: text) -> FFIFnSpec:
        FFIFnSpec(
            name: name, abi: "C", unsafe_fn: true, no_mangle: true,
            params: params, return_type: return_type, body: body,
            visibility: "pub", generics: [], where_clauses: [], doc: ""
        )

    static fn internal(name: text, params: [FFIParamSpec], return_type: text, body: text) -> FFIFnSpec:
        FFIFnSpec(
            name: name, abi: "", unsafe_fn: false, no_mangle: false,
            params: params, return_type: return_type, body: body,
            visibility: "", generics: [], where_clauses: [], doc: ""
        )

# ============================================================================
# Common Rust Code Patterns
# ============================================================================

# Standard Cranelift value ID allocation body
# Used by 28+ FFI functions in cranelift_ops/cranelift_codegen specs
val CRANELIFT_VALUE_ID_BODY =
    "let mut contexts = FUNC_CONTEXTS.lock().unwrap();{NL}" +
    "if let Some(fctx) = contexts.get_mut(&ctx) {{NL}" +
    "    let value_id = fctx.next_value_id;{NL}" +
    "    fctx.next_value_id += 1;{NL}" +
    "    value_id{NL}" +
    "} else {{NL}" +
    "    0{NL}" +
    "}"

# ============================================================================
# Impl Block Specifications
# ============================================================================

# A method within an impl block (similar to FFIFnSpec but for methods)
class MethodSpec:
    name: text
    # Does this method take self? "", "&self", "&mut self", "self"
    self_param: text
    params: [FFIParamSpec]
    return_type: text
    body: text
    visibility: text
    # Is this unsafe?
    unsafe_fn: bool
    generics: [text]
    where_clauses: [text]
    doc: text

    static fn method(name: text, self_param: text, params: [FFIParamSpec], return_type: text, body: text) -> MethodSpec:
        MethodSpec(
            name: name, self_param: self_param, params: params,
            return_type: return_type, body: body, visibility: "pub",
            unsafe_fn: false, generics: [], where_clauses: [], doc: ""
        )

    static fn static_method(name: text, params: [FFIParamSpec], return_type: text, body: text) -> MethodSpec:
        MethodSpec(
            name: name, self_param: "", params: params,
            return_type: return_type, body: body, visibility: "pub",
            unsafe_fn: false, generics: [], where_clauses: [], doc: ""
        )

# Describes an impl block
class ImplSpec:
    # The type being implemented (e.g. "RuntimeValue")
    type_name: text
    # Generic parameters for the impl
    generics: [text]
    # Trait being implemented (empty for inherent impl)
    trait_name: text
    # Where clause constraints
    where_clauses: [text]
    methods: [MethodSpec]

    static fn inherent(type_name: text, methods: [MethodSpec]) -> ImplSpec:
        ImplSpec(
            type_name: type_name, generics: [], trait_name: "",
            where_clauses: [], methods: methods
        )

    static fn trait_impl(type_name: text, trait_name: text, methods: [MethodSpec]) -> ImplSpec:
        ImplSpec(
            type_name: type_name, generics: [], trait_name: trait_name,
            where_clauses: [], methods: methods
        )

# ============================================================================
# Test Specifications
# ============================================================================

class TestSpec:
    name: text
    # #[ignore]
    ignored: bool
    # Ignore message
    ignore_reason: text
    body: text
    doc: text

    static fn test(name: text, body: text) -> TestSpec:
        TestSpec(name: name, ignored: false, ignore_reason: "", body: body, doc: "")

    static fn ignored_test(name: text, reason: text, body: text) -> TestSpec:
        TestSpec(name: name, ignored: true, ignore_reason: reason, body: body, doc: "")

# ============================================================================
# Module Specifications
# ============================================================================

class ModuleSpec:
    # Module name (e.g. "runtime_value")
    name: text
    # Module-level doc comment
    doc: text
    imports: [ImportSpec]
    # Type definitions (enums and structs)
    types: [RustTypeSpec]
    # Impl blocks
    impls: [ImplSpec]
    # FFI functions with bodies
    functions: [FFIFnSpec]
    # Unit tests
    tests: [TestSpec]
    # Additional raw Rust code at module level (constants, statics, etc.)
    raw_code: text

    static fn empty(name: text) -> ModuleSpec:
        ModuleSpec(
            name: name, doc: "", imports: [], types: [], impls: [],
            functions: [], tests: [], raw_code: ""
        )

# ============================================================================
# Workspace Configuration
# ============================================================================

# A dependency in Cargo.toml
class CrateDependency:
    name: text
    version: text
    # Features to enable
    features: [text]
    # Path dependency (for local crates)
    path: text
    # Git repository
    git: text
    # Optional dependency
    optional: bool

    static fn version(name: text, ver: text) -> CrateDependency:
        CrateDependency(name: name, version: ver, features: [], path: "", git: "", optional: false)

    static fn with_features(name: text, ver: text, features: [text]) -> CrateDependency:
        CrateDependency(name: name, version: ver, features: features, path: "", git: "", optional: false)

    static fn path_dep(name: text, path: text) -> CrateDependency:
        CrateDependency(name: name, version: "", features: [], path: path, git: "", optional: false)

# Cargo.toml specification
class CargoSpec:
    # [package] section
    name: text
    version: text
    edition: text
    authors: [text]
    description: text
    license: text
    # Crate type: "lib", "bin", "cdylib", "staticlib"
    crate_type: text
    # [dependencies]
    dependencies: [CrateDependency]
    # [dev-dependencies]
    dev_dependencies: [CrateDependency]
    # [build-dependencies]
    build_dependencies: [CrateDependency]
    # [features]
    features: [{text: [text]}]
    # Additional raw TOML content
    raw_toml: text

    static fn library(name: text, version: text) -> CargoSpec:
        CargoSpec(
            name: name, version: version, edition: "2021", authors: [],
            description: "", license: "", crate_type: "lib",
            dependencies: [], dev_dependencies: [], build_dependencies: [],
            features: [], raw_toml: ""
        )

    static fn cdylib(name: text, version: text) -> CargoSpec:
        CargoSpec(
            name: name, version: version, edition: "2021", authors: [],
            description: "", license: "", crate_type: "cdylib",
            dependencies: [], dev_dependencies: [], build_dependencies: [],
            features: [], raw_toml: ""
        )

# Workspace configuration
class WorkspaceSpec:
    # Root Cargo.toml settings
    resolver: text
    # Members (relative paths)
    members: [text]
    # Workspace-level dependencies
    workspace_dependencies: [CrateDependency]

    static fn default_resolver() -> WorkspaceSpec:
        WorkspaceSpec(resolver: "2", members: [], workspace_dependencies: [])

# ============================================================================
# Project-level Specification
# ============================================================================

# Full project specification (multiple modules + workspace)
class ProjectSpec:
    workspace: WorkspaceSpec
    cargo: CargoSpec
    modules: [ModuleSpec]
    # lib.rs content (pub mod + pub use)
    lib_modules: [text]

    static fn empty() -> ProjectSpec:
        ProjectSpec(
            workspace: WorkspaceSpec.default_resolver(),
            cargo: CargoSpec.library("ffi_gen", "0.1.0"),
            modules: [],
            lib_modules: []
        )
