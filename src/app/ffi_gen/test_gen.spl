# FFI Wrapper Generator - Test Module Code Generation
#
# Generates Rust #[cfg(test)] mod tests from TestSpec.
#
# Usage:
#   import app.ffi_gen.test_gen (generate_tests, generate_test_module)

use app.ffi_gen.types*
use std.text.{NL}

# ============================================================================
# Test Module Generation
# ============================================================================

# Generate a complete #[cfg(test)] mod tests block
fn generate_test_module(tests: [TestSpec]) -> text:
    if tests.len() == 0:
        return ""

    var out = ""
    out = out + "#[cfg(test)]{NL}"
    out = out + "mod tests {{{NL}"
    out = out + "    use super::*;{NL}"
    out = out + NL

    for test in tests:
        out = out + generate_test(test)
        out = out + NL

    out = out + "}}{NL}"
    out

# Generate a single test function
fn generate_test(spec: TestSpec) -> text:
    var out = ""

    # Doc comment
    if spec.doc != "":
        for line in spec.doc.split(NL):
            out = out + "    /// {line}{NL}"

    # Attributes
    out = out + "    #[test]{NL}"
    if spec.ignored:
        if spec.ignore_reason != "":
            out = out + "    #[ignore = \"{spec.ignore_reason}\"]{NL}"
        else:
            out = out + "    #[ignore]{NL}"

    out = out + "    fn {spec.name}() {{{NL}"

    # Body - indent each line
    for line in spec.body.split(NL):
        if line.trim() != "":
            out = out + "        {line}{NL}"
        else:
            out = out + NL

    out = out + "    }}{NL}"
    out

# ============================================================================
# Convenience Constructors
# ============================================================================

# Create a simple test that wraps unsafe code
fn unsafe_test(name: text, body: text) -> TestSpec:
    TestSpec.test(name, "unsafe {{{NL}{body}{NL}}}")

# Create a test with setup and teardown pattern
fn test_with_cleanup(name: text, setup: text, test_body: text, cleanup: text) -> TestSpec:
    val body = "{setup}{NL}{test_body}{NL}{cleanup}"
    TestSpec.test(name, body)

# Create a test that allocates and frees values
fn alloc_test(name: text, alloc_code: text, test_code: text, free_code: text) -> TestSpec:
    val body = "unsafe {{{NL}    {alloc_code}{NL}    {test_code}{NL}    {free_code}{NL}}}"
    TestSpec.test(name, body)

# ============================================================================
# Common Test Patterns
# ============================================================================

# Generate assertion: assert!(!ptr.is_null())
fn assert_not_null(var_name: text) -> text:
    "assert!(!{var_name}.is_null());"

# Generate assertion: assert_eq!(actual, expected)
fn assert_eq(actual: text, expected: text) -> text:
    "assert_eq!({actual}, {expected});"

# Generate assertion: assert!(condition)
fn assert_true(condition: text) -> text:
    "assert!({condition});"

# Generate assertion: assert!(!condition)
fn assert_false(condition: text) -> text:
    "assert!(!{condition});"

# Generate let binding for test
fn let_val(name: text, value: text) -> text:
    "let {name} = {value};"

# Generate value creation and test pattern
fn test_value_creation(fn_name: text, var_name: text, args: text, assertions: [text]) -> text:
    var out = "let {var_name} = {fn_name}({args});{NL}"
    out = out + "assert!(!{var_name}.is_null());{NL}"
    for assertion in assertions:
        out = out + "{assertion}{NL}"
    out = out + "rt_value_free({var_name});"
    out
