# FFI Wrapper Generator - Workspace and Cargo.toml Generation
#
# Generates workspace Cargo.toml and crate Cargo.toml files.
#
# Usage:
#   import app.ffi_gen.workspace_gen (generate_cargo_toml, generate_workspace_toml)

use app.ffi_gen.types*

# ============================================================================
# Cargo.toml Generation
# ============================================================================

# Generate a complete Cargo.toml from CargoSpec
fn generate_cargo_toml(spec: CargoSpec) -> text:
    var out = ""

    # [package] section
    out = out + "[package]\n"
    out = out + "name = \"{spec.name}\"\n"
    out = out + "version = \"{spec.version}\"\n"
    out = out + "edition = \"{spec.edition}\"\n"

    if spec.description != "":
        out = out + "description = \"{spec.description}\"\n"
    if spec.license != "":
        out = out + "license = \"{spec.license}\"\n"
    if spec.authors.len() > 0:
        val authors_str = spec.authors.map(\a: "\"{a}\"").join(", ")
        out = out + "authors = [{authors_str}]\n"

    out = out + "\n"

    # [lib] section for crate type
    if spec.crate_type != "" and spec.crate_type != "lib":
        out = out + "[lib]\n"
        out = out + "crate-type = [\"{spec.crate_type}\"]\n"
        out = out + "\n"

    # [dependencies]
    if spec.dependencies.len() > 0:
        out = out + "[dependencies]\n"
        for dep in spec.dependencies:
            out = out + generate_dependency(dep)
        out = out + "\n"

    # [dev-dependencies]
    if spec.dev_dependencies.len() > 0:
        out = out + "[dev-dependencies]\n"
        for dep in spec.dev_dependencies:
            out = out + generate_dependency(dep)
        out = out + "\n"

    # [build-dependencies]
    if spec.build_dependencies.len() > 0:
        out = out + "[build-dependencies]\n"
        for dep in spec.build_dependencies:
            out = out + generate_dependency(dep)
        out = out + "\n"

    # [features]
    if spec.features.len() > 0:
        out = out + "[features]\n"
        for feature_entry in spec.features:
            for fname in feature_entry.keys():
                val deps = feature_entry[fname]
                val deps_str = deps.map(\d: "\"{d}\"").join(", ")
                out = out + "{fname} = [{deps_str}]\n"
        out = out + "\n"

    # Raw TOML content
    if spec.raw_toml != "":
        out = out + spec.raw_toml

    out

# Generate a single dependency line
fn generate_dependency(dep: CrateDependency) -> text:
    if dep.path != "":
        # Path dependency
        if dep.features.len() > 0:
            val features_str = dep.features.map(\f: "\"{f}\"").join(", ")
            "{dep.name} = {{ path = \"{dep.path}\", features = [{features_str}] }}\n"
        else:
            "{dep.name} = {{ path = \"{dep.path}\" }}\n"
    elif dep.git != "":
        # Git dependency
        if dep.features.len() > 0:
            val features_str = dep.features.map(\f: "\"{f}\"").join(", ")
            "{dep.name} = {{ git = \"{dep.git}\", features = [{features_str}] }}\n"
        else:
            "{dep.name} = {{ git = \"{dep.git}\" }}\n"
    elif dep.features.len() > 0:
        # Version with features
        val features_str = dep.features.map(\f: "\"{f}\"").join(", ")
        "{dep.name} = {{ version = \"{dep.version}\", features = [{features_str}] }}\n"
    elif dep.optional:
        "{dep.name} = {{ version = \"{dep.version}\", optional = true }}\n"
    else:
        # Simple version
        "{dep.name} = \"{dep.version}\"\n"

# ============================================================================
# Workspace Cargo.toml Generation
# ============================================================================

# Generate a workspace Cargo.toml
fn generate_workspace_toml(spec: WorkspaceSpec) -> text:
    var out = ""

    out = out + "[workspace]\n"
    out = out + "resolver = \"{spec.resolver}\"\n"

    if spec.members.len() > 0:
        out = out + "members = [\n"
        for member in spec.members:
            out = out + "    \"{member}\",\n"
        out = out + "]\n"

    out = out + "\n"

    # Workspace dependencies
    if spec.workspace_dependencies.len() > 0:
        out = out + "[workspace.dependencies]\n"
        for dep in spec.workspace_dependencies:
            out = out + generate_dependency(dep)

    out

# ============================================================================
# lib.rs Generation
# ============================================================================

# Generate lib.rs content
fn generate_lib_rs(modules: [text]) -> text:
    var out = ""
    out = out + "//! FFI Generated Crate\n"
    out = out + "//!\n"
    out = out + "//! Auto-generated by: simple ffi-gen --gen-all\n"
    out = out + "//! Do not edit manually.\n"
    out = out + "\n"

    # Module declarations
    for mod_name in modules:
        out = out + "pub mod {mod_name};\n"

    out = out + "\n"

    # Re-exports
    for mod_name in modules:
        out = out + "pub use {mod_name}::*;\n"

    out

# ============================================================================
# Convenience Functions
# ============================================================================

# Create a simple library crate spec
fn simple_lib(name: text, version: text, deps: [CrateDependency]) -> CargoSpec:
    var spec = CargoSpec.library(name, version)
    spec.dependencies = deps
    spec

# Create the FFI gen crate spec for Simple runtime
fn ffi_gen_crate() -> CargoSpec:
    var spec = CargoSpec.cdylib("simple-ffi-gen", "0.1.0")
    spec.description = "Generated FFI wrappers for Simple runtime"

    spec.dependencies = [
        CrateDependency.version("bdwgc-alloc", "0.6"),
    ]

    spec
