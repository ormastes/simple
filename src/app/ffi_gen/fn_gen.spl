# FFI Wrapper Generator - FFI Function Code Generation
#
# Generates Rust extern "C" functions with full bodies from FFIFnSpec.
#
# Usage:
#   import app.ffi_gen.fn_gen (generate_ffi_fn, generate_ffi_functions)

use app.ffi_gen.types*
use std.string.{NL}

# ============================================================================
# FFI Function Generation
# ============================================================================

# Generate a single FFI function
fn generate_ffi_fn(spec: FFIFnSpec) -> text:
    var out = ""

    # Doc comment
    if spec.doc != "":
        for line in spec.doc.split(NL):
            out = out + "/// {line}{NL}"

    # Attributes
    if spec.no_mangle:
        out = out + "#[no_mangle]{NL}"

    # Build signature
    val vis = if spec.visibility != "": "{spec.visibility} " else: ""
    val unsafe_kw = if spec.unsafe_fn: "unsafe " else: ""
    val abi_str = if spec.abi != "": "extern \"{spec.abi}\" " else: ""
    val generics_str = format_fn_generics(spec.generics)
    val where_str = format_fn_where(spec.where_clauses)

    # Parameters
    var params_list: [text] = []
    for p in spec.params:
        params_list.push("{p.name}: {p.rust_type}")
    val params_str = params_list.join(", ")

    # Return type
    val return_str = if spec.return_type != "" and spec.return_type != "()":
        " -> {spec.return_type}"
    else:
        ""

    out = out + "{vis}{unsafe_kw}{abi_str}fn {spec.name}{generics_str}({params_str}){return_str}{where_str} {{{NL}"

    # Body - preserve indentation
    for line in spec.body.split(NL):
        if line.trim() != "":
            out = out + "    {line}{NL}"
        else:
            out = out + NL

    out = out + "}}{NL}"
    out

# Generate multiple FFI functions
fn generate_ffi_functions(specs: [FFIFnSpec]) -> text:
    var out = ""
    for spec in specs:
        out = out + generate_ffi_fn(spec)
        out = out + NL
    out

# ============================================================================
# Helper Functions
# ============================================================================

fn format_fn_generics(generics: [text]) -> text:
    if generics.len() == 0:
        ""
    else:
        "<{generics.join(\", \")}>"

fn format_fn_where(where_clauses: [text]) -> text:
    if where_clauses.len() == 0:
        ""
    else:
        "{NL}where{NL}    {where_clauses.join(\",\\n    \")}"

# ============================================================================
# Convenience Constructors
# ============================================================================

# Create a simple extern "C" constructor (no params, returns *mut Type)
fn constructor_fn(name: text, type_name: text, body: text) -> FFIFnSpec:
    FFIFnSpec.extern_c(name, [], "*mut {type_name}", body)

# Create a simple extern "C" function taking a raw pointer
fn ptr_fn(name: text, ptr_type: text, return_type: text, body: text) -> FFIFnSpec:
    val params = [FFIParamSpec.simple("value", "*const {ptr_type}")]
    FFIFnSpec.unsafe_extern_c(name, params, return_type, body)

# Create a binary operation function
fn binop_fn(name: text, type_name: text, return_type: text, body: text) -> FFIFnSpec:
    val params = [
        FFIParamSpec.simple("left", "*const {type_name}"),
        FFIParamSpec.simple("right", "*const {type_name}")
    ]
    FFIFnSpec.unsafe_extern_c(name, params, return_type, body)

# Create a void function taking a mutable pointer
fn void_ptr_fn(name: text, ptr_type: text, body: text) -> FFIFnSpec:
    val params = [FFIParamSpec.simple("value", "*mut {ptr_type}")]
    FFIFnSpec.unsafe_extern_c(name, params, "()", body)

# ============================================================================
# Code Snippet Helpers
# ============================================================================

# Generate null check preamble
fn null_check(var_name: text, return_value: text) -> text:
    "if {var_name}.is_null() {{{NL}    return {return_value};{NL}}}"

# Generate null check for binary operations
fn null_check_binary(left: text, right: text, return_value: text) -> text:
    "if {left}.is_null() || {right}.is_null() {{{NL}    return {return_value};{NL}}}"

# Generate Box::into_raw wrapper
fn box_into_raw(inner: text) -> text:
    "Box::into_raw(Box::new({inner}))"

# Generate unsafe dereference
fn deref(ptr: text) -> text:
    "(*{ptr})"

# Generate match expression for RuntimeValue patterns
fn match_value(var_name: text, cases: [{text: text}], default: text) -> text:
    var out = "match &{deref(var_name)} {{{NL}"
    for case_entry in cases:
        for pattern in case_entry.keys():
            val body = case_entry[pattern]
            out = out + "    {pattern} => {body},{NL}"
    out = out + "    _ => {default},{NL}"
    out = out + "}}"
    out
