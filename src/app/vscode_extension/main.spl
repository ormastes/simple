# VSCode Extension Build CLI
# Compile Simple code to WASM for VSCode extensions
#
# Usage:
#   simple vscode build [options]
#   simple vscode build --watch
#   simple vscode build --release

# Build options
struct BuildOptions:
    source_dir: text
    output_dir: text
    release: bool
    watch: bool
    generate_manifest: bool
    extension_name: text
    version: text
    lsp_wasm: bool

fn default_build_options() -> BuildOptions:
    BuildOptions(
        source_dir: "src",
        output_dir: "out",
        release: false,
        watch: false,
        generate_manifest: true,
        extension_name: "",
        version: "1.0.0",
        lsp_wasm: false
    )

# Build result
struct BuildResult:
    success: bool
    wasm_path: text
    manifest_path: text
    errors: [text]

fn default_build_result() -> BuildResult:
    BuildResult(
        success: false,
        wasm_path: "",
        manifest_path: "",
        errors: []
    )

# Compile result
struct CompileResult:
    success: bool
    path: text
    errors: [text]

# VSCode extension builder
fn build_extension(options: BuildOptions) -> BuildResult:
    """Build VSCode extension."""
    var result = default_build_result()

    # Step 0: Build LSP WASM if requested
    if options.lsp_wasm:
        print "Compiling LSP server to WASM..."
        val lsp_result = compile_lsp_to_wasm(options)
        if not lsp_result.success:
            result = BuildResult(success: false, wasm_path: "", manifest_path: "", errors: lsp_result.errors)
            return result
        print "  LSP WASM: {lsp_result.path}"

    # Step 1: Compile Simple to WASM
    print "Compiling Simple to WASM..."
    val wasm_result = compile_to_wasm(options)

    if not wasm_result.success:
        result = BuildResult(success: false, wasm_path: "", manifest_path: "", errors: wasm_result.errors)
        return result

    var manifest_path = ""

    # Step 2: Generate manifest
    if options.generate_manifest:
        print "Generating package.json..."
        manifest_path = "package.json"

    # Step 3: Generate JS wrapper
    print "Generating JavaScript wrapper..."
    val wrapper_path = "{options.output_dir}/extension.js"

    # Step 4: Copy assets
    print "Copying assets..."
    copy_assets(options)

    BuildResult(success: true, wasm_path: wasm_result.path, manifest_path: manifest_path, errors: [])

fn compile_to_wasm(options: BuildOptions) -> CompileResult:
    """Compile Simple code to WASM."""
    val wasm_path = "{options.output_dir}/extension.wasm"

    var args = ["build", "--target", "wasm32-unknown-unknown"]

    if options.release:
        args.push("--release")

    args.push("--output")
    args.push(wasm_path)
    args.push("{options.source_dir}/extension.spl")

    # Execute simple compiler
    val run_result = process_run("simple", args)
    val exit_code = run_result[2]

    if exit_code == 0:
        CompileResult(success: true, path: wasm_path, errors: [])
    else:
        val stderr = run_result[1]
        CompileResult(success: false, path: "", errors: [stderr])

fn compile_lsp_to_wasm(options: BuildOptions) -> CompileResult:
    """Compile Simple LSP server to WASM for VSCode Web."""
    val wasm_dir = "{options.output_dir}/wasm"
    val lsp_wasm_path = "{wasm_dir}/simple-lsp.wasm"

    var args = ["build", "--target", "wasm32-wasi"]

    if options.release:
        args.push("--release")

    args.push("--output")
    args.push(lsp_wasm_path)
    args.push("src/app/lsp/main.spl")

    val run_result = process_run("simple", args)
    val exit_code = run_result[2]

    if exit_code == 0:
        CompileResult(success: true, path: lsp_wasm_path, errors: [])
    else:
        val stderr = run_result[1]
        CompileResult(success: false, path: "", errors: [stderr])

fn copy_assets(options: BuildOptions):
    """Copy assets to output directory."""
    val assets = ["README.md", "CHANGELOG.md", "LICENSE", "LICENSE.md", "icon.png"]

    for asset in assets:
        if file_exists(asset):
            print "  Copied {asset}"

# Parse command-line arguments
fn parse_args() -> BuildOptions:
    """Parse command-line arguments."""
    var options = default_build_options()
    val args = get_args()

    var i = 0
    while i < args.len():
        val arg = args[i]

        if arg == "--release":
            options = BuildOptions(source_dir: options.source_dir, output_dir: options.output_dir, release: true, watch: options.watch, generate_manifest: options.generate_manifest, extension_name: options.extension_name, version: options.version, lsp_wasm: options.lsp_wasm)
        elif arg == "--watch":
            options = BuildOptions(source_dir: options.source_dir, output_dir: options.output_dir, release: options.release, watch: true, generate_manifest: options.generate_manifest, extension_name: options.extension_name, version: options.version, lsp_wasm: options.lsp_wasm)
        elif arg == "--lsp-wasm":
            options = BuildOptions(source_dir: options.source_dir, output_dir: options.output_dir, release: options.release, watch: options.watch, generate_manifest: options.generate_manifest, extension_name: options.extension_name, version: options.version, lsp_wasm: true)
        elif arg == "--no-manifest":
            options = BuildOptions(source_dir: options.source_dir, output_dir: options.output_dir, release: options.release, watch: options.watch, generate_manifest: false, extension_name: options.extension_name, version: options.version, lsp_wasm: options.lsp_wasm)
        elif arg == "--source":
            i = i + 1
            if i < args.len():
                options = BuildOptions(source_dir: args[i], output_dir: options.output_dir, release: options.release, watch: options.watch, generate_manifest: options.generate_manifest, extension_name: options.extension_name, version: options.version, lsp_wasm: options.lsp_wasm)
        elif arg == "--output":
            i = i + 1
            if i < args.len():
                options = BuildOptions(source_dir: options.source_dir, output_dir: args[i], release: options.release, watch: options.watch, generate_manifest: options.generate_manifest, extension_name: options.extension_name, version: options.version, lsp_wasm: options.lsp_wasm)
        elif arg == "--name":
            i = i + 1
            if i < args.len():
                options = BuildOptions(source_dir: options.source_dir, output_dir: options.output_dir, release: options.release, watch: options.watch, generate_manifest: options.generate_manifest, extension_name: args[i], version: options.version, lsp_wasm: options.lsp_wasm)
        elif arg == "--version":
            i = i + 1
            if i < args.len():
                options = BuildOptions(source_dir: options.source_dir, output_dir: options.output_dir, release: options.release, watch: options.watch, generate_manifest: options.generate_manifest, extension_name: options.extension_name, version: args[i], lsp_wasm: options.lsp_wasm)

        i = i + 1

    options

# Main entry point
fn main():
    """VSCode extension build CLI entry point."""
    print "VSCode Extension Builder"
    print "========================"
    print ""

    # Parse arguments
    val options = parse_args()

    # Build
    val result = build_extension(options)

    # Report results
    if result.success:
        print ""
        print "Build succeeded"
        print "  WASM: {result.wasm_path}"
        if result.manifest_path != "":
            print "  Manifest: {result.manifest_path}"
        print ""
        print "Run 'simple vscode package' to create .vsix file"
    else:
        print ""
        print "Build failed:"
        for err in result.errors:
            print "  {err}"
