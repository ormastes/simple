# LSP Server Implementation
# Handles LSP requests and maintains server state

import sys
import io.fs as fs
import core.collections as collections
import lsp.protocol as protocol
import lsp.transport as transport
import parser.treesitter.{TreeSitterParser, Tree, Query, QueryCursor}
import parser.treesitter.optimize as optimize
import lsp.handlers.semantic_tokens as semantic_tokens
import lsp.handlers.diagnostics as diagnostics
import lsp.handlers.hover as hover
import lsp.handlers.definition as definition
import lsp.handlers.references as references
import lsp.handlers.completion as completion
import lsp.handlers.verification as verification

# NEW: Import Compiler Query API
import compiler.query_api.{CompilerQueryContext, Position as QueryPosition}

# Server state
enum ServerState:
    Uninitialized
    Initialized
    ShuttingDown

# Document cache entry
class DocumentInfo:
    uri: String
    version: Int
    text: String
    tree: Option<Tree>          # Parsed syntax tree
    parser: TreeSitterParser    # Parser instance

    static fn new(uri: String, version: Int, text: String) -> DocumentInfo:
        # Create parser - just unwrap for now (TODO: better error handling)
        val parser = TreeSitterParser__create("simple").unwrap()

        # Parse document
        val tree = parser.parse(text).ok()

        DocumentInfo(
            uri: uri,
            version: version,
            text: text,
            tree: tree,
            parser: parser
        )

    # Update document with new text
    me update(new_text: String, new_version: Int):
        # Compute edits for incremental parsing
        val edits = parser.treesitter.edits.compute_edits(self.text, new_text)

        # Incremental parse
        self.tree = match self.tree:
            case Some(old_tree):
                self.parser.parse_incremental(new_text, old_tree, edits).ok()
            case None:
                self.parser.parse(new_text).ok()

        self.text = new_text
        self.version = new_version

# LSP Server
class LspServer:
    state: ServerState
    documents: Dict<String, DocumentInfo>  # uri -> DocumentInfo
    query_optimizer: optimize.QueryOptimizer  # Query compilation cache
    query_cache: optimize.QueryCache  # Query result cache
    debouncer: optimize.Debouncer  # didChange debouncing
    metrics: optimize.PerformanceMetrics  # Performance tracking
    lean_output_dir: Option<String>  # Lean artifact output directory

    # NEW: Compiler Query Context for code intelligence
    compiler_query_ctx: CompilerQueryContext
    project_root: String

    static fn new() -> LspServer:
        # Get current working directory as project root
        val project_root = get_current_dir()

        LspServer(
            state: ServerState.Uninitialized,
            documents: {},
            query_optimizer: optimize.QueryOptimizer__new(),
            query_cache: optimize.QueryCache__new(100),  # Cache 100 query results
            debouncer: optimize.Debouncer__new(300),  # 300ms debounce delay
            metrics: optimize.PerformanceMetrics__new(),
            lean_output_dir: Some("build/lean"),  # Default Lean output directory

            # NEW: Initialize compiler query context
            compiler_query_ctx: CompilerQueryContext__create(project_root),
            project_root: project_root,
        )

# Helper: Get current directory (using Simple's built-in io.cwd)
fn get_current_dir() -> String:
    io.cwd()

    # Handle initialize request
    fn handle_initialize(id: Int, params: Option<Dict>) -> Result<Nil, String>:
        transport.log_debug("Handling initialize request")

        # Update state
        self.state = ServerState.Initialized

        # Build initialize result
        val result = protocol.InitializeResult__new()
        val response_data = result.to_json()

        # Send response
        transport.write_response(id, response_data)?

        Ok(nil)

    # Handle initialized notification
    fn handle_initialized() -> Result<Nil, String>:
        transport.log_debug("Received initialized notification")
        Ok(nil)

    # Handle shutdown request
    fn handle_shutdown(id: Int) -> Result<Nil, String>:
        transport.log_debug("Handling shutdown request")

        # Update state
        self.state = ServerState.ShuttingDown

        # Send null result
        transport.write_response(id, {})?

        Ok(nil)

    # Handle exit notification
    fn handle_exit() -> Result<Nil, String>:
        transport.log_debug("Handling exit notification")

        # Exit with appropriate code
        match self.state:
            case ShuttingDown:
                sys.exit(0)
            case _:
                sys.exit(1)

        Ok(nil)

    # Handle textDocument/didOpen notification
    fn handle_did_open(params: Option<Dict>) -> Result<Nil, String>:
        match params:
            case None:
                return Err("Missing params for didOpen")
            case Some(p):
                # Extract text document
                val text_document_data = p.get("textDocument")?
                val doc = protocol.TextDocumentItem__from_json(text_document_data)?

                # Cache document
                val doc_info = DocumentInfo__new(doc.uri, doc.version, doc.text)
                self.documents[doc.uri] = doc_info

                transport.log_debug("Opened document: {doc.uri}")

                # Run diagnostics
                self.publish_diagnostics(doc.uri)?

                Ok(nil)

    # Handle textDocument/didChange notification
    fn handle_did_change(params: Option<Dict>) -> Result<Nil, String>:
        match params:
            case None:
                return Err("Missing params for didChange")
            case Some(p):
                # Extract versioned document
                val text_document_data = p.get("textDocument")?
                val versioned_doc = protocol.VersionedTextDocumentIdentifier__from_json(text_document_data)?

                # Extract content changes
                val content_changes = p.get("contentChanges")?
                if content_changes.is_empty():
                    return Err("No content changes")

                # Get first change (we use full sync)
                val change_data = content_changes[0]
                val change = protocol.TextDocumentContentChangeEvent__from_json(change_data)?

                # Check if we should debounce this update
                val current_time = sys.time.now_ms()
                val should_parse = self.debouncer.should_trigger(current_time)

                if should_parse:
                    # Time the parsing operation
                    val start_time = sys.time.now_ms()

                    # Update cached document
                    val doc_info = DocumentInfo__new(
                        versioned_doc.uri,
                        versioned_doc.version,
                        change.text
                    )
                    self.documents[versioned_doc.uri] = doc_info

                    val end_time = sys.time.now_ms()
                    val parse_time = end_time - start_time

                    # Record metrics
                    self.metrics.record_parse(parse_time)

                    transport.log_debug("Changed document: {versioned_doc.uri} (parse: {parse_time:.2f}ms)")

                    # Clear query cache on document change
                    self.query_cache.clear()

                    # NEW: Invalidate compiler query cache for this file
                    val file_path = uri_to_file_path(versioned_doc.uri)
                    self.compiler_query_ctx.invalidate_file(file_path)

                    # Run diagnostics
                    self.publish_diagnostics(versioned_doc.uri)?
                else:
                    # Mark as pending - will be processed later
                    transport.log_debug("Debouncing change for: {versioned_doc.uri}")

                Ok(nil)

    # Handle textDocument/didClose notification
    fn handle_did_close(params: Option<Dict>) -> Result<Nil, String>:
        match params:
            case None:
                return Err("Missing params for didClose")
            case Some(p):
                val text_document_data = p.get("textDocument")?
                val doc = protocol.TextDocumentIdentifier__from_json(text_document_data)?

                # Remove from cache
                self.documents.remove(doc.uri)

                transport.log_debug("Closed document: {doc.uri}")

                Ok(nil)

    # Publish diagnostics for a document
    fn publish_diagnostics(uri: String) -> Result<Nil, String>:
        # Get document from cache
        match self.documents.get(uri):
            case None:
                # Document not in cache - send empty diagnostics
                val params = {
                    "uri": uri,
                    "diagnostics": []
                }
                transport.write_notification("textDocument/publishDiagnostics", params)?
                Ok(nil)
            case Some(doc_info):
                # Use tree-sitter diagnostics if tree is available
                match doc_info.tree:
                    case Some(tree):
                        diagnostics.handle_diagnostics(uri, tree)
                    case None:
                        # No tree - send empty diagnostics
                        val params = {
                            "uri": uri,
                            "diagnostics": []
                        }
                        transport.write_notification("textDocument/publishDiagnostics", params)?
                        Ok(nil)

    # Handle textDocument/completion request
    fn handle_completion(id: Int, params: Option<Dict>) -> Result<Nil, String>:
        match params:
            case None:
                return Err("Missing params for completion")
            case Some(p):
                # Extract text document and position
                val text_document_data = p.get("textDocument")?
                val doc_id = protocol.TextDocumentIdentifier__from_json(text_document_data)?

                val position_data = p.get("position")?
                val position = protocol.Position__from_json(position_data)?

                # Get document from cache
                match self.documents.get(doc_id.uri):
                    case None:
                        transport.write_error(
                            id,
                            protocol.ERROR_INVALID_PARAMS,
                            "Document not found: {doc_id.uri}"
                        )?
                        Ok(nil)
                    case Some(doc_info):
                        # NEW: Use Compiler Query API for completions
                        val file_path = uri_to_file_path(doc_id.uri)
                        val query_pos = QueryPosition(line: position.line, column: position.character)

                        val completions = self.compiler_query_ctx.completions_at(file_path, query_pos)

                        # Convert to LSP completion items
                        var items = []
                        for comp in completions:
                            val item = {
                                "label": comp.label,
                                "kind": completion_kind_to_lsp(comp.kind),
                                "detail": comp.detail,
                                "documentation": comp.documentation,
                                "insertText": comp.insert_text,
                                "sortText": format_sort_text(comp.sort_priority),
                            }
                            items.push(item)

                        transport.write_response(id, items)?
                        Ok(nil)

# Helper: Convert completion kind to LSP kind
fn completion_kind_to_lsp(kind: query_api.CompletionKind) -> Int:
    match kind:
        query_api.CompletionKind.Variable: 6      # Variable
        query_api.CompletionKind.Function: 3      # Function
        query_api.CompletionKind.Method: 2        # Method
        query_api.CompletionKind.Keyword: 14      # Keyword
        query_api.CompletionKind.Module: 9        # Module
        query_api.CompletionKind.Type: 7          # Class
        query_api.CompletionKind.Field: 5         # Field
        query_api.CompletionKind.EnumVariant: 20  # EnumMember

# Helper: Format sort priority for LSP
fn format_sort_text(priority: i64) -> String:
    # LSP sorts alphabetically, so pad numbers
    val padded = priority.to_string().pad_left(5, '0')
    padded

# Helper: Convert URI to file path
fn uri_to_file_path(uri: String) -> String:
    # Remove file:// prefix
    if uri.starts_with("file://"):
        return uri[7:]
    uri

    # Handle textDocument/references request
    fn handle_references(id: Int, params: Option<Dict>) -> Result<Nil, String>:
        match params:
            case None:
                return Err("Missing params for references")
            case Some(p):
                # Extract text document and position
                val text_document_data = p.get("textDocument")?
                val doc_id = protocol.TextDocumentIdentifier__from_json(text_document_data)?

                val position_data = p.get("position")?
                val position = protocol.Position__from_json(position_data)?

                # Extract context (includeDeclaration)
                val include_declaration = match p.get_optional("context"):
                    case Some(context):
                        match context.get_optional("includeDeclaration"):
                            case Some(v):
                                v  # Assume boolean
                            case None:
                                true  # Default to including declaration
                    case None:
                        true

                # Get document from cache
                match self.documents.get(doc_id.uri):
                    case None:
                        transport.write_error(
                            id,
                            protocol.ERROR_INVALID_PARAMS,
                            "Document not found: {doc_id.uri}"
                        )?
                        Ok(nil)
                    case Some(doc_info):
                        # Use references handler
                        match doc_info.tree:
                            case None:
                                # No tree - return null
                                transport.write_response(id, nil)?
                                Ok(nil)
                            case Some(tree):
                                val refs_result = references.handle_references(
                                    tree,
                                    doc_info.text,
                                    position.line,
                                    position.character,
                                    include_declaration
                                )?

                                match refs_result:
                                    case None:
                                        transport.write_response(id, nil)?
                                    case Some(locations):
                                        # Add URI to each location
                                        for location in locations:
                                            location["uri"] = doc_id.uri

                                        transport.write_response(id, locations)?

                                Ok(nil)

    # Handle textDocument/definition request
    fn handle_definition(id: Int, params: Option<Dict>) -> Result<Nil, String>:
        match params:
            case None:
                return Err("Missing params for definition")
            case Some(p):
                # Extract text document and position
                val text_document_data = p.get("textDocument")?
                val doc_id = protocol.TextDocumentIdentifier__from_json(text_document_data)?

                val position_data = p.get("position")?
                val position = protocol.Position__from_json(position_data)?

                # Get document from cache
                match self.documents.get(doc_id.uri):
                    case None:
                        transport.write_error(
                            id,
                            protocol.ERROR_INVALID_PARAMS,
                            "Document not found: {doc_id.uri}"
                        )?
                        Ok(nil)
                    case Some(doc_info):
                        # NEW: Use Compiler Query API for definition
                        val file_path = uri_to_file_path(doc_id.uri)
                        val query_pos = QueryPosition(line: position.line, column: position.character)

                        val def_result = self.compiler_query_ctx.find_definition(file_path, query_pos)

                        match def_result:
                            case None:
                                transport.write_response(id, nil)?
                            case Some(result):
                                # Convert locations to LSP format
                                var lsp_locations = []
                                for loc in result.locations:
                                    val lsp_loc = {
                                        "uri": file_path_to_uri(loc.file),
                                        "range": {
                                            "start": {
                                                "line": loc.start.line,
                                                "character": loc.start.column,
                                            },
                                            "end": {
                                                "line": loc.end.line,
                                                "character": loc.end.column,
                                            },
                                        },
                                    }
                                    lsp_locations.push(lsp_loc)

                                # Return first location (or array if multiple)
                                if lsp_locations.length == 1:
                                    transport.write_response(id, lsp_locations[0])?
                                else:
                                    transport.write_response(id, lsp_locations)?

                        Ok(nil)

# Helper: Convert file path to URI
fn file_path_to_uri(file_path: String) -> String:
    # Add file:// prefix
    "file://" + file_path

    # Handle textDocument/hover request
    fn handle_hover(id: Int, params: Option<Dict>) -> Result<Nil, String>:
        match params:
            case None:
                return Err("Missing params for hover")
            case Some(p):
                # Extract text document and position
                val text_document_data = p.get("textDocument")?
                val doc_id = protocol.TextDocumentIdentifier__from_json(text_document_data)?

                val position_data = p.get("position")?
                val position = protocol.Position__from_json(position_data)?

                # Get document from cache
                match self.documents.get(doc_id.uri):
                    case None:
                        transport.write_error(
                            id,
                            protocol.ERROR_INVALID_PARAMS,
                            "Document not found: {doc_id.uri}"
                        )?
                        Ok(nil)
                    case Some(doc_info):
                        # NEW: Use Compiler Query API for hover
                        val file_path = uri_to_file_path(doc_id.uri)
                        val query_pos = QueryPosition(line: position.line, column: position.character)

                        val hover_info = self.compiler_query_ctx.hover_at(file_path, query_pos)

                        match hover_info:
                            case None:
                                transport.write_response(id, nil)?
                            case Some(info):
                                # Convert to LSP hover response
                                val hover_data = {
                                    "contents": {
                                        "kind": "markdown",
                                        "value": info.contents,
                                    },
                                    "range": {
                                        "start": {
                                            "line": info.range.start.line,
                                            "character": info.range.start.column,
                                        },
                                        "end": {
                                            "line": info.range.end.line,
                                            "character": info.range.end.column,
                                        },
                                    },
                                }
                                transport.write_response(id, hover_data)?

                        Ok(nil)

    # Handle textDocument/semanticTokens/full request
    fn handle_semantic_tokens_full(id: Int, params: Option<Dict>) -> Result<Nil, String>:
        match params:
            case None:
                return Err("Missing params for semanticTokens/full")
            case Some(p):
                # Extract text document identifier
                val text_document_data = p.get("textDocument")?
                val doc_id = protocol.TextDocumentIdentifier__from_json(text_document_data)?

                # Get document from cache
                match self.documents.get(doc_id.uri):
                    case None:
                        transport.write_error(
                            id,
                            protocol.ERROR_INVALID_PARAMS,
                            "Document not found: {doc_id.uri}"
                        )?
                        Ok(nil)
                    case Some(doc_info):
                        # Use semantic tokens handler
                        match doc_info.tree:
                            case None:
                                # No tree - return empty tokens
                                val result = { "data": [] }
                                transport.write_response(id, result)?
                                Ok(nil)
                            case Some(tree):
                                val result = semantic_tokens.handle_semantic_tokens_full(tree, doc_info.text)?
                                transport.write_response(id, result)?
                                Ok(nil)

    # Handle simple/leanDefinition request (go to Lean artifact)
    fn handle_lean_definition(id: Int, params: Option<Dict>) -> Result<Nil, String>:
        match params:
            case None:
                return Err("Missing params for leanDefinition")
            case Some(p):
                # Extract text document and position
                val text_document_data = p.get("textDocument")?
                val doc_id = protocol.TextDocumentIdentifier__from_json(text_document_data)?

                val position_data = p.get("position")?
                val position = protocol.Position__from_json(position_data)?

                # Get document from cache
                match self.documents.get(doc_id.uri):
                    case None:
                        transport.write_error(
                            id,
                            protocol.ERROR_INVALID_PARAMS,
                            "Document not found: {doc_id.uri}"
                        )?
                        Ok(nil)
                    case Some(doc_info):
                        match doc_info.tree:
                            case None:
                                transport.write_response(id, nil)?
                                Ok(nil)
                            case Some(tree):
                                # Use Lean output dir from server config
                                match self.lean_output_dir:
                                    case Some(output_dir):
                                        match verification.handle_lean_definition(tree, position.line, position.character, output_dir):
                                            case Some(location):
                                                transport.write_response(id, location)?
                                            case None:
                                                transport.write_response(id, nil)?
                                    case None:
                                        transport.write_response(id, nil)?
                                Ok(nil)

    # Handle simple/verificationSymbols request
    fn handle_verification_symbols(id: Int, params: Option<Dict>) -> Result<Nil, String>:
        match params:
            case None:
                return Err("Missing params for verificationSymbols")
            case Some(p):
                # Extract text document
                val text_document_data = p.get("textDocument")?
                val doc_id = protocol.TextDocumentIdentifier__from_json(text_document_data)?

                # Get document from cache
                match self.documents.get(doc_id.uri):
                    case None:
                        transport.write_error(
                            id,
                            protocol.ERROR_INVALID_PARAMS,
                            "Document not found: {doc_id.uri}"
                        )?
                        Ok(nil)
                    case Some(doc_info):
                        match doc_info.tree:
                            case None:
                                transport.write_response(id, [])?
                                Ok(nil)
                            case Some(tree):
                                val symbols = verification.get_verification_symbols(tree)
                                transport.write_response(id, symbols)?
                                Ok(nil)

    # Main request dispatcher
    fn handle_request(request: protocol.JsonRpcRequest) -> Result<Nil, String>:
        match request.method:
            case "initialize":
                self.handle_initialize(request.id, request.params)
            case "shutdown":
                self.handle_shutdown(request.id)
            case "textDocument/semanticTokens/full":
                self.handle_semantic_tokens_full(request.id, request.params)
            case "textDocument/hover":
                self.handle_hover(request.id, request.params)
            case "textDocument/definition":
                self.handle_definition(request.id, request.params)
            case "textDocument/references":
                self.handle_references(request.id, request.params)
            case "textDocument/completion":
                self.handle_completion(request.id, request.params)
            case "simple/leanDefinition":
                self.handle_lean_definition(request.id, request.params)
            case "simple/verificationSymbols":
                self.handle_verification_symbols(request.id, request.params)
            case _:
                # Unknown method
                transport.write_error(
                    request.id,
                    protocol.ERROR_METHOD_NOT_FOUND,
                    "Method not found: {request.method}"
                )?
                Ok(nil)

    # Main notification dispatcher
    fn handle_notification(notification: protocol.JsonRpcNotification) -> Result<Nil, String>:
        match notification.method:
            case "initialized":
                self.handle_initialized()
            case "exit":
                self.handle_exit()
            case "textDocument/didOpen":
                self.handle_did_open(notification.params)
            case "textDocument/didChange":
                self.handle_did_change(notification.params)
            case "textDocument/didClose":
                self.handle_did_close(notification.params)
            case _:
                # Unknown notification - ignore (LSP spec allows this)
                transport.log_debug("Ignoring unknown notification: {notification.method}")
                Ok(nil)

    # Main server loop
    fn run() -> Result<Nil, String>:
        transport.log_debug("LSP server starting")

        loop:
            # Read next message
            val message = match transport.read_message():
                case Ok(msg):
                    msg
                case Err(e):
                    # EOF or error - exit gracefully
                    transport.log_debug("Read error: {e}")
                    return Ok(nil)

            # Determine message type
            val msg_type = transport.parse_message_type(message)?

            # Dispatch based on type
            match msg_type:
                case "request":
                    val request = protocol.JsonRpcRequest__from_json(message)?
                    self.handle_request(request)?
                case "notification":
                    val notification = protocol.JsonRpcNotification__from_json(message)?
                    self.handle_notification(notification)?
                case "response":
                    # We don't expect responses (we're the server)
                    transport.log_debug("Ignoring unexpected response message")
                case _:
                    transport.log_error("Unknown message type: {msg_type}")

        Ok(nil)

# Export classes and types
export LspServer
export ServerState
export DocumentInfo
