# LSP Diagnostics Handler
#
# Provides error and warning diagnostics

export handle_diagnostics, Diagnostic, DiagnosticSeverity

use compiler.treesitter.{TreeSitter, OutlineModule, ParseError}
# NOTE: awaiting FFI tree-sitter integration for Node, Tree, Query, QueryCursor

# Diagnostic severity levels
enum DiagnosticSeverity:
    Error = 1
    Warning = 2
    Information = 3
    Hint = 4

# Diagnostic message
struct Diagnostic:
    message: text
    severity: i64
    line: i64
    character: i64
    end_line: i64
    end_character: i64

# Handle diagnostics request
fn handle_diagnostics(tree: Tree?, source: text, uri: text) -> [Diagnostic]:
    """Generate diagnostics (errors/warnings) for document.

    Args:
        tree - Optional syntax tree
        source - Source code
        uri - Document URI

    Returns:
        List of diagnostics
    """
    var diagnostics: [Diagnostic] = []

    # Check for parse errors
    if not tree.?:
        diagnostics.push(Diagnostic(
            message: "Failed to parse document",
            severity: DiagnosticSeverity.Error.to_i64(),
            line: 0,
            character: 0,
            end_line: 0,
            end_character: 0
        ))
        return diagnostics

    val tree_val = tree.unwrap()
    val root = tree_val.root_node()

    # Check for error nodes in tree
    if root.has_error():
        diagnostics.push(Diagnostic(
            message: "Syntax error in document",
            severity: DiagnosticSeverity.Error.to_i64(),
            line: 0,
            character: 0,
            end_line: 0,
            end_character: 0
        ))

    # Check for common issues
    diagnostics = check_unused_variables(tree_val, source, diagnostics)
    diagnostics = check_missing_return(tree_val, source, diagnostics)
    diagnostics = check_unreachable_code(tree_val, source, diagnostics)

    diagnostics

fn check_unused_variables(tree: Tree, source: text, diagnostics: [Diagnostic]) -> [Diagnostic]:
    """Check for unused variable declarations.

    Args:
        tree - Syntax tree
        source - Source code
        diagnostics - Current diagnostics list

    Returns:
        Updated diagnostics list
    """
    var result = diagnostics

    # Query for variable declarations
    val var_query_result = Query.create("simple", """
        (variable_declaration) @var
    """)

    match var_query_result:
        Ok(var_query):
            val cursor = QueryCursor.create()
            cursor.exec(var_query, tree.root_node())

            while true:
                val match_opt = cursor.next_match()
                if not match_opt.?:
                    break

                # For each variable, would check if it's used
                # Simplified: just mark as hint that variable should be used
                result.push(Diagnostic(
                    message: "Consider using declared variable",
                    severity: DiagnosticSeverity.Hint.to_i64(),
                    line: 0,
                    character: 0,
                    end_line: 0,
                    end_character: 0
                ))
                break  # Only show one for now

            var_query.free()
            cursor.free()
        Err(_):
            ()

    result

fn check_missing_return(tree: Tree, source: text, diagnostics: [Diagnostic]) -> [Diagnostic]:
    """Check for functions missing return statements.

    Args:
        tree - Syntax tree
        source - Source code
        diagnostics - Current diagnostics list

    Returns:
        Updated diagnostics list
    """
    var result = diagnostics

    # Query for function definitions with return type
    val fn_query_result = Query.create("simple", """
        (function_definition) @fn
    """)

    match fn_query_result:
        Ok(fn_query):
            val cursor = QueryCursor.create()
            cursor.exec(fn_query, tree.root_node())

            while true:
                val match_opt = cursor.next_match()
                if not match_opt.?:
                    break

                # Would check if function has explicit return type but no return statement
                # For now, skip actual check

            fn_query.free()
            cursor.free()
        Err(_):
            ()

    result

fn check_unreachable_code(tree: Tree, source: text, diagnostics: [Diagnostic]) -> [Diagnostic]:
    """Check for unreachable code after return/break.

    Args:
        tree - Syntax tree
        source - Source code
        diagnostics - Current diagnostics list

    Returns:
        Updated diagnostics list
    """
    var result = diagnostics

    # Query for return statements
    val return_query_result = Query.create("simple", """
        (return_statement) @ret
    """)

    match return_query_result:
        Ok(return_query):
            val cursor = QueryCursor.create()
            cursor.exec(return_query, tree.root_node())

            while true:
                val match_opt = cursor.next_match()
                if not match_opt.?:
                    break

                # Would check if there's code after return in same block
                # For now, skip actual check

            return_query.free()
            cursor.free()
        Err(_):
            ()

    result

impl DiagnosticSeverity:
    fn to_i64() -> i64:
        match self:
            case Error: 1
            case Warning: 2
            case Information: 3
            case Hint: 4
