# LSP Completion Handler
#
# Provides auto-completion for Simple language including:
# - Keywords (fn, val, var, if, etc.)
# - Identifiers from scope
# - Member access completions
# - Import completions

use app.lsp.utils (node_at_position)

export handle_completion, CompletionItem, CompletionItemKind

use parser.treesitter.{Node, Query, QueryCursor, Tree}

# ============================================================================
# LSP Protocol Types
# ============================================================================

enum CompletionItemKind:
    """LSP completion item kinds."""
    Text = 1
    Method = 2
    Function = 3
    Constructor = 4
    Field = 5
    Variable = 6
    Class = 7
    Interface = 8
    Module = 9
    Property = 10
    Unit = 11
    Value = 12
    Enum = 13
    Keyword = 14
    Snippet = 15
    Color = 16
    File = 17
    Reference = 18
    Folder = 19
    EnumMember = 20
    Constant = 21
    Struct = 22
    Event = 23
    Operator = 24
    TypeParameter = 25

impl CompletionItemKind:
    fn to_i64() -> i64:
        match self:
            case Text: 1
            case Method: 2
            case Function: 3
            case Constructor: 4
            case Field: 5
            case Variable: 6
            case Class: 7
            case Interface: 8
            case Module: 9
            case Property: 10
            case Unit: 11
            case Value: 12
            case Enum: 13
            case Keyword: 14
            case Snippet: 15
            case Color: 16
            case File: 17
            case Reference: 18
            case Folder: 19
            case EnumMember: 20
            case Constant: 21
            case Struct: 22
            case Event: 23
            case Operator: 24
            case TypeParameter: 25

class CompletionItem:
    """LSP completion item."""
    label: text
    kind: i64
    detail: text?
    documentation: text?
    insert_text: text?

    static fn create(label: text, kind: CompletionItemKind) -> CompletionItem:
        """Create completion item.

        Args:
            label - Display text
            kind - Completion kind

        Returns:
            Completion item
        """
        CompletionItem(
            label: label,
            kind: kind.to_i64(),
            detail: None,
            documentation: None,
            insert_text: None
        )

    fn with_detail(detail_text: text) -> CompletionItem:
        """Add detail text (builder pattern).

        Args:
            detail_text - Detail text

        Returns:
            Self for chaining
        """
        self.detail = Some(detail_text)
        self

    fn with_documentation(doc_text: text) -> CompletionItem:
        """Add documentation (builder pattern).

        Args:
            doc_text - Documentation text

        Returns:
            Self for chaining
        """
        self.documentation = Some(doc_text)
        self

    fn with_insert_text(text: text) -> CompletionItem:
        """Add insert text (builder pattern).

        Args:
            text - Text to insert

        Returns:
            Self for chaining
        """
        self.insert_text = Some(text)
        self

struct Position:
    """LSP position (line, character)."""
    line: i64
    character: i64

# ============================================================================
# Completion Context
# ============================================================================

enum CompletionContext:
    """Context for completion."""
    KeywordContext
    IdentifierContext
    MemberAccessContext(object_type: text)
    ImportContext
    UnknownContext

# ============================================================================
# Main Completion Handler
# ============================================================================

fn handle_completion(tree: Tree?, source: text, position: Position) -> Result<[CompletionItem], text>:
    """Generate completion items at cursor position.

    Args:
        tree - Optional syntax tree
        source - Source code
        position - Cursor position

    Returns:
        List of completion items
    """
    # If no tree, return keyword completions only
    if not tree.?:
        return Ok(keyword_completions())

    val tree_val = tree.unwrap()

    # Get node at position
    val node = node_at_position(tree_val, position)
    if not node.?:
        return Ok(keyword_completions())

    val node_val = node.unwrap()

    # Determine completion context
    val context = completion_context(node_val)

    # Generate completions based on context
    match context:
        case KeywordContext:
            Ok(keyword_completions())
        case IdentifierContext:
            Ok(merge_completions(
                keyword_completions(),
                identifier_completions(tree_val, node_val)
            ))
        case MemberAccessContext(obj_type):
            Ok(member_completions(obj_type))
        case ImportContext:
            Ok(import_completions())
        case UnknownContext:
            Ok(keyword_completions())

# ============================================================================
# Completion Generators
# ============================================================================

fn keyword_completions() -> [CompletionItem]:
    """Return Simple language keyword completions."""
    [
        CompletionItem.create("fn", CompletionItemKind.Keyword)
            .with_detail("Function definition")
            .with_insert_text("fn ${1:name}(${2:args}):\n    ${0}"),

        CompletionItem.create("val", CompletionItemKind.Keyword)
            .with_detail("Immutable variable"),

        CompletionItem.create("var", CompletionItemKind.Keyword)
            .with_detail("Mutable variable"),

        CompletionItem.create("class", CompletionItemKind.Keyword)
            .with_detail("Class definition")
            .with_insert_text("class ${1:Name}:\n    ${0}"),

        CompletionItem.create("struct", CompletionItemKind.Keyword)
            .with_detail("Struct definition")
            .with_insert_text("struct ${1:Name}:\n    ${0}"),

        CompletionItem.create("enum", CompletionItemKind.Keyword)
            .with_detail("Enum definition")
            .with_insert_text("enum ${1:Name}:\n    ${0}"),

        CompletionItem.create("if", CompletionItemKind.Keyword)
            .with_detail("Conditional")
            .with_insert_text("if ${1:condition}:\n    ${0}"),

        CompletionItem.create("else", CompletionItemKind.Keyword)
            .with_detail("Else branch"),

        CompletionItem.create("elif", CompletionItemKind.Keyword)
            .with_detail("Else-if branch")
            .with_insert_text("elif ${1:condition}:\n    ${0}"),

        CompletionItem.create("match", CompletionItemKind.Keyword)
            .with_detail("Pattern matching")
            .with_insert_text("match ${1:expr}:\n    case ${2:pattern}: ${0}"),

        CompletionItem.create("case", CompletionItemKind.Keyword)
            .with_detail("Match case"),

        CompletionItem.create("for", CompletionItemKind.Keyword)
            .with_detail("For loop")
            .with_insert_text("for ${1:item} in ${2:iterable}:\n    ${0}"),

        CompletionItem.create("while", CompletionItemKind.Keyword)
            .with_detail("While loop")
            .with_insert_text("while ${1:condition}:\n    ${0}"),

        CompletionItem.create("return", CompletionItemKind.Keyword)
            .with_detail("Return value"),

        CompletionItem.create("break", CompletionItemKind.Keyword)
            .with_detail("Break loop"),

        CompletionItem.create("continue", CompletionItemKind.Keyword)
            .with_detail("Continue loop"),

        CompletionItem.create("import", CompletionItemKind.Keyword)
            .with_detail("Import module")
            .with_insert_text("import ${1:module}"),

        CompletionItem.create("from", CompletionItemKind.Keyword)
            .with_detail("Import from module")
            .with_insert_text("from ${1:module} import ${2:item}"),

        CompletionItem.create("use", CompletionItemKind.Keyword)
            .with_detail("Use declaration")
            .with_insert_text("use ${1:module}"),

        CompletionItem.create("export", CompletionItemKind.Keyword)
            .with_detail("Export declaration"),

        CompletionItem.create("trait", CompletionItemKind.Keyword)
            .with_detail("Trait definition")
            .with_insert_text("trait ${1:Name}:\n    ${0}"),

        CompletionItem.create("impl", CompletionItemKind.Keyword)
            .with_detail("Implementation block")
            .with_insert_text("impl ${1:Type}:\n    ${0}"),

        CompletionItem.create("static", CompletionItemKind.Keyword)
            .with_detail("Static method/field"),

        CompletionItem.create("me", CompletionItemKind.Keyword)
            .with_detail("Mutable method"),

        CompletionItem.create("extern", CompletionItemKind.Keyword)
            .with_detail("External function"),

        CompletionItem.create("true", CompletionItemKind.Keyword)
            .with_detail("Boolean true"),

        CompletionItem.create("false", CompletionItemKind.Keyword)
            .with_detail("Boolean false"),

        CompletionItem.create("None", CompletionItemKind.Keyword)
            .with_detail("None value"),

        CompletionItem.create("Some", CompletionItemKind.Keyword)
            .with_detail("Some value")
            .with_insert_text("Some(${1:value})"),

        CompletionItem.create("Ok", CompletionItemKind.Keyword)
            .with_detail("Ok result")
            .with_insert_text("Ok(${1:value})"),

        CompletionItem.create("Err", CompletionItemKind.Keyword)
            .with_detail("Error result")
            .with_insert_text("Err(${1:error})")
    ]

fn identifier_completions(tree: Tree, node: Node) -> [CompletionItem]:
    """Complete identifiers from scope.

    Args:
        tree - Syntax tree
        node - Current node

    Returns:
        List of identifier completions
    """
    var items: [CompletionItem] = []

    # Query for function definitions
    val fn_query_result = Query.create("simple", """
        (function_definition name: (identifier) @name)
    """)

    match fn_query_result:
        Ok(fn_query):
            val cursor = QueryCursor.create()
            cursor.exec(fn_query, tree.root_node())

            # Collect function names
            var seen: [text] = []
            while true:
                val match_opt = cursor.next_match()
                if not match_opt.?:
                    break

                val match_val = match_opt.unwrap()
                for capture in match_val.captures:
                    # Get node from handle (simplified for now)
                    val name = capture.node.text() ?? "function"
                    if not seen.contains(name):
                        items.push(CompletionItem.create(name, CompletionItemKind.Function))
                        seen.push(name)

            fn_query.free()
            cursor.free()
        Err(_):
            # Ignore query errors
            ()

    items

fn member_completions(object_type: text) -> [CompletionItem]:
    """Complete members of a type.

    Args:
        object_type - Type name

    Returns:
        List of member completions
    """
    # Common methods for built-in types
    match object_type:
        case "text" | "String":
            [
                CompletionItem.create("len", CompletionItemKind.Method)
                    .with_detail("Get string length"),
                CompletionItem.create("trim", CompletionItemKind.Method)
                    .with_detail("Trim whitespace"),
                CompletionItem.create("split", CompletionItemKind.Method)
                    .with_detail("Split string"),
                CompletionItem.create("contains", CompletionItemKind.Method)
                    .with_detail("Check if contains substring"),
                CompletionItem.create("starts_with", CompletionItemKind.Method)
                    .with_detail("Check if starts with prefix"),
                CompletionItem.create("ends_with", CompletionItemKind.Method)
                    .with_detail("Check if ends with suffix")
            ]
        case "Array" | "List":
            [
                CompletionItem.create("len", CompletionItemKind.Method)
                    .with_detail("Get array length"),
                CompletionItem.create("push", CompletionItemKind.Method)
                    .with_detail("Add element"),
                CompletionItem.create("pop", CompletionItemKind.Method)
                    .with_detail("Remove last element"),
                CompletionItem.create("filter", CompletionItemKind.Method)
                    .with_detail("Filter elements"),
                CompletionItem.create("map", CompletionItemKind.Method)
                    .with_detail("Transform elements"),
                CompletionItem.create("contains", CompletionItemKind.Method)
                    .with_detail("Check if contains element")
            ]
        case _:
            []

fn import_completions() -> [CompletionItem]:
    """Complete module imports.

    Returns:
        List of import completions
    """
    [
        CompletionItem.create("std", CompletionItemKind.Module)
            .with_detail("Standard library"),
        CompletionItem.create("core", CompletionItemKind.Module)
            .with_detail("Core module"),
        CompletionItem.create("io", CompletionItemKind.Module)
            .with_detail("I/O module"),
        CompletionItem.create("collections", CompletionItemKind.Module)
            .with_detail("Collections module"),
        CompletionItem.create("parser", CompletionItemKind.Module)
            .with_detail("Parser module")
    ]

# ============================================================================
# Helper Functions
# ============================================================================

fn completion_context(node: Node) -> CompletionContext:
    """Determine completion context from node.

    Args:
        node - Current node

    Returns:
        Completion context
    """
    val kind = node.kind()

    # Check node type to determine context
    if kind.contains("function") or kind.contains("identifier"):
        CompletionContext.IdentifierContext
    else if kind.contains("member") or kind.contains("field"):
        CompletionContext.MemberAccessContext("unknown")
    else if kind.contains("import") or kind.contains("use"):
        CompletionContext.ImportContext
    else:
        CompletionContext.KeywordContext

fn merge_completions(list1: [CompletionItem], list2: [CompletionItem]) -> [CompletionItem]:
    """Merge two completion lists.

    Args:
        list1 - First list
        list2 - Second list

    Returns:
        Merged list
    """
    var result = list1
    for item in list2:
        result.push(item)
    result
