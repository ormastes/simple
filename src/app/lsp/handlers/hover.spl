# LSP Hover Handler
#
# Provides hover information for symbols

export handle_hover, HoverResult

use parser.treesitter.{Node, Tree}
use app.lsp.utils (node_at_position)

# Hover result
struct HoverResult:
    content: text
    range: Range?

struct Range:
    start_line: i64
    start_char: i64
    end_line: i64
    end_char: i64

struct Position:
    line: i64
    character: i64

struct Point:
    row: i64
    column: i64

# Handle hover request
fn handle_hover(tree: Tree?, source: text, position: Position) -> HoverResult?:
    """Provide hover information at cursor position.

    Args:
        tree - Optional syntax tree
        source - Source code
        position - Cursor position

    Returns:
        Hover result or nil
    """
    # If no tree, can't provide hover info
    if not tree.?:
        return nil

    val tree_val = tree.unwrap()

    # Get node at position
    val node = node_at_position(tree_val, position)
    if not node.?:
        return nil

    val node_val = node.unwrap()
    val kind = node_val.kind()

    # Extract hover content based on node type
    var content = ""

    if kind.contains("identifier"):
        # Get identifier text
        val name = node_val.text(source)
        content = "**Symbol:** `{name}`\n\nType: identifier"
    else if kind.contains("function"):
        content = "**Type:** function\n\nFunction definition"
    else if kind.contains("class"):
        content = "**Type:** class\n\nClass definition"
    else if kind.contains("struct"):
        content = "**Type:** struct\n\nStructure definition"
    else if kind.contains("keyword"):
        val keyword_text = node_val.text(source)
        content = keyword_doc(keyword_text)
    else:
        # Generic node info
        content = "Node type: {kind}"

    # Create range from node bounds
    val start_point = node_val.start_point()
    val end_point = node_val.end_point()
    val range = Range(
        start_line: start_point.row,
        start_char: start_point.column,
        end_line: end_point.row,
        end_char: end_point.column
    )

    Some(HoverResult(content: content, range: Some(range)))

fn keyword_doc(keyword: text) -> text:
    """Get documentation for a keyword.

    Args:
        keyword - Keyword name

    Returns:
        Documentation string
    """
    match keyword:
        case "fn":
            "**fn** - Function definition\n\nDefines a function or method."
        case "val":
            "**val** - Immutable variable\n\nDeclares an immutable binding."
        case "var":
            "**var** - Mutable variable\n\nDeclares a mutable binding."
        case "class":
            "**class** - Class definition\n\nDefines a class with methods and fields."
        case "struct":
            "**struct** - Struct definition\n\nDefines a data structure."
        case "enum":
            "**enum** - Enum definition\n\nDefines an enumeration type."
        case "if":
            "**if** - Conditional\n\nConditional branching."
        case "else":
            "**else** - Else branch\n\nAlternative branch in conditional."
        case "match":
            "**match** - Pattern matching\n\nPattern matching expression."
        case "for":
            "**for** - For loop\n\nIterates over a collection."
        case "while":
            "**while** - While loop\n\nLoops while condition is true."
        case "return":
            "**return** - Return statement\n\nReturns a value from function."
        case "import" | "use":
            "**{keyword}** - Import declaration\n\nImports a module or symbols."
        case "export":
            "**export** - Export declaration\n\nExports symbols from module."
        case "trait":
            "**trait** - Trait definition\n\nDefines a trait (interface)."
        case "impl":
            "**impl** - Implementation block\n\nImplements methods for a type."
        case "static":
            "**static** - Static modifier\n\nMarks a method or field as static."
        case "me":
            "**me** - Mutable method modifier\n\nMarks a method that can mutate self."
        case "extern":
            "**extern** - External function\n\nDeclares an external (FFI) function."
        case _:
            "**{keyword}**"
