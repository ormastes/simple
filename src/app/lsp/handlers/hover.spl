# LSP Hover Handler
#
# Provides hover information for symbols

export handle_hover, HoverResult

use parser.treesitter.{Node, Tree}
use app.lsp.utils (node_at_position)
use std.string.{NL}

# Hover result
struct HoverResult:
    content: text
    range: Range?

struct Range:
    start_line: i64
    start_char: i64
    end_line: i64
    end_char: i64

struct Position:
    line: i64
    character: i64

struct Point:
    row: i64
    column: i64

# Handle hover request
fn handle_hover(tree: Tree?, source: text, position: Position) -> HoverResult?:
    """Provide hover information at cursor position.

    Args:
        tree - Optional syntax tree
        source - Source code
        position - Cursor position

    Returns:
        Hover result or nil
    """
    # If no tree, can't provide hover info
    if not tree.?:
        return nil

    val tree_val = tree.unwrap()

    # Get node at position
    val node = node_at_position(tree_val, position)
    if not node.?:
        return nil

    val node_val = node.unwrap()
    val kind = node_val.kind()

    # Extract hover content based on node type
    var content = ""

    if kind.contains("identifier"):
        # Get identifier text
        val name = node_val.text(source)
        content = "**Symbol:** `{name}`{NL}{NL}Type: identifier"
    else if kind.contains("function"):
        content = "**Type:** function{NL}{NL}Function definition"
    else if kind.contains("class"):
        content = "**Type:** class{NL}{NL}Class definition"
    else if kind.contains("struct"):
        content = "**Type:** struct{NL}{NL}Structure definition"
    else if kind.contains("keyword"):
        val keyword_text = node_val.text(source)
        content = keyword_doc(keyword_text)
    else:
        # Generic node info
        content = "Node type: {kind}"

    # Create range from node bounds
    val start_point = node_val.start_point()
    val end_point = node_val.end_point()
    val range = Range(
        start_line: start_point.row,
        start_char: start_point.column,
        end_line: end_point.row,
        end_char: end_point.column
    )

    Some(HoverResult(content: content, range: Some(range)))

fn keyword_doc(keyword: text) -> text:
    """Get documentation for a keyword.

    Args:
        keyword - Keyword name

    Returns:
        Documentation string
    """
    match keyword:
        case "fn":
            "**fn** - Function definition{NL}{NL}Defines a function or method."
        case "val":
            "**val** - Immutable variable{NL}{NL}Declares an immutable binding."
        case "var":
            "**var** - Mutable variable{NL}{NL}Declares a mutable binding."
        case "class":
            "**class** - Class definition{NL}{NL}Defines a class with methods and fields."
        case "struct":
            "**struct** - Struct definition{NL}{NL}Defines a data structure."
        case "enum":
            "**enum** - Enum definition{NL}{NL}Defines an enumeration type."
        case "if":
            "**if** - Conditional{NL}{NL}Conditional branching."
        case "else":
            "**else** - Else branch{NL}{NL}Alternative branch in conditional."
        case "match":
            "**match** - Pattern matching{NL}{NL}Pattern matching expression."
        case "for":
            "**for** - For loop{NL}{NL}Iterates over a collection."
        case "while":
            "**while** - While loop{NL}{NL}Loops while condition is true."
        case "return":
            "**return** - Return statement{NL}{NL}Returns a value from function."
        case "import" | "use":
            "**{keyword}** - Import declaration{NL}{NL}Imports a module or symbols."
        case "export":
            "**export** - Export declaration{NL}{NL}Exports symbols from module."
        case "trait":
            "**trait** - Trait definition{NL}{NL}Defines a trait (interface)."
        case "impl":
            "**impl** - Implementation block{NL}{NL}Implements methods for a type."
        case "static":
            "**static** - Static modifier{NL}{NL}Marks a method or field as static."
        case "me":
            "**me** - Mutable method modifier{NL}{NL}Marks a method that can mutate self."
        case "extern":
            "**extern** - External function{NL}{NL}Declares an external (FFI) function."
        case _:
            "**{keyword}**"
