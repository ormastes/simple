# Test Runner Client Harness
#
# Minimal test harness for embedded targets.
# Designed for small code size and minimal dependencies.
#
# Usage:
#   val harness = TestHarness_create(sender, 10)  # 10 tests
#   harness.begin_test(1)
#   # ... run test ...
#   harness.pass_test()
#   harness.complete()

# =========================================================================
# Test Harness State
# =========================================================================

class TestHarness:
    sender: MessageSender
    test_count: i32
    current_test: i32
    test_start_time: i64
    passed: i32
    failed: i32
    skipped: i32

fn TestHarness_create(sender: MessageSender, test_count: i32) -> TestHarness:
    TestHarness(
        sender: sender,
        test_count: test_count,
        current_test: 0,
        test_start_time: 0,
        passed: 0,
        failed: 0,
        skipped: 0
    )

impl TestHarness:
    # Initialize and send ready message
    me init():
        self.sender.send_ready(self.test_count)

    # Start a test suite
    me begin_suite(suite_id: i32):
        self.sender.send_suite_start(suite_id)

    # End a test suite
    me end_suite(suite_id: i32):
        self.sender.send_suite_end(suite_id)

    # Begin a test
    me begin_test(test_id: i32):
        self.current_test = test_id
        self.test_start_time = get_time_ms()
        self.sender.send_test_start(test_id)

    # Mark current test as passed
    me pass_test():
        val duration = (get_time_ms() - self.test_start_time) as i32
        self.passed = self.passed + 1
        self.sender.send_test_pass(self.current_test, duration)

    # Mark current test as failed
    me fail_test(msg_handle: i32, file_handle: i32, line: i32):
        val duration = (get_time_ms() - self.test_start_time) as i32
        self.failed = self.failed + 1
        self.sender.send_test_fail(self.current_test, duration, msg_handle, file_handle, line)

    # Mark current test as skipped
    me skip_test():
        self.skipped = self.skipped + 1
        self.sender.send_test_skip(self.current_test)

    # Mark current test as timed out
    me timeout_test():
        val duration = (get_time_ms() - self.test_start_time) as i32
        self.failed = self.failed + 1
        self.sender.send_test_timeout(self.current_test, duration)

    # Log a message during test
    me log(msg_handle: i32):
        self.sender.send_log(msg_handle)

    # Report assertion failure (doesn't end test)
    me assert_fail(msg_handle: i32, file_handle: i32, line: i32):
        self.sender.send_assert_fail(self.current_test, msg_handle, file_handle, line)

    # Complete all tests
    me complete():
        val total = self.passed + self.failed + self.skipped
        self.sender.send_complete(total, self.passed, self.failed, self.skipped)

    # Get results
    fn get_passed() -> i32:
        self.passed

    fn get_failed() -> i32:
        self.failed

    fn get_skipped() -> i32:
        self.skipped

    fn get_total() -> i32:
        self.passed + self.failed + self.skipped

    fn is_success() -> bool:
        self.failed == 0

# =========================================================================
# Time Functions (platform-specific stubs)
# =========================================================================

# Get current time in milliseconds
# On embedded: Uses timer or semihosting SYS_CLOCK
# For testing: Returns mock value
fn get_time_ms() -> i64:
    # Platform-specific implementation would go here
    # For now, return 0 (tests can mock this)
    0

# =========================================================================
# Exit Functions (platform-specific stubs)
# =========================================================================

# Exit with code (for QEMU debug exit)
fn embedded_exit(code: i32):
    # Platform-specific implementation would go here
    # QEMU x86: outb(0xF4, (code << 1) | 1)
    # ARM semihosting: SYS_EXIT
    pass

# Exit based on test results
fn exit_with_results(harness: TestHarness):
    if harness.is_success():
        embedded_exit(0)
    else:
        embedded_exit(1)

# =========================================================================
# Convenience Harness (global state for simple usage)
# =========================================================================

class GlobalHarness:
    harness: TestHarness?
    initialized: bool

fn GlobalHarness_empty() -> GlobalHarness:
    GlobalHarness(harness: None, initialized: false)

impl GlobalHarness:
    me init(sender: MessageSender, test_count: i32):
        var h = TestHarness_create(sender, test_count)
        h.init()
        self.harness = Some(h)
        self.initialized = true

    me begin_test(test_id: i32):
        if self.initialized:
            match self.harness:
                Some(h):
                    h.begin_test(test_id)
                    self.harness = Some(h)
                None: pass

    me pass_test():
        if self.initialized:
            match self.harness:
                Some(h):
                    h.pass_test()
                    self.harness = Some(h)
                None: pass

    me fail_test(msg_handle: i32, file_handle: i32, line: i32):
        if self.initialized:
            match self.harness:
                Some(h):
                    h.fail_test(msg_handle, file_handle, line)
                    self.harness = Some(h)
                None: pass

    me skip_test():
        if self.initialized:
            match self.harness:
                Some(h):
                    h.skip_test()
                    self.harness = Some(h)
                None: pass

    me complete():
        if self.initialized:
            match self.harness:
                Some(h):
                    h.complete()
                    self.harness = Some(h)
                None: pass

    fn is_success() -> bool:
        match self.harness:
            Some(h): h.is_success()
            None: false
