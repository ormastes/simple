# Leak Check - External Tool Output Parsers
#
# Parses ASan and Valgrind output into structured ExternalLeakReport.

use types

# Parse AddressSanitizer (ASan) leak output from stderr
fn parse_asan_output(stderr: text) -> ExternalLeakReport:
    var report = empty_external_leak_report()
    report.tool = "asan"
    report.raw_output = stderr

    val lines = stderr.split("\n")
    var i = 0
    var current_leak: ExternalLeak = nil
    var current_frames: [text] = []

    while i < lines.len():
        val line = lines[i]

        # Parse leak blocks: "Direct leak of N byte(s) in M object(s)"
        # or "Indirect leak of N byte(s) in M object(s)"
        if line.contains("leak of ") and line.contains("byte(s)"):
            # Save previous leak if any
            if current_leak != nil:
                current_leak.stack_frames = current_frames
                report.leaks.push(current_leak)

            val bytes = extract_number_before(line, " byte(s)")
            val blocks = extract_number_before(line, " object(s)")
            var category = "unknown"
            if line.contains("Direct leak"):
                category = "definitely_lost"
            elif line.contains("Indirect leak"):
                category = "indirectly_lost"
            current_leak = ExternalLeak(bytes: bytes, blocks: blocks, category: category, stack_frames: [])
            current_frames = []

        # Parse stack frames: "#0 0xABCD in func_name file.c:123"
        elif line.contains("#") and line.contains(" in "):
            val trimmed = line.trim()
            current_frames.push(trimmed)

        # Parse SUMMARY line (skip byte extraction â€” totals computed from per-leak loop below)
        elif line.contains("SUMMARY: AddressSanitizer"):
            pass_dn

        i = i + 1

    # Save last leak block
    if current_leak != nil:
        current_leak.stack_frames = current_frames
        report.leaks.push(current_leak)

    # Sum up leak categories
    for leak in report.leaks:
        if leak.category == "definitely_lost":
            report.definitely_lost_bytes = report.definitely_lost_bytes + leak.bytes
        elif leak.category == "indirectly_lost":
            report.indirectly_lost_bytes = report.indirectly_lost_bytes + leak.bytes

    report

# Parse Valgrind --leak-check=full output
fn parse_valgrind_output(output: text) -> ExternalLeakReport:
    var report = empty_external_leak_report()
    report.tool = "valgrind"
    report.raw_output = output

    val lines = output.split("\n")
    var i = 0
    var in_leak_summary = false
    var current_leak: ExternalLeak = nil
    var current_frames: [text] = []

    while i < lines.len():
        val raw_line = lines[i]
        val line = strip_valgrind_prefix(raw_line)

        # Detect LEAK SUMMARY section
        if line.contains("LEAK SUMMARY"):
            in_leak_summary = true
            # Save any pending leak
            if current_leak != nil:
                current_leak.stack_frames = current_frames
                report.leaks.push(current_leak)
                current_leak = nil
                current_frames = []

        elif in_leak_summary:
            if line.contains("definitely lost:"):
                report.definitely_lost_bytes = extract_number_after(line, "definitely lost:")
            elif line.contains("indirectly lost:"):
                report.indirectly_lost_bytes = extract_number_after(line, "indirectly lost:")
            elif line.contains("possibly lost:"):
                report.possibly_lost_bytes = extract_number_after(line, "possibly lost:")
            elif line.contains("still reachable:"):
                report.still_reachable_bytes = extract_number_after(line, "still reachable:")
            # End of summary section on blank or next section
            if line.trim() == "" and report.definitely_lost_bytes > 0:
                in_leak_summary = false

        # Parse individual leak blocks
        # "N bytes in M blocks are definitely lost in loss record X of Y"
        elif line.contains("bytes in") and line.contains("blocks are"):
            # Save previous leak
            if current_leak != nil:
                current_leak.stack_frames = current_frames
                report.leaks.push(current_leak)

            val bytes = extract_number_before(line, " bytes in")
            val blocks = extract_number_after(line, "bytes in ")
            var category = "unknown"
            if line.contains("definitely lost"):
                category = "definitely_lost"
            elif line.contains("indirectly lost"):
                category = "indirectly_lost"
            elif line.contains("possibly lost"):
                category = "possibly_lost"
            elif line.contains("still reachable"):
                category = "still_reachable"
            current_leak = ExternalLeak(bytes: bytes, blocks: blocks, category: category, stack_frames: [])
            current_frames = []

        # Parse stack frames: "at 0xABCD: func (file.c:123)" or "by 0xABCD: func (file.c:123)"
        elif (line.trim().starts_with("at 0x") or line.trim().starts_with("by 0x")) and current_leak != nil:
            current_frames.push(line.trim())

        i = i + 1

    # Save last leak block
    if current_leak != nil:
        current_leak.stack_frames = current_frames
        report.leaks.push(current_leak)

    report

# Extract the number that appears before a keyword in a line
# Example: "Direct leak of 128 byte(s)" with keyword " byte(s)" -> 128
fn extract_number_before(line: text, keyword: text) -> i64:
    val idx = line.index_of(keyword)
    if idx == nil:
        return 0
    val before = line.substring(0, idx)
    # Walk backwards from end to find the number
    var num_str = ""
    var j = before.len() - 1
    while j >= 0:
        val ch = before.substring(j, j + 1)
        if ch == "0" or ch == "1" or ch == "2" or ch == "3" or ch == "4" or ch == "5" or ch == "6" or ch == "7" or ch == "8" or ch == "9":
            num_str = ch + num_str
            j = j - 1
        elif ch == "," or ch == " ":
            # Skip comma/space separators within numbers
            if num_str.len() > 0:
                j = j - 1
            else:
                break
        else:
            break
    if num_str.len() > 0:
        return num_str.replace(",", "").to_int()
    0

# Extract the number that appears after a keyword in a line
# Example: "definitely lost: 128 bytes" with keyword "definitely lost:" -> 128
fn extract_number_after(line: text, keyword: text) -> i64:
    val idx = line.index_of(keyword)
    if idx == nil:
        return 0
    val after = line.substring(idx + keyword.len())
    val trimmed = after.trim()
    # Extract leading digits
    var num_str = ""
    var j = 0
    while j < trimmed.len():
        val ch = trimmed.substring(j, j + 1)
        if ch == "0" or ch == "1" or ch == "2" or ch == "3" or ch == "4" or ch == "5" or ch == "6" or ch == "7" or ch == "8" or ch == "9":
            num_str = num_str + ch
        elif ch == ",":
            # Skip comma separators
            j = j + 1
            continue
        else:
            break
        j = j + 1
    if num_str.len() > 0:
        return num_str.to_int()
    0

# Strip Valgrind's "==PID== " prefix from a line
fn strip_valgrind_prefix(line: text) -> text:
    if line.starts_with("=="):
        val end_prefix = line.index_of("== ")
        if end_prefix != nil:
            return line.substring(end_prefix + 3)
    line

export parse_asan_output, parse_valgrind_output
export extract_number_before, extract_number_after, strip_valgrind_prefix
