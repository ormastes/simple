# Control Flow Expressions
#
# Parses control flow expressions: if, match, spawn, go, new, contract old,
# forall, exists, and dollar identifiers.

from token import {Span, TokenKind}
from ast import {Expr, Block, Node, Pattern, MatchArm, PointerKind, MoveMode, LambdaParam}
from error import {ParseError}

impl Parser:

    fn parse_primary_control() -> Expr:
        match self.current.kind:
            TokenKind.Old: self.parse_contract_old()
            TokenKind.Forall: self.parse_forall()
            TokenKind.Exists: self.parse_exists()
            TokenKind.If | TokenKind.Elif:
                self.advance()
                self.parse_if_expr()
            TokenKind.Match: self.parse_match_expr()
            TokenKind.Spawn: self.parse_spawn_expr()
            TokenKind.Go: self.parse_go_expr()
            TokenKind.New: self.parse_new_expr()
            TokenKind.Dollar: self.parse_dollar_identifier()
            _:
                raise ParseError.unexpected_token("control expression",
                    "{self.current.kind}", self.current.span)

    fn parse_contract_old() -> Expr:
        self.advance()
        self.expect(TokenKind.LParen)
        val expr = self.parse_expression()
        self.expect(TokenKind.RParen)
        Expr.ContractOld(expr)

    fn parse_forall() -> Expr:
        self.advance()
        val pattern = self.parse_pattern()
        self.expect(TokenKind.In)
        val range = self.parse_expression()
        self.expect(TokenKind.Colon)
        val predicate = self.parse_expression()
        Expr.Forall(pattern: pattern, range: range, predicate: predicate)

    fn parse_exists() -> Expr:
        self.advance()
        val pattern = self.parse_pattern()
        self.expect(TokenKind.In)
        val range = self.parse_expression()
        self.expect(TokenKind.Colon)
        val predicate = self.parse_expression()
        Expr.Exists(pattern: pattern, range: range, predicate: predicate)

    fn parse_match_expr() -> Expr:
        self.advance()
        val subject = self.parse_expression()
        self.lexer.enable_forced_indentation()
        self.expect(TokenKind.Colon)
        if self.check(TokenKind.Newline):
            self.advance()
            self.expect(TokenKind.Indent)
            var arms = []
            while not self.check(TokenKind.Dedent) and not self.is_at_end():
                while self.check(TokenKind.Newline): self.advance()
                if self.check(TokenKind.Dedent): break
                arms.push(self.parse_match_arm_expr())
            if self.check(TokenKind.Dedent): self.advance()
            self.lexer.disable_forced_indentation()
            Expr.Match(subject: subject, arms: arms)
        else:
            self.lexer.disable_forced_indentation()
            raise ParseError.unexpected_token("newline after match",
                "{self.current.kind}", self.current.span)

    fn parse_match_arm_expr() -> MatchArm:
        val start_span = self.current.span

        val is_pipe_syntax = self.check(TokenKind.Pipe)
        if is_pipe_syntax:
            self.advance()
        elif self.check(TokenKind.Case):
            self.advance()

        val pattern = self.parse_pattern()
        val guard = if self.check(TokenKind.If):
            self.advance()
            self.parse_expression()
        else:
            None

        val valid_separator = if is_pipe_syntax:
            self.check(TokenKind.Arrow)
        else:
            self.check(TokenKind.Arrow) or self.check(TokenKind.FatArrow) or self.check(TokenKind.Colon)

        if not valid_separator:
            val expected = if is_pipe_syntax: "->" else: "-> or => or :"
            raise ParseError.unexpected_token(expected,
                "{self.current.kind}", self.current.span)

        self.advance()
        val body = if self.check(TokenKind.Newline):
            self.parse_block()
        elif self.check(TokenKind.Return) or self.check(TokenKind.Break) or self.check(TokenKind.Continue):
            val stmt = self.parse_item()
            Block(span: self.previous.span, statements: [stmt])
        else:
            val expr = self.parse_expression()
            Block(span: self.previous.span, statements: [Node.Expression(expr)])

        MatchArm(span: Span(start: start_span.start, end: self.previous.span.end,
                            line: start_span.line, column: start_span.column),
                 pattern: pattern, guard: guard, body: body)

    fn parse_spawn_expr() -> Expr:
        self.advance()
        val expr = self.parse_expression()
        Expr.Spawn(expr)

    fn parse_go_expr() -> Expr:
        self.advance()
        val args = if self.check(TokenKind.LParen):
            self.advance()
            if self.check(TokenKind.RParen):
                self.advance()
                []
            else:
                var a = []
                loop:
                    a.push(self.parse_expression())
                    if self.check(TokenKind.Comma): self.advance()
                    else: break
                self.expect(TokenKind.RParen)
                a
        elif self.check(TokenKind.Backslash):
            []
        else:
            raise ParseError.unexpected_token("( or \\ after go",
                "{self.current.kind}", self.current.span)

        self.expect(TokenKind.Backslash)
        var params = []
        if self.check(TokenKind.Star):
            self.advance()
        elif not self.check(TokenKind.Colon):
            loop:
                params.push(self.expect_identifier())
                if self.check(TokenKind.Comma): self.advance()
                else: break
        self.expect(TokenKind.Colon)
        val body = self.parse_expression()
        Expr.Go(args: args, params: params, body: body)

    fn parse_new_expr() -> Expr:
        self.advance()
        val kind = match self.current.kind:
            TokenKind.Ampersand:
                self.advance()
                PointerKind.Unique
            TokenKind.Star:
                self.advance()
                PointerKind.Shared
            TokenKind.Minus:
                self.advance()
                PointerKind.Weak
            TokenKind.Plus:
                self.advance()
                PointerKind.Handle
            _: PointerKind.Shared
        val expr = self.parse_postfix()
        Expr.New(kind: kind, expr: expr)

    fn parse_dollar_identifier() -> Expr:
        self.advance()
        val name = self.expect_identifier()
        Expr.Identifier("${name}")

    fn parse_if_expr() -> Expr:
        val old_no_brace = self.no_brace_postfix
        self.no_brace_postfix = true
        val (let_pattern, condition) = self.parse_optional_let_pattern()
        self.no_brace_postfix = old_no_brace

        val use_braces = self.check(TokenKind.LBrace)
        if not use_braces:
            self.expect(TokenKind.Colon)

        val then_branch = if use_braces:
            self.parse_brace_block_expr()
        elif self.check(TokenKind.Newline):
            self.advance()
            self.expect(TokenKind.Indent)
            var statements = []
            while not self.check(TokenKind.Dedent) and not self.is_at_end():
                while self.check(TokenKind.Newline): self.advance()
                if self.check(TokenKind.Dedent) or self.is_at_end(): break
                statements.push(self.parse_item())
                if self.check(TokenKind.Newline): self.advance()
            if self.check(TokenKind.Dedent): self.advance()
            Expr.DoBlock(statements)
        else:
            self.parse_expression()

        val else_branch = if self.check(TokenKind.Elif):
            self.advance()
            self.parse_if_expr()
        elif self.check(TokenKind.Else):
            self.advance()
            if self.check(TokenKind.If):
                self.advance()
                self.parse_if_expr()
            elif self.check(TokenKind.LBrace):
                self.parse_brace_block_expr()
            else:
                self.expect(TokenKind.Colon)
                if self.check(TokenKind.Newline):
                    self.advance()
                    self.expect(TokenKind.Indent)
                    var statements = []
                    while not self.check(TokenKind.Dedent) and not self.is_at_end():
                        while self.check(TokenKind.Newline): self.advance()
                        if self.check(TokenKind.Dedent) or self.is_at_end(): break
                        statements.push(self.parse_item())
                        if self.check(TokenKind.Newline): self.advance()
                    if self.check(TokenKind.Dedent): self.advance()
                    Expr.DoBlock(statements)
                else:
                    self.parse_expression()
        else:
            None

        Expr.If(let_pattern: let_pattern, condition: condition, then_branch: then_branch, else_branch: else_branch)

    fn parse_brace_block_expr() -> Expr:
        self.expect(TokenKind.LBrace)
        self.skip_whitespace_tokens()
        if self.check(TokenKind.RBrace):
            self.advance()
            return Expr.DoBlock([])
        val expr = self.parse_expression()
        self.skip_whitespace_tokens()
        self.expect(TokenKind.RBrace)
        expr
