# Collections
#
# Parses collection literals: arrays, dicts, tuples, and comprehensions.

from token import {TokenKind}
from ast import {Expr, Argument, MoveMode, Pattern}
from error import {ParseError}

impl Parser:

    fn parse_primary_collection() -> Expr:
        match self.current.kind:
            TokenKind.LParen: self.parse_grouped_or_tuple()
            TokenKind.LBracket: self.parse_array_literal()
            TokenKind.LBrace: self.parse_dict_literal()
            _:
                raise ParseError.unexpected_token("collection",
                    "{self.current.kind}", self.current.span)

    fn parse_grouped_or_tuple() -> Expr:
        self.advance()
        self.skip_whitespace_tokens()

        if self.check(TokenKind.RParen):
            self.advance()
            if self.check(TokenKind.FatArrow):
                self.advance()
                val body = self.parse_expression()
                return Expr.Lambda(params: [], body: body, move_mode: MoveMode.Copy, capture_all: false)
            return Expr.Tuple([])

        val first = self.parse_expression()
        self.skip_whitespace_tokens()

        if self.check(TokenKind.Comma):
            var elements = [first]
            while self.check(TokenKind.Comma):
                self.advance()
                self.skip_whitespace_tokens()
                if self.check(TokenKind.RParen): break
                elements.push(self.parse_expression())
                self.skip_whitespace_tokens()
            self.expect(TokenKind.RParen)
            Expr.Tuple(elements)
        else:
            self.expect(TokenKind.RParen)
            first

    fn parse_array_literal() -> Expr:
        self.advance()
        self.skip_whitespace_tokens()

        if self.check(TokenKind.RBracket):
            self.advance()
            return Expr.Array([])

        # Comprehension: [for pattern in iterable if cond: expr]
        if self.check(TokenKind.For):
            self.advance()
            val (pattern, iterable, condition) = self.parse_comprehension_clause()
            self.expect(TokenKind.Colon)
            self.skip_whitespace_tokens()
            val expr = self.parse_expression()
            self.skip_whitespace_tokens()
            self.expect(TokenKind.RBracket)
            return Expr.ListComprehension(expr: expr, pattern: pattern, iterable: iterable, condition: condition)

        # Spread: [*arr]
        if self.check(TokenKind.Star):
            self.advance()
            val spread_expr = self.parse_expression()
            var elements = [Expr.Spread(spread_expr)]
            while self.check(TokenKind.Comma):
                self.advance()
                self.skip_whitespace_tokens()
                if self.check(TokenKind.RBracket): break
                if self.check(TokenKind.Star):
                    self.advance()
                    elements.push(Expr.Spread(self.parse_expression()))
                else:
                    elements.push(self.parse_expression())
                self.skip_whitespace_tokens()
            self.expect(TokenKind.RBracket)
            return Expr.Array(elements)

        val first = self.parse_expression()
        self.skip_whitespace_tokens()

        # Comprehension: [expr for pattern in iterable]
        if self.check(TokenKind.For):
            self.advance()
            val (pattern, iterable, condition) = self.parse_comprehension_clause()
            self.expect(TokenKind.RBracket)
            return Expr.ListComprehension(expr: first, pattern: pattern, iterable: iterable, condition: condition)

        # Array repeat: [value; count]
        if self.check(TokenKind.Semicolon):
            self.advance()
            self.skip_whitespace_tokens()
            val count = self.parse_expression()
            self.skip_whitespace_tokens()
            self.expect(TokenKind.RBracket)
            return Expr.ArrayRepeat(value: first, count: count)

        # Regular array
        var elements = [first]
        while self.check(TokenKind.Comma):
            self.advance()
            self.skip_whitespace_tokens()
            if self.check(TokenKind.RBracket): break
            if self.check(TokenKind.Star):
                self.advance()
                elements.push(Expr.Spread(self.parse_expression()))
            else:
                elements.push(self.parse_expression())
            self.skip_whitespace_tokens()
        self.expect(TokenKind.RBracket)
        Expr.Array(elements)

    fn parse_dict_literal() -> Expr:
        self.advance()
        self.skip_newlines()

        if self.check(TokenKind.RBrace):
            self.advance()
            return Expr.Dict([])

        # Dict comprehension: {for pattern in iterable if cond: (key, value)}
        if self.check(TokenKind.For):
            self.advance()
            val (pattern, iterable, condition) = self.parse_comprehension_clause()
            self.expect(TokenKind.Colon)
            self.skip_whitespace_tokens()
            self.expect(TokenKind.LParen)
            val key = self.parse_expression()
            self.expect(TokenKind.Comma)
            val value = self.parse_expression()
            self.expect(TokenKind.RParen)
            self.skip_whitespace_tokens()
            self.expect(TokenKind.RBrace)
            return Expr.DictComprehension(key: key, value: value, pattern: pattern, iterable: iterable, condition: condition)

        # Dict spread: {**d1, **d2}
        if self.check(TokenKind.DoubleStar):
            self.advance()
            val spread_expr = self.parse_expression()
            var pairs = [(Expr.DictSpread(spread_expr), Expr.Nil)]
            while self.check(TokenKind.Comma):
                self.advance()
                self.skip_newlines()
                if self.check(TokenKind.RBrace): break
                if self.check(TokenKind.DoubleStar):
                    self.advance()
                    val spread_expr2 = self.parse_expression()
                    pairs.push((Expr.DictSpread(spread_expr2), Expr.Nil))
                else:
                    val k = self.parse_expression()
                    self.skip_newlines()
                    self.expect(TokenKind.Colon)
                    self.skip_newlines()
                    val v = self.parse_expression()
                    self.skip_newlines()
                    pairs.push((k, v))
            self.expect(TokenKind.RBrace)
            return Expr.Dict(pairs)

        val key = self.parse_expression()
        self.skip_newlines()
        self.expect(TokenKind.Colon)
        self.skip_newlines()
        val value = self.parse_expression()
        self.skip_newlines()

        # Dict comprehension: {k: v for pattern in iterable}
        if self.check(TokenKind.For):
            self.advance()
            val (pattern, iterable, condition) = self.parse_comprehension_clause()
            self.expect(TokenKind.RBrace)
            return Expr.DictComprehension(key: key, value: value, pattern: pattern, iterable: iterable, condition: condition)

        var pairs = [(key, value)]
        while self.check(TokenKind.Comma):
            self.advance()
            self.skip_newlines()
            if self.check(TokenKind.RBrace): break
            if self.check(TokenKind.DoubleStar):
                self.advance()
                val spread_expr = self.parse_expression()
                pairs.push((Expr.DictSpread(spread_expr), Expr.Nil))
            else:
                val k = self.parse_expression()
                self.skip_newlines()
                self.expect(TokenKind.Colon)
                self.skip_newlines()
                val v = self.parse_expression()
                self.skip_newlines()
                pairs.push((k, v))
        self.expect(TokenKind.RBrace)
        Expr.Dict(pairs)

    fn parse_comprehension_clause() -> (pattern: Pattern, iterable: Expr, condition: Expr?):
        val pattern = self.parse_pattern()
        self.expect(TokenKind.In)
        val iterable = self.parse_expression()
        val condition = if self.check(TokenKind.If):
            self.advance()
            self.parse_expression()
        else:
            nil
        (pattern, iterable, condition)
