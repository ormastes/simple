# Definition Parser - Class, Mixin, and Actor Definitions
#
# Parsing for:
# - class Name<T>(Parent) with Mixin: ...
# - mixin Name requires Trait: ...
# - actor Name: ...

from token import {Span, TokenKind}
from ast import {Node, ClassDef, MixinDef, ActorDef, MixinRef, RequiredMethodSig,
                 DocComment, Visibility, Attribute}
from error import {ParseError}

export ClassParser

# ============================================================================
# Class
# ============================================================================

fn parse_class(self) -> Result<Node, ParseError>:
    self.parse_class_with_attrs([])

fn parse_class_with_attrs(self, attributes: [Attribute]) -> Result<Node, ParseError>:
    val start_span = self.current.span
    self.expect(TokenKind.Class)
    val name = self.expect_identifier()
    val generic_params = self.parse_generic_params_as_strings()

    # Inheritance: class Child(Parent) or class Child extends Parent
    val parent = if self.check(TokenKind.LParen):
        self.advance()
        val p = self.expect_identifier()
        self.expect(TokenKind.RParen)
        Some(p)
    elif self.check(TokenKind.Extends):
        self.advance()
        Some(self.expect_identifier())
    else:
        nil

    # Mixin application: class Name with Mixin1, Mixin2<T>:
    var explicit_mixins = []
    if self.check(TokenKind.With):
        self.advance()
        loop:
            val mixin_name = self.expect_identifier()
            val type_args = if self.check(TokenKind.Lt):
                self.parse_generic_args()
            else:
                []
            explicit_mixins.append(MixinRef(
                span: self.current.span,
                name: mixin_name,
                type_args: type_args,
                overrides: [],
            ))
            if not self.check(TokenKind.Comma):
                break
            self.advance()

    val where_clause = self.parse_where_clause()

    val (fields, methods, invariant, macro_invocations, mixins, doc_comment) =
        if self.check(TokenKind.Newline) or self.is_at_end():
            ([], [], nil, [], [], nil)
        else:
            self.parse_class_body()

    # Prepend explicit mixins from `with` clause
    var all_mixins = explicit_mixins.merge(mixins)

    Ok(Node.Class(ClassDef(
        span: self.make_span(start_span),
        name: name,
        generic_params: generic_params,
        where_clause: where_clause,
        fields: fields,
        methods: methods,
        parent: parent,
        visibility: Visibility.Private,
        effects: [],
        attributes: attributes,
        doc_comment: doc_comment,
        invariant: invariant,
        macro_invocations: macro_invocations,
        mixins: all_mixins,
        is_generic_template: not generic_params.is_empty(),
        specialization_of: nil,
        type_bindings: {},
    )))

fn parse_class_with_doc(self, doc_comment: Option<DocComment>) -> Result<Node, ParseError>:
    var node = self.parse_class()
    match node:
        Ok(Node.Class(c)):
            c.doc_comment = doc_comment ?? c.doc_comment
    node

# ============================================================================
# Mixin
# ============================================================================

fn parse_mixin(self) -> Result<Node, ParseError>:
    val start_span = self.current.span
    self.expect(TokenKind.Mixin)
    val name = self.expect_identifier()
    val generic_params = self.parse_generic_params_as_strings()

    # Optional requires clause
    val (required_traits, required_mixins) = if self.check(TokenKind.Requires):
        self.advance()
        self.parse_mixin_requirements()
    else:
        ([], [])

    val _where_clause = self.parse_where_clause()
    val (fields, methods, _invariant, _macro_invocations, inner_mixins, doc_comment) = self.parse_class_body()

    # Merge use declarations from body into required_mixins
    var all_required_mixins = required_mixins
    for mref in inner_mixins:
        if not all_required_mixins.contains(mref.name):
            all_required_mixins.append(mref.name)

    # Separate abstract methods from implemented ones
    val required_methods = methods
        .filter(\m: m.is_abstract)
        .map(\m: RequiredMethodSig(
            span: m.span,
            name: m.name,
            params: m.params,
            return_type: m.return_type,
        ))
    val impl_methods = methods.filter(\m: not m.is_abstract)

    Ok(Node.Mixin(MixinDef(
        span: self.make_span(start_span),
        name: name,
        generic_params: generic_params,
        required_traits: required_traits,
        required_mixins: all_required_mixins,
        fields: fields,
        methods: impl_methods,
        required_methods: required_methods,
        visibility: Visibility.Private,
        doc_comment: doc_comment,
    )))

fn parse_mixin_with_doc(self, doc_comment: Option<DocComment>) -> Result<Node, ParseError>:
    var node = self.parse_mixin()
    match node:
        Ok(Node.Mixin(m)):
            m.doc_comment = doc_comment ?? m.doc_comment
    node

fn parse_mixin_with_attrs(self, attributes: [Attribute]) -> Result<Node, ParseError>:
    self.parse_mixin()

# Parse mixin requirements: requires Trait1, mixin2
fn parse_mixin_requirements(self) -> ([String], [String]):
    var required_traits = []
    var required_mixins = []
    loop:
        val req = self.expect_identifier()
        # Heuristic: uppercase = trait, lowercase = mixin
        if req[0].is_uppercase():
            required_traits.append(req)
        else:
            required_mixins.append(req)
        if not self.check(TokenKind.Comma):
            break
        self.advance()
    (required_traits, required_mixins)

# ============================================================================
# Actor
# ============================================================================

fn parse_actor(self) -> Result<Node, ParseError>:
    val start_span = self.current.span
    self.expect(TokenKind.Actor)
    val name = self.expect_identifier()

    val (fields, methods, _invariant, _doc_comment) = self.parse_indented_fields_and_methods()

    Ok(Node.Actor(ActorDef(
        span: self.make_span(start_span),
        name: name,
        fields: fields,
        methods: methods,
        visibility: Visibility.Private,
    )))
