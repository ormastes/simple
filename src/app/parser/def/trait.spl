# Definition Parser - Trait Definitions
#
# Parsing for:
# - trait Name<T>: Copy: methods...
# - Associated types
# - Abstract and default methods

from token import {Span, Token, TokenKind}
from ast import {Node, TraitDef, AssociatedTypeDef, FunctionDef, DocComment,
                 Visibility, Decorator, Effect, Type}
from error import {ParseError}

export TraitParser

# ============================================================================
# Trait
# ============================================================================

fn parse_trait(self) -> Result<Node, ParseError>:
    val start_span = self.current.span
    self.expect(TokenKind.Trait)
    val name = self.expect_identifier()
    val generic_params = self.parse_generic_params_as_strings()

    # Parse super traits: trait Copy: Clone or trait T: A + B<T>
    var super_traits = []
    if self.check(TokenKind.Colon):
        val colon_span = self.current.span
        self.advance()  # consume :

        if self.is_identifier():
            # Super trait syntax
            super_traits.append(self.parse_type())
            while self.check(TokenKind.Plus):
                self.advance()
                super_traits.append(self.parse_type())
        else:
            # Not super trait â€” put colon back for body parser
            val colon_token = Token(TokenKind.Colon, colon_span, ":")
            self.pending_tokens.push_front(self.current)
            self.current = colon_token

    val where_clause = self.parse_where_clause()
    val (associated_types, methods) = self.parse_indented_trait_body()

    Ok(Node.Trait(TraitDef(
        span: self.make_span(start_span),
        name: name,
        generic_params: generic_params,
        super_traits: super_traits,
        where_clause: where_clause,
        associated_types: associated_types,
        methods: methods,
        visibility: Visibility.Private,
        doc_comment: nil,
        is_generic_template: not generic_params.is_empty(),
        specialization_of: nil,
        type_bindings: {},
    )))

fn parse_trait_with_doc(self, doc_comment: Option<DocComment>) -> Result<Node, ParseError>:
    var node = self.parse_trait()
    match node:
        Ok(Node.Trait(t)):
            t.doc_comment = doc_comment
    node

# ============================================================================
# Trait Body
# ============================================================================

# Parse trait body: associated types and methods
fn parse_indented_trait_body(self) -> ([AssociatedTypeDef], [FunctionDef]):
    self.expect_block_start()
    var associated_types = []
    var methods = []

    while not self.check(TokenKind.Dedent) and not self.is_at_end():
        self.skip_newlines()
        if self.check(TokenKind.Dedent):
            break

        # Skip standalone docstrings
        if self.check_string() or self.check_fstring():
            self.advance()
            self.skip_newlines()
            continue

        # Associated type: type Name or type Name: Bound or type Name = Default
        if self.check(TokenKind.Type):
            associated_types.append(self.parse_associated_type_def())
        else:
            # Parse optional decorators
            var decorators = []
            while self.check(TokenKind.At):
                decorators.append(self.parse_decorator())
                self.skip_newlines()

            val is_async = if self.check(TokenKind.Async):
                self.advance()
                true
            else:
                false

            val is_static = if self.check(TokenKind.Static):
                self.advance()
                true
            else:
                false

            # Handle 'me' (mutable method) keyword
            val is_me = if self.check(TokenKind.Me):
                self.advance()
                if self.check(TokenKind.Fn):
                    self.advance()
                true
            else:
                false

            var method = if is_me:
                self.parse_trait_method_after_fn()
            else:
                self.parse_trait_method()
            method.decorators = decorators
            method.is_static = is_static
            if is_async:
                method.effects.append(Effect.Async)
            methods.append(method)

    self.consume_dedent()
    (associated_types, methods)

# ============================================================================
# Trait Methods
# ============================================================================

# Parse trait method (abstract or with default body)
fn parse_trait_method(self) -> FunctionDef:
    self.expect(TokenKind.Fn)
    self.parse_trait_method_after_fn()

fn parse_trait_method_after_fn(self) -> FunctionDef:
    val start_span = self.current.span
    val name = self.expect_identifier()
    val generic_params = self.parse_generic_params_as_strings()
    val params = self.parse_parameters()

    val return_type = if self.check(TokenKind.Arrow):
        self.advance()
        Some(self.parse_type())
    else:
        nil

    val where_clause = self.parse_where_clause()

    # Abstract (newline/dedent) vs default body (colon)
    val (body, is_abstract) = if self.check(TokenKind.Newline) or self.check(TokenKind.Dedent):
        if self.check(TokenKind.Newline):
            self.advance()
        (Block.default(), true)
    else:
        self.expect(TokenKind.Colon)
        (self.parse_block(), false)

    FunctionDef(
        span: self.make_span(start_span),
        name: name,
        generic_params: generic_params,
        params: params,
        return_type: return_type,
        where_clause: where_clause,
        body: body,
        visibility: Visibility.Private,
        effects: [],
        decorators: [],
        attributes: [],
        doc_comment: nil,
        contract: nil,
        is_abstract: is_abstract,
        is_sync: false,
        is_static: false,
        is_me_method: false,
        is_generator: false,
        bounds_block: nil,
        return_constraint: nil,
        is_generic_template: not generic_params.is_empty(),
        specialization_of: nil,
        type_bindings: {},
    )

# ============================================================================
# Associated Types
# ============================================================================

# Parse associated type definition in a trait: type Name or type Name: Bound
fn parse_associated_type_def(self) -> AssociatedTypeDef:
    val start_span = self.current.span
    self.expect(TokenKind.Type)
    val name = self.expect_identifier()

    # Optional bounds: type Item: Clone + Default
    val bounds = if self.check(TokenKind.Colon):
        self.advance()
        var b = []
        val bound_name = self.expect_identifier()
        # Skip generic args on bound
        if self.check(TokenKind.Lt):
            self.skip_generic_args()
        b.append(bound_name)
        while self.check(TokenKind.Plus):
            self.advance()
            val bn = self.expect_identifier()
            if self.check(TokenKind.Lt):
                self.skip_generic_args()
            b.append(bn)
        b
    else:
        []

    # Optional default: type Item = i64
    val default = if self.check(TokenKind.Assign):
        self.advance()
        Some(self.parse_type())
    else:
        nil

    if self.check(TokenKind.Newline):
        self.advance()

    AssociatedTypeDef(
        span: self.make_span(start_span),
        name: name,
        bounds: bounds,
        default: default,
    )
