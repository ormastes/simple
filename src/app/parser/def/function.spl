# Definition Parser - Function Definitions
#
# Parsing for:
# - fn name<T>(params) -> Type: body
# - async fn, sync fn, gen (generator)
# - Literal functions: literal fn _suffix(s: text) -> Type
# - Decorated functions
# - Function aliases
# - Return constraints

from token import {Span, TokenKind}
from ast import {Node, FunctionDef, LiteralFunctionDef, FunctionAliasDef, ClassAliasDef,
                 Block, Expr, Effect, Decorator, Attribute, Visibility, DocComment}
from error import {ParseError}

export FunctionParser

# ============================================================================
# Functions
# ============================================================================

fn parse_async_function(self) -> Result<Node, ParseError>:
    self.advance()  # consume 'async'
    var func = self.parse_function()
    match func:
        Node.Function(f): f.effects.append(Effect.Async)
    func

fn parse_sync_function(self) -> Result<Node, ParseError>:
    self.advance()  # consume 'sync'
    var func = self.parse_function()
    match func:
        Node.Function(f):
            f.is_sync = true
            if self.has_suspension_in_body(f.body):
                return Err(ParseError.syntax_error_with_span(
                    "Suspension operators not allowed in sync functions",
                    f.span))
    func

fn parse_function(self) -> Result<Node, ParseError>:
    self.parse_function_with_decorators([])

fn parse_function_with_decorators(self, decorators: [Decorator]) -> Result<Node, ParseError>:
    self.parse_function_with_attrs(decorators, [])

fn parse_function_with_attrs(self, decorators: [Decorator], attributes: [Attribute]) -> Result<Node, ParseError>:
    val start_span = self.current.span

    # Accept fn, me (mutable method), gen (generator), kernel
    var is_generator = false
    val is_me_method = if self.check(TokenKind.Me):
        self.advance()
        if self.check(TokenKind.Fn):
            self.advance()
        true
    elif self.check(TokenKind.Gen):
        is_generator = true
        self.advance()
        false
    elif self.check(TokenKind.Kernel):
        self.advance()
        false
    else:
        self.expect(TokenKind.Fn)
        false

    val name = self.expect_method_name()
    val generic_params = self.parse_generic_params_as_strings()
    val params = self.parse_parameters()

    val return_type = if self.check(TokenKind.Arrow):
        self.advance()
        Some(self.parse_type())
    else:
        nil

    val return_constraint = self.parse_return_constraint()
    val where_clause = self.parse_where_clause()
    self.skip_newlines()

    # Abstract: semicolon or no colon
    val is_abstract = if self.check(TokenKind.Semicolon):
        self.advance()
        true
    elif not self.check(TokenKind.Colon):
        true
    else:
        false

    val (body, contract, bounds_block) = if is_abstract:
        (Block.default(), nil, nil)
    else:
        self.expect(TokenKind.Colon)
        if self.check(TokenKind.Newline):
            self.expect(TokenKind.Newline)
            self.expect(TokenKind.Indent)

            val contract = if self.check(TokenKind.In) or self.check(TokenKind.Invariant) or self.check(TokenKind.Out) or self.check(TokenKind.OutErr) or self.check(TokenKind.Requires) or self.check(TokenKind.Ensures) or self.check(TokenKind.Decreases):
                self.parse_contract_block()
            else:
                nil

            val body = self.parse_block_body()

            val has_simd = decorators.any(\d: match d.name:
                Expr.Identifier(n): n == "simd"
                _: false)
            val bounds_block = if has_simd:
                self.skip_newlines()
                self.parse_bounds_block()
            else:
                nil

            (body, contract, bounds_block)
        else:
            # Single-line: fn name(): expr
            val expr_start = self.current.span
            val expr = self.parse_expression()
            val expr_end = self.previous.span
            val body = Block(
                span: Span(expr_start.start, expr_end.end, expr_start.line, expr_start.column),
                statements: [Node.Expression(expr)],
            )
            (body, nil, nil)

    # Effect inference: suspension in body â†’ async
    val inferred_effects = if not is_abstract and self.has_suspension_in_body(body):
        [Effect.Async]
    else:
        []

    Ok(Node.Function(FunctionDef(
        span: self.make_span(start_span),
        name: name,
        generic_params: generic_params,
        params: params,
        return_type: return_type,
        where_clause: where_clause,
        body: body,
        visibility: Visibility.Private,
        effects: inferred_effects,
        decorators: decorators,
        attributes: attributes,
        doc_comment: nil,
        contract: contract,
        is_abstract: is_abstract,
        is_sync: false,
        is_static: false,
        is_me_method: is_me_method,
        is_generator: is_generator,
        bounds_block: bounds_block,
        return_constraint: return_constraint,
        is_generic_template: not generic_params.is_empty(),
        specialization_of: nil,
        type_bindings: {},
    )))

# ============================================================================
# Return Constraints
# ============================================================================

# Parse optional return constraint: where result.len() == x.len()
fn parse_return_constraint(self) -> Option<Expr>:
    if not self.check(TokenKind.Where):
        return nil

    val saved_current = self.current
    val saved_previous = self.previous
    self.advance()  # consume 'where'

    val is_return_constraint = self.check_ident("result")

    if is_return_constraint:
        Some(self.parse_expression())
    else:
        # Restore state for where clause parsing
        self.pending_tokens.push_front(self.current)
        self.current = saved_current
        self.previous = saved_previous
        nil

# ============================================================================
# Literal Functions
# ============================================================================

# Parse literal function: literal fn _suffix(s: text) -> Type: body
fn parse_literal_function(self) -> Result<Node, ParseError>:
    val start_span = self.current.span
    self.expect(TokenKind.Literal)
    self.expect(TokenKind.Fn)

    val suffix_token = self.expect_identifier()
    if not suffix_token.starts_with("_"):
        return Err(ParseError.syntax_error_with_span(
            "Literal function name must start with underscore",
            self.previous.span))

    val suffix = suffix_token[1:]

    self.expect(TokenKind.LParen)
    val param_name = self.expect_identifier()
    self.expect(TokenKind.Colon)
    val param_type = self.parse_type()
    self.expect(TokenKind.RParen)

    val return_type = if self.check(TokenKind.Arrow):
        self.advance()
        Some(self.parse_type())
    else:
        nil

    self.expect(TokenKind.Colon)

    val body = if self.check(TokenKind.Newline):
        self.expect(TokenKind.Newline)
        self.expect(TokenKind.Indent)
        self.parse_block_body()
    else:
        val expr_start = self.current.span
        val expr = self.parse_expression()
        val expr_end = self.previous.span
        Block(
            span: Span(expr_start.start, expr_end.end, expr_start.line, expr_start.column),
            statements: [Node.Expression(expr)],
        )

    Ok(Node.LiteralFunction(LiteralFunctionDef(
        span: self.make_span(start_span),
        suffix: suffix,
        param_name: param_name,
        return_type: return_type,
        body: body,
        doc_comment: nil,
    )))

# ============================================================================
# Decorated Functions
# ============================================================================

# Parse decorated function: @decorator fn foo()
fn parse_decorated_function(self) -> Result<Node, ParseError>:
    var decorators = []
    var effects = []
    var impl_attributes = []

    while self.check(TokenKind.At):
        val decorator = self.parse_decorator()

        match decorator.name:
            Expr.Identifier(name):
                val effect = Effect.from_decorator_name(name)
                if effect.?:
                    effects.append(effect.unwrap())
                    self.skip_newlines()
                    continue
                if name == "default":
                    impl_attributes.append(Attribute(
                        span: decorator.span,
                        name: "default",
                        value: nil,
                        args: nil,
                    ))
                    self.skip_newlines()
                    continue
            _: ()

        decorators.append(decorator)
        self.skip_newlines()

    # @default before impl
    if self.check(TokenKind.Impl) and not impl_attributes.is_empty():
        return self.parse_impl_with_attrs(impl_attributes)

    val _is_pub = if self.check(TokenKind.Pub):
        self.advance()
        true
    else:
        false

    var node = self.parse_function_with_decorators(decorators)
    match node:
        Node.Function(f): f.effects = effects
    node

# ============================================================================
# Aliases
# ============================================================================

# Parse class alias: alias NewName = OldName
fn parse_class_alias(self) -> Result<Node, ParseError>:
    self.parse_class_alias_with_decorators([])

fn parse_class_alias_with_decorators(self, decorators: [Decorator]) -> Result<Node, ParseError>:
    val start_span = self.current.span
    self.expect(TokenKind.Alias)
    val name = self.expect_identifier()
    self.expect(TokenKind.Assign)
    val target = self.expect_identifier()

    Ok(Node.ClassAlias(ClassAliasDef(
        span: self.make_span(start_span),
        name: name,
        target: target,
        visibility: Visibility.Private,
        decorators: decorators,
        doc_comment: nil,
    )))

# Parse function alias: fn new_name = old_name
fn parse_function_alias(self) -> Result<Node, ParseError>:
    self.parse_function_alias_with_decorators([])

fn parse_function_alias_with_decorators(self, decorators: [Decorator]) -> Result<Node, ParseError>:
    val start_span = self.current.span
    self.expect(TokenKind.Fn)
    val name = self.expect_identifier()
    self.expect(TokenKind.Assign)
    val target = self.expect_identifier()

    Ok(Node.FunctionAlias(FunctionAliasDef(
        span: self.make_span(start_span),
        name: name,
        target: target,
        visibility: Visibility.Private,
        decorators: decorators,
        doc_comment: nil,
    )))
