# Definition Parser
#
# Parsing for type definitions: struct, class, enum, union, trait, impl, mixin,
# actor, aliases, functions, literal functions, and associated types.
# Port of rust/parser/src/parser_impl/definitions.rs + types_def/ + functions.rs

from token import {Span, Token, TokenKind}
from ast import {Node, FunctionDef, StructDef, ClassDef, EnumDef, EnumVariant,
                 EnumField, TraitDef, ImplBlock, MixinDef, ActorDef,
                 TypeAliasDef, Field, ClassAliasDef, FunctionAliasDef,
                 LiteralFunctionDef, InterfaceBinding,
                 AssociatedTypeDef, AssociatedTypeImpl,
                 MixinRef, RequiredMethodSig, MacroInvocation, InvariantBlock,
                 Parameter, Block, Expr, Type, Pattern, WhereClause, WhereBound,
                 Decorator, Attribute, DocComment, Effect,
                 Visibility, Mutability}
from error import {ParseError}

export DefinitionParser

# ============================================================================
# Helper: constructor name detection
# ============================================================================

fn is_constructor_name(name: String) -> Bool:
    name == "new" or name == "create" or name == "default" or name == "init" or name.starts_with("from_")

# ============================================================================
# Struct
# ============================================================================

# Parse struct definition: struct Name<T>: fields...
fn parse_struct(self) -> Result<Node, ParseError>:
    self.parse_struct_with_attrs([])

fn parse_struct_with_attrs(self, attributes: [Attribute]) -> Result<Node, ParseError>:
    val start_span = self.current.span
    self.expect(TokenKind.Struct)
    val name = self.expect_identifier()
    val generic_params = self.parse_generic_params_as_strings()

    # Optional trait implementation syntax: struct Name(Trait):
    val implements_trait = if self.check(TokenKind.LParen):
        self.advance()
        val trait_name = self.expect_identifier()
        self.expect(TokenKind.RParen)
        Some(trait_name)
    else:
        None

    val where_clause = self.parse_where_clause()

    # Empty struct (no body) or indented fields/methods
    val (fields, methods, invariant, doc_comment) = if self.check(TokenKind.Newline) or self.is_at_end():
        ([], [], None, None)
    else:
        self.parse_indented_fields_and_methods()

    Ok(Node.Struct(StructDef(
        span: self.make_span(start_span),
        name: name,
        generic_params: generic_params,
        where_clause: where_clause,
        fields: fields,
        methods: methods,
        visibility: Visibility.Private,
        attributes: attributes,
        doc_comment: doc_comment,
        invariant: invariant,
        is_generic_template: not generic_params.is_empty(),
        specialization_of: None,
        type_bindings: {},
    )))

# Parse struct with leading doc comment
fn parse_struct_with_doc(self, doc_comment: Option<DocComment>) -> Result<Node, ParseError>:
    var node = self.parse_struct()
    match node:
        Ok(Node.Struct(s)):
            s.doc_comment = doc_comment ?? s.doc_comment
    node

# ============================================================================
# Class
# ============================================================================

fn parse_class(self) -> Result<Node, ParseError>:
    self.parse_class_with_attrs([])

fn parse_class_with_attrs(self, attributes: [Attribute]) -> Result<Node, ParseError>:
    val start_span = self.current.span
    self.expect(TokenKind.Class)
    val name = self.expect_identifier()
    val generic_params = self.parse_generic_params_as_strings()

    # Inheritance: class Child(Parent) or class Child extends Parent
    val parent = if self.check(TokenKind.LParen):
        self.advance()
        val p = self.expect_identifier()
        self.expect(TokenKind.RParen)
        Some(p)
    elif self.check(TokenKind.Extends):
        self.advance()
        Some(self.expect_identifier())
    else:
        None

    # Mixin application: class Name with Mixin1, Mixin2<T>:
    var explicit_mixins = []
    if self.check(TokenKind.With):
        self.advance()
        loop:
            val mixin_name = self.expect_identifier()
            val type_args = if self.check(TokenKind.Lt):
                self.parse_generic_args()
            else:
                []
            explicit_mixins.append(MixinRef(
                span: self.current.span,
                name: mixin_name,
                type_args: type_args,
                overrides: [],
            ))
            if not self.check(TokenKind.Comma):
                break
            self.advance()

    val where_clause = self.parse_where_clause()

    val (fields, methods, invariant, macro_invocations, mixins, doc_comment) =
        if self.check(TokenKind.Newline) or self.is_at_end():
            ([], [], None, [], [], None)
        else:
            self.parse_class_body()

    # Prepend explicit mixins from `with` clause
    var all_mixins = explicit_mixins.merge(mixins)

    Ok(Node.Class(ClassDef(
        span: self.make_span(start_span),
        name: name,
        generic_params: generic_params,
        where_clause: where_clause,
        fields: fields,
        methods: methods,
        parent: parent,
        visibility: Visibility.Private,
        effects: [],
        attributes: attributes,
        doc_comment: doc_comment,
        invariant: invariant,
        macro_invocations: macro_invocations,
        mixins: all_mixins,
        is_generic_template: not generic_params.is_empty(),
        specialization_of: None,
        type_bindings: {},
    )))

fn parse_class_with_doc(self, doc_comment: Option<DocComment>) -> Result<Node, ParseError>:
    var node = self.parse_class()
    match node:
        Ok(Node.Class(c)):
            c.doc_comment = doc_comment ?? c.doc_comment
    node

# ============================================================================
# Mixin
# ============================================================================

fn parse_mixin(self) -> Result<Node, ParseError>:
    val start_span = self.current.span
    self.expect(TokenKind.Mixin)
    val name = self.expect_identifier()
    val generic_params = self.parse_generic_params_as_strings()

    # Optional requires clause
    val (required_traits, required_mixins) = if self.check(TokenKind.Requires):
        self.advance()
        self.parse_mixin_requirements()
    else:
        ([], [])

    val _where_clause = self.parse_where_clause()
    val (fields, methods, _invariant, _macro_invocations, inner_mixins, doc_comment) = self.parse_class_body()

    # Merge use declarations from body into required_mixins
    var all_required_mixins = required_mixins
    for mref in inner_mixins:
        if not all_required_mixins.contains(mref.name):
            all_required_mixins.append(mref.name)

    # Separate abstract methods from implemented ones
    val required_methods = methods
        .filter(\m: m.is_abstract)
        .map(\m: RequiredMethodSig(
            span: m.span,
            name: m.name,
            params: m.params,
            return_type: m.return_type,
        ))
    val impl_methods = methods.filter(\m: not m.is_abstract)

    Ok(Node.Mixin(MixinDef(
        span: self.make_span(start_span),
        name: name,
        generic_params: generic_params,
        required_traits: required_traits,
        required_mixins: all_required_mixins,
        fields: fields,
        methods: impl_methods,
        required_methods: required_methods,
        visibility: Visibility.Private,
        doc_comment: doc_comment,
    )))

fn parse_mixin_with_doc(self, doc_comment: Option<DocComment>) -> Result<Node, ParseError>:
    var node = self.parse_mixin()
    match node:
        Ok(Node.Mixin(m)):
            m.doc_comment = doc_comment ?? m.doc_comment
    node

fn parse_mixin_with_attrs(self, attributes: [Attribute]) -> Result<Node, ParseError>:
    self.parse_mixin()

# Parse mixin requirements: requires Trait1, mixin2
fn parse_mixin_requirements(self) -> ([String], [String]):
    var required_traits = []
    var required_mixins = []
    loop:
        val req = self.expect_identifier()
        # Heuristic: uppercase = trait, lowercase = mixin
        if req[0].is_uppercase():
            required_traits.append(req)
        else:
            required_mixins.append(req)
        if not self.check(TokenKind.Comma):
            break
        self.advance()
    (required_traits, required_mixins)

# ============================================================================
# Actor
# ============================================================================

fn parse_actor(self) -> Result<Node, ParseError>:
    val start_span = self.current.span
    self.expect(TokenKind.Actor)
    val name = self.expect_identifier()

    val (fields, methods, _invariant, _doc_comment) = self.parse_indented_fields_and_methods()

    Ok(Node.Actor(ActorDef(
        span: self.make_span(start_span),
        name: name,
        fields: fields,
        methods: methods,
        visibility: Visibility.Private,
    )))

# ============================================================================
# Enum
# ============================================================================

fn parse_enum(self) -> Result<Node, ParseError>:
    self.parse_enum_with_attrs([])

fn parse_enum_with_attrs(self, attributes: [Attribute]) -> Result<Node, ParseError>:
    val start_span = self.current.span
    self.expect(TokenKind.Enum)
    self.parse_enum_body(start_span, attributes)

# Parse enum body without consuming keyword (for `effect` alias)
fn parse_enum_body_after_keyword(self) -> Result<Node, ParseError>:
    val start_span = self.current.span
    self.parse_enum_body(start_span, [])

fn parse_enum_with_doc(self, doc_comment: Option<DocComment>) -> Result<Node, ParseError>:
    var node = self.parse_enum()
    match node:
        Ok(Node.Enum(e)):
            e.doc_comment = doc_comment ?? e.doc_comment
    node

# ============================================================================
# Union (alias for enum with data variants)
# ============================================================================

fn parse_union(self) -> Result<Node, ParseError>:
    self.parse_union_with_attrs([])

fn parse_union_with_attrs(self, attributes: [Attribute]) -> Result<Node, ParseError>:
    val start_span = self.current.span
    self.expect(TokenKind.Union)
    self.parse_enum_body(start_span, attributes)

fn parse_union_with_doc(self, doc_comment: Option<DocComment>) -> Result<Node, ParseError>:
    var node = self.parse_union()
    match node:
        Ok(Node.Enum(e)):
            e.doc_comment = doc_comment ?? e.doc_comment
    node

# Shared enum/union body parsing
fn parse_enum_body(self, start_span: Span, attributes: [Attribute]) -> Result<Node, ParseError>:
    val name = self.expect_identifier()
    val generic_params = self.parse_generic_params_as_strings()
    val where_clause = self.parse_where_clause()

    self.expect(TokenKind.Colon)
    self.expect(TokenKind.Newline)
    self.expect(TokenKind.Indent)

    # Optional docstring
    var doc_comment = None
    self.skip_newlines()
    match self.current.kind:
        TokenKind.String(content):
            doc_comment = Some(DocComment(content: content))
            self.advance()
            self.skip_newlines()
        TokenKind.FString(parts):
            val content = parts.filter_map(\p: match p:
                FStringToken.Literal(s): Some(s)
                _: None
            ).join("")
            doc_comment = Some(DocComment(content: content))
            self.advance()
            self.skip_newlines()
        _: ()

    val (variants, methods) = self.parse_enum_variants_and_methods()

    Ok(Node.Enum(EnumDef(
        span: self.make_span(start_span),
        name: name,
        generic_params: generic_params,
        where_clause: where_clause,
        variants: variants,
        methods: methods,
        visibility: Visibility.Private,
        attributes: attributes,
        doc_comment: doc_comment,
        is_generic_template: not generic_params.is_empty(),
        specialization_of: None,
        type_bindings: {},
    )))

# Parse enum variants and methods
fn parse_enum_variants_and_methods(self) -> ([EnumVariant], [FunctionDef]):
    var variants = []
    var methods = []

    while not self.check(TokenKind.Dedent) and not self.is_at_end():
        self.skip_newlines()
        if self.check(TokenKind.Dedent):
            break

        # Method definition
        if self.check(TokenKind.Fn) or self.check(TokenKind.Async) or self.check(TokenKind.At) or self.check(TokenKind.Hash) or (self.check(TokenKind.Pub) and (self.peek_is(TokenKind.Fn) or self.peek_is(TokenKind.Async))):
            val item = self.parse_item()
            match item:
                Node.Function(f): methods.append(f)
                _: self.error("Expected method definition in enum body")
        else:
            # Variant(s) — may be comma-separated on same line
            variants.append(self.parse_enum_variant())
            while self.check(TokenKind.Comma):
                self.advance()
                if self.check(TokenKind.Newline) or self.check(TokenKind.Indent) or self.check(TokenKind.Dedent) or self.is_at_end():
                    break
                variants.append(self.parse_enum_variant())

    self.consume_dedent()
    (variants, methods)

# Parse single enum variant
fn parse_enum_variant(self) -> EnumVariant:
    val start_span = self.current.span
    val name = self.expect_identifier()

    val fields = if self.check(TokenKind.LParen):
        Some(self.parse_enum_field_list())
    elif self.check(TokenKind.LBrace):
        Some(self.parse_enum_struct_fields())
    else:
        None

    # Optional discriminant: Variant = 0
    val discriminant = if self.check(TokenKind.Assign):
        self.advance()
        Some(self.parse_expression())
    else:
        None

    EnumVariant(
        span: self.make_span(start_span),
        name: name,
        fields: fields,
        discriminant: discriminant,
    )

# Parse struct-style enum fields: { name1: Type1, name2: Type2 }
fn parse_enum_struct_fields(self) -> [EnumField]:
    self.expect(TokenKind.LBrace)
    var fields = []
    self.skip_newlines()

    while not self.check(TokenKind.RBrace):
        val field_name = self.expect_identifier()
        self.expect(TokenKind.Colon)
        val field_type = self.parse_type()
        fields.append(EnumField(name: Some(field_name), ty: field_type))

        if self.check(TokenKind.Comma):
            self.advance()
            self.skip_newlines()
        elif self.check(TokenKind.Newline):
            self.skip_newlines()

    self.expect(TokenKind.RBrace)
    fields

# Parse enum field list: (Type1, Type2) or (name1: Type1, name2: Type2)
fn parse_enum_field_list(self) -> [EnumField]:
    self.expect(TokenKind.LParen)
    var fields = []
    self.skip_newlines()

    while not self.check(TokenKind.RParen):
        # Try named field: check if identifier followed by colon
        val maybe_name = self.try_get_field_name()

        val field = if maybe_name.? and self.peek_after_name_is_colon():
            val name = self.expect_field_name()
            self.advance()  # consume colon
            val ty = self.parse_type()
            EnumField(name: Some(name), ty: ty)
        else:
            val ty = self.parse_type()
            EnumField(name: None, ty: ty)

        fields.append(field)
        self.skip_newlines()

        if self.check(TokenKind.Comma):
            self.advance()
            self.skip_newlines()
        elif not self.check(TokenKind.RParen):
            self.error("expected comma or closing paren")

    self.expect(TokenKind.RParen)
    fields

# Helper: check if current is an identifier/keyword usable as field name
fn try_get_field_name(self) -> Option<String>:
    match self.current.kind:
        TokenKind.Identifier(name, _): Some(name)
        TokenKind.Type: Some("type")
        TokenKind.Default: Some("default")
        TokenKind.Result: Some("result")
        TokenKind.Bounds: Some("bounds")
        TokenKind.Alias: Some("alias")
        TokenKind.From: Some("from")
        TokenKind.To: Some("to")
        TokenKind.In: Some("in")
        TokenKind.Is: Some("is")
        TokenKind.As: Some("as")
        TokenKind.Match: Some("match")
        TokenKind.Use: Some("use")
        TokenKind.Unit: Some("unit")
        TokenKind.Out: Some("out")
        TokenKind.OutErr: Some("out_err")
        _: None

# Helper: check if after current identifier token the next is colon (for named fields)
fn peek_after_name_is_colon(self) -> Bool:
    # Save, advance, check, restore
    val saved = self.current
    self.advance()
    val result = self.check(TokenKind.Colon)
    self.pending_tokens.push_front(self.current)
    self.current = saved
    result

# Helper: consume a field name (identifier or keyword-as-name)
fn expect_field_name(self) -> String:
    val name = match self.current.kind:
        TokenKind.Identifier(n, _): n
        TokenKind.Type: "type"
        TokenKind.Default: "default"
        TokenKind.Result: "result"
        TokenKind.Bounds: "bounds"
        TokenKind.Alias: "alias"
        TokenKind.From: "from"
        TokenKind.To: "to"
        TokenKind.In: "in"
        TokenKind.Is: "is"
        TokenKind.As: "as"
        TokenKind.Match: "match"
        TokenKind.Use: "use"
        TokenKind.Unit: "unit"
        TokenKind.Out: "out"
        TokenKind.OutErr: "out_err"
        _: self.error("expected field name")
    self.advance()
    name

# ============================================================================
# Trait
# ============================================================================

fn parse_trait(self) -> Result<Node, ParseError>:
    val start_span = self.current.span
    self.expect(TokenKind.Trait)
    val name = self.expect_identifier()
    val generic_params = self.parse_generic_params_as_strings()

    # Parse super traits: trait Copy: Clone or trait T: A + B<T>
    var super_traits = []
    if self.check(TokenKind.Colon):
        val colon_span = self.current.span
        self.advance()  # consume :

        if self.is_identifier():
            # Super trait syntax
            super_traits.append(self.parse_type())
            while self.check(TokenKind.Plus):
                self.advance()
                super_traits.append(self.parse_type())
        else:
            # Not super trait — put colon back for body parser
            val colon_token = Token(TokenKind.Colon, colon_span, ":")
            self.pending_tokens.push_front(self.current)
            self.current = colon_token

    val where_clause = self.parse_where_clause()
    val (associated_types, methods) = self.parse_indented_trait_body()

    Ok(Node.Trait(TraitDef(
        span: self.make_span(start_span),
        name: name,
        generic_params: generic_params,
        super_traits: super_traits,
        where_clause: where_clause,
        associated_types: associated_types,
        methods: methods,
        visibility: Visibility.Private,
        doc_comment: None,
        is_generic_template: not generic_params.is_empty(),
        specialization_of: None,
        type_bindings: {},
    )))

fn parse_trait_with_doc(self, doc_comment: Option<DocComment>) -> Result<Node, ParseError>:
    var node = self.parse_trait()
    match node:
        Ok(Node.Trait(t)):
            t.doc_comment = doc_comment
    node

# Parse trait body: associated types and methods
fn parse_indented_trait_body(self) -> ([AssociatedTypeDef], [FunctionDef]):
    self.expect_block_start()
    var associated_types = []
    var methods = []

    while not self.check(TokenKind.Dedent) and not self.is_at_end():
        self.skip_newlines()
        if self.check(TokenKind.Dedent):
            break

        # Skip standalone docstrings
        if self.check_string() or self.check_fstring():
            self.advance()
            self.skip_newlines()
            continue

        # Associated type: type Name or type Name: Bound or type Name = Default
        if self.check(TokenKind.Type):
            associated_types.append(self.parse_associated_type_def())
        else:
            # Parse optional decorators
            var decorators = []
            while self.check(TokenKind.At):
                decorators.append(self.parse_decorator())
                self.skip_newlines()

            val is_async = if self.check(TokenKind.Async):
                self.advance()
                true
            else:
                false

            val is_static = if self.check(TokenKind.Static):
                self.advance()
                true
            else:
                false

            # Handle 'me' (mutable method) keyword
            val is_me = if self.check(TokenKind.Me):
                self.advance()
                if self.check(TokenKind.Fn):
                    self.advance()
                true
            else:
                false

            var method = if is_me:
                self.parse_trait_method_after_fn()
            else:
                self.parse_trait_method()
            method.decorators = decorators
            method.is_static = is_static
            if is_async:
                method.effects.append(Effect.Async)
            methods.append(method)

    self.consume_dedent()
    (associated_types, methods)

# Parse trait method (abstract or with default body)
fn parse_trait_method(self) -> FunctionDef:
    self.expect(TokenKind.Fn)
    self.parse_trait_method_after_fn()

fn parse_trait_method_after_fn(self) -> FunctionDef:
    val start_span = self.current.span
    val name = self.expect_identifier()
    val generic_params = self.parse_generic_params_as_strings()
    val params = self.parse_parameters()

    val return_type = if self.check(TokenKind.Arrow):
        self.advance()
        Some(self.parse_type())
    else:
        None

    val where_clause = self.parse_where_clause()

    # Abstract (newline/dedent) vs default body (colon)
    val (body, is_abstract) = if self.check(TokenKind.Newline) or self.check(TokenKind.Dedent):
        if self.check(TokenKind.Newline):
            self.advance()
        (Block.default(), true)
    else:
        self.expect(TokenKind.Colon)
        (self.parse_block(), false)

    FunctionDef(
        span: self.make_span(start_span),
        name: name,
        generic_params: generic_params,
        params: params,
        return_type: return_type,
        where_clause: where_clause,
        body: body,
        visibility: Visibility.Private,
        effects: [],
        decorators: [],
        attributes: [],
        doc_comment: None,
        contract: None,
        is_abstract: is_abstract,
        is_sync: false,
        is_static: false,
        is_me_method: false,
        is_generator: false,
        bounds_block: None,
        return_constraint: None,
        is_generic_template: not generic_params.is_empty(),
        specialization_of: None,
        type_bindings: {},
    )

# Parse associated type definition in a trait: type Name or type Name: Bound
fn parse_associated_type_def(self) -> AssociatedTypeDef:
    val start_span = self.current.span
    self.expect(TokenKind.Type)
    val name = self.expect_identifier()

    # Optional bounds: type Item: Clone + Default
    val bounds = if self.check(TokenKind.Colon):
        self.advance()
        var b = []
        val bound_name = self.expect_identifier()
        # Skip generic args on bound
        if self.check(TokenKind.Lt):
            self.skip_generic_args()
        b.append(bound_name)
        while self.check(TokenKind.Plus):
            self.advance()
            val bn = self.expect_identifier()
            if self.check(TokenKind.Lt):
                self.skip_generic_args()
            b.append(bn)
        b
    else:
        []

    # Optional default: type Item = i64
    val default = if self.check(TokenKind.Assign):
        self.advance()
        Some(self.parse_type())
    else:
        None

    if self.check(TokenKind.Newline):
        self.advance()

    AssociatedTypeDef(
        span: self.make_span(start_span),
        name: name,
        bounds: bounds,
        default: default,
    )

# Helper: skip balanced generic args (for bounds)
fn skip_generic_args(self):
    var depth = 1
    self.advance()  # consume <
    while depth > 0 and not self.is_at_end():
        if self.check(TokenKind.Lt):
            depth = depth + 1
            self.advance()
        elif self.check(TokenKind.Gt):
            depth = depth - 1
            self.advance()
        elif self.check(TokenKind.ShiftRight):
            depth = depth - 2
            self.advance()
        else:
            self.advance()

# ============================================================================
# Impl
# ============================================================================

fn parse_impl(self) -> Result<Node, ParseError>:
    self.parse_impl_with_attrs([])

fn parse_impl_with_attrs(self, attributes: [Attribute]) -> Result<Node, ParseError>:
    val start_span = self.current.span
    self.expect(TokenKind.Impl)

    val generic_params = self.parse_generic_params_as_strings()
    val first_type = self.parse_type()

    val (trait_name, trait_type_params, target_type) = if self.check(TokenKind.For):
        self.advance()
        val target = self.parse_type()
        match first_type:
            Type.Simple(name): (Some(name), [], target)
            Type.Generic(name, args): (Some(name), args, target)
            _: self.error("expected simple trait name")
    else:
        (None, [], first_type)

    val where_clause = self.parse_where_clause()
    val (associated_types, methods) = self.parse_indented_impl_body()

    Ok(Node.Impl(ImplBlock(
        span: self.make_span(start_span),
        attributes: attributes,
        generic_params: generic_params,
        target_type: target_type,
        trait_name: trait_name,
        trait_type_params: trait_type_params,
        where_clause: where_clause,
        associated_types: associated_types,
        methods: methods,
    )))

# Parse impl body: associated type impls and methods (supports empty impl)
fn parse_indented_impl_body(self) -> ([AssociatedTypeImpl], [FunctionDef]):
    self.expect(TokenKind.Colon)

    if not self.check(TokenKind.Newline):
        self.error("expected newline after impl block colon")
    self.advance()

    # Empty impl: no indent after newline
    if not self.check(TokenKind.Indent):
        return ([], [])
    self.advance()

    var associated_types = []
    var methods = []

    while not self.check(TokenKind.Dedent) and not self.is_at_end():
        self.skip_newlines()
        if self.check(TokenKind.Dedent):
            break

        # Skip standalone docstrings
        if self.check_string() or self.check_fstring():
            self.advance()
            self.skip_newlines()
            continue

        # Associated type impl: type Item = i64
        if self.check(TokenKind.Type):
            associated_types.append(self.parse_associated_type_impl())
        else:
            # Parse optional decorators
            var decorators = []
            while self.check(TokenKind.At):
                decorators.append(self.parse_decorator())
                self.skip_newlines()

            val visibility = if self.check(TokenKind.Pub):
                self.advance()
                Visibility.Public
            else:
                Visibility.Private

            var is_static = if self.check(TokenKind.Static):
                self.advance()
                true
            else:
                false

            # Deprecated var fn syntax
            val is_var_fn = if self.check(TokenKind.Var) and self.peek_is(TokenKind.Fn):
                self.emit_deprecation_warning(
                    "Deprecated: `var fn` syntax",
                    "Replace `var fn method()` with `me method()`",
                    None,
                )
                self.advance()
                true
            else:
                false

            val item = if self.check(TokenKind.Async):
                self.parse_async_function()
            else:
                self.parse_function()

            match item:
                Node.Function(f):
                    f.visibility = visibility
                    if is_var_fn:
                        f.is_me_method = true
                    f.decorators = f.decorators.merge(decorators)

                    # Implicit static for constructor names
                    if not is_static and not f.is_me_method and is_constructor_name(f.name):
                        is_static = true

                    f.is_static = is_static

                    # Auto-inject self for instance methods
                    if not is_static and (f.params.is_empty() or f.params[0].name != "self"):
                        val self_param = Parameter(
                            span: f.span,
                            name: "self",
                            ty: None,
                            default: None,
                            mutability: Mutability.Immutable,
                            inject: false,
                            variadic: false,
                            call_site_label: None,
                        )
                        f.params.insert(0, self_param)
                    methods.append(f)
                _: ()

    self.consume_dedent()
    (associated_types, methods)

# Parse associated type impl: type Item = i64
fn parse_associated_type_impl(self) -> AssociatedTypeImpl:
    val start_span = self.current.span
    self.expect(TokenKind.Type)
    val name = self.expect_identifier()
    self.expect(TokenKind.Assign)
    val ty = self.parse_type()

    if self.check(TokenKind.Newline):
        self.advance()

    AssociatedTypeImpl(
        span: self.make_span(start_span),
        name: name,
        ty: ty,
    )

# ============================================================================
# Interface Binding (Static Polymorphism)
# ============================================================================

# Parse: bind Interface = ImplType
fn parse_interface_binding(self) -> Result<Node, ParseError>:
    val start_span = self.current.span
    self.expect(TokenKind.Bind)
    val interface_name = self.expect_identifier()
    self.expect(TokenKind.Assign)
    val impl_type = self.parse_type()

    Ok(Node.InterfaceBinding(InterfaceBinding(
        span: self.make_span(start_span),
        interface_name: interface_name,
        impl_type: impl_type,
        doc_comment: None,
    )))

# ============================================================================
# Aliases
# ============================================================================

# Parse class alias: alias NewName = OldName
fn parse_class_alias(self) -> Result<Node, ParseError>:
    self.parse_class_alias_with_decorators([])

fn parse_class_alias_with_decorators(self, decorators: [Decorator]) -> Result<Node, ParseError>:
    val start_span = self.current.span
    self.expect(TokenKind.Alias)
    val name = self.expect_identifier()
    self.expect(TokenKind.Assign)
    val target = self.expect_identifier()

    Ok(Node.ClassAlias(ClassAliasDef(
        span: self.make_span(start_span),
        name: name,
        target: target,
        visibility: Visibility.Private,
        decorators: decorators,
        doc_comment: None,
    )))

# Parse function alias: fn new_name = old_name
fn parse_function_alias(self) -> Result<Node, ParseError>:
    self.parse_function_alias_with_decorators([])

fn parse_function_alias_with_decorators(self, decorators: [Decorator]) -> Result<Node, ParseError>:
    val start_span = self.current.span
    self.expect(TokenKind.Fn)
    val name = self.expect_identifier()
    self.expect(TokenKind.Assign)
    val target = self.expect_identifier()

    Ok(Node.FunctionAlias(FunctionAliasDef(
        span: self.make_span(start_span),
        name: name,
        target: target,
        visibility: Visibility.Private,
        decorators: decorators,
        doc_comment: None,
    )))

# ============================================================================
# Functions
# ============================================================================

fn parse_async_function(self) -> Result<Node, ParseError>:
    self.advance()  # consume 'async'
    var func = self.parse_function()
    match func:
        Node.Function(f): f.effects.append(Effect.Async)
    func

fn parse_sync_function(self) -> Result<Node, ParseError>:
    self.advance()  # consume 'sync'
    var func = self.parse_function()
    match func:
        Node.Function(f):
            f.is_sync = true
            if self.has_suspension_in_body(f.body):
                return Err(ParseError.syntax_error_with_span(
                    "Suspension operators not allowed in sync functions",
                    f.span))
    func

fn parse_function(self) -> Result<Node, ParseError>:
    self.parse_function_with_decorators([])

fn parse_function_with_decorators(self, decorators: [Decorator]) -> Result<Node, ParseError>:
    self.parse_function_with_attrs(decorators, [])

fn parse_function_with_attrs(self, decorators: [Decorator], attributes: [Attribute]) -> Result<Node, ParseError>:
    val start_span = self.current.span

    # Accept fn, me (mutable method), gen (generator), kernel
    var is_generator = false
    val is_me_method = if self.check(TokenKind.Me):
        self.advance()
        if self.check(TokenKind.Fn):
            self.advance()
        true
    elif self.check(TokenKind.Gen):
        is_generator = true
        self.advance()
        false
    elif self.check(TokenKind.Kernel):
        self.advance()
        false
    else:
        self.expect(TokenKind.Fn)
        false

    val name = self.expect_method_name()
    val generic_params = self.parse_generic_params_as_strings()
    val params = self.parse_parameters()

    val return_type = if self.check(TokenKind.Arrow):
        self.advance()
        Some(self.parse_type())
    else:
        None

    val return_constraint = self.parse_return_constraint()
    val where_clause = self.parse_where_clause()
    self.skip_newlines()

    # Abstract: semicolon or no colon
    val is_abstract = if self.check(TokenKind.Semicolon):
        self.advance()
        true
    elif not self.check(TokenKind.Colon):
        true
    else:
        false

    val (body, contract, bounds_block) = if is_abstract:
        (Block.default(), None, None)
    else:
        self.expect(TokenKind.Colon)
        if self.check(TokenKind.Newline):
            self.expect(TokenKind.Newline)
            self.expect(TokenKind.Indent)

            val contract = if self.check(TokenKind.In) or self.check(TokenKind.Invariant) or self.check(TokenKind.Out) or self.check(TokenKind.OutErr) or self.check(TokenKind.Requires) or self.check(TokenKind.Ensures) or self.check(TokenKind.Decreases):
                self.parse_contract_block()
            else:
                None

            val body = self.parse_block_body()

            val has_simd = decorators.any(\d: match d.name:
                Expr.Identifier(n): n == "simd"
                _: false)
            val bounds_block = if has_simd:
                self.skip_newlines()
                self.parse_bounds_block()
            else:
                None

            (body, contract, bounds_block)
        else:
            # Single-line: fn name(): expr
            val expr_start = self.current.span
            val expr = self.parse_expression()
            val expr_end = self.previous.span
            val body = Block(
                span: Span(expr_start.start, expr_end.end, expr_start.line, expr_start.column),
                statements: [Node.Expression(expr)],
            )
            (body, None, None)

    # Effect inference: suspension in body → async
    val inferred_effects = if not is_abstract and self.has_suspension_in_body(body):
        [Effect.Async]
    else:
        []

    Ok(Node.Function(FunctionDef(
        span: self.make_span(start_span),
        name: name,
        generic_params: generic_params,
        params: params,
        return_type: return_type,
        where_clause: where_clause,
        body: body,
        visibility: Visibility.Private,
        effects: inferred_effects,
        decorators: decorators,
        attributes: attributes,
        doc_comment: None,
        contract: contract,
        is_abstract: is_abstract,
        is_sync: false,
        is_static: false,
        is_me_method: is_me_method,
        is_generator: is_generator,
        bounds_block: bounds_block,
        return_constraint: return_constraint,
        is_generic_template: not generic_params.is_empty(),
        specialization_of: None,
        type_bindings: {},
    )))

# Parse optional return constraint: where result.len() == x.len()
fn parse_return_constraint(self) -> Option<Expr>:
    if not self.check(TokenKind.Where):
        return None

    val saved_current = self.current
    val saved_previous = self.previous
    self.advance()  # consume 'where'

    val is_return_constraint = self.check_ident("result")

    if is_return_constraint:
        Some(self.parse_expression())
    else:
        # Restore state for where clause parsing
        self.pending_tokens.push_front(self.current)
        self.current = saved_current
        self.previous = saved_previous
        None

# Parse where clause: where T: Trait1 + Trait2, U: Other
fn parse_where_clause(self) -> WhereClause:
    if not self.check(TokenKind.Where):
        return []

    self.advance()
    var bounds = []

    loop:
        val span = self.current.span
        val type_param = self.expect_identifier()
        self.expect(TokenKind.Colon)

        var trait_bounds = []
        var negative_trait_bounds = []
        loop:
            val is_negative = if self.check(TokenKind.Bang):
                self.advance()
                true
            else:
                false

            val bound_type = self.parse_type()

            if is_negative:
                negative_trait_bounds.append(bound_type)
            else:
                trait_bounds.append(bound_type)

            if self.check(TokenKind.Plus):
                self.advance()
            else:
                break

        bounds.append(WhereBound(
            span: span,
            type_param: type_param,
            bounds: trait_bounds,
            negative_bounds: negative_trait_bounds,
        ))

        if self.check(TokenKind.Comma):
            self.advance()
        else:
            break

    bounds

# Parse literal function: literal fn _suffix(s: text) -> Type: body
fn parse_literal_function(self) -> Result<Node, ParseError>:
    val start_span = self.current.span
    self.expect(TokenKind.Literal)
    self.expect(TokenKind.Fn)

    val suffix_token = self.expect_identifier()
    if not suffix_token.starts_with("_"):
        return Err(ParseError.syntax_error_with_span(
            "Literal function name must start with underscore",
            self.previous.span))

    val suffix = suffix_token[1:]

    self.expect(TokenKind.LParen)
    val param_name = self.expect_identifier()
    self.expect(TokenKind.Colon)
    val param_type = self.parse_type()
    self.expect(TokenKind.RParen)

    val return_type = if self.check(TokenKind.Arrow):
        self.advance()
        Some(self.parse_type())
    else:
        None

    self.expect(TokenKind.Colon)

    val body = if self.check(TokenKind.Newline):
        self.expect(TokenKind.Newline)
        self.expect(TokenKind.Indent)
        self.parse_block_body()
    else:
        val expr_start = self.current.span
        val expr = self.parse_expression()
        val expr_end = self.previous.span
        Block(
            span: Span(expr_start.start, expr_end.end, expr_start.line, expr_start.column),
            statements: [Node.Expression(expr)],
        )

    Ok(Node.LiteralFunction(LiteralFunctionDef(
        span: self.make_span(start_span),
        suffix: suffix,
        param_name: param_name,
        return_type: return_type,
        body: body,
        doc_comment: None,
    )))

# Parse decorated function: @decorator fn foo()
fn parse_decorated_function(self) -> Result<Node, ParseError>:
    var decorators = []
    var effects = []
    var impl_attributes = []

    while self.check(TokenKind.At):
        val decorator = self.parse_decorator()

        match decorator.name:
            Expr.Identifier(name):
                val effect = Effect.from_decorator_name(name)
                if effect.?:
                    effects.append(effect.unwrap())
                    self.skip_newlines()
                    continue
                if name == "default":
                    impl_attributes.append(Attribute(
                        span: decorator.span,
                        name: "default",
                        value: None,
                        args: None,
                    ))
                    self.skip_newlines()
                    continue
            _: ()

        decorators.append(decorator)
        self.skip_newlines()

    # @default before impl
    if self.check(TokenKind.Impl) and not impl_attributes.is_empty():
        return self.parse_impl_with_attrs(impl_attributes)

    val _is_pub = if self.check(TokenKind.Pub):
        self.advance()
        true
    else:
        false

    var node = self.parse_function_with_decorators(decorators)
    match node:
        Node.Function(f): f.effects = effects
    node

# ============================================================================
# Field Parsing (shared by struct, class, actor)
# ============================================================================

fn parse_field(self) -> Field:
    val start_span = self.current.span

    val visibility = if self.check(TokenKind.Pub):
        self.advance()
        Visibility.Public
    else:
        Visibility.Private

    val mutability = if self.check(TokenKind.Mut):
        self.advance()
        Mutability.Mutable
    else:
        Mutability.Immutable

    val name = self.expect_identifier()
    self.expect(TokenKind.Colon)
    val ty = self.parse_type()

    val default = if self.check(TokenKind.Assign):
        self.advance()
        Some(self.parse_expression())
    else:
        None

    if self.check(TokenKind.Newline):
        self.advance()

    Field(
        span: self.make_span(start_span),
        name: name,
        ty: ty,
        default: default,
        mutability: mutability,
        visibility: visibility,
    )

# ============================================================================
# Body Parsing Helpers
# ============================================================================

fn make_span(self, start_span: Span) -> Span:
    Span(start_span.start, self.previous.span.end, start_span.line, start_span.column)

fn skip_newlines(self):
    while self.check(TokenKind.Newline):
        self.advance()

fn consume_dedent(self):
    if self.check(TokenKind.Dedent):
        self.advance()

fn expect_block_start(self):
    self.expect(TokenKind.Colon)
    self.expect(TokenKind.Newline)
    self.expect(TokenKind.Indent)

# Parse indented fields and methods (struct/actor body)
fn parse_indented_fields_and_methods(self) -> ([Field], [FunctionDef], Option<InvariantBlock>, Option<DocComment>):
    self.expect_block_start()
    var fields = []
    var methods = []
    var invariant = None
    var doc_comment = None

    # Optional docstring
    self.skip_newlines()
    doc_comment = self.try_parse_docstring()

    while not self.check(TokenKind.Dedent) and not self.is_at_end():
        self.skip_newlines()
        if self.check(TokenKind.Dedent):
            break

        if self.check(TokenKind.Invariant):
            if invariant.?:
                self.error("Multiple invariant blocks not allowed")
            invariant = self.parse_invariant_block()
        elif self.check(TokenKind.Var) and self.peek_is(TokenKind.Fn):
            # Deprecated var fn
            self.emit_deprecation_warning("Deprecated: `var fn` syntax",
                "Replace `var fn method()` with `me method()`", None)
            self.advance()
            val item = self.parse_item()
            match item:
                Node.Function(f):
                    f.is_me_method = true
                    self.inject_self_if_needed(f)
                    methods.append(f)
                _: ()
        elif self.is_method_start():
            val (f, is_static) = self.parse_body_method()
            f.is_static = is_static
            if not is_static and f.name != "new":
                self.inject_self_if_needed(f)
            methods.append(f)
        else:
            fields.append(self.parse_field())

    self.consume_dedent()
    (fields, methods, invariant, doc_comment)

# Parse class body: fields, methods, macros, mixins
fn parse_class_body(self) -> ([Field], [FunctionDef], Option<InvariantBlock>, [MacroInvocation], [MixinRef], Option<DocComment>):
    self.expect_block_start()
    var fields = []
    var methods = []
    var invariant = None
    var macro_invocations = []
    var mixins = []
    var doc_comment = None

    self.skip_newlines()
    doc_comment = self.try_parse_docstring()

    while not self.check(TokenKind.Dedent) and not self.is_at_end():
        self.skip_newlines()
        if self.check(TokenKind.Dedent):
            break

        if self.check(TokenKind.Invariant):
            if invariant.?:
                self.error("Multiple invariant blocks not allowed")
            invariant = self.parse_invariant_block()
        elif self.check(TokenKind.Use):
            # Mixin application: use MixinName
            self.advance()
            loop:
                val mixin_start = self.current.span
                val mixin_name = self.expect_identifier()
                val type_args = if self.check(TokenKind.Lt):
                    self.parse_generic_args()
                else:
                    []
                mixins.append(MixinRef(
                    span: self.make_span(mixin_start),
                    name: mixin_name,
                    type_args: type_args,
                    overrides: [],
                ))
                if not self.check(TokenKind.Comma):
                    break
                self.advance()
            self.skip_newlines()
        elif self.is_method_start_class():
            val (f, is_static) = self.parse_class_body_method()
            f.is_static = is_static
            if not is_static and f.name != "new":
                self.inject_self_if_needed(f)
            methods.append(f)
        elif self.is_macro_invocation_start():
            macro_invocations.append(self.parse_class_body_macro_invocation())
        elif self.check(TokenKind.Var) and self.peek_is(TokenKind.Fn):
            self.emit_deprecation_warning("Deprecated: `var fn` syntax",
                "Replace `var fn method()` with `me method()`", None)
            self.advance()
            val item = self.parse_item()
            match item:
                Node.Function(f):
                    f.is_me_method = true
                    self.inject_self_if_needed(f)
                    methods.append(f)
                _: ()
        else:
            fields.append(self.parse_field())

    self.consume_dedent()
    (fields, methods, invariant, macro_invocations, mixins, doc_comment)

# Helper: check if current position starts a method
fn is_method_start(self) -> Bool:
    self.check(TokenKind.Fn) or self.check(TokenKind.Me) or self.check(TokenKind.Async) or self.check(TokenKind.At) or self.check(TokenKind.Hash) or self.check(TokenKind.Static) or (self.check(TokenKind.Pub) and (self.peek_is(TokenKind.Fn) or self.peek_is(TokenKind.Async) or self.peek_is(TokenKind.Me)))

fn is_method_start_class(self) -> Bool:
    self.check(TokenKind.Fn) or self.check(TokenKind.Me) or self.check(TokenKind.Async) or self.check(TokenKind.At) or self.check(TokenKind.Hash) or self.check(TokenKind.Static) or (self.check(TokenKind.Pub) and (self.peek_is(TokenKind.Fn) or self.peek_is(TokenKind.Async) or self.peek_is(TokenKind.Me) or self.peek_is(TokenKind.Static)))

# Parse a method in struct/actor body, returns (FunctionDef, is_static)
fn parse_body_method(self) -> (FunctionDef, Bool):
    var decorators = []
    while self.check(TokenKind.At):
        decorators.append(self.parse_decorator())
        self.skip_newlines()

    val _is_pub = if self.check(TokenKind.Pub):
        self.advance()
        true
    else:
        false

    val is_static = if self.check(TokenKind.Static):
        self.advance()
        true
    else:
        false

    val item = if decorators.is_empty() and not _is_pub:
        self.parse_item()
    else:
        self.parse_function_with_decorators(decorators)

    match item:
        Node.Function(f): (f, is_static)
        _: self.error("Expected method definition")

# Parse a method in class body, returns (FunctionDef, is_static)
fn parse_class_body_method(self) -> (FunctionDef, Bool):
    var decorators = []
    while self.check(TokenKind.At):
        decorators.append(self.parse_decorator())
        self.skip_newlines()

    val _is_pub = if self.check(TokenKind.Pub):
        self.advance()
        true
    else:
        false

    val is_static = if self.check(TokenKind.Static):
        self.advance()
        true
    else:
        false

    # Handle static async
    val is_async_after_static = if is_static and self.check(TokenKind.Async):
        self.advance()
        true
    else:
        false

    var item = if decorators.is_empty() and not _is_pub and not is_static:
        self.parse_item()
    else:
        self.parse_function_with_decorators(decorators)

    if is_async_after_static:
        match item:
            Node.Function(f): f.effects.append(Effect.Async)
            _: ()

    match item:
        Node.Function(f): (f, is_static)
        _: self.error("Expected method definition in class body")

# Auto-inject self parameter for instance methods
fn inject_self_if_needed(self, f: mut FunctionDef):
    if f.params.is_empty() or f.params[0].name != "self":
        val self_param = Parameter(
            span: f.span,
            name: "self",
            ty: None,
            default: None,
            mutability: Mutability.Immutable,
            inject: false,
            variadic: false,
            call_site_label: None,
        )
        f.params.insert(0, self_param)

# Try to parse a docstring (first string after indent)
fn try_parse_docstring(self) -> Option<DocComment>:
    match self.current.kind:
        TokenKind.String(content):
            self.advance()
            self.skip_newlines()
            Some(DocComment(content: content))
        TokenKind.FString(parts):
            val content = parts.filter_map(\p: match p:
                FStringToken.Literal(s): Some(s)
                _: None
            ).join("")
            self.advance()
            self.skip_newlines()
            Some(DocComment(content: content))
        _: None

# Check if current position is at macro invocation (identifier followed by !)
fn is_macro_invocation_start(self) -> Bool:
    self.is_identifier() and self.peek_is(TokenKind.Bang)

# Parse macro invocation in class body: name!(args)
fn parse_class_body_macro_invocation(self) -> MacroInvocation:
    val start_span = self.current.span
    val name = self.expect_identifier()
    self.expect(TokenKind.Bang)
    val args = self.parse_macro_args()

    if self.check(TokenKind.Newline):
        self.advance()

    MacroInvocation(
        span: self.make_span(start_span),
        name: name,
        args: args,
    )

# Parse generic args: <T, U>
fn parse_generic_args(self) -> [Type]:
    self.expect(TokenKind.Lt)
    var args = []
    loop:
        args.append(self.parse_type())
        if not self.check(TokenKind.Comma):
            break
        self.advance()
    self.expect(TokenKind.Gt)
    args
