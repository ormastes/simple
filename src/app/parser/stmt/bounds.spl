# Statement Parser - Bounds Module
#
# Parsing for bounds blocks used with @simd kernels.
# Supports pattern matching with AND/OR composition for overflow/underflow detection.
# Extracted from statements.spl (Bounds section)

from token import {Span, Token, TokenKind}
from ast import {Node, Block,
                 BoundsBlock, BoundsCase, BoundsPattern, BoundsAtom, BoundsKind}
from error import {ParseError}

export BoundsParser

impl Parser:
    # Parse optional bounds: block after @simd function body
    fn parse_bounds_block(self) -> Option<BoundsBlock>:
        if not self.check(TokenKind.Bounds):
            return nil

        val start_span = self.current.span
        self.advance()
        self.expect(TokenKind.Colon)
        self.expect(TokenKind.Newline)
        self.expect(TokenKind.Indent)

        val cases = []
        while not self.check(TokenKind.Dedent) and not self.is_at_end():
            cases.append(self.parse_bounds_case())

        if self.check(TokenKind.Dedent):
            self.advance()

        Some(BoundsBlock(
            span: Span(start_span.start, self.previous.span.end, start_span.line, start_span.column),
            cases: cases,
        ))

    # Parse single bounds case: pattern: body
    fn parse_bounds_case(self) -> BoundsCase:
        val start_span = self.current.span
        val pattern = self.parse_bounds_pattern()
        self.expect(TokenKind.Colon)
        val body = self.parse_block()

        BoundsCase(
            span: Span(start_span.start, self.previous.span.end, start_span.line, start_span.column),
            pattern: pattern,
            body: body,
        )

    # Parse bounds pattern (with boolean composition)
    fn parse_bounds_pattern(self) -> BoundsPattern:
        self.parse_bounds_or()

    # Parse OR: pattern || pattern
    fn parse_bounds_or(self) -> BoundsPattern:
        var left = self.parse_bounds_and()
        while self.check(TokenKind.Or) or self.check(TokenKind.DoublePipe):
            self.advance()
            val right = self.parse_bounds_and()
            left = BoundsPattern.Or(left, right)
        left

    # Parse AND: pattern && pattern
    fn parse_bounds_and(self) -> BoundsPattern:
        var left = self.parse_bounds_primary()
        while self.check(TokenKind.And) or self.check(TokenKind.DoubleAmp):
            self.advance()
            val right = self.parse_bounds_primary()
            left = BoundsPattern.And(left, right)
        left

    # Parse primary: atom, parenthesized, or default
    fn parse_bounds_primary(self) -> BoundsPattern:
        # Default catch-all: _ (not followed by dot)
        if self.check(TokenKind.Underscore):
            if not self.peek_is(TokenKind.Dot):
                self.advance()
                return BoundsPattern.Default

        # Parenthesized
        if self.check(TokenKind.LParen):
            self.advance()
            val inner = self.parse_bounds_pattern()
            self.expect(TokenKind.RParen)
            return BoundsPattern.Paren(inner)

        # Atom: _.<variable>.<kind>
        self.parse_bounds_atom()

    # Parse bounds atom: _.<variable>.<kind>
    fn parse_bounds_atom(self) -> BoundsPattern:
        val start_span = self.current.span
        self.expect(TokenKind.Underscore)
        self.expect(TokenKind.Dot)
        val variable = self.expect_identifier()
        self.expect(TokenKind.Dot)

        val kind = if self.check_ident("over"):
            self.advance()
            BoundsKind.Over
        elif self.check_ident("under"):
            self.advance()
            BoundsKind.Under
        else:
            self.error("expected 'over' or 'under'")

        BoundsPattern.Atom(BoundsAtom(
            span: Span(start_span.start, self.previous.span.end, start_span.line, start_span.column),
            variable: variable,
            kind: kind,
        ))
