# Module System Parser
#
# Parsing for module system: use, import, from, export, mod, common, auto,
# requires capabilities, structured_export.
# Port of rust/parser/src/stmt_parsing/module_system.rs

use std.text.{NL}

from token import {Span, Token, TokenKind}
from ast import {Node, ModulePath, ImportTarget, ModDecl, UseStmt, MultiUse,
                 CommonUseStmt, ExportUseStmt, AutoImportStmt,
                 RequiresCapabilitiesStmt, Capability, PassStmt,
                 Visibility, Attribute}
from error import {ParseError}

export ModuleParser

# ============================================================================
# Module Path Parsing
# ============================================================================

# Parse module path: crate.sys.http.router
# Handles relative paths: .sibling, ..parent, ...grandparent
fn parse_module_path(self) -> Result<ModulePath, ParseError>:
    var segments = []

    # Handle single dot for same-directory imports: .definition
    if self.check(TokenKind.Dot):
        self.advance()
        segments.append(".")
        if not self.check(TokenKind.Newline) and not self.is_at_end() and not self.check(TokenKind.As):
            segments.append(self.expect_path_segment())
            while self.check(TokenKind.Dot) or self.check(TokenKind.DoubleColon):
                if self.check(TokenKind.DoubleColon):
                    self.emit_deprecation_warning(
                        "Deprecated: '::' in module paths",
                        "Use '.' instead of '::'",
                        "Example: use std.spec.* instead of use std::spec::*")
                self.advance()
                segments.append(self.expect_path_segment())
        return Ok(ModulePath.new(segments))

    # Handle double dot for parent directory imports: ..parent
    while self.check(TokenKind.DoubleDot):
        self.advance()
        segments.append("..")

    # If only DoubleDots and at statement boundary, done
    if not segments.is_empty():
        if self.check(TokenKind.As) or self.check(TokenKind.Newline) or self.is_at_end():
            return Ok(ModulePath.new(segments))

    # First segment (could be 'crate' keyword or identifier)
    if segments.is_empty():
        if self.check(TokenKind.Crate):
            self.advance()
            segments.append("crate")
        else:
            segments.append(self.expect_path_segment())
    else:
        segments.append(self.expect_path_segment())

    # Parse dot-separated segments (also accept :: with deprecation warning)
    while self.check(TokenKind.Dot) or self.check(TokenKind.DoubleColon):
        if self.check(TokenKind.DoubleColon):
            self.emit_deprecation_warning(
                "Deprecated: '::' in module paths",
                "Use '.' instead of '::'",
                "Example: use std.spec.* instead of use std::spec::*")
        self.advance()

        # Stop at glob: module.*
        if self.check(TokenKind.Star):
            break
        # Stop at group: module.{A, B}
        if self.check(TokenKind.LBrace):
            break

        segments.append(self.expect_path_segment())

    Ok(ModulePath.new(segments))

# ============================================================================
# Import Target Parsing
# ============================================================================

# Parse import target: single, alias, group, or glob
fn parse_import_target(self, last_segment: Option<String>) -> Result<ImportTarget, ParseError>:
    # Glob: *
    if self.check(TokenKind.Star):
        self.advance()
        return Ok(ImportTarget.Glob)

    # Group: {A, B, C}
    if self.check(TokenKind.LBrace):
        self.advance()
        var targets = []
        while not self.check(TokenKind.RBrace):
            val name = self.expect_path_segment()
            val target = if self.check(TokenKind.As):
                self.advance()
                val alias = self.expect_path_segment()
                ImportTarget.Aliased(name: name, alias: alias)
            else:
                ImportTarget.Single(name)
            targets.append(target)
            if not self.check(TokenKind.RBrace):
                self.expect(TokenKind.Comma)
        self.expect(TokenKind.RBrace)
        return Ok(ImportTarget.Group(targets))

    # Single item (already parsed as last segment)
    if last_segment.?:
        val name = last_segment.unwrap()
        if self.check(TokenKind.As):
            self.advance()
            val alias = self.expect_identifier()
            return Ok(ImportTarget.Aliased(name: name, alias: alias))
        return Ok(ImportTarget.Single(name))

    Err(ParseError.unexpected_token("import target", "{self.current.kind}", self.current.span))

# Parse path and target together (shared by use/import/export)
fn parse_use_path_and_target(self) -> (ModulePath, ImportTarget):
    # Bare * or {A, B} without module path
    if self.check(TokenKind.Star) or self.check(TokenKind.LBrace):
        val target = self.parse_import_target(nil)
        return (ModulePath.new([]), target)

    val path = self.parse_module_path()

    # Check for :: before { or * (deprecated)
    if self.check(TokenKind.DoubleColon):
        self.emit_deprecation_warning(
            "Deprecated: '::' in module paths",
            "Use '.' instead of '::'",
            "Example: use std.spec.* instead of use std::spec::*")
        self.advance()

    if self.check(TokenKind.Star) or self.check(TokenKind.LBrace):
        val target = self.parse_import_target(nil)
        (path, target)
    else:
        var segments = path.segments

        # Bare module import: use core â†’ import * from core
        if segments.len() == 1 and (self.check(TokenKind.Newline) or self.is_at_end()):
            return (path, ImportTarget.Glob)

        val last = segments.pop() ?? ""
        val target = self.parse_import_target(Some(last))
        (ModulePath.new(segments), target)

# ============================================================================
# Use Statement
# ============================================================================

# Parse use statement: use crate.module.Item
fn parse_use(self) -> Result<Node, ParseError>:
    val start_span = self.current.span
    self.expect(TokenKind.Use)

    # Check for type-only import: use type module.Item
    val is_type_only = if self.check(TokenKind.Type):
        self.advance()
        true
    else:
        false

    self.parse_use_or_import_body(start_span, is_type_only)

# ============================================================================
# Import Statement (deprecated, alias for use)
# ============================================================================

fn parse_import(self) -> Result<Node, ParseError>:
    val start_span = self.current.span

    self.emit_deprecation_warning(
        "Deprecated: 'import' keyword",
        "Use 'use' instead of 'import'",
        "Example: use std.spec.* instead of import std.spec")

    self.expect(TokenKind.Import)

    val is_type_only = if self.check(TokenKind.Type):
        self.advance()
        true
    else:
        false

    self.parse_use_or_import_body(start_span, is_type_only)

# ============================================================================
# From-Import (deprecated Python-style)
# ============================================================================

fn parse_from_import(self) -> Result<Node, ParseError>:
    val start_span = self.current.span

    self.emit_deprecation_warning(
        "Deprecated: 'from ... import' syntax",
        "Use 'use module.{...}' instead",
        "Example: use mmap.{File, open} instead of from mmap import {File, open}")

    self.expect(TokenKind.From)
    val path = self.parse_module_path()
    self.expect(TokenKind.Import)

    val target = if self.check(TokenKind.Star):
        self.advance()
        ImportTarget.Glob
    elif self.check(TokenKind.LBrace):
        self.advance()
        var items = []
        while not self.check(TokenKind.RBrace):
            val name = self.expect_path_segment()
            if self.check(TokenKind.As):
                self.advance()
                val alias = self.expect_path_segment()
                items.append(ImportTarget.Aliased(name: name, alias: alias))
            else:
                items.append(ImportTarget.Single(name))
            if not self.check(TokenKind.RBrace):
                self.expect(TokenKind.Comma)
        self.expect(TokenKind.RBrace)
        ImportTarget.Group(items)
    else:
        val name = self.expect_path_segment()
        if self.check(TokenKind.As):
            self.advance()
            val alias = self.expect_path_segment()
            ImportTarget.Aliased(name: name, alias: alias)
        else:
            ImportTarget.Single(name)

    val end_span = self.previous.span
    Ok(Node.UseStmt(UseStmt(
        span: Span(start_span.start, end_span.end, start_span.line, start_span.column),
        path: path,
        target: target,
        is_type_only: false,
    )))

# Common body for use/import statements
fn parse_use_or_import_body(self, start_span: Span, is_type_only: Bool) -> Result<Node, ParseError>:
    val (path, target) = self.parse_use_path_and_target()

    # Comma-separated imports: use a.B, c.D
    if self.check(TokenKind.Comma):
        var imports = [(path, target)]
        while self.check(TokenKind.Comma):
            self.advance()
            val (p, t) = self.parse_use_path_and_target()
            imports.append((p, t))
        Ok(Node.MultiUse(MultiUse(
            span: Span(start_span.start, self.previous.span.end, start_span.line, start_span.column),
            imports: imports,
            is_type_only: is_type_only,
        )))
    else:
        Ok(Node.UseStmt(UseStmt(
            span: Span(start_span.start, self.previous.span.end, start_span.line, start_span.column),
            path: path,
            target: target,
            is_type_only: is_type_only,
        )))

# ============================================================================
# Mod Declaration
# ============================================================================

# Parse mod declaration: mod name (external) or mod name: body (inline)
fn parse_mod(self, visibility: Visibility, attributes: [Attribute]) -> Result<Node, ParseError>:
    val start_span = self.current.span
    self.expect(TokenKind.Mod)
    val name = self.expect_identifier()

    val body = if self.check(TokenKind.Colon):
        self.advance()
        self.expect(TokenKind.Newline)
        self.expect(TokenKind.Indent)

        var items = []
        while not self.check(TokenKind.Dedent) and not self.is_at_end():
            while self.check(TokenKind.Newline):
                self.advance()
            if self.check(TokenKind.Dedent):
                break
            items.append(self.parse_item())
        if self.check(TokenKind.Dedent):
            self.advance()
        Some(items)
    else:
        nil

    Ok(Node.ModDecl(ModDecl(
        span: Span(start_span.start, self.previous.span.end, start_span.line, start_span.column),
        name: name,
        visibility: visibility,
        attributes: attributes,
        body: body,
    )))

# ============================================================================
# Common Use
# ============================================================================

fn parse_common_use(self) -> Result<Node, ParseError>:
    val start_span = self.current.span
    self.expect(TokenKind.Common)
    self.expect(TokenKind.Use)
    val (path, target) = self.parse_use_path_and_target()

    Ok(Node.CommonUseStmt(CommonUseStmt(
        span: Span(start_span.start, self.previous.span.end, start_span.line, start_span.column),
        path: path,
        target: target,
    )))

# ============================================================================
# Export Use
# ============================================================================

fn parse_export_use(self) -> Result<Node, ParseError>:
    val start_span = self.current.span
    self.expect(TokenKind.Export)

    # Style 1: export use X
    if self.check(TokenKind.Use):
        self.advance()
        val (path, target) = self.parse_use_path_and_target()

        if match target: ImportTarget.Glob: true; _: false:
            self.emit_deprecation_warning(
                "Avoid 'export use *' - exposes unnecessary interfaces",
                "Use explicit exports instead",
                "Example: export use module.{A, B, C} or export A, B from module")

        return Ok(Node.ExportUseStmt(ExportUseStmt(
            span: Span(start_span.start, self.previous.span.end, start_span.line, start_span.column),
            path: path,
            target: target,
        )))

    # export * from module
    if self.check(TokenKind.Star):
        self.advance()
        self.expect(TokenKind.From)
        val module_path = self.parse_module_path()
        return Ok(Node.ExportUseStmt(ExportUseStmt(
            span: Span(start_span.start, self.previous.span.end, start_span.line, start_span.column),
            path: module_path,
            target: ImportTarget.Glob,
        )))

    # export { X, Y, Z } from module (JS-style)
    if self.check(TokenKind.LBrace):
        self.advance()
        var items = []
        self.skip_newlines()
        while not self.check(TokenKind.RBrace):
            items.append(self.expect_path_segment())
            self.skip_newlines()
            if not self.check(TokenKind.RBrace):
                if self.check(TokenKind.Comma):
                    self.advance()
                    self.skip_newlines()
        self.expect(TokenKind.RBrace)
        self.expect(TokenKind.From)
        val module_path = self.parse_module_path()

        val targets = items.map({NL}ame: ImportTarget.Single(name))
        return Ok(Node.ExportUseStmt(ExportUseStmt(
            span: Span(start_span.start, self.previous.span.end, start_span.line, start_span.column),
            path: module_path,
            target: ImportTarget.Group(targets),
        )))

    # export X, Y from module OR export module.* OR export X, Y (bare)
    val first_item = self.expect_path_segment()

    # Check for dot (module path continuation): export module.* or export module.Item
    if self.check(TokenKind.Dot):
        var segments = [first_item]
        while self.check(TokenKind.Dot):
            self.advance()

            if self.check(TokenKind.Star):
                self.advance()
                self.emit_deprecation_warning(
                    "Consider explicit exports to avoid exposing internal APIs",
                    "Use 'export {A, B, C}' or 'export {A, B} from module' for better control",
                    "Glob exports (export module.*) are acceptable for submodule re-exports")
                return Ok(Node.ExportUseStmt(ExportUseStmt(
                    span: Span(start_span.start, self.previous.span.end, start_span.line, start_span.column),
                    path: ModulePath.new(segments),
                    target: ImportTarget.Glob,
                )))

            segments.append(self.expect_path_segment())

        if segments.len() >= 2:
            val last_item = segments.pop()
            val module_path = ModulePath.new(segments)
            var targets = [ImportTarget.Single(last_item)]

            while self.check(TokenKind.Comma):
                self.advance()
                val next_item = self.expect_path_segment()
                if self.check(TokenKind.Dot):
                    var skip_segs = [next_item]
                    while self.check(TokenKind.Dot):
                        self.advance()
                        skip_segs.append(self.expect_path_segment())
                    targets.append(ImportTarget.Single(skip_segs.pop()))
                else:
                    targets.append(ImportTarget.Single(next_item))

            val target = if targets.len() == 1:
                targets[0]
            else:
                ImportTarget.Group(targets)

            return Ok(Node.ExportUseStmt(ExportUseStmt(
                span: Span(start_span.start, self.previous.span.end, start_span.line, start_span.column),
                path: module_path,
                target: target,
            )))

        return Err(ParseError.syntax_error_with_span(
            "Expected '.*', '{...}', or specific item after module path in export",
            self.current.span))

    # Identifier list: export X, Y, Z or export X, Y from module
    var items = [first_item]
    while self.check(TokenKind.Comma):
        self.advance()
        items.append(self.expect_path_segment())

    if self.check(TokenKind.From):
        # export X, Y from module
        self.advance()
        val module_path = self.parse_module_path()
        val targets = items.map({NL}ame: ImportTarget.Single(name))
        Ok(Node.ExportUseStmt(ExportUseStmt(
            span: Span(start_span.start, self.previous.span.end, start_span.line, start_span.column),
            path: module_path,
            target: ImportTarget.Group(targets),
        )))
    else:
        # Bare export: export X, Y, Z
        val targets = items.map({NL}ame: ImportTarget.Single(name))
        Ok(Node.ExportUseStmt(ExportUseStmt(
            span: Span(start_span.start, self.previous.span.end, start_span.line, start_span.column),
            path: ModulePath.new([]),
            target: ImportTarget.Group(targets),
        )))

# ============================================================================
# Auto Import
# ============================================================================

fn parse_auto_import(self) -> Result<Node, ParseError>:
    val start_span = self.current.span
    self.expect(TokenKind.Auto)
    self.expect(TokenKind.Import)

    val path = self.parse_module_path()
    var segments = path.segments
    val macro_name = segments.pop() ?? ""

    Ok(Node.AutoImportStmt(AutoImportStmt(
        span: Span(start_span.start, self.previous.span.end, start_span.line, start_span.column),
        path: ModulePath.new(segments),
        macro_name: macro_name,
    )))

# ============================================================================
# Requires Capabilities
# ============================================================================

# Parse: requires [pure, io, net]
fn parse_requires_capabilities(self) -> Result<Node, ParseError>:
    val start_span = self.current.span
    self.expect(TokenKind.Requires)
    self.expect(TokenKind.LBracket)

    var capabilities = []
    if not self.check(TokenKind.RBracket):
        loop:
            val cap_name = self.expect_identifier()
            val capability = Capability.from_name(cap_name)
            if not capability.?:
                return Err(ParseError.syntax_error_with_span(
                    "unknown capability '{cap_name}'. Valid: pure, io, net, fs, unsafe, gc",
                    self.previous.span))
            capabilities.append(capability.unwrap())

            if self.check(TokenKind.Comma):
                self.advance()
                if self.check(TokenKind.RBracket):
                    break
            else:
                break

    self.expect(TokenKind.RBracket)

    Ok(Node.RequiresCapabilities(RequiresCapabilitiesStmt(
        span: Span(start_span.start, self.previous.span.end, start_span.line, start_span.column),
        capabilities: capabilities,
    )))

# ============================================================================
# Structured Export
# ============================================================================

# Parse structured_export: block (desugars to multiple ExportUseStmt)
fn parse_structured_export(self) -> Result<Node, ParseError>:
    val start_span = self.current.span
    self.expect(TokenKind.StructuredExport)
    self.expect(TokenKind.Colon)
    self.expect(TokenKind.Newline)
    self.expect(TokenKind.Indent)

    var entries = []
    while not self.check(TokenKind.Dedent) and not self.is_at_end():
        while self.check(TokenKind.Newline):
            self.advance()
        if self.check(TokenKind.Dedent) or self.is_at_end():
            break

        val (path, target) = self.parse_use_path_and_target()
        entries.append(Node.ExportUseStmt(ExportUseStmt(
            span: Span(start_span.start, self.previous.span.end, start_span.line, start_span.column),
            path: path,
            target: target,
        )))

        if self.check(TokenKind.Newline):
            self.advance()

    if self.check(TokenKind.Dedent):
        self.advance()

    if entries.is_empty():
        Ok(Node.Pass(PassStmt(span: start_span)))
    else:
        # Push remaining entries to pending_statements
        for entry in entries[1:]:
            self.pending_statements.append(entry)
        Ok(entries[0])

# ============================================================================
# Helper: expect_path_segment (allows keywords as path segments)
# ============================================================================

fn expect_path_segment(self) -> String:
    # Regular identifier
    if self.is_identifier():
        return self.expect_identifier()

    # Keywords allowed as path segments
    val name = match self.current.kind:
        TokenKind.Unit: "unit"
        TokenKind.Type: "type"
        TokenKind.As: "as"
        TokenKind.In: "in"
        TokenKind.Is: "is"
        TokenKind.Or: "or"
        TokenKind.And: "and"
        TokenKind.Not: "not"
        TokenKind.Mod: "mod"
        TokenKind.Use: "use"
        TokenKind.Match: "match"
        TokenKind.If: "if"
        TokenKind.Else: "else"
        TokenKind.For: "for"
        TokenKind.While: "while"
        TokenKind.Loop: "loop"
        TokenKind.Break: "break"
        TokenKind.Continue: "continue"
        TokenKind.Return: "return"
        TokenKind.Fn: "fn"
        TokenKind.Let: "let"
        TokenKind.Val: "val"
        TokenKind.Var: "var"
        TokenKind.Struct: "struct"
        TokenKind.Class: "class"
        TokenKind.Enum: "enum"
        TokenKind.Trait: "trait"
        TokenKind.Impl: "impl"
        TokenKind.Const: "const"
        TokenKind.Static: "static"
        TokenKind.Pub: "pub"
        TokenKind.Export: "export"
        TokenKind.Import: "import"
        TokenKind.From: "from"
        TokenKind.To: "to"
        TokenKind.Context: "context"
        TokenKind.Feature: "feature"
        TokenKind.Scenario: "scenario"
        TokenKind.Given: "given"
        TokenKind.When: "when"
        TokenKind.Then: "then"
        TokenKind.Common: "common"
        TokenKind.Mock: "mock"
        TokenKind.Bounds: "bounds"
        TokenKind.Default: "default"
        TokenKind.Alias: "alias"
        TokenKind.Result: "result"
        TokenKind.Out: "out"
        TokenKind.OutErr: "out_err"
        _: self.error("expected path segment")
    self.advance()
    name
