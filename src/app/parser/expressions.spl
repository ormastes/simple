# Expression Parser
#
# Pratt parser for expressions with precedence climbing.
# Port of rust/parser/src/expressions/ (all submodules)
#
# Precedence levels (low to high):
#   pipe (|>)  >  parallel (//)  >  or  >  and  >  equality  >
#   comparison  >  range  >  bitwise_or  >  bitwise_xor  >  bitwise_and  >
#   shift  >  matmul (@)  >  term (+-)  >  factor (*/)  >
#   power (**)  >  unary  >  postfix  >  primary

from token import {Span, Token, TokenKind, NamePattern, FStringToken}
from ast import {Expr, Node, BinOp, UnaryOp, Pattern, Type, Block,
                 Argument, LambdaParam, MacroArg, MoveMode, MatchArm,
                 FStringPart, TypeMeta, AssignOp, AssignmentStmt,
                 PointerKind, RangeBound, TensorMode, TensorSlice,
                 TensorSliceContent}
from error import {ParseError}

export ExpressionParser

# Extension methods for Parser (mixed into Parser via impl)

impl Parser:

    # =========================================================================
    # Core entry point
    # =========================================================================

    fn parse_expression() -> Expr:
        self.parse_pipe()

    fn parse_expression_or_assignment() -> Node:
        val expr = self.parse_expression()

        # Check for assignment operators
        val assign_op = match self.current.kind:
            TokenKind.Assign: AssignOp.Assign
            TokenKind.PlusAssign: AssignOp.AddAssign
            TokenKind.MinusAssign: AssignOp.SubAssign
            TokenKind.StarAssign: AssignOp.MulAssign
            TokenKind.SlashAssign: AssignOp.DivAssign
            TokenKind.PercentAssign: AssignOp.ModAssign
            TokenKind.TildeAssign: AssignOp.SuspendAssign
            TokenKind.TildePlusAssign: AssignOp.SuspendAddAssign
            TokenKind.TildeMinusAssign: AssignOp.SuspendSubAssign
            TokenKind.TildeStarAssign: AssignOp.SuspendMulAssign
            TokenKind.TildeSlashAssign: AssignOp.SuspendDivAssign
            _: None

        if assign_op.?:
            val span = self.current.span
            self.advance()
            var value = self.parse_expression()
            value = self.parse_with_no_paren_calls(value)
            Node.Assignment(AssignmentStmt(span: span, target: expr, op: assign_op, value: value))
        else:
            var result = self.parse_with_no_paren_calls(expr)
            result = self.parse_infix_keywords(result)
            Node.Expression(result)

    # =========================================================================
    # Helpers (core.rs)
    # =========================================================================

    fn make_call_expr(expr: Expr, args: [Argument]) -> Expr:
        match expr:
            Expr.FieldAccess(receiver, field):
                Expr.MethodCall(receiver: receiver, method: field, args: args)
            _:
                Expr.Call(callee: expr, args: args)

    fn make_slice_expr(receiver: Expr, start: Expr?, end: Expr?, step: Expr?) -> Expr:
        Expr.Slice(receiver: receiver, start: start, end: end, step: step)

    fn parse_optional_step() -> Expr?:
        if self.check(TokenKind.Colon):
            self.advance()
            if self.check(TokenKind.RBracket):
                None
            else:
                self.parse_expression()
        else:
            None

    fn parse_optional_expr_before_bracket() -> Expr?:
        if self.check(TokenKind.RBracket):
            None
        else:
            self.parse_expression()

    # =========================================================================
    # Binary operators with precedence climbing (binary.rs)
    # Expanding Rust macros into explicit methods
    # =========================================================================

    # Pipeline |> (lowest precedence)
    fn parse_pipe() -> Expr:
        var left = self.parse_parallel()
        while self.check(TokenKind.PipeForward):
            self.advance()
            val right = self.parse_parallel()
            left = Expr.Binary(op: BinOp.PipeForward, left: left, right: right)
        left

    # Parallel //
    fn parse_parallel() -> Expr:
        var left = self.parse_or()
        while self.check(TokenKind.Parallel):
            self.advance()
            val right = self.parse_or()
            left = Expr.Binary(op: BinOp.Parallel, left: left, right: right)
        left

    # Logical or (or, ||, or~)
    fn parse_or() -> Expr:
        var left = self.parse_and()
        loop:
            val op = match self.current.kind:
                TokenKind.Or: BinOp.Or
                TokenKind.DoublePipe: BinOp.Or
                TokenKind.OrSuspend: BinOp.OrSuspend
                _: break
            self.advance()
            val right = self.parse_and()
            left = Expr.Binary(op: op, left: left, right: right)
        left

    # Logical and (and, &&, and~)
    fn parse_and() -> Expr:
        var left = self.parse_equality()
        loop:
            val op = match self.current.kind:
                TokenKind.And: BinOp.And
                TokenKind.DoubleAmp: BinOp.And
                TokenKind.AndSuspend: BinOp.AndSuspend
                _: break
            self.advance()
            val right = self.parse_equality()
            left = Expr.Binary(op: op, left: left, right: right)
        left

    # Equality and membership (==, !=, is, in, not in)
    fn parse_equality() -> Expr:
        var left = self.parse_comparison()
        loop:
            val op = match self.current.kind:
                TokenKind.Eq: BinOp.Eq
                TokenKind.NotEq: BinOp.NotEq
                TokenKind.Is: BinOp.Is
                TokenKind.In: BinOp.In
                TokenKind.Not:
                    if self.peek_is(TokenKind.In):
                        self.advance()  # consume 'not'
                        BinOp.NotIn
                    else:
                        break
                _: break
            self.advance()
            val right = self.parse_comparison()
            left = Expr.Binary(op: op, left: left, right: right)
        left

    # Comparison with chaining: a < b < c -> (a < b) and (b < c)
    fn parse_comparison() -> Expr:
        val left = self.parse_range()

        val has_cmp = match self.current.kind:
            TokenKind.Lt: true
            TokenKind.Gt: true
            TokenKind.LtEq: true
            TokenKind.GtEq: true
            _: false

        if not has_cmp:
            return left

        var comparisons = []
        var prev_right = left

        loop:
            val op = match self.current.kind:
                TokenKind.Lt: BinOp.Lt
                TokenKind.Gt: BinOp.Gt
                TokenKind.LtEq: BinOp.LtEq
                TokenKind.GtEq: BinOp.GtEq
                _: break
            self.advance()
            val right = self.parse_range()
            comparisons.push(Expr.Binary(op: op, left: prev_right.clone(), right: right.clone()))
            prev_right = right

        if comparisons.len() == 1:
            return comparisons[0]

        var result = comparisons[0]
        for cmp in comparisons[1:]:
            result = Expr.Binary(op: BinOp.And, left: result, right: cmp)
        result

    # Range: a..b, a..=b, a.., ..b, ..
    fn parse_range() -> Expr:
        # Prefix range (..end or ..=end)
        if self.check(TokenKind.DoubleDotEq):
            self.advance()
            val end = if self.is_range_terminator(): None else: self.parse_bitwise_or()
            return Expr.Range(start: None, end: end, bound: RangeBound.Inclusive)

        if self.check(TokenKind.DoubleDot):
            self.advance()
            val end = if self.is_range_terminator(): None else: self.parse_bitwise_or()
            return Expr.Range(start: None, end: end, bound: RangeBound.Exclusive)

        val start = self.parse_bitwise_or()

        val bound = match self.current.kind:
            TokenKind.DoubleDotEq: RangeBound.Inclusive
            TokenKind.DoubleDot: RangeBound.Exclusive
            _: return start

        self.advance()
        val end = if self.is_range_terminator(): None else: self.parse_bitwise_or()
        Expr.Range(start: start, end: end, bound: bound)

    fn is_range_terminator() -> bool:
        match self.current.kind:
            TokenKind.RBracket: true
            TokenKind.RParen: true
            TokenKind.RBrace: true
            TokenKind.Comma: true
            TokenKind.Colon: true
            TokenKind.Semicolon: true
            TokenKind.Newline: true
            TokenKind.Dedent: true
            TokenKind.Eof: true
            _: false

    # Bitwise or |
    fn parse_bitwise_or() -> Expr:
        var left = self.parse_bitwise_xor()
        while self.check(TokenKind.Pipe):
            self.advance()
            val right = self.parse_bitwise_xor()
            left = Expr.Binary(op: BinOp.BitOr, left: left, right: right)
        left

    # Bitwise xor (xor keyword)
    fn parse_bitwise_xor() -> Expr:
        var left = self.parse_bitwise_and()
        while self.check(TokenKind.Xor):
            self.advance()
            val right = self.parse_bitwise_and()
            left = Expr.Binary(op: BinOp.BitXor, left: left, right: right)
        left

    # Bitwise and &
    fn parse_bitwise_and() -> Expr:
        var left = self.parse_shift()
        while self.check(TokenKind.Ampersand):
            self.advance()
            val right = self.parse_shift()
            left = Expr.Binary(op: BinOp.BitAnd, left: left, right: right)
        left

    # Shift <<, >>
    fn parse_shift() -> Expr:
        var left = self.parse_matmul()
        loop:
            val op = match self.current.kind:
                TokenKind.ShiftLeft: BinOp.ShiftLeft
                TokenKind.ShiftRight: BinOp.ShiftRight
                _: break
            self.advance()
            val right = self.parse_matmul()
            left = Expr.Binary(op: op, left: left, right: right)
        left

    # Matrix multiplication @
    fn parse_matmul() -> Expr:
        var left = self.parse_term()
        while self.check(TokenKind.At):
            self.advance()
            val right = self.parse_term()
            left = Expr.Binary(op: BinOp.MatMul, left: left, right: right)
        left

    # Term +, -
    fn parse_term() -> Expr:
        var left = self.parse_factor()
        loop:
            val op = match self.current.kind:
                TokenKind.Plus: BinOp.Add
                TokenKind.Minus: BinOp.Sub
                _: break
            self.advance()
            val right = self.parse_factor()
            left = Expr.Binary(op: op, left: left, right: right)
        left

    # Factor *, /, %
    fn parse_factor() -> Expr:
        var left = self.parse_power()
        loop:
            val op = match self.current.kind:
                TokenKind.Star: BinOp.Mul
                TokenKind.Slash: BinOp.Div
                TokenKind.Percent: BinOp.Mod
                _: break
            self.advance()
            val right = self.parse_power()
            left = Expr.Binary(op: op, left: left, right: right)
        left

    # Power ** (right-associative)
    fn parse_power() -> Expr:
        val left = self.parse_unary()
        if self.check(TokenKind.DoubleStar):
            self.advance()
            val right = self.parse_power()  # right-associative recursion
            Expr.Binary(op: BinOp.Pow, left: left, right: right)
        else:
            left

    # =========================================================================
    # Unary operators (binary.rs)
    # =========================================================================

    fn parse_unary() -> Expr:
        match self.current.kind:
            TokenKind.Minus:
                self.advance()
                val operand = self.parse_unary()
                Expr.Unary(op: UnaryOp.Neg, operand: operand)
            TokenKind.Not:
                self.advance()
                val operand = self.parse_unary()
                Expr.Unary(op: UnaryOp.Not, operand: operand)
            TokenKind.Tilde:
                self.advance()
                val operand = self.parse_unary()
                Expr.Unary(op: UnaryOp.BitNot, operand: operand)
            TokenKind.Ampersand:
                self.advance()
                if self.check(TokenKind.Mut):
                    self.advance()
                    val operand = self.parse_unary()
                    Expr.Unary(op: UnaryOp.RefMut, operand: operand)
                else:
                    val operand = self.parse_unary()
                    Expr.Unary(op: UnaryOp.Ref, operand: operand)
            TokenKind.Star:
                self.advance()
                val operand = self.parse_unary()
                Expr.Unary(op: UnaryOp.Deref, operand: operand)
            TokenKind.ChannelArrow:
                self.advance()
                val operand = self.parse_unary()
                Expr.Unary(op: UnaryOp.ChannelRecv, operand: operand)
            TokenKind.Move:
                self.advance()
                val operand = self.parse_unary()
                Expr.Unary(op: UnaryOp.Move, operand: operand)
            TokenKind.Await:
                self.advance()
                val operand = self.parse_unary()
                Expr.Await(operand)
            TokenKind.Yield:
                self.advance()
                if self.is_at_end() or match self.current.kind:
                    TokenKind.Newline: true
                    TokenKind.Dedent: true
                    TokenKind.RParen: true
                    TokenKind.RBrace: true
                    TokenKind.Comma: true
                    _: false:
                    Expr.Yield(None)
                else:
                    val operand = self.parse_expression()
                    Expr.Yield(operand)
            _:
                self.parse_postfix()

    # =========================================================================
    # Postfix operators (postfix.rs)
    # =========================================================================

    fn expr_to_qualified_name(expr: Expr) -> text:
        match expr:
            Expr.Identifier(name): name
            Expr.FieldAccess(receiver, field):
                val receiver_name = self.expr_to_qualified_name(receiver)
                "{receiver_name}.{field}"
            _:
                raise ParseError.syntax_error_with_span(
                    "Expected qualified name", self.current.span)

    fn field_access_to_path_segments(expr: Expr) -> [text]:
        match expr:
            Expr.Identifier(name): [name]
            Expr.FieldAccess(receiver, field):
                var segments = self.field_access_to_path_segments(receiver)
                segments.push(field)
                segments
            _:
                raise ParseError.syntax_error_with_span(
                    "Expected path expression", self.current.span)

    fn is_type_path(expr: Expr) -> bool:
        match expr:
            Expr.Identifier(name): name[0].is_uppercase()
            _: false

    fn parse_postfix() -> Expr:
        var expr = self.parse_primary()
        var consumed_indents = 0

        loop:
            match self.current.kind:
                TokenKind.LParen:
                    expr = self.parse_call(expr)

                TokenKind.Bang:
                    # Macro invocation: name!(args)
                    match expr:
                        Expr.Identifier(name):
                            self.advance()
                            val args = self.parse_macro_args()
                            expr = Expr.MacroInvocation(name: name, args: args)
                        _: break

                TokenKind.LBracket:
                    # Only treat [ as indexing if adjacent (no whitespace)
                    if self.previous.span.end != self.current.span.start:
                        break
                    self.advance()

                    if self.check(TokenKind.DoubleColon):
                        # [::step]
                        self.advance()
                        val step = self.parse_optional_expr_before_bracket()
                        self.expect(TokenKind.RBracket)
                        expr = self.make_slice_expr(expr, None, None, step)
                    elif self.check(TokenKind.Colon):
                        # [:end:step]
                        self.advance()
                        if self.check(TokenKind.Colon):
                            self.advance()
                            val step = self.parse_optional_expr_before_bracket()
                            self.expect(TokenKind.RBracket)
                            expr = self.make_slice_expr(expr, None, None, step)
                        else:
                            val end = self.parse_optional_expr_before_bracket()
                            val step = self.parse_optional_step()
                            self.expect(TokenKind.RBracket)
                            expr = Expr.Slice(receiver: expr, start: None, end: end, step: step)
                    else:
                        val first = self.parse_expression()
                        if self.check(TokenKind.DoubleColon):
                            # [start::step]
                            self.advance()
                            val step = self.parse_optional_expr_before_bracket()
                            self.expect(TokenKind.RBracket)
                            expr = Expr.Slice(receiver: expr, start: first, end: None, step: step)
                        elif self.check(TokenKind.Colon) or match self.current.kind:
                            TokenKind.Symbol(_): true
                            _: false:
                            # Slice: [start:end:step]
                            val end = match self.current.kind:
                                TokenKind.Symbol(name):
                                    # Symbol like :name - convert back to identifier
                                    val sym_name = name
                                    val span = self.current.span
                                    self.advance()
                                    self.pending_tokens.push_front(self.current.clone())
                                    self.current = Token(kind: TokenKind.Identifier(name: sym_name, pattern: NamePattern.Immutable), lexeme: sym_name, span: span)
                                    self.parse_expression()
                                _:
                                    self.advance()  # consume colon
                                    if self.check(TokenKind.Colon) or self.check(TokenKind.RBracket):
                                        None
                                    else:
                                        self.parse_expression()
                            val step = self.parse_optional_step()
                            self.expect(TokenKind.RBracket)
                            expr = Expr.Slice(receiver: expr, start: first, end: end, step: step)
                        else:
                            # Regular index
                            self.expect(TokenKind.RBracket)
                            expr = Expr.Index(receiver: expr, index: first)

                TokenKind.Dot:
                    self.advance()
                    # Skip newlines/indents for multi-line chaining
                    while match self.current.kind:
                        TokenKind.Newline: true
                        TokenKind.Indent: true
                        _: false:
                        if match self.current.kind:
                            TokenKind.Indent: true
                            _: false:
                            consumed_indents = consumed_indents + 1
                        self.advance()

                    # Tuple element access: tuple.0
                    if match self.current.kind:
                        TokenKind.Integer(_): true
                        _: false:
                        val index = match self.current.kind:
                            TokenKind.Integer(n): n
                            _: 0
                        self.advance()
                        expr = Expr.TupleIndex(receiver: expr, index: index)
                    else:
                        val field = self.expect_method_name()
                        if self.check(TokenKind.LParen):
                            var args = self.parse_arguments()
                            if self.check(TokenKind.Backslash):
                                val trailing = self.parse_trailing_lambda()
                                args.push(Argument(name: None, value: trailing))
                            if self.is_type_path(expr):
                                var path_segments = self.field_access_to_path_segments(expr)
                                path_segments.push(field)
                                expr = Expr.Call(callee: Expr.Path(path_segments), args: args)
                            else:
                                expr = Expr.MethodCall(receiver: expr, method: field, args: args)
                        elif self.check(TokenKind.Backslash):
                            val trailing = self.parse_trailing_lambda()
                            expr = Expr.MethodCall(receiver: expr, method: field, args: [Argument(name: None, value: trailing)])
                        elif self.check(TokenKind.LBrace) and not self.no_brace_postfix and field[0].is_uppercase():
                            # Qualified struct init: module.StructName { ... }
                            val qualified_name = self.expr_to_qualified_name(expr)
                            val full_name = "{qualified_name}.{field}"
                            self.advance()  # consume '{'
                            self.skip_newlines()
                            var fields = []
                            while not self.check(TokenKind.RBrace):
                                val field_name = self.expect_identifier()
                                self.skip_newlines()
                                val value = if self.check(TokenKind.Colon):
                                    self.advance()
                                    self.skip_newlines()
                                    self.parse_expression()
                                else:
                                    Expr.Identifier(field_name)
                                self.skip_newlines()
                                fields.push((field_name, value))
                                if not self.check(TokenKind.RBrace):
                                    self.expect(TokenKind.Comma)
                                    self.skip_newlines()
                            self.expect(TokenKind.RBrace)
                            expr = Expr.StructInit(name: full_name, fields: fields)
                        elif self.check(TokenKind.LBrace) and not self.no_brace_postfix:
                            # Method call with dict arg: obj.method {...}
                            val dict_expr = self.parse_expression()
                            expr = Expr.MethodCall(receiver: expr, method: field, args: [Argument(name: None, value: dict_expr)])
                        else:
                            expr = Expr.FieldAccess(receiver: expr, field: field)

                        # Handle deprecated :: after field access
                        if self.check(TokenKind.DoubleColon):
                            var segments = self.field_access_to_path_segments(expr)
                            while self.check(TokenKind.DoubleColon):
                                self.advance()
                                val segment = self.expect_method_name()
                                segments.push(segment)
                            expr = Expr.Path(segments)

                TokenKind.Arrow:
                    # Functional update: obj->method(args)
                    self.advance()
                    val method = self.expect_method_name()
                    val args = self.parse_arguments()
                    expr = Expr.FunctionalUpdate(target: expr, method: method, args: args)

                TokenKind.Question:
                    self.advance()
                    expr = Expr.Try(expr)

                TokenKind.DoubleQuestion:
                    self.advance()
                    val default = self.parse_unary()
                    expr = Expr.Coalesce(expr: expr, default: default)

                TokenKind.QuestionDot:
                    self.advance()
                    val field = self.expect_method_name()
                    if self.check(TokenKind.LParen):
                        val args = self.parse_arguments()
                        expr = Expr.OptionalMethodCall(receiver: expr, method: field, args: args)
                    else:
                        expr = Expr.OptionalChain(expr: expr, field: field)

                TokenKind.DotQuestion:
                    self.advance()
                    expr = Expr.ExistsCheck(expr)

                TokenKind.Unwrap:
                    self.advance()
                    match self.current.kind:
                        TokenKind.OrColon:
                            self.advance()
                            val default = self.parse_expression()
                            expr = Expr.UnwrapOr(expr: expr, default: default)
                        TokenKind.Else:
                            self.advance()
                            self.expect(TokenKind.Colon)
                            val fallback_fn = self.parse_expression()
                            expr = Expr.UnwrapElse(expr: expr, fallback_fn: fallback_fn)
                        TokenKind.OrReturn:
                            self.advance()
                            expr = Expr.UnwrapOrReturn(expr)
                        _:
                            raise ParseError.syntax_error_with_span(
                                "unwrap requires 'or:', 'else:', or 'or_return:' suffix",
                                self.current.span)

                TokenKind.As:
                    self.advance()
                    val target_type = self.parse_type()
                    match self.current.kind:
                        TokenKind.OrColon:
                            self.advance()
                            val default = self.parse_expression()
                            expr = Expr.CastOr(expr: expr, target_type: target_type, default: default)
                        TokenKind.Else:
                            self.advance()
                            self.expect(TokenKind.Colon)
                            val fallback_fn = self.parse_expression()
                            expr = Expr.CastElse(expr: expr, target_type: target_type, fallback_fn: fallback_fn)
                        TokenKind.OrReturn:
                            self.advance()
                            expr = Expr.CastOrReturn(expr: expr, target_type: target_type)
                        _:
                            expr = Expr.Cast(expr: expr, target_type: target_type)

                TokenKind.Newline:
                    # Multi-line method chaining
                    if self.peek_through_newlines_and_indents_is(TokenKind.Dot):
                        consumed_indents = consumed_indents + self.skip_newlines_and_indents_for_method_chain()
                    else:
                        break

                _: break

        # Consume matching DEDENTs for multi-line chaining indents
        while consumed_indents > 0:
            if match self.current.kind:
                TokenKind.Newline: true
                _: false:
                val next_is_dedent = self.pending_tokens.front().map(\t: match t.kind:
                    TokenKind.Dedent: true
                    _: false) ?? false
                if next_is_dedent:
                    self.advance()  # NEWLINE
                    self.advance()  # DEDENT
                    consumed_indents = consumed_indents - 1
                else:
                    break
            elif match self.current.kind:
                TokenKind.Dedent: true
                _: false:
                self.advance()
                consumed_indents = consumed_indents - 1
            else:
                break

        expr

    fn parse_call(callee: Expr) -> Expr:
        var args = self.parse_arguments()
        if self.check(TokenKind.Backslash):
            val trailing = self.parse_trailing_lambda()
            args.push(Argument(name: None, value: trailing))
        Expr.Call(callee: callee, args: args)

    fn parse_trailing_lambda() -> Expr:
        self.expect(TokenKind.Backslash)
        val (params, capture_all) = self.parse_lambda_params()
        self.expect(TokenKind.Colon)

        val body = if self.check(TokenKind.Newline):
            if self.peek_is(TokenKind.Indent):
                val block = self.parse_block()
                Expr.DoBlock(block.statements)
            else:
                self.parse_expression()
        else:
            self.parse_expression()

        Expr.Lambda(params: params, body: body, move_mode: MoveMode.Copy, capture_all: capture_all)

    fn parse_lambda_params() -> (params: [LambdaParam], capture_all: bool):
        var params = []
        var capture_all = false

        if self.check(TokenKind.Star):
            self.advance()
            capture_all = true
        elif not self.check(TokenKind.Colon):
            val name = if self.check(TokenKind.Underscore):
                self.advance()
                "_"
            else:
                self.expect_identifier()
            params.push(LambdaParam(name: name, ty: None))
            self.parse_remaining_lambda_params(params)
        else:
            capture_all = true

        (params, capture_all)

    fn parse_pipe_lambda_params() -> [LambdaParam]:
        var params = []
        if not self.check(TokenKind.Pipe):
            val name = if self.check(TokenKind.Underscore):
                self.advance()
                "_"
            else:
                self.expect_identifier()
            params.push(LambdaParam(name: name, ty: None))
            self.parse_remaining_lambda_params(params)
        params

    fn parse_remaining_lambda_params(params: [LambdaParam]):
        while self.check(TokenKind.Comma):
            self.advance()
            val name = if self.check(TokenKind.Underscore):
                self.advance()
                "_"
            else:
                self.expect_identifier()
            params.push(LambdaParam(name: name, ty: None))

    # =========================================================================
    # Primary expressions (primary/mod.rs)
    # =========================================================================

    fn parse_primary() -> Expr:
        match self.current.kind:
            TokenKind.Ellipsis:
                self.advance()
                Expr.Tuple([])

            TokenKind.Underscore:
                self.advance()
                Expr.Identifier("_")

            TokenKind.Integer(_) | TokenKind.TypedInteger(_, _) | TokenKind.Float(_) |
            TokenKind.TypedFloat(_, _) | TokenKind.String(_) | TokenKind.RawString(_) |
            TokenKind.TypedString(_, _) | TokenKind.TypedRawString(_, _) |
            TokenKind.FString(_) | TokenKind.Bool(_) | TokenKind.Nil |
            TokenKind.Symbol(_) | TokenKind.CustomBlock(_, _, _):
                self.parse_primary_literal()

            TokenKind.I18nString(_, _) | TokenKind.I18nFString(_, _):
                self.parse_i18n_literal()

            TokenKind.Result | TokenKind.Identifier(_, _) | TokenKind.Self_ |
            TokenKind.Super | TokenKind.Out | TokenKind.OutErr | TokenKind.Type |
            TokenKind.Feature | TokenKind.Scenario | TokenKind.Outline |
            TokenKind.Examples | TokenKind.Given | TokenKind.When |
            TokenKind.Then | TokenKind.AndThen | TokenKind.Context |
            TokenKind.Common | TokenKind.Vec | TokenKind.Gpu |
            TokenKind.Slice | TokenKind.Flat | TokenKind.Alias |
            TokenKind.Bounds | TokenKind.Default | TokenKind.From | TokenKind.To:
                self.parse_primary_identifier()

            TokenKind.Backslash | TokenKind.Pipe | TokenKind.Move:
                self.parse_primary_lambda()

            TokenKind.Fn:
                val next = self.peek_token()
                if match next.kind:
                    TokenKind.LParen: true
                    _: false:
                    self.parse_primary_lambda()
                else:
                    raise ParseError.unexpected_token("expression",
                        "fn (function definitions are not expressions - use fn(): for lambdas)",
                        self.current.span)

            TokenKind.LParen | TokenKind.LBracket | TokenKind.LBrace:
                self.parse_primary_collection()

            TokenKind.New:
                val next = self.peek_token()
                match next.kind:
                    TokenKind.Identifier(_, _) | TokenKind.Ampersand |
                    TokenKind.Star | TokenKind.Plus | TokenKind.Minus:
                        self.parse_primary_control()
                    _:
                        self.parse_primary_identifier()

            TokenKind.Old:
                val next = self.peek_token()
                if match next.kind:
                    TokenKind.LParen: true
                    _: false:
                    self.parse_primary_control()
                else:
                    self.parse_primary_identifier()

            TokenKind.Spawn | TokenKind.Go | TokenKind.If | TokenKind.Elif |
            TokenKind.Match | TokenKind.Dollar:
                self.parse_primary_control()

            TokenKind.Grid | TokenKind.Tensor:
                self.parse_primary_math()

            TokenKind.At:
                val next = self.peek_token()
                if match next.kind:
                    TokenKind.Identifier(_, _): true
                    _: false:
                    self.advance()  # consume '@'
                    val name = self.expect_identifier()
                    Expr.Identifier("@{name}")
                else:
                    raise ParseError.unexpected_token("expression",
                        "@ (matrix mul requires left operand, FFI calls require @identifier)",
                        self.current.span)

            TokenKind.Forall:
                self.parse_forall()

            TokenKind.Exists:
                self.parse_exists()

            _:
                raise ParseError.unexpected_token("expression",
                    "{self.current.kind}", self.current.span)

    # =========================================================================
    # Literals (primary/literals.rs)
    # =========================================================================

    fn parse_primary_literal() -> Expr:
        match self.current.kind:
            TokenKind.Integer(n):
                self.advance()
                Expr.Integer(n)
            TokenKind.TypedInteger(n, suffix):
                self.advance()
                Expr.TypedInteger(n, suffix)
            TokenKind.Float(n):
                self.advance()
                Expr.Float(n)
            TokenKind.TypedFloat(n, suffix):
                self.advance()
                Expr.TypedFloat(n, suffix)
            TokenKind.String(s):
                self.advance()
                Expr.String(s)
            TokenKind.RawString(s):
                self.advance()
                Expr.String(s)
            TokenKind.TypedString(s, suffix):
                self.advance()
                Expr.TypedString(s, suffix)
            TokenKind.TypedRawString(s, suffix):
                self.advance()
                Expr.TypedString(s, suffix)
            TokenKind.FString(parts):
                self.advance()
                val result_parts = self.parse_fstring_parts(parts)
                val const_keys = extract_fstring_keys(result_parts)
                val type_meta = TypeMeta.with_const_keys(const_keys)
                Expr.FString(parts: result_parts, type_meta: type_meta)
            TokenKind.Bool(b):
                self.advance()
                Expr.Bool(b)
            TokenKind.Nil:
                self.advance()
                Expr.Nil
            TokenKind.Symbol(s):
                self.advance()
                Expr.Symbol(s)
            TokenKind.CustomBlock(kind, payload, _):
                self.advance()
                Expr.BlockExpr(kind: kind, payload: payload)
            _:
                raise ParseError.unexpected_token("literal",
                    "{self.current.kind}", self.current.span)

    fn parse_fstring_parts(parts: [FStringToken]) -> [FStringPart]:
        var result = []
        for part in parts:
            match part:
                FStringToken.Literal(s):
                    result.push(FStringPart.Literal(s))
                FStringToken.Expr(expr_str):
                    var sub_parser = Parser.expression(expr_str)
                    match sub_parser.parse_expression():
                        Ok(expr):
                            if sub_parser.is_at_end() or match sub_parser.current.kind:
                                TokenKind.Eof: true
                                _: false:
                                result.push(FStringPart.Expr(expr))
                            else:
                                result.push(FStringPart.Literal("{" + expr_str + "}"))
                        Err(_):
                            result.push(FStringPart.Literal("{" + expr_str + "}"))
        result

    # =========================================================================
    # Identifiers (primary/identifiers.rs)
    # =========================================================================

    fn parse_primary_identifier() -> Expr:
        match self.current.kind:
            TokenKind.Result:
                self.advance()
                Expr.Identifier("result")
            TokenKind.Identifier(name, _):
                self.parse_identifier_or_struct(name)
            TokenKind.Self_:
                self.advance()
                Expr.Identifier("self")
            TokenKind.Super:
                self.advance()
                Expr.Identifier("super")
            TokenKind.Out:
                self.advance()
                Expr.Identifier("out")
            TokenKind.OutErr:
                self.advance()
                Expr.Identifier("out_err")
            TokenKind.Type:
                self.advance()
                Expr.Identifier("type")
            TokenKind.Feature: self.parse_keyword_identifier("feature")
            TokenKind.Scenario: self.parse_keyword_identifier("scenario")
            TokenKind.Outline: self.parse_keyword_identifier("outline")
            TokenKind.Examples: self.parse_keyword_identifier("examples")
            TokenKind.Given: self.parse_keyword_identifier("given")
            TokenKind.When: self.parse_keyword_identifier("when")
            TokenKind.Then: self.parse_keyword_identifier("then")
            TokenKind.AndThen: self.parse_keyword_identifier("and_then")
            TokenKind.Context: self.parse_keyword_identifier("context")
            TokenKind.Common: self.parse_keyword_identifier("common")
            TokenKind.Slice: self.parse_keyword_identifier("Slice")
            TokenKind.Flat: self.parse_keyword_identifier("Flat")
            TokenKind.Vec: self.parse_vec_keyword()
            TokenKind.Gpu:
                self.advance()
                Expr.Identifier("gpu")
            TokenKind.Alias: self.parse_keyword_identifier("alias")
            TokenKind.Bounds: self.parse_keyword_identifier("bounds")
            TokenKind.Default: self.parse_keyword_identifier("default")
            TokenKind.New: self.parse_keyword_identifier("new")
            TokenKind.Old: self.parse_keyword_identifier("old")
            TokenKind.From: self.parse_keyword_identifier("from")
            TokenKind.To: self.parse_keyword_identifier("to")
            _:
                raise ParseError.unexpected_token("identifier",
                    "{self.current.kind}", self.current.span)

    fn parse_keyword_identifier(keyword: text) -> Expr:
        self.advance()
        Expr.Identifier(keyword)

    fn parse_identifier_or_struct(name: text) -> Expr:
        self.advance()

        # Deprecated :: path
        if self.check(TokenKind.DoubleColon):
            var segments = [name]
            while self.check(TokenKind.DoubleColon):
                self.advance()
                val segment = self.expect_method_name()
                segments.push(segment)
            Expr.Path(segments)
        # Struct init: Name { field: value }
        elif self.check(TokenKind.LBrace) and not self.no_brace_postfix and (name[0].is_uppercase() or self.peek_is_struct_init()):
            self.advance()  # consume '{'
            self.skip_newlines()
            var fields = []
            while not self.check(TokenKind.RBrace):
                val field_name = self.expect_identifier()
                self.skip_newlines()
                val value = if self.check(TokenKind.Colon) or self.check(TokenKind.Assign):
                    self.advance()  # consume ':' or '='
                    self.skip_newlines()
                    self.parse_expression()
                else:
                    Expr.Identifier(field_name)
                self.skip_newlines()
                fields.push((field_name, value))
                if not self.check(TokenKind.RBrace):
                    self.expect(TokenKind.Comma)
                    self.skip_newlines()
            self.expect(TokenKind.RBrace)
            Expr.StructInit(name: name, fields: fields)
        else:
            Expr.Identifier(name)

    fn parse_vec_keyword() -> Expr:
        self.advance()
        if self.check(TokenKind.Bang):
            self.advance()
            val args = self.parse_macro_args()
            Expr.MacroInvocation(name: "vec", args: args)
        elif self.check(TokenKind.LBracket):
            # SIMD vector literal: vec[1.0, 2.0]
            self.advance()
            self.skip_whitespace_tokens()
            if self.check(TokenKind.RBracket):
                self.advance()
                return Expr.VecLiteral([])
            var elements = [self.parse_expression()]
            while self.check(TokenKind.Comma):
                self.advance()
                self.skip_whitespace_tokens()
                if self.check(TokenKind.RBracket):
                    break
                elements.push(self.parse_expression())
            self.expect(TokenKind.RBracket)
            Expr.VecLiteral(elements)
        else:
            Expr.Identifier("vec")

    # =========================================================================
    # Lambdas (primary/lambdas.rs)
    # =========================================================================

    fn parse_primary_lambda() -> Expr:
        match self.current.kind:
            TokenKind.Backslash:
                self.advance()
                self.parse_lambda_body(MoveMode.Copy)
            TokenKind.Fn:
                self.advance()
                self.expect(TokenKind.LParen)
                val params = if self.check(TokenKind.RParen):
                    []
                else:
                    val (p, _) = self.parse_lambda_params()
                    p
                self.expect(TokenKind.RParen)
                self.lexer.enable_forced_indentation()
                self.expect(TokenKind.Colon)
                val body = if self.check(TokenKind.Newline):
                    self.advance()
                    if self.check(TokenKind.Indent):
                        self.advance()
                        var statements = []
                        while not self.check(TokenKind.Dedent) and not self.check(TokenKind.Eof):
                            while self.check(TokenKind.Newline): self.advance()
                            if self.check(TokenKind.Dedent) or self.check(TokenKind.Eof): break
                            statements.push(self.parse_item())
                            while self.check(TokenKind.Newline): self.advance()
                        if self.check(TokenKind.Dedent): self.advance()
                        self.lexer.disable_forced_indentation()
                        Expr.DoBlock(statements)
                    else:
                        self.lexer.disable_forced_indentation()
                        self.parse_expression()
                else:
                    val e = self.parse_expression()
                    self.lexer.disable_forced_indentation()
                    e
                Expr.Lambda(params: params, body: body, move_mode: MoveMode.Copy, capture_all: false)
            TokenKind.Pipe:
                self.advance()
                val params = self.parse_pipe_lambda_params()
                self.expect(TokenKind.Pipe)
                val body = self.parse_expression()
                Expr.Lambda(params: params, body: body, move_mode: MoveMode.Copy, capture_all: false)
            TokenKind.Move:
                self.advance()
                if not self.check(TokenKind.Backslash):
                    raise ParseError.unexpected_token("'\\'",
                        "{self.current.kind}", self.current.span)
                self.advance()
                self.parse_lambda_body(MoveMode.Move)
            _:
                raise ParseError.unexpected_token("lambda",
                    "{self.current.kind}", self.current.span)

    fn parse_lambda_body(move_mode: MoveMode) -> Expr:
        val (params, capture_all) = self.parse_lambda_params()
        self.lexer.enable_forced_indentation()
        self.expect(TokenKind.Colon)
        val body = if self.check(TokenKind.Newline):
            self.advance()
            if self.check(TokenKind.Indent):
                self.advance()
                var statements = []
                while not self.check(TokenKind.Dedent) and not self.check(TokenKind.Eof):
                    while self.check(TokenKind.Newline): self.advance()
                    if self.check(TokenKind.Dedent) or self.check(TokenKind.Eof): break
                    statements.push(self.parse_item())
                    while self.check(TokenKind.Newline): self.advance()
                if self.check(TokenKind.Dedent): self.advance()
                self.lexer.disable_forced_indentation()
                Expr.DoBlock(statements)
            else:
                self.lexer.disable_forced_indentation()
                self.parse_expression()
        else:
            val e = self.parse_expression()
            self.lexer.disable_forced_indentation()
            e
        Expr.Lambda(params: params, body: body, move_mode: move_mode, capture_all: capture_all)

    # =========================================================================
    # Collections (primary/collections.rs)
    # =========================================================================

    fn parse_primary_collection() -> Expr:
        match self.current.kind:
            TokenKind.LParen: self.parse_grouped_or_tuple()
            TokenKind.LBracket: self.parse_array_literal()
            TokenKind.LBrace: self.parse_dict_literal()
            _:
                raise ParseError.unexpected_token("collection",
                    "{self.current.kind}", self.current.span)

    fn parse_grouped_or_tuple() -> Expr:
        self.advance()
        self.skip_whitespace_tokens()

        if self.check(TokenKind.RParen):
            self.advance()
            if self.check(TokenKind.FatArrow):
                self.advance()
                val body = self.parse_expression()
                return Expr.Lambda(params: [], body: body, move_mode: MoveMode.Copy, capture_all: false)
            return Expr.Tuple([])

        val first = self.parse_expression()
        self.skip_whitespace_tokens()

        if self.check(TokenKind.Comma):
            var elements = [first]
            while self.check(TokenKind.Comma):
                self.advance()
                self.skip_whitespace_tokens()
                if self.check(TokenKind.RParen): break
                elements.push(self.parse_expression())
                self.skip_whitespace_tokens()
            self.expect(TokenKind.RParen)
            Expr.Tuple(elements)
        else:
            self.expect(TokenKind.RParen)
            first

    fn parse_array_literal() -> Expr:
        self.advance()
        self.skip_whitespace_tokens()

        if self.check(TokenKind.RBracket):
            self.advance()
            return Expr.Array([])

        # Comprehension: [for pattern in iterable if cond: expr]
        if self.check(TokenKind.For):
            self.advance()
            val (pattern, iterable, condition) = self.parse_comprehension_clause()
            self.expect(TokenKind.Colon)
            self.skip_whitespace_tokens()
            val expr = self.parse_expression()
            self.skip_whitespace_tokens()
            self.expect(TokenKind.RBracket)
            return Expr.ListComprehension(expr: expr, pattern: pattern, iterable: iterable, condition: condition)

        # Spread: [*arr]
        if self.check(TokenKind.Star):
            return self.parse_array_with_spreads()

        val first = self.parse_expression()
        self.skip_whitespace_tokens()

        # Comprehension: [expr for pattern in iterable]
        if self.check(TokenKind.For):
            self.advance()
            val (pattern, iterable, condition) = self.parse_comprehension_clause()
            self.expect(TokenKind.RBracket)
            return Expr.ListComprehension(expr: first, pattern: pattern, iterable: iterable, condition: condition)

        # Array repeat: [value; count]
        if self.check(TokenKind.Semicolon):
            self.advance()
            self.skip_whitespace_tokens()
            val count = self.parse_expression()
            self.skip_whitespace_tokens()
            self.expect(TokenKind.RBracket)
            return Expr.ArrayRepeat(value: first, count: count)

        # Regular array
        var elements = [first]
        while self.check(TokenKind.Comma):
            self.advance()
            self.skip_whitespace_tokens()
            if self.check(TokenKind.RBracket): break
            if self.check(TokenKind.Star):
                self.advance()
                elements.push(Expr.Spread(self.parse_expression()))
            else:
                elements.push(self.parse_expression())
            self.skip_whitespace_tokens()
        self.expect(TokenKind.RBracket)
        Expr.Array(elements)

    fn parse_dict_literal() -> Expr:
        self.advance()
        self.skip_newlines()

        if self.check(TokenKind.RBrace):
            self.advance()
            return Expr.Dict([])

        # Dict comprehension: {for pattern in iterable if cond: (key, value)}
        if self.check(TokenKind.For):
            self.advance()
            val (pattern, iterable, condition) = self.parse_comprehension_clause()
            self.expect(TokenKind.Colon)
            self.skip_whitespace_tokens()
            self.expect(TokenKind.LParen)
            val key = self.parse_expression()
            self.expect(TokenKind.Comma)
            val value = self.parse_expression()
            self.expect(TokenKind.RParen)
            self.skip_whitespace_tokens()
            self.expect(TokenKind.RBrace)
            return Expr.DictComprehension(key: key, value: value, pattern: pattern, iterable: iterable, condition: condition)

        # Dict spread: {**d1, **d2}
        if self.check(TokenKind.DoubleStar):
            return self.parse_dict_with_spreads()

        val key = self.parse_expression()
        self.skip_newlines()
        self.expect(TokenKind.Colon)
        self.skip_newlines()
        val value = self.parse_expression()
        self.skip_newlines()

        # Dict comprehension: {k: v for pattern in iterable}
        if self.check(TokenKind.For):
            self.advance()
            val (pattern, iterable, condition) = self.parse_comprehension_clause()
            self.expect(TokenKind.RBrace)
            return Expr.DictComprehension(key: key, value: value, pattern: pattern, iterable: iterable, condition: condition)

        var pairs = [(key, value)]
        while self.check(TokenKind.Comma):
            self.advance()
            self.skip_newlines()
            if self.check(TokenKind.RBrace): break
            if self.check(TokenKind.DoubleStar):
                self.advance()
                val spread_expr = self.parse_expression()
                pairs.push((Expr.DictSpread(spread_expr), Expr.Nil))
            else:
                val k = self.parse_expression()
                self.skip_newlines()
                self.expect(TokenKind.Colon)
                self.skip_newlines()
                val v = self.parse_expression()
                self.skip_newlines()
                pairs.push((k, v))
        self.expect(TokenKind.RBrace)
        Expr.Dict(pairs)

    # =========================================================================
    # Control expressions (primary/control.rs)
    # =========================================================================

    fn parse_primary_control() -> Expr:
        match self.current.kind:
            TokenKind.Old: self.parse_contract_old()
            TokenKind.Forall: self.parse_forall()
            TokenKind.Exists: self.parse_exists()
            TokenKind.If | TokenKind.Elif:
                self.advance()
                self.parse_if_expr()
            TokenKind.Match: self.parse_match_expr()
            TokenKind.Spawn: self.parse_spawn_expr()
            TokenKind.Go: self.parse_go_expr()
            TokenKind.New: self.parse_new_expr()
            TokenKind.Dollar: self.parse_dollar_identifier()
            _:
                raise ParseError.unexpected_token("control expression",
                    "{self.current.kind}", self.current.span)

    fn parse_contract_old() -> Expr:
        self.advance()
        self.expect(TokenKind.LParen)
        val expr = self.parse_expression()
        self.expect(TokenKind.RParen)
        Expr.ContractOld(expr)

    fn parse_forall() -> Expr:
        self.advance()
        val pattern = self.parse_pattern()
        self.expect(TokenKind.In)
        val range = self.parse_expression()
        self.expect(TokenKind.Colon)
        val predicate = self.parse_expression()
        Expr.Forall(pattern: pattern, range: range, predicate: predicate)

    fn parse_exists() -> Expr:
        self.advance()
        val pattern = self.parse_pattern()
        self.expect(TokenKind.In)
        val range = self.parse_expression()
        self.expect(TokenKind.Colon)
        val predicate = self.parse_expression()
        Expr.Exists(pattern: pattern, range: range, predicate: predicate)

    fn parse_match_expr() -> Expr:
        self.advance()
        val subject = self.parse_expression()
        self.lexer.enable_forced_indentation()
        self.expect(TokenKind.Colon)
        if self.check(TokenKind.Newline):
            self.advance()
            self.expect(TokenKind.Indent)
            var arms = []
            while not self.check(TokenKind.Dedent) and not self.is_at_end():
                while self.check(TokenKind.Newline): self.advance()
                if self.check(TokenKind.Dedent): break
                arms.push(self.parse_match_arm_expr())
            if self.check(TokenKind.Dedent): self.advance()
            self.lexer.disable_forced_indentation()
            Expr.Match(subject: subject, arms: arms)
        else:
            self.lexer.disable_forced_indentation()
            raise ParseError.unexpected_token("newline after match",
                "{self.current.kind}", self.current.span)

    fn parse_match_arm_expr() -> MatchArm:
        val start_span = self.current.span

        val is_pipe_syntax = self.check(TokenKind.Pipe)
        if is_pipe_syntax:
            self.advance()
        elif self.check(TokenKind.Case):
            self.advance()

        val pattern = self.parse_pattern()
        val guard = if self.check(TokenKind.If):
            self.advance()
            self.parse_expression()
        else:
            None

        val valid_separator = if is_pipe_syntax:
            self.check(TokenKind.Arrow)
        else:
            self.check(TokenKind.Arrow) or self.check(TokenKind.FatArrow) or self.check(TokenKind.Colon)

        if not valid_separator:
            val expected = if is_pipe_syntax: "->" else: "-> or => or :"
            raise ParseError.unexpected_token(expected,
                "{self.current.kind}", self.current.span)

        self.advance()
        val body = if self.check(TokenKind.Newline):
            self.parse_block()
        elif self.check(TokenKind.Return) or self.check(TokenKind.Break) or self.check(TokenKind.Continue):
            val stmt = self.parse_item()
            Block(span: self.previous.span, statements: [stmt])
        else:
            val expr = self.parse_expression()
            Block(span: self.previous.span, statements: [Node.Expression(expr)])

        MatchArm(span: Span(start: start_span.start, end: self.previous.span.end,
                            line: start_span.line, column: start_span.column),
                 pattern: pattern, guard: guard, body: body)

    fn parse_spawn_expr() -> Expr:
        self.advance()
        val expr = self.parse_expression()
        Expr.Spawn(expr)

    fn parse_go_expr() -> Expr:
        self.advance()
        val args = if self.check(TokenKind.LParen):
            self.advance()
            if self.check(TokenKind.RParen):
                self.advance()
                []
            else:
                var a = []
                loop:
                    a.push(self.parse_expression())
                    if self.check(TokenKind.Comma): self.advance()
                    else: break
                self.expect(TokenKind.RParen)
                a
        elif self.check(TokenKind.Backslash):
            []
        else:
            raise ParseError.unexpected_token("( or \\ after go",
                "{self.current.kind}", self.current.span)

        self.expect(TokenKind.Backslash)
        var params = []
        if self.check(TokenKind.Star):
            self.advance()
        elif not self.check(TokenKind.Colon):
            loop:
                params.push(self.expect_identifier())
                if self.check(TokenKind.Comma): self.advance()
                else: break
        self.expect(TokenKind.Colon)
        val body = self.parse_expression()
        Expr.Go(args: args, params: params, body: body)

    fn parse_new_expr() -> Expr:
        self.advance()
        val kind = match self.current.kind:
            TokenKind.Ampersand:
                self.advance()
                PointerKind.Unique
            TokenKind.Star:
                self.advance()
                PointerKind.Shared
            TokenKind.Minus:
                self.advance()
                PointerKind.Weak
            TokenKind.Plus:
                self.advance()
                PointerKind.Handle
            _: PointerKind.Shared
        val expr = self.parse_postfix()
        Expr.New(kind: kind, expr: expr)

    fn parse_dollar_identifier() -> Expr:
        self.advance()
        val name = self.expect_identifier()
        Expr.Identifier("${name}")

    # =========================================================================
    # If expression (helpers.rs)
    # =========================================================================

    fn parse_if_expr() -> Expr:
        val old_no_brace = self.no_brace_postfix
        self.no_brace_postfix = true
        val (let_pattern, condition) = self.parse_optional_let_pattern()
        self.no_brace_postfix = old_no_brace

        val use_braces = self.check(TokenKind.LBrace)
        if not use_braces:
            self.expect(TokenKind.Colon)

        val then_branch = if use_braces:
            self.parse_brace_block_expr()
        elif self.check(TokenKind.Newline):
            self.advance()
            self.expect(TokenKind.Indent)
            var statements = []
            while not self.check(TokenKind.Dedent) and not self.is_at_end():
                while self.check(TokenKind.Newline): self.advance()
                if self.check(TokenKind.Dedent) or self.is_at_end(): break
                statements.push(self.parse_item())
                if self.check(TokenKind.Newline): self.advance()
            if self.check(TokenKind.Dedent): self.advance()
            Expr.DoBlock(statements)
        else:
            self.parse_expression()

        val else_branch = if self.check(TokenKind.Elif):
            self.advance()
            self.parse_if_expr()
        elif self.check(TokenKind.Else):
            self.advance()
            if self.check(TokenKind.If):
                self.advance()
                self.parse_if_expr()
            elif self.check(TokenKind.LBrace):
                self.parse_brace_block_expr()
            else:
                self.expect(TokenKind.Colon)
                if self.check(TokenKind.Newline):
                    self.advance()
                    self.expect(TokenKind.Indent)
                    var statements = []
                    while not self.check(TokenKind.Dedent) and not self.is_at_end():
                        while self.check(TokenKind.Newline): self.advance()
                        if self.check(TokenKind.Dedent) or self.is_at_end(): break
                        statements.push(self.parse_item())
                        if self.check(TokenKind.Newline): self.advance()
                    if self.check(TokenKind.Dedent): self.advance()
                    Expr.DoBlock(statements)
                else:
                    self.parse_expression()
        else:
            None

        Expr.If(let_pattern: let_pattern, condition: condition, then_branch: then_branch, else_branch: else_branch)

    fn parse_brace_block_expr() -> Expr:
        self.expect(TokenKind.LBrace)
        self.skip_whitespace_tokens()
        if self.check(TokenKind.RBrace):
            self.advance()
            return Expr.DoBlock([])
        val expr = self.parse_expression()
        self.skip_whitespace_tokens()
        self.expect(TokenKind.RBrace)
        expr

    # =========================================================================
    # Arguments (helpers.rs)
    # =========================================================================

    fn parse_arguments() -> [Argument]:
        self.expect(TokenKind.LParen)
        var args = []

        while self.check(TokenKind.Newline) or self.check(TokenKind.Indent):
            self.advance()

        while not self.check(TokenKind.RParen) and not self.check(TokenKind.Eof):
            self.skip_whitespace_tokens()
            if self.check(TokenKind.RParen): break

            val arg_start = self.current.span
            var name = None

            # Check for named argument: name= or name:
            val maybe_name = match self.current.kind:
                TokenKind.Identifier(id, _): id
                TokenKind.Type: "type"
                TokenKind.Default: "default"
                TokenKind.Result: "result"
                TokenKind.From: "from"
                TokenKind.To: "to"
                TokenKind.In: "in"
                TokenKind.Is: "is"
                TokenKind.As: "as"
                TokenKind.Match: "match"
                TokenKind.Use: "use"
                TokenKind.Alias: "alias"
                TokenKind.Bounds: "bounds"
                TokenKind.Outline: "outline"
                TokenKind.By: "by"
                TokenKind.Into: "into"
                TokenKind.Onto: "onto"
                TokenKind.With: "with"
                _: None

            if maybe_name.?:
                val next = self.peek_token()
                if next.kind == TokenKind.Assign:
                    name = maybe_name
                    self.advance()
                    self.expect(TokenKind.Assign)
                elif next.kind == TokenKind.Colon:
                    name = maybe_name
                    self.advance()
                    self.expect(TokenKind.Colon)

            var value = self.parse_expression()

            # Spread: args...
            if self.check(TokenKind.Ellipsis):
                self.advance()
                value = Expr.Spread(value)

            # Placeholder lambda transform: _ * 2 -> \__p0: __p0 * 2
            value = transform_placeholder_lambda(value)

            val arg_end = self.previous.span
            val arg_span = Span(start: arg_start.start, end: arg_end.end, line: arg_start.line, column: arg_start.column)

            # Call-site label keywords
            val label = match self.current.kind:
                TokenKind.To:
                    self.advance()
                    "to"
                TokenKind.From:
                    self.advance()
                    "from"
                TokenKind.By:
                    self.advance()
                    "by"
                TokenKind.Into:
                    self.advance()
                    "into"
                TokenKind.Onto:
                    self.advance()
                    "onto"
                TokenKind.With:
                    self.advance()
                    "with"
                _: None

            args.push(Argument(name: name, value: value, span: arg_span, label: label))

            while self.check(TokenKind.Newline) or self.check(TokenKind.Indent) or self.check(TokenKind.Dedent):
                self.advance()

            if not self.check(TokenKind.RParen):
                self.expect(TokenKind.Comma)
                while self.check(TokenKind.Newline) or self.check(TokenKind.Indent) or self.check(TokenKind.Dedent):
                    self.advance()

        self.expect(TokenKind.RParen)
        args

    fn parse_macro_args() -> [MacroArg]:
        val close = match self.current.kind:
            TokenKind.LParen: TokenKind.RParen
            TokenKind.LBrace: TokenKind.RBrace
            TokenKind.LBracket: TokenKind.RBracket
            _:
                raise ParseError.unexpected_token("'(', '{', or '['",
                    "{self.current.kind}", self.current.span)

        self.advance()
        var args = []
        while not self.check(close):
            val expr = self.parse_expression()
            args.push(MacroArg.Expr(expr))
            if not self.check(close):
                if self.check(TokenKind.Comma) or self.check(TokenKind.Semicolon):
                    self.advance()
        self.expect(close)
        args

    fn parse_comprehension_clause() -> (pattern: Pattern, iterable: Expr, condition: Expr?):
        val pattern = self.parse_pattern()
        self.expect(TokenKind.In)
        val iterable = self.parse_expression()
        val condition = if self.check(TokenKind.If):
            self.advance()
            self.parse_expression()
        else:
            None
        (pattern, iterable, condition)

    fn try_parse_colon_block() -> Expr?:
        if not self.check(TokenKind.Colon):
            return None

        self.advance()  # consume ':'
        while self.check(TokenKind.Newline): self.advance()

        if not self.check(TokenKind.Indent):
            raise ParseError.unexpected_token("indented block after ':'",
                "{self.current.kind}", self.current.span)

        self.advance()  # consume Indent
        var statements = []
        while not self.check(TokenKind.Dedent) and not self.check(TokenKind.Eof):
            while self.check(TokenKind.Newline): self.advance()
            if self.check(TokenKind.Dedent) or self.check(TokenKind.Eof): break
            statements.push(self.parse_item())
            while self.check(TokenKind.Newline): self.advance()
        if self.check(TokenKind.Dedent): self.advance()

        val block_expr = Expr.DoBlock(statements)
        Expr.Lambda(params: [], body: block_expr, move_mode: MoveMode.Copy, capture_all: false)

    # =========================================================================
    # No-paren calls (no_paren.rs)
    # =========================================================================

    fn parse_with_no_paren_calls(expr: Expr) -> Expr:
        if self.is_callable_expr(expr) and self.is_at_colon_block():
            if val Some(block_lambda) = self.try_parse_colon_block():
                val args = [Argument(name: None, value: block_lambda)]
                return self.make_call_expr(expr, args)
        elif self.is_callable_expr(expr) and self.can_start_argument():
            if self.mode == ParserMode.Strict and self.no_paren_depth > 0:
                return expr

            self.no_paren_depth = self.no_paren_depth + 1
            var args = self.parse_no_paren_arguments()
            self.no_paren_depth = self.no_paren_depth - 1

            if self.check(TokenKind.Backslash):
                val trailing = self.parse_trailing_lambda()
                args.push(Argument(name: None, value: trailing))
            elif self.check(TokenKind.Colon):
                if val Some(block_lambda) = self.try_parse_colon_block():
                    args.push(Argument(name: None, value: block_lambda))

            if args.?:
                return self.make_call_expr(expr, args)
        expr

    fn parse_infix_keywords(expr: Expr) -> Expr:
        var result = expr
        loop:
            val method_name = match self.current.kind:
                TokenKind.To: "to"
                TokenKind.NotTo: "not_to"
                _: break
            self.advance()
            val arg_expr = self.parse_expression()
            val arg_expr2 = self.parse_with_no_paren_calls(arg_expr)
            result = Expr.MethodCall(receiver: result, method: method_name,
                                     args: [Argument(name: None, value: arg_expr2)])
        result

    fn is_callable_expr(expr: Expr) -> bool:
        match expr:
            Expr.Identifier(_): true
            Expr.FieldAccess(_, _): true
            Expr.Path(_): true
            _: false

    fn is_at_colon_block() -> bool:
        if not self.check(TokenKind.Colon):
            return false
        self.peek_is(TokenKind.Newline)

    fn can_start_argument() -> bool:
        match self.current.kind:
            TokenKind.Integer(_) | TokenKind.TypedInteger(_, _) |
            TokenKind.Float(_) | TokenKind.TypedFloat(_, _) |
            TokenKind.String(_) | TokenKind.RawString(_) |
            TokenKind.TypedString(_, _) | TokenKind.TypedRawString(_, _) |
            TokenKind.FString(_) | TokenKind.Bool(_) | TokenKind.Nil |
            TokenKind.Symbol(_) | TokenKind.Identifier(_, _) |
            TokenKind.Result | TokenKind.Type | TokenKind.Out | TokenKind.OutErr |
            TokenKind.Context | TokenKind.Feature | TokenKind.Scenario |
            TokenKind.Given | TokenKind.When | TokenKind.Then | TokenKind.Common |
            TokenKind.LParen | TokenKind.LBracket | TokenKind.LBrace |
            TokenKind.Backslash | TokenKind.Colon |
            TokenKind.Await | TokenKind.Yield |
            TokenKind.Not | TokenKind.Minus | TokenKind.Plus |
            TokenKind.Tilde | TokenKind.Ampersand | TokenKind.Star |
            TokenKind.New | TokenKind.Old | TokenKind.From | TokenKind.To:
                true
            _: false

    fn parse_no_paren_arguments() -> [Argument]:
        var args = []
        match self.parse_single_argument():
            Ok(arg): args.push(arg)
            Err(_): return args

        loop:
            val has_comma = self.check(TokenKind.Comma)
            if has_comma: self.advance()

            if self.mode == ParserMode.Strict:
                if not self.can_start_argument() or match self.current.kind:
                    TokenKind.To: true
                    TokenKind.NotTo: true
                    _: false:
                    break
            else:
                if not has_comma: break

            match self.parse_single_argument():
                Ok(arg): args.push(arg)
                Err(_): break
        args

    fn parse_single_argument() -> Argument:
        match self.current.kind:
            TokenKind.Identifier(name, _):
                if self.peek_is(TokenKind.Colon) or self.peek_is(TokenKind.Assign):
                    val name_clone = name
                    self.advance()
                    self.advance()  # consume ':' or '='
                    val prev_depth = self.no_paren_depth
                    if self.mode == ParserMode.Strict:
                        self.no_paren_depth = self.no_paren_depth + 1
                    val value = self.parse_expression()
                    self.no_paren_depth = prev_depth
                    return Argument(name: name_clone, value: value)
            _: ()

        val prev_depth = self.no_paren_depth
        if self.mode == ParserMode.Strict:
            self.no_paren_depth = self.no_paren_depth + 1
        val value = self.parse_expression()
        self.no_paren_depth = prev_depth
        Argument(name: None, value: value)

    # =========================================================================
    # Math expressions (primary/math.rs)
    # =========================================================================

    fn parse_primary_math() -> Expr:
        match self.current.kind:
            TokenKind.Grid: self.parse_grid_literal()
            TokenKind.Tensor: self.parse_tensor_literal()
            _:
                raise ParseError.unexpected_token("math literal",
                    "{self.current.kind}", self.current.span)

    fn parse_grid_literal() -> Expr:
        self.advance()
        val device = if self.check_ident("device"):
            self.advance()
            self.expect(TokenKind.Assign)
            match self.current.kind:
                TokenKind.String(s):
                    self.advance()
                    s
                _:
                    raise ParseError.unexpected_token("string for device",
                        "{self.current.kind}", self.current.span)
        else:
            None

        self.expect(TokenKind.Colon)
        self.expect(TokenKind.Newline)
        self.expect(TokenKind.Indent)
        val rows = self.parse_grid_rows()
        self.expect(TokenKind.Dedent)
        Expr.GridLiteral(rows: rows, device: device)

    fn parse_grid_rows() -> [[Expr]]:
        var rows = []
        while self.check(TokenKind.Pipe):
            self.advance()
            var cells = []
            loop:
                val cell = self.parse_expression()
                cells.push(cell)
                if self.check(TokenKind.Pipe):
                    self.advance()
                    if self.check(TokenKind.Newline): break
                else:
                    raise ParseError.missing_token("| after grid cell", self.current.span)
            self.expect(TokenKind.Newline)
            rows.push(cells)
            while self.check(TokenKind.Newline): self.advance()
        if rows.len() == 0:
            raise ParseError.syntax_error_with_span("Grid literal must have at least one row", self.current.span)
        rows

    fn parse_tensor_literal() -> Expr:
        self.advance()
        val tensor_name = self.expect_identifier()
        self.expect(TokenKind.Colon)
        val dtype = self.expect_identifier()

        self.expect(TokenKind.LBracket)
        var dims = []
        while not self.check(TokenKind.RBracket):
            val dim_name = self.expect_identifier()
            self.expect(TokenKind.Assign)
            val dim_value = match self.current.kind:
                TokenKind.Integer(n):
                    self.advance()
                    n
                _:
                    raise ParseError.unexpected_token("integer for dimension",
                        "{self.current.kind}", self.current.span)
            dims.push((dim_name, dim_value))
            if self.check(TokenKind.Comma): self.advance()
        self.expect(TokenKind.RBracket)

        val device = if self.check_ident("device"):
            self.advance()
            self.expect(TokenKind.Assign)
            match self.current.kind:
                TokenKind.String(s):
                    self.advance()
                    s
                _:
                    raise ParseError.unexpected_token("string for device",
                        "{self.current.kind}", self.current.span)
        else:
            None

        self.expect(TokenKind.Newline)
        self.expect(TokenKind.Indent)

        val mode = if self.check_ident("slice"):
            val slices = self.parse_tensor_slices()
            TensorMode.Slice(slices)
        elif self.check_ident("default") or self.check_ident("flat"):
            val default_val = if self.check_ident("default"):
                self.advance()
                self.expect(TokenKind.Colon)
                val v = self.parse_expression()
                self.expect(TokenKind.Newline)
                v
            else:
                None
            self.expect(TokenKind.Flat)
            self.expect(TokenKind.Colon)
            self.expect(TokenKind.Newline)
            self.expect(TokenKind.Indent)
            val values = self.parse_grid_rows()
            self.expect(TokenKind.Dedent)
            TensorMode.Flat(default: default_val, values: values)
        else:
            raise ParseError.syntax_error_with_span("'slice' or 'flat' mode in tensor literal",
                self.current.span)

        self.expect(TokenKind.Dedent)
        Expr.TensorLiteral(dtype: dtype, dims: dims, mode: mode, device: device)

    fn parse_tensor_slices() -> [TensorSlice]:
        var slices = []
        while self.check_ident("slice"):
            self.advance()
            val dim_name = self.expect_identifier()
            self.expect(TokenKind.Assign)
            val dim_value = match self.current.kind:
                TokenKind.Integer(n):
                    self.advance()
                    n
                _:
                    raise ParseError.unexpected_token("integer for slice index",
                        "{self.current.kind}", self.current.span)
            self.expect(TokenKind.Colon)
            self.expect(TokenKind.Newline)
            self.expect(TokenKind.Indent)
            val content = if self.check_ident("slice"):
                val nested = self.parse_tensor_slices()
                TensorSliceContent.NestedSlices(nested)
            else:
                val rows = self.parse_grid_rows()
                TensorSliceContent.GridRows(rows)
            self.expect(TokenKind.Dedent)
            slices.push(TensorSlice(dim_name: dim_name, dim_value: dim_value, content: content))
            while self.check(TokenKind.Newline): self.advance()
        slices

    # =========================================================================
    # i18n expressions (primary/i18n.rs)
    # =========================================================================

    fn parse_i18n_literal() -> Expr:
        match self.current.kind:
            TokenKind.I18nString(name, default_text):
                self.advance()
                if self.check(TokenKind.LBrace):
                    val args = self.parse_i18n_args()
                    Expr.I18nTemplate(name: name, parts: [FStringPart.Literal(default_text)], args: args)
                else:
                    Expr.I18nString(name: name, default_text: default_text)
            TokenKind.I18nFString(name, parts):
                self.advance()
                val parsed_parts = self.parse_fstring_parts(parts)
                if self.check(TokenKind.LBrace):
                    val args = self.parse_i18n_args()
                    Expr.I18nTemplate(name: name, parts: parsed_parts, args: args)
                else:
                    Expr.I18nTemplate(name: name, parts: parsed_parts, args: [])
            _:
                raise ParseError.unexpected_token("i18n literal",
                    "{self.current.kind}", self.current.span)

    fn parse_i18n_args() -> [(text, Expr)]:
        self.expect(TokenKind.LBrace)
        var args = []
        while not self.check(TokenKind.RBrace):
            val key = self.expect_identifier()
            self.expect(TokenKind.Colon)
            val value = self.parse_expression()
            args.push((key, value))
            if not self.check(TokenKind.RBrace):
                self.expect(TokenKind.Comma)
        self.expect(TokenKind.RBrace)
        args

    # =========================================================================
    # Placeholder lambda (placeholder.rs)
    # =========================================================================

    static fn transform_placeholder_lambda(expr: Expr) -> Expr:
        val count = count_placeholders(expr)
        if count == 0:
            return expr
        var counter = 0
        val body = replace_placeholders(expr, counter)
        val params = [for i in 0..count: LambdaParam(name: "__p{i}", ty: None)]
        Expr.Lambda(params: params, body: body, move_mode: MoveMode.Copy, capture_all: false)

    # =========================================================================
    # Helper: skip whitespace tokens
    # =========================================================================

    fn skip_whitespace_tokens():
        while match self.current.kind:
            TokenKind.Newline: true
            TokenKind.Indent: true
            TokenKind.Dedent: true
            _: false:
            self.advance()


# Standalone functions for placeholder counting/replacement

fn count_placeholders(expr: Expr) -> i64:
    match expr:
        Expr.Identifier(name):
            if name == "_": 1 else: 0
        Expr.Binary(_, left, right):
            count_placeholders(left) + count_placeholders(right)
        Expr.Unary(_, operand):
            count_placeholders(operand)
        Expr.Call(callee, args):
            count_placeholders(callee) + args.map(\a: count_placeholders(a.value)).sum()
        Expr.MethodCall(receiver, _, args):
            count_placeholders(receiver) + args.map(\a: count_placeholders(a.value)).sum()
        Expr.FieldAccess(receiver, _):
            count_placeholders(receiver)
        Expr.Index(receiver, index):
            count_placeholders(receiver) + count_placeholders(index)
        Expr.If(_, condition, then_branch, else_branch):
            count_placeholders(condition) + count_placeholders(then_branch) + (if else_branch.?: count_placeholders(else_branch) else: 0)
        Expr.Tuple(items) | Expr.Array(items):
            items.map(\i: count_placeholders(i)).sum()
        Expr.Dict(entries):
            entries.map(\e: count_placeholders(e.0) + count_placeholders(e.1)).sum()
        Expr.OptionalChain(e, _):
            count_placeholders(e)
        Expr.Coalesce(e, default):
            count_placeholders(e) + count_placeholders(default)
        Expr.Cast(e, _):
            count_placeholders(e)
        Expr.Spread(inner):
            count_placeholders(inner)
        Expr.Lambda(_, _, _, _): 0
        _: 0

fn replace_placeholders(expr: Expr, counter: i64) -> Expr:
    match expr:
        Expr.Identifier(name):
            if name == "_":
                val new_name = "__p{counter}"
                counter = counter + 1
                Expr.Identifier(new_name)
            else:
                expr
        Expr.Binary(op, left, right):
            Expr.Binary(op: op, left: replace_placeholders(left, counter),
                        right: replace_placeholders(right, counter))
        Expr.Unary(op, operand):
            Expr.Unary(op: op, operand: replace_placeholders(operand, counter))
        Expr.Call(callee, args):
            Expr.Call(callee: replace_placeholders(callee, counter),
                      args: args.map(\a: Argument(name: a.name, value: replace_placeholders(a.value, counter), span: a.span, label: a.label)))
        Expr.MethodCall(receiver, method, args):
            Expr.MethodCall(receiver: replace_placeholders(receiver, counter), method: method,
                           args: args.map(\a: Argument(name: a.name, value: replace_placeholders(a.value, counter), span: a.span, label: a.label)))
        Expr.FieldAccess(receiver, field):
            Expr.FieldAccess(receiver: replace_placeholders(receiver, counter), field: field)
        Expr.Index(receiver, index):
            Expr.Index(receiver: replace_placeholders(receiver, counter),
                       index: replace_placeholders(index, counter))
        Expr.Tuple(items):
            Expr.Tuple(items.map(\i: replace_placeholders(i, counter)))
        Expr.Array(items):
            Expr.Array(items.map(\i: replace_placeholders(i, counter)))
        Expr.Dict(entries):
            Expr.Dict(entries.map(\e: (replace_placeholders(e.0, counter), replace_placeholders(e.1, counter))))
        Expr.OptionalChain(e, field):
            Expr.OptionalChain(expr: replace_placeholders(e, counter), field: field)
        Expr.Coalesce(e, default):
            Expr.Coalesce(expr: replace_placeholders(e, counter), default: replace_placeholders(default, counter))
        Expr.Cast(e, target_type):
            Expr.Cast(expr: replace_placeholders(e, counter), target_type: target_type)
        Expr.Spread(inner):
            Expr.Spread(replace_placeholders(inner, counter))
        Expr.Lambda(_, _, _, _): expr
        _: expr
