# Token Types for the Simple Language Parser
#
# Source location, token kinds, naming patterns, numeric suffixes.
# Port of rust/parser/src/token.rs

export Span, Token, TokenKind, NamePattern, NumericSuffix
export FStringToken, TextSpan, PreLexInfo

# Source location
struct Span:
    start: i64
    end: i64
    line: i64
    column: i64

# Naming pattern for variables and identifiers
enum NamePattern:
    Constant    # ALL_CAPS
    TypeName    # PascalCase
    Immutable   # lowercase
    Mutable     # ends with _
    Private     # starts with _

impl NamePattern:
    static fn detect(name: text) -> NamePattern:
        if name.len() == 0:
            return NamePattern.Immutable
        if name.starts_with("_"):
            return NamePattern.Private
        if name.ends_with("_"):
            return NamePattern.Mutable
        # ALL_CAPS check
        val is_all_caps = name.chars().all(\c: c.is_upper() or c.is_digit() or c == '_')
        if is_all_caps and name.chars().any(\c: c.is_alpha()):
            return NamePattern.Constant
        if name[0].is_upper():
            return NamePattern.TypeName
        NamePattern.Immutable

# Numeric type suffix for typed literals
enum NumericSuffix:
    I8
    I16
    I32
    I64
    U8
    U16
    U32
    U64
    F32
    F64
    Unit(text)  # User-defined unit suffix like _km, _hr

# Part of an f-string token (for interpolated strings)
enum FStringToken:
    Literal(text)
    Expr(text)  # Expression text to be parsed later

# Byte range within a block payload
struct TextSpan:
    start: i64
    end: i64

# Pre-lexing info collected during brace tracking
struct PreLexInfo:
    string_spans: [TextSpan]
    comment_spans: [TextSpan]
    escape_positions: [i64]
    brace_pairs: [(i64, i64)]

# Token types for the Simple language
enum TokenKind:
    # Literals
    Integer(i64)
    Float(f64)
    TypedInteger(i64, NumericSuffix)
    TypedFloat(f64, NumericSuffix)
    String(text)
    FString([FStringToken])
    RawString(text)
    TypedString(text, text)
    TypedRawString(text, text)
    Bool(bool)
    Nil
    Symbol(text)
    I18nString(name: text, default_text: text)
    I18nFString(name: text, parts: [FStringToken])

    # Identifiers
    Identifier(name: text, pattern: NamePattern)

    # Keywords
    Fn
    Me
    Let
    Mut
    Val
    Var
    If
    Elif
    Else
    For
    While
    Loop
    Break
    Continue
    Pass
    Defer
    Skip
    Return
    Match
    Case
    IfSuspend
    WhileSuspend
    ForSuspend
    MatchSuspend
    Struct
    Class
    Enum
    Union
    Trait
    Impl
    Mixin
    Actor
    Extends
    Pub
    Priv
    Import
    From
    As
    Mod
    Use
    Export
    Common
    Auto
    StructuredExport
    Crate
    In
    Is
    Not
    And
    Or
    Xor
    True
    False
    Spawn
    Go
    New
    Self_
    Super
    Async
    Await
    Sync
    Yield
    Move
    Const
    Static
    Type
    Unit
    Extern
    Context
    With
    By
    Into
    Onto
    Ghost
    Macro
    Bang
    Vec
    Shared
    Gpu
    Bounds
    Kernel
    Gen
    Dyn
    Repr
    Literal
    Alias

    # Package unfold
    Unfold

    # AOP
    Pointcut(text)
    On
    Bind
    Forbid
    Allow
    Mock

    # Safe Unwrap/Cast
    Unwrap
    OrColon
    ElseColon
    OrReturn

    # Custom Blocks
    CustomBlock(kind: text, payload: text, pre_lex_info: PreLexInfo)

    # Contract keywords
    Out
    OutErr
    Where
    Requires
    Ensures
    Invariant
    Old
    Result
    Decreases
    Forall
    Exists
    Assert
    Assume
    Admit
    Calc

    # Infix keywords (BDD)
    To
    NotTo

    # Gherkin DSL
    Feature
    Scenario
    Outline
    Examples
    Given
    When
    Then
    AndThen

    # Memory
    HandlePool

    # Math
    Grid
    Tensor
    Slice
    Flat
    Default

    # Operators
    Plus
    Minus
    Star
    Slash
    Percent
    DoubleStar
    Parallel

    Eq
    NotEq
    Lt
    Gt
    LtEq
    GtEq

    Assign
    PlusAssign
    MinusAssign
    StarAssign
    SlashAssign
    PercentAssign
    TildeAssign
    TildePlusAssign
    TildeMinusAssign
    TildeStarAssign
    TildeSlashAssign

    Ampersand
    Pipe
    PipeForward
    DoublePipe
    DoubleAmp
    AndSuspend
    OrSuspend
    Tilde
    ShiftLeft
    ShiftRight

    Arrow
    FatArrow
    ChannelArrow

    # Delimiters
    LParen
    RParen
    LBracket
    RBracket
    LBrace
    RBrace

    Comma
    Colon
    DoubleColon
    Semicolon
    Dot
    DoubleDot
    DoubleDotEq
    Ellipsis
    Question
    DoubleQuestion
    QuestionDot
    DotQuestion
    At
    Hash
    Dollar
    Backslash
    Underscore

    # Indentation
    Newline
    Indent
    Dedent

    # Documentation
    DocComment(text)

    # Special
    Eof
    Error(text)

impl TokenKind:
    fn is_identifier() -> bool:
        match self:
            case TokenKind.Identifier(_, _): true
            case _: false

    fn as_identifier() -> text?:
        match self:
            case TokenKind.Identifier(name, _): Some(name)
            case _: None

    fn is_identifier_named(expected: text) -> bool:
        match self:
            case TokenKind.Identifier(name, _): name == expected
            case _: false

# Token with kind, span, and lexeme
struct Token:
    kind: TokenKind
    span: Span
    lexeme: text
