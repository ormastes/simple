# Simple Context Pack Generator (Written in Simple)
#
# Extracts minimal context for LLM consumption (#890-893)
#
# Usage:
#   context <file.spl> [target] [options]
#
# Features:
#   - 90% reduction in LLM context tokens
#   - Extracts only symbols used by target
#   - Multiple export formats (JSON, Markdown, Text)

# FFI function declarations for context operations
extern fn rt_context_generate(path: str, target: str, format: str) -> str
extern fn rt_context_stats(path: str, target: str) -> str

# CLI helpers
extern fn rt_cli_get_args() -> [str]
extern fn rt_cli_file_exists(path: str) -> bool

# Native file I/O
extern fn native_fs_write_string(path: str, content: str) -> Any

fn print_help():
    print "Simple Context Pack Generator"
    print ""
    print "Usage:"
    print "  context <file.spl> [target] [options]"
    print ""
    print "Arguments:"
    print "  <file.spl>  Source file to analyze"
    print "  [target]    Target function/module (default: file name)"
    print ""
    print "Options:"
    print "  --format=<fmt>  Output format: json, markdown, text (default: markdown)"
    print "  --json          Shorthand for --format=json"
    print "  --text          Shorthand for --format=text"
    print "  -o <file>       Output to file instead of stdout"
    print "  --stats         Show context reduction statistics"
    print "  -h, --help      Show this help"
    print ""
    print "Examples:"
    print "  context app.spl"
    print "  context app.spl UserService --json"
    print "  context app.spl calculate --format=markdown -o context.md"
    print ""
    print "Features:"
    print "  - 90% reduction in LLM context tokens"
    print "  - Extracts only symbols used by target"
    print "  - Multiple export formats (JSON, Markdown, Text)"

fn get_file_stem(path: str) -> str:
    # Extract filename without extension
    val parts = path.split("/")
    val filename = parts[-1]
    val name_parts = filename.split(".")
    if name_parts.len() > 1:
        name_parts[0]
    else:
        filename

fn main() -> i64:
    val all_args = rt_cli_get_args()

    # Skip program name and script name
    var args = []
    var i = 2
    while i < all_args.len():
        args.push(all_args[i])
        i = i + 1

    # Check for help
    if args.len() == 0 or args.contains("-h") or args.contains("--help"):
        print_help()
        return if args.len() == 0: 1 else: 0

    # Parse arguments
    val source_path = args[0]

    # Check file exists
    if not rt_cli_file_exists(source_path):
        print "error: cannot read {source_path}: file not found"
        return 1

    # Default target is file stem
    var target = get_file_stem(source_path)
    var format = "markdown"
    var output_file = ""
    var show_stats = false

    # Parse remaining arguments
    var j = 1
    while j < args.len():
        val arg = args[j]
        if arg == "--json":
            format = "json"
        elif arg == "--text":
            format = "text"
        elif arg == "--stats":
            show_stats = true
        elif arg == "-o":
            if j + 1 < args.len():
                output_file = args[j + 1]
                j = j + 1
        elif arg.starts_with("--format="):
            format = arg[9:]
        elif not arg.starts_with("-"):
            target = arg
        j = j + 1

    # Show stats if requested
    if show_stats:
        val stats = rt_context_stats(source_path, target)
        if stats != "":
            print "Context Statistics:"
            print stats
            print ""

    # Generate context
    val output = rt_context_generate(source_path, target, format)
    if output == "":
        print "error: failed to generate context for {source_path}"
        return 1

    # Write output
    if output_file != "":
        val write_result = native_fs_write_string(output_file, output)
        match write_result:
            case Err(e):
                print "error: cannot write {output_file}: {e}"
                return 1
            case Ok(_):
                print "Context written to {output_file}"
                return 0
    else:
        print output
        return 0
