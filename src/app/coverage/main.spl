"""
Coverage Analysis Tool

Commands:
  scan     - Scan source code and generate/update public_api.yml
  class    - Show class/struct touch coverage (for System Tests)
  func     - Show public function touch coverage (for Integration Tests)
  report   - Show full coverage report
  generate - Generate extended coverage reports
  check    - Check coverage against threshold
  summary  - Print coverage summary
"""

# Note: std.cli, std.fs, std.process would be used if available
# For now, we use basic functions and FFI

# FFI declarations for CLI
use app.cli_util (get_cli_args)

# FFI declarations for Rust coverage functions
extern fn coverage_scan(source_dir: str, output_file: str) -> i64
extern fn coverage_class(coverage_json: str, source_dir: str, filter: str) -> i64
extern fn coverage_func(coverage_json: str, source_dir: str, filter: str) -> i64
extern fn coverage_report(coverage_json: str, public_api: str, type_filter: str) -> i64
extern fn coverage_generate(llvm_cov: str, api: str, output_dir: str, report_type: str) -> i64
extern fn coverage_check(coverage_file: str, threshold: f64) -> i64
extern fn coverage_summary(coverage_file: str) -> i64


fn print_usage():
    print "Usage: simple coverage <command> [options]"
    print ""
    print "Commands:"
    print "  scan      Scan source and generate public_api.yml"
    print "            --source <dir>   Source directory (default: src)"
    print "            --output <file>  Output YAML file (default: public_api.yml)"
    print ""
    print "  class     Show class/struct touch coverage"
    print "            --coverage-json <file>  LLVM coverage JSON"
    print "            --source <dir>          Source directory (default: src)"
    print "            --filter <pattern>      Filter by type name"
    print ""
    print "  func      Show public function touch coverage"
    print "            --coverage-json <file>  LLVM coverage JSON"
    print "            --source <dir>          Source directory (default: src)"
    print "            --filter <pattern>      Filter by crate/module"
    print ""
    print "  report    Show full coverage report (legacy)"
    print "            --coverage-json <file>  LLVM coverage JSON"
    print "            --public-api <file>     Public API YAML"
    print "            --type-filter <pattern> Filter by type name"
    print ""
    print "  generate  Generate extended coverage reports"
    print "            --llvm-cov <file>       LLVM coverage JSON"
    print "            --api <file>            Public API YAML"
    print "            --output-dir <dir>      Output directory (default: target/coverage)"
    print "            --report-type <type>    system|integration|merged|all (default: all)"
    print ""
    print "  check     Check coverage against threshold"
    print "            --coverage <file>       Extended coverage JSON"
    print "            --threshold <percent>   Threshold percentage (default: 80.0)"
    print ""
    print "  summary   Print coverage summary"
    print "            --coverage <file>       Extended coverage JSON"


fn get_arg(args: [str], flag: str, default_val: str) -> str:
    var i = 0
    while i < args.len() - 1:
        if args[i] == flag:
            return args[i + 1]
        i = i + 1
    default_val


fn has_flag(args: [str], flag: str) -> bool:
    var i = 0
    while i < args.len():
        if args[i] == flag:
            return true
        i = i + 1
    false


fn cmd_scan(args: [str]) -> i64:
    val source = get_arg(args, "--source", "src")
    val output = get_arg(args, "--output", "public_api.yml")

    print "Scanning source directory: {source}"
    val result = coverage_scan(source, output)

    if result == 0:
        print "Written to: {output}"
    else:
        print "Error: scan failed with code {result}"

    result


fn cmd_class(args: [str]) -> i64:
    val coverage_json = get_arg(args, "--coverage-json", "")
    val source = get_arg(args, "--source", "src")
    val filter = get_arg(args, "--filter", "")

    if coverage_json == "":
        print "Error: --coverage-json is required"
        return 1

    coverage_class(coverage_json, source, filter)


fn cmd_func(args: [str]) -> i64:
    val coverage_json = get_arg(args, "--coverage-json", "")
    val source = get_arg(args, "--source", "src")
    val filter = get_arg(args, "--filter", "")

    if coverage_json == "":
        print "Error: --coverage-json is required"
        return 1

    coverage_func(coverage_json, source, filter)


fn cmd_report(args: [str]) -> i64:
    val coverage_json = get_arg(args, "--coverage-json", "")
    val public_api = get_arg(args, "--public-api", "")
    val type_filter = get_arg(args, "--type-filter", "")

    if coverage_json == "":
        print "Error: --coverage-json is required"
        return 1

    if public_api == "":
        print "Error: --public-api is required"
        return 1

    coverage_report(coverage_json, public_api, type_filter)


fn cmd_generate(args: [str]) -> i64:
    val llvm_cov = get_arg(args, "--llvm-cov", "")
    val api = get_arg(args, "--api", "")
    val output_dir = get_arg(args, "--output-dir", "target/coverage")
    val report_type = get_arg(args, "--report-type", "all")

    if llvm_cov == "":
        print "Error: --llvm-cov is required"
        return 1

    if api == "":
        print "Error: --api is required"
        return 1

    print "Loading coverage data from {llvm_cov}"
    print "Loading API spec from {api}"

    coverage_generate(llvm_cov, api, output_dir, report_type)


fn cmd_check(args: [str]) -> i64:
    val coverage = get_arg(args, "--coverage", "")
    val threshold_str = get_arg(args, "--threshold", "80.0")

    if coverage == "":
        print "Error: --coverage is required"
        return 1

    # Default threshold of 80.0
    val threshold = 80.0

    print "Checking coverage in {coverage} against {threshold}% threshold"

    coverage_check(coverage, threshold)


fn cmd_summary(args: [str]) -> i64:
    val coverage = get_arg(args, "--coverage", "")

    if coverage == "":
        print "Error: --coverage is required"
        return 1

    coverage_summary(coverage)


fn main() -> i64:
    val args = get_cli_args()

    if args.len() < 1:
        print_usage()
        return 0

    val command = args[0]

    match command:
        case "scan":
            return cmd_scan(args)
        case "class":
            return cmd_class(args)
        case "func":
            return cmd_func(args)
        case "report":
            return cmd_report(args)
        case "generate":
            return cmd_generate(args)
        case "check":
            return cmd_check(args)
        case "summary":
            return cmd_summary(args)
        case "--help" | "-h" | "help":
            print_usage()
            return 0
        case _:
            print "Unknown command: {command}"
            print_usage()
            return 1
