#!/usr/bin/env simple
# Analyze interpreter hotspots using perf report
# Migrated from scripts/profiling/analyze-hotspots.sh
#
# Usage:
#   analyze_hotspots [perf.data]
#
# This script analyzes perf data and generates reports showing:
#   - Top functions by CPU time
#   - Call graph for hotspot functions
#   - Annotated source code

use app.io
use app.utils.colors (success, error, warning, info)
use std.text.{NL}

export main, analyze_hotspots

fn main():
    val args = get_args()
    val perf_data = if args.len() > 0:
        args[0]
    else:
        "perf.data"

    analyze_hotspots(perf_data)

fn analyze_hotspots(perf_data: text):
    """Analyze hotspots from perf data"""

    if not file_exists(perf_data):
        print error("perf data not found: {perf_data}")
        print ""
        print "Run profiling first:"
        print "  ./src/app/profiling/profile.spl <script.spl>"
        exit(1)

    print success("Analyzing hotspots from: {perf_data}")
    print ""

    # Top functions by overhead
    print info("=== Top 20 Functions by CPU Time ===")
    val (stdout1, _, _) = process_run("perf",
        ["report", "-i", perf_data, "--stdio", "-n", "--sort", "overhead,symbol"])
    print_first_lines(stdout1, 50)

    print ""
    print info("=== Top Interpreter Functions ===")
    # Filter for interpreter functions
    val lines1 = stdout1.split(NL)
    var interpreter_lines = []
    for line in lines1:
        if line.contains("interpreter_eval") or
           line.contains("eval_") or
           line.contains("exec_"):
            interpreter_lines = interpreter_lines + [line]
            if interpreter_lines.len() >= 20:
                break

    for line in interpreter_lines:
        print line

    print ""
    print info("=== Call Graph for Top Hotspot ===")

    # Get the top function
    val top_func = find_top_interpreter_func(perf_data)
    if top_func.len() > 0:
        print "Analyzing: {top_func}"

        val (stdout2, _, _) = process_run("perf",
            ["report", "-i", perf_data, "--stdio", "--call-graph", "-n", "-s", "symbol"])

        # Find lines containing the top function and show context
        val lines2 = stdout2.split(NL)
        var found = false
        var line_count = 0

        for line in lines2:
            if found:
                print line
                line_count = line_count + 1
                if line_count >= 30:
                    break
            elif line.contains(top_func):
                found = true
                print line
                line_count = 1

    print ""
    print success("Analysis complete!")
    print ""
    print "For interactive exploration:"
    print "  perf report -i {perf_data}"
    print ""
    print "For annotated source (if debug symbols available):"
    print "  perf annotate -i {perf_data}"

fn print_first_lines(text: text, count: i64):
    """Print first N lines of text"""
    val lines = text.split(NL)
    for i in 0..count:
        if i < lines.len():
            print lines[i]

fn find_top_interpreter_func(perf_data: text) -> text:
    """Find the top interpreter function from perf report"""
    val (stdout, _, _) = process_run("perf",
        ["report", "-i", perf_data, "--stdio", "--sort", "symbol"])

    val lines = stdout.split(NL)
    for line in lines:
        if line.contains("interpreter_eval") or
           line.contains("eval_") or
           line.contains("exec_"):
            # Extract function name (last field)
            val parts = line.split(" ")
            if parts.len() > 0:
                return parts[parts.len() - 1].trim()

    ""
