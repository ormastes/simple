# Diagnostics Handler
# Provides error diagnostics from tree-sitter parse errors and verification

import lsp.protocol as protocol
import lsp.transport as transport
import parser.treesitter.{Tree, Node, NodeId}
import lsp.handlers.verification as verification

# Find all ERROR nodes in the tree
fn find_error_nodes(tree: Tree) -> [Node]:
    var errors: [Node] = []

    # Helper function to traverse tree recursively
    fn traverse(node_id: NodeId):
        match tree.arena.get(node_id):
            case nil:
                return
            case Some(node):
                # Check if this node is an error
                if node.kind == "ERROR" or node.has_error:
                    errors.push(node)

                # Traverse children
                for child_id in node.children:
                    traverse(child_id)

    # Start traversal from root
    traverse(tree.root_node)

    errors

# Convert tree-sitter node to LSP diagnostic
fn node_to_diagnostic(node: Node) -> Dict:
    # Create range
    val range = {
        "start": {
            "line": node.span.start_line,
            "character": node.span.start_column
        },
        "end": {
            "line": node.span.end_line,
            "character": node.span.end_column
        }
    }

    # Determine message based on node context
    val message = if node.text.len() > 0:
        "Syntax error near '{node.text}'"
    else:
        "Syntax error"

    # Create diagnostic
    {
        "range": range,
        "severity": protocol.DiagnosticSeverity.Error,
        "source": "simple-lsp",
        "message": message
    }

# Generate diagnostics from parse tree
fn generate_diagnostics(tree: Tree) -> [Dict]:
    val error_nodes = find_error_nodes(tree)
    var diagnostics: [Dict] = []

    for error_node in error_nodes:
        val diagnostic = node_to_diagnostic(error_node)
        diagnostics.push(diagnostic)

    diagnostics

# Handle diagnostics for a document
fn handle_diagnostics(uri: String, tree: Tree) -> Result<Nil, String>:
    # Generate syntax diagnostics from tree
    var diagnostics = generate_diagnostics(tree)

    # Add verification diagnostics
    match verification.handle_verification_diagnostics(tree, uri):
        case Ok(verify_diags):
            for diag in verify_diags:
                diagnostics.push(diag)
        case Err(e):
            transport.log_debug("Verification diagnostics error: {e}")

    transport.log_debug("Found {diagnostics.len()} diagnostics for {uri}")

    # Send publishDiagnostics notification
    val params = {
        "uri": uri,
        "diagnostics": diagnostics
    }

    transport.write_notification("textDocument/publishDiagnostics", params)?

    Ok(nil)
