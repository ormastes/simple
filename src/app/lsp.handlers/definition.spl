# Definition Handler
# Provides go-to-definition functionality for symbols and Lean artifacts

import lsp.protocol as protocol
import lsp.transport as transport
use compiler.treesitter.{TreeSitter, OutlineModule, ParseError}
# TODO: awaiting FFI tree-sitter integration for Tree, Node, NodeId
import lsp.handlers.verification as verification

# Symbol definition info
class SymbolDefinition:
    name: String
    kind: String  # "function", "variable", "type", "parameter"
    span: Span
    node_id: NodeId

    static fn new(name: String, kind: String, span: Span, node_id: NodeId) -> SymbolDefinition:
        SymbolDefinition(
            name: name,
            kind: kind,
            span: span,
            node_id: node_id
        )

# Scope containing symbols
class Scope:
    symbols: Dict<String, SymbolDefinition>
    parent: Option<Scope>

    static fn new(parent: Option<Scope>) -> Scope:
        Scope(symbols: {}, parent: parent)

    # Lookup symbol in this scope or parent scopes
    fn lookup(name: String) -> Option<SymbolDefinition>:
        # Check this scope first
        match self.symbols.get(name):
            case Some(def):
                Some(def)
            case nil:
                # Check parent scope
                match self.parent:
                    case Some(parent):
                        parent.lookup(name)
                    case nil:
                        nil

    # Add symbol to this scope
    var fn add(name: String, def: SymbolDefinition):
        self.symbols[name] = def

# Build symbol table from tree
fn build_symbol_table(tree: Tree) -> Scope:
    var global_scope = Scope.new(nil)

    # Traverse tree and collect definitions
    fn traverse(node_id: NodeId, current_scope: Scope) -> Scope:
        match tree.arena.get(node_id):
            case nil:
                current_scope
            case Some(node):
                var scope = current_scope

                # Check for definition nodes
                match node.kind:
                    case "function_def":
                        # Extract function name from fields
                        match node.fields.get("name"):
                            case Some(name_id):
                                match tree.arena.get(name_id):
                                    case Some(name_node):
                                        val def = SymbolDefinition.new(
                                            name_node.text,
                                            "function",
                                            node.span,
                                            node_id
                                        )
                                        scope.add(name_node.text, def)
                                    case nil:
                                        pass
                            case nil:
                                pass

                        # Create new scope for function body
                        var func_scope = Scope.new(Some(scope))

                        # Add parameters to function scope
                        match node.fields.get("params"):
                            case Some(params_id):
                                # Traverse params to add to func_scope
                                func_scope = traverse(params_id, func_scope)
                            case nil:
                                pass

                        # Traverse function body with function scope
                        match node.fields.get("body"):
                            case Some(body_id):
                                traverse(body_id, func_scope)
                            case nil:
                                pass

                        scope

                    case "let_stmt":
                        # Variable definition
                        match node.fields.get("pattern"):
                            case Some(pattern_id):
                                match tree.arena.get(pattern_id):
                                    case Some(pattern_node):
                                        if pattern_node.kind == "identifier":
                                            val def = SymbolDefinition.new(
                                                pattern_node.text,
                                                "variable",
                                                pattern_node.span,
                                                pattern_id
                                            )
                                            scope.add(pattern_node.text, def)
                                    case nil:
                                        pass
                            case nil:
                                pass

                        # Traverse children
                        for child_id in node.children:
                            scope = traverse(child_id, scope)

                        scope

                    case "parameter":
                        # Function parameter
                        match node.fields.get("name"):
                            case Some(name_id):
                                match tree.arena.get(name_id):
                                    case Some(name_node):
                                        val def = SymbolDefinition.new(
                                            name_node.text,
                                            "parameter",
                                            name_node.span,
                                            name_id
                                        )
                                        scope.add(name_node.text, def)
                                    case nil:
                                        pass
                            case nil:
                                pass

                        scope

                    case "struct_def":
                        # Type definition
                        match node.fields.get("name"):
                            case Some(name_id):
                                match tree.arena.get(name_id):
                                    case Some(name_node):
                                        val def = SymbolDefinition.new(
                                            name_node.text,
                                            "type",
                                            node.span,
                                            node_id
                                        )
                                        scope.add(name_node.text, def)
                                    case nil:
                                        pass
                            case nil:
                                pass

                        scope

                    case _:
                        # Traverse children for other nodes
                        for child_id in node.children:
                            scope = traverse(child_id, scope)

                        scope

    traverse(tree.root_node, global_scope)

# Find node at specific position (from hover handler)
fn find_node_at_position(tree: Tree, line: Int, column: Int) -> Option<Node>:
    fn position_in_span(span: Span, line: Int, column: Int) -> Bool:
        if line < span.start_line or line > span.end_line:
            return false
        if line == span.start_line and column < span.start_column:
            return false
        if line == span.end_line and column > span.end_column:
            return false
        true

    fn traverse(node_id: NodeId, best: Option<Node>) -> Option<Node>:
        match tree.arena.get(node_id):
            case nil:
                best
            case Some(node):
                if not position_in_span(node.span, line, column):
                    return best
                var new_best = Some(node)
                for child_id in node.children:
                    new_best = traverse(child_id, new_best)
                new_best

    traverse(tree.root_node, nil)

# Handle textDocument/definition request
fn handle_definition(tree: Tree, source: String, line: Int, column: Int) -> Result<Option<Dict>, String>:
    # Find node at cursor
    match find_node_at_position(tree, line, column):
        case nil:
            Ok(nil)
        case Some(node):
            # Check if this is a reference (identifier)
            if node.kind != "identifier":
                return Ok(nil)

            # Build symbol table
            val symbol_table = build_symbol_table(tree)

            # Look up symbol
            match symbol_table.lookup(node.text):
                case nil:
                    Ok(nil)
                case Some(def):
                    # Create location response
                    val location = {
                        "range": {
                            "start": {
                                "line": def.span.start_line,
                                "character": def.span.start_column
                            },
                            "end": {
                                "line": def.span.end_line,
                                "character": def.span.end_column
                            }
                        }
                    }

                    Ok(Some(location))

# Handle go-to-definition for Lean artifacts
# Returns the location of the Lean file for verified symbols
fn handle_lean_definition(tree: Tree, source: String, line: Int, column: Int, output_dir: String) -> Result<Option<Dict>, String>:
    # Check if we're on a verified symbol
    match verification.handle_lean_definition(tree, line, column, output_dir):
        case Some(location):
            Ok(Some(location))
        case nil:
            Ok(nil)

# Handle definition with Lean artifact fallback
fn handle_definition_with_lean(tree: Tree, source: String, line: Int, column: Int, lean_output_dir: Option<String>) -> Result<Option<Dict>, String>:
    # First try normal definition
    match handle_definition(tree, source, line, column)?:
        case Some(location):
            Ok(Some(location))
        case nil:
            # Try Lean artifact definition if output dir is configured
            match lean_output_dir:
                case Some(output_dir):
                    handle_lean_definition(tree, source, line, column, output_dir)
                case nil:
                    Ok(nil)
