# Dependency Graph Generator - Directory Scanner Module
# Scans directories for .spl files and identifies child modules

# Native file system functions
extern fn rt_dir_list(path: String) -> List<String>
extern fn rt_file_exists(path: String) -> Bool

# Helper to check if path is a directory
# A path is a directory if rt_dir_list succeeds on it
fn is_directory(path: String) -> Bool:
    # Try to list directory; if it fails, it's not a directory
    val entries = rt_dir_list(path)
    # If we got a list back (even empty), it's a directory
    return true
    # Note: If path doesn't exist or isn't a directory, rt_dir_list may return empty list or throw

# Helper to join paths
fn path_join(base: String, child: String) -> String:
    if base.ends_with("/"):
        return base + child
    return base + "/" + child

# File info structure
class FileInfo:
    path: String
    name: String
    is_directory: Bool

    fn new(path: String, name: String, is_directory: Bool) -> FileInfo:
        return FileInfo(path: path, name: name, is_directory: is_directory)

# Scan result structure
class ScanResult:
    directory: String
    spl_files: List<String>
    child_dirs: List<String>
    has_init: Bool

    fn new(directory: String) -> ScanResult:
        return ScanResult(
            directory: directory,
            spl_files: [],
            child_dirs: [],
            has_init: false
        )

# Check if file is a valid .spl source file (not generated)
fn is_source_file(name: String) -> Bool:
    # Must end with .spl
    if not name.ends_with(".spl"):
        return false
    # Exclude dot-prefixed files (generated)
    if name.starts_with("."):
        return false
    # Exclude __init__.spl (manifest, not module)
    if name == "__init__.spl":
        return false
    return true

# Check if directory is a valid module directory
fn is_module_dir(dir_path: String) -> Bool:
    val init_path = path_join(base=dir_path, child="__init__.spl")
    return rt_file_exists(init_path)

# Get module name from file name (strip .spl extension)
pub fn get_module_name(file_name: String) -> String:
    if file_name.ends_with(".spl"):
        return file_name.substring(0, file_name.len() - 4)
    return file_name

# Scan a single directory for .spl files and child directories
pub fn scan_directory(dir_path: String, recursive: Bool) -> Result<ScanResult, String>:
    if not rt_file_exists(dir_path):
        return Err("Directory not found: {dir_path}")

    if not is_directory(dir_path):
        return Err("Not a directory: {dir_path}")

    # Check if this directory has __init__.spl
    val init_path = path_join(base=dir_path, child="__init__.spl")
    val has_init = rt_file_exists(init_path)

    # Use local lists for collecting results
    var spl_files: List<String> = []
    var child_dirs: List<String> = []

    # Read directory contents
    val entry_names = rt_dir_list(dir_path)
    # rt_dir_list returns List<String> of file/directory names
    for name in entry_names:
        val full_path = path_join(base=dir_path, child=name)

                # Check if entry is a directory by trying to read it
                if is_directory(full_path):
                    # Check if child directory is a module
                    if is_module_dir(full_path):
                        child_dirs.push(name)
                else:
                    # Check if it's a source .spl file
                    if is_source_file(name):
                        spl_files.push(name)

    # Construct result - use the same pattern as new()
    var result = ScanResult.new(dir_path)
    result.spl_files = spl_files
    result.child_dirs = child_dirs
    result.has_init = has_init
    return Ok(result)

# Scan directory tree recursively
pub fn scan_tree(dir_path: String) -> Result<List<ScanResult>, String>:
    val results: List<ScanResult> = []

    # Scan root directory
    val root_result = scan_directory(dir_path, true)
    match root_result:
        case Err(e):
            return Err(e)
        case Ok(result):
            results.push(result)

            # Recursively scan child directories
            for child in result.child_dirs:
                val child_path = path_join(base=dir_path, child=child)
                val child_results = scan_tree(child_path)
                match child_results:
                    case Err(e):
                        # Log error but continue
                        print("[WARN] Failed to scan {child_path}: {e}")
                    case Ok(sub_results):
                        for sub in sub_results:
                            results.push(sub)

    return Ok(results)

# Get list of module names from scan result
pub fn get_module_names(scan: ScanResult) -> List<String>:
    val modules: List<String> = []
    for file in scan.spl_files:
        modules.push(get_module_name(file))
    return modules
