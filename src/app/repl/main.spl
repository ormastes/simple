# Simple Language REPL
# Interactive Read-Eval-Print Loop with TUI
# Usage: simple_repl [--version]

use ui.tui.backend.ratatui.*
use ui.tui.widgets.line_editor.*
use repl
use sys
use std.text.{NL}

## REPL version information
const VERSION = "0.1.0"

## Get the banner text
fn get_banner() -> String:
    return "Simple Language REPL v" + VERSION + "{NL}Type 'exit()' or press ESC to quit{NL}Type 'help()' for help{NL}"

## Execute Simple code and return result
fn execute_code(code: String) -> String:
    # Execute Simple code via Rust Runner and return the result
    val (success, result) = repl.execute(code)

    if success:
        # Execution succeeded
        if result == "OK":
            return ""  # No output for successful statements
        else:
            return result
    else:
        # Execution failed - return error
        return result

## Show help information
fn show_help() -> String:
    return "Simple REPL Help{NL}================{NL}{NL}Commands:{NL}  exit()         - Exit the REPL{NL}  help()         - Show this help{NL}  clear()        - Clear the screen{NL}{NL}Features:{NL}  - Multi-line input (end lines with ':' to continue){NL}  - Auto-indentation (4 spaces after ':'){NL}  - Smart backspace (deletes 4 spaces in indentation){NL}  - Tab inserts 4 spaces{NL}  - ESC to exit{NL}{NL}Examples:{NL}  >>> 1 + 1{NL}  2{NL}{NL}  >>> val x = 42{NL}  >>> x * 2{NL}  84{NL}{NL}  >>> if 1:{NL}  ...     print(\"hello\"){NL}  ...{NL}  hello{NL}"

## Main REPL loop
fn run_repl() -> i32:
    # Initialize runner
    if not repl.runner_init():
        print("Error: Failed to initialize REPL runner")
        return 1

    # Create terminal
    val terminal = terminal_new()
    if terminal == 0:
        print("Error: Failed to create terminal")
        repl.runner_cleanup()
        return 1

    # Create line editor
    val editor = LineEditor.new(terminal)

    # Print banner
    terminal_clear(terminal)
    print(get_banner())

    # Track if we should continue running
    var running = true
    var output_buffer = []

    # Set up submission callback
    editor.on_submit(fn(input: String):
        val trimmed = input.trim()

        # Handle built-in commands
        if trimmed == "exit()" or trimmed == "quit()":
            running = false
            return

        if trimmed == "help()":
            val help_text = show_help()
            output_buffer.push(help_text)
            return

        if trimmed == "clear()":
            terminal_clear(terminal)
            output_buffer = []
            return

        # Skip empty input
        if trimmed.is_empty():
            return

        # Execute code
        val result = execute_code(input)
        output_buffer.push(result)

        # Keep only last 100 output lines to prevent memory issues
        if output_buffer.len() > 100:
            output_buffer = output_buffer[output_buffer.len() - 100..]
    )

    # Main event loop
    while running:
        # Clear screen
        terminal_clear(terminal)

        # Render output buffer
        for line in output_buffer:
            print(line)

        # Render editor
        editor.render()

        # Poll for events with 100ms timeout
        val event = read_event(100)

        # Handle events
        if event.event_type == EventType.Key:
            # ESC to exit
            if event.key_code == KEY_ESCAPE:
                running = false
            # Ctrl+C to exit
            elif event.key_code == ord('c') and has_modifier(event.key_mods, MOD_CTRL):
                running = false
            # Ctrl+D to exit
            elif event.key_code == ord('d') and has_modifier(event.key_mods, MOD_CTRL):
                running = false
            # Ctrl+L to clear
            elif event.key_code == ord('l') and has_modifier(event.key_mods, MOD_CTRL):
                terminal_clear(terminal)
                output_buffer = []
            else:
                # Pass event to editor
                editor.handle_event(event)

    # Cleanup
    editor.destroy()
    terminal_cleanup(terminal)
    repl.runner_cleanup()

    return 0

## Entry point
fn main():
    val args = sys.args()

    # Handle --version flag
    if args.contains("--version"):
        print("Simple REPL v" + VERSION)
        sys.exit(0)

    # Handle --help flag
    if args.contains("--help") or args.contains("-h"):
        print("Simple Language REPL")
        print("====================")
        print("")
        print("Usage: simple_repl [OPTIONS]")
        print("")
        print("Options:")
        print("  --version    Show version information")
        print("  --help, -h   Show this help")
        print("")
        print("Interactive Commands:")
        print("  exit()       Exit the REPL")
        print("  help()       Show help")
        print("  clear()      Clear screen")
        print("")
        print("Keyboard Shortcuts:")
        print("  ESC          Exit REPL")
        print("  Ctrl+C       Exit REPL")
        print("  Ctrl+D       Exit REPL")
        print("  Ctrl+L       Clear screen")
        print("  Tab          Insert 4 spaces")
        print("")
        sys.exit(0)

    # Run REPL
    val exit_code = run_repl()
    sys.exit(exit_code)
