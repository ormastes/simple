# Doc Coverage Threshold Validator
#
# Validate coverage results against thresholds and generate reports.

use app.doc_coverage.thresholds.types.{ScopeCoverage, scope_coverage_to_text}

fn validate_thresholds(coverages: [ScopeCoverage]) -> (bool, [text]):
    # Returns: (all_passed, failed_scope_names)

    var all_passed = true
    var failed_scopes = []

    var idx = 0
    val count = coverages.len()

    while idx < count:
        val cov = coverages[idx]
        if not cov.passed:
            all_passed = false
            failed_scopes = failed_scopes + ([cov.scope])

        idx = idx + 1

    return (all_passed, failed_scopes)

fn generate_threshold_report(
    coverages: [ScopeCoverage],
    all_passed: bool,
    failed_scopes: [text]
) -> text:
    # Generate human-readable threshold report

    var report = ""
    report = report + ("=" * 70) + ("\n")
    report = report + ("Doc Coverage Threshold Report\n")
    report = report + ("=" * 70) + ("\n\n")

    # Per-scope results
    var idx = 0
    val count = coverages.len()
    while idx < count:
        val cov = coverages[idx]
        val line = scope_coverage_to_text(cov)
        report = report + (line) + ("\n")

        # Show missing items for failed scopes
        if not cov.passed:
            val missing_count = cov.missing_items.len()
            if missing_count > 0:
                report = report + ("  Missing ({missing_count} items):\n")

                var m_idx = 0
                val max_show = 10
                val show_count = if missing_count < max_show: missing_count else: max_show

                while m_idx < show_count:
                    val item = cov.missing_items[m_idx]
                    report = report + ("    - {item}\n")
                    m_idx = m_idx + 1

                if missing_count > max_show:
                    val remaining = missing_count - max_show
                    report = report + ("    ... and {remaining} more\n")

        idx = idx + 1

    # Summary
    report = report + ("\n")
    report = report + ("=" * 70) + ("\n")

    if all_passed:
        report = report + ("Result: ALL THRESHOLDS PASSED\n")
    else:
        val failed_count = failed_scopes.len()
        report = report + ("Result: {failed_count} scope(s) below threshold\n")
        report = report + ("Failed scopes:\n")

        var f_idx = 0
        while f_idx < failed_count:
            val scope = failed_scopes[f_idx]
            report = report + ("  - {scope}\n")
            f_idx = f_idx + 1

    report = report + ("=" * 70) + ("\n")

    return report

fn get_overall_coverage(coverages: [ScopeCoverage]) -> i64:
    # Calculate overall coverage across all scopes
    var total = 0
    var covered = 0

    var idx = 0
    val count = coverages.len()
    while idx < count:
        val cov = coverages[idx]
        total = total + cov.total_items
        covered = covered + cov.covered_items
        idx = idx + 1

    if total == 0:
        return 0

    val pct = (covered * 100) / total
    return pct

export validate_thresholds
export generate_threshold_report
export get_overall_coverage
