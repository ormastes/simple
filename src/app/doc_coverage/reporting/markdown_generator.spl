# Markdown report generator for documentation coverage
#
# Generates human-readable reports with summary, breakdown, and recommendations.

use doc_coverage.types.coverage_result.{CoverageReport, FileCoverage}
use doc_coverage.types.doc_item.{DocItem, DocKind}
use std.string.{NL}

# Generate markdown report for coverage
fn generate_coverage_markdown(coverage: CoverageReport) -> text:
    var md = "# Documentation Coverage Report{NL}{NL}"

    # Summary section
    md = "{md}## Summary{NL}{NL}"
    md = "{md}{_generate_summary_section(coverage)}{NL}"

    # Per-scope breakdown
    md = "{md}## Coverage by Scope{NL}{NL}"
    md = "{md}{_generate_scope_breakdown(coverage)}{NL}"

    # Top files needing documentation
    md = "{md}## Top 10 Files Needing Documentation{NL}{NL}"
    md = "{md}{_generate_top_files_needing_docs(coverage)}{NL}"

    # Missing sdoctests
    md = "{md}## Missing SDoctest Examples{NL}{NL}"
    md = "{md}{_generate_missing_sdoctests(coverage)}{NL}"

    md

fn _generate_summary_section(coverage: CoverageReport) -> text:
    val total = coverage.total_items
    val documented = coverage.documented_items
    val missing = coverage.missing_docs
    val overall_pct = coverage.overall_percent()

    val sdoc_total = coverage.sdoctest_coverage + coverage.missing_sdoctest
    val sdoc_covered = coverage.sdoctest_coverage
    val sdoc_pct = coverage.sdoctest_percent()

    # Determine status emoji
    val status_emoji = _get_status_emoji(overall_pct)

    var md = "**Overall Status:** {status_emoji}{NL}{NL}"
    md = "{md}- **Total Items:** {total}{NL}"
    md = "{md}- **Documented:** {documented} ({overall_pct}%){NL}"
    md = "{md}- **Missing Docs:** {missing}{NL}"
    md = "{md}- **SDoctest Coverage:** {sdoc_covered}/{sdoc_total} ({sdoc_pct}%){NL}"

    md

fn _generate_scope_breakdown(coverage: CoverageReport) -> text:
    # Group files by scope (src/std/, src/core/, etc.)
    val scopes = _group_by_scope(coverage.files)

    val scope_names = scopes.0
    val scope_files = scopes.1

    var md = "| Scope | Files | Items | Documented | Coverage % |{NL}"
    md = "{md}|-------|-------|-------|------------|-----------|{NL}"

    var i = 0
    while i < scope_names.len():
        val scope_name = scope_names[i]
        val files = scope_files[i]

        # Calculate scope totals
        val totals = _calculate_scope_totals(files)
        val file_count = files.len()
        val total_items = totals.0
        val documented = totals.1
        var coverage_pct = 0

        if total_items > 0:
            coverage_pct = (documented * 100) / total_items

        val status = _get_status_emoji(coverage_pct)

        md = "{md}| {scope_name} {status} | {file_count} | {total_items} | {documented} | {coverage_pct}% |{NL}"

        i = i + 1

    md

fn _generate_top_files_needing_docs(coverage: CoverageReport) -> text:
    # Find files with most missing documentation
    val sorted_files = _sort_files_by_missing_docs(coverage.files)

    var md = "| File | Missing Docs | Total Items | Coverage % |{NL}"
    md = "{md}|------|--------------|-------------|-----------|{NL}"

    var i = 0
    val max_files = 10
    while i < sorted_files.len() and i < max_files:
        val file_cov = sorted_files[i]
        val missing = file_cov.missing_docs

        # Only show files with missing docs
        if missing > 0:
            val file_path = file_cov.file_path
            val total = file_cov.total_items
            val coverage_pct = file_cov.coverage_percent()

            md = "{md}| `{file_path}` | {missing} | {total} | {coverage_pct}% |{NL}"

        i = i + 1

    md

fn _generate_missing_sdoctests(coverage: CoverageReport) -> text:
    # List all public functions missing sdoctests
    var missing_items: [DocItem] = []

    val files = coverage.files
    var i = 0
    while i < files.len():
        val file_cov = files[i]
        val items = file_cov.items

        var j = 0
        while j < items.len():
            val item = items[j]

            # Check if public function without sdoctest
            val needs_test = item.needs_sdoctest()
            val has_test = item.has_sdoctest

            if needs_test and not has_test:
                missing_items.push(item)

            j = j + 1

        i = i + 1

    # Generate table
    var md = "| Function | File | Line |{NL}"
    md = "{md}|----------|------|------|{NL}"

    var k = 0
    val max_items = 50
    while k < missing_items.len() and k < max_items:
        val item = missing_items[k]
        val name = item.name
        val file = item.file
        val line = item.line

        md = "{md}| `{name}` | `{file}` | {line} |{NL}"

        k = k + 1

    # Show count if more items exist
    if missing_items.len() > max_items:
        val remaining = missing_items.len() - max_items
        md = "{md}{NL}*... and {remaining} more functions*{NL}"

    md

# Helper: Get status emoji based on coverage percentage
fn _get_status_emoji(pct: f64) -> text:
    var pct_int = pct
    if pct_int >= 90:
        "✅"
    elif pct_int >= 60:
        "⚠️"
    else:
        "❌"

# Helper: Group files by scope
fn _group_by_scope(files: [FileCoverage]) -> ([text], [[FileCoverage]]):
    var scope_names: [text] = []
    var scope_files_arrays: [[FileCoverage]] = []

    var i = 0
    while i < files.len():
        val file_cov = files[i]
        val scope = _extract_scope(file_cov.file_path)

        # Find existing scope or create new one
        val scope_idx = _find_scope_index(scope_names, scope)

        if scope_idx < 0:
            # New scope
            scope_names.push(scope)
            var new_array: [FileCoverage] = []
            new_array.push(file_cov)
            scope_files_arrays.push(new_array)
        else:
            # Existing scope
            var existing_array = scope_files_arrays[scope_idx]
            existing_array.push(file_cov)
            scope_files_arrays[scope_idx] = existing_array

        i = i + 1

    (scope_names, scope_files_arrays)

fn _extract_scope(file_path: text) -> text:
    # Extract scope from file path
    if file_path.starts_with("src/std/"):
        "src/std"
    elif file_path.starts_with("src/core/"):
        "src/core"
    elif file_path.starts_with("src/lib/"):
        "src/lib"
    elif file_path.starts_with("src/app/"):
        "src/app"
    elif file_path.starts_with("src/compiler/"):
        "src/compiler"
    else:
        "other"

fn _find_scope_index(scope_names: [text], target: text) -> i64:
    var i = 0
    while i < scope_names.len():
        if scope_names[i] == target:
            return i
        i = i + 1
    -1

fn _calculate_scope_totals(files: [FileCoverage]) -> (i64, i64):
    # Returns (total_items, documented_items)
    var total_items = 0
    var documented_items = 0

    var i = 0
    while i < files.len():
        val file_cov = files[i]
        total_items = total_items + file_cov.total_items
        documented_items = documented_items + file_cov.documented_items

        i = i + 1

    (total_items, documented_items)

fn _sort_files_by_missing_docs(files: [FileCoverage]) -> [FileCoverage]:
    # Simple bubble sort by missing_docs count (descending)
    var sorted = files

    var i = 0
    while i < sorted.len():
        var j = i + 1
        while j < sorted.len():
            val a = sorted[i]
            val b = sorted[j]

            if b.missing_docs > a.missing_docs:
                # Swap
                sorted[i] = b
                sorted[j] = a

            j = j + 1

        i = i + 1

    sorted

export generate_coverage_markdown
