# GC Module - Complete Simple Implementation
#
# ✅ GC implemented in Simple (core.spl)
# ✅ Only syscall FFI (malloc/free)
# ❌ NO Rust GC code
#
# Usage:
#   import gc
#   val my_gc = gc.new()
#   val ptr = gc.allocate(my_gc, 1024, type_id)
#   gc.collect(my_gc, "cleanup")

export GC, GCStats, GCConfig
export new, unlimited, with_limit_mb
export allocate, try_allocate, collect
export stats, register_root, unregister_root

use app.gc.core (
    GCCore, GCObject, GCStats, GCConfig,
    gc_create, gc_create_default, gc_create_unlimited,
    gc_allocate, gc_try_allocate, gc_collect, gc_destroy,
    gc_register_unique_root, gc_unregister_unique_root,
    gc_register_shared_root, gc_unregister_shared_root
)

# Re-export types
type GC = GCCore
type Stats = GCStats
type Config = GCConfig

# ============================================================================
# GC Creation (Simple implementation)
# ============================================================================

fn new() -> GC:
    """Create GC with default config.

    Simple implementation - NO Rust!
    """
    gc_create_default()

fn unlimited() -> GC:
    """Create GC with unlimited memory.

    Simple implementation - NO Rust!
    """
    gc_create_unlimited()

fn with_limit_mb(limit_mb: i64) -> GC:
    """Create GC with MB limit.

    Simple implementation - NO Rust!
    """
    val config = GCConfig(
        limit_bytes: limit_mb * 1024 * 1024,
        threshold_bytes: limit_mb * 1024 * 100,  # 10% of limit
        fail_on_exceeded: true,
        enable_logging: false,
        enable_leak_detection: false,
        leak_window_size: 10,
        collection_frequency: 0.5,
        min_heap_bytes: 0
    )
    gc_create(config)

# ============================================================================
# GC Operations (Simple implementation)
# ============================================================================

fn allocate(gc: GC, size: i64, type_id: i64) -> i64:
    """Allocate object.

    Simple implementation - NO Rust!
    """
    gc_allocate(gc, size, type_id)

fn try_allocate(gc: GC, size: i64, type_id: i64) -> i64:
    """Try allocate.

    Simple implementation - NO Rust!
    """
    gc_try_allocate(gc, size, type_id)

fn collect(gc: GC, reason: text) -> i64:
    """Trigger collection.

    Simple implementation - NO Rust!
    """
    gc_collect(gc, reason)

# ============================================================================
# GC Statistics (Simple implementation)
# ============================================================================

fn stats(gc: GC) -> GCStats:
    """Get statistics.

    Simple implementation - NO Rust!
    """
    gc.stats

fn heap_bytes(gc: GC) -> i64:
    """Get heap size."""
    gc.heap_bytes

fn usage_percent(gc: GC) -> f64:
    """Get memory usage percent."""
    if gc.config.limit_bytes == 0:
        return 0.0
    (gc.heap_bytes as f64 / gc.config.limit_bytes as f64) * 100.0

# ============================================================================
# Root Management (Simple implementation)
# ============================================================================

fn register_root(gc: GC, ptr: i64):
    """Register unique root.

    Simple implementation - NO Rust!
    """
    gc_register_unique_root(gc, ptr)

fn unregister_root(gc: GC, ptr: i64):
    """Unregister unique root.

    Simple implementation - NO Rust!
    """
    gc_unregister_unique_root(gc, ptr)

fn register_shared_root(gc: GC, ptr: i64):
    """Register shared root."""
    gc_register_shared_root(gc, ptr)

fn unregister_shared_root(gc: GC, ptr: i64):
    """Unregister shared root."""
    gc_unregister_shared_root(gc, ptr)

# ============================================================================
# ALL LOGIC IN SIMPLE - NO RUST GC CODE!
# ============================================================================
