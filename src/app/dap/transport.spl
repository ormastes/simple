# DAP Transport Layer
# Handles Content-Length protocol over stdin/stdout (same as LSP)

import sys
import io.stdio as stdio
import core.json as json

# Read a DAP message from stdin
# Same Content-Length protocol as LSP
fn read_message() -> Result<Dict, String>:
    # Read headers until we find Content-Length
    var content_length: Option<Int> = None

    loop:
        val line = stdio.read_line()?
        val trimmed = line.trim()

        # Empty line signals end of headers
        if trimmed.is_empty():
            break

        # Parse Content-Length header
        if trimmed.starts_with("Content-Length:"):
            val parts = trimmed.split(":")
            if parts.len() >= 2:
                val length_str = parts[1].trim()
                match length_str.parse_int():
                    case Ok(length):
                        content_length = Some(length)
                    case Err(e):
                        return Err("Invalid Content-Length: {e}")

    # Ensure we got Content-Length
    match content_length:
        case None:
            return Err("Missing Content-Length header")
        case Some(length):
            # Read exactly 'length' bytes of JSON content
            val content = stdio.read_exact(length)?

            # Parse JSON
            match json.parse(content):
                case Ok(parsed):
                    match parsed:
                        case Dict(dict):
                            return Ok(dict)
                        case _:
                            return Err("JSON payload is not an object")
                case Err(e):
                    return Err("JSON parse error: {e}")

# Write a DAP message to stdout
fn write_message(data: Dict) -> Result<Nil, String>:
    # Serialize to JSON
    val json_str = json.stringify(data)?
    val content_bytes = json_str.as_bytes()
    val content_length = content_bytes.len()

    # Build message with headers
    var message = "Content-Length: {content_length}\r\n"
    message = message + "\r\n"
    message = message + json_str

    # Write to stdout
    stdio.write(message)?
    stdio.flush()?

    Ok(nil)

# Write a DAP response
fn write_response(request_seq: Int, success: Bool, command: String, body: Option<Dict>) -> Result<Nil, String>:
    var response = {
        "type": "response",
        "request_seq": request_seq,
        "success": success,
        "command": command,
        "seq": generate_seq()
    }

    match body:
        case Some(b):
            response["body"] = b
        case None:
            pass

    write_message(response)

# Write a DAP event
fn write_event(event: String, body: Dict) -> Result<Nil, String>:
    val event_msg = {
        "type": "event",
        "event": event,
        "seq": generate_seq(),
        "body": body
    }
    write_message(event_msg)

# Global sequence counter
var SEQUENCE_COUNTER = 0

fn generate_seq() -> Int:
    SEQUENCE_COUNTER = SEQUENCE_COUNTER + 1
    SEQUENCE_COUNTER

# Helper: Log a message to stderr for debugging
fn log_debug(message: String):
    match sys.env.get("SIMPLE_DAP_DEBUG"):
        case Some(_):
            stdio.write_stderr("[DAP DEBUG] {message}\n")
        case None:
            pass

# Helper: Log an error to stderr
fn log_error(message: String):
    stdio.write_stderr("[DAP ERROR] {message}\n")

# Parse message type
fn parse_message_type(data: Dict) -> Result<String, String>:
    match data.get("type"):
        case Ok(msg_type):
            Ok(msg_type)
        case Err(_):
            Err("Missing 'type' field in message")
