# DAP Server Implementation
# Handles DAP requests and manages debugging state

import sys
import dap.protocol as protocol
import dap.transport as transport
import dap.breakpoints as breakpoints
import app.dap.hooks.{InterpreterHookContext, StackFrame, Variable, VariableScope, ExecutionState, EvalResult}
import app.debug.remote.backend.RemoteRiscV32Backend
import app.debug.remote.types.DebugConfig
import app.debug.coordinator.{VarInfo, FrameInfo}

# Launch configuration parsed from DAP launch request
class LaunchConfig:
    program: String               # Path to the program to debug
    args: [String]            # Command line arguments
    cwd: Option<String>           # Working directory
    stop_on_entry: Bool           # Stop at program entry
    no_debug: Bool                # Run without debugging

    static fn default() -> LaunchConfig:
        LaunchConfig(
            program: "",
            args: [],
            cwd: nil,
            stop_on_entry: true,
            no_debug: false
        )

    static fn from_json(args: Dict) -> LaunchConfig:
        var config = LaunchConfig__default()

        # Parse program path (required)
        match args.get("program"):
            Some(p):
                config.program = p
            nil:
                pass

        # Parse arguments (optional)
        match args.get("args"):
            Some(a):
                config.args = a
            nil:
                pass

        # Parse working directory (optional)
        match args.get("cwd"):
            Some(c):
                config.cwd = Some(c)
            nil:
                pass

        # Parse stopOnEntry (optional, default true)
        match args.get("stopOnEntry"):
            Some(s):
                config.stop_on_entry = s
            nil:
                pass

        # Parse noDebug (optional, default false)
        match args.get("noDebug"):
            Some(n):
                config.no_debug = n
            nil:
                pass

        config

# Debug context capturing interpreter state
class DebugContext:
    source_path: String           # Current source file
    current_line: Int             # Current line number
    current_column: Int           # Current column
    call_stack: [StackEntry]  # Call stack frames
    local_variables: Dict<String, VariableInfo>   # Local scope variables
    global_variables: Dict<String, VariableInfo>  # Global scope variables

    static fn new() -> DebugContext:
        DebugContext(
            source_path: "",
            current_line: 1,
            current_column: 0,
            call_stack: [],
            local_variables: {},
            global_variables: {}
        )

# Stack entry for call stack
class StackEntry:
    name: String                  # Function/method name
    source_path: String           # Source file path
    line: Int                     # Line number
    column: Int                   # Column number

    fn new(name: String, source_path: String, line: Int, column: Int) -> StackEntry:
        StackEntry(name: name, source_path: source_path, line: line, column: column)

# Variable info for inspection
class VariableInfo:
    name: String
    value: String
    type_name: String
    variables_reference: Int      # Non-zero if this variable has children

    fn new(name: String, value: String, type_name: String) -> VariableInfo:
        VariableInfo(name: name, value: value, type_name: type_name, variables_reference: 0)

    fn with_children(variables_reference: Int) -> VariableInfo:
        VariableInfo(
            name: self.name,
            value: self.value,
            type_name: self.type_name,
            variables_reference: variables_reference
        )

# Debugger state
enum DebuggerState:
    Uninitialized
    Initialized
    Launched
    Running
    Stopped
    Terminated

# DAP Server
class DapServer:
    state: DebuggerState
    breakpoint_manager: breakpoints.BreakpointManager
    current_thread_id: Int
    current_frame_id: Int
    stop_reason: Option<protocol.StopReason>
    launch_config: LaunchConfig
    debug_context: DebugContext
    step_mode: Option<StepMode>   # Current stepping mode
    hook_context: InterpreterHookContext   # Interpreter hook context for debugging
    remote_backend: Option<RemoteRiscV32Backend>  # Remote debug backend (GDB/Trace32)
    data_breakpoints: [Dict]         # Active data breakpoints/watchpoints
    next_data_breakpoint_id: Int
    max_data_breakpoints: Int        # Runtime capacity policy (host vs bare-metal)

    static fn new() -> DapServer:
        DapServer(
            state: DebuggerState.Uninitialized,
            breakpoint_manager: breakpoints.BreakpointManager__new(),
            current_thread_id: 1,
            current_frame_id: 1,
            stop_reason: nil,
            launch_config: LaunchConfig__default(),
            debug_context: DebugContext__new(),
            step_mode: nil,
            hook_context: InterpreterHookContext__create(),
            remote_backend: nil,
            data_breakpoints: [],
            next_data_breakpoint_id: 1,
            max_data_breakpoints: 1024
        )

    # Create a DAP server with a remote backend
    static fn with_remote(backend: RemoteRiscV32Backend) -> DapServer:
        DapServer(
            state: DebuggerState.Uninitialized,
            breakpoint_manager: breakpoints.BreakpointManager__new(),
            current_thread_id: 1,
            current_frame_id: 1,
            stop_reason: nil,
            launch_config: LaunchConfig__default(),
            debug_context: DebugContext__new(),
            step_mode: nil,
            hook_context: InterpreterHookContext__create(),
            remote_backend: Some(backend),
            data_breakpoints: [],
            next_data_breakpoint_id: 1,
            max_data_breakpoints: 1
        )

    # Create a DAP server with a Trace32 backend
    static fn with_trace32(config: DebugConfig) -> Result<DapServer, String>:
        val backend = RemoteRiscV32Backend.trace32_only(config)?
        Ok(DapServer(
            state: DebuggerState.Uninitialized,
            breakpoint_manager: breakpoints.BreakpointManager__new(),
            current_thread_id: 1,
            current_frame_id: 1,
            stop_reason: nil,
            launch_config: LaunchConfig__default(),
            debug_context: DebugContext__new(),
            step_mode: nil,
            hook_context: InterpreterHookContext__create(),
            remote_backend: Some(backend),
            data_breakpoints: [],
            next_data_breakpoint_id: 1,
            max_data_breakpoints: 1
        ))

# Step mode for stepping commands
enum StepMode:
    StepOver    # Next line in current function
    StepIn      # Step into function calls
    StepOut     # Step out of current function

impl DapServer:
    fn handle_initialize(request_seq: Int, command: String, arguments: Option<Dict>) -> Result<Nil, String>:
        transport.log_debug("Handling initialize request")

        # Update state
        self.state = DebuggerState.Initialized

        # Build capabilities
        val capabilities = protocol.Capabilities__default()

        # Send response
        transport.write_response(request_seq, true, command, Some(capabilities))?

        # Send initialized event
        transport.write_event("initialized", {})?

        Ok(nil)
    fn handle_launch(request_seq: Int, command: String, arguments: Option<Dict>) -> Result<Nil, String>:
        transport.log_debug("Handling launch request")

        # Parse launch configuration
        match arguments:
            Some(args):
                self.launch_config = LaunchConfig__from_json(args)
                transport.log_debug("Launching program: {self.launch_config.program}")
                transport.log_debug("Arguments: {self.launch_config.args}")
                transport.log_debug("Stop on entry: {self.launch_config.stop_on_entry}")

                # Initialize debug context with source path
                self.debug_context.source_path = self.launch_config.program
                # Watchpoint policy:
                # - Host/interpreter mode: effectively unbounded software watchpoints.
                # - Bare-metal/remote mode: conservative default 1 slot because HW slots
                #   can be shared with loader/scripts and may be unavailable.
                match self.remote_backend:
                    Some(_):
                        self.max_data_breakpoints = 1
                    nil:
                        self.max_data_breakpoints = 1024
            nil:
                transport.log_debug("No launch arguments provided")

        # Enable debugging in hook context
        self.hook_context.enable()

        # Update state
        self.state = DebuggerState.Launched

        # Send response
        transport.write_response(request_seq, true, command, nil)?

        Ok(nil)
    fn handle_configuration_done(request_seq: Int, command: String) -> Result<Nil, String>:
        transport.log_debug("Handling configurationDone request")

        # Send response
        transport.write_response(request_seq, true, command, nil)?

        # Update state to running
        self.state = DebuggerState.Running

        # Check if we should stop on entry
        if self.launch_config.stop_on_entry:
            # Initialize stack with entry frame
            val entry_frame = StackEntry__new(
                "main",
                self.launch_config.program,
                1,
                0
            )
            self.debug_context.call_stack = [entry_frame]
            self.debug_context.current_line = 1

            # Send stopped event at entry point
            self.send_stopped_event(protocol.StopReason.Entry)?
        else:
            # Start execution without stopping
            # NOTE: Interpreter integration needed for actual execution
            transport.log_debug("Starting execution without stopping on entry")

        Ok(nil)
    fn handle_set_breakpoints(request_seq: Int, command: String, arguments: Option<Dict>) -> Result<Nil, String>:
        match arguments:
            case nil:
                return Err("Missing arguments for setBreakpoints")
            case Some(args):
                # Extract source
                val source_data = args.get("source")?
                val source_path = source_data.get("path")?

                # Extract breakpoints
                val breakpoints_data = args.get("breakpoints")?
                var source_breakpoints = []

                for bp_data in breakpoints_data:
                    val source_bp = protocol.SourceBreakpoint__from_json(bp_data)?
                    source_breakpoints.push(source_bp)

                # Set breakpoints using hook context
                var protocol_breakpoints = []
                for source_bp in source_breakpoints:
                    # Add breakpoint to hook context
                    val bp_id = self.hook_context.add_breakpoint_with_options(
                        file: source_path,
                        line: source_bp.line,
                        condition: source_bp.condition,
                        hit_condition: source_bp.hit_condition,
                        log_message: source_bp.log_message,
                    )

                    # Create protocol breakpoint response
                    val protocol_bp = {
                        "id": bp_id.id,
                        "verified": true,
                        "line": source_bp.line,
                        "source": {
                            "path": source_path
                        }
                    }
                    protocol_breakpoints.push(protocol_bp)

                val body = {
                    "breakpoints": protocol_breakpoints
                }

                transport.log_debug("Set {protocol_breakpoints.len()} breakpoints in {source_path}")

                # Send response
                transport.write_response(request_seq, true, command, Some(body))?

                Ok(nil)
    fn handle_threads(request_seq: Int, command: String) -> Result<Nil, String>:
        # Return single main thread
        val thread = protocol.Thread__new(self.current_thread_id, "Main Thread")

        val body = {
            "threads": [thread.to_json()]
        }

        transport.write_response(request_seq, true, command, Some(body))?

        Ok(nil)
    fn handle_stack_trace(request_seq: Int, command: String, arguments: Option<Dict>) -> Result<Nil, String>:
        var stack_frames: [Dict] = []
        var frame_id = self.current_frame_id

        # Check remote backend first
        match self.remote_backend:
            Some(backend):
                val remote_frames = backend.stack_trace()
                match remote_frames:
                    Ok(frames):
                        for f in frames:
                            val protocol_frame = protocol.StackFrame__new(
                                frame_id,
                                f.function_name,
                                f.line,
                                f.column
                            ).with_source(f.file)
                            stack_frames.push(protocol_frame.to_json())
                            frame_id = frame_id + 1
                    Err(_):
                        pass
            nil:
                # Get stack frames from hook context
                val frames = self.hook_context.stack_frames()
                for frame in frames:
                    val protocol_frame = protocol.StackFrame__new(
                        frame_id,
                        frame.name,
                        frame.line,
                        frame.column
                    ).with_source(frame.file)
                    stack_frames.push(protocol_frame.to_json())
                    frame_id = frame_id + 1

        # Fallback if no frames
        if stack_frames.len() == 0:
            val frame = protocol.StackFrame__new(
                frame_id,
                "main",
                1,
                0
            ).with_source(self.debug_context.source_path)
            stack_frames.push(frame.to_json())

        val body = {
            "stackFrames": stack_frames,
            "totalFrames": stack_frames.len()
        }

        transport.write_response(request_seq, true, command, Some(body))?

        Ok(nil)
    fn handle_scopes(request_seq: Int, command: String, arguments: Option<Dict>) -> Result<Nil, String>:
        # Return local and global scopes
        val local_scope = protocol.Scope__new("Local", 1)
        val global_scope = protocol.Scope__new("Global", 2)

        var scopes = [
            local_scope.to_json(),
            global_scope.to_json()
        ]

        # Add Registers scope for remote targets
        match self.remote_backend:
            Some(_):
                val register_scope = protocol.Scope__new("Registers", 3)
                scopes.push(register_scope.to_json())
            nil:
                pass

        val body = {
            "scopes": scopes
        }

        transport.write_response(request_seq, true, command, Some(body))?

        Ok(nil)
    fn handle_variables(request_seq: Int, command: String, arguments: Option<Dict>) -> Result<Nil, String>:
        match arguments:
            nil:
                return Err("Missing arguments for variables")
            Some(args):
                val variables_reference = args.get("variablesReference")?

                var variables: [Dict] = []

                # Variables reference 1 = local scope, 2 = global scope, 3 = registers (remote)
                if variables_reference == 1:
                    # Check remote backend first
                    match self.remote_backend:
                        Some(backend):
                            val remote_vars = backend.locals()
                            match remote_vars:
                                Ok(vars):
                                    for v in vars:
                                        val protocol_var = protocol.Variable__new(v.name, v.value).with_type(v.type_name)
                                        variables.push(protocol_var.to_json())
                                Err(_):
                                    pass
                        nil:
                            # Get local variables from hook context (frame 0 = current frame)
                            val vars = self.hook_context.variables_in_scope(0, VariableScope.Local)
                            for v in vars:
                                val protocol_var = protocol.Variable__new(v.name, v.value).with_type(v.type)
                                variables.push(protocol_var.to_json())

                    # Placeholder if no variables
                    if variables.len() == 0:
                        val placeholder = protocol.Variable__new(
                            "(no local variables)",
                            ""
                        ).with_type("")
                        variables.push(placeholder.to_json())

                elif variables_reference == 2:
                    # Check remote backend first
                    match self.remote_backend:
                        Some(backend):
                            val remote_vars = backend.read_arguments()
                            match remote_vars:
                                Ok(vars):
                                    for v in vars:
                                        val protocol_var = protocol.Variable__new(v.name, v.value).with_type(v.type_name)
                                        variables.push(protocol_var.to_json())
                                Err(_):
                                    pass
                        nil:
                            # Get global variables from hook context
                            val vars = self.hook_context.variables_in_scope(0, VariableScope.Global)
                            for v in vars:
                                val protocol_var = protocol.Variable__new(v.name, v.value).with_type(v.type)
                                variables.push(protocol_var.to_json())

                    # Placeholder if no variables
                    if variables.len() == 0:
                        val placeholder = protocol.Variable__new(
                            "(no global variables)",
                            ""
                        ).with_type("")
                        variables.push(placeholder.to_json())

                elif variables_reference == 3:
                    # Register scope (remote targets only)
                    match self.remote_backend:
                        Some(backend):
                            val regs_result = backend.read_all_registers()
                            match regs_result:
                                Ok(regs):
                                    for name in regs.keys():
                                        val value = "0x{regs[name]}"
                                        val protocol_var = protocol.Variable__new(name, value).with_type("u32")
                                        variables.push(protocol_var.to_json())
                                Err(_):
                                    val placeholder = protocol.Variable__new(
                                        "(registers unavailable)",
                                        ""
                                    ).with_type("")
                                    variables.push(placeholder.to_json())
                        nil:
                            pass

                else:
                    # Nested variable inspection (for objects, arrays, structs)
                    match self.remote_backend:
                        Some(backend):
                            # Use GDB variable objects for recursive expansion
                            match backend.gdb:
                                Some(gdb):
                                    val children = gdb.list_children("{variables_reference}")
                                    match children:
                                        Ok(child_list):
                                            for child in child_list:
                                                var pvar = protocol.Variable__new(child.name, child.value).with_type(child.type_name)
                                                if child.num_children > 0:
                                                    pvar = pvar.with_children(child.name.hash())
                                                variables.push(pvar.to_json())
                                        Err(_):
                                            pass
                                nil:
                                    pass
                        nil:
                            pass

                val body = {
                    "variables": variables
                }

                transport.write_response(request_seq, true, command, Some(body))?

                Ok(nil)
    fn handle_continue(request_seq: Int, command: String, arguments: Option<Dict>) -> Result<Nil, String>:
        transport.log_debug("Handling continue request")

        # Continue execution via hook context
        self.hook_context.continue()
        self.step_mode = nil

        # Update state
        self.state = DebuggerState.Running

        val body = {
            "allThreadsContinued": true
        }

        transport.write_response(request_seq, true, command, Some(body))?

        # NOTE: When interpreter integration is complete, this will:
        # 1. Resume interpreter execution
        # 2. Check breakpoints at each step
        # 3. Stop when a breakpoint is hit or program terminates
        self.execute_until_stop()?

        Ok(nil)
    fn handle_pause(request_seq: Int, command: String, arguments: Option<Dict>) -> Result<Nil, String>:
        transport.log_debug("Handling pause request")

        # Pause execution via hook context
        self.hook_context.pause()

        # Send response
        transport.write_response(request_seq, true, command, nil)?

        # Send stopped event
        self.send_stopped_event(protocol.StopReason.Pause)?

        Ok(nil)
    fn handle_next(request_seq: Int, command: String, arguments: Option<Dict>) -> Result<Nil, String>:
        transport.log_debug("Handling next (step over) request")

        # Step over via hook context
        self.hook_context.step_over()
        self.step_mode = Some(StepMode.StepOver)

        # Send response
        transport.write_response(request_seq, true, command, nil)?

        Ok(nil)
    fn handle_step_in(request_seq: Int, command: String, arguments: Option<Dict>) -> Result<Nil, String>:
        transport.log_debug("Handling stepIn request")

        # Step into via hook context
        self.hook_context.step_into()
        self.step_mode = Some(StepMode.StepIn)

        transport.write_response(request_seq, true, command, nil)?

        Ok(nil)
    fn handle_step_out(request_seq: Int, command: String, arguments: Option<Dict>) -> Result<Nil, String>:
        transport.log_debug("Handling stepOut request")

        # Step out via hook context
        self.hook_context.step_out()
        self.step_mode = Some(StepMode.StepOut)

        transport.write_response(request_seq, true, command, nil)?

        Ok(nil)
    fn lookup_data_breakpoint_value(name: String) -> Option<String>:
        # Prefer in-memory debug context values if available.
        match self.debug_context.local_variables.get(name):
            Some(v):
                return Some(v.value)
            nil:
                pass
        match self.debug_context.global_variables.get(name):
            Some(v):
                return Some(v.value)
            nil:
                pass

        # Fallback to hook context scope snapshots.
        val local_vars = self.hook_context.variables_in_scope(0, VariableScope.Local)
        for v in local_vars:
            if v.name == name:
                return Some(v.value)
        val global_vars = self.hook_context.variables_in_scope(0, VariableScope.Global)
        for v in global_vars:
            if v.name == name:
                return Some(v.value)

        nil
    fn check_runtime_data_breakpoints() -> Bool:
        var hit = false
        var updated: [Dict] = []
        for dbp in self.data_breakpoints:
            var nd = dbp
            val access = nd.get("accessType") ?? "write"
            val data_id = nd.get("dataId") ?? ""
            if access == "read":
                updated.push(nd)
                continue

            if data_id == "":
                updated.push(nd)
                continue

            match self.lookup_data_breakpoint_value(data_id):
                Some(current_value):
                    val prev_value = nd.get("lastValue") ?? ""
                    if prev_value == "":
                        nd["lastValue"] = current_value
                    elif prev_value != current_value:
                        nd["lastValue"] = current_value
                        val prev_hits = nd.get("hitCount") ?? 0
                        nd["hitCount"] = prev_hits + 1
                        hit = true
                nil:
                    pass
            updated.push(nd)

        self.data_breakpoints = updated
        hit
    fn execute_until_stop() -> Result<Nil, String>:
        # NOTE: This is the interpreter integration point
        # When connected to the interpreter, this will:
        # 1. Run the interpreter in a loop
        # 2. Before each statement, check for breakpoints
        # 3. If breakpoint hit, update debug context and send stopped event
        # 4. If program terminates, send terminated event

        # For now, simulate stopping at the next line
        self.debug_context.current_line = self.debug_context.current_line + 1

        # Runtime data breakpoint check (variable-change watchpoints).
        if self.check_runtime_data_breakpoints():
            self.send_stopped_event(protocol.StopReason.DataBreakpoint)?
            return Ok(nil)

        # Check if we hit a breakpoint
        match self.breakpoint_manager.should_stop_at_line(
            self.debug_context.source_path,
            self.debug_context.current_line
        ):
            Some(bp):
                # Hit a breakpoint
                self.breakpoint_manager.increment_hit_count(bp.id)
                self.send_stopped_event(protocol.StopReason.Breakpoint)?
            nil:
                # No breakpoint - in a real implementation, continue execution
                # For now, just stop (simulating end of program or next statement)
                self.send_stopped_event(protocol.StopReason.Step)?

        Ok(nil)
    fn execute_step() -> Result<Nil, String>:
        # NOTE: This is the interpreter integration point
        # When connected to the interpreter, this will:
        # - StepOver: Execute one statement, skipping into function calls
        # - StepIn: Execute one statement, entering function calls
        # - StepOut: Execute until current function returns

        match self.step_mode:
            Some(StepMode.StepOver):
                # Step to next line in current function
                self.debug_context.current_line = self.debug_context.current_line + 1

            Some(StepMode.StepIn):
                # Step into function call (or next line if no call)
                # For now, same as step over
                self.debug_context.current_line = self.debug_context.current_line + 1

            Some(StepMode.StepOut):
                # Step out of current function
                # For now, pop stack and advance line
                if self.debug_context.call_stack.len() > 1:
                    self.debug_context.call_stack.pop()
                    # Update line to caller
                    match self.debug_context.call_stack.last():
                        Some(frame):
                            self.debug_context.current_line = frame.line + 1
                        nil:
                            self.debug_context.current_line = self.debug_context.current_line + 1
                else:
                    self.debug_context.current_line = self.debug_context.current_line + 1

            nil:
                # No step mode, just advance
                self.debug_context.current_line = self.debug_context.current_line + 1

        # Update call stack with new position
        if self.debug_context.call_stack.len() > 0:
            match self.debug_context.call_stack.last_mut():
                Some(frame):
                    frame.line = self.debug_context.current_line
                nil:
                    pass

        # Runtime data breakpoint check (variable-change watchpoints).
        if self.check_runtime_data_breakpoints():
            self.send_stopped_event(protocol.StopReason.DataBreakpoint)?
            return Ok(nil)

        # Send stopped event
        self.send_stopped_event(protocol.StopReason.Step)?

        Ok(nil)
    fn handle_evaluate(request_seq: Int, command: String, arguments: Option<Dict>) -> Result<Nil, String>:
        match arguments:
            nil:
                return Err("Missing arguments for evaluate")
            Some(args):
                val expression = args.get("expression")?

                var result_value = ""
                var result_type = ""

                match self.remote_backend:
                    Some(backend):
                        val eval_result = backend.evaluate(expression)
                        match eval_result:
                            Ok(value):
                                result_value = value
                            Err(e):
                                result_value = "<error: {e}>"
                    nil:
                        # Use hook context for local evaluation
                        result_value = "<evaluation not available>"

                val body = {
                    "result": result_value,
                    "variablesReference": 0
                }

                transport.write_response(request_seq, true, command, Some(body))?
                Ok(nil)
    fn handle_disconnect(request_seq: Int, command: String, arguments: Option<Dict>) -> Result<Nil, String>:
        transport.log_debug("Handling disconnect request")

        # Update state
        self.state = DebuggerState.Terminated

        # Send response
        transport.write_response(request_seq, true, command, nil)?

        # Send terminated event
        transport.write_event("terminated", {})?

        Ok(nil)
    fn handle_data_breakpoint_info(request_seq: Int, command: String, arguments: Option<Dict>) -> Result<Nil, String>:
        var name = ""
        match arguments:
            Some(args):
                match args.get_optional("name"):
                    Some(n):
                        name = n
                    nil:
                        pass
            nil:
                pass

        var data_id = name
        if data_id == "":
            data_id = "watch_expr"

        val body = {
            "dataId": data_id,
            "description": "Break when value changes: {data_id}",
            "accessTypes": ["read", "write", "readWrite"],
            "canPersist": true
        }
        transport.write_response(request_seq, true, command, Some(body))?
        Ok(nil)
    fn handle_set_data_breakpoints(request_seq: Int, command: String, arguments: Option<Dict>) -> Result<Nil, String>:
        match arguments:
            nil:
                return Err("Missing arguments for setDataBreakpoints")
            Some(args):
                val requested = args.get("breakpoints")?
                self.data_breakpoints = []
                var response_breakpoints = []
                var applied = 0
                var limit = self.max_data_breakpoints
                if limit < 1:
                    limit = 1

                match self.remote_backend:
                    Some(backend):
                        val cap = backend.watchpoint_capacity()
                        if cap > 0:
                            limit = cap
                    nil:
                        pass

                for bp_data in requested:
                    var data_id = ""
                    var access_type = "write"
                    var condition = ""
                    var hit_condition = ""

                    match bp_data.get_optional("dataId"):
                        Some(v):
                            data_id = v
                        nil:
                            pass
                    if data_id == "":
                        match bp_data.get_optional("expression"):
                            Some(v):
                                data_id = v
                            nil:
                                pass
                    if data_id == "":
                        data_id = "watch_{self.next_data_breakpoint_id}"

                    match bp_data.get_optional("accessType"):
                        Some(v):
                            access_type = v
                        nil:
                            pass
                    match bp_data.get_optional("condition"):
                        Some(v):
                            condition = v
                        nil:
                            pass
                    match bp_data.get_optional("hitCondition"):
                        Some(v):
                            hit_condition = v
                        nil:
                            pass

                    if applied >= limit:
                        val out_bp = {
                            "verified": false,
                            "message": "data breakpoint capacity reached (limit={limit})"
                        }
                        response_breakpoints.push(out_bp)
                    else:
                        var remote_ok = true
                        var remote_error = ""
                        match self.remote_backend:
                            Some(backend):
                                val set_result = backend.set_watchpoint(data_id, access_type)
                                match set_result:
                                    Ok(_):
                                        remote_ok = true
                                    Err(e):
                                        remote_ok = false
                                        remote_error = e
                            nil:
                                pass

                        if not remote_ok:
                            val out_bp = {
                                "verified": false,
                                "message": "failed to set target watchpoint: {remote_error}"
                            }
                            response_breakpoints.push(out_bp)
                        else:
                            val dbp_id = self.next_data_breakpoint_id
                            self.next_data_breakpoint_id = self.next_data_breakpoint_id + 1
                            val stored = {
                                "id": dbp_id,
                                "dataId": data_id,
                                "accessType": access_type,
                                "condition": condition,
                                "hitCondition": hit_condition,
                                "hitCount": 0
                            }
                            self.data_breakpoints.push(stored)
                            applied = applied + 1

                            val out_bp = {
                                "id": dbp_id,
                                "verified": true
                            }
                            response_breakpoints.push(out_bp)

                val body = {
                    "breakpoints": response_breakpoints
                }
                transport.write_response(request_seq, true, command, Some(body))?
                Ok(nil)
    fn handle_set_variable(request_seq: Int, command: String, arguments: Option<Dict>) -> Result<Nil, String>:
        match arguments:
            nil:
                return Err("Missing arguments for setVariable")
            Some(args):
                val variables_reference = args.get("variablesReference")?
                val name = args.get("name")?
                val value = args.get("value")?

                var old_value = ""
                if variables_reference == 2:
                    match self.debug_context.global_variables.get(name):
                        Some(v):
                            old_value = v.value
                        nil:
                            pass
                    self.debug_context.global_variables[name] = VariableInfo__new(name, value, "string")
                else:
                    match self.debug_context.local_variables.get(name):
                        Some(v):
                            old_value = v.value
                        nil:
                            pass
                    self.debug_context.local_variables[name] = VariableInfo__new(name, value, "string")

                val body = {
                    "value": value,
                    "type": "string",
                    "variablesReference": 0
                }
                transport.write_response(request_seq, true, command, Some(body))?

                # If the value changed and a data breakpoint targets this variable,
                # emit a stopped event with data breakpoint reason.
                if old_value != value:
                    var should_stop = false
                    for dbp in self.data_breakpoints:
                        val data_id = dbp["dataId"]
                        val access = dbp["accessType"]
                        if data_id == name:
                            if access == "write" or access == "readWrite" or access == "readwrite":
                                should_stop = true
                    if should_stop:
                        self.send_stopped_event(protocol.StopReason.DataBreakpoint)?

                Ok(nil)
    fn send_stopped_event(reason: protocol.StopReason) -> Result<Nil, String>:
        self.state = DebuggerState.Stopped
        self.stop_reason = Some(reason)

        val body = {
            "reason": reason.to_string(),
            "threadId": self.current_thread_id,
            "allThreadsStopped": true
        }

        transport.write_event("stopped", body)?

        Ok(nil)
    fn handle_request(request: protocol.DapRequest) -> Result<Nil, String>:
        match request.command:
            case "initialize":
                self.handle_initialize(request.id, request.command, request.arguments)
            case "launch":
                self.handle_launch(request.id, request.command, request.arguments)
            case "configurationDone":
                self.handle_configuration_done(request.id, request.command)
            case "setBreakpoints":
                self.handle_set_breakpoints(request.id, request.command, request.arguments)
            case "dataBreakpointInfo":
                self.handle_data_breakpoint_info(request.id, request.command, request.arguments)
            case "setDataBreakpoints":
                self.handle_set_data_breakpoints(request.id, request.command, request.arguments)
            case "threads":
                self.handle_threads(request.id, request.command)
            case "stackTrace":
                self.handle_stack_trace(request.id, request.command, request.arguments)
            case "scopes":
                self.handle_scopes(request.id, request.command, request.arguments)
            case "variables":
                self.handle_variables(request.id, request.command, request.arguments)
            case "continue":
                self.handle_continue(request.id, request.command, request.arguments)
            case "pause":
                self.handle_pause(request.id, request.command, request.arguments)
            case "next":
                self.handle_next(request.id, request.command, request.arguments)
            case "stepIn":
                self.handle_step_in(request.id, request.command, request.arguments)
            case "stepOut":
                self.handle_step_out(request.id, request.command, request.arguments)
            case "evaluate":
                self.handle_evaluate(request.id, request.command, request.arguments)
            case "setVariable":
                self.handle_set_variable(request.id, request.command, request.arguments)
            case "disconnect":
                self.handle_disconnect(request.id, request.command, request.arguments)
            case _:
                # Unknown command
                transport.log_error("Unknown command: {request.command}")
                transport.write_response(request.id, false, request.command, nil)?
                Ok(nil)
    fn run() -> Result<Nil, String>:
        transport.log_debug("DAP server starting")

        loop:
            # Check if terminated
            match self.state:
                case Terminated:
                    transport.log_debug("Server terminated")
                    return Ok(nil)
                case _:
                    pass

            # Read next message
            val message = match transport.read_message():
                case Ok(msg):
                    msg
                case Err(e):
                    transport.log_debug("Read error: {e}")
                    return Ok(nil)

            # Parse message type
            val msg_type = transport.parse_message_type(message)?

            # Only handle requests (DAP doesn't use notifications from client)
            if msg_type == "request":
                val request = protocol.DapRequest__from_json(message)?
                self.handle_request(request)?

        Ok(nil)
