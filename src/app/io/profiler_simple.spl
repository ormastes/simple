#!/usr/bin/env simple
# Profiler SFFI Wrapper - Using Existing Runtime Functions
#
# This version uses the EXISTING rt_profiler_* functions in the runtime.
# No Rust changes needed - works immediately!
#
# Provides call/return profiling for performance analysis.

# ============================================================================
# Tier 1: Extern Declarations (Existing Runtime Functions)
# ============================================================================

# These functions ALREADY EXIST in the runtime!
extern fn rt_profiler_record_call(function_name: text, file: text, line: i64)
extern fn rt_profiler_record_return(function_name: text, file: text, line: i64)
extern fn rt_profiler_is_active() -> bool

# ============================================================================
# Tier 2: Simple-Friendly Wrapper Functions
# ============================================================================

# --- Profiler State ---

fn profiler_active() -> bool:
    """Check if profiler is active

    Returns: true if profiling is enabled

    Example:
        if profiler_active():
            print "Profiler is running"
    """
    rt_profiler_is_active()

# --- Manual Profiling ---

fn profiler_call(function_name: text, file: text, line: i64):
    """Record function call entry

    Args:
        function_name: Name of function being called
        file: Source file path
        line: Line number of call

    Example:
        fn my_function():
            profiler_call("my_function", "test.spl", 10)
            do_work()
            profiler_return("my_function", "test.spl", 15)
    """
    rt_profiler_record_call(function_name, file, line)

fn profiler_return(function_name: text, file: text, line: i64):
    """Record function return exit

    Args:
        function_name: Name of function returning
        file: Source file path
        line: Line number of return

    Example:
        fn my_function():
            profiler_call("my_function", "test.spl", 10)
            val result = compute()
            profiler_return("my_function", "test.spl", 12)
            result
    """
    rt_profiler_record_return(function_name, file, line)

# --- High-Level Profiling ---

fn profile_function<T>(name: text, file: text, line: i64, block: fn() -> T) -> T:
    """Profile a function/block execution

    Automatically records call/return around block execution.

    Args:
        name: Function/block name
        file: Source file path
        line: Starting line number
        block: Code to profile

    Returns: Result of block execution

    Example:
        val result = profile_function("compute", "test.spl", 20, \:
            expensive_computation()
        )
    """
    profiler_call(name, file, line)
    val result = block()
    profiler_return(name, file, line)
    result

# --- Timing Helpers ---

struct ProfileTimer:
    name: text
    file: text
    start_line: i64
    started: bool

fn timer_start(name: text, file: text, line: i64) -> ProfileTimer:
    """Start a profiling timer

    Args:
        name: Timer name
        file: Source file path
        line: Line number

    Returns: ProfileTimer handle

    Example:
        val timer = timer_start("database_query", "db.spl", 100)
        execute_query()
        timer_end(timer, 105)
    """
    profiler_call(name, file, line)
    ProfileTimer(name: name, file: file, start_line: line, started: true)

fn timer_end(timer: ProfileTimer, end_line: i64):
    """End a profiling timer

    Args:
        timer: Timer started with timer_start()
        end_line: Line number where timer ends

    Example:
        val timer = timer_start("request", "api.spl", 50)
        handle_request()
        timer_end(timer, 60)
    """
    if timer.started:
        profiler_return(timer.name, timer.file, end_line)

# --- Profiling Macros (Manual Instrumentation) ---

fn profile_begin(name: text):
    """Begin profiling a named section

    Simplified version without file/line tracking.

    Args:
        name: Section name

    Example:
        profile_begin("initialization")
        initialize_system()
        profile_end("initialization")
    """
    profiler_call(name, "", 0)

fn profile_end(name: text):
    """End profiling a named section

    Args:
        name: Section name (must match profile_begin)

    Example:
        profile_begin("processing")
        process_data()
        profile_end("processing")
    """
    profiler_return(name, "", 0)

# --- Scoped Profiling ---

fn with_profiling<T>(name: text, block: fn() -> T) -> T:
    """Run code block with profiling

    Automatically profiles the block execution.

    Args:
        name: Profile section name
        block: Code to profile

    Returns: Result of block execution

    Example:
        val result = with_profiling("calculation", \:
            compute_result()
        )
    """
    profile_begin(name)
    val result = block()
    profile_end(name)
    result

# ============================================================================
# Export Functions
# ============================================================================

export profiler_active
export profiler_call, profiler_return
export profile_function, profile_begin, profile_end, with_profiling
export ProfileTimer, timer_start, timer_end
