# CLI Compile Functions - Compilation pipeline
# Extracted from cli_ops.spl for modularity
# Functions here reference helpers in cli_ops.spl (same directory, no imports needed)

# Helpers from cli_ops.spl
use app.io.cli_ops.{rt_env_get, _cli_eprint, _cli_dir_create_impl, _cli_file_write_impl, _cli_file_copy_impl, _cli_process_run, _cli_shell, _cli_shell_bool, _cli_file_exists_impl, _cli_file_read_impl}

# Pure Simple compiler driver (use desugared static methods for interpreter compatibility)
use compiler.driver.driver.{CompilerDriver, CompilerDriver__create, CompilerDriver__run_compile, aot_file, aot_c_file, aot_vhdl_file, compile_to_smf}
use app.compile.native.{compile_native}
use compiler.driver.driver_types.{CompileOptions, CompileOptions__default, CompileMode, CompileResult, OutputFormat}

extern fn rt_compile_to_llvm_ir(source_file: text, target_triple: text, bare_metal: bool) -> (text, text, i64)

# Pure Simple compiler implementation (no Rust FFI dependency)
fn cli_compile_pure_simple(source_file: text, output_file: text, output_format: text, backend: text, verbose: bool, release: bool) -> i64:
    var out = output_file
    if out == "":
        # Default output based on format
        if output_format == "smf":
            out = source_file.replace(".spl", ".smf")
        else:
            out = "a.out"

    if verbose:
        _cli_eprint("[Pure Simple Compiler] Compiling {source_file} -> {out}")

    # Use the Pure Simple compiler driver directly
    # (use desugared __default/__create for interpreter compatibility)
    var options = CompileOptions__default()
    options.input_files = [source_file]
    options.output_file = out
    options.verbose = verbose
    if release:
        options.release = true
        options.optimize = true
    if backend != "" and backend != "auto":
        options.backend = backend

    val driver = CompilerDriver__create(options)
    val result = CompilerDriver__run_compile(driver)

    match result:
        case CompileResult.Success(_):
            if verbose:
                _cli_eprint("[Pure Simple Compiler] Compilation successful: {out}")
            return 0
        case _:
            val errors = result.get_errors()
            if errors.len() > 0:
                for err in errors:
                    _cli_eprint("error: {err}")
            else:
                _cli_eprint("error: Compilation failed")
            return 1

fn cli_compile(args: [str]) -> i64:
    _cli_eprint("[cli_compile] args = {args}")

    var source_file: text = ""
    var output_file: text = ""
    var target: text = ""
    var emit: text = "elf"
    var output_format: text = ""
    var backend: text = "auto"
    var verbose: bool = false
    var release: bool = false
    var use_lto: bool = false
    var march_target: text = ""
    var pgo_generate: bool = false
    var pgo_use_path: text = ""
    var release_optimized: bool = false
    var emit_c: bool = false

    var i = 0
    if args.len() > 0 and args[0] == "compile":
        i = 1

    while i < args.len():
        val arg = args[i]

        if arg == "--help" or arg == "-h":
            print "Simple Compiler"
            print ""
            print "Usage: simple compile [options] <source.spl>"
            print ""
            print "Options:"
            print "  --target=<target>     Target: baremetal-x86, baremetal-arm, etc."
            print "  --emit=<format>       Output: llvm-ir, object, elf (default: elf)"
            print "  --format=<fmt>        Output: native, smf, self-contained (sc), both"
            print "  --native              Compile to native binary via C codegen + gcc"
            print "  --backend=<backend>   Backend: auto, cranelift, llvm, vhdl, c (default: auto)"
            print "  --emit-c              Emit C++20 source code (C backend)"
            print "  --coverage            Enable coverage instrumentation"
            print "  --coverage-output=<p> Coverage output file path"
            print "  --release             Release build (optimized, prefers LLVM)"
            print "  --release-optimized   Max optimization: -O2 + x86-64-v3 + ThinLTO"
            print "  --lto                 Enable ThinLTO (+2-3% speed)"
            print "  --march=<target>      CPU target: native, x86-64-v2, x86-64-v3, x86-64-v4"
            print "  --pgo-generate        Build instrumented binary for PGO"
            print "  --pgo-use=<path>      Use PGO profile for optimization (+5-20% speed)"
            print "  -o <output>           Output file path"
            print "  --verbose, -v         Verbose output"
            print "  --help, -h            Show this help"
            print ""
            print "Output Formats (--format):"
            print "  native                Native executable (default)"
            print "  smf                   SMF module file"
            print "  self-contained, sc    Self-contained binary (runtime + SMF in one file)"
            print "  both                  Both native executable and SMF module"
            print ""
            print "Examples:"
            print "  simple compile hello.spl"
            print "  simple compile hello.spl --backend=llvm"
            print "  simple compile hello.spl --release -o hello.smf"
            print "  simple compile hello.spl --format=self-contained -o hello"
            print "  simple compile --native -o hello hello.spl"
            print "  simple compile --target=baremetal-x86 --emit=llvm-ir kernel.spl"
            print "  simple compile --backend=vhdl -o counter.vhd counter.spl"
            return 0
        elif arg.starts_with("--target="):
            target = arg.substring(9)
        elif arg.starts_with("--emit="):
            emit = arg.substring(7)
        elif arg.starts_with("--format="):
            output_format = arg.substring(9)
        elif arg.starts_with("--backend="):
            backend = arg.substring(10)
        elif arg == "--release":
            release = true
        elif arg == "--release-optimized":
            release_optimized = true
            release = true
            use_lto = true
            march_target = "x86-64-v3"
        elif arg == "--lto":
            use_lto = true
        elif arg.starts_with("--march="):
            march_target = arg.substring(8)
        elif arg == "--pgo-generate":
            pgo_generate = true
        elif arg.starts_with("--pgo-use="):
            pgo_use_path = arg.substring(10)
        elif arg == "--coverage":
            # Pass-through (compiler config reads env/args)
            pass
        elif arg.starts_with("--coverage-output="):
            # Pass-through (handled by compiler)
            pass
        elif arg == "--emit-c":
            emit_c = true
            backend = "c"
        elif arg == "--native":
            emit = "native"
        elif arg == "-o":
            i = i + 1
            if i < args.len():
                output_file = args[i]
            else:
                _cli_eprint("Error: -o requires an argument")
                return 1
        elif arg == "--verbose" or arg == "-v":
            verbose = true
        elif not arg.starts_with("-"):
            if source_file == "":
                source_file = arg
            else:
                # Ignore additional positional args; keep the first as the source.
                _cli_eprint("[cli_compile] ignoring extra positional arg: {arg}")
        else:
            _cli_eprint("Error: Unknown option: {arg}")
            return 1

        i = i + 1

    if source_file == "":
        _cli_eprint("Error: No source file specified")
        _cli_eprint("Usage: simple compile [options] <source.spl>")
        return 1

    if not _cli_file_exists_impl(source_file):
        _cli_eprint("Error: Source file not found: {source_file}")
        return 1

    if backend == "vhdl":
        return compile_vhdl(source_file, output_file, verbose)

    if backend == "c" or backend == "cpp" or backend == "ccodegen" or emit_c:
        return compile_c_backend(source_file, output_file, verbose)

    if emit == "native":
        var out = output_file
        if out == "":
            out = source_file.replace(".spl", "")
        return compile_native(source_file, out, verbose, "", false)

    if target.starts_with("baremetal-"):
        return compile_baremetal(source_file, target, emit, output_file, verbose)

    if output_format != "":
        if output_format != "native" and output_format != "smf" and output_format != "self-contained" and output_format != "sc" and output_format != "both":
            _cli_eprint("Error: Unknown format: {output_format}")
            _cli_eprint("Valid formats: native, smf, self-contained (sc), both")
            return 1

    # Use Pure Simple compiler driver for all compilation
    return cli_compile_pure_simple(source_file, output_file, output_format, backend, verbose, release)

fn compile_baremetal(source_file: text, target: text, emit: text, output_file: text, verbose: bool) -> i64:
    if verbose:
        print "Compiling {source_file} for {target}"
        print "  Emit: {emit}"
        if output_file != "":
            print "  Output: {output_file}"

    _cli_eprint("[NOTE] Using shell-based baremetal build; direct BaremetalBuilder import not yet available")

    val arch = if target == "baremetal-x86":
        "i686"
    elif target == "baremetal-x86_64":
        "x86_64"
    elif target == "baremetal-arm":
        "armv7"
    elif target == "baremetal-aarch64":
        "aarch64"
    elif target == "baremetal-riscv32":
        "riscv32"
    elif target == "baremetal-riscv64":
        "riscv64"
    else:
        _cli_eprint("Error: Unknown bare-metal target: {target}")
        _cli_eprint("Supported: baremetal-x86, baremetal-x86_64, baremetal-arm,")
        _cli_eprint("           baremetal-aarch64, baremetal-riscv32, baremetal-riscv64")
        return 1

    if not _cli_dir_create_impl("build/baremetal", true):
        _cli_eprint("Error: Failed to create build/baremetal directory")
        return 1

    val target_triple = arch + "-unknown-none"

    if verbose:
        print "Compiling Simple -> LLVM IR (pure Simple compiler)..."
        print "  Target triple: {target_triple}"

    val (llvm_ir, compile_err, compile_exit) = rt_compile_to_llvm_ir(source_file, target_triple, true)

    if compile_exit != 0 or llvm_ir == "":
        _cli_eprint("Error: LLVM IR generation failed")
        if compile_err != "":
            _cli_eprint(compile_err)
        return 1

    # Keep bootstrap-safe: avoid nested method calls on str/text
    val base_name = "baremetal_stub"
    val ir_file = "build/baremetal/{base_name}.ll"
    if not _cli_file_write_impl(ir_file, llvm_ir):
        _cli_eprint("Error: Failed to write LLVM IR to {ir_file}")
        return 1

    if verbose:
        print "  Generated: {ir_file}"

    if emit == "llvm-ir":
        if output_file != "":
            if not _cli_file_copy_impl(ir_file, output_file):
                _cli_eprint("Error: Failed to copy to {output_file}")
                return 1
            print "Output: {output_file}"
        else:
            print "Output: {ir_file}"
        return 0

    if verbose:
        print "Compiling LLVM IR -> Object file..."

    val obj_file = "build/baremetal/{base_name}.o"
    val (llc_out, llc_err, llc_exit) = _cli_process_run("llc", [
        "--filetype=obj",
        "--relocation-model=static",
        ir_file,
        "-o", obj_file
    ])

    if llc_exit != 0:
        _cli_eprint("Error: llc compilation failed")
        _cli_eprint(llc_err)
        return 1

    if verbose:
        print "  Generated: {obj_file}"

    if emit == "object":
        if output_file != "":
            if not _cli_file_copy_impl(obj_file, output_file):
                _cli_eprint("Error: Failed to copy to {output_file}")
                return 1
            print "Output: {output_file}"
        else:
            print "Output: {obj_file}"
        return 0

    if verbose:
        print "Linking Object -> ELF binary..."

    val elf_file = if output_file != "":
        output_file
    else:
        "build/baremetal/kernel.elf"

    val linker_script = "build/baremetal/linker.ld"
    if not _cli_file_exists_impl(linker_script):
        val fmt = if arch == "i686": "elf32-i386" else: "elf64-x86-64"
        val script = "OUTPUT_FORMAT(" + fmt + ")\nENTRY(_start)\nSECTIONS {\n  . = 0x00100000;\n  .text : { *(.text*) }\n  .rodata : { *(.rodata*) }\n  .data : { *(.data*) }\n  .bss : { *(.bss*) *(COMMON) }\n}\n"
        if not _cli_file_write_impl(linker_script, script):
            _cli_eprint("Error: Failed to write linker script {linker_script}")
            return 1

    val (ld_out, ld_err, ld_exit) = _cli_process_run("ld", [
        "-T", linker_script,
        "-nostdlib",
        "--entry=_start",
        # Force 32-bit output for i686 target
        "-m", if arch == "i686": "elf_i386" else: "elf64_x86_64",
        obj_file,
        "-o", elf_file
    ])

    if ld_exit != 0:
        _cli_eprint("Error: Linking failed")
        _cli_eprint(ld_err)
        _cli_eprint("")
        _cli_eprint("Note: Linker script should be at: {linker_script}")
        _cli_eprint("Generate it using: simple linker-gen resources/boards/qemu_x86.sdn")
        return 1

    if verbose:
        print "  Generated: {elf_file}"

    print "Success: {elf_file}"
    return 0

# ============================================================================
# Advanced Features
# ============================================================================

fn compile_c_backend(source_file: text, output_file: text, verbose: bool) -> i64:
    var out = output_file
    if out == "":
        out = source_file.replace(".spl", ".cpp")

    if verbose:
        print "Compiling {source_file} to C++20 (MIR C backend)"
        print "  Output: {out}"

    val aot_result = aot_c_file(source_file, out)
    match aot_result:
        case CompileResult.Success(_):
            print "Output: {out}"
            print "Build with: clang -std=gnu11 -O2 {out} src/runtime/runtime.c -I src/runtime -o output"
            return 0
        case _:
            val errors = aot_result.get_errors()
            for err in errors:
                _cli_eprint("error: {err}")
            _cli_eprint("Error: C backend generation failed")
            return 1

fn compile_vhdl(source_file: text, output_file: text, verbose: bool) -> i64:
    var out = output_file
    if out == "":
        out = source_file.replace(".spl", ".vhd")

    if verbose:
        print "Compiling {source_file} to VHDL"
        print "  Output: {out}"

    val aot_result = aot_vhdl_file(source_file, out)
    match aot_result:
        case CompileResult.Success(_):
            print "Output: {out}"
            return 0
        case _:
            val errors = aot_result.get_errors()
            for err in errors:
                _cli_eprint("error: {err}")
            _cli_eprint("Error: VHDL compilation failed")
            return 1

# Native build: compile entire project to native binary via Pure Simple pipeline
fn cli_native_build(args: [text]) -> i64:
    var source = ""
    var output = ""
    var verbose = false

    var i = 0
    while i < args.len():
        val arg = args[i]
        if arg == "native-build":
            i = i + 1
        elif arg == "-o":
            i = i + 1
            if i < args.len():
                output = args[i]
        elif arg == "--verbose" or arg == "-v":
            verbose = true
        elif not arg.starts_with("-"):
            if source == "":
                source = arg
        i = i + 1

    if source == "":
        _cli_eprint("Error: No source file specified for native build")
        return 1

    if output == "":
        output = source.replace(".spl", "")

    return compile_native(source, output, verbose, "", false)

export cli_compile, compile_baremetal, compile_vhdl, cli_native_build
