# CLI Compile Functions - Compilation pipeline
# Extracted from cli_ops.spl for modularity
# Functions here reference helpers in cli_ops.spl (same directory, no imports needed)

# Check if native compiler FFI is available
fn has_native_compiler_ffi() -> bool:
    # Default to native compiler FFI in compiled CLI.
    # Allow explicit override via SIMPLE_COMPILE_RUST:
    #   1 => force native FFI path
    #   0 => force pure-simple fallback path
    val compile_rust = rt_env_get("SIMPLE_COMPILE_RUST")
    if compile_rust == "0":
        return false
    if compile_rust == "1":
        return true

    true

# Pure Simple compiler implementation (no FFI dependency)
fn cli_compile_pure_simple(source_file: text, output_file: text, output_format: text, backend: text, verbose: bool, release: bool) -> i64:
    var out = output_file
    if out == "":
        # Default output based on format
        if output_format == "smf":
            out = source_file.replace(".spl", ".smf")
        else:
            out = "a.out"

    if verbose:
        _cli_eprint("[Pure Simple Compiler] Compiling {source_file} -> {out}")

    # Use the compile_to_smf function from compiler.driver
    # Note: This requires the compiler module to be available
    # For bootstrap, we shell out to avoid circular dependencies
    var use_direct = rt_env_get("SIMPLE_DIRECT_COMPILE") == "1"

    if use_direct:
        # TODO: Direct import of compiler.driver.compile_to_smf
        # This will work once we have proper module loading in place
        _cli_eprint("[Pure Simple Compiler] Direct compilation not yet available")
        _cli_eprint("[Pure Simple Compiler] Set SIMPLE_COMPILE_RUST=1 to use native compiler")
        return 1
    else:
        # For now, report that we're in interpreter mode and can't compile
        # The bootstrap will need to use SIMPLE_COMPILE_RUST=1
        _cli_eprint("error: rt_cli_handle_compile is not supported in interpreter mode")
        _cli_eprint("hint: Build and run the compiled CLI for full functionality")
        _cli_eprint("hint: Or set SIMPLE_COMPILE_RUST=1 to use native compiler backend")
        return 1

fn cli_compile(args: [str]) -> i64:
    var source_file: text = ""
    var output_file: text = ""
    var target: text = ""
    var emit: text = "elf"
    var output_format: text = ""
    var backend: text = "auto"
    var verbose: bool = false
    var release: bool = false
    var use_lto: bool = false
    var march_target: text = ""
    var pgo_generate: bool = false
    var pgo_use_path: text = ""
    var release_optimized: bool = false
    var emit_c: bool = false

    var i = 0
    if args.len() > 0 and args[0] == "compile":
        i = 1

    while i < args.len():
        val arg = args[i]

        if arg == "--help" or arg == "-h":
            print "Simple Compiler"
            print ""
            print "Usage: simple compile [options] <source.spl>"
            print ""
            print "Options:"
            print "  --target=<target>     Target: baremetal-x86, baremetal-arm, etc."
            print "  --emit=<format>       Output: llvm-ir, object, elf (default: elf)"
            print "  --format=<fmt>        Output: native, smf, self-contained (sc), both"
            print "  --native              Compile to native binary via C codegen + gcc"
            print "  --backend=<backend>   Backend: auto, cranelift, llvm, vhdl, c (default: auto)"
            print "  --emit-c              Emit C++20 source code (C backend)"
            print "  --coverage            Enable coverage instrumentation"
            print "  --coverage-output=<p> Coverage output file path"
            print "  --release             Release build (optimized, prefers LLVM)"
            print "  --release-optimized   Max optimization: -O2 + x86-64-v3 + ThinLTO"
            print "  --lto                 Enable ThinLTO (+2-3% speed)"
            print "  --march=<target>      CPU target: native, x86-64-v2, x86-64-v3, x86-64-v4"
            print "  --pgo-generate        Build instrumented binary for PGO"
            print "  --pgo-use=<path>      Use PGO profile for optimization (+5-20% speed)"
            print "  -o <output>           Output file path"
            print "  --verbose, -v         Verbose output"
            print "  --help, -h            Show this help"
            print ""
            print "Output Formats (--format):"
            print "  native                Native executable (default)"
            print "  smf                   SMF module file"
            print "  self-contained, sc    Self-contained binary (runtime + SMF in one file)"
            print "  both                  Both native executable and SMF module"
            print ""
            print "Examples:"
            print "  simple compile hello.spl"
            print "  simple compile hello.spl --backend=llvm"
            print "  simple compile hello.spl --release -o hello.smf"
            print "  simple compile hello.spl --format=self-contained -o hello"
            print "  simple compile --native -o hello hello.spl"
            print "  simple compile --target=baremetal-x86 --emit=llvm-ir kernel.spl"
            print "  simple compile --backend=vhdl -o counter.vhd counter.spl"
            return 0
        elif arg.starts_with("--target="):
            target = arg.substring(9)
        elif arg.starts_with("--emit="):
            emit = arg.substring(7)
        elif arg.starts_with("--format="):
            output_format = arg.substring(9)
        elif arg.starts_with("--backend="):
            backend = arg.substring(10)
        elif arg == "--release":
            release = true
        elif arg == "--release-optimized":
            release_optimized = true
            release = true
            use_lto = true
            march_target = "x86-64-v3"
        elif arg == "--lto":
            use_lto = true
        elif arg.starts_with("--march="):
            march_target = arg.substring(8)
        elif arg == "--pgo-generate":
            pgo_generate = true
        elif arg.starts_with("--pgo-use="):
            pgo_use_path = arg.substring(10)
        elif arg == "--coverage":
            # Pass-through (compiler config reads env/args)
            pass
        elif arg.starts_with("--coverage-output="):
            # Pass-through (handled by compiler)
            pass
        elif arg == "--emit-c":
            emit_c = true
            backend = "c"
        elif arg == "--native":
            emit = "native"
        elif arg == "-o":
            i = i + 1
            if i < args.len():
                output_file = args[i]
            else:
                _cli_eprint("Error: -o requires an argument")
                return 1
        elif arg == "--verbose" or arg == "-v":
            verbose = true
        elif not arg.starts_with("-"):
            if source_file == "":
                source_file = arg
            else:
                _cli_eprint("Error: Multiple source files not supported")
                return 1
        else:
            _cli_eprint("Error: Unknown option: {arg}")
            return 1

        i = i + 1

    if source_file == "":
        _cli_eprint("Error: No source file specified")
        _cli_eprint("Usage: simple compile [options] <source.spl>")
        return 1

    if not _cli_file_exists_impl(source_file):
        _cli_eprint("Error: Source file not found: {source_file}")
        return 1

    if backend == "vhdl":
        return compile_vhdl(source_file, output_file, verbose)

    if backend == "c" or backend == "cpp" or backend == "ccodegen" or emit_c:
        return compile_c_backend(source_file, output_file, verbose)

    if emit == "native":
        var out = output_file
        if out == "":
            out = source_file.replace(".spl", "")
        # Build optimization flags for llvm_direct pipeline
        var opt_flags = ""
        if use_lto:
            opt_flags = opt_flags + " --lto"
        if march_target != "":
            opt_flags = opt_flags + " --march=" + march_target
        if pgo_generate:
            opt_flags = opt_flags + " --pgo-generate"
        if pgo_use_path != "":
            opt_flags = opt_flags + " --pgo-use=" + pgo_use_path
        if release_optimized:
            opt_flags = opt_flags + " --release-optimized"
        # Use llvm_direct if optimization flags are set, otherwise native
        var has_opt_flags = use_lto or march_target != "" or pgo_generate or pgo_use_path != "" or release_optimized
        if has_opt_flags:
            var llvm_cmd = "bin/release/simple src/app/compile/llvm_direct.spl '{source_file}' '{out}'" + opt_flags
            if verbose:
                llvm_cmd = llvm_cmd + " --verbose"
            val llvm_result = _cli_shell(llvm_cmd)
            if llvm_result.stdout != "":
                print llvm_result.stdout
            if llvm_result.stderr != "" and llvm_result.exit_code != 0:
                _cli_eprint(llvm_result.stderr)
            return llvm_result.exit_code
        var native_cmd = "bin/release/simple src/app/compile/native.spl '{source_file}' '{out}'"
        if verbose:
            native_cmd = "bin/release/simple src/app/compile/native.spl '{source_file}' '{out}' --verbose"
        val native_result = _cli_shell(native_cmd)
        if native_result.stdout != "":
            print native_result.stdout
        if native_result.stderr != "" and native_result.exit_code != 0:
            _cli_eprint(native_result.stderr)
        return native_result.exit_code

    if target.starts_with("baremetal-"):
        return compile_baremetal(source_file, target, emit, output_file, verbose)

    var compile_args = args
    if output_format != "":
        if output_format != "native" and output_format != "smf" and output_format != "self-contained" and output_format != "sc" and output_format != "both":
            _cli_eprint("Error: Unknown format: {output_format}")
            _cli_eprint("Valid formats: native, smf, self-contained (sc), both")
            return 1

    # Check if we should use Pure Simple compiler (interpreter mode, no FFI)
    val use_pure_simple = rt_env_get("SIMPLE_USE_PURE_COMPILER") == "1"

    if use_pure_simple or not has_native_compiler_ffi():
        # Use Pure Simple compiler implementation (works in interpreter/SMF mode)
        return cli_compile_pure_simple(source_file, output_file, output_format, backend, verbose, release)

    _cli_eprint("[NOTE] Using bootstrap Cranelift path; pure-Simple LLVM path not yet available in interpreter mode")

    if backend == "llvm":
        val llc_check = _cli_shell("command -v llc >/dev/null 2>&1")
        if llc_check.exit_code != 0:
            _cli_eprint("Error: llc not found. Install LLVM: apt install llvm (Ubuntu) or brew install llvm (macOS)")
            return 1

    rt_cli_handle_compile(compile_args)

fn compile_baremetal(source_file: text, target: text, emit: text, output_file: text, verbose: bool) -> i64:
    if verbose:
        print "Compiling {source_file} for {target}"
        print "  Emit: {emit}"
        if output_file != "":
            print "  Output: {output_file}"

    _cli_eprint("[NOTE] Using shell-based baremetal build; direct BaremetalBuilder import not yet available")

    val arch = if target == "baremetal-x86":
        "i686"
    elif target == "baremetal-x86_64":
        "x86_64"
    elif target == "baremetal-arm":
        "armv7"
    elif target == "baremetal-aarch64":
        "aarch64"
    elif target == "baremetal-riscv32":
        "riscv32"
    elif target == "baremetal-riscv64":
        "riscv64"
    else:
        _cli_eprint("Error: Unknown bare-metal target: {target}")
        _cli_eprint("Supported: baremetal-x86, baremetal-x86_64, baremetal-arm,")
        _cli_eprint("           baremetal-aarch64, baremetal-riscv32, baremetal-riscv64")
        return 1

    if not _cli_dir_create_impl("build/baremetal", true):
        _cli_eprint("Error: Failed to create build/baremetal directory")
        return 1

    val target_triple = arch + "-unknown-none"

    if verbose:
        print "Compiling Simple -> LLVM IR (pure Simple compiler)..."
        print "  Target triple: {target_triple}"

    val (llvm_ir, compile_err, compile_exit) = rt_compile_to_llvm_ir(source_file, target_triple, true)

    if compile_exit != 0 or llvm_ir == "":
        _cli_eprint("Error: LLVM IR generation failed")
        if compile_err != "":
            _cli_eprint(compile_err)
        return 1

    val base_name = source_file.replace(".spl", "").replace("/", "_")
    val ir_file = "build/baremetal/{base_name}.ll"
    if not _cli_file_write_impl(ir_file, llvm_ir):
        _cli_eprint("Error: Failed to write LLVM IR to {ir_file}")
        return 1

    if verbose:
        print "  Generated: {ir_file}"

    if emit == "llvm-ir":
        if output_file != "":
            if not _cli_file_copy_impl(ir_file, output_file):
                _cli_eprint("Error: Failed to copy to {output_file}")
                return 1
            print "Output: {output_file}"
        else:
            print "Output: {ir_file}"
        return 0

    if verbose:
        print "Compiling LLVM IR -> Object file..."

    val obj_file = "build/baremetal/{base_name}.o"
    val (llc_out, llc_err, llc_exit) = _cli_process_run("llc", [
        "--filetype=obj",
        "--relocation-model=static",
        ir_file,
        "-o", obj_file
    ])

    if llc_exit != 0:
        _cli_eprint("Error: llc compilation failed")
        _cli_eprint(llc_err)
        return 1

    if verbose:
        print "  Generated: {obj_file}"

    if emit == "object":
        if output_file != "":
            if not _cli_file_copy_impl(obj_file, output_file):
                _cli_eprint("Error: Failed to copy to {output_file}")
                return 1
            print "Output: {output_file}"
        else:
            print "Output: {obj_file}"
        return 0

    if verbose:
        print "Linking Object -> ELF binary..."

    val elf_file = if output_file != "":
        output_file
    else:
        "build/baremetal/kernel.elf"

    val linker_script = "build/baremetal/linker.ld"

    val (ld_out, ld_err, ld_exit) = _cli_process_run("ld", [
        "-T", linker_script,
        "-nostdlib",
        "--entry=_start",
        obj_file,
        "-o", elf_file
    ])

    if ld_exit != 0:
        _cli_eprint("Error: Linking failed")
        _cli_eprint(ld_err)
        _cli_eprint("")
        _cli_eprint("Note: Linker script should be at: {linker_script}")
        _cli_eprint("Generate it using: simple linker-gen resources/boards/qemu_x86.sdn")
        return 1

    if verbose:
        print "  Generated: {elf_file}"

    print "Success: {elf_file}"
    return 0

# ============================================================================
# Advanced Features
# ============================================================================

fn compile_c_backend(source_file: text, output_file: text, verbose: bool) -> i64:
    """Compile a Simple source file to C++20 output using the MIR C backend.

    Path 1: Pure Simple MIR C backend via compile_c_entry.spl (interpreter mode).
    Path 2: Native compile handler (when SIMPLE_COMPILE_RUST=1).
    Path 3: Bootstrap generator fallback (legacy gen-c).
    """
    var out = output_file
    if out == "":
        out = source_file.replace(".spl", ".cpp")

    if verbose:
        print "Compiling {source_file} to C++20 (MIR C backend)"
        print "  Output: {out}"

    # Path 1: Use the Pure Simple MIR C backend via interpreter.
    # This loads the compiler driver in interpreter mode and runs the full pipeline.
    val simple_bin = _find_simple_binary()
    val compile_c_script = "src/app/cli/compile_c_entry.spl"
    if _cli_file_exists_impl(compile_c_script):
        if verbose:
            print "Using MIR C backend pipeline (interpreter mode)"
        var c_cmd = "timeout 600s {simple_bin} {compile_c_script} '{source_file}' '{out}'"
        val result = _cli_shell(c_cmd)
        if result.stdout != "":
            print result.stdout
        if result.stderr != "":
            _cli_eprint(result.stderr)
        if result.exit_code == 124:
            _cli_eprint("Error: C backend compilation timed out after 600s")
            return 124
        if result.exit_code == 0:
            print "Output: {out}"
            print "Build with: clang++ -std=c++20 -O2 {out} src/runtime/runtime.c -I src/runtime -o output"
            return 0
        if verbose:
            _cli_eprint("MIR C backend failed with exit code {result.exit_code}; trying fallbacks")

    # Path 2: Native runtime compile handler (requires SIMPLE_COMPILE_RUST=1).
    val force_native_c = rt_env_get("SIMPLE_COMPILE_RUST") == "1"
    if force_native_c and has_native_compiler_ffi():
        var compile_args: [str] = ["compile", source_file, "--backend=c", "-o", out]
        if verbose:
            compile_args.push("--verbose")

        val exit_code = rt_cli_handle_compile(compile_args)
        if exit_code == 0:
            print "Output: {out}"
            print "Build with: clang++ -std=c++20 -O2 {out} src/runtime/runtime.c -I src/runtime -o output"
            return 0
        if verbose:
            _cli_eprint("Native compile handler failed with exit code {exit_code}")

    # Path 3: Legacy bootstrap C generator (simple_codegen).
    val codegen_bin = "bin/bootstrap/cpp/simple_codegen"
    if _cli_file_exists_impl(codegen_bin):
        if verbose:
            print "Using legacy simple_codegen (text-based C codegen)"
        var c_cmd = "timeout 120s {codegen_bin} '{source_file}' '{out}'"
        val result = _cli_shell(c_cmd)
        if result.stdout != "":
            print result.stdout
        if result.stderr != "":
            _cli_eprint(result.stderr)
        if result.exit_code == 0:
            print "Output: {out}"
            print "Build with: clang -std=gnu11 -O2 {out} -lm -o output"
            return 0

    _cli_eprint("Error: C backend generation failed")
    _cli_eprint("hint: Ensure bin/bootstrap/cpp/simple_codegen exists (build with: cmake -B build -G Ninja -S src/compiler_cpp && ninja -C build)")
    1

fn _find_simple_binary() -> text:
    """Find the Simple interpreter binary."""
    if _cli_file_exists_impl("bin/release/linux-x86_64/simple"):
        return "bin/release/linux-x86_64/simple"
    if _cli_file_exists_impl("bin/release/simple"):
        return "bin/release/simple"
    if _cli_file_exists_impl("bin/simple"):
        return "bin/simple"
    "simple"

fn compile_vhdl(source_file: text, output_file: text, verbose: bool) -> i64:
    """Compile a Simple source file to VHDL output."""
    var out = output_file
    if out == "":
        out = source_file.replace(".spl", ".vhd")

    if verbose:
        print "Compiling {source_file} to VHDL"
        print "  Output: {out}"

    # The VHDL backend produces .vhd text files from MIR.
    # Full pipeline: source -> parse -> HIR -> MIR -> VhdlConstraintChecker -> VhdlBackend -> .vhd
    # Currently delegates to the Simple runtime for compilation.
    var vhdl_cmd = "bin/release/simple src/app/compile/native.spl '{source_file}' '{out}' --backend=vhdl"
    if verbose:
        vhdl_cmd = vhdl_cmd + " --verbose"
    val result = _cli_shell(vhdl_cmd)
    if result.stdout != "":
        print result.stdout
    if result.stderr != "" and result.exit_code != 0:
        _cli_eprint(result.stderr)
        return result.exit_code

    if result.exit_code == 0:
        print "Output: {out}"
    return result.exit_code

export cli_compile, compile_baremetal, compile_vhdl
