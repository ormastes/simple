# CLI Compile Functions - Compilation pipeline
# Extracted from cli_ops.spl for modularity
# Functions here reference helpers in cli_ops.spl (same directory, no imports needed)

# Helpers from cli_ops.spl
use app.io.cli_ops.{rt_env_get, _cli_eprint, _cli_dir_create_impl, _cli_file_write_impl, _cli_file_copy_impl, _cli_process_run, _cli_shell, _cli_shell_bool, _cli_file_exists_impl, _cli_file_read_impl}

# Pure Simple compiler driver
use compiler.driver.driver.{CompilerDriver, aot_file, aot_c_file, compile_to_smf}
use compiler.driver.driver_types.{CompileOptions, CompileMode, CompileResult, OutputFormat}
use compiler.backend.build_native.{BuildConfig, BuildResult, build_native, build_native_llvm}

extern fn rt_compile_to_llvm_ir(source_file: text, target_triple: text, bare_metal: bool) -> (text, text, i64)

# Pure Simple compiler implementation (no Rust FFI dependency)
fn cli_compile_pure_simple(source_file: text, output_file: text, output_format: text, backend: text, verbose: bool, release: bool) -> i64:
    var out = output_file
    if out == "":
        # Default output based on format
        if output_format == "smf":
            out = source_file.replace(".spl", ".smf")
        else:
            out = "a.out"

    if verbose:
        _cli_eprint("[Pure Simple Compiler] Compiling {source_file} -> {out}")

    # Use the Pure Simple compiler driver directly
    val options = CompileOptions.default()
    options.input_files = [source_file]
    options.output_file = out
    options.mode = CompileMode.Aot
    options.verbose = verbose
    if release:
        options.release = true
        options.optimize = true
    if backend != "" and backend != "auto":
        options.backend = backend

    # Set output format
    if output_format == "smf":
        options.output_format = OutputFormat.Smf
    elif output_format == "self-contained" or output_format == "sc":
        options.output_format = OutputFormat.SelfContained

    val driver = CompilerDriver.create(options)
    val result = driver.compile()

    match result:
        case CompileResult.Success(_):
            if verbose:
                _cli_eprint("[Pure Simple Compiler] Compilation successful: {out}")
            return 0
        case _:
            val errors = result.get_errors()
            if errors.len() > 0:
                for err in errors:
                    _cli_eprint("error: {err}")
            else:
                _cli_eprint("error: Compilation failed")
            return 1

fn cli_compile(args: [str]) -> i64:
    _cli_eprint("[cli_compile] args = {args}")

    var source_file: text = ""
    var output_file: text = ""
    var target: text = ""
    var emit: text = "elf"
    var output_format: text = ""
    var backend: text = "auto"
    var verbose: bool = false
    var release: bool = false
    var use_lto: bool = false
    var march_target: text = ""
    var pgo_generate: bool = false
    var pgo_use_path: text = ""
    var release_optimized: bool = false
    var emit_c: bool = false

    var i = 0
    if args.len() > 0 and args[0] == "compile":
        i = 1

    while i < args.len():
        val arg = args[i]

        if arg == "--help" or arg == "-h":
            print "Simple Compiler"
            print ""
            print "Usage: simple compile [options] <source.spl>"
            print ""
            print "Options:"
            print "  --target=<target>     Target: baremetal-x86, baremetal-arm, etc."
            print "  --emit=<format>       Output: llvm-ir, object, elf (default: elf)"
            print "  --format=<fmt>        Output: native, smf, self-contained (sc), both"
            print "  --native              Compile to native binary via C codegen + gcc"
            print "  --backend=<backend>   Backend: auto, cranelift, llvm, vhdl, c (default: auto)"
            print "  --emit-c              Emit C++20 source code (C backend)"
            print "  --coverage            Enable coverage instrumentation"
            print "  --coverage-output=<p> Coverage output file path"
            print "  --release             Release build (optimized, prefers LLVM)"
            print "  --release-optimized   Max optimization: -O2 + x86-64-v3 + ThinLTO"
            print "  --lto                 Enable ThinLTO (+2-3% speed)"
            print "  --march=<target>      CPU target: native, x86-64-v2, x86-64-v3, x86-64-v4"
            print "  --pgo-generate        Build instrumented binary for PGO"
            print "  --pgo-use=<path>      Use PGO profile for optimization (+5-20% speed)"
            print "  -o <output>           Output file path"
            print "  --verbose, -v         Verbose output"
            print "  --help, -h            Show this help"
            print ""
            print "Output Formats (--format):"
            print "  native                Native executable (default)"
            print "  smf                   SMF module file"
            print "  self-contained, sc    Self-contained binary (runtime + SMF in one file)"
            print "  both                  Both native executable and SMF module"
            print ""
            print "Examples:"
            print "  simple compile hello.spl"
            print "  simple compile hello.spl --backend=llvm"
            print "  simple compile hello.spl --release -o hello.smf"
            print "  simple compile hello.spl --format=self-contained -o hello"
            print "  simple compile --native -o hello hello.spl"
            print "  simple compile --target=baremetal-x86 --emit=llvm-ir kernel.spl"
            print "  simple compile --backend=vhdl -o counter.vhd counter.spl"
            return 0
        elif arg.starts_with("--target="):
            target = arg.substring(9)
        elif arg.starts_with("--emit="):
            emit = arg.substring(7)
        elif arg.starts_with("--format="):
            output_format = arg.substring(9)
        elif arg.starts_with("--backend="):
            backend = arg.substring(10)
        elif arg == "--release":
            release = true
        elif arg == "--release-optimized":
            release_optimized = true
            release = true
            use_lto = true
            march_target = "x86-64-v3"
        elif arg == "--lto":
            use_lto = true
        elif arg.starts_with("--march="):
            march_target = arg.substring(8)
        elif arg == "--pgo-generate":
            pgo_generate = true
        elif arg.starts_with("--pgo-use="):
            pgo_use_path = arg.substring(10)
        elif arg == "--coverage":
            # Pass-through (compiler config reads env/args)
            pass
        elif arg.starts_with("--coverage-output="):
            # Pass-through (handled by compiler)
            pass
        elif arg == "--emit-c":
            emit_c = true
            backend = "c"
        elif arg == "--native":
            emit = "native"
        elif arg == "-o":
            i = i + 1
            if i < args.len():
                output_file = args[i]
            else:
                _cli_eprint("Error: -o requires an argument")
                return 1
        elif arg == "--verbose" or arg == "-v":
            verbose = true
        elif not arg.starts_with("-"):
            if source_file == "":
                source_file = arg
            else:
                # Ignore additional positional args; keep the first as the source.
                _cli_eprint("[cli_compile] ignoring extra positional arg: {arg}")
        else:
            _cli_eprint("Error: Unknown option: {arg}")
            return 1

        i = i + 1

    if source_file == "":
        _cli_eprint("Error: No source file specified")
        _cli_eprint("Usage: simple compile [options] <source.spl>")
        return 1

    if not _cli_file_exists_impl(source_file):
        _cli_eprint("Error: Source file not found: {source_file}")
        return 1

    if backend == "vhdl":
        return compile_vhdl(source_file, output_file, verbose)

    if backend == "c" or backend == "cpp" or backend == "ccodegen" or emit_c:
        return compile_c_backend(source_file, output_file, verbose)

    if emit == "native":
        # Use the pure-Simple native build pipeline
        var out = output_file
        if out == "":
            out = source_file.replace(".spl", "")
        var config = BuildConfig.default(source_file, out)
        config.verbose = verbose
        if release:
            config.optimization = 2
        if march_target != "":
            config.target_cpu = march_target
        if use_lto:
            config.linker_flags = config.linker_flags + ["--lto"]

        # Use LLVM backend if requested
        val build_result = if backend == "llvm":
            config.backend = "llvm"
            build_native_llvm(config)
        else:
            build_native(config)

        match build_result:
            case BuildResult.Success(output_path, stats):
                if verbose:
                    print "Native build successful: {output_path}"
                    print "  Size: {stats.output_size} bytes"
                    print "  Source files: {stats.source_files}"
                    print "  Compile time: {stats.compile_time_ms}ms"
                    print "  Link time: {stats.link_time_ms}ms"
                return 0
            case BuildResult.CompileError(file, msg):
                _cli_eprint("Compile error in {file}: {msg}")
                return 1
            case BuildResult.LinkError(msg):
                _cli_eprint("Link error: {msg}")
                return 1
            case BuildResult.Error(msg):
                _cli_eprint("Build error: {msg}")
                return 1

    if target.starts_with("baremetal-"):
        return compile_baremetal(source_file, target, emit, output_file, verbose)

    if output_format != "":
        if output_format != "native" and output_format != "smf" and output_format != "self-contained" and output_format != "sc" and output_format != "both":
            _cli_eprint("Error: Unknown format: {output_format}")
            _cli_eprint("Valid formats: native, smf, self-contained (sc), both")
            return 1

    # Use Pure Simple compiler driver for all compilation
    return cli_compile_pure_simple(source_file, output_file, output_format, backend, verbose, release)

fn compile_baremetal(source_file: text, target: text, emit: text, output_file: text, verbose: bool) -> i64:
    if verbose:
        print "Compiling {source_file} for {target}"
        print "  Emit: {emit}"
        if output_file != "":
            print "  Output: {output_file}"

    _cli_eprint("[NOTE] Using shell-based baremetal build; direct BaremetalBuilder import not yet available")

    val arch = if target == "baremetal-x86":
        "i686"
    elif target == "baremetal-x86_64":
        "x86_64"
    elif target == "baremetal-arm":
        "armv7"
    elif target == "baremetal-aarch64":
        "aarch64"
    elif target == "baremetal-riscv32":
        "riscv32"
    elif target == "baremetal-riscv64":
        "riscv64"
    else:
        _cli_eprint("Error: Unknown bare-metal target: {target}")
        _cli_eprint("Supported: baremetal-x86, baremetal-x86_64, baremetal-arm,")
        _cli_eprint("           baremetal-aarch64, baremetal-riscv32, baremetal-riscv64")
        return 1

    if not _cli_dir_create_impl("build/baremetal", true):
        _cli_eprint("Error: Failed to create build/baremetal directory")
        return 1

    val target_triple = arch + "-unknown-none"

    if verbose:
        print "Compiling Simple -> LLVM IR (pure Simple compiler)..."
        print "  Target triple: {target_triple}"

    val (llvm_ir, compile_err, compile_exit) = rt_compile_to_llvm_ir(source_file, target_triple, true)

    if compile_exit != 0 or llvm_ir == "":
        _cli_eprint("Error: LLVM IR generation failed")
        if compile_err != "":
            _cli_eprint(compile_err)
        return 1

    # Keep bootstrap-safe: avoid nested method calls on str/text
    val base_name = "baremetal_stub"
    val ir_file = "build/baremetal/{base_name}.ll"
    if not _cli_file_write_impl(ir_file, llvm_ir):
        _cli_eprint("Error: Failed to write LLVM IR to {ir_file}")
        return 1

    if verbose:
        print "  Generated: {ir_file}"

    if emit == "llvm-ir":
        if output_file != "":
            if not _cli_file_copy_impl(ir_file, output_file):
                _cli_eprint("Error: Failed to copy to {output_file}")
                return 1
            print "Output: {output_file}"
        else:
            print "Output: {ir_file}"
        return 0

    if verbose:
        print "Compiling LLVM IR -> Object file..."

    val obj_file = "build/baremetal/{base_name}.o"
    val (llc_out, llc_err, llc_exit) = _cli_process_run("llc", [
        "--filetype=obj",
        "--relocation-model=static",
        ir_file,
        "-o", obj_file
    ])

    if llc_exit != 0:
        _cli_eprint("Error: llc compilation failed")
        _cli_eprint(llc_err)
        return 1

    if verbose:
        print "  Generated: {obj_file}"

    if emit == "object":
        if output_file != "":
            if not _cli_file_copy_impl(obj_file, output_file):
                _cli_eprint("Error: Failed to copy to {output_file}")
                return 1
            print "Output: {output_file}"
        else:
            print "Output: {obj_file}"
        return 0

    if verbose:
        print "Linking Object -> ELF binary..."

    val elf_file = if output_file != "":
        output_file
    else:
        "build/baremetal/kernel.elf"

    val linker_script = "build/baremetal/linker.ld"
    if not _cli_file_exists_impl(linker_script):
        val fmt = if arch == "i686": "elf32-i386" else: "elf64-x86-64"
        val script = "OUTPUT_FORMAT(" + fmt + ")\nENTRY(_start)\nSECTIONS {\n  . = 0x00100000;\n  .text : { *(.text*) }\n  .rodata : { *(.rodata*) }\n  .data : { *(.data*) }\n  .bss : { *(.bss*) *(COMMON) }\n}\n"
        if not _cli_file_write_impl(linker_script, script):
            _cli_eprint("Error: Failed to write linker script {linker_script}")
            return 1

    val (ld_out, ld_err, ld_exit) = _cli_process_run("ld", [
        "-T", linker_script,
        "-nostdlib",
        "--entry=_start",
        # Force 32-bit output for i686 target
        "-m", if arch == "i686": "elf_i386" else: "elf64_x86_64",
        obj_file,
        "-o", elf_file
    ])

    if ld_exit != 0:
        _cli_eprint("Error: Linking failed")
        _cli_eprint(ld_err)
        _cli_eprint("")
        _cli_eprint("Note: Linker script should be at: {linker_script}")
        _cli_eprint("Generate it using: simple linker-gen resources/boards/qemu_x86.sdn")
        return 1

    if verbose:
        print "  Generated: {elf_file}"

    print "Success: {elf_file}"
    return 0

# ============================================================================
# Advanced Features
# ============================================================================

fn compile_c_backend(source_file: text, output_file: text, verbose: bool) -> i64:
    """Compile a Simple source file to C++20 output using the MIR C backend.

    Path 1: Pure Simple MIR C backend via compile_c_entry.spl (interpreter mode).
    Path 2: Pure Simple compiler driver with C backend (aot_c_file).
    Path 3: Bootstrap generator fallback (legacy gen-c).
    """
    var out = output_file
    if out == "":
        out = source_file.replace(".spl", ".cpp")

    if verbose:
        print "Compiling {source_file} to C++20 (MIR C backend)"
        print "  Output: {out}"

    # Path 1: Use the Pure Simple MIR C backend via interpreter.
    # This loads the compiler driver in interpreter mode and runs the full pipeline.
    val simple_bin = _find_simple_binary()
    val compile_c_script = "src/app/cli/compile_c_entry.spl"
    if _cli_file_exists_impl(compile_c_script):
        if verbose:
            print "Using MIR C backend pipeline (interpreter mode)"
        var c_cmd = "timeout 600s {simple_bin} {compile_c_script} '{source_file}' '{out}'"
        val result = _cli_shell(c_cmd)
        if result.stdout != "":
            print result.stdout
        if result.stderr != "":
            _cli_eprint(result.stderr)
        if result.exit_code == 124:
            _cli_eprint("Error: C backend compilation timed out after 600s")
            return 124
        if result.exit_code == 0:
            print "Output: {out}"
            print "Build with: clang++ -std=c++20 -O2 {out} src/runtime/runtime.c -I src/runtime -o output"
            return 0
        if verbose:
            _cli_eprint("MIR C backend failed with exit code {result.exit_code}; trying fallbacks")

    # Path 2: Use Pure Simple compiler driver with C backend.
    val aot_result = aot_c_file(source_file, out)
    match aot_result:
        case CompileResult.Success(_):
            print "Output: {out}"
            print "Build with: clang++ -std=c++20 -O2 {out} src/runtime/runtime.c -I src/runtime -o output"
            return 0
        case _:
            if verbose:
                _cli_eprint("Pure Simple C backend failed; trying legacy fallback")

    # Path 3: Legacy bootstrap C generator (simple_codegen).
    val codegen_bin = "bin/bootstrap/cpp/simple_codegen"
    if _cli_file_exists_impl(codegen_bin):
        if verbose:
            print "Using legacy simple_codegen (text-based C codegen)"
        var c_cmd = "timeout 120s {codegen_bin} '{source_file}' '{out}'"
        val result = _cli_shell(c_cmd)
        if result.stdout != "":
            print result.stdout
        if result.stderr != "":
            _cli_eprint(result.stderr)
        if result.exit_code == 0:
            print "Output: {out}"
            print "Build with: clang -std=gnu11 -O2 {out} -lm -o output"
            return 0

    _cli_eprint("Error: C backend generation failed")
    _cli_eprint("hint: Ensure bin/bootstrap/cpp/simple_codegen exists (build with: cmake -B build -G Ninja -S src/compiler_cpp && ninja -C build)")
    1

fn _find_simple_binary() -> text:
    """Find the Simple interpreter binary."""
    if _cli_file_exists_impl("bin/release/linux-x86_64/simple"):
        return "bin/release/linux-x86_64/simple"
    if _cli_file_exists_impl("bin/release/simple"):
        return "bin/release/simple"
    if _cli_file_exists_impl("bin/simple"):
        return "bin/simple"
    "simple"

fn compile_vhdl(source_file: text, output_file: text, verbose: bool) -> i64:
    """Compile a Simple source file to VHDL output."""
    var out = output_file
    if out == "":
        out = source_file.replace(".spl", ".vhd")

    if verbose:
        print "Compiling {source_file} to VHDL"
        print "  Output: {out}"

    # The VHDL backend produces .vhd text files from MIR.
    # Full pipeline: source -> parse -> HIR -> MIR -> VhdlConstraintChecker -> VhdlBackend -> .vhd
    # Currently delegates to the Simple runtime for compilation.
    var vhdl_cmd = "bin/release/simple src/app/compile/native.spl '{source_file}' '{out}' --backend=vhdl"
    if verbose:
        vhdl_cmd = vhdl_cmd + " --verbose"
    val result = _cli_shell(vhdl_cmd)
    if result.stdout != "":
        print result.stdout
    if result.stderr != "" and result.exit_code != 0:
        _cli_eprint(result.stderr)
        return result.exit_code

    if result.exit_code == 0:
        print "Output: {out}"
    return result.exit_code

# Native build: compile entire project to native binary via Pure Simple pipeline
fn cli_native_build(args: [text]) -> i64:
    # Parse args into BuildConfig
    var source = ""
    var output = ""
    var verbose = false
    var backend_name = ""

    var i = 0
    while i < args.len():
        val arg = args[i]
        if arg == "-o":
            i = i + 1
            if i < args.len():
                output = args[i]
        elif arg == "--verbose" or arg == "-v":
            verbose = true
        elif arg == "--backend=llvm":
            backend_name = "llvm"
        elif arg.starts_with("--backend="):
            backend_name = arg.substring(10)
        elif not arg.starts_with("-"):
            if source == "":
                source = arg
        i = i + 1

    if source == "":
        _cli_eprint("Error: No source file specified for native build")
        return 1

    if output == "":
        output = source.replace(".spl", "")

    var config = BuildConfig.default(source, output)
    config.verbose = verbose
    if backend_name == "llvm":
        config.backend = "llvm"

    val result = if backend_name == "llvm":
        build_native_llvm(config)
    else:
        build_native(config)

    match result:
        case BuildResult.Success(out, stats):
            print "Build successful: {out}"
            if verbose:
                print "  Size: {stats.output_size} bytes"
                print "  Compile time: {stats.compile_time_ms}ms"
                print "  Link time: {stats.link_time_ms}ms"
            return 0
        case BuildResult.CompileError(file, msg):
            _cli_eprint("Compile error in {file}: {msg}")
            return 1
        case BuildResult.LinkError(msg):
            _cli_eprint("Link error: {msg}")
            return 1
        case BuildResult.Error(msg):
            _cli_eprint("Build error: {msg}")
            return 1

export cli_compile, compile_baremetal, compile_vhdl, cli_native_build
