# Signal Handler Management - SFFI Wrapper
#
# Provides signal handling for graceful shutdown on SIGTERM/SIGINT/SIGHUP.
# Requires SFFI additions to runtime for actual signal registration.

use app.io.mod.{exit}

# ============================================================================
# SFFI Declarations (use stubs until runtime implementation available)
# ============================================================================

# Import stub implementations (will be replaced by actual SFFI later)
use app.io.signal_stubs.{rt_signal_handler_available, rt_signal_handler_install, rt_atexit_register}

# ============================================================================
# Signal Numbers (POSIX standard)
# ============================================================================

val SIGHUP = 1    # Hangup (terminal closed)
val SIGINT = 2    # Interrupt (Ctrl+C)
val SIGTERM = 15  # Termination request
val SIGKILL = 9   # Kill (cannot be caught)

# ============================================================================
# Global Cleanup Handler Reference
# ============================================================================

# NOTE: This needs to be set by the test runner before installing handlers
var _global_cleanup_handler: fn() = default_cleanup_handler

fn default_cleanup_handler():
    """Default cleanup handler (does nothing)"""
    pass_do_nothing

# ============================================================================
# Signal Handler Installation
# ============================================================================

fn install_signal_handlers(cleanup_handler: fn()) -> bool:
    """
    Install signal handlers for graceful shutdown.

    Args:
        cleanup_handler: Function to call on signal (should cleanup resources)

    Returns: true if handlers installed, false if SFFI not available

    Usage:
        fn my_cleanup():
            cleanup_all_children()
            exit(130)

        install_signal_handlers(my_cleanup)
    """
    # Check if signal handling SFFI is available
    if not rt_signal_handler_available():
        return false

    # Store cleanup handler reference
    _global_cleanup_handler = cleanup_handler

    # Install handlers for common signals
    rt_signal_handler_install(SIGINT, on_sigint)
    rt_signal_handler_install(SIGTERM, on_sigterm)
    rt_signal_handler_install(SIGHUP, on_sighup)

    # Register atexit handler for normal exit
    rt_atexit_register(on_normal_exit)

    true

# ============================================================================
# Signal Handler Callbacks
# ============================================================================

fn on_sigint():
    """
    Handle SIGINT (Ctrl+C).

    Exit code: 130 (128 + 2)
    """
    print ""
    print "[SIGNAL] SIGINT received (Ctrl+C)"
    print "[SIGNAL] Cleaning up resources..."

    _global_cleanup_handler()

    # Exit with standard SIGINT code
    exit(130)

fn on_sigterm():
    """
    Handle SIGTERM (termination request).

    Exit code: 143 (128 + 15)
    """
    print ""
    print "[SIGNAL] SIGTERM received (termination request)"
    print "[SIGNAL] Cleaning up resources..."

    _global_cleanup_handler()

    # Exit with standard SIGTERM code
    exit(143)

fn on_sighup():
    """
    Handle SIGHUP (terminal closed).

    Exit code: 129 (128 + 1)
    """
    print ""
    print "[SIGNAL] SIGHUP received (terminal closed)"
    print "[SIGNAL] Cleaning up resources..."

    _global_cleanup_handler()

    # Exit with standard SIGHUP code
    exit(129)

fn on_normal_exit():
    """
    Handle normal exit (via exit() call or end of main).

    Performs cleanup without changing exit code.
    """
    _global_cleanup_handler()

# ============================================================================
# Graceful Shutdown Helpers
# ============================================================================

fn create_signal_cleanup_handler(
    cleanup_processes: fn() -> i64,
    cleanup_containers: fn() -> i64,
    save_checkpoint: fn()
) -> fn():
    """
    Create a cleanup handler that calls provided cleanup functions.

    Args:
        cleanup_processes: Function to kill all child processes
        cleanup_containers: Function to stop all containers
        save_checkpoint: Function to save checkpoint (optional)

    Returns: Cleanup handler function

    Usage:
        val handler = create_signal_cleanup_handler(
            tracker_kill_all_children,
            tracker_stop_all_containers,
            fn(): checkpoint_save([], 0, 0, 0, "signal")
        )
        install_signal_handlers(handler)
    """
    fn combined_cleanup():
        # Save checkpoint first (if handler provided)
        save_checkpoint()

        # Cleanup resources
        val killed = cleanup_processes()
        val stopped = cleanup_containers()

        print "[SIGNAL] Cleanup complete: {killed} processes, {stopped} containers"

    combined_cleanup

# ============================================================================
# Utility Functions
# ============================================================================

fn signal_handlers_available() -> bool:
    """
    Check if signal handling SFFI is available.

    Returns: true if rt_signal_handler_install is implemented
    """
    rt_signal_handler_available()

fn signal_name(signal: i64) -> text:
    """Get signal name from number"""
    if signal == SIGHUP:
        return "SIGHUP"
    elif signal == SIGINT:
        return "SIGINT"
    elif signal == SIGTERM:
        return "SIGTERM"
    elif signal == SIGKILL:
        return "SIGKILL"
    else:
        return "UNKNOWN"

# ============================================================================
# Exports
# ============================================================================

export SIGHUP, SIGINT, SIGTERM, SIGKILL
export install_signal_handlers
export create_signal_cleanup_handler
export signal_handlers_available
export signal_name
export on_sigint, on_sigterm, on_sighup, on_normal_exit
