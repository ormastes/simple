#!/usr/bin/env simple
# SSH Client SFFI Wrapper
#
# Two-tier SFFI pattern for SSH2 protocol operations.
# Supports remote command execution, SFTP file transfer, and port forwarding.
#
# Rust crate: ssh2 (https://docs.rs/ssh2/)
# Based on: libssh2 C library

use app.io.sffi_common.{is_valid_handle, is_invalid_handle}

# ============================================================================
# Tier 1: Extern Declarations (Raw FFI)
# ============================================================================

# --- Session Management ---

extern fn rt_ssh_connect(host: text, port: i64) -> i64
extern fn rt_ssh_disconnect(session: i64) -> bool
extern fn rt_ssh_auth_password(session: i64, username: text, password: text) -> bool
extern fn rt_ssh_auth_pubkey(session: i64, username: text, pubkey_path: text, privkey_path: text, passphrase: text) -> bool
extern fn rt_ssh_auth_agent(session: i64, username: text) -> bool

# --- Remote Command Execution ---

extern fn rt_ssh_exec(session: i64, command: text) -> (i64, text, text)  # (exit_code, stdout, stderr)
extern fn rt_ssh_shell(session: i64) -> i64  # Returns channel handle
extern fn rt_ssh_channel_read(channel: i64) -> text
extern fn rt_ssh_channel_write(channel: i64, data: text) -> i64
extern fn rt_ssh_channel_close(channel: i64) -> bool

# --- SFTP File Transfer ---

extern fn rt_sftp_init(session: i64) -> i64  # Returns SFTP handle
extern fn rt_sftp_shutdown(sftp: i64) -> bool
extern fn rt_sftp_upload(sftp: i64, local_path: text, remote_path: text) -> bool
extern fn rt_sftp_download(sftp: i64, remote_path: text, local_path: text) -> bool
extern fn rt_sftp_mkdir(sftp: i64, path: text, mode: i64) -> bool
extern fn rt_sftp_rmdir(sftp: i64, path: text) -> bool
extern fn rt_sftp_unlink(sftp: i64, path: text) -> bool
extern fn rt_sftp_rename(sftp: i64, src: text, dst: text) -> bool
extern fn rt_sftp_readdir(sftp: i64, path: text) -> text  # Newline-separated
extern fn rt_sftp_stat(sftp: i64, path: text) -> (i64, i64, i64)  # (size, mode, mtime)

# --- Port Forwarding ---

extern fn rt_ssh_forward_local(session: i64, local_host: text, local_port: i64, remote_host: text, remote_port: i64) -> i64
extern fn rt_ssh_forward_remote(session: i64, remote_host: text, remote_port: i64, local_host: text, local_port: i64) -> i64
extern fn rt_ssh_forward_close(forward: i64) -> bool

# --- Known Hosts ---

extern fn rt_ssh_check_host_key(session: i64, known_hosts_file: text) -> bool
extern fn rt_ssh_get_host_key(session: i64) -> text
extern fn rt_ssh_add_known_host(known_hosts_file: text, host: text, key: text) -> bool

# --- Session Info ---

extern fn rt_ssh_get_banner(session: i64) -> text
extern fn rt_ssh_get_methods(session: i64) -> text
extern fn rt_ssh_set_timeout(session: i64, timeout_ms: i64) -> bool
extern fn rt_ssh_is_authenticated(session: i64) -> bool

# ============================================================================
# Tier 2: Simple-Friendly Wrapper Functions
# ============================================================================

# --- Core Types ---

struct SshSession:
    handle: i64
    host: text
    port: i64
    is_valid: bool

struct SshChannel:
    handle: i64
    is_valid: bool

struct SftpSession:
    handle: i64
    is_valid: bool

struct SshExecResult:
    exit_code: i64
    stdout: text
    stderr: text

struct SftpFileInfo:
    size: i64
    mode: i64
    mtime: i64

# --- Session Management ---

fn ssh_connect(host: text, port: i64) -> SshSession:
    """Connect to SSH server

    Args:
        host: SSH server hostname/IP
        port: Port number (usually 22)

    Returns: SshSession (check is_valid)

    Example:
        session = ssh_connect("example.com", 22)
        if session.is_valid:
            ssh_auth_password(session, "user", "pass")
    """
    val handle = rt_ssh_connect(host, port)
    SshSession(handle: handle, host: host, port: port, is_valid: is_valid_handle(handle))

fn ssh_disconnect(session: SshSession) -> bool:
    """Disconnect from SSH server"""
    if is_invalid_handle(session.handle):
        return false

    rt_ssh_disconnect(session.handle)

fn ssh_auth_password(session: SshSession, username: text, password: text) -> bool:
    """Authenticate with username/password

    Args:
        username: SSH username
        password: SSH password

    Returns: true if authentication successful

    Example:
        if ssh_auth_password(session, "admin", "secret"):
            print "Authenticated successfully"
    """
    if is_invalid_handle(session.handle):
        return false

    rt_ssh_auth_password(session.handle, username, password)

fn ssh_auth_pubkey(session: SshSession, username: text, pubkey_path: text, privkey_path: text, passphrase: text) -> bool:
    """Authenticate with public key

    Args:
        username: SSH username
        pubkey_path: Path to public key file (e.g., ~/.ssh/id_rsa.pub)
        privkey_path: Path to private key file (e.g., ~/.ssh/id_rsa)
        passphrase: Key passphrase (empty if no passphrase)

    Returns: true if authentication successful

    Example:
        if ssh_auth_pubkey(session, "user", "~/.ssh/id_rsa.pub", "~/.ssh/id_rsa", ""):
            print "Authenticated with key"
    """
    if is_invalid_handle(session.handle):
        return false

    rt_ssh_auth_pubkey(session.handle, username, pubkey_path, privkey_path, passphrase)

fn ssh_auth_agent(session: SshSession, username: text) -> bool:
    """Authenticate using SSH agent

    Args:
        username: SSH username

    Returns: true if authentication successful
    """
    if is_invalid_handle(session.handle):
        return false

    rt_ssh_auth_agent(session.handle, username)

# --- Remote Command Execution ---

fn ssh_exec(session: SshSession, command: text) -> SshExecResult:
    """Execute command on remote server

    Args:
        command: Shell command to execute

    Returns: SshExecResult with exit code, stdout, stderr

    Example:
        result = ssh_exec(session, "ls -la /home")
        print "Output: {result.stdout}"
        print "Exit code: {result.exit_code}"
    """
    if is_invalid_handle(session.handle):
        return SshExecResult(exit_code: -1, stdout: "", stderr: "Invalid session")

    val result_tuple = rt_ssh_exec(session.handle, command)
    SshExecResult(exit_code: result_tuple.0, stdout: result_tuple.1, stderr: result_tuple.2)

fn ssh_shell(session: SshSession) -> SshChannel:
    """Open interactive shell channel

    Returns: SshChannel for interactive commands
    """
    if is_invalid_handle(session.handle):
        return SshChannel(handle: 0, is_valid: false)

    val handle = rt_ssh_shell(session.handle)
    SshChannel(handle: handle, is_valid: is_valid_handle(handle))

fn ssh_channel_read(channel: SshChannel) -> text:
    """Read data from channel"""
    if is_invalid_handle(channel.handle):
        return ""

    rt_ssh_channel_read(channel.handle)

fn ssh_channel_write(channel: SshChannel, data: text) -> i64:
    """Write data to channel

    Returns: Number of bytes written
    """
    if is_invalid_handle(channel.handle):
        return 0

    rt_ssh_channel_write(channel.handle, data)

fn ssh_channel_close(channel: SshChannel) -> bool:
    """Close channel"""
    if is_invalid_handle(channel.handle):
        return false

    rt_ssh_channel_close(channel.handle)

# --- SFTP File Transfer ---

fn sftp_init(session: SshSession) -> SftpSession:
    """Initialize SFTP subsystem

    Args:
        session: Authenticated SSH session

    Returns: SftpSession for file operations

    Example:
        sftp = sftp_init(session)
        if sftp.is_valid:
            sftp_upload(sftp, "local.txt", "/remote/path.txt")
    """
    if is_invalid_handle(session.handle):
        return SftpSession(handle: 0, is_valid: false)

    val handle = rt_sftp_init(session.handle)
    SftpSession(handle: handle, is_valid: is_valid_handle(handle))

fn sftp_shutdown(sftp: SftpSession) -> bool:
    """Shutdown SFTP subsystem"""
    if is_invalid_handle(sftp.handle):
        return false

    rt_sftp_shutdown(sftp.handle)

fn sftp_upload(sftp: SftpSession, local_path: text, remote_path: text) -> bool:
    """Upload file to remote server

    Args:
        local_path: Local file to upload
        remote_path: Destination path on server

    Returns: true if successful

    Example:
        if sftp_upload(sftp, "/tmp/data.txt", "/home/user/data.txt"):
            print "Upload successful"
    """
    if is_invalid_handle(sftp.handle):
        return false

    rt_sftp_upload(sftp.handle, local_path, remote_path)

fn sftp_download(sftp: SftpSession, remote_path: text, local_path: text) -> bool:
    """Download file from remote server

    Args:
        remote_path: Remote file to download
        local_path: Local destination path

    Returns: true if successful
    """
    if is_invalid_handle(sftp.handle):
        return false

    rt_sftp_download(sftp.handle, remote_path, local_path)

fn sftp_mkdir(sftp: SftpSession, path: text, mode: i64) -> bool:
    """Create directory on remote server

    Args:
        path: Directory path
        mode: Permissions (e.g., 0o755)

    Returns: true if successful
    """
    if is_invalid_handle(sftp.handle):
        return false

    rt_sftp_mkdir(sftp.handle, path, mode)

fn sftp_rmdir(sftp: SftpSession, path: text) -> bool:
    """Remove directory on remote server"""
    if is_invalid_handle(sftp.handle):
        return false

    rt_sftp_rmdir(sftp.handle, path)

fn sftp_delete(sftp: SftpSession, path: text) -> bool:
    """Delete file on remote server"""
    if is_invalid_handle(sftp.handle):
        return false

    rt_sftp_unlink(sftp.handle, path)

fn sftp_rename(sftp: SftpSession, src: text, dst: text) -> bool:
    """Rename/move file on remote server"""
    if is_invalid_handle(sftp.handle):
        return false

    rt_sftp_rename(sftp.handle, src, dst)

fn sftp_list(sftp: SftpSession, path: text) -> [text]:
    """List files in remote directory

    Args:
        path: Remote directory path

    Returns: Array of filenames

    Example:
        files = sftp_list(sftp, "/home/user")
        for file in files:
            print file
    """
    if is_invalid_handle(sftp.handle):
        return []

    val result = rt_sftp_readdir(sftp.handle, path)
    if result == "":
        return []

    result.split("\n")

fn sftp_stat(sftp: SftpSession, path: text) -> SftpFileInfo:
    """Get file information

    Args:
        path: Remote file path

    Returns: SftpFileInfo with size, mode, mtime
    """
    if is_invalid_handle(sftp.handle):
        return SftpFileInfo(size: 0, mode: 0, mtime: 0)

    val stats = rt_sftp_stat(sftp.handle, path)
    SftpFileInfo(size: stats.0, mode: stats.1, mtime: stats.2)

# --- Utilities ---

fn ssh_is_authenticated(session: SshSession) -> bool:
    """Check if session is authenticated"""
    if is_invalid_handle(session.handle):
        return false

    rt_ssh_is_authenticated(session.handle)

fn ssh_get_banner(session: SshSession) -> text:
    """Get SSH server banner"""
    if is_invalid_handle(session.handle):
        return ""

    rt_ssh_get_banner(session.handle)

fn ssh_set_timeout(session: SshSession, timeout_ms: i64) -> bool:
    """Set session timeout in milliseconds"""
    if is_invalid_handle(session.handle):
        return false

    rt_ssh_set_timeout(session.handle, timeout_ms)

# ============================================================================
# Export Functions
# ============================================================================

export SshSession, SshChannel, SftpSession, SshExecResult, SftpFileInfo
export ssh_connect, ssh_disconnect
export ssh_auth_password, ssh_auth_pubkey, ssh_auth_agent
export ssh_exec, ssh_shell
export ssh_channel_read, ssh_channel_write, ssh_channel_close
export sftp_init, sftp_shutdown
export sftp_upload, sftp_download, sftp_mkdir, sftp_rmdir, sftp_delete, sftp_rename
export sftp_list, sftp_stat
export ssh_is_authenticated, ssh_get_banner, ssh_set_timeout
