# Lyon 2D Graphics SFFI Bindings
#
# SFFI pattern for Lyon 2D vector graphics tessellation.
# Provides path building, stroke, fill, and shape primitives.
#
# Documentation: https://docs.rs/lyon/

# ============================================================================
# Tier 1: Extern Declarations (Raw FFI)
# ============================================================================

# --- Path Builder ---
extern fn rt_lyon_path_builder_new() -> i64
extern fn rt_lyon_path_builder_free(builder: i64) -> bool
extern fn rt_lyon_path_builder_begin(builder: i64, x: f64, y: f64) -> bool
extern fn rt_lyon_path_builder_line_to(builder: i64, x: f64, y: f64) -> bool
extern fn rt_lyon_path_builder_quadratic_bezier_to(builder: i64, ctrl_x: f64, ctrl_y: f64, to_x: f64, to_y: f64) -> bool
extern fn rt_lyon_path_builder_cubic_bezier_to(builder: i64, ctrl1_x: f64, ctrl1_y: f64, ctrl2_x: f64, ctrl2_y: f64, to_x: f64, to_y: f64) -> bool
extern fn rt_lyon_path_builder_arc_to(builder: i64, center_x: f64, center_y: f64, radius: f64, start_angle: f64, sweep_angle: f64) -> bool
extern fn rt_lyon_path_builder_close(builder: i64) -> bool
extern fn rt_lyon_path_builder_build(builder: i64) -> i64

# --- Path Operations ---
extern fn rt_lyon_path_free(path: i64) -> bool
extern fn rt_lyon_path_get_bounds(path: i64) -> (f64, f64, f64, f64)
extern fn rt_lyon_path_contains_point(path: i64, x: f64, y: f64) -> bool
extern fn rt_lyon_path_transform(path: i64, m11: f64, m12: f64, m21: f64, m22: f64, tx: f64, ty: f64) -> i64

# --- Shape Primitives ---
extern fn rt_lyon_path_rectangle(x: f64, y: f64, width: f64, height: f64) -> i64
extern fn rt_lyon_path_rounded_rectangle(x: f64, y: f64, width: f64, height: f64, radius: f64) -> i64
extern fn rt_lyon_path_circle(center_x: f64, center_y: f64, radius: f64) -> i64
extern fn rt_lyon_path_ellipse(center_x: f64, center_y: f64, radius_x: f64, radius_y: f64) -> i64
extern fn rt_lyon_path_polygon(points: [f64], num_points: i64) -> i64
extern fn rt_lyon_path_star(center_x: f64, center_y: f64, inner_radius: f64, outer_radius: f64, num_points: i64) -> i64

# --- Fill Tessellation ---
extern fn rt_lyon_fill_tessellate(path: i64, tolerance: f64) -> i64
extern fn rt_lyon_fill_tessellate_with_rule(path: i64, tolerance: f64, fill_rule: i64) -> i64
extern fn rt_lyon_fill_tessellation_free(tess: i64) -> bool
extern fn rt_lyon_fill_tessellation_get_vertices(tess: i64) -> i64
extern fn rt_lyon_fill_tessellation_get_indices(tess: i64) -> i64
extern fn rt_lyon_fill_tessellation_vertex_count(tess: i64) -> i64
extern fn rt_lyon_fill_tessellation_index_count(tess: i64) -> i64

# --- Stroke Tessellation ---
extern fn rt_lyon_stroke_tessellate(path: i64, width: f64, tolerance: f64) -> i64
extern fn rt_lyon_stroke_tessellate_with_options(path: i64, width: f64, tolerance: f64, options_json: text) -> i64
extern fn rt_lyon_stroke_tessellation_free(tess: i64) -> bool
extern fn rt_lyon_stroke_tessellation_get_vertices(tess: i64) -> i64
extern fn rt_lyon_stroke_tessellation_get_indices(tess: i64) -> i64
extern fn rt_lyon_stroke_tessellation_vertex_count(tess: i64) -> i64
extern fn rt_lyon_stroke_tessellation_index_count(tess: i64) -> i64

# --- Vertex Buffer ---
extern fn rt_lyon_vertex_buffer_free(buffer: i64) -> bool
extern fn rt_lyon_vertex_buffer_get_position(buffer: i64, index: i64) -> (f64, f64)
extern fn rt_lyon_vertex_buffer_get_normal(buffer: i64, index: i64) -> (f64, f64)
extern fn rt_lyon_vertex_buffer_size(buffer: i64) -> i64
extern fn rt_lyon_vertex_buffer_to_array(buffer: i64) -> [f64]

# --- Index Buffer ---
extern fn rt_lyon_index_buffer_free(buffer: i64) -> bool
extern fn rt_lyon_index_buffer_get(buffer: i64, index: i64) -> i64
extern fn rt_lyon_index_buffer_size(buffer: i64) -> i64
extern fn rt_lyon_index_buffer_to_array(buffer: i64) -> [i64]

# --- Transform ---
extern fn rt_lyon_transform_identity() -> i64
extern fn rt_lyon_transform_translate(tx: f64, ty: f64) -> i64
extern fn rt_lyon_transform_rotate(angle: f64) -> i64
extern fn rt_lyon_transform_scale(sx: f64, sy: f64) -> i64
extern fn rt_lyon_transform_multiply(t1: i64, t2: i64) -> i64
extern fn rt_lyon_transform_free(transform: i64) -> bool

# --- Utilities ---
extern fn rt_lyon_get_last_error() -> text

# ============================================================================
# Tier 2: Simple-Friendly Wrapper Functions
# ============================================================================

# --- Core Types ---

struct Point2D:
    x: f64
    y: f64

struct Vector2D:
    x: f64
    y: f64

struct Rect:
    x: f64
    y: f64
    width: f64
    height: f64

struct Bounds:
    min_x: f64
    min_y: f64
    max_x: f64
    max_y: f64

impl Bounds:
    fn width() -> f64:
        self.max_x - self.min_x

    fn height() -> f64:
        self.max_y - self.min_y

    fn center() -> Point2D:
        Point2D(
            x: (self.min_x + self.max_x) / 2.0,
            y: (self.min_y + self.max_y) / 2.0
        )

# --- Path Builder ---

struct PathBuilder:
    handle: i64
    is_valid: bool
    is_closed: bool

fn graphics_path_builder_new() -> PathBuilder:
    val handle = rt_lyon_path_builder_new()
    PathBuilder(handle: handle, is_valid: handle != 0, is_closed: false)

fn graphics_path_builder_free(builder: PathBuilder) -> bool:
    if builder.is_valid:
        rt_lyon_path_builder_free(builder.handle)
    else:
        true

fn graphics_path_begin(builder: PathBuilder, point: Point2D) -> bool:
    if not builder.is_valid:
        false
    else:
        rt_lyon_path_builder_begin(builder.handle, point.x, point.y)

fn graphics_path_line_to(builder: PathBuilder, point: Point2D) -> bool:
    if not builder.is_valid:
        false
    else:
        rt_lyon_path_builder_line_to(builder.handle, point.x, point.y)

fn graphics_path_quadratic_to(builder: PathBuilder, ctrl: Point2D, to: Point2D) -> bool:
    if not builder.is_valid:
        false
    else:
        rt_lyon_path_builder_quadratic_bezier_to(builder.handle, ctrl.x, ctrl.y, to.x, to.y)

fn graphics_path_cubic_to(builder: PathBuilder, ctrl1: Point2D, ctrl2: Point2D, to: Point2D) -> bool:
    if not builder.is_valid:
        false
    else:
        rt_lyon_path_builder_cubic_bezier_to(builder.handle, ctrl1.x, ctrl1.y, ctrl2.x, ctrl2.y, to.x, to.y)

fn graphics_path_arc_to(builder: PathBuilder, center: Point2D, radius: f64, start_angle: f64, sweep_angle: f64) -> bool:
    if not builder.is_valid:
        false
    else:
        rt_lyon_path_builder_arc_to(builder.handle, center.x, center.y, radius, start_angle, sweep_angle)

fn graphics_path_close(builder: PathBuilder) -> bool:
    if not builder.is_valid:
        false
    else:
        rt_lyon_path_builder_close(builder.handle)

fn graphics_path_build(builder: PathBuilder) -> Path:
    if not builder.is_valid:
        Path(handle: 0, is_valid: false)
    else:
        val handle = rt_lyon_path_builder_build(builder.handle)
        Path(handle: handle, is_valid: handle != 0)

# --- Path ---

struct Path:
    handle: i64
    is_valid: bool

fn graphics_path_free(path: Path) -> bool:
    if path.is_valid:
        rt_lyon_path_free(path.handle)
    else:
        true

fn graphics_path_get_bounds(path: Path) -> Bounds:
    if not path.is_valid:
        Bounds(min_x: 0.0, min_y: 0.0, max_x: 0.0, max_y: 0.0)
    else:
        val result = rt_lyon_path_get_bounds(path.handle)
        Bounds(min_x: result.0, min_y: result.1, max_x: result.2, max_y: result.3)

fn graphics_path_contains_point(path: Path, point: Point2D) -> bool:
    if not path.is_valid:
        false
    else:
        rt_lyon_path_contains_point(path.handle, point.x, point.y)

# --- Shape Primitives ---

fn graphics_rectangle(rect: Rect) -> Path:
    val handle = rt_lyon_path_rectangle(rect.x, rect.y, rect.width, rect.height)
    Path(handle: handle, is_valid: handle != 0)

fn graphics_rounded_rectangle(rect: Rect, corner_radius: f64) -> Path:
    val handle = rt_lyon_path_rounded_rectangle(rect.x, rect.y, rect.width, rect.height, corner_radius)
    Path(handle: handle, is_valid: handle != 0)

fn graphics_circle(center: Point2D, radius: f64) -> Path:
    val handle = rt_lyon_path_circle(center.x, center.y, radius)
    Path(handle: handle, is_valid: handle != 0)

fn graphics_ellipse(center: Point2D, radius_x: f64, radius_y: f64) -> Path:
    val handle = rt_lyon_path_ellipse(center.x, center.y, radius_x, radius_y)
    Path(handle: handle, is_valid: handle != 0)

fn graphics_polygon(points: [Point2D]) -> Path:
    # Flatten points to array of f64
    var flat_points: [f64] = []
    for point in points:
        flat_points.push(point.x)
        flat_points.push(point.y)

    val handle = rt_lyon_path_polygon(flat_points, points.len())
    Path(handle: handle, is_valid: handle != 0)

fn graphics_star(center: Point2D, inner_radius: f64, outer_radius: f64, num_points: i64) -> Path:
    val handle = rt_lyon_path_star(center.x, center.y, inner_radius, outer_radius, num_points)
    Path(handle: handle, is_valid: handle != 0)

# --- Fill Tessellation ---

enum FillRule:
    EvenOdd
    NonZero

fn fill_rule_to_code(rule: FillRule) -> i64:
    if rule == FillRule.EvenOdd:
        0
    else:
        1

struct FillTessellation:
    handle: i64
    is_valid: bool

fn graphics_fill_tessellate(path: Path, tolerance: f64) -> FillTessellation:
    if not path.is_valid:
        FillTessellation(handle: 0, is_valid: false)
    else:
        val handle = rt_lyon_fill_tessellate(path.handle, tolerance)
        FillTessellation(handle: handle, is_valid: handle != 0)

fn graphics_fill_tessellate_with_rule(path: Path, tolerance: f64, fill_rule: FillRule) -> FillTessellation:
    if not path.is_valid:
        FillTessellation(handle: 0, is_valid: false)
    else:
        val rule_code = fill_rule_to_code(fill_rule)
        val handle = rt_lyon_fill_tessellate_with_rule(path.handle, tolerance, rule_code)
        FillTessellation(handle: handle, is_valid: handle != 0)

fn graphics_fill_free(tess: FillTessellation) -> bool:
    if tess.is_valid:
        rt_lyon_fill_tessellation_free(tess.handle)
    else:
        true

fn graphics_fill_vertex_count(tess: FillTessellation) -> i64:
    if not tess.is_valid:
        0
    else:
        rt_lyon_fill_tessellation_vertex_count(tess.handle)

fn graphics_fill_index_count(tess: FillTessellation) -> i64:
    if not tess.is_valid:
        0
    else:
        rt_lyon_fill_tessellation_index_count(tess.handle)

fn graphics_fill_get_vertices(tess: FillTessellation) -> VertexBuffer:
    if not tess.is_valid:
        VertexBuffer(handle: 0, is_valid: false)
    else:
        val handle = rt_lyon_fill_tessellation_get_vertices(tess.handle)
        VertexBuffer(handle: handle, is_valid: handle != 0)

fn graphics_fill_get_indices(tess: FillTessellation) -> IndexBuffer:
    if not tess.is_valid:
        IndexBuffer(handle: 0, is_valid: false)
    else:
        val handle = rt_lyon_fill_tessellation_get_indices(tess.handle)
        IndexBuffer(handle: handle, is_valid: handle != 0)

# --- Stroke Tessellation ---

enum LineCap:
    Butt
    Square
    Round

enum LineJoin:
    Miter
    Round
    Bevel

struct StrokeOptions:
    width: f64
    line_cap: LineCap
    line_join: LineJoin
    miter_limit: f64

fn stroke_options_default() -> StrokeOptions:
    StrokeOptions(
        width: 1.0,
        line_cap: LineCap.Butt,
        line_join: LineJoin.Miter,
        miter_limit: 4.0
    )

struct StrokeTessellation:
    handle: i64
    is_valid: bool

fn graphics_stroke_tessellate(path: Path, width: f64, tolerance: f64) -> StrokeTessellation:
    if not path.is_valid:
        StrokeTessellation(handle: 0, is_valid: false)
    else:
        val handle = rt_lyon_stroke_tessellate(path.handle, width, tolerance)
        StrokeTessellation(handle: handle, is_valid: handle != 0)

fn graphics_stroke_tessellate_with_options(path: Path, options: StrokeOptions, tolerance: f64) -> StrokeTessellation:
    if not path.is_valid:
        StrokeTessellation(handle: 0, is_valid: false)
    else:
        # Build JSON options string
        val line_cap_str = if options.line_cap == LineCap.Butt:
            "butt"
        elif options.line_cap == LineCap.Square:
            "square"
        else:
            "round"

        val line_join_str = if options.line_join == LineJoin.Miter:
            "miter"
        elif options.line_join == LineJoin.Round:
            "round"
        else:
            "bevel"

        val options_json = "{{\"line_cap\":\"{line_cap_str}\",\"line_join\":\"{line_join_str}\",\"miter_limit\":{options.miter_limit}}}"

        val handle = rt_lyon_stroke_tessellate_with_options(path.handle, options.width, tolerance, options_json)
        StrokeTessellation(handle: handle, is_valid: handle != 0)

fn graphics_stroke_free(tess: StrokeTessellation) -> bool:
    if tess.is_valid:
        rt_lyon_stroke_tessellation_free(tess.handle)
    else:
        true

fn graphics_stroke_vertex_count(tess: StrokeTessellation) -> i64:
    if not tess.is_valid:
        0
    else:
        rt_lyon_stroke_tessellation_vertex_count(tess.handle)

fn graphics_stroke_index_count(tess: StrokeTessellation) -> i64:
    if not tess.is_valid:
        0
    else:
        rt_lyon_stroke_tessellation_index_count(tess.handle)

fn graphics_stroke_get_vertices(tess: StrokeTessellation) -> VertexBuffer:
    if not tess.is_valid:
        VertexBuffer(handle: 0, is_valid: false)
    else:
        val handle = rt_lyon_stroke_tessellation_get_vertices(tess.handle)
        VertexBuffer(handle: handle, is_valid: handle != 0)

fn graphics_stroke_get_indices(tess: StrokeTessellation) -> IndexBuffer:
    if not tess.is_valid:
        IndexBuffer(handle: 0, is_valid: false)
    else:
        val handle = rt_lyon_stroke_tessellation_get_indices(tess.handle)
        IndexBuffer(handle: handle, is_valid: handle != 0)

# --- Vertex Buffer ---

struct VertexBuffer:
    handle: i64
    is_valid: bool

fn graphics_vertex_buffer_free(buffer: VertexBuffer) -> bool:
    if buffer.is_valid:
        rt_lyon_vertex_buffer_free(buffer.handle)
    else:
        true

fn graphics_vertex_buffer_size(buffer: VertexBuffer) -> i64:
    if not buffer.is_valid:
        0
    else:
        rt_lyon_vertex_buffer_size(buffer.handle)

fn graphics_vertex_buffer_get_position(buffer: VertexBuffer, index: i64) -> Point2D:
    if not buffer.is_valid:
        Point2D(x: 0.0, y: 0.0)
    else:
        val result = rt_lyon_vertex_buffer_get_position(buffer.handle, index)
        Point2D(x: result.0, y: result.1)

fn graphics_vertex_buffer_get_normal(buffer: VertexBuffer, index: i64) -> Vector2D:
    if not buffer.is_valid:
        Vector2D(x: 0.0, y: 0.0)
    else:
        val result = rt_lyon_vertex_buffer_get_normal(buffer.handle, index)
        Vector2D(x: result.0, y: result.1)

fn graphics_vertex_buffer_to_array(buffer: VertexBuffer) -> [f64]:
    if not buffer.is_valid:
        []
    else:
        rt_lyon_vertex_buffer_to_array(buffer.handle)

# --- Index Buffer ---

struct IndexBuffer:
    handle: i64
    is_valid: bool

fn graphics_index_buffer_free(buffer: IndexBuffer) -> bool:
    if buffer.is_valid:
        rt_lyon_index_buffer_free(buffer.handle)
    else:
        true

fn graphics_index_buffer_size(buffer: IndexBuffer) -> i64:
    if not buffer.is_valid:
        0
    else:
        rt_lyon_index_buffer_size(buffer.handle)

fn graphics_index_buffer_get(buffer: IndexBuffer, index: i64) -> i64:
    if not buffer.is_valid:
        0
    else:
        rt_lyon_index_buffer_get(buffer.handle, index)

fn graphics_index_buffer_to_array(buffer: IndexBuffer) -> [i64]:
    if not buffer.is_valid:
        []
    else:
        rt_lyon_index_buffer_to_array(buffer.handle)

# --- Transform ---

struct Transform2D:
    handle: i64
    is_valid: bool

fn graphics_transform_identity() -> Transform2D:
    val handle = rt_lyon_transform_identity()
    Transform2D(handle: handle, is_valid: handle != 0)

fn graphics_transform_translate(offset: Vector2D) -> Transform2D:
    val handle = rt_lyon_transform_translate(offset.x, offset.y)
    Transform2D(handle: handle, is_valid: handle != 0)

fn graphics_transform_rotate(angle: f64) -> Transform2D:
    val handle = rt_lyon_transform_rotate(angle)
    Transform2D(handle: handle, is_valid: handle != 0)

fn graphics_transform_scale(scale: Vector2D) -> Transform2D:
    val handle = rt_lyon_transform_scale(scale.x, scale.y)
    Transform2D(handle: handle, is_valid: handle != 0)

fn graphics_transform_multiply(t1: Transform2D, t2: Transform2D) -> Transform2D:
    if not t1.is_valid or not t2.is_valid:
        Transform2D(handle: 0, is_valid: false)
    else:
        val handle = rt_lyon_transform_multiply(t1.handle, t2.handle)
        Transform2D(handle: handle, is_valid: handle != 0)

fn graphics_transform_free(transform: Transform2D) -> bool:
    if transform.is_valid:
        rt_lyon_transform_free(transform.handle)
    else:
        true

fn graphics_path_transform(path: Path, transform: Transform2D) -> Path:
    if not path.is_valid or not transform.is_valid:
        Path(handle: 0, is_valid: false)
    else:
        # For now, use identity matrix - full implementation needs matrix extraction
        val handle = rt_lyon_path_transform(path.handle, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0)
        Path(handle: handle, is_valid: handle != 0)

# --- Utilities ---

fn graphics_last_error() -> text:
    rt_lyon_get_last_error()

# ============================================================================
# Exports
# ============================================================================

export Point2D, Vector2D, Rect, Bounds
export PathBuilder, graphics_path_builder_new, graphics_path_builder_free
export graphics_path_begin, graphics_path_line_to, graphics_path_quadratic_to
export graphics_path_cubic_to, graphics_path_arc_to, graphics_path_close, graphics_path_build
export Path, graphics_path_free, graphics_path_get_bounds, graphics_path_contains_point
export graphics_rectangle, graphics_rounded_rectangle, graphics_circle, graphics_ellipse
export graphics_polygon, graphics_star
export FillRule, FillTessellation
export graphics_fill_tessellate, graphics_fill_tessellate_with_rule, graphics_fill_free
export graphics_fill_vertex_count, graphics_fill_index_count
export graphics_fill_get_vertices, graphics_fill_get_indices
export LineCap, LineJoin, StrokeOptions, stroke_options_default, StrokeTessellation
export graphics_stroke_tessellate, graphics_stroke_tessellate_with_options, graphics_stroke_free
export graphics_stroke_vertex_count, graphics_stroke_index_count
export graphics_stroke_get_vertices, graphics_stroke_get_indices
export VertexBuffer, graphics_vertex_buffer_free, graphics_vertex_buffer_size
export graphics_vertex_buffer_get_position, graphics_vertex_buffer_get_normal
export graphics_vertex_buffer_to_array
export IndexBuffer, graphics_index_buffer_free, graphics_index_buffer_size
export graphics_index_buffer_get, graphics_index_buffer_to_array
export Transform2D, graphics_transform_identity, graphics_transform_translate
export graphics_transform_rotate, graphics_transform_scale, graphics_transform_multiply
export graphics_transform_free, graphics_path_transform
export graphics_last_error
