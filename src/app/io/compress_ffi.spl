# Compression SFFI Wrapper
# Two-tier SFFI pattern for compression and archive operations
# Dependencies: flate2, zip, tar (Rust crates)

use app.io.sffi_common.{is_valid_handle, is_invalid_handle, is_empty_string}
use std.text.{NL}

# ============================================================================
# Tier 1: Extern Function Declarations (Raw FFI)
# ============================================================================

# --- Gzip Compression ---

extern fn rt_gzip_compress(data: text, level: i64) -> text
extern fn rt_gzip_decompress(data: text) -> text
extern fn rt_gzip_compress_file(input: text, output: text, level: i64) -> i64
extern fn rt_gzip_decompress_file(input: text, output: text) -> i64

# --- Deflate Compression (raw) ---

extern fn rt_deflate_compress(data: text, level: i64) -> text
extern fn rt_deflate_decompress(data: text) -> text

# --- Zip Archive ---

extern fn rt_zip_create(path: text) -> i64
extern fn rt_zip_open(path: text) -> i64
extern fn rt_zip_add_file(handle: i64, archive_path: text, file_path: text) -> i64
extern fn rt_zip_add_data(handle: i64, archive_path: text, data: text) -> i64
extern fn rt_zip_extract(handle: i64, output_dir: text) -> i64
extern fn rt_zip_extract_file(handle: i64, archive_path: text, output_path: text) -> i64
extern fn rt_zip_list(handle: i64) -> text
extern fn rt_zip_close(handle: i64)

# --- Tar Archive ---

extern fn rt_tar_create(path: text) -> i64
extern fn rt_tar_open(path: text) -> i64
extern fn rt_tar_add_file(handle: i64, archive_path: text, file_path: text) -> i64
extern fn rt_tar_add_data(handle: i64, archive_path: text, data: text) -> i64
extern fn rt_tar_extract(handle: i64, output_dir: text) -> i64
extern fn rt_tar_extract_file(handle: i64, archive_path: text, output_path: text) -> i64
extern fn rt_tar_list(handle: i64) -> text
extern fn rt_tar_close(handle: i64)

# --- Combined Tar.gz ---

extern fn rt_targz_create(tar_path: text, output_path: text, level: i64) -> i64
extern fn rt_targz_extract(input_path: text, output_dir: text) -> i64

# ============================================================================
# Tier 2: Simple-Friendly Wrapper Functions
# ============================================================================

# --- Core Types ---

struct ZipArchive:
    handle: i64
    path: text
    is_valid: bool

struct TarArchive:
    handle: i64
    path: text
    is_valid: bool

enum CompressionLevel:
    None_
    Fast
    Default
    Best

# --- Compression Level Helpers ---

fn compression_level_to_int(level: CompressionLevel) -> i64:
    """Convert CompressionLevel enum to integer

    Returns: 0 (nil), 1 (Fast), 6 (Default), 9 (Best)
    """
    match level:
        CompressionLevel.None: 0
        CompressionLevel.Fast: 1
        CompressionLevel.Default: 6
        CompressionLevel.Best: 9

# --- Gzip Compression ---

fn gzip_compress(data: text, level: CompressionLevel) -> text:
    """Compress data using gzip

    Args:
        data: Data to compress
        level: Compression level

    Returns: Compressed data (binary), empty string on error

    Example:
        compressed = gzip_compress("Hello World!", CompressionLevel.Default)
    """
    val level_int = compression_level_to_int(level)
    rt_gzip_compress(data, level_int)

fn gzip_decompress(data: text) -> text:
    """Decompress gzip data

    Args:
        data: Compressed data

    Returns: Decompressed data, empty string on error
    """
    rt_gzip_decompress(data)

fn gzip_compress_file(input_path: text, output_path: text, level: CompressionLevel) -> bool:
    """Compress file to .gz

    Args:
        input_path: Input file path
        output_path: Output .gz file path
        level: Compression level

    Returns: true on success

    Example:
        gzip_compress_file("data.txt", "data.txt.gz", CompressionLevel.Best)
    """
    val level_int = compression_level_to_int(level)
    val result = rt_gzip_compress_file(input_path, output_path, level_int)
    result == 1

fn gzip_decompress_file(input_path: text, output_path: text) -> bool:
    """Decompress .gz file

    Args:
        input_path: Input .gz file path
        output_path: Output file path

    Returns: true on success
    """
    val result = rt_gzip_decompress_file(input_path, output_path)
    result == 1

# --- Deflate Compression (raw) ---

fn deflate_compress(data: text, level: CompressionLevel) -> text:
    """Compress data using deflate (raw, no headers)

    Returns: Compressed data (binary)
    """
    val level_int = compression_level_to_int(level)
    rt_deflate_compress(data, level_int)

fn deflate_decompress(data: text) -> text:
    """Decompress deflate data

    Returns: Decompressed data
    """
    rt_deflate_decompress(data)

# --- Zip Archive ---

fn zip_create(path: text) -> ZipArchive:
    """Create new zip archive

    Args:
        path: Path to zip file (will be created/overwritten)

    Returns: Zip archive handle (check is_valid)

    Example:
        zip = zip_create("archive.zip")
        if zip.is_valid:
            zip_add_file(zip, "data.txt", "path/to/data.txt")
            zip_close(zip)
    """
    val handle = rt_zip_create(path)
    ZipArchive(handle: handle, path: path, is_valid: is_valid_handle(handle))

fn zip_open(path: text) -> ZipArchive:
    """Open existing zip archive

    Args:
        path: Path to zip file

    Returns: Zip archive handle (check is_valid)
    """
    val handle = rt_zip_open(path)
    ZipArchive(handle: handle, path: path, is_valid: is_valid_handle(handle))

fn zip_add_file(archive: ZipArchive, archive_path: text, file_path: text) -> bool:
    """Add file to zip archive

    Args:
        archive: Zip archive
        archive_path: Path inside archive (e.g., "data/file.txt")
        file_path: Path to file on disk

    Returns: true on success

    Example:
        zip = zip_create("backup.zip")
        zip_add_file(zip, "config.txt", "/path/to/config.txt")
    """
    if is_invalid_handle(archive.handle):
        return false

    val result = rt_zip_add_file(archive.handle, archive_path, file_path)
    result == 1

fn zip_add_data(archive: ZipArchive, archive_path: text, data: text) -> bool:
    """Add data to zip archive (in-memory)

    Args:
        archive: Zip archive
        archive_path: Path inside archive
        data: Data to add

    Returns: true on success

    Example:
        zip = zip_create("data.zip")
        zip_add_data(zip, "hello.txt", "Hello, World!")
    """
    if is_invalid_handle(archive.handle):
        return false

    val result = rt_zip_add_data(archive.handle, archive_path, data)
    result == 1

fn zip_extract(archive: ZipArchive, output_dir: text) -> bool:
    """Extract entire zip archive

    Args:
        archive: Zip archive
        output_dir: Output directory

    Returns: true on success

    Example:
        zip = zip_open("backup.zip")
        zip_extract(zip, "extracted/")
    """
    if is_invalid_handle(archive.handle):
        return false

    val result = rt_zip_extract(archive.handle, output_dir)
    result == 1

fn zip_extract_file(archive: ZipArchive, archive_path: text, output_path: text) -> bool:
    """Extract single file from zip archive

    Args:
        archive: Zip archive
        archive_path: Path inside archive
        output_path: Output file path

    Returns: true on success
    """
    if is_invalid_handle(archive.handle):
        return false

    val result = rt_zip_extract_file(archive.handle, archive_path, output_path)
    result == 1

fn zip_list(archive: ZipArchive) -> [text]:
    """List files in zip archive

    Returns: Array of file paths inside archive

    Example:
        zip = zip_open("archive.zip")
        files = zip_list(zip)
        for file in files:
            print file
    """
    if is_invalid_handle(archive.handle):
        return []

    val result = rt_zip_list(archive.handle)
    if result == "":
        return []

    result.split(NL)

fn zip_close(archive: ZipArchive):
    """Close zip archive"""
    if archive.is_valid:
        rt_zip_close(archive.handle)

# --- Tar Archive ---

fn tar_create(path: text) -> TarArchive:
    """Create new tar archive

    Args:
        path: Path to tar file (will be created/overwritten)

    Returns: Tar archive handle (check is_valid)

    Example:
        tar = tar_create("backup.tar")
        if tar.is_valid:
            tar_add_file(tar, "data.txt", "path/to/data.txt")
            tar_close(tar)
    """
    val handle = rt_tar_create(path)
    TarArchive(handle: handle, path: path, is_valid: is_valid_handle(handle))

fn tar_open(path: text) -> TarArchive:
    """Open existing tar archive

    Args:
        path: Path to tar file

    Returns: Tar archive handle (check is_valid)
    """
    val handle = rt_tar_open(path)
    TarArchive(handle: handle, path: path, is_valid: is_valid_handle(handle))

fn tar_add_file(archive: TarArchive, archive_path: text, file_path: text) -> bool:
    """Add file to tar archive

    Args:
        archive: Tar archive
        archive_path: Path inside archive
        file_path: Path to file on disk

    Returns: true on success
    """
    if is_invalid_handle(archive.handle):
        return false

    val result = rt_tar_add_file(archive.handle, archive_path, file_path)
    result == 1

fn tar_add_data(archive: TarArchive, archive_path: text, data: text) -> bool:
    """Add data to tar archive (in-memory)

    Args:
        archive: Tar archive
        archive_path: Path inside archive
        data: Data to add

    Returns: true on success
    """
    if is_invalid_handle(archive.handle):
        return false

    val result = rt_tar_add_data(archive.handle, archive_path, data)
    result == 1

fn tar_extract(archive: TarArchive, output_dir: text) -> bool:
    """Extract entire tar archive

    Args:
        archive: Tar archive
        output_dir: Output directory

    Returns: true on success
    """
    if is_invalid_handle(archive.handle):
        return false

    val result = rt_tar_extract(archive.handle, output_dir)
    result == 1

fn tar_extract_file(archive: TarArchive, archive_path: text, output_path: text) -> bool:
    """Extract single file from tar archive

    Returns: true on success
    """
    if is_invalid_handle(archive.handle):
        return false

    val result = rt_tar_extract_file(archive.handle, archive_path, output_path)
    result == 1

fn tar_list(archive: TarArchive) -> [text]:
    """List files in tar archive

    Returns: Array of file paths inside archive
    """
    if is_invalid_handle(archive.handle):
        return []

    val result = rt_tar_list(archive.handle)
    if result == "":
        return []

    result.split(NL)

fn tar_close(archive: TarArchive):
    """Close tar archive"""
    if archive.is_valid:
        rt_tar_close(archive.handle)

# --- Combined Tar.gz ---

fn targz_create(tar_path: text, output_path: text, level: CompressionLevel) -> bool:
    """Create tar.gz archive from tar file

    Args:
        tar_path: Input tar file
        output_path: Output .tar.gz file
        level: Compression level

    Returns: true on success

    Example:
        # Create tar, then compress to tar.gz
        tar = tar_create("backup.tar")
        tar_add_file(tar, "data.txt", "/path/to/data.txt")
        tar_close(tar)
        targz_create("backup.tar", "backup.tar.gz", CompressionLevel.Best)
    """
    val level_int = compression_level_to_int(level)
    val result = rt_targz_create(tar_path, output_path, level_int)
    result == 1

fn targz_extract(input_path: text, output_dir: text) -> bool:
    """Extract tar.gz archive

    Args:
        input_path: Input .tar.gz file
        output_dir: Output directory

    Returns: true on success

    Example:
        targz_extract("backup.tar.gz", "extracted/")
    """
    val result = rt_targz_extract(input_path, output_dir)
    result == 1

# --- Helper Functions ---

fn compress(data: text) -> text:
    """Default compression (gzip, default level)

    Returns: Compressed data
    """
    gzip_compress(data, CompressionLevel.Default)

fn decompress(data: text) -> text:
    """Default decompression (gzip)

    Returns: Decompressed data
    """
    gzip_decompress(data)

fn compress_file(input_path: text, output_path: text) -> bool:
    """Compress file (auto-detect format from extension)

    Supports: .gz, .zip

    Returns: true on success
    """
    if output_path.ends_with(".gz"):
        return gzip_compress_file(input_path, output_path, CompressionLevel.Default)

    if output_path.ends_with(".zip"):
        val zip = zip_create(output_path)
        if not zip.is_valid:
            return false

        val base_name = input_path.split("/").last()
        val success = zip_add_file(zip, base_name, input_path)
        zip_close(zip)
        return success

    false

fn decompress_file(input_path: text, output_path: text) -> bool:
    """Decompress file (auto-detect format from extension)

    Supports: .gz

    Returns: true on success
    """
    if input_path.ends_with(".gz"):
        return gzip_decompress_file(input_path, output_path)

    false

# ============================================================================
# Export Functions
# ============================================================================

export ZipArchive, TarArchive, CompressionLevel
export compression_level_to_int
export gzip_compress, gzip_decompress, gzip_compress_file, gzip_decompress_file
export deflate_compress, deflate_decompress
export zip_create, zip_open, zip_add_file, zip_add_data
export zip_extract, zip_extract_file, zip_list, zip_close
export tar_create, tar_open, tar_add_file, tar_add_data
export tar_extract, tar_extract_file, tar_list, tar_close
export targz_create, targz_extract
export compress, decompress, compress_file, decompress_file
