# Volatile Memory Operations - SFFI Wrappers
#
# Provides volatile read/write primitives for memory-mapped I/O (MMIO).
# Essential for embedded systems where compiler optimizations must not
# reorder or eliminate hardware register accesses.
#
# Two-tier SFFI pattern:
#   - extern fn rt_volatile_* : raw runtime bindings
#   - fn volatile_* : Simple API wrappers
#
# Usage:
#   val gpio_in = volatile_read_u32(0x40020010)
#   volatile_write_u32(0x40020014, 0x0001)
#   memory_barrier()
#
# Memory Barriers:
#   memory_barrier()  - full fence (prevents reordering across barrier)
#   load_barrier()    - acquire fence (loads before barrier are visible)
#   store_barrier()   - release fence (stores before barrier are committed)

# ============================================================================
# Extern Declarations - Volatile Reads
# ============================================================================

extern fn rt_volatile_read_u8(addr: i64) -> i64
extern fn rt_volatile_read_u16(addr: i64) -> i64
extern fn rt_volatile_read_u32(addr: i64) -> i64
extern fn rt_volatile_read_u64(addr: i64) -> i64

# ============================================================================
# Extern Declarations - Volatile Writes
# ============================================================================

extern fn rt_volatile_write_u8(addr: i64, value: i64)
extern fn rt_volatile_write_u16(addr: i64, value: i64)
extern fn rt_volatile_write_u32(addr: i64, value: i64)
extern fn rt_volatile_write_u64(addr: i64, value: i64)

# ============================================================================
# Extern Declarations - Memory Barriers
# ============================================================================

extern fn rt_memory_barrier()
extern fn rt_load_barrier()
extern fn rt_store_barrier()

# ============================================================================
# Simple API - Volatile Reads
# ============================================================================

fn volatile_read_u8(addr: i64) -> i64:
    # Read a single byte from a volatile memory address.
    rt_volatile_read_u8(addr)

fn volatile_read_u16(addr: i64) -> i64:
    # Read a 16-bit value from a volatile memory address.
    rt_volatile_read_u16(addr)

fn volatile_read_u32(addr: i64) -> i64:
    # Read a 32-bit value from a volatile memory address.
    rt_volatile_read_u32(addr)

fn volatile_read_u64(addr: i64) -> i64:
    # Read a 64-bit value from a volatile memory address.
    rt_volatile_read_u64(addr)

# ============================================================================
# Simple API - Volatile Writes
# ============================================================================

fn volatile_write_u8(addr: i64, value: i64):
    # Write a single byte to a volatile memory address.
    rt_volatile_write_u8(addr, value)

fn volatile_write_u16(addr: i64, value: i64):
    # Write a 16-bit value to a volatile memory address.
    rt_volatile_write_u16(addr, value)

fn volatile_write_u32(addr: i64, value: i64):
    # Write a 32-bit value to a volatile memory address.
    rt_volatile_write_u32(addr, value)

fn volatile_write_u64(addr: i64, value: i64):
    # Write a 64-bit value to a volatile memory address.
    rt_volatile_write_u64(addr, value)

# ============================================================================
# Simple API - Memory Barriers
# ============================================================================

fn memory_barrier():
    # Full memory barrier. Prevents reordering of loads and stores.
    rt_memory_barrier()

fn load_barrier():
    # Acquire barrier. All loads after this point see stores from before.
    rt_load_barrier()

fn store_barrier():
    # Release barrier. All stores before this point are visible after.
    rt_store_barrier()

# ============================================================================
# Utility
# ============================================================================

fn volatile_read_modify_write_u32(addr: i64, mask: i64, value: i64):
    # Atomic read-modify-write on a 32-bit volatile register.
    # Clears the bits in mask, then sets the bits in value.
    val current = volatile_read_u32(addr)
    val mask_inv = mask_invert_u32(mask)
    val cleared = bitand_u32(current, mask_inv)
    val updated = bitor_u32(cleared, bitand_u32(value, mask))
    volatile_write_u32(addr, updated)

fn bitand_u32(a: i64, b: i64) -> i64:
    # Bitwise AND for 32-bit values using arithmetic.
    var result: i64 = 0
    var bit: i64 = 1
    var i: i64 = 0
    while i < 32:
        if (a / bit) % 2 == 1 and (b / bit) % 2 == 1:
            result = result + bit
        bit = bit * 2
        i = i + 1
    result

fn bitor_u32(a: i64, b: i64) -> i64:
    # Bitwise OR for 32-bit values using arithmetic.
    var result: i64 = 0
    var bit: i64 = 1
    var i: i64 = 0
    while i < 32:
        val a_bit = (a / bit) % 2
        val b_bit = (b / bit) % 2
        if a_bit == 1 or b_bit == 1:
            result = result + bit
        bit = bit * 2
        i = i + 1
    result

fn mask_invert_u32(mask: i64) -> i64:
    # Invert a 32-bit mask (ones complement within 32 bits).
    val max_u32: i64 = 4294967295
    max_u32 - mask

# ============================================================================
# Exports
# ============================================================================

export volatile_read_u8, volatile_read_u16, volatile_read_u32, volatile_read_u64
export volatile_write_u8, volatile_write_u16, volatile_write_u32, volatile_write_u64
export memory_barrier, load_barrier, store_barrier
export volatile_read_modify_write_u32
export bitand_u32, bitor_u32, mask_invert_u32
export rt_volatile_read_u8, rt_volatile_read_u16, rt_volatile_read_u32, rt_volatile_read_u64
export rt_volatile_write_u8, rt_volatile_write_u16, rt_volatile_write_u32, rt_volatile_write_u64
export rt_memory_barrier, rt_load_barrier, rt_store_barrier
