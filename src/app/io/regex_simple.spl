#!/usr/bin/env simple
# Regex SFFI Wrapper - Using Existing Runtime Functions
#
# This version uses the EXISTING ffi_regex_* functions in the runtime.
# No Rust changes needed - works immediately!
#
# Note: Stateless API (compiles pattern each time).
# For performance-critical code, cache patterns manually.

# ============================================================================
# Tier 1: Extern Declarations (Existing Runtime Functions)
# ============================================================================

# These functions ALREADY EXIST in the runtime!
extern fn ffi_regex_is_match(pattern: text, text: text) -> bool
extern fn ffi_regex_find(pattern: text, text: text) -> [text]
extern fn ffi_regex_find_all(pattern: text, text: text) -> [[text]]
extern fn ffi_regex_captures(pattern: text, text: text) -> [text]
extern fn ffi_regex_replace(pattern: text, text: text, replacement: text) -> text
extern fn ffi_regex_replace_all(pattern: text, text: text, replacement: text) -> text
extern fn ffi_regex_split(pattern: text, text: text) -> [text]
extern fn ffi_regex_split_n(pattern: text, text: text, limit: i64) -> [text]

# ============================================================================
# Tier 2: Simple-Friendly Wrapper Functions
# ============================================================================

# --- Pattern Matching ---

fn regex_is_match(pattern: text, text: text) -> bool:
    """Test if pattern matches text

    Args:
        pattern: Regular expression pattern
        text: Text to search

    Returns: true if pattern found, false otherwise

    Example:
        if regex_is_match(r"\d+", "hello 123"):
            print "Contains digits"
    """
    ffi_regex_is_match(pattern, text)

fn regex_test(pattern: text, text: text) -> bool:
    """Alias for regex_is_match (JavaScript-style)"""
    regex_is_match(pattern, text)

# --- Finding Matches ---

fn regex_find(pattern: text, text: text) -> text:
    """Find first match in text

    Returns: First matching substring, empty string if not found

    Example:
        match = regex_find(r"\d+", "abc 123 def")  # "123"
    """
    val results = ffi_regex_find(pattern, text)
    if results.len() == 0:
        ""
    else:
        results[0]

fn regex_find_all(pattern: text, text: text) -> [text]:
    """Find all matches in text

    Returns: Array of matching substrings

    Example:
        matches = regex_find_all(r"\d+", "12 abc 34 def 56")  # ["12", "34", "56"]
    """
    val all_matches = ffi_regex_find_all(pattern, text)
    if all_matches.len() == 0:
        return []

    # Flatten nested array - each match is in its own array
    var result = []
    for match_group in all_matches:
        if match_group.len() > 0:
            result = result + [match_group[0]]

    result

fn regex_match(pattern: text, text: text) -> text:
    """Alias for regex_find (for consistency with other languages)"""
    regex_find(pattern, text)

# --- Capture Groups ---

fn regex_captures(pattern: text, text: text) -> [text]:
    """Capture groups from first match

    Returns: Array of captured groups (index 0 = full match)

    Example:
        groups = regex_captures(r"(\d+)-(\d+)", "abc 12-34 def")
        # ["12-34", "12", "34"]
        print "Full match: {groups[0]}"
        print "First group: {groups[1]}"
        print "Second group: {groups[2]}"
    """
    ffi_regex_captures(pattern, text)

# --- Replace Operations ---

fn regex_replace(pattern: text, text: text, replacement: text) -> text:
    """Replace first match with replacement text

    Args:
        pattern: Regular expression pattern
        text: Input text
        replacement: Replacement string (can use $1, $2 for captures)

    Returns: Text with first match replaced

    Example:
        result = regex_replace(r"\d+", "abc 123 def 456", "NUM")
        # "abc NUM def 456"
    """
    ffi_regex_replace(pattern, text, replacement)

fn regex_replace_all(pattern: text, text: text, replacement: text) -> text:
    """Replace all matches with replacement text

    Args:
        pattern: Regular expression pattern
        text: Input text
        replacement: Replacement string (can use $1, $2 for captures)

    Returns: Text with all matches replaced

    Example:
        result = regex_replace_all(r"\d+", "abc 123 def 456", "NUM")
        # "abc NUM def NUM"
    """
    ffi_regex_replace_all(pattern, text, replacement)

# --- Split Operations ---

fn regex_split(pattern: text, text: text) -> [text]:
    """Split text by pattern matches

    Returns: Array of substrings

    Example:
        parts = regex_split(r"\s+", "hello  world   test")
        # ["hello", "world", "test"]
    """
    ffi_regex_split(pattern, text)

fn regex_split_n(pattern: text, text: text, limit: i64) -> [text]:
    """Split text by pattern with limit

    Args:
        pattern: Regular expression pattern
        text: Text to split
        limit: Maximum number of splits

    Returns: Array of substrings (up to limit+1 elements)

    Example:
        parts = regex_split_n(r"\s+", "a b c d e", 2)
        # ["a", "b", "c d e"]
    """
    ffi_regex_split_n(pattern, text, limit)

# --- Validation Helpers ---

fn is_valid_email(email: text) -> bool:
    """Validate email address

    Returns: true if email format is valid

    Example:
        if is_valid_email("user@example.com"):
            print "Valid email"
    """
    regex_is_match(r"^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$", email)

fn is_valid_url(url: text) -> bool:
    """Validate URL

    Returns: true if URL format is valid

    Example:
        if is_valid_url("https://example.com"):
            print "Valid URL"
    """
    regex_is_match(r"^https?://[^\s]+$", url)

fn is_valid_ipv4(ip: text) -> bool:
    """Validate IPv4 address

    Returns: true if IPv4 format is valid

    Example:
        if is_valid_ipv4("192.168.1.1"):
            print "Valid IPv4"
    """
    regex_is_match(r"^\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}$", ip)

fn is_valid_uuid(uuid: text) -> bool:
    """Validate UUID format

    Returns: true if UUID format is valid

    Example:
        if is_valid_uuid("550e8400-e29b-41d4-a716-446655440000"):
            print "Valid UUID"
    """
    regex_is_match(r"^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}$", uuid)

fn is_valid_hex_color(color: text) -> bool:
    """Validate hex color code (#RGB or #RRGGBB)

    Example:
        if is_valid_hex_color("#FF5733"):
            print "Valid color"
    """
    regex_is_match(r"^#[0-9a-fA-F]{3}(?:[0-9a-fA-F]{3})?$", color)

fn is_valid_phone_us(phone: text) -> bool:
    """Validate US phone number

    Formats supported:
    - 123-456-7890
    - 123.456.7890
    - 1234567890

    Example:
        if is_valid_phone_us("123-456-7890"):
            print "Valid phone"
    """
    regex_is_match(r"^\d{3}[-.]?\d{3}[-.]?\d{4}$", phone)

# --- Common Pattern Helpers ---

fn regex_extract_emails(text: text) -> [text]:
    """Extract all email addresses from text

    Example:
        emails = regex_extract_emails("Contact: john@example.com or mary@test.org")
        # ["john@example.com", "mary@test.org"]
    """
    regex_find_all(r"[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}", text)

fn regex_extract_urls(text: text) -> [text]:
    """Extract all URLs from text

    Example:
        urls = regex_extract_urls("Visit https://example.com or http://test.org")
        # ["https://example.com", "http://test.org"]
    """
    regex_find_all(r"https?://[^\s]+", text)

fn regex_extract_numbers(text: text) -> [text]:
    """Extract all numbers from text

    Example:
        numbers = regex_extract_numbers("I have 3 apples and 5 oranges")
        # ["3", "5"]
    """
    regex_find_all(r"\d+", text)

fn regex_extract_words(text: text) -> [text]:
    """Extract all words from text

    Example:
        words = regex_extract_words("Hello, world! How are you?")
        # ["Hello", "world", "How", "are", "you"]
    """
    regex_find_all(r"\w+", text)

# --- Text Cleaning Helpers ---

fn regex_remove_html_tags(html: text) -> text:
    """Remove HTML tags from text

    Example:
        clean = regex_remove_html_tags("<p>Hello <b>world</b></p>")
        # "Hello world"
    """
    regex_replace_all(r"<[^>]+>", html, "")

fn regex_remove_whitespace(text: text) -> text:
    """Remove all whitespace from text

    Example:
        clean = regex_remove_whitespace("  hello   world  ")
        # "helloworld"
    """
    regex_replace_all(r"\s+", text, "")

fn regex_normalize_whitespace(text: text) -> text:
    """Normalize whitespace (multiple spaces to single space)

    Example:
        clean = regex_normalize_whitespace("hello    world")
        # "hello world"
    """
    regex_replace_all(r"\s+", text, " ")

fn regex_trim(text: text) -> text:
    """Trim whitespace from start and end

    Example:
        clean = regex_trim("  hello world  ")
        # "hello world"
    """
    val trimmed_start = regex_replace(r"^\s+", text, "")
    regex_replace(r"\s+$", trimmed_start, "")

# ============================================================================
# Export Functions
# ============================================================================

export regex_is_match, regex_test
export regex_find, regex_find_all, regex_match
export regex_captures
export regex_replace, regex_replace_all
export regex_split, regex_split_n
export is_valid_email, is_valid_url, is_valid_ipv4, is_valid_uuid
export is_valid_hex_color, is_valid_phone_us
export regex_extract_emails, regex_extract_urls, regex_extract_numbers, regex_extract_words
export regex_remove_html_tags, regex_remove_whitespace, regex_normalize_whitespace, regex_trim
