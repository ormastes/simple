#!/usr/bin/env simple
# Coverage SFFI Wrapper - Using Existing Runtime Functions
#
# This version uses the EXISTING rt_coverage_* functions in the runtime.
# No Rust changes needed - works immediately!
#
# Provides runtime coverage tracking for decisions, conditions, and paths.

# ============================================================================
# Tier 1: Extern Declarations (Existing Runtime Functions)
# ============================================================================

# These functions ALREADY EXIST in the runtime!
extern fn rt_coverage_enabled() -> bool
extern fn rt_coverage_decision_probe(file: text, line: i64, decision_id: i64, taken: bool)
extern fn rt_coverage_condition_probe(file: text, line: i64, condition_id: i64, result: bool)
extern fn rt_coverage_path_probe(file: text, line: i64, path_id: i64)
extern fn rt_coverage_path_finalizer(file: text, line: i64)
extern fn rt_coverage_dump_sdn() -> text
extern fn rt_coverage_free_sdn(sdn: text)
extern fn rt_coverage_clear()

# ============================================================================
# Tier 2: Simple-Friendly Wrapper Functions
# ============================================================================

# --- Coverage State ---

fn coverage_enabled() -> bool:
    """Check if coverage tracking is enabled

    Returns: true if SIMPLE_COVERAGE=1 environment variable is set

    Example:
        if coverage_enabled():
            print "Coverage tracking is active"
    """
    rt_coverage_enabled()

fn coverage_clear():
    """Clear all coverage data

    Resets all tracked decisions, conditions, and paths.

    Example:
        coverage_clear()
        run_tests()
        val report = coverage_report()
    """
    rt_coverage_clear()

# --- Coverage Probes ---

fn coverage_decision(file: text, line: i64, decision_id: i64, taken: bool):
    """Record a decision point (if/match branch taken)

    Args:
        file: Source file path
        line: Line number
        decision_id: Unique ID for this decision point
        taken: Whether this branch was taken

    Example:
        if condition:
            coverage_decision("test.spl", 42, 1, true)
            do_something()
        else:
            coverage_decision("test.spl", 42, 2, false)
    """
    rt_coverage_decision_probe(file, line, decision_id, taken)

fn coverage_condition(file: text, line: i64, condition_id: i64, result: bool):
    """Record a condition evaluation (boolean expression)

    Args:
        file: Source file path
        line: Line number
        condition_id: Unique ID for this condition
        result: Boolean result of condition

    Example:
        val result = (x > 5)
        coverage_condition("test.spl", 10, 1, result)
        if result:
            process(x)
    """
    rt_coverage_condition_probe(file, line, condition_id, result)

fn coverage_path(file: text, line: i64, path_id: i64):
    """Record a path segment execution

    Args:
        file: Source file path
        line: Line number
        path_id: Unique ID for this path segment

    Example:
        coverage_path("test.spl", 20, 1)
        step1()
        coverage_path("test.spl", 21, 2)
        step2()
    """
    rt_coverage_path_probe(file, line, path_id)

fn coverage_path_end(file: text, line: i64):
    """Mark end of a path sequence

    Args:
        file: Source file path
        line: Line number where path ends

    Example:
        coverage_path("test.spl", 20, 1)
        do_work()
        coverage_path_end("test.spl", 25)
    """
    rt_coverage_path_finalizer(file, line)

# --- Coverage Reports ---

fn coverage_report() -> text:
    """Get coverage report in SDN format

    Returns: SDN-formatted coverage data with all tracked probes

    Example:
        val report = coverage_report()
        file_write(".coverage/coverage.sdn", report)
    """
    rt_coverage_dump_sdn()

fn coverage_report_free(sdn: text):
    """Free coverage report memory

    Args:
        sdn: SDN report string to free

    Note: Usually not needed, but available if managing memory manually

    Example:
        val report = coverage_report()
        process(report)
        coverage_report_free(report)
    """
    rt_coverage_free_sdn(sdn)

# --- High-Level Coverage Tracking ---

fn with_coverage<T>(block: fn() -> T) -> T:
    """Run code block with fresh coverage tracking

    Clears coverage before running block, returns result and coverage report.

    Args:
        block: Function to run with coverage

    Returns: Result of block execution

    Example:
        val result = with_coverage(\:
            run_tests()
            42
        )
        val report = coverage_report()
        print "Result: {result}"
        print "Coverage:\\n{report}"
    """
    coverage_clear()
    val result = block()
    result

# --- Coverage Statistics ---

struct CoverageStats:
    decisions_total: i64
    decisions_covered: i64
    conditions_total: i64
    conditions_covered: i64
    paths_total: i64
    paths_covered: i64
    decision_coverage_percent: i64
    condition_coverage_percent: i64
    path_coverage_percent: i64

fn parse_coverage_stats(sdn: text) -> CoverageStats:
    """Parse coverage report SDN to extract statistics

    Args:
        sdn: SDN coverage report from coverage_report()

    Returns: CoverageStats with coverage percentages

    Note: Simple SDN parsing - counts occurrences

    Example:
        val report = coverage_report()
        val stats = parse_coverage_stats(report)
        print "Decision coverage: {stats.decision_coverage_percent}%"
    """
    # Count decision probes
    var decisions_total = 0
    var decisions_covered = 0

    # Count condition probes
    var conditions_total = 0
    var conditions_covered = 0

    # Count path probes
    var paths_total = 0
    var paths_covered = 0

    # Parse SDN line by line
    val lines = sdn.split("\n")
    for line in lines:
        if line.contains("decision"):
            decisions_total = decisions_total + 1
            if line.contains("true"):
                decisions_covered = decisions_covered + 1

        if line.contains("condition"):
            conditions_total = conditions_total + 1
            if line.contains("true"):
                conditions_covered = conditions_covered + 1

        if line.contains("path"):
            paths_total = paths_total + 1
            paths_covered = paths_covered + 1  # All recorded paths are covered

    # Calculate percentages
    var decision_pct = 0
    if decisions_total > 0:
        decision_pct = (decisions_covered * 100) / decisions_total

    var condition_pct = 0
    if conditions_total > 0:
        condition_pct = (conditions_covered * 100) / conditions_total

    var path_pct = 0
    if paths_total > 0:
        path_pct = (paths_covered * 100) / paths_total

    CoverageStats(
        decisions_total: decisions_total,
        decisions_covered: decisions_covered,
        conditions_total: conditions_total,
        conditions_covered: conditions_covered,
        paths_total: paths_total,
        paths_covered: paths_covered,
        decision_coverage_percent: decision_pct,
        condition_coverage_percent: condition_pct,
        path_coverage_percent: path_pct
    )

# ============================================================================
# Export Functions
# ============================================================================

export coverage_enabled, coverage_clear
export coverage_decision, coverage_condition, coverage_path, coverage_path_end
export coverage_report, coverage_report_free
export with_coverage
export CoverageStats, parse_coverage_stats
