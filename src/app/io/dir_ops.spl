# Directory Operations - Pure Simple I/O
# Extracted from mod.spl for modularity

# Extern fn declarations (runtime resolves at file level)
use std.text.{NL}

extern fn rt_dir_create(path: text, recursive: bool) -> bool
extern fn rt_dir_remove_all(path: text) -> bool
extern fn rt_process_run(cmd: text, args: [text]) -> (text, text, i64)

# --- Shell helpers (local copies to avoid circular imports) ---

fn _dir_shell(command: text) -> (text, text, i64):
    rt_process_run("/bin/sh", ["-c", command])

fn _dir_shell_bool(command: text) -> bool:
    val (out, err, code) = _dir_shell(command)
    code == 0

fn _dir_shell_lines(command: text) -> [text]:
    val (out, err, code) = _dir_shell(command)
    if code == 0 and out.trim().len() > 0:
        out.trim().split(NL)
    else:
        []

# ============================================================================
# Directory Operations
# ============================================================================

fn dir_create(path: text, recursive: bool) -> bool:
    rt_dir_create(path, recursive)

fn dir_create_all(path: text) -> bool:
    dir_create(path, true)

fn dir_walk(path: text) -> [text]:
    val (out, err, code) = _dir_shell("find '{path}' -type f 2>/dev/null | sort")
    if code == 0:
        var trimmed = out.trim()
        if trimmed != "":
            return trimmed.split(NL)
    []

fn dir_remove_all(path: text) -> i32:
    if rt_dir_remove_all(path):
        0
    else:
        -1

fn is_dir(path: text) -> bool:
    _dir_shell_bool("test -d '{path}'")

fn dir_list(path: text) -> [text]:
    _dir_shell_lines("ls -1 '{path}' 2>/dev/null")

fn dir_remove(path: text, recursive: bool) -> bool:
    if recursive:
        dir_remove_all(path) == 0
    else:
        false

export dir_create, dir_create_all, dir_walk, dir_remove_all, is_dir
export dir_list, dir_remove
