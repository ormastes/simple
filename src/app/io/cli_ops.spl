# CLI Functions - Pure Simple I/O
# Extracted from mod.spl for modularity

# Extern fn declarations (runtime resolves at file level)

extern fn rt_cli_get_args() -> [str]
extern fn rt_exit(code: i64)
extern fn rt_process_run(cmd: text, args: [text]) -> (text, text, i64)
extern fn rt_cli_run_tests(args: [str], gc_log: bool, gc_off: bool) -> i64
extern fn rt_cli_handle_compile(args: [str]) -> i64
extern fn rt_compile_to_llvm_ir(source_file: text, target_triple: text, bare_metal: bool) -> (text, text, i64)
extern fn rt_env_get(key: text) -> text

# --- Shell/file helpers (local copies to avoid circular imports) ---

fn _cli_is_windows_platform() -> bool:
    val os_env = rt_env_get("OS")
    if os_env == nil:
        false
    else:
        os_env.lower().contains("windows")

struct _CliProcessResult:
    stdout: text
    stderr: text
    exit_code: i64

fn _cli_shell(command: text) -> _CliProcessResult:
    val (shell_path, shell_args) = if _cli_is_windows_platform():
        ("cmd.exe", ["/c", command])
    else:
        ("/bin/sh", ["-c", command])
    val (stdout, stderr, code) = rt_process_run(shell_path, shell_args)
    _CliProcessResult(stdout: stdout, stderr: stderr, exit_code: code)

fn _cli_shell_bool(command: text) -> bool:
    val result = _cli_shell(command)
    result.exit_code == 0

fn _cli_file_exists_impl(path: text) -> bool:
    _cli_shell_bool("test -f '{path}'")

fn _cli_file_read_impl(path: text) -> text:
    val result = _cli_shell("cat '{path}' 2>/dev/null")
    if result.exit_code == 0:
        result.stdout
    else:
        ""

fn _cli_file_write_impl(path: text, content: text) -> bool:
    val result = _cli_shell("cat > '{path}' << 'SIMPLE_WRITE_EOF'\n{content}\nSIMPLE_WRITE_EOF")
    result.exit_code == 0

fn _cli_file_copy_impl(src: text, dst: text) -> bool:
    val result = _cli_shell("cp '{src}' '{dst}'")
    result.exit_code == 0

fn _cli_dir_create_impl(path: text, recursive: bool) -> bool:
    if recursive:
        val result = _cli_shell("mkdir -p '{path}'")
        result.exit_code == 0
    else:
        val result = _cli_shell("mkdir '{path}'")
        result.exit_code == 0

fn _cli_eprint(msg: text):
    print "[STDERR] {msg}"

fn _cli_process_run(cmd: text, args: [text]) -> (text, text, i64):
    var resolved_cmd = cmd
    if _cli_is_windows_platform():
        if not cmd.ends_with(".exe") and not cmd.ends_with(".cmd") and not cmd.ends_with(".bat"):
            val check = rt_process_run("where", [cmd + ".exe"])
            if check.2 == 0:
                resolved_cmd = cmd + ".exe"
    else:
        if not cmd.contains("/"):
            val check = rt_process_run("which", [cmd])
            if check.2 == 0 and check.0.trim() != "":
                resolved_cmd = check.0.trim()
    rt_process_run(resolved_cmd, args)

# ============================================================================
# CLI Core Functions
# ============================================================================

fn get_args() -> [String]:
    rt_cli_get_args()

fn exit(code: i64):
    rt_exit(code)

fn cli_get_args() -> [str]:
    rt_cli_get_args()

fn cli_exit(code: i64):
    rt_exit(code)

fn cli_file_exists(path: str) -> bool:
    _cli_file_exists_impl(path)

fn cli_read_file(path: str) -> str:
    _cli_file_read_impl(path)

# ============================================================================
# CLI Command Handlers
# ============================================================================

fn cli_run_code(code: str, gc_log: bool, gc_off: bool) -> i64:
    print "=== Simple Code Execution ==="
    print "Code: {code}"
    print "Note: Interpreter would evaluate this code"
    1

fn cli_run_file(path: str, args: [str], gc_log: bool, gc_off: bool) -> i64:
    var run_args: [text] = [path]
    for arg in args:
        run_args.push(arg)
    val result = _cli_process_run("bin/release/simple", run_args)
    val stdout = result[0]
    val exit_code = result[2]
    if stdout.len() > 0:
        print stdout
    exit_code

fn cli_watch_file(path: str) -> i64:
    print "Watch mode not yet implemented in pure Simple"
    1

fn cli_run_repl(gc_log: bool, gc_off: bool) -> i64:
    print "=== Simple REPL ==="
    print "REPL not yet implemented in pure Simple"
    print ""
    print "For now, use: ./bin/release/simple yourfile.spl"
    1

fn cli_not_implemented(tool_name: text) -> i64:
    print "{tool_name} not yet implemented in pure Simple"
    1

fn _cli_strip_command(args: [str], cmd: text) -> [str]:
    if args.len() > 0 and args[0] == cmd:
        args.slice(1, args.len())
    else:
        args

fn cli_run_tests(args: [str], gc_log: bool, gc_off: bool) -> i64:
    # Use the new Simple test runner instead of Rust FFI
    # This enables resource monitoring, process cleanup, and container support
    var run_args: [text] = ["src/app/test_runner_new/main.spl"]

    # Pass through all test arguments
    for arg in args:
        run_args.push(arg)

    # Add GC flags if needed (test runner supports these)
    if gc_log:
        run_args.push("--gc-log")
    if gc_off:
        run_args.push("--gc=off")

    # Execute test runner with NO timeout - module loading takes ~35s with 24+ imports
    # Standard process_run has no timeout and relies on system defaults
    # This allows the test runner to complete even with slow module loading
    val result = _cli_process_run("bin/release/simple", run_args)
    val stdout = result[0]
    val stderr = result[1]
    val exit_code = result[2]

    if stdout.len() > 0:
        print stdout
    if stderr.len() > 0:
        _cli_eprint(stderr)

    exit_code

fn cli_run_lint(args: [str]) -> i64:
    cli_not_implemented("Linter")

fn cli_run_fmt(args: [str]) -> i64:
    cli_not_implemented("Formatter")

fn cli_run_fix(args: [str]) -> i64:
    cli_not_implemented("Fix tool")

fn cli_run_verify(args: [str], gc_log: bool, gc_off: bool) -> i64:
    cli_not_implemented("Verifier")

fn cli_run_migrate(args: [str]) -> i64:
    cli_not_implemented("Migration tool")

fn cli_run_mcp(args: [str]) -> i64:
    var cmd = "./bin/release/simple src/app/mcp/main.spl"
    var i = 1
    while i < args.len():
        cmd = cmd + " " + args[i]
        i = i + 1

    val result = _cli_shell(cmd)
    if result.stdout.len() > 0:
        print(result.stdout)
    if result.stderr.len() > 0:
        _cli_eprint(result.stderr)
    result.exit_code

fn cli_run_lsp(args: [str]) -> i64:
    # Handle --help/--version inline (subprocess can't access rt_cli_args)
    var i = 1
    for idx in 1..args.len():
        val arg = args[idx]
        if arg == "--help" or arg == "-h":
            print "Simple Language Server (LSP)"
            print ""
            print "Usage: simple lsp [options]"
            print ""
            print "The language server communicates via stdin/stdout using the"
            print "Language Server Protocol (LSP) with JSON-RPC 2.0 messages."
            print ""
            print "Options:"
            print "  -h, --help       Show this help message"
            print "  -v, --version    Show version information"
            print ""
            print "Environment Variables:"
            print "  SIMPLE_LSP_DEBUG  Enable debug logging to stderr"
            print ""
            print "Editor Integration:"
            print "  VS Code: Install the Simple Language extension"
            print "    Settings: simple.lsp.serverPath = simple"
            print ""
            print "  Neovim: Use simple.nvim plugin"
            print "    require('simple').setup()"
            return 0
        if arg == "--version" or arg == "-v":
            print "simple-lsp 0.1.0"
            print "Simple Language Server (LSP)"
            return 0

    # Start LSP server (requires compiled mode for tree-sitter, JSON-RPC)
    print "Simple Language Server"
    print "The LSP server requires compiled mode for full operation."
    print "Run: simple build && ./build/simple lsp"
    print ""
    print "For help, use: simple lsp --help"
    1

fn cli_run_diff(args: [str]) -> i64:
    cli_not_implemented("Diff tool")

fn cli_constr(args: [str]) -> i64:
    cli_not_implemented("Constraint checker")

fn cli_run_query(args: [str]) -> i64:
    cli_not_implemented("Query tool")

fn cli_run_spec_coverage(args: [str]) -> i64:
    val run_args = _cli_strip_command(args, "spec-coverage")
    cli_run_file("src/app/spec_coverage/main.spl", run_args, false, false)

fn cli_gen_lean(args: [str]) -> i64:
    cli_not_implemented("Lean generator")

fn cli_run_feature_gen(args: [str]) -> i64:
    val run_args = _cli_strip_command(args, "feature-gen")
    cli_run_file("src/app/feature_gen/main.spl", run_args, false, false)

fn cli_run_task_gen(args: [str]) -> i64:
    val run_args = _cli_strip_command(args, "task-gen")
    cli_run_file("src/app/task_gen/main.spl", run_args, false, false)

fn cli_run_spec_gen(args: [str]) -> i64:
    val run_args = _cli_strip_command(args, "spec-gen")
    cli_run_file("src/app/spec_gen/main.spl", run_args, false, false)

fn cli_run_sspec_docgen(args: [str]) -> i64:
    val run_args = _cli_strip_command(args, "sspec-docgen")
    cli_run_file("src/app/sspec_docgen/main.spl", run_args, false, false)

fn cli_run_feature_doc(args: [str]) -> i64:
    val run_args = _cli_strip_command(args, "feature-doc")
    cli_run_file("src/app/feature_doc/main.spl", run_args, false, false)

fn cli_run_todo_gen(args: [str]) -> i64:
    cli_run_file("src/app/todo_scan/main.spl", args, false, false)

fn cli_todo_scan(args: [str]) -> i64:
    cli_run_file("src/app/todo_scan/main.spl", args, false, false)

fn cli_run_lex(args: [str]) -> i64:
    cli_not_implemented("Lexer")

fn cli_run_brief(args: [str]) -> i64:
    cli_not_implemented("Brief tool")

fn cli_run_ffi_gen(args: [str]) -> i64:
    cli_not_implemented("FFI generator")

fn cli_run_i18n(args: [str]) -> i64:
    cli_not_implemented("i18n tool")

fn cli_handle_web(args: [str]) -> i64:
    cli_not_implemented("Web handler")

fn cli_handle_diagram(args: [str]) -> i64:
    cli_not_implemented("Diagram generator")

fn cli_handle_run(args: [str], gc_log: bool, gc_off: bool) -> i64:
    if args.len() > 0:
        cli_run_file(args[0], args[1:], gc_log, gc_off)
    else:
        print "No file specified"
        1

fn cli_handle_compile(args: [str]) -> i64:
    rt_cli_handle_compile(args)

fn cli_handle_linkers() -> i64:
    cli_not_implemented("Linker information")

fn cli_replay(args: [str]) -> i64:
    cli_not_implemented("Replay tool")

fn cli_check(args: [str]) -> i64:
    cli_not_implemented("Type checker")

# Check if native compiler FFI is available
fn has_native_compiler_ffi() -> bool:
    # Try to detect if we're in interpreter mode where FFI might not work
    # If SIMPLE_COMPILE_RUST is set, assume FFI is available
    val compile_rust = rt_env_get("SIMPLE_COMPILE_RUST")
    if compile_rust == "1":
        return true

    # Otherwise, assume we need Pure Simple compiler
    false

# Pure Simple compiler implementation (no FFI dependency)
fn cli_compile_pure_simple(source_file: text, output_file: text, output_format: text, backend: text, verbose: bool, release: bool) -> i64:
    var out = output_file
    if out == "":
        # Default output based on format
        if output_format == "smf":
            out = source_file.replace(".spl", ".smf")
        else:
            out = "a.out"

    if verbose:
        _cli_eprint("[Pure Simple Compiler] Compiling {source_file} -> {out}")

    # Use the compile_to_smf function from compiler.driver
    # Note: This requires the compiler module to be available
    # For bootstrap, we shell out to avoid circular dependencies
    var use_direct = rt_env_get("SIMPLE_DIRECT_COMPILE") == "1"

    if use_direct:
        # TODO: Direct import of compiler.driver.compile_to_smf
        # This will work once we have proper module loading in place
        _cli_eprint("[Pure Simple Compiler] Direct compilation not yet available")
        _cli_eprint("[Pure Simple Compiler] Set SIMPLE_COMPILE_RUST=1 to use native compiler")
        return 1
    else:
        # For now, report that we're in interpreter mode and can't compile
        # The bootstrap will need to use SIMPLE_COMPILE_RUST=1
        _cli_eprint("error: rt_cli_handle_compile is not supported in interpreter mode")
        _cli_eprint("hint: Build and run the compiled CLI for full functionality")
        _cli_eprint("hint: Or set SIMPLE_COMPILE_RUST=1 to use native compiler backend")
        return 1

fn cli_compile(args: [str]) -> i64:
    var source_file: text = ""
    var output_file: text = ""
    var target: text = ""
    var emit: text = "elf"
    var output_format: text = ""
    var backend: text = "auto"
    var verbose: bool = false
    var release: bool = false
    var use_lto: bool = false
    var march_target: text = ""
    var pgo_generate: bool = false
    var pgo_use_path: text = ""
    var release_optimized: bool = false
    var emit_c: bool = false

    var i = 0
    if args.len() > 0 and args[0] == "compile":
        i = 1

    while i < args.len():
        val arg = args[i]

        if arg == "--help" or arg == "-h":
            print "Simple Compiler"
            print ""
            print "Usage: simple compile [options] <source.spl>"
            print ""
            print "Options:"
            print "  --target=<target>     Target: baremetal-x86, baremetal-arm, etc."
            print "  --emit=<format>       Output: llvm-ir, object, elf (default: elf)"
            print "  --format=<fmt>        Output: native, smf, self-contained (sc), both"
            print "  --native              Compile to native binary via C codegen + gcc"
            print "  --backend=<backend>   Backend: auto, cranelift, llvm, vhdl, c (default: auto)"
            print "  --emit-c              Emit C++20 source code (C backend)"
            print "  --coverage            Enable coverage instrumentation"
            print "  --coverage-output=<p> Coverage output file path"
            print "  --release             Release build (optimized, prefers LLVM)"
            print "  --release-optimized   Max optimization: -O2 + x86-64-v3 + ThinLTO"
            print "  --lto                 Enable ThinLTO (+2-3% speed)"
            print "  --march=<target>      CPU target: native, x86-64-v2, x86-64-v3, x86-64-v4"
            print "  --pgo-generate        Build instrumented binary for PGO"
            print "  --pgo-use=<path>      Use PGO profile for optimization (+5-20% speed)"
            print "  -o <output>           Output file path"
            print "  --verbose, -v         Verbose output"
            print "  --help, -h            Show this help"
            print ""
            print "Output Formats (--format):"
            print "  native                Native executable (default)"
            print "  smf                   SMF module file"
            print "  self-contained, sc    Self-contained binary (runtime + SMF in one file)"
            print "  both                  Both native executable and SMF module"
            print ""
            print "Examples:"
            print "  simple compile hello.spl"
            print "  simple compile hello.spl --backend=llvm"
            print "  simple compile hello.spl --release -o hello.smf"
            print "  simple compile hello.spl --format=self-contained -o hello"
            print "  simple compile --native -o hello hello.spl"
            print "  simple compile --target=baremetal-x86 --emit=llvm-ir kernel.spl"
            print "  simple compile --backend=vhdl -o counter.vhd counter.spl"
            return 0
        elif arg.starts_with("--target="):
            target = arg.substring(9)
        elif arg.starts_with("--emit="):
            emit = arg.substring(7)
        elif arg.starts_with("--format="):
            output_format = arg.substring(9)
        elif arg.starts_with("--backend="):
            backend = arg.substring(10)
        elif arg == "--release":
            release = true
        elif arg == "--release-optimized":
            release_optimized = true
            release = true
            use_lto = true
            march_target = "x86-64-v3"
        elif arg == "--lto":
            use_lto = true
        elif arg.starts_with("--march="):
            march_target = arg.substring(8)
        elif arg == "--pgo-generate":
            pgo_generate = true
        elif arg.starts_with("--pgo-use="):
            pgo_use_path = arg.substring(10)
        elif arg == "--coverage":
            # Pass-through (compiler config reads env/args)
            pass
        elif arg.starts_with("--coverage-output="):
            # Pass-through (handled by compiler)
            pass
        elif arg == "--emit-c":
            emit_c = true
            backend = "c"
        elif arg == "--native":
            emit = "native"
        elif arg == "-o":
            i = i + 1
            if i < args.len():
                output_file = args[i]
            else:
                _cli_eprint("Error: -o requires an argument")
                return 1
        elif arg == "--verbose" or arg == "-v":
            verbose = true
        elif not arg.starts_with("-"):
            if source_file == "":
                source_file = arg
            else:
                _cli_eprint("Error: Multiple source files not supported")
                return 1
        else:
            _cli_eprint("Error: Unknown option: {arg}")
            return 1

        i = i + 1

    if source_file == "":
        _cli_eprint("Error: No source file specified")
        _cli_eprint("Usage: simple compile [options] <source.spl>")
        return 1

    if not _cli_file_exists_impl(source_file):
        _cli_eprint("Error: Source file not found: {source_file}")
        return 1

    if backend == "vhdl":
        return compile_vhdl(source_file, output_file, verbose)

    if backend == "c" or backend == "cpp" or backend == "ccodegen" or emit_c:
        return compile_c_backend(source_file, output_file, verbose)

    if emit == "native":
        var out = output_file
        if out == "":
            out = source_file.replace(".spl", "")
        # Build optimization flags for llvm_direct pipeline
        var opt_flags = ""
        if use_lto:
            opt_flags = opt_flags + " --lto"
        if march_target != "":
            opt_flags = opt_flags + " --march=" + march_target
        if pgo_generate:
            opt_flags = opt_flags + " --pgo-generate"
        if pgo_use_path != "":
            opt_flags = opt_flags + " --pgo-use=" + pgo_use_path
        if release_optimized:
            opt_flags = opt_flags + " --release-optimized"
        # Use llvm_direct if optimization flags are set, otherwise native
        var has_opt_flags = use_lto or march_target != "" or pgo_generate or pgo_use_path != "" or release_optimized
        if has_opt_flags:
            var llvm_cmd = "bin/release/simple src/app/compile/llvm_direct.spl '{source_file}' '{out}'" + opt_flags
            if verbose:
                llvm_cmd = llvm_cmd + " --verbose"
            val llvm_result = _cli_shell(llvm_cmd)
            if llvm_result.stdout != "":
                print llvm_result.stdout
            if llvm_result.stderr != "" and llvm_result.exit_code != 0:
                _cli_eprint(llvm_result.stderr)
            return llvm_result.exit_code
        var native_cmd = "bin/release/simple src/app/compile/native.spl '{source_file}' '{out}'"
        if verbose:
            native_cmd = "bin/release/simple src/app/compile/native.spl '{source_file}' '{out}' --verbose"
        val native_result = _cli_shell(native_cmd)
        if native_result.stdout != "":
            print native_result.stdout
        if native_result.stderr != "" and native_result.exit_code != 0:
            _cli_eprint(native_result.stderr)
        return native_result.exit_code

    if target.starts_with("baremetal-"):
        return compile_baremetal(source_file, target, emit, output_file, verbose)

    var compile_args = args
    if output_format != "":
        if output_format != "native" and output_format != "smf" and output_format != "self-contained" and output_format != "sc" and output_format != "both":
            _cli_eprint("Error: Unknown format: {output_format}")
            _cli_eprint("Valid formats: native, smf, self-contained (sc), both")
            return 1

    # Check if we should use Pure Simple compiler (interpreter mode, no FFI)
    val use_pure_simple = rt_env_get("SIMPLE_USE_PURE_COMPILER") == "1"

    if use_pure_simple or not has_native_compiler_ffi():
        # Use Pure Simple compiler implementation (works in interpreter/SMF mode)
        return cli_compile_pure_simple(source_file, output_file, output_format, backend, verbose, release)

    _cli_eprint("[NOTE] Using bootstrap Cranelift path; pure-Simple LLVM path not yet available in interpreter mode")

    if backend == "llvm":
        val llc_check = _cli_shell("command -v llc >/dev/null 2>&1")
        if llc_check.exit_code != 0:
            _cli_eprint("Error: llc not found. Install LLVM: apt install llvm (Ubuntu) or brew install llvm (macOS)")
            return 1

    rt_cli_handle_compile(compile_args)

fn compile_baremetal(source_file: text, target: text, emit: text, output_file: text, verbose: bool) -> i64:
    if verbose:
        print "Compiling {source_file} for {target}"
        print "  Emit: {emit}"
        if output_file != "":
            print "  Output: {output_file}"

    _cli_eprint("[NOTE] Using shell-based baremetal build; direct BaremetalBuilder import not yet available")

    val arch = if target == "baremetal-x86":
        "i686"
    elif target == "baremetal-x86_64":
        "x86_64"
    elif target == "baremetal-arm":
        "armv7"
    elif target == "baremetal-aarch64":
        "aarch64"
    elif target == "baremetal-riscv32":
        "riscv32"
    elif target == "baremetal-riscv64":
        "riscv64"
    else:
        _cli_eprint("Error: Unknown bare-metal target: {target}")
        _cli_eprint("Supported: baremetal-x86, baremetal-x86_64, baremetal-arm,")
        _cli_eprint("           baremetal-aarch64, baremetal-riscv32, baremetal-riscv64")
        return 1

    if not _cli_dir_create_impl("build/baremetal", true):
        _cli_eprint("Error: Failed to create build/baremetal directory")
        return 1

    val target_triple = arch + "-unknown-none"

    if verbose:
        print "Compiling Simple -> LLVM IR (pure Simple compiler)..."
        print "  Target triple: {target_triple}"

    _cli_eprint("[NOTE] Pure Simple LLVM compilation not yet wired up; compiler.driver and compiler.backend.llvm_backend imports pending")

    val llvm_ir = ""
    val error_msg = "Pure Simple compilation not yet wired up. To complete this, we need to: 1. Import compiler.driver (CompilerDriver, compile_file) 2. Import compiler.backend.llvm_backend (LlvmBackend, MirToLlvm) 3. Compile source to MIR using CompilerDriver 4. Translate MIR to LLVM IR using MirToLlvm.translate_module() 5. Return the textual LLVM IR. The LLVM backend already generates textual IR in pure Simple! See: src/compiler/backend/llvm_backend.spl line 790. This is ~20-30 lines of Simple code to wire up. No Rust FFI needed - it's pure Simple!"

    if llvm_ir == "":
        _cli_eprint("Error: Compilation not yet wired up")
        _cli_eprint(error_msg)
        return 1

    val base_name = source_file.replace(".spl", "").replace("/", "_")
    val ir_file = "build/baremetal/{base_name}.ll"
    if not _cli_file_write_impl(ir_file, llvm_ir):
        _cli_eprint("Error: Failed to write LLVM IR to {ir_file}")
        return 1

    if verbose:
        print "  Generated: {ir_file}"

    if emit == "llvm-ir":
        if output_file != "":
            if not _cli_file_copy_impl(ir_file, output_file):
                _cli_eprint("Error: Failed to copy to {output_file}")
                return 1
            print "Output: {output_file}"
        else:
            print "Output: {ir_file}"
        return 0

    if verbose:
        print "Compiling LLVM IR -> Object file..."

    val obj_file = "build/baremetal/{base_name}.o"
    val (llc_out, llc_err, llc_exit) = _cli_process_run("llc", [
        "--filetype=obj",
        "--relocation-model=static",
        ir_file,
        "-o", obj_file
    ])

    if llc_exit != 0:
        _cli_eprint("Error: llc compilation failed")
        _cli_eprint(llc_err)
        return 1

    if verbose:
        print "  Generated: {obj_file}"

    if emit == "object":
        if output_file != "":
            if not _cli_file_copy_impl(obj_file, output_file):
                _cli_eprint("Error: Failed to copy to {output_file}")
                return 1
            print "Output: {output_file}"
        else:
            print "Output: {obj_file}"
        return 0

    if verbose:
        print "Linking Object -> ELF binary..."

    val elf_file = if output_file != "":
        output_file
    else:
        "build/baremetal/kernel.elf"

    val linker_script = "build/baremetal/linker.ld"

    val (ld_out, ld_err, ld_exit) = _cli_process_run("ld", [
        "-T", linker_script,
        "-nostdlib",
        "--entry=_start",
        obj_file,
        "-o", elf_file
    ])

    if ld_exit != 0:
        _cli_eprint("Error: Linking failed")
        _cli_eprint(ld_err)
        _cli_eprint("")
        _cli_eprint("Note: Linker script should be at: {linker_script}")
        _cli_eprint("Generate it using: simple linker-gen resources/boards/qemu_x86.sdn")
        return 1

    if verbose:
        print "  Generated: {elf_file}"

    print "Success: {elf_file}"
    return 0

fn cli_info(args: [str]) -> i64:
    cli_not_implemented("Info tool")

# ============================================================================
# Advanced Features
# ============================================================================

fn compile_c_backend(source_file: text, output_file: text, verbose: bool) -> i64:
    """Compile a Simple source file to C++20 source code."""
    var out = output_file
    if out == "":
        out = source_file.replace(".spl", ".cpp")

    if verbose:
        print "Compiling {source_file} to C++20"
        print "  Output: {out}"

    # The C backend produces .cpp text files from MIR.
    # Pipeline: source -> parse -> HIR -> MIR -> MirToC -> .cpp
    var c_cmd = "bin/release/simple src/app/compile/native.spl '{source_file}' '{out}' --backend=c"
    if verbose:
        c_cmd = c_cmd + " --verbose"
    val result = _cli_shell(c_cmd)
    if result.stdout != "":
        print result.stdout
    if result.stderr != "" and result.exit_code != 0:
        _cli_eprint(result.stderr)
        return result.exit_code

    if result.exit_code == 0:
        print "Output: {out}"
        print "Build with: clang++ -std=c++20 -O2 {out} runtime.c -o {source_file.replace('.spl', '')}"
    return result.exit_code

fn compile_vhdl(source_file: text, output_file: text, verbose: bool) -> i64:
    """Compile a Simple source file to VHDL output."""
    var out = output_file
    if out == "":
        out = source_file.replace(".spl", ".vhd")

    if verbose:
        print "Compiling {source_file} to VHDL"
        print "  Output: {out}"

    # The VHDL backend produces .vhd text files from MIR.
    # Full pipeline: source -> parse -> HIR -> MIR -> VhdlConstraintChecker -> VhdlBackend -> .vhd
    # Currently delegates to the Simple runtime for compilation.
    var vhdl_cmd = "bin/release/simple src/app/compile/native.spl '{source_file}' '{out}' --backend=vhdl"
    if verbose:
        vhdl_cmd = vhdl_cmd + " --verbose"
    val result = _cli_shell(vhdl_cmd)
    if result.stdout != "":
        print result.stdout
    if result.stderr != "" and result.exit_code != 0:
        _cli_eprint(result.stderr)
        return result.exit_code

    if result.exit_code == 0:
        print "Output: {out}"
    return result.exit_code

fn context_generate(path: str, target: str, format: str) -> str:
    ""

fn context_stats(path: str, target: str) -> str:
    ""

fn settlement_main() -> i64:
    0

fn fault_set_stack_overflow_detection(enabled: bool):
    ()

fn fault_set_max_recursion_depth(depth: i64):
    ()

fn fault_set_timeout(secs: i64):
    ()

fn fault_set_execution_limit(limit: i64):
    ()

# ============================================================================
# Exports
# ============================================================================

export get_args, exit, cli_get_args, cli_exit, cli_file_exists
export cli_replay, cli_constr, cli_check, cli_compile, cli_todo_scan, cli_gen_lean, cli_info
export cli_run_code, cli_run_file, cli_watch_file, cli_run_repl, cli_run_tests
export cli_run_lint, cli_run_fmt, cli_run_fix, cli_run_verify, cli_run_migrate
export cli_run_mcp, cli_run_lsp, cli_run_diff, cli_run_query, cli_run_spec_coverage
export cli_run_feature_gen, cli_run_task_gen, cli_run_spec_gen, cli_run_sspec_docgen, cli_run_feature_doc
export cli_run_todo_gen, cli_run_lex, cli_run_brief, cli_run_ffi_gen, cli_run_i18n
export cli_handle_web, cli_handle_diagram, cli_handle_run, cli_handle_compile, cli_handle_linkers
export cli_read_file, context_generate, context_stats, settlement_main
export fault_set_stack_overflow_detection, fault_set_max_recursion_depth
export fault_set_timeout, fault_set_execution_limit
export compile_baremetal, compile_vhdl
