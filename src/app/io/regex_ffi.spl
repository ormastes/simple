# Regular Expressions SFFI Wrapper
# Two-tier SFFI pattern for pattern matching and text processing
# Dependencies: regex (Rust crate)

use app.io.sffi_common.{is_valid_handle, is_invalid_handle}
use std.text.{NL}

# ============================================================================
# Tier 1: Extern Function Declarations (Raw FFI)
# ============================================================================

# --- Regex Compilation ---

extern fn rt_regex_new(pattern: text) -> i64
extern fn rt_regex_destroy(handle: i64)

# --- Pattern Matching ---

extern fn rt_regex_is_match(handle: i64, text: text) -> i64
extern fn rt_regex_find(handle: i64, text: text) -> text
extern fn rt_regex_find_all(handle: i64, text: text) -> text

# --- Captures ---

extern fn rt_regex_captures(handle: i64, text: text) -> text
extern fn rt_regex_captures_len(handle: i64, text: text) -> i64

# --- Replace ---

extern fn rt_regex_replace(handle: i64, text: text, replacement: text) -> text
extern fn rt_regex_replace_all(handle: i64, text: text, replacement: text) -> text

# --- Split ---

extern fn rt_regex_split(handle: i64, text: text) -> text

# --- Quick Functions (no handle) ---

extern fn rt_regex_is_match_quick(pattern: text, text: text) -> i64
extern fn rt_regex_find_quick(pattern: text, text: text) -> text
extern fn rt_regex_replace_quick(pattern: text, text: text, replacement: text) -> text
extern fn rt_regex_replace_all_quick(pattern: text, text: text, replacement: text) -> text
extern fn rt_regex_split_quick(pattern: text, text: text) -> text

# ============================================================================
# Tier 2: Simple-Friendly Wrapper Functions
# ============================================================================

# --- Core Type ---

struct Regex:
    handle: i64
    pattern: text
    is_valid: bool

# --- Regex Construction ---

fn regex_new(pattern: text) -> Regex:
    """Compile regular expression pattern

    Args:
        pattern: Regular expression pattern

    Returns: Regex object (check is_valid field for success)

    Example:
        re = regex_new(r"\d+")
        if re.is_valid:
            # Use regex
    """
    val handle = rt_regex_new(pattern)
    Regex(handle: handle, pattern: pattern, is_valid: is_valid_handle(handle))

fn regex_destroy(regex: Regex):
    """Free regex resources"""
    if regex.is_valid:
        rt_regex_destroy(regex.handle)

# --- Pattern Matching ---

fn regex_is_match(regex: Regex, text: text) -> bool:
    """Test if pattern matches text

    Args:
        regex: Compiled regex
        text: Text to search

    Returns: true if pattern found, false otherwise

    Example:
        re = regex_new(r"\d+")
        if regex_is_match(re, "hello 123"):
            # Contains digits
    """
    if is_invalid_handle(regex.handle):
        return false

    val result = rt_regex_is_match(regex.handle, text)
    result == 1

fn regex_find(regex: Regex, text: text) -> text:
    """Find first match in text

    Returns: First matching substring, empty string if not found

    Example:
        re = regex_new(r"\d+")
        match = regex_find(re, "abc 123 def")  # "123"
    """
    if is_invalid_handle(regex.handle):
        return ""

    rt_regex_find(regex.handle, text)

fn regex_find_all(regex: Regex, text: text) -> [text]:
    """Find all matches in text

    Returns: Array of matching substrings

    Example:
        re = regex_new(r"\d+")
        matches = regex_find_all(re, "12 abc 34 def 56")  # ["12", "34", "56"]
    """
    if is_invalid_handle(regex.handle):
        return []

    val result = rt_regex_find_all(regex.handle, text)
    if result == "":
        return []

    result.split(NL)

# --- Captures (Groups) ---

fn regex_captures(regex: Regex, text: text) -> [text]:
    """Capture groups from first match

    Returns: Array of captured groups (index 0 = full match)

    Example:
        re = regex_new(r"(\d+)-(\d+)")
        groups = regex_captures(re, "abc 12-34 def")  # ["12-34", "12", "34"]
    """
    if is_invalid_handle(regex.handle):
        return []

    val result = rt_regex_captures(regex.handle, text)
    if result == "":
        return []

    result.split(NL)

fn regex_captures_len(regex: Regex, text: text) -> i64:
    """Count number of capture groups

    Returns: Number of groups (0 if no match)
    """
    if is_invalid_handle(regex.handle):
        return 0

    rt_regex_captures_len(regex.handle, text)

# --- Replace ---

fn regex_replace(regex: Regex, text: text, replacement: text) -> text:
    """Replace first match with replacement text

    Args:
        regex: Compiled regex
        text: Input text
        replacement: Replacement string (can use $1, $2 for captures)

    Returns: Text with first match replaced

    Example:
        re = regex_new(r"\d+")
        result = regex_replace(re, "abc 123 def 456", "NUM")  # "abc NUM def 456"
    """
    if is_invalid_handle(regex.handle):
        return text

    rt_regex_replace(regex.handle, text, replacement)

fn regex_replace_all(regex: Regex, text: text, replacement: text) -> text:
    """Replace all matches with replacement text

    Args:
        regex: Compiled regex
        text: Input text
        replacement: Replacement string (can use $1, $2 for captures)

    Returns: Text with all matches replaced

    Example:
        re = regex_new(r"\d+")
        result = regex_replace_all(re, "abc 123 def 456", "NUM")  # "abc NUM def NUM"
    """
    if is_invalid_handle(regex.handle):
        return text

    rt_regex_replace_all(regex.handle, text, replacement)

# --- Split ---

fn regex_split(regex: Regex, text: text) -> [text]:
    """Split text by pattern matches

    Returns: Array of substrings

    Example:
        re = regex_new(r"\s+")
        parts = regex_split(re, "hello  world   test")  # ["hello", "world", "test"]
    """
    if is_invalid_handle(regex.handle):
        return [text]

    val result = rt_regex_split(regex.handle, text)
    if result == "":
        return [text]

    result.split(NL)

# --- Quick Functions (one-off operations, no handle) ---

fn regex_is_match_quick(pattern: text, text: text) -> bool:
    """Test pattern match without compiling regex

    Use for one-off matches. For multiple matches, use regex_new()
    """
    val result = rt_regex_is_match_quick(pattern, text)
    result == 1

fn regex_find_quick(pattern: text, text: text) -> text:
    """Find first match without compiling regex

    Returns: First matching substring, empty string if not found
    """
    rt_regex_find_quick(pattern, text)

fn regex_replace_quick(pattern: text, text: text, replacement: text) -> text:
    """Replace first match without compiling regex"""
    rt_regex_replace_quick(pattern, text, replacement)

fn regex_replace_all_quick(pattern: text, text: text, replacement: text) -> text:
    """Replace all matches without compiling regex"""
    rt_regex_replace_all_quick(pattern, text, replacement)

fn regex_split_quick(pattern: text, text: text) -> [text]:
    """Split text by pattern without compiling regex

    Returns: Array of substrings
    """
    val result = rt_regex_split_quick(pattern, text)
    if result == "":
        return [text]

    result.split(NL)

# --- Helper Functions ---

fn regex_test(pattern: text, text: text) -> bool:
    """Alias for regex_is_match_quick (JavaScript-style)"""
    regex_is_match_quick(pattern, text)

fn regex_match(pattern: text, text: text) -> text:
    """Alias for regex_find_quick"""
    regex_find_quick(pattern, text)

fn regex_extract(pattern: text, text: text) -> [text]:
    """Extract all matches (quick version)

    Returns: Array of matching substrings
    """
    val result = rt_regex_find_quick(pattern, text)
    if result == "":
        return []

    result.split(NL)

# --- Common Patterns ---

fn regex_email() -> Regex:
    """Compile email validation regex

    Returns: Regex for basic email validation
    """
    regex_new(r"[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}")

fn regex_url() -> Regex:
    """Compile URL matching regex

    Returns: Regex for URL matching
    """
    regex_new(r"https?://[^\s]+")

fn regex_ipv4() -> Regex:
    """Compile IPv4 address regex

    Returns: Regex for IPv4 validation
    """
    regex_new(r"\b(?:[0-9]{1,3}\.){3}[0-9]{1,3}\b")

fn regex_phone_us() -> Regex:
    """Compile US phone number regex

    Returns: Regex for US phone numbers
    """
    regex_new(r"\d{3}[-.]?\d{3}[-.]?\d{4}")

fn regex_hex_color() -> Regex:
    """Compile hex color code regex

    Returns: Regex for hex colors (#RGB or #RRGGBB)
    """
    regex_new(r"#[0-9a-fA-F]{3}(?:[0-9a-fA-F]{3})?")

# --- Validation Helpers ---

fn is_valid_email(email: text) -> bool:
    """Validate email address

    Returns: true if email format is valid
    """
    regex_is_match_quick(r"[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}", email)

fn is_valid_url(url: text) -> bool:
    """Validate URL

    Returns: true if URL format is valid
    """
    regex_is_match_quick(r"https?://[^\s]+", url)

fn is_valid_ipv4(ip: text) -> bool:
    """Validate IPv4 address

    Returns: true if IPv4 format is valid
    """
    regex_is_match_quick(r"\b(?:[0-9]{1,3}\.){3}[0-9]{1,3}\b", ip)

# ============================================================================
# Export Functions
# ============================================================================

export Regex
export regex_new, regex_destroy
export regex_is_match, regex_find, regex_find_all
export regex_captures, regex_captures_len
export regex_replace, regex_replace_all
export regex_split
export regex_is_match_quick, regex_find_quick
export regex_replace_quick, regex_replace_all_quick, regex_split_quick
export regex_test, regex_match, regex_extract
export regex_email, regex_url, regex_ipv4, regex_phone_us, regex_hex_color
export is_valid_email, is_valid_url, is_valid_ipv4
