# Vulkan Compute Runtime SFFI Bindings
#
# Two-tier SFFI pattern:
# - Tier 1: extern fn rt_vulkan_* - Raw FFI bindings to runtime
# - Tier 2: Wrapper functions - Idiomatic Simple API
#
# These bindings require Vulkan SDK installed on the system.
# Focus is on compute shaders, not graphics rendering.

# ============================================================================
# Tier 1: Extern Declarations (Raw FFI)
# ============================================================================

# --- Instance and Device Management ---
extern fn rt_vulkan_init() -> bool
extern fn rt_vulkan_shutdown() -> bool
extern fn rt_vulkan_is_available() -> bool
extern fn rt_vulkan_device_count() -> i64
extern fn rt_vulkan_select_device(id: i64) -> bool
extern fn rt_vulkan_get_device() -> i64
extern fn rt_vulkan_device_name(id: i64) -> text
extern fn rt_vulkan_device_memory(id: i64) -> i64
extern fn rt_vulkan_device_type(id: i64) -> text  # "discrete", "integrated", "virtual", "cpu"
extern fn rt_vulkan_api_version(id: i64) -> (i64, i64, i64)  # major, minor, patch

# --- Memory Management ---
extern fn rt_vulkan_alloc_buffer(size: i64, usage: i64) -> i64  # Returns buffer handle
extern fn rt_vulkan_free_buffer(handle: i64) -> bool
extern fn rt_vulkan_map_memory(handle: i64) -> i64  # Returns mapped pointer
extern fn rt_vulkan_unmap_memory(handle: i64) -> bool
extern fn rt_vulkan_copy_to_buffer(handle: i64, data: [u8], offset: i64) -> bool
extern fn rt_vulkan_copy_from_buffer(data: [u8], handle: i64, offset: i64) -> bool
extern fn rt_vulkan_copy_buffer(dst: i64, src: i64, size: i64) -> bool

# --- Shader Compilation ---
extern fn rt_vulkan_compile_spirv(spirv_bytes: [u8]) -> i64  # Returns shader module handle
extern fn rt_vulkan_compile_glsl(glsl_source: text) -> i64  # Compile GLSL to module
extern fn rt_vulkan_destroy_shader(module: i64) -> bool

# --- Compute Pipeline ---
extern fn rt_vulkan_create_compute_pipeline(
    shader_module: i64,
    entry_point: text,
    push_constant_size: i64
) -> i64  # Returns pipeline handle
extern fn rt_vulkan_destroy_pipeline(pipeline: i64) -> bool

# --- Descriptor Sets (Buffer Bindings) ---
extern fn rt_vulkan_create_descriptor_set(pipeline: i64) -> i64
extern fn rt_vulkan_bind_buffer(descriptor_set: i64, binding: i64, buffer: i64) -> bool
extern fn rt_vulkan_destroy_descriptor_set(descriptor_set: i64) -> bool

# --- Command Execution ---
extern fn rt_vulkan_begin_compute() -> i64  # Returns command buffer handle
extern fn rt_vulkan_bind_pipeline(cmd: i64, pipeline: i64) -> bool
extern fn rt_vulkan_bind_descriptors(cmd: i64, descriptor_set: i64) -> bool
extern fn rt_vulkan_push_constants(cmd: i64, pipeline: i64, data: [u8]) -> bool
extern fn rt_vulkan_dispatch(cmd: i64, x: i64, y: i64, z: i64) -> bool
extern fn rt_vulkan_end_compute(cmd: i64) -> bool
extern fn rt_vulkan_submit_and_wait(cmd: i64) -> bool

# --- Synchronization ---
extern fn rt_vulkan_wait_idle() -> bool
extern fn rt_vulkan_create_fence() -> i64
extern fn rt_vulkan_destroy_fence(fence: i64) -> bool
extern fn rt_vulkan_wait_fence(fence: i64, timeout_ns: i64) -> bool
extern fn rt_vulkan_reset_fence(fence: i64) -> bool

# --- Error Handling ---
extern fn rt_vulkan_get_last_error() -> text

# ============================================================================
# Tier 2: Simple-Friendly Wrapper Functions
# ============================================================================

"""
Check if Vulkan is available on this system.
"""
fn vulkan_available() -> bool:
    rt_vulkan_is_available()

"""
Initialize the Vulkan instance.
Must be called before any other Vulkan functions.
"""
fn vulkan_init() -> bool:
    rt_vulkan_init()

"""
Shutdown Vulkan and release resources.
"""
fn vulkan_shutdown() -> bool:
    rt_vulkan_shutdown()

"""
Get the number of Vulkan-capable devices.
"""
fn vulkan_device_count() -> i64:
    rt_vulkan_device_count()

"""
Select a Vulkan device for compute operations.
"""
fn vulkan_select_device(id: i64) -> bool:
    rt_vulkan_select_device(id)

"""
Get the currently selected device.
"""
fn vulkan_get_device() -> i64:
    rt_vulkan_get_device()

"""
Vulkan device type.
"""
enum VulkanDeviceType:
    Discrete     # Dedicated GPU
    Integrated   # Integrated GPU
    Virtual      # Virtual GPU
    Cpu          # Software renderer
    Unknown

fn parse_device_type(type_str: text) -> VulkanDeviceType:
    match type_str:
        case "discrete": VulkanDeviceType.Discrete
        case "integrated": VulkanDeviceType.Integrated
        case "virtual": VulkanDeviceType.Virtual
        case "cpu": VulkanDeviceType.Cpu
        case _: VulkanDeviceType.Unknown

"""
Vulkan device information.
"""
struct VulkanDeviceInfo:
    id: i64
    name: text
    device_type: VulkanDeviceType
    total_memory: i64
    api_version: (i64, i64, i64)

fn vulkan_device_info(id: i64) -> VulkanDeviceInfo:
    VulkanDeviceInfo(
        id: id,
        name: rt_vulkan_device_name(id),
        device_type: parse_device_type(rt_vulkan_device_type(id)),
        total_memory: rt_vulkan_device_memory(id),
        api_version: rt_vulkan_api_version(id)
    )

"""
Buffer usage flags for Vulkan buffers.
"""
enum VulkanBufferUsage:
    Storage        # Storage buffer (read/write in shaders)
    Uniform        # Uniform buffer (read-only constants)
    TransferSrc    # Source for transfer operations
    TransferDst    # Destination for transfer operations

fn buffer_usage_to_flags(usage: VulkanBufferUsage) -> i64:
    match usage:
        case Storage: 0x80     # VK_BUFFER_USAGE_STORAGE_BUFFER_BIT
        case Uniform: 0x10     # VK_BUFFER_USAGE_UNIFORM_BUFFER_BIT
        case TransferSrc: 0x1  # VK_BUFFER_USAGE_TRANSFER_SRC_BIT
        case TransferDst: 0x2  # VK_BUFFER_USAGE_TRANSFER_DST_BIT

"""
Vulkan buffer wrapper.
"""
struct VulkanBuffer:
    handle: i64
    size: i64
    usage: VulkanBufferUsage
    is_valid: bool

"""
Allocate a Vulkan buffer.
"""
fn vulkan_alloc_buffer(size: i64, usage: VulkanBufferUsage) -> VulkanBuffer:
    val flags = buffer_usage_to_flags(usage)
    val handle = rt_vulkan_alloc_buffer(size, flags)
    VulkanBuffer(
        handle: handle,
        size: size,
        usage: usage,
        is_valid: handle != 0
    )

"""
Allocate a storage buffer (most common for compute).
"""
fn vulkan_alloc_storage(size: i64) -> VulkanBuffer:
    vulkan_alloc_buffer(size, VulkanBufferUsage.Storage)

"""
Free a Vulkan buffer.
"""
fn vulkan_free_buffer(buffer: VulkanBuffer) -> bool:
    if buffer.is_valid:
        rt_vulkan_free_buffer(buffer.handle)
    else:
        true

"""
Copy data to a Vulkan buffer.
"""
fn vulkan_copy_to(buffer: VulkanBuffer, data: [u8]) -> bool:
    if not buffer.is_valid:
        false
    else:
        rt_vulkan_copy_to_buffer(buffer.handle, data, 0)

"""
Copy data from a Vulkan buffer.
"""
fn vulkan_copy_from(data: [u8], buffer: VulkanBuffer) -> bool:
    if not buffer.is_valid:
        false
    else:
        rt_vulkan_copy_from_buffer(data, buffer.handle, 0)

"""
Copy between Vulkan buffers.
"""
fn vulkan_copy_buffer(dst: VulkanBuffer, src: VulkanBuffer, size: i64) -> bool:
    if not dst.is_valid or not src.is_valid:
        false
    else:
        rt_vulkan_copy_buffer(dst.handle, src.handle, size)

"""
Vulkan shader module wrapper.
"""
struct VulkanShader:
    handle: i64
    is_valid: bool

"""
Compile SPIR-V bytes into a shader module.
"""
fn vulkan_compile_spirv(spirv_bytes: [u8]) -> VulkanShader:
    val handle = rt_vulkan_compile_spirv(spirv_bytes)
    VulkanShader(
        handle: handle,
        is_valid: handle != 0
    )

"""
Compile GLSL source into a shader module.
Requires glslangValidator or shaderc to be available.
"""
fn vulkan_compile_glsl(glsl_source: text) -> VulkanShader:
    val handle = rt_vulkan_compile_glsl(glsl_source)
    VulkanShader(
        handle: handle,
        is_valid: handle != 0
    )

"""
Destroy a shader module.
"""
fn vulkan_destroy_shader(shader: VulkanShader) -> bool:
    if shader.is_valid:
        rt_vulkan_destroy_shader(shader.handle)
    else:
        true

"""
Vulkan compute pipeline wrapper.
"""
struct VulkanPipeline:
    handle: i64
    shader: VulkanShader
    entry_point: text
    is_valid: bool

"""
Create a compute pipeline from a shader.
"""
fn vulkan_create_pipeline(shader: VulkanShader, entry_point: text) -> VulkanPipeline:
    if not shader.is_valid:
        VulkanPipeline(handle: 0, shader: shader, entry_point: entry_point, is_valid: false)
    else:
        val handle = rt_vulkan_create_compute_pipeline(shader.handle, entry_point, 0)
        VulkanPipeline(
            handle: handle,
            shader: shader,
            entry_point: entry_point,
            is_valid: handle != 0
        )

"""
Create a compute pipeline with push constants.
"""
fn vulkan_create_pipeline_with_push(shader: VulkanShader, entry_point: text, push_size: i64) -> VulkanPipeline:
    if not shader.is_valid:
        VulkanPipeline(handle: 0, shader: shader, entry_point: entry_point, is_valid: false)
    else:
        val handle = rt_vulkan_create_compute_pipeline(shader.handle, entry_point, push_size)
        VulkanPipeline(
            handle: handle,
            shader: shader,
            entry_point: entry_point,
            is_valid: handle != 0
        )

"""
Destroy a compute pipeline.
"""
fn vulkan_destroy_pipeline(pipeline: VulkanPipeline) -> bool:
    if pipeline.is_valid:
        rt_vulkan_destroy_pipeline(pipeline.handle)
    else:
        true

"""
Vulkan descriptor set for binding buffers.
"""
struct VulkanDescriptorSet:
    handle: i64
    pipeline: VulkanPipeline
    is_valid: bool

"""
Create a descriptor set for a pipeline.
"""
fn vulkan_create_descriptors(pipeline: VulkanPipeline) -> VulkanDescriptorSet:
    if not pipeline.is_valid:
        VulkanDescriptorSet(handle: 0, pipeline: pipeline, is_valid: false)
    else:
        val handle = rt_vulkan_create_descriptor_set(pipeline.handle)
        VulkanDescriptorSet(
            handle: handle,
            pipeline: pipeline,
            is_valid: handle != 0
        )

"""
Bind a buffer to a descriptor set at a specific binding point.
"""
fn vulkan_bind_buffer(descriptors: VulkanDescriptorSet, binding: i64, buffer: VulkanBuffer) -> bool:
    if not descriptors.is_valid or not buffer.is_valid:
        false
    else:
        rt_vulkan_bind_buffer(descriptors.handle, binding, buffer.handle)

"""
Destroy a descriptor set.
"""
fn vulkan_destroy_descriptors(descriptors: VulkanDescriptorSet) -> bool:
    if descriptors.is_valid:
        rt_vulkan_destroy_descriptor_set(descriptors.handle)
    else:
        true

"""
Vulkan command buffer for recording operations.
"""
struct VulkanCommandBuffer:
    handle: i64
    is_valid: bool

"""
Begin recording compute commands.
"""
fn vulkan_begin_compute() -> VulkanCommandBuffer:
    val handle = rt_vulkan_begin_compute()
    VulkanCommandBuffer(
        handle: handle,
        is_valid: handle != 0
    )

"""
Record binding a pipeline.
"""
fn vulkan_cmd_bind_pipeline(cmd: VulkanCommandBuffer, pipeline: VulkanPipeline) -> bool:
    if not cmd.is_valid or not pipeline.is_valid:
        false
    else:
        rt_vulkan_bind_pipeline(cmd.handle, pipeline.handle)

"""
Record binding descriptors.
"""
fn vulkan_cmd_bind_descriptors(cmd: VulkanCommandBuffer, descriptors: VulkanDescriptorSet) -> bool:
    if not cmd.is_valid or not descriptors.is_valid:
        false
    else:
        rt_vulkan_bind_descriptors(cmd.handle, descriptors.handle)

"""
Record push constants.
"""
fn vulkan_cmd_push_constants(cmd: VulkanCommandBuffer, pipeline: VulkanPipeline, data: [u8]) -> bool:
    if not cmd.is_valid or not pipeline.is_valid:
        false
    else:
        rt_vulkan_push_constants(cmd.handle, pipeline.handle, data)

"""
Record a dispatch (launch workgroups).
"""
fn vulkan_cmd_dispatch(cmd: VulkanCommandBuffer, x: i64, y: i64, z: i64) -> bool:
    if not cmd.is_valid:
        false
    else:
        rt_vulkan_dispatch(cmd.handle, x, y, z)

"""
End recording compute commands.
"""
fn vulkan_end_compute(cmd: VulkanCommandBuffer) -> bool:
    if not cmd.is_valid:
        false
    else:
        rt_vulkan_end_compute(cmd.handle)

"""
Submit commands and wait for completion.
"""
fn vulkan_submit_and_wait(cmd: VulkanCommandBuffer) -> bool:
    if not cmd.is_valid:
        false
    else:
        rt_vulkan_submit_and_wait(cmd.handle)

"""
Wait for all device operations to complete.
"""
fn vulkan_wait_idle() -> bool:
    rt_vulkan_wait_idle()

"""
Get the last Vulkan error message.
"""
fn vulkan_last_error() -> text:
    rt_vulkan_get_last_error()

# ============================================================================
# High-Level Convenience API
# ============================================================================

"""
Configuration for compute dispatch.
"""
struct VulkanDispatchConfig:
    workgroups: (i64, i64, i64)
    local_size: (i64, i64, i64)  # Workgroup size (must match shader)

fn vulkan_dispatch_1d(total_elements: i64, local_size: i64) -> VulkanDispatchConfig:
    val workgroups = (total_elements + local_size - 1) / local_size
    VulkanDispatchConfig(
        workgroups: (workgroups, 1, 1),
        local_size: (local_size, 1, 1)
    )

"""
Simple compute execution: compile shader, bind buffers, dispatch, wait.
"""
fn vulkan_compute(
    glsl_source: text,
    entry_point: text,
    buffers: [(i64, VulkanBuffer)],  # (binding, buffer) pairs
    dispatch: VulkanDispatchConfig
) -> bool:
    # Compile shader
    val shader = vulkan_compile_glsl(glsl_source)
    if not shader.is_valid:
        return false

    # Create pipeline
    val pipeline = vulkan_create_pipeline(shader, entry_point)
    if not pipeline.is_valid:
        vulkan_destroy_shader(shader)
        return false

    # Create and configure descriptors
    val descriptors = vulkan_create_descriptors(pipeline)
    if not descriptors.is_valid:
        vulkan_destroy_pipeline(pipeline)
        vulkan_destroy_shader(shader)
        return false

    # Bind buffers
    for (binding, buffer) in buffers:
        if not vulkan_bind_buffer(descriptors, binding, buffer):
            vulkan_destroy_descriptors(descriptors)
            vulkan_destroy_pipeline(pipeline)
            vulkan_destroy_shader(shader)
            return false

    # Record and execute commands
    val cmd = vulkan_begin_compute()
    if not cmd.is_valid:
        vulkan_destroy_descriptors(descriptors)
        vulkan_destroy_pipeline(pipeline)
        vulkan_destroy_shader(shader)
        return false

    val (wx, wy, wz) = dispatch.workgroups
    val success = vulkan_cmd_bind_pipeline(cmd, pipeline)
        and vulkan_cmd_bind_descriptors(cmd, descriptors)
        and vulkan_cmd_dispatch(cmd, wx, wy, wz)
        and vulkan_end_compute(cmd)
        and vulkan_submit_and_wait(cmd)

    # Cleanup
    vulkan_destroy_descriptors(descriptors)
    vulkan_destroy_pipeline(pipeline)
    vulkan_destroy_shader(shader)

    success

# ============================================================================
# Exports
# ============================================================================

export vulkan_available, vulkan_init, vulkan_shutdown
export vulkan_device_count, vulkan_select_device, vulkan_get_device
export VulkanDeviceType, VulkanDeviceInfo, vulkan_device_info
export VulkanBufferUsage, VulkanBuffer
export vulkan_alloc_buffer, vulkan_alloc_storage, vulkan_free_buffer
export vulkan_copy_to, vulkan_copy_from, vulkan_copy_buffer
export VulkanShader, vulkan_compile_spirv, vulkan_compile_glsl, vulkan_destroy_shader
export VulkanPipeline, vulkan_create_pipeline, vulkan_create_pipeline_with_push, vulkan_destroy_pipeline
export VulkanDescriptorSet, vulkan_create_descriptors, vulkan_bind_buffer, vulkan_destroy_descriptors
export VulkanCommandBuffer, vulkan_begin_compute, vulkan_end_compute, vulkan_submit_and_wait
export vulkan_cmd_bind_pipeline, vulkan_cmd_bind_descriptors, vulkan_cmd_push_constants, vulkan_cmd_dispatch
export vulkan_wait_idle, vulkan_last_error
export VulkanDispatchConfig, vulkan_dispatch_1d, vulkan_compute
