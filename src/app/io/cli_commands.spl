# CLI Command Handlers - Command dispatch functions
# Extracted from cli_ops.spl for modularity
# Functions here reference helpers in cli_ops.spl (same directory, no imports needed)

use compiler.driver.driver.{interpret_file}
use compiler.driver.driver_types.{CompileResult}

# ============================================================================
# CLI Command Handlers
# ============================================================================

fn cli_run_code(code: str, gc_log: bool, gc_off: bool) -> i64:
    print "=== Simple Code Execution ==="
    print "Code: {code}"
    print "Note: Interpreter would evaluate this code"
    1

fn cli_run_file(path: str, args: [str], gc_log: bool, gc_off: bool) -> i64:
    val result = interpret_file(path)
    match result:
        case CompileResult.Success(_): 0
        case _:
            _cli_eprint("Error running {path}")
            1

fn cli_watch_file(path: str) -> i64:
    print "Watch mode not yet implemented in pure Simple"
    1

fn cli_run_repl(gc_log: bool, gc_off: bool) -> i64:
    print "=== Simple REPL ==="
    print "REPL not yet implemented in pure Simple"
    print ""
    print "For now, use: bin/simple yourfile.spl"
    1

fn cli_not_implemented(tool_name: text) -> i64:
    print "{tool_name} not yet implemented in pure Simple"
    1

fn _cli_strip_command(args: [str], cmd: text) -> [str]:
    if args.len() > 0 and args[0] == cmd:
        args.slice(1, args.len())
    else:
        args

fn cli_run_tests(args: [str], gc_log: bool, gc_off: bool) -> i64:
    val result = interpret_file("src/app/test_runner_new/main.spl")
    match result:
        case CompileResult.Success(_): 0
        case _:
            _cli_eprint("Error running test runner")
            1

fn cli_run_lint(args: [str]) -> i64:
    cli_not_implemented("Linter")

fn cli_run_fmt(args: [str]) -> i64:
    cli_not_implemented("Formatter")

fn cli_run_fix(args: [str]) -> i64:
    cli_not_implemented("Fix tool")

fn cli_run_verify(args: [str], gc_log: bool, gc_off: bool) -> i64:
    cli_not_implemented("Verifier")

fn cli_run_migrate(args: [str]) -> i64:
    cli_not_implemented("Migration tool")

fn cli_run_mcp(args: [str]) -> i64:
    # Single canonical MCP entry via wrapper for fast startup and stable stdio framing.
    var cmd = "./bin/simple_mcp_server"
    var i = 1
    while i < args.len():
        cmd = cmd + " " + args[i]
        i = i + 1

    val result = _cli_shell(cmd)
    if result.stdout.len() > 0:
        print(result.stdout)
    if result.stderr.len() > 0:
        _cli_eprint(result.stderr)
    result.exit_code

fn cli_run_lsp(args: [str]) -> i64:
    # Handle --help/--version inline (subprocess can't access rt_cli_args)
    var i = 1
    for idx in 1..args.len():
        val arg = args[idx]
        if arg == "--help" or arg == "-h":
            print "Simple Language Server (LSP)"
            print ""
            print "Usage: simple lsp [options]"
            print ""
            print "The language server communicates via stdin/stdout using the"
            print "Language Server Protocol (LSP) with JSON-RPC 2.0 messages."
            print ""
            print "Options:"
            print "  -h, --help       Show this help message"
            print "  -v, --version    Show version information"
            print ""
            print "Environment Variables:"
            print "  SIMPLE_LSP_DEBUG  Enable debug logging to stderr"
            print ""
            print "Editor Integration:"
            print "  VS Code: Install the Simple Language extension"
            print "    Settings: simple.lsp.serverPath = simple"
            print ""
            print "  Neovim: Use simple.nvim plugin"
            print "    require('simple').setup()"
            return 0
        if arg == "--version" or arg == "-v":
            print "simple-lsp 0.1.0"
            print "Simple Language Server (LSP)"
            return 0

    # Start LSP server (requires compiled mode for tree-sitter, JSON-RPC)
    print "Simple Language Server"
    print "The LSP server requires compiled mode for full operation."
    print "Run: simple build && ./build/simple lsp"
    print ""
    print "For help, use: simple lsp --help"
    1

fn cli_run_diff(args: [str]) -> i64:
    cli_not_implemented("Diff tool")

fn cli_constr(args: [str]) -> i64:
    cli_not_implemented("Constraint checker")

fn cli_run_query(args: [str]) -> i64:
    val run_args = _cli_strip_command(args, "query")
    cli_run_file("src/app/cli/query.spl", run_args, false, false)

fn cli_run_spec_coverage(args: [str]) -> i64:
    val run_args = _cli_strip_command(args, "spec-coverage")
    cli_run_file("src/app/spec_coverage/main.spl", run_args, false, false)

fn cli_gen_lean(args: [str]) -> i64:
    cli_not_implemented("Lean generator")

fn cli_run_feature_gen(args: [str]) -> i64:
    val run_args = _cli_strip_command(args, "feature-gen")
    cli_run_file("src/app/feature_gen/main.spl", run_args, false, false)

fn cli_run_task_gen(args: [str]) -> i64:
    val run_args = _cli_strip_command(args, "task-gen")
    cli_run_file("src/app/task_gen/main.spl", run_args, false, false)

fn cli_run_spec_gen(args: [str]) -> i64:
    val run_args = _cli_strip_command(args, "spec-gen")
    cli_run_file("src/app/spec_gen/main.spl", run_args, false, false)

fn cli_run_sspec_docgen(args: [str]) -> i64:
    val run_args = _cli_strip_command(args, "sspec-docgen")
    cli_run_file("src/app/sspec_docgen/main.spl", run_args, false, false)

fn cli_run_feature_doc(args: [str]) -> i64:
    val run_args = _cli_strip_command(args, "feature-doc")
    cli_run_file("src/app/feature_doc/main.spl", run_args, false, false)

fn cli_run_todo_gen(args: [str]) -> i64:
    cli_run_file("src/app/todo_scan/main.spl", args, false, false)

fn cli_todo_scan(args: [str]) -> i64:
    cli_run_file("src/app/todo_scan/main.spl", args, false, false)

fn cli_run_lex(args: [str]) -> i64:
    cli_not_implemented("Lexer")

fn cli_run_brief(args: [str]) -> i64:
    cli_not_implemented("Brief tool")

fn cli_run_ffi_gen(args: [str]) -> i64:
    cli_not_implemented("FFI generator")

fn cli_run_i18n(args: [str]) -> i64:
    cli_not_implemented("i18n tool")

fn cli_handle_web(args: [str]) -> i64:
    cli_not_implemented("Web handler")

fn cli_handle_diagram(args: [str]) -> i64:
    cli_not_implemented("Diagram generator")

fn cli_handle_run(args: [str], gc_log: bool, gc_off: bool) -> i64:
    if args.len() > 0:
        cli_run_file(args[0], args[1:], gc_log, gc_off)
    else:
        print "No file specified"
        1

fn cli_handle_compile(args: [str]) -> i64:
    cli_compile(args)

fn cli_handle_linkers() -> i64:
    cli_not_implemented("Linker information")

fn cli_replay(args: [str]) -> i64:
    cli_not_implemented("Replay tool")

fn cli_check(args: [str]) -> i64:
    cli_not_implemented("Type checker")

fn cli_info(args: [str]) -> i64:
    cli_not_implemented("Info tool")

export cli_run_code, cli_run_file, cli_watch_file, cli_run_repl, cli_run_tests
export cli_run_lint, cli_run_fmt, cli_run_fix, cli_run_verify, cli_run_migrate
export cli_run_mcp, cli_run_lsp, cli_run_diff, cli_run_query, cli_run_spec_coverage
export cli_run_feature_gen, cli_run_task_gen, cli_run_spec_gen, cli_run_sspec_docgen, cli_run_feature_doc
export cli_run_todo_gen, cli_run_lex, cli_run_brief, cli_run_ffi_gen, cli_run_i18n
export cli_handle_web, cli_handle_diagram, cli_handle_run, cli_handle_compile, cli_handle_linkers
export cli_replay, cli_constr, cli_check, cli_info
export cli_todo_scan, cli_gen_lean
