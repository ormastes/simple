# Time Functions - Pure Simple I/O
# Extracted from mod.spl for modularity

# Extern fn declarations (runtime resolves at file level)
extern fn rt_time_now_unix_micros() -> i64

# ============================================================================
# Time Functions
# ============================================================================

fn time_now_unix_micros() -> i64:
    rt_time_now_unix_micros()

fn current_time_unix() -> i64:
    time_now_unix_micros() / 1_000_000

fn current_time_ms() -> i64:
    time_now_unix_micros() / 1_000

fn timestamp_year(micros: i64) -> i32:
    val seconds = micros / 1_000_000
    val years = seconds / (365 * 24 * 60 * 60)
    (1970 + years).to_i32()

fn timestamp_month(micros: i64) -> i32:
    1

fn timestamp_day(micros: i64) -> i32:
    1

fn timestamp_hour(micros: i64) -> i32:
    val seconds = micros / 1_000_000
    val hours = (seconds / 3600) % 24
    hours.to_i32()

fn timestamp_minute(micros: i64) -> i32:
    val seconds = micros / 1_000_000
    val minutes = (seconds / 60) % 60
    minutes.to_i32()

fn timestamp_second(micros: i64) -> i32:
    val seconds = micros / 1_000_000
    val secs = seconds % 60
    secs.to_i32()

# --- Timestamp string helper ---

fn rt_timestamp_now() -> i64:
    time_now_unix_micros()

# --- Sleep ---

extern fn rt_process_run(cmd: text, args: [text]) -> (text, text, i64)

fn rt_sleep_ms(milliseconds: i64):
    val seconds = milliseconds / 1000
    val remainder = milliseconds % 1000
    if seconds > 0:
        rt_process_run("/bin/sh", ["-c", "sleep {seconds}"])
    if remainder > 0:
        rt_process_run("/bin/sh", ["-c", "sleep 0.{remainder}"])

export time_now_unix_micros, current_time_unix, current_time_ms
export timestamp_year, timestamp_month, timestamp_day
export timestamp_hour, timestamp_minute, timestamp_second
export rt_timestamp_now, rt_sleep_ms
