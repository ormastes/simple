# Rapier2D Physics Engine SFFI Bindings
#
# SFFI pattern for Rapier2D physics.
# Rapier is a fast and cross-platform physics engine written in Rust.
#
# Documentation: https://rapier.rs/docs/user_guides/rust/getting_started

# ============================================================================
# Tier 1: Extern Declarations (Raw FFI)
# ============================================================================

# --- Physics World ---
extern fn rt_rapier2d_world_new(gravity_x: f64, gravity_y: f64) -> i64
extern fn rt_rapier2d_world_free(world: i64) -> bool
extern fn rt_rapier2d_world_step(world: i64, dt: f64) -> bool
extern fn rt_rapier2d_world_set_gravity(world: i64, x: f64, y: f64) -> bool

# --- Rigid Body ---
extern fn rt_rapier2d_body_new_dynamic(world: i64, x: f64, y: f64, rotation: f64) -> i64
extern fn rt_rapier2d_body_new_static(world: i64, x: f64, y: f64, rotation: f64) -> i64
extern fn rt_rapier2d_body_new_kinematic(world: i64, x: f64, y: f64, rotation: f64) -> i64
extern fn rt_rapier2d_body_free(world: i64, handle: i64) -> bool
extern fn rt_rapier2d_body_get_position(world: i64, handle: i64) -> (f64, f64, f64)
extern fn rt_rapier2d_body_set_position(world: i64, handle: i64, x: f64, y: f64, rotation: f64) -> bool
extern fn rt_rapier2d_body_get_velocity(world: i64, handle: i64) -> (f64, f64, f64)
extern fn rt_rapier2d_body_set_velocity(world: i64, handle: i64, vx: f64, vy: f64, angular: f64) -> bool
extern fn rt_rapier2d_body_apply_force(world: i64, handle: i64, fx: f64, fy: f64, wake_up: bool) -> bool
extern fn rt_rapier2d_body_apply_impulse(world: i64, handle: i64, ix: f64, iy: f64, wake_up: bool) -> bool
extern fn rt_rapier2d_body_apply_torque(world: i64, handle: i64, torque: f64, wake_up: bool) -> bool
extern fn rt_rapier2d_body_apply_torque_impulse(world: i64, handle: i64, impulse: f64, wake_up: bool) -> bool
extern fn rt_rapier2d_body_set_mass(world: i64, handle: i64, mass: f64) -> bool
extern fn rt_rapier2d_body_get_mass(world: i64, handle: i64) -> f64
extern fn rt_rapier2d_body_set_linear_damping(world: i64, handle: i64, damping: f64) -> bool
extern fn rt_rapier2d_body_set_angular_damping(world: i64, handle: i64, damping: f64) -> bool
extern fn rt_rapier2d_body_is_sleeping(world: i64, handle: i64) -> bool
extern fn rt_rapier2d_body_wake_up(world: i64, handle: i64) -> bool
extern fn rt_rapier2d_body_sleep(world: i64, handle: i64) -> bool

# --- Colliders (Shapes) ---
extern fn rt_rapier2d_collider_new_circle(world: i64, body: i64, radius: f64) -> i64
extern fn rt_rapier2d_collider_new_box(world: i64, body: i64, half_width: f64, half_height: f64) -> i64
extern fn rt_rapier2d_collider_new_capsule(world: i64, body: i64, half_height: f64, radius: f64) -> i64
extern fn rt_rapier2d_collider_new_polygon(world: i64, body: i64, vertices: [f64]) -> i64
extern fn rt_rapier2d_collider_free(world: i64, handle: i64) -> bool
extern fn rt_rapier2d_collider_set_offset(world: i64, handle: i64, x: f64, y: f64, rotation: f64) -> bool
extern fn rt_rapier2d_collider_set_restitution(world: i64, handle: i64, coef: f64) -> bool
extern fn rt_rapier2d_collider_set_friction(world: i64, handle: i64, coef: f64) -> bool
extern fn rt_rapier2d_collider_set_density(world: i64, handle: i64, density: f64) -> bool
extern fn rt_rapier2d_collider_set_sensor(world: i64, handle: i64, is_sensor: bool) -> bool

# --- Collision Detection ---
extern fn rt_rapier2d_world_get_contacts(world: i64) -> i64
extern fn rt_rapier2d_contacts_count(contacts: i64) -> i64
extern fn rt_rapier2d_contacts_get(contacts: i64, index: i64) -> (i64, i64, f64, f64, f64, f64, f64)
extern fn rt_rapier2d_contacts_free(contacts: i64) -> bool
extern fn rt_rapier2d_world_intersection_test(world: i64, collider1: i64, collider2: i64) -> bool
extern fn rt_rapier2d_world_cast_ray(world: i64, origin_x: f64, origin_y: f64, dir_x: f64, dir_y: f64, max_dist: f64) -> (bool, i64, f64)

# --- Joints/Constraints ---
extern fn rt_rapier2d_joint_distance(world: i64, body1: i64, body2: i64, anchor1_x: f64, anchor1_y: f64, anchor2_x: f64, anchor2_y: f64, distance: f64) -> i64
extern fn rt_rapier2d_joint_revolute(world: i64, body1: i64, body2: i64, anchor_x: f64, anchor_y: f64) -> i64
extern fn rt_rapier2d_joint_prismatic(world: i64, body1: i64, body2: i64, axis_x: f64, axis_y: f64) -> i64
extern fn rt_rapier2d_joint_fixed(world: i64, body1: i64, body2: i64) -> i64
extern fn rt_rapier2d_joint_free(world: i64, handle: i64) -> bool
extern fn rt_rapier2d_joint_set_limits(world: i64, joint: i64, min: f64, max: f64) -> bool
extern fn rt_rapier2d_joint_set_motor(world: i64, joint: i64, target_vel: f64, max_force: f64) -> bool

# --- Query and Utilities ---
extern fn rt_rapier2d_world_body_count(world: i64) -> i64
extern fn rt_rapier2d_world_collider_count(world: i64) -> i64
extern fn rt_rapier2d_world_joint_count(world: i64) -> i64
extern fn rt_rapier2d_get_last_error() -> text

# ============================================================================
# Tier 2: Simple-Friendly Wrapper Functions
# ============================================================================

# --- Core Types ---

struct Vector2:
    x: f64
    y: f64

impl Vector2:
    fn length() -> f64:
        (self.x * self.x + self.y * self.y).sqrt()

    fn normalize() -> Vector2:
        val len = self.length()
        if len > 0.0:
            Vector2(x: self.x / len, y: self.y / len)
        else:
            Vector2(x: 0.0, y: 0.0)

    fn dot(other: Vector2) -> f64:
        self.x * other.x + self.y * other.y

    fn add(other: Vector2) -> Vector2:
        Vector2(x: self.x + other.x, y: self.y + other.y)

    fn sub(other: Vector2) -> Vector2:
        Vector2(x: self.x - other.x, y: self.y - other.y)

    fn scale(factor: f64) -> Vector2:
        Vector2(x: self.x * factor, y: self.y * factor)

struct Rotation2:
    angle: f64  # Radians

impl Rotation2:
    fn to_degrees() -> f64:
        self.angle * 57.29577951308232  # 180 / PI

    static fn from_degrees(degrees: f64) -> Rotation2:
        Rotation2(angle: degrees * 0.017453292519943295)  # PI / 180

struct Transform2:
    position: Vector2
    rotation: Rotation2

# --- Physics World ---

struct PhysicsWorld:
    handle: i64
    is_valid: bool

fn physics_create_world(gravity: Vector2) -> PhysicsWorld:
    val handle = rt_rapier2d_world_new(gravity.x, gravity.y)
    PhysicsWorld(handle: handle, is_valid: handle != 0)

fn physics_create_world_default() -> PhysicsWorld:
    physics_create_world(Vector2(x: 0.0, y: -9.81))

fn physics_destroy_world(world: PhysicsWorld) -> bool:
    if world.is_valid:
        rt_rapier2d_world_free(world.handle)
    else:
        true

fn physics_step(world: PhysicsWorld, dt: f64) -> bool:
    if not world.is_valid:
        false
    else:
        rt_rapier2d_world_step(world.handle, dt)

fn physics_set_gravity(world: PhysicsWorld, gravity: Vector2) -> bool:
    if not world.is_valid:
        false
    else:
        rt_rapier2d_world_set_gravity(world.handle, gravity.x, gravity.y)

fn physics_world_stats(world: PhysicsWorld) -> (i64, i64, i64):
    if not world.is_valid:
        (0, 0, 0)
    else:
        val bodies = rt_rapier2d_world_body_count(world.handle)
        val colliders = rt_rapier2d_world_collider_count(world.handle)
        val joints = rt_rapier2d_world_joint_count(world.handle)
        (bodies, colliders, joints)

# --- Rigid Bodies ---

enum BodyType:
    Dynamic
    Static
    Kinematic

struct RigidBody:
    handle: i64
    world: PhysicsWorld
    body_type: BodyType
    is_valid: bool

fn physics_create_body(world: PhysicsWorld, body_type: BodyType, transform: Transform2) -> RigidBody:
    if not world.is_valid:
        RigidBody(handle: 0, world: world, body_type: body_type, is_valid: false)
    else:
        val handle = if body_type == BodyType.Dynamic:
            rt_rapier2d_body_new_dynamic(world.handle, transform.position.x, transform.position.y, transform.rotation.angle)
        elif body_type == BodyType.Static:
            rt_rapier2d_body_new_static(world.handle, transform.position.x, transform.position.y, transform.rotation.angle)
        else:
            rt_rapier2d_body_new_kinematic(world.handle, transform.position.x, transform.position.y, transform.rotation.angle)
        RigidBody(handle: handle, world: world, body_type: body_type, is_valid: handle != 0)

fn physics_create_dynamic_body(world: PhysicsWorld, position: Vector2) -> RigidBody:
    physics_create_body(world, BodyType.Dynamic, Transform2(position: position, rotation: Rotation2(angle: 0.0)))

fn physics_create_static_body(world: PhysicsWorld, position: Vector2) -> RigidBody:
    physics_create_body(world, BodyType.Static, Transform2(position: position, rotation: Rotation2(angle: 0.0)))

fn physics_destroy_body(body: RigidBody) -> bool:
    if not body.is_valid:
        true
    else:
        rt_rapier2d_body_free(body.world.handle, body.handle)

fn physics_body_get_position(body: RigidBody) -> Transform2:
    if not body.is_valid:
        Transform2(position: Vector2(x: 0.0, y: 0.0), rotation: Rotation2(angle: 0.0))
    else:
        val result = rt_rapier2d_body_get_position(body.world.handle, body.handle)
        Transform2(position: Vector2(x: result.0, y: result.1), rotation: Rotation2(angle: result.2))

fn physics_body_set_position(body: RigidBody, transform: Transform2) -> bool:
    if not body.is_valid:
        false
    else:
        rt_rapier2d_body_set_position(body.world.handle, body.handle, transform.position.x, transform.position.y, transform.rotation.angle)

fn physics_body_get_velocity(body: RigidBody) -> (Vector2, f64):
    if not body.is_valid:
        (Vector2(x: 0.0, y: 0.0), 0.0)
    else:
        val result = rt_rapier2d_body_get_velocity(body.world.handle, body.handle)
        (Vector2(x: result.0, y: result.1), result.2)

fn physics_body_set_velocity(body: RigidBody, linear: Vector2, angular: f64) -> bool:
    if not body.is_valid:
        false
    else:
        rt_rapier2d_body_set_velocity(body.world.handle, body.handle, linear.x, linear.y, angular)

fn physics_body_apply_force(body: RigidBody, force: Vector2) -> bool:
    if not body.is_valid:
        false
    else:
        rt_rapier2d_body_apply_force(body.world.handle, body.handle, force.x, force.y, true)

fn physics_body_apply_impulse(body: RigidBody, impulse: Vector2) -> bool:
    if not body.is_valid:
        false
    else:
        rt_rapier2d_body_apply_impulse(body.world.handle, body.handle, impulse.x, impulse.y, true)

fn physics_body_apply_torque(body: RigidBody, torque: f64) -> bool:
    if not body.is_valid:
        false
    else:
        rt_rapier2d_body_apply_torque(body.world.handle, body.handle, torque, true)

fn physics_body_set_mass(body: RigidBody, mass: f64) -> bool:
    if not body.is_valid:
        false
    else:
        rt_rapier2d_body_set_mass(body.world.handle, body.handle, mass)

fn physics_body_get_mass(body: RigidBody) -> f64:
    if not body.is_valid:
        0.0
    else:
        rt_rapier2d_body_get_mass(body.world.handle, body.handle)

fn physics_body_set_damping(body: RigidBody, linear: f64, angular: f64) -> bool:
    if not body.is_valid:
        false
    else:
        val r1 = rt_rapier2d_body_set_linear_damping(body.world.handle, body.handle, linear)
        val r2 = rt_rapier2d_body_set_angular_damping(body.world.handle, body.handle, angular)
        r1 and r2

fn physics_body_is_sleeping(body: RigidBody) -> bool:
    if not body.is_valid:
        false
    else:
        rt_rapier2d_body_is_sleeping(body.world.handle, body.handle)

fn physics_body_wake_up(body: RigidBody) -> bool:
    if not body.is_valid:
        false
    else:
        rt_rapier2d_body_wake_up(body.world.handle, body.handle)

# --- Colliders ---

enum ColliderShape:
    Circle
    Box
    Capsule
    Polygon

struct Collider:
    handle: i64
    world: PhysicsWorld
    shape: ColliderShape
    is_valid: bool

fn physics_create_circle_collider(world: PhysicsWorld, body: RigidBody, radius: f64) -> Collider:
    if not world.is_valid or not body.is_valid:
        Collider(handle: 0, world: world, shape: ColliderShape.Circle, is_valid: false)
    else:
        val handle = rt_rapier2d_collider_new_circle(world.handle, body.handle, radius)
        Collider(handle: handle, world: world, shape: ColliderShape.Circle, is_valid: handle != 0)

fn physics_create_box_collider(world: PhysicsWorld, body: RigidBody, half_width: f64, half_height: f64) -> Collider:
    if not world.is_valid or not body.is_valid:
        Collider(handle: 0, world: world, shape: ColliderShape.Box, is_valid: false)
    else:
        val handle = rt_rapier2d_collider_new_box(world.handle, body.handle, half_width, half_height)
        Collider(handle: handle, world: world, shape: ColliderShape.Box, is_valid: handle != 0)

fn physics_create_capsule_collider(world: PhysicsWorld, body: RigidBody, half_height: f64, radius: f64) -> Collider:
    if not world.is_valid or not body.is_valid:
        Collider(handle: 0, world: world, shape: ColliderShape.Capsule, is_valid: false)
    else:
        val handle = rt_rapier2d_collider_new_capsule(world.handle, body.handle, half_height, radius)
        Collider(handle: handle, world: world, shape: ColliderShape.Capsule, is_valid: handle != 0)

fn physics_create_polygon_collider(world: PhysicsWorld, body: RigidBody, vertices: [f64]) -> Collider:
    if not world.is_valid or not body.is_valid:
        Collider(handle: 0, world: world, shape: ColliderShape.Polygon, is_valid: false)
    else:
        val handle = rt_rapier2d_collider_new_polygon(world.handle, body.handle, vertices)
        Collider(handle: handle, world: world, shape: ColliderShape.Polygon, is_valid: handle != 0)

fn physics_destroy_collider(collider: Collider) -> bool:
    if not collider.is_valid:
        true
    else:
        rt_rapier2d_collider_free(collider.world.handle, collider.handle)

fn physics_collider_set_offset(collider: Collider, offset: Vector2, rotation: f64) -> bool:
    if not collider.is_valid:
        false
    else:
        rt_rapier2d_collider_set_offset(collider.world.handle, collider.handle, offset.x, offset.y, rotation)

struct PhysicsMaterial:
    restitution: f64  # Bounciness (0 = no bounce, 1 = perfect bounce)
    friction: f64     # Friction coefficient (0 = no friction)
    density: f64      # Mass per unit area

fn physics_collider_set_material(collider: Collider, material: PhysicsMaterial) -> bool:
    if not collider.is_valid:
        false
    else:
        val r1 = rt_rapier2d_collider_set_restitution(collider.world.handle, collider.handle, material.restitution)
        val r2 = rt_rapier2d_collider_set_friction(collider.world.handle, collider.handle, material.friction)
        val r3 = rt_rapier2d_collider_set_density(collider.world.handle, collider.handle, material.density)
        r1 and r2 and r3

fn physics_collider_set_sensor(collider: Collider, is_sensor: bool) -> bool:
    if not collider.is_valid:
        false
    else:
        rt_rapier2d_collider_set_sensor(collider.world.handle, collider.handle, is_sensor)

# --- Collision Detection ---

struct Contact:
    collider1: i64
    collider2: i64
    point: Vector2
    normal: Vector2
    penetration: f64

struct ContactList:
    handle: i64
    world: PhysicsWorld
    is_valid: bool

fn physics_get_contacts(world: PhysicsWorld) -> ContactList:
    if not world.is_valid:
        ContactList(handle: 0, world: world, is_valid: false)
    else:
        val handle = rt_rapier2d_world_get_contacts(world.handle)
        ContactList(handle: handle, world: world, is_valid: handle != 0)

fn physics_contacts_count(contacts: ContactList) -> i64:
    if not contacts.is_valid:
        0
    else:
        rt_rapier2d_contacts_count(contacts.handle)

fn physics_contacts_get(contacts: ContactList, index: i64) -> Contact:
    if not contacts.is_valid:
        Contact(collider1: 0, collider2: 0, point: Vector2(x: 0.0, y: 0.0), normal: Vector2(x: 0.0, y: 0.0), penetration: 0.0)
    else:
        val result = rt_rapier2d_contacts_get(contacts.handle, index)
        Contact(collider1: result.0, collider2: result.1, point: Vector2(x: result.2, y: result.3), normal: Vector2(x: result.4, y: result.5), penetration: result.6)

fn physics_destroy_contacts(contacts: ContactList) -> bool:
    if not contacts.is_valid:
        true
    else:
        rt_rapier2d_contacts_free(contacts.handle)

fn physics_intersection_test(world: PhysicsWorld, collider1: Collider, collider2: Collider) -> bool:
    if not world.is_valid or not collider1.is_valid or not collider2.is_valid:
        false
    else:
        rt_rapier2d_world_intersection_test(world.handle, collider1.handle, collider2.handle)

struct RayCastResult:
    hit: bool
    collider: i64
    distance: f64

fn physics_cast_ray(world: PhysicsWorld, origin: Vector2, direction: Vector2, max_distance: f64) -> RayCastResult:
    if not world.is_valid:
        RayCastResult(hit: false, collider: 0, distance: 0.0)
    else:
        val result = rt_rapier2d_world_cast_ray(world.handle, origin.x, origin.y, direction.x, direction.y, max_distance)
        RayCastResult(hit: result.0, collider: result.1, distance: result.2)

# --- Joints ---

enum JointType:
    Distance
    Revolute
    Prismatic
    Fixed

struct Joint:
    handle: i64
    world: PhysicsWorld
    joint_type: JointType
    is_valid: bool

fn physics_create_distance_joint(world: PhysicsWorld, body1: RigidBody, body2: RigidBody, anchor1: Vector2, anchor2: Vector2, distance: f64) -> Joint:
    if not world.is_valid or not body1.is_valid or not body2.is_valid:
        Joint(handle: 0, world: world, joint_type: JointType.Distance, is_valid: false)
    else:
        val handle = rt_rapier2d_joint_distance(world.handle, body1.handle, body2.handle, anchor1.x, anchor1.y, anchor2.x, anchor2.y, distance)
        Joint(handle: handle, world: world, joint_type: JointType.Distance, is_valid: handle != 0)

fn physics_create_revolute_joint(world: PhysicsWorld, body1: RigidBody, body2: RigidBody, anchor: Vector2) -> Joint:
    if not world.is_valid or not body1.is_valid or not body2.is_valid:
        Joint(handle: 0, world: world, joint_type: JointType.Revolute, is_valid: false)
    else:
        val handle = rt_rapier2d_joint_revolute(world.handle, body1.handle, body2.handle, anchor.x, anchor.y)
        Joint(handle: handle, world: world, joint_type: JointType.Revolute, is_valid: handle != 0)

fn physics_create_prismatic_joint(world: PhysicsWorld, body1: RigidBody, body2: RigidBody, axis: Vector2) -> Joint:
    if not world.is_valid or not body1.is_valid or not body2.is_valid:
        Joint(handle: 0, world: world, joint_type: JointType.Prismatic, is_valid: false)
    else:
        val handle = rt_rapier2d_joint_prismatic(world.handle, body1.handle, body2.handle, axis.x, axis.y)
        Joint(handle: handle, world: world, joint_type: JointType.Prismatic, is_valid: handle != 0)

fn physics_create_fixed_joint(world: PhysicsWorld, body1: RigidBody, body2: RigidBody) -> Joint:
    if not world.is_valid or not body1.is_valid or not body2.is_valid:
        Joint(handle: 0, world: world, joint_type: JointType.Fixed, is_valid: false)
    else:
        val handle = rt_rapier2d_joint_fixed(world.handle, body1.handle, body2.handle)
        Joint(handle: handle, world: world, joint_type: JointType.Fixed, is_valid: handle != 0)

fn physics_destroy_joint(joint: Joint) -> bool:
    if not joint.is_valid:
        true
    else:
        rt_rapier2d_joint_free(joint.world.handle, joint.handle)

fn physics_joint_set_limits(joint: Joint, min: f64, max: f64) -> bool:
    if not joint.is_valid:
        false
    else:
        rt_rapier2d_joint_set_limits(joint.world.handle, joint.handle, min, max)

fn physics_joint_set_motor(joint: Joint, target_velocity: f64, max_force: f64) -> bool:
    if not joint.is_valid:
        false
    else:
        rt_rapier2d_joint_set_motor(joint.world.handle, joint.handle, target_velocity, max_force)

# --- Utilities ---

fn physics_last_error() -> text:
    rt_rapier2d_get_last_error()

# ============================================================================
# Exports
# ============================================================================

export Vector2, Rotation2, Transform2
export PhysicsWorld, physics_create_world, physics_create_world_default
export physics_destroy_world, physics_step, physics_set_gravity, physics_world_stats
export BodyType, RigidBody
export physics_create_body, physics_create_dynamic_body, physics_create_static_body, physics_destroy_body
export physics_body_get_position, physics_body_set_position
export physics_body_get_velocity, physics_body_set_velocity
export physics_body_apply_force, physics_body_apply_impulse, physics_body_apply_torque
export physics_body_set_mass, physics_body_get_mass, physics_body_set_damping
export physics_body_is_sleeping, physics_body_wake_up
export ColliderShape, Collider, PhysicsMaterial
export physics_create_circle_collider, physics_create_box_collider
export physics_create_capsule_collider, physics_create_polygon_collider
export physics_destroy_collider, physics_collider_set_offset
export physics_collider_set_material, physics_collider_set_sensor
export Contact, ContactList
export physics_get_contacts, physics_contacts_count, physics_contacts_get, physics_destroy_contacts
export physics_intersection_test, RayCastResult, physics_cast_ray
export JointType, Joint
export physics_create_distance_joint, physics_create_revolute_joint
export physics_create_prismatic_joint, physics_create_fixed_joint
export physics_destroy_joint, physics_joint_set_limits, physics_joint_set_motor
export physics_last_error
