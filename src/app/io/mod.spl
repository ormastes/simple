# Pure Simple I/O Implementation
# All implementations in Simple - no Rust dependencies

# Platform detection - inlined to avoid bootstrap runtime limitations
# Use environment variable to detect Windows (OS or OSTYPE)
# Defaults to Unix if environment variable not set
fn is_windows_platform() -> bool:
    val os_env = rt_env_get("OS")
    if os_env == nil:
        false  # Default to Unix/Linux
    else:
        os_env.lower().contains("windows")

# Extern function declarations for runtime
extern fn rt_env_get(key: text) -> text
extern fn rt_cli_get_args() -> [str]
extern fn rt_exit(code: i64)
extern fn rt_process_run(cmd: text, args: [text]) -> (text, text, i64)
extern fn rt_cli_run_tests(args: [str], gc_log: bool, gc_off: bool) -> i64
extern fn rt_cli_handle_compile(args: [str]) -> i64
extern fn rt_compile_to_llvm_ir(source_file: text, target_triple: text, bare_metal: bool) -> (text, text, i64)

# Note: String ptr+len conversions are handled by Simple runtime internally
# No additional FFI functions needed - strings already work with existing rt_* functions

# --- System & Concurrency SFFI (Phase 4) ---
# Note: These use the exact runtime function names.
# Wrapper functions (getpid, hostname, etc.) call these externs.
extern fn rt_getpid() -> i64
extern fn rt_hostname() -> text
extern fn rt_time_now_unix_micros() -> i64
extern fn rt_env_set(key: text, value_str: text) -> bool
extern fn rt_file_hash_sha256(path: text) -> text
extern fn rt_dir_remove_all(path: text) -> bool
extern fn rt_thread_available_parallelism() -> i64

# --- Platform Detection ---
# Note: Implemented using shell commands instead of runtime FFI
# since pre-built runtime doesn't have rt_host_arch/rt_host_os

# --- Execution Manager (moved to app.io.jit) ---
# extern fn declarations now in jit.spl

# --- Debug/Hook Functions ---
# C++ backend available: libsimple_debug.so (SFFI three-tier pattern)
# Tier 1: .build/rust/ffi_debug/ (C++ bridge, 499K .so)
# Tier 2: src/ffi/debug.spl (extern fn declarations for compiled mode)
# Spec: examples/debug.wrapper_spec
# Interpreter mode: Simple stubs below return defaults
# Compiled mode: links against libsimple_debug.so via Tier 2 extern fn

fn rt_debug_set_active(active: bool):
    pass

fn rt_hook_enable_debugging(enable: bool):
    pass

fn rt_debug_add_breakpoint_at(bp_file: text, bp_line: i64) -> i64:
    0

fn rt_debug_remove_breakpoint_at(bp_file: text, bp_line: i64):
    pass

fn rt_debug_continue_exec():
    pass

fn rt_debug_pause_exec():
    pass

fn rt_debug_set_step_mode_val(mode: i64):
    pass

fn rt_debug_stack_trace_lines() -> [text]:
    []

fn rt_debug_local_vars() -> [text]:
    []

fn rt_debug_get_current_file() -> text:
    ""

fn rt_debug_get_current_line() -> i64:
    0

fn rt_debug_run_file_debug(path: text, debug_mode: bool) -> i64:
    0

# --- Rich Breakpoints (Phase 1.5) ---
fn rt_debug_add_breakpoint_rich(bp_file: text, bp_line: i64, condition: text, hit_condition: text, log_message: text, is_temporary: i64) -> i64:
    0

fn rt_debug_add_function_breakpoint(func_name: text, condition: text) -> i64:
    0

fn rt_debug_set_breakpoint_enabled(bp_id: i64, enabled: i64):
    pass

fn rt_debug_get_breakpoint_info(bp_id: i64) -> text:
    "{}"

fn rt_debug_list_breakpoints() -> text:
    "[]"

fn rt_debug_get_pending_condition() -> text:
    ""

fn rt_debug_report_condition_result(cond_result: i64):
    pass

# --- Frame Navigation ---
fn rt_debug_select_frame(index: i64) -> i64:
    0

fn rt_debug_get_selected_frame() -> i64:
    0

fn rt_debug_frame_locals(frame_index: i64) -> text:
    ""

# --- Source File Reading ---
fn rt_debug_get_source_lines(src_file: text, start_line: i64, line_count: i64) -> text:
    ""

# --- Watch Expressions ---
fn rt_debug_add_watch(expr: text) -> i64:
    0

fn rt_debug_remove_watch(expr: text) -> i64:
    0

fn rt_debug_list_watches() -> text:
    "[]"

# --- Variable Modification ---
fn rt_debug_set_variable(var_name: text, value_str: text, frame_index: i64) -> i64:
    0

# --- Expression Evaluation ---
# Stub for interpreter mode - the real evaluator is in debug_tools.spl
# which has access to imported rt_debug_local_vars etc.
fn rt_debug_eval_expression(expr: text, frame_index: i64) -> text:
    "{\"result\":\"(stub)\",\"type\":\"error\"}"

# --- Terminate ---
fn rt_debug_terminate():
    pass

# --- Fault Detection Functions ---
# Note: These are stubs - full fault detection not yet implemented in runtime
fn rt_fault_set_stack_overflow_detection(enabled: bool) -> bool:
    # Stub: Stack overflow detection not yet implemented
    true

fn rt_fault_set_max_recursion_depth(depth: i64) -> bool:
    # Stub: Recursion depth limits not yet implemented
    true

fn rt_fault_set_timeout(timeout_ms: i64) -> bool:
    # Stub: Timeout detection not yet implemented
    true

fn rt_fault_set_execution_limit(limit: i64) -> bool:
    # Stub: Execution limits not yet implemented
    true

# --- Atomic Operations ---
# Note: These are stubs - atomic operations not yet fully implemented
fn atomic_i64_new(value: i64) -> i64:
    # Stub: Returns regular i64 until atomics are implemented
    value

fn atomic_bool_new(value: bool) -> bool:
    # Stub: Returns regular bool until atomics are implemented
    value

# --- Hardware/Feature Detection ---
fn rt_vulkan_is_available() -> bool:
    # Stub: Vulkan detection not yet implemented
    false

fn upx_is_available() -> bool:
    # Stub: UPX compression tool detection not yet implemented
    # Check if upx command exists in PATH
    shell_bool("command -v upx >/dev/null 2>&1")

# --- String Helper Functions (Phase 1.1 - Pure Simple) ---
# These are Pure Simple implementations, no FFI needed

fn hex_to_char(hex_code: i64) -> text:
    """Convert hexadecimal code to character.

    Pure Simple implementation using string formatting.
    Example: hex_to_char(0x41) → "A"
    """
    # Use chr() builtin if available, otherwise format as char
    if hex_code >= 0 and hex_code <= 127:
        # ASCII range - safe to convert
        "{hex_code as char}"
    else:
        # Non-ASCII - return hex representation
        "\\x{hex_code:x}"

fn byte_to_char(byte: i64) -> text:
    """Convert byte value to character.

    Pure Simple implementation.
    Example: byte_to_char(65) → "A"
    """
    hex_to_char(byte)

fn char_code(c: text) -> i64:
    """Get numeric code of first character.

    Pure Simple implementation.
    Example: char_code("A") → 65
    """
    if c.len() == 0:
        0
    else:
        # Get first byte - Simple strings are UTF-8
        c[0].to_i64()

export rt_debug_set_active, rt_hook_enable_debugging
export rt_debug_add_breakpoint_at, rt_debug_remove_breakpoint_at
export rt_debug_continue_exec, rt_debug_pause_exec, rt_debug_set_step_mode_val
export rt_debug_stack_trace_lines, rt_debug_local_vars
export rt_debug_get_current_file, rt_debug_get_current_line, rt_debug_run_file_debug
export rt_debug_add_breakpoint_rich, rt_debug_add_function_breakpoint
export rt_debug_set_breakpoint_enabled, rt_debug_get_breakpoint_info
export rt_debug_list_breakpoints, rt_debug_get_pending_condition, rt_debug_report_condition_result
export rt_debug_select_frame, rt_debug_get_selected_frame, rt_debug_frame_locals
export rt_debug_get_source_lines
export rt_debug_add_watch, rt_debug_remove_watch, rt_debug_list_watches
export rt_debug_set_variable, rt_debug_eval_expression, rt_debug_terminate
export rt_fault_set_stack_overflow_detection, rt_fault_set_max_recursion_depth
export rt_fault_set_timeout, rt_fault_set_execution_limit
export atomic_i64_new, atomic_bool_new
export rt_vulkan_is_available, upx_is_available

# String helper exports (Phase 1.1)
export hex_to_char, byte_to_char, char_code

export file_exists, file_read, file_write, file_copy, file_delete, file_atomic_write
export file_append, file_modified_time, file_remove, file_hash_sha256, file_read_lines
export file_lock, file_unlock, file_size, file_size_raw
export rt_file_rename, rt_sleep_ms
export rt_timestamp_now
export dir_create, dir_create_all, dir_walk, dir_remove_all, is_dir
export dir_list, dir_remove
export cwd, home, env_get, env_set
export host_arch, host_os
export ProcessResult
export process_run, process_run_timeout, process_run_with_limits
export process_output, shell
export time_now_unix_micros, current_time_unix, current_time_ms
export timestamp_year, timestamp_month, timestamp_day
export timestamp_hour, timestamp_minute, timestamp_second
export getpid, hostname, cpu_count, path_basename
export get_args, exit, cli_get_args, cli_exit, cli_file_exists
export cli_replay, cli_constr, cli_check, cli_compile, cli_todo_scan, cli_gen_lean, cli_info
export cli_run_code, cli_run_file, cli_watch_file, cli_run_repl, cli_run_tests
export cli_run_lint, cli_run_fmt, cli_run_fix, cli_run_verify, cli_run_migrate
export cli_run_mcp, cli_run_diff, cli_run_query, cli_run_spec_coverage
export cli_run_feature_gen, cli_run_task_gen, cli_run_spec_gen, cli_run_sspec_docgen
export cli_run_todo_gen, cli_run_lex, cli_run_brief, cli_run_ffi_gen, cli_run_i18n
export cli_handle_web, cli_handle_diagram, cli_handle_run, cli_handle_compile, cli_handle_linkers
export cli_read_file, context_generate, context_stats, settlement_main
export fault_set_stack_overflow_detection, fault_set_max_recursion_depth
export fault_set_timeout, fault_set_execution_limit
export eprint
export math_exp, math_ln, math_sqrt, math_cos, math_sin, math_random
export math_log, math_log10, math_log2
export math_asin, math_acos, math_atan, math_atan2
export math_sinh, math_cosh, math_tanh
export math_ceil, math_floor, math_round
export thread_available_parallelism, thread_sleep_ms, thread_yield, thread_current_id
export atomic_i64_load, atomic_i64_store, atomic_i64_fetch_add, atomic_i64_compare_exchange

# ============================================================================
# Core I/O - Using runtime's built-in capabilities
# ============================================================================

# The runtime has these functions built-in. We use them by matching
# the function signatures that the runtime expects.

fn file_exists(path: text) -> bool:
    # Use shell test command
    shell_bool("test -f '{path}'")

fn file_size_raw(path: text) -> i64:
    # Use stat command to get file size
    shell_int("stat -c '%s' '{path}' 2>/dev/null", -1)

fn file_read(path: text) -> text:
    # Use cat to read file
    shell_output("cat '{path}' 2>/dev/null", "")

fn file_write(path: text, content: text) -> bool:
    # Write using heredoc for shell-safe writing (handles quotes, special chars)
    # Single-quoted delimiter prevents shell variable/command expansion in content
    val result = shell("cat > '{path}' << 'SIMPLE_WRITE_EOF'\n{content}\nSIMPLE_WRITE_EOF")
    result.exit_code == 0

fn file_copy(src: text, dst: text) -> bool:
    val result = shell("cp '{src}' '{dst}'")
    result.exit_code == 0

fn file_delete(path: text) -> bool:
    val result = shell("rm -f '{path}'")
    result.exit_code == 0

fn file_atomic_write(path: text, content: text) -> bool:
    # Write to temp file then move atomically
    val temp = path + ".tmp." + timestamp_str()
    if file_write(temp, content):
        val result = shell("mv '{temp}' '{path}'")
        result.exit_code == 0
    else:
        false

fn timestamp_str() -> text:
    # Generate timestamp for temp file names
    val micros = time_now_unix_micros()
    "{micros}"

fn file_append(path: text, content: text) -> bool:
    # Append using heredoc for shell-safe writing (handles quotes, special chars)
    val result = shell("cat >> '{path}' << 'SIMPLE_WRITE_EOF'\n{content}\nSIMPLE_WRITE_EOF")
    result.exit_code == 0

fn file_modified_time(path: text) -> i64:
    # Get file modification time as Unix timestamp using stat
    val result = shell("stat -c '%Y' '{path}' 2>/dev/null || stat -f '%m' '{path}' 2>/dev/null")
    if result.exit_code == 0:
        int(result.stdout.trim())
    else:
        0

fn file_remove(path: text) -> bool:
    file_delete(path)

fn file_hash_sha256(path: text) -> text:
    # File hash via SFFI
    rt_file_hash_sha256(path)

fn file_read_lines(path: text) -> [text]?:
    # Read file and split by newlines
    val content = file_read(path)
    if content.len() == 0:
        nil
    else:
        Some(content.split("\n"))

fn file_lock(path: text, timeout_secs: i64) -> i64:
    # Pure Simple file locking: create a .lock file
    val lock_path = path + ".lock"
    val lock_exists = file_exists(lock_path)
    if lock_exists:
        -1  # Already locked
    else:
        # Create lock file with current PID
        val pid = getpid()
        file_write(lock_path, "{pid}")
        1  # Lock handle

fn file_unlock(handle: i64) -> bool:
    # Would need to track lock files
    true

fn file_size(path: text) -> i64:
    file_size_raw(path)

# ============================================================================
# Directory Operations - Pure Simple
# ============================================================================

fn dir_create(path: text, recursive: bool) -> bool:
    # Create directory using shell mkdir
    if recursive:
        val result = shell("mkdir -p '{path}'")
        result.exit_code == 0
    else:
        val result = shell("mkdir '{path}'")
        result.exit_code == 0

fn dir_create_all(path: text) -> bool:
    dir_create(path, true)

fn dir_walk(path: text) -> [text]:
    # Recursively list all files under path using find command
    val result = shell("find '{path}' -type f 2>/dev/null | sort")
    if result.exit_code == 0:
        var trimmed = result.stdout.trim()
        if trimmed != "":
            return trimmed.split("\n")
    []

fn dir_remove_all(path: text) -> i32:
    # Recursive directory removal via SFFI
    if rt_dir_remove_all(path):
        0
    else:
        -1

fn is_dir(path: text) -> bool:
    # Check if path is a directory using test -d
    shell_bool("test -d '{path}'")

fn dir_list(path: text) -> [text]:
    # List files in directory using ls
    shell_lines("ls -1 '{path}' 2>/dev/null")

fn dir_remove(path: text, recursive: bool) -> bool:
    if recursive:
        dir_remove_all(path) == 0
    else:
        false

# ============================================================================
# Environment - Pure Simple
# ============================================================================

fn cwd() -> text:
    # Current working directory using pwd command
    val result = shell("pwd")
    if result.exit_code == 0:
        result.stdout.trim()
    else:
        "."

fn home() -> text:
    # Home directory via runtime
    rt_env_get("HOME")

fn env_get(key: text) -> text:
    # Environment variables - delegate to runtime
    rt_env_get(key)

fn env_set(key: text, value: text) -> bool:
    # Set environment variable via SFFI
    rt_env_set(key, value)

fn host_arch() -> text:
    """Get the host architecture (e.g., x86_64, aarch64, arm, i686).

    Uses `uname -m` on Unix/Linux/macOS to detect architecture.
    Returns normalized architecture names compatible with target triples.
    """
    if is_windows_platform():
        # Windows: Check PROCESSOR_ARCHITECTURE environment variable
        val proc_arch = env_get("PROCESSOR_ARCHITECTURE")
        if proc_arch.?:
            match proc_arch.lower():
                case "amd64" | "x64": "x86_64"
                case "x86": "i686"
                case "arm64": "aarch64"
                case "arm": "arm"
                case _: "x86_64"  # Default for Windows
        else:
            "x86_64"  # Default
    else:
        # Unix/Linux/macOS: Use uname -m
        val arch = shell_output_trimmed("uname -m", "x86_64")
        # Normalize architecture names
        match arch:
            case "x86_64" | "amd64": "x86_64"
            case "i686" | "i386" | "i586": "i686"
            case "aarch64" | "arm64": "aarch64"
            case "armv7l" | "armv7" | "arm": "armv7"
            case "riscv64": "riscv64"
            case "riscv32": "riscv32"
            case _: arch  # Return as-is if unknown

fn host_os() -> text:
    """Get the host operating system (e.g., linux, windows, macos, freebsd).

    Uses `uname -s` on Unix/Linux/macOS to detect OS.
    Returns normalized OS names compatible with target triples.
    """
    if is_windows_platform():
        "windows"
    else:
        # Unix/Linux/macOS: Use uname -s
        val os = shell_output_trimmed("uname -s", "linux")
        # Normalize OS names
        match os:
            case "Linux": "linux"
            case "Darwin": "macos"
            case "FreeBSD": "freebsd"
            case "OpenBSD": "openbsd"
            case "NetBSD": "netbsd"
            case _: os.lower()  # Return lowercase if unknown

# ============================================================================
# Process Execution - Pure Simple
# ============================================================================

struct ProcessResult:
    stdout: text
    stderr: text
    exit_code: i64

fn process_run(cmd: text, args: [text]) -> (text, text, i64):
    # Platform-specific command resolution
    # When running under bootstrap runtime, resolve_command is not available,
    # so we detect the platform and adjust the command if needed.
    var resolved_cmd = cmd
    if is_windows_platform():
        # On Windows, try appending .exe if not already present
        if not cmd.ends_with(".exe") and not cmd.ends_with(".cmd") and not cmd.ends_with(".bat"):
            val check = rt_process_run("where", [cmd + ".exe"])
            if check.2 == 0:
                resolved_cmd = cmd + ".exe"
    else:
        # On Unix, try resolving via 'which' if command doesn't contain a path separator
        if not cmd.contains("/"):
            val check = rt_process_run("which", [cmd])
            if check.2 == 0 and check.0.trim() != "":
                resolved_cmd = check.0.trim()

    # Delegate to runtime's process execution
    rt_process_run(resolved_cmd, args)

fn process_run_timeout(cmd: text, args: [text], timeout_ms: i64) -> (text, text, i32):
    # Convert timeout from milliseconds to seconds (minimum 1 second)
    val timeout_secs = if timeout_ms <= 0:
        120  # Default 2 minutes
    else:
        val secs = timeout_ms / 1000
        if secs < 1: 1 else: secs

    # Use Unix 'timeout' command to enforce timeout
    # The timeout command will send SIGTERM, then SIGKILL if needed
    if is_windows_platform():
        # Windows doesn't have a native timeout command like Unix.
        # PowerShell-based timeout is not reliably available in all environments.
        eprint("[WARNING] Windows timeout not implemented; running without timeout enforcement")
        val (out, err, code) = process_run(cmd, args)
        (out, err, code)
    else:
        # Unix/Linux: use timeout command
        # Build args array: timeout [seconds] cmd [args...]
        var timeout_args: [text] = ["{timeout_secs}", cmd]
        timeout_args.merge(args)

        val (out, err, code) = rt_process_run("timeout", timeout_args)

        # timeout command returns 124 if process was killed by timeout
        if code == 124:
            (out, err + "\n[TIMEOUT: Process killed after {timeout_secs}s]", -1)
        else:
            (out, err, code)

fn process_run_with_limits(cmd: text, args: [text], timeout_ms: i64, memory_bytes: i64, cpu_seconds: i64, max_fds: i64, max_procs: i64) -> (text, text, i32):
    # Resource limits require OS-level support (setrlimit/ulimit) via FFI.
    # Log warnings for any non-default limits that are requested but not enforced.
    if memory_bytes > 0:
        eprint("[WARNING] memory_bytes limit ({memory_bytes} bytes) not enforced; requires FFI setrlimit support")
    if cpu_seconds > 0:
        eprint("[WARNING] cpu_seconds limit ({cpu_seconds}s) not enforced; requires FFI setrlimit support")
    if max_fds > 0:
        eprint("[WARNING] max_fds limit ({max_fds}) not enforced; requires FFI setrlimit support")
    if max_procs > 0:
        eprint("[WARNING] max_procs limit ({max_procs}) not enforced; requires FFI setrlimit support")
    # Timeout is the only limit currently enforced
    process_run_timeout(cmd, args, timeout_ms)

fn process_output(cmd: text, args: [text]) -> text:
    val (stdout, stderr, code) = process_run(cmd, args)
    stdout

fn shell(command: text) -> ProcessResult:
    # Execute shell command using platform-specific shell
    val (shell_path, shell_args) = if is_windows_platform():
        # Windows: use cmd.exe /c
        ("cmd.exe", ["/c", command])
    else:
        # Unix: use /bin/sh -c
        ("/bin/sh", ["-c", command])

    val (stdout, stderr, code) = rt_process_run(shell_path, shell_args)
    ProcessResult(stdout: stdout, stderr: stderr, exit_code: code)

# Shell helper functions to reduce duplication

fn shell_bool(command: text) -> bool:
    """Run shell command and return true if exit_code == 0."""
    val result = shell(command)
    result.exit_code == 0

fn shell_output(command: text, default: text) -> text:
    """Run shell command and return stdout if success, else default."""
    val result = shell(command)
    if result.exit_code == 0:
        result.stdout
    else:
        default

fn shell_output_trimmed(command: text, default: text) -> text:
    """Run shell command and return trimmed stdout if success, else default."""
    val result = shell(command)
    if result.exit_code == 0:
        result.stdout.trim()
    else:
        default

fn shell_lines(command: text) -> [text]:
    """Run shell command and return stdout split by newlines."""
    val result = shell(command)
    if result.exit_code == 0 and result.stdout.?:
        result.stdout.trim().split("\n")
    else:
        []

fn shell_int(command: text, default: i64) -> i64:
    """Run shell command and parse stdout as integer."""
    val result = shell(command)
    if result.exit_code == 0:
        val trimmed = result.stdout.trim()
        if trimmed.len() > 0:
            int(trimmed)
        else:
            default
    else:
        default

export shell_bool, shell_output, shell_output_trimmed, shell_lines, shell_int

# ============================================================================
# Memory-Mapped File I/O (SFFI wrappers)
# ============================================================================

extern fn rt_file_read_text(path: text) -> text
extern fn rt_file_read_bytes(path: text) -> [i64]
extern fn rt_file_mmap_read_text(path: text) -> text
extern fn rt_file_mmap_read_bytes(path: text) -> [i64]

fn file_read_text(path: text) -> text:
    rt_file_read_text(path)

fn file_read_bytes(path: text) -> [i64]:
    rt_file_read_bytes(path)

fn file_mmap_read_text(path: text) -> text:
    rt_file_mmap_read_text(path)

fn file_mmap_read_bytes(path: text) -> [i64]:
    rt_file_mmap_read_bytes(path)

export file_read_text, file_read_bytes, file_mmap_read_text, file_mmap_read_bytes

# ============================================================================
# Random Number Generation (SFFI wrappers)
# ============================================================================

extern fn rt_random_uniform(min: f64, max: f64) -> f64
extern fn rt_random_randint(min: i64, max: i64) -> i64

fn random_uniform(min: f64, max: f64) -> f64:
    rt_random_uniform(min, max)

fn random_randint(min: i64, max: i64) -> i64:
    rt_random_randint(min, max)

export random_uniform, random_randint

# ============================================================================
# Environment Variables (additional)
# ============================================================================

extern fn rt_env_vars() -> Dict<text, text>

fn env_vars() -> Dict<text, text>:
    rt_env_vars()

export env_vars

# ============================================================================
# Logging (SFFI wrappers)
# ============================================================================

extern fn rt_log_emit(level: i64, scope_ptr: i64, scope_len: i64, msg_ptr: i64, msg_len: i64)
extern fn rt_log_get_global_level() -> i64
extern fn rt_log_set_global_level(level: i64)
extern fn rt_log_get_scope_level(scope_ptr: i64, scope_len: i64) -> i64
extern fn rt_log_set_scope_level(scope_ptr: i64, scope_len: i64, level: i64)
extern fn rt_log_is_enabled(level: i64, scope_ptr: i64, scope_len: i64) -> i64
extern fn rt_log_clear_scope_levels()

fn log_emit(level: i64, scope_ptr: i64, scope_len: i64, msg_ptr: i64, msg_len: i64):
    rt_log_emit(level, scope_ptr, scope_len, msg_ptr, msg_len)

fn log_get_global_level() -> i64:
    rt_log_get_global_level()

fn log_set_global_level(level: i64):
    rt_log_set_global_level(level)

fn log_get_scope_level(scope_ptr: i64, scope_len: i64) -> i64:
    rt_log_get_scope_level(scope_ptr, scope_len)

fn log_set_scope_level(scope_ptr: i64, scope_len: i64, level: i64):
    rt_log_set_scope_level(scope_ptr, scope_len, level)

fn log_is_enabled(level: i64, scope_ptr: i64, scope_len: i64) -> i64:
    rt_log_is_enabled(level, scope_ptr, scope_len)

fn log_clear_scope_levels():
    rt_log_clear_scope_levels()

export log_emit, log_get_global_level, log_set_global_level
export log_get_scope_level, log_set_scope_level
export log_is_enabled, log_clear_scope_levels

# ============================================================================
# Thread Sleep alias (for modules expecting millis-based sleep)
# ============================================================================

fn thread_sleep(millis: i64):
    thread_sleep_ms(millis)

export thread_sleep

# ============================================================================
# Time Functions - Pure Simple
# ============================================================================

fn time_now_unix_micros() -> i64:
    # Current time in microseconds since epoch via SFFI
    rt_time_now_unix_micros()

fn current_time_unix() -> i64:
    time_now_unix_micros() / 1_000_000

fn current_time_ms() -> i64:
    time_now_unix_micros() / 1_000

fn timestamp_year(micros: i64) -> i32:
    # Convert microseconds to year
    # Simplified: assume 1970 + (micros / microseconds_per_year)
    val seconds = micros / 1_000_000
    val years = seconds / (365 * 24 * 60 * 60)
    (1970 + years).to_i32()

fn timestamp_month(micros: i64) -> i32:
    # Simplified month calculation
    1

fn timestamp_day(micros: i64) -> i32:
    # Simplified day calculation
    1

fn timestamp_hour(micros: i64) -> i32:
    val seconds = micros / 1_000_000
    val hours = (seconds / 3600) % 24
    hours.to_i32()

fn timestamp_minute(micros: i64) -> i32:
    val seconds = micros / 1_000_000
    val minutes = (seconds / 60) % 60
    minutes.to_i32()

fn timestamp_second(micros: i64) -> i32:
    val seconds = micros / 1_000_000
    val secs = seconds % 60
    secs.to_i32()

# ============================================================================
# System Information - Pure Simple
# ============================================================================

fn getpid() -> i64:
    # Process ID via SFFI
    rt_getpid()

fn hostname() -> text:
    # Hostname via SFFI
    rt_hostname()

fn cpu_count() -> i64:
    # CPU count via SFFI (rt_thread_available_parallelism returns logical CPUs)
    rt_thread_available_parallelism()

fn path_basename(path: text) -> text:
    # Pure Simple path manipulation
    val parts = path.split("/")
    if parts.len() > 0:
        parts[parts.len() - 1]
    else:
        path

# ============================================================================
# Additional System Functions
# ============================================================================

fn rt_file_rename(src: text, dst: text) -> bool:
    # Atomic file rename using mv
    val result = shell("mv '{src}' '{dst}'")
    result.exit_code == 0

fn rt_sleep_ms(milliseconds: i64):
    # Sleep for specified milliseconds
    val seconds = milliseconds / 1000
    val remainder = milliseconds % 1000
    if seconds > 0:
        shell("sleep {seconds}")
    if remainder > 0:
        shell("sleep 0.{remainder}")

# rt_getpid() is now declared as extern fn at the top of this file

fn rt_timestamp_now() -> i64:
    # Return current timestamp in microseconds
    time_now_unix_micros()

# ============================================================================
# Thread & Concurrency - Imported from app.io.thread
# ============================================================================
use app.io.thread.{thread_available_parallelism, thread_sleep_ms, thread_yield, thread_current_id}
use app.io.thread.{atomic_i64_load, atomic_i64_store, atomic_i64_fetch_add, atomic_i64_compare_exchange}

# ============================================================================
# CLI Functions - Pure Simple Implementations
# ============================================================================

fn get_args() -> [String]:
    # Command line arguments - delegate to runtime
    rt_cli_get_args()

fn exit(code: i64):
    # Exit the program with given code - delegate to runtime
    rt_exit(code)

fn cli_get_args() -> [str]:
    # CLI arguments - delegate to runtime
    rt_cli_get_args()

fn cli_exit(code: i64):
    rt_exit(code)

fn cli_file_exists(path: str) -> bool:
    file_exists(path)

fn cli_read_file(path: str) -> str:
    file_read(path)

# ============================================================================
# CLI Command Handlers - To be implemented in Simple
# ============================================================================

fn cli_run_code(code: str, gc_log: bool, gc_off: bool) -> i64:
    print "=== Simple Code Execution ==="
    print "Code: {code}"
    print "Note: Interpreter would evaluate this code"
    1

fn cli_run_file(path: str, args: [str], gc_log: bool, gc_off: bool) -> i64:
    # Run a Simple file using the bootstrap runtime
    var run_args: [text] = [path]
    for arg in args:
        run_args.push(arg)
    val result = process_run("bin/bootstrap/simple", run_args)
    val stdout = result[0]
    val exit_code = result[2]
    if stdout.len() > 0:
        print stdout
    exit_code

fn cli_watch_file(path: str) -> i64:
    print "Watch mode not yet implemented in pure Simple"
    1

fn cli_run_repl(gc_log: bool, gc_off: bool) -> i64:
    print "=== Simple REPL ==="
    print "REPL not yet implemented in pure Simple"
    print ""
    print "For now, use: ./bin/bootstrap/simple yourfile.spl"
    1

# Helper for unimplemented CLI commands
fn cli_not_implemented(tool_name: text) -> i64:
    print "{tool_name} not yet implemented in pure Simple"
    1

fn cli_run_tests(args: [str], gc_log: bool, gc_off: bool) -> i64:
    rt_cli_run_tests(args, gc_log, gc_off)

fn cli_run_lint(args: [str]) -> i64:
    cli_not_implemented("Linter")

fn cli_run_fmt(args: [str]) -> i64:
    cli_not_implemented("Formatter")

fn cli_run_fix(args: [str]) -> i64:
    cli_not_implemented("Fix tool")

fn cli_run_verify(args: [str], gc_log: bool, gc_off: bool) -> i64:
    cli_not_implemented("Verifier")

fn cli_run_migrate(args: [str]) -> i64:
    cli_not_implemented("Migration tool")

fn cli_run_mcp(args: [str]) -> i64:
    # Run MCP server using the dedicated MCP main.spl
    # args[0] is "mcp", so we skip it and pass args[1:]
    var cmd = "./bin/bootstrap/simple src/app/mcp/main.spl"
    var i = 1
    while i < args.len():
        cmd = cmd + " " + args[i]
        i = i + 1

    val result = shell(cmd)
    # Print the output from MCP server
    if result.stdout.len() > 0:
        print(result.stdout)
    if result.stderr.len() > 0:
        eprint(result.stderr)
    result.exit_code

fn cli_run_diff(args: [str]) -> i64:
    cli_not_implemented("Diff tool")

fn cli_constr(args: [str]) -> i64:
    cli_not_implemented("Constraint checker")

fn cli_run_query(args: [str]) -> i64:
    cli_not_implemented("Query tool")

fn cli_run_spec_coverage(args: [str]) -> i64:
    cli_not_implemented("Spec coverage")

fn cli_gen_lean(args: [str]) -> i64:
    cli_not_implemented("Lean generator")

fn cli_run_feature_gen(args: [str]) -> i64:
    cli_not_implemented("Feature generator")

fn cli_run_task_gen(args: [str]) -> i64:
    cli_not_implemented("Task generator")

fn cli_run_spec_gen(args: [str]) -> i64:
    cli_not_implemented("Spec generator")

fn cli_run_sspec_docgen(args: [str]) -> i64:
    cli_not_implemented("SSpec doc generator")

fn cli_run_todo_gen(args: [str]) -> i64:
    # todo-scan now generates both db and md, so just run scan
    cli_run_file("src/app/todo_scan/main.spl", args, false, false)

fn cli_todo_scan(args: [str]) -> i64:
    cli_run_file("src/app/todo_scan/main.spl", args, false, false)

fn cli_run_lex(args: [str]) -> i64:
    cli_not_implemented("Lexer")

fn cli_run_brief(args: [str]) -> i64:
    cli_not_implemented("Brief tool")

fn cli_run_ffi_gen(args: [str]) -> i64:
    cli_not_implemented("FFI generator")

fn cli_run_i18n(args: [str]) -> i64:
    cli_not_implemented("i18n tool")

fn cli_handle_web(args: [str]) -> i64:
    cli_not_implemented("Web handler")

fn cli_handle_diagram(args: [str]) -> i64:
    cli_not_implemented("Diagram generator")

fn cli_handle_run(args: [str], gc_log: bool, gc_off: bool) -> i64:
    if args.len() > 0:
        cli_run_file(args[0], args[1:], gc_log, gc_off)
    else:
        print "No file specified"
        1

fn cli_handle_compile(args: [str]) -> i64:
    rt_cli_handle_compile(args)

fn cli_handle_linkers() -> i64:
    cli_not_implemented("Linker information")

fn cli_replay(args: [str]) -> i64:
    cli_not_implemented("Replay tool")

fn cli_check(args: [str]) -> i64:
    cli_not_implemented("Type checker")

fn cli_compile(args: [str]) -> i64:
    # Parse: simple compile [options] <source.spl>
    # Options:
    #   --target=<target>        Target architecture (e.g., baremetal-x86)
    #   --emit=<format>          Output format: llvm-ir, object, elf (default: elf)
    #   --format=<fmt>           Output format: native, smf, self-contained, both
    #   --backend=<backend>      Compilation backend: auto, cranelift, llvm (default: auto)
    #   -o <output>              Output file path
    #   --release                Release build (enables optimization, prefers LLVM)
    #   --help                   Show help

    # Default values
    var source_file: text = ""
    var output_file: text = ""
    var target: text = ""
    var emit: text = "elf"
    var output_format: text = ""
    var backend: text = "auto"
    var verbose: bool = false
    var release: bool = false

    # Parse arguments (skip first arg if it's "compile")
    var i = 0
    if args.len() > 0 and args[0] == "compile":
        i = 1

    while i < args.len():
        val arg = args[i]

        if arg == "--help" or arg == "-h":
            print "Simple Compiler"
            print ""
            print "Usage: simple compile [options] <source.spl>"
            print ""
            print "Options:"
            print "  --target=<target>     Target: baremetal-x86, baremetal-arm, etc."
            print "  --emit=<format>       Output: llvm-ir, object, elf (default: elf)"
            print "  --format=<fmt>        Output: native, smf, self-contained (sc), both"
            print "  --native              Compile to native binary via C codegen + gcc"
            print "  --backend=<backend>   Backend: auto, cranelift, llvm (default: auto)"
            print "  --release             Release build (optimized, prefers LLVM)"
            print "  -o <output>           Output file path"
            print "  --verbose, -v         Verbose output"
            print "  --help, -h            Show this help"
            print ""
            print "Output Formats (--format):"
            print "  native                Native executable (default)"
            print "  smf                   SMF module file"
            print "  self-contained, sc    Self-contained binary (runtime + SMF in one file)"
            print "  both                  Both native executable and SMF module"
            print ""
            print "Examples:"
            print "  simple compile hello.spl"
            print "  simple compile hello.spl --backend=llvm"
            print "  simple compile hello.spl --release -o hello.smf"
            print "  simple compile hello.spl --format=self-contained -o hello"
            print "  simple compile --native -o hello hello.spl"
            print "  simple compile --target=baremetal-x86 --emit=llvm-ir kernel.spl"
            return 0
        elif arg.starts_with("--target="):
            target = arg.substring(9)
        elif arg.starts_with("--emit="):
            emit = arg.substring(7)
        elif arg.starts_with("--format="):
            output_format = arg.substring(9)
        elif arg.starts_with("--backend="):
            backend = arg.substring(10)
        elif arg == "--release":
            release = true
        elif arg == "--native":
            emit = "native"
        elif arg == "-o":
            i = i + 1
            if i < args.len():
                output_file = args[i]
            else:
                eprint("Error: -o requires an argument")
                return 1
        elif arg == "--verbose" or arg == "-v":
            verbose = true
        elif not arg.starts_with("-"):
            # Positional argument - source file
            if source_file == "":
                source_file = arg
            else:
                eprint("Error: Multiple source files not supported")
                return 1
        else:
            eprint("Error: Unknown option: {arg}")
            return 1

        i = i + 1

    # Validate required arguments
    if source_file == "":
        eprint("Error: No source file specified")
        eprint("Usage: simple compile [options] <source.spl>")
        return 1

    # Check if source file exists
    if not file_exists(source_file):
        eprint("Error: Source file not found: {source_file}")
        return 1

    # Handle native compilation (Simple -> C -> gcc -> binary)
    if emit == "native":
        var out = output_file
        if out == "":
            out = source_file.replace(".spl", "")
        # Shell out to native compile module to avoid circular import
        var native_cmd = "bin/bootstrap/simple src/app/compile/native.spl '{source_file}' '{out}'"
        if verbose:
            native_cmd = "bin/bootstrap/simple src/app/compile/native.spl '{source_file}' '{out}' --verbose"
        val native_result = shell(native_cmd)
        if native_result.stdout != "":
            print native_result.stdout
        if native_result.stderr != "" and native_result.exit_code != 0:
            eprint(native_result.stderr)
        return native_result.exit_code

    # Handle bare-metal compilation
    if target.starts_with("baremetal-"):
        return compile_baremetal(source_file, target, emit, output_file, verbose)

    # If --format is specified, inject it into args for the bootstrap compiler
    # The bootstrap compiler's rt_cli_handle_compile will pass --format through
    # to the CompilerDriver which uses OutputFormat__from_text()
    var compile_args = args
    if output_format != "":
        # Validate format value
        if output_format != "native" and output_format != "smf" and output_format != "self-contained" and output_format != "sc" and output_format != "both":
            eprint("Error: Unknown format: {output_format}")
            eprint("Valid formats: native, smf, self-contained (sc), both")
            return 1

    # Use bootstrap binary's native compile path via FFI.
    # rt_cli_handle_compile() calls directly into the bootstrap binary's Cranelift compiler,
    # avoiding shell-out which would cause infinite recursion (bootstrap binary interprets
    # this same source file, which would shell out again).
    #
    # NOTE: When compiler modules can run in interpreter mode, switch to pure-Simple LLVM path:
    #   CompilerDriver.compile() -> MirToLlvm -> shell("llc") -> SMF
    # Currently blocked on interpreter support for compiler module imports.
    eprint("[NOTE] Using bootstrap Cranelift path; pure-Simple LLVM path not yet available in interpreter mode")

    # Check if llc is available for LLVM backend
    if backend == "llvm":
        val llc_check = shell("command -v llc >/dev/null 2>&1")
        if llc_check.exit_code != 0:
            eprint("Error: llc not found. Install LLVM: apt install llvm (Ubuntu) or brew install llvm (macOS)")
            return 1

    rt_cli_handle_compile(compile_args)

# Bare-metal compilation using BaremetalBuilder
fn compile_baremetal(source_file: text, target: text, emit: text, output_file: text, verbose: bool) -> i64:
    # Import would be: use app.build.baremetal (BaremetalConfig, BaremetalBuilder)
    # But for now, we'll shell out to the build system

    if verbose:
        print "Compiling {source_file} for {target}"
        print "  Emit: {emit}"
        if output_file != "":
            print "  Output: {output_file}"

    # For now, call the build system via shell
    # NOTE: Import and use BaremetalBuilder directly once module imports work.
    # Currently blocked on cross-module import support in the interpreter.
    eprint("[NOTE] Using shell-based baremetal build; direct BaremetalBuilder import not yet available")

    # Determine architecture from target
    val arch = if target == "baremetal-x86":
        "i686"
    elif target == "baremetal-x86_64":
        "x86_64"
    elif target == "baremetal-arm":
        "armv7"
    elif target == "baremetal-aarch64":
        "aarch64"
    elif target == "baremetal-riscv32":
        "riscv32"
    elif target == "baremetal-riscv64":
        "riscv64"
    else:
        eprint("Error: Unknown bare-metal target: {target}")
        eprint("Supported: baremetal-x86, baremetal-x86_64, baremetal-arm,")
        eprint("           baremetal-aarch64, baremetal-riscv32, baremetal-riscv64")
        return 1

    # Create output directory
    if not dir_create("build/baremetal", true):
        eprint("Error: Failed to create build/baremetal directory")
        return 1

    # Determine target triple from architecture
    val target_triple = arch + "-unknown-none"

    if verbose:
        print "Compiling Simple → LLVM IR (pure Simple compiler)..."
        print "  Target triple: {target_triple}"

    # Step 1: Compile Simple source to LLVM IR using pure Simple compiler
    # NOTE: Import and use compiler.driver and compiler.backend.llvm_backend
    # once cross-module imports are supported. Requires:
    #   1. Import compiler.driver (CompilerDriver, compile_file)
    #   2. Import compiler.backend.llvm_backend (LlvmBackend, MirToLlvm)
    #   3. Compile source -> MIR -> LLVM IR via MirToLlvm.translate_module()
    # Currently blocked on interpreter module import support.
    eprint("[NOTE] Pure Simple LLVM compilation not yet wired up; compiler.driver and compiler.backend.llvm_backend imports pending")

    val llvm_ir = ""
    val error_msg = "Pure Simple compilation not yet wired up. To complete this, we need to: 1. Import compiler.driver (CompilerDriver, compile_file) 2. Import compiler.backend.llvm_backend (LlvmBackend, MirToLlvm) 3. Compile source to MIR using CompilerDriver 4. Translate MIR to LLVM IR using MirToLlvm.translate_module() 5. Return the textual LLVM IR. The LLVM backend already generates textual IR in pure Simple! See: src/compiler/backend/llvm_backend.spl line 790. This is ~20-30 lines of Simple code to wire up. No Rust FFI needed - it's pure Simple!"

    if llvm_ir == "":
        eprint("Error: Compilation not yet wired up")
        eprint(error_msg)
        return 1

    # Write LLVM IR to file
    val base_name = source_file.replace(".spl", "").replace("/", "_")
    val ir_file = "build/baremetal/{base_name}.ll"
    if not file_write(ir_file, llvm_ir):
        eprint("Error: Failed to write LLVM IR to {ir_file}")
        return 1

    if verbose:
        print "  Generated: {ir_file}"

    # If only emitting LLVM IR, stop here
    if emit == "llvm-ir":
        if output_file != "":
            if not file_copy(ir_file, output_file):
                eprint("Error: Failed to copy to {output_file}")
                return 1
            print "Output: {output_file}"
        else:
            print "Output: {ir_file}"
        return 0

    # Step 2: Compile LLVM IR to object file using llc
    if verbose:
        print "Compiling LLVM IR → Object file..."

    val obj_file = "build/baremetal/{base_name}.o"
    val (llc_out, llc_err, llc_exit) = process_run("llc", [
        "--filetype=obj",
        "--relocation-model=static",
        ir_file,
        "-o", obj_file
    ])

    if llc_exit != 0:
        eprint("Error: llc compilation failed")
        eprint(llc_err)
        return 1

    if verbose:
        print "  Generated: {obj_file}"

    # If only emitting object file, stop here
    if emit == "object":
        if output_file != "":
            if not file_copy(obj_file, output_file):
                eprint("Error: Failed to copy to {output_file}")
                return 1
            print "Output: {output_file}"
        else:
            print "Output: {obj_file}"
        return 0

    # Step 3: Link to ELF binary using ld
    if verbose:
        print "Linking Object → ELF binary..."

    val elf_file = if output_file != "":
        output_file
    else:
        "build/baremetal/kernel.elf"

    # Generate linker script if needed
    # For now, assume linker script exists at build/baremetal/linker.ld
    val linker_script = "build/baremetal/linker.ld"

    val (ld_out, ld_err, ld_exit) = process_run("ld", [
        "-T", linker_script,
        "-nostdlib",
        "--entry=_start",
        obj_file,
        "-o", elf_file
    ])

    if ld_exit != 0:
        eprint("Error: Linking failed")
        eprint(ld_err)
        eprint("")
        eprint("Note: Linker script should be at: {linker_script}")
        eprint("Generate it using: simple linker-gen boards/qemu_x86.sdn")
        return 1

    if verbose:
        print "  Generated: {elf_file}"

    print "Success: {elf_file}"
    return 0

fn cli_info(args: [str]) -> i64:
    cli_not_implemented("Info tool")

# ============================================================================
# Advanced Features - Pure Simple
# ============================================================================

fn context_generate(path: str, target: str, format: str) -> str:
    ""

fn context_stats(path: str, target: str) -> str:
    ""

fn settlement_main() -> i64:
    0

fn fault_set_stack_overflow_detection(enabled: bool):
    ()

fn fault_set_max_recursion_depth(depth: i64):
    ()

fn fault_set_timeout(secs: i64):
    ()

fn fault_set_execution_limit(limit: i64):
    ()

fn eprint(msg: text):
    print "[STDERR] {msg}"

# ============================================================================
# Math Functions - Using shell bc for computation
# ============================================================================

# Helper for BC shell calculations
fn shell_bc_calc(bc_expr: text, default: f64) -> f64:
    val result = shell("echo '{bc_expr}' | bc -l")
    if result.exit_code == 0:
        result.stdout.trim().to_float_or(default)
    else:
        default

fn math_exp(x: f64) -> f64:
    """Exponential function: e^x"""
    shell_bc_calc("e({x})", 0.0)

fn math_ln(x: f64) -> f64:
    """Natural logarithm: ln(x)"""
    if x <= 0.0:
        return -999999.0  # Negative infinity approximation
    shell_bc_calc("l({x})", 0.0)

fn math_sqrt(x: f64) -> f64:
    """Square root: sqrt(x)"""
    if x < 0.0:
        return 0.0  # NaN approximation
    shell_bc_calc("sqrt({x})", 0.0)

fn math_cos(x: f64) -> f64:
    """Cosine: cos(x)"""
    shell_bc_calc("c({x})", 0.0)

fn math_sin(x: f64) -> f64:
    """Sine: sin(x)"""
    shell_bc_calc("s({x})", 0.0)

fn math_random() -> f64:
    """Random number in [0, 1)"""
    # Use /dev/urandom for randomness
    val result = shell("od -An -N4 -tu4 /dev/urandom | awk '{print $1}'")
    if result.exit_code == 0:
        val trimmed_rand = result.stdout.trim()
        var rand_int = 0
        if trimmed_rand.len() > 0:
            rand_int = int(trimmed_rand)
        # Normalize to [0, 1)
        rand_int / 4294967296.0  # 2^32
    else:
        0.5  # Fallback

# ============================================================================
# String Hashing (SFFI)
# ============================================================================

# Note: rt_text_hash not yet available in runtime. When added, uncomment:
# extern fn rt_text_hash(s: text) -> i64
# For now, use std.string.text_hash() for proper FNV-1a hash with ASCII lookup.
fn text_hash_native(s: text) -> i64:
    """Stub: Use std.string.text_hash() for proper FNV-1a hash.
    This stub provides a simple position-based hash for internal use."""
    var hash = 2166136261
    var i = 0
    while i < s.len():
        hash = (hash xor (i + 1)) * 16777619
        i = i + 1
    hash = hash xor s.len()
    hash

# ============================================================================
# Advanced Math Functions - Imported from app.io.math
# ============================================================================
use app.io.math.{math_log, math_log10, math_log2}
use app.io.math.{math_asin, math_acos, math_atan, math_atan2}
use app.io.math.{math_sinh, math_cosh, math_tanh}
use app.io.math.{math_ceil, math_floor, math_round}

# ============================================================================
# JIT Backend Control - Imported from app.io.jit
# ============================================================================
use app.io.jit.{set_jit_backend, get_jit_backend}
use app.io.jit.{exec_manager_create, exec_manager_compile, exec_manager_execute}
use app.io.jit.{exec_manager_has_function, exec_manager_backend_name, exec_manager_cleanup}
