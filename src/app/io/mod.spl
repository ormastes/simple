# Pure Simple I/O Implementation
# All implementations in Simple - no Rust dependencies

# Platform detection - inlined to avoid bootstrap runtime limitations
# Use environment variable to detect Windows (OS or OSTYPE)
# Defaults to Unix if environment variable not set
fn is_windows_platform() -> bool:
    val os_env = rt_env_get("OS")
    if os_env == nil:
        false  # Default to Unix/Linux
    else:
        os_env.lower().contains("windows")

# Extern function declarations for runtime
extern fn rt_env_get(key: text) -> text
extern fn rt_cli_get_args() -> [str]
extern fn rt_exit(code: i64)
extern fn rt_process_run(cmd: text, args: [text]) -> (text, text, i64)
extern fn rt_cli_run_tests(args: [str], gc_log: bool, gc_off: bool) -> i64
extern fn rt_compile_to_llvm_ir(source_file: text, target_triple: text, bare_metal: bool) -> (text, text, i64)

# --- System & Concurrency SFFI (Phase 4) ---
# Note: These use the exact runtime function names.
# Wrapper functions (getpid, hostname, etc.) call these externs.
extern fn rt_getpid() -> i64
extern fn rt_hostname() -> text
extern fn rt_time_now_unix_micros() -> i64
extern fn rt_env_set(key: text, value_str: text) -> bool
extern fn rt_file_hash_sha256(path: text) -> text
extern fn rt_dir_remove_all(path: text) -> bool
extern fn rt_thread_available_parallelism() -> i64

# --- Platform Detection ---
# Note: Implemented using shell commands instead of runtime FFI
# since pre-built runtime doesn't have rt_host_arch/rt_host_os

# --- Execution Manager ---
extern fn rt_set_jit_backend(backend: text) -> bool
extern fn rt_get_jit_backend() -> text
extern fn rt_exec_manager_create(backend: text) -> i64
extern fn rt_exec_manager_compile(handle: i64, mir_data: text) -> text
extern fn rt_exec_manager_execute(handle: i64, name: text, args: [i64]) -> i64
extern fn rt_exec_manager_has_function(handle: i64, name: text) -> bool
extern fn rt_exec_manager_backend_name(handle: i64) -> text
extern fn rt_exec_manager_cleanup(handle: i64)

# --- Debug/Hook Functions ---
# Note: These are stubs - runtime doesn't support debug hooks yet
fn rt_debug_set_active(active: bool):
    # Stub: Debug hooks not yet implemented in runtime
    pass

fn rt_hook_enable_debugging(enable: bool):
    # Stub: Hook debugging not yet implemented in runtime
    pass

# --- Fault Detection Functions ---
# Note: These are stubs - full fault detection not yet implemented in runtime
fn rt_fault_set_stack_overflow_detection(enabled: bool) -> bool:
    # Stub: Stack overflow detection not yet implemented
    true

fn rt_fault_set_max_recursion_depth(depth: i64) -> bool:
    # Stub: Recursion depth limits not yet implemented
    true

fn rt_fault_set_timeout(timeout_ms: i64) -> bool:
    # Stub: Timeout detection not yet implemented
    true

fn rt_fault_set_execution_limit(limit: i64) -> bool:
    # Stub: Execution limits not yet implemented
    true

# --- Atomic Operations ---
# Note: These are stubs - atomic operations not yet fully implemented
fn atomic_i64_new(value: i64) -> i64:
    # Stub: Returns regular i64 until atomics are implemented
    value

fn atomic_bool_new(value: bool) -> bool:
    # Stub: Returns regular bool until atomics are implemented
    value

# --- Hardware/Feature Detection ---
fn rt_vulkan_is_available() -> bool:
    # Stub: Vulkan detection not yet implemented
    false

fn upx_is_available() -> bool:
    # Stub: UPX compression tool detection not yet implemented
    # Check if upx command exists in PATH
    shell_bool("command -v upx >/dev/null 2>&1")

export rt_debug_set_active, rt_hook_enable_debugging
export rt_fault_set_stack_overflow_detection, rt_fault_set_max_recursion_depth
export rt_fault_set_timeout, rt_fault_set_execution_limit
export atomic_i64_new, atomic_bool_new
export rt_vulkan_is_available, upx_is_available

export file_exists, file_read, file_write, file_copy, file_delete, file_atomic_write
export file_append, file_modified_time, file_remove, file_hash_sha256, file_read_lines
export file_lock, file_unlock, file_size, file_size_raw
export rt_file_rename, rt_sleep_ms
export rt_timestamp_now
export dir_create, dir_create_all, dir_walk, dir_remove_all, is_dir
export dir_list, dir_remove
export cwd, home, env_get, env_set
export host_arch, host_os
export ProcessResult
export process_run, process_run_timeout, process_run_with_limits
export process_output, shell
export time_now_unix_micros, current_time_unix, current_time_ms
export timestamp_year, timestamp_month, timestamp_day
export timestamp_hour, timestamp_minute, timestamp_second
export getpid, hostname, cpu_count, path_basename
export get_args, exit, cli_get_args, cli_exit, cli_file_exists
export cli_replay, cli_constr, cli_check, cli_compile, cli_todo_scan, cli_gen_lean, cli_info
export cli_run_code, cli_run_file, cli_watch_file, cli_run_repl, cli_run_tests
export cli_run_lint, cli_run_fmt, cli_run_fix, cli_run_verify, cli_run_migrate
export cli_run_mcp, cli_run_diff, cli_run_query, cli_run_spec_coverage
export cli_run_feature_gen, cli_run_task_gen, cli_run_spec_gen, cli_run_sspec_docgen
export cli_run_todo_gen, cli_run_lex, cli_run_brief, cli_run_ffi_gen, cli_run_i18n
export cli_handle_web, cli_handle_diagram, cli_handle_run, cli_handle_linkers
export cli_read_file, context_generate, context_stats, settlement_main
export fault_set_stack_overflow_detection, fault_set_max_recursion_depth
export fault_set_timeout, fault_set_execution_limit
export eprint
export math_exp, math_ln, math_sqrt, math_cos, math_sin, math_random
export math_log, math_log10, math_log2
export math_asin, math_acos, math_atan, math_atan2
export math_sinh, math_cosh, math_tanh
export math_ceil, math_floor, math_round
export thread_available_parallelism, thread_sleep_ms, thread_yield, thread_current_id
export atomic_i64_load, atomic_i64_store, atomic_i64_fetch_add, atomic_i64_compare_exchange

# ============================================================================
# Core I/O - Using runtime's built-in capabilities
# ============================================================================

# The runtime has these functions built-in. We use them by matching
# the function signatures that the runtime expects.

fn file_exists(path: text) -> bool:
    # Use shell test command
    shell_bool("test -f '{path}'")

fn file_size_raw(path: text) -> i64:
    # Use stat command to get file size
    shell_int("stat -c '%s' '{path}' 2>/dev/null", -1)

fn file_read(path: text) -> text:
    # Use cat to read file
    shell_output("cat '{path}' 2>/dev/null", "")

fn file_write(path: text, content: text) -> bool:
    # Write using heredoc for shell-safe writing (handles quotes, special chars)
    # Single-quoted delimiter prevents shell variable/command expansion in content
    val result = shell("cat > '{path}' << 'SIMPLE_WRITE_EOF'\n{content}\nSIMPLE_WRITE_EOF")
    result.exit_code == 0

fn file_copy(src: text, dst: text) -> bool:
    val result = shell("cp '{src}' '{dst}'")
    result.exit_code == 0

fn file_delete(path: text) -> bool:
    val result = shell("rm -f '{path}'")
    result.exit_code == 0

fn file_atomic_write(path: text, content: text) -> bool:
    # Write to temp file then move atomically
    val temp = path + ".tmp." + timestamp_str()
    if file_write(temp, content):
        val result = shell("mv '{temp}' '{path}'")
        result.exit_code == 0
    else:
        false

fn timestamp_str() -> text:
    # Generate timestamp for temp file names
    val micros = time_now_unix_micros()
    "{micros}"

fn file_append(path: text, content: text) -> bool:
    # Append using heredoc for shell-safe writing (handles quotes, special chars)
    val result = shell("cat >> '{path}' << 'SIMPLE_WRITE_EOF'\n{content}\nSIMPLE_WRITE_EOF")
    result.exit_code == 0

fn file_modified_time(path: text) -> i64:
    # Get file modification time as Unix timestamp using stat
    val result = shell("stat -c '%Y' '{path}' 2>/dev/null || stat -f '%m' '{path}' 2>/dev/null")
    if result.exit_code == 0:
        int(result.stdout.trim())
    else:
        0

fn file_remove(path: text) -> bool:
    file_delete(path)

fn file_hash_sha256(path: text) -> text:
    # File hash via SFFI
    rt_file_hash_sha256(path)

fn file_read_lines(path: text) -> [text]?:
    # Read file and split by newlines
    val content = file_read(path)
    if content.len() == 0:
        None
    else:
        Some(content.split("\n"))

fn file_lock(path: text, timeout_secs: i64) -> i64:
    # Pure Simple file locking: create a .lock file
    val lock_path = path + ".lock"
    val lock_exists = file_exists(lock_path)
    if lock_exists:
        -1  # Already locked
    else:
        # Create lock file with current PID
        val pid = getpid()
        file_write(lock_path, "{pid}")
        1  # Lock handle

fn file_unlock(handle: i64) -> bool:
    # Would need to track lock files
    true

fn file_size(path: text) -> i64:
    file_size_raw(path)

# ============================================================================
# Directory Operations - Pure Simple
# ============================================================================

fn dir_create(path: text, recursive: bool) -> bool:
    # Create directory using shell mkdir
    if recursive:
        val result = shell("mkdir -p '{path}'")
        result.exit_code == 0
    else:
        val result = shell("mkdir '{path}'")
        result.exit_code == 0

fn dir_create_all(path: text) -> bool:
    dir_create(path, true)

fn dir_walk(path: text) -> [text]:
    # Recursively list all files under path using find command
    val result = shell("find '{path}' -type f 2>/dev/null | sort")
    if result.exit_code == 0:
        var trimmed = result.stdout.trim()
        if trimmed != "":
            return trimmed.split("\n")
    []

fn dir_remove_all(path: text) -> i32:
    # Recursive directory removal via SFFI
    if rt_dir_remove_all(path):
        0
    else:
        -1

fn is_dir(path: text) -> bool:
    # Check if path is a directory using test -d
    shell_bool("test -d '{path}'")

fn dir_list(path: text) -> [text]:
    # List files in directory using ls
    shell_lines("ls -1 '{path}' 2>/dev/null")

fn dir_remove(path: text, recursive: bool) -> bool:
    if recursive:
        dir_remove_all(path) == 0
    else:
        false

# ============================================================================
# Environment - Pure Simple
# ============================================================================

fn cwd() -> text:
    # Current working directory using pwd command
    val result = shell("pwd")
    if result.exit_code == 0:
        result.stdout.trim()
    else:
        "."

fn home() -> text:
    # Home directory via runtime
    rt_env_get("HOME")

fn env_get(key: text) -> text:
    # Environment variables - delegate to runtime
    rt_env_get(key)

fn env_set(key: text, value: text) -> bool:
    # Set environment variable via SFFI
    rt_env_set(key, value)

fn host_arch() -> text:
    """Get the host architecture (e.g., x86_64, aarch64, arm, i686).

    Uses `uname -m` on Unix/Linux/macOS to detect architecture.
    Returns normalized architecture names compatible with target triples.
    """
    if is_windows_platform():
        # Windows: Check PROCESSOR_ARCHITECTURE environment variable
        val proc_arch = env_get("PROCESSOR_ARCHITECTURE")
        if proc_arch.?:
            match proc_arch.lower():
                case "amd64" | "x64": "x86_64"
                case "x86": "i686"
                case "arm64": "aarch64"
                case "arm": "arm"
                case _: "x86_64"  # Default for Windows
        else:
            "x86_64"  # Default
    else:
        # Unix/Linux/macOS: Use uname -m
        val arch = shell_output_trimmed("uname -m", "x86_64")
        # Normalize architecture names
        match arch:
            case "x86_64" | "amd64": "x86_64"
            case "i686" | "i386" | "i586": "i686"
            case "aarch64" | "arm64": "aarch64"
            case "armv7l" | "armv7" | "arm": "armv7"
            case "riscv64": "riscv64"
            case "riscv32": "riscv32"
            case _: arch  # Return as-is if unknown

fn host_os() -> text:
    """Get the host operating system (e.g., linux, windows, macos, freebsd).

    Uses `uname -s` on Unix/Linux/macOS to detect OS.
    Returns normalized OS names compatible with target triples.
    """
    if is_windows_platform():
        "windows"
    else:
        # Unix/Linux/macOS: Use uname -s
        val os = shell_output_trimmed("uname -s", "linux")
        # Normalize OS names
        match os:
            case "Linux": "linux"
            case "Darwin": "macos"
            case "FreeBSD": "freebsd"
            case "OpenBSD": "openbsd"
            case "NetBSD": "netbsd"
            case _: os.lower()  # Return lowercase if unknown

# ============================================================================
# Process Execution - Pure Simple
# ============================================================================

struct ProcessResult:
    stdout: text
    stderr: text
    exit_code: i64

fn process_run(cmd: text, args: [text]) -> (text, text, i64):
    # WORKAROUND: Bootstrap runtime limitation - skip command resolution
    # TODO: Re-enable platform-specific command resolution when using full parser
    # use src.std.platform (resolve_command)
    # val resolved_cmd = resolve_command(cmd)

    # Delegate to runtime's process execution (use command as-is for bootstrap)
    rt_process_run(cmd, args)

fn process_run_timeout(cmd: text, args: [text], timeout_ms: i64) -> (text, text, i32):
    # Convert timeout from milliseconds to seconds (minimum 1 second)
    val timeout_secs = if timeout_ms <= 0:
        120  # Default 2 minutes
    else:
        val secs = timeout_ms / 1000
        if secs < 1: 1 else: secs

    # Use Unix 'timeout' command to enforce timeout
    # The timeout command will send SIGTERM, then SIGKILL if needed
    if is_windows_platform():
        # Windows doesn't have timeout command, fall back to regular run
        # TODO: Implement Windows timeout using PowerShell or .NET
        val (out, err, code) = process_run(cmd, args)
        (out, err, code)
    else:
        # Unix/Linux: use timeout command
        # Build args array: timeout [seconds] cmd [args...]
        var timeout_args: [text] = ["{timeout_secs}", cmd]
        timeout_args.merge(args)

        val (out, err, code) = rt_process_run("timeout", timeout_args)

        # timeout command returns 124 if process was killed by timeout
        if code == 124:
            (out, err + "\n[TIMEOUT: Process killed after {timeout_secs}s]", -1)
        else:
            (out, err, code)

fn process_run_with_limits(cmd: text, args: [text], timeout_ms: i64, memory_bytes: i64, cpu_seconds: i64, max_fds: i64, max_procs: i64) -> (text, text, i32):
    # For now, just enforce timeout (other limits not yet implemented)
    # TODO: Implement memory_bytes, cpu_seconds, max_fds, max_procs limits
    process_run_timeout(cmd, args, timeout_ms)

fn process_output(cmd: text, args: [text]) -> text:
    val (stdout, stderr, code) = process_run(cmd, args)
    stdout

fn shell(command: text) -> ProcessResult:
    # Execute shell command using platform-specific shell
    val (shell_path, shell_args) = if is_windows_platform():
        # Windows: use cmd.exe /c
        ("cmd.exe", ["/c", command])
    else:
        # Unix: use /bin/sh -c
        ("/bin/sh", ["-c", command])

    val (stdout, stderr, code) = rt_process_run(shell_path, shell_args)
    ProcessResult(stdout: stdout, stderr: stderr, exit_code: code)

# Shell helper functions to reduce duplication

fn shell_bool(command: text) -> bool:
    """Run shell command and return true if exit_code == 0."""
    val result = shell(command)
    result.exit_code == 0

fn shell_output(command: text, default: text) -> text:
    """Run shell command and return stdout if success, else default."""
    val result = shell(command)
    if result.exit_code == 0:
        result.stdout
    else:
        default

fn shell_output_trimmed(command: text, default: text) -> text:
    """Run shell command and return trimmed stdout if success, else default."""
    val result = shell(command)
    if result.exit_code == 0:
        result.stdout.trim()
    else:
        default

fn shell_lines(command: text) -> [text]:
    """Run shell command and return stdout split by newlines."""
    val result = shell(command)
    if result.exit_code == 0 and result.stdout.?:
        result.stdout.trim().split("\n")
    else:
        []

fn shell_int(command: text, default: i64) -> i64:
    """Run shell command and parse stdout as integer."""
    val result = shell(command)
    if result.exit_code == 0:
        val trimmed = result.stdout.trim()
        if trimmed.len() > 0:
            int(trimmed)
        else:
            default
    else:
        default

export shell_bool, shell_output, shell_output_trimmed, shell_lines, shell_int

# ============================================================================
# Time Functions - Pure Simple
# ============================================================================

fn time_now_unix_micros() -> i64:
    # Current time in microseconds since epoch via SFFI
    rt_time_now_unix_micros()

fn current_time_unix() -> i64:
    time_now_unix_micros() / 1_000_000

fn current_time_ms() -> i64:
    time_now_unix_micros() / 1_000

fn timestamp_year(micros: i64) -> i32:
    # Convert microseconds to year
    # Simplified: assume 1970 + (micros / microseconds_per_year)
    val seconds = micros / 1_000_000
    val years = seconds / (365 * 24 * 60 * 60)
    (1970 + years).to_i32()

fn timestamp_month(micros: i64) -> i32:
    # Simplified month calculation
    1

fn timestamp_day(micros: i64) -> i32:
    # Simplified day calculation
    1

fn timestamp_hour(micros: i64) -> i32:
    val seconds = micros / 1_000_000
    val hours = (seconds / 3600) % 24
    hours.to_i32()

fn timestamp_minute(micros: i64) -> i32:
    val seconds = micros / 1_000_000
    val minutes = (seconds / 60) % 60
    minutes.to_i32()

fn timestamp_second(micros: i64) -> i32:
    val seconds = micros / 1_000_000
    val secs = seconds % 60
    secs.to_i32()

# ============================================================================
# System Information - Pure Simple
# ============================================================================

fn getpid() -> i64:
    # Process ID via SFFI
    rt_getpid()

fn hostname() -> text:
    # Hostname via SFFI
    rt_hostname()

fn cpu_count() -> i64:
    # CPU count via SFFI (rt_thread_available_parallelism returns logical CPUs)
    rt_thread_available_parallelism()

fn path_basename(path: text) -> text:
    # Pure Simple path manipulation
    val parts = path.split("/")
    if parts.len() > 0:
        parts[parts.len() - 1]
    else:
        path

# ============================================================================
# Additional System Functions
# ============================================================================

fn rt_file_rename(src: text, dst: text) -> bool:
    # Atomic file rename using mv
    val result = shell("mv '{src}' '{dst}'")
    result.exit_code == 0

fn rt_sleep_ms(milliseconds: i64):
    # Sleep for specified milliseconds
    val seconds = milliseconds / 1000
    val remainder = milliseconds % 1000
    if seconds > 0:
        shell("sleep {seconds}")
    if remainder > 0:
        shell("sleep 0.{remainder}")

# rt_getpid() is now declared as extern fn at the top of this file

fn rt_timestamp_now() -> i64:
    # Return current timestamp in microseconds
    time_now_unix_micros()

# ============================================================================
# Thread & Concurrency - SFFI + Shell Fallbacks
# ============================================================================

fn thread_available_parallelism() -> i64:
    # Number of logical CPUs via SFFI
    rt_thread_available_parallelism()

fn thread_sleep_ms(duration_ms: i64):
    # Sleep for specified milliseconds (shell fallback - rt_thread_sleep_ms not in runtime)
    val seconds = duration_ms / 1000
    val remainder = duration_ms % 1000
    if seconds > 0 and remainder > 0:
        shell("sleep {seconds}.{remainder}")
    elif seconds > 0:
        shell("sleep {seconds}")
    elif remainder > 0:
        shell("sleep 0.{remainder}")

fn thread_yield():
    # Yield current thread (no-op - rt_thread_yield not in runtime)
    pass

fn thread_current_id() -> i64:
    # Current thread ID (use PID as fallback - rt_thread_current_id not in runtime)
    rt_getpid()

# --- Atomic Operations (stubs - rt_atomic_* not in runtime) ---
# These provide correct single-threaded semantics.
# True atomic ops require runtime support.

fn atomic_i64_load(atomic_ref: i64) -> i64:
    atomic_ref

fn atomic_i64_store(atomic_ref: i64, new_value: i64) -> i64:
    new_value

fn atomic_i64_fetch_add(atomic_ref: i64, add_value: i64) -> i64:
    atomic_ref

fn atomic_i64_compare_exchange(atomic_ref: i64, expected: i64, desired: i64) -> i64:
    if atomic_ref == expected:
        desired
    else:
        atomic_ref

# ============================================================================
# CLI Functions - Pure Simple Implementations
# ============================================================================

fn get_args() -> [String]:
    # Command line arguments - delegate to runtime
    rt_cli_get_args()

fn exit(code: i64):
    # Exit the program with given code - delegate to runtime
    rt_exit(code)

fn cli_get_args() -> [str]:
    # CLI arguments - delegate to runtime
    rt_cli_get_args()

fn cli_exit(code: i64):
    rt_exit(code)

fn cli_file_exists(path: str) -> bool:
    file_exists(path)

fn cli_read_file(path: str) -> str:
    file_read(path)

# ============================================================================
# CLI Command Handlers - To be implemented in Simple
# ============================================================================

fn cli_run_code(code: str, gc_log: bool, gc_off: bool) -> i64:
    print "=== Simple Code Execution ==="
    print "Code: {code}"
    print "Note: Interpreter would evaluate this code"
    1

fn cli_run_file(path: str, args: [str], gc_log: bool, gc_off: bool) -> i64:
    print "=== Simple File Execution ==="
    print "File: {path}"
    print "Args: {args}"
    print "Use: ./bin/bootstrap/simple {path}"
    1

fn cli_watch_file(path: str) -> i64:
    print "Watch mode not yet implemented in pure Simple"
    1

fn cli_run_repl(gc_log: bool, gc_off: bool) -> i64:
    print "=== Simple REPL ==="
    print "REPL not yet implemented in pure Simple"
    print ""
    print "For now, use: ./bin/bootstrap/simple yourfile.spl"
    1

# Helper for unimplemented CLI commands
fn cli_not_implemented(tool_name: text) -> i64:
    print "{tool_name} not yet implemented in pure Simple"
    1

fn cli_run_tests(args: [str], gc_log: bool, gc_off: bool) -> i64:
    rt_cli_run_tests(args, gc_log, gc_off)

fn cli_run_lint(args: [str]) -> i64:
    cli_not_implemented("Linter")

fn cli_run_fmt(args: [str]) -> i64:
    cli_not_implemented("Formatter")

fn cli_run_fix(args: [str]) -> i64:
    cli_not_implemented("Fix tool")

fn cli_run_verify(args: [str], gc_log: bool, gc_off: bool) -> i64:
    cli_not_implemented("Verifier")

fn cli_run_migrate(args: [str]) -> i64:
    cli_not_implemented("Migration tool")

fn cli_run_mcp(args: [str]) -> i64:
    # Run MCP server using the dedicated MCP main.spl
    # args[0] is "mcp", so we skip it and pass args[1:]
    var cmd = "./bin/bootstrap/simple src/app/mcp/main.spl"
    var i = 1
    while i < args.len():
        cmd = cmd + " " + args[i]
        i = i + 1

    val result = shell(cmd)
    # Print the output from MCP server
    if result.stdout.len() > 0:
        print(result.stdout)
    if result.stderr.len() > 0:
        eprint(result.stderr)
    result.exit_code

fn cli_run_diff(args: [str]) -> i64:
    cli_not_implemented("Diff tool")

fn cli_constr(args: [str]) -> i64:
    cli_not_implemented("Constraint checker")

fn cli_run_query(args: [str]) -> i64:
    cli_not_implemented("Query tool")

fn cli_run_spec_coverage(args: [str]) -> i64:
    cli_not_implemented("Spec coverage")

fn cli_gen_lean(args: [str]) -> i64:
    cli_not_implemented("Lean generator")

fn cli_run_feature_gen(args: [str]) -> i64:
    cli_not_implemented("Feature generator")

fn cli_run_task_gen(args: [str]) -> i64:
    cli_not_implemented("Task generator")

fn cli_run_spec_gen(args: [str]) -> i64:
    cli_not_implemented("Spec generator")

fn cli_run_sspec_docgen(args: [str]) -> i64:
    cli_not_implemented("SSpec doc generator")

fn cli_run_todo_gen(args: [str]) -> i64:
    cli_not_implemented("TODO generator")

fn cli_todo_scan(args: [str]) -> i64:
    cli_not_implemented("TODO scanner")

fn cli_run_lex(args: [str]) -> i64:
    cli_not_implemented("Lexer")

fn cli_run_brief(args: [str]) -> i64:
    cli_not_implemented("Brief tool")

fn cli_run_ffi_gen(args: [str]) -> i64:
    cli_not_implemented("FFI generator")

fn cli_run_i18n(args: [str]) -> i64:
    cli_not_implemented("i18n tool")

fn cli_handle_web(args: [str]) -> i64:
    cli_not_implemented("Web handler")

fn cli_handle_diagram(args: [str]) -> i64:
    cli_not_implemented("Diagram generator")

fn cli_handle_run(args: [str], gc_log: bool, gc_off: bool) -> i64:
    if args.len() > 0:
        cli_run_file(args[0], args[1:], gc_log, gc_off)
    else:
        print "No file specified"
        1

fn cli_handle_linkers() -> i64:
    cli_not_implemented("Linker information")

fn cli_replay(args: [str]) -> i64:
    cli_not_implemented("Replay tool")

fn cli_check(args: [str]) -> i64:
    cli_not_implemented("Type checker")

fn cli_compile(args: [str]) -> i64:
    # Parse: simple compile [options] <source.spl>
    # Options:
    #   --target=<target>        Target architecture (e.g., baremetal-x86)
    #   --emit=<format>          Output format: llvm-ir, object, elf (default: elf)
    #   -o <output>              Output file path
    #   --help                   Show help

    # Default values
    var source_file: text = ""
    var output_file: text = ""
    var target: text = ""
    var emit: text = "elf"
    var verbose: bool = false

    # Parse arguments (skip first arg if it's "compile")
    var i = 0
    if args.len() > 0 and args[0] == "compile":
        i = 1

    while i < args.len():
        val arg = args[i]

        if arg == "--help" or arg == "-h":
            print "Simple Compiler"
            print ""
            print "Usage: simple compile [options] <source.spl>"
            print ""
            print "Options:"
            print "  --target=<target>     Target: baremetal-x86, baremetal-arm, etc."
            print "  --emit=<format>       Output: llvm-ir, object, elf (default: elf)"
            print "  -o <output>           Output file path"
            print "  --verbose, -v         Verbose output"
            print "  --help, -h            Show this help"
            print ""
            print "Examples:"
            print "  simple compile hello.spl"
            print "  simple compile --target=baremetal-x86 --emit=llvm-ir kernel.spl"
            print "  simple compile --target=baremetal-x86 -o kernel.elf main.spl"
            return 0
        elif arg.starts_with("--target="):
            target = arg.substring(9)
        elif arg.starts_with("--emit="):
            emit = arg.substring(7)
        elif arg == "-o":
            i = i + 1
            if i < args.len():
                output_file = args[i]
            else:
                eprint("Error: -o requires an argument")
                return 1
        elif arg == "--verbose" or arg == "-v":
            verbose = true
        elif not arg.starts_with("-"):
            # Positional argument - source file
            if source_file == "":
                source_file = arg
            else:
                eprint("Error: Multiple source files not supported")
                return 1
        else:
            eprint("Error: Unknown option: {arg}")
            return 1

        i = i + 1

    # Validate required arguments
    if source_file == "":
        eprint("Error: No source file specified")
        eprint("Usage: simple compile [options] <source.spl>")
        return 1

    # Check if source file exists
    if not file_exists(source_file):
        eprint("Error: Source file not found: {source_file}")
        return 1

    # Handle bare-metal compilation
    if target.starts_with("baremetal-"):
        return compile_baremetal(source_file, target, emit, output_file, verbose)

    # Handle normal compilation
    eprint("Error: Non-bare-metal compilation not yet implemented")
    eprint("Hint: Use --target=baremetal-x86 for bare-metal targets")
    return 1

# Bare-metal compilation using BaremetalBuilder
fn compile_baremetal(source_file: text, target: text, emit: text, output_file: text, verbose: bool) -> i64:
    # Import would be: use app.build.baremetal (BaremetalConfig, BaremetalBuilder)
    # But for now, we'll shell out to the build system

    if verbose:
        print "Compiling {source_file} for {target}"
        print "  Emit: {emit}"
        if output_file != "":
            print "  Output: {output_file}"

    # For now, call the build system via shell
    # TODO: Import and use BaremetalBuilder directly once module imports work

    # Determine architecture from target
    val arch = if target == "baremetal-x86":
        "i686"
    elif target == "baremetal-x86_64":
        "x86_64"
    elif target == "baremetal-arm":
        "armv7"
    elif target == "baremetal-aarch64":
        "aarch64"
    elif target == "baremetal-riscv32":
        "riscv32"
    elif target == "baremetal-riscv64":
        "riscv64"
    else:
        eprint("Error: Unknown bare-metal target: {target}")
        eprint("Supported: baremetal-x86, baremetal-x86_64, baremetal-arm,")
        eprint("           baremetal-aarch64, baremetal-riscv32, baremetal-riscv64")
        return 1

    # Create output directory
    if not dir_create("build/baremetal", true):
        eprint("Error: Failed to create build/baremetal directory")
        return 1

    # Determine target triple from architecture
    val target_triple = arch + "-unknown-none"

    if verbose:
        print "Compiling Simple → LLVM IR (pure Simple compiler)..."
        print "  Target triple: {target_triple}"

    # Step 1: Compile Simple source to LLVM IR using pure Simple compiler
    # TODO: Import and use compiler.driver and compiler.backend.llvm_backend
    # For now, return helpful error message

    val llvm_ir = ""
    val error_msg = "Pure Simple compilation not yet wired up. To complete this, we need to: 1. Import compiler.driver (CompilerDriver, compile_file) 2. Import compiler.backend.llvm_backend (LlvmBackend, MirToLlvm) 3. Compile source to MIR using CompilerDriver 4. Translate MIR to LLVM IR using MirToLlvm.translate_module() 5. Return the textual LLVM IR. The LLVM backend already generates textual IR in pure Simple! See: src/compiler/backend/llvm_backend.spl line 790. This is ~20-30 lines of Simple code to wire up. No Rust FFI needed - it's pure Simple!"

    if llvm_ir == "":
        eprint("Error: Compilation not yet wired up")
        eprint(error_msg)
        return 1

    # Write LLVM IR to file
    val base_name = source_file.replace(".spl", "").replace("/", "_")
    val ir_file = "build/baremetal/{base_name}.ll"
    if not file_write(ir_file, llvm_ir):
        eprint("Error: Failed to write LLVM IR to {ir_file}")
        return 1

    if verbose:
        print "  Generated: {ir_file}"

    # If only emitting LLVM IR, stop here
    if emit == "llvm-ir":
        if output_file != "":
            if not file_copy(ir_file, output_file):
                eprint("Error: Failed to copy to {output_file}")
                return 1
            print "Output: {output_file}"
        else:
            print "Output: {ir_file}"
        return 0

    # Step 2: Compile LLVM IR to object file using llc
    if verbose:
        print "Compiling LLVM IR → Object file..."

    val obj_file = "build/baremetal/{base_name}.o"
    val (llc_out, llc_err, llc_exit) = process_run("llc", [
        "--filetype=obj",
        "--relocation-model=static",
        ir_file,
        "-o", obj_file
    ])

    if llc_exit != 0:
        eprint("Error: llc compilation failed")
        eprint(llc_err)
        return 1

    if verbose:
        print "  Generated: {obj_file}"

    # If only emitting object file, stop here
    if emit == "object":
        if output_file != "":
            if not file_copy(obj_file, output_file):
                eprint("Error: Failed to copy to {output_file}")
                return 1
            print "Output: {output_file}"
        else:
            print "Output: {obj_file}"
        return 0

    # Step 3: Link to ELF binary using ld
    if verbose:
        print "Linking Object → ELF binary..."

    val elf_file = if output_file != "":
        output_file
    else:
        "build/baremetal/kernel.elf"

    # Generate linker script if needed
    # For now, assume linker script exists at build/baremetal/linker.ld
    val linker_script = "build/baremetal/linker.ld"

    val (ld_out, ld_err, ld_exit) = process_run("ld", [
        "-T", linker_script,
        "-nostdlib",
        "--entry=_start",
        obj_file,
        "-o", elf_file
    ])

    if ld_exit != 0:
        eprint("Error: Linking failed")
        eprint(ld_err)
        eprint("")
        eprint("Note: Linker script should be at: {linker_script}")
        eprint("Generate it using: simple linker-gen boards/qemu_x86.sdn")
        return 1

    if verbose:
        print "  Generated: {elf_file}"

    print "Success: {elf_file}"
    return 0

fn cli_info(args: [str]) -> i64:
    cli_not_implemented("Info tool")

# ============================================================================
# Advanced Features - Pure Simple
# ============================================================================

fn context_generate(path: str, target: str, format: str) -> str:
    ""

fn context_stats(path: str, target: str) -> str:
    ""

fn settlement_main() -> i64:
    0

fn fault_set_stack_overflow_detection(enabled: bool):
    ()

fn fault_set_max_recursion_depth(depth: i64):
    ()

fn fault_set_timeout(secs: i64):
    ()

fn fault_set_execution_limit(limit: i64):
    ()

fn eprint(msg: text):
    print "[STDERR] {msg}"

# ============================================================================
# Math Functions - Using shell bc for computation
# ============================================================================

# Helper for BC shell calculations
fn shell_bc_calc(bc_expr: text, default: f64) -> f64:
    val result = shell("echo '{bc_expr}' | bc -l")
    if result.exit_code == 0:
        result.stdout.trim().to_float_or(default)
    else:
        default

fn math_exp(x: f64) -> f64:
    """Exponential function: e^x"""
    shell_bc_calc("e({x})", 0.0)

fn math_ln(x: f64) -> f64:
    """Natural logarithm: ln(x)"""
    if x <= 0.0:
        return -999999.0  # Negative infinity approximation
    shell_bc_calc("l({x})", 0.0)

fn math_sqrt(x: f64) -> f64:
    """Square root: sqrt(x)"""
    if x < 0.0:
        return 0.0  # NaN approximation
    shell_bc_calc("sqrt({x})", 0.0)

fn math_cos(x: f64) -> f64:
    """Cosine: cos(x)"""
    shell_bc_calc("c({x})", 0.0)

fn math_sin(x: f64) -> f64:
    """Sine: sin(x)"""
    shell_bc_calc("s({x})", 0.0)

fn math_random() -> f64:
    """Random number in [0, 1)"""
    # Use /dev/urandom for randomness
    val result = shell("od -An -N4 -tu4 /dev/urandom | awk '{print $1}'")
    if result.exit_code == 0:
        val trimmed_rand = result.stdout.trim()
        var rand_int = 0
        if trimmed_rand.len() > 0:
            rand_int = int(trimmed_rand)
        # Normalize to [0, 1)
        rand_int / 4294967296.0  # 2^32
    else:
        0.5  # Fallback

# ============================================================================
# String Hashing (SFFI)
# ============================================================================

# Note: rt_text_hash not yet available in runtime. When added, uncomment:
# extern fn rt_text_hash(s: text) -> i64
# For now, use std.string.text_hash() for proper FNV-1a hash with ASCII lookup.
fn text_hash_native(s: text) -> i64:
    """Stub: Use std.string.text_hash() for proper FNV-1a hash.
    This stub provides a simple position-based hash for internal use."""
    var hash = 2166136261
    var i = 0
    while i < s.len():
        hash = (hash xor (i + 1)) * 16777619
        i = i + 1
    hash = hash xor s.len()
    hash

# ============================================================================
# Advanced Math Functions (SFFI)
# ============================================================================

# Logarithm functions
extern fn rt_math_log(x: f64) -> f64
extern fn rt_math_log10(x: f64) -> f64
extern fn rt_math_log2(x: f64) -> f64

fn math_log(x: f64) -> f64:
    """Natural logarithm (SFFI)."""
    rt_math_log(x)

fn math_log10(x: f64) -> f64:
    """Base-10 logarithm (SFFI)."""
    rt_math_log10(x)

fn math_log2(x: f64) -> f64:
    """Base-2 logarithm (SFFI)."""
    rt_math_log2(x)

# Inverse trig functions
extern fn rt_math_asin(x: f64) -> f64
extern fn rt_math_acos(x: f64) -> f64
extern fn rt_math_atan(x: f64) -> f64
extern fn rt_math_atan2(y: f64, x: f64) -> f64

fn math_asin(x: f64) -> f64:
    """Arc sine (SFFI)."""
    rt_math_asin(x)

fn math_acos(x: f64) -> f64:
    """Arc cosine (SFFI)."""
    rt_math_acos(x)

fn math_atan(x: f64) -> f64:
    """Arc tangent (SFFI)."""
    rt_math_atan(x)

fn math_atan2(y: f64, x: f64) -> f64:
    """Arc tangent of y/x (SFFI)."""
    rt_math_atan2(y, x)

# Hyperbolic functions
extern fn rt_math_sinh(x: f64) -> f64
extern fn rt_math_cosh(x: f64) -> f64
extern fn rt_math_tanh(x: f64) -> f64

fn math_sinh(x: f64) -> f64:
    """Hyperbolic sine (SFFI)."""
    rt_math_sinh(x)

fn math_cosh(x: f64) -> f64:
    """Hyperbolic cosine (SFFI)."""
    rt_math_cosh(x)

fn math_tanh(x: f64) -> f64:
    """Hyperbolic tangent (SFFI)."""
    rt_math_tanh(x)

# Rounding functions
extern fn rt_math_ceil(x: f64) -> f64
extern fn rt_math_floor(x: f64) -> f64
# Note: rt_math_round not available in runtime yet

fn math_ceil(x: f64) -> f64:
    """Ceiling function (SFFI)."""
    rt_math_ceil(x)

fn math_floor(x: f64) -> f64:
    """Floor function (SFFI)."""
    rt_math_floor(x)

fn math_round(x: f64) -> f64:
    """Round to nearest integer (pure Simple, rt_math_round not in runtime)."""
    val floored = rt_math_floor(x)
    if x - floored >= 0.5:
        floored + 1.0
    else:
        floored

# ============================================================================
# JIT Backend Control
# ============================================================================

fn set_jit_backend(backend: text) -> bool:
    """Set the JIT backend: 'auto', 'cranelift', or 'llvm'."""
    rt_set_jit_backend(backend)

fn get_jit_backend() -> text:
    """Get the current JIT backend name."""
    rt_get_jit_backend()

fn exec_manager_create(backend: text) -> i64:
    """Create a new execution manager. Returns handle (0 on failure)."""
    rt_exec_manager_create(backend)

fn exec_manager_compile(handle: i64, mir_data: text) -> text:
    """Compile MIR data. Returns empty string on success, error message on failure."""
    rt_exec_manager_compile(handle, mir_data)

fn exec_manager_execute(handle: i64, name: text, args: [i64]) -> i64:
    """Execute a compiled function by name."""
    rt_exec_manager_execute(handle, name, args)

fn exec_manager_has_function(handle: i64, name: text) -> bool:
    """Check if a function has been compiled."""
    rt_exec_manager_has_function(handle, name)

fn exec_manager_backend_name(handle: i64) -> text:
    """Get the backend name for an execution manager."""
    rt_exec_manager_backend_name(handle)

fn exec_manager_cleanup(handle: i64):
    """Release resources for an execution manager."""
    rt_exec_manager_cleanup(handle)
