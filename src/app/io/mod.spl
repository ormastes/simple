# Pure Simple I/O Implementation
# All implementations in Simple - no Rust dependencies

# Extern function declarations for runtime
extern fn rt_cli_get_args() -> [str]
extern fn rt_exit(code: i64)
extern fn rt_process_run(cmd: text, args: [text]) -> (text, text, i64)

export file_exists, file_read, file_write, file_copy, file_delete, file_atomic_write
export file_append, file_modified_time, file_remove, file_hash_sha256, file_read_lines
export file_lock, file_unlock, file_size, file_size_raw
export rt_file_rename, rt_sleep_ms, rt_getpid, rt_timestamp_now
export dir_create, dir_create_all, dir_walk, dir_remove_all, is_dir
export dir_list, dir_remove
export cwd, home, env_get, env_set
export process_run, process_run_timeout, process_run_with_limits
export process_output, shell
export time_now_unix_micros, current_time_unix, current_time_ms
export timestamp_year, timestamp_month, timestamp_day
export timestamp_hour, timestamp_minute, timestamp_second
export getpid, hostname, cpu_count, path_basename
export get_args, exit, cli_get_args, cli_exit, cli_file_exists
export cli_replay, cli_constr, cli_check, cli_compile, cli_todo_scan, cli_gen_lean, cli_info
export cli_run_code, cli_run_file, cli_watch_file, cli_run_repl, cli_run_tests
export cli_run_lint, cli_run_fmt, cli_run_fix, cli_run_verify, cli_run_migrate
export cli_run_mcp, cli_run_diff, cli_run_query, cli_run_spec_coverage
export cli_run_feature_gen, cli_run_task_gen, cli_run_spec_gen, cli_run_sspec_docgen
export cli_run_todo_gen, cli_run_lex, cli_run_brief, cli_run_ffi_gen, cli_run_i18n
export cli_handle_web, cli_handle_diagram, cli_handle_run, cli_handle_linkers
export cli_read_file, context_generate, context_stats, settlement_main
export fault_set_stack_overflow_detection, fault_set_max_recursion_depth
export fault_set_timeout, fault_set_execution_limit
export eprintln
export math_exp, math_ln, math_sqrt, math_cos, math_sin, math_random

# ============================================================================
# Core I/O - Using runtime's built-in capabilities
# ============================================================================

# The runtime has these functions built-in. We use them by matching
# the function signatures that the runtime expects.

fn file_exists(path: text) -> bool:
    # Use shell test command
    val result = shell("test -f '{path}'")
    result.exit_code == 0

fn file_size_raw(path: text) -> i64:
    # Use stat command to get file size
    val result = shell("stat -c '%s' '{path}' 2>/dev/null")
    if result.exit_code == 0:
        result.stdout.trim().to_int_or(-1)
    else:
        -1

fn file_read(path: text) -> text:
    # Use cat to read file
    val result = shell("cat '{path}' 2>/dev/null")
    if result.exit_code == 0:
        result.stdout
    else:
        ""

fn file_write(path: text, content: text) -> bool:
    # Write using shell redirection via echo
    # Escape single quotes in content
    val escaped = content.replace("'", "'\\''")
    val result = shell("printf '%s' '{escaped}' > '{path}'")
    result.exit_code == 0

fn file_copy(src: text, dst: text) -> bool:
    val result = shell("cp '{src}' '{dst}'")
    result.exit_code == 0

fn file_delete(path: text) -> bool:
    val result = shell("rm -f '{path}'")
    result.exit_code == 0

fn file_atomic_write(path: text, content: text) -> bool:
    # Write to temp file then move atomically
    val temp = path + ".tmp." + timestamp_str()
    if file_write(temp, content):
        val result = shell("mv '{temp}' '{path}'")
        result.exit_code == 0
    else:
        false

fn timestamp_str() -> text:
    # Generate timestamp for temp file names
    val micros = time_now_unix_micros()
    "{micros}"

fn file_append(path: text, content: text) -> bool:
    # Use shell append redirection
    val escaped = content.replace("'", "'\\''")
    val result = shell("printf '%s' '{escaped}' >> '{path}'")
    result.exit_code == 0

fn file_modified_time(path: text) -> i64:
    # Return 0 for now (epoch time)
    0

fn file_remove(path: text) -> bool:
    file_delete(path)

fn file_hash_sha256(path: text) -> text:
    # Pure Simple SHA256 would require implementing the algorithm
    # For now, return empty string
    ""

fn file_read_lines(path: text) -> [text]?:
    # Read file and split by newlines
    val content = file_read(path)
    if content.len() == 0:
        None
    else:
        Some(content.split("\n"))

fn file_lock(path: text, timeout_secs: i64) -> i64:
    # Pure Simple file locking: create a .lock file
    val lock_path = path + ".lock"
    val lock_exists = file_exists(lock_path)
    if lock_exists:
        -1  # Already locked
    else:
        # Create lock file with current PID
        val pid = getpid()
        file_write(lock_path, "{pid}")
        1  # Lock handle

fn file_unlock(handle: i64) -> bool:
    # Would need to track lock files
    true

fn file_size(path: text) -> i64:
    file_size_raw(path)

# ============================================================================
# Directory Operations - Pure Simple
# ============================================================================

fn dir_create(path: text, recursive: bool) -> bool:
    print "[INFO] dir_create('{path}', recursive={recursive})"
    false

fn dir_create_all(path: text) -> bool:
    dir_create(path, true)

fn dir_walk(path: text) -> [text]:
    # Would need to recursively traverse directories
    []

fn dir_remove_all(path: text) -> i32:
    print "[INFO] dir_remove_all('{path}')"
    -1

fn is_dir(path: text) -> bool:
    # Check if path is a directory using test -d
    val result = shell("test -d '{path}'")
    result.exit_code == 0

fn dir_list(path: text) -> [text]:
    # List files in directory using ls
    val result = shell("ls -1 '{path}' 2>/dev/null")
    if result.exit_code == 0 and result.stdout.?:
        val out = result.stdout
        val trimmed = out.trim()
        trimmed.split("\n")
    else:
        []

fn dir_remove(path: text, recursive: bool) -> bool:
    if recursive:
        dir_remove_all(path) == 0
    else:
        false

# ============================================================================
# Environment - Pure Simple
# ============================================================================

fn cwd() -> text:
    # Current working directory
    # Could be tracked in a global variable
    "."

fn home() -> text:
    # Home directory
    # Could use env_get("HOME")
    env_get("HOME")

fn env_get(key: text) -> text:
    # Environment variables
    # The runtime might have these
    ""

fn env_set(key: text, value: text) -> bool:
    print "[INFO] env_set('{key}', '{value}')"
    false

# ============================================================================
# Process Execution - Pure Simple
# ============================================================================

struct ProcessResult:
    stdout: text
    stderr: text
    exit_code: i64

fn process_run(cmd: text, args: [text]) -> (text, text, i64):
    # Delegate to runtime's process execution
    rt_process_run(cmd, args)

fn process_run_timeout(cmd: text, args: [text], timeout_ms: i64) -> (text, text, i32):
    val (out, err, code) = process_run(cmd, args)
    (out, err, code)

fn process_run_with_limits(cmd: text, args: [text], timeout_ms: i64, memory_bytes: i64, cpu_seconds: i64, max_fds: i64, max_procs: i64) -> (text, text, i32):
    val (out, err, code) = process_run(cmd, args)
    (out, err, code)

fn process_output(cmd: text, args: [text]) -> text:
    val (stdout, stderr, code) = process_run(cmd, args)
    stdout

fn shell(command: text) -> ProcessResult:
    # Execute shell command using /bin/sh
    val (stdout, stderr, code) = process_run("/bin/sh", ["-c", command])
    ProcessResult(stdout: stdout, stderr: stderr, exit_code: code)

# ============================================================================
# Time Functions - Pure Simple
# ============================================================================

fn time_now_unix_micros() -> i64:
    # Current time in microseconds since epoch
    # Could be tracked by the runtime
    0

fn current_time_unix() -> i64:
    time_now_unix_micros() / 1_000_000

fn current_time_ms() -> i64:
    time_now_unix_micros() / 1_000

fn timestamp_year(micros: i64) -> i32:
    # Convert microseconds to year
    # Simplified: assume 1970 + (micros / microseconds_per_year)
    val seconds = micros / 1_000_000
    val years = seconds / (365 * 24 * 60 * 60)
    (1970 + years).to_i32()

fn timestamp_month(micros: i64) -> i32:
    # Simplified month calculation
    1

fn timestamp_day(micros: i64) -> i32:
    # Simplified day calculation
    1

fn timestamp_hour(micros: i64) -> i32:
    val seconds = micros / 1_000_000
    val hours = (seconds / 3600) % 24
    hours.to_i32()

fn timestamp_minute(micros: i64) -> i32:
    val seconds = micros / 1_000_000
    val minutes = (seconds / 60) % 60
    minutes.to_i32()

fn timestamp_second(micros: i64) -> i32:
    val seconds = micros / 1_000_000
    val secs = seconds % 60
    secs.to_i32()

# ============================================================================
# System Information - Pure Simple
# ============================================================================

fn getpid() -> i64:
    # Process ID - could be stored by runtime on startup
    # For now, return a fake PID
    12345

fn hostname() -> text:
    # Hostname - could be read from /etc/hostname in pure Simple
    "localhost"

fn cpu_count() -> i64:
    # CPU count - could be read from /proc/cpuinfo
    1

fn path_basename(path: text) -> text:
    # Pure Simple path manipulation
    val parts = path.split("/")
    if parts.len() > 0:
        parts[parts.len() - 1]
    else:
        path

# ============================================================================
# Additional System Functions
# ============================================================================

fn rt_file_rename(src: text, dst: text) -> bool:
    # Atomic file rename using mv
    val result = shell("mv '{src}' '{dst}'")
    result.exit_code == 0

fn rt_sleep_ms(milliseconds: i64):
    # Sleep for specified milliseconds
    val seconds = milliseconds / 1000
    val remainder = milliseconds % 1000
    if seconds > 0:
        shell("sleep {seconds}")
    if remainder > 0:
        shell("sleep 0.{remainder}")

fn rt_getpid() -> i64:
    # Get process ID using shell
    val result = shell("echo $$")
    if result.exit_code == 0:
        result.stdout.trim().parse_i64() ?? 12345
    else:
        12345

fn rt_timestamp_now() -> i64:
    # Return current timestamp in microseconds
    time_now_unix_micros()

# ============================================================================
# CLI Functions - Pure Simple Implementations
# ============================================================================

fn get_args() -> [String]:
    # Command line arguments - delegate to runtime
    rt_cli_get_args()

fn exit(code: i64):
    # Exit the program with given code - delegate to runtime
    rt_exit(code)

fn cli_get_args() -> [str]:
    # CLI arguments - delegate to runtime
    rt_cli_get_args()

fn cli_exit(code: i64):
    rt_exit(code)

fn cli_file_exists(path: str) -> bool:
    file_exists(path)

fn cli_read_file(path: str) -> str:
    file_read(path)

# ============================================================================
# CLI Command Handlers - To be implemented in Simple
# ============================================================================

fn cli_run_code(code: str, gc_log: bool, gc_off: bool) -> i64:
    print "=== Simple Code Execution ==="
    print "Code: {code}"
    print "Note: Interpreter would evaluate this code"
    1

fn cli_run_file(path: str, args: [str], gc_log: bool, gc_off: bool) -> i64:
    print "=== Simple File Execution ==="
    print "File: {path}"
    print "Args: {args}"
    print "Use: ./bin/simple_runtime {path}"
    1

fn cli_watch_file(path: str) -> i64:
    print "Watch mode not yet implemented in pure Simple"
    1

fn cli_run_repl(gc_log: bool, gc_off: bool) -> i64:
    print "=== Simple REPL ==="
    print "REPL not yet implemented in pure Simple"
    print ""
    print "For now, use: ./bin/simple_runtime yourfile.spl"
    1

fn cli_run_tests(args: [str], gc_log: bool, gc_off: bool) -> i64:
    print "Test runner not yet implemented in pure Simple"
    1

fn cli_run_lint(args: [str]) -> i64:
    print "Linter not yet implemented in pure Simple"
    1

fn cli_run_fmt(args: [str]) -> i64:
    print "Formatter not yet implemented in pure Simple"
    1

fn cli_run_fix(args: [str]) -> i64:
    print "Fix tool not yet implemented in pure Simple"
    1

fn cli_run_verify(args: [str], gc_log: bool, gc_off: bool) -> i64:
    print "Verifier not yet implemented in pure Simple"
    1

fn cli_run_migrate(args: [str]) -> i64:
    print "Migration tool not yet implemented in pure Simple"
    1

fn cli_run_mcp(args: [str]) -> i64:
    # Run MCP server using the dedicated MCP main.spl
    # args[0] is "mcp", so we skip it and pass args[1:]
    var cmd = "./bin/simple_runtime src/app/mcp/main.spl"
    var i = 1
    while i < args.len():
        cmd = cmd + " " + args[i]
        i = i + 1

    val result = shell(cmd)
    # Print the output from MCP server
    if result.stdout.len() > 0:
        print(result.stdout)
    if result.stderr.len() > 0:
        eprint(result.stderr)
    result.exit_code

fn cli_run_diff(args: [str]) -> i64:
    print "Diff tool not yet implemented in pure Simple"
    1

fn cli_constr(args: [str]) -> i64:
    print "Constraint checker not yet implemented in pure Simple"
    1

fn cli_run_query(args: [str]) -> i64:
    print "Query tool not yet implemented in pure Simple"
    1

fn cli_run_spec_coverage(args: [str]) -> i64:
    print "Spec coverage not yet implemented in pure Simple"
    1

fn cli_gen_lean(args: [str]) -> i64:
    print "Lean generator not yet implemented in pure Simple"
    1

fn cli_run_feature_gen(args: [str]) -> i64:
    print "Feature generator not yet implemented in pure Simple"
    1

fn cli_run_task_gen(args: [str]) -> i64:
    print "Task generator not yet implemented in pure Simple"
    1

fn cli_run_spec_gen(args: [str]) -> i64:
    print "Spec generator not yet implemented in pure Simple"
    1

fn cli_run_sspec_docgen(args: [str]) -> i64:
    print "SSpec doc generator not yet implemented in pure Simple"
    1

fn cli_run_todo_gen(args: [str]) -> i64:
    print "TODO generator not yet implemented in pure Simple"
    1

fn cli_todo_scan(args: [str]) -> i64:
    print "TODO scanner not yet implemented in pure Simple"
    1

fn cli_run_lex(args: [str]) -> i64:
    print "Lexer not yet implemented in pure Simple"
    1

fn cli_run_brief(args: [str]) -> i64:
    print "Brief tool not yet implemented in pure Simple"
    1

fn cli_run_ffi_gen(args: [str]) -> i64:
    print "FFI generator not yet implemented in pure Simple"
    1

fn cli_run_i18n(args: [str]) -> i64:
    print "i18n tool not yet implemented in pure Simple"
    1

fn cli_handle_web(args: [str]) -> i64:
    print "Web handler not yet implemented in pure Simple"
    1

fn cli_handle_diagram(args: [str]) -> i64:
    print "Diagram generator not yet implemented in pure Simple"
    1

fn cli_handle_run(args: [str], gc_log: bool, gc_off: bool) -> i64:
    if args.len() > 0:
        cli_run_file(args[0], args[1:], gc_log, gc_off)
    else:
        print "No file specified"
        1

fn cli_handle_linkers() -> i64:
    print "Linker information not yet implemented in pure Simple"
    1

fn cli_replay(args: [str]) -> i64:
    print "Replay tool not yet implemented in pure Simple"
    1

fn cli_check(args: [str]) -> i64:
    print "Type checker not yet implemented in pure Simple"
    1

fn cli_compile(args: [str]) -> i64:
    print "Compiler not yet implemented in pure Simple"
    1

fn cli_info(args: [str]) -> i64:
    print "Info tool not yet implemented in pure Simple"
    1

# ============================================================================
# Advanced Features - Pure Simple
# ============================================================================

fn context_generate(path: str, target: str, format: str) -> str:
    ""

fn context_stats(path: str, target: str) -> str:
    ""

fn settlement_main() -> i64:
    0

fn fault_set_stack_overflow_detection(enabled: bool):
    ()

fn fault_set_max_recursion_depth(depth: i64):
    ()

fn fault_set_timeout(secs: i64):
    ()

fn fault_set_execution_limit(limit: i64):
    ()

fn eprintln(msg: text):
    print "[STDERR] {msg}"

# ============================================================================
# Math Functions - Using shell bc for computation
# ============================================================================

fn math_exp(x: f64) -> f64:
    """Exponential function: e^x"""
    val result = shell("echo 'e({x})' | bc -l")
    if result.exit_code == 0:
        result.stdout.trim().to_float_or(0.0)
    else:
        0.0

fn math_ln(x: f64) -> f64:
    """Natural logarithm: ln(x)"""
    if x <= 0.0:
        return -999999.0  # Negative infinity approximation
    val result = shell("echo 'l({x})' | bc -l")
    if result.exit_code == 0:
        result.stdout.trim().to_float_or(0.0)
    else:
        0.0

fn math_sqrt(x: f64) -> f64:
    """Square root: sqrt(x)"""
    if x < 0.0:
        return 0.0  # NaN approximation
    val result = shell("echo 'sqrt({x})' | bc -l")
    if result.exit_code == 0:
        result.stdout.trim().to_float_or(0.0)
    else:
        0.0

fn math_cos(x: f64) -> f64:
    """Cosine: cos(x)"""
    val result = shell("echo 'c({x})' | bc -l")
    if result.exit_code == 0:
        result.stdout.trim().to_float_or(0.0)
    else:
        0.0

fn math_sin(x: f64) -> f64:
    """Sine: sin(x)"""
    val result = shell("echo 's({x})' | bc -l")
    if result.exit_code == 0:
        result.stdout.trim().to_float_or(0.0)
    else:
        0.0

fn math_random() -> f64:
    """Random number in [0, 1)"""
    # Use /dev/urandom for randomness
    val result = shell("od -An -N4 -tu4 /dev/urandom | awk '{print $1}'")
    if result.exit_code == 0:
        val rand_int = result.stdout.trim().to_int_or(0)
        # Normalize to [0, 1)
        rand_int / 4294967296.0  # 2^32
    else:
        0.5  # Fallback
