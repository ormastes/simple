# Memory Leak Finder - SDN Report Generation
#
# Generates SDN format output for leak reports.

use types
use shell.*

# Generate SDN report from leak report
fn generate_sdn_report(report: types.LeakReport) -> text:
    var output = ""

    # Header
    output = output + "# Memory Leak Finder Report\n"
    output = output + "# Generated: {report.timestamp}\n\n"

    # Summary section
    output = output + "leak_report:\n"
    output = output + "    timestamp: \"{report.timestamp}\"\n"
    output = output + "    test_type: \"{report.test_type}\"\n"
    output = output + "    total_tests: {report.total_tests}\n"
    output = output + "    baseline_memory_kb: {report.baseline_memory_kb}\n"
    output = output + "    final_memory_kb: {report.final_memory_kb}\n"
    output = output + "    total_growth_kb: {report.total_growth_kb()}\n"
    output = output + "    leak_count: {report.leak_count()}\n"
    output = output + "\n"

    # Leaks table
    output = output + "leaks |test_file, consecutive_count, growth_kb, first_test_index|\n"
    for leak in report.leaks:
        val escaped_file = escape_sdn_string(leak.test_file)
        output = output + "    \"{escaped_file}\", {leak.consecutive_count}, {leak.growth_kb}, {leak.first_test_index}\n"
    output = output + "\n"

    # Test runs table
    output = output + "test_runs |test_file, memory_before_kb, memory_after_kb, diff_kb, status, duration_ms|\n"
    for run in report.test_runs:
        val escaped_file = escape_sdn_string(run.test_file)
        output = output + "    \"{escaped_file}\", {run.memory_before_kb}, {run.memory_after_kb}, {run.diff_kb}, \"{run.status}\", {run.duration_ms}\n"

    output

# Escape string for SDN format
fn escape_sdn_string(s: text) -> text:
    s.replace("\\", "\\\\").replace("\"", "\\\"")

# Write report to file
fn write_report(report: types.LeakReport, path: text) -> Result<(), text>:
    val content = generate_sdn_report(report)
    file.write_text(path, content)
    Ok(())

# Print report to stdout
fn print_report(report: types.LeakReport):
    print(generate_sdn_report(report))

# Generate summary for console output
fn generate_summary(report: types.LeakReport) -> text:
    var output = "\n=== Memory Leak Finder Summary ===\n"
    output = output + "Test type: {report.test_type}\n"
    output = output + "Total tests: {report.total_tests}\n"
    output = output + "Baseline memory: {format_kb(report.baseline_memory_kb)}\n"
    output = output + "Final memory: {format_kb(report.final_memory_kb)}\n"

    val total_change = report.total_growth_kb()
    if total_change > 0:
        output = output + "Net memory freed: {format_kb(total_change)}\n"
    elif total_change < 0:
        output = output + "Net memory consumed: {format_kb(-total_change)}\n"
    else:
        output = output + "Net memory change: 0 KB\n"

    output = output + "\n"

    if report.has_leaks():
        output = output + "LEAKS DETECTED: {report.leak_count()}\n"
        output = output + "---\n"
        for leak in report.leaks:
            output = output + "  {leak.format()}\n"
    else:
        output = output + "No sustained memory leaks detected.\n"

    # Test status summary
    var ok_count = 0
    var failed_count = 0
    var timeout_count = 0
    for run in report.test_runs:
        if run.status == "ok":
            ok_count = ok_count + 1
        elif run.status == "failed":
            failed_count = failed_count + 1
        elif run.status == "timeout":
            timeout_count = timeout_count + 1

    output = output + "\nTest results: {ok_count} ok, {failed_count} failed, {timeout_count} timeout\n"

    output

# Format KB value with units
fn format_kb(kb: i64) -> text:
    if kb >= 1048576:  # >= 1 GB
        val gb = (kb as f64) / 1048576.0
        "{gb:.2} GB"
    elif kb >= 1024:   # >= 1 MB
        val mb = (kb as f64) / 1024.0
        "{mb:.2} MB"
    else:
        "{kb} KB"

# Export functions
export generate_sdn_report, escape_sdn_string, write_report, print_report
export generate_summary, format_kb
