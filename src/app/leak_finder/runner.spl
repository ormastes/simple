# Memory Leak Finder - Test Runner
#
# Executes individual tests with timeout and captures results.

use types
use discovery
use shell.*

# Timer for measuring elapsed time
use app.io.io (current_time_unix)

fn now_ms() -> i64:
    current_time_unix() * 1000

# Run a single test and return the result
fn run_test(test: discovery.DiscoveredTest, timeout_seconds: i32) -> types.TestRunResult:
    val start_time = now_ms()

    # Convert test type to string for reliable matching
    val type_str = types.test_type_to_string(test.test_type)
    var stdout = ""
    var stderr = ""
    var exit_code = -1

    if type_str == "simple":
        val result = run_simple_test(test.path, timeout_seconds)
        stdout = result.0
        stderr = result.1
        exit_code = result.2
    elif type_str == "sdoctest":
        val result = run_sdoctest_test(test.path, timeout_seconds)
        stdout = result.0
        stderr = result.1
        exit_code = result.2
    elif type_str == "rust":
        val result = run_rust_test(test.path, timeout_seconds)
        stdout = result.0
        stderr = result.1
        exit_code = result.2

    val end_time = now_ms()
    val duration_ms = end_time - start_time

    var status = "failed"
    if exit_code == 0:
        status = "ok"
    elif exit_code == 124:  # timeout exit code
        status = "timeout"

    types.TestRunResult(
        test_file: test.path,
        memory_before_kb: 0,  # Set by caller
        memory_after_kb: 0,   # Set by caller
        diff_kb: 0,           # Set by caller
        status: status,
        duration_ms: duration_ms
    )

# Run Simple test file
fn run_simple_test(path: text, timeout_seconds: i32) -> (text, text, i32):
    # Check if the simple binary exists
    var simple_binary = "simple"
    if file.exist("./target/debug/simple"):
        simple_binary = "./target/debug/simple"
    elif file.exist("./target/release/simple"):
        simple_binary = "./target/release/simple"

    # Run with timeout
    val args = [timeout_seconds.to_string() + "s", simple_binary, "test", path, "--sequential"]
    val result = shell.run("timeout", args)
    (result.stdout, result.stderr, result.exit_code as i32)

# Run SDoctest file
fn run_sdoctest_test(path: text, timeout_seconds: i32) -> (text, text, i32):
    var simple_binary = "simple"
    if file.exist("./target/debug/simple"):
        simple_binary = "./target/debug/simple"
    elif file.exist("./target/release/simple"):
        simple_binary = "./target/release/simple"

    val args = [timeout_seconds.to_string() + "s", simple_binary, "doctest", path]
    val result = shell.run("timeout", args)
    (result.stdout, result.stderr, result.exit_code as i32)

# Run Rust test
fn run_rust_test(test_name: text, timeout_seconds: i32) -> (text, text, i32):
    val args = [timeout_seconds.to_string() + "s", "cargo", "test", "--", test_name, "--exact", "--nocapture"]
    val result = shell.run("timeout", args)
    (result.stdout, result.stderr, result.exit_code as i32)

# Format test result for display
fn format_test_result(result: types.TestRunResult, verbose: bool) -> text:
    val status_icon = match result.status:
        case "ok": "+"
        case "timeout": "T"
        case "failed": "x"
        case _: "?"

    if verbose:
        var memory_change = "{result.diff_kb}"
        if result.diff_kb >= 0:
            memory_change = "+{result.diff_kb}"
        "[{status_icon}] {result.test_file} ({result.duration_ms}ms, mem: {memory_change} KB)"
    else:
        "[{status_icon}] {result.test_file}"

# Export functions
export run_test, run_simple_test, run_sdoctest_test, run_rust_test
export format_test_result
