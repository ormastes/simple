# Memory Leak Finder - Memory Reading
#
# Reads memory information from /proc/meminfo on Linux.

use shell.file

# Memory info structure
class MemoryInfo:
    mem_total_kb: i64
    mem_free_kb: i64
    mem_available_kb: i64
    buffers_kb: i64
    cached_kb: i64
    swap_total_kb: i64
    swap_free_kb: i64

    fn used_kb() -> i64:
        self.mem_total_kb - self.mem_available_kb

    fn swap_used_kb() -> i64:
        self.swap_total_kb - self.swap_free_kb

# Parse integer from string (simple implementation)
fn parse_int(s: text) -> i64:
    var result: i64 = 0
    for i in 0..s.len():
        val ch = s[i]
        if ch == "0":
            result = result * 10
        elif ch == "1":
            result = result * 10 + 1
        elif ch == "2":
            result = result * 10 + 2
        elif ch == "3":
            result = result * 10 + 3
        elif ch == "4":
            result = result * 10 + 4
        elif ch == "5":
            result = result * 10 + 5
        elif ch == "6":
            result = result * 10 + 6
        elif ch == "7":
            result = result * 10 + 7
        elif ch == "8":
            result = result * 10 + 8
        elif ch == "9":
            result = result * 10 + 9
    result

# Extract value from /proc/meminfo line
# Format: "KeyName:     12345 kB"
fn extract_value(line: text, key: text) -> i64:
    if not line.starts_with(key):
        return -1

    # Get the part after the key
    val after_key = line.slice(key.len())
    # Parse the number (skipping whitespace)
    parse_int(after_key.trim())

# Get available memory in KB from /proc/meminfo
fn get_available_memory() -> i64:
    val content = file.read_text("/proc/meminfo")
    if content == "":
        return -1

    for line in content.split("\n"):
        val mem = extract_value(line, "MemAvailable:")
        if mem > 0:
            return mem
    return -1

# Get full memory info from /proc/meminfo
fn get_memory_info() -> Option<MemoryInfo>:
    val content = file.read_text("/proc/meminfo")
    if content == "":
        return nil

    var mem_total: i64 = 0
    var mem_free: i64 = 0
    var mem_available: i64 = 0
    var buffers: i64 = 0
    var cached: i64 = 0
    var swap_total: i64 = 0
    var swap_free: i64 = 0

    for line in content.split("\n"):
        val val_total = extract_value(line, "MemTotal:")
        if val_total > 0:
            mem_total = val_total

        val val_free = extract_value(line, "MemFree:")
        if val_free > 0:
            mem_free = val_free

        val val_available = extract_value(line, "MemAvailable:")
        if val_available > 0:
            mem_available = val_available

        val val_buffers = extract_value(line, "Buffers:")
        if val_buffers > 0:
            buffers = val_buffers

        val val_cached = extract_value(line, "Cached:")
        if val_cached > 0:
            cached = val_cached

        val val_swap_total = extract_value(line, "SwapTotal:")
        if val_swap_total > 0:
            swap_total = val_swap_total

        val val_swap_free = extract_value(line, "SwapFree:")
        if val_swap_free > 0:
            swap_free = val_swap_free

    Some(MemoryInfo(
        mem_total_kb: mem_total,
        mem_free_kb: mem_free,
        mem_available_kb: mem_available,
        buffers_kb: buffers,
        cached_kb: cached,
        swap_total_kb: swap_total,
        swap_free_kb: swap_free
    ))

# Format memory size for display
fn format_memory_kb(kb: i64) -> text:
    if kb >= 1048576:  # >= 1 GB
        val gb_whole = kb / 1048576
        val gb_frac = (kb % 1048576) / 10485  # Two decimal places
        "{gb_whole}.{gb_frac} GB"
    elif kb >= 1024:   # >= 1 MB
        val mb_whole = kb / 1024
        val mb_frac = (kb % 1024) / 10  # Two decimal places
        "{mb_whole}.{mb_frac} MB"
    else:
        "{kb} KB"

# Check if memory reading is available (Linux only)
fn is_memory_available() -> bool:
    file.exist("/proc/meminfo")

# Export functions
export get_available_memory, get_memory_info, format_memory_kb, is_memory_available
export parse_int, extract_value
