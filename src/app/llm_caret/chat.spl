# LLM Caret - Chat Session Management
#
# Maintains conversation history in module-level state.
# Provides add, clear, truncate operations.

# ============================================================================
# JSON helpers (inlined)
# ============================================================================

fn _LB() -> text:
    (123 as char).to_text()

fn _RB() -> text:
    (125 as char).to_text()

fn _Q() -> text:
    "\""

fn _escape_json(s: text) -> text:
    var result = ""
    var i = 0
    while i < s.len():
        val ch = s[i]
        if ch == "\\":
            result = result + "\\\\"
        elif ch == "\"":
            result = result + "\\\""
        elif ch == "\n":
            result = result + "\\n"
        elif ch == "\r":
            result = result + "\\r"
        elif ch == "\t":
            result = result + "\\t"
        else:
            result = result + ch
        i = i + 1
    result

# ============================================================================
# Module-level state
# ============================================================================

var CHAT_ROLES: [text] = []
var CHAT_CONTENTS: [text] = []
var CHAT_SYSTEM_PROMPT = ""
var CHAT_MAX_HISTORY = 100

# ============================================================================
# History management
# ============================================================================

fn chat_clear():
    CHAT_ROLES = []
    CHAT_CONTENTS = []

fn chat_set_system_prompt(prompt: text):
    CHAT_SYSTEM_PROMPT = prompt

fn chat_get_system_prompt() -> text:
    CHAT_SYSTEM_PROMPT

fn chat_set_max_history(max_items: i64):
    CHAT_MAX_HISTORY = max_items

fn chat_add_message(role: text, content: text):
    CHAT_ROLES = CHAT_ROLES + [role]
    CHAT_CONTENTS = CHAT_CONTENTS + [content]
    # Truncate if over limit
    if CHAT_ROLES.len() > CHAT_MAX_HISTORY:
        chat_truncate(CHAT_MAX_HISTORY)

fn chat_add_user(content: text):
    chat_add_message("user", content)

fn chat_add_assistant(content: text):
    chat_add_message("assistant", content)

fn chat_history_len() -> i64:
    CHAT_ROLES.len()

fn chat_get_role(idx: i64) -> text:
    if idx >= 0 and idx < CHAT_ROLES.len():
        return CHAT_ROLES[idx]
    ""

fn chat_get_content(idx: i64) -> text:
    if idx >= 0 and idx < CHAT_CONTENTS.len():
        return CHAT_CONTENTS[idx]
    ""

fn chat_truncate(keep_last: i64):
    if CHAT_ROLES.len() <= keep_last:
        return
    val start = CHAT_ROLES.len() - keep_last
    var new_roles: [text] = []
    var new_contents: [text] = []
    var i = start
    while i < CHAT_ROLES.len():
        new_roles = new_roles + [CHAT_ROLES[i]]
        new_contents = new_contents + [CHAT_CONTENTS[i]]
        i = i + 1
    CHAT_ROLES = new_roles
    CHAT_CONTENTS = new_contents

# ============================================================================
# Build messages JSON from history
# ============================================================================

fn chat_build_messages_json() -> text:
    var items: [text] = []
    var i = 0
    while i < CHAT_ROLES.len():
        var msg = _LB()
        msg = msg + _Q() + "role" + _Q() + ":" + _Q() + CHAT_ROLES[i] + _Q() + ","
        msg = msg + _Q() + "content" + _Q() + ":" + _Q() + _escape_json(CHAT_CONTENTS[i]) + _Q()
        msg = msg + _RB()
        items = items + [msg]
        i = i + 1
    var result = "["
    var j = 0
    for item in items:
        if j > 0:
            result = result + ","
        result = result + item
        j = j + 1
    result = result + "]"
    result

# Get last message content (useful for getting the latest assistant reply)
fn chat_last_content() -> text:
    if CHAT_CONTENTS.len() == 0:
        return ""
    CHAT_CONTENTS[CHAT_CONTENTS.len() - 1]

fn chat_last_role() -> text:
    if CHAT_ROLES.len() == 0:
        return ""
    CHAT_ROLES[CHAT_ROLES.len() - 1]
