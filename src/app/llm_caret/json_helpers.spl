# LLM Caret - JSON Helpers
#
# JSON building and parsing utilities following mcp/helpers.spl patterns.
# Uses string concat (no f-strings) to avoid `}}` brace issues.

use std.text.{escape_json}
use std.mcp.helpers.{Q, LB, RB, js, jp}

# ============================================================================
# JSON Escaping
# ============================================================================

fn escape_json_text(s: text) -> text:
    escape_json(s)

# ============================================================================
# JSON Building Helpers
# ============================================================================


# JSON object with 1 pair
fn jo1(pair: text) -> text:
    var r = LB()
    r = r + pair
    r = r + RB()
    r

# JSON object with 2 pairs
fn jo2(p1: text, p2: text) -> text:
    var r = LB()
    r = r + p1
    r = r + ","
    r = r + p2
    r = r + RB()
    r

# JSON object with 3 pairs
fn jo3(p1: text, p2: text, p3: text) -> text:
    var r = LB()
    r = r + p1
    r = r + ","
    r = r + p2
    r = r + ","
    r = r + p3
    r = r + RB()
    r

# JSON object with 4 pairs
fn jo4(p1: text, p2: text, p3: text, p4: text) -> text:
    var r = LB()
    r = r + p1
    r = r + ","
    r = r + p2
    r = r + ","
    r = r + p3
    r = r + ","
    r = r + p4
    r = r + RB()
    r

# JSON object with 5 pairs
fn jo5(p1: text, p2: text, p3: text, p4: text, p5: text) -> text:
    var r = LB()
    r = r + p1
    r = r + ","
    r = r + p2
    r = r + ","
    r = r + p3
    r = r + ","
    r = r + p4
    r = r + ","
    r = r + p5
    r = r + RB()
    r

# JSON object with 6 pairs
fn jo6(p1: text, p2: text, p3: text, p4: text, p5: text, p6: text) -> text:
    var r = LB()
    r = r + p1 + ","
    r = r + p2 + ","
    r = r + p3 + ","
    r = r + p4 + ","
    r = r + p5 + ","
    r = r + p6
    r = r + RB()
    r

# JSON array from list of pre-formatted items
fn ja(items: [text]) -> text:
    var r = "["
    var i = 0
    for item in items:
        if i > 0:
            r = r + ","
        r = r + item
        i = i + 1
    r = r + "]"
    r

# ============================================================================
# JSON Parsing Helpers
# ============================================================================

fn _unwrap_idx(opt) -> i64:
    match opt:
        Some(i): return i
        nil: return -1

# Extract a string value for a given key from JSON
fn extract_json_string(json: text, key: text) -> text:
    val quote = "\""
    val search = quote + key + quote + ":"
    val idx = _unwrap_idx(json.index_of(search))
    if idx < 0:
        return ""
    val slen = search.len()
    val start = idx + slen
    val after = json.substring(start)
    val trimmed = after.trim()
    if trimmed.starts_with(quote):
        val rest = trimmed.substring(1)
        # Find unescaped closing quote
        var end = 0
        var escaped = false
        while end < rest.len():
            val ch = rest[end]
            if escaped:
                escaped = false
            elif ch == "\\":
                escaped = true
            elif ch == "\"":
                return rest.substring(0, end)
            end = end + 1
    ""

# Extract a raw value (number, boolean, null) for a given key from JSON
fn extract_json_value(json: text, key: text) -> text:
    val search = Q() + key + Q() + ":"
    val idx = _unwrap_idx(json.index_of(search))
    if idx < 0:
        return "null"
    val slen = search.len()
    val start = idx + slen
    val after = json.substring(start)
    val trimmed = after.trim()
    var end = 0
    while end < trimmed.len():
        val ch = trimmed[end]
        if ch == "," or ch == RB() or ch == "]":
            break
        end = end + 1
    trimmed.substring(0, end).trim()

# Extract integer value for a given key
fn extract_json_int(json: text, key: text) -> i64:
    val raw = extract_json_value(json, key)
    if raw == "null" or raw == "":
        return 0
    int(raw)

# Extract boolean value for a given key
fn extract_json_bool(json: text, key: text) -> bool:
    val raw = extract_json_value(json, key)
    raw == "true"

# Extract a nested string value: outer_key -> inner_key
fn extract_nested_string(json: text, outer_key: text, inner_key: text) -> text:
    val search = Q() + outer_key + Q() + ":"
    val idx = _unwrap_idx(json.index_of(search))
    if idx < 0:
        return ""
    val slen = search.len()
    val start = idx + slen
    val after = json.substring(start)
    extract_json_string(after, inner_key)

# ============================================================================
# Message JSON Building
# ============================================================================

# Build a single message as JSON object
fn build_message_json(role: text, content: text) -> text:
    jo2(jp("role", js(role)), jp("content", js(content)))

# Build messages array JSON from list of (role, content) pairs
fn build_messages_json(roles: [text], contents: [text]) -> text:
    var items: [text] = []
    var i = 0
    while i < roles.len():
        var r = roles[i]
        var c = ""
        if i < contents.len():
            c = contents[i]
        items = items + [build_message_json(r, c)]
        i = i + 1
    ja(items)
