# Simple Language Canonical Formatter
# Complete formatter with intelligent line breaking and method chaining
# Usage: simple_fmt <file.spl> [--check] [--write] [--diff]

# I/O imports
use app.io.mod (file_read, file_write, file_exists, get_args)
use std.text.{NL}

# Synchronous file I/O wrappers (runtime functions are synchronous)
fn read_file(path: String) -> Result<String, String>:
    val file_content = file_read(path)
    if file_content == "":
        return Err("Failed to read file: {path}")
    return Ok(file_content)

fn write_file(path: String, content: String) -> Result<Int, String>:
    file_write(path, content)
    # rt_file_write_text returns Unit; assume success if no exception
    return Ok(content.len())

# Helper function to find last occurrence of a substring
fn last_index_of(s: String, pattern: String) -> Option<Int>:
    """Find the last occurrence of pattern in string s.

    Returns:
        Some(index) - index of last occurrence
        nil - pattern not found

    Example:
        last_index_of("hello world hello", "hello") -> Some(12)
        last_index_of("test", "x") -> nil
    """
    if pattern.is_empty():
        return nil

    if s.len() < pattern.len():
        return nil

    # Search from end to beginning
    var i = s.len() - pattern.len()
    while i >= 0:
        # Check if pattern matches at position i
        var matches = true
        var j = 0
        while j < pattern.len():
            if s[i + j] != pattern[j]:
                matches = false
                break
            j = j + 1

        if matches:
            return Some(i)

        i = i - 1

    nil

class FormatConfig:
    indent_size: Int
    max_line_length: Int
    use_tabs: Bool
    blank_lines_between_items: Int
    continuation_indent: Int

class Formatter:
    config: FormatConfig
    indent_level: Int

    static fn with_defaults() -> Formatter:
        val config = FormatConfig(indent_size: 4, max_line_length: 100, use_tabs: false, blank_lines_between_items: 2, continuation_indent: 8)
        Formatter(config: config, indent_level: 0)

    fn format_file(self, path: String) -> Result<String, String>:
        # Read file using synchronous file I/O
        val source_content = read_file(path)
        match source_content:
            case Ok(content):
                val formatted = self.format_source(content)
                return formatted
            case Err(e):
                return Err(e)

    fn format_source(source: String) -> Result<String, String>:
        # First pass: Fix missing commas
        val fixed_commas = self.fix_missing_commas(source)

        # Second pass: Fix indentation errors before formatting
        val fixed_indent = self.fix_indentation(fixed_commas)

        val lines = fixed_indent.split(NL)

        # Separate imports from other content
        var imports = []
        var other_lines = []
        var in_import_section = true

        for line in lines:
            val trimmed = line.trim()

            if trimmed.starts_with("import "):
                imports.push(trimmed)
            elif trimmed.is_empty() and in_import_section:
                # Skip blank lines in import section
                continue
            else:
                if not trimmed.is_empty():
                    in_import_section = false
                other_lines.push(line)

        # Sort imports alphabetically
        imports.sort()

        # Format non-import code
        val formatted_code = self.format_code_lines(other_lines)
        match formatted_code:
            case Err(e):
                return Err(e)
            case Ok(code):
                # Combine sorted imports + blank lines + formatted code
                var result = []

                if imports.len() > 0:
                    for imp in imports:
                        result.push(imp)

                    # Add blank lines between imports and code
                    if other_lines.len() > 0:
                        var i = 0
                        while i < self.config.blank_lines_between_items:
                            result.push("")
                            i = i + 1

                result.extend(code)

                return Ok(result.join(NL))

    fn fix_missing_commas(source: String) -> String:
        # Fix missing commas in function parameters, array literals, and dict literals.
        # Patterns:
        # - fn name(a: Type b: Type) -> fn name(a: Type, b: Type)
        # - [1 2 3] -> [1, 2, 3]
        # - dict literals with missing commas
        var result = source

        # Fix missing commas in function parameters: "Type identifier" → "Type, identifier"
        # Pattern: ": Type identifier" where identifier is followed by ":"
        # This is a simplified regex-like replacement
        # For now, let's do basic text processing

        # Fix array literals: "number number" → "number, number"
        # Look for pattern: digit/] space digit/[
        result = self.fix_array_commas(result)

        # Fix dict literals: ": value key:" → ": value, key:"
        result = self.fix_dict_commas(result)

        # Fix function parameters: "Type name" → "Type, name" when followed by ":"
        result = self.fix_param_commas(result)

        return result

    fn fix_array_commas(text: String) -> String:
        """Fix missing commas in array literals like [1 2 3]"""
        var result = text
        # Simple heuristic: if we see "] digit" or "digit digit", add comma
        # This is simplified - a full implementation would use proper parsing
        # For now, just return unchanged - proper fix needs token-level work
        return result

    fn fix_dict_commas(text: String) -> String:
        # Fix missing commas in dict literals
        var result = text
        # Pattern: ": value identifier:" → ": value, identifier:"
        # This needs proper tokenization to implement correctly
        return result

    fn fix_param_commas(text: String) -> String:
        """Fix missing commas in function parameters like fn(a: i32 b: i32)"""
        var result = text
        # Pattern: "type name" where name is followed by ":"
        # This needs proper tokenization to implement correctly
        return result

    fn fix_indentation(source: String) -> String:
        """
        Fix indentation errors by recalculating proper indentation based on code structure.
        This allows formatting files that have indentation errors.
        """
        val lines = source.split(NL)
        var result = []
        var indent_level = 0
        var previous_line_ended_with_colon = false

        for line in lines:
            val trimmed = line.trim()

            # Skip empty lines
            if trimmed.is_empty():
                result.push("")
                continue

            # Check if previous line ended with colon (increases indent)
            if previous_line_ended_with_colon:
                indent_level = indent_level + 1
                previous_line_ended_with_colon = false

            # Check for dedent indicators (closing braces, return, break, etc.)
            if trimmed.starts_with("\}") or trimmed.starts_with("elif ") or trimmed.starts_with("else:") or trimmed.starts_with("case "):
                if indent_level > 0:
                    indent_level = indent_level - 1

            # Apply correct indentation
            val indent_str = " ".repeat(indent_level * self.config.indent_size)
            result.push(indent_str + trimmed)

            # Check if this line ends with colon (will increase indent for next line)
            if trimmed.ends_with(":"):
                previous_line_ended_with_colon = true

            # Check if this line is a dedent indicator for next line (return, break, continue, pass)
            if trimmed.starts_with("return ") or trimmed.starts_with("break") or trimmed.starts_with("continue") or trimmed.starts_with("pass"):
                if indent_level > 0:
                    indent_level = indent_level - 1

        return result.join(NL)

    fn format_code_lines(lines: [String]) -> Result<[String], String>:
        var result = []
        var last_was_def = false
        var blank_line_count = 0

        for line in lines:
            val trimmed = line.trim()

            # Skip empty lines but track them
            if trimmed.is_empty():
                blank_line_count = blank_line_count + 1
                if blank_line_count <= self.config.blank_lines_between_items:
                    result.push("")
                continue

            # Reset blank line counter
            blank_line_count = 0

            # Calculate source indentation level from leading spaces
            val source_indent = self.count_leading_spaces(line) / self.config.indent_size

            # Add blank lines before top-level definitions
            if source_indent == 0 and self.is_definition(trimmed) and last_was_def:
                var i = 0
                while i < self.config.blank_lines_between_items:
                    result.push("")
                    i = i + 1

            # Format line with source-derived indent
            val formatted_lines = self.format_line(trimmed, source_indent)

            # Add all formatted lines (may be multiple if line breaking occurred)
            for fmt_line in formatted_lines:
                result.push(fmt_line)

            # Track if this was a definition
            last_was_def = source_indent == 0 and self.is_definition(trimmed)

        return Ok(result)

    fn count_leading_spaces(line: String) -> Int:
        var count = 0
        for char in line:
            if char == ' ':
                count = count + 1
            elif char == '\t':
                count = count + self.config.indent_size
            else:
                break
        return count

    fn is_definition(line: String) -> Bool:
        if line.starts_with("fn "):
            return true
        if line.starts_with("class "):
            return true
        if line.starts_with("struct "):
            return true
        if line.starts_with("enum "):
            return true
        if line.starts_with("trait "):
            return true
        if line.starts_with("impl "):
            return true
        return false

    fn format_line(line: String, indent: Int) -> [String]:
        # Apply indentation
        val indent_str = " ".repeat(indent * self.config.indent_size)

        # Apply expression spacing
        val spaced = self.add_expression_spacing(line)

        # Check if line needs breaking
        val full_line = indent_str + spaced

        if full_line.len() > self.config.max_line_length:
            # Line too long - apply intelligent breaking
            return self.break_long_line(spaced, indent)
        else:
            return [full_line]

    fn break_long_line(line: String, base_indent: Int) -> [String]:
        val indent_str = " ".repeat(base_indent * self.config.indent_size)
        val continuation_str = " ".repeat((base_indent * self.config.indent_size) + self.config.continuation_indent)

        # Check for method chaining (contains multiple dots)
        if self.is_method_chain(line):
            return self.break_method_chain(line, indent_str, continuation_str)

        # Check for function signature (contains "fn " and "->")
        if line.starts_with("fn ") and line.contains("->"):
            return self.break_function_signature(line, indent_str, continuation_str)

        # Check for function call with many arguments
        if line.contains("(") and line.contains(")"):
            return self.break_function_call(line, indent_str, continuation_str)

        # Check for list/dict literal
        val has_brackets = line.contains("[") or line.contains("\{")
        val has_close = line.contains("]") or line.contains("\}")
        if has_brackets and has_close:
            return self.break_collection(line, indent_str, continuation_str)

        # Default: break at logical operators
        return self.break_at_operators(line, indent_str, continuation_str)

    fn is_method_chain(line: String) -> Bool:
        # Check if line has multiple dots (method chaining)
        var dot_count = 0
        for char in line:
            if char == '.':
                dot_count = dot_count + 1

        return dot_count >= 2

    fn break_method_chain(line: String, indent_str: String, continuation_str: String) -> [String]:
        # Break method chains so each method call is on its own line
        var result = []
        val parts = line.split(".")
        var first = true

        for part in parts:
            if first:
                result.push(indent_str + part)
                first = false
            else:
                result.push(continuation_str + "." + part.trim())

        return result

    fn remove_trailing_comma(lines: [String]) -> [String]:
        """Remove trailing comma from last line in a list."""
        if lines.len() > 1:
            val last_idx = lines.len() - 1
            val last_line = lines[last_idx]
            if last_line.ends_with(","):
                var result = lines
                result[last_idx] = last_line.substring(0, last_line.len() - 1)
                return result
        lines

    fn break_delimited_content(
        line: String,
        indent_str: String,
        continuation_str: String,
        open_delim: String,
        close_delim: String,
        skip_empty: bool
    ) -> [String]:
        """Generic helper to break content within delimiters across multiple lines."""
        if not line.contains(open_delim):
            return [indent_str + line]

        val delim_start_opt = line.index_of(open_delim)
        val delim_end_opt = line.index_of(close_delim)

        match delim_start_opt:
            case nil:
                return [indent_str + line]
            case Some(delim_start):
                match delim_end_opt:
                    case nil:
                        return [indent_str + line]
                    case Some(delim_end):
                        if delim_end < delim_start:
                            return [indent_str + line]

                        val before = line.substring(0, delim_start + 1)
                        val content = line.substring(delim_start + 1, delim_end)
                        val after = line.substring(delim_end, line.len())

                        # Check if it fits on one line
                        val one_line = indent_str + before + content + after
                        if one_line.len() <= self.config.max_line_length:
                            return [one_line]

                        # Break items across multiple lines
                        var result = []
                        result.push(indent_str + before)

                        val items = content.split(",")
                        for item in items:
                            val trimmed = item.trim()
                            if skip_empty and trimmed.is_empty():
                                pass
                            else:
                                result.push(continuation_str + trimmed + ",")

                        # Remove trailing comma from last item
                        result = self.remove_trailing_comma(result)
                        result.push(indent_str + after)
                        return result

    fn break_function_signature(line: String, indent_str: String, continuation_str: String) -> [String]:
        """Break function signature at parameter list."""
        self.break_delimited_content(line, indent_str, continuation_str, "(", ")", false)

    fn break_function_call(line: String, indent_str: String, continuation_str: String) -> [String]:
        """Break long function calls across multiple lines."""
        self.break_delimited_content(line, indent_str, continuation_str, "(", ")", true)

    fn break_collection(line: String, indent_str: String, continuation_str: String) -> [String]:
        """Break collections (lists, dicts, arrays) across multiple lines."""
        var open_delim = "["
        var close_delim = "]"
        if line.contains("\{"):
            open_delim = "\{"
            close_delim = "\}"
        self.break_delimited_content(line, indent_str, continuation_str, open_delim, close_delim, true)

    fn break_at_operators(line: String, indent_str: String, continuation_str: String) -> [String]:
        # Default line breaking: break at logical operators
        val operators = [" and ", " or ", " + ", " - ", " * ", " / "]
        var best_break = -1
        var best_op = ""

        for op in operators:
            if line.contains(op):
                val idx_opt = line.index_of(op)
                match idx_opt:
                    case Some(idx):
                        if idx > best_break:
                            best_break = idx
                            best_op = op
                    case nil:
                        pass

        if best_break > 0:
            val first_part = line.substring(0, best_break)
            val second_part = line.substring(best_break + best_op.len(), line.len())

            return [
                indent_str + first_part + best_op,
                continuation_str + second_part
            ]

        # No good break point found - return as is
        return [indent_str + line]

    fn add_expression_spacing(line: String) -> String:
        # Add spaces around binary operators
        var result = line

        # First, protect multi-character operators by replacing them with placeholders
        result = result.replace("->", "@ARROW@")
        result = result.replace("=>", "@FATARROW@")
        result = result.replace("==", "@EQ@")
        result = result.replace("!=", "@NE@")
        result = result.replace("<=", "@LE@")
        result = result.replace(">=", "@GE@")

        # Now process single-char operators safely
        val operators = ["+", "-", "*", "/", "%", "<", ">"]
        for op in operators:
            result = result.replace(op, " " + op + " ")

        # Restore multi-character operators with proper spacing
        result = result.replace("@ARROW@", " -> ")
        result = result.replace("@FATARROW@", " => ")
        result = result.replace("@EQ@", " == ")
        result = result.replace("@NE@", " != ")
        result = result.replace("@LE@", " <= ")
        result = result.replace("@GE@", " >= ")

        # Clean up multiple spaces
        while result.contains("  "):
            result = result.replace("  ", " ")

        # Clean up spaces in specific contexts
        result = result.replace("( ", "(")
        result = result.replace(" )", ")")
        result = result.replace("[ ", "[")
        result = result.replace(" ]", "]")
        result = result.replace(" ,", ",")
        result = result.replace(", ", ",")
        result = result.replace(",", ", ")

        # Clean up function signatures (colon spacing)
        result = result.replace(" :", ":")

        # Clean up dots (no spaces around dots in method calls)
        result = result.replace(" .", ".")
        result = result.replace(". ", ".")

        return result.trim()

    fn is_indent_line(line: String) -> Bool:
        # Check if line should increase indent level
        if line.ends_with(":"):
            return true
        if line.ends_with("\{"):
            return true
        if line.ends_with("("):
            return true
        if line.ends_with("["):
            return true
        return false

    fn is_dedent_line(line: String) -> Bool:
        # Check if line should decrease indent level
        if line.starts_with("\}"):
            return true
        if line.starts_with(")"):
            return true
        if line.starts_with("]"):
            return true
        if line.starts_with("else"):
            return true
        if line.starts_with("elif"):
            return true
        if line.starts_with("except"):
            return true
        if line.starts_with("finally"):
            return true
        return false

fn format_file_inplace(path: String) -> Result<String, String>:
    val fmt_instance = make_formatter()

    val format_output = fmt_instance.format_file(path)
    match format_output:
        case Err(e):
            return Err(e)
        case Ok(formatted):
            val write_status = write_file(path, formatted)
            match write_status:
                case Ok(_):
                    return Ok("Formatted successfully")
                case Err(e):
                    return Err(e)

fn check_formatting(path: String) -> Result<Bool, String>:
    val check_formatter = make_formatter()

    val original_content = read_file(path)
    match original_content:
        case Err(e):
            return Err(e)
        case Ok(original):
            val formatted_output = check_formatter.format_source(original)
            match formatted_output:
                case Err(e):
                    return Err(e)
                case Ok(formatted):
                    return Ok(original == formatted)

fn print_diff(original: String, formatted: String, file_path: String):
    """Print unified diff between original and formatted code"""
    print("--- " + file_path + " (original)")
    print("+++ " + file_path + " (formatted)")
    print("")

    val orig_lines = original.split(NL)
    val fmt_lines = formatted.split(NL)

    val max_len = orig_lines.len()
    if fmt_lines.len() > max_len:
        max_len = fmt_lines.len()

    var i = 0
    while i < max_len:
        if i < orig_lines.len() and i < fmt_lines.len():
            if orig_lines[i] != fmt_lines[i]:
                val line_num = i + 1
                print("@@ Line " + line_num.to_string() + " @@")
                print("-" + orig_lines[i])
                print("+" + fmt_lines[i])
        elif i < orig_lines.len():
            val line_num = i + 1
            print("@@ Line " + line_num.to_string() + " @@")
            print("-" + orig_lines[i])
        else:
            val line_num = i + 1
            print("@@ Line " + line_num.to_string() + " @@")
            print("+" + fmt_lines[i])
        i = i + 1


fn print_usage():
    print("Simple Language Canonical Formatter")
    print("=====================================")
    print("")
    print("Usage: simple_fmt <file.spl> [OPTIONS]")
    print("")
    print("Options:")
    print("  --check     Check if file is formatted (exit 1 if not)")
    print("  --write     Format file in place")
    print("  --diff      Show formatting diff")
    print("  --stdout    Print formatted output to stdout (default)")
    print("")
    print("Features:")
    print("  - Automatic import sorting (alphabetical)")
    print("  - Expression spacing (x + y, not x+y)")
    print("  - Blank lines between definitions (2 lines)")
    print("  - Consistent indentation (4 spaces)")
    print("  - Intelligent line breaking (100 char limit)")
    print("  - Method chaining alignment")
    print("  - Function signature formatting")
    print("  - Collection formatting (arrays, dicts)")

fn make_formatter() -> Formatter:
    Formatter.with_defaults()

fn main() -> Int:
    val args = get_args()

    if args.len() < 2:
        print_usage()
        return 1

    val file_path = args[1]
    val check_mode = args.contains("--check")
    val write_mode = args.contains("--write")
    val diff_mode = args.contains("--diff")

    # Verify file exists
    if not native_fs_exists(file_path):
        print("Error: File not found: " + file_path)
        return 1

    if check_mode:
        val check_result = check_formatting(file_path)
        match check_result:
            case Ok(is_formatted):
                if is_formatted:
                    print("OK " + file_path + " is formatted")
                    return 0
                else:
                    print("FAIL " + file_path + " needs formatting")
                    return 1
            case Err(error):
                print("Error: " + error)
                return 1

    elif write_mode:
        val inplace_result = format_file_inplace(file_path)
        match inplace_result:
            case Ok(_):
                print("OK Formatted " + file_path)
                return 0
            case Err(error):
                print("Error: " + error)
                return 1

    elif diff_mode:
        val diff_formatter = make_formatter()
        val diff_read = read_file(file_path)
        match diff_read:
            case Err(e):
                print("Error reading file: " + e)
                return 1
            case Ok(original):
                val diff_format = diff_formatter.format_source(original)
                match diff_format:
                    case Err(e):
                        print("Error: " + e)
                        return 1
                    case Ok(formatted):
                        if original == formatted:
                            print("OK " + file_path + " is correctly formatted")
                            return 0
                        else:
                            print_diff(original, formatted, file_path)
                            return 1

    else:
        val stdout_formatter = make_formatter()
        val stdout_result = stdout_formatter.format_file(file_path)
        match stdout_result:
            case Ok(formatted):
                print(formatted)
                return 0
            case Err(error):
                print("Error: " + error)
                return 1

    return 0
