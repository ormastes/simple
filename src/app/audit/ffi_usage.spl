#!/usr/bin/env simple
# FFI Usage Audit Script
# Finds direct FFI calls (rt_*) without wrappers
# Migrated from scripts/audit_ffi_usage.sh

use app.io
use app.utils.colors (success, error, warning, info)
use app.utils.markdown (MarkdownBuilder)

export main, audit_ffi_usage

struct AuditResults:
    extern_fns: [(text, i64, text)]      # (file, line, name)
    wrappers: [(text, text, text)]       # (file, wrapper_name, rt_name)
    direct_calls: [(text, i64, text)]    # (file, line, content)

fn main():
    val result = audit_ffi_usage()
    if not result:
        exit(1)

fn audit_ffi_usage() -> bool:
    """Audit FFI usage and generate report"""

    print "=== FFI Usage Audit ==="
    print ""

    # Step 1: Find all extern fn declarations
    print "Step 1: Finding extern fn rt_* declarations..."
    val extern_fns = find_extern_declarations()
    print "Found {extern_fns.len()} extern fn declarations"
    print ""

    # Step 2: Find all wrapper functions
    print "Step 2: Finding wrapper functions..."
    val wrappers = find_wrapper_functions()
    print "Found {wrappers.len()} wrapper functions"
    print ""

    # Step 3: Find direct rt_* calls
    print "Step 3: Finding direct FFI calls..."
    val direct_calls = find_direct_ffi_calls()
    print "Found {direct_calls.len()} potential direct FFI calls"
    print ""

    # Step 4: Generate report
    print "Step 4: Generating report..."
    val results = AuditResults(
        extern_fns: extern_fns,
        wrappers: wrappers,
        direct_calls: direct_calls
    )
    val report = generate_report(results)

    if not is_dir("doc/report"):
        dir_create("doc/report", recursive: true)

    file_write("doc/report/ffi_direct_calls.md", report)

    print success("Report saved to: doc/report/ffi_direct_calls.md")
    print ""
    print "Summary:"
    print "  - Extern declarations: {extern_fns.len()}"
    print "  - Wrapper functions: {wrappers.len()}"
    print "  - Direct FFI calls: {direct_calls.len()}"
    print ""
    print "Next steps:"
    print "  1. Review report: cat doc/report/ffi_direct_calls.md"
    print "  2. Fix direct calls by using wrappers or creating them"
    print "  3. Add TODO comments where needed"

    true

fn find_extern_declarations() -> [(text, i64, text)]:
    """Find all extern fn rt_* declarations"""
    var declarations = []

    val paths = ["src/", "rust/lib/std/src/"]
    for path in paths:
        if not is_dir(path):
            continue

        val files = find_spl_files(path)
        for file in files:
            if file.contains("/core/"):
                continue

            val content = file_read(file)
            val lines = content.split("\n")

            for i in 0..lines.len():
                val line = lines[i].trim()
                if line.starts_with("extern fn rt_"):
                    val func_name = extract_function_name_from_extern(line)
                    if func_name.len() > 0:
                        declarations = declarations + [(file, i + 1, func_name)]

    declarations

fn find_wrapper_functions() -> [(text, text, text)]:
    """Find wrapper functions that call rt_* functions"""
    var wrappers = []

    val paths = ["src/", "rust/lib/std/src/"]
    for path in paths:
        if not is_dir(path):
            continue

        val files = find_spl_files(path)
        for file in files:
            if file.contains("/core/"):
                continue

            val content = file_read(file)
            val lines = content.split("\n")

            var current_fn = ""
            for line in lines:
                val trimmed = line.trim()

                # Check for function definition
                if trimmed.starts_with("fn ") and trimmed.contains("("):
                    current_fn = extract_function_name(trimmed)
                # Check for rt_* call
                elif current_fn.len() > 0 and trimmed.contains("rt_"):
                    val rt_name = extract_rt_call(trimmed)
                    if rt_name.len() > 0:
                        wrappers = wrappers + [(file, current_fn, rt_name)]
                        current_fn = ""  # Reset after finding call

    wrappers

fn find_direct_ffi_calls() -> [(text, i64, text)]:
    """Find direct FFI calls (not in extern declarations, not in wrappers)"""
    var direct_calls = []

    val paths = ["src/", "test/", "rust/lib/std/src/"]
    for path in paths:
        if not is_dir(path):
            continue

        val files = find_spl_files(path)
        for file in files:
            # Skip excluded files
            if file.contains("/core/") or
               file.ends_with("/ffi.spl") or
               file.ends_with("io/mod.spl"):
                continue

            val content = file_read(file)
            val lines = content.split("\n")

            for i in 0..lines.len():
                val line = lines[i]
                val trimmed = line.trim()

                # Skip extern declarations and comments
                if trimmed.starts_with("extern fn rt_") or
                   trimmed.starts_with("#"):
                    continue

                # Check for rt_* calls
                if trimmed.contains("rt_") and trimmed.contains("("):
                    direct_calls = direct_calls + [(file, i + 1, trimmed)]

    direct_calls

fn find_spl_files(directory: text) -> [text]:
    """Find all .spl files recursively"""
    val (stdout, _, code) = process_run("find",
        [directory, "-name", "*.spl", "-type", "f"])

    if code != 0:
        return []

    val lines = stdout.split("\n")
    var files = []
    for line in lines:
        val trimmed = line.trim()
        if trimmed.len() > 0:
            files = files + [trimmed]
    files

fn extract_function_name_from_extern(line: text) -> text:
    """Extract function name from extern fn declaration"""
    # Pattern: extern fn rt_name(
    val start = line.find("extern fn ")
    if start < 0:
        return ""

    val after_fn = line.substring(start + 10, line.len())
    val paren_idx = after_fn.find("(")
    if paren_idx > 0:
        return after_fn.substring(0, paren_idx).trim()

    ""

fn extract_function_name(line: text) -> text:
    """Extract function name from fn declaration"""
    # Pattern: fn name(
    val start = line.find("fn ")
    if start < 0:
        return ""

    val after_fn = line.substring(start + 3, line.len())
    val paren_idx = after_fn.find("(")
    if paren_idx > 0:
        return after_fn.substring(0, paren_idx).trim()

    ""

fn extract_rt_call(line: text) -> text:
    """Extract rt_* function name from call"""
    # Find rt_ pattern
    val rt_idx = line.find("rt_")
    if rt_idx < 0:
        return ""

    var func_name = "rt_"
    var i = rt_idx + 3

    while i < line.len():
        val ch = line[i]
        if (ch >= 'a' and ch <= 'z') or ch == '_':
            func_name = func_name + "{ch}"
            i = i + 1
        else:
            break

    if i < line.len() and line[i] == '(':
        return func_name

    ""

fn generate_report(results: AuditResults) -> text:
    """Generate markdown report"""
    var md = MarkdownBuilder(content: "")

    md.h1("Direct FFI Calls Without Wrappers - Audit Report")

    md.h2("Summary")
    md.paragraph("This report identifies all direct calls to FFI functions (rt_*) that should ideally use SFFI wrapper functions.")

    md.h2("FFI Call Analysis")
    md.h3("Direct FFI Calls by File")

    # Group by file
    var current_file = ""
    for call in results.direct_calls:
        val file = call.0
        val line_num = call.1
        val content = call.2

        if file != current_file:
            md.h4("`{file}`")
            current_file = file

        val rt_func = extract_rt_call(content)
        md.append("- **Line {line_num}**: `{rt_func}()`\n")
        md.code_block(content.trim(), "simple")

    md.h2("Wrapper Functions Found")
    md.paragraph("The following wrapper functions were detected:")

    for wrapper in results.wrappers:
        val wrapper_name = wrapper.1
        val rt_name = wrapper.2
        md.append("- `{wrapper_name}()` → wraps `{rt_name}()`\n")

    # Add recommendations
    md.h2("Recommendations")
    md.h3("Pattern 1: Use Existing Wrapper")
    md.paragraph("If a wrapper exists, import and use it:")
    md.code_block("# ❌ Before (direct FFI call)
extern fn rt_file_exists(path: text) -> bool
val exists = rt_file_exists(path)

# ✅ After (use wrapper)
use app.io.{file_exists}
val exists = file_exists(path)", "simple")

    md.h3("Pattern 2: Create Missing Wrapper")
    md.paragraph("If no wrapper exists, add it to the appropriate FFI module:")
    md.paragraph("**In `src/lib/ffi/` or `src/compiler/ffi.spl`:**")
    md.code_block("# Tier 1: Extern declaration
extern fn rt_new_function(arg: text) -> i64

# Tier 2: Wrapper function
fn new_function(arg: text) -> i64:
    rt_new_function(arg)

# Export
export new_function", "simple")

    md.to_string()
