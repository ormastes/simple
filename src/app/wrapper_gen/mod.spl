# Wrapper Generator - Main Entry Point
#
# Generates SFFI wrappers for external libraries using the three-tier pattern.
# Supports both C++ libraries (via cxx bridge) and Rust crates (direct FFI).
#
# Input: Wrapper spec file (.wrapper_spec)
# Output:
#   - Tier 1: Native wrapper (.build/rust/ffi_<lib>/)
#     - lang: cpp  -> Rust + cxx bridge + C++ (bridge.h, bridge.cpp, lib.rs)
#     - lang: rust -> Direct Rust FFI with handle tables (lib.rs only)
#   - Tier 2: Simple SFFI bindings (src/lib/<lib>/ffi.spl)
#   - Tier 3: Simple API scaffold (src/lib/<lib>/mod.spl)
#
# Usage:
#   simple wrapper-gen <spec_file> [OPTIONS]
#
# Options:
#   --tier=1|2|3|all    Generate specific tier or all (default: all)
#   --output=<dir>      Output directory (default: auto-detect)
#   --dry-run           Print generated code without writing
#   --verbose           Enable verbose logging
#   --verify            Verify Rust code compiles
#   --help              Show this help message
#
# Example:
#   simple wrapper-gen torch.wrapper_spec --dry-run
#   simple wrapper-gen regex.wrapper_spec --tier=1 --dry-run

use app.io.{file_read, file_write, file_exists, dir_create_all, print}
use std.cli.cli_util.{get_cli_args}

# Import wrapper generator modules
use app.wrapper_gen.spec_parser.{parse_wrapper_spec, WrapperSpec}
use app.wrapper_gen.tier1_gen.{generate_tier1}
use app.wrapper_gen.tier1_rust_gen.{generate_tier1_rust}
use app.wrapper_gen.tier2_gen.{generate_tier2}
use app.wrapper_gen.tier3_gen.{generate_tier3}

# ============================================================================
# CLI Options
# ============================================================================

class WrapperGenOptions:
    spec_file: text
    tier: text
    dry_run: bool
    verbose: bool
    verify: bool
    show_help: bool

fn parse_args(args: [text]) -> WrapperGenOptions:
    var spec_file = ""
    var tier = "all"
    var dry_run = false
    var verbose = false
    var verify = false
    var show_help = false

    for arg in args:
        if arg == "-h" or arg == "--help":
            show_help = true
        elif arg == "--dry-run":
            dry_run = true
        elif arg == "--verbose":
            verbose = true
        elif arg == "--verify":
            verify = true
        elif arg.starts_with("--tier="):
            tier = arg[7:]
        elif not arg.starts_with("--") and not arg.starts_with("-"):
            spec_file = arg

    WrapperGenOptions(
        spec_file: spec_file,
        tier: tier,
        dry_run: dry_run,
        verbose: verbose,
        verify: verify,
        show_help: show_help
    )

# ============================================================================
# Main Entry Point
# ============================================================================

fn main():
    val args = get_cli_args()
    val opts = parse_args(args)

    if opts.show_help:
        print_help()
        return

    if opts.spec_file == "":
        print "Error: No spec file provided"
        print "Usage: simple wrapper-gen <spec_file> [OPTIONS]"
        return

    if not file_exists(opts.spec_file):
        print "Error: Spec file not found: {opts.spec_file}"
        return

    # Parse spec file
    val content = file_read(opts.spec_file)
    val spec = parse_wrapper_spec(content)

    if opts.verbose:
        print "Parsed spec for library: {spec.name} (lang: {spec.lang})"
        print "Handle types: {spec.handle_types.len()}"
        print "Functions: {spec.functions.len()}"
        print "Methods: {spec.methods.len()}"

    # Generate requested tiers
    if opts.tier == "1" or opts.tier == "all":
        if spec.lang == "rust":
            generate_tier1_rust(spec, opts.dry_run)
        else:
            generate_tier1(spec, opts.dry_run)

    if opts.tier == "2" or opts.tier == "all":
        generate_tier2(spec, opts.dry_run)

    if opts.tier == "3" or opts.tier == "all":
        generate_tier3(spec, opts.dry_run)

    if not opts.dry_run:
        print "Wrapper generation complete for '{spec.name}'"

# ============================================================================
# Help
# ============================================================================

fn print_help():
    print "Simple SFFI Wrapper Generator"
    print ""
    print "Generates three-tier SFFI wrappers for external libraries"
    print ""
    print "Usage: simple wrapper-gen <spec_file> [OPTIONS]"
    print ""
    print "Options:"
    print "  --tier=1|2|3|all   Generate specific tier (default: all)"
    print "  --dry-run          Print code without writing files"
    print "  --verbose          Enable verbose output"
    print "  --verify           Verify Rust code compiles"
    print "  -h, --help         Show this help"
    print ""
    print "Tiers:"
    print "  1 - Native wrapper (.build/rust/ffi_<lib>/)"
    print "      lang: cpp  -> cxx bridge + C++ (for C++ libraries)"
    print "      lang: rust -> Direct Rust FFI (for Rust crates)"
    print "  2 - Simple SFFI bindings (src/lib/<lib>/ffi.spl)"
    print "  3 - Simple API scaffold (src/lib/<lib>/mod.spl)"
    print ""
    print "Spec file lang field:"
    print "  lang: cpp   Use cxx bridge for C++ libraries (default)"
    print "  lang: rust  Use direct Rust FFI for Rust crates"
    print ""
    print "Examples:"
    print "  simple wrapper-gen torch.wrapper_spec --dry-run        # C++ lib"
    print "  simple wrapper-gen regex.wrapper_spec --tier=1 --dry-run  # Rust crate"
    print "  simple wrapper-gen torch.wrapper_spec --verbose"

export main
export print_help
