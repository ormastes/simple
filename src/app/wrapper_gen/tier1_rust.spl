# Tier 1 Generator - Rust Code Generation
#
# Generates src/lib.rs with cxx bridge module and C ABI export functions.

use app.io.{file_write, print}
use app.wrapper_gen.spec_parser.{WrapperSpec, FunctionSpec, MethodSpec}
use app.wrapper_gen.tier1_helpers.{is_handle_type, qualified_fn_name, is_void_return}
use app.wrapper_gen.tier1_types.{map_type_to_cxx, map_return_to_cxx, map_type_to_c_abi, map_return_to_c_abi, default_return_value}
use std.text.{NL}

# ============================================================================
# lib.rs Generation (Rust with cxx bridge + complete C ABI exports)
# ============================================================================

fn generate_lib_rs(spec: WrapperSpec, output_dir: text, dry_run: bool):
    var content = ""
    content = content + "// Auto-generated Rust wrapper for {spec.name} using cxx{NL}{NL}"
    content = content + "use cxx::UniquePtr;{NL}"
    content = content + "use std::ffi::{CStr, CString};{NL}"
    content = content + "use std::os::raw::c_char;{NL}{NL}"

    # cxx bridge module
    content = content + "#[cxx::bridge]{NL}"
    content = content + "mod ffi {{NL}"
    content = content + "    unsafe extern \"C++\" {{NL}"
    content = content + "        include!(\"simple-{spec.name}/src/bridge.h\");{NL}{NL}"

    # Opaque types
    for handle in spec.handle_types:
        content = content + "        type {handle.name};{NL}"
    content = content + NL

    # Functions as free functions in cxx bridge
    for func in spec.functions:
        content = content + gen_cxx_fn_decl(func, spec)
    content = content + NL

    # Methods as free functions in cxx bridge
    for method in spec.methods:
        content = content + gen_cxx_method_decl(method, spec)
    content = content + NL

    # Library info functions
    content = content + "        // Library info{NL}"
    content = content + "        fn {spec.name}_available() -> bool;{NL}"
    content = content + "        fn {spec.name}_version() -> String;{NL}"

    content = content + "    }{NL}"
    content = content + "}{NL}{NL}"

    # Opaque handle structs for C ABI
    for handle in spec.handle_types:
        content = content + "/// Opaque handle for Simple FFI{NL}"
        content = content + "#[repr(C)]{NL}"
        content = content + "pub struct Simple{handle.name} {{NL}"
        content = content + "    inner: UniquePtr<ffi::{handle.name}>,{NL}"
        content = content + "}{NL}{NL}"

    # ---- Library info C ABI exports ----
    content = content + "// ============================================================================{NL}"
    content = content + "// Library Info{NL}"
    content = content + "// ============================================================================{NL}{NL}"

    content = content + "#[no_mangle]{NL}"
    content = content + "pub extern \"C\" fn rt_{spec.name}_available() -> bool {{NL}"
    content = content + "    ffi::{spec.name}_available(){NL}"
    content = content + "}{NL}{NL}"

    content = content + "#[no_mangle]{NL}"
    content = content + "pub extern \"C\" fn rt_{spec.name}_version() -> *mut c_char {{NL}"
    content = content + "    let version = ffi::{spec.name}_version();{NL}"
    content = content + "    CString::new(version).unwrap_or_default().into_raw(){NL}"
    content = content + "}{NL}{NL}"

    # ---- Handle free functions ----
    for handle in spec.handle_types:
        val h_lower = handle.name.lower()
        content = content + "#[no_mangle]{NL}"
        content = content + "pub extern \"C\" fn rt_{spec.name}_{h_lower}_free(ptr: *mut Simple{handle.name}) {{NL}"
        content = content + "    if !ptr.is_null() {{NL}"
        content = content + "        unsafe {{NL}"
        content = content + "            let _ = Box::from_raw(ptr);{NL}"
        content = content + "        }{NL}"
        content = content + "    }{NL}"
        content = content + "}{NL}{NL}"

    # ---- Function C ABI exports ----
    content = content + "// ============================================================================{NL}"
    content = content + "// Function Exports{NL}"
    content = content + "// ============================================================================{NL}{NL}"

    for func in spec.functions:
        content = content + gen_c_export_fn(func, spec)

    # ---- Method C ABI exports ----
    content = content + "// ============================================================================{NL}"
    content = content + "// Method Exports{NL}"
    content = content + "// ============================================================================{NL}{NL}"

    for method in spec.methods:
        content = content + gen_c_export_method(method, spec)

    if dry_run:
        print "--- src/lib.rs ---"
        print content
    else:
        file_write("{output_dir}/src/lib.rs", content)

# ---- cxx bridge function declaration ----
fn gen_cxx_fn_decl(func: FunctionSpec, spec: WrapperSpec) -> text:
    var params = ""
    for param in func.params:
        if params != "":
            params = params + ", "
        val cxx_type = map_type_to_cxx(param.param_type, spec)
        params = params + "{param.name}: {cxx_type}"

    val qname = qualified_fn_name(spec.name, func.name)
    if is_void_return(func.return_type):
        return "        fn {qname}({params});{NL}"
    val ret = map_return_to_cxx(func.return_type, spec)
    "        fn {qname}({params}) -> {ret};{NL}"

# ---- cxx bridge method declaration (as free function) ----
fn gen_cxx_method_decl(method: MethodSpec, spec: WrapperSpec) -> text:
    val h_lower = method.handle.lower()
    var params = "h: &{method.handle}"
    for param in method.params:
        val cxx_type = map_type_to_cxx(param.param_type, spec)
        params = params + ", {param.name}: {cxx_type}"

    val qname = qualified_fn_name(spec.name, "{h_lower}_{method.name}")
    if is_void_return(method.return_type):
        return "        fn {qname}({params});{NL}"
    val ret = map_return_to_cxx(method.return_type, spec)
    "        fn {qname}({params}) -> {ret};{NL}"

# ---- C ABI export for function ----
fn gen_c_export_fn(func: FunctionSpec, spec: WrapperSpec) -> text:
    val qname = qualified_fn_name(spec.name, func.name)
    var content = ""
    content = content + "#[no_mangle]{NL}"
    content = content + "pub extern \"C\" fn rt_{qname}({NL}"

    # Parameters
    var param_idx = 0
    for param in func.params:
        val c_type = map_type_to_c_abi(param.param_type, spec)
        content = content + "    {param.name}: {c_type},{NL}"
        # Array types need a length param
        if param.param_type == "[i64]" or param.param_type == "[f64]":
            content = content + "    {param.name}_len: usize,{NL}"
        param_idx = param_idx + 1

    if is_void_return(func.return_type):
        content = content + ") {{NL}"
    else:
        val ret_type = map_return_to_c_abi(func.return_type, spec)
        content = content + ") -> {ret_type} {{NL}"

    # Null safety checks (skip for void returns - just return early)
    var has_null_check = false
    for param in func.params:
        if param.param_type == "[i64]" or param.param_type == "[f64]":
            if not has_null_check:
                content = content + "    // Null safety{NL}"
                has_null_check = true
            content = content + "    if {param.name}.is_null() || {param.name}_len == 0 {{NL}"
            if is_void_return(func.return_type):
                content = content + "        return;{NL}"
            else:
                val default_ret = default_return_value(func.return_type, spec)
                content = content + "        return {default_ret};{NL}"
            content = content + "    }{NL}"
        elif param.param_type == "text":
            if not has_null_check:
                content = content + "    // Null safety{NL}"
                has_null_check = true
            content = content + "    if {param.name}.is_null() {{NL}"
            if is_void_return(func.return_type):
                content = content + "        return;{NL}"
            else:
                val default_ret = default_return_value(func.return_type, spec)
                content = content + "        return {default_ret};{NL}"
            content = content + "    }{NL}"
        elif is_handle_type(param.param_type, spec):
            if not has_null_check:
                content = content + "    // Null safety{NL}"
                has_null_check = true
            content = content + "    if {param.name}.is_null() {{NL}"
            if is_void_return(func.return_type):
                content = content + "        return;{NL}"
            else:
                val default_ret = default_return_value(func.return_type, spec)
                content = content + "        return {default_ret};{NL}"
            content = content + "    }{NL}"

    if has_null_check:
        content = content + NL

    # Check if any params need unsafe (pointer conversions)
    var needs_unsafe = false
    for param in func.params:
        if param.param_type == "[i64]" or param.param_type == "[f64]":
            needs_unsafe = true
        elif param.param_type == "text":
            needs_unsafe = true
        elif is_handle_type(param.param_type, spec):
            needs_unsafe = true

    if needs_unsafe:
        content = content + "    unsafe {{NL}"

    # Convert parameters
    var call_args = ""
    val indent = if needs_unsafe: "        " else: "    "
    for param in func.params:
        if param.param_type == "[i64]":
            content = content + "{indent}let {param.name}_slice = std::slice::from_raw_parts({param.name}, {param.name}_len);{NL}"
            if call_args != "":
                call_args = call_args + ", "
            call_args = call_args + "{param.name}_slice"
        elif param.param_type == "[f64]":
            content = content + "{indent}let {param.name}_slice = std::slice::from_raw_parts({param.name}, {param.name}_len);{NL}"
            if call_args != "":
                call_args = call_args + ", "
            call_args = call_args + "{param.name}_slice"
        elif param.param_type == "text":
            content = content + "{indent}let {param.name}_str = CStr::from_ptr({param.name}).to_str().unwrap_or(\"\");{NL}"
            if call_args != "":
                call_args = call_args + ", "
            call_args = call_args + "{param.name}_str"
        elif is_handle_type(param.param_type, spec):
            content = content + "{indent}let {param.name}_ref = &*{param.name};{NL}"
            if call_args != "":
                call_args = call_args + ", "
            call_args = call_args + "&{param.name}_ref.inner"
        else:
            if call_args != "":
                call_args = call_args + ", "
            call_args = call_args + "{param.name}"

    # Call ffi function and return
    if is_void_return(func.return_type):
        content = content + "{indent}ffi::{qname}({call_args});{NL}"
    elif is_handle_type(func.return_type, spec):
        content = content + "{indent}let result = ffi::{qname}({call_args});{NL}"
        content = content + "{indent}Box::into_raw(Box::new(Simple{func.return_type} { inner: result })){NL}"
    elif func.return_type == "text":
        content = content + "{indent}let result = ffi::{qname}({call_args});{NL}"
        content = content + "{indent}CString::new(result).unwrap_or_default().into_raw(){NL}"
    elif func.return_type == "[i64]":
        content = content + "{indent}let result = ffi::{qname}({call_args});{NL}"
        content = content + "{indent}// Caller must provide output buffer; returning length here{NL}"
        content = content + "{indent}result.len() as i64{NL}"
    elif func.return_type == "[f64]":
        content = content + "{indent}let result = ffi::{qname}({call_args});{NL}"
        content = content + "{indent}result.len() as i64{NL}"
    elif func.return_type == "[text]":
        content = content + "{indent}let result = ffi::{qname}({call_args});{NL}"
        content = content + "{indent}result.len() as i64{NL}"
    else:
        content = content + "{indent}ffi::{qname}({call_args}){NL}"

    if needs_unsafe:
        content = content + "    }{NL}"
    content = content + "}{NL}{NL}"

    content

# ---- C ABI export for method ----
fn gen_c_export_method(method: MethodSpec, spec: WrapperSpec) -> text:
    val h_lower = method.handle.lower()
    val qname = qualified_fn_name(spec.name, "{h_lower}_{method.name}")
    var content = ""
    content = content + "#[no_mangle]{NL}"
    content = content + "pub extern \"C\" fn rt_{qname}({NL}"
    content = content + "    handle: *const Simple{method.handle},{NL}"

    # Additional parameters
    for param in method.params:
        val c_type = map_type_to_c_abi(param.param_type, spec)
        content = content + "    {param.name}: {c_type},{NL}"
        if param.param_type == "[i64]" or param.param_type == "[f64]":
            content = content + "    {param.name}_len: usize,{NL}"

    # Return type - special case for [i64] methods that need output buffer
    if method.return_type == "[i64]":
        content = content + "    dims_out: *mut i64,{NL}"
        content = content + "    max_dims: usize,{NL}"
        content = content + ") -> i64 {{NL}"
    elif is_void_return(method.return_type):
        content = content + ") {{NL}"
    else:
        val ret_type = map_return_to_c_abi(method.return_type, spec)
        content = content + ") -> {ret_type} {{NL}"

    # Null safety on handle
    content = content + "    if handle.is_null() {{NL}"
    if is_void_return(method.return_type):
        content = content + "        return;{NL}"
    else:
        val default_ret = default_return_value(method.return_type, spec)
        content = content + "        return {default_ret};{NL}"
    content = content + "    }{NL}"

    # Null checks on pointer params
    for param in method.params:
        if is_handle_type(param.param_type, spec):
            content = content + "    if {param.name}.is_null() {{NL}"
            if is_void_return(method.return_type):
                content = content + "        return;{NL}"
            else:
                val def_ret = default_return_value(method.return_type, spec)
                content = content + "        return {def_ret};{NL}"
            content = content + "    }{NL}"
        elif param.param_type == "text":
            content = content + "    if {param.name}.is_null() {{NL}"
            if is_void_return(method.return_type):
                content = content + "        return;{NL}"
            else:
                val def_ret = default_return_value(method.return_type, spec)
                content = content + "        return {def_ret};{NL}"
            content = content + "    }{NL}"

    content = content + NL
    content = content + "    unsafe {{NL}"
    content = content + "        let h = &*handle;{NL}"

    # Convert additional params
    var call_args = "&h.inner"
    for param in method.params:
        if param.param_type == "[i64]":
            content = content + "        let {param.name}_slice = std::slice::from_raw_parts({param.name}, {param.name}_len);{NL}"
            call_args = call_args + ", {param.name}_slice"
        elif param.param_type == "[f64]":
            content = content + "        let {param.name}_slice = std::slice::from_raw_parts({param.name}, {param.name}_len);{NL}"
            call_args = call_args + ", {param.name}_slice"
        elif param.param_type == "text":
            content = content + "        let {param.name}_str = CStr::from_ptr({param.name}).to_str().unwrap_or(\"\");{NL}"
            call_args = call_args + ", {param.name}_str"
        elif is_handle_type(param.param_type, spec):
            content = content + "        let {param.name}_ref = &*{param.name};{NL}"
            call_args = call_args + ", &{param.name}_ref.inner"
        else:
            call_args = call_args + ", {param.name}"

    # Call ffi method and return
    if is_void_return(method.return_type):
        content = content + "        ffi::{qname}({call_args});{NL}"
    elif is_handle_type(method.return_type, spec):
        content = content + "        let result = ffi::{qname}({call_args});{NL}"
        content = content + "        Box::into_raw(Box::new(Simple{method.return_type} { inner: result })){NL}"
    elif method.return_type == "text":
        content = content + "        let result = ffi::{qname}({call_args});{NL}"
        content = content + "        CString::new(result).unwrap_or_default().into_raw(){NL}"
    elif method.return_type == "[i64]":
        content = content + "        let result = ffi::{qname}({call_args});{NL}"
        content = content + "        let ndims = result.len().min(max_dims);{NL}"
        content = content + "        for i in 0..ndims {{NL}"
        content = content + "            *dims_out.add(i) = result[i];{NL}"
        content = content + "        }{NL}"
        content = content + "        result.len() as i64{NL}"
    elif method.return_type == "[text]":
        content = content + "        let result = ffi::{qname}({call_args});{NL}"
        content = content + "        result.len() as i64{NL}"
    else:
        content = content + "        ffi::{qname}({call_args}){NL}"

    content = content + "    }{NL}"
    content = content + "}{NL}{NL}"

    content

export generate_lib_rs, gen_cxx_fn_decl, gen_cxx_method_decl, gen_c_export_fn, gen_c_export_method
