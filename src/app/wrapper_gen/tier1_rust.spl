# Tier 1 Generator - Rust Code Generation
#
# Generates src/lib.rs with cxx bridge module and C ABI export functions.

use app.io.{file_write, print}
use app.wrapper_gen.spec_parser.{WrapperSpec, FunctionSpec, MethodSpec}
use app.wrapper_gen.tier1_helpers.{is_handle_type, qualified_fn_name, is_void_return}
use app.wrapper_gen.tier1_types.{map_type_to_cxx, map_return_to_cxx, map_type_to_c_abi, map_return_to_c_abi, default_return_value}

# ============================================================================
# lib.rs Generation (Rust with cxx bridge + complete C ABI exports)
# ============================================================================

fn generate_lib_rs(spec: WrapperSpec, output_dir: text, dry_run: bool):
    var content = ""
    content = content + "// Auto-generated Rust wrapper for {spec.name} using cxx\n\n"
    content = content + "use cxx::UniquePtr;\n"
    content = content + "use std::ffi::{CStr, CString};\n"
    content = content + "use std::os::raw::c_char;\n\n"

    # cxx bridge module
    content = content + "#[cxx::bridge]\n"
    content = content + "mod ffi {\n"
    content = content + "    unsafe extern \"C++\" {\n"
    content = content + "        include!(\"simple-{spec.name}/src/bridge.h\");\n\n"

    # Opaque types
    for handle in spec.handle_types:
        content = content + "        type {handle.name};\n"
    content = content + "\n"

    # Functions as free functions in cxx bridge
    for func in spec.functions:
        content = content + gen_cxx_fn_decl(func, spec)
    content = content + "\n"

    # Methods as free functions in cxx bridge
    for method in spec.methods:
        content = content + gen_cxx_method_decl(method, spec)
    content = content + "\n"

    # Library info functions
    content = content + "        // Library info\n"
    content = content + "        fn {spec.name}_available() -> bool;\n"
    content = content + "        fn {spec.name}_version() -> String;\n"

    content = content + "    }\n"
    content = content + "}\n\n"

    # Opaque handle structs for C ABI
    for handle in spec.handle_types:
        content = content + "/// Opaque handle for Simple FFI\n"
        content = content + "#[repr(C)]\n"
        content = content + "pub struct Simple{handle.name} {\n"
        content = content + "    inner: UniquePtr<ffi::{handle.name}>,\n"
        content = content + "}\n\n"

    # ---- Library info C ABI exports ----
    content = content + "// ============================================================================\n"
    content = content + "// Library Info\n"
    content = content + "// ============================================================================\n\n"

    content = content + "#[no_mangle]\n"
    content = content + "pub extern \"C\" fn rt_{spec.name}_available() -> bool {\n"
    content = content + "    ffi::{spec.name}_available()\n"
    content = content + "}\n\n"

    content = content + "#[no_mangle]\n"
    content = content + "pub extern \"C\" fn rt_{spec.name}_version() -> *mut c_char {\n"
    content = content + "    let version = ffi::{spec.name}_version();\n"
    content = content + "    CString::new(version).unwrap_or_default().into_raw()\n"
    content = content + "}\n\n"

    # ---- Handle free functions ----
    for handle in spec.handle_types:
        val h_lower = handle.name.lower()
        content = content + "#[no_mangle]\n"
        content = content + "pub extern \"C\" fn rt_{spec.name}_{h_lower}_free(ptr: *mut Simple{handle.name}) {\n"
        content = content + "    if !ptr.is_null() {\n"
        content = content + "        unsafe {\n"
        content = content + "            let _ = Box::from_raw(ptr);\n"
        content = content + "        }\n"
        content = content + "    }\n"
        content = content + "}\n\n"

    # ---- Function C ABI exports ----
    content = content + "// ============================================================================\n"
    content = content + "// Function Exports\n"
    content = content + "// ============================================================================\n\n"

    for func in spec.functions:
        content = content + gen_c_export_fn(func, spec)

    # ---- Method C ABI exports ----
    content = content + "// ============================================================================\n"
    content = content + "// Method Exports\n"
    content = content + "// ============================================================================\n\n"

    for method in spec.methods:
        content = content + gen_c_export_method(method, spec)

    if dry_run:
        print "--- src/lib.rs ---"
        print content
    else:
        file_write("{output_dir}/src/lib.rs", content)

# ---- cxx bridge function declaration ----
fn gen_cxx_fn_decl(func: FunctionSpec, spec: WrapperSpec) -> text:
    var params = ""
    for param in func.params:
        if params != "":
            params = params + ", "
        val cxx_type = map_type_to_cxx(param.param_type, spec)
        params = params + "{param.name}: {cxx_type}"

    val qname = qualified_fn_name(spec.name, func.name)
    if is_void_return(func.return_type):
        return "        fn {qname}({params});\n"
    val ret = map_return_to_cxx(func.return_type, spec)
    "        fn {qname}({params}) -> {ret};\n"

# ---- cxx bridge method declaration (as free function) ----
fn gen_cxx_method_decl(method: MethodSpec, spec: WrapperSpec) -> text:
    val h_lower = method.handle.lower()
    var params = "h: &{method.handle}"
    for param in method.params:
        val cxx_type = map_type_to_cxx(param.param_type, spec)
        params = params + ", {param.name}: {cxx_type}"

    val qname = qualified_fn_name(spec.name, "{h_lower}_{method.name}")
    if is_void_return(method.return_type):
        return "        fn {qname}({params});\n"
    val ret = map_return_to_cxx(method.return_type, spec)
    "        fn {qname}({params}) -> {ret};\n"

# ---- C ABI export for function ----
fn gen_c_export_fn(func: FunctionSpec, spec: WrapperSpec) -> text:
    val qname = qualified_fn_name(spec.name, func.name)
    var content = ""
    content = content + "#[no_mangle]\n"
    content = content + "pub extern \"C\" fn rt_{qname}(\n"

    # Parameters
    var param_idx = 0
    for param in func.params:
        val c_type = map_type_to_c_abi(param.param_type, spec)
        content = content + "    {param.name}: {c_type},\n"
        # Array types need a length param
        if param.param_type == "[i64]" or param.param_type == "[f64]":
            content = content + "    {param.name}_len: usize,\n"
        param_idx = param_idx + 1

    if is_void_return(func.return_type):
        content = content + ") {\n"
    else:
        val ret_type = map_return_to_c_abi(func.return_type, spec)
        content = content + ") -> {ret_type} {\n"

    # Null safety checks (skip for void returns - just return early)
    var has_null_check = false
    for param in func.params:
        if param.param_type == "[i64]" or param.param_type == "[f64]":
            if not has_null_check:
                content = content + "    // Null safety\n"
                has_null_check = true
            content = content + "    if {param.name}.is_null() || {param.name}_len == 0 {\n"
            if is_void_return(func.return_type):
                content = content + "        return;\n"
            else:
                val default_ret = default_return_value(func.return_type, spec)
                content = content + "        return {default_ret};\n"
            content = content + "    }\n"
        elif param.param_type == "text":
            if not has_null_check:
                content = content + "    // Null safety\n"
                has_null_check = true
            content = content + "    if {param.name}.is_null() {\n"
            if is_void_return(func.return_type):
                content = content + "        return;\n"
            else:
                val default_ret = default_return_value(func.return_type, spec)
                content = content + "        return {default_ret};\n"
            content = content + "    }\n"
        elif is_handle_type(param.param_type, spec):
            if not has_null_check:
                content = content + "    // Null safety\n"
                has_null_check = true
            content = content + "    if {param.name}.is_null() {\n"
            if is_void_return(func.return_type):
                content = content + "        return;\n"
            else:
                val default_ret = default_return_value(func.return_type, spec)
                content = content + "        return {default_ret};\n"
            content = content + "    }\n"

    if has_null_check:
        content = content + "\n"

    # Check if any params need unsafe (pointer conversions)
    var needs_unsafe = false
    for param in func.params:
        if param.param_type == "[i64]" or param.param_type == "[f64]":
            needs_unsafe = true
        elif param.param_type == "text":
            needs_unsafe = true
        elif is_handle_type(param.param_type, spec):
            needs_unsafe = true

    if needs_unsafe:
        content = content + "    unsafe {\n"

    # Convert parameters
    var call_args = ""
    val indent = if needs_unsafe: "        " else: "    "
    for param in func.params:
        if param.param_type == "[i64]":
            content = content + "{indent}let {param.name}_slice = std::slice::from_raw_parts({param.name}, {param.name}_len);\n"
            if call_args != "":
                call_args = call_args + ", "
            call_args = call_args + "{param.name}_slice"
        elif param.param_type == "[f64]":
            content = content + "{indent}let {param.name}_slice = std::slice::from_raw_parts({param.name}, {param.name}_len);\n"
            if call_args != "":
                call_args = call_args + ", "
            call_args = call_args + "{param.name}_slice"
        elif param.param_type == "text":
            content = content + "{indent}let {param.name}_str = CStr::from_ptr({param.name}).to_str().unwrap_or(\"\");\n"
            if call_args != "":
                call_args = call_args + ", "
            call_args = call_args + "{param.name}_str"
        elif is_handle_type(param.param_type, spec):
            content = content + "{indent}let {param.name}_ref = &*{param.name};\n"
            if call_args != "":
                call_args = call_args + ", "
            call_args = call_args + "&{param.name}_ref.inner"
        else:
            if call_args != "":
                call_args = call_args + ", "
            call_args = call_args + "{param.name}"

    # Call ffi function and return
    if is_void_return(func.return_type):
        content = content + "{indent}ffi::{qname}({call_args});\n"
    elif is_handle_type(func.return_type, spec):
        content = content + "{indent}let result = ffi::{qname}({call_args});\n"
        content = content + "{indent}Box::into_raw(Box::new(Simple{func.return_type} { inner: result }))\n"
    elif func.return_type == "text":
        content = content + "{indent}let result = ffi::{qname}({call_args});\n"
        content = content + "{indent}CString::new(result).unwrap_or_default().into_raw()\n"
    elif func.return_type == "[i64]":
        content = content + "{indent}let result = ffi::{qname}({call_args});\n"
        content = content + "{indent}// Caller must provide output buffer; returning length here\n"
        content = content + "{indent}result.len() as i64\n"
    elif func.return_type == "[f64]":
        content = content + "{indent}let result = ffi::{qname}({call_args});\n"
        content = content + "{indent}result.len() as i64\n"
    elif func.return_type == "[text]":
        content = content + "{indent}let result = ffi::{qname}({call_args});\n"
        content = content + "{indent}result.len() as i64\n"
    else:
        content = content + "{indent}ffi::{qname}({call_args})\n"

    if needs_unsafe:
        content = content + "    }\n"
    content = content + "}\n\n"

    content

# ---- C ABI export for method ----
fn gen_c_export_method(method: MethodSpec, spec: WrapperSpec) -> text:
    val h_lower = method.handle.lower()
    val qname = qualified_fn_name(spec.name, "{h_lower}_{method.name}")
    var content = ""
    content = content + "#[no_mangle]\n"
    content = content + "pub extern \"C\" fn rt_{qname}(\n"
    content = content + "    handle: *const Simple{method.handle},\n"

    # Additional parameters
    for param in method.params:
        val c_type = map_type_to_c_abi(param.param_type, spec)
        content = content + "    {param.name}: {c_type},\n"
        if param.param_type == "[i64]" or param.param_type == "[f64]":
            content = content + "    {param.name}_len: usize,\n"

    # Return type - special case for [i64] methods that need output buffer
    if method.return_type == "[i64]":
        content = content + "    dims_out: *mut i64,\n"
        content = content + "    max_dims: usize,\n"
        content = content + ") -> i64 {\n"
    elif is_void_return(method.return_type):
        content = content + ") {\n"
    else:
        val ret_type = map_return_to_c_abi(method.return_type, spec)
        content = content + ") -> {ret_type} {\n"

    # Null safety on handle
    content = content + "    if handle.is_null() {\n"
    if is_void_return(method.return_type):
        content = content + "        return;\n"
    else:
        val default_ret = default_return_value(method.return_type, spec)
        content = content + "        return {default_ret};\n"
    content = content + "    }\n"

    # Null checks on pointer params
    for param in method.params:
        if is_handle_type(param.param_type, spec):
            content = content + "    if {param.name}.is_null() {\n"
            if is_void_return(method.return_type):
                content = content + "        return;\n"
            else:
                val def_ret = default_return_value(method.return_type, spec)
                content = content + "        return {def_ret};\n"
            content = content + "    }\n"
        elif param.param_type == "text":
            content = content + "    if {param.name}.is_null() {\n"
            if is_void_return(method.return_type):
                content = content + "        return;\n"
            else:
                val def_ret = default_return_value(method.return_type, spec)
                content = content + "        return {def_ret};\n"
            content = content + "    }\n"

    content = content + "\n"
    content = content + "    unsafe {\n"
    content = content + "        let h = &*handle;\n"

    # Convert additional params
    var call_args = "&h.inner"
    for param in method.params:
        if param.param_type == "[i64]":
            content = content + "        let {param.name}_slice = std::slice::from_raw_parts({param.name}, {param.name}_len);\n"
            call_args = call_args + ", {param.name}_slice"
        elif param.param_type == "[f64]":
            content = content + "        let {param.name}_slice = std::slice::from_raw_parts({param.name}, {param.name}_len);\n"
            call_args = call_args + ", {param.name}_slice"
        elif param.param_type == "text":
            content = content + "        let {param.name}_str = CStr::from_ptr({param.name}).to_str().unwrap_or(\"\");\n"
            call_args = call_args + ", {param.name}_str"
        elif is_handle_type(param.param_type, spec):
            content = content + "        let {param.name}_ref = &*{param.name};\n"
            call_args = call_args + ", &{param.name}_ref.inner"
        else:
            call_args = call_args + ", {param.name}"

    # Call ffi method and return
    if is_void_return(method.return_type):
        content = content + "        ffi::{qname}({call_args});\n"
    elif is_handle_type(method.return_type, spec):
        content = content + "        let result = ffi::{qname}({call_args});\n"
        content = content + "        Box::into_raw(Box::new(Simple{method.return_type} { inner: result }))\n"
    elif method.return_type == "text":
        content = content + "        let result = ffi::{qname}({call_args});\n"
        content = content + "        CString::new(result).unwrap_or_default().into_raw()\n"
    elif method.return_type == "[i64]":
        content = content + "        let result = ffi::{qname}({call_args});\n"
        content = content + "        let ndims = result.len().min(max_dims);\n"
        content = content + "        for i in 0..ndims {\n"
        content = content + "            *dims_out.add(i) = result[i];\n"
        content = content + "        }\n"
        content = content + "        result.len() as i64\n"
    elif method.return_type == "[text]":
        content = content + "        let result = ffi::{qname}({call_args});\n"
        content = content + "        result.len() as i64\n"
    else:
        content = content + "        ffi::{qname}({call_args})\n"

    content = content + "    }\n"
    content = content + "}\n\n"

    content

export generate_lib_rs, gen_cxx_fn_decl, gen_cxx_method_decl, gen_c_export_fn, gen_c_export_method
