# Tier 1 Generator - Hub Module
#
# Generates complete, compilable code for:
#   - Cargo.toml (with features section)
#   - build.rs (with include paths and search paths)
#   - src/lib.rs (with cxx bridge + complete C ABI exports)
#   - src/bridge.h (with wrapper structs + function declarations)
#   - src/bridge.cpp (with #ifdef conditional implementations)

use app.io.{dir_create_all, print}
use app.wrapper_gen.spec_parser.{WrapperSpec}

# Import from sub-modules
use app.wrapper_gen.tier1_helpers.{is_handle_type, lib_upper, is_embedded, qualified_fn_name, is_void_return}
use app.wrapper_gen.tier1_types.{map_type_to_cxx, map_return_to_cxx, map_type_to_c_abi, map_return_to_c_abi, default_return_value, map_type_to_cpp_param, map_return_to_cpp, cpp_default_return}
use app.wrapper_gen.tier1_cargo.{generate_cargo_toml, generate_build_rs}
use app.wrapper_gen.tier1_rust.{generate_lib_rs, gen_cxx_fn_decl, gen_cxx_method_decl, gen_c_export_fn, gen_c_export_method}
use app.wrapper_gen.tier1_cpp.{generate_bridge_h, generate_bridge_cpp, gen_h_fn_decl, gen_h_method_decl, gen_cpp_fn_impl, gen_cpp_method_impl, build_param_conversions}

fn generate_tier1(spec: WrapperSpec, dry_run: bool):
    """Generate Tier 1: Rust/C++ wrapper using cxx."""

    val output_dir = ".build/rust/ffi_{spec.name}"

    if not dry_run:
        dir_create_all(output_dir)
        dir_create_all("{output_dir}/src")

    # Generate all Tier 1 files
    generate_cargo_toml(spec, output_dir, dry_run)
    generate_build_rs(spec, output_dir, dry_run)
    generate_lib_rs(spec, output_dir, dry_run)
    generate_bridge_h(spec, output_dir, dry_run)
    generate_bridge_cpp(spec, output_dir, dry_run)

    if dry_run:
        print "--- Tier 1 (Rust/C++) would be generated to: {output_dir}/"
    else:
        print "Tier 1 generated: {output_dir}/"

export generate_tier1
