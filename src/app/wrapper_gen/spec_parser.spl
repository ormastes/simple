# Wrapper Spec Parser
#
# Parses .wrapper_spec files that describe C++ library APIs
#
# Spec format (YAML-like):
#   wrapper_lib:
#     name: torch
#     version: "2.0"
#     link: [torch, c10]
#
#   handle_types:
#     - name: TorchTensor
#       cpp_type: "torch::Tensor"
#       drop_fn: "at_free"
#
#   functions:
#     - name: tensor_zeros
#       cpp_fn: "torch::zeros"
#       params:
#         - name: dims
#           type: "[i64]"
#       return: TorchTensor

# ============================================================================
# Spec Data Structures
# ============================================================================

use std.string.{NL}

class WrapperSpec:
    name: text
    version: text
    lang: text
    link_libs: [text]
    search_paths: [text]
    cpp_include: text
    include_paths: [text]
    handle_types: [HandleTypeSpec]
    functions: [FunctionSpec]
    methods: [MethodSpec]
    rust_crate: text
    rust_crate_version: text

class HandleTypeSpec:
    name: text
    cpp_type: text
    drop_fn: text

class ParamSpec:
    name: text
    param_type: text

class FunctionSpec:
    name: text
    cpp_fn: text
    params: [ParamSpec]
    return_type: text

class MethodSpec:
    handle: text
    name: text
    cpp_method: text
    params: [ParamSpec]
    return_type: text

# ============================================================================
# Helper: Check if line is indented (part of a section)
# ============================================================================

fn is_indented(line: text) -> bool:
    """Check if a raw (untrimmed) line starts with whitespace."""
    if line.len() == 0:
        return false
    line.starts_with(" ") or line.starts_with("\t")

# ============================================================================
# Parser - Single-pass line-based
# ============================================================================

fn parse_wrapper_spec(content: text) -> WrapperSpec:
    """Parse wrapper spec from file content.

    Single-pass parser that avoids function-parameter mutation issues
    by doing all parsing in one function.
    """

    var name = ""
    var version = "0.1.0"
    var lang = "cpp"
    var link_libs: [text] = []
    var search_paths: [text] = []
    var cpp_include = ""
    var include_paths: [text] = []
    var handle_types: [HandleTypeSpec] = []
    var functions: [FunctionSpec] = []
    var methods: [MethodSpec] = []
    var rust_crate = ""
    var rust_crate_version = ""

    val lines = content.split(NL)
    var i = 0
    var section = ""

    while i < lines.len():
        val raw_line = lines[i]
        val line = raw_line.trim()

        # Skip empty lines and comments
        if line == "" or line.starts_with("#"):
            i = i + 1
            continue

        # Detect top-level sections (non-indented)
        if not is_indented(raw_line):
            if line.starts_with("wrapper_lib:"):
                section = "wrapper_lib"
            elif line.starts_with("handle_types:"):
                section = "handle_types"
            elif line.starts_with("functions:"):
                section = "functions"
            elif line.starts_with("methods:"):
                section = "methods"
            else:
                section = ""
            i = i + 1
            continue

        # Parse indented content based on current section
        if section == "wrapper_lib":
            if line.starts_with("name:"):
                name = extract_value(line)
            elif line.starts_with("version:"):
                version = extract_value(line)
            elif line.starts_with("lang:"):
                lang = extract_value(line)
            elif line.starts_with("link:"):
                link_libs = parse_array(line)
            elif line.starts_with("search_paths:"):
                search_paths = parse_array(line)
            elif line.starts_with("cpp_include:"):
                cpp_include = extract_value(line)
            elif line.starts_with("include_paths:"):
                include_paths = parse_array(line)
            elif line.starts_with("rust_crate:"):
                rust_crate = extract_value(line)
            elif line.starts_with("rust_crate_version:"):
                rust_crate_version = extract_value(line)
            i = i + 1

        elif section == "handle_types":
            if line.starts_with("- name:"):
                var h_name = extract_value(line)
                var h_cpp_type = ""
                var h_drop_fn = ""
                i = i + 1
                # Parse handle properties until next item or section end
                while i < lines.len():
                    val prop_raw = lines[i]
                    val prop = prop_raw.trim()
                    if prop == "" or prop.starts_with("#"):
                        i = i + 1
                        continue
                    if not is_indented(prop_raw) or prop.starts_with("- "):
                        break
                    if prop.starts_with("cpp_type:"):
                        h_cpp_type = extract_value(prop)
                    elif prop.starts_with("drop_fn:"):
                        h_drop_fn = extract_value(prop)
                    i = i + 1
                handle_types.push(HandleTypeSpec(name: h_name, cpp_type: h_cpp_type, drop_fn: h_drop_fn))
            else:
                i = i + 1

        elif section == "functions":
            if line.starts_with("- name:"):
                var f_name = extract_value(line)
                var f_cpp_fn = ""
                var f_return_type = ""
                var f_params: [ParamSpec] = []
                i = i + 1
                while i < lines.len():
                    val prop_raw = lines[i]
                    val prop = prop_raw.trim()
                    if prop == "" or prop.starts_with("#"):
                        i = i + 1
                        continue
                    if not is_indented(prop_raw):
                        break
                    if prop.starts_with("- name:"):
                        # Next function entry - check indent level
                        # If same indent as parent "- name:", break
                        break
                    if prop.starts_with("cpp_fn:"):
                        f_cpp_fn = extract_value(prop)
                    elif prop.starts_with("return:"):
                        f_return_type = extract_value(prop)
                    elif prop.starts_with("params:"):
                        i = i + 1
                        # Parse params inline
                        while i < lines.len():
                            val p_raw = lines[i]
                            val p = p_raw.trim()
                            if p == "":
                                i = i + 1
                                continue
                            if not p.starts_with("- name:"):
                                break
                            var p_name = extract_value(p)
                            var p_type = ""
                            i = i + 1
                            if i < lines.len():
                                val t = lines[i].trim()
                                if t.starts_with("type:"):
                                    p_type = extract_value(t)
                                    i = i + 1
                            f_params.push(ParamSpec(name: p_name, param_type: p_type))
                        continue
                    i = i + 1
                functions.push(FunctionSpec(name: f_name, cpp_fn: f_cpp_fn, params: f_params, return_type: f_return_type))
            else:
                i = i + 1

        elif section == "methods":
            if line.starts_with("- handle:"):
                var m_handle = extract_value(line)
                var m_name = ""
                var m_cpp_method = ""
                var m_return_type = ""
                var m_params: [ParamSpec] = []
                i = i + 1
                while i < lines.len():
                    val prop_raw = lines[i]
                    val prop = prop_raw.trim()
                    if prop == "" or prop.starts_with("#"):
                        i = i + 1
                        continue
                    if not is_indented(prop_raw):
                        break
                    if prop.starts_with("- handle:"):
                        break
                    if prop.starts_with("name:"):
                        m_name = extract_value(prop)
                    elif prop.starts_with("cpp_method:"):
                        m_cpp_method = extract_value(prop)
                    elif prop.starts_with("return:"):
                        m_return_type = extract_value(prop)
                    elif prop.starts_with("params:"):
                        i = i + 1
                        while i < lines.len():
                            val p_raw = lines[i]
                            val p = p_raw.trim()
                            if p == "":
                                i = i + 1
                                continue
                            if not p.starts_with("- name:"):
                                break
                            var p_name = extract_value(p)
                            var p_type = ""
                            i = i + 1
                            if i < lines.len():
                                val t = lines[i].trim()
                                if t.starts_with("type:"):
                                    p_type = extract_value(t)
                                    i = i + 1
                            m_params.push(ParamSpec(name: p_name, param_type: p_type))
                        continue
                    i = i + 1
                methods.push(MethodSpec(handle: m_handle, name: m_name, cpp_method: m_cpp_method, params: m_params, return_type: m_return_type))
            else:
                i = i + 1

        else:
            i = i + 1

    WrapperSpec(
        name: name,
        version: version,
        lang: lang,
        link_libs: link_libs,
        search_paths: search_paths,
        cpp_include: cpp_include,
        include_paths: include_paths,
        handle_types: handle_types,
        functions: functions,
        methods: methods,
        rust_crate: rust_crate,
        rust_crate_version: rust_crate_version
    )

# ============================================================================
# Helper Functions
# ============================================================================

fn extract_value(line: text) -> text:
    """Extract value from 'key: value' line."""
    val parts = line.split(":")
    if parts.len() < 2:
        return ""

    # Rejoin all parts after the first colon (handles values like "torch::Tensor")
    var value = parts[1]
    var j = 2
    while j < parts.len():
        value = value + ":" + parts[j]
        j = j + 1
    value = value.trim()

    # Remove quotes
    if value.starts_with("\"") and value.ends_with("\""):
        return value[1:value.len()-1]

    value

fn parse_array(line: text) -> [text]:
    """Parse array from 'key: [val1, val2]' line."""
    val value = extract_value(line)

    if not value.starts_with("[") or not value.ends_with("]"):
        return []

    val inner = value[1:value.len()-1]
    val items = inner.split(",")

    var result: [text] = []
    for item in items:
        var trimmed = item.trim()
        # Remove surrounding quotes from each item
        if trimmed.starts_with("\"") and trimmed.ends_with("\""):
            trimmed = trimmed[1:trimmed.len()-1]
        result.push(trimmed)

    result

export WrapperSpec
export HandleTypeSpec
export ParamSpec
export FunctionSpec
export MethodSpec
export parse_wrapper_spec
