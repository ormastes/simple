# Tier 3 Generator - Simple API Scaffold
#
# Generates src/lib/<library>/mod.spl with user-facing API

use app.io.{file_write, dir_create_all, print}
use app.wrapper_gen.spec_parser.{WrapperSpec, HandleTypeSpec, FunctionSpec, MethodSpec}
use std.text.{NL}

fn generate_tier3(spec: WrapperSpec, dry_run: bool):
    """Generate Tier 3: Simple API scaffold (user-facing classes)."""

    val output_dir = "src/lib/{spec.name}"
    val output_file = "{output_dir}/mod.spl"

    if not dry_run:
        dir_create_all(output_dir)

    var content = ""
    content = content + "# {spec.name} Simple API (Tier 3){NL}"
    content = content + "# Auto-generated API scaffold{NL}"
    content = content + "#{NL}"
    content = content + "# This provides an idiomatic Simple API wrapping the FFI bindings.{NL}"
    content = content + "# Feel free to customize and extend this code.{NL}{NL}"

    content = content + "use lib.{spec.name}.ffi.*{NL}{NL}"

    # Backend detection
    content = content + "# ============================================================================{NL}"
    content = content + "# Backend Detection{NL}"
    content = content + "# ============================================================================{NL}{NL}"

    content = content + "fn {spec.name}_available() -> bool:{NL}"
    content = content + "    rt_{spec.name}_available(){NL}{NL}"

    content = content + "fn {spec.name}_version() -> text:{NL}"
    content = content + "    rt_{spec.name}_version(){NL}{NL}"

    # Generate wrapper classes for each handle type
    for handle in spec.handle_types:
        content = content + generate_wrapper_class(handle, spec)

    # Exports
    content = content + "# ============================================================================{NL}"
    content = content + "# Exports{NL}"
    content = content + "# ============================================================================{NL}{NL}"

    for handle in spec.handle_types:
        content = content + "export {handle.name}Wrapper{NL}"

    content = content + "export {spec.name}_available{NL}"
    content = content + "export {spec.name}_version{NL}"

    if dry_run:
        print "--- Tier 3 (Simple API) ---"
        print content
    else:
        file_write(output_file, content)
        print "âœ“ Tier 3 generated: {output_file}"

fn generate_wrapper_class(handle: HandleTypeSpec, spec: WrapperSpec) -> text:
    var content = ""
    content = content + "# ============================================================================{NL}"
    content = content + "# {handle.name} Wrapper Class{NL}"
    content = content + "# ============================================================================{NL}{NL}"

    content = content + "class {handle.name}Wrapper:{NL}"
    content = content + "    \"\"\"High-level wrapper for {handle.name}.{NL}{NL}"
    content = content + "    Automatically manages memory via RAII pattern.{NL}"
    content = content + "    \"\"\"{NL}{NL}"

    content = content + "    handle: i64  # Opaque FFI handle (pointer){NL}"
    content = content + "    owns_handle: bool{NL}{NL}"

    # Static constructor methods
    val constructors = find_constructors(handle.name, spec)
    if constructors.len() > 0:
        content = content + "    # Static factory methods{NL}"
        for func in constructors:
            content = content + generate_static_method(func, handle.name, spec)
        content = content + NL

    # Drop method
    if handle.drop_fn != "":
        content = content + "    fn drop():{NL}"
        content = content + "        \"\"\"Automatically free memory when object goes out of scope.\"\"\"{NL}"
        content = content + "        if self.owns_handle:{NL}"
        content = content + "            {handle.drop_fn}(self.handle){NL}{NL}"

    # Instance methods
    val methods = find_methods(handle.name, spec)
    if methods.len() > 0:
        content = content + "    # Methods{NL}"
        for method in methods:
            content = content + generate_instance_method(method, handle.name, spec)
        content = content + NL

    content

fn find_constructors(handle_name: text, spec: WrapperSpec) -> [FunctionSpec]:
    """Find functions that return this handle type."""
    var result: [FunctionSpec] = []

    for func in spec.functions:
        if func.return_type == handle_name:
            result.push(func)

    result

fn find_methods(handle_name: text, spec: WrapperSpec) -> [MethodSpec]:
    """Find methods for this handle type."""
    var result: [MethodSpec] = []

    for method in spec.methods:
        if method.handle == handle_name:
            result.push(method)

    result

fn generate_static_method(func: FunctionSpec, handle_name: text, spec: WrapperSpec) -> text:
    var params = ""
    var call_args = ""

    for param in func.params:
        if params != "":
            params = params + ", "
            call_args = call_args + ", "
        params = params + "{param.name}: {param.param_type}"
        call_args = call_args + param.name

    var content = ""
    content = content + "    static fn {func.name}({params}) -> {handle_name}Wrapper:{NL}"
    content = content + "        val handle = rt_{spec.name}_{func.name}({call_args}){NL}"
    content = content + "        {handle_name}Wrapper(handle: handle, owns_handle: true){NL}{NL}"

    content

fn generate_instance_method(method: MethodSpec, handle_name: text, spec: WrapperSpec) -> text:
    var params = ""
    var call_args = "self.handle"

    for param in method.params:
        if params != "":
            params = params + ", "
        call_args = call_args + ", {param.name}"
        val param_type = map_handle_to_wrapper(param.param_type, spec)
        params = params + "{param.name}: {param_type}"

    val mapped_return = map_handle_to_wrapper(method.return_type, spec)
    val return_decl = if mapped_return != "": " -> {mapped_return}" else: ""

    var content = ""
    content = content + "    fn {method.name}({params}){return_decl}:{NL}"

    if method.return_type == handle_name:
        # Returns same handle type - wrap it
        content = content + "        val result_handle = rt_{spec.name}_{handle_name.lower()}_{method.name}({call_args}){NL}"
        content = content + "        {handle_name}Wrapper(handle: result_handle, owns_handle: true){NL}{NL}"
    else:
        # Returns primitive or different type
        content = content + "        rt_{spec.name}_{handle_name.lower()}_{method.name}({call_args}){NL}{NL}"

    content

# Helper: Map handle types to i64 (for FFI layer interaction)
# In the API layer, we accept wrapper types, but internally use i64 handles
fn map_handle_to_wrapper(type_name: text, spec: WrapperSpec) -> text:
    # Check if this is a handle type - if so, use i64
    for handle in spec.handle_types:
        if type_name == handle.name:
            return "i64"

    # Not a handle type, return as-is
    type_name

fn is_handle_type(type_name: text, spec: WrapperSpec) -> bool:
    for handle in spec.handle_types:
        if type_name == handle.name:
            return true
    false

export generate_tier3
