# Tier 1 Generator - Type Mapping Functions
#
# Maps Simple types to cxx bridge types, C ABI types, and C++ types.

use app.wrapper_gen.spec_parser.{WrapperSpec}
use app.wrapper_gen.tier1_helpers.{is_handle_type, is_void_return}

# ============================================================================
# cxx bridge types (used in cxx::bridge mod)
# ============================================================================

fn map_type_to_cxx(simple_type: text, spec: WrapperSpec) -> text:
    if simple_type == "[i64]":
        return "&[i64]"
    elif simple_type == "[f64]":
        return "&[f64]"
    elif simple_type == "text":
        return "&str"
    elif simple_type == "i64":
        return "i64"
    elif simple_type == "f64":
        return "f64"
    elif simple_type == "bool":
        return "bool"
    elif is_handle_type(simple_type, spec):
        return "&{simple_type}"
    else:
        return simple_type

fn map_return_to_cxx(simple_type: text, spec: WrapperSpec) -> text:
    if is_handle_type(simple_type, spec):
        return "UniquePtr<{simple_type}>"
    elif simple_type == "text":
        return "String"
    elif simple_type == "[i64]":
        return "Vec<i64>"
    elif simple_type == "[f64]":
        return "Vec<f64>"
    elif simple_type == "[text]":
        return "Vec<String>"
    elif simple_type == "i64":
        return "i64"
    elif simple_type == "f64":
        return "f64"
    elif simple_type == "bool":
        return "bool"
    else:
        return simple_type

# ============================================================================
# C ABI types (used in extern "C" exports)
# ============================================================================

fn map_type_to_c_abi(simple_type: text, spec: WrapperSpec) -> text:
    if simple_type == "[i64]":
        return "*const i64"
    elif simple_type == "[f64]":
        return "*const f64"
    elif simple_type == "text":
        return "*const c_char"
    elif simple_type == "i64":
        return "i64"
    elif simple_type == "f64":
        return "f64"
    elif simple_type == "bool":
        return "bool"
    elif is_handle_type(simple_type, spec):
        return "*const Simple{simple_type}"
    else:
        return simple_type

fn map_return_to_c_abi(simple_type: text, spec: WrapperSpec) -> text:
    if simple_type == "text":
        return "*mut c_char"
    elif simple_type == "[i64]" or simple_type == "[f64]" or simple_type == "[text]":
        return "i64"
    elif simple_type == "i64":
        return "i64"
    elif simple_type == "f64":
        return "f64"
    elif simple_type == "bool":
        return "bool"
    elif is_handle_type(simple_type, spec):
        return "*mut Simple{simple_type}"
    else:
        return simple_type

fn default_return_value(simple_type: text, spec: WrapperSpec) -> text:
    if is_handle_type(simple_type, spec):
        return "std::ptr::null_mut()"
    elif simple_type == "text":
        return "std::ptr::null_mut()"
    elif simple_type == "[i64]" or simple_type == "[f64]" or simple_type == "[text]":
        return "0"
    elif simple_type == "i64":
        return "-1"
    elif simple_type == "f64":
        return "0.0"
    elif simple_type == "bool":
        return "false"
    else:
        return "std::ptr::null_mut()"

# ============================================================================
# C++ types (used in bridge.h/.cpp)
# ============================================================================

fn map_type_to_cpp_param(simple_type: text, spec: WrapperSpec) -> text:
    if simple_type == "[i64]":
        return "rust::Slice<const int64_t>"
    elif simple_type == "[f64]":
        return "rust::Slice<const double>"
    elif simple_type == "text":
        return "rust::Str"
    elif simple_type == "i64":
        return "int64_t"
    elif simple_type == "f64":
        return "double"
    elif simple_type == "bool":
        return "bool"
    elif is_handle_type(simple_type, spec):
        return "const {simple_type}&"
    else:
        return simple_type

fn map_return_to_cpp(simple_type: text, spec: WrapperSpec) -> text:
    if is_void_return(simple_type):
        return "void"
    elif is_handle_type(simple_type, spec):
        return "std::unique_ptr<{simple_type}>"
    elif simple_type == "text":
        return "rust::String"
    elif simple_type == "[i64]":
        return "rust::Vec<int64_t>"
    elif simple_type == "[f64]":
        return "rust::Vec<double>"
    elif simple_type == "[text]":
        return "rust::Vec<rust::String>"
    elif simple_type == "i64":
        return "int64_t"
    elif simple_type == "f64":
        return "double"
    elif simple_type == "bool":
        return "bool"
    else:
        return "std::unique_ptr<{simple_type}>"

fn cpp_default_return(simple_type: text, spec: WrapperSpec) -> text:
    if is_void_return(simple_type):
        return "return;"
    elif is_handle_type(simple_type, spec):
        return "return std::make_unique<{simple_type}>();"
    elif simple_type == "text":
        return "return rust::String(\"\");"
    elif simple_type == "[i64]":
        return "return rust::Vec<int64_t>();"
    elif simple_type == "[f64]":
        return "return rust::Vec<double>();"
    elif simple_type == "[text]":
        return "return rust::Vec<rust::String>();"
    elif simple_type == "i64":
        return "return 0;"
    elif simple_type == "f64":
        return "return 0.0;"
    elif simple_type == "bool":
        return "return false;"
    else:
        return "return {};"

export map_type_to_cxx, map_return_to_cxx
export map_type_to_c_abi, map_return_to_c_abi
export default_return_value
export map_type_to_cpp_param, map_return_to_cpp
export cpp_default_return
