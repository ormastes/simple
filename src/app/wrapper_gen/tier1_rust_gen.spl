# Tier 1 Rust-Native Generator
#
# Generates direct Rust FFI code for wrapping pure Rust crates.
# Unlike tier1_gen.spl (which generates cxx bridge + C++ code),
# this generates simple handle-table based Rust code with #[no_mangle] exports.
#
# Output:
#   .build/rust/ffi_<lib>/Cargo.toml
#   .build/rust/ffi_<lib>/src/lib.rs
#
# No bridge.h, bridge.cpp, or cxx dependency needed.

use app.io.{file_write, dir_create_all, print}
use app.wrapper_gen.spec_parser.{WrapperSpec, HandleTypeSpec, ParamSpec, FunctionSpec, MethodSpec}
use std.text.{NL}

fn generate_tier1_rust(spec: WrapperSpec, dry_run: bool):
    """Generate Tier 1: Direct Rust FFI wrapper (no cxx, no C++)."""

    val output_dir = "build/artifacts/rust/ffi_{spec.name}"

    if not dry_run:
        dir_create_all(output_dir)
        dir_create_all("{output_dir}/src")

    generate_cargo_toml_rust(spec, output_dir, dry_run)
    generate_lib_rs_rust(spec, output_dir, dry_run)

    if dry_run:
        print "--- Tier 1 (Rust-native) would be generated to: {output_dir}/"
    else:
        print "Tier 1 generated (Rust-native): {output_dir}/"

# ============================================================================
# Helper: Check if type is a handle type
# ============================================================================

fn is_handle_type(type_name: text, spec: WrapperSpec) -> bool:
    for handle in spec.handle_types:
        if type_name == handle.name:
            return true
    false

fn get_handle_cpp_type(type_name: text, spec: WrapperSpec) -> text:
    """Get the underlying Rust/C++ type for a handle type."""
    for handle in spec.handle_types:
        if type_name == handle.name:
            return handle.cpp_type
    ""

# ============================================================================
# Cargo.toml Generation (Rust-native)
# ============================================================================

fn generate_cargo_toml_rust(spec: WrapperSpec, output_dir: text, dry_run: bool):
    var content = ""
    content = content + "[package]{NL}"
    content = content + "name = \"simple-{spec.name}-ffi\"{NL}"
    content = content + "version = \"{spec.version}\"{NL}"
    content = content + "edition = \"2021\"{NL}"
    content = content + "description = \"SFFI Rust-native wrapper for {spec.name} (auto-generated)\"{NL}{NL}"

    content = content + "[lib]{NL}"
    content = content + "name = \"simple_{spec.name}_ffi\"{NL}"
    content = content + "crate-type = [\"cdylib\"]{NL}{NL}"

    content = content + "[dependencies]{NL}"

    # Use rust_crate/rust_crate_version if specified, else fall back to name
    var crate_name = spec.rust_crate
    if crate_name == "":
        crate_name = spec.name
    var crate_version = spec.rust_crate_version
    if crate_version == "":
        crate_version = "1"

    content = content + "{crate_name} = \"{crate_version}\"{NL}"

    # Add link_libs as extra dependencies if specified
    for lib in spec.link_libs:
        if lib != crate_name:
            content = content + "{lib} = \"*\"{NL}"

    if dry_run:
        print "--- Cargo.toml ---"
        print content
    else:
        file_write("{output_dir}/Cargo.toml", content)

# ============================================================================
# lib.rs Generation (Rust-native with handle table)
# ============================================================================

fn generate_lib_rs_rust(spec: WrapperSpec, output_dir: text, dry_run: bool):
    var content = ""
    content = content + "// Auto-generated Rust-native FFI wrapper for {spec.name}{NL}"
    content = content + "// Generated by Simple wrapper-gen (lang: rust){NL}"
    content = content + "//{NL}"
    content = content + "// Pattern: Handle table with atomic counter{NL}"
    content = content + "// All functions use #[no_mangle] extern \"C\" for Simple runtime.{NL}{NL}"

    content = content + "#![allow(unused_imports)]{NL}"
    content = content + "#![allow(dead_code)]{NL}{NL}"

    content = content + "use std::collections::HashMap;{NL}"
    content = content + "use std::ffi::{CStr, CString};{NL}"
    content = content + "use std::os::raw::c_char;{NL}"
    content = content + "use std::sync::Mutex;{NL}"
    content = content + "use std::sync::atomic::{AtomicI64, Ordering};{NL}{NL}"

    # Import the Rust crate
    var crate_name = spec.rust_crate
    if crate_name == "":
        crate_name = spec.name
    # Rust crate names use underscores
    var crate_ident = crate_name.replace("-", "_")
    content = content + "use {crate_ident};{NL}{NL}"

    # Generate handle table for each handle type
    for handle in spec.handle_types:
        val h_upper = handle.name.upper()
        val rust_type = handle.cpp_type
        content = content + "// ============================================================================{NL}"
        content = content + "// Handle Table: {handle.name} -> {rust_type}{NL}"
        content = content + "// ============================================================================{NL}{NL}"

        content = content + "static {h_upper}_NEXT_ID: AtomicI64 = AtomicI64::new(1);{NL}"
        content = content + "static {h_upper}_HANDLES: Mutex<Option<HashMap<i64, {rust_type}>>> ={NL}"
        content = content + "    Mutex::new(None);{NL}{NL}"

        content = content + "fn {handle.name.lower()}_alloc(obj: {rust_type}) -> i64 {{NL}"
        content = content + "    let id = {h_upper}_NEXT_ID.fetch_add(1, Ordering::SeqCst);{NL}"
        content = content + "    let mut guard = {h_upper}_HANDLES.lock().unwrap();{NL}"
        content = content + "    let map = guard.get_or_insert_with(HashMap::new);{NL}"
        content = content + "    map.insert(id, obj);{NL}"
        content = content + "    id{NL}"
        content = content + "}{NL}{NL}"

        content = content + "fn {handle.name.lower()}_get<F, R>(id: i64, f: F) -> Option<R>{NL}"
        content = content + "where{NL}"
        content = content + "    F: FnOnce(&{rust_type}) -> R,{NL}"
        content = content + "{{NL}"
        content = content + "    let guard = {h_upper}_HANDLES.lock().unwrap();{NL}"
        content = content + "    guard.as_ref()?.get(&id).map(f){NL}"
        content = content + "}{NL}{NL}"

        content = content + "fn {handle.name.lower()}_free(id: i64) -> bool {{NL}"
        content = content + "    let mut guard = {h_upper}_HANDLES.lock().unwrap();{NL}"
        content = content + "    if let Some(map) = guard.as_mut() {{NL}"
        content = content + "        map.remove(&id).is_some(){NL}"
        content = content + "    } else {{NL}"
        content = content + "        false{NL}"
        content = content + "    }{NL}"
        content = content + "}{NL}{NL}"

    # Generate helper functions
    content = content + "// ============================================================================{NL}"
    content = content + "// FFI Helpers{NL}"
    content = content + "// ============================================================================{NL}{NL}"

    content = content + "unsafe fn cstr_to_str<'a>(ptr: *const c_char) -> &'a str {{NL}"
    content = content + "    if ptr.is_null() {{NL}"
    content = content + "        return \"\";{NL}"
    content = content + "    }{NL}"
    content = content + "    CStr::from_ptr(ptr).to_str().unwrap_or(\"\"){NL}"
    content = content + "}{NL}{NL}"

    content = content + "fn str_to_c(s: &str) -> *mut c_char {{NL}"
    content = content + "    CString::new(s).unwrap_or_default().into_raw(){NL}"
    content = content + "}{NL}{NL}"

    content = content + "fn string_to_c(s: String) -> *mut c_char {{NL}"
    content = content + "    CString::new(s).unwrap_or_default().into_raw(){NL}"
    content = content + "}{NL}{NL}"

    # Free string helper
    content = content + "#[no_mangle]{NL}"
    content = content + "pub extern \"C\" fn rt_{spec.name}_free_string(ptr: *mut c_char) {{NL}"
    content = content + "    if !ptr.is_null() {{NL}"
    content = content + "        unsafe {{NL}"
    content = content + "            let _ = CString::from_raw(ptr);{NL}"
    content = content + "        }{NL}"
    content = content + "    }{NL}"
    content = content + "}{NL}{NL}"

    # Generate function exports
    content = content + "// ============================================================================{NL}"
    content = content + "// Function Exports{NL}"
    content = content + "// ============================================================================{NL}{NL}"

    for func in spec.functions:
        content = content + gen_rust_fn_export(func, spec)

    # Generate method exports
    if spec.methods.len() > 0:
        content = content + "// ============================================================================{NL}"
        content = content + "// Method Exports{NL}"
        content = content + "// ============================================================================{NL}{NL}"

        for method in spec.methods:
            content = content + gen_rust_method_export(method, spec)

    # Library info
    content = content + "// ============================================================================{NL}"
    content = content + "// Library Info{NL}"
    content = content + "// ============================================================================{NL}{NL}"

    content = content + "#[no_mangle]{NL}"
    content = content + "pub extern \"C\" fn rt_{spec.name}_available() -> bool {{NL}"
    content = content + "    true{NL}"
    content = content + "}{NL}{NL}"

    content = content + "#[no_mangle]{NL}"
    content = content + "pub extern \"C\" fn rt_{spec.name}_version() -> *mut c_char {{NL}"
    content = content + "    string_to_c(\"{spec.name} {spec.version} (Rust-native SFFI)\".to_string()){NL}"
    content = content + "}{NL}"

    if dry_run:
        print "--- src/lib.rs ---"
        print content
    else:
        file_write("{output_dir}/src/lib.rs", content)

# ============================================================================
# Function Export Generation
# ============================================================================

fn gen_rust_fn_export(func: FunctionSpec, spec: WrapperSpec) -> text:
    var content = ""

    # Export name: rt_<lib>_<fn_name>
    val export_name = "rt_{spec.name}_{func.name}"

    content = content + "#[no_mangle]{NL}"
    content = content + "pub extern \"C\" fn {export_name}({NL}"

    # Parameters
    for param in func.params:
        val c_type = map_type_to_c(param.param_type, spec)
        content = content + "    {param.name}: {c_type},{NL}"

    # Return type
    val ret_type = map_return_to_c(func.return_type, spec)
    content = content + ") -> {ret_type} {{NL}"

    # Function body - call the underlying crate function
    # Generate parameter conversions
    content = content + "    unsafe {{NL}"

    for param in func.params:
        if param.param_type == "text":
            content = content + "        let {param.name}_s = cstr_to_str({param.name});{NL}"

    # Call the crate function
    var call_args = ""
    for param in func.params:
        if call_args != "":
            call_args = call_args + ", "
        if param.param_type == "text":
            call_args = call_args + "{param.name}_s"
        elif is_handle_type(param.param_type, spec):
            call_args = call_args + "{param.name}"
        else:
            call_args = call_args + "{param.name}"

    val cpp_fn = func.cpp_fn
    if cpp_fn != "":
        # Use specified function path
        if is_handle_type(func.return_type, spec):
            content = content + "        match {cpp_fn}({call_args}) {{NL}"
            content = content + "            Ok(result) => {func.return_type.lower()}_alloc(result),{NL}"
            content = content + "            Err(_) => 0,{NL}"
            content = content + "        }{NL}"
        elif func.return_type == "text":
            content = content + "        let result = {cpp_fn}({call_args});{NL}"
            content = content + "        string_to_c(result){NL}"
        elif func.return_type == "bool":
            content = content + "        {cpp_fn}({call_args}){NL}"
        elif func.return_type == "i64":
            content = content + "        {cpp_fn}({call_args}){NL}"
        elif func.return_type == "f64":
            content = content + "        {cpp_fn}({call_args}){NL}"
        else:
            content = content + "        {cpp_fn}({call_args}){NL}"
    else:
        # No cpp_fn specified - generate TODO placeholder
        val default_val = default_return_value_rust(func.return_type, spec)
        content = content + "        // TODO: Implement {export_name}{NL}"
        content = content + "        {default_val}{NL}"

    content = content + "    }{NL}"
    content = content + "}{NL}{NL}"

    content

# ============================================================================
# Method Export Generation
# ============================================================================

fn gen_rust_method_export(method: MethodSpec, spec: WrapperSpec) -> text:
    var content = ""

    val h_lower = method.handle.lower()
    val export_name = "rt_{spec.name}_{h_lower}_{method.name}"

    content = content + "#[no_mangle]{NL}"
    content = content + "pub extern \"C\" fn {export_name}({NL}"
    content = content + "    handle: i64,{NL}"

    for param in method.params:
        val c_type = map_type_to_c(param.param_type, spec)
        content = content + "    {param.name}: {c_type},{NL}"

    val ret_type = map_return_to_c(method.return_type, spec)
    content = content + ") -> {ret_type} {{NL}"

    # Method body - look up handle and call method
    val default_val = default_return_value_rust(method.return_type, spec)

    content = content + "    unsafe {{NL}"

    # Convert text params
    for param in method.params:
        if param.param_type == "text":
            content = content + "        let {param.name}_s = cstr_to_str({param.name});{NL}"

    val cpp_method = method.cpp_method
    if cpp_method != "":
        # Build method call args
        var call_args = ""
        for param in method.params:
            if call_args != "":
                call_args = call_args + ", "
            if param.param_type == "text":
                call_args = call_args + "{param.name}_s"
            else:
                call_args = call_args + "{param.name}"

        content = content + "        {h_lower}_get(handle, |obj| {{NL}"

        if is_handle_type(method.return_type, spec):
            content = content + "            let result = obj.{cpp_method}({call_args});{NL}"
            content = content + "            {method.return_type.lower()}_alloc(result){NL}"
        elif method.return_type == "text":
            content = content + "            let result = obj.{cpp_method}({call_args});{NL}"
            content = content + "            string_to_c(result){NL}"
        else:
            content = content + "            obj.{cpp_method}({call_args}){NL}"

        content = content + "        }).unwrap_or({default_val}){NL}"
    else:
        content = content + "        // TODO: Implement {export_name}{NL}"
        content = content + "        {default_val}{NL}"

    content = content + "    }{NL}"
    content = content + "}{NL}{NL}"

    content

# ============================================================================
# Type Mapping (Simple -> C ABI for Rust)
# ============================================================================

fn map_type_to_c(simple_type: text, spec: WrapperSpec) -> text:
    if simple_type == "text":
        return "*const c_char"
    elif simple_type == "i64":
        return "i64"
    elif simple_type == "i32":
        return "i32"
    elif simple_type == "f64":
        return "f64"
    elif simple_type == "f32":
        return "f32"
    elif simple_type == "bool":
        return "bool"
    elif simple_type == "[i64]":
        return "*const i64"
    elif simple_type == "[f64]":
        return "*const f64"
    elif is_handle_type(simple_type, spec):
        return "i64"
    else:
        return simple_type

fn map_return_to_c(simple_type: text, spec: WrapperSpec) -> text:
    if simple_type == "text":
        return "*mut c_char"
    elif simple_type == "i64":
        return "i64"
    elif simple_type == "i32":
        return "i32"
    elif simple_type == "f64":
        return "f64"
    elif simple_type == "f32":
        return "f32"
    elif simple_type == "bool":
        return "bool"
    elif simple_type == "[i64]" or simple_type == "[f64]" or simple_type == "[text]":
        return "i64"
    elif is_handle_type(simple_type, spec):
        return "i64"
    elif simple_type == "":
        return "()"
    else:
        return simple_type

fn default_return_value_rust(simple_type: text, spec: WrapperSpec) -> text:
    if is_handle_type(simple_type, spec):
        return "0i64"
    elif simple_type == "text":
        return "std::ptr::null_mut()"
    elif simple_type == "i64":
        return "0i64"
    elif simple_type == "i32":
        return "0i32"
    elif simple_type == "f64":
        return "0.0f64"
    elif simple_type == "f32":
        return "0.0f32"
    elif simple_type == "bool":
        return "false"
    elif simple_type == "[i64]" or simple_type == "[f64]" or simple_type == "[text]":
        return "0i64"
    elif simple_type == "":
        return "()"
    else:
        return "0i64"

export generate_tier1_rust
