# Tier 1 Generator - Cargo/Build File Generation
#
# Generates Cargo.toml and build.rs for the Rust/C++ wrapper crate.

use app.io.{file_write, print}
use app.wrapper_gen.spec_parser.{WrapperSpec}
use app.wrapper_gen.tier1_helpers.{lib_upper, is_embedded}
use std.text.{NL}

# ============================================================================
# Cargo.toml Generation
# ============================================================================

fn generate_cargo_toml(spec: WrapperSpec, output_dir: text, dry_run: bool):
    var content = ""
    content = content + "[package]{NL}"
    content = content + "name = \"simple-{spec.name}\"{NL}"
    content = content + "version = \"{spec.version}\"{NL}"
    content = content + "edition = \"2021\"{NL}"
    content = content + "description = \"SFFI wrapper for {spec.name} (auto-generated)\"{NL}{NL}"

    content = content + "[lib]{NL}"
    content = content + "name = \"simple_{spec.name}\"{NL}"
    content = content + "crate-type = [\"cdylib\", \"staticlib\"]{NL}{NL}"

    content = content + "[dependencies]{NL}"
    content = content + "cxx = \"1.0\"{NL}{NL}"

    content = content + "[build-dependencies]{NL}"
    content = content + "cxx-build = \"1.0\"{NL}{NL}"

    content = content + "[features]{NL}"
    content = content + "default = [\"stub\"]{NL}"
    content = content + "stub = []{NL}"

    if dry_run:
        print "--- Cargo.toml ---"
        print content
    else:
        file_write("{output_dir}/Cargo.toml", content)

# ============================================================================
# build.rs Generation
# ============================================================================

fn generate_build_rs(spec: WrapperSpec, output_dir: text, dry_run: bool):
    val upper = lib_upper(spec)
    val embedded = is_embedded(spec)
    var content = ""
    content = content + "// Auto-generated build script for {spec.name}{NL}{NL}"
    content = content + "fn main() {{NL}"
    content = content + "    println!(\"cargo:rerun-if-changed=src/lib.rs\");{NL}"
    content = content + "    println!(\"cargo:rerun-if-changed=src/bridge.cpp\");{NL}"
    content = content + "    println!(\"cargo:rerun-if-changed=src/bridge.h\");{NL}{NL}"

    content = content + "    let mut build = cxx_build::bridge(\"src/lib.rs\");{NL}"
    content = content + "    build{NL}"
    content = content + "        .file(\"src/bridge.cpp\"){NL}"
    content = content + "        .flag_if_supported(\"-std=c++17\"){NL}"

    # Add include paths
    for inc_path in spec.include_paths:
        content = content + "        .include(\"{inc_path}\"){NL}"

    if not embedded:
        # External library: add conditional define
        content = content + "        .define(\"HAS_{upper}\", None){NL}"

    content = content + "        .compile(\"simple-{spec.name}-bridge\");{NL}{NL}"

    # Add library search paths
    for search_path in spec.search_paths:
        content = content + "    println!(\"cargo:rustc-link-search=native={search_path}\");{NL}"

    # Add library linking
    for lib in spec.link_libs:
        content = content + "    println!(\"cargo:rustc-link-lib={lib}\");{NL}"

    if embedded:
        # Embedded library: link pthread for mutex/condvar
        content = content + "    // Embedded library - link pthread for std::mutex/condition_variable{NL}"
        content = content + "    println!(\"cargo:rustc-link-lib=pthread\");{NL}"

    content = content + "}{NL}"

    if dry_run:
        print "--- build.rs ---"
        print content
    else:
        file_write("{output_dir}/build.rs", content)

export generate_cargo_toml, generate_build_rs
