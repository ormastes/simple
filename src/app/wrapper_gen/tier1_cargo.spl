# Tier 1 Generator - Cargo/Build File Generation
#
# Generates Cargo.toml and build.rs for the Rust/C++ wrapper crate.

use app.io.{file_write, print}
use app.wrapper_gen.spec_parser.{WrapperSpec}
use app.wrapper_gen.tier1_helpers.{lib_upper, is_embedded}

# ============================================================================
# Cargo.toml Generation
# ============================================================================

fn generate_cargo_toml(spec: WrapperSpec, output_dir: text, dry_run: bool):
    var content = ""
    content = content + "[package]\n"
    content = content + "name = \"simple-{spec.name}\"\n"
    content = content + "version = \"{spec.version}\"\n"
    content = content + "edition = \"2021\"\n"
    content = content + "description = \"SFFI wrapper for {spec.name} (auto-generated)\"\n\n"

    content = content + "[lib]\n"
    content = content + "name = \"simple_{spec.name}\"\n"
    content = content + "crate-type = [\"cdylib\", \"staticlib\"]\n\n"

    content = content + "[dependencies]\n"
    content = content + "cxx = \"1.0\"\n\n"

    content = content + "[build-dependencies]\n"
    content = content + "cxx-build = \"1.0\"\n\n"

    content = content + "[features]\n"
    content = content + "default = [\"stub\"]\n"
    content = content + "stub = []\n"

    if dry_run:
        print "--- Cargo.toml ---"
        print content
    else:
        file_write("{output_dir}/Cargo.toml", content)

# ============================================================================
# build.rs Generation
# ============================================================================

fn generate_build_rs(spec: WrapperSpec, output_dir: text, dry_run: bool):
    val upper = lib_upper(spec)
    val embedded = is_embedded(spec)
    var content = ""
    content = content + "// Auto-generated build script for {spec.name}\n\n"
    content = content + "fn main() {\n"
    content = content + "    println!(\"cargo:rerun-if-changed=src/lib.rs\");\n"
    content = content + "    println!(\"cargo:rerun-if-changed=src/bridge.cpp\");\n"
    content = content + "    println!(\"cargo:rerun-if-changed=src/bridge.h\");\n\n"

    content = content + "    let mut build = cxx_build::bridge(\"src/lib.rs\");\n"
    content = content + "    build\n"
    content = content + "        .file(\"src/bridge.cpp\")\n"
    content = content + "        .flag_if_supported(\"-std=c++17\")\n"

    # Add include paths
    for inc_path in spec.include_paths:
        content = content + "        .include(\"{inc_path}\")\n"

    if not embedded:
        # External library: add conditional define
        content = content + "        .define(\"HAS_{upper}\", None)\n"

    content = content + "        .compile(\"simple-{spec.name}-bridge\");\n\n"

    # Add library search paths
    for search_path in spec.search_paths:
        content = content + "    println!(\"cargo:rustc-link-search=native={search_path}\");\n"

    # Add library linking
    for lib in spec.link_libs:
        content = content + "    println!(\"cargo:rustc-link-lib={lib}\");\n"

    if embedded:
        # Embedded library: link pthread for mutex/condvar
        content = content + "    // Embedded library - link pthread for std::mutex/condition_variable\n"
        content = content + "    println!(\"cargo:rustc-link-lib=pthread\");\n"

    content = content + "}\n"

    if dry_run:
        print "--- build.rs ---"
        print content
    else:
        file_write("{output_dir}/build.rs", content)

export generate_cargo_toml, generate_build_rs
