# Tier 1 Generator - C++ Code Generation
#
# Generates src/bridge.h and src/bridge.cpp for the C++ bridge layer.

use app.io.{file_write, print}
use app.wrapper_gen.spec_parser.{WrapperSpec, ParamSpec, FunctionSpec, MethodSpec}
use app.wrapper_gen.tier1_helpers.{is_handle_type, lib_upper, is_embedded, qualified_fn_name, is_void_return}
use app.wrapper_gen.tier1_types.{map_type_to_cpp_param, map_return_to_cpp, cpp_default_return}

# ============================================================================
# bridge.h Generation (C++ header)
# ============================================================================

fn generate_bridge_h(spec: WrapperSpec, output_dir: text, dry_run: bool):
    val upper = lib_upper(spec)
    val embedded = is_embedded(spec)
    var content = ""
    content = content + "// Auto-generated C++ bridge header for {spec.name}\n"
    content = content + "#pragma once\n\n"
    content = content + "#include <cstdint>\n"
    content = content + "#include <memory>\n"
    content = content + "#include <vector>\n"
    content = content + "#include <string>\n"
    content = content + "#include <map>\n"
    content = content + "#include \"rust/cxx.h\"\n"

    if embedded:
        # Embedded library: add extra includes for implementation
        content = content + "#include <mutex>\n"
        content = content + "#include <condition_variable>\n"
    content = content + "\n"

    # Conditional library include
    if spec.cpp_include != "":
        content = content + "#ifdef HAS_{upper}\n"
        content = content + "#include <{spec.cpp_include}>\n"
        content = content + "#else\n"
        content = content + "// Stub declarations when library is not available\n"
        content = content + "#endif\n\n"

    # Wrapper structs for each handle type
    for handle in spec.handle_types:
        content = content + "// Opaque wrapper for {handle.cpp_type}\n"
        content = content + "struct {handle.name} {\n"
        content = content + "#ifdef HAS_{upper}\n"
        content = content + "    {handle.cpp_type} inner;\n"
        content = content + "    {handle.name}({handle.cpp_type} t);\n"
        content = content + "#else\n"
        content = content + "    {handle.name}();\n"
        content = content + "#endif\n"
        content = content + "    ~{handle.name}();\n"
        content = content + "};\n\n"

    # Function declarations
    content = content + "// ============================================================================\n"
    content = content + "// Function Declarations\n"
    content = content + "// ============================================================================\n\n"

    for func in spec.functions:
        content = content + gen_h_fn_decl(func, spec)

    content = content + "\n"

    # Method declarations (as free functions)
    content = content + "// ============================================================================\n"
    content = content + "// Method Declarations\n"
    content = content + "// ============================================================================\n\n"

    for method in spec.methods:
        content = content + gen_h_method_decl(method, spec)

    content = content + "\n"

    # Library info declarations
    content = content + "// ============================================================================\n"
    content = content + "// Library Info\n"
    content = content + "// ============================================================================\n\n"
    content = content + "bool {spec.name}_available();\n"
    content = content + "rust::String {spec.name}_version();\n"

    if dry_run:
        print "--- src/bridge.h ---"
        print content
    else:
        file_write("{output_dir}/src/bridge.h", content)

fn gen_h_fn_decl(func: FunctionSpec, spec: WrapperSpec) -> text:
    var params = ""
    for param in func.params:
        if params != "":
            params = params + ", "
        val cpp_type = map_type_to_cpp_param(param.param_type, spec)
        params = params + "{cpp_type} {param.name}"

    val qname = qualified_fn_name(spec.name, func.name)
    val ret = map_return_to_cpp(func.return_type, spec)
    "{ret} {qname}({params});\n"

fn gen_h_method_decl(method: MethodSpec, spec: WrapperSpec) -> text:
    val h_lower = method.handle.lower()
    var params = "const {method.handle}& h"
    for param in method.params:
        val cpp_type = map_type_to_cpp_param(param.param_type, spec)
        params = params + ", {cpp_type} {param.name}"

    val qname = qualified_fn_name(spec.name, "{h_lower}_{method.name}")
    val ret = map_return_to_cpp(method.return_type, spec)
    "{ret} {qname}({params});\n"

# ============================================================================
# bridge.cpp Generation (C++ implementation)
# ============================================================================

fn generate_bridge_cpp(spec: WrapperSpec, output_dir: text, dry_run: bool):
    val upper = lib_upper(spec)
    var content = ""
    content = content + "// Auto-generated C++ bridge implementation for {spec.name}\n\n"
    content = content + "#include \"bridge.h\"\n\n"

    # Conditional include
    if spec.cpp_include != "":
        content = content + "#ifdef HAS_{upper}\n"
        content = content + "#include <{spec.cpp_include}>\n"
        content = content + "#else\n"
        content = content + "// Stub types when library is not available\n"
        # Generate minimal stub types based on handle types
        for handle in spec.handle_types:
            # Only generate stubs for complex types (not raw pointers)
            if not handle.cpp_type.ends_with("*"):
                val parts = handle.cpp_type.split("::")
                if parts.len() >= 2:
                    var ns = parts[0]
                    var idx = 1
                    while idx < parts.len() - 1:
                        ns = ns + "::" + parts[idx]
                        idx = idx + 1
                    val cls = parts[parts.len() - 1]
                    content = content + "namespace {ns} {\n"
                    content = content + "    class {cls} {\n"
                    content = content + "    public:\n"
                    content = content + "        {cls}() {}\n"
                    content = content + "    };\n"
                    content = content + "}\n"
        content = content + "#endif\n\n"

    # Wrapper struct constructors/destructors
    content = content + "// ============================================================================\n"
    content = content + "// Wrapper Struct Implementations\n"
    content = content + "// ============================================================================\n\n"

    for handle in spec.handle_types:
        content = content + "#ifdef HAS_{upper}\n"
        content = content + "{handle.name}::{handle.name}({handle.cpp_type} t) : inner(std::move(t)) {}\n"
        content = content + "#else\n"
        content = content + "{handle.name}::{handle.name}() {}\n"
        content = content + "#endif\n"
        content = content + "{handle.name}::~{handle.name}() = default;\n\n"

    # Function implementations
    content = content + "// ============================================================================\n"
    content = content + "// Function Implementations\n"
    content = content + "// ============================================================================\n\n"

    for func in spec.functions:
        content = content + gen_cpp_fn_impl(func, spec)

    # Method implementations
    content = content + "// ============================================================================\n"
    content = content + "// Method Implementations\n"
    content = content + "// ============================================================================\n\n"

    for method in spec.methods:
        content = content + gen_cpp_method_impl(method, spec)

    # Library info implementations
    content = content + "// ============================================================================\n"
    content = content + "// Library Info\n"
    content = content + "// ============================================================================\n\n"

    val embedded = is_embedded(spec)

    if embedded:
        # Embedded library: always available
        content = content + "bool {spec.name}_available() {\n"
        content = content + "    return true;\n"
        content = content + "}\n\n"

        content = content + "rust::String {spec.name}_version() {\n"
        content = content + "    return rust::String(\"{spec.name} {spec.version} (embedded)\");\n"
        content = content + "}\n"
    else:
        content = content + "bool {spec.name}_available() {\n"
        content = content + "#ifdef HAS_{upper}\n"
        content = content + "    return true;\n"
        content = content + "#else\n"
        content = content + "    return false;\n"
        content = content + "#endif\n"
        content = content + "}\n\n"

        content = content + "rust::String {spec.name}_version() {\n"
        content = content + "#ifdef HAS_{upper}\n"
        content = content + "    return rust::String(\"{spec.name} {spec.version} (cxx bridge)\");\n"
        content = content + "#else\n"
        content = content + "    return rust::String(\"{spec.name} stub (library not linked)\");\n"
        content = content + "#endif\n"
        content = content + "}\n"

    if dry_run:
        print "--- src/bridge.cpp ---"
        print content
    else:
        file_write("{output_dir}/src/bridge.cpp", content)

# Helper: Build parameter conversions and call arguments
fn build_param_conversions(params: [ParamSpec], spec: WrapperSpec) -> (text, text):
    var content = ""
    var call_args = ""
    for param in params:
        if param.param_type == "[i64]":
            content = content + "    std::vector<int64_t> {param.name}_vec({param.name}.begin(), {param.name}.end());\n"
            if call_args != "":
                call_args = call_args + ", "
            call_args = call_args + "{param.name}_vec"
        elif param.param_type == "[f64]":
            content = content + "    std::vector<double> {param.name}_vec({param.name}.begin(), {param.name}.end());\n"
            if call_args != "":
                call_args = call_args + ", "
            call_args = call_args + "{param.name}_vec"
        elif param.param_type == "text":
            content = content + "    std::string {param.name}_str({param.name}.begin(), {param.name}.end());\n"
            if call_args != "":
                call_args = call_args + ", "
            call_args = call_args + "{param.name}_str"
        elif is_handle_type(param.param_type, spec):
            if call_args != "":
                call_args = call_args + ", "
            call_args = call_args + "{param.name}.inner"
        else:
            if call_args != "":
                call_args = call_args + ", "
            call_args = call_args + "{param.name}"
    (content, call_args)

fn gen_cpp_fn_impl(func: FunctionSpec, spec: WrapperSpec) -> text:
    val upper = lib_upper(spec)
    val qname = qualified_fn_name(spec.name, func.name)
    val embedded = is_embedded(spec)

    # Build parameter list
    var params = ""
    for param in func.params:
        if params != "":
            params = params + ", "
        val cpp_type = map_type_to_cpp_param(param.param_type, spec)
        params = params + "{cpp_type} {param.name}"

    val ret = map_return_to_cpp(func.return_type, spec)
    var content = ""
    content = content + "{ret} {qname}({params}) {\n"

    # For embedded libraries (no external deps), always generate stub body
    # For external libraries with cpp_fn, use #ifdef pattern
    val has_cpp_fn = func.cpp_fn != ""

    if embedded or not has_cpp_fn:
        # Embedded mode or no cpp_fn: generate direct stub (no #ifdef)
        content = content + "    // TODO: Implement {qname}\n"
        val stub_ret = cpp_default_return(func.return_type, spec)
        content = content + "    {stub_ret}\n"
    else:
        # External library mode: use #ifdef pattern
        content = content + "#ifdef HAS_{upper}\n"

        # Build argument conversions and call
        val (conv_content, call_args) = build_param_conversions(func.params, spec)
        content = content + conv_content

        # Generate the call and return
        if is_void_return(func.return_type):
            content = content + "    {func.cpp_fn}({call_args});\n"
        elif is_handle_type(func.return_type, spec):
            content = content + "    auto result = {func.cpp_fn}({call_args});\n"
            content = content + "    return std::make_unique<{func.return_type}>(result);\n"
        elif func.return_type == "text":
            content = content + "    auto result = {func.cpp_fn}({call_args});\n"
            content = content + "    return rust::String(result);\n"
        elif func.return_type == "[i64]":
            content = content + "    auto result = {func.cpp_fn}({call_args});\n"
            content = content + "    rust::Vec<int64_t> out;\n"
            content = content + "    for (auto v : result) {\n"
            content = content + "        out.push_back(v);\n"
            content = content + "    }\n"
            content = content + "    return out;\n"
        elif func.return_type == "[text]":
            content = content + "    auto result = {func.cpp_fn}({call_args});\n"
            content = content + "    rust::Vec<rust::String> out;\n"
            content = content + "    for (auto& v : result) {\n"
            content = content + "        out.push_back(rust::String(v));\n"
            content = content + "    }\n"
            content = content + "    return out;\n"
        else:
            content = content + "    return {func.cpp_fn}({call_args});\n"

        content = content + "#else\n"

        # Stub return
        val stub_ret = cpp_default_return(func.return_type, spec)
        content = content + "    {stub_ret}\n"

        content = content + "#endif\n"

    content = content + "}\n\n"

    content

fn gen_cpp_method_impl(method: MethodSpec, spec: WrapperSpec) -> text:
    val upper = lib_upper(spec)
    val h_lower = method.handle.lower()
    val qname = qualified_fn_name(spec.name, "{h_lower}_{method.name}")
    val embedded = is_embedded(spec)

    # Build parameter list
    var params = "const {method.handle}& h"
    for param in method.params:
        val cpp_type = map_type_to_cpp_param(param.param_type, spec)
        params = params + ", {cpp_type} {param.name}"

    val ret = map_return_to_cpp(method.return_type, spec)
    var content = ""
    content = content + "{ret} {qname}({params}) {\n"

    val has_cpp_method = method.cpp_method != ""

    if embedded or not has_cpp_method:
        # Embedded mode: generate direct stub
        content = content + "    // TODO: Implement {qname}\n"
        val stub_ret = cpp_default_return(method.return_type, spec)
        content = content + "    {stub_ret}\n"
    else:
        content = content + "#ifdef HAS_{upper}\n"

        # Build call arguments (method call on handle's inner)
        val (conv_content, call_args) = build_param_conversions(method.params, spec)
        content = content + conv_content

        # Generate the call and return (method call on inner)
        if is_void_return(method.return_type):
            content = content + "    h.inner.{method.cpp_method}({call_args});\n"
        elif is_handle_type(method.return_type, spec):
            content = content + "    auto result = h.inner.{method.cpp_method}({call_args});\n"
            content = content + "    return std::make_unique<{method.return_type}>(result);\n"
        elif method.return_type == "text":
            content = content + "    auto result = h.inner.{method.cpp_method}({call_args});\n"
            content = content + "    return rust::String(result);\n"
        elif method.return_type == "[i64]":
            content = content + "    auto sizes = h.inner.{method.cpp_method}({call_args});\n"
            content = content + "    rust::Vec<int64_t> result;\n"
            content = content + "    for (auto size : sizes) {\n"
            content = content + "        result.push_back(size);\n"
            content = content + "    }\n"
            content = content + "    return result;\n"
        elif method.return_type == "[text]":
            content = content + "    auto items = h.inner.{method.cpp_method}({call_args});\n"
            content = content + "    rust::Vec<rust::String> result;\n"
            content = content + "    for (auto& item : items) {\n"
            content = content + "        result.push_back(rust::String(item));\n"
            content = content + "    }\n"
            content = content + "    return result;\n"
        else:
            content = content + "    return h.inner.{method.cpp_method}({call_args});\n"

        content = content + "#else\n"

        # Stub return
        val stub_ret = cpp_default_return(method.return_type, spec)
        content = content + "    {stub_ret}\n"

        content = content + "#endif\n"

    content = content + "}\n\n"

    content

export generate_bridge_h, generate_bridge_cpp
export gen_h_fn_decl, gen_h_method_decl
export gen_cpp_fn_impl, gen_cpp_method_impl
export build_param_conversions
