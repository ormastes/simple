# Tier 1 Generator - C++ Code Generation
#
# Generates src/bridge.h and src/bridge.cpp for the C++ bridge layer.

use app.io.{file_write, print}
use app.wrapper_gen.spec_parser.{WrapperSpec, ParamSpec, FunctionSpec, MethodSpec}
use app.wrapper_gen.tier1_helpers.{is_handle_type, lib_upper, is_embedded, qualified_fn_name, is_void_return}
use app.wrapper_gen.tier1_types.{map_type_to_cpp_param, map_return_to_cpp, cpp_default_return}
use std.string.{NL}

# ============================================================================
# bridge.h Generation (C++ header)
# ============================================================================

fn generate_bridge_h(spec: WrapperSpec, output_dir: text, dry_run: bool):
    val upper = lib_upper(spec)
    val embedded = is_embedded(spec)
    var content = ""
    content = content + "// Auto-generated C++ bridge header for {spec.name}{NL}"
    content = content + "#pragma once{NL}{NL}"
    content = content + "#include <cstdint>{NL}"
    content = content + "#include <memory>{NL}"
    content = content + "#include <vector>{NL}"
    content = content + "#include <string>{NL}"
    content = content + "#include <map>{NL}"
    content = content + "#include \"rust/cxx.h\"{NL}"

    if embedded:
        # Embedded library: add extra includes for implementation
        content = content + "#include <mutex>{NL}"
        content = content + "#include <condition_variable>{NL}"
    content = content + NL

    # Conditional library include
    if spec.cpp_include != "":
        content = content + "#ifdef HAS_{upper}{NL}"
        content = content + "#include <{spec.cpp_include}>{NL}"
        content = content + "#else{NL}"
        content = content + "// Stub declarations when library is not available{NL}"
        content = content + "#endif{NL}{NL}"

    # Wrapper structs for each handle type
    for handle in spec.handle_types:
        content = content + "// Opaque wrapper for {handle.cpp_type}{NL}"
        content = content + "struct {handle.name} {{NL}"
        content = content + "#ifdef HAS_{upper}{NL}"
        content = content + "    {handle.cpp_type} inner;{NL}"
        content = content + "    {handle.name}({handle.cpp_type} t);{NL}"
        content = content + "#else{NL}"
        content = content + "    {handle.name}();{NL}"
        content = content + "#endif{NL}"
        content = content + "    ~{handle.name}();{NL}"
        content = content + "};{NL}{NL}"

    # Function declarations
    content = content + "// ============================================================================{NL}"
    content = content + "// Function Declarations{NL}"
    content = content + "// ============================================================================{NL}{NL}"

    for func in spec.functions:
        content = content + gen_h_fn_decl(func, spec)

    content = content + NL

    # Method declarations (as free functions)
    content = content + "// ============================================================================{NL}"
    content = content + "// Method Declarations{NL}"
    content = content + "// ============================================================================{NL}{NL}"

    for method in spec.methods:
        content = content + gen_h_method_decl(method, spec)

    content = content + NL

    # Library info declarations
    content = content + "// ============================================================================{NL}"
    content = content + "// Library Info{NL}"
    content = content + "// ============================================================================{NL}{NL}"
    content = content + "bool {spec.name}_available();{NL}"
    content = content + "rust::String {spec.name}_version();{NL}"

    if dry_run:
        print "--- src/bridge.h ---"
        print content
    else:
        file_write("{output_dir}/src/bridge.h", content)

fn gen_h_fn_decl(func: FunctionSpec, spec: WrapperSpec) -> text:
    var params = ""
    for param in func.params:
        if params != "":
            params = params + ", "
        val cpp_type = map_type_to_cpp_param(param.param_type, spec)
        params = params + "{cpp_type} {param.name}"

    val qname = qualified_fn_name(spec.name, func.name)
    val ret = map_return_to_cpp(func.return_type, spec)
    "{ret} {qname}({params});{NL}"

fn gen_h_method_decl(method: MethodSpec, spec: WrapperSpec) -> text:
    val h_lower = method.handle.lower()
    var params = "const {method.handle}& h"
    for param in method.params:
        val cpp_type = map_type_to_cpp_param(param.param_type, spec)
        params = params + ", {cpp_type} {param.name}"

    val qname = qualified_fn_name(spec.name, "{h_lower}_{method.name}")
    val ret = map_return_to_cpp(method.return_type, spec)
    "{ret} {qname}({params});{NL}"

# ============================================================================
# bridge.cpp Generation (C++ implementation)
# ============================================================================

fn generate_bridge_cpp(spec: WrapperSpec, output_dir: text, dry_run: bool):
    val upper = lib_upper(spec)
    var content = ""
    content = content + "// Auto-generated C++ bridge implementation for {spec.name}{NL}{NL}"
    content = content + "#include \"bridge.h\"{NL}{NL}"

    # Conditional include
    if spec.cpp_include != "":
        content = content + "#ifdef HAS_{upper}{NL}"
        content = content + "#include <{spec.cpp_include}>{NL}"
        content = content + "#else{NL}"
        content = content + "// Stub types when library is not available{NL}"
        # Generate minimal stub types based on handle types
        for handle in spec.handle_types:
            # Only generate stubs for complex types (not raw pointers)
            if not handle.cpp_type.ends_with("*"):
                val parts = handle.cpp_type.split("::")
                if parts.len() >= 2:
                    var ns = parts[0]
                    var idx = 1
                    while idx < parts.len() - 1:
                        ns = ns + "::" + parts[idx]
                        idx = idx + 1
                    val cls = parts[parts.len() - 1]
                    content = content + "namespace {ns} {{NL}"
                    content = content + "    class {cls} {{NL}"
                    content = content + "    public:{NL}"
                    content = content + "        {cls}() {}{NL}"
                    content = content + "    };{NL}"
                    content = content + "}{NL}"
        content = content + "#endif{NL}{NL}"

    # Wrapper struct constructors/destructors
    content = content + "// ============================================================================{NL}"
    content = content + "// Wrapper Struct Implementations{NL}"
    content = content + "// ============================================================================{NL}{NL}"

    for handle in spec.handle_types:
        content = content + "#ifdef HAS_{upper}{NL}"
        content = content + "{handle.name}::{handle.name}({handle.cpp_type} t) : inner(std::move(t)) {}{NL}"
        content = content + "#else{NL}"
        content = content + "{handle.name}::{handle.name}() {}{NL}"
        content = content + "#endif{NL}"
        content = content + "{handle.name}::~{handle.name}() = default;{NL}{NL}"

    # Function implementations
    content = content + "// ============================================================================{NL}"
    content = content + "// Function Implementations{NL}"
    content = content + "// ============================================================================{NL}{NL}"

    for func in spec.functions:
        content = content + gen_cpp_fn_impl(func, spec)

    # Method implementations
    content = content + "// ============================================================================{NL}"
    content = content + "// Method Implementations{NL}"
    content = content + "// ============================================================================{NL}{NL}"

    for method in spec.methods:
        content = content + gen_cpp_method_impl(method, spec)

    # Library info implementations
    content = content + "// ============================================================================{NL}"
    content = content + "// Library Info{NL}"
    content = content + "// ============================================================================{NL}{NL}"

    val embedded = is_embedded(spec)

    if embedded:
        # Embedded library: always available
        content = content + "bool {spec.name}_available() {{NL}"
        content = content + "    return true;{NL}"
        content = content + "}{NL}{NL}"

        content = content + "rust::String {spec.name}_version() {{NL}"
        content = content + "    return rust::String(\"{spec.name} {spec.version} (embedded)\");{NL}"
        content = content + "}{NL}"
    else:
        content = content + "bool {spec.name}_available() {{NL}"
        content = content + "#ifdef HAS_{upper}{NL}"
        content = content + "    return true;{NL}"
        content = content + "#else{NL}"
        content = content + "    return false;{NL}"
        content = content + "#endif{NL}"
        content = content + "}{NL}{NL}"

        content = content + "rust::String {spec.name}_version() {{NL}"
        content = content + "#ifdef HAS_{upper}{NL}"
        content = content + "    return rust::String(\"{spec.name} {spec.version} (cxx bridge)\");{NL}"
        content = content + "#else{NL}"
        content = content + "    return rust::String(\"{spec.name} stub (library not linked)\");{NL}"
        content = content + "#endif{NL}"
        content = content + "}{NL}"

    if dry_run:
        print "--- src/bridge.cpp ---"
        print content
    else:
        file_write("{output_dir}/src/bridge.cpp", content)

# Helper: Build parameter conversions and call arguments
fn build_param_conversions(params: [ParamSpec], spec: WrapperSpec) -> (text, text):
    var content = ""
    var call_args = ""
    for param in params:
        if param.param_type == "[i64]":
            content = content + "    std::vector<int64_t> {param.name}_vec({param.name}.begin(), {param.name}.end());{NL}"
            if call_args != "":
                call_args = call_args + ", "
            call_args = call_args + "{param.name}_vec"
        elif param.param_type == "[f64]":
            content = content + "    std::vector<double> {param.name}_vec({param.name}.begin(), {param.name}.end());{NL}"
            if call_args != "":
                call_args = call_args + ", "
            call_args = call_args + "{param.name}_vec"
        elif param.param_type == "text":
            content = content + "    std::string {param.name}_str({param.name}.begin(), {param.name}.end());{NL}"
            if call_args != "":
                call_args = call_args + ", "
            call_args = call_args + "{param.name}_str"
        elif is_handle_type(param.param_type, spec):
            if call_args != "":
                call_args = call_args + ", "
            call_args = call_args + "{param.name}.inner"
        else:
            if call_args != "":
                call_args = call_args + ", "
            call_args = call_args + "{param.name}"
    (content, call_args)

fn gen_cpp_fn_impl(func: FunctionSpec, spec: WrapperSpec) -> text:
    val upper = lib_upper(spec)
    val qname = qualified_fn_name(spec.name, func.name)
    val embedded = is_embedded(spec)

    # Build parameter list
    var params = ""
    for param in func.params:
        if params != "":
            params = params + ", "
        val cpp_type = map_type_to_cpp_param(param.param_type, spec)
        params = params + "{cpp_type} {param.name}"

    val ret = map_return_to_cpp(func.return_type, spec)
    var content = ""
    content = content + "{ret} {qname}({params}) {{NL}"

    # For embedded libraries (no external deps), always generate stub body
    # For external libraries with cpp_fn, use #ifdef pattern
    val has_cpp_fn = func.cpp_fn != ""

    if embedded or not has_cpp_fn:
        # Embedded mode or no cpp_fn: generate direct stub (no #ifdef)
        content = content + "    // TODO: Implement {qname}{NL}"
        val stub_ret = cpp_default_return(func.return_type, spec)
        content = content + "    {stub_ret}{NL}"
    else:
        # External library mode: use #ifdef pattern
        content = content + "#ifdef HAS_{upper}{NL}"

        # Build argument conversions and call
        val (conv_content, call_args) = build_param_conversions(func.params, spec)
        content = content + conv_content

        # Generate the call and return
        if is_void_return(func.return_type):
            content = content + "    {func.cpp_fn}({call_args});{NL}"
        elif is_handle_type(func.return_type, spec):
            content = content + "    auto result = {func.cpp_fn}({call_args});{NL}"
            content = content + "    return std::make_unique<{func.return_type}>(result);{NL}"
        elif func.return_type == "text":
            content = content + "    auto result = {func.cpp_fn}({call_args});{NL}"
            content = content + "    return rust::String(result);{NL}"
        elif func.return_type == "[i64]":
            content = content + "    auto result = {func.cpp_fn}({call_args});{NL}"
            content = content + "    rust::Vec<int64_t> out;{NL}"
            content = content + "    for (auto v : result) {{NL}"
            content = content + "        out.push_back(v);{NL}"
            content = content + "    }{NL}"
            content = content + "    return out;{NL}"
        elif func.return_type == "[text]":
            content = content + "    auto result = {func.cpp_fn}({call_args});{NL}"
            content = content + "    rust::Vec<rust::String> out;{NL}"
            content = content + "    for (auto& v : result) {{NL}"
            content = content + "        out.push_back(rust::String(v));{NL}"
            content = content + "    }{NL}"
            content = content + "    return out;{NL}"
        else:
            content = content + "    return {func.cpp_fn}({call_args});{NL}"

        content = content + "#else{NL}"

        # Stub return
        val stub_ret = cpp_default_return(func.return_type, spec)
        content = content + "    {stub_ret}{NL}"

        content = content + "#endif{NL}"

    content = content + "}{NL}{NL}"

    content

fn gen_cpp_method_impl(method: MethodSpec, spec: WrapperSpec) -> text:
    val upper = lib_upper(spec)
    val h_lower = method.handle.lower()
    val qname = qualified_fn_name(spec.name, "{h_lower}_{method.name}")
    val embedded = is_embedded(spec)

    # Build parameter list
    var params = "const {method.handle}& h"
    for param in method.params:
        val cpp_type = map_type_to_cpp_param(param.param_type, spec)
        params = params + ", {cpp_type} {param.name}"

    val ret = map_return_to_cpp(method.return_type, spec)
    var content = ""
    content = content + "{ret} {qname}({params}) {{NL}"

    val has_cpp_method = method.cpp_method != ""

    if embedded or not has_cpp_method:
        # Embedded mode: generate direct stub
        content = content + "    // TODO: Implement {qname}{NL}"
        val stub_ret = cpp_default_return(method.return_type, spec)
        content = content + "    {stub_ret}{NL}"
    else:
        content = content + "#ifdef HAS_{upper}{NL}"

        # Build call arguments (method call on handle's inner)
        val (conv_content, call_args) = build_param_conversions(method.params, spec)
        content = content + conv_content

        # Generate the call and return (method call on inner)
        if is_void_return(method.return_type):
            content = content + "    h.inner.{method.cpp_method}({call_args});{NL}"
        elif is_handle_type(method.return_type, spec):
            content = content + "    auto result = h.inner.{method.cpp_method}({call_args});{NL}"
            content = content + "    return std::make_unique<{method.return_type}>(result);{NL}"
        elif method.return_type == "text":
            content = content + "    auto result = h.inner.{method.cpp_method}({call_args});{NL}"
            content = content + "    return rust::String(result);{NL}"
        elif method.return_type == "[i64]":
            content = content + "    auto sizes = h.inner.{method.cpp_method}({call_args});{NL}"
            content = content + "    rust::Vec<int64_t> result;{NL}"
            content = content + "    for (auto size : sizes) {{NL}"
            content = content + "        result.push_back(size);{NL}"
            content = content + "    }{NL}"
            content = content + "    return result;{NL}"
        elif method.return_type == "[text]":
            content = content + "    auto items = h.inner.{method.cpp_method}({call_args});{NL}"
            content = content + "    rust::Vec<rust::String> result;{NL}"
            content = content + "    for (auto& item : items) {{NL}"
            content = content + "        result.push_back(rust::String(item));{NL}"
            content = content + "    }{NL}"
            content = content + "    return result;{NL}"
        else:
            content = content + "    return h.inner.{method.cpp_method}({call_args});{NL}"

        content = content + "#else{NL}"

        # Stub return
        val stub_ret = cpp_default_return(method.return_type, spec)
        content = content + "    {stub_ret}{NL}"

        content = content + "#endif{NL}"

    content = content + "}{NL}{NL}"

    content

export generate_bridge_h, generate_bridge_cpp
export gen_h_fn_decl, gen_h_method_decl
export gen_cpp_fn_impl, gen_cpp_method_impl
export build_param_conversions
