# Tier 2 Generator - Simple SFFI Bindings
#
# Generates src/lib/<library>/ffi.spl with extern declarations

use app.io.{file_write, dir_create_all, print}
use app.wrapper_gen.spec_parser.{WrapperSpec, HandleTypeSpec, FunctionSpec, MethodSpec}
use std.text.{NL}

fn generate_tier2(spec: WrapperSpec, dry_run: bool):
    """Generate Tier 2: Simple SFFI bindings (extern fn declarations)."""

    val output_dir = "src/lib/{spec.name}"
    val output_file = "{output_dir}/ffi.spl"

    if not dry_run:
        dir_create_all(output_dir)

    var content = ""
    content = content + "# {spec.name} SFFI Bindings (Tier 2){NL}"
    content = content + "# Auto-generated extern fn declarations{NL}"
    content = content + "#{NL}"
    content = content + "# These map to Rust FFI exports in .build/rust/ffi_{spec.name}/{NL}{NL}"

    # Opaque handle types
    content = content + "# ============================================================================{NL}"
    content = content + "# Opaque Handle Types (represented as i64 pointers){NL}"
    content = content + "# ============================================================================{NL}{NL}"

    # Runtime parser doesn't support 'extern type', so we use type aliases to i64
    for handle in spec.handle_types:
        content = content + "# {handle.name}: Opaque handle (pointer cast to i64){NL}"

    content = content + NL

    # Library info functions
    content = content + "# ============================================================================{NL}"
    content = content + "# Library Information{NL}"
    content = content + "# ============================================================================{NL}{NL}"

    content = content + "extern fn rt_{spec.name}_available() -> bool{NL}"
    content = content + "extern fn rt_{spec.name}_version() -> text{NL}{NL}"

    # Tensor creation functions
    if spec.functions.len() > 0:
        content = content + "# ============================================================================{NL}"
        content = content + "# Functions{NL}"
        content = content + "# ============================================================================{NL}{NL}"

        for func in spec.functions:
            content = content + generate_extern_function(func, spec)

    # Methods
    if spec.methods.len() > 0:
        content = content + "# ============================================================================{NL}"
        content = content + "# Methods{NL}"
        content = content + "# ============================================================================{NL}{NL}"

        for method in spec.methods:
            content = content + generate_extern_method(method, spec)

    # Exports
    content = content + "# ============================================================================{NL}"
    content = content + "# Exports (handle types are i64, no need to export){NL}"
    content = content + "# ============================================================================{NL}{NL}"

    # Handle types are now i64, so no exports needed
    content = content + "# All extern functions are automatically available when imported{NL}"

    if dry_run:
        print "--- Tier 2 (Simple SFFI) ---"
        print content
    else:
        file_write(output_file, content)
        print "âœ“ Tier 2 generated: {output_file}"

fn qualified_fn_name(spec_name: text, fn_name: text) -> text:
    """Build qualified function name, avoiding double prefix."""
    val prefix = spec_name + "_"
    if fn_name.starts_with(prefix):
        return fn_name
    "{spec_name}_{fn_name}"

fn is_void_type(type_name: text) -> bool:
    """Check if type is void."""
    val t = type_name.trim()
    t == "void" or t == ""

fn generate_extern_function(func: FunctionSpec, spec: WrapperSpec) -> text:
    var params = ""
    for param in func.params:
        if params != "":
            params = params + ", "
        val param_type = map_handle_to_i64(param.param_type, spec)
        params = params + "{param.name}: {param_type}"

    val qname = qualified_fn_name(spec.name, func.name)

    if is_void_type(func.return_type):
        return "extern fn rt_{qname}({params}){NL}"

    val return_type = map_handle_to_i64(func.return_type, spec)
    "extern fn rt_{qname}({params}) -> {return_type}{NL}"

fn generate_extern_method(method: MethodSpec, spec: WrapperSpec) -> text:
    val handle_type = map_handle_to_i64(method.handle, spec)
    var params = "handle: {handle_type}"
    for param in method.params:
        val param_type = map_handle_to_i64(param.param_type, spec)
        params = params + ", {param.name}: {param_type}"

    val qname = qualified_fn_name(spec.name, "{method.handle.lower()}_{method.name}")

    if is_void_type(method.return_type):
        return "extern fn rt_{qname}({params}){NL}"

    val return_type = map_handle_to_i64(method.return_type, spec)
    "extern fn rt_{qname}({params}) -> {return_type}{NL}"

# Helper: Map handle types to i64, leave other types unchanged
fn map_handle_to_i64(type_name: text, spec: WrapperSpec) -> text:
    # Check if this is a handle type
    for handle in spec.handle_types:
        if type_name == handle.name:
            return "i64"

    # Not a handle type, return as-is
    type_name

fn is_handle_type(type_name: text, spec: WrapperSpec) -> bool:
    for handle in spec.handle_types:
        if type_name == handle.name:
            return true
    false

export generate_tier2
