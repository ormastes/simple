# Unreal CLI Tool - Project Scaffolding
#
# Command-line tool for creating and managing Unreal projects with Simple integration
#
# Usage:
#   simple_unreal new <project_name> [--path <path>] [--version <ue_version>]
#   simple_unreal add-module <module_name> [--type <Runtime|Editor>]
#   simple_unreal generate-bindings <class_name>
#
# Examples:
#   simple_unreal new MyGame --path ~/Projects --version 5.4
#   simple_unreal add-module Gameplay --type Runtime
#   simple_unreal generate-bindings MyCharacter

import std.io
import std.args
import std.fs
import std.string

# Project template structure
fn create_project_structure(project_name: String, base_path: String, ue_version: String):
    val project_path = base_path + "/" + project_name

    io.println("Creating Unreal project: " + project_name)
    io.println("Path: " + project_path)
    io.println("Unreal Engine version: " + ue_version)

    # Create directories
    fs.create_dir(project_path)
    fs.create_dir(project_path + "/Source")
    fs.create_dir(project_path + "/Source/" + project_name)
    fs.create_dir(project_path + "/Source/" + project_name + "Editor")
    fs.create_dir(project_path + "/Content")
    fs.create_dir(project_path + "/Config")
    fs.create_dir(project_path + "/Plugins")
    fs.create_dir(project_path + "/Plugins/SimpleIntegration")
    fs.create_dir(project_path + "/Plugins/SimpleIntegration/Source")
    fs.create_dir(project_path + "/Plugins/SimpleIntegration/Content")
    fs.create_dir(project_path + "/Simple")
    fs.create_dir(project_path + "/Simple/Core")
    fs.create_dir(project_path + "/Simple/Gameplay")

    # Create .uproject file
    val uproject_content = generate_uproject(project_name, ue_version)
    fs.write_file(project_path + "/" + project_name + ".uproject", uproject_content)

    # Create main module Build.cs
    val build_cs = generate_build_cs(project_name)
    fs.write_file(project_path + "/Source/" + project_name + "/" + project_name + ".Build.cs", build_cs)

    # Create main module header
    val module_header = generate_module_header(project_name)
    fs.write_file(project_path + "/Source/" + project_name + "/" + project_name + ".h", module_header)

    # Create main module cpp
    val module_cpp = generate_module_cpp(project_name)
    fs.write_file(project_path + "/Source/" + project_name + "/" + project_name + ".cpp", module_cpp)

    # Create game mode header
    val gamemode_header = generate_gamemode_header(project_name)
    fs.write_file(project_path + "/Source/" + project_name + "/" + project_name + "GameMode.h", gamemode_header)

    # Create game mode cpp
    val gamemode_cpp = generate_gamemode_cpp(project_name)
    fs.write_file(project_path + "/Source/" + project_name + "/" + project_name + "GameMode.cpp", gamemode_cpp)

    # Create Simple integration plugin
    val plugin_descriptor = generate_plugin_descriptor(project_name)
    fs.write_file(project_path + "/Plugins/SimpleIntegration/SimpleIntegration.uplugin", plugin_descriptor)

    # Create Simple plugin Build.cs
    val plugin_build_cs = generate_plugin_build_cs()
    fs.write_file(project_path + "/Plugins/SimpleIntegration/Source/SimpleIntegration/SimpleIntegration.Build.cs", plugin_build_cs)

    # Create example Simple script
    val example_simple = generate_example_simple_script(project_name)
    fs.write_file(project_path + "/Simple/Core/Example.spl", example_simple)

    # Create simple.toml for package management
    val simple_toml = generate_simple_toml(project_name)
    fs.write_file(project_path + "/Simple/simple.toml", simple_toml)

    io.println("✅ Project created successfully!")
    io.println("")
    io.println("Next steps:")
    io.println("  1. cd " + project_path)
    io.println("  2. Generate project files: UnrealBuildTool -projectfiles")
    io.println("  3. Open " + project_name + ".uproject in Unreal Editor")
    io.println("  4. Build Simple scripts: cd Simple && simple build")

# Generate .uproject file
fn generate_uproject(project_name: String, ue_version: String) -> String:
    return """{
    "FileVersion": 3,
    "EngineAssociation": """ + "\"" + ue_version + "\"" + """,
    "Category": "",
    "Description": "",
    "Modules": [
        {
            "Name": """ + "\"" + project_name + "\"" + """,
            "Type": "Runtime",
            "LoadingPhase": "Default"
        }
    ],
    "Plugins": [
        {
            "Name": "SimpleIntegration",
            "Enabled": true
        }
    ]
}"""

# Generate Build.cs file
fn generate_build_cs(project_name: String) -> String:
    return """using UnrealBuildTool;

public class """ + project_name + """ : ModuleRules
{
    public """ + project_name + """(ReadOnlyTargetRules Target) : base(Target)
    {
        PCHUsage = PCHUsageMode.UseExplicitOrSharedPCHs;

        PublicDependencyModuleNames.AddRange(new string[] {
            "Core",
            "CoreUObject",
            "Engine",
            "InputCore",
            "SimpleIntegration"
        });

        PrivateDependencyModuleNames.AddRange(new string[] {});
    }
}"""

# Generate module header
fn generate_module_header(project_name: String) -> String:
    return """#pragma once

#include "CoreMinimal.h"
#include "Modules/ModuleManager.h"

class F""" + project_name + """Module : public IModuleInterface
{
public:
    virtual void StartupModule() override;
    virtual void ShutdownModule() override;
};"""

# Generate module cpp
fn generate_module_cpp(project_name: String) -> String:
    return """#include """ + "\"" + project_name + ".h\"" + """

#define LOCTEXT_NAMESPACE "F""" + project_name + """Module"

void F""" + project_name + """Module::StartupModule()
{
    // Module startup
}

void F""" + project_name + """Module::ShutdownModule()
{
    // Module shutdown
}

#undef LOCTEXT_NAMESPACE

IMPLEMENT_PRIMARY_GAME_MODULE(F""" + project_name + """Module, """ + project_name + """, """ + "\"" + project_name + "\"" + """);"""

# Generate game mode header
fn generate_gamemode_header(project_name: String) -> String:
    return """#pragma once

#include "CoreMinimal.h"
#include "GameFramework/GameModeBase.h"
#include """ + "\"" + project_name + "GameMode.generated.h\"" + """

UCLASS()
class """ + project_name.upper() + """_API A""" + project_name + """GameMode : public AGameModeBase
{
    GENERATED_BODY()

public:
    A""" + project_name + """GameMode();
};"""

# Generate game mode cpp
fn generate_gamemode_cpp(project_name: String) -> String:
    return """#include """ + "\"" + project_name + "GameMode.h\"" + """

A""" + project_name + """GameMode::A""" + project_name + """GameMode()
{
    // Set default classes
}"""

# Generate plugin descriptor
fn generate_plugin_descriptor(project_name: String) -> String:
    return """{
    "FileVersion": 3,
    "Version": 1,
    "VersionName": "1.0",
    "FriendlyName": "Simple Language Integration",
    "Description": "Integration plugin for Simple language scripts",
    "Category": "Scripting",
    "CreatedBy": "Simple Language Team",
    "CreatedByURL": "",
    "DocsURL": "",
    "MarketplaceURL": "",
    "SupportURL": "",
    "CanContainContent": true,
    "IsBetaVersion": false,
    "IsExperimentalVersion": false,
    "Installed": false,
    "Modules": [
        {
            "Name": "SimpleIntegration",
            "Type": "Runtime",
            "LoadingPhase": "PreDefault"
        }
    ]
}"""

# Generate plugin Build.cs
fn generate_plugin_build_cs() -> String:
    return """using UnrealBuildTool;

public class SimpleIntegration : ModuleRules
{
    public SimpleIntegration(ReadOnlyTargetRules Target) : base(Target)
    {
        PCHUsage = PCHUsageMode.UseExplicitOrSharedPCHs;

        PublicDependencyModuleNames.AddRange(new string[] {
            "Core",
            "CoreUObject",
            "Engine"
        });

        // Link to Simple runtime library
        PublicAdditionalLibraries.Add(System.IO.Path.Combine(
            ModuleDirectory, "..", "..", "..", "Simple", "lib", "libsimple_runtime.a"
        ));
    }
}"""

# Generate example Simple script
fn generate_example_simple_script(project_name: String) -> String:
    return """# Example Simple Script for """ + project_name + """
#
# This script demonstrates integration with Unreal Engine

import std.io
import unreal.actor
import unreal.tick

# Example actor behavior
fn on_tick(actor: AActor, delta: tick.DeltaTime):
    # Get current location
    val (x, y, z) = actor.get_actor_location()

    # Move actor
    val speed = 100.0
    val new_x = x + delta.delta_seconds() * speed

    actor.set_actor_location(new_x, y, z)

# Register tick function
pub fn init_actor(actor: AActor):
    val tick_fn = tick.register_tick(actor, on_tick)
    tick_fn.set_tick_enabled(true)
    io.println("Actor initialized with Simple script!")"""

# Generate simple.toml
fn generate_simple_toml(project_name: String) -> String:
    return """[package]
name = """ + "\"" + project_name.to_lower() + "\"" + """
version = "0.1.0"
authors = []

[dependencies]
# Add Simple package dependencies here"""

# Add module to existing project
fn add_module(module_name: String, module_type: String):
    io.println("Adding module: " + module_name + " (type: " + module_type + ")")

    # Check if we're in a project directory
    if not fs.file_exists("Source"):
        io.println("Error: Not in an Unreal project directory")
        io.println("Please run this command from the project root")
        return

    # Get project name from .uproject file
    val project_name = detect_project_name()
    if project_name == "":
        io.println("Error: Could not detect project name")
        return

    # Create module directory
    val module_path = "Source/" + module_name
    fs.create_dir(module_path)

    # Generate Build.cs
    val build_cs = """using UnrealBuildTool;

public class """ + module_name + """ : ModuleRules
{
    public """ + module_name + """(ReadOnlyTargetRules Target) : base(Target)
    {
        PCHUsage = PCHUsageMode.UseExplicitOrSharedPCHs;

        PublicDependencyModuleNames.AddRange(new string[] {
            "Core",
            "CoreUObject",
            "Engine"
        });
    }
}"""

    fs.write_file(module_path + "/" + module_name + ".Build.cs", build_cs)

    io.println("✅ Module created: " + module_name)
    io.println("Regenerate project files to complete integration")

# Detect project name from .uproject file
fn detect_project_name() -> String:
    val files = fs.list_dir(".")
    for file in files:
        if string.ends_with(file, ".uproject"):
            return string.replace(file, ".uproject", "")
    return ""

# Main entry point
fn main():
    val argv = args.get_args()

    if argv.len() < 2:
        io.println("Usage: simple_unreal <command> [options]")
        io.println("")
        io.println("Commands:")
        io.println("  new <project_name>           Create new Unreal project with Simple integration")
        io.println("  add-module <module_name>     Add new module to existing project")
        io.println("")
        io.println("Options:")
        io.println("  --path <path>                Project path (default: current directory)")
        io.println("  --version <version>          Unreal Engine version (default: 5.4)")
        io.println("  --type <Runtime|Editor>      Module type (default: Runtime)")
        return

    val command = argv[1]

    if command == "new":
        if argv.len() < 3:
            io.println("Error: Project name required")
            io.println("Usage: simple_unreal new <project_name>")
            return

        val project_name = argv[2]
        val base_path = "."
        val ue_version = "5.4"

        # Parse options
        var i = 3
        while i < argv.len():
            if argv[i] == "--path" and i + 1 < argv.len():
                base_path = argv[i + 1]
                i = i + 2
            elif argv[i] == "--version" and i + 1 < argv.len():
                ue_version = argv[i + 1]
                i = i + 2
            else:
                i = i + 1

        create_project_structure(project_name, base_path, ue_version)

    elif command == "add-module":
        if argv.len() < 3:
            io.println("Error: Module name required")
            io.println("Usage: simple_unreal add-module <module_name>")
            return

        val module_name = argv[2]
        val module_type = "Runtime"

        # Parse options
        var i = 3
        while i < argv.len():
            if argv[i] == "--type" and i + 1 < argv.len():
                module_type = argv[i + 1]
                i = i + 2
            else:
                i = i + 1

        add_module(module_name, module_type)

    else:
        io.println("Unknown command: " + command)
        io.println("Run 'simple_unreal' for usage information")
