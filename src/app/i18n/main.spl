# Simple CLI - i18n command
# Extract internationalization strings from Simple source files

use app.cli_util (get_cli_args)
use app.io.mod (file_exists, file_read, file_write, dir_walk, dir_create)

fn print_help():
    print "Usage: simple i18n <subcommand> [options]"
    print ""
    print "Internationalization tools for Simple projects."
    print ""
    print "Subcommands:"
    print "  extract              Extract i18n strings from source files"
    print "  generate <locale>    Generate locale template"
    print ""
    print "Options:"
    print "  --dir=<path>         Source directory (default: src/)"
    print "  --output=<path>      Output directory (default: i18n/)"
    print "  -h, --help           Show this help"

# i18n string pattern: Name_"default text"

struct I18nString:
    key: text
    default_text: text
    file: text
    line: i64

fn extract_i18n_strings(content: text, file_path: text) -> [I18nString]:
    val lines = content.split("\n")
    var strings: [I18nString] = []
    var line_num = 1

    for line in lines:
        # Look for Name_"..." patterns
        var i = 0
        while i < line.len():
            if i > 0 and line[i] == "_" and i + 1 < line.len() and line[i + 1] == "\"":
                # Extract key (identifier before _")
                var key_start = i - 1
                while key_start > 0 and is_ident_char(line[key_start - 1]):
                    key_start = key_start - 1
                val key = line[key_start:i]

                if key != "":
                    # Extract the quoted string
                    val quote_start = i + 2
                    var quote_end = quote_start
                    var escaped = false
                    while quote_end < line.len():
                        if escaped:
                            escaped = false
                        elif line[quote_end] == "\\":
                            escaped = true
                        elif line[quote_end] == "\"":
                            break
                        quote_end = quote_end + 1

                    if quote_end < line.len():
                        val default_text = line[quote_start:quote_end]
                        strings.push(I18nString(
                            key: key,
                            default_text: default_text,
                            file: file_path,
                            line: line_num
                        ))
                    i = quote_end + 1
                    continue
            i = i + 1
        line_num = line_num + 1

    strings

fn is_ident_char(ch: text) -> bool:
    (ch >= "a" and ch <= "z") or (ch >= "A" and ch <= "Z") or (ch >= "0" and ch <= "9") or ch == "_"

fn generate_locale_catalog(strings: [I18nString]) -> text:
    var lines: [text] = []
    lines.push("# I18n String Catalog")
    lines.push("# Generated by: simple i18n extract")
    lines.push("")
    lines.push("strings |key, default_text, file, line|")

    var seen: Dict<text, bool> = {}
    for s in strings:
        if not seen.contains_key(s.key):
            lines.push("    {s.key}, \"{s.default_text}\", {s.file}, {s.line}")
            seen[s.key] = true

    lines.join("\n") + "\n"

fn generate_locale_template(locale: text, strings: [I18nString]) -> text:
    var lines: [text] = []
    lines.push("# Locale: {locale}")
    lines.push("# Translate the values below")
    lines.push("")

    var seen: Dict<text, bool> = {}
    for s in strings:
        if not seen.contains_key(s.key):
            lines.push("{s.key} = \"{s.default_text}\"  # TODO: translate")
            seen[s.key] = true

    lines.join("\n") + "\n"

fn handle_extract(source_dir: text, output_dir: text) -> i64:
    if not file_exists(source_dir):
        print "error: source directory not found: {source_dir}"
        return 1

    val files = dir_walk(source_dir)
    var all_strings: [I18nString] = []
    var file_count = 0

    for file in files:
        if not file.ends_with(".spl"):
            continue
        val content = file_read(file)
        val strings = extract_i18n_strings(content, file)
        if strings.len() > 0:
            for s in strings:
                all_strings.push(s)
            file_count = file_count + 1

    if all_strings.len() == 0:
        print "No i18n strings found in {source_dir}/"
        return 0

    dir_create(output_dir, true)
    val catalog = generate_locale_catalog(all_strings)
    val catalog_path = "{output_dir}/strings.sdn"
    file_write(catalog_path, catalog)

    print "Extracted {all_strings.len()} i18n strings from {file_count} files"
    print "Catalog written to {catalog_path}"
    0

fn handle_generate(locale: text, source_dir: text, output_dir: text) -> i64:
    if not file_exists(source_dir):
        print "error: source directory not found: {source_dir}"
        return 1

    val files = dir_walk(source_dir)
    var all_strings: [I18nString] = []

    for file in files:
        if not file.ends_with(".spl"):
            continue
        val content = file_read(file)
        val strings = extract_i18n_strings(content, file)
        for s in strings:
            all_strings.push(s)

    if all_strings.len() == 0:
        print "No i18n strings found."
        return 0

    dir_create(output_dir, true)
    val template = generate_locale_template(locale, all_strings)
    val template_path = "{output_dir}/__init__.{locale}.spl"
    file_write(template_path, template)

    print "Generated locale template: {template_path}"
    print "Next steps:"
    print "  1. Translate the strings in {template_path}"
    print "  2. Run 'simple i18n extract' to verify"
    0

fn main() -> i64:
    val args = get_cli_args()

    if args.len() == 0:
        print_help()
        return 0

    var source_dir = "src"
    var output_dir = "i18n"
    var subcommand = ""
    var locale = ""

    for arg in args:
        if arg == "-h" or arg == "--help":
            print_help()
            return 0
        elif arg.starts_with("--dir="):
            source_dir = arg[6:]
        elif arg.starts_with("--output="):
            output_dir = arg[9:]
        elif not arg.starts_with("-"):
            if subcommand == "":
                subcommand = arg
            elif subcommand == "generate" and locale == "":
                locale = arg

    match subcommand:
        case "extract":
            return handle_extract(source_dir, output_dir)
        case "generate":
            if locale == "":
                print "error: locale required for generate"
                print "Usage: simple i18n generate <locale>"
                return 1
            return handle_generate(locale, source_dir, output_dir)
        case _:
            print "error: unknown subcommand '{subcommand}'"
            print_help()
            return 1
