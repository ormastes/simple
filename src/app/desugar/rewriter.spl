# Call Rewriter - Source-Level Static Call Transformation
#
# Rewrites Type.method(args) and Type.CONSTANT to TypeName__method(args) and
# TypeName__CONSTANT in source text.
# Works at the text level (not AST) for compatibility with the current runtime.
#
# Detection: Any UppercaseWord.identifier pattern is treated as a static member.
# No need for pre-collected type definitions.
#
# Patterns handled:
#   Type.method()                -> Type__method()
#   Type.method(a, b)            -> Type__method(a, b)
#   Type.method(Other.factory()) -> Type__method(Other__factory())
#   val x = Type.method()        -> val x = Type__method()
#   Type.CONSTANT                -> Type__CONSTANT
#   val y = Type.MAX_VALUE       -> val y = Type__MAX_VALUE
#
# NOT rewritten (preserved):
#   obj.method()                 -> obj.method()      (instance method, lowercase receiver)
#   self.field                   -> self.field         (self access)
#   "string".method()            -> "string".method()  (literal method)
#
# NOTE: This module runs on the Rust runtime, so it MUST NOT use static fn.
# NOTE: No try/catch/throw - Simple does not support exceptions.

use std.text.{NL}

export rewrite_static_calls

# Main entry: rewrite static method calls in source text
fn rewrite_static_calls(source: text) -> text:
    val lines = source.split(NL)
    var result_lines = []
    for line in lines:
        val rewritten = rewrite_line(line)
        result_lines.push(rewritten)

    result_lines.join(NL)

# ================================================================
# Helper Functions
# ================================================================

fn extract_word(s: text) -> text:
    var word = ""
    var ci = 0
    val slen = s.len()
    while ci < slen:
        val ch = s[ci:ci + 1]
        if is_ident_char(ch):
            word = word + ch
            ci = ci + 1
        else:
            break
    word

fn is_ident_char(ch: text) -> bool:
    if ch.len() != 1:
        return false
    val c = ch
    (c >= "a" and c <= "z") or (c >= "A" and c <= "Z") or (c >= "0" and c <= "9") or c == "_"

fn is_upper(ch: text) -> bool:
    ch >= "A" and ch <= "Z"

fn is_lower_or_underscore(ch: text) -> bool:
    (ch >= "a" and ch <= "z") or ch == "_"

# ================================================================
# Line Rewriting
# ================================================================

# Rewrite a single line: find UpperCase.method( and replace with UpperCase__method(
fn rewrite_line(line: text) -> text:
    val trimmed = line.trim()

    # Skip comments
    if trimmed.starts_with("#"):
        return line

    # Skip triple-quoted strings
    if trimmed.starts_with("\"\"\""):
        return line

    # Skip import/use/export lines
    if trimmed.starts_with("use ") or trimmed.starts_with("from ") or trimmed.starts_with("export ") or trimmed.starts_with("import "):
        return line

    # Skip impl/class/struct/enum definitions
    if trimmed.starts_with("impl ") or trimmed.starts_with("class ") or trimmed.starts_with("struct ") or trimmed.starts_with("enum "):
        return line

    # Skip static fn definitions (already hoisted)
    if trimmed.starts_with("static fn ") or trimmed.starts_with("static me "):
        return line

    # Scan for Uppercase.method( patterns
    rewrite_static_patterns(line)

# Scan line and rewrite all UppercaseWord.member to UppercaseWord__member
# Handles both Type.method( and Type.CONSTANT
fn rewrite_static_patterns(line: text) -> text:
    val llen = line.len()
    if llen < 3:
        return line

    var result = ""
    var ci = 0

    while ci < llen:
        # Check if we're inside a string literal
        if is_in_string_context(line, ci):
            result = result + line[ci:ci + 1]
            ci = ci + 1
            continue

        val ch = line[ci:ci + 1]

        # Look for an uppercase letter that starts an identifier
        if is_upper(ch):
            # Make sure previous char is not an ident char (word boundary)
            var at_boundary = true
            if ci > 0:
                at_boundary = not is_ident_char(line[ci - 1:ci])

            if at_boundary:
                # Extract the full identifier (Type name)
                val ident = extract_word(line[ci:])
                val ident_len = ident.len()
                val after_ident = ci + ident_len

                # Check if followed by .identifier
                if after_ident + 2 < llen and line[after_ident:after_ident + 1] == ".":
                    val after_dot = after_ident + 1
                    val next_ch = line[after_dot:after_dot + 1]

                    # Check for lowercase method or uppercase constant
                    if is_lower_or_underscore(next_ch) or is_upper(next_ch):
                        val member_name = extract_word(line[after_dot:])
                        val after_member = after_dot + member_name.len()

                        # Distinguish between method call and constant access
                        var is_method_call = false
                        if after_member < llen and line[after_member:after_member + 1] == "(":
                            is_method_call = true

                        # Rewrite both cases: Type.member -> Type__member
                        # The parenthesis check helps distinguish, but we rewrite both
                        result = result + ident + "__" + member_name
                        ci = after_member
                        continue

        result = result + line[ci:ci + 1]
        ci = ci + 1

    result

# Simple check if position is inside a string literal
# Counts unescaped quotes before position
fn is_in_string_context(line: text, pos: i64) -> bool:
    var quote_count = 0
    var ci = 0
    while ci < pos:
        val ch = line[ci:ci + 1]
        if ch == "\"" and (ci == 0 or line[ci - 1:ci] != "\\"):
            quote_count = quote_count + 1
        ci = ci + 1
    # Odd number of quotes means we're inside a string
    quote_count % 2 == 1
