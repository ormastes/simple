# Forwarding Alias Desugaring
#
# Processes alias-based forwarding declarations and deprecated function aliases.
# These are text-level transformations that generate delegation code before
# the parser sees the alias syntax.
#
# Deprecated: Module-level `fn name = target` generates delegation function.
#   Scans source for target's signature, generates: fn name(params): target(params)
#   Use explicit delegation instead: fn name(params): target(params)
#
# Phase 2: Generates delegation methods from `alias fn NAME = FIELD.METHOD`
#   Supported forms:
#     alias fn len = inner.len               -> fn len(): self.inner.len()
#     alias fn push(item) = inner.push       -> fn push(item): self.inner.push(item)
#     alias me set(key, val) = inner.set     -> me set(key, val): self.inner.set(key, val)
#
# Phase 3: Generates trait forwarding from `alias TraitName = field`
#   Scans for trait definitions, generates forwarding for each abstract method.
#
# Phase 4: Blanket forwarding from `alias field_name`
#   Scans for the field's type definition, generates forwarding for ALL methods.
#
# NOTE: This module runs on the Rust runtime, so it MUST NOT use
# static fn patterns. All BUG workarounds applied.
# NOTE: No try/catch/throw - Simple does not support exceptions.

use std.text.{NL}
use app.desugar.trait_scanner (scan_traits, find_trait, ScannedTrait, TraitMethod)
use app.desugar.fn_scanner (scan_functions, find_function, ScannedFn)
use app.desugar.type_scanner (scan_types, find_type, ScannedType, TypeMethod)

export desugar_forwarding

# Main entry: desugar alias-based forwarding declarations in source text
#
# Scans source for class/struct bodies and transforms:
#   - `alias fn` and `alias me` lines into delegation methods (Phase 2)
#   - `alias TraitName = field` into per-method delegation (Phase 3)
#
# Phase 3 first scans the source for trait definitions to discover method
# signatures, then generates forwarding methods for each non-default
# trait method when encountering `alias TraitName = field`.
#
# Parameters:
#   source: Original Simple source code as text
#
# Returns:
#   Source text with alias forwarding lines replaced by delegation methods
fn desugar_forwarding(source: text) -> text:
    # Pre-scan source for definitions needed by all phases
    val traits = scan_traits(source)
    val fns = scan_functions(source)
    val types = scan_types(source)

    val lines = source.split(NL)
    var result_lines = []
    var i = 0
    var in_class = false
    var class_indent = 0
    # Track current class fields for Phase 4 blanket alias
    var current_fields = []
    var current_field_types = []

    while i < lines.len():
        val line = lines[i]
        val trimmed = line.trim()

        # Track class/struct body context
        if is_class_header(trimmed):
            in_class = true
            class_indent = get_indent(line)
            # Pre-collect field info from scanned types for Phase 4
            val class_name = extract_type_name(trimmed)
            val scanned_type = find_type(class_name, types)
            current_fields = scanned_type.fields
            current_field_types = scanned_type.field_types
            result_lines.push(line)
            i = i + 1
            continue

        # Detect end of class/struct body by indentation
        if in_class:
            if trimmed != "" and get_indent(line) <= class_indent:
                in_class = false

        # ============================================================
        # DEPRECATED: Module-level fn name = target
        # Generates: fn name(params): target(params)
        # ============================================================
        if not in_class and trimmed != "":
            if trimmed.starts_with("fn "):
                val fn_alias = parse_fn_alias(trimmed)
                if fn_alias.is_valid:
                    val target_fn = find_function(fn_alias.target_name, fns)
                    var args_str = ""
                    var call_args_str = ""
                    if target_fn.param_names.len() > 0:
                        args_str = join_texts(target_fn.param_names, ", ")
                        call_args_str = join_texts(target_fn.param_names, ", ")
                    # Generate deprecated delegation function
                    result_lines.push("# DEPRECATED: fn {fn_alias.alias_name} = {fn_alias.target_name}")
                    result_lines.push("fn {fn_alias.alias_name}({args_str}):")
                    result_lines.push("    {fn_alias.target_name}({call_args_str})")
                    i = i + 1
                    continue

        # Inside class/struct body: check for alias patterns
        if in_class and trimmed != "":
            # Phase 2: alias fn NAME[(args)] = FIELD.METHOD
            #          alias me NAME[(args)] = FIELD.METHOD
            if trimmed.starts_with("alias fn ") or trimmed.starts_with("alias me "):
                val indent_str = get_indent_str(line)
                val body_indent_str = indent_str + "    "
                val parsed = parse_alias_line(trimmed)
                if parsed.is_valid:
                    var keyword = "fn"
                    if parsed.is_me:
                        keyword = "me"
                    var args_str = ""
                    var call_args_str = ""
                    if parsed.args.len() > 0:
                        args_str = join_texts(parsed.args, ", ")
                        call_args_str = join_texts(parsed.args, ", ")
                    var sig_line = "{indent_str}{keyword} {parsed.name}({args_str}):"
                    var body_line = "{body_indent_str}self.{parsed.field_path}.{parsed.method_name}({call_args_str})"
                    result_lines.push(sig_line)
                    result_lines.push(body_line)
                i = i + 1
                continue

            # Check for alias patterns (trait or blanket)
            if trimmed.starts_with("alias "):
                val rest = trimmed[6:]
                if rest.len() > 0:
                    val first_char = rest[0:1]

                    # Phase 3: alias TraitName = field (uppercase = trait)
                    if is_uppercase(first_char):
                        val indent_str = get_indent_str(line)
                        val body_indent_str = indent_str + "    "
                        val trait_alias = parse_trait_alias(rest)
                        if trait_alias.is_valid:
                            val scanned = find_trait(trait_alias.trait_name, traits)
                            var midx = 0
                            while midx < scanned.methods.len():
                                val method = scanned.methods[midx]
                                if not method.has_default:
                                    var keyword = "fn"
                                    if method.is_me:
                                        keyword = "me"
                                    var args_str = ""
                                    var call_args_str = ""
                                    if method.param_names.len() > 0:
                                        args_str = join_texts(method.param_names, ", ")
                                        call_args_str = join_texts(method.param_names, ", ")
                                    var sig_line = "{indent_str}{keyword} {method.name}({args_str}):"
                                    var body_line = "{body_indent_str}self.{trait_alias.field_name}.{method.name}({call_args_str})"
                                    result_lines.push(sig_line)
                                    result_lines.push(body_line)
                                midx = midx + 1
                        i = i + 1
                        continue

                    # Phase 4: alias field_name (lowercase = blanket forwarding)
                    # Forward ALL methods from the field's type
                    if not is_uppercase(first_char):
                        val field_name = rest.trim()
                        # No "=" sign means blanket alias
                        val has_eq = find_char(field_name, "=")
                        if has_eq < 0:
                            val indent_str = get_indent_str(line)
                            val body_indent_str = indent_str + "    "
                            # Find the field's type from scanned class fields
                            val field_type_name = lookup_field_type(field_name, current_fields, current_field_types)
                            if field_type_name != "":
                                val field_type = find_type(field_type_name, types)
                                var midx = 0
                                while midx < field_type.methods.len():
                                    val method = field_type.methods[midx]
                                    var keyword = "fn"
                                    if method.is_me:
                                        keyword = "me"
                                    var args_str = ""
                                    var call_args_str = ""
                                    if method.param_names.len() > 0:
                                        args_str = join_texts(method.param_names, ", ")
                                        call_args_str = join_texts(method.param_names, ", ")
                                    var sig_line = "{indent_str}{keyword} {method.name}({args_str}):"
                                    var body_line = "{body_indent_str}self.{field_name}.{method.name}({call_args_str})"
                                    result_lines.push(sig_line)
                                    result_lines.push(body_line)
                                    midx = midx + 1
                            i = i + 1
                            continue

        result_lines.push(line)
        i = i + 1

    result_lines.join(NL)

# ================================================================
# Trait Alias Parsing
# ================================================================

struct TraitAliasInfo:
    is_valid: bool
    trait_name: text
    field_name: text

# Parse "TraitName = field_name" from the rest after "alias "
fn parse_trait_alias(rest: text) -> TraitAliasInfo:
    val empty = TraitAliasInfo(is_valid: false, trait_name: "", field_name: "")
    val eq_idx = find_char(rest, "=")
    if eq_idx < 0:
        return empty
    val left = rest[0:eq_idx]
    val left_trimmed = left.trim()
    var right_start = eq_idx + 1
    val right = rest[right_start:]
    val right_trimmed = right.trim()
    if left_trimmed == "" or right_trimmed == "":
        return empty
    TraitAliasInfo(is_valid: true, trait_name: left_trimmed, field_name: right_trimmed)

# ================================================================
# Deprecated Function Alias Parsing
# ================================================================

struct FnAliasInfo:
    is_valid: bool
    alias_name: text
    target_name: text

# Parse "fn name = target" at module level (deprecated syntax)
# Returns FnAliasInfo with is_valid=true only if the line matches
# the exact pattern: fn IDENTIFIER = IDENTIFIER (no parens, no colon)
fn parse_fn_alias(trimmed: text) -> FnAliasInfo:
    val empty = FnAliasInfo(is_valid: false, alias_name: "", target_name: "")
    # Must start with "fn "
    if not trimmed.starts_with("fn "):
        return empty
    val rest = trimmed[3:]
    # Find "=" sign
    val eq_idx = find_char(rest, "=")
    if eq_idx < 0:
        return empty
    # Must NOT have "(" before "=" (that would be a normal function)
    val paren_idx = find_char(rest, "(")
    if paren_idx >= 0 and paren_idx < eq_idx:
        return empty
    # Must NOT have ":" before "=" (that would be inline body)
    val colon_idx = find_char(rest, ":")
    if colon_idx >= 0 and colon_idx < eq_idx:
        return empty
    val left = rest[0:eq_idx]
    val alias_name = left.trim()
    var right_start = eq_idx + 1
    val right = rest[right_start:]
    val target_name = right.trim()
    if alias_name == "" or target_name == "":
        return empty
    FnAliasInfo(is_valid: true, alias_name: alias_name, target_name: target_name)

# ================================================================
# Phase 4: Field Type Lookup
# ================================================================

# Look up a field name in the current class's field lists to get its type
fn lookup_field_type(field_name: text, fields: [text], field_types: [text]) -> text:
    var idx = 0
    while idx < fields.len():
        if fields[idx] == field_name:
            if idx < field_types.len():
                return field_types[idx]
        idx = idx + 1
    ""

# Extract type name from a class/struct/impl header line
fn extract_type_name(trimmed: text) -> text:
    var rest = ""
    if trimmed.starts_with("class "):
        rest = trimmed[6:]
    elif trimmed.starts_with("struct "):
        rest = trimmed[7:]
    elif trimmed.starts_with("impl "):
        rest = trimmed[5:]
    else:
        return ""
    # Remove trailing ":"
    if rest.ends_with(":"):
        val rlen = rest.len()
        rest = rest[0:rlen - 1]
    rest = rest.trim()
    # Extract just the name (before < or ()
    var name = ""
    var ci = 0
    val slen = rest.len()
    while ci < slen:
        val ch = rest[ci:ci + 1]
        if ch == "<" or ch == "(" or ch == " ":
            break
        name = name + ch
        ci = ci + 1
    name

# ================================================================
# Alias Line Parsing
# ================================================================

struct AliasInfo:
    is_valid: bool
    is_me: bool
    name: text
    args: [text]
    field_path: text
    method_name: text

# Parse an alias line into its components
#
# Input formats (trimmed):
#   alias fn NAME = FIELD.METHOD
#   alias fn NAME(arg1, arg2) = FIELD.METHOD
#   alias me NAME = FIELD.METHOD
#   alias me NAME(arg1, arg2) = FIELD.METHOD
#
# FIELD.METHOD can be a dotted path like inner.items.push
fn parse_alias_line(trimmed: text) -> AliasInfo:
    val empty_result = AliasInfo(is_valid: false, is_me: false, name: "", args: [], field_path: "", method_name: "")

    # Step 1: Remove "alias " prefix
    var rest = trimmed[6:]

    # Step 2: Determine fn vs me
    var is_me = false
    if rest.starts_with("fn "):
        rest = rest[3:]
    elif rest.starts_with("me "):
        is_me = true
        rest = rest[3:]
    else:
        return empty_result

    # Step 3: Find "=" to split left and right
    var eq_idx = find_char(rest, "=")
    if eq_idx < 0:
        return empty_result

    var left = rest[0:eq_idx]
    left = left.trim()
    var right_start = eq_idx + 1
    var right = rest[right_start:]
    right = right.trim()

    # Step 4: Parse left side: NAME or NAME(arg1, arg2)
    var name = ""
    var args = []
    var paren_idx = find_char(left, "(")
    if paren_idx >= 0:
        # Has args
        name = left[0:paren_idx]
        name = name.trim()
        # Extract args between ( and )
        var close_idx = find_char(left, ")")
        if close_idx < 0:
            close_idx = left.len()
        var args_part_start = paren_idx + 1
        var args_part = left[args_part_start:close_idx]
        args_part = args_part.trim()
        if args_part != "":
            args = split_args(args_part)
    else:
        name = left

    if name == "":
        return empty_result

    # Step 5: Parse right side: FIELD.METHOD or FIELD.SUB.METHOD
    # The last dot-segment is the method name, everything before is the field path
    if right == "":
        return empty_result

    var last_dot = find_last_char(right, ".")
    if last_dot < 0:
        # No dot - just a bare name. Use right as both field path and method name.
        # e.g., "alias fn push = push" doesn't make sense, but handle gracefully
        return empty_result

    var field_path = right[0:last_dot]
    var method_start = last_dot + 1
    var method_name = right[method_start:]

    if field_path == "" or method_name == "":
        return empty_result

    AliasInfo(is_valid: true, is_me: is_me, name: name, args: args, field_path: field_path, method_name: method_name)

# ================================================================
# Class/Struct Header Detection
# ================================================================

# Check if a trimmed line starts a class or struct body
fn is_class_header(trimmed: text) -> bool:
    if trimmed.starts_with("class ") and trimmed.ends_with(":"):
        return true
    if trimmed.starts_with("struct ") and trimmed.ends_with(":"):
        return true
    # Also handle impl blocks since alias forwarding can appear there
    if trimmed.starts_with("impl ") and trimmed.ends_with(":"):
        return true
    false

# ================================================================
# Helpers
# ================================================================

# Check if a single character is uppercase A-Z
fn is_uppercase(ch: text) -> bool:
    if ch.len() != 1:
        return false
    ch >= "A" and ch <= "Z"

# Get the indentation level (number of leading spaces) of a line
fn get_indent(line: text) -> i64:
    var count = 0
    val llen = line.len()
    while count < llen:
        val ch = line[count:count + 1]
        if ch == " ":
            count = count + 1
        elif ch == "\t":
            count = count + 4  # Tab = 4 spaces
        else:
            break
    count

# Get the leading whitespace of a line as a string
fn get_indent_str(line: text) -> text:
    var count = 0
    val llen = line.len()
    while count < llen:
        val ch = line[count:count + 1]
        if ch == " " or ch == "\t":
            count = count + 1
        else:
            break
    if count == 0:
        return ""
    line[0:count]

# Find the first occurrence of a character in a string, return index or -1
fn find_char(s: text, ch: text) -> i64:
    var idx = 0
    val slen = s.len()
    while idx < slen:
        val c = s[idx:idx + 1]
        if c == ch:
            return idx
        idx = idx + 1
    -1

# Find the last occurrence of a character in a string, return index or -1
fn find_last_char(s: text, ch: text) -> i64:
    var result = -1
    var idx = 0
    val slen = s.len()
    while idx < slen:
        val c = s[idx:idx + 1]
        if c == ch:
            result = idx
        idx = idx + 1
    result

# Split a comma-separated string into trimmed parts
fn split_args(s: text) -> [text]:
    var parts = []
    var current = ""
    var idx = 0
    val slen = s.len()
    while idx < slen:
        val ch = s[idx:idx + 1]
        if ch == ",":
            var trimmed = current.trim()
            if trimmed != "":
                parts.push(trimmed)
            current = ""
        else:
            current = current + ch
        idx = idx + 1
    # Last part
    var trimmed = current.trim()
    if trimmed != "":
        parts.push(trimmed)
    parts

# Join a list of texts with a separator
# (Avoids using .join() which may conflict with actor keyword in some contexts)
fn join_texts(items: [text], sep: text) -> text:
    var result = ""
    var idx = 0
    while idx < items.len():
        if idx > 0:
            result = result + sep
        result = result + items[idx]
        idx = idx + 1
    result
