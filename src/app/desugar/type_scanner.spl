# Type Scanner - Text-Level Class/Struct Definition Scanner
#
# Scans raw Simple source text to find class and struct definitions and extract
# their field declarations and method signatures. This is a TEXT-LEVEL scanner
# that runs before the parser, processing raw source lines to identify type
# blocks and their contents.
#
# This module supports Phase 4 "blanket alias forwarding" where `alias field`
# in a class body forwards ALL methods from the field's type. The type scanner
# provides the method signatures needed to generate those forwarding methods.
#
# Scanned patterns:
#   class Storage:
#       items: [i64]
#       fn size() -> i64:
#           self.items.len()
#       me add(item: i64):
#           self.items.push(item)
#
#   struct Point:
#       x: i64
#       y: i64
#       fn distance() -> f64:
#           (self.x ** 2 + self.y ** 2).sqrt()
#
# Output:
#   A list of ScannedType structs, each containing the type name, kind
#   (class or struct), field declarations, and a list of TypeMethod structs
#   describing each method's name, mutability, and parameter names.
#
# Algorithm:
#   1. Split source by newlines
#   2. Detect "class NAME:" or "struct NAME:" lines
#   3. Collect subsequent indented lines as type body
#   4. Parse body for field declarations (name: Type) and method signatures (fn/me)
#   5. Return list of ScannedType
#
# NOTE: This module runs on the current runtime, so it MUST NOT use
# try/catch/throw, generics, or static fn patterns.
# NOTE: Chained method calls are broken - use intermediate vars.
# NOTE: `val` is a keyword - do not use as parameter name.
# NOTE: `join` is an actor keyword - use join_texts helper instead.
# NOTE: `assert` is a keyword - use check instead.

use std.text.{NL}

export scan_types, find_type, ScannedType, TypeMethod

# ================================================================
# Output Structs
# ================================================================

struct TypeMethod:
    name: text
    is_me: bool
    param_names: [text]

struct ScannedType:
    name: text
    kind: text          # "class" or "struct"
    fields: [text]      # field names
    field_types: [text]  # corresponding type names
    methods: [TypeMethod]

# ================================================================
# Main API
# ================================================================

# Scan source text for all class and struct definitions.
#
# Splits the source into lines, identifies type blocks by their header pattern
# ("class NAME:" or "struct NAME:"), collects indented body lines, and parses
# field declarations and method signatures from each type body.
#
# Parameters:
#   source: Raw Simple source code as text
#
# Returns:
#   List of ScannedType structs, one per class/struct found in the source
fn scan_types(source: text) -> [ScannedType]:
    val lines = source.split(NL)
    var types = []
    var i = 0

    while i < lines.len():
        val line = lines[i]
        val trimmed = line.trim()

        # Check if this line starts a class or struct definition
        var type_name = ""
        var type_kind = ""
        val class_name = parse_class_header(trimmed)
        if class_name != "":
            type_name = class_name
            type_kind = "class"
        else:
            val struct_name = parse_struct_header(trimmed)
            if struct_name != "":
                type_name = struct_name
                type_kind = "struct"

        if type_name != "":
            val type_indent = get_indent(line)

            # Collect body lines (deeper indent than type header)
            var body_lines = []
            var j = i + 1
            while j < lines.len():
                val next_line = lines[j]
                val next_trimmed = next_line.trim()
                # Empty lines inside the type body are part of it
                if next_trimmed == "":
                    body_lines.push(next_line)
                    j = j + 1
                # Lines with deeper indent are part of the body
                elif get_indent(next_line) > type_indent:
                    body_lines.push(next_line)
                    j = j + 1
                # Lines at same or lesser indent end the body
                else:
                    break

            # Parse fields and methods from the collected body lines
            val body_indent = type_indent + 4
            val parsed = parse_type_body(body_lines, body_indent, type_indent)
            types.push(ScannedType(
                name: type_name,
                kind: type_kind,
                fields: parsed.field_names,
                field_types: parsed.field_type_names,
                methods: parsed.methods))
            i = j
        else:
            i = i + 1

    types

# Look up a type by name from a list of scanned types.
#
# Searches through the provided list for a type matching the given name.
# If not found, returns a ScannedType with the given name, kind "class",
# and empty lists, allowing callers to safely use the result without nil checks.
#
# Parameters:
#   name: The type name to search for
#   types: List of ScannedType to search through
#
# Returns:
#   The matching ScannedType, or a ScannedType with empty fields/methods if not found
fn find_type(name: text, types: [ScannedType]) -> ScannedType:
    var idx = 0
    while idx < types.len():
        val t = types[idx]
        if t.name == name:
            return t
        idx = idx + 1
    # Not found - return empty type
    ScannedType(name: name, kind: "class", fields: [], field_types: [], methods: [])

# ================================================================
# Type Header Parsing
# ================================================================

# Parse a trimmed line as a class header. Returns the class name if the line
# matches "class NAME:", or empty text if it does not.
fn parse_class_header(trimmed: text) -> text:
    if not trimmed.starts_with("class "):
        return ""
    if not trimmed.ends_with(":"):
        return ""

    # Extract name between "class " and ":"
    val tlen = trimmed.len()
    val name_part = trimmed[6:tlen - 1]
    val name = name_part.trim()

    # Validate: name must be non-empty and start with uppercase
    if name == "":
        return ""
    val first_ch = name[0:1]
    if not is_upper_char(first_ch):
        return ""

    name

# Parse a trimmed line as a struct header. Returns the struct name if the line
# matches "struct NAME:", or empty text if it does not.
fn parse_struct_header(trimmed: text) -> text:
    if not trimmed.starts_with("struct "):
        return ""
    if not trimmed.ends_with(":"):
        return ""

    # Extract name between "struct " and ":"
    val tlen = trimmed.len()
    val name_part = trimmed[7:tlen - 1]
    val name = name_part.trim()

    # Validate: name must be non-empty and start with uppercase
    if name == "":
        return ""
    val first_ch = name[0:1]
    if not is_upper_char(first_ch):
        return ""

    name

# ================================================================
# Type Body Parsing
# ================================================================

# Intermediate struct to hold parsed body results (fields + methods together)
struct ParsedBody:
    field_names: [text]
    field_type_names: [text]
    methods: [TypeMethod]

# Parse field declarations and method signatures from type body lines.
#
# Scans body lines for:
#   - Field declarations: lines matching "name: Type" at the body indent level,
#     that do NOT start with fn/me/static/alias/type/export/use keywords
#   - Method declarations: lines starting with "fn " or "me "
#
# Skips comments (#), blank lines, static declarations, and nested bodies.
#
# Parameters:
#   body_lines: Lines from the type body
#   body_indent: Expected indent level of direct body members
#   type_indent: Indent level of the type header (for skipping deeper nesting)
fn parse_type_body(body_lines: [text], body_indent: i64, type_indent: i64) -> ParsedBody:
    var field_names = []
    var field_type_names = []
    var methods = []
    var i = 0

    while i < body_lines.len():
        val line = body_lines[i]
        val trimmed = line.trim()

        # Skip blank lines
        if trimmed == "":
            i = i + 1
            continue

        # Skip comment lines
        if trimmed.starts_with("#"):
            i = i + 1
            continue

        val current_indent = get_indent(line)

        # Only process lines at the body indent level (direct members)
        # Lines deeper than body indent are method bodies - skip them
        if current_indent > body_indent:
            i = i + 1
            continue

        # Lines at or before the type indent are outside the body
        if current_indent <= type_indent:
            break

        # Check for method declarations: fn or me
        if trimmed.starts_with("fn "):
            val sig_rest = trimmed[3:]
            val method_name = extract_method_name(sig_rest)
            if method_name != "":
                val param_names = extract_param_names(sig_rest)
                methods.push(TypeMethod(
                    name: method_name,
                    is_me: false,
                    param_names: param_names))
            # Skip past any method body lines
            i = skip_method_body(body_lines, i, current_indent)
            continue

        if trimmed.starts_with("me "):
            val sig_rest = trimmed[3:]
            val method_name = extract_method_name(sig_rest)
            if method_name != "":
                val param_names = extract_param_names(sig_rest)
                methods.push(TypeMethod(
                    name: method_name,
                    is_me: true,
                    param_names: param_names))
            # Skip past any method body lines
            i = skip_method_body(body_lines, i, current_indent)
            continue

        # Skip static methods
        if trimmed.starts_with("static "):
            i = skip_method_body(body_lines, i, current_indent)
            continue

        # Skip alias, type, export, use declarations
        if trimmed.starts_with("alias "):
            i = i + 1
            continue
        if trimmed.starts_with("type "):
            i = i + 1
            continue
        if trimmed.starts_with("export "):
            i = i + 1
            continue
        if trimmed.starts_with("use "):
            i = i + 1
            continue

        # Remaining lines at body indent: check for field declarations
        # A field declaration looks like "name: Type" where name starts lowercase
        val field_info = parse_field_declaration(trimmed)
        if field_info.is_valid:
            field_names.push(field_info.name)
            field_type_names.push(field_info.type_name)

        i = i + 1

    ParsedBody(
        field_names: field_names,
        field_type_names: field_type_names,
        methods: methods)

# Skip past a method's body lines. A method body consists of lines with
# deeper indentation than the method signature. Returns the next index
# to process (the line after the method body).
fn skip_method_body(body_lines: [text], method_idx: i64, method_indent: i64) -> i64:
    var j = method_idx + 1
    while j < body_lines.len():
        val next_line = body_lines[j]
        val next_trimmed = next_line.trim()
        # Empty lines inside the method body are part of it
        if next_trimmed == "":
            j = j + 1
        elif get_indent(next_line) > method_indent:
            j = j + 1
        else:
            break
    j

# ================================================================
# Field Declaration Parsing
# ================================================================

struct FieldInfo:
    is_valid: bool
    name: text
    type_name: text

# Parse a trimmed line as a field declaration.
# A field declaration is "name: Type" where name starts with a lowercase letter
# or underscore and does not look like a keyword-prefixed line.
#
# Returns a FieldInfo with is_valid=true if the line is a field, false otherwise.
fn parse_field_declaration(trimmed: text) -> FieldInfo:
    val invalid = FieldInfo(is_valid: false, name: "", type_name: "")

    # Must contain a colon
    val colon_idx = find_char(trimmed, ":")
    if colon_idx <= 0:
        return invalid

    # Name is everything before the colon
    val name_part = trimmed[0:colon_idx]
    val name = name_part.trim()

    if name == "":
        return invalid

    # Field names start with lowercase letter or underscore
    val first_ch = name[0:1]
    if not is_lower_char(first_ch) and first_ch != "_":
        return invalid

    # Field names must not contain spaces (otherwise it might be something else)
    val space_idx = find_char(name, " ")
    if space_idx >= 0:
        return invalid

    # Field names must not contain parentheses (not a method)
    val paren_idx = find_char(name, "(")
    if paren_idx >= 0:
        return invalid

    # Extract type name (everything after the colon)
    val type_start = colon_idx + 1
    val type_part = trimmed[type_start:]
    val type_name = type_part.trim()

    if type_name == "":
        return invalid

    FieldInfo(is_valid: true, name: name, type_name: type_name)

# ================================================================
# Method Signature Parsing
# ================================================================

# Extract the method name from the rest of a signature line (after "fn " or "me ").
# The name is everything up to the first '(', ':', '<', or ' '.
fn extract_method_name(sig_rest: text) -> text:
    var name = ""
    var ci = 0
    val slen = sig_rest.len()
    while ci < slen:
        val ch = sig_rest[ci:ci + 1]
        if ch == "(" or ch == ":" or ch == "<" or ch == " ":
            break
        name = name + ch
        ci = ci + 1
    name

# Extract parameter names from a method signature.
# Given "method_name(a: i64, b: text) -> i64:", extracts ["a", "b"].
# Only extracts the parameter names (before the colon in each param).
fn extract_param_names(sig_rest: text) -> [text]:
    # Find the opening parenthesis
    val open_paren = find_char(sig_rest, "(")
    if open_paren < 0:
        return []

    # Find the matching closing parenthesis
    val close_paren = find_matching_paren(sig_rest, open_paren)
    if close_paren < 0:
        return []

    # Extract the parameter string between parens
    val param_start = open_paren + 1
    val params_text = sig_rest[param_start:close_paren]
    val trimmed_params = params_text.trim()
    if trimmed_params == "":
        return []

    # Split on commas and extract names
    split_param_names(trimmed_params)

# ================================================================
# Self-Contained Helper Functions
# ================================================================

# Count leading spaces of a line (tabs count as 4 spaces).
fn get_indent(line: text) -> i64:
    var count = 0
    val llen = line.len()
    while count < llen:
        val ch = line[count:count + 1]
        if ch == " ":
            count = count + 1
        elif ch == "\t":
            count = count + 4
        else:
            break
    count

# Find the first occurrence of a character in a string.
# Returns the index or -1 if not found.
fn find_char(s: text, ch: text) -> i64:
    var idx = 0
    val slen = s.len()
    while idx < slen:
        val c = s[idx:idx + 1]
        if c == ch:
            return idx
        idx = idx + 1
    -1

# Find the matching closing parenthesis for an opening paren at the given index.
# Handles nested parentheses. Returns index of closing paren or -1.
fn find_matching_paren(s: text, open_idx: i64) -> i64:
    var depth = 0
    var ci = open_idx
    val slen = s.len()
    while ci < slen:
        val ch = s[ci:ci + 1]
        if ch == "(":
            depth = depth + 1
        elif ch == ")":
            depth = depth - 1
            if depth == 0:
                return ci
        ci = ci + 1
    -1

# Split a parameter string like "a: i64, b: text" into just the names ["a", "b"].
# For each comma-separated segment, extracts the portion before the first colon.
# If a segment has no colon, the entire trimmed segment is used as the name.
fn split_param_names(s: text) -> [text]:
    var names = []
    var current = ""
    var idx = 0
    val slen = s.len()
    var paren_depth = 0

    while idx < slen:
        val ch = s[idx:idx + 1]
        if ch == "(":
            paren_depth = paren_depth + 1
            current = current + ch
        elif ch == ")":
            paren_depth = paren_depth - 1
            current = current + ch
        elif ch == "," and paren_depth == 0:
            # End of one parameter - extract name
            val param_name = extract_name_from_param(current)
            if param_name != "":
                names.push(param_name)
            current = ""
        else:
            current = current + ch
        idx = idx + 1

    # Handle the last parameter
    val last_name = extract_name_from_param(current)
    if last_name != "":
        names.push(last_name)

    names

# Extract the parameter name from a single parameter declaration.
# Given "name: Type" returns "name". Given "name" returns "name".
fn extract_name_from_param(param: text) -> text:
    val trimmed = param.trim()
    if trimmed == "":
        return ""

    # Find colon - name is everything before it
    val colon_idx = find_char(trimmed, ":")
    if colon_idx > 0:
        val name_part = trimmed[0:colon_idx]
        return name_part.trim()

    # No colon - the whole thing is the name
    trimmed

# Check if a single character is uppercase A-Z.
fn is_upper_char(ch: text) -> bool:
    if ch.len() != 1:
        return false
    ch >= "A" and ch <= "Z"

# Check if a single character is lowercase a-z.
fn is_lower_char(ch: text) -> bool:
    if ch.len() != 1:
        return false
    ch >= "a" and ch <= "z"
