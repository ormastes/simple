# Trait Static Dispatch Rewrite Pass
#
# Rewrites function signatures that take trait-typed parameters into
# generic (monomorphized) signatures for static dispatch.
#
# INPUT:
#   fn process(x: Printable):
#       x.print()
#
# OUTPUT:
#   fn process<__T0: Printable>(x: __T0):
#       x.print()
#
# Rules:
#   - Only rewrites parameters whose type is a known trait name (NOT interface)
#   - Parameters with `dyn Trait` prefix are left as dynamic dispatch
#   - Parameters with `[Trait]` (array types) are left as dynamic
#   - Parameters with complex types (fn(...), generics) are skipped
#   - Interface-typed parameters are NOT rewritten (interfaces = always dynamic)
#   - `me` methods are rewritten the same way as `fn`
#
# This pass runs AFTER scan_traits identifies trait/interface names
# but BEFORE desugar_traits converts traits to structs.
#
# NOTE: This module runs on the current runtime, so it MUST NOT use
# try/catch/throw, generics, or static fn patterns.
# NOTE: Chained method calls are broken - use intermediate vars.

use app.desugar.trait_scanner (scan_traits, ScannedTrait)

export desugar_trait_static_dispatch

# Main entry: rewrite trait-typed params to generic params for static dispatch.
#
# Scans source for trait/interface definitions, then rewrites function signatures
# where parameter types match known trait names (excluding interfaces and dyn-prefixed types).
#
# Parameters:
#   source: Raw Simple source code as text
#
# Returns:
#   Source text with trait-typed params rewritten to generic type params
fn desugar_trait_static_dispatch(source: text) -> text:
    val traits = scan_traits(source)

    # Build list of trait names (NOT interfaces) for static dispatch
    var trait_names = []
    var ti = 0
    while ti < traits.len():
        val t = traits[ti]
        if not t.is_interface:
            trait_names.push(t.name)
        ti = ti + 1

    # If no non-interface traits found, return source unchanged
    if trait_names.len() == 0:
        return source

    val lines = source.split("\n")
    var result_lines = []
    var i = 0

    while i < lines.len():
        val line = lines[i]
        val rewritten = rewrite_fn_signature(line, trait_names)
        result_lines.push(rewritten)
        i = i + 1

    join_lines(result_lines, "\n")

# Rewrite a single line if it contains a fn/me signature with trait-typed params.
#
# Detects lines starting with `fn ` or `me ` (after optional indent), extracts
# the parameter list, checks each param type against known trait names, and
# rewrites matching params to use synthetic type variables.
#
# Parameters:
#   line: A single source line
#   trait_names: List of known trait names eligible for static dispatch
#
# Returns:
#   The line unchanged if no rewrite needed, or the rewritten line
fn rewrite_fn_signature(line: text, trait_names: [text]) -> text:
    val trimmed = line.trim()

    # Detect fn or me signature
    var is_fn = false
    var is_me = false
    if trimmed.starts_with("fn "):
        is_fn = true
    elif trimmed.starts_with("me "):
        is_me = true

    if not is_fn and not is_me:
        return line

    # Skip lines that already have generic params (contains '<' before '(')
    val open_paren_idx = find_char_in(trimmed, "(")
    if open_paren_idx < 0:
        return line

    val before_paren = trimmed[0:open_paren_idx]
    val has_angle = find_char_in(before_paren, "<")
    if has_angle >= 0:
        return line

    # Extract the function name portion (after "fn " or "me ")
    val sig_start = 3
    val fn_name = extract_fn_name(trimmed, sig_start)
    if fn_name == "":
        return line

    # Find matching close paren
    val close_paren_idx = find_matching_paren(trimmed, open_paren_idx)
    if close_paren_idx < 0:
        return line

    # Extract parameter text between parens
    val params_text = trimmed[open_paren_idx + 1:close_paren_idx]
    val params_trimmed = params_text.trim()
    if params_trimmed == "":
        return line

    # Parse individual parameters
    val params = split_params(params_trimmed)

    # Check each param for trait types and collect rewrites
    var type_vars = []
    var bounds = []
    var new_params = []
    var tvar_counter = 0
    var has_rewrite = false

    var pi = 0
    while pi < params.len():
        val param = params[pi]
        val param_info = parse_param(param)

        if param_info.name != "" and param_info.type_name != "":
            # Check if type matches a known trait (and not prefixed with dyn)
            val should_rewrite = is_trait_param(param_info.type_name, trait_names)
            if should_rewrite:
                val tvar = "__T{tvar_counter}"
                type_vars.push(tvar)
                bounds.push(param_info.type_name)
                new_params.push("{param_info.name}: {tvar}")
                tvar_counter = tvar_counter + 1
                has_rewrite = true
            else:
                new_params.push(param)
        else:
            new_params.push(param)

        pi = pi + 1

    if not has_rewrite:
        return line

    # Build the generic type parameter list: <__T0: Trait0, __T1: Trait1>
    var generic_parts = []
    var gi = 0
    while gi < type_vars.len():
        generic_parts.push("{type_vars[gi]}: {bounds[gi]}")
        gi = gi + 1
    val generic_str = join_texts(generic_parts, ", ")

    # Build the new parameter list
    val new_params_str = join_texts(new_params, ", ")

    # Reconstruct the line
    val indent_str = get_indent_str(line)
    var keyword = "fn"
    if is_me:
        keyword = "me"

    val after_close = trimmed[close_paren_idx + 1:]
    "{indent_str}{keyword} {fn_name}<{generic_str}>({new_params_str}){after_close}"

# Check if a parameter type is a known trait name eligible for static dispatch.
#
# Returns false if:
#   - type_name starts with "dyn " (explicit dynamic dispatch)
#   - type_name starts with "[" (array type)
#   - type_name contains "(" (function type)
#   - type_name contains "<" (already generic)
#   - type_name is not in the trait_names list
fn is_trait_param(type_name: text, trait_names: [text]) -> bool:
    val trimmed = type_name.trim()

    # Skip dyn-prefixed types
    if trimmed.starts_with("dyn "):
        return false

    # Skip array types
    if trimmed.starts_with("["):
        return false

    # Skip function types
    if find_char_in(trimmed, "(") >= 0:
        return false

    # Skip already-generic types
    if find_char_in(trimmed, "<") >= 0:
        return false

    # Skip optional types (e.g. Trait?)
    if trimmed.ends_with("?"):
        return false

    # Check if it's a known trait name
    var idx = 0
    while idx < trait_names.len():
        if trait_names[idx] == trimmed:
            return true
        idx = idx + 1

    false

# ================================================================
# Parameter Parsing
# ================================================================

struct ParamInfo:
    name: text
    type_name: text

# Parse a single parameter string like "x: Printable" into name and type.
fn parse_param(param: text) -> ParamInfo:
    val trimmed = param.trim()
    if trimmed == "":
        return ParamInfo(name: "", type_name: "")

    val colon_idx = find_char_in(trimmed, ":")
    if colon_idx <= 0:
        return ParamInfo(name: trimmed, type_name: "")

    val name_part = trimmed[0:colon_idx]
    val name = name_part.trim()
    val type_part = trimmed[colon_idx + 1:]
    val type_name = type_part.trim()

    ParamInfo(name: name, type_name: type_name)

# Split a parameter string on commas, respecting nested parens and brackets.
fn split_params(s: text) -> [text]:
    var params = []
    var current = ""
    var idx = 0
    val slen = s.len()
    var paren_depth = 0
    var bracket_depth = 0
    var angle_depth = 0

    while idx < slen:
        val ch = s[idx:idx + 1]
        if ch == "(":
            paren_depth = paren_depth + 1
            current = current + ch
        elif ch == ")":
            paren_depth = paren_depth - 1
            current = current + ch
        elif ch == "[":
            bracket_depth = bracket_depth + 1
            current = current + ch
        elif ch == "]":
            bracket_depth = bracket_depth - 1
            current = current + ch
        elif ch == "<":
            angle_depth = angle_depth + 1
            current = current + ch
        elif ch == ">":
            angle_depth = angle_depth - 1
            current = current + ch
        elif ch == "," and paren_depth == 0 and bracket_depth == 0 and angle_depth == 0:
            val trimmed = current.trim()
            if trimmed != "":
                params.push(trimmed)
            current = ""
        else:
            current = current + ch
        idx = idx + 1

    val last = current.trim()
    if last != "":
        params.push(last)

    params

# ================================================================
# Signature Parsing Helpers
# ================================================================

# Extract the function name from the trimmed signature, starting at offset.
# Name ends at first '(', '<', or ' ' that isn't part of the name.
fn extract_fn_name(trimmed: text, start: i64) -> text:
    var name = ""
    var ci = start
    val slen = trimmed.len()
    while ci < slen:
        val ch = trimmed[ci:ci + 1]
        if ch == "(" or ch == "<" or ch == " ":
            break
        name = name + ch
        ci = ci + 1
    name

# ================================================================
# General Text Helpers
# ================================================================

# Find the first occurrence of a character in a string. Returns index or -1.
fn find_char_in(s: text, ch: text) -> i64:
    var idx = 0
    val slen = s.len()
    while idx < slen:
        val c = s[idx:idx + 1]
        if c == ch:
            return idx
        idx = idx + 1
    -1

# Find the matching closing parenthesis for an opening paren at open_idx.
fn find_matching_paren(s: text, open_idx: i64) -> i64:
    if open_idx < 0:
        return -1
    var depth = 0
    var ci = open_idx
    val slen = s.len()
    while ci < slen:
        val ch = s[ci:ci + 1]
        if ch == "(":
            depth = depth + 1
        elif ch == ")":
            depth = depth - 1
            if depth == 0:
                return ci
        ci = ci + 1
    -1

# Get the leading whitespace string of a line
fn get_indent_str(line: text) -> text:
    var count = 0
    val llen = line.len()
    while count < llen:
        val ch = line[count:count + 1]
        if ch == " " or ch == "\t":
            count = count + 1
        else:
            break
    if count == 0:
        return ""
    line[0:count]

# Join a list of texts with a separator
fn join_texts(items: [text], sep: text) -> text:
    var result = ""
    var idx = 0
    while idx < items.len():
        if idx > 0:
            result = result + sep
        result = result + items[idx]
        idx = idx + 1
    result

# Join a list of lines with a newline separator
fn join_lines(lines: [text], nl: text) -> text:
    join_texts(lines, nl)
