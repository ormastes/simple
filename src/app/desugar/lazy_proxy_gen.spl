# Lazy Proxy Generator - Auto-Generate Lazy DI Proxies
#
# Text-level desugar pass that generates proxy code for lazy DI services.
# For each `@lazy_proxy("service_name")` annotation above a trait, generates
# named delegation functions that call `_di_force_service()` before forwarding.
#
# INPUT (annotation + trait):
#   # @lazy_proxy("json_helpers")
#   trait JsonService:
#       fn escape(s: text) -> text
#       fn js(s: text) -> text
#
# OUTPUT (generated proxy factory):
#   fn __lazy_json_helpers_escape(s: text) -> text:
#       val real = di_resolve("json_helpers")
#       real.escape_fn(s)
#
#   fn __lazy_json_helpers_js(s: text) -> text:
#       val real = di_resolve("json_helpers")
#       real.js_fn(s)
#
#   fn make_lazy_JsonService(service_name: text) -> JsonService:
#       JsonService(
#           escape_fn: __lazy_json_helpers_escape,
#           js_fn: __lazy_json_helpers_js)
#
# Why named functions (not lambdas): Closures cannot modify captured vars.
# Each delegation function calls di_resolve() which uses module-level Dict.
# No capture needed.
#
# NOTE: This module runs on the current runtime. NO try/catch/throw,
# NO generics, NO static fn patterns. Chained methods broken - use vars.

use app.desugar.trait_scanner.{scan_traits, ScannedTrait, TraitMethod}

export desugar_lazy_proxies

# ============================================================================
# Main Entry Point
# ============================================================================

# Scan source for @lazy_proxy annotations and generate proxy code.
#
# For each trait preceded by a `# @lazy_proxy("service_name")` comment,
# generates delegation functions and a factory function.
#
# Parameters:
#   source: Raw Simple source code
#
# Returns:
#   Source with generated proxy code appended after each annotated trait
fn desugar_lazy_proxies(source: text) -> text:
    val lines = source.split("\n")
    var result_lines: [text] = []
    var annotations: [ProxyAnnotation] = []

    # First pass: find all @lazy_proxy annotations
    var i = 0
    while i < lines.len():
        val line = lines[i]
        val trimmed = line.trim()

        # Check for @lazy_proxy annotation comment
        val annotation = parse_proxy_annotation(trimmed)
        if annotation.is_valid:
            # Look ahead for the trait declaration
            var j = i + 1
            while j < lines.len():
                val next_trimmed = lines[j].trim()
                if next_trimmed == "" or next_trimmed.starts_with("#"):
                    j = j + 1
                    continue
                # Found non-comment, non-blank line
                if next_trimmed.starts_with("trait "):
                    val trait_name = parse_trait_name(next_trimmed)
                    if trait_name != "":
                        annotations.push(ProxyAnnotation(
                            service_name: annotation.service_name,
                            trait_name: trait_name,
                            line_index: i))
                break
        i = i + 1

    # If no annotations, return source unchanged
    if annotations.len() == 0:
        return source

    # Scan traits from source
    val traits = scan_traits(source)

    # Second pass: copy lines and insert generated proxy code after trait blocks
    i = 0
    var annotation_idx = 0
    while i < lines.len():
        result_lines.push(lines[i])

        # Check if this line is a trait header that has an annotation
        val trimmed = lines[i].trim()
        if trimmed.starts_with("trait ") and trimmed.ends_with(":"):
            val trait_name = parse_trait_name(trimmed)
            val ann = find_annotation(trait_name, annotations)
            if ann.is_valid:
                # Find the matching scanned trait
                val scanned = find_scanned_trait(trait_name, traits)
                if scanned.methods.len() > 0:
                    # Skip past the trait body lines first
                    val trait_indent = count_indent(lines[i])
                    var j = i + 1
                    while j < lines.len():
                        val next_line = lines[j]
                        val next_trimmed = next_line.trim()
                        if next_trimmed == "":
                            result_lines.push(next_line)
                            j = j + 1
                        elif count_indent(next_line) > trait_indent:
                            result_lines.push(next_line)
                            j = j + 1
                        else:
                            break
                    i = j

                    # Generate proxy code
                    val proxy_lines = generate_proxy_code(ann.service_name, trait_name, scanned.methods)
                    var pi = 0
                    while pi < proxy_lines.len():
                        result_lines.push(proxy_lines[pi])
                        pi = pi + 1
                    continue
        i = i + 1

    join_lines(result_lines)

# ============================================================================
# Proxy Code Generation
# ============================================================================

# Generate delegation functions and factory for a trait's lazy proxy.
fn generate_proxy_code(service_name: text, trait_name: text, methods: [TraitMethod]) -> [text]:
    var lines: [text] = []

    # Blank line before generated code
    lines.push("")
    lines.push("# --- Auto-generated lazy proxy for \"{service_name}\" ---")
    lines.push("")

    # Generate one named delegation function per method
    var mi = 0
    while mi < methods.len():
        val method = methods[mi]
        val fn_name = "__lazy_{service_name}_{method.name}"
        val params_str = join_param_names(method.param_names)
        val args_str = join_param_names(method.param_names)

        # Build function signature
        var sig = "fn {fn_name}({params_str}):"
        lines.push(sig)
        lines.push("    val real = di_resolve(\"{service_name}\")")
        if args_str != "":
            lines.push("    real.{method.name}_fn({args_str})")
        else:
            lines.push("    real.{method.name}_fn()")
        lines.push("")
        mi = mi + 1

    # Generate factory function
    lines.push("fn make_lazy_{trait_name}() -> {trait_name}:")
    var constructor = "    {trait_name}("
    mi = 0
    while mi < methods.len():
        val method = methods[mi]
        val fn_name = "__lazy_{service_name}_{method.name}"
        if mi > 0:
            constructor = constructor + ", "
        constructor = constructor + "{method.name}_fn: {fn_name}"
        mi = mi + 1
    constructor = constructor + ")"
    lines.push(constructor)
    lines.push("")
    lines.push("# --- End auto-generated proxy ---")

    lines

# ============================================================================
# Annotation Parsing
# ============================================================================

struct ProxyAnnotation:
    is_valid: bool
    service_name: text
    trait_name: text
    line_index: i64

# Parse a comment line for @lazy_proxy annotation.
# Expected format: # @lazy_proxy("service_name")
fn parse_proxy_annotation(trimmed: text) -> ProxyAnnotation:
    val empty = ProxyAnnotation(is_valid: false, service_name: "", trait_name: "", line_index: 0)
    if not trimmed.starts_with("# @lazy_proxy("):
        return empty

    # Find the service name between quotes
    val start_marker = "# @lazy_proxy(\""
    val start_len = start_marker.len()
    if trimmed.len() <= start_len:
        return empty

    val rest = trimmed.substring(start_len)
    val quote_idx = find_char(rest, "\"")
    if quote_idx < 0:
        return empty

    val service_name = rest.substring(0, quote_idx)
    if service_name == "":
        return empty

    ProxyAnnotation(is_valid: true, service_name: service_name, trait_name: "", line_index: 0)

# Extract trait name from "trait NAME:" line.
fn parse_trait_name(trimmed: text) -> text:
    if not trimmed.starts_with("trait "):
        return ""
    if not trimmed.ends_with(":"):
        return ""
    val tlen = trimmed.len()
    val name_part = trimmed.substring(6, tlen - 1)
    name_part.trim()

# Find annotation for a given trait name.
fn find_annotation(trait_name: text, annotations: [ProxyAnnotation]) -> ProxyAnnotation:
    var idx = 0
    while idx < annotations.len():
        val ann = annotations[idx]
        if ann.trait_name == trait_name:
            return ann
        idx = idx + 1
    ProxyAnnotation(is_valid: false, service_name: "", trait_name: "", line_index: 0)

# Find a scanned trait by name.
fn find_scanned_trait(name: text, traits: [ScannedTrait]) -> ScannedTrait:
    var idx = 0
    while idx < traits.len():
        val t = traits[idx]
        if t.name == name:
            return t
        idx = idx + 1
    ScannedTrait(name: name, methods: [])

# ============================================================================
# Helpers
# ============================================================================

fn join_param_names(names: [text]) -> text:
    var result = ""
    var idx = 0
    while idx < names.len():
        if idx > 0:
            result = result + ", "
        result = result + names[idx]
        idx = idx + 1
    result

fn find_char(s: text, ch: text) -> i64:
    var idx = 0
    val slen = s.len()
    while idx < slen:
        val c = s.substring(idx, idx + 1)
        if c == ch:
            return idx
        idx = idx + 1
    -1

fn count_indent(line: text) -> i64:
    var count = 0
    val llen = line.len()
    while count < llen:
        val ch = line.substring(count, count + 1)
        if ch == " ":
            count = count + 1
        elif ch == "\t":
            count = count + 4
        else:
            break
    count

fn join_lines(lines: [text]) -> text:
    var result = ""
    var idx = 0
    while idx < lines.len():
        if idx > 0:
            result = result + "\n"
        result = result + lines[idx]
        idx = idx + 1
    result
