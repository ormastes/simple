# Trait Desugaring Pass
#
# Transforms trait declarations into struct-with-fn-fields that the current
# runtime can execute. This is a TEXT-LEVEL transformation that runs before
# the parser, processing raw source lines.
#
# INPUT:
#   trait OrderRepo:
#       fn save(order: Order)
#       fn find(id: text) -> Order?
#       fn list() -> [Order]
#       me delete(id: text)
#
# OUTPUT:
#   struct OrderRepo:
#       save_fn: fn(Order)
#       find_fn: fn(text) -> Order?
#       list_fn: fn() -> [Order]
#       delete_fn: fn(text)
#
# Rules:
#   - Each `fn method(p1: T1, p2: T2) -> R` becomes `method_fn: fn(T1, T2) -> R`
#   - Each `me method(p1: T1) -> R` becomes `method_fn: fn(T1) -> R`
#   - Methods with default bodies (ends with ":" + indented body) are also converted
#   - Methods with no params become `method_fn: fn()`
#   - The `me` keyword is stripped (fn-fields don't distinguish mutability)
#
# Optional: impl TraitName for value:
#   impl OrderRepo for sql:
#       fn save(order: Order): sql_insert(order)
#
# Generates:
#   fn sql_as_OrderRepo() -> OrderRepo:
#       OrderRepo(save_fn: fn(order): sql_insert(order), ...)
#
# NOTE: This module runs on the current runtime, so it MUST NOT use
# try/catch/throw, generics, or static fn patterns.
# NOTE: Chained method calls are broken - use intermediate vars.
# NOTE: No multi-line boolean expressions without parentheses.


export desugar_traits

# Main entry: desugar all trait declarations in source text
#
# Scans source for `trait Name:` headers and replaces each trait block
# with a `struct Name:` block containing `method_fn: fn(types)` fields.
# Also handles `impl TraitName for value:` blocks by generating factory
# functions.
#
# Parameters:
#   source: Raw Simple source code as text
#
# Returns:
#   Source text with trait declarations replaced by struct declarations
fn desugar_traits(source: text) -> text:
    val lines = source.split("\n")
    var result_lines = []
    var i = 0

    while i < lines.len():
        val line = lines[i]
        val trimmed = line.trim()

        # Check if this is a trait header: "trait NAME:"
        val trait_name = parse_trait_header(trimmed)
        if trait_name != "":
            val trait_indent = get_indent(line)
            val body_indent = trait_indent + 4

            # Collect the entire trait body (lines with deeper indent)
            var body_lines = []
            var j = i + 1
            while j < lines.len():
                val next_line = lines[j]
                val next_trimmed = next_line.trim()
                if next_trimmed == "":
                    body_lines.push(next_line)
                    j = j + 1
                elif get_indent(next_line) > trait_indent:
                    body_lines.push(next_line)
                    j = j + 1
                else:
                    break

            # Generate: struct TraitName:
            val indent_str = get_indent_str(line)
            result_lines.push("{indent_str}struct {trait_name}:")

            # Generate fn-field lines for each method
            val field_lines = generate_struct_fields(body_lines, body_indent, indent_str)
            var fi = 0
            while fi < field_lines.len():
                result_lines.push(field_lines[fi])
                fi = fi + 1

            i = j
            continue

        # Check if this is an impl-for header: "impl TraitName for VALUE:"
        val impl_info = parse_impl_for_header(trimmed)
        if impl_info.is_valid:
            val trait_indent = get_indent(line)

            # Collect the entire impl block body
            var body_lines = []
            var j = i + 1
            while j < lines.len():
                val next_line = lines[j]
                val next_trimmed = next_line.trim()
                if next_trimmed == "":
                    body_lines.push(next_line)
                    j = j + 1
                elif get_indent(next_line) > trait_indent:
                    body_lines.push(next_line)
                    j = j + 1
                else:
                    break

            # Generate factory function: fn VALUE_as_TraitName() -> TraitName:
            val indent_str = get_indent_str(line)
            val factory_name = impl_info.value_name + "_as_" + impl_info.trait_name
            val factory_lines = generate_factory_fn(
                factory_name,
                impl_info.trait_name,
                body_lines,
                indent_str)

            var fi = 0
            while fi < factory_lines.len():
                result_lines.push(factory_lines[fi])
                fi = fi + 1

            i = j
            continue

        result_lines.push(line)
        i = i + 1

    join_lines(result_lines, "\n")

# ================================================================
# Struct Field Generation
# ================================================================

# Generate `method_fn: fn(types) -> ReturnType` fields from trait body lines.
#
# Skips blank lines, comments, `type` declarations, and default method bodies.
# For each abstract method signature, creates a fn-field.
fn generate_struct_fields(body_lines: [text], body_indent: i64, parent_indent: text) -> [text]:
    var fields = []
    var field_indent = parent_indent + "    "
    var i = 0

    while i < body_lines.len():
        val line = body_lines[i]
        val trimmed = line.trim()

        if trimmed == "":
            i = i + 1
            continue

        if trimmed.starts_with("#"):
            i = i + 1
            continue

        if trimmed.starts_with("type "):
            i = i + 1
            continue

        # Handle fn or me method lines
        var is_method = false
        var sig_rest = ""

        if trimmed.starts_with("fn "):
            is_method = true
            sig_rest = trimmed[3:]
        elif trimmed.starts_with("me "):
            is_method = true
            sig_rest = trimmed[3:]

        if is_method:
            val method_name = extract_method_name(sig_rest)
            if method_name != "":
                val param_types = extract_param_types(sig_rest)
                val return_type = extract_return_type(sig_rest)

                val fn_type = build_fn_type(param_types, return_type)
                val field_line = "{field_indent}{method_name}_fn: {fn_type}"
                fields.push(field_line)

            # Skip the method body if it has one (ends with ":" + indented body)
            val current_indent = get_indent(line)
            if trimmed.ends_with(":"):
                var k = i + 1
                while k < body_lines.len():
                    val next_line = body_lines[k]
                    val next_trimmed = next_line.trim()
                    if next_trimmed == "":
                        k = k + 1
                    elif get_indent(next_line) > current_indent:
                        k = k + 1
                    else:
                        break
                i = k
                continue
            else:
                val has_inline = has_inline_body(trimmed)
                if has_inline:
                    i = i + 1
                    continue

        i = i + 1

    fields

# ================================================================
# Factory Function Generation (impl X for Y)
# ================================================================

# Generate a factory function from an impl-for block.
#
# Example input:
#   impl_for: "sql", "OrderRepo"
#   body_lines: fn save(order: Order): sql_insert(order)
#               fn find(id: text) -> Order?: sql_select(id)
#
# Example output:
#   fn sql_as_OrderRepo() -> OrderRepo:
#       OrderRepo(
#           save_fn: fn(order): sql_insert(order),
#           find_fn: fn(id): sql_select(id),
#       )
fn generate_factory_fn(
    factory_name: text,
    trait_name: text,
    body_lines: [text],
    indent_str: text) -> [text]:

    var lines = []
    val fn_indent = indent_str
    val body_indent = fn_indent + "    "
    val field_indent = body_indent + "    "

    lines.push("{fn_indent}fn {factory_name}() -> {trait_name}:")
    lines.push("{body_indent}{trait_name}(")

    var method_entries = collect_impl_methods(body_lines)
    var last_idx = method_entries.len() - 1
    var mi = 0
    while mi < method_entries.len():
        val entry = method_entries[mi]
        var comma = ","
        if mi == last_idx:
            comma = ""
        lines.push("{field_indent}{entry.method_name}_fn: {entry.lambda}{comma}")
        mi = mi + 1

    lines.push("{body_indent})")
    lines

# Holds a parsed impl-for method entry for factory generation
struct ImplMethodEntry:
    method_name: text
    lambda: text

# Collect method entries from impl-for body, building lambda expressions.
#
# For each method like: fn save(order: Order): sql_insert(order)
# Generates: save -> "fn(order): sql_insert(order)"
fn collect_impl_methods(body_lines: [text]) -> [ImplMethodEntry]:
    var entries = []
    var i = 0

    while i < body_lines.len():
        val line = body_lines[i]
        val trimmed = line.trim()

        if trimmed == "":
            i = i + 1
            continue

        if trimmed.starts_with("#"):
            i = i + 1
            continue

        var sig_rest = ""
        if trimmed.starts_with("fn "):
            sig_rest = trimmed[3:]
        elif trimmed.starts_with("me "):
            sig_rest = trimmed[3:]
        else:
            i = i + 1
            continue

        val method_name = extract_method_name(sig_rest)
        if method_name == "":
            i = i + 1
            continue

        val param_names = extract_param_names(sig_rest)
        val names_str = join_texts(param_names, ", ")

        # Check for inline body: "fn method(params) -> type: body_expr"
        val inline_body = extract_inline_body(sig_rest)
        var lambda = ""
        if inline_body != "":
            lambda = "fn({names_str}): {inline_body}"
            entries.push(ImplMethodEntry(method_name: method_name, lambda: lambda))
            i = i + 1
            continue

        # Check for multi-line body (ends with ":")
        val current_indent = get_indent(line)
        if trimmed.ends_with(":"):
            # Collect body lines for multi-line lambda
            var body_parts = []
            var k = i + 1
            while k < body_lines.len():
                val next_line = body_lines[k]
                val next_trimmed = next_line.trim()
                if next_trimmed == "":
                    k = k + 1
                elif get_indent(next_line) > current_indent:
                    body_parts.push(next_trimmed)
                    k = k + 1
                else:
                    break

            if body_parts.len() == 1:
                # Single-line body - make inline lambda
                lambda = "fn({names_str}): {body_parts[0]}"
            else:
                # Multi-line body - use first line as approximation
                # TODO: full multi-line lambda support
                var body_text = ""
                var bi = 0
                while bi < body_parts.len():
                    if bi > 0:
                        body_text = body_text + "; "
                    body_text = body_text + body_parts[bi]
                    bi = bi + 1
                lambda = "fn({names_str}): {body_text}"

            entries.push(ImplMethodEntry(method_name: method_name, lambda: lambda))
            i = k
            continue

        i = i + 1

    entries

# ================================================================
# Signature Parsing Helpers
# ================================================================

# Parse a trimmed line as a trait header.
# Returns the trait name if the line matches "trait NAME:", else "".
fn parse_trait_header(trimmed: text) -> text:
    if not trimmed.starts_with("trait "):
        return ""
    if not trimmed.ends_with(":"):
        return ""

    val tlen = trimmed.len()
    val name_part = trimmed[6:tlen - 1]
    val name = name_part.trim()

    if name == "":
        return ""
    val first_ch = name[0:1]
    if not is_uppercase(first_ch):
        return ""

    name

# Holds parsed info from "impl TraitName for value:"
struct ImplForInfo:
    is_valid: bool
    trait_name: text
    value_name: text

# Parse a trimmed line as an "impl TraitName for value:" header.
# Returns ImplForInfo with is_valid=false if not matched.
fn parse_impl_for_header(trimmed: text) -> ImplForInfo:
    val empty = ImplForInfo(is_valid: false, trait_name: "", value_name: "")

    if not trimmed.starts_with("impl "):
        return empty
    if not trimmed.ends_with(":"):
        return empty

    val tlen = trimmed.len()
    val inner = trimmed[5:tlen - 1]
    val inner_trimmed = inner.trim()

    # Find " for " in the inner portion
    val for_idx = find_substr(inner_trimmed, " for ")
    if for_idx < 0:
        return empty

    val trait_part = inner_trimmed[0:for_idx]
    val trait_name = trait_part.trim()
    val value_start = for_idx + 5
    val value_part = inner_trimmed[value_start:]
    val value_name = value_part.trim()

    if trait_name == "" or value_name == "":
        return empty

    val first_ch = trait_name[0:1]
    if not is_uppercase(first_ch):
        return empty

    ImplForInfo(is_valid: true, trait_name: trait_name, value_name: value_name)

# Extract the method name from sig_rest (the part after "fn " or "me ").
# Name ends at first "(", ":", "<", or " ".
fn extract_method_name(sig_rest: text) -> text:
    var name = ""
    var ci = 0
    val slen = sig_rest.len()
    while ci < slen:
        val ch = sig_rest[ci:ci + 1]
        if ch == "(" or ch == ":" or ch == "<" or ch == " ":
            break
        name = name + ch
        ci = ci + 1
    name

# Extract parameter TYPES from a method signature for fn-field type building.
#
# Given "method(order: Order, id: text) -> text", extracts ["Order", "text"].
# For unnamed params like "method(Order)", extracts ["Order"].
# For no params like "method()", extracts [].
fn extract_param_types(sig_rest: text) -> [text]:
    val open_paren = find_char(sig_rest, "(")
    if open_paren < 0:
        return []

    val close_paren = find_matching_paren(sig_rest, open_paren)
    if close_paren < 0:
        return []

    val param_start = open_paren + 1
    val params_text = sig_rest[param_start:close_paren]
    val trimmed_params = params_text.trim()
    if trimmed_params == "":
        return []

    split_param_types(trimmed_params)

# Extract parameter NAMES from a method signature for lambda generation.
#
# Given "method(order: Order, id: text)", extracts ["order", "id"].
fn extract_param_names(sig_rest: text) -> [text]:
    val open_paren = find_char(sig_rest, "(")
    if open_paren < 0:
        return []

    val close_paren = find_matching_paren(sig_rest, open_paren)
    if close_paren < 0:
        return []

    val param_start = open_paren + 1
    val params_text = sig_rest[param_start:close_paren]
    val trimmed_params = params_text.trim()
    if trimmed_params == "":
        return []

    split_names_from_params(trimmed_params)

# Extract the return type from a method signature.
# Looks for "-> Type" after the closing paren.
# Returns "" if no return type.
fn extract_return_type(sig_rest: text) -> text:
    val close_paren = find_matching_paren(sig_rest, find_char(sig_rest, "("))
    if close_paren < 0:
        return ""

    val slen = sig_rest.len()
    val rest = sig_rest[close_paren + 1:]
    val rest_trimmed = rest.trim()

    if not rest_trimmed.starts_with("->"):
        return ""

    # Skip "->" and collect until ":" or end
    val arrow_part = rest_trimmed[2:]
    val arrow_trimmed = arrow_part.trim()

    # Stop at ":" (method body follows)
    val colon_idx = find_char(arrow_trimmed, ":")
    if colon_idx >= 0:
        val type_part = arrow_trimmed[0:colon_idx]
        return type_part.trim()

    arrow_trimmed

# Extract inline body from a signature line.
# e.g., "fn method(params) -> Type: body_expr" -> "body_expr"
# Returns "" if no inline body.
fn extract_inline_body(sig_rest: text) -> text:
    val open_paren = find_char(sig_rest, "(")
    if open_paren < 0:
        return ""

    val close_paren = find_matching_paren(sig_rest, open_paren)
    if close_paren < 0:
        return ""

    val slen = sig_rest.len()
    var ci = close_paren + 1

    # Look for ":" after params/return-type
    while ci < slen:
        val ch = sig_rest[ci:ci + 1]
        if ch == ":":
            val after = ci + 1
            if after < slen:
                val body_part = sig_rest[after:]
                val body_trimmed = body_part.trim()
                if body_trimmed != "":
                    return body_trimmed
            return ""
        ci = ci + 1

    ""

# Check if a method signature has an inline body (colon followed by content).
fn has_inline_body(trimmed: text) -> bool:
    val body = extract_inline_body(trimmed[3:])
    body != ""

# Build a fn-field type string from parameter types and return type.
# e.g., types=["Order", "text"], return_type="bool" -> "fn(Order, text) -> bool"
# e.g., types=[], return_type="" -> "fn()"
fn build_fn_type(param_types: [text], return_type: text) -> text:
    val types_str = join_texts(param_types, ", ")
    if return_type == "":
        return "fn({types_str})"
    "fn({types_str}) -> {return_type}"

# ================================================================
# Parameter Splitting Helpers
# ================================================================

# Split "param: Type, param2: Type2" into types ["Type", "Type2"].
# Handles both "name: Type" and bare "Type" formats.
fn split_param_types(s: text) -> [text]:
    var types = []
    var current = ""
    var idx = 0
    val slen = s.len()
    var paren_depth = 0
    var bracket_depth = 0

    while idx < slen:
        val ch = s[idx:idx + 1]
        if ch == "(":
            paren_depth = paren_depth + 1
            current = current + ch
        elif ch == ")":
            paren_depth = paren_depth - 1
            current = current + ch
        elif ch == "[":
            bracket_depth = bracket_depth + 1
            current = current + ch
        elif ch == "]":
            bracket_depth = bracket_depth - 1
            current = current + ch
        elif ch == "," and paren_depth == 0 and bracket_depth == 0:
            val param_type = extract_type_from_param(current)
            if param_type != "":
                types.push(param_type)
            current = ""
        else:
            current = current + ch
        idx = idx + 1

    val last_type = extract_type_from_param(current)
    if last_type != "":
        types.push(last_type)

    types

# Split "param: Type, param2: Type2" into names ["param", "param2"].
fn split_names_from_params(s: text) -> [text]:
    var names = []
    var current = ""
    var idx = 0
    val slen = s.len()
    var paren_depth = 0
    var bracket_depth = 0

    while idx < slen:
        val ch = s[idx:idx + 1]
        if ch == "(":
            paren_depth = paren_depth + 1
            current = current + ch
        elif ch == ")":
            paren_depth = paren_depth - 1
            current = current + ch
        elif ch == "[":
            bracket_depth = bracket_depth + 1
            current = current + ch
        elif ch == "]":
            bracket_depth = bracket_depth - 1
            current = current + ch
        elif ch == "," and paren_depth == 0 and bracket_depth == 0:
            val param_name = extract_name_from_param(current)
            if param_name != "":
                names.push(param_name)
            current = ""
        else:
            current = current + ch
        idx = idx + 1

    val last_name = extract_name_from_param(current)
    if last_name != "":
        names.push(last_name)

    names

# Extract type from a single parameter declaration.
# "name: Type" -> "Type", "Type" -> "Type" (bare type)
fn extract_type_from_param(param: text) -> text:
    val trimmed = param.trim()
    if trimmed == "":
        return ""

    val colon_idx = find_char(trimmed, ":")
    if colon_idx >= 0:
        val colon_plus = colon_idx + 1
        val type_part = trimmed[colon_plus:]
        return type_part.trim()

    # No colon - treat whole thing as type
    trimmed

# Extract name from a single parameter declaration.
# "name: Type" -> "name", "name" -> "name"
fn extract_name_from_param(param: text) -> text:
    val trimmed = param.trim()
    if trimmed == "":
        return ""

    val colon_idx = find_char(trimmed, ":")
    if colon_idx > 0:
        val name_part = trimmed[0:colon_idx]
        return name_part.trim()

    trimmed

# ================================================================
# General Text Helpers
# ================================================================

# Get the number of leading spaces in a line (tabs = 4 spaces)
fn get_indent(line: text) -> i64:
    var count = 0
    val llen = line.len()
    while count < llen:
        val ch = line[count:count + 1]
        if ch == " ":
            count = count + 1
        elif ch == "\t":
            count = count + 4
        else:
            break
    count

# Get the leading whitespace string of a line
fn get_indent_str(line: text) -> text:
    var count = 0
    val llen = line.len()
    while count < llen:
        val ch = line[count:count + 1]
        if ch == " " or ch == "\t":
            count = count + 1
        else:
            break
    if count == 0:
        return ""
    line[0:count]

# Check if a single character is uppercase A-Z
fn is_uppercase(ch: text) -> bool:
    if ch.len() != 1:
        return false
    ch >= "A" and ch <= "Z"

# Find the first occurrence of a character in a string. Returns index or -1.
fn find_char(s: text, ch: text) -> i64:
    var idx = 0
    val slen = s.len()
    while idx < slen:
        val c = s[idx:idx + 1]
        if c == ch:
            return idx
        idx = idx + 1
    -1

# Find the matching closing parenthesis for an opening paren at open_idx.
# Returns the index or -1 if not found.
fn find_matching_paren(s: text, open_idx: i64) -> i64:
    if open_idx < 0:
        return -1
    var depth = 0
    var ci = open_idx
    val slen = s.len()
    while ci < slen:
        val ch = s[ci:ci + 1]
        if ch == "(":
            depth = depth + 1
        elif ch == ")":
            depth = depth - 1
            if depth == 0:
                return ci
        ci = ci + 1
    -1

# Find a substring in a string. Returns the start index or -1.
fn find_substr(haystack: text, needle: text) -> i64:
    val hlen = haystack.len()
    val nlen = needle.len()
    if nlen == 0:
        return 0
    if nlen > hlen:
        return -1

    var idx = 0
    while idx <= hlen - nlen:
        val candidate = haystack[idx:idx + nlen]
        if candidate == needle:
            return idx
        idx = idx + 1
    -1

# Join a list of texts with a separator
fn join_texts(items: [text], sep: text) -> text:
    var result = ""
    var idx = 0
    while idx < items.len():
        if idx > 0:
            result = result + sep
        result = result + items[idx]
        idx = idx + 1
    result

# Join a list of lines with a newline separator
fn join_lines(lines: [text], nl: text) -> text:
    join_texts(lines, nl)
