# Enum Constructor Desugaring
#
# Transforms enum variant constructors into factory functions to work around
# "unsupported path call" runtime limitation.
#
# INPUT:
#   enum Value:
#       Int(n: i32)
#       Float(f: f64)
#       String(s: text)
#       nil
#
# OUTPUT:
#   fn Value__Int(n: i32) -> Value:
#       Value(variant: "Int", n: n)
#
#   fn Value__Float(f: f64) -> Value:
#       Value(variant: "Float", f: f)
#
#   fn Value__String(s: text) -> Value:
#       Value(variant: "String", s: s)
#
#   fn Value__None() -> Value:
#       Value(variant: "None")
#
#   enum Value:
#       Int(n: i32)
#       Float(f: f64)
#       String(s: text)
#       nil
#
# NOTE: This module runs on the Rust runtime, so it MUST NOT use
# static fn patterns. All BUG workarounds applied.

use std.text.{NL}

export desugar_enum_constructors

# Main entry: desugar all enum constructors in source text
fn desugar_enum_constructors(source: text) -> text:
    val lines = source.split(NL)
    var result_lines = []
    var i = 0

    while i < lines.len():
        val line = lines[i]
        val trimmed = line.trim()

        # Check if this line starts an enum block
        val enum_info = parse_enum_header(trimmed)
        if enum_info.is_enum:
            val enum_name = enum_info.enum_name
            val type_params = enum_info.type_params
            val enum_indent = get_indent(line)

            # Collect the entire enum block
            var enum_lines = [line]
            var j = i + 1
            while j < lines.len():
                val next_line = lines[j]
                # Empty lines inside the block are part of it
                if next_line.trim() == "":
                    enum_lines.push(next_line)
                    j = j + 1
                # Lines with greater indent are part of the block
                elif get_indent(next_line) > enum_indent:
                    enum_lines.push(next_line)
                    j = j + 1
                # Lines with same or less indent end the block
                else:
                    break

            # Process the enum block: extract variants and generate factories
            val factories = generate_enum_factories(enum_name, type_params, enum_lines, enum_indent)

            # Add generated factory functions BEFORE the enum block
            for factory_line in factories:
                result_lines.push(factory_line)

            # Add blank line separator if we generated factories
            if factories.len() > 0:
                result_lines.push("")

            # Add original enum definition unchanged
            for enum_line in enum_lines:
                result_lines.push(enum_line)

            i = j
        else:
            result_lines.push(line)
            i = i + 1

    result_lines.join(NL)

# ================================================================
# Enum Header Parsing
# ================================================================

struct EnumInfo:
    is_enum: bool
    enum_name: text
    type_params: text  # generic parameters like "<T>" or "<K, V>"

fn parse_enum_header(trimmed: text) -> EnumInfo:
    # Match "enum EnumName:" or "enum EnumName<T>:"
    if not trimmed.starts_with("enum "):
        return EnumInfo(is_enum: false, enum_name: "", type_params: "")

    # Remove trailing ':'
    var header = trimmed
    if header.ends_with(":"):
        val hlen = header.len()
        header = header[0:hlen - 1]

    # Remove "enum " prefix
    header = header[5:]
    header = header.trim()

    # Extract type parameters
    val type_params = extract_generics(header)
    val enum_name = strip_generics(header)
    EnumInfo(is_enum: true, enum_name: enum_name, type_params: type_params)

# Strip generic parameters: "Foo<T, U>" -> "Foo"
fn strip_generics(name: text) -> text:
    var angle = -1
    var ni = 0
    val nlen = name.len()
    while ni < nlen:
        val ch = name[ni:ni + 1]
        if ch == "<":
            angle = ni
            break
        ni = ni + 1

    if angle >= 0:
        return name[0:angle]
    name

# Extract generic parameters: "Foo<T, U>" -> "<T, U>"
fn extract_generics(name: text) -> text:
    var angle_start = -1
    var ni = 0
    val nlen = name.len()

    # Find opening <
    while ni < nlen:
        val ch = name[ni:ni + 1]
        if ch == "<":
            angle_start = ni
            break
        ni = ni + 1

    if angle_start < 0:
        return ""  # No generics

    # Find closing > (handle nested <>)
    var depth = 0
    var ci = angle_start
    while ci < nlen:
        val ch = name[ci:ci + 1]
        if ch == "<":
            depth = depth + 1
        elif ch == ">":
            depth = depth - 1
            if depth == 0:
                # Found matching >
                return name[angle_start:ci + 1]
        ci = ci + 1

    # No matching >, return what we have
    name[angle_start:]

# ================================================================
# Factory Generation
# ================================================================

struct Variant:
    name: text
    parameters: text  # Full parameter list like "(n: i32, s: text)"

fn generate_enum_factories(enum_name: text, type_params: text, enum_lines: [text], enum_indent: i64) -> [text]:
    # Parse variants from enum body
    val variants = extract_variants(enum_lines, enum_indent)

    var factory_lines = []

    for variant in variants:
        val factory = generate_variant_factory(enum_name, type_params, variant)
        for factory_line in factory:
            factory_lines.push(factory_line)
        factory_lines.push("")  # Blank line between factories

    factory_lines

# Extract all variants from enum body
fn extract_variants(enum_lines: [text], enum_indent: i64) -> [Variant]:
    var variants = []
    val variant_indent = enum_indent + 4

    # Skip the enum header line
    var i = 1
    while i < enum_lines.len():
        val line = enum_lines[i]
        val trimmed = line.trim()

        # Skip blank lines and comments
        if trimmed == "" or trimmed.starts_with("#"):
            i = i + 1
            continue

        # Check if this line is a variant at the right indent level
        if get_indent(line) == variant_indent:
            val variant_info = parse_variant_line(trimmed)
            if variant_info.name != "":
                variants.push(variant_info)

        i = i + 1

    variants

# Parse a single variant line
fn parse_variant_line(trimmed: text) -> Variant:
    # Format: "VariantName" or "VariantName(param: type, ...)"
    var name = ""
    var parameters = ""

    # Find opening parenthesis if any
    var paren_pos = -1
    var ci = 0
    val tlen = trimmed.len()
    while ci < tlen:
        val ch = trimmed[ci:ci + 1]
        if ch == "(":
            paren_pos = ci
            break
        ci = ci + 1

    if paren_pos < 0:
        # No parameters: "VariantName"
        name = trimmed.trim()
        parameters = ""
    else:
        # Has parameters: "VariantName(params)"
        name = trimmed[0:paren_pos].trim()
        parameters = trimmed[paren_pos:].trim()

    Variant(name: name, parameters: parameters)

# Generate factory function for a single variant
fn generate_variant_factory(enum_name: text, type_params: text, variant: Variant) -> [text]:
    var lines = []

    val factory_name = "{enum_name}__{variant.name}"

    # Build function signature
    var signature = ""
    if variant.parameters == "":
        # No parameters: fn EnumName__Variant() -> EnumName:
        signature = "fn {factory_name}() -> {enum_name}:"
    else:
        # Has parameters: fn EnumName__Variant(params) -> EnumName:
        signature = "fn {factory_name}{variant.parameters} -> {enum_name}:"

    lines.push(signature)

    # Build function body: construct enum variant
    # Try direct variant construction (runtime might support this in function scope)
    if variant.parameters == "":
        # No parameters: just return the variant name
        lines.push("    {variant.name}")
    else:
        # With parameters: construct using parameter names
        val param_names = extract_parameter_names(variant.parameters)
        lines.push("    {variant.name}{param_names}")

    lines

# Extract parameter names from parameter list
# Input: "(n: i32, s: text)" -> Output: "(n, s)"
fn extract_parameter_names(params: text) -> text:
    # Remove outer parentheses
    var inner = params
    if inner.starts_with("(") and inner.ends_with(")"):
        val ilen = inner.len()
        inner = inner[1:ilen - 1]

    # Split by comma and extract names
    val parts = inner.split(",")
    var names = []
    for part in parts:
        val trimmed = part.trim()
        # Extract name (before ':')
        var colon_pos = -1
        var ci = 0
        val tlen = trimmed.len()
        while ci < tlen:
            val ch = trimmed[ci:ci + 1]
            if ch == ":":
                colon_pos = ci
                break
            ci = ci + 1

        if colon_pos > 0:
            val name = trimmed[0:colon_pos].trim()
            names.push(name)

    # Rebuild as (name1, name2, ...)
    var result = "("
    var i = 0
    while i < names.len():
        if i > 0:
            result = result + ", "
        result = result + names[i]
        i = i + 1
    result = result + ")"
    result

# ================================================================
# Helpers
# ================================================================

# Get the indentation level (number of leading spaces) of a line
fn get_indent(line: text) -> i64:
    var count = 0
    val llen = line.len()
    while count < llen:
        val ch = line[count:count + 1]
        if ch == " ":
            count = count + 1
        elif ch == "\t":
            count = count + 4  # Tab = 4 spaces
        else:
            break
    count
