# SSpec Documentation Generator (Written in Simple)
#
# Extracts markdown documentation from sspec test files ("""...""" blocks)
# and generates comprehensive BDD-style documentation in doc/spec/
#
# Usage: sspec-docgen <spec_files...> [--output <dir>]
#
# Features:
# - Metadata Extraction: Parses Feature ID, Category, Status, Difficulty
# - Categorized INDEX: Groups features by category
# - Validation: Warns about missing documentation and incomplete specs
# - Statistics: Tracks documentation coverage and quality metrics

# I/O imports
use app.io.mod (file_read, file_write, file_exists, dir_create)
use lib.cli.cli_util (get_cli_args)
use std.text.{NL}
use std.log.{error, warn}

# Compatibility aliases for native_fs_* -> io module
fn native_fs_read_string(path: str) -> text:
    file_read(path)

fn native_fs_write_string(path: str, content: str):
    file_write(path, content)

fn native_fs_exists(path: str) -> bool:
    file_exists(path)

fn native_fs_create_dir(path: str):
    dir_create(path, true)

# Documentation block extracted from sspec file
struct DocBlock:
    content: str
    line_start: i64
    line_end: i64

# Feature metadata extracted from documentation
struct FeatureMetadata:
    id: str
    category: str
    difficulty: str
    status: str

    static fn empty() -> FeatureMetadata:
        FeatureMetadata(id: "", category: "", difficulty: "", status: "")

# Parsed sspec file with documentation and test structure
struct SspecDoc:
    file_path: str
    doc_blocks: [DocBlock]
    feature_title: str
    feature_ids: [str]
    metadata: FeatureMetadata

# Validation result for a spec file
struct ValidationResult:
    file_path: str
    has_docs: bool
    doc_lines: i64
    warnings: [str]

# Statistics for documentation generation
struct DocStats:
    total_specs: i64
    specs_with_docs: i64
    specs_without_docs: i64
    total_doc_lines: i64
    total_warnings: i64

    static fn empty() -> DocStats:
        DocStats(
            total_specs: 0,
            specs_with_docs: 0,
            specs_without_docs: 0,
            total_doc_lines: 0,
            total_warnings: 0
        )

    fn coverage_percent(self) -> f64:
        if self.total_specs == 0:
            0.0
        else:
            (self.specs_with_docs * 100) / self.total_specs

# Feature entry for INDEX generation
struct FeatureEntry:
    title: str
    filename: str
    status: str
    difficulty: str
    coverage: str
    doc_lines: i64
    category: str

# ============================================================================
# PARSER MODULE
# ============================================================================

fn parse_id_attr(line: str) -> str:
    # Parse #[id("...")] attribute to extract ID
    val trimmed = line.trim()
    if not trimmed.starts_with("#[id("):
        return ""

    # Extract content between quotes
    val after_prefix = trimmed[5:]  # Remove "#[id("
    val without_suffix = after_prefix.trim_end_matches(")]")
    val inner = without_suffix.trim()

    if inner.starts_with("\"") and inner.ends_with("\"") and inner.len() >= 2:
        inner[1:-1]  # Remove quotes
    else:
        ""

fn parse_sspec_file(path: str) -> Result<SspecDoc, str>:
    val content_result = native_fs_read_string(path)
    match content_result:
        case Err(e):
            return Err("Failed to read file: {e}")
        case Ok(content):
            val lines = content.split(NL)
            var doc_blocks = []
            var feature_title = ""
            var feature_ids = []

            var i = 0
            while i < lines.len():
                val line = lines[i]
                val trimmed = line.trim()

                # Extract feature IDs from #[id(...)] attributes
                if trimmed.starts_with("#[id("):
                    val id = parse_id_attr(trimmed)
                    if id != "":
                        feature_ids.push(id)

                # Check for doc block start
                if trimmed == "\"\"\"":
                    val start_line = i
                    i = i + 1

                    var block_content = ""
                    var found_end = false

                    # Collect lines until closing """
                    while i < lines.len():
                        val block_line = lines[i]

                        if block_line.trim() == "\"\"\"":
                            found_end = true
                            break

                        block_content = block_content + block_line + NL
                        i = i + 1

                    if found_end:
                        # Extract feature title from first doc block if present
                        if feature_title == "" and block_content.contains("# "):
                            val block_lines = block_content.split(NL)
                            for bl in block_lines:
                                val bl_trimmed = bl.trim()
                                if bl_trimmed.starts_with("# "):
                                    feature_title = bl_trimmed[2:].trim()
                                    break

                        doc_blocks.push(DocBlock(
                            content: block_content.trim(),
                            line_start: start_line,
                            line_end: i
                        ))

                i = i + 1

            val doc = SspecDoc(
                file_path: path,
                doc_blocks: doc_blocks,
                feature_title: feature_title,
                feature_ids: feature_ids,
                metadata: FeatureMetadata.empty()
            )
            return Ok(doc)

# ============================================================================
# METADATA MODULE
# ============================================================================

fn extract_field_value(line: str, prefix: str) -> str:
    # Extract value from a metadata field line
    if not line.starts_with(prefix):
        return ""

    val value_part = line[prefix.len():]
    value_part.trim()

fn extract_metadata(doc: SspecDoc) -> FeatureMetadata:
    var metadata = FeatureMetadata.empty()

    # Concatenate all doc blocks for metadata extraction
    var full_content = ""
    for block in doc.doc_blocks:
        full_content = full_content + block.content + NL

    # Extract metadata fields from markdown
    val lines = full_content.split(NL)
    for line in lines:
        val trimmed = line.trim()

        # Match patterns like "**Feature ID:** #20"
        if trimmed.starts_with("**Feature ID:**"):
            val value = extract_field_value(trimmed, "**Feature ID:**")
            if value != "":
                metadata = FeatureMetadata(
                    id: value,
                    category: metadata.category,
                    difficulty: metadata.difficulty,
                    status: metadata.status
                )
        elif trimmed.starts_with("**Category:**"):
            val value = extract_field_value(trimmed, "**Category:**")
            if value != "":
                metadata = FeatureMetadata(
                    id: metadata.id,
                    category: value,
                    difficulty: metadata.difficulty,
                    status: metadata.status
                )
        elif trimmed.starts_with("**Difficulty:**"):
            val value = extract_field_value(trimmed, "**Difficulty:**")
            if value != "":
                metadata = FeatureMetadata(
                    id: metadata.id,
                    category: metadata.category,
                    difficulty: value,
                    status: metadata.status
                )
        elif trimmed.starts_with("**Status:**"):
            val value = extract_field_value(trimmed, "**Status:**")
            if value != "":
                metadata = FeatureMetadata(
                    id: metadata.id,
                    category: metadata.category,
                    difficulty: metadata.difficulty,
                    status: value
                )

    # Extract feature ID from feature_ids if metadata.id is not set
    if metadata.id == "" and doc.feature_ids.len() > 0:
        metadata = FeatureMetadata(
            id: doc.feature_ids[0],
            category: metadata.category,
            difficulty: metadata.difficulty,
            status: metadata.status
        )

    metadata

# ============================================================================
# VALIDATION MODULE
# ============================================================================

fn validate_spec(doc: SspecDoc) -> ValidationResult:
    var warnings = []
    val has_docs = doc.doc_blocks.len() > 0

    var doc_lines = 0
    for block in doc.doc_blocks:
        doc_lines = doc_lines + block.content.split(NL).len()

    # Check if doc blocks exist
    if not has_docs:
        warnings.push("No documentation blocks found (stub generated)")
    else:
        # Check total documentation length
        if doc_lines < 100:
            warnings.push("Only {doc_lines} lines of documentation (recommended: 100+)")

        # Concatenate all docs to check for sections
        var full_content = ""
        for block in doc.doc_blocks:
            full_content = full_content + block.content + NL

        var has_overview = false
        var has_syntax = false

        val lines = full_content.split(NL)
        for line in lines:
            val trimmed = line.trim()
            if trimmed.starts_with("## Overview") or trimmed.starts_with("## Description"):
                has_overview = true
            if trimmed.starts_with("## Syntax") or trimmed.starts_with("## Examples"):
                has_syntax = true

        # Warn about missing important sections
        if not has_overview:
            warnings.push("Missing '## Overview' or '## Description' section")
        if not has_syntax:
            warnings.push("Missing '## Syntax' or '## Examples' section")

    ValidationResult(
        file_path: doc.file_path,
        has_docs: has_docs,
        doc_lines: doc_lines,
        warnings: warnings
    )

# ============================================================================
# GENERATOR MODULE
# ============================================================================

fn get_file_stem(path: str) -> str:
    # Extract filename without extension
    val parts = path.split("/")
    val filename = parts[-1]
    val name_parts = filename.split(".")
    if name_parts.len() > 1:
        name_parts[0]
    else:
        filename

fn get_current_date() -> str:
    use app.io.{shell_output_trimmed}
    shell_output_trimmed("date -u +%Y-%m-%d", "2026-01-25")

fn generate_feature_doc(doc: SspecDoc, output_dir: str) -> Result<str, str>:
    val file_name = get_file_stem(doc.file_path)
    val feature_name = if doc.feature_title != "": doc.feature_title else: file_name

    var md = ""

    # Check if first doc block already has a title header
    var has_title_in_content = false
    if doc.doc_blocks.len() > 0:
        val first_content = doc.doc_blocks[0].content.trim()
        if first_content.starts_with("#"):
            has_title_in_content = true

    # Add header only if content doesn't already have one
    if not has_title_in_content:
        md = md + "# {feature_name}{NL}{NL}"

    # Add metadata with timestamp
    val now = get_current_date()
    md = md + "*Source: `{doc.file_path}`*{NL}"
    md = md + "*Last Updated: {now}*{NL}{NL}"

    # Add feature IDs if present
    if doc.feature_ids.len() > 0:
        md = md + "## Feature IDs{NL}{NL}"
        for id in doc.feature_ids:
            val anchor = id.replace(".", "-")
            md = md + "- <a id=\"feature-{anchor}\"></a>{id}{NL}"
        md = md + NL

    md = md + "---{NL}{NL}"

    # Add all documentation blocks
    var idx = 0
    for doc_block in doc.doc_blocks:
        if idx > 0:
            md = md + NL
        md = md + doc_block.content
        md = md + NL
        idx = idx + 1

    # Write to file
    val output_path = "{output_dir}/{file_name}.md"
    val write_result = native_fs_write_string(output_path, md)
    match write_result:
        case Err(e):
            return Err("Failed to write {output_path}: {e}")
        case Ok(_):
            return Ok(output_path)

# ============================================================================
# INDEX MODULE
# ============================================================================

fn infer_category_from_path(path: str) -> str:
    # Infer category from file path
    if path.contains("/infrastructure/"):
        "Infrastructure"
    elif path.contains("/language/"):
        "Language Features"
    elif path.contains("/types/"):
        "Type System"
    elif path.contains("/data_structures/"):
        "Data Structures"
    elif path.contains("/control_flow/"):
        "Control Flow"
    elif path.contains("/concurrency/"):
        "Concurrency"
    elif path.contains("/codegen/"):
        "Code Generation"
    elif path.contains("/testing_framework/"):
        "Testing Framework"
    elif path.contains("/stdlib/"):
        "Standard Library"
    elif path.contains("/ml/"):
        "ML/AI Infrastructure"
    elif path.contains("/syntax/"):
        "Syntax Features"
    else:
        "Other"

fn calculate_coverage(doc_lines: i64) -> i64:
    if doc_lines >= 500:
        100
    elif doc_lines >= 300:
        90
    elif doc_lines >= 200:
        80
    elif doc_lines >= 100:
        60
    elif doc_lines >= 50:
        40
    elif doc_lines > 0:
        20
    else:
        0

fn generate_index_page(entries: [FeatureEntry], output_dir: str, stats: DocStats) -> Result<str, str>:
    var md = ""

    # Header
    md = md + "# Test Specification Index{NL}{NL}"
    md = md + "*Generated: {get_current_date()}*{NL}{NL}"

    # Quick stats
    md = md + "## Quick Stats{NL}{NL}"
    md = md + "- **Total Features:** {stats.total_specs}{NL}"
    md = md + "- **Complete Documentation:** {stats.specs_with_docs} ({stats.coverage_percent()}%){NL}"
    md = md + "- **Stubs Remaining:** {stats.specs_without_docs}{NL}"
    md = md + "- **Total Lines:** {stats.total_doc_lines}{NL}"
    if stats.total_warnings > 0:
        md = md + "- **Warnings:** {stats.total_warnings}{NL}"
    md = md + "{NL}---{NL}{NL}"

    # Group by category
    var categories = {}
    for entry in entries:
        val cat = entry.category
        if categories.contains_key(cat):
            var cat_list = categories[cat]
            cat_list.push(entry)
            categories[cat] = cat_list
        else:
            categories[cat] = [entry]

    # Generate categorized tables
    val cat_names = categories.keys()
    for cat_name in cat_names:
        val cat_entries = categories[cat_name]
        md = md + "## {cat_name} ({cat_entries.len()} features){NL}{NL}"
        md = md + "| Feature | Status | Difficulty | Coverage | Details |{NL}"
        md = md + "|---------|--------|------------|----------|----------|{NL}"

        for entry in cat_entries:
            md = md + "| [{entry.title}]({entry.filename}) | {entry.status} | {entry.difficulty} | {entry.coverage} | {entry.doc_lines} lines |{NL}"

        md = md + NL

    # Write to file
    val output_path = "{output_dir}/INDEX.md"
    val write_result = native_fs_write_string(output_path, md)
    match write_result:
        case Err(e):
            return Err("Failed to write {output_path}: {e}")
        case Ok(_):
            return Ok(output_path)

# ============================================================================
# MAIN ENTRY POINT
# ============================================================================

fn print_spec_status(doc: SspecDoc, validation: ValidationResult):
    val filename = get_file_stem(doc.file_path)

    if validation.has_docs:
        if validation.warnings.len() == 0:
            print "  OK {filename} ({validation.doc_lines} lines)"
        else:
            print "  WARN  {filename} ({validation.doc_lines} lines, {validation.warnings.len()} warnings)"
            for warning in validation.warnings:
                print "      -> {warning}"
    else:
        print "  FAIL {filename} - No documentation blocks found"

fn print_summary(stats: DocStats):
    print ""
    print "============================================================"
    print "Summary:"
    print "  Complete documentation: {stats.specs_with_docs}/{stats.total_specs} ({stats.coverage_percent()}%)"

    var stub_percent = 0
    if stats.total_specs > 0:
        stub_percent = (stats.specs_without_docs * 100) / stats.total_specs
    print "  Stubs: {stats.specs_without_docs}/{stats.total_specs} ({stub_percent}%)"
    print "  Total documentation: {stats.total_doc_lines} lines"

    if stats.total_warnings > 0:
        print "  Warnings: {stats.total_warnings}"

    print "============================================================"
    print ""
    print "DONE Documentation generated successfully!"

fn print_usage():
    print "SSpec Documentation Generator"
    print ""
    print "Usage: sspec-docgen <spec_file>... [--output <dir>]"
    print ""
    print "Arguments:"
    print "  <spec_file>...    One or more sspec files (*_spec.spl)"
    print ""
    print "Options:"
    print "  --output <dir>    Output directory (default: doc/spec)"
    print "  -o <dir>          Short form of --output"
    print "  --help, -h        Show this help message"
    print ""
    print "Features:"
    print "  - Extracts \"\"\"...\"\"\" documentation blocks"
    print "  - Parses #[id(...)] feature attributes"
    print "  - Extracts metadata (Feature ID, Category, Status, Difficulty)"
    print "  - Generates per-feature .md files"
    print "  - Generates categorized INDEX.md"
    print "  - Validates documentation quality"
    print ""
    print "Example:"
    print "  sspec-docgen tests/system/*_spec.spl"
    print "  sspec-docgen tests/specs/*.spl --output doc/spec/generated"

fn main() -> i64:
    val all_args = get_cli_args()

    # Skip program name and script name
    # When running `simple script.spl arg1`, args are ["simple", "script.spl", "arg1"]
    var args = []
    var i = 2
    while i < all_args.len():
        args.push(all_args[i])
        i = i + 1

    # Parse arguments
    if args.len() == 0 or args.contains("--help") or args.contains("-h"):
        print_usage()
        return if args.len() == 0: 1 else: 0

    # Extract output directory
    var output_dir = "doc/spec"
    var spec_files = []

    var j = 0
    while j < args.len():
        val arg = args[j]
        if arg == "--output" or arg == "-o":
            if j + 1 < args.len():
                output_dir = args[j + 1]
                j = j + 2
                continue
        elif not arg.starts_with("-"):
            spec_files.push(arg)
        j = j + 1

    if spec_files.len() == 0:
        error("sspec_docgen", "No spec files provided")
        print ""
        print_usage()
        return 1

    # Create output directory
    val mkdir_result = native_fs_create_dir(output_dir)
    match mkdir_result:
        case Err(e):
            # Ignore if directory exists
            pass
        case _:
            pass

    print ""
    print "Generating BDD documentation..."
    print "  Input files: {spec_files.len()}"
    print "  Output dir: {output_dir}"
    print ""
    print "Processing specs:"

    var stats = DocStats.empty()
    var entries = []

    # Parse and process all sspec files
    for file_path in spec_files:
        val parse_result = parse_sspec_file(file_path)
        match parse_result:
            case Err(e):
                error("sspec_docgen", "Failed to parse {file_path}: {e}")
            case Ok(parsed):
                # Extract metadata
                val metadata = extract_metadata(parsed)
                val doc_with_meta = SspecDoc(
                    file_path: parsed.file_path,
                    doc_blocks: parsed.doc_blocks,
                    feature_title: parsed.feature_title,
                    feature_ids: parsed.feature_ids,
                    metadata: metadata
                )

                # Validate
                val validation = validate_spec(doc_with_meta)

                # Update stats
                stats = DocStats(
                    total_specs: stats.total_specs + 1,
                    specs_with_docs: stats.specs_with_docs + (if validation.has_docs: 1 else: 0),
                    specs_without_docs: stats.specs_without_docs + (if validation.has_docs: 0 else: 1),
                    total_doc_lines: stats.total_doc_lines + validation.doc_lines,
                    total_warnings: stats.total_warnings + validation.warnings.len()
                )

                # Print progress
                print_spec_status(doc_with_meta, validation)

                # Generate individual doc
                val gen_result = generate_feature_doc(doc_with_meta, output_dir)
                match gen_result:
                    case Err(e):
                        warn("sspec_docgen", "Failed to generate doc for {file_path}: {e}")
                    case Ok(_):
                        pass

                # Create feature entry for INDEX
                val file_name = get_file_stem(file_path)
                var title = file_name
                if doc_with_meta.feature_title != "":
                    title = doc_with_meta.feature_title
                var category = infer_category_from_path(file_path)
                if metadata.category != "":
                    category = metadata.category

                var status_str = "FAIL Stub"
                if validation.has_docs:
                    if validation.doc_lines >= 200:
                        status_str = "OK Complete"
                    else:
                        status_str = "WARN Partial"

                var difficulty_str = "N/A"
                if metadata.difficulty != "":
                    difficulty_str = metadata.difficulty
                val coverage_val = calculate_coverage(validation.doc_lines)

                entries.push(FeatureEntry(
                    title: title,
                    filename: "{file_name}.md",
                    status: status_str,
                    difficulty: difficulty_str,
                    coverage: "{coverage_val}%",
                    doc_lines: validation.doc_lines,
                    category: category
                ))

    # Generate INDEX.md
    val index_result = generate_index_page(entries, output_dir, stats)
    match index_result:
        case Err(e):
            warn("sspec_docgen", "Failed to generate INDEX.md: {e}")
        case Ok(_):
            pass

    # Print summary
    print_summary(stats)

    print "DONE Generated {stats.total_specs} docs ({stats.specs_with_docs} complete, {stats.specs_without_docs} stubs)"

    0
