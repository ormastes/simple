# SSpec Documentation Generator (Written in Simple)
#
# Extracts markdown documentation from sspec test files ("""...""" blocks)
# and generates comprehensive BDD-style documentation in doc/spec/
#
# Usage: sspec-docgen <spec_files...> [--output <dir>]
#
# Features:
# - Metadata Extraction: Parses Feature ID, Category, Status, Difficulty
# - Test Structure: Extracts describe/context/it hierarchy
# - Categorized INDEX: Groups features by category
# - Validation: Warns about missing documentation and incomplete specs
# - Statistics: Tracks documentation coverage and quality metrics

# I/O imports
use app.io.mod (file_read, file_write, file_exists, dir_create, env_get)
use std.cli.cli_util (get_cli_args)
use std.text.{NL}

# Local log helpers â€” std.log.debug/info/warn/error are broken in interpreter mode
# (GLOBAL_LOG_LEVEL undefined due to type annotation issue, causes crash at runtime).
# Per log.spl docs, use inline env_get pattern for CLI-mode files.
# Using prefixed names (sspec_*) to avoid conflict with std.log transitively imported.
fn sspec_dbg(msg: text):
    val level = env_get("SIMPLE_LOG")
    if level == "debug" or level == "trace" or level == "all":
        print "[DEBUG] [sspec_docgen] {msg}"

fn sspec_info(msg: text):
    val level = env_get("SIMPLE_LOG")
    if level == "info" or level == "debug" or level == "trace" or level == "all":
        print "[INFO] [sspec_docgen] {msg}"

fn sspec_warn(msg: text):
    val level = env_get("SIMPLE_LOG")
    if level != "" and level != "off" and level != "error":
        print "[WARN] [sspec_docgen] {msg}"

fn sspec_err(msg: text):
    val level = env_get("SIMPLE_LOG")
    if level != "" and level != "off":
        print "[ERROR] [sspec_docgen] {msg}"

# Compatibility aliases for native_fs_* -> io module
fn native_fs_read_string(path: str) -> text:
    val result = file_read(path)
    result ?? ""

fn native_fs_write_string(path: str, content: str) -> bool:
    file_write(path, content)

fn native_fs_exists(path: str) -> bool:
    file_exists(path)

fn native_fs_create_dir(path: str):
    dir_create(path, true)

# Documentation block extracted from sspec file
struct DocBlock:
    content: str
    line_start: i64
    line_end: i64

# Feature metadata extracted from documentation
struct FeatureMetadata:
    id: str
    category: str
    difficulty: str
    status: str

    static fn empty() -> FeatureMetadata:
        FeatureMetadata(id: "", category: "", difficulty: "", status: "")

# Parsed sspec file with documentation and test structure
struct SspecDoc:
    file_path: str
    raw_content: str
    doc_blocks: [DocBlock]
    feature_title: str
    feature_ids: [str]
    metadata: FeatureMetadata

# Validation result for a spec file
struct ValidationResult:
    file_path: str
    has_docs: bool
    doc_lines: i64
    warnings: [str]

# Statistics for documentation generation
struct DocStats:
    total_specs: i64
    specs_with_docs: i64
    specs_without_docs: i64
    total_doc_lines: i64
    total_warnings: i64

    static fn empty() -> DocStats:
        DocStats(
            total_specs: 0,
            specs_with_docs: 0,
            specs_without_docs: 0,
            total_doc_lines: 0,
            total_warnings: 0
        )

    fn coverage_percent(self) -> f64:
        if self.total_specs == 0:
            0.0
        else:
            (self.specs_with_docs * 100) / self.total_specs

# Feature entry for INDEX generation
struct FeatureEntry:
    title: str
    filename: str
    status: str
    difficulty: str
    coverage: str
    doc_lines: i64
    category: str
    test_count: i64

# ============================================================================
# PARSER MODULE
# ============================================================================

fn parse_id_attr(line: str) -> str:
    # Parse #[id("...")] attribute to extract ID
    val trimmed = line.trim()
    if not trimmed.starts_with("#[id("):
        return ""

    # Extract content between quotes
    val after_prefix = trimmed[5:]  # Remove "#[id("
    val without_suffix = after_prefix.trim_end_matches(")]")
    val inner = without_suffix.trim()

    if inner.starts_with("\"") and inner.ends_with("\"") and inner.len() >= 2:
        inner[1:-1]  # Remove quotes
    else:
        ""

fn parse_sspec_file(path: str) -> Result<SspecDoc, str>:
    sspec_dbg("reading file: {path}")
    val content = native_fs_read_string(path)
    sspec_dbg("file read, splitting lines")
    val lines = content.split(NL)
    val lines_len = lines.len()
    sspec_dbg("got {lines_len} lines")
    var doc_blocks = []
    var feature_title = ""
    var feature_ids = []

    var i = 0
    while i < lines.len():
        val line = lines[i]
        val trimmed = line.trim()

        # Extract feature IDs from #[id(...)] attributes
        if trimmed.starts_with("#[id("):
            val id = parse_id_attr(trimmed)
            if id != "":
                feature_ids.push(id)

        # Check for doc block start (standalone """ on its own line)
        if trimmed == "\"\"\"":
            val start_line = i
            i = i + 1

            var block_content = ""
            var found_end = false

            # Collect lines until closing """
            while i < lines.len():
                val block_line = lines[i]

                if block_line.trim() == "\"\"\"":
                    found_end = true
                    break

                block_content = block_content + block_line + NL
                i = i + 1

            if found_end:
                # Extract feature title from first doc block if present
                if feature_title == "" and block_content.contains("# "):
                    val block_lines = block_content.split(NL)
                    for bl in block_lines:
                        val bl_trimmed = bl.trim()
                        if bl_trimmed.starts_with("# "):
                            feature_title = bl_trimmed[2:].trim()
                            break

                doc_blocks.push(DocBlock(
                    content: block_content.trim(),
                    line_start: start_line,
                    line_end: i
                ))

        i = i + 1

    val doc = SspecDoc(
        file_path: path,
        raw_content: content,
        doc_blocks: doc_blocks,
        feature_title: feature_title,
        feature_ids: feature_ids,
        metadata: FeatureMetadata.empty()
    )
    sspec_dbg("parse_sspec_file done: {doc_blocks.len()} doc blocks, title={feature_title}")
    return Ok(doc)

# ============================================================================
# METADATA MODULE
# ============================================================================

fn extract_field_value(line: str, prefix: str) -> str:
    # Extract value from a metadata field line
    if not line.starts_with(prefix):
        return ""

    val value_part = line[prefix.len():]
    value_part.trim()

fn extract_metadata(doc: SspecDoc) -> FeatureMetadata:
    var metadata = FeatureMetadata.empty()

    # Concatenate all doc blocks for metadata extraction
    var full_content = ""
    for block in doc.doc_blocks:
        full_content = full_content + block.content + NL

    # Extract metadata fields from markdown
    val lines = full_content.split(NL)
    for line in lines:
        val trimmed = line.trim()

        # Match patterns like "**Feature ID:** #20" or "**Feature IDs:** #20"
        if trimmed.starts_with("**Feature ID:**"):
            val value = extract_field_value(trimmed, "**Feature ID:**")
            if value != "":
                metadata = FeatureMetadata(
                    id: value,
                    category: metadata.category,
                    difficulty: metadata.difficulty,
                    status: metadata.status
                )
        elif trimmed.starts_with("**Feature IDs:**"):
            val value = extract_field_value(trimmed, "**Feature IDs:**")
            if value != "":
                metadata = FeatureMetadata(
                    id: value,
                    category: metadata.category,
                    difficulty: metadata.difficulty,
                    status: metadata.status
                )
        elif trimmed.starts_with("**Category:**"):
            val value = extract_field_value(trimmed, "**Category:**")
            if value != "":
                metadata = FeatureMetadata(
                    id: metadata.id,
                    category: value,
                    difficulty: metadata.difficulty,
                    status: metadata.status
                )
        elif trimmed.starts_with("**Difficulty:**"):
            val value = extract_field_value(trimmed, "**Difficulty:**")
            if value != "":
                metadata = FeatureMetadata(
                    id: metadata.id,
                    category: metadata.category,
                    difficulty: value,
                    status: metadata.status
                )
        elif trimmed.starts_with("**Status:**"):
            val value = extract_field_value(trimmed, "**Status:**")
            if value != "":
                metadata = FeatureMetadata(
                    id: metadata.id,
                    category: metadata.category,
                    difficulty: metadata.difficulty,
                    status: value
                )

    # Extract feature ID from feature_ids if metadata.id is not set
    if metadata.id == "" and doc.feature_ids.len() > 0:
        metadata = FeatureMetadata(
            id: doc.feature_ids[0],
            category: metadata.category,
            difficulty: metadata.difficulty,
            status: metadata.status
        )

    metadata

# ============================================================================
# VALIDATION MODULE
# ============================================================================

fn validate_spec(doc: SspecDoc) -> ValidationResult:
    var warnings = []
    val has_docs = doc.doc_blocks.len() > 0

    var doc_lines = 0
    for block in doc.doc_blocks:
        doc_lines = doc_lines + block.content.split(NL).len()

    # Check if doc blocks exist
    if not has_docs:
        warnings.push("No documentation blocks found (stub generated)")
    else:
        # Check total documentation length
        if doc_lines < 100:
            warnings.push("Only {doc_lines} lines of documentation (recommended: 100+)")

        # Concatenate all docs to check for sections
        var full_content = ""
        for block in doc.doc_blocks:
            full_content = full_content + block.content + NL

        var has_overview = false
        var has_syntax = false

        val lines = full_content.split(NL)
        for line in lines:
            val trimmed = line.trim()
            if trimmed.starts_with("## Overview") or trimmed.starts_with("## Description"):
                has_overview = true
            if trimmed.starts_with("## Syntax") or trimmed.starts_with("## Examples"):
                has_syntax = true

        # Warn about missing important sections
        if not has_overview:
            warnings.push("Missing '## Overview' or '## Description' section")
        if not has_syntax:
            warnings.push("Missing '## Syntax' or '## Examples' section")

    ValidationResult(
        file_path: doc.file_path,
        has_docs: has_docs,
        doc_lines: doc_lines,
        warnings: warnings
    )

# ============================================================================
# TEST STRUCTURE EXTRACTION
# ============================================================================

fn extract_quoted_name(line: str) -> str:
    # Extract text between first and last double-quote in a line
    # e.g. describe "Null Coalescing (??)"": -> "Null Coalescing (??)"
    if not line.contains("\""):
        return line
    val parts = line.split("\"")
    if parts.len() >= 2:
        parts[1]
    else:
        line

fn extract_inline_docstring(trimmed: str) -> str:
    # Extract content from """single line content""" (both open and close on same line)
    if trimmed.starts_with("\"\"\"") and trimmed.ends_with("\"\"\"") and trimmed.len() > 6:
        trimmed[3:-3].trim()
    else:
        ""

fn extract_test_structure(content: str) -> str:
    val lines = content.split(NL)
    var result = ""
    var i = 0
    var in_docstring = false

    while i < lines.len():
        val line = lines[i]
        val trimmed = line.trim()

        # Handle multi-line docstring content â€” skip until closing """
        if in_docstring:
            if trimmed == "\"\"\"" or trimmed.ends_with("\"\"\""):
                in_docstring = false
            i = i + 1
            continue

        # Detect standalone """ opening (multi-line block)
        if trimmed == "\"\"\"":
            in_docstring = true
            i = i + 1
            continue

        # Detect inline multi-line start: """text (no closing """ on same line)
        if trimmed.starts_with("\"\"\"") and not (trimmed.ends_with("\"\"\"") and trimmed.len() > 6):
            in_docstring = true
            i = i + 1
            continue

        # describe block â†’ H3
        if trimmed.starts_with("describe ") and trimmed.contains("\""):
            val name = extract_quoted_name(trimmed)
            result = result + "### {name}{NL}"

            # Check next line for single-line docstring
            if i + 1 < lines.len():
                val next_trimmed = lines[i + 1].trim()
                val doc = extract_inline_docstring(next_trimmed)
                if doc != "":
                    result = result + "_{doc}_{NL}"
                    i = i + 1

            result = result + NL

        # skip context block â†’ H4 with skipped marker
        elif trimmed.starts_with("skip context ") and trimmed.contains("\""):
            val name = extract_quoted_name(trimmed)
            result = result + "#### {name} _(skipped)_{NL}"

        # regular context block â†’ H4
        elif trimmed.starts_with("context ") and trimmed.contains("\""):
            val name = extract_quoted_name(trimmed)
            result = result + "#### {name}{NL}"

            # Check next line for single-line docstring
            if i + 1 < lines.len():
                val next_trimmed = lines[i + 1].trim()
                val doc = extract_inline_docstring(next_trimmed)
                if doc != "":
                    result = result + "_{doc}_{NL}"
                    i = i + 1

            result = result + NL

        # skip it â†’ skipped bullet
        elif trimmed.starts_with("skip it ") and trimmed.contains("\""):
            val name = extract_quoted_name(trimmed)
            result = result + "- â­ {name} (skipped){NL}"

        # pending â†’ pending bullet
        elif trimmed.starts_with("pending ") and trimmed.contains("\""):
            val name = extract_quoted_name(trimmed)
            result = result + "- ðŸ“‹ {name} (pending){NL}"

        # regular it â†’ check bullet
        elif trimmed.starts_with("it ") and trimmed.contains("\""):
            val name = extract_quoted_name(trimmed)
            result = result + "- âœ… {name}{NL}"

        i = i + 1

    result.trim()

# ============================================================================
# GENERATOR MODULE
# ============================================================================

fn get_file_stem(path: str) -> str:
    # Extract filename without extension
    val parts = path.split("/")
    val filename = parts[-1]
    val name_parts = filename.split(".")
    if name_parts.len() > 1:
        name_parts[0]
    else:
        filename

fn humanize_filename(stem: str) -> str:
    # Convert file_name_spec -> "File Name Specification"
    var name = stem
    # Strip _spec suffix
    if name.ends_with("_spec"):
        name = name[:-5]
    # Replace underscores with spaces and capitalize each word
    val words = name.split("_")
    var result = ""
    for word in words:
        if word == "":
            continue
        if result != "":
            result = result + " "
        # Capitalize first letter
        if word.len() > 0:
            val first = word[0:1].upper()
            val rest = word[1:]
            result = result + first + rest
    result + " Specification"

fn count_test_items(content: str) -> (i64, i64, i64):
    # Returns (total_it, skipped_it, pending_it)
    val lines = content.split(NL)
    var total = 0
    var skipped = 0
    var pending = 0
    for line in lines:
        val trimmed = line.trim()
        if trimmed.starts_with("it ") and trimmed.contains("\""):
            total = total + 1
        elif trimmed.starts_with("skip it ") and trimmed.contains("\""):
            skipped = skipped + 1
        elif trimmed.starts_with("pending ") and trimmed.contains("\""):
            pending = pending + 1
    (total, skipped, pending)

fn build_auto_overview(content: str) -> str:
    # Auto-generate an overview from describe block names
    val lines = content.split(NL)
    var describes = []
    for line in lines:
        val trimmed = line.trim()
        if trimmed.starts_with("describe ") and trimmed.contains("\""):
            val name = extract_quoted_name(trimmed)
            describes.push(name)
    if describes.len() == 0:
        return ""
    var result = "Tests covering:"
    for d in describes:
        result = result + NL + "- " + d
    result

fn get_current_date() -> str:
    use app.io.{shell_output_trimmed}
    shell_output_trimmed("date -u +%Y-%m-%d", "2026-01-25")

fn build_metadata_line(metadata: FeatureMetadata) -> str:
    # Build compact pipe-separated metadata line
    var result = ""
    if metadata.id != "":
        result = result + "**Feature ID:** {metadata.id}"
    if metadata.category != "":
        if result != "":
            result = result + " | "
        result = result + "**Category:** {metadata.category}"
    if metadata.difficulty != "":
        if result != "":
            result = result + " | "
        result = result + "**Difficulty:** {metadata.difficulty}"
    if metadata.status != "":
        if result != "":
            result = result + " | "
        result = result + "**Status:** {metadata.status}"
    result

fn extract_content_section(block_content: str) -> str:
    # Extract content from first doc block, skipping title and metadata lines.
    # Returns everything from the first "## " heading onward.
    # If no "## " heading, strips title/metadata lines and returns the rest.
    val lines = block_content.split(NL)

    # Find the first ## heading
    var section_start = -1
    var j = 0
    while j < lines.len():
        val trimmed = lines[j].trim()
        if trimmed.starts_with("## "):
            section_start = j
            break
        j = j + 1

    if section_start >= 0:
        # Build from first ## heading to end
        var result = ""
        var k = section_start
        while k < lines.len():
            result = result + lines[k] + NL
            k = k + 1
        return result.trim()

    # No ## heading: strip title/metadata lines
    var result = ""
    var found_content = false
    for line in lines:
        val trimmed = line.trim()
        var is_meta = false
        if trimmed.starts_with("# ") and not trimmed.starts_with("## "):
            is_meta = true
        elif trimmed.starts_with("**Feature"):
            is_meta = true
        elif trimmed.starts_with("**Category"):
            is_meta = true
        elif trimmed.starts_with("**Difficulty"):
            is_meta = true
        elif trimmed.starts_with("**Status"):
            is_meta = true

        if not is_meta:
            if trimmed != "" or found_content:
                found_content = true
                result = result + line + NL

    result.trim()

fn generate_feature_doc(doc: SspecDoc, output_dir: str) -> Result<str, str>:
    val file_name = get_file_stem(doc.file_path)
    val has_docstring = doc.doc_blocks.len() > 0

    # Title: from docstring, or auto-generate from filename
    var feature_name = file_name
    if doc.feature_title != "":
        feature_name = doc.feature_title
    elif not has_docstring:
        feature_name = humanize_filename(file_name)

    var md = ""

    # H1 title
    md = md + "# {feature_name}{NL}{NL}"

    # Metadata line: from docstring or auto-generated
    var meta = doc.metadata
    if meta.category == "":
        meta = FeatureMetadata(
            id: meta.id,
            category: infer_category_from_path(doc.file_path),
            difficulty: meta.difficulty,
            status: meta.status
        )
    if meta.status == "":
        # Auto-detect status from test content
        val counts = count_test_items(doc.raw_content)
        val skip_count = counts[1]
        val pending_count = counts[2]
        var auto_status = "Active"
        if skip_count > 0 or pending_count > 0:
            auto_status = "In Progress"
        meta = FeatureMetadata(
            id: meta.id,
            category: meta.category,
            difficulty: meta.difficulty,
            status: auto_status
        )

    val meta_line = build_metadata_line(meta)
    if meta_line != "":
        md = md + "{meta_line}{NL}{NL}"

    # Source reference
    md = md + "_Source: `{doc.file_path}`_{NL}{NL}"

    md = md + "---{NL}{NL}"

    # Content from docstring OR auto-generated overview
    if has_docstring:
        val first_block = doc.doc_blocks[0]
        val content = extract_content_section(first_block.content)
        if content != "":
            md = md + content + NL
            md = md + "{NL}---{NL}{NL}"
    else:
        # Auto-generate overview from test structure
        val overview = build_auto_overview(doc.raw_content)
        if overview != "":
            md = md + "## Overview{NL}{NL}"
            md = md + overview + NL
            md = md + "{NL}---{NL}{NL}"

    # Test stats summary
    val counts = count_test_items(doc.raw_content)
    val total_tests = counts[0]
    val skip_tests = counts[1]
    val pending_tests = counts[2]
    if total_tests > 0 or skip_tests > 0 or pending_tests > 0:
        md = md + "## Test Summary{NL}{NL}"
        md = md + "| Metric | Count |{NL}"
        md = md + "|--------|-------|{NL}"
        md = md + "| Tests | {total_tests} |{NL}"
        if skip_tests > 0:
            md = md + "| Skipped | {skip_tests} |{NL}"
        if pending_tests > 0:
            md = md + "| Pending | {pending_tests} |{NL}"
        md = md + NL

    # Test structure section
    val structure = extract_test_structure(doc.raw_content)
    if structure != "":
        md = md + "## Test Structure{NL}{NL}"
        md = md + structure + NL

    # Write to file
    val output_path = "{output_dir}/{file_name}.md"
    val ok = native_fs_write_string(output_path, md)
    if not ok:
        return Err("Failed to write {output_path}")
    return Ok(output_path)

# ============================================================================
# INDEX MODULE
# ============================================================================

fn infer_category_from_path(path: str) -> str:
    # Infer category from test/feature/ subdirectory name
    if path.contains("/usage/"):
        "Language Features"
    elif path.contains("/app/"):
        "Application"
    elif path.contains("/compiler/"):
        "Compiler"
    elif path.contains("/interpreter/"):
        "Runtime"
    elif path.contains("/lib/"):
        "Standard Library"
    elif path.contains("/baremetal/"):
        "Baremetal"
    elif path.contains("/dap/"):
        "Developer Tools"
    elif path.contains("/ffi/"):
        "FFI"
    elif path.contains("/io/"):
        "I/O"
    elif path.contains("/platform/"):
        "Platform"
    elif path.contains("/watcher/"):
        "Tooling"
    else:
        "Other"

fn calculate_coverage(doc_lines: i64) -> i64:
    if doc_lines >= 500:
        100
    elif doc_lines >= 300:
        90
    elif doc_lines >= 200:
        80
    elif doc_lines >= 100:
        60
    elif doc_lines >= 50:
        40
    elif doc_lines > 0:
        20
    else:
        0

fn generate_index_page(entries: [FeatureEntry], output_dir: str, stats: DocStats) -> Result<str, str>:
    var md = ""

    # Header
    md = md + "# Test Specification Index{NL}{NL}"
    md = md + "*Generated: {get_current_date()}*{NL}{NL}"

    # Quick stats
    md = md + "## Quick Stats{NL}{NL}"
    md = md + "- **Total Features:** {stats.total_specs}{NL}"
    md = md + "- **Complete Documentation:** {stats.specs_with_docs} ({stats.coverage_percent()}%){NL}"
    md = md + "- **Stubs Remaining:** {stats.specs_without_docs}{NL}"
    md = md + "- **Total Lines:** {stats.total_doc_lines}{NL}"
    if stats.total_warnings > 0:
        md = md + "- **Warnings:** {stats.total_warnings}{NL}"
    md = md + "{NL}---{NL}{NL}"

    # Group by category
    var categories = {}
    for entry in entries:
        val cat = entry.category
        if categories.contains_key(cat):
            var cat_list = categories[cat]
            cat_list.push(entry)
            categories[cat] = cat_list
        else:
            categories[cat] = [entry]

    # Generate categorized tables
    val cat_names = categories.keys()
    for cat_name in cat_names:
        val cat_entries = categories[cat_name]
        md = md + "## {cat_name} ({cat_entries.len()} features){NL}{NL}"
        md = md + "| Feature | Status | Tests | Coverage | Details |{NL}"
        md = md + "|---------|--------|-------|----------|----------|{NL}"

        for entry in cat_entries:
            md = md + "| [{entry.title}]({entry.filename}) | {entry.status} | {entry.test_count} | {entry.coverage} | {entry.doc_lines} lines |{NL}"

        md = md + NL

    # Write to file
    val output_path = "{output_dir}/INDEX.md"
    val ok = native_fs_write_string(output_path, md)
    if not ok:
        return Err("Failed to write {output_path}")
    return Ok(output_path)

# ============================================================================
# MAIN ENTRY POINT
# ============================================================================

fn print_spec_status(doc: SspecDoc, validation: ValidationResult):
    val filename = get_file_stem(doc.file_path)

    if validation.has_docs:
        if validation.warnings.len() == 0:
            print "  OK {filename} ({validation.doc_lines} lines)"
        else:
            print "  WARN  {filename} ({validation.doc_lines} lines, {validation.warnings.len()} warnings)"
            for warning in validation.warnings:
                print "      -> {warning}"
    else:
        print "  AUTO {filename} - Auto-generated from test structure"

fn print_summary(stats: DocStats):
    print ""
    print "============================================================"
    print "Summary:"
    print "  Complete documentation: {stats.specs_with_docs}/{stats.total_specs} ({stats.coverage_percent()}%)"

    var stub_percent = 0
    if stats.total_specs > 0:
        stub_percent = (stats.specs_without_docs * 100) / stats.total_specs
    print "  Stubs: {stats.specs_without_docs}/{stats.total_specs} ({stub_percent}%)"
    print "  Total documentation: {stats.total_doc_lines} lines"

    if stats.total_warnings > 0:
        print "  Warnings: {stats.total_warnings}"

    print "============================================================"
    print ""
    print "DONE Documentation generated successfully!"

fn print_usage():
    print "SSpec Documentation Generator"
    print ""
    print "Usage: sspec-docgen <spec_file>... [--output <dir>]"
    print ""
    print "Arguments:"
    print "  <spec_file>...    One or more sspec files (*_spec.spl)"
    print ""
    print "Options:"
    print "  --output <dir>    Output directory (default: doc/spec)"
    print "  -o <dir>          Short form of --output"
    print "  --help, -h        Show this help message"
    print ""
    print "Features:"
    print "  - Extracts \"\"\"...\"\"\" documentation blocks"
    print "  - Parses #[id(...)] feature attributes"
    print "  - Extracts metadata (Feature ID, Category, Status, Difficulty)"
    print "  - Extracts describe/context/it test structure"
    print "  - Generates per-feature .md files"
    print "  - Generates categorized INDEX.md"
    print "  - Validates documentation quality"
    print ""
    print "Example:"
    print "  sspec-docgen tests/system/*_spec.spl"
    print "  sspec-docgen tests/specs/*.spl --output doc/spec/generated"

fn main() -> i64:
    # get_cli_args() already strips program name and script path
    val args = get_cli_args()

    # Parse arguments
    if args.len() == 0 or args.contains("--help") or args.contains("-h"):
        print_usage()
        return if args.len() == 0: 1 else: 0

    # Extract output directory
    var output_dir = "doc/spec"
    var spec_files = []

    var j = 0
    while j < args.len():
        val arg = args[j]
        if arg == "--output" or arg == "-o":
            if j + 1 < args.len():
                output_dir = args[j + 1]
                j = j + 2
            else:
                j = j + 1
        elif not arg.starts_with("-"):
            spec_files.push(arg)
            j = j + 1
        else:
            j = j + 1

    if spec_files.len() == 0:
        sspec_err("No spec files provided")
        print ""
        print_usage()
        return 1

    # Create output directory (ignore errors if it already exists)
    native_fs_create_dir(output_dir)

    print ""
    print "Generating BDD documentation..."
    print "  Input files: {spec_files.len()}"
    print "  Output dir: {output_dir}"
    print ""
    print "Processing specs:"

    var stats = DocStats.empty()
    var entries = []

    # Parse and process all sspec files
    for file_path in spec_files:
        sspec_dbg("processing: {file_path}")
        val parse_result = parse_sspec_file(file_path)
        sspec_dbg("parse complete for: {file_path}")
        match parse_result:
            case Err(e):
                sspec_err("Failed to parse {file_path}: {e}")
            case Ok(parsed):
                sspec_dbg("matched Ok, extracting metadata")
                # Extract metadata
                val metadata = extract_metadata(parsed)
                sspec_dbg("metadata extracted")
                val doc_with_meta = SspecDoc(
                    file_path: parsed.file_path,
                    raw_content: parsed.raw_content,
                    doc_blocks: parsed.doc_blocks,
                    feature_title: parsed.feature_title,
                    feature_ids: parsed.feature_ids,
                    metadata: metadata
                )

                # Validate
                val validation = validate_spec(doc_with_meta)

                # Update stats
                stats = DocStats(
                    total_specs: stats.total_specs + 1,
                    specs_with_docs: stats.specs_with_docs + (if validation.has_docs: 1 else: 0),
                    specs_without_docs: stats.specs_without_docs + (if validation.has_docs: 0 else: 1),
                    total_doc_lines: stats.total_doc_lines + validation.doc_lines,
                    total_warnings: stats.total_warnings + validation.warnings.len()
                )

                # Print progress
                print_spec_status(doc_with_meta, validation)

                # Generate individual doc
                val gen_result = generate_feature_doc(doc_with_meta, output_dir)
                match gen_result:
                    case Err(e):
                        sspec_warn("Failed to generate doc for {file_path}: {e}")
                    case Ok(_):
                        pass

                # Create feature entry for INDEX
                val file_name = get_file_stem(file_path)
                var title = humanize_filename(file_name)
                if doc_with_meta.feature_title != "":
                    title = doc_with_meta.feature_title
                var category = infer_category_from_path(file_path)
                if metadata.category != "":
                    category = metadata.category

                # Compute test counts for status
                val test_counts = count_test_items(parsed.raw_content)
                val total_it = test_counts[0]
                val skip_it = test_counts[1]
                val pending_it = test_counts[2]

                var status_str = "Auto-generated"
                if validation.has_docs:
                    if validation.doc_lines >= 200:
                        status_str = "Complete"
                    elif validation.doc_lines >= 50:
                        status_str = "Partial"
                    else:
                        status_str = "Minimal"

                var difficulty_str = "N/A"
                if metadata.difficulty != "":
                    difficulty_str = metadata.difficulty
                val coverage_val = calculate_coverage(validation.doc_lines)

                entries.push(FeatureEntry(
                    title: title,
                    filename: "{file_name}.md",
                    status: status_str,
                    difficulty: difficulty_str,
                    coverage: "{coverage_val}%",
                    doc_lines: validation.doc_lines,
                    category: category,
                    test_count: total_it + skip_it + pending_it
                ))

    # Generate INDEX.md
    val index_result = generate_index_page(entries, output_dir, stats)
    match index_result:
        case Err(e):
            sspec_warn("Failed to generate INDEX.md: {e}")
        case Ok(_):
            pass

    # Print summary
    print_summary(stats)

    print "DONE Generated {stats.total_specs} docs ({stats.specs_with_docs} complete, {stats.specs_without_docs} stubs)"

    0
