# SSpec Documentation Generator â€” Generator & Index Modules
#
# Extracted from main.spl. Contains:
# - Generator Module: Feature doc generation, file helpers, metadata formatting
# - Index Module: Category inference, coverage calculation, index page generation

use app.io.mod (file_write)
use app.sspec_docgen.main.{SspecDoc, FeatureMetadata, FeatureEntry, DocStats, ValidationResult, native_fs_write_string, extract_test_structure, extract_quoted_name, sspec_dbg}

# ============================================================================
# GENERATOR MODULE
# ============================================================================

fn get_file_stem(path: str) -> str:
    # Extract filename without extension
    val parts = path.split("/")
    val filename = parts[-1]
    val name_parts = filename.split(".")
    if name_parts.len() > 1:
        name_parts[0]
    else:
        filename

fn humanize_filename(stem: str) -> str:
    # Convert file_name_spec -> "File Name Specification"
    var name = stem
    # Strip _spec suffix
    if name.ends_with("_spec"):
        name = name[:-5]
    # Replace underscores with spaces and capitalize each word
    val words = name.split("_")
    var result = ""
    for word in words:
        if word == "":
            continue
        if result != "":
            result = result + " "
        # Capitalize first letter
        if word.len() > 0:
            val first = word[0:1].upper()
            val rest = word[1:]
            result = result + first + rest
    result + " Specification"

fn count_test_items(content: str) -> (i64, i64, i64):
    # Returns (total_it, skipped_it, pending_it)
    val lines = content.split("\n")
    var total = 0
    var skipped = 0
    var pending = 0
    for line in lines:
        val trimmed = line.trim()
        if trimmed.starts_with("it ") and trimmed.contains("\""):
            total = total + 1
        elif trimmed.starts_with("skip it ") and trimmed.contains("\""):
            skipped = skipped + 1
        elif trimmed.starts_with("pending ") and trimmed.contains("\""):
            pending = pending + 1
    (total, skipped, pending)

fn build_auto_overview(content: str) -> str:
    # Auto-generate an overview from describe block names
    val lines = content.split("\n")
    var describes = []
    for line in lines:
        val trimmed = line.trim()
        if trimmed.starts_with("describe ") and trimmed.contains("\""):
            val name = extract_quoted_name(trimmed)
            describes.push(name)
    if describes.len() == 0:
        return ""
    var result = "Tests covering:"
    for d in describes:
        result = result + "\n" + "- " + d
    result

fn get_current_date() -> str:
    use app.io.{shell_output_trimmed}
    shell_output_trimmed("date -u +%Y-%m-%d", "2026-01-25")

fn build_metadata_line(metadata: FeatureMetadata) -> str:
    # Build compact pipe-separated metadata line
    var result = ""
    if metadata.id != "":
        result = result + "**Feature ID:** {metadata.id}"
    if metadata.category != "":
        if result != "":
            result = result + " | "
        result = result + "**Category:** {metadata.category}"
    if metadata.difficulty != "":
        if result != "":
            result = result + " | "
        result = result + "**Difficulty:** {metadata.difficulty}"
    if metadata.status != "":
        if result != "":
            result = result + " | "
        result = result + "**Status:** {metadata.status}"
    result

fn extract_content_section(block_content: str) -> str:
    # Extract content from first doc block, skipping title and metadata lines.
    # Returns everything from the first "## " heading onward.
    # If no "## " heading, strips title/metadata lines and returns the rest.
    val lines = block_content.split("\n")

    # Find the first ## heading
    var section_start = -1
    var j = 0
    while j < lines.len():
        val trimmed = lines[j].trim()
        if trimmed.starts_with("## "):
            section_start = j
            break
        j = j + 1

    if section_start >= 0:
        # Build from first ## heading to end
        var result = ""
        var k = section_start
        while k < lines.len():
            result = result + lines[k] + "\n"
            k = k + 1
        return result.trim()

    # No ## heading: strip title/metadata lines
    var result = ""
    var found_content = false
    for line in lines:
        val trimmed = line.trim()
        var is_meta = false
        if trimmed.starts_with("# ") and not trimmed.starts_with("## "):
            is_meta = true
        elif trimmed.starts_with("**Feature"):
            is_meta = true
        elif trimmed.starts_with("**Category"):
            is_meta = true
        elif trimmed.starts_with("**Difficulty"):
            is_meta = true
        elif trimmed.starts_with("**Status"):
            is_meta = true

        if not is_meta:
            if trimmed != "" or found_content:
                found_content = true
                result = result + line + "\n"

    result.trim()

fn generate_feature_doc(doc: SspecDoc, output_dir: str) -> Result<str, str>:
    val file_name = get_file_stem(doc.file_path)
    val has_docstring = doc.doc_blocks.len() > 0

    # Title: from docstring, or auto-generate from filename
    var feature_name = file_name
    if doc.feature_title != "":
        feature_name = doc.feature_title
    elif not has_docstring:
        feature_name = humanize_filename(file_name)

    var md = ""

    # H1 title
    md = md + "# {feature_name}\n\n"

    # Metadata line: from docstring or auto-generated
    var meta = doc.metadata
    if meta.category == "":
        meta = FeatureMetadata(
            id: meta.id,
            category: infer_category_from_path(doc.file_path),
            difficulty: meta.difficulty,
            status: meta.status
        )
    if meta.status == "":
        # Auto-detect status from test content
        val counts = count_test_items(doc.raw_content)
        val skip_count = counts[1]
        val pending_count = counts[2]
        var auto_status = "Active"
        if skip_count > 0 or pending_count > 0:
            auto_status = "In Progress"
        meta = FeatureMetadata(
            id: meta.id,
            category: meta.category,
            difficulty: meta.difficulty,
            status: auto_status
        )

    val meta_line = build_metadata_line(meta)
    if meta_line != "":
        md = md + "{meta_line}\n\n"

    # Source reference
    md = md + "_Source: `{doc.file_path}`_\n\n"

    md = md + "---\n\n"

    # Content from docstring OR auto-generated overview
    if has_docstring:
        val first_block = doc.doc_blocks[0]
        val content = extract_content_section(first_block.content)
        if content != "":
            md = md + content + "\n"
            md = md + "\n---\n\n"
    else:
        # Auto-generate overview from test structure
        val overview = build_auto_overview(doc.raw_content)
        if overview != "":
            md = md + "## Overview\n\n"
            md = md + overview + "\n"
            md = md + "\n---\n\n"

    # Test stats summary
    val counts = count_test_items(doc.raw_content)
    val total_tests = counts[0]
    val skip_tests = counts[1]
    val pending_tests = counts[2]
    if total_tests > 0 or skip_tests > 0 or pending_tests > 0:
        md = md + "## Test Summary\n\n"
        md = md + "| Metric | Count |\n"
        md = md + "|--------|-------|\n"
        md = md + "| Tests | {total_tests} |\n"
        if skip_tests > 0:
            md = md + "| Skipped | {skip_tests} |\n"
        if pending_tests > 0:
            md = md + "| Pending | {pending_tests} |\n"
        md = md + "\n"

    # Test structure section
    val structure = extract_test_structure(doc.raw_content)
    if structure != "":
        md = md + "## Test Structure\n\n"
        md = md + structure + "\n"

    # Write to file
    val output_path = "{output_dir}/{file_name}.md"
    val ok = native_fs_write_string(output_path, md)
    if not ok:
        return Err("Failed to write {output_path}")
    return Ok(output_path)

# ============================================================================
# INDEX MODULE
# ============================================================================

fn infer_category_from_path(path: str) -> str:
    # Infer category from test/feature/ subdirectory name
    if path.contains("/usage/"):
        "Language Features"
    elif path.contains("/app/"):
        "Application"
    elif path.contains("/compiler/"):
        "Compiler"
    elif path.contains("/interpreter/"):
        "Runtime"
    elif path.contains("/lib/"):
        "Standard Library"
    elif path.contains("/baremetal/"):
        "Baremetal"
    elif path.contains("/dap/"):
        "Developer Tools"
    elif path.contains("/ffi/"):
        "FFI"
    elif path.contains("/io/"):
        "I/O"
    elif path.contains("/platform/"):
        "Platform"
    elif path.contains("/watcher/"):
        "Tooling"
    else:
        "Other"

fn calculate_coverage(doc_lines: i64) -> i64:
    if doc_lines >= 500:
        100
    elif doc_lines >= 300:
        90
    elif doc_lines >= 200:
        80
    elif doc_lines >= 100:
        60
    elif doc_lines >= 50:
        40
    elif doc_lines > 0:
        20
    else:
        0

fn generate_index_page(entries: [FeatureEntry], output_dir: str, stats: DocStats) -> Result<str, str>:
    var md = ""

    # Header
    md = md + "# Test Specification Index\n\n"
    md = md + "*Generated: {get_current_date()}*\n\n"

    # Quick stats
    md = md + "## Quick Stats\n\n"
    md = md + "- **Total Features:** {stats.total_specs}\n"
    md = md + "- **Complete Documentation:** {stats.specs_with_docs} ({stats.coverage_percent()}%)\n"
    md = md + "- **Stubs Remaining:** {stats.specs_without_docs}\n"
    md = md + "- **Total Lines:** {stats.total_doc_lines}\n"
    if stats.total_warnings > 0:
        md = md + "- **Warnings:** {stats.total_warnings}\n"
    md = md + "\n---\n\n"

    # Group by category
    var categories = {}
    for entry in entries:
        val cat = entry.category
        if categories.contains_key(cat):
            var cat_list = categories[cat]
            cat_list.push(entry)
            categories[cat] = cat_list
        else:
            categories[cat] = [entry]

    # Generate categorized tables
    val cat_names = categories.keys()
    for cat_name in cat_names:
        val cat_entries = categories[cat_name]
        md = md + "## {cat_name} ({cat_entries.len()} features)\n\n"
        md = md + "| Feature | Status | Tests | Coverage | Details |\n"
        md = md + "|---------|--------|-------|----------|----------|\n"

        for entry in cat_entries:
            md = md + "| [{entry.title}]({entry.filename}) | {entry.status} | {entry.test_count} | {entry.coverage} | {entry.doc_lines} lines |\n"

        md = md + "\n"

    # Write to file
    val output_path = "{output_dir}/INDEX.md"
    val ok = native_fs_write_string(output_path, md)
    if not ok:
        return Err("Failed to write {output_path}")
    return Ok(output_path)

export get_file_stem, humanize_filename, count_test_items, build_auto_overview
export get_current_date, build_metadata_line, extract_content_section, generate_feature_doc
export infer_category_from_path, calculate_coverage, generate_index_page
