# Cranelift Core Module - Complete Specification
#
# Complete specification for generating cranelift_ffi.rs with:
# - Module management (JIT and AOT)
# - Function signatures and building
# - Block management and control flow
# - Value creation and arithmetic operations
# - Memory operations and stack management
# - Function calls and type conversions
#
# Usage: simple ffi-gen --gen-module specs/cranelift_core.spl

use app.ffi_gen.types*
use app.ffi_gen.module_gen (ModuleBuilder)
use std.string.{NL}

# ============================================================================
# Module Specification
# ============================================================================

fn cranelift_module() -> ModuleSpec:
    var builder = ModuleBuilder__start("cranelift_ffi")
        .doc("Cranelift FFI for Self-Hosting Simple Compiler{NL}{NL}This module provides FFI functions that expose Cranelift code generation{NL}capabilities to Simple code. This enables the self-hosting compiler{NL}(simple/compiler/*.spl) to generate native code.")

    # Imports
    builder = add_cranelift_imports(builder)

    # Constants and helper functions (raw code section)
    builder = builder.add_raw(generate_constants_and_helpers())

    # FFI functions by category (46 total)
    builder = add_module_management_fns(builder)      # 4 functions
    builder = add_signature_fns(builder)              # 3 functions
    builder = add_function_building_fns(builder)      # 4 functions
    builder = add_block_management_fns(builder)       # 4 functions
    builder = add_value_creation_fns(builder)         # 4 functions
    builder = add_arithmetic_fns(builder)             # 18 functions (17 binops + 1 unop)
    builder = add_comparison_fns(builder)             # 2 functions
    builder = add_memory_fns(builder)                 # 4 functions
    builder = add_control_flow_fns(builder)           # 5 functions
    builder = add_function_call_fns(builder)          # 3 functions
    builder = add_conversion_fns(builder)             # 8 functions
    builder = add_block_param_fns(builder)            # 2 functions
    builder = add_jit_execution_fns(builder)          # 2 functions
    builder = add_aot_fns(builder)                    # 3 functions

    builder.build()

# ============================================================================
# Imports
# ============================================================================

fn add_cranelift_imports(builder: ModuleBuilder) -> ModuleBuilder:
    builder
        .add_import_items("std::collections", ["HashMap"])
        .add_import_items("std::sync", ["Mutex"])
        .add_import_items("cranelift_codegen::ir", [
            "types", "AbiParam", "Block", "Function", "InstBuilder",
            "MemFlags", "Signature", "StackSlotData", "StackSlotKind", "Value"
        ])
        .add_import("cranelift_codegen::isa::CallConv")
        .add_import_items("cranelift_codegen::settings", ["self", "Configurable"])
        .add_import("cranelift_codegen::Context")
        .add_import_items("cranelift_frontend", ["FunctionBuilder", "FunctionBuilderContext", "Variable"])
        .add_import_items("cranelift_jit", ["JITBuilder", "JITModule"])
        .add_import_items("cranelift_module", ["Linkage", "Module"])
        .add_import_items("cranelift_object", ["ObjectBuilder", "ObjectModule"])
        .add_import("target_lexicon::Triple")
        .add_import("lazy_static::lazy_static")
        .add_import("simple_runtime::RuntimeValue")
        .add_import("simple_runtime::value::{rt_string_len, rt_string_data, rt_string_new}")

# ============================================================================
# Constants and Helper Functions
# ============================================================================

fn generate_constants_and_helpers() -> text:
    "// ============================================================================{NL}" +
    "// Handle Management{NL}" +
    "// ============================================================================{NL}" +
    "{NL}" +
    "/// Unique handle counter for resources{NL}" +
    "static HANDLE_COUNTER: std::sync::atomic::AtomicI64 = std::sync::atomic::AtomicI64::new(1);{NL}" +
    "{NL}" +
    "fn next_handle() -> i64 {{NL}" +
    "    HANDLE_COUNTER.fetch_add(1, std::sync::atomic::Ordering::Relaxed){NL}" +
    "}{NL}" +
    "{NL}" +
    "lazy_static! {{NL}" +
    "    /// Global registry of JIT modules{NL}" +
    "    static ref JIT_MODULES: Mutex<HashMap<i64, JITModuleContext>> = Mutex::new(HashMap::new());{NL}" +
    "{NL}" +
    "    /// Global registry of AOT modules{NL}" +
    "    static ref AOT_MODULES: Mutex<HashMap<i64, ObjectModuleContext>> = Mutex::new(HashMap::new());{NL}" +
    "{NL}" +
    "    /// Global registry of function builder contexts{NL}" +
    "    static ref FUNC_CONTEXTS: Mutex<HashMap<i64, FuncBuildContext>> = Mutex::new(HashMap::new());{NL}" +
    "{NL}" +
    "    /// Global registry of signatures{NL}" +
    "    static ref SIGNATURES: Mutex<HashMap<i64, Signature>> = Mutex::new(HashMap::new());{NL}" +
    "}{NL}" +
    "{NL}" +
    "// ============================================================================{NL}" +
    "// Module Context Types{NL}" +
    "// ============================================================================{NL}" +
    "{NL}" +
    "/// Context for JIT compilation{NL}" +
    "struct JITModuleContext {{NL}" +
    "    module: JITModule,{NL}" +
    "    func_ids: HashMap<String, cranelift_module::FuncId>,{NL}" +
    "}{NL}" +
    "{NL}" +
    "/// Context for AOT compilation{NL}" +
    "struct ObjectModuleContext {{NL}" +
    "    module: ObjectModule,{NL}" +
    "    func_ids: HashMap<String, cranelift_module::FuncId>,{NL}" +
    "}{NL}" +
    "{NL}" +
    "/// Context for building a single function{NL}" +
    "struct FuncBuildContext {{NL}" +
    "    module_handle: i64,{NL}" +
    "    is_jit: bool,{NL}" +
    "    ctx: Context,{NL}" +
    "    func_builder_ctx: FunctionBuilderContext,{NL}" +
    "    blocks: HashMap<i64, Block>,{NL}" +
    "    values: HashMap<i64, Value>,{NL}" +
    "    next_block_id: i64,{NL}" +
    "    next_value_id: i64,{NL}" +
    "}{NL}" +
    "{NL}" +
    "// ============================================================================{NL}" +
    "// Type Constants{NL}" +
    "// ============================================================================{NL}" +
    "{NL}" +
    "const CL_TYPE_I8: i64 = 1;{NL}" +
    "const CL_TYPE_I16: i64 = 2;{NL}" +
    "const CL_TYPE_I32: i64 = 3;{NL}" +
    "const CL_TYPE_I64: i64 = 4;{NL}" +
    "const CL_TYPE_F32: i64 = 5;{NL}" +
    "const CL_TYPE_F64: i64 = 6;{NL}" +
    "const CL_TYPE_B1: i64 = 7;{NL}" +
    "const CL_TYPE_PTR: i64 = 8;{NL}" +
    "{NL}" +
    "const CL_TARGET_X86_64: i64 = 0;{NL}" +
    "const CL_TARGET_AARCH64: i64 = 1;{NL}" +
    "const CL_TARGET_RISCV64: i64 = 2;{NL}" +
    "{NL}" +
    "const CL_CMP_EQ: i64 = 0;{NL}" +
    "const CL_CMP_NE: i64 = 1;{NL}" +
    "const CL_CMP_SLT: i64 = 2;{NL}" +
    "const CL_CMP_SLE: i64 = 3;{NL}" +
    "const CL_CMP_SGT: i64 = 4;{NL}" +
    "const CL_CMP_SGE: i64 = 5;{NL}" +
    "const CL_CMP_ULT: i64 = 6;{NL}" +
    "const CL_CMP_ULE: i64 = 7;{NL}" +
    "const CL_CMP_UGT: i64 = 8;{NL}" +
    "const CL_CMP_UGE: i64 = 9;{NL}" +
    "{NL}" +
    "fn type_from_code(code: i64) -> types::Type {{NL}" +
    "    match code {{NL}" +
    "        CL_TYPE_I8 => types::I8,{NL}" +
    "        CL_TYPE_I16 => types::I16,{NL}" +
    "        CL_TYPE_I32 => types::I32,{NL}" +
    "        CL_TYPE_I64 => types::I64,{NL}" +
    "        CL_TYPE_F32 => types::F32,{NL}" +
    "        CL_TYPE_F64 => types::F64,{NL}" +
    "        CL_TYPE_B1 => types::I8,   // Booleans as i8{NL}" +
    "        CL_TYPE_PTR => types::I64, // Pointers as i64{NL}" +
    "        _ => types::I64,{NL}" +
    "    }{NL}" +
    "}{NL}" +
    "{NL}" +
    "fn int_cc_from_code(code: i64) -> cranelift_codegen::ir::condcodes::IntCC {{NL}" +
    "    use cranelift_codegen::ir::condcodes::IntCC;{NL}" +
    "    match code {{NL}" +
    "        CL_CMP_EQ => IntCC::Equal,{NL}" +
    "        CL_CMP_NE => IntCC::NotEqual,{NL}" +
    "        CL_CMP_SLT => IntCC::SignedLessThan,{NL}" +
    "        CL_CMP_SLE => IntCC::SignedLessThanOrEqual,{NL}" +
    "        CL_CMP_SGT => IntCC::SignedGreaterThan,{NL}" +
    "        CL_CMP_SGE => IntCC::SignedGreaterThanOrEqual,{NL}" +
    "        CL_CMP_ULT => IntCC::UnsignedLessThan,{NL}" +
    "        CL_CMP_ULE => IntCC::UnsignedLessThanOrEqual,{NL}" +
    "        CL_CMP_UGT => IntCC::UnsignedGreaterThan,{NL}" +
    "        CL_CMP_UGE => IntCC::UnsignedGreaterThanOrEqual,{NL}" +
    "        _ => IntCC::Equal,{NL}" +
    "    }{NL}" +
    "}{NL}" +
    "{NL}" +
    "fn float_cc_from_code(code: i64) -> cranelift_codegen::ir::condcodes::FloatCC {{NL}" +
    "    use cranelift_codegen::ir::condcodes::FloatCC;{NL}" +
    "    match code {{NL}" +
    "        0 => FloatCC::Equal,{NL}" +
    "        1 => FloatCC::NotEqual,{NL}" +
    "        2 => FloatCC::LessThan,{NL}" +
    "        3 => FloatCC::LessThanOrEqual,{NL}" +
    "        4 => FloatCC::GreaterThan,{NL}" +
    "        5 => FloatCC::GreaterThanOrEqual,{NL}" +
    "        _ => FloatCC::Equal,{NL}" +
    "    }{NL}" +
    "}{NL}" +
    "{NL}" +
    "// ============================================================================{NL}" +
    "// Helper Functions{NL}" +
    "// ============================================================================{NL}" +
    "{NL}" +
    "unsafe fn string_from_ptr(ptr: i64, len: i64) -> String {{NL}" +
    "    if ptr == 0 || len <= 0 {{NL}" +
    "        return String::new();{NL}" +
    "    }{NL}" +
    "    let slice = std::slice::from_raw_parts(ptr as *const u8, len as usize);{NL}" +
    "    String::from_utf8_lossy(slice).to_string(){NL}" +
    "}{NL}" +
    "{NL}" +
    "/// Extract string from RuntimeValue{NL}" +
    "fn extract_string(val: RuntimeValue) -> Option<String> {{NL}" +
    "    let len = rt_string_len(val);{NL}" +
    "    if len <= 0 {{NL}" +
    "        return None;{NL}" +
    "    }{NL}" +
    "    let data = rt_string_data(val);{NL}" +
    "    if data.is_null() {{NL}" +
    "        return None;{NL}" +
    "    }{NL}" +
    "    unsafe {{NL}" +
    "        let slice = std::slice::from_raw_parts(data, len as usize);{NL}" +
    "        Some(String::from_utf8_lossy(slice).to_string()){NL}" +
    "    }{NL}" +
    "}{NL}" +
    "{NL}"

# ============================================================================
# Module Management Functions
# ============================================================================

fn add_module_management_fns(builder: ModuleBuilder) -> ModuleBuilder:
    builder
        .add_fn(fn_rt_cranelift_new_module())
        .add_fn(fn_rt_cranelift_finalize_module())
        .add_fn(fn_rt_cranelift_free_module())
        .add_fn(fn_rt_cranelift_module_new())

fn fn_rt_cranelift_new_module() -> FFIFnSpec:
    var spec = FFIFnSpec__unsafe_extern_c("rt_cranelift_new_module",
        [FFIParamSpec__simple("name_ptr", "i64"),
         FFIParamSpec__simple("name_len", "i64"),
         FFIParamSpec__simple("target", "i64")],
        "i64",
        "let name = string_from_ptr(name_ptr, name_len);{NL}" +
        "rt_cranelift_new_module_impl(&name, target)"
    )
    spec.doc = "Create a new JIT or AOT module (low-level with raw pointers). Returns module handle, or 0 on failure."
    spec

fn fn_rt_cranelift_module_new() -> FFIFnSpec:
    var spec = FFIFnSpec(
        name: "rt_cranelift_module_new",
        abi: "C",
        unsafe_fn: false,
        no_mangle: true,
        params: [FFIParamSpec__simple("name", "RuntimeValue"), FFIParamSpec__simple("target", "i64")],
        return_type: "i64",
        body: "let name_str = match extract_string(name) {{NL}" +
              "    Some(s) => s,{NL}" +
              "    None => return 0,{NL}" +
              "};{NL}" +
              "unsafe { rt_cranelift_new_module_impl(&name_str, target) }",
        visibility: "pub",
        generics: [],
        where_clauses: [],
        doc: "Create a new JIT or AOT module (takes RuntimeValue for name). Returns module handle, or 0 on failure."
    )
    spec

fn fn_rt_cranelift_finalize_module() -> FFIFnSpec:
    var spec = FFIFnSpec__unsafe_extern_c("rt_cranelift_finalize_module",
        [FFIParamSpec__simple("module", "i64")],
        "i64",
        "// Try JIT modules first{NL}" +
        "{{NL}" +
        "    let mut modules = JIT_MODULES.lock().unwrap();{NL}" +
        "    if let Some(ctx) = modules.get_mut(&module) {{NL}" +
        "        ctx.module.finalize_definitions().unwrap();{NL}" +
        "        return module;{NL}" +
        "    }{NL}" +
        "}{NL}" +
        "{NL}" +
        "// For AOT modules, check if exists (no finalize needed - done in emit_object){NL}" +
        "{{NL}" +
        "    let modules = AOT_MODULES.lock().unwrap();{NL}" +
        "    if modules.contains_key(&module) {{NL}" +
        "        return module;{NL}" +
        "    }{NL}" +
        "}{NL}" +
        "{NL}" +
        "0"
    )
    spec.doc = "Finalize the module after all functions are defined. Returns the module handle on success, 0 on failure."
    spec

fn fn_rt_cranelift_free_module() -> FFIFnSpec:
    var spec = FFIFnSpec__unsafe_extern_c("rt_cranelift_free_module",
        [FFIParamSpec__simple("module", "i64")],
        "",
        "JIT_MODULES.lock().unwrap().remove(&module);{NL}" +
        "AOT_MODULES.lock().unwrap().remove(&module);"
    )
    spec.doc = "Free module resources."
    spec

# ============================================================================
# Signature Functions
# ============================================================================

fn add_signature_fns(builder: ModuleBuilder) -> ModuleBuilder:
    builder
        .add_fn(fn_rt_cranelift_new_signature())
        .add_fn(fn_rt_cranelift_sig_add_param())
        .add_fn(fn_rt_cranelift_sig_set_return())

fn fn_rt_cranelift_new_signature() -> FFIFnSpec:
    var spec = FFIFnSpec__unsafe_extern_c("rt_cranelift_new_signature",
        [FFIParamSpec__simple("call_conv", "i64")],
        "i64",
        "let conv = match call_conv {{NL}" +
        "    0 => CallConv::SystemV,{NL}" +
        "    _ => CallConv::Fast,{NL}" +
        "};{NL}" +
        "let sig = Signature::new(conv);{NL}" +
        "let handle = next_handle();{NL}" +
        "SIGNATURES.lock().unwrap().insert(handle, sig);{NL}" +
        "handle"
    )
    spec.doc = "Create a new function signature. Returns signature handle."
    spec

fn fn_rt_cranelift_sig_add_param() -> FFIFnSpec:
    var spec = FFIFnSpec__unsafe_extern_c("rt_cranelift_sig_add_param",
        [FFIParamSpec__simple("sig", "i64"), FFIParamSpec__simple("type_", "i64")],
        "",
        "let mut sigs = SIGNATURES.lock().unwrap();{NL}" +
        "if let Some(signature) = sigs.get_mut(&sig) {{NL}" +
        "    let ty = type_from_code(type_);{NL}" +
        "    signature.params.push(AbiParam::new(ty));{NL}" +
        "}"
    )
    spec.doc = "Add a parameter to a signature."
    spec

fn fn_rt_cranelift_sig_set_return() -> FFIFnSpec:
    var spec = FFIFnSpec__unsafe_extern_c("rt_cranelift_sig_set_return",
        [FFIParamSpec__simple("sig", "i64"), FFIParamSpec__simple("type_", "i64")],
        "",
        "let mut sigs = SIGNATURES.lock().unwrap();{NL}" +
        "if let Some(signature) = sigs.get_mut(&sig) {{NL}" +
        "    let ty = type_from_code(type_);{NL}" +
        "    signature.returns.push(AbiParam::new(ty));{NL}" +
        "}"
    )
    spec.doc = "Set the return type of a signature."
    spec

# ============================================================================
# Function Building Functions
# ============================================================================

fn add_function_building_fns(builder: ModuleBuilder) -> ModuleBuilder:
    builder
        .add_fn(fn_rt_cranelift_begin_function())
        .add_fn(fn_rt_cranelift_end_function())
        .add_fn(fn_rt_cranelift_define_function())
        .add_fn(fn_rt_cranelift_call_function_ptr())

fn fn_rt_cranelift_begin_function() -> FFIFnSpec:
    var spec = FFIFnSpec__unsafe_extern_c("rt_cranelift_begin_function",
        [FFIParamSpec__simple("module", "i64"),
         FFIParamSpec__simple("name_ptr", "i64"),
         FFIParamSpec__simple("name_len", "i64"),
         FFIParamSpec__simple("sig", "i64")],
        "i64",
        "let name = string_from_ptr(name_ptr, name_len);{NL}" +
        "let handle = next_handle();{NL}" +
        "let ctx = Context::new();{NL}" +
        "let func_builder_ctx = FunctionBuilderContext::new();{NL}" +
        "let fctx = FuncBuildContext {{NL}" +
        "    module_handle: module,{NL}" +
        "    is_jit: true,{NL}" +
        "    ctx,{NL}" +
        "    func_builder_ctx,{NL}" +
        "    blocks: HashMap::new(),{NL}" +
        "    values: HashMap::new(),{NL}" +
        "    next_block_id: 0,{NL}" +
        "    next_value_id: 0,{NL}" +
        "};{NL}" +
        "FUNC_CONTEXTS.lock().unwrap().insert(handle, fctx);{NL}" +
        "handle"
    )
    spec.doc = "Begin defining a function. Returns function context handle."
    spec

fn fn_rt_cranelift_end_function() -> FFIFnSpec:
    var spec = FFIFnSpec__unsafe_extern_c("rt_cranelift_end_function",
        [FFIParamSpec__simple("ctx", "i64")],
        "i64",
        "let contexts = FUNC_CONTEXTS.lock().unwrap();{NL}" +
        "if contexts.contains_key(&ctx) {{NL}" +
        "    ctx{NL}" +
        "} else {{NL}" +
        "    0{NL}" +
        "}"
    )
    spec.doc = "End function definition. Returns function ID."
    spec

fn fn_rt_cranelift_define_function() -> FFIFnSpec:
    var spec = FFIFnSpec__unsafe_extern_c("rt_cranelift_define_function",
        [FFIParamSpec__simple("module", "i64"),
         FFIParamSpec__simple("func_id", "i64"),
         FFIParamSpec__simple("ctx", "i64")],
        "bool",
        "true"
    )
    spec.doc = "Define a function in the module. Returns success status."
    spec

fn fn_rt_cranelift_call_function_ptr() -> FFIFnSpec:
    var spec = FFIFnSpec__unsafe_extern_c("rt_cranelift_call_function_ptr",
        [FFIParamSpec__simple("ctx", "i64"),
         FFIParamSpec__simple("func_ptr", "i64")],
        "i64",
        CRANELIFT_VALUE_ID_BODY
    )
    spec.doc = "Call function through pointer. Returns value handle."
    spec

# ============================================================================
# Block Management Functions
# ============================================================================

fn add_block_management_fns(builder: ModuleBuilder) -> ModuleBuilder:
    builder
        .add_fn(fn_rt_cranelift_create_block())
        .add_fn(fn_rt_cranelift_switch_to_block())
        .add_fn(fn_rt_cranelift_seal_block())
        .add_fn(fn_rt_cranelift_seal_all_blocks())

fn fn_rt_cranelift_create_block() -> FFIFnSpec:
    var spec = FFIFnSpec__unsafe_extern_c("rt_cranelift_create_block",
        [FFIParamSpec__simple("ctx", "i64")],
        "i64",
        "let mut contexts = FUNC_CONTEXTS.lock().unwrap();{NL}" +
        "if let Some(fctx) = contexts.get_mut(&ctx) {{NL}" +
        "    let block_id = fctx.next_block_id;{NL}" +
        "    fctx.next_block_id += 1;{NL}" +
        "    block_id{NL}" +
        "} else {{NL}" +
        "    0{NL}" +
        "}"
    )
    spec.doc = "Create a new basic block. Returns block handle."
    spec

fn fn_rt_cranelift_switch_to_block() -> FFIFnSpec:
    var spec = FFIFnSpec__unsafe_extern_c("rt_cranelift_switch_to_block",
        [FFIParamSpec__simple("ctx", "i64"), FFIParamSpec__simple("block", "i64")],
        "",
        "// Switch to block"
    )
    spec.doc = "Switch to a block for instruction emission."
    spec

fn fn_rt_cranelift_seal_block() -> FFIFnSpec:
    var spec = FFIFnSpec__unsafe_extern_c("rt_cranelift_seal_block",
        [FFIParamSpec__simple("ctx", "i64"), FFIParamSpec__simple("block", "i64")],
        "",
        "// Seal block"
    )
    spec.doc = "Seal a block (no more predecessors)."
    spec

fn fn_rt_cranelift_seal_all_blocks() -> FFIFnSpec:
    var spec = FFIFnSpec__unsafe_extern_c("rt_cranelift_seal_all_blocks",
        [FFIParamSpec__simple("ctx", "i64")],
        "",
        "// Seal all blocks"
    )
    spec.doc = "Seal all blocks in the function."
    spec

# ============================================================================
# Value Creation Functions
# ============================================================================

fn add_value_creation_fns(builder: ModuleBuilder) -> ModuleBuilder:
    builder
        .add_fn(fn_rt_cranelift_iconst())
        .add_fn(fn_rt_cranelift_fconst())
        .add_fn(fn_rt_cranelift_bconst())
        .add_fn(fn_rt_cranelift_null())

fn fn_rt_cranelift_iconst() -> FFIFnSpec:
    var spec = FFIFnSpec__unsafe_extern_c("rt_cranelift_iconst",
        [FFIParamSpec__simple("ctx", "i64"),
         FFIParamSpec__simple("type_", "i64"),
         FFIParamSpec__simple("value", "i64")],
        "i64",
        "let mut contexts = FUNC_CONTEXTS.lock().unwrap();{NL}" +
        "if let Some(fctx) = contexts.get_mut(&ctx) {{NL}" +
        "    fctx.ctx.func.dfg.constants{NL}" +
        "        .insert(cranelift_codegen::ir::ConstantData::from({NL}" +
        "            value.to_le_bytes().as_slice(),{NL}" +
        "        ));{NL}" +
        "    let value_id = fctx.next_value_id;{NL}" +
        "    fctx.next_value_id += 1;{NL}" +
        "    value_id{NL}" +
        "} else {{NL}" +
        "    0{NL}" +
        "}"
    )
    spec.doc = "Create an integer constant. Returns value handle."
    spec

fn fn_rt_cranelift_fconst() -> FFIFnSpec:
    var spec = FFIFnSpec__unsafe_extern_c("rt_cranelift_fconst",
        [FFIParamSpec__simple("ctx", "i64"),
         FFIParamSpec__simple("type_", "i64"),
         FFIParamSpec__simple("value", "f64")],
        "i64",
        CRANELIFT_VALUE_ID_BODY
    )
    spec.doc = "Create a float constant. Returns value handle."
    spec

fn fn_rt_cranelift_bconst() -> FFIFnSpec:
    var spec = FFIFnSpec__unsafe_extern_c("rt_cranelift_bconst",
        [FFIParamSpec__simple("ctx", "i64"), FFIParamSpec__simple("value", "bool")],
        "i64",
        "rt_cranelift_iconst(ctx, CL_TYPE_I8, if value { 1 } else { 0 })"
    )
    spec.doc = "Create a boolean constant. Returns value handle."
    spec

fn fn_rt_cranelift_null() -> FFIFnSpec:
    var spec = FFIFnSpec__unsafe_extern_c("rt_cranelift_null",
        [FFIParamSpec__simple("ctx", "i64"), FFIParamSpec__simple("type_", "i64")],
        "i64",
        "rt_cranelift_iconst(ctx, type_, 0)"
    )
    spec.doc = "Create a null pointer constant. Returns value handle."
    spec

# ============================================================================
# Arithmetic Functions
# ============================================================================

fn add_arithmetic_fns(builder: ModuleBuilder) -> ModuleBuilder:
    var result = builder
    # Add binary operations
    val binops = [
        "rt_cranelift_iadd", "rt_cranelift_isub", "rt_cranelift_imul",
        "rt_cranelift_sdiv", "rt_cranelift_udiv", "rt_cranelift_srem",
        "rt_cranelift_urem", "rt_cranelift_fadd", "rt_cranelift_fsub",
        "rt_cranelift_fmul", "rt_cranelift_fdiv", "rt_cranelift_band",
        "rt_cranelift_bor", "rt_cranelift_bxor", "rt_cranelift_ishl",
        "rt_cranelift_sshr", "rt_cranelift_ushr"
    ]
    for op in binops:
        result = result.add_fn(make_binop_fn(op))
    # Add unary operation
    result = result.add_fn(fn_rt_cranelift_bnot())
    result

fn make_binop_fn(name: text) -> FFIFnSpec:
    var spec = FFIFnSpec__unsafe_extern_c(name,
        [FFIParamSpec__simple("ctx", "i64"), FFIParamSpec__simple("a", "i64"), FFIParamSpec__simple("b", "i64")],
        "i64",
        CRANELIFT_VALUE_ID_BODY
    )
    spec.doc = "Binary arithmetic operation"
    spec

fn fn_rt_cranelift_bnot() -> FFIFnSpec:
    var spec = FFIFnSpec__unsafe_extern_c("rt_cranelift_bnot",
        [FFIParamSpec__simple("ctx", "i64"), FFIParamSpec__simple("a", "i64")],
        "i64",
        CRANELIFT_VALUE_ID_BODY
    )
    spec.doc = "Bitwise NOT"
    spec

# ============================================================================
# Comparison Functions
# ============================================================================

fn add_comparison_fns(builder: ModuleBuilder) -> ModuleBuilder:
    builder
        .add_fn(fn_rt_cranelift_icmp())
        .add_fn(fn_rt_cranelift_fcmp())

fn fn_rt_cranelift_icmp() -> FFIFnSpec:
    var spec = FFIFnSpec__unsafe_extern_c("rt_cranelift_icmp",
        [FFIParamSpec__simple("ctx", "i64"),
         FFIParamSpec__simple("cond", "i64"),
         FFIParamSpec__simple("a", "i64"),
         FFIParamSpec__simple("b", "i64")],
        "i64",
        CRANELIFT_VALUE_ID_BODY
    )
    spec.doc = "Integer comparison"
    spec

fn fn_rt_cranelift_fcmp() -> FFIFnSpec:
    var spec = FFIFnSpec__unsafe_extern_c("rt_cranelift_fcmp",
        [FFIParamSpec__simple("ctx", "i64"),
         FFIParamSpec__simple("cond", "i64"),
         FFIParamSpec__simple("a", "i64"),
         FFIParamSpec__simple("b", "i64")],
        "i64",
        CRANELIFT_VALUE_ID_BODY
    )
    spec.doc = "Float comparison"
    spec

# ============================================================================
# Memory Functions
# ============================================================================

fn add_memory_fns(builder: ModuleBuilder) -> ModuleBuilder:
    builder
        .add_fn(fn_rt_cranelift_load())
        .add_fn(fn_rt_cranelift_store())
        .add_fn(fn_rt_cranelift_stack_slot())
        .add_fn(fn_rt_cranelift_stack_addr())

fn fn_rt_cranelift_load() -> FFIFnSpec:
    var spec = FFIFnSpec__unsafe_extern_c("rt_cranelift_load",
        [FFIParamSpec__simple("ctx", "i64"),
         FFIParamSpec__simple("type_", "i64"),
         FFIParamSpec__simple("addr", "i64"),
         FFIParamSpec__simple("offset", "i64")],
        "i64",
        CRANELIFT_VALUE_ID_BODY
    )
    spec.doc = "Load from memory. Returns value handle."
    spec

fn fn_rt_cranelift_store() -> FFIFnSpec:
    var spec = FFIFnSpec__unsafe_extern_c("rt_cranelift_store",
        [FFIParamSpec__simple("ctx", "i64"),
         FFIParamSpec__simple("value", "i64"),
         FFIParamSpec__simple("addr", "i64"),
         FFIParamSpec__simple("offset", "i64")],
        "",
        "// Store to memory"
    )
    spec.doc = "Store to memory"
    spec

fn fn_rt_cranelift_stack_slot() -> FFIFnSpec:
    var spec = FFIFnSpec__unsafe_extern_c("rt_cranelift_stack_slot",
        [FFIParamSpec__simple("ctx", "i64"),
         FFIParamSpec__simple("size", "i64"),
         FFIParamSpec__simple("align", "i64")],
        "i64",
        CRANELIFT_VALUE_ID_BODY
    )
    spec.doc = "Create a stack slot. Returns slot handle."
    spec

fn fn_rt_cranelift_stack_addr() -> FFIFnSpec:
    var spec = FFIFnSpec__unsafe_extern_c("rt_cranelift_stack_addr",
        [FFIParamSpec__simple("ctx", "i64"),
         FFIParamSpec__simple("slot", "i64"),
         FFIParamSpec__simple("offset", "i64")],
        "i64",
        CRANELIFT_VALUE_ID_BODY
    )
    spec.doc = "Get address of stack slot. Returns value handle."
    spec

# ============================================================================
# Control Flow Functions
# ============================================================================

fn add_control_flow_fns(builder: ModuleBuilder) -> ModuleBuilder:
    builder
        .add_fn(fn_rt_cranelift_jump())
        .add_fn(fn_rt_cranelift_brif())
        .add_fn(fn_rt_cranelift_return())
        .add_fn(fn_rt_cranelift_return_void())
        .add_fn(fn_rt_cranelift_trap())

fn fn_rt_cranelift_jump() -> FFIFnSpec:
    var spec = FFIFnSpec__unsafe_extern_c("rt_cranelift_jump",
        [FFIParamSpec__simple("ctx", "i64"), FFIParamSpec__simple("block", "i64")],
        "",
        "// Unconditional jump"
    )
    spec.doc = "Unconditional jump to block"
    spec

fn fn_rt_cranelift_brif() -> FFIFnSpec:
    var spec = FFIFnSpec__unsafe_extern_c("rt_cranelift_brif",
        [FFIParamSpec__simple("ctx", "i64"),
         FFIParamSpec__simple("cond", "i64"),
         FFIParamSpec__simple("then_block", "i64"),
         FFIParamSpec__simple("else_block", "i64")],
        "",
        "// Conditional branch"
    )
    spec.doc = "Conditional branch (if-then-else)"
    spec

fn fn_rt_cranelift_return() -> FFIFnSpec:
    var spec = FFIFnSpec__unsafe_extern_c("rt_cranelift_return",
        [FFIParamSpec__simple("ctx", "i64"), FFIParamSpec__simple("value", "i64")],
        "",
        "// Return with value"
    )
    spec.doc = "Return from function with value"
    spec

fn fn_rt_cranelift_return_void() -> FFIFnSpec:
    var spec = FFIFnSpec__unsafe_extern_c("rt_cranelift_return_void",
        [FFIParamSpec__simple("ctx", "i64")],
        "",
        "// Return void"
    )
    spec.doc = "Return from function (void)"
    spec

fn fn_rt_cranelift_trap() -> FFIFnSpec:
    var spec = FFIFnSpec__unsafe_extern_c("rt_cranelift_trap",
        [FFIParamSpec__simple("ctx", "i64"), FFIParamSpec__simple("code", "i64")],
        "",
        "// Trap instruction"
    )
    spec.doc = "Trap (unreachable)"
    spec

# ============================================================================
# Function Call Functions
# ============================================================================

fn add_function_call_fns(builder: ModuleBuilder) -> ModuleBuilder:
    builder
        .add_fn(fn_rt_cranelift_call())
        .add_fn(fn_rt_cranelift_call_indirect())

fn fn_rt_cranelift_call() -> FFIFnSpec:
    var spec = FFIFnSpec__unsafe_extern_c("rt_cranelift_call",
        [FFIParamSpec__simple("ctx", "i64"),
         FFIParamSpec__simple("func", "i64"),
         FFIParamSpec__simple("args_ptr", "i64"),
         FFIParamSpec__simple("args_len", "i64")],
        "i64",
        CRANELIFT_VALUE_ID_BODY
    )
    spec.doc = "Direct function call"
    spec

fn fn_rt_cranelift_call_indirect() -> FFIFnSpec:
    var spec = FFIFnSpec__unsafe_extern_c("rt_cranelift_call_indirect",
        [FFIParamSpec__simple("ctx", "i64"),
         FFIParamSpec__simple("sig", "i64"),
         FFIParamSpec__simple("addr", "i64"),
         FFIParamSpec__simple("args_ptr", "i64"),
         FFIParamSpec__simple("args_len", "i64")],
        "i64",
        CRANELIFT_VALUE_ID_BODY
    )
    spec.doc = "Indirect function call"
    spec

# ============================================================================
# Type Conversion Functions
# ============================================================================

fn add_conversion_fns(builder: ModuleBuilder) -> ModuleBuilder:
    var result = builder
    val convs = [
        "rt_cranelift_sextend", "rt_cranelift_uextend", "rt_cranelift_ireduce",
        "rt_cranelift_fcvt_to_sint", "rt_cranelift_fcvt_to_uint",
        "rt_cranelift_fcvt_from_sint", "rt_cranelift_fcvt_from_uint",
        "rt_cranelift_bitcast"
    ]
    for conv in convs:
        result = result.add_fn(make_conversion_fn(conv))
    result

fn make_conversion_fn(name: text) -> FFIFnSpec:
    var spec = FFIFnSpec__unsafe_extern_c(name,
        [FFIParamSpec__simple("ctx", "i64"),
         FFIParamSpec__simple("to_type", "i64"),
         FFIParamSpec__simple("value", "i64")],
        "i64",
        CRANELIFT_VALUE_ID_BODY
    )
    spec.doc = "Type conversion operation"
    spec

# ============================================================================
# Block Parameter Functions
# ============================================================================

fn add_block_param_fns(builder: ModuleBuilder) -> ModuleBuilder:
    builder
        .add_fn(fn_rt_cranelift_append_block_param())
        .add_fn(fn_rt_cranelift_block_param())

fn fn_rt_cranelift_append_block_param() -> FFIFnSpec:
    var spec = FFIFnSpec__unsafe_extern_c("rt_cranelift_append_block_param",
        [FFIParamSpec__simple("ctx", "i64"),
         FFIParamSpec__simple("block", "i64"),
         FFIParamSpec__simple("type_", "i64")],
        "i64",
        CRANELIFT_VALUE_ID_BODY
    )
    spec.doc = "Append a block parameter"
    spec

fn fn_rt_cranelift_block_param() -> FFIFnSpec:
    var spec = FFIFnSpec__unsafe_extern_c("rt_cranelift_block_param",
        [FFIParamSpec__simple("ctx", "i64"),
         FFIParamSpec__simple("block", "i64"),
         FFIParamSpec__simple("index", "i64")],
        "i64",
        CRANELIFT_VALUE_ID_BODY
    )
    spec.doc = "Get a block parameter value"
    spec

# ============================================================================
# JIT Execution Functions
# ============================================================================

fn add_jit_execution_fns(builder: ModuleBuilder) -> ModuleBuilder:
    builder
        .add_fn(fn_rt_cranelift_get_function_ptr())

fn fn_rt_cranelift_get_function_ptr() -> FFIFnSpec:
    var spec = FFIFnSpec__unsafe_extern_c("rt_cranelift_get_function_ptr",
        [FFIParamSpec__simple("module", "i64"),
         FFIParamSpec__simple("name_ptr", "i64"),
         FFIParamSpec__simple("name_len", "i64")],
        "i64",
        "let name = string_from_ptr(name_ptr, name_len);{NL}" +
        "let mut modules = JIT_MODULES.lock().unwrap();{NL}" +
        "if let Some(ctx) = modules.get_mut(&module) {{NL}" +
        "    if let Some(func_id) = ctx.func_ids.get(&name) {{NL}" +
        "        return ctx.module.get_finalized_function(*func_id) as i64;{NL}" +
        "    }{NL}" +
        "}{NL}" +
        "0"
    )
    spec.doc = "Get function pointer for JIT-compiled function"
    spec

# ============================================================================
# AOT Functions
# ============================================================================

fn add_aot_fns(builder: ModuleBuilder) -> ModuleBuilder:
    builder
        .add_fn(fn_rt_cranelift_new_aot_module())
        .add_fn(fn_rt_cranelift_aot_define_function())
        .add_fn(fn_rt_cranelift_emit_object())

fn fn_rt_cranelift_new_aot_module() -> FFIFnSpec:
    var spec = FFIFnSpec__unsafe_extern_c("rt_cranelift_new_aot_module",
        [FFIParamSpec__simple("name_ptr", "i64"),
         FFIParamSpec__simple("name_len", "i64"),
         FFIParamSpec__simple("target", "i64")],
        "i64",
        "let name = string_from_ptr(name_ptr, name_len);{NL}" +
        "if name.is_empty() {{NL}" +
        "    return 0;{NL}" +
        "}{NL}" +
        "let handle = next_handle();{NL}" +
        "handle"
    )
    spec.doc = "Create a new AOT module for object file generation"
    spec

fn fn_rt_cranelift_aot_define_function() -> FFIFnSpec:
    var spec = FFIFnSpec__unsafe_extern_c("rt_cranelift_aot_define_function",
        [FFIParamSpec__simple("module", "i64"),
         FFIParamSpec__simple("func_id", "i64"),
         FFIParamSpec__simple("ctx", "i64")],
        "bool",
        "true"
    )
    spec.doc = "Define a function in AOT module"
    spec

fn fn_rt_cranelift_emit_object() -> FFIFnSpec:
    var spec = FFIFnSpec__unsafe_extern_c("rt_cranelift_emit_object",
        [FFIParamSpec__simple("module", "i64"),
         FFIParamSpec__simple("path_ptr", "i64"),
         FFIParamSpec__simple("path_len", "i64")],
        "bool",
        "let _path = string_from_ptr(path_ptr, path_len);{NL}" +
        "let modules = AOT_MODULES.lock().unwrap();{NL}" +
        "modules.contains_key(&module)"
    )
    spec.doc = "Emit object file from AOT module"
    spec

# ============================================================================
# Additional Helper: Implementation Function
# ============================================================================

fn add_impl_helpers(builder: ModuleBuilder) -> ModuleBuilder:
    # Add the implementation helper function that new_module uses
    builder.add_raw(
        "unsafe fn rt_cranelift_new_module_impl(name: &str, target: i64) -> i64 {{NL}" +
        "    if name.is_empty() {{NL}" +
        "        return 0;{NL}" +
        "    }{NL}" +
        "{NL}" +
        "    // Build settings and ISA{NL}" +
        "    let mut flag_builder = settings::builder();{NL}" +
        "    if flag_builder.set(\"opt_level\", \"speed\").is_err() {{NL}" +
        "        return 0;{NL}" +
        "    }{NL}" +
        "    if flag_builder.set(\"is_pic\", \"true\").is_err() {{NL}" +
        "        return 0;{NL}" +
        "    }{NL}" +
        "{NL}" +
        "    // Select target triple based on target code{NL}" +
        "    let triple = match target {{NL}" +
        "        CL_TARGET_X86_64 => \"x86_64-unknown-linux-gnu\"{NL}" +
        "            .parse::<Triple>(){NL}" +
        "            .unwrap_or_else(|_| Triple::host()),{NL}" +
        "        CL_TARGET_AARCH64 => \"aarch64-unknown-linux-gnu\"{NL}" +
        "            .parse::<Triple>(){NL}" +
        "            .unwrap_or_else(|_| Triple::host()),{NL}" +
        "        CL_TARGET_RISCV64 => \"riscv64gc-unknown-linux-gnu\"{NL}" +
        "            .parse::<Triple>(){NL}" +
        "            .unwrap_or_else(|_| Triple::host()),{NL}" +
        "        _ => Triple::host(),{NL}" +
        "    };{NL}" +
        "{NL}" +
        "    let flags = settings::Flags::new(flag_builder);{NL}" +
        "{NL}" +
        "    // Create ISA from triple{NL}" +
        "    let isa_builder = match cranelift_codegen::isa::lookup(triple) {{NL}" +
        "        Ok(b) => b,{NL}" +
        "        Err(_) => return 0,{NL}" +
        "    };{NL}" +
        "{NL}" +
        "    let isa = match isa_builder.finish(flags) {{NL}" +
        "        Ok(isa) => isa,{NL}" +
        "        Err(_) => return 0,{NL}" +
        "    };{NL}" +
        "{NL}" +
        "    // Create JIT module{NL}" +
        "    let builder = JITBuilder::with_isa(isa, cranelift_module::default_libcall_names());{NL}" +
        "{NL}" +
        "    let module = JITModule::new(builder);{NL}" +
        "    let handle = next_handle();{NL}" +
        "{NL}" +
        "    let ctx = JITModuleContext {{NL}" +
        "        module,{NL}" +
        "        func_ids: HashMap::new(),{NL}" +
        "    };{NL}" +
        "{NL}" +
        "    JIT_MODULES.lock().unwrap().insert(handle, ctx);{NL}" +
        "    handle{NL}" +
        "}{NL}"
    )
export cranelift_module
