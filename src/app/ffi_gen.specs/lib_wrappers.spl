# @Lib Wrapper Declarations
#
# Demonstrates the @Lib annotation pattern for wrapping external Rust crates.
# These declarations are used by `simple ffi-gen --lang=rust` to auto-generate
# Rust FFI wrapper crates with extern "C" functions.
#
# Usage: simple ffi-gen --lang=rust src/app/ffi_gen/specs/lib_wrappers.spl
#
# See doc/research/ffi_wrapper_generator_design.md for full design.

# ============================================================================
# lasso - Fast string interning
# ============================================================================

@Lib(lang: "rust", name: "lasso", version: "0.7")
extern class StringInterner:
    """Fast string interning using lasso crate.
    Maps strings to compact integer keys for O(1) comparison."""

    static fn new() -> StringInterner
    fn get_or_intern(s: text) -> i64
    fn resolve(key: i64) -> text?
    fn contains(s: text) -> bool
    fn len() -> i64

@Lib(lang: "rust", name: "lasso", version: "0.7")
extern class ThreadedInterner:
    """Thread-safe string interner for concurrent use."""

    static fn new() -> ThreadedInterner
    fn get_or_intern(s: text) -> i64
    fn resolve(key: i64) -> text?

# ============================================================================
# regex - Regular expressions
# ============================================================================

@Lib(lang: "rust", name: "regex", version: "1.10")
extern class Regex:
    """Compiled regular expression pattern."""

    static fn new(pattern: text) -> Result<Regex, text>
    fn is_match(input: text) -> bool
    fn find(input: text) -> Match?
    fn find_all(input: text) -> [Match]
    fn captures(input: text) -> Captures?
    fn replace(input: text, replacement: text) -> text
    fn replace_all(input: text, replacement: text) -> text
    fn split(input: text) -> [text]

@Lib(lang: "rust", name: "regex", version: "1.10")
extern struct Match:
    start: i64
    end: i64
    text: text

@Lib(lang: "rust", name: "regex", version: "1.10")
extern struct Captures:
    fn get(idx: i64) -> Match?
    fn name(name: text) -> Match?
    fn len() -> i64

# ============================================================================
# memmap2 - Memory-mapped file I/O
# ============================================================================

@Lib(lang: "rust", name: "memmap2", version: "0.9")
extern class MmapFile:
    """Memory-mapped file for zero-copy reads of large files."""

    static fn open(path: text) -> Result<MmapFile, text>
    fn len() -> i64
    fn as_bytes() -> [u8]
    fn slice(start: i64, end: i64) -> [u8]

@Lib(lang: "rust", name: "memmap2", version: "0.9")
extern class MmapMutFile:
    """Mutable memory-mapped file."""

    static fn create(path: text, size: i64) -> Result<MmapMutFile, text>
    me write(offset: i64, data: [u8])
    me flush()

# ============================================================================
# rayon - Parallel iteration
# ============================================================================

@Lib(lang: "rust", name: "rayon", version: "1.10")
extern class ParallelPool:
    """Rayon thread pool for parallel iteration."""

    static fn new(num_threads: i64) -> ParallelPool
    static fn global() -> ParallelPool
    fn num_threads() -> i64

@Lib(lang: "rust", name: "rayon", version: "1.10")
extern fn par_map(items: [Value], f: fn(Value) -> Value) -> [Value]

@Lib(lang: "rust", name: "rayon", version: "1.10")
extern fn par_filter(items: [Value], f: fn(Value) -> bool) -> [Value]

@Lib(lang: "rust", name: "rayon", version: "1.10")
extern fn par_reduce(items: [Value], init: Value, f: fn(Value, Value) -> Value) -> Value

@Lib(lang: "rust", name: "rayon", version: "1.10")
extern fn par_sort(items: [Value], cmp: fn(Value, Value) -> i64) -> [Value]

# ============================================================================
# typed-arena - Arena allocation
# ============================================================================

@Lib(lang: "rust", name: "typed-arena", version: "2.0")
extern class Arena:
    """Arena allocator for batch allocation with single deallocation.
    All items are freed when the arena is dropped."""

    static fn new() -> Arena
    fn alloc(value: Value) -> i64
    fn get(id: i64) -> Value?
    fn len() -> i64

# ============================================================================
# serde_json - JSON serialization
# ============================================================================

@Lib(lang: "rust", name: "serde_json", version: "1.0")
extern fn json_parse(input: text) -> Result<Value, text>

@Lib(lang: "rust", name: "serde_json", version: "1.0")
extern fn json_stringify(value: Value) -> text

@Lib(lang: "rust", name: "serde_json", version: "1.0")
extern fn json_stringify_pretty(value: Value) -> text
