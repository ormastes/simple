# Dashboard Web Server
#
# HTTP server for dashboard web interface with REST API endpoints.

use core.net.tcp.{TcpListener, TcpStream}
use core.time.{now_iso8601}
use tooling.dashboard.collector.{collect_dashboard_data}
use tooling.dashboard.cache.{get_cached_data}
use tooling.dashboard.trends.{analyze_weekly_trends, analyze_monthly_trends}
use tooling.dashboard.alerts.{check_alerts_with_trends}
use std.json.builder.{escape_json}
use std.text.{NL}

# =========================================================================
# HTTP Server
# =========================================================================

class DashboardServer:
    port: i32
    auto_refresh_seconds: i32

    static fn new(port: i32) -> DashboardServer:
        return DashboardServer {
            port: port,
            auto_refresh_seconds: 30
        }

    # Start the server
    fn start():
        print "Starting Dashboard Web Server on port {self.port}..."
        print "Open http://localhost:{self.port} in your browser"
        print "Press Ctrl+C to stop{NL}"

        match TcpListener.bind("0.0.0.0", self.port):
            Err(e) =>
                print "Error: Failed to bind to port {self.port}: {e}"
                return
            Ok(listener) =>
                self.serve_loop(listener)

    # Main server loop
    fn serve_loop(listener: TcpListener):
        loop:
            match listener.accept():
                Ok(stream) =>
                    self.handle_connection(stream)
                Err(e) =>
                    print "Error accepting connection: {e}"

    # Handle a single connection
    fn handle_connection(stream: TcpStream):
        match stream.read_line():
            Err(e) =>
                print "Error reading request: {e}"
            Ok(request_line) =>
                val response = self.route_request(request_line)
                match stream.write_all(response):
                    Err(e) => print "Error writing response: {e}"
                    Ok(_) => pass

        stream.close()

    # Route HTTP request
    fn route_request(request_line: text) -> text:
        val parts = request_line.split(" ")
        if parts.len() < 2:
            return http_error(400, "Bad Request")

        val method = parts[0]
        val path = parts[1]

        # API routes
        if path.starts_with("/api/"):
            return self.handle_api(method, path)

        # Static files
        if path.starts_with("/static/"):
            return self.serve_static(path)

        # Default: serve index page
        return self.serve_index()

    # Handle API requests
    fn handle_api(method: text, path: text) -> text:
        if method != "GET":
            return http_error(405, "Method Not Allowed")

        match path:
            "/api/status" => self.api_status()
            "/api/features" => self.api_features()
            "/api/todos" => self.api_todos()
            "/api/coverage" => self.api_coverage()
            "/api/tests" => self.api_tests()
            "/api/trends" => self.api_trends()
            "/api/alerts" => self.api_alerts()
            "/api/vcs" => self.api_vcs()
            "/api/plans" => self.api_plans()
            _ => http_error(404, "Not Found")

    # Serve index page
    fn serve_index() -> text:
        val html = generate_dashboard_html()
        return http_response(200, "text/html", html)

    # Serve static files
    fn serve_static(path: text) -> text:
        # For now, return 404 (static files would be added later)
        return http_error(404, "Not Found")

    # =========================================================================
    # API Endpoints
    # =========================================================================

    # GET /api/status - Dashboard summary
    fn api_status() -> text:
        match get_cached_data():
            Ok(data) =>
                val json = "{{NL}"
                json = "{json}  \"features_total\": {data.total_features()},{NL}"
                json = "{json}  \"features_complete\": {data.completed_features()},{NL}"
                json = "{json}  \"todos_total\": {data.total_todos()},{NL}"
                json = "{json}  \"todos_critical\": {data.critical_todos()},{NL}"
                json = "{json}  \"coverage_percent\": {data.overall_coverage()},{NL}"
                json = "{json}  \"sspec_tests\": {data.sspec_tests.len()},{NL}"
                json = "{json}  \"plans_total\": {data.plans.len()},{NL}"
                json = "{json}  \"timestamp\": \"{data.timestamp}\"{NL}"
                json = "{json}}"
                return http_response(200, "application/json", json)
            Err(e) =>
                return http_error(500, "Failed to load data: {e}")

    # GET /api/features - All features
    fn api_features() -> text:
        match get_cached_data():
            Ok(data) =>
                var json = "[{NL}"
                for i in 0..data.features.len():
                    val f = data.features[i]
                    json = "{json}  {{NL}"
                    json = "{json}    \"id\": {f.id},{NL}"
                    json = "{json}    \"category\": \"{f.category}\",{NL}"
                    json = "{json}    \"name\": \"{f.name}\",{NL}"
                    json = "{json}    \"status\": \"{f.status}\"{NL}"
                    json = "{json}  }"
                    if i < data.features.len() - 1:
                        json = "{json},"
                    json = "{json}{NL}"
                json = "{json}]"
                return http_response(200, "application/json", json)
            Err(e) =>
                return http_error(500, e)

    # GET /api/todos - All TODOs
    fn api_todos() -> text:
        match get_cached_data():
            Ok(data) =>
                var json = "[{NL}"
                for i in 0..data.todos.len():
                    val t = data.todos[i]
                    json = "{json}  {{NL}"
                    json = "{json}    \"id\": {t.id},{NL}"
                    json = "{json}    \"priority\": \"{t.priority}\",{NL}"
                    json = "{json}    \"area\": \"{t.area}\",{NL}"
                    json = "{json}    \"description\": \"{escape_json(t.description)}\",{NL}"
                    json = "{json}    \"file\": \"{t.file}\"{NL}"
                    json = "{json}  }"
                    if i < data.todos.len() - 1:
                        json = "{json},"
                    json = "{json}{NL}"
                json = "{json}]"
                return http_response(200, "application/json", json)
            Err(e) =>
                return http_error(500, e)

    # GET /api/coverage - Coverage metrics
    fn api_coverage() -> text:
        match get_cached_data():
            Ok(data) =>
                var json = "{{NL}"
                json = "{json}  \"overall\": {data.overall_coverage()},{NL}"
                json = "{json}  \"metrics\": [{NL}"
                for i in 0..data.coverage.len():
                    val c = data.coverage[i]
                    json = "{json}    {{NL}"
                    json = "{json}      \"level\": \"{c.level}\",{NL}"
                    json = "{json}      \"crate\": \"{c.crate}\",{NL}"
                    json = "{json}      \"percent\": {c.lines_percent}{NL}"
                    json = "{json}    }"
                    if i < data.coverage.len() - 1:
                        json = "{json},"
                    json = "{json}{NL}"
                json = "{json}  ]{NL}"
                json = "{json}}"
                return http_response(200, "application/json", json)
            Err(e) =>
                return http_error(500, e)

    # GET /api/tests - SSpec test summary
    fn api_tests() -> text:
        match get_cached_data():
            Ok(data) =>
                var passing = 0
                for test in data.sspec_tests:
                    if test.success_rate() == 100.0:
                        passing = passing + 1

                var json = "{{NL}"
                json = "{json}  \"total\": {data.sspec_tests.len()},{NL}"
                json = "{json}  \"passing\": {passing}{NL}"
                json = "{json}}"
                return http_response(200, "application/json", json)
            Err(e) =>
                return http_error(500, e)

    # GET /api/trends - Trend analysis
    fn api_trends() -> text:
        match analyze_weekly_trends():
            Ok(report) =>
                var json = "{{NL}"
                json = "{json}  \"days\": {report.days},{NL}"
                json = "{json}  \"coverage\": {{NL}"
                json = "{json}    \"current\": {report.coverage.current},{NL}"
                json = "{json}    \"change\": {report.coverage.change_percent},{NL}"
                json = "{json}    \"status\": \"{report.coverage.status}\"{NL}"
                json = "{json}  },{NL}"
                json = "{json}  \"features\": {{NL}"
                json = "{json}    \"current\": {report.features.current},{NL}"
                json = "{json}    \"change\": {report.features.change_percent},{NL}"
                json = "{json}    \"status\": \"{report.features.status}\"{NL}"
                json = "{json}  }{NL}"
                json = "{json}}"
                return http_response(200, "application/json", json)
            Err(e) =>
                return http_error(500, e)

    # GET /api/alerts - Current alerts
    fn api_alerts() -> text:
        match get_cached_data():
            Ok(data) =>
                match analyze_weekly_trends():
                    Ok(trends) =>
                        val alerts = check_alerts_with_trends(data, trends)
                        var json = "[{NL}"
                        for i in 0..alerts.len():
                            val a = alerts[i]
                            json = "{json}  {{NL}"
                            json = "{json}    \"level\": \"{a.level}\",{NL}"
                            json = "{json}    \"metric\": \"{a.metric}\",{NL}"
                            json = "{json}    \"message\": \"{escape_json(a.message)}\"{NL}"
                            json = "{json}  }"
                            if i < alerts.len() - 1:
                                json = "{json},"
                            json = "{json}{NL}"
                        json = "{json}]"
                        return http_response(200, "application/json", json)
                    Err(_) =>
                        return http_response(200, "application/json", "[]")
            Err(e) =>
                return http_error(500, e)

    # GET /api/vcs - VCS state
    fn api_vcs() -> text:
        match get_cached_data():
            Ok(data) =>
                var json = "{{NL}"
                json = "{json}  \"bookmark\": \"{data.vcs_state.bookmark}\",{NL}"
                json = "{json}  \"commit_id\": \"{data.vcs_state.commit_id}\",{NL}"
                json = "{json}  \"uncommitted\": {data.vcs_state.uncommitted_files},{NL}"
                json = "{json}  \"is_clean\": {data.vcs_state.is_clean()}{NL}"
                json = "{json}}"
                return http_response(200, "application/json", json)
            Err(e) =>
                return http_error(500, e)

    # GET /api/plans - All plans
    fn api_plans() -> text:
        match get_cached_data():
            Ok(data) =>
                var json = "[{NL}"
                for i in 0..data.plans.len():
                    val p = data.plans[i]
                    json = "{json}  {{NL}"
                    json = "{json}    \"id\": {p.id},{NL}"
                    json = "{json}    \"title\": \"{escape_json(p.title)}\",{NL}"
                    json = "{json}    \"status\": \"{p.status}\",{NL}"
                    json = "{json}    \"progress\": {p.progress_percent()}{NL}"
                    json = "{json}  }"
                    if i < data.plans.len() - 1:
                        json = "{json},"
                    json = "{json}{NL}"
                json = "{json}]"
                return http_response(200, "application/json", json)
            Err(e) =>
                return http_error(500, e)

# =========================================================================
# HTTP Helpers
# =========================================================================

# Create HTTP response
fn http_response(status: i32, content_type: text, body: text) -> text:
    val status_text = match status:
        200 => "OK"
        404 => "Not Found"
        500 => "Internal Server Error"
        _ => "Unknown"

    var response = "HTTP/1.1 {status} {status_text}\r{NL}"
    response = "{response}Content-Type: {content_type}\r{NL}"
    response = "{response}Content-Length: {body.len()}\r{NL}"
    response = "{response}Access-Control-Allow-Origin: *\r{NL}"
    response = "{response}\r{NL}"
    response = "{response}{body}"
    return response

# Create HTTP error response
fn http_error(status: i32, message: text) -> text:
    val body = "{\"error\": \"{message}\"}"
    return http_response(status, "application/json", body)

# Generate dashboard HTML
fn generate_dashboard_html() -> text:
    val html = "<!DOCTYPE html>{NL}"
    html = "{html}<html>{NL}"
    html = "{html}<head>{NL}"
    html = "{html}  <title>Simple Compiler Dashboard</title>{NL}"
    html = "{html}  <meta charset=\"utf-8\">{NL}"
    html = "{html}  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">{NL}"
    html = "{html}  <style>{NL}"
    html = "{html}    body {{ font-family: system-ui, sans-serif; margin: 0; padding: 20px; background: #f5f5f5; }}{NL}"
    html = "{html}    .container {{ max-width: 1200px; margin: 0 auto; }}{NL}"
    html = "{html}    h1 {{ color: #333; }}{NL}"
    html = "{html}    .card {{ background: white; padding: 20px; margin: 20px 0; border-radius: 8px; box-shadow: 0 2px 4px rgba(0,0,0,0.1); }}{NL}"
    html = "{html}    .metric {{ display: inline-block; margin: 10px 20px 10px 0; }}{NL}"
    html = "{html}    .metric-label {{ color: #666; font-size: 14px; }}{NL}"
    html = "{html}    .metric-value {{ font-size: 32px; font-weight: bold; color: #2196F3; }}{NL}"
    html = "{html}    .progress {{ background: #e0e0e0; height: 20px; border-radius: 10px; overflow: hidden; }}{NL}"
    html = "{html}    .progress-bar {{ background: #4CAF50; height: 100%; transition: width 0.3s; }}{NL}"
    html = "{html}    .alert {{ padding: 15px; margin: 10px 0; border-radius: 4px; }}{NL}"
    html = "{html}    .alert-critical {{ background: #ffebee; border-left: 4px solid #f44336; }}{NL}"
    html = "{html}    .alert-warning {{ background: #fff3e0; border-left: 4px solid #ff9800; }}{NL}"
    html = "{html}    .refresh {{ color: #666; font-size: 12px; }}{NL}"
    html = "{html}  </style>{NL}"
    html = "{html}</head>{NL}"
    html = "{html}<body>{NL}"
    html = "{html}  <div class=\"container\">{NL}"
    html = "{html}    <h1>Simple Compiler Dashboard</h1>{NL}"
    html = "{html}    <div class=\"refresh\">Auto-refreshing every 30s...</div>{NL}"
    html = "{html}    <div id=\"content\">Loading...</div>{NL}"
    html = "{html}  </div>{NL}"
    html = "{html}  <script>{NL}"
    html = "{html}    async function loadDashboard() {{{NL}"
    html = "{html}      const status = await fetch('/api/status').then(r => r.json());{NL}"
    html = "{html}      const alerts = await fetch('/api/alerts').then(r => r.json());{NL}"
    html = "{html}      const content = document.getElementById('content');{NL}"
    html = "{html}      let html = '<div class=\"card\">';{NL}"
    html = "{html}      html += '<h2>Overview</h2>';{NL}"
    html = "{html}      html += '<div class=\"metric\"><div class=\"metric-label\">Features</div><div class=\"metric-value\">' + status.features_complete + '/' + status.features_total + '</div></div>';{NL}"
    html = "{html}      html += '<div class=\"metric\"><div class=\"metric-label\">Coverage</div><div class=\"metric-value\">' + status.coverage_percent.toFixed(1) + '%</div></div>';{NL}"
    html = "{html}      html += '<div class=\"metric\"><div class=\"metric-label\">TODOs</div><div class=\"metric-value\">' + status.todos_total + '</div></div>';{NL}"
    html = "{html}      html += '</div>';{NL}"
    html = "{html}      if (alerts.length > 0) {{{NL}"
    html = "{html}        html += '<div class=\"card\"><h2>Alerts</h2>';{NL}"
    html = "{html}        alerts.forEach(a => {{{NL}"
    html = "{html}          const cls = a.level === 'critical' ? 'alert-critical' : 'alert-warning';{NL}"
    html = "{html}          html += '<div class=\"alert ' + cls + '\">' + a.message + '</div>';{NL}"
    html = "{html}        }});{NL}"
    html = "{html}        html += '</div>';{NL}"
    html = "{html}      }}{NL}"
    html = "{html}      content.innerHTML = html;{NL}"
    html = "{html}    }}{NL}"
    html = "{html}    loadDashboard();{NL}"
    html = "{html}    setInterval(loadDashboard, 30000);{NL}"
    html = "{html}  </script>{NL}"
    html = "{html}</body>{NL}"
    html = "{html}</html>"
    return html

# =========================================================================
# Exports
# =========================================================================

export DashboardServer
export http_response, http_error, escape_json, generate_dashboard_html
