# Feature Documentation Generator - Usage Index
#
# Generates INDEX.md for usage (language feature) documentation,
# grouped by category.

use app.io.mod (file_write, dir_create)
use app.feature_doc.types.*

fn generate_usage_index(infos: [FeatureFileInfo], output_dir: text) -> text:
    """Generate INDEX.md for usage docs, grouped by category.

    Returns the output path.
    """
    var md = ""
    md = md + "# Usage Feature Documentation Index\n\n"
    md = md + "Language feature tests with Cucumber-style documentation.\n\n"

    # Group by category
    var categories = {}
    for info in infos:
        var cat = info.metadata.category
        if cat == "":
            cat = "Uncategorized"
        if categories.contains_key(cat):
            var list = categories[cat]
            list.push(info)
            categories[cat] = list
        else:
            categories[cat] = [info]

    # Summary
    md = md + "**Total features:** {infos.len()}\n\n"
    md = md + "---\n\n"

    # Generate sections by category
    val cat_names = categories.keys()
    for cat_name in cat_names:
        val entries = categories[cat_name]
        md = md + "## {cat_name} ({entries.len()} features)\n\n"
        md = md + "| Feature | Status | Feature IDs | Details |\n"
        md = md + "|---------|--------|-------------|---------|\n"

        for info in entries:
            val filename = extract_index_filename(info.file_path)
            val status = if info.metadata.status != "": info.metadata.status else: "N/A"
            val fids = if info.metadata.feature_ids != "": info.metadata.feature_ids else: "-"
            val desc_count = info.describes.len()
            var it_count = 0
            for desc in info.describes:
                for ctx in desc.contexts:
                    it_count = it_count + ctx.its.len()
            md = md + "| [{info.title}]({filename}.md) | {status} | {fids} | {desc_count} describes, {it_count} tests |\n"

        md = md + "\n"

    # Write
    val output_path = "{output_dir}/INDEX.md"
    dir_create(output_dir, true)
    file_write(output_path, md)
    output_path

fn extract_index_filename(file_path: text) -> text:
    """Get filename stem from path."""
    val parts = file_path.split("/")
    val filename = parts[-1]
    if filename.ends_with("_spec.spl"):
        return filename[:-9]
    if filename.ends_with(".spl"):
        return filename[:-4]
    filename

export generate_usage_index
