# Feature Documentation Generator - CLI Entry Point
#
# Usage:
#   simple feature-doc              # Generate all docs (app + usage)
#   simple feature-doc usage        # Usage docs only
#   simple feature-doc app          # App docs only
#   simple feature-doc --list       # List tests with classification

use app.io.mod (file_read, file_exists, dir_walk, dir_create)
use app.cli_util (get_cli_args)
use app.feature_doc.types.*
use app.feature_doc.parser (parse_feature_file)
use app.feature_doc.usage_docgen (generate_usage_doc)
use app.feature_doc.usage_index (generate_usage_index)
use app.feature_doc.app_docgen (generate_app_doc)
use app.feature_doc.app_index (generate_app_index)
use std.text.{NL}

val FEATURE_DIR = "test/feature"
val DOC_APP_DIR = "doc/feature/app"
val DOC_USAGE_DIR = "doc/feature/usage"

# ============================================================================
# File Discovery
# ============================================================================

fn discover_spec_files(base_path: text) -> [text]:
    """Walk directory and return all _spec.spl and _test.spl files."""
    val all_files = dir_walk(base_path)
    var spec_files: [text] = []
    for f in all_files:
        if f.ends_with("_spec.spl") or f.ends_with("_test.spl"):
            spec_files.push(f)
    spec_files

fn classify_file(path: text) -> text:
    """Classify a test file as 'app' or 'usage'."""
    if path.contains("/app/"):
        return "app"
    if path.contains("/usage/"):
        return "usage"
    # Fallback: unclassified files in root feature/
    "usage"

# ============================================================================
# Commands
# ============================================================================

fn cmd_generate_all() -> i64:
    """Generate both app and usage docs."""
    print "Generating feature documentation..."
    print ""

    val app_count = cmd_generate_app()
    val usage_count = cmd_generate_usage()

    print ""
    print "Done. Generated app + usage documentation."
    0

fn cmd_generate_usage() -> i64:
    """Generate usage (Cucumber-like) docs."""
    val usage_path = "{FEATURE_DIR}/usage"
    if not file_exists(usage_path):
        print "No usage tests found at {usage_path}"
        return 1

    val files = discover_spec_files(usage_path)
    if files.len() == 0:
        print "No spec files found in {usage_path}"
        return 0

    dir_create(DOC_USAGE_DIR, true)

    var infos: [FeatureFileInfo] = []
    var generated = 0

    for f in files:
        val info = parse_feature_file(f)
        infos.push(info)
        val out = generate_usage_doc(info, DOC_USAGE_DIR)
        if out != "":
            generated = generated + 1

    # Generate index
    val idx_path = generate_usage_index(infos, DOC_USAGE_DIR)

    print "Usage docs: {generated} files generated in {DOC_USAGE_DIR}/"
    if idx_path != "":
        print "  Index: {idx_path}"
    generated

fn cmd_generate_app() -> i64:
    """Generate app (manual-like) docs."""
    val app_path = "{FEATURE_DIR}/app"
    if not file_exists(app_path):
        print "No app tests found at {app_path}"
        return 1

    val files = discover_spec_files(app_path)
    if files.len() == 0:
        print "No spec files found in {app_path}"
        return 0

    dir_create(DOC_APP_DIR, true)

    var infos: [FeatureFileInfo] = []
    var generated = 0

    for f in files:
        val info = parse_feature_file(f)
        infos.push(info)
        val out = generate_app_doc(info, DOC_APP_DIR)
        if out != "":
            generated = generated + 1

    # Generate index
    val idx_path = generate_app_index(infos, DOC_APP_DIR)

    print "App docs: {generated} files generated in {DOC_APP_DIR}/"
    if idx_path != "":
        print "  Index: {idx_path}"
    generated

fn cmd_list() -> i64:
    """List all feature tests with their classification."""
    val all_files = discover_spec_files(FEATURE_DIR)

    var app_count = 0
    var usage_count = 0

    print "Feature Test Classification"
    print "=========================={NL}"

    print "## App Tests (CLI/tools){NL}"
    for f in all_files:
        if classify_file(f) == "app":
            val info = parse_feature_file(f)
            var it_count = 0
            for desc in info.describes:
                for ctx in desc.contexts:
                    it_count = it_count + ctx.its.len()
            print "  {f}  ({it_count} tests)"
            app_count = app_count + 1

    print ""
    print "## Usage Tests (language features){NL}"
    for f in all_files:
        if classify_file(f) == "usage":
            val info = parse_feature_file(f)
            var it_count = 0
            for desc in info.describes:
                for ctx in desc.contexts:
                    it_count = it_count + ctx.its.len()
            print "  {f}  ({it_count} tests)"
            usage_count = usage_count + 1

    print ""
    print "Total: {app_count} app + {usage_count} usage = {app_count + usage_count} feature tests"
    0

# ============================================================================
# Help
# ============================================================================

fn print_help():
    print "Feature Documentation Generator"
    print ""
    print "Usage: simple feature-doc [subcommand] [options]"
    print ""
    print "Subcommands:"
    print "  (none)     Generate all docs (app + usage)"
    print "  usage      Generate usage (Cucumber-like) docs only"
    print "  app        Generate app (manual-like) docs only"
    print ""
    print "Options:"
    print "  --list     List tests with app/usage classification"
    print "  -h, --help Show this help"
    print ""
    print "Output:"
    print "  doc/feature/app/     Manual-style docs from test/feature/app/"
    print "  doc/feature/usage/   Cucumber-style docs from test/feature/usage/"

# ============================================================================
# Main
# ============================================================================

fn main() -> i64:
    val all_args = get_cli_args()

    # Strip program name and script path
    var args: [text] = []
    var i = 2
    while i < all_args.len():
        args.push(all_args[i])
        i = i + 1

    # Check for help
    if args.contains("--help") or args.contains("-h"):
        print_help()
        return 0

    # Check for --list
    if args.contains("--list"):
        return cmd_list()

    # Determine subcommand
    if args.len() == 0:
        return cmd_generate_all()

    val subcmd = args[0]
    match subcmd:
        case "usage":
            cmd_generate_usage()
            return 0
        case "app":
            cmd_generate_app()
            return 0
        case _:
            print "Unknown subcommand: {subcmd}"
            print_help()
            return 1
