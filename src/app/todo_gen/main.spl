# Simple CLI - todo-gen command
# Generates TODO.md from todo_db.sdn

use lib.cli.cli_util (get_cli_args, parse_csv_fields)
use app.io.mod (file_exists, file_read, file_write)
use std.text.{NL}

val TODO_DB_PATH = "doc/todo/todo_db.sdn"
val TODO_MD_PATH = "doc/TODO.md"

fn print_help():
    print "Usage: simple todo-gen [options]"
    print ""
    print "Generate TODO report from todo_db.sdn."
    print ""
    print "Options:"
    print "  -h, --help   Show this help"

struct TodoItem:
    id: text
    keyword: text
    area: text
    priority: text
    description: text
    file: text
    line: text
    issue: text
    blocked: text
    status: text
    valid: bool

fn load_todos() -> [TodoItem]:
    if not file_exists(TODO_DB_PATH):
        return []

    val content = file_read(TODO_DB_PATH)
    val lines = content.split(NL)
    var todos: [TodoItem] = []
    var in_table = false

    for line in lines:
        val trimmed = line.trim()
        if trimmed.starts_with("todos |"):
            in_table = true
            continue
        if not in_table or trimmed == "" or trimmed.starts_with("#"):
            if in_table and trimmed != "" and not trimmed.starts_with("#") and not trimmed.starts_with(" "):
                in_table = false
            continue

        val fields = parse_csv_fields(trimmed)
        if fields.len() >= 11:
            todos.push(TodoItem(
                id: fields[0],
                keyword: fields[1],
                area: fields[2],
                priority: fields[3],
                description: fields[4],
                file: fields[5],
                line: fields[6],
                issue: fields[7],
                blocked: fields[8],
                status: fields[9],
                valid: fields[10] == "true" or fields[10] == "false"
            ))

    todos

fn get_areas(todos: [TodoItem]) -> [text]:
    var areas: [text] = []
    var seen: Dict<text, bool> = {}
    for t in todos:
        if not seen.contains_key(t.area):
            areas.push(t.area)
            seen[t.area] = true
    areas

fn count_by_area_priority(todos: [TodoItem], area: text, priority: text) -> i64:
    var count = 0
    for t in todos:
        if t.area == area and t.priority == priority:
            count = count + 1
    count

fn count_by_area(todos: [TodoItem], area: text) -> i64:
    var count = 0
    for t in todos:
        if t.area == area:
            count = count + 1
    count

fn count_by_area_blocked(todos: [TodoItem], area: text) -> i64:
    var count = 0
    for t in todos:
        if t.area == area and t.blocked != "":
            count = count + 1
    count

fn count_priority(todos: [TodoItem], priority: text) -> i64:
    var count = 0
    for t in todos:
        if t.priority == priority:
            count = count + 1
    count

fn count_priority_status(todos: [TodoItem], priority: text, status: text) -> i64:
    var count = 0
    for t in todos:
        if t.priority == priority and t.status == status:
            count = count + 1
    count

fn count_priority_blocked(todos: [TodoItem], priority: text) -> i64:
    var count = 0
    for t in todos:
        if t.priority == priority and t.blocked != "":
            count = count + 1
    count

fn count_priority_stale(todos: [TodoItem], priority: text) -> i64:
    var count = 0
    for t in todos:
        if t.priority == priority and t.status == "stale":
            count = count + 1
    count

fn generate_todo_md(todos: [TodoItem]) -> text:
    val total = todos.len()
    var open_count = 0
    var blocked_count = 0
    var stale_count = 0
    for t in todos:
        if t.status == "open": open_count = open_count + 1
        if t.blocked != "": blocked_count = blocked_count + 1
        if t.status == "stale": stale_count = stale_count + 1

    var lines: [text] = []
    lines.push("# TODO List")
    lines.push("")
    lines.push("**Generated:** 2026-02-03")
    lines.push("**Total:** {total} items | **Open:** {open_count} | **Blocked:** {blocked_count} | **Stale:** {stale_count}")
    lines.push("**Database:** `{TODO_DB_PATH}`")
    lines.push("")
    lines.push("## Statistics")
    lines.push("")
    lines.push("### By Area")
    lines.push("")
    lines.push("| Area | Count | P0 | P1 | P2 | P3 | Blocked |")
    lines.push("|------|-------|----|----|----|----|---------|")

    val areas = get_areas(todos)
    for area in areas:
        val cnt = count_by_area(todos, area)
        val p0 = count_by_area_priority(todos, area, "P0")
        val p1 = count_by_area_priority(todos, area, "P1")
        val p2 = count_by_area_priority(todos, area, "P2")
        val p3 = count_by_area_priority(todos, area, "P3")
        val blk = count_by_area_blocked(todos, area)
        lines.push("| {area} | {cnt} | {p0} | {p1} | {p2} | {p3} | {blk} |")

    lines.push("")
    lines.push("### By Priority")
    lines.push("")
    lines.push("| Priority | Count | Open | Blocked | Stale |")
    lines.push("|----------|-------|------|---------|-------|")

    val priorities = ["P0", "P1", "P2", "P3"]
    val priority_labels = ["P0 (critical)", "P1 (high)", "P2 (medium)", "P3 (low)"]
    var pi = 0
    for p in priorities:
        val cnt = count_priority(todos, p)
        val open = count_priority_status(todos, p, "open")
        val blk = count_priority_blocked(todos, p)
        val stale = count_priority_stale(todos, p)
        lines.push("| {priority_labels[pi]} | {cnt} | {open} | {blk} | {stale} |")
        pi = pi + 1

    # P0 critical items
    lines.push("")
    lines.push("## P0 - Critical")
    lines.push("")
    for t in todos:
        if t.priority == "P0":
            val issue_str = if t.issue != "": " (#{t.issue})" else: ""
            val blocked_str = if t.blocked != "": " [blocked by: {t.blocked}]" else: ""
            lines.push("- **{t.keyword}** {t.description} - `{t.file}:{t.line}`{issue_str}{blocked_str}")

    # P1 high items
    lines.push("")
    lines.push("## P1 - High Priority")
    lines.push("")
    for t in todos:
        if t.priority == "P1":
            val issue_str = if t.issue != "": " (#{t.issue})" else: ""
            lines.push("- **{t.keyword}** {t.description} - `{t.file}:{t.line}`{issue_str}")

    lines.push("")
    lines.push("## Appendix")
    lines.push("")
    lines.push("### Legend")
    lines.push("")
    lines.push("- **P0/critical:** Blocking, fix immediately")
    lines.push("- **P1/high:** Important, next sprint")
    lines.push("- **P2/medium:** Should do, backlog")
    lines.push("- **P3/low:** Nice to have, someday")
    lines.push("")
    lines.push("### Areas")
    lines.push("")
    lines.push("- `runtime` - GC, values, monoio, concurrency")
    lines.push("- `codegen` - MIR, Cranelift, LLVM, Vulkan")
    lines.push("- `compiler` - HIR, pipeline, interpreter")
    lines.push("- `parser` - Lexer, AST, parsing")
    lines.push("- `type` - Type checker, inference")
    lines.push("- `stdlib` - Simple standard library")
    lines.push("- `gpu` - GPU/SIMD/graphics")
    lines.push("- `ui` - UI framework")
    lines.push("- `test` - Test frameworks")
    lines.push("- `driver` - CLI, tools")
    lines.push("- `loader` - SMF loader")
    lines.push("- `pkg` - Package manager")
    lines.push("- `doc` - Documentation, specs, guides")
    lines.push("")

    lines.join(NL)

fn main() -> i64:
    val args = get_cli_args()

    for arg in args:
        if arg == "-h" or arg == "--help":
            print_help()
            return 0

    val todos = load_todos()
    val md = generate_todo_md(todos)
    file_write(TODO_MD_PATH, md)
    print "Generated {TODO_MD_PATH} ({todos.len()} items)"
    0
