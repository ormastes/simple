#!/usr/bin/env simple
# Quick Test Runner - runs first N test files to verify everything works
# Migrated from scripts/build/run_quick_tests.sh

use app.io
use app.utils.colors (success, error, warning, info)
use std.text.{NL}

export main, run_quick_tests

struct TestStats:
    total_files: i64
    passed_files: i64
    failed_files: i64
    crashed_files: i64
    timed_out_files: i64

fn main():
    val args = get_args()
    val num_files = if args.len() > 0:
        args[0].parse_int().unwrap_or(20)
    else:
        20

    val result = run_quick_tests(num_files)
    if result.failed_files > 0 or result.crashed_files > 0:
        exit(1)

fn run_quick_tests(num_files: i64) -> TestStats:
    """Run first N test files to verify everything works"""

    val binary = "./target/debug/simple_old"
    val log_dir = "log"
    val log_file = "{log_dir}/quick_test.log"
    val timeout_seconds = 120  # 2 minutes per file

    # Create log directory
    if not is_dir(log_dir):
        dir_create(log_dir, recursive: true)

    # Initialize log file
    val header = "# Quick Test Run - {num_files} files{NL}"
                 + "# Started: {current_timestamp()}{NL}{NL}"
    file_write(log_file, header)

    log(log_file, "Starting quick test run ({num_files} files)...")

    # Get test files
    val (stdout, stderr, code) = process_run(binary, ["test", "--list"])
    if code != 0:
        log(log_file, "ERROR: No test files found")
        exit(1)

    # Parse test file paths (lines starting with /, extract path before :)
    val lines = stdout.split(NL)
    var test_files = []
    for line in lines:
        if line.starts_with("/"):
            val parts = line.split(":")
            if parts.len() > 0:
                test_files = test_files + [parts[0]]

    # Take first num_files
    test_files = test_files.take(num_files as i32)

    if test_files.len() == 0:
        log(log_file, "ERROR: No test files found")
        return TestStats(total_files: 0, passed_files: 0, failed_files: 0,
                        crashed_files: 0, timed_out_files: 0)

    # Run tests
    var stats = TestStats(total_files: 0, passed_files: 0, failed_files: 0,
                          crashed_files: 0, timed_out_files: 0)

    var current = 0
    for test_file in test_files:
        current = current + 1
        print "[{current}/{test_files.len()}] {path_basename(test_file)}"
        stats = run_test_file(binary, test_file, timeout_seconds, log_file, stats)

    # Print summary
    log(log_file, "")
    log(log_file, "==========================================")
    log(log_file, "QUICK TEST RUN COMPLETE")
    log(log_file, "==========================================")
    log(log_file, "Total files:     {stats.total_files}")
    log(log_file, "Passed files:    {stats.passed_files}")
    log(log_file, "Failed files:    {stats.failed_files}")
    log(log_file, "Crashed files:   {stats.crashed_files}")
    log(log_file, "Timed out files: {stats.timed_out_files}")
    log(log_file, "==========================================")

    if stats.crashed_files > 0 or stats.timed_out_files > 0:
        log(log_file, "")
        log(log_file, "PROBLEM TEST FILES:")
        # Read log and filter for CRASH/TIMEOUT
        val log_content = file_read(log_file)
        val log_lines = log_content.split(NL)
        for line in log_lines:
            if line.contains("CRASH") or line.contains("TIMEOUT"):
                if line.contains("END TEST"):
                    print line

    log(log_file, "")
    log(log_file, "Finished: {current_timestamp()}")
    log(log_file, "Log file: {log_file}")

    stats

fn run_test_file(binary: text, test_file: text, timeout_seconds: i64,
                 log_file: text, stats: TestStats) -> TestStats:
    """Run a single test file and update stats"""

    var new_stats = stats
    new_stats.total_files = new_stats.total_files + 1

    log(log_file, "START TEST: {test_file}")

    val start_time = current_time_unix()

    # Run test with timeout
    val (stdout, stderr, exit_code) = process_run_timeout(
        "timeout",
        ["--kill-after=10", "{timeout_seconds}", binary, "test", test_file],
        timeout_seconds * 1000
    )

    val end_time = current_time_unix()
    val duration = end_time - start_time

    # Determine result
    var result_str = ""
    if exit_code == 0:
        result_str = "PASS"
        new_stats.passed_files = new_stats.passed_files + 1
    elif exit_code == 124 or exit_code == 137:
        result_str = "TIMEOUT"
        new_stats.timed_out_files = new_stats.timed_out_files + 1
    elif exit_code >= 128:
        val signal = exit_code - 128
        result_str = "CRASH (signal {signal})"
        new_stats.crashed_files = new_stats.crashed_files + 1
    else:
        result_str = "FAIL"
        new_stats.failed_files = new_stats.failed_files + 1

    log(log_file, "END TEST: {test_file} ({result_str}, {duration}s)")

    # Append output for failed tests
    if result_str != "PASS":
        val output_header = "--- Output for {test_file} ---{NL}"
        val output_lines = stdout.split(NL).take(20)
        val output_content = output_lines.join(NL)
        val output_footer = "{NL}--- End output ---{NL}"
        file_append(log_file, output_header + output_content + output_footer)

    new_stats

fn log(log_file: text, message: text):
    """Log message to file and stdout with timestamp"""
    val timestamp = current_timestamp()
    val line = "[{timestamp}] {message}{NL}"
    file_append(log_file, line)
    print message

fn current_timestamp() -> text:
    """Get current timestamp as formatted string"""
    val year = timestamp_year()
    val month = timestamp_month()
    val day = timestamp_day()
    val hour = timestamp_hour()
    val minute = timestamp_minute()
    val second = timestamp_second()
    "{year}-{month:02}-{day:02} {hour:02}:{minute:02}:{second:02}"

fn path_basename(path: text) -> text:
    """Extract basename from path"""
    val parts = path.split("/")
    if parts.len() > 0:
        parts[parts.len() - 1]
    else:
        path
