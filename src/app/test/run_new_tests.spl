#!/usr/bin/env simple
# Simple Test Runner with Crash Detection
# Runs Simple/SSpec test files with 5-minute timeout per file
# Logs start/end timestamps to detect crashes
# Migrated from scripts/build/run_simple_new_tests.sh

use app.io
use app.utils.colors (success, error, warning, info)
use std.text.{NL}

export main, run_new_tests

struct TestConfig:
    binary: text
    log_dir: text
    log_file: text
    timeout_seconds: i64
    max_parallel: i64

struct TestStats:
    total_files: i64
    passed_files: i64
    failed_files: i64
    crashed_files: i64
    timed_out_files: i64

struct TestResult:
    result_type: text    # "PASS", "FAIL", "CRASH", "TIMEOUT"
    duration: i64
    output: text
    exit_code: i64

fn main():
    val args = get_args()

    val binary = if args.len() > 0:
        args[0]
    else:
        "./target/debug/simple_old"

    val config = TestConfig(
        binary: binary,
        log_dir: "log",
        log_file: "log/simple_new_test.log",
        timeout_seconds: 300,  # 5 minutes
        max_parallel: 1
    )

    val result = run_new_tests(config)
    if not result:
        exit(1)

fn run_new_tests(config: TestConfig) -> bool:
    """Run all tests with crash detection"""

    # Create log directory
    if not is_dir(config.log_dir):
        dir_create(config.log_dir, recursive: true)

    # Initialize log file
    init_log_file(config)

    # Check binary exists
    if not file_exists(config.binary):
        log_message(config, "ERROR: Binary not found or not executable: {config.binary}")
        return false

    log_message(config, "Starting test run...")
    log_message(config, "Binary: {config.binary}")

    # Collect test files
    log_message(config, "Collecting test files...")
    val test_files = collect_test_files(config)

    if test_files.len() == 0:
        log_message(config, "ERROR: No test files found")
        return false

    log_message(config, "Found {test_files.len()} unique test files")

    # Run each test file
    var stats = TestStats(
        total_files: 0,
        passed_files: 0,
        failed_files: 0,
        crashed_files: 0,
        timed_out_files: 0
    )

    var current = 0
    for test_file in test_files:
        current = current + 1

        # Progress indicator
        print ""
        print "========================================"
        print "[{current}/{test_files.len()}] {test_file}"
        print "========================================"

        val result = run_test_file(config, test_file)
        update_stats(stats, result)

    # Generate summary
    generate_summary(config, stats)

    # Determine exit status
    stats.crashed_files == 0 and stats.timed_out_files == 0 and stats.failed_files == 0

fn init_log_file(config: TestConfig):
    """Initialize log file with header"""
    var header = "# Simple Test Runner Log{NL}"
    header = header + "# Started: {current_timestamp()}{NL}"
    header = header + "# Binary: {config.binary}{NL}"
    header = header + "# Timeout: {config.timeout_seconds}s per file{NL}"
    header = header + NL
    file_write(config.log_file, header)

fn log_message(config: TestConfig, message: text):
    """Log message to file and console"""
    val timestamp = current_timestamp()
    val line = "[{timestamp}] {message}{NL}"

    # Append to log file
    if file_exists(config.log_file):
        val content = file_read(config.log_file)
        file_write(config.log_file, content + line)
    else:
        file_write(config.log_file, line)

    # Print to console
    print "[{timestamp}] {message}"

fn collect_test_files(config: TestConfig) -> [text]:
    """Collect unique test files from binary"""
    val (stdout, _, code) = process_run(config.binary, ["test", "--list"])

    if code != 0:
        return []

    val lines = stdout.split(NL)
    var test_files = []
    var seen = []

    for line in lines:
        # Look for lines starting with /
        if line.starts_with("/"):
            # Extract file path (before first colon)
            val colon_idx = line.find(":")
            val file_path = if colon_idx > 0:
                line.substring(0, colon_idx)
            else:
                line

            # Add if not seen before
            if not contains(seen, file_path):
                test_files = test_files + [file_path]
                seen = seen + [file_path]

    test_files

fn run_test_file(config: TestConfig, test_file: text) -> TestResult:
    """Run a single test file with timeout"""

    log_message(config, "START TEST: {test_file}")

    val start_time = time_now_unix_micros() / 1000000  # Convert to seconds

    # Run test with timeout
    val (stdout, stderr, exit_code) = process_run_timeout(
        config.binary,
        ["test", test_file],
        config.timeout_seconds * 1000  # Convert to milliseconds
    )

    val end_time = time_now_unix_micros() / 1000000
    val duration = end_time - start_time

    val output = stdout + NL + stderr

    # Determine result type
    var result_type = ""
    if exit_code == 0:
        result_type = "PASS"
    elif exit_code == 124 or exit_code == 137:
        result_type = "TIMEOUT"
    elif exit_code >= 128:
        # Killed by signal (crash)
        val signal = exit_code - 128
        result_type = "CRASH (signal {signal})"
    else:
        result_type = "FAIL"

    log_message(config, "END TEST: {test_file} ({result_type}, {duration}s)")

    # Log output for non-passing tests
    if result_type != "PASS":
        log_test_output(config, test_file, output)

    TestResult(
        result_type: result_type,
        duration: duration,
        output: output,
        exit_code: exit_code
    )

fn log_test_output(config: TestConfig, test_file: text, output: text):
    """Log last 30 lines of output for failed tests"""
    val lines = output.split(NL)
    val start_idx = if lines.len() > 30:
        lines.len() - 30
    else:
        0

    var log_content = file_read(config.log_file)
    log_content = log_content + "--- Output for {test_file} ---{NL}"

    for i in start_idx..lines.len():
        log_content = log_content + lines[i] + NL

    log_content = log_content + "--- End output ---{NL}{NL}"
    file_write(config.log_file, log_content)

fn update_stats(stats: TestStats, result: TestResult):
    """Update statistics based on test result"""
    stats.total_files = stats.total_files + 1

    if result.result_type == "PASS":
        stats.passed_files = stats.passed_files + 1
    elif result.result_type.starts_with("CRASH"):
        stats.crashed_files = stats.crashed_files + 1
    elif result.result_type == "TIMEOUT":
        stats.timed_out_files = stats.timed_out_files + 1
    else:
        stats.failed_files = stats.failed_files + 1

fn generate_summary(config: TestConfig, stats: TestStats):
    """Generate summary report"""
    log_message(config, "")
    log_message(config, "==========================================")
    log_message(config, "TEST RUN COMPLETE")
    log_message(config, "==========================================")
    log_message(config, "Total files:     {stats.total_files}")
    log_message(config, "Passed files:    {stats.passed_files}")
    log_message(config, "Failed files:    {stats.failed_files}")
    log_message(config, "Crashed files:   {stats.crashed_files}")
    log_message(config, "Timed out files: {stats.timed_out_files}")
    log_message(config, "==========================================")

    # List problem tests
    if stats.crashed_files > 0 or stats.timed_out_files > 0:
        log_message(config, "")
        log_message(config, "PROBLEM TEST FILES:")
        show_problem_tests(config)

    log_message(config, "")
    log_message(config, "Finished: {current_timestamp()}")
    log_message(config, "Log file: {config.log_file}")

fn show_problem_tests(config: TestConfig):
    """Show tests that crashed or timed out"""
    val log_content = file_read(config.log_file)
    val lines = log_content.split(NL)

    for line in lines:
        if (line.contains("CRASH") or line.contains("TIMEOUT")) and line.contains("END TEST"):
            print line

fn current_timestamp() -> text:
    """Get current timestamp in YYYY-MM-DD HH:MM:SS format"""
    val year = timestamp_year()
    val month = timestamp_month()
    val day = timestamp_day()
    val hour = timestamp_hour()
    val minute = timestamp_minute()
    val second = timestamp_second()

    "{year}-{month:02}-{day:02} {hour:02}:{minute:02}:{second:02}"

fn contains(list: [text], item: text) -> bool:
    """Check if list contains item"""
    for elem in list:
        if elem == item:
            return true
    false
