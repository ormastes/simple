# Local Container Test Helper
#
# Developer-friendly wrapper for running tests in isolated containers
# Simple (.spl) replacement for scripts/local-container-test.sh
#
# Features:
# - Interactive commands (quick, unit, integration, system, all)
# - Container lifecycle management (build, status, shell)
# - Resource profiles matching CI environment
# - Auto-detection of Docker/Podman
# - Color-coded output

use app.io.mod.{shell, shell_bool, shell_output, env_get, cwd, file_exists, get_args, exit}
use std.text.{contains, trim, split}
use std.path.{join}

# Configuration
val DEFAULT_IMAGE = "simple-test-isolation:latest"

# ANSI color codes
val COLOR_RED = "\x1b[0;31m"
val COLOR_GREEN = "\x1b[0;32m"
val COLOR_YELLOW = "\x1b[1;33m"
val COLOR_BLUE = "\x1b[0;34m"
val COLOR_CYAN = "\x1b[0;36m"
val COLOR_RESET = "\x1b[0m"

# Resource limits by test type
class ResourceConfig:
    memory: text
    cpu: text
    profile: text

fn get_resource_config(test_type: text) -> ResourceConfig:
    """Get resource configuration for test type"""
    if test_type == "quick":
        return ResourceConfig(memory: "128m", cpu: "0.5", profile: "fast")
    else if test_type == "unit":
        return ResourceConfig(memory: "128m", cpu: "0.5", profile: "fast")
    else if test_type == "integration":
        return ResourceConfig(memory: "512m", cpu: "1.0", profile: "standard")
    else if test_type == "system":
        return ResourceConfig(memory: "1g", cpu: "2.0", profile: "slow")
    else:
        return ResourceConfig(memory: "128m", cpu: "0.5", profile: "fast")

# Logging functions
fn log(msg: text):
    print "{COLOR_BLUE}→{COLOR_RESET} {msg}"

fn success(msg: text):
    print "{COLOR_GREEN}✓{COLOR_RESET} {msg}"

fn warn(msg: text):
    print "{COLOR_YELLOW}⚠{COLOR_RESET} {msg}"

fn error(msg: text):
    print "{COLOR_RED}✗{COLOR_RESET} {msg}"

fn header(msg: text):
    print ""
    print "{COLOR_CYAN}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━{COLOR_RESET}"
    print "{COLOR_CYAN} {msg}{COLOR_RESET}"
    print "{COLOR_CYAN}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━{COLOR_RESET}"
    print ""

# Container runtime detection
fn detect_runtime() -> text:
    """Detect available container runtime (podman or docker)"""
    if shell_bool("command -v podman"):
        return "podman"
    else if shell_bool("command -v docker"):
        return "docker"
    else:
        error("No container runtime found")
        print ""
        print "Install Docker or Podman:"
        print "  Ubuntu/Debian: sudo apt install podman"
        print "  macOS:         brew install podman"
        exit(1)
        ""  # Unreachable but needed for type checker

fn check_container_exists(runtime: text, image: text) -> i64:
    """Check if container image exists (returns 1 if exists, 0 if not)"""
    val inspect_cmd = "{runtime} image inspect {image}"
    if shell_bool(inspect_cmd):
        1
    else:
        0

fn check_container(runtime: text, image: text, project_root: text):
    """Check if container exists, build if not"""
    val exists = check_container_exists(runtime, image)
    if exists == 0:
        warn("Container image not found: {image}")
        print ""
        log("Building container (this may take a minute)...")
        build_container(runtime, image, project_root)
    else:
        success("Container image ready: {image}")

fn build_container(runtime: text, image: text, project_root: text):
    """Build container image from Dockerfile"""
    log("Building container from tools/docker/Dockerfile.test-isolation...")

    val dockerfile = join(project_root, "tools/docker/Dockerfile.test-isolation")
    val build_cmd = "{runtime} build -t {image} -f {dockerfile} {project_root}"

    val result = shell(build_cmd)
    if result.exit_code == 0:
        success("Container built successfully")
    else:
        error("Container build failed")
        exit(1)

fn run_container_test(runtime: text, image: text, project_root: text, config: ResourceConfig, test_args: text):
    """Run tests in container with specified resources"""
    val run_cmd = "{runtime} run --rm -v {project_root}:/workspace:ro --memory={config.memory} --cpus={config.cpu} {image} test {test_args}"

    val result = shell(run_cmd)
    if result.exit_code != 0:
        exit(result.exit_code)

fn quick_test(runtime: text, image: text, project_root: text, test_file: text):
    """Run single test file quickly"""
    header("Quick Test: {test_file}")

    val config = get_resource_config("quick")
    run_container_test(runtime, image, project_root, config, test_file)

fn unit_tests(runtime: text, image: text, project_root: text):
    """Run all unit tests with fast profile"""
    header("Unit Tests (Fast Profile)")

    val config = get_resource_config("unit")
    run_container_test(runtime, image, project_root, config, "test/unit/ --profile=fast")

fn integration_tests(runtime: text, image: text, project_root: text):
    """Run integration tests with standard profile"""
    header("Integration Tests (Standard Profile)")

    val config = get_resource_config("integration")
    run_container_test(runtime, image, project_root, config, "test/integration/ --profile=standard")

fn system_tests(runtime: text, image: text, project_root: text):
    """Run system tests with slow profile"""
    header("System Tests (Slow Profile)")

    val config = get_resource_config("system")
    run_container_test(runtime, image, project_root, config, "test/system/ --profile=slow")

fn all_tests(runtime: text, image: text, project_root: text):
    """Run all test suites"""
    header("All Tests (Mixed Profiles)")

    unit_tests(runtime, image, project_root)
    integration_tests(runtime, image, project_root)
    system_tests(runtime, image, project_root)

    success("All test suites completed")

fn interactive_shell(runtime: text, image: text, project_root: text):
    """Open interactive shell in container"""
    header("Interactive Shell")

    log("Dropping into container shell...")
    log("Try: simple test test/unit/std/string_spec.spl")
    log("Exit with: exit or Ctrl+D")
    print ""

    val shell_cmd = "{runtime} run -it --rm -v {project_root}:/workspace --entrypoint /bin/bash {image}"
    val result = shell(shell_cmd)
    exit(result.exit_code)

fn rebuild_container(runtime: text, image: text, project_root: text):
    """Rebuild container from scratch"""
    header("Rebuild Container")

    # Remove existing image if it exists
    val exists = check_container_exists(runtime, image)
    if exists == 1:
        log("Removing existing image...")
        val remove_cmd = "{runtime} rmi {image}"
        shell(remove_cmd)

    # Rebuild
    build_container(runtime, image, project_root)

fn get_image_size(runtime: text, image: text) -> text:
    """Get human-readable image size"""
    val size_cmd = "{runtime} image inspect {image} --format='{{.Size}}'"
    val size_bytes = shell_output(size_cmd).trim()

    # Simple conversion to human-readable format
    val bytes = int(size_bytes)
    if bytes > 1073741824:
        val gb = bytes / 1073741824
        "{gb}GB"
    else if bytes > 1048576:
        val mb = bytes / 1048576
        "{mb}MB"
    else if bytes > 1024:
        val kb = bytes / 1024
        "{kb}KB"
    else:
        "{bytes}B"

fn get_image_created(runtime: text, image: text) -> text:
    """Get image creation date"""
    val created_cmd = "{runtime} image inspect {image} --format='{{.Created}}'"
    val created_full = shell_output(created_cmd).trim()

    # Extract date part (before 'T')
    val parts = split(created_full, "T")
    if parts.len() > 0:
        parts[0]
    else:
        "unknown"

fn show_status(runtime: text, image: text):
    """Show container status and health"""
    header("Container Status")

    val version_cmd = "{runtime} --version"
    val version_output = shell_output(version_cmd).trim()
    val version_lines = split(version_output, "\n")
    val version = if version_lines.len() > 0:
        version_lines[0]
    else:
        "unknown"

    log("Runtime: {runtime} ({version})")
    log("Image: {image}")

    val exists = check_container_exists(runtime, image)
    if exists == 1:
        val size = get_image_size(runtime, image)
        val created = get_image_created(runtime, image)
        success("Image exists (Size: {size}, Created: {created})")

        # Test if container works
        log("Testing container health...")
        val health_cmd = "{runtime} run --rm {image} --version"
        if shell_bool(health_cmd):
            success("Container is functional")
        else:
            error("Container health check failed")
    else:
        warn("Image not found - run with 'build' command to create it")

fn show_help():
    """Display help text"""
    print "{COLOR_CYAN}Simple Language - Local Container Test Helper{COLOR_RESET}"
    print ""
    print "Usage: simple run src/app/test/container_test.spl [COMMAND] [OPTIONS]"
    print ""
    print "Commands:"
    print "  quick <file>   Run single test file (fast profile)"
    print "  unit           Run all unit tests (fast profile, 128MB, 0.5 CPU)"
    print "  integration    Run integration tests (standard profile, 512MB, 1.0 CPU)"
    print "  system         Run system tests (slow profile, 1GB, 2.0 CPU)"
    print "  all            Run all test suites"
    print "  shell          Open interactive shell in container"
    print "  build          Build/rebuild container image"
    print "  status         Show container status and health"
    print "  help           Show this help message"
    print ""
    print "Examples:"
    print "  # Run single test file"
    print "  simple run src/app/test/container_test.spl quick test/unit/std/string_spec.spl"
    print ""
    print "  # Run unit tests"
    print "  simple run src/app/test/container_test.spl unit"
    print ""
    print "  # Run all tests"
    print "  simple run src/app/test/container_test.spl all"
    print ""
    print "  # Debug in container"
    print "  simple run src/app/test/container_test.spl shell"
    print ""
    print "  # Rebuild container after Dockerfile changes"
    print "  simple run src/app/test/container_test.spl build"
    print ""
    print "Environment Variables:"
    print "  CONTAINER_IMAGE   Container image name (default: simple-test-isolation:latest)"
    print ""
    print "Resource Profiles:"
    print "  Fast (unit)        - 128MB RAM, 0.5 CPU, 30s timeout"
    print "  Standard (integ)   - 512MB RAM, 1.0 CPU, 120s timeout"
    print "  Slow (system)      - 1GB RAM, 2.0 CPU, 600s timeout"
    print ""
    print "See Also:"
    print "  doc/guide/container_testing.md   - Full container testing guide"
    print "  doc/guide/resource_limits.md     - Resource profile documentation"
    print "  src/app/test/ci_runner.spl       - CI test runner"

fn main():
    """Entry point"""
    val args = get_args()

    # Get project root
    val project_root = cwd()

    # Detect container runtime
    val runtime = detect_runtime()

    # Get container image from environment or use default
    val container_image = env_get("CONTAINER_IMAGE") ?? DEFAULT_IMAGE

    # Parse command
    val command = if args.len() > 1:
        args[1]
    else:
        "help"

    # Execute command
    if command == "quick":
        if args.len() < 3:
            error("Usage: simple run src/app/test/container_test.spl quick <test_file>")
            exit(1)
        check_container(runtime, container_image, project_root)
        quick_test(runtime, container_image, project_root, args[2])
    else if command == "unit":
        check_container(runtime, container_image, project_root)
        unit_tests(runtime, container_image, project_root)
    else if command == "integration":
        check_container(runtime, container_image, project_root)
        integration_tests(runtime, container_image, project_root)
    else if command == "system":
        check_container(runtime, container_image, project_root)
        system_tests(runtime, container_image, project_root)
    else if command == "all":
        check_container(runtime, container_image, project_root)
        all_tests(runtime, container_image, project_root)
    else if command == "shell":
        check_container(runtime, container_image, project_root)
        interactive_shell(runtime, container_image, project_root)
    else if command == "build":
        rebuild_container(runtime, container_image, project_root)
    else if command == "status":
        show_status(runtime, container_image)
    else if command == "help" or command == "-h" or command == "--help":
        show_help()
    else:
        error("Unknown command: {command}")
        print ""
        show_help()
        exit(1)

export main
