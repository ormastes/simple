#!/usr/bin/env simple
# Feature Test Scaffolding Tool
# Generates BDD test templates from existing feature markdown files
# Migrated from scripts/build/scaffold_feature_test.py

use app.io
use app.utils.colors (success, error, warning, info)
use app.utils.parsing (extract_section, parse_key_value, parse_table, split_lines)
use app.utils.markdown (MarkdownBuilder)
use std.text.{NL}

export main, scaffold_feature_test, parse_feature_markdown

struct FeatureMetadata:
    feature_id: text
    feature_name: text
    category: text
    difficulty: i64
    status: text
    impl_type: text
    spec_ref: text
    files: [text]
    rust_tests: [text]
    notes: text
    depends_on: [i64]
    required_by: [i64]
    examples: [text]

fn main():
    val args = get_args()
    if args.len() == 0:
        print error("Usage: scaffold <feature-markdown-file.md>")
        print "Example: scaffold doc/old_features/infrastructure/0001_lexer.md"
        exit(1)

    val md_path = args[0]
    if not file_exists(md_path):
        print error("File not found: {md_path}")
        exit(1)

    val result = scaffold_feature_test(md_path)
    print result

fn scaffold_feature_test(md_path: text) -> text:
    """Generate BDD test scaffold from markdown file"""
    val metadata = parse_feature_markdown(md_path)
    generate_test_scaffold(metadata, md_path)

fn parse_feature_markdown(md_path: text) -> FeatureMetadata:
    """Parse feature markdown and extract metadata"""
    val content = file_read(md_path)

    # Parse overview table
    val metadata_map = parse_overview_table(content)

    # Extract basic fields
    val feature_id = metadata_map.get("Feature ID", "").replace("#", "")
    val feature_name = metadata_map.get("Feature Name", "")
    val category = metadata_map.get("Category", "")
    val difficulty_str = metadata_map.get("Difficulty", "3")
    val difficulty = parse_difficulty(difficulty_str)
    val status = metadata_map.get("Status", "âœ… Complete")
    val impl_type = metadata_map.get("Implementation", "R")

    # Extract sections
    val description = extract_section(content, "Description")
    val spec_section = extract_section(content, "Specification")
    val impl_section = extract_section(content, "Implementation")
    val testing_section = extract_section(content, "Testing")
    val notes_section = extract_section(content, "Notes")

    # Parse spec reference
    val spec_ref = extract_spec_reference(spec_section)

    # Parse implementation files
    val files = parse_file_table(impl_section)

    # Parse test files
    val rust_tests = parse_test_table(testing_section, "Rust Tests")

    # Parse dependencies
    val (depends_on, required_by) = parse_dependencies(content)

    # Extract code examples
    val examples = extract_code_examples(content)

    FeatureMetadata(
        feature_id: feature_id,
        feature_name: feature_name,
        category: category,
        difficulty: difficulty,
        status: status,
        impl_type: impl_type,
        spec_ref: spec_ref,
        files: files,
        rust_tests: rust_tests,
        notes: notes_section,
        depends_on: depends_on,
        required_by: required_by,
        examples: examples
    )

fn parse_overview_table(content: text) -> Dict<text, text>:
    """Extract metadata from the Overview table"""
    var metadata = {}

    # Find overview section
    val overview_start = content.find("## Overview")
    if overview_start < 0:
        return metadata

    # Extract table content between ## Overview and next ##
    val section_content = content.substring(overview_start, content.len())
    val next_section = section_content.find("## ", 12)  # Skip the "## Overview" itself
    val table_content = if next_section > 0:
        section_content.substring(0, next_section)
    else:
        section_content

    # Parse table rows
    val lines = split_lines(table_content)
    for line in lines:
        if line.contains("|") and not line.contains("|---"):
            val parts = line.split("|")
            if parts.len() >= 3:
                val key = parts[1].trim().replace("**", "")
                val value = parts[2].trim()
                if key.len() > 0 and value.len() > 0:
                    metadata[key] = value

    metadata

fn parse_difficulty(difficulty_str: text) -> i64:
    """Parse difficulty string like '3 (Medium)' to integer"""
    val parts = difficulty_str.split(" ")
    if parts.len() > 0:
        parts[0].parse_int().unwrap_or(3)
    else:
        3

fn extract_spec_reference(spec_section: text) -> text:
    """Extract spec reference from markdown links"""
    # Look for pattern [text](../../path)
    val link_start = spec_section.find("](../../")
    if link_start < 0:
        return ""

    val path_start = link_start + 2
    val path_end = spec_section.find(")", path_start)
    if path_end < 0:
        return ""

    spec_section.substring(path_start, path_end)

fn parse_file_table(impl_section: text) -> [text]:
    """Extract file paths from implementation files table"""
    var files = []

    # Look for ### Files subsection
    val files_start = impl_section.find("### Files")
    if files_start < 0:
        return files

    val files_content = impl_section.substring(files_start, impl_section.len())
    val lines = split_lines(files_content)

    for line in lines:
        if line.contains("|") and not line.contains("|---"):
            val parts = line.split("|")
            if parts.len() >= 2:
                val file_path = parts[1].trim().replace("`", "")
                if file_path.len() > 0 and not file_path.starts_with("File"):
                    files = files + [file_path]

    files

fn parse_test_table(testing_section: text, section_name: text) -> [text]:
    """Extract test file paths from testing section"""
    var tests = []

    # Look for specific test subsection
    val section_marker = "### {section_name}"
    val section_start = testing_section.find(section_marker)
    if section_start < 0:
        return tests

    val section_content = testing_section.substring(section_start, testing_section.len())
    val lines = split_lines(section_content)

    for line in lines:
        if line.contains("|") and not line.contains("|---"):
            val parts = line.split("|")
            if parts.len() >= 2:
                val test_path = parts[1].trim().replace("`", "")
                if test_path.len() > 0 and not test_path.starts_with("Test File"):
                    tests = tests + [test_path]

    tests

fn parse_dependencies(content: text) -> ([i64], [i64]):
    """Extract depends_on and required_by feature IDs"""
    var depends_on = []
    var required_by = []

    val deps_section = extract_section(content, "Dependencies")
    if deps_section.len() == 0:
        return (depends_on, required_by)

    # Parse "Depends on: #1, #2, #3" format
    val depends_start = deps_section.find("Depends on:")
    if depends_start >= 0:
        val depends_line = extract_line_after(deps_section, depends_start)
        if depends_line.len() > 0 and not depends_line.contains("none"):
            depends_on = extract_feature_ids(depends_line)

    # Parse "Required by: #4, #5" format
    val required_start = deps_section.find("Required by:")
    if required_start >= 0:
        val required_line = extract_line_after(deps_section, required_start)
        if required_line.len() > 0 and not required_line.contains("none"):
            required_by = extract_feature_ids(required_line)

    (depends_on, required_by)

fn extract_line_after(text: text, start_pos: i64) -> text:
    """Extract rest of line after position"""
    val newline_pos = text.find(NL, start_pos)
    if newline_pos > start_pos:
        text.substring(start_pos, newline_pos)
    else:
        text.substring(start_pos, text.len())

fn extract_feature_ids(line: text) -> [i64]:
    """Extract #123 style feature IDs from line"""
    var ids = []
    var i = 0

    while i < line.len():
        if line[i] == '#':
            # Extract number after #
            var num_str = ""
            var j = i + 1
            while j < line.len():
                val ch = line[j]
                if ch >= '0' and ch <= '9':
                    num_str = num_str + "{ch}"
                    j = j + 1
                else:
                    break

            if num_str.len() > 0:
                val id = num_str.parse_int().unwrap_or(0)
                if id > 0:
                    ids = ids + [id]
            i = j
        else:
            i = i + 1

    ids

fn extract_code_examples(content: text) -> [text]:
    """Extract code examples from Examples section"""
    var examples = []

    val examples_section = extract_section(content, "Examples")
    if examples_section.len() == 0:
        return examples

    # Find code blocks (```simple ... ```)
    var i = 0
    while i < examples_section.len():
        val block_start = examples_section.find("```simple", i)
        if block_start < 0:
            break

        val code_start = block_start + 9  # Length of "```simple"
        val block_end = examples_section.find("```", code_start)
        if block_end < 0:
            break

        val code = examples_section.substring(code_start, block_end).trim()
        examples = examples + [code]
        i = block_end + 3

    examples

fn generate_test_scaffold(metadata: FeatureMetadata, md_path: text) -> text:
    """Generate BDD test scaffold from metadata"""
    var output = []

    output = output + ["# Scaffolded from {md_path}"]
    output = output + ["# TODO: Add real test assertions before marking complete"]
    output = output + [""]
    output = output + ["use spec.feature_doc.feature_metadata"]
    output = output + [""]
    output = output + ["describe \"{metadata.feature_name} (#{metadata.feature_id})\":"]
    output = output + ["    feature_metadata("]
    output = output + ["        id: {metadata.feature_id},"]
    output = output + ["        name: \"{metadata.feature_name}\","]
    output = output + ["        category: \"{metadata.category}\","]
    output = output + ["        difficulty: {metadata.difficulty},"]
    output = output + ["        status: \"{metadata.status}\","]
    output = output + ["        impl_type: \"{metadata.impl_type}\","]
    output = output + ["        spec_ref: \"{metadata.spec_ref}\","]
    output = output + ["        files: {format_string_list(metadata.files)},"]
    output = output + ["        rust_tests: {format_string_list(metadata.rust_tests)},"]
    output = output + ["        depends_on: {format_int_list(metadata.depends_on)},"]
    output = output + ["        required_by: {format_int_list(metadata.required_by)}"]
    output = output + ["    )"]
    output = output + [""]

    # Generate test stubs from examples
    if metadata.examples.len() > 0:
        output = output + ["    it \"parses and executes examples\":"]
        output = output + ["        # TODO: Add test assertions"]
        output = output + ["        assert true"]
        output = output + [""]

    output = output + ["    it \"implements specification requirements\":"]
    output = output + ["        # TODO: Add test assertions"]
    output = output + ["        assert true"]

    output.join(NL)

fn format_string_list(items: [text]) -> text:
    """Format list of strings for Simple code"""
    if items.len() == 0:
        return "[]"

    var parts = []
    for item in items:
        parts = parts + ["\"{item}\""]
    "[" + parts.join(", ") + "]"

fn format_int_list(items: [i64]) -> text:
    """Format list of integers for Simple code"""
    if items.len() == 0:
        return "[]"

    var parts = []
    for item in items:
        parts = parts + ["{item}"]
    "[" + parts.join(", ") + "]"
