# Semi-Host Reader Tool
#
# Host-side tool that receives semihosting calls from target and
# reconstructs human-readable output using SMF StringIntern sections.
#
# Usage:
#   simple semi-host-reader --smf-root=./build --transport=openocd
#   simple semi-host-reader --smf-root=./build --transport=qemu --output=stdout
#   simple semi-host-reader --smf-root=./build --transport=serial --port=/dev/ttyUSB0
#
# Design: doc/design/semihosting_system_api_design.md

extern fn rt_file_read_text(path: text) -> text
extern fn rt_file_exists(path: text) -> bool
extern fn rt_dir_list(path: text) -> [text]

fn file_read(path: text) -> text:
    rt_file_read_text(path) ?? ""

fn file_exists(path: text) -> bool:
    rt_file_exists(path)

fn dir_list(path: text) -> [text]:
    rt_dir_list(path) ?? []

fn escape_json(s: text) -> text:
    # Simple JSON escaping for output
    var result = s
    result = result.replace("\\", "\\\\")
    result = result.replace("\"", "\\\"")
    result = result.replace("\n", "\\n")
    result = result.replace("\t", "\\t")
    result

export SemiHostReader, Transport, TransportType
export run_reader, parse_serial_frame, format_interned_string

# ============================================================================
# FormatType enum (local definition for portability)
# ============================================================================

enum FormatType:
    Void
    Int8
    Int16
    Int32
    Int64
    UInt8
    UInt16
    UInt32
    UInt64
    Float32
    Float64
    Bool
    Char
    Hex8
    Hex16
    Hex32
    Hex64
    Binary
    Pointer
    Text

# ============================================================================
# StringIntern Entry (local definition)
# ============================================================================

class StringInternEntry:
    handle: i32
    text: text
    format_types: [FormatType]

impl StringInternEntry:
    static fn create(h: i32, fmt: text) -> StringInternEntry:
        StringInternEntry(handle: h, text: fmt, format_types: [])

# ============================================================================
# StringIntern Table (local definition)
# ============================================================================

class StringInternTable:
    entries: [StringInternEntry]
    next_handle: i32

impl StringInternTable:
    static fn with_test_handles() -> StringInternTable:
        StringInternTable(entries: [], next_handle: 1)

    me add_reserved(handle: i32, format_text: text, types: [FormatType]):
        val entry = StringInternEntry(handle: handle, text: format_text, format_types: types)
        self.entries.push(entry)
        if handle >= self.next_handle:
            self.next_handle = handle + 1

    fn get(handle: i32) -> StringInternEntry?:
        var i = 0
        while i < self.entries.len():
            val entry = self.entries[i]
            if entry.handle == handle:
                return entry
            i = i + 1
        nil

    fn all_entries() -> [StringInternEntry]:
        self.entries

    fn count() -> i32:
        self.entries.len() as i32

# ============================================================================
# Transport Types
# ============================================================================

enum TransportType:
    OpenOCD     # OpenOCD semihosting via GDB RSP
    JLink       # SEGGER J-Link semihosting
    Trace32     # Lauterbach Trace32
    QEMU        # QEMU serial output
    Serial      # Raw serial port
    File        # Read from file (for testing)

struct Transport:
    transport_type: TransportType
    config: Dict<text, text>    # Transport-specific config

impl Transport:
    static fn openocd(host: text, port: u16) -> Transport:
        var config: Dict<text, text> = {}
        config["host"] = host
        config["port"] = "{port}"
        Transport(transport_type: TransportType.OpenOCD, config: config)

    static fn qemu_serial() -> Transport:
        var config: Dict<text, text> = {}
        config["source"] = "stdin"
        Transport(transport_type: TransportType.QEMU, config: config)

    static fn serial(port: text, baud: u32) -> Transport:
        var config: Dict<text, text> = {}
        config["port"] = port
        config["baud"] = "{baud}"
        Transport(transport_type: TransportType.Serial, config: config)

    static fn file(path: text) -> Transport:
        var config: Dict<text, text> = {}
        config["path"] = path
        Transport(transport_type: TransportType.File, config: config)

# ============================================================================
# Semi-Host Reader
# ============================================================================

class SemiHostReader:
    smf_root: text
    string_tables: [StringInternTable]
    merged_table: StringInternTable
    transport: Transport
    output_timestamps: bool
    output_json: bool

impl SemiHostReader:
    # Create new reader
    static fn new(smf_root: text, transport: Transport) -> SemiHostReader:
        var reader = SemiHostReader(
            smf_root: smf_root,
            string_tables: [],
            merged_table: StringInternTable.with_test_handles(),
            transport: transport,
            output_timestamps: false,
            output_json: false
        )
        reader.load_all_smf_files()
        reader

    # Load string tables from all SMF files in root
    me load_all_smf_files():
        val smf_files = find_smf_files(self.smf_root)
        for smf_path in smf_files:
            val result = self.load_smf_strings(smf_path)
            if not result.is_ok():
                print "[WARN] Failed to load {smf_path}: {result.err.unwrap()}"

    # Load strings from single SMF file
    me load_smf_strings(smf_path: text) -> Result<(), text>:
        if not file_exists(smf_path):
            return Err("File not found: {smf_path}")

        val content = file_read(smf_path)
        if content == "":
            return Err("Empty file: {smf_path}")

        # Parse SMF and extract StringIntern section
        val section_data = extract_string_intern_section(content.as_bytes())
        if not section_data.?:
            # No StringIntern section in this file
            return Ok(())

        val table_result = read_string_intern_section(section_data.unwrap())
        if not table_result.is_ok():
            return Err(table_result.err.unwrap())

        val table = table_result.unwrap()

        # Merge into main table
        for entry in table.all_entries():
            self.merged_table.add_reserved(entry.handle, entry.text, entry.format_types)

        self.string_tables.push(table)
        Ok(())

    # Enable timestamp output
    me with_timestamps() -> SemiHostReader:
        self.output_timestamps = true
        self

    # Enable JSON output
    me with_json() -> SemiHostReader:
        self.output_json = true
        self

    # Load string table from .smt JSON file
    me load_smt_json_file(path: text):
        val content = file_read(path)
        if content == "":
            print "[WARN] Empty or missing SMT file: {path}"
            return

        # Parse JSON string table entries
        # Format: {"strings": [{"id": N, "text": "...", "params": N, "format_types": []}, ...]}
        var pos = 0
        var in_strings = false
        while pos < content.len():
            # Look for "id": entries within "strings" array
            val id_marker = "\"id\":"
            val id_pos = content.index_of(id_marker, pos)
            if id_pos < 0:
                break

            # Extract id value
            var id_start = id_pos + id_marker.len()
            # Skip whitespace
            while id_start < content.len() and (content[id_start] == " " or content[id_start] == "\t"):
                id_start = id_start + 1
            var id_end = id_start
            while id_end < content.len() and content[id_end] >= "0" and content[id_end] <= "9":
                id_end = id_end + 1
            val id_str = content.substring(id_start, id_end)
            val handle = id_str.parse_int() as i32

            # Find "text": after this id
            val text_marker = "\"text\":"
            val text_pos = content.index_of(text_marker, id_end)
            if text_pos < 0:
                break

            # Extract text value (find opening quote, then closing quote)
            var quote_start = text_pos + text_marker.len()
            while quote_start < content.len() and content[quote_start] != "\"":
                quote_start = quote_start + 1
            quote_start = quote_start + 1  # skip opening quote
            var quote_end = quote_start
            while quote_end < content.len() and content[quote_end] != "\"":
                # Handle escaped quotes
                if content[quote_end] == "\\":
                    quote_end = quote_end + 2
                else:
                    quote_end = quote_end + 1
            val entry_text = content.substring(quote_start, quote_end)

            # Unescape \\n to real newline
            val clean_text = entry_text.replace("\\n", "\n")

            self.merged_table.add_reserved(handle, clean_text, [])
            pos = quote_end + 1

        print "[semi-host-reader] Loaded {self.merged_table.count()} entries from SMT file: {path}"

    # Main reader loop
    fn run():
        print "[semi-host-reader] Starting with SMF root: {self.smf_root}"
        print "[semi-host-reader] Loaded {self.merged_table.count()} interned strings"

        match self.transport.transport_type:
            case TransportType.QEMU:
                self.run_qemu_serial()
            case TransportType.Serial:
                self.run_serial()
            case TransportType.File:
                self.run_file()
            case TransportType.OpenOCD:
                self.run_openocd()
            case _:
                print "[ERROR] Transport not yet implemented: {self.transport.transport_type}"

    # Run with QEMU serial input (from stdin)
    fn run_qemu_serial():
        print "[semi-host-reader] Reading from stdin (QEMU serial)"
        # Read binary frames from stdin
        # Each frame: MAGIC(1) + VERSION(1) + OP(4) + LEN(4) + PAYLOAD(N)

        var buffer: [u8] = []
        while true:
            val byte = read_stdin_byte()
            if byte < 0:
                break  # EOF

            buffer.push(byte as u8)

            # Try to parse frame
            val frame_result = parse_serial_frame(buffer)
            if frame_result.ok.?:
                val (frame, consumed) = frame_result.unwrap()
                self.handle_frame(frame)
                # Remove consumed bytes
                buffer = buffer[consumed..]

    # Run with serial port
    fn run_serial():
        val port = self.transport.config["port"] ?? "/dev/ttyUSB0"
        val baud = self.transport.config["baud"] ?? "115200"
        print "[semi-host-reader] Opening serial port: {port} at {baud} baud"
        eprint("[WARNING] Serial port reading not implemented; requires FFI for termios/serial I/O")
        eprint("[WARNING] Serial transport is a no-op; no data will be read from {port}")

    # Run with file input (for testing)
    fn run_file():
        val path = self.transport.config["path"] ?? ""
        if path == "":
            print "[ERROR] No file path specified"
            return

        print "[semi-host-reader] Reading from file: {path}"
        val content = file_read(path)
        val buffer = content.as_bytes()

        var offset: u64 = 0
        while offset < buffer.len() as u64:
            val remaining = buffer[offset..]
            val frame_result = parse_serial_frame(remaining)
            if not frame_result.is_ok():
                offset = offset + 1  # Skip byte and retry
                continue

            val (frame, consumed) = frame_result.unwrap()
            self.handle_frame(frame)
            offset = offset + consumed as u64

    # Run with OpenOCD
    fn run_openocd():
        val host = self.transport.config["host"] ?? "localhost"
        val port = self.transport.config["port"] ?? "4444"
        print "[semi-host-reader] Connecting to OpenOCD at {host}:{port}"
        eprint("[WARNING] OpenOCD GDB RSP connection not implemented; requires TCP socket FFI support")
        eprint("[WARNING] OpenOCD transport is a no-op; no data will be read from {host}:{port}")

    # Handle a parsed semihosting frame
    fn handle_frame(frame: SemihostFrame):
        match frame.op:
            case 0x100:  # SYS_WRITE_HANDLE
                self.handle_print(frame.handle, [])
            case 0x101:  # SYS_WRITE_HANDLE_P1
                self.handle_print(frame.handle, frame.params[0..1])
            case 0x102:  # SYS_WRITE_HANDLE_P2
                self.handle_print(frame.handle, frame.params[0..2])
            case 0x103:  # SYS_WRITE_HANDLE_P3
                self.handle_print(frame.handle, frame.params[0..3])
            case 0x104:  # SYS_WRITE_HANDLE_PN
                self.handle_print(frame.handle, frame.params)
            case 0x18 | 0x20:  # SYS_EXIT / SYS_EXIT_EXTENDED
                val code = if frame.params.len() > 0: frame.params[0] else: 0
                self.handle_exit(code)
            case _:
                print "[UNKNOWN OP: 0x{frame.op:04x}]"

    # Handle interned print
    fn handle_print(handle: u32, params: [i64]):
        val entry_opt = self.merged_table.get(handle)
        if not entry_opt.?:
            if self.output_json:
                print "{{\"type\":\"unknown\",\"handle\":{handle},\"params\":{params}}}"
            else:
                print "[UNKNOWN HANDLE: 0x{handle:08x}] params={params}"
            return

        val entry = entry_opt.unwrap()
        val formatted = format_interned_string(entry.text, entry.format_types, params)

        if self.output_json:
            print "{{\"type\":\"print\",\"handle\":{handle},\"text\":\"{escape_json(formatted)}\"}}"
        else:
            if self.output_timestamps:
                val ts = current_timestamp()
                print "[{ts}] {formatted}"
            else:
                print formatted

    # Handle exit
    fn handle_exit(code: i64):
        if self.output_json:
            print "{{\"type\":\"exit\",\"code\":{code}}}"
        else:
            print "[EXIT] Code: {code}"

# ============================================================================
# Serial Protocol Parsing
# ============================================================================

# Frame structure for QEMU serial protocol
struct SemihostFrame:
    op: u32
    handle: u32
    params: [i64]

# Protocol constants
val PROTO_MAGIC = 0xAB
val PROTO_VERSION = 0x01

# Parse serial frame from buffer
# Returns (frame, bytes_consumed) or error
fn parse_serial_frame(buffer: [u8]) -> Result<(SemihostFrame, u32), text>:
    # Minimum frame size: magic(1) + version(1) + op(4) + len(4) = 10
    if buffer.len() < 10:
        return Err("Buffer too small")

    # Check magic
    if buffer[0] != PROTO_MAGIC:
        return Err("Invalid magic byte")

    # Check version
    if buffer[1] != PROTO_VERSION:
        return Err("Unsupported protocol version")

    # Read operation code
    val op = read_u32_le(buffer, 2)

    # Read payload length
    val payload_len = read_u32_le(buffer, 6)

    # Check if full frame available
    val frame_size = 10 + payload_len
    if buffer.len() < frame_size as i64:
        return Err("Incomplete frame")

    # Parse payload
    val handle = read_u32_le(buffer, 10)
    var params: [i64] = []

    val param_count = (payload_len - 4) / 8  # handle is 4 bytes, each param is 8
    for i in 0..param_count:
        val param_offset = 14 + i * 8
        val param = read_i64_le(buffer, param_offset as u32)
        params.push(param)

    val frame = SemihostFrame(op: op, handle: handle, params: params)
    Ok((frame, frame_size))

# ============================================================================
# String Formatting
# ============================================================================

# Format interned string with parameters
fn format_interned_string(fmt_str: text, types: [FormatType], params: [i64]) -> text:
    var result = fmt_str
    var param_idx: u64 = 0

    while result.contains("{}") and param_idx < params.len() as u64:
        val param = params[param_idx as i64]
        val fmt_type = if param_idx < types.len() as u64: types[param_idx as i64] else: FormatType.Int64

        val formatted = format_param(param, fmt_type)
        result = result.replace_first("{}", formatted)
        param_idx = param_idx + 1

    result

# Format single parameter based on type
fn format_param(value: i64, fmt_type: FormatType) -> text:
    match fmt_type:
        case FormatType.Void: ""
        case FormatType.Int8: (value as i8).to_string()
        case FormatType.Int16: (value as i16).to_string()
        case FormatType.Int32: (value as i32).to_string()
        case FormatType.Int64: value.to_string()
        case FormatType.UInt8: (value as u8).to_string()
        case FormatType.UInt16: (value as u16).to_string()
        case FormatType.UInt32: (value as u32).to_string()
        case FormatType.UInt64: (value as u64).to_string()
        case FormatType.Float32: f32.from_bits((value & 0xFFFFFFFF) as u32).to_string()
        case FormatType.Float64: f64.from_bits(value as u64).to_string()
        case FormatType.Bool: if value != 0: "true" else: "false"
        case FormatType.Char: char.from_u32(value as u32).to_string()
        case FormatType.Hex8: "0x{(value as u8):02x}"
        case FormatType.Hex16: "0x{(value as u16):04x}"
        case FormatType.Hex32: "0x{(value as u32):08x}"
        case FormatType.Hex64: "0x{(value as u64):016x}"
        case FormatType.Binary: "0b{value:b}"
        case FormatType.Pointer: "0x{(value as u64):016x}"
        case FormatType.Text: "[text:{value}]"  # Would lookup in string table

# ============================================================================
# Helper Functions
# ============================================================================

# Find all SMF files in directory tree
fn find_smf_files(root: text) -> [text]:
    var files: [text] = []

    val entries = dir_list(root)
    for entry in entries:
        val path = root + "/" + entry
        if entry.ends_with(".smf"):
            files.push(path)
        elif is_directory(path):
            val sub_files = find_smf_files(path)
            for f in sub_files:
                files.push(f)

    files

# Check if path is directory
fn is_directory(path: text) -> bool:
    # Use dir_list - if it returns non-empty, it's a directory
    val entries = dir_list(path)
    entries.len() > 0

# Extract StringIntern section from SMF file bytes
fn extract_string_intern_section(data: [u8]) -> [u8]?:
    # Proper SMF parsing requires full header/section table decoding.
    # Currently returns nil as the SMF binary format parser is not yet available.
    eprint("[WARNING] SMF section extraction not implemented; proper SMF header parsing required")
    nil

# Read little-endian u32
fn read_u32_le(data: [u8], offset: u32) -> u32:
    val b0 = data[offset as i64] as u32
    val b1 = data[(offset + 1) as i64] as u32
    val b2 = data[(offset + 2) as i64] as u32
    val b3 = data[(offset + 3) as i64] as u32
    b0 | (b1 << 8) | (b2 << 16) | (b3 << 24)

# Read little-endian i64
fn read_i64_le(data: [u8], offset: u32) -> i64:
    val lo = read_u32_le(data, offset) as i64
    val hi = read_u32_le(data, offset + 4) as i64
    lo | (hi << 32)

# Read single byte from stdin (blocking)
# Returns -1 on EOF
fn read_stdin_byte() -> i32:
    # Proper byte-level stdin reading requires SFFI support for raw I/O.
    # Return -1 (EOF) as a safe default until FFI is available.
    eprint("[WARNING] stdin byte reading not implemented; requires SFFI for raw I/O. Returning EOF.")
    -1

# Get current timestamp string
extern fn rt_time_now_unix_micros() -> i64

fn current_timestamp() -> text:
    val micros = rt_time_now_unix_micros()
    val total_secs = micros / 1000000
    val hours = (total_secs / 3600) % 24
    val mins = (total_secs / 60) % 60
    val secs = total_secs % 60
    val millis = (micros / 1000) % 1000
    "{hours}:{mins}:{secs}.{millis}"

# ============================================================================
# CLI Entry Point
# ============================================================================

# Main entry point for semi-host-reader command
fn run_reader(args: [text]) -> i32:
    var smf_root = "."
    var transport_type = TransportType.QEMU
    var host = "localhost"
    var port: u16 = 4444
    var serial_port = "/dev/ttyUSB0"
    var baud: u32 = 115200
    var file_path = ""
    var smt_file = ""
    var timestamps = false
    var json_output = false

    # Parse arguments
    var i: u64 = 0
    while i < args.len() as u64:
        val arg = args[i as i64]

        if arg.starts_with("--smf-root="):
            smf_root = arg.substring(11)
        elif arg.starts_with("--transport="):
            val t = arg.substring(12)
            match t:
                case "openocd": transport_type = TransportType.OpenOCD
                case "jlink": transport_type = TransportType.JLink
                case "trace32": transport_type = TransportType.Trace32
                case "qemu": transport_type = TransportType.QEMU
                case "serial": transport_type = TransportType.Serial
                case "file": transport_type = TransportType.File
                case _:
                    print "[ERROR] Unknown transport: {t}"
                    return 1
        elif arg.starts_with("--host="):
            host = arg.substring(7)
        elif arg.starts_with("--port="):
            port = arg.substring(7).parse_int() as u16
        elif arg.starts_with("--serial-port="):
            serial_port = arg.substring(14)
        elif arg.starts_with("--baud="):
            baud = arg.substring(7).parse_int() as u32
        elif arg.starts_with("--file="):
            file_path = arg.substring(7)
            transport_type = TransportType.File
        elif arg.starts_with("--smt-file="):
            smt_file = arg.substring(11)
        elif arg == "--timestamps":
            timestamps = true
        elif arg == "--json":
            json_output = true
        elif arg == "--help" or arg == "-h":
            print_help()
            return 0

        i = i + 1

    # Create transport
    val transport = match transport_type:
        case TransportType.OpenOCD: Transport.openocd(host, port)
        case TransportType.QEMU: Transport.qemu_serial()
        case TransportType.Serial: Transport.serial(serial_port, baud)
        case TransportType.File: Transport.file(file_path)
        case _: Transport.qemu_serial()

    # Create and run reader
    var reader = SemiHostReader.new(smf_root, transport)
    if smt_file != "":
        reader.load_smt_json_file(smt_file)
    if timestamps:
        reader = reader.with_timestamps()
    if json_output:
        reader = reader.with_json()

    reader.run()
    0

fn print_help():
    print "semi-host-reader - Host-side semihosting string reconstruction"
    print ""
    print "Usage:"
    print "  simple semi-host-reader [OPTIONS]"
    print ""
    print "Options:"
    print "  --smf-root=PATH     Path to SMF files (default: .)"
    print "  --transport=TYPE    Transport type: openocd, jlink, trace32, qemu, serial, file"
    print "  --host=HOST         OpenOCD host (default: localhost)"
    print "  --port=PORT         OpenOCD port (default: 4444)"
    print "  --serial-port=PATH  Serial port path (default: /dev/ttyUSB0)"
    print "  --baud=RATE         Serial baud rate (default: 115200)"
    print "  --file=PATH         Read from file (sets transport to file)"
    print "  --smt-file=PATH    Load string table from .smt JSON file"
    print "  --timestamps        Show timestamps in output"
    print "  --json              Output in JSON format"
    print "  --help, -h          Show this help"
    print ""
    print "Examples:"
    print "  simple semi-host-reader --smf-root=./build --transport=qemu"
    print "  simple semi-host-reader --smf-root=./build --transport=openocd --host=localhost --port=4444"
    print "  simple semi-host-reader --file=test_output.bin --smf-root=./build"
