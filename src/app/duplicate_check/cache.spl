# File-level token caching with timestamp-based invalidation

use app.duplicate_check.tokenizer.{SimpleToken}
use app.io.mod.{file_exists, shell}

struct TokenCache:
    file_path: text
    mtime: i64
    tokens: [SimpleToken]

struct TokenCacheManager:
    cache: {text: TokenCache}

fn new_token_cache_manager() -> TokenCacheManager:
    TokenCacheManager(cache: {})

fn get_file_mtime(file_path: text) -> i64:
    """Get file modification time in seconds since epoch."""
    val result = shell("stat -c %Y '{file_path}' 2>/dev/null || stat -f %m '{file_path}' 2>/dev/null || echo 0")
    val output = result.stdout.trim()
    int(output)

fn get_tokens_cached(manager: TokenCacheManager, file_path: text, tokenize_fn: fn(text) -> [SimpleToken]) -> [SimpleToken]:
    """Get tokens with caching. Returns cached tokens if file hasn't changed."""
    val current_mtime = get_file_mtime(file_path)

    if manager.cache.contains_key(file_path):
        val cached = manager.cache[file_path]
        if cached.mtime == current_mtime:
            return cached.tokens

    # Cache miss or invalidated - re-tokenize
    val tokens = tokenize_fn(file_path)

    # Update cache
    manager.cache[file_path] = TokenCache(
        file_path: file_path,
        mtime: current_mtime,
        tokens: tokens
    )

    tokens

fn invalidate_file(manager: TokenCacheManager, file_path: text):
    """Explicitly invalidate cache entry for a file."""
    if manager.cache.contains_key(file_path):
        var new_cache = {}
        for key in manager.cache.keys():
            if key != file_path:
                new_cache[key] = manager.cache[key]
        manager.cache = new_cache

fn clear_cache(manager: TokenCacheManager):
    """Clear all cached entries."""
    manager.cache = {}

fn get_cache_stats(manager: TokenCacheManager) -> text:
    """Get cache statistics as formatted string."""
    val entries = manager.cache.keys().len()

    var total_tokens = 0
    for key in manager.cache.keys():
        total_tokens = total_tokens + manager.cache[key].tokens.len()

    "Cache: {entries} files, {total_tokens} tokens"

export TokenCache, TokenCacheManager, new_token_cache_manager, get_tokens_cached, invalidate_file, clear_cache, get_cache_stats, get_file_mtime
