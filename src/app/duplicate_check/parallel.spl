# Parallel file processing for duplicate detection
#
# Processes multiple files concurrently while respecting shared state (cache, interner).
# Simplified from BuildGraph pattern since files have no inter-dependencies.

use app.duplicate_check.config.{DuplicationConfig}
use app.duplicate_check.tokenizer.{SimpleToken}
use app.duplicate_check.cache.{TokenCacheManager}
use app.duplicate_check.detector.{DuplicateBlock, find_duplicates_in_file}
use app.io.mod.{shell}

# Parallel processing configuration
struct ParallelConfig:
    num_workers: i64        # Number of parallel workers (0 = auto-detect)
    batch_size: i64         # Files per batch
    enabled: bool           # Enable parallel processing

fn default_parallel_config() -> ParallelConfig:
    ParallelConfig(
        num_workers: 0,      # Auto-detect CPU count
        batch_size: 10,       # Process 10 files per batch
        enabled: true
    )

fn single_threaded_config() -> ParallelConfig:
    ParallelConfig(
        num_workers: 1,
        batch_size: 1,
        enabled: false
    )

# Detect CPU count
fn detect_cpu_count() -> i64:
    val result = shell("nproc 2>/dev/null || echo 4")
    val output = result.stdout.trim()
    val count = int(output)
    if count > 0:
        count
    else:
        4  # Default to 4 if detection fails

# TODO: Parallel processing implementation
# Requires integration with detector.spl to avoid circular dependencies
# Will be implemented in Phase 2.1 completion

export ParallelConfig, default_parallel_config, single_threaded_config
export detect_cpu_count
