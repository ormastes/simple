# Doc comment and signature extraction from .spl files

use app.duplicate_check.config.{DuplicationConfig}
use app.duplicate_check.detector.{collect_files}
use app.io.mod.{file_read}
use std.text.{NL}
use std.encoding.{hash_string_fnv}

struct DocEntry:
    file_path: text
    line_number: i64
    item_name: text
    item_kind: text
    signature: text
    doc_comment: text
    has_doc: bool

fn extract_docs_from_file(file_path: text) -> [DocEntry]:
    val content = file_read(file_path) ?? ""
    if content.len() == 0:
        return []

    val lines = content.split(NL)
    var entries: [DocEntry] = []
    var pending_doc = ""
    var i = 0

    while i < lines.len():
        val line = lines[i]
        val trimmed = line.trim()

        # Collect doc comments (lines starting with #)
        if trimmed.starts_with("#") and not trimmed.starts_with("#!"):
            val comment_text = process_doc_line(trimmed)
            if pending_doc.len() > 0:
                pending_doc = pending_doc + " " + comment_text
            else:
                pending_doc = comment_text
            i = i + 1
            continue

        # Check for function definition
        val is_fn = trimmed.starts_with("fn ")
        val is_me = trimmed.starts_with("me ")
        val is_static_fn = trimmed.starts_with("static fn ")
        if is_fn or is_me or is_static_fn:
            val sig = extract_signature(trimmed)
            val name = extract_fn_name(trimmed)
            val has = pending_doc.len() > 0
            entries = entries + [DocEntry(
                file_path: file_path,
                line_number: i + 1,
                item_name: name,
                item_kind: "fn",
                signature: sig,
                doc_comment: pending_doc,
                has_doc: has
            )]
            pending_doc = ""
            i = i + 1
            continue

        # Check for struct definition
        if trimmed.starts_with("struct "):
            val name = extract_type_name(trimmed, "struct ")
            val has = pending_doc.len() > 0
            entries = entries + [DocEntry(
                file_path: file_path,
                line_number: i + 1,
                item_name: name,
                item_kind: "struct",
                signature: trimmed,
                doc_comment: pending_doc,
                has_doc: has
            )]
            pending_doc = ""
            i = i + 1
            continue

        # Check for class definition
        if trimmed.starts_with("class "):
            val name = extract_type_name(trimmed, "class ")
            val has = pending_doc.len() > 0
            entries = entries + [DocEntry(
                file_path: file_path,
                line_number: i + 1,
                item_name: name,
                item_kind: "class",
                signature: trimmed,
                doc_comment: pending_doc,
                has_doc: has
            )]
            pending_doc = ""
            i = i + 1
            continue

        # Check for enum definition
        if trimmed.starts_with("enum "):
            val name = extract_type_name(trimmed, "enum ")
            val has = pending_doc.len() > 0
            entries = entries + [DocEntry(
                file_path: file_path,
                line_number: i + 1,
                item_name: name,
                item_kind: "enum",
                signature: trimmed,
                doc_comment: pending_doc,
                has_doc: has
            )]
            pending_doc = ""
            i = i + 1
            continue

        # Non-doc line resets pending doc
        if trimmed.len() > 0:
            pending_doc = ""

        i = i + 1

    entries

fn extract_docs_from_directory(path: text, exclude: [text]) -> [DocEntry]:
    var config = DuplicationConfig(
        min_tokens: 0, min_lines: 0,
        ignore_identifiers: false, ignore_literals: false,
        ignore_comments: false, ignore_whitespace: false,
        similarity_threshold: 0.0, output_format: "text",
        report_path: "", max_allowed: 0, min_impact: 0,
        exclude_patterns: exclude,
        use_ast_features: false, use_cosine_similarity: false,
        verbose: false, quiet: true,
        use_parallel: false, num_workers: 0,
        use_incremental: false, incremental_cache_path: "",
        use_semantic: false, semantic_threshold: 0.90,
        semantic_drift_threshold: 0.40,
        semantic_model: "nomic-embed-text",
        ollama_url: "http://localhost:11434",
        rebuild_embeddings: false
    )
    val files = collect_files(path, config)
    var all_entries: [DocEntry] = []
    for file in files:
        val file_entries = extract_docs_from_file(file)
        all_entries = all_entries + file_entries
    all_entries

fn process_doc_line(raw: text) -> text:
    var s = raw
    # Strip leading # characters
    while s.starts_with("#"):
        s = s[1:]
    s.trim()

fn process_doc_text(raw: text) -> text:
    val lines = raw.split(NL)
    var parts: [text] = []
    for line in lines:
        val processed = process_doc_line(line)
        if processed.len() > 0:
            parts = parts + [processed]
    parts.join(" ")

fn extract_signature(line: text) -> text:
    # Extract up to the colon that ends the signature
    val colon_idx = find_signature_end(line)
    if colon_idx >= 0:
        return line[0:colon_idx].trim()
    line.trim()

fn find_signature_end(line: text) -> i64:
    var paren_depth = 0
    var i = 0
    while i < line.len():
        val ch = line[i:i+1]
        if ch == "(":
            paren_depth = paren_depth + 1
        elif ch == ")":
            paren_depth = paren_depth - 1
        elif ch == ":" and paren_depth == 0:
            return i
        i = i + 1
    -1

fn extract_fn_name(line: text) -> text:
    # Find "fn " and extract name after it
    var start = 0
    if line.contains("fn "):
        val idx = find_substr(line, "fn ")
        if idx >= 0:
            start = idx + 3

    # Read identifier
    var name = ""
    var i = start
    while i < line.len():
        val ch = line[i:i+1]
        val is_alpha = is_ident_char(ch)
        if is_alpha:
            name = name + ch
        else:
            break
        i = i + 1
    name

fn extract_type_name(line: text, prefix: text) -> text:
    val after = line[prefix.len():]
    var name = ""
    var i = 0
    while i < after.len():
        val ch = after[i:i+1]
        if is_ident_char(ch):
            name = name + ch
        else:
            break
        i = i + 1
    name

fn is_ident_char(ch: text) -> bool:
    if ch.len() != 1:
        return false
    val c = ch.bytes()[0]
    val is_lower = c >= 97 and c <= 122
    val is_upper = c >= 65 and c <= 90
    val is_digit = c >= 48 and c <= 57
    val is_underscore = c == 95
    is_lower or is_upper or is_digit or is_underscore

fn find_substr(haystack: text, needle: text) -> i64:
    var i = 0
    val max_i = haystack.len() - needle.len()
    while i <= max_i:
        if haystack[i:i+needle.len()] == needle:
            return i
        i = i + 1
    -1

fn build_embedding_key(entry: DocEntry) -> text:
    val sig_part = entry.signature
    val doc_part = entry.doc_comment
    if doc_part.len() > 0:
        sig_part + " | " + doc_part
    else:
        sig_part

fn content_hash(s: text) -> text:
    val h = hash_string_fnv(s)
    val abs_h = if h < 0: -h else: h
    "{abs_h}"

export DocEntry
export extract_docs_from_file, extract_docs_from_directory
export process_doc_text, build_embedding_key, content_hash
