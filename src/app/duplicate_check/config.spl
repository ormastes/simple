# Configuration handling for duplication detection

use app.io.mod.{file_exists, file_read}

struct DuplicationConfig:
    min_tokens: i64
    min_lines: i64
    ignore_identifiers: bool
    ignore_literals: bool
    ignore_comments: bool
    ignore_whitespace: bool
    similarity_threshold: f64
    output_format: text
    report_path: text
    max_allowed: i64
    min_impact: i64
    exclude_patterns: [text]
    use_ast_features: bool
    use_cosine_similarity: bool

fn default_config() -> DuplicationConfig:
    DuplicationConfig(
        min_tokens: 30,
        min_lines: 5,
        ignore_identifiers: true,
        ignore_literals: false,
        ignore_comments: true,
        ignore_whitespace: true,
        similarity_threshold: 0.85,
        output_format: "text",
        report_path: "doc/analysis/duplicate_db.sdn",
        max_allowed: 0,
        min_impact: 50,
        exclude_patterns: ["test/", "doc/", "**/*_spec.spl", "**/*_test.spl"],
        use_ast_features: false,
        use_cosine_similarity: false
    )

fn parse_config_file(content: text) -> DuplicationConfig:
    var config = default_config()

    val lines = content.split("\n")
    var in_section = false
    var in_exclude = false

    for line in lines:
        val trimmed = line.trim()

        if trimmed == "duplicate-check:":
            in_section = true
            continue

        if not in_section:
            continue

        if trimmed.starts_with("exclude:"):
            in_exclude = true
            config.exclude_patterns = []
            continue

        if in_exclude:
            if trimmed.starts_with("-"):
                var pattern = trimmed[1:].trim()
                var cleaned = ""
                var i = 0
                while i < pattern.len():
                    val ch = pattern[i:i+1]
                    if ch != "\"" and ch != "'":
                        cleaned = cleaned + ch
                    i = i + 1
                config.exclude_patterns = config.exclude_patterns + [cleaned]
            elif trimmed.contains(":"):
                in_exclude = false
            else:
                continue

        if trimmed.contains(":") and not in_exclude:
            val parts = trimmed.split(":")
            if parts.len() < 2:
                continue

            val key = parts[0].trim()
            var value = parts[1].trim()

            var clean_value = ""
            var i = 0
            while i < value.len():
                val ch = value[i:i+1]
                if ch != "\"" and ch != "'":
                    clean_value = clean_value + ch
                i = i + 1

            if key == "min-tokens":
                config.min_tokens = int(clean_value)
            elif key == "min-lines":
                config.min_lines = int(clean_value)
            elif key == "ignore-identifiers":
                config.ignore_identifiers = clean_value == "true"
            elif key == "ignore-literals":
                config.ignore_literals = clean_value == "true"
            elif key == "ignore-comments":
                config.ignore_comments = clean_value == "true"
            elif key == "ignore-whitespace":
                config.ignore_whitespace = clean_value == "true"
            elif key == "similarity-threshold":
                if clean_value == "0.80":
                    config.similarity_threshold = 0.80
                elif clean_value == "0.85":
                    config.similarity_threshold = 0.85
                elif clean_value == "0.90":
                    config.similarity_threshold = 0.90
                elif clean_value == "0.75":
                    config.similarity_threshold = 0.75
                elif clean_value == "0.70":
                    config.similarity_threshold = 0.70
                elif clean_value == "1.0" or clean_value == "1.00" or clean_value == "1":
                    config.similarity_threshold = 1.0
                else:
                    config.similarity_threshold = 0.85
            elif key == "output-format":
                config.output_format = clean_value
            elif key == "report-path":
                config.report_path = clean_value
            elif key == "max-allowed":
                config.max_allowed = int(clean_value)
            elif key == "min-impact":
                config.min_impact = int(clean_value)
            elif key == "use-ast-features":
                config.use_ast_features = clean_value == "true"
            elif key == "use-cosine-similarity":
                config.use_cosine_similarity = clean_value == "true"

    config

fn load_config() -> DuplicationConfig:
    val config_path = "simple.duplicate-check.sdn"

    if file_exists(config_path):
        val content = file_read(config_path)
        parse_config_file(content)
    else:
        default_config()

export DuplicationConfig, default_config, parse_config_file, load_config
