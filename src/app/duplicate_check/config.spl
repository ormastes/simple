# Configuration handling for duplication detection

struct DuplicationConfig:
    min_tokens: i64
    min_lines: i64
    ignore_identifiers: bool
    ignore_literals: bool
    ignore_comments: bool
    ignore_whitespace: bool
    similarity_threshold: f64
    output_format: text
    report_path: text
    max_allowed: i64
    min_impact: i64
    exclude_patterns: [text]
    use_ast_features: bool
    use_cosine_similarity: bool

fn default_config() -> DuplicationConfig:
    DuplicationConfig(
        min_tokens: 30,
        min_lines: 5,
        ignore_identifiers: true,
        ignore_literals: false,
        ignore_comments: true,
        ignore_whitespace: true,
        similarity_threshold: 0.85,
        output_format: "text",
        report_path: "doc/analysis/duplicate_db.sdn",
        max_allowed: 0,
        min_impact: 50,
        exclude_patterns: ["test/", "doc/", "**/*_spec.spl", "**/*_test.spl"],
        use_ast_features: false,
        use_cosine_similarity: false
    )

fn parse_config_file(content: text) -> DuplicationConfig:
    var config = default_config()

    val lines = content.split("\n")
    var in_section = false
    var in_exclude = false

    for line in lines:
        val trimmed = line.trim()

        if trimmed == "duplicate-check:":
            in_section = true
            continue

        if not in_section:
            continue

        if trimmed.starts_with("exclude:"):
            in_exclude = true
            config.exclude_patterns = []
            continue

        if in_exclude:
            if trimmed.starts_with("-"):
                val pattern = trimmed[1:].trim()
                val cleaned = pattern.replace("\"", "").replace("'", "")
                config.exclude_patterns = config.exclude_patterns + [cleaned]
            elif trimmed.contains(":"):
                in_exclude = false
            else:
                continue

        if trimmed.contains(":") and not in_exclude:
            val parts = trimmed.split(":")
            if parts.len() < 2:
                continue

            val key = parts[0].trim()
            val value = parts[1].trim()

            if key == "min-tokens":
                config.min_tokens = int(value)
            elif key == "min-lines":
                config.min_lines = int(value)
            elif key == "ignore-identifiers":
                config.ignore_identifiers = value == "true"
            elif key == "ignore-literals":
                config.ignore_literals = value == "true"
            elif key == "ignore-comments":
                config.ignore_comments = value == "true"
            elif key == "ignore-whitespace":
                config.ignore_whitespace = value == "true"
            elif key == "similarity-threshold":
                config.similarity_threshold = float(value)
            elif key == "output-format":
                config.output_format = value.replace("\"", "").replace("'", "")
            elif key == "report-path":
                config.report_path = value.replace("\"", "").replace("'", "")
            elif key == "max-allowed":
                config.max_allowed = int(value)
            elif key == "min-impact":
                config.min_impact = int(value)
            elif key == "use-ast-features":
                config.use_ast_features = value == "true"
            elif key == "use-cosine-similarity":
                config.use_cosine_similarity = value == "true"

    config

fn load_config() -> DuplicationConfig:
    val config_path = "simple.duplicate-check.sdn"

    if file_exists(config_path):
        val content = file_read(config_path)
        parse_config_file(content)
    else:
        default_config()

export config, DuplicationConfig, default_config, parse_config_file, load_config
