# Dashboard CLI â€” Data Collectors
#
# Extracted from main.spl. Contains:
# - collect_features, collect_todos, collect_tests, collect_plans, collect_coverage
# - compute_summary

use app.io.mod (file_read, file_write)
use app.dashboard.main.{load_table, load_table_named, header_index, get_field, count_eq, sum_int, count_nonempty, write_table, today_date, itos, DASHBOARD_TABLE_DIR}

fn collect_features():
    val src = load_table_named("doc/feature/feature_db.sdn", "features")
    val idx = header_index(src.headers)
    var rows: [[text]] = []
    val today = today_date()

    for row in src.rows:
        val valid = get_field(row, idx, "valid")
        if valid != "" and valid != "true":
            continue
        val id = get_field(row, idx, "id")
        if id == "":
            continue
        val category = get_field(row, idx, "category")
        val name = get_field(row, idx, "name")
        val status = get_field(row, idx, "status")
        rows.push([id, category, name, status, "", today])

    write_table("{DASHBOARD_TABLE_DIR}/features.sdn", "features",
        ["id", "category", "name", "status", "test_coverage", "last_updated"], rows)
    print "  [OK] Feature database"

fn collect_todos():
    val src = load_table_named("doc/todo/todo_db.sdn", "todos")
    val idx = header_index(src.headers)
    var rows: [[text]] = []
    val today = today_date()

    for row in src.rows:
        val valid = get_field(row, idx, "valid")
        if valid != "" and valid != "true":
            continue
        val id = get_field(row, idx, "id")
        if id == "":
            continue
        val keyword = get_field(row, idx, "keyword")
        val area = get_field(row, idx, "area")
        val priority = get_field(row, idx, "priority")
        val description = get_field(row, idx, "description")
        val file = get_field(row, idx, "file")
        val line = get_field(row, idx, "line")
        val issue = get_field(row, idx, "issue")
        val blocked = get_field(row, idx, "blocked")
        val status = get_field(row, idx, "status")
        rows.push([id, keyword, area, priority, description, file, line, issue, blocked, status, "0", "", today])

    write_table("{DASHBOARD_TABLE_DIR}/todos.sdn", "todos",
        ["id", "keyword", "area", "priority", "description", "file", "line", "issue", "blocked", "status", "age_days", "assigned", "last_updated"], rows)
    print "  [OK] TODO items"

fn collect_tests():
    val test_db = "doc/test/test_db.sdn"
    val strings = load_table_named(test_db, "strings")
    val files = load_table_named(test_db, "files")
    val suites = load_table_named(test_db, "suites")
    val tests = load_table_named(test_db, "tests")

    var strings_map = {}
    for row in strings.rows:
        if row.len() >= 2:
            strings_map[row[0]] = row[1]

    var file_map = {}
    for row in files.rows:
        if row.len() >= 2:
            val path_id = row[1]
            val path = if strings_map.has(path_id): strings_map[path_id] else: ""
            file_map[row[0]] = path

    var suite_file = {}
    var suite_title = {}
    for row in suites.rows:
        if row.len() >= 3:
            val suite_id = row[0]
            val file_id = row[1]
            val name_id = row[2]
            suite_file[suite_id] = if file_map.has(file_id): file_map[file_id] else: ""
            suite_title[suite_id] = if strings_map.has(name_id): strings_map[name_id] else: ""

    var suite_total = {}
    var suite_passed = {}
    var suite_failed = {}
    var suite_skipped = {}
    var suite_category = {}
    var suite_has_docs = {}

    for row in tests.rows:
        if row.len() < 8:
            continue
        val suite_id = row[1]
        val category_id = row[3]
        val status_id = row[4]
        val desc_id = row[6]
        val valid = row[7]
        if valid != "true" and valid != "":
            continue

        val status = if strings_map.has(status_id): strings_map[status_id] else: ""
        val category = if strings_map.has(category_id): strings_map[category_id] else: "unknown"
        val desc = if strings_map.has(desc_id): strings_map[desc_id] else: ""

        if suite_total.has(suite_id):
            suite_total[suite_id] = suite_total[suite_id] + 1
        else:
            suite_total[suite_id] = 1

        if status == "passed":
            if suite_passed.has(suite_id):
                suite_passed[suite_id] = suite_passed[suite_id] + 1
            else:
                suite_passed[suite_id] = 1
        elif status == "failed":
            if suite_failed.has(suite_id):
                suite_failed[suite_id] = suite_failed[suite_id] + 1
            else:
                suite_failed[suite_id] = 1
        elif status == "skipped" or status == "ignored":
            if suite_skipped.has(suite_id):
                suite_skipped[suite_id] = suite_skipped[suite_id] + 1
            else:
                suite_skipped[suite_id] = 1

        if not suite_category.has(suite_id) and category != "":
            suite_category[suite_id] = category

        if desc.trim() != "":
            suite_has_docs[suite_id] = "true"

    var sspec_rows: [[text]] = []
    var total_all = 0
    var passed_all = 0
    var failed_all = 0
    var skipped_all = 0
    var next_id = 1
    val today = today_date()

    for suite_id in suite_total.keys():
        val total = suite_total[suite_id]
        val passed = if suite_passed.has(suite_id): suite_passed[suite_id] else: 0
        val failed = if suite_failed.has(suite_id): suite_failed[suite_id] else: 0
        val skipped = if suite_skipped.has(suite_id): suite_skipped[suite_id] else: 0
        val status = if failed > 0: "failed" else: "passed"
        val file = if suite_file.has(suite_id): suite_file[suite_id] else: ""
        val title = if suite_title.has(suite_id): suite_title[suite_id] else: ""
        val category = if suite_category.has(suite_id): suite_category[suite_id] else: "unknown"
        val has_docs = if suite_has_docs.has(suite_id): suite_has_docs[suite_id] else: "false"

        sspec_rows.push([itos(next_id), file, title, category, "-", status, itos(total), itos(passed), itos(failed), "0", has_docs, today])
        next_id = next_id + 1

        total_all = total_all + total
        passed_all = passed_all + passed
        failed_all = failed_all + failed
        skipped_all = skipped_all + skipped

    write_table("{DASHBOARD_TABLE_DIR}/sspec_tests.sdn", "sspec_tests",
        ["id", "file", "title", "category", "difficulty", "status", "total_tests", "passed", "failed", "duration_ms", "has_docs", "last_run"], sspec_rows)

    val test_status_rows = [[
        "1", "sspec", "all", itos(total_all), itos(passed_all),
        itos(failed_all), itos(skipped_all), "0", today
    ]]
    write_table("{DASHBOARD_TABLE_DIR}/test_status.sdn", "test_status",
        ["id", "mode", "suite", "total", "passed", "failed", "skipped", "duration_ms", "timestamp"], test_status_rows)

    print "  [OK] Test results"

fn collect_plans():
    val src = load_table_named("doc/task/task_db.sdn", "tasks")
    val idx = header_index(src.headers)
    var rows: [[text]] = []
    val today = today_date()

    for row in src.rows:
        val valid = get_field(row, idx, "valid")
        if valid != "" and valid != "true":
            continue
        val id = get_field(row, idx, "id")
        if id == "":
            continue
        val title = get_field(row, idx, "name")
        val status = get_field(row, idx, "status")
        rows.push([id, "", title, status, "", today, "0", "0", ""])

    write_table("{DASHBOARD_TABLE_DIR}/plans.sdn", "plans",
        ["id", "file", "title", "status", "created", "last_updated", "total_steps", "completed_steps", "blocked"], rows)

fn collect_coverage():
    val src = load_table_named("build/coverage/coverage.sdn", "coverage")
    val rows = if src.rows.len() > 0: src.rows else: []
    write_table("{DASHBOARD_TABLE_DIR}/coverage.sdn", "coverage",
        ["id", "level", "crate", "file", "lines_total", "lines_covered", "lines_percent", "branches_covered", "branches_percent", "timestamp"], rows)
    print "  [OK] Coverage data"

fn compute_summary() -> Dict<text, text>:
    val feature_table = load_table("{DASHBOARD_TABLE_DIR}/features.sdn")
    val todo_table = load_table("{DASHBOARD_TABLE_DIR}/todos.sdn")
    val test_table = load_table("{DASHBOARD_TABLE_DIR}/test_status.sdn")
    val coverage_table = load_table("{DASHBOARD_TABLE_DIR}/coverage.sdn")

    val feature_idx = header_index(feature_table.headers)
    val todo_idx = header_index(todo_table.headers)
    val test_idx = header_index(test_table.headers)
    val coverage_idx = header_index(coverage_table.headers)

    val features_total = feature_table.rows.len()
    val features_complete = count_eq(feature_table.rows, feature_idx, "status", "complete")
    val features_in_progress = count_eq(feature_table.rows, feature_idx, "status", "in_progress")
    val features_planned = count_eq(feature_table.rows, feature_idx, "status", "planned")

    val todos_total = todo_table.rows.len()
    val todos_open = count_eq(todo_table.rows, todo_idx, "status", "open")
    val todos_blocked = count_nonempty(todo_table.rows, todo_idx, "blocked")

    val tests_total = sum_int(test_table.rows, test_idx, "total")
    val tests_passed = sum_int(test_table.rows, test_idx, "passed")
    val tests_failed = sum_int(test_table.rows, test_idx, "failed")
    val tests_skipped = sum_int(test_table.rows, test_idx, "skipped")

    val lines_total = sum_int(coverage_table.rows, coverage_idx, "lines_total")
    val lines_covered = sum_int(coverage_table.rows, coverage_idx, "lines_covered")
    val coverage_pct = if lines_total > 0: (lines_covered * 100) / lines_total else: 0

    {
        "features_total": itos(features_total),
        "features_complete": itos(features_complete),
        "features_in_progress": itos(features_in_progress),
        "features_planned": itos(features_planned),
        "todos_total": itos(todos_total),
        "todos_open": itos(todos_open),
        "todos_blocked": itos(todos_blocked),
        "tests_total": itos(tests_total),
        "tests_passed": itos(tests_passed),
        "tests_failed": itos(tests_failed),
        "tests_skipped": itos(tests_skipped),
        "lines_total": itos(lines_total),
        "lines_covered": itos(lines_covered),
        "coverage_pct": itos(coverage_pct)
    }
