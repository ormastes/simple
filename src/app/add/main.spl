# Simple CLI - add command
# Adds a dependency to simple.sdn manifest

use std.cli.cli_util (get_cli_args)

use app.io.mod (file_exists, file_read, file_write, cwd)
use std.log.{error, warn, info, debug}

fn print_help():
    print "Usage: simple add <package> [options]"
    print ""
    print "Add a dependency to simple.sdn"
    print ""
    print "Arguments:"
    print "  <package>            Package name (e.g., http)"
    print "  <package>@<version>  Package with version constraint (e.g., http@^1.0.0)"
    print ""
    print "Options:"
    print "  --dev                Add as dev dependency"
    print "  --path=<dir>         Add as path dependency"
    print "  --git=<url>          Add as git dependency"
    print "  --branch=<name>      Git branch (default: main)"
    print "  --tag=<name>         Git tag"
    print "  -h, --help           Show this help"

fn find_manifest_path() -> text:
    val cwd = cwd()
    val sdn_path = "{cwd}/simple.sdn"
    val toml_path = "{cwd}/simple.toml"
    if file_exists(sdn_path):
        return sdn_path
    if file_exists(toml_path):
        return toml_path
    ""

fn parse_package_spec(spec: text) -> (text, text):
    # Parse "name@constraint" or just "name"
    val parts = spec.split("@")
    if parts.len() > 1:
        return (parts[0], parts[1])
    (spec, "*")

fn add_dependency_to_sdn(content: text, name: text, constraint: text, is_dev: bool, path_dep: text, git_dep: text, git_branch: text, git_tag: text) -> text:
    # Build the dependency entry
    var dep_entry = ""
    if path_dep != "":
        dep_entry = "  {name}:\n    path: {path_dep}\n"
    elif git_dep != "":
        dep_entry = "  {name}:\n    git: {git_dep}\n"
        if git_tag != "":
            dep_entry = dep_entry + "    tag: {git_tag}\n"
        elif git_branch != "":
            dep_entry = dep_entry + "    branch: {git_branch}\n"
    elif constraint == "*":
        dep_entry = "  {name}: *\n"
    else:
        dep_entry = "  {name}: {constraint}\n"

    val section = if is_dev: "dev_dependencies" else: "dependencies"
    val section_header = "{section}:\n"

    # Check if section exists
    if content.contains("{section}:"):
        # Find the section and append before next section or end
        val lines = content.split("\n")
        var result = []
        var in_section = false
        var inserted = false
        for line in lines:
            if line.starts_with("{section}:"):
                in_section = true
                result.push(line)
            elif in_section and not inserted:
                if line.trim() == "" or (not line.starts_with("  ") and not line.starts_with("\t") and line.trim() != ""):
                    # End of section - insert before this line
                    result.push(dep_entry.trim_end())
                    inserted = true
                    in_section = false
                    result.push(line)
                else:
                    result.push(line)
            else:
                result.push(line)
        if not inserted:
            result.push(dep_entry.trim_end())
        result.join("\n")
    else:
        # Add new section at end
        content.trim_end() + "\n\n" + section_header + dep_entry

fn main() -> i64:
    val args = get_cli_args()

    if args.len() == 0:
        error("add", "missing package name")
        print ""
        print_help()
        return 1

    # Parse flags
    var is_dev = false
    var path_dep = ""
    var git_dep = ""
    var git_branch = "main"
    var git_tag = ""
    var package_spec = ""

    for arg in args:
        if arg == "-h" or arg == "--help":
            print_help()
            return 0
        elif arg == "--dev":
            is_dev = true
        elif arg.starts_with("--path="):
            path_dep = arg[7:]
        elif arg.starts_with("--git="):
            git_dep = arg[6:]
        elif arg.starts_with("--branch="):
            git_branch = arg[9:]
        elif arg.starts_with("--tag="):
            git_tag = arg[6:]
        elif not arg.starts_with("-"):
            package_spec = arg

    if package_spec == "":
        error("add", "missing package name")
        return 1

    val manifest_path = find_manifest_path()
    if manifest_path == "":
        error("add", "no simple.sdn or simple.toml found in current directory")
        print "Run 'simple init' to create a project first."
        return 1

    val (name, constraint) = parse_package_spec(package_spec)

    # Read current manifest
    val content = file_read(manifest_path)

    # Check if dependency already exists
    if content.contains("  {name}:") or content.contains("  {name} "):
        error("add", "dependency '{name}' already exists in manifest")
        print "Use 'simple update {name}' to change the version."
        return 1

    # Add dependency
    val new_content = add_dependency_to_sdn(content, name, constraint, is_dev, path_dep, git_dep, git_branch, git_tag)

    if not file_write(manifest_path, new_content):
        error("add", "failed to write {manifest_path}")
        return 1

    val section = if is_dev: "dev dependency" else: "dependency"
    if path_dep != "":
        print "Added {section} '{name}' (path: {path_dep})"
    elif git_dep != "":
        print "Added {section} '{name}' (git: {git_dep})"
    else:
        print "Added {section} '{name}' ({constraint})"
    0
