# @tag:api @tag:tool
# Application Layer - Self-hosted Simple Tools
#
# This module provides the application layer of the Simple compiler ecosystem.
# All applications are written in pure Simple (.spl files), with no Rust dependencies.
#
# Architecture:
# - **Build Tools**: Compiler driver, formatter, linter, release automation
# - **Development**: LSP server, debugger (DAP), REPL, test runner
# - **MCP Servers**: Model Context Protocol servers for AI integration
# - **I/O Layer**: File, directory, process, environment operations (SFFI-based)
# - **Package Management**: Dependency resolution, lockfiles, registry
# - **CLI Utilities**: Argument parsing, stats, coverage, profiling
# - **Code Transformation**: Desugar, FFI generator, wrapper generator
#
# Key Modules:
# - `app.io` - File I/O, process execution, environment variables (SFFI wrappers)
# - `app.cli` - Command-line interface and subcommands
# - `app.cli_parser` - Declarative CLI argument parsing with auto-help
# - `app.build` - Build system orchestration (compile, test, lint, format)
# - `app.test_runner_new` - SSpec test framework runner with SDoctest support
# - `app.mcp` - MCP server for Simple language integration
# - `app.mcp_jj` - MCP server for Jujutsu version control
# - `app.lsp` - Language Server Protocol implementation
# - `app.dap` - Debug Adapter Protocol implementation
# - `app.desugar` - Static method desugaring and AST transformations
# - `app.package` - Package management (semver, manifest, lockfile)
# - `app.stats` - Codebase statistics and documentation coverage
# - `app.verify` - Code verification and quality checks
# - `app.depgraph` - Dependency graph analysis and visualization
#
# Deprecated:
# - `app.interpreter` - REMOVED. Use `core.interpreter` instead for tree-walk
#   interpretation, or `core.interpreter.jit` for JIT-enabled interpretation.
#
# Examples:
#
#     # File I/O operations using app.io
#     use app.io.{file_read, file_write, dir_list}
#
#     fn save_config(path: text, content: text):
#         file_write(path, content)
#
#     fn load_files(directory: text) -> [text]:
#         val entries = dir_list(directory)
#         entries
#
#     # CLI argument parsing using app.cli_parser
#     use app.cli_parser.{cli_spec, parse_cli_args}
#
#     fn main(args: [text]):
#         val spec = cli_spec()
#         var spec2 = spec.flag("verbose", "v", "Show detailed output")
#         var spec3 = spec2.option("output", "o", "Output file", default: "")
#         val parsed = parse_cli_args(spec3, args)
#
#         val verbose = parsed.flag("verbose")
#         val output = parsed.option("output")
#
#         if verbose:
#             print "Running in verbose mode"
#         if output != "":
#             print "Output will be written to: {output}"
#
# See Also:
# - `src/app/README.md` - Comprehensive application module documentation
# - `doc/guide/cli_reference.md` - Command-line interface guide
# - `doc/guide/mcp_servers.md` - MCP server usage and integration
# - `CLAUDE.md` - Development workflow and project conventions
