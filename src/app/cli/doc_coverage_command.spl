# Doc Coverage Command Implementation
#
# Provides CLI interface for documentation coverage analysis and SDoctest reporting.

use app.io.mod (file_write, file_exists, cwd, shell)
use app.doc_coverage.scanner.mod.{scan_file_for_docs, discover_source_files, DocItem}
use app.doc_coverage.scanner.file_scanner (filter_public_only)
use app.doc_coverage.analysis.sdoctest_coverage.{load_sdoctest_blocks, suggest_missing_tags, compute_sdoctest_coverage}
use app.doc_coverage.analysis.init_parser.{parse_init_file, PublicApiGroup, PublicApiItem}
use app.doc_coverage.analysis.group_sdoctest.{check_group_sdoctest}
use app.doc_coverage.reporting.mod (export_coverage_json, export_coverage_csv, generate_coverage_markdown, render_coverage_terminal)
use app.doc_coverage.types.coverage_result.{CoverageReport, FileCoverage}
use std.string.{NL}

# =========================================================================
# CLI Entry Point
# =========================================================================

fn handle_doc_coverage_command(args: [text]) -> i64:
    """
    Handle doc-coverage command.

    Flags:
        --check-public-api Check public API SDoctest coverage
        --sdoctest-report  Generate SDoctest coverage report
        --tag-file=FILE    Export missing tags to file
        --format=text|json|csv|md|terminal  Output format
        --missing          Show only missing documentation
        --tag=X            Filter by tag

    Returns: Exit code (0 = success, 1 = error)
    """
    var check_public_api = false
    var sdoctest_report = false
    var tag_file = ""
    var format = "terminal"
    var root = cwd()
    var show_missing = false
    var tag_filter = ""

    # Parse arguments
    var i = 1
    while i < args.len():
        val arg = args[i]
        if arg == "--check-public-api":
            check_public_api = true
        elif arg == "--sdoctest-report":
            sdoctest_report = true
        elif arg == "--missing":
            show_missing = true
        elif arg.starts_with("--tag-file="):
            tag_file = arg[11:]
        elif arg.starts_with("--format="):
            format = arg[9:]
        elif arg.starts_with("--tag="):
            tag_filter = arg[6:]
        elif not arg.starts_with("-"):
            root = arg
        i = i + 1

    # Handle public API checking
    if check_public_api:
        return handle_public_api_check(root, show_missing)

    # Discover source files
    val patterns: [text] = []
    val all_files = discover_source_files(root, patterns)
    val files = filter_public_only(all_files)

    if files.len() == 0:
        print "No source files found in {root}"
        return 1

    # Load sdoctest blocks
    val sdoctest_result = load_sdoctest_blocks()
    val sdoctest_blocks = sdoctest_result.1

    # Scan files for documentation items
    if format == "terminal":
        print "Scanning {files.len()} source files..."

    var all_items: [DocItem] = []

    var j = 0
    while j < files.len():
        val file_path = files[j]
        val items = scan_file_for_docs(file_path)
        var k = 0
        while k < items.len():
            all_items.push(items[k])
            k = k + 1
        j = j + 1

    # Compute full coverage report
    val coverage = compute_sdoctest_coverage(all_items, sdoctest_blocks)

    # Generate SDoctest coverage report if requested (legacy format)
    if sdoctest_report:
        return generate_sdoctest_report(all_items, files, tag_file, format)

    # New reporting system: handle different formats
    match format:
        "json":
            val json_output = export_coverage_json(coverage, true)
            print json_output
            return 0

        "csv":
            val csv_output = generate_csv_output(coverage)
            print csv_output
            return 0

        "md":
            val md_output = generate_coverage_markdown(coverage)
            print md_output
            return 0

        "terminal":
            val terminal_output = render_coverage_terminal(coverage)
            print terminal_output
            return 0

        _:
            # Default: terminal output
            val terminal_output = render_coverage_terminal(coverage)
            print terminal_output
            return 0

    0

# =========================================================================
# SDoctest Report Generation
# =========================================================================

fn generate_sdoctest_report(items: [DocItem], files: [text], tag_file: text, format: text) -> i64:
    """
    Generate SDoctest coverage report.

    Args:
        items: All documented items
        files: Source file paths
        tag_file: Path to export tags (empty = no export)
        format: Output format (text only)

    Returns: Exit code
    """
    print "Loading SDoctest blocks..."
    val blocks_result = load_sdoctest_blocks()
    val block_names = blocks_result.0
    val block_codes = blocks_result.1

    print "Found {block_codes.len()} SDoctest blocks"
    print ""

    # Count functions with sdoctest coverage
    var public_funcs = 0
    var covered_funcs = 0

    var i = 0
    while i < items.len():
        val item = items[i]
        val is_func = item.kind == "fn"
        val is_static = item.kind == "static fn"
        if is_func or is_static:
            public_funcs = public_funcs + 1

            # Check if function name appears in any block
            val func_name = item.name
            val in_blocks = function_in_blocks(func_name, block_codes)
            if in_blocks:
                covered_funcs = covered_funcs + 1
        i = i + 1

    val missing = public_funcs - covered_funcs
    val percent = compute_percent(covered_funcs, public_funcs)

    # Display report
    print "SDoctest Coverage Report"
    print "========================"
    print "Total public functions: {public_funcs}"
    print "With sdoctest: {covered_funcs} ({percent}%)"
    print "Missing: {missing}"
    print ""

    # Show missing tags if requested
    if tag_file != "":
        val export_result = export_missing_tags(files, tag_file)
        if export_result == 0:
            print ""
            print "Missing tags exported to: {tag_file}"

    0

fn function_in_blocks(func_name: text, blocks: [text]) -> bool:
    """Check if function name appears in any SDoctest block."""
    var i = 0
    while i < blocks.len():
        val block = blocks[i]
        if block.contains(func_name):
            return true
        i = i + 1
    false

# =========================================================================
# Coverage Summary Display
# =========================================================================

fn print_coverage_summary(items: [DocItem]):
    """Display overall coverage summary for all items."""
    var total = items.len()
    var documented = 0
    var public_funcs = 0

    var i = 0
    while i < items.len():
        val item = items[i]
        val has_doc = item.has_inline_comment or item.has_docstring
        if has_doc:
            documented = documented + 1
        val is_func = item.kind == "fn"
        val is_static = item.kind == "static fn"
        if is_func or is_static:
            public_funcs = public_funcs + 1
        i = i + 1

    val missing = total - documented
    val percent = compute_percent(documented, total)

    print "Documentation Coverage Summary"
    print "=============================="
    print "Total items: {total}"
    print "Documented: {documented} ({percent}%)"
    print "Missing: {missing}"
    print ""
    print "Public functions: {public_funcs}"

# =========================================================================
# Tag Export
# =========================================================================

fn export_missing_tags(files: [text], output_path: text) -> i64:
    """
    Export missing SDoctest tags to a file.

    Args:
        files: Source file paths
        output_path: Path to write tags

    Returns: Exit code
    """
    var tags: [text] = []

    # Generate suggested tags for each file
    var i = 0
    while i < files.len():
        val file_path = files[i]
        val suggested = suggest_missing_tags(file_path)
        var j = 0
        while j < suggested.len():
            tags.push(suggested[j])
            j = j + 1
        i = i + 1

    # Write to file
    var content = "# Missing SDoctest Tags{NL}# Auto-generated tag suggestions{NL}{NL}"
    var k = 0
    while k < tags.len():
        content = content + tags[k] + NL
        k = k + 1

    val write_ok = file_write(output_path, content)
    if not write_ok:
        print "Error: Failed to write tags to {output_path}"
        return 1

    0

# =========================================================================
# New Reporting System Helpers
# =========================================================================

fn generate_csv_output(coverage: CoverageReport) -> text:
    """Generate CSV output from coverage report."""
    # Collect all items from all files
    var all_items: [DocItem] = []

    val files = coverage.files
    var i = 0
    while i < files.len():
        val file_cov = files[i]
        val items = file_cov.items

        var j = 0
        while j < items.len():
            all_items.push(items[j])
            j = j + 1

        i = i + 1

    export_coverage_csv(all_items)

# =========================================================================
# Utility Functions
# =========================================================================

fn compute_percent(count: i64, total: i64) -> i64:
    """Compute percentage as integer."""
    if total == 0:
        return 100
    val ratio = count * 100 / total
    ratio

# =========================================================================
# Public API Coverage Checking
# =========================================================================

fn handle_public_api_check(root: text, show_missing: bool) -> i64:
    """
    Check public API SDoctest coverage.

    Args:
        root: Root directory to scan
        show_missing: Show only missing coverage

    Returns: Exit code (0 = all covered, 1 = missing coverage)
    """
    print "Checking public API SDoctest coverage..."
    print ""

    # Find all __init__.spl files
    val init_files = find_init_files(root)

    if init_files.len() == 0:
        print "No __init__.spl files found in {root}"
        return 0

    # Load SDoctest blocks
    val blocks_result = load_sdoctest_blocks()
    val sdoctest_blocks = blocks_result.1

    # Track totals
    var total_groups = 0
    var covered_groups = 0
    var total_items = 0
    var covered_items = 0

    # Check each __init__.spl file
    for init_file in init_files:
        val result = parse_init_file(init_file)
        val groups = result.0
        val items = result.1

        # Check groups
        for group in groups:
            total_groups = total_groups + 1
            val has_coverage = check_group_sdoctest(group, sdoctest_blocks)
            if has_coverage:
                covered_groups = covered_groups + 1
            else:
                if show_missing or not has_coverage:
                    print "❌ Group '{group.group_name}' missing SDoctest"
                    print "   File: {group.file_path}:{group.group_line}"
                    print "   Items: {group.items.len()} functions"
                    print ""

        # Check individual items
        for item in items:
            total_items = total_items + 1
            val has_coverage = item_in_blocks(item.name, sdoctest_blocks)
            if has_coverage:
                covered_items = covered_items + 1
            else:
                if show_missing or not has_coverage:
                    print "❌ Item '{item.name}' missing SDoctest"
                    print "   File: {item.file_path}:{item.line}"
                    print ""

    # Print summary
    val group_pct = compute_percent(covered_groups, total_groups)
    val item_pct = compute_percent(covered_items, total_items)

    print "Public API SDoctest Coverage Summary"
    print "===================================="
    print "Groups: {covered_groups}/{total_groups} ({group_pct}%)"
    print "Individual items: {covered_items}/{total_items} ({item_pct}%)"
    print ""

    # Return exit code
    val all_covered = covered_groups == total_groups and covered_items == total_items
    if all_covered:
        print "✅ All public APIs have SDoctest coverage"
        return 0
    else:
        val missing_groups = total_groups - covered_groups
        val missing_items = total_items - covered_items
        print "⚠️  Missing coverage for {missing_groups} groups and {missing_items} items"
        return 1

fn find_init_files(root: text) -> [text]:
    """Find all __init__.spl files under root directory."""
    val result = shell("find {root} -name '__init__.spl' -type f 2>/dev/null || true")
    val stdout = result.stdout
    val trimmed = stdout.trim()

    if trimmed == "":
        var empty: [text] = []
        return empty

    val lines = trimmed.split(NL)
    lines

fn item_in_blocks(name: text, blocks: [text]) -> bool:
    """Check if item name appears in any SDoctest block."""
    for block in blocks:
        if block.contains(name):
            return true
    false

# =========================================================================
# Exports
# =========================================================================

export handle_doc_coverage_command
