# Simple Language - Unified CLI (Written in Simple)
#
# This is the main entry point for the Simple CLI, written in Simple itself.
# Most functionality is implemented in Simple; FFI is only used for runtime operations.
#
# Usage like Python:
#   simple              - Start interactive REPL
#   simple file.spl     - Run source file
#   simple file.smf     - Run compiled binary
#   simple -c "code"    - Run code string

use app.cli_util (get_cli_args)
use app.io.mod (file_exists, file_write, dir_create, cwd, env_get, shell, file_size_raw,
    cli_file_exists, cli_read_file,
    cli_run_code, cli_run_file, cli_watch_file, cli_run_repl, cli_run_tests,
    cli_run_lint, cli_run_fmt, cli_run_fix, cli_run_verify,
    cli_run_migrate, cli_run_mcp, cli_run_diff, cli_constr, cli_run_query, cli_info,
    cli_run_spec_coverage, cli_replay, cli_gen_lean, cli_run_feature_gen,
    cli_run_task_gen, cli_run_spec_gen, cli_run_sspec_docgen, cli_todo_scan,
    cli_run_todo_gen, cli_run_lex, cli_run_brief, cli_run_ffi_gen, cli_run_i18n,
    cli_compile, cli_handle_web, cli_handle_diagram, cli_handle_run,
    fault_set_stack_overflow_detection, fault_set_max_recursion_depth,
    fault_set_timeout, fault_set_execution_limit)
use app.build.cli_entry (handle_build)
use app.cli.check (run_check)  # New type checking implementation
use app.stats.dynamic (run_stats)
use std.path as path
use std.db_atomic.{atomic_write, DbConfig}
#   simple compile src.spl [-o out.smf]  - Compile to SMF
#   simple watch file.spl  - Watch and auto-recompile

# =========================================================================
# Version and Help - implemented in Simple
# =========================================================================
fn get_version() -> str:
    val version = env_get("SIMPLE_VERSION")
    if version != "" and version != nil:
        return version
    "0.5.0"

fn print_version():
    val v = get_version()
    print "Simple v{v}"

fn print_help():
    val v = get_version()
    print "Simple Language v{v}"
    print ""
    print "Usage:"
    print "  simple                      Start interactive TUI REPL (default)"
    print "  simple --notui              Start Normal REPL (rustyline-based)"
    print "  simple <file.spl>           Run source file"
    print "  simple <file.smf>           Run compiled binary"
    print "  simple -c \"code\"            Run code string"
    print "  simple compile <src> [-o <out>] [options]  Compile source file"
    print "  simple compile <src> --format=self-contained -o <out>  Self-contained binary"
    print "  simple watch <file.spl>     Watch and auto-recompile"
    print "  simple targets              List available target architectures"
    print "  simple linkers              List available native linkers"
    print ""
    print "Testing:"
    print "  simple test [path]          Run tests (default: test/)"
    print "  simple test --unit          Run unit tests only"
    print "  simple test --integration   Run integration tests only"
    print "  simple test --system        Run system tests only"
    print "  simple test --tag <name>    Filter by tag"
    print "  simple test --fail-fast     Stop on first failure"
    print "  simple test --format <fmt>  Output format: text, json, doc"
    print "  simple test --list-skip-features  List features from .skip files"
    print "  simple test --planned-only  Filter to planned features only"
    print ""
    print "Code Quality:"
    print "  simple lex <file.spl>       Tokenize file (Simple lexer)"
    print "  simple lint [path]          Run linter on file or directory"
    print "  simple lint --fix           Apply auto-fixes"
    print "  simple duplicate-check [path]  Detect code duplication"
    print "  simple fmt [path]           Format file or directory"
    print "  simple fmt --check          Check formatting without changes"
    print "  simple check [path]         Type check without running (NEW: Full type inference)"
    print "  simple check --show-types   Show inferred types"
    print "  simple check --verbose      Verbose type checking output"
    print ""
    print "LLM-Friendly Tools:"
    print "  simple mcp <file.spl>       Generate minimal code preview"
    print "  simple diff <old> <new>     Semantic diff"
    print "  simple brief <path>         Brief view for LLM context"
    print "  simple query --generated    Find LLM-generated code"
    print ""
    print "Project Statistics:"
    print "  simple stats                Show project metrics (files, lines, tests, features)"
    print "  simple stats --brief        Show condensed statistics (no docs section)"
    print "  simple stats --verbose      Show detailed statistics (with directory info)"
    print "  simple stats --quick        Skip line counting (faster)"
    print "  simple stats --json         Output as JSON (for CI/CD integration)"
    print ""
    print "Verification:"
    print "  simple verify <file.spl>    Run formal verification"
    print "  simple gen-lean generate    Generate Lean verification files"
    print ""
    print "FFI Generation:"
    print "  simple ffi-gen <file.spl>   Generate FFI wrappers from @Lib annotations"
    print "  simple wrapper-gen <spec>   Generate C++ wrapper (three-tier SFFI)"
    print ""
    print "Build System:"
    print "  simple build [options]      Build the project"
    print "  simple build test           Run tests"
    print "  simple build clean          Clean build artifacts"
    print ""
    print "Package Management:"
    print "  simple init [name]          Create a new project"
    print "  simple add <pkg> [options]  Add a dependency"
    print "  simple remove <pkg>         Remove a dependency"
    print "  simple install              Install all dependencies"
    print "  simple update [pkg]         Update dependencies"
    print "  simple list                 List installed dependencies"
    print "  simple tree                 Show dependency tree"
    print ""
    print "Options:"
    print "  -h, --help     Show this help"
    print "  -v, --version  Show version"
    print "  -c <code>      Run code string"
    print "  --notui        Use Normal REPL instead of TUI"
    print "  --gc-log       Enable verbose GC logging"
    print "  --gc-off       Disable garbage collection"
    print ""
    print "Execution Mode:"
    print "  --backend=auto|cranelift|llvm  Select JIT backend (default: auto)"
    print "  --interpret                    Force interpreter mode (no JIT)"
    print "  --interpret-optimized          Interpreter mode without GC/FFI overhead"
    print "  --interpreter-mode=classic|optimized  Select interpreter mode"
    print "  SIMPLE_EXECUTION_MODE env var  jit|interpret|interpret-optimized|cranelift|llvm"
    print ""
    print "Fault Detection:"
    print "  --stack-overflow-detection     Enable recursion depth check"
    print "  --no-stack-overflow-detection  Disable recursion depth check"
    print "  --max-recursion-depth=N        Set max call depth (default: 1000)"
    print "  --timeout=N                    Set wall-clock timeout in seconds"
    print "  --execution-limit=N            Set instruction count limit"
    print ""
    print "Examples:"
    print "  simple                      # Start REPL"
    print "  simple hello.spl            # Run source"
    print "  simple -c \"print 42\"        # Run expression"
    print "  simple compile app.spl      # Compile to native"
    print "  simple test                 # Run all tests"

# =========================================================================
# Target architectures - implemented in Simple
# =========================================================================
fn print_targets():
    print "Available target architectures:"
    print ""
    print "  x86_64    64-bit x86 (default on most systems)"
    print "  aarch64   64-bit ARM (Apple Silicon, ARM servers)"
    print "  i686      32-bit x86"
    print "  armv7     32-bit ARM"
    print "  riscv64   64-bit RISC-V"
    print "  riscv32   32-bit RISC-V"
    print ""
    print "Usage:"
    print "  simple compile app.spl --target aarch64"

# =========================================================================
# Native linkers - implemented in Simple
# =========================================================================
fn print_linkers():
    print "Available native linkers:"
    print ""
    print "  mold      Modern linker (fastest, recommended)"
    print "  lld       LLVM linker (fast, widely available)"
    print "  ld        GNU linker (default, always available)"
    print ""
    print "The linker is auto-detected if not specified."
    print "Preference order: mold > lld > ld"
    print ""
    print "Usage:"
    print "  simple compile app.spl --linker mold"

# =========================================================================
# Error messages - implemented in Simple
# =========================================================================
fn print_error(msg: str):
    print "error: {msg}"

fn print_error_with_help(msg: str):
    print "error: {msg}"
    print ""
    print_help()

# =========================================================================
# Simple Lexer - delegates to Rust runtime
# =========================================================================

fn run_lex_command(path: str) -> i64:
    val args = get_cli_args()
    cli_run_lex(args)

# Global flags struct
struct GlobalFlags:
    gc_log: bool
    gc_off: bool
    use_notui: bool
    max_recursion_depth: i64
    timeout_secs: i64
    execution_limit: i64
    stack_overflow_detection: bool
    backend: text        # "auto", "cranelift", "llvm" - JIT backend selection
    force_interpret: bool  # --interpret flag to force interpreter mode
    interpreter_mode: text  # "classic" or "optimized" - interpreter mode selection

fn parse_global_flags(args: [str]) -> GlobalFlags:
    var gc_log = false
    var gc_off = false
    var use_notui = false
    var max_recursion_depth = 0
    var timeout_secs = 0
    var execution_limit = 0
    var stack_overflow_detection = false
    var has_stack_overflow_flag = false
    var backend = "auto"
    var force_interpret = false
    var interpreter_mode = "classic"

    var i = 0
    while i < args.len():
        val arg = args[i]
        if arg == "--gc-log":
            gc_log = true
        elif arg == "--gc-off":
            gc_off = true
        elif arg == "--notui":
            use_notui = true
        elif arg == "--interpret":
            force_interpret = true
        elif arg == "--interpret-optimized":
            force_interpret = true
            interpreter_mode = "optimized"
        elif arg.starts_with("--interpreter-mode="):
            interpreter_mode = arg[19:]
        elif arg == "--interpreter-mode" and i + 1 < args.len():
            i = i + 1
            interpreter_mode = args[i]
        elif arg.starts_with("--backend="):
            backend = arg[10:]
        elif arg == "--backend" and i + 1 < args.len():
            i = i + 1
            backend = args[i]
        elif arg == "--stack-overflow-detection":
            stack_overflow_detection = true
            has_stack_overflow_flag = true
        elif arg == "--no-stack-overflow-detection":
            stack_overflow_detection = false
            has_stack_overflow_flag = true
        elif arg.starts_with("--max-recursion-depth="):
            val val_str = arg[21:]
            max_recursion_depth = val_str.to_int()
        elif arg == "--max-recursion-depth" and i + 1 < args.len():
            i = i + 1
            max_recursion_depth = args[i].to_int()
        elif arg.starts_with("--timeout="):
            val val_str = arg[10:]
            timeout_secs = val_str.to_int()
        elif arg == "--timeout" and i + 1 < args.len():
            i = i + 1
            timeout_secs = args[i].to_int()
        elif arg.starts_with("--execution-limit="):
            val val_str = arg[18:]
            execution_limit = val_str.to_int()
        elif arg == "--execution-limit" and i + 1 < args.len():
            i = i + 1
            execution_limit = args[i].to_int()
        i = i + 1

    # Check SIMPLE_EXECUTION_MODE env var as fallback
    if not force_interpret and backend == "auto":
        val env_mode = env_get("SIMPLE_EXECUTION_MODE")
        if env_mode == "interpret":
            force_interpret = true
        elif env_mode == "interpret-optimized":
            force_interpret = true
            interpreter_mode = "optimized"
        elif env_mode == "cranelift":
            backend = "cranelift"
        elif env_mode == "llvm":
            backend = "llvm"
        elif env_mode == "jit":
            backend = "auto"

    GlobalFlags(gc_log: gc_log, gc_off: gc_off, use_notui: use_notui,
        max_recursion_depth: max_recursion_depth, timeout_secs: timeout_secs,
        execution_limit: execution_limit, stack_overflow_detection: stack_overflow_detection,
        backend: backend, force_interpret: force_interpret,
        interpreter_mode: interpreter_mode)

fn apply_fault_detection(flags: GlobalFlags):
    if flags.max_recursion_depth > 0:
        fault_set_max_recursion_depth(flags.max_recursion_depth)
        fault_set_stack_overflow_detection(true)
    if flags.stack_overflow_detection:
        fault_set_stack_overflow_detection(true)
    if flags.timeout_secs > 0:
        fault_set_timeout(flags.timeout_secs)
    if flags.execution_limit > 0:
        fault_set_execution_limit(flags.execution_limit)

fn filter_internal_flags(args: [str]) -> [str]:
    var result = []
    var skip_next = false
    for arg in args:
        if skip_next:
            skip_next = false
        elif arg == "--max-recursion-depth" or arg == "--timeout" or arg == "--execution-limit" or arg == "--interpreter-mode":
            skip_next = true
        elif not arg.starts_with("--gc") and arg != "--notui" and arg != "--lang" and arg != "--stack-overflow-detection" and arg != "--no-stack-overflow-detection" and arg != "--interpret" and arg != "--interpret-optimized":
            if not arg.starts_with("--lang=") and not arg.starts_with("--max-recursion-depth=") and not arg.starts_with("--timeout=") and not arg.starts_with("--execution-limit=") and not arg.starts_with("--interpreter-mode"):
                # Keep --backend flags (used by both JIT and compile commands)
                result.push(arg)
    result

# =========================================================================
# Init command - implemented in Simple
# =========================================================================

fn handle_init(args: [str]) -> i64:
    val current_dir = cwd()

    # Check if already initialized
    if file_exists("{current_dir}/simple.sdn"):
        print_error("Project already initialized (simple.sdn exists)")
        return 1
    if file_exists("{current_dir}/simple.toml"):
        print_error("Project already initialized (simple.toml exists)")
        return 1

    # Determine project name from args or directory name
    # args[0] is "init" command itself, args[1+] are actual arguments
    var name = ""
    if args.len() > 1:
        name = args[1]
    else:
        name = path.basename(current_dir)
    if name == "":
        name = "my-project"

    # Write simple.sdn manifest atomically
    val manifest = "# Simple Package Manifest\n# SDN (Simple Data Notation) format\n\npackage:\n  name: {name}\n  version: 0.1.0\n  license: MIT\n  main: src/main.spl\n"
    val write_result = atomic_write("{current_dir}/simple.sdn", manifest, DbConfig__defaults())
    if write_result.err.?:
        print_error("Failed to write simple.sdn: {write_result.unwrap_err()}")
        return 1

    # Create src directory
    if not dir_create("{current_dir}/src", true):
        print_error("Failed to create src/ directory")
        return 1

    # Write src/main.spl if it doesn't exist
    val main_path = "{current_dir}/src/main.spl"
    if not file_exists(main_path):
        val main_content = "# Simple Language Project\n# Run with: simple run\n\nfn main() -> i32:\n    print(\"Hello, Simple!\")\n    return 0\n"
        if not file_write(main_path, main_content):
            print_error("Failed to write src/main.spl")
            return 1

    print "Initialized Simple project '{name}'"
    return 0

fn check_self_contained() -> bool:
    # Check if this binary is a self-contained executable (runtime + SMF)
    # by reading the last 32 bytes and looking for "SMFE" magic.
    #
    # Self-contained binary format:
    #   [Runtime Binary] [SMF Data] [32-byte Trailer]
    #   Trailer: "SMFE"(4) + smf_offset(8) + smf_size(8) + checksum(8) + version(4)
    #
    # If detected, extract and execute the embedded SMF data.

    # Get own executable path
    val exe_path_result = shell("readlink -f /proc/self/exe 2>/dev/null")
    if exe_path_result.exit_code != 0:
        return false

    val exe_path = exe_path_result.stdout.replace("\n", "")
    if exe_path == "":
        return false

    # Quick size check: must be > 32 bytes
    val size = file_size_raw(exe_path)
    if size < 33:
        return false

    # Read last 4 bytes to check magic "SMFE" (83 77 70 69)
    val trailer_offset = size - 32
    val magic_result = shell("dd if='{exe_path}' bs=1 skip={trailer_offset} count=4 2>/dev/null | od -A n -t x1 | tr -d ' \\n'")
    if magic_result.exit_code != 0:
        return false

    val magic_hex = magic_result.stdout.replace("\n", "")
    if magic_hex != "534d4645":
        return false

    # This is a self-contained binary - extract SMF offset and size from trailer
    # Read full 32-byte trailer as hex
    val trailer_result = shell("dd if='{exe_path}' bs=1 skip={trailer_offset} count=32 2>/dev/null | od -A n -t x1 | tr -d ' \\n'")
    if trailer_result.exit_code != 0:
        return false

    # For now, delegate to the runtime's SMF loader by running:
    #   bin/bootstrap/simple --run-embedded-smf <exe_path>
    # When SMF loader is available in Simple, load and execute directly.
    eprint("[WARNING] SMF loader not yet available in Simple; cannot load embedded SMF directly")
    print "[self-contained] Detected embedded SMF in {exe_path}"
    print "[self-contained] Self-contained execution not yet fully implemented"
    print "[self-contained] Use: simple run <file.smf> to run SMF modules"
    true

fn main() -> i64:
    val args = get_cli_args()

    # Early check: is this a self-contained binary?
    # Only check when no args are passed (self-contained binaries run directly)
    # or when args don't start with a known subcommand
    if args.len() == 0:
        if check_self_contained():
            return 0

    val flags = parse_global_flags(args)
    apply_fault_detection(flags)
    val filtered_args = filter_internal_flags(args)

    if filtered_args.len() == 0:
        return cli_run_repl(flags.gc_log, flags.gc_off)

    val first = filtered_args[0]

    match first:
        case "-h" | "--help":
            print_help()
            return 0

        case "-v" | "--version":
            print_version()
            return 0

        case "-c":
            if filtered_args.len() < 2:
                print_error("-c requires a code argument")
                return 1
            return cli_run_code(filtered_args[1], flags.gc_log, flags.gc_off)

        case "compile":
            return cli_compile(filtered_args)

        case "targets":
            print_targets()
            return 0

        case "linkers":
            print_linkers()
            return 0

        case "web":
            return cli_handle_web(filtered_args)

        case "watch":
            if filtered_args.len() < 2:
                print_error("watch requires a source file")
                return 1
            return cli_watch_file(filtered_args[1])

        case "test":
            val test_args = filtered_args[1:]
            return cli_run_tests(test_args, flags.gc_log, flags.gc_off)

        case "lex":
            if filtered_args.len() < 2:
                print_error("lex requires a source file")
                return 1
            return run_lex_command(filtered_args[1])

        case "lint":
            return cli_run_lint(filtered_args)

        case "duplicate-check":
            return cli_run_file("src/app/duplicate_check/main.spl", filtered_args, flags.gc_log, flags.gc_off)

        case "fix":
            return cli_run_fix(filtered_args)

        case "fmt":
            return cli_run_fmt(filtered_args)

        case "check":
            val check_args = filtered_args[1:]
            return run_check(check_args)  # Use new type inference system

        case "i18n":
            return cli_run_i18n(filtered_args)

        case "migrate":
            return cli_run_migrate(filtered_args)

        case "mcp":
            return cli_run_mcp(filtered_args)

        case "diff":
            return cli_run_diff(filtered_args)

        case "constr":
            return cli_constr(filtered_args)

        case "query":
            return cli_run_query(filtered_args)

        case "info":
            return cli_info(filtered_args)

        case "spec-coverage":
            return cli_run_spec_coverage(filtered_args)

        case "replay":
            return cli_replay(filtered_args)

        case "gen-lean":
            return cli_gen_lean(filtered_args)

        case "feature-gen":
            return cli_run_feature_gen(filtered_args)

        case "task-gen":
            return cli_run_task_gen(filtered_args)

        case "spec-gen":
            return cli_run_spec_gen(filtered_args)

        case "sspec-docgen":
            return cli_run_sspec_docgen(filtered_args)

        case "todo-scan":
            return cli_todo_scan(filtered_args)

        case "todo-gen":
            return cli_run_todo_gen(filtered_args)

        case "brief":
            return cli_run_brief(filtered_args)

        case "stats":
            run_stats(filtered_args[1:])
            return 0

        case "ffi-gen":
            return cli_run_ffi_gen(filtered_args)

        case "wrapper-gen":
            return cli_run_file("src/app/wrapper_gen/mod.spl", filtered_args, flags.gc_log, flags.gc_off)

        case "desugar":
            return cli_run_file("src/app/desugar/mod.spl", filtered_args, flags.gc_log, flags.gc_off)

        case "dashboard":
            print "Dashboard command - implementation in progress"
            return 0

        case "verify":
            return cli_run_verify(filtered_args, flags.gc_log, flags.gc_off)

        case "diagram":
            return cli_handle_diagram(filtered_args)

        case "build":
            val build_args = filtered_args[1:]
            return handle_build(build_args)

        case "init":
            return handle_init(filtered_args)

        case "add":
            return cli_run_file("src/app/add/main.spl", filtered_args, flags.gc_log, flags.gc_off)

        case "remove":
            return cli_run_file("src/app/remove/main.spl", filtered_args, flags.gc_log, flags.gc_off)

        case "install":
            return cli_run_file("src/app/install/main.spl", filtered_args, flags.gc_log, flags.gc_off)

        case "update":
            return cli_run_file("src/app/update/main.spl", filtered_args, flags.gc_log, flags.gc_off)

        case "list":
            return cli_run_file("src/app/list/main.spl", filtered_args, flags.gc_log, flags.gc_off)

        case "tree":
            return cli_run_file("src/app/tree/main.spl", filtered_args, flags.gc_log, flags.gc_off)

        case "cache":
            return cli_run_file("src/app/cache/main.spl", filtered_args, flags.gc_log, flags.gc_off)

        case "env":
            return cli_run_file("src/app/env/main.spl", filtered_args, flags.gc_log, flags.gc_off)

        case "lock":
            return cli_run_file("src/app/lock/main.spl", filtered_args, flags.gc_log, flags.gc_off)

        case "run":
            return cli_handle_run(filtered_args, flags.gc_log, flags.gc_off)

        case _:
            if cli_file_exists(first):
                var program_args = [first]
                var j = 1
                while j < filtered_args.len():
                    program_args.push(filtered_args[j])
                    j = j + 1
                return cli_run_file(first, program_args, flags.gc_log, flags.gc_off)
            else:
                print_error_with_help("file not found: {first}")
                return 1
