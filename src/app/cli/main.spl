# Simple Language - Unified CLI (Written in Simple)
#
# This is the main entry point for the Simple CLI, written in Simple itself.
# Most functionality is implemented in Simple; FFI is only used for runtime operations.
#
# Usage like Python:
#   simple              - Start interactive REPL
#   simple file.spl     - Run source file
#   simple file.smf     - Run compiled binary
#   simple -c "code"    - Run code string
#   simple compile src.spl [-o out.smf]  - Compile to SMF
#   simple watch file.spl  - Watch and auto-recompile

# =========================================================================
# Version and Help - implemented in Simple
# =========================================================================
fn get_version() -> str:
    "0.1.0"

fn print_version():
    val v = get_version()
    print "Simple v{v}"

fn print_help():
    val v = get_version()
    print "Simple Language v{v}"
    print ""
    print "Usage:"
    print "  simple                      Start interactive TUI REPL (default)"
    print "  simple --notui              Start Normal REPL (rustyline-based)"
    print "  simple <file.spl>           Run source file"
    print "  simple <file.smf>           Run compiled binary"
    print "  simple -c \"code\"            Run code string"
    print "  simple compile <src> [-o <out>] [options]  Compile source file"
    print "  simple watch <file.spl>     Watch and auto-recompile"
    print "  simple targets              List available target architectures"
    print "  simple linkers              List available native linkers"
    print ""
    print "Testing:"
    print "  simple test [path]          Run tests (default: test/)"
    print "  simple test --unit          Run unit tests only"
    print "  simple test --integration   Run integration tests only"
    print "  simple test --system        Run system tests only"
    print "  simple test --tag <name>    Filter by tag"
    print "  simple test --fail-fast     Stop on first failure"
    print "  simple test --format <fmt>  Output format: text, json, doc"
    print "  simple test --list-skip-features  List features from .skip files"
    print "  simple test --planned-only  Filter to planned features only"
    print ""
    print "Code Quality:"
    print "  simple lex <file.spl>       Tokenize file (Simple lexer)"
    print "  simple lint [path]          Run linter on file or directory"
    print "  simple lint --fix           Apply auto-fixes"
    print "  simple fmt [path]           Format file or directory"
    print "  simple fmt --check          Check formatting without changes"
    print "  simple check [path]         Type check without running"
    print ""
    print "LLM-Friendly Tools:"
    print "  simple mcp <file.spl>       Generate minimal code preview"
    print "  simple diff <old> <new>     Semantic diff"
    print "  simple brief <path>         Brief view for LLM context"
    print "  simple query --generated    Find LLM-generated code"
    print ""
    print "Verification:"
    print "  simple verify <file.spl>    Run formal verification"
    print "  simple gen-lean generate    Generate Lean verification files"
    print ""
    print "Package Management:"
    print "  simple init [name]          Create a new project"
    print "  simple add <pkg> [options]  Add a dependency"
    print "  simple remove <pkg>         Remove a dependency"
    print "  simple install              Install all dependencies"
    print "  simple update [pkg]         Update dependencies"
    print "  simple list                 List installed dependencies"
    print "  simple tree                 Show dependency tree"
    print ""
    print "Options:"
    print "  -h, --help     Show this help"
    print "  -v, --version  Show version"
    print "  -c <code>      Run code string"
    print "  --notui        Use Normal REPL instead of TUI"
    print "  --gc-log       Enable verbose GC logging"
    print "  --gc-off       Disable garbage collection"
    print ""
    print "Examples:"
    print "  simple                      # Start REPL"
    print "  simple hello.spl            # Run source"
    print "  simple -c \"print 42\"        # Run expression"
    print "  simple compile app.spl      # Compile to native"
    print "  simple test                 # Run all tests"

# =========================================================================
# Target architectures - implemented in Simple
# =========================================================================
fn print_targets():
    print "Available target architectures:"
    print ""
    print "  x86_64    64-bit x86 (default on most systems)"
    print "  aarch64   64-bit ARM (Apple Silicon, ARM servers)"
    print "  i686      32-bit x86"
    print "  armv7     32-bit ARM"
    print "  riscv64   64-bit RISC-V"
    print "  riscv32   32-bit RISC-V"
    print ""
    print "Usage:"
    print "  simple compile app.spl --target aarch64"

# =========================================================================
# Native linkers - implemented in Simple
# =========================================================================
fn print_linkers():
    print "Available native linkers:"
    print ""
    print "  mold      Modern linker (fastest, recommended)"
    print "  lld       LLVM linker (fast, widely available)"
    print "  ld        GNU linker (default, always available)"
    print ""
    print "The linker is auto-detected if not specified."
    print "Preference order: mold > lld > ld"
    print ""
    print "Usage:"
    print "  simple compile app.spl --linker mold"

# =========================================================================
# Error messages - implemented in Simple
# =========================================================================
fn print_error(msg: str):
    print "error: {msg}"

fn print_error_with_help(msg: str):
    print "error: {msg}"
    print ""
    print_help()

# =========================================================================
# Simple Lexer - delegates to Rust runtime
# =========================================================================

fn run_lex_command(path: str) -> i64:
    val args = rt_cli_get_args()
    rt_cli_run_lex(args)

# =========================================================================
# FFI - only for operations requiring Rust runtime
# =========================================================================
extern fn rt_cli_get_args() -> [str]
extern fn rt_cli_file_exists(path: str) -> bool
extern fn rt_cli_read_file(path: str) -> str

# Code execution
extern fn rt_cli_run_code(code: str, gc_log: bool, gc_off: bool) -> i64
extern fn rt_cli_run_file(path: str, args: [str], gc_log: bool, gc_off: bool) -> i64
extern fn rt_cli_watch_file(path: str) -> i64
extern fn rt_cli_run_repl(gc_log: bool, gc_off: bool) -> i64

# Testing
extern fn rt_cli_run_tests(args: [str], gc_log: bool, gc_off: bool) -> i64

# Code quality
extern fn rt_cli_run_lint(args: [str]) -> i64
extern fn rt_cli_run_fmt(args: [str]) -> i64
extern fn rt_cli_run_check(args: [str]) -> i64

# Verification
extern fn rt_cli_run_verify(args: [str], gc_log: bool, gc_off: bool) -> i64

# Migration and tooling
extern fn rt_cli_run_migrate(args: [str]) -> i64
extern fn rt_cli_run_mcp(args: [str]) -> i64
extern fn rt_cli_run_diff(args: [str]) -> i64
extern fn rt_cli_run_constr(args: [str]) -> i64

# Analysis
extern fn rt_cli_run_query(args: [str]) -> i64
extern fn rt_cli_run_info(args: [str]) -> i64

# Auditing
extern fn rt_cli_run_spec_coverage(args: [str]) -> i64
extern fn rt_cli_run_replay(args: [str]) -> i64

# Code generation
extern fn rt_cli_run_gen_lean(args: [str]) -> i64
extern fn rt_cli_run_feature_gen(args: [str]) -> i64
extern fn rt_cli_run_task_gen(args: [str]) -> i64
extern fn rt_cli_run_spec_gen(args: [str]) -> i64
extern fn rt_cli_run_sspec_docgen(args: [str]) -> i64
extern fn rt_cli_run_todo_scan(args: [str]) -> i64
extern fn rt_cli_run_todo_gen(args: [str]) -> i64

# Lexer
extern fn rt_cli_run_lex(args: [str]) -> i64

# Brief view
extern fn rt_cli_run_brief(args: [str]) -> i64

# i18n
extern fn rt_cli_run_i18n(args: [str]) -> i64

# Compilation
extern fn rt_cli_handle_compile(args: [str]) -> i64

# Web framework
extern fn rt_cli_handle_web(args: [str]) -> i64

# Diagram generation
extern fn rt_cli_handle_diagram(args: [str]) -> i64

# Package management
extern fn rt_cli_handle_init(args: [str]) -> i64
extern fn rt_cli_handle_add(args: [str]) -> i64
extern fn rt_cli_handle_remove(args: [str]) -> i64
extern fn rt_cli_handle_install() -> i64
extern fn rt_cli_handle_update(args: [str]) -> i64
extern fn rt_cli_handle_list() -> i64
extern fn rt_cli_handle_tree() -> i64
extern fn rt_cli_handle_cache(args: [str]) -> i64

# Environment management
extern fn rt_cli_handle_env(args: [str]) -> i64

# Lock file management
extern fn rt_cli_handle_lock(args: [str]) -> i64

# Explicit run command
extern fn rt_cli_handle_run(args: [str], gc_log: bool, gc_off: bool) -> i64

# Global flags struct
struct GlobalFlags:
    gc_log: bool
    gc_off: bool
    use_notui: bool

fn parse_global_flags(args: [str]) -> GlobalFlags:
    var gc_log = false
    var gc_off = false
    var use_notui = false

    for arg in args:
        if arg == "--gc-log":
            gc_log = true
        elif arg == "--gc-off":
            gc_off = true
        elif arg == "--notui":
            use_notui = true

    GlobalFlags(gc_log: gc_log, gc_off: gc_off, use_notui: use_notui)

fn filter_internal_flags(args: [str]) -> [str]:
    var result = []
    for arg in args:
        if not arg.starts_with("--gc") and arg != "--notui" and arg != "--lang":
            if not arg.starts_with("--lang="):
                result.push(arg)
    result

fn main() -> i64:
    val all_args = rt_cli_get_args()

    var args = []
    var start_idx = 1
    if all_args.len() > 1 and all_args[1].ends_with("main.spl"):
        start_idx = 2
    var i = start_idx
    while i < all_args.len():
        args.push(all_args[i])
        i = i + 1

    val flags = parse_global_flags(args)
    val filtered_args = filter_internal_flags(args)

    if filtered_args.len() == 0:
        return rt_cli_run_repl(flags.gc_log, flags.gc_off)

    val first = filtered_args[0]

    match first:
        case "-h" | "--help":
            print_help()
            return 0

        case "-v" | "--version":
            print_version()
            return 0

        case "-c":
            if filtered_args.len() < 2:
                print_error("-c requires a code argument")
                return 1
            return rt_cli_run_code(filtered_args[1], flags.gc_log, flags.gc_off)

        case "compile":
            return rt_cli_handle_compile(filtered_args)

        case "targets":
            print_targets()
            return 0

        case "linkers":
            print_linkers()
            return 0

        case "web":
            return rt_cli_handle_web(filtered_args)

        case "watch":
            if filtered_args.len() < 2:
                print_error("watch requires a source file")
                return 1
            return rt_cli_watch_file(filtered_args[1])

        case "test":
            val test_args = filtered_args[1:]
            return rt_cli_run_tests(test_args, flags.gc_log, flags.gc_off)

        case "lex":
            if filtered_args.len() < 2:
                print_error("lex requires a source file")
                return 1
            return run_lex_command(filtered_args[1])

        case "lint":
            return rt_cli_run_lint(filtered_args)

        case "fmt":
            return rt_cli_run_fmt(filtered_args)

        case "check":
            val check_args = filtered_args[1:]
            return rt_cli_run_check(check_args)

        case "i18n":
            return rt_cli_run_i18n(filtered_args)

        case "migrate":
            return rt_cli_run_migrate(filtered_args)

        case "mcp":
            return rt_cli_run_mcp(filtered_args)

        case "diff":
            return rt_cli_run_diff(filtered_args)

        case "constr":
            return rt_cli_run_constr(filtered_args)

        case "query":
            return rt_cli_run_query(filtered_args)

        case "info":
            return rt_cli_run_info(filtered_args)

        case "spec-coverage":
            return rt_cli_run_spec_coverage(filtered_args)

        case "replay":
            return rt_cli_run_replay(filtered_args)

        case "gen-lean":
            return rt_cli_run_gen_lean(filtered_args)

        case "feature-gen":
            return rt_cli_run_feature_gen(filtered_args)

        case "task-gen":
            return rt_cli_run_task_gen(filtered_args)

        case "spec-gen":
            return rt_cli_run_spec_gen(filtered_args)

        case "sspec-docgen":
            return rt_cli_run_sspec_docgen(filtered_args)

        case "todo-scan":
            return rt_cli_run_todo_scan(filtered_args)

        case "todo-gen":
            return rt_cli_run_todo_gen(filtered_args)

        case "brief":
            return rt_cli_run_brief(filtered_args)

        case "dashboard":
            print "Dashboard command - implementation in progress"
            return 0

        case "verify":
            return rt_cli_run_verify(filtered_args, flags.gc_log, flags.gc_off)

        case "diagram":
            return rt_cli_handle_diagram(filtered_args)

        case "init":
            return rt_cli_handle_init(filtered_args)

        case "add":
            return rt_cli_handle_add(filtered_args)

        case "remove":
            return rt_cli_handle_remove(filtered_args)

        case "install":
            return rt_cli_handle_install()

        case "update":
            return rt_cli_handle_update(filtered_args)

        case "list":
            return rt_cli_handle_list()

        case "tree":
            return rt_cli_handle_tree()

        case "cache":
            return rt_cli_handle_cache(filtered_args)

        case "env":
            return rt_cli_handle_env(filtered_args)

        case "lock":
            return rt_cli_handle_lock(filtered_args)

        case "run":
            return rt_cli_handle_run(filtered_args, flags.gc_log, flags.gc_off)

        case _:
            if rt_cli_file_exists(first):
                var program_args = [first]
                var j = 1
                while j < filtered_args.len():
                    program_args.push(filtered_args[j])
                    j = j + 1
                return rt_cli_run_file(first, program_args, flags.gc_log, flags.gc_off)
            else:
                print_error_with_help("file not found: {first}")
                return 1
