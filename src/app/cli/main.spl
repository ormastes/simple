# Simple Language - Unified CLI (Written in Simple)
#
# This is the main entry point for the Simple CLI, written in Simple itself.
# Most functionality is implemented in Simple; FFI is only used for runtime operations.
#
# Usage like Python:
#   simple              - Start interactive REPL
#   simple file.spl     - Run source file
#   simple file.smf     - Run compiled binary
#   simple -c "code"    - Run code string

use app.cli_util (get_cli_args)
use app.build.cli_entry (handle_build)
#   simple compile src.spl [-o out.smf]  - Compile to SMF
#   simple watch file.spl  - Watch and auto-recompile

# =========================================================================
# Version and Help - implemented in Simple
# =========================================================================
fn get_version() -> str:
    "0.1.0"

fn print_version():
    val v = get_version()
    print "Simple v{v}"

fn print_help():
    val v = get_version()
    print "Simple Language v{v}"
    print ""
    print "Usage:"
    print "  simple                      Start interactive TUI REPL (default)"
    print "  simple --notui              Start Normal REPL (rustyline-based)"
    print "  simple <file.spl>           Run source file"
    print "  simple <file.smf>           Run compiled binary"
    print "  simple -c \"code\"            Run code string"
    print "  simple compile <src> [-o <out>] [options]  Compile source file"
    print "  simple watch <file.spl>     Watch and auto-recompile"
    print "  simple targets              List available target architectures"
    print "  simple linkers              List available native linkers"
    print ""
    print "Testing:"
    print "  simple test [path]          Run tests (default: test/)"
    print "  simple test --unit          Run unit tests only"
    print "  simple test --integration   Run integration tests only"
    print "  simple test --system        Run system tests only"
    print "  simple test --tag <name>    Filter by tag"
    print "  simple test --fail-fast     Stop on first failure"
    print "  simple test --format <fmt>  Output format: text, json, doc"
    print "  simple test --list-skip-features  List features from .skip files"
    print "  simple test --planned-only  Filter to planned features only"
    print ""
    print "Code Quality:"
    print "  simple lex <file.spl>       Tokenize file (Simple lexer)"
    print "  simple lint [path]          Run linter on file or directory"
    print "  simple lint --fix           Apply auto-fixes"
    print "  simple fmt [path]           Format file or directory"
    print "  simple fmt --check          Check formatting without changes"
    print "  simple check [path]         Type check without running"
    print ""
    print "LLM-Friendly Tools:"
    print "  simple mcp <file.spl>       Generate minimal code preview"
    print "  simple diff <old> <new>     Semantic diff"
    print "  simple brief <path>         Brief view for LLM context"
    print "  simple query --generated    Find LLM-generated code"
    print ""
    print "Verification:"
    print "  simple verify <file.spl>    Run formal verification"
    print "  simple gen-lean generate    Generate Lean verification files"
    print ""
    print "FFI Generation:"
    print "  simple ffi-gen <file.spl>   Generate FFI wrappers from @Lib annotations"
    print ""
    print "Build System:"
    print "  simple build [options]      Build the project"
    print "  simple build test           Run tests"
    print "  simple build clean          Clean build artifacts"
    print ""
    print "Package Management:"
    print "  simple init [name]          Create a new project"
    print "  simple add <pkg> [options]  Add a dependency"
    print "  simple remove <pkg>         Remove a dependency"
    print "  simple install              Install all dependencies"
    print "  simple update [pkg]         Update dependencies"
    print "  simple list                 List installed dependencies"
    print "  simple tree                 Show dependency tree"
    print ""
    print "Options:"
    print "  -h, --help     Show this help"
    print "  -v, --version  Show version"
    print "  -c <code>      Run code string"
    print "  --notui        Use Normal REPL instead of TUI"
    print "  --gc-log       Enable verbose GC logging"
    print "  --gc-off       Disable garbage collection"
    print ""
    print "Fault Detection:"
    print "  --stack-overflow-detection     Enable recursion depth check"
    print "  --no-stack-overflow-detection  Disable recursion depth check"
    print "  --max-recursion-depth=N        Set max call depth (default: 1000)"
    print "  --timeout=N                    Set wall-clock timeout in seconds"
    print "  --execution-limit=N            Set instruction count limit"
    print ""
    print "Examples:"
    print "  simple                      # Start REPL"
    print "  simple hello.spl            # Run source"
    print "  simple -c \"print 42\"        # Run expression"
    print "  simple compile app.spl      # Compile to native"
    print "  simple test                 # Run all tests"

# =========================================================================
# Target architectures - implemented in Simple
# =========================================================================
fn print_targets():
    print "Available target architectures:"
    print ""
    print "  x86_64    64-bit x86 (default on most systems)"
    print "  aarch64   64-bit ARM (Apple Silicon, ARM servers)"
    print "  i686      32-bit x86"
    print "  armv7     32-bit ARM"
    print "  riscv64   64-bit RISC-V"
    print "  riscv32   32-bit RISC-V"
    print ""
    print "Usage:"
    print "  simple compile app.spl --target aarch64"

# =========================================================================
# Native linkers - implemented in Simple
# =========================================================================
fn print_linkers():
    print "Available native linkers:"
    print ""
    print "  mold      Modern linker (fastest, recommended)"
    print "  lld       LLVM linker (fast, widely available)"
    print "  ld        GNU linker (default, always available)"
    print ""
    print "The linker is auto-detected if not specified."
    print "Preference order: mold > lld > ld"
    print ""
    print "Usage:"
    print "  simple compile app.spl --linker mold"

# =========================================================================
# Error messages - implemented in Simple
# =========================================================================
fn print_error(msg: str):
    print "error: {msg}"

fn print_error_with_help(msg: str):
    print "error: {msg}"
    print ""
    print_help()

# =========================================================================
# Simple Lexer - delegates to Rust runtime
# =========================================================================

fn run_lex_command(path: str) -> i64:
    val args = get_cli_args()
    rt_cli_run_lex(args)

# =========================================================================
# FFI - only for operations requiring Rust runtime
# =========================================================================
extern fn rt_cli_file_exists(path: str) -> bool
extern fn rt_cli_read_file(path: str) -> str

# Code execution
extern fn rt_cli_run_code(code: str, gc_log: bool, gc_off: bool) -> i64
extern fn rt_cli_run_file(path: str, args: [str], gc_log: bool, gc_off: bool) -> i64
extern fn rt_cli_watch_file(path: str) -> i64
extern fn rt_cli_run_repl(gc_log: bool, gc_off: bool) -> i64

# Testing
extern fn rt_cli_run_tests(args: [str], gc_log: bool, gc_off: bool) -> i64

# Code quality
extern fn rt_cli_run_lint(args: [str]) -> i64
extern fn rt_cli_run_fmt(args: [str]) -> i64
extern fn rt_cli_run_check(args: [str]) -> i64
extern fn rt_cli_run_fix(args: [str]) -> i64

# Verification
extern fn rt_cli_run_verify(args: [str], gc_log: bool, gc_off: bool) -> i64

# Migration and tooling
extern fn rt_cli_run_migrate(args: [str]) -> i64
extern fn rt_cli_run_mcp(args: [str]) -> i64
extern fn rt_cli_run_diff(args: [str]) -> i64
extern fn rt_cli_run_constr(args: [str]) -> i64

# Analysis
extern fn rt_cli_run_query(args: [str]) -> i64
extern fn rt_cli_run_info(args: [str]) -> i64

# Auditing
extern fn rt_cli_run_spec_coverage(args: [str]) -> i64
extern fn rt_cli_run_replay(args: [str]) -> i64

# Code generation
extern fn rt_cli_run_gen_lean(args: [str]) -> i64
extern fn rt_cli_run_feature_gen(args: [str]) -> i64
extern fn rt_cli_run_task_gen(args: [str]) -> i64
extern fn rt_cli_run_spec_gen(args: [str]) -> i64
extern fn rt_cli_run_sspec_docgen(args: [str]) -> i64
extern fn rt_cli_run_todo_scan(args: [str]) -> i64
extern fn rt_cli_run_todo_gen(args: [str]) -> i64

# Lexer
extern fn rt_cli_run_lex(args: [str]) -> i64

# Brief view
extern fn rt_cli_run_brief(args: [str]) -> i64

# FFI generation
extern fn rt_cli_run_ffi_gen(args: [str]) -> i64

# i18n
extern fn rt_cli_run_i18n(args: [str]) -> i64

# Compilation
extern fn rt_cli_handle_compile(args: [str]) -> i64

# Web framework
extern fn rt_cli_handle_web(args: [str]) -> i64

# Diagram generation
extern fn rt_cli_handle_diagram(args: [str]) -> i64

# Package management - now implemented in Simple (see src/app/*/main.spl)
# Dispatched via rt_cli_run_file to run the app scripts directly

# Explicit run command
extern fn rt_cli_handle_run(args: [str], gc_log: bool, gc_off: bool) -> i64

# Build system (implemented in app.build.main)
# extern fn rt_cli_handle_build(args: [str]) -> i64  # Replaced with build_main

# Fault detection configuration
extern fn rt_fault_set_stack_overflow_detection(enabled: bool)
extern fn rt_fault_set_max_recursion_depth(depth: i64)
extern fn rt_fault_set_timeout(secs: i64)
extern fn rt_fault_set_execution_limit(limit: i64)

# Global flags struct
struct GlobalFlags:
    gc_log: bool
    gc_off: bool
    use_notui: bool
    max_recursion_depth: i64
    timeout_secs: i64
    execution_limit: i64
    stack_overflow_detection: bool

fn parse_global_flags(args: [str]) -> GlobalFlags:
    var gc_log = false
    var gc_off = false
    var use_notui = false
    var max_recursion_depth = 0
    var timeout_secs = 0
    var execution_limit = 0
    var stack_overflow_detection = false
    var has_stack_overflow_flag = false

    var i = 0
    while i < args.len():
        val arg = args[i]
        if arg == "--gc-log":
            gc_log = true
        elif arg == "--gc-off":
            gc_off = true
        elif arg == "--notui":
            use_notui = true
        elif arg == "--stack-overflow-detection":
            stack_overflow_detection = true
            has_stack_overflow_flag = true
        elif arg == "--no-stack-overflow-detection":
            stack_overflow_detection = false
            has_stack_overflow_flag = true
        elif arg.starts_with("--max-recursion-depth="):
            val val_str = arg[21:]
            max_recursion_depth = val_str.to_int()
        elif arg == "--max-recursion-depth" and i + 1 < args.len():
            i = i + 1
            max_recursion_depth = args[i].to_int()
        elif arg.starts_with("--timeout="):
            val val_str = arg[10:]
            timeout_secs = val_str.to_int()
        elif arg == "--timeout" and i + 1 < args.len():
            i = i + 1
            timeout_secs = args[i].to_int()
        elif arg.starts_with("--execution-limit="):
            val val_str = arg[18:]
            execution_limit = val_str.to_int()
        elif arg == "--execution-limit" and i + 1 < args.len():
            i = i + 1
            execution_limit = args[i].to_int()
        i = i + 1

    GlobalFlags(gc_log: gc_log, gc_off: gc_off, use_notui: use_notui,
        max_recursion_depth: max_recursion_depth, timeout_secs: timeout_secs,
        execution_limit: execution_limit, stack_overflow_detection: stack_overflow_detection)

fn apply_fault_detection(flags: GlobalFlags):
    if flags.max_recursion_depth > 0:
        rt_fault_set_max_recursion_depth(flags.max_recursion_depth)
        rt_fault_set_stack_overflow_detection(true)
    if flags.stack_overflow_detection:
        rt_fault_set_stack_overflow_detection(true)
    if flags.timeout_secs > 0:
        rt_fault_set_timeout(flags.timeout_secs)
    if flags.execution_limit > 0:
        rt_fault_set_execution_limit(flags.execution_limit)

fn filter_internal_flags(args: [str]) -> [str]:
    var result = []
    var skip_next = false
    for arg in args:
        if skip_next:
            skip_next = false
        elif arg == "--max-recursion-depth" or arg == "--timeout" or arg == "--execution-limit":
            skip_next = true
        elif not arg.starts_with("--gc") and arg != "--notui" and arg != "--lang" and arg != "--stack-overflow-detection" and arg != "--no-stack-overflow-detection":
            if not arg.starts_with("--lang=") and not arg.starts_with("--max-recursion-depth=") and not arg.starts_with("--timeout=") and not arg.starts_with("--execution-limit="):
                result.push(arg)
    result

# =========================================================================
# Init command - implemented in Simple
# =========================================================================
extern fn rt_file_exists(path: text) -> bool
extern fn rt_file_write_text(path: text, content: text) -> bool
extern fn rt_dir_create(path: text, recursive: bool) -> bool
extern fn rt_env_cwd() -> text
extern fn rt_path_basename(path: text) -> text

fn handle_init(args: [str]) -> i64:
    val cwd = rt_env_cwd()

    # Check if already initialized
    if rt_file_exists("{cwd}/simple.sdn"):
        print_error("Project already initialized (simple.sdn exists)")
        return 1
    if rt_file_exists("{cwd}/simple.toml"):
        print_error("Project already initialized (simple.toml exists)")
        return 1

    # Determine project name from args or directory name
    # args[0] is "init" command itself, args[1+] are actual arguments
    var name = ""
    if args.len() > 1:
        name = args[1]
    else:
        name = rt_path_basename(cwd)
    if name == "":
        name = "my-project"

    # Write simple.sdn manifest
    val manifest = "# Simple Package Manifest\n# SDN (Simple Data Notation) format\n\npackage:\n  name: {name}\n  version: 0.1.0\n  license: MIT\n  main: src/main.spl\n"
    if not rt_file_write_text("{cwd}/simple.sdn", manifest):
        print_error("Failed to write simple.sdn")
        return 1

    # Create src directory
    if not rt_dir_create("{cwd}/src", true):
        print_error("Failed to create src/ directory")
        return 1

    # Write src/main.spl if it doesn't exist
    val main_path = "{cwd}/src/main.spl"
    if not rt_file_exists(main_path):
        val main_content = "# Simple Language Project\n# Run with: simple run\n\nfn main() -> i32:\n    print(\"Hello, Simple!\")\n    return 0\n"
        if not rt_file_write_text(main_path, main_content):
            print_error("Failed to write src/main.spl")
            return 1

    print "Initialized Simple project '{name}'"
    return 0

fn main() -> i64:
    val args = get_cli_args()

    val flags = parse_global_flags(args)
    apply_fault_detection(flags)
    val filtered_args = filter_internal_flags(args)

    if filtered_args.len() == 0:
        return rt_cli_run_repl(flags.gc_log, flags.gc_off)

    val first = filtered_args[0]

    match first:
        case "-h" | "--help":
            print_help()
            return 0

        case "-v" | "--version":
            print_version()
            return 0

        case "-c":
            if filtered_args.len() < 2:
                print_error("-c requires a code argument")
                return 1
            return rt_cli_run_code(filtered_args[1], flags.gc_log, flags.gc_off)

        case "compile":
            return rt_cli_handle_compile(filtered_args)

        case "targets":
            print_targets()
            return 0

        case "linkers":
            print_linkers()
            return 0

        case "web":
            return rt_cli_handle_web(filtered_args)

        case "watch":
            if filtered_args.len() < 2:
                print_error("watch requires a source file")
                return 1
            return rt_cli_watch_file(filtered_args[1])

        case "test":
            val test_args = filtered_args[1:]
            return rt_cli_run_tests(test_args, flags.gc_log, flags.gc_off)

        case "lex":
            if filtered_args.len() < 2:
                print_error("lex requires a source file")
                return 1
            return run_lex_command(filtered_args[1])

        case "lint":
            return rt_cli_run_lint(filtered_args)

        case "fix":
            return rt_cli_run_fix(filtered_args)

        case "fmt":
            return rt_cli_run_fmt(filtered_args)

        case "check":
            val check_args = filtered_args[1:]
            return rt_cli_run_check(check_args)

        case "i18n":
            return rt_cli_run_i18n(filtered_args)

        case "migrate":
            return rt_cli_run_migrate(filtered_args)

        case "mcp":
            return rt_cli_run_mcp(filtered_args)

        case "diff":
            return rt_cli_run_diff(filtered_args)

        case "constr":
            return rt_cli_run_constr(filtered_args)

        case "query":
            return rt_cli_run_query(filtered_args)

        case "info":
            return rt_cli_run_info(filtered_args)

        case "spec-coverage":
            return rt_cli_run_spec_coverage(filtered_args)

        case "replay":
            return rt_cli_run_replay(filtered_args)

        case "gen-lean":
            return rt_cli_run_gen_lean(filtered_args)

        case "feature-gen":
            return rt_cli_run_feature_gen(filtered_args)

        case "task-gen":
            return rt_cli_run_task_gen(filtered_args)

        case "spec-gen":
            return rt_cli_run_spec_gen(filtered_args)

        case "sspec-docgen":
            return rt_cli_run_sspec_docgen(filtered_args)

        case "todo-scan":
            return rt_cli_run_todo_scan(filtered_args)

        case "todo-gen":
            return rt_cli_run_todo_gen(filtered_args)

        case "brief":
            return rt_cli_run_brief(filtered_args)

        case "ffi-gen":
            return rt_cli_run_ffi_gen(filtered_args)

        case "dashboard":
            print "Dashboard command - implementation in progress"
            return 0

        case "verify":
            return rt_cli_run_verify(filtered_args, flags.gc_log, flags.gc_off)

        case "diagram":
            return rt_cli_handle_diagram(filtered_args)

        case "build":
            val build_args = filtered_args[1:]
            return handle_build(build_args)

        case "init":
            return handle_init(filtered_args)

        case "add":
            return rt_cli_run_file("src/app/add/main.spl", filtered_args, flags.gc_log, flags.gc_off)

        case "remove":
            return rt_cli_run_file("src/app/remove/main.spl", filtered_args, flags.gc_log, flags.gc_off)

        case "install":
            return rt_cli_run_file("src/app/install/main.spl", filtered_args, flags.gc_log, flags.gc_off)

        case "update":
            return rt_cli_run_file("src/app/update/main.spl", filtered_args, flags.gc_log, flags.gc_off)

        case "list":
            return rt_cli_run_file("src/app/list/main.spl", filtered_args, flags.gc_log, flags.gc_off)

        case "tree":
            return rt_cli_run_file("src/app/tree/main.spl", filtered_args, flags.gc_log, flags.gc_off)

        case "cache":
            return rt_cli_run_file("src/app/cache/main.spl", filtered_args, flags.gc_log, flags.gc_off)

        case "env":
            return rt_cli_run_file("src/app/env/main.spl", filtered_args, flags.gc_log, flags.gc_off)

        case "lock":
            return rt_cli_run_file("src/app/lock/main.spl", filtered_args, flags.gc_log, flags.gc_off)

        case "run":
            return rt_cli_handle_run(filtered_args, flags.gc_log, flags.gc_off)

        case _:
            if rt_cli_file_exists(first):
                var program_args = [first]
                var j = 1
                while j < filtered_args.len():
                    program_args.push(filtered_args[j])
                    j = j + 1
                return rt_cli_run_file(first, program_args, flags.gc_log, flags.gc_off)
            else:
                print_error_with_help("file not found: {first}")
                return 1
