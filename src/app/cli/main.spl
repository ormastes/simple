# Simple Language - Unified CLI (Written in Simple)
#
# This is the main entry point for the Simple CLI, written in Simple itself.
# Most functionality is implemented in Simple; FFI is only used for runtime operations.
#
# Usage like Python:
#   simple              - Start interactive REPL
#   simple file.spl     - Run source file
#   simple file.smf     - Run compiled binary
#   simple -c "code"    - Run code string

# Direct sub-module imports (bypass app.io.mod hub for faster startup)
use app.io.env_ops.{env_get, env_set}
use app.io.cli_ops.{cli_file_exists, cli_get_args,
    cli_run_code, cli_run_file, cli_watch_file, cli_run_repl, cli_run_tests,
    cli_run_lint, cli_run_fmt, cli_run_fix, cli_run_verify,
    cli_run_migrate, cli_run_mcp, cli_run_lsp, cli_run_diff, cli_constr, cli_run_query, cli_info,
    cli_run_spec_coverage, cli_replay, cli_gen_lean, cli_run_feature_gen,
    cli_run_task_gen, cli_run_spec_gen, cli_run_sspec_docgen, cli_run_feature_doc, cli_todo_scan,
    cli_run_todo_gen, cli_run_lex, cli_run_brief, cli_run_ffi_gen, cli_run_i18n,
    cli_compile, cli_handle_web, cli_handle_diagram, cli_handle_run,
    fault_set_stack_overflow_detection, fault_set_max_recursion_depth,
    fault_set_timeout, fault_set_execution_limit}
use app.io.jit_ffi.{jit_available}
use app.build.cli_entry.{handle_build}
use app.cli.check.{run_check}  # New type checking implementation
use app.cli.arch_check.{run_arch_check}
use app.cli.check_dbs.{run_check_dbs}
use app.cli.fix_dbs.{run_fix_dbs}
use app.stats.doc_coverage_dynamic.{run_doc_coverage}
use app.stats.dynamic.{run_stats}
use app.leak_check.main.{run_leak_check}
#   simple compile src.spl [-o out.smf]  - Compile to SMF
#   simple watch file.spl  - Watch and auto-recompile

use app.cli.cli_helpers (print_cli_help, handle_init, read_sdn_run_config, sdn_line_indent, strip_sdn_quotes, check_self_contained)

# Extract CLI args, skipping program name and script path
fn get_cli_args() -> [str]:
    val all_args = cli_get_args()
    var args = []
    var start_idx = 1
    if all_args.len() > 1 and all_args[1].ends_with("main.spl"):
        start_idx = 2
    var i = start_idx
    while i < all_args.len():
        args.push(all_args[i])
        i = i + 1
    args

# =========================================================================
# Version and Help - implemented in Simple
# =========================================================================
fn get_version() -> str:
    val version = env_get("SIMPLE_VERSION")
    if version != "" and version != nil:
        return version
    "0.5.0"

fn print_version():
    val v = get_version()
    print "Simple v{v}"

# =========================================================================
# Target architectures - implemented in Simple
# =========================================================================
fn print_targets():
    print "Available target architectures:"
    print ""
    print "  x86_64          64-bit x86 Linux (ELF)"
    print "  aarch64         64-bit ARM Linux (ELF)"
    print "  riscv64         64-bit RISC-V Linux (ELF)"
    print "  aarch64-macos   64-bit ARM macOS (Mach-O, Apple Silicon)"
    print "  x86_64-macos    64-bit x86 macOS (Mach-O, Intel Mac)"
    print "  i686            32-bit x86"
    print "  armv7           32-bit ARM"
    print "  riscv32         32-bit RISC-V"
    print ""
    print "WebAssembly:"
    print "  wasm32-wasi     32-bit WebAssembly (WASI Preview 1)"
    print "  wasm32          32-bit WebAssembly (standalone, no WASI)"
    print "  wasm64          64-bit WebAssembly (Memory64 proposal)"
    print ""
    print "Usage:"
    print "  simple compile app.spl --target aarch64"
    print "  simple compile app.spl --target aarch64-macos"
    print "  simple compile app.spl --target wasm32-wasi -o app.wasm"

# =========================================================================
# Native linkers - implemented in Simple
# =========================================================================
fn print_linkers():
    print "Available native linkers:"
    print ""
    print "  mold      Modern linker (fastest, recommended)"
    print "  lld       LLVM linker (fast, widely available)"
    print "  ld        GNU linker (default, always available)"
    print ""
    print "The linker is auto-detected if not specified."
    print "Preference order: mold > lld > ld"
    print ""
    print "Usage:"
    print "  simple compile app.spl --linker mold"

# =========================================================================
# Error messages - implemented in Simple
# =========================================================================
fn print_error(msg: str):
    error("cli", msg)

fn print_error_with_help(msg: str):
    error("cli", msg)
    print ""
    print_cli_help()

# =========================================================================
# Simple Lexer - delegates to Rust runtime
# =========================================================================

fn run_lex_command(path: str) -> i64:
    val args = get_cli_args()
    cli_run_lex(args)

# Global flags struct
struct GlobalFlags:
    gc_log: bool
    gc_off: bool
    use_notui: bool
    max_recursion_depth: i64
    timeout_secs: i64
    execution_limit: i64
    stack_overflow_detection: bool
    backend: text        # "auto", "cranelift", "llvm" - JIT backend selection
    force_interpret: bool  # --interpret flag to force interpreter mode
    interpreter_mode: text  # "optimized" (default), "classic" (legacy)
    run_config: text        # "shared" (default), "interpreter"/"compiler" (compat), "legacy"
    no_jit: bool            # --no-jit flag to disable JIT compilation
    jit_threshold: i64      # --jit-threshold=N for JIT compilation threshold

fn parse_global_flags(args: [str]) -> GlobalFlags:
    var gc_log = false
    var gc_off = false
    var use_notui = false
    var max_recursion_depth = 0
    var timeout_secs = 0
    var execution_limit = 0
    var stack_overflow_detection = false
    var has_stack_overflow_flag = false
    var backend = "auto"
    var force_interpret = false
    var interpreter_mode = "optimized"
    var run_config = ""
    var no_jit = false
    var jit_threshold = 10

    var i = 0
    while i < args.len():
        val arg = args[i]
        if arg == "--gc-log":
            gc_log = true
        elif arg == "--gc-off":
            gc_off = true
        elif arg == "--notui":
            use_notui = true
        elif arg == "--interpret":
            force_interpret = true
        elif arg == "--interpret-optimized":
            force_interpret = true
            interpreter_mode = "optimized"
        elif arg == "--no-jit":
            no_jit = true
        elif arg.starts_with("--jit-threshold="):
            val val_str = arg[16:]
            jit_threshold = val_str.to_int()
        elif arg == "--jit-threshold" and i + 1 < args.len():
            i = i + 1
            jit_threshold = args[i].to_int()
        elif arg.starts_with("--interpreter-mode="):
            interpreter_mode = arg[19:]
        elif arg == "--interpreter-mode" and i + 1 < args.len():
            i = i + 1
            interpreter_mode = args[i]
        elif arg.starts_with("--run-config="):
            run_config = arg[13:]
        elif arg == "--run-config" and i + 1 < args.len():
            i = i + 1
            run_config = args[i]
        elif arg.starts_with("--backend="):
            backend = arg[10:]
        elif arg == "--backend" and i + 1 < args.len():
            i = i + 1
            backend = args[i]
        elif arg == "--stack-overflow-detection":
            stack_overflow_detection = true
            has_stack_overflow_flag = true
        elif arg == "--no-stack-overflow-detection":
            stack_overflow_detection = false
            has_stack_overflow_flag = true
        elif arg.starts_with("--max-recursion-depth="):
            val val_str = arg[21:]
            max_recursion_depth = val_str.to_int()
        elif arg == "--max-recursion-depth" and i + 1 < args.len():
            i = i + 1
            max_recursion_depth = args[i].to_int()
        elif arg.starts_with("--timeout="):
            val val_str = arg[10:]
            timeout_secs = val_str.to_int()
        elif arg == "--timeout" and i + 1 < args.len():
            i = i + 1
            timeout_secs = args[i].to_int()
        elif arg.starts_with("--execution-limit="):
            val val_str = arg[18:]
            execution_limit = val_str.to_int()
        elif arg == "--execution-limit" and i + 1 < args.len():
            i = i + 1
            execution_limit = args[i].to_int()
        i = i + 1

    # Check SIMPLE_EXECUTION_MODE env var as fallback
    if not force_interpret and backend == "auto":
        val env_mode = env_get("SIMPLE_EXECUTION_MODE")
        if env_mode == "interpret":
            force_interpret = true
        elif env_mode == "interpret-optimized":
            force_interpret = true
            interpreter_mode = "optimized"
        elif env_mode == "cranelift":
            backend = "cranelift"
        elif env_mode == "llvm":
            backend = "llvm"
        elif env_mode == "vhdl":
            backend = "vhdl"
        elif env_mode == "jit":
            backend = "auto"

    # Read run-config from simple.sdn if not set via CLI/env
    if run_config == "":
        run_config = read_sdn_run_config()

    # Map run_config to interpreter_mode
    if run_config == "compiler" or run_config == "shared":
        interpreter_mode = "optimized"
        force_interpret = true
    elif run_config == "interpreter":
        # Backward-compatible alias: "interpreter" now means shared/default mode.
        interpreter_mode = "optimized"
        force_interpret = true
    elif run_config == "legacy":
        interpreter_mode = "classic"
        force_interpret = true

    GlobalFlags(gc_log: gc_log, gc_off: gc_off, use_notui: use_notui,
        max_recursion_depth: max_recursion_depth, timeout_secs: timeout_secs,
        execution_limit: execution_limit, stack_overflow_detection: stack_overflow_detection,
        backend: backend, force_interpret: force_interpret,
        interpreter_mode: interpreter_mode, run_config: run_config,
        no_jit: no_jit, jit_threshold: jit_threshold)

fn apply_fault_detection(flags: GlobalFlags):
    if flags.max_recursion_depth > 0:
        fault_set_max_recursion_depth(flags.max_recursion_depth)
        fault_set_stack_overflow_detection(true)
    if flags.stack_overflow_detection:
        fault_set_stack_overflow_detection(true)
    if flags.timeout_secs > 0:
        fault_set_timeout(flags.timeout_secs)
    if flags.execution_limit > 0:
        fault_set_execution_limit(flags.execution_limit)

fn apply_jit_env_vars(flags: GlobalFlags):
    if flags.no_jit:
        env_set("SIMPLE_NO_JIT", "1")
    if flags.jit_threshold != 10:
        val t = "{flags.jit_threshold}"
        env_set("SIMPLE_JIT_THRESHOLD", t)
    if flags.backend != "auto":
        env_set("SIMPLE_JIT_BACKEND", flags.backend)

fn filter_internal_flags(args: [str]) -> [str]:
    var result = []
    var skip_next = false
    for arg in args:
        if skip_next:
            skip_next = false
        elif arg == "--max-recursion-depth" or arg == "--timeout" or arg == "--execution-limit" or arg == "--interpreter-mode" or arg == "--run-config" or arg == "--jit-threshold":
            skip_next = true
        elif not arg.starts_with("--gc") and arg != "--notui" and arg != "--lang" and arg != "--stack-overflow-detection" and arg != "--no-stack-overflow-detection" and arg != "--interpret" and arg != "--interpret-optimized" and arg != "--no-jit":
            if not arg.starts_with("--lang=") and not arg.starts_with("--max-recursion-depth=") and not arg.starts_with("--timeout=") and not arg.starts_with("--execution-limit=") and not arg.starts_with("--interpreter-mode") and not arg.starts_with("--run-config") and not arg.starts_with("--jit-threshold="):
                # Keep --backend flags (used by both JIT and compile commands)
                result.push(arg)
    result

# =========================================================================
# Init command - implemented in Simple
# =========================================================================


fn main() -> i64:
    val args = get_cli_args()

    # Early check: is this a self-contained binary?
    # Only check when no args are passed (self-contained binaries run directly)
    # or when args don't start with a known subcommand
    if args.len() == 0:
        if check_self_contained():
            return 0

    val flags = parse_global_flags(args)
    apply_fault_detection(flags)
    apply_jit_env_vars(flags)

    val filtered_args = filter_internal_flags(args)

    # Standalone native build: assume native exec_manager is present; suppress fallback messaging.

    if filtered_args.len() == 0:
        return cli_run_repl(flags.gc_log, flags.gc_off)

    val first = filtered_args[0]

    match first:
        case "-h" | "--help":
            print_cli_help()
            return 0

        case "-v" | "--version":
            print_version()
            return 0

        case "-c":
            if filtered_args.len() < 2:
                print_error("-c requires a code argument")
                return 1
            return cli_run_code(filtered_args[1], flags.gc_log, flags.gc_off)

        case "compile":
            return cli_compile(filtered_args)

        case "targets":
            print_targets()
            return 0

        case "linkers":
            print_linkers()
            return 0

        case "web":
            return cli_handle_web(filtered_args)

        case "watch":
            if filtered_args.len() < 2:
                print_error("watch requires a source file")
                return 1
            return cli_watch_file(filtered_args[1])

        case "test":
            val test_args = filtered_args[1:]
            return cli_run_tests(test_args, flags.gc_log, flags.gc_off)

        case "lex":
            if filtered_args.len() < 2:
                print_error("lex requires a source file")
                return 1
            return run_lex_command(filtered_args[1])

        case "lint":
            return cli_run_lint(filtered_args)

        case "duplicate-check":
            return cli_run_file("src/app/duplicate_check/main.spl", filtered_args, flags.gc_log, flags.gc_off)

        case "fix":
            return cli_run_fix(filtered_args)

        case "fmt":
            return cli_run_fmt(filtered_args)

        case "check":
            val check_args = filtered_args[1:]
            return run_check(check_args)  # Use new type inference system

        case "doc-coverage":
            return run_doc_coverage(filtered_args[1:])

        case "check-arch":
            val arch_args = filtered_args[1:]
            return run_arch_check(arch_args)

        case "check-dbs":
            val check_db_args = filtered_args[1:]
            return run_check_dbs(check_db_args)

        case "fix-dbs":
            val fix_db_args = filtered_args[1:]
            return run_fix_dbs(fix_db_args)

        case "grammar-doc":
            val grammar_args = filtered_args[1:]
            return cli_run_file("src/app/grammar_doc/mod.spl", grammar_args, flags.gc_log, flags.gc_off)

        case "i18n":
            return cli_run_i18n(filtered_args)

        case "migrate":
            return cli_run_migrate(filtered_args)

        case "mcp":
            return cli_run_mcp(filtered_args)

        case "lsp":
            return cli_run_lsp(filtered_args)

        case "diff":
            return cli_run_diff(filtered_args)

        case "constr":
            return cli_constr(filtered_args)

        case "query":
            return cli_run_query(filtered_args)

        case "info":
            return cli_info(filtered_args)

        case "spec-coverage":
            return cli_run_spec_coverage(filtered_args)

        case "replay":
            return cli_replay(filtered_args)

        case "gen-lean":
            return cli_gen_lean(filtered_args)

        case "feature-gen":
            return cli_run_feature_gen(filtered_args)

        case "task-gen":
            return cli_run_task_gen(filtered_args)

        case "spec-gen":
            return cli_run_spec_gen(filtered_args)

        case "sspec-docgen":
            return cli_run_sspec_docgen(filtered_args)

        case "feature-doc":
            return cli_run_feature_doc(filtered_args)

        case "todo-scan":
            return cli_todo_scan(filtered_args)

        case "todo-gen":
            return cli_run_todo_gen(filtered_args)

        case "brief":
            return cli_run_brief(filtered_args)

        case "stats":
            run_stats(filtered_args[1:])
            return 0

        case "ffi-gen":
            return cli_run_ffi_gen(filtered_args)

        case "wrapper-gen":
            return cli_run_file("src/app/wrapper_gen/mod.spl", filtered_args, flags.gc_log, flags.gc_off)

        case "desugar":
            return cli_run_file("src/app/desugar/mod.spl", filtered_args, flags.gc_log, flags.gc_off)

        case "dashboard":
            val dashboard_args = filtered_args[1:]
            return cli_run_file("src/app/dashboard/main.spl", dashboard_args, flags.gc_log, flags.gc_off)

        case "verify":
            return cli_run_verify(filtered_args, flags.gc_log, flags.gc_off)

        case "diagram":
            return cli_handle_diagram(filtered_args)

        case "build":
            val build_args = filtered_args[1:]
            return handle_build(build_args)

        case "init":
            return handle_init(filtered_args)

        case "add":
            return cli_run_file("src/app/add/main.spl", filtered_args, flags.gc_log, flags.gc_off)

        case "remove":
            return cli_run_file("src/app/remove/main.spl", filtered_args, flags.gc_log, flags.gc_off)

        case "install":
            return cli_run_file("src/app/install/main.spl", filtered_args, flags.gc_log, flags.gc_off)

        case "update":
            return cli_run_file("src/app/update/main.spl", filtered_args, flags.gc_log, flags.gc_off)

        case "list":
            return cli_run_file("src/app/list/main.spl", filtered_args, flags.gc_log, flags.gc_off)

        case "tree":
            return cli_run_file("src/app/tree/main.spl", filtered_args, flags.gc_log, flags.gc_off)

        case "cache":
            return cli_run_file("src/app/cache/main.spl", filtered_args, flags.gc_log, flags.gc_off)

        case "env":
            return cli_run_file("src/app/env/main.spl", filtered_args, flags.gc_log, flags.gc_off)

        case "lock":
            return cli_run_file("src/app/lock/main.spl", filtered_args, flags.gc_log, flags.gc_off)

        case "run":
            return cli_handle_run(filtered_args, flags.gc_log, flags.gc_off)

        case "leak-check":
            return run_leak_check()

        case _:
            if cli_file_exists(first):
                var program_args = [first]
                var j = 1
                while j < filtered_args.len():
                    program_args.push(filtered_args[j])
                    j = j + 1
                return cli_run_file(first, program_args, flags.gc_log, flags.gc_off)
            else:
                print_error_with_help("file not found: {first}")
                return 1
