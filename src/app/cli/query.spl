# Simple Language - Query CLI
#
# Provides structured code query subcommands for IDE integration.
# Uses outline-based parsing for scope-aware queries (not grep).
# Called via: bin/simple query <subcommand> <file> <line> [column]
#
# Subcommands:
#   definition          <file> <line> [column]  — Find definition of symbol at position
#   references          <file> <line> [column]  — Find all references to symbol at position
#   hover               <file> <line> [column]  — Show type + docs at position
#   completions         <file> <line> [column] [--prefix X]  — Code completions at position
#   type-at             <file> <line> [column]  — Type info at position
#   signature-help      <file> <line> [column]  — Signature help for function call
#   rename              <file> <line> [column] --new-name X [--apply]  — Rename symbol
#   code-actions        <file> <line>           — Code actions / quick fixes at position
#   call-hierarchy      <file> <line> [column] [--direction incoming|outgoing]
#   type-hierarchy      <file> <line> [column] [--direction supertypes|subtypes]
#   selection-range     <file> <line> [column]  — Nested selection ranges
#   workspace-symbols   [--query X] [--kind fn|class|struct|enum|trait]
#   semantic-tokens     <file> [--start-line N] [--end-line N]
#   inlay-hints         <file> [--start-line N] [--end-line N]
#   document-formatting <file>                  — Format file
#   document-highlight  <file> <line> [col]     — Same-file references with R/W
#   type-definition     <file> <line> [col]     — Find where type is defined
#   implementation      <file> <line> [col]     — Find trait implementations
#   folding-range       <file>                  — Folding ranges

extern fn rt_cli_get_args() -> [text]
extern fn rt_file_read_text(path: text) -> text
extern fn rt_process_run(cmd: text, args: [text]) -> (text, text, i64)
extern fn rt_file_write_text(path: text, content: text) -> bool

use app.cli.query_engine.{engine_find_definition, engine_find_references, engine_hover, engine_completions, engine_type_at, engine_signature_help, engine_document_symbols}
use app.cli.query_sanitize.{sanitize_path, sanitize_symbol, safe_grep, safe_grep_file, safe_process}
use app.cli.query_lsp_extras.{query_document_highlight, query_type_definition, query_implementation, query_folding_range}
use app.cli.query_ast_query.{engine_ast_query}
use app.cli.query_sem_query.{engine_sem_query}
use app.cli.query_schema.{engine_query_schema}

fn query_main() -> i64:
    val all_args = rt_cli_get_args()
    # Strip program name and script path (first 2 args: binary + script.spl)
    var args: [text] = []
    var i = 0
    for arg in all_args:
        if i >= 2:
            args.push(arg)
        i = i + 1
    run_query(args)

# Top-level entry point
query_main()

fn query_shell(command: text) -> (text, i64):
    val (stdout, stderr, code) = rt_process_run("/bin/sh", ["-c", command])
    (stdout, code)

fn query_file_read(path: text) -> text:
    rt_file_read_text(path) ?? ""

# Extract the symbol name at a given line and optional column
fn extract_symbol_at(file: text, line_num: i64, col: i64) -> text:
    val content = query_file_read(file)
    if content == "":
        return ""
    val lines = content.split("\n")
    if line_num < 1 or line_num > lines.len():
        return ""
    val target_line = lines[line_num - 1]
    if target_line.trim() == "":
        return ""

    # If column is specified, extract word at that position
    if col > 0 and col <= target_line.len():
        var start = col - 1
        var end_pos = col - 1
        # Scan backward to find word start
        for _i in range(0, col):
            if start <= 0:
                break
            val ch = target_line.substring(start - 1, start)
            val is_word = (ch >= "a" and ch <= "z") or (ch >= "A" and ch <= "Z") or (ch >= "0" and ch <= "9") or ch == "_"
            if not is_word:
                break
            start = start - 1
        # Scan forward to find word end
        for _i in range(0, 200):
            if end_pos >= target_line.len():
                break
            val ch = target_line.substring(end_pos, end_pos + 1)
            val is_word = (ch >= "a" and ch <= "z") or (ch >= "A" and ch <= "Z") or (ch >= "0" and ch <= "9") or ch == "_"
            if not is_word:
                break
            end_pos = end_pos + 1
        if end_pos > start:
            return target_line.substring(start, end_pos)

    # No column or column extraction failed — extract first identifier-like token
    val trimmed = target_line.trim()
    # Skip common keywords to find the symbol name
    var rest = trimmed
    if rest.starts_with("fn "):
        rest = rest.substring(3)
    elif rest.starts_with("val "):
        rest = rest.substring(4)
    elif rest.starts_with("var "):
        rest = rest.substring(4)
    elif rest.starts_with("class "):
        rest = rest.substring(6)
    elif rest.starts_with("struct "):
        rest = rest.substring(7)
    elif rest.starts_with("enum "):
        rest = rest.substring(5)
    elif rest.starts_with("use "):
        rest = rest.substring(4)
    elif rest.starts_with("import "):
        rest = rest.substring(7)
    elif rest.starts_with("me "):
        rest = rest.substring(3)
    elif rest.starts_with("static fn "):
        rest = rest.substring(10)

    # Extract first word
    var parts: [text] = []
    for ch in rest:
        val is_word = (ch >= "a" and ch <= "z") or (ch >= "A" and ch <= "Z") or (ch >= "0" and ch <= "9") or ch == "_"
        if not is_word:
            break
        parts.push(ch)
    parts.join("")

fn run_query(args: [text]) -> i64:
    # Strip "query" from args if present
    var cmd_args = args
    if cmd_args.len() > 0 and cmd_args[0] == "query":
        cmd_args = cmd_args[1:]

    if cmd_args.len() == 0:
        print "Usage: simple query <subcommand> <file> <line> [column]"
        print ""
        print "Subcommands:"
        print "  definition          <file> <line> [col]  Find definition of symbol"
        print "  references          <file> <line> [col]  Find all references"
        print "  hover               <file> <line> [col]  Type + docs at position"
        print "  completions         <file> <line> [col]  Code completions"
        print "  type-at             <file> <line> [col]  Type info at position"
        print "  signature-help      <file> <line> [col]  Signature help for call"
        print "  rename              <file> <line> [col] --new-name X [--apply]  Rename"
        print "  code-actions        <file> <line>        Code actions / quick fixes"
        print "  call-hierarchy      <file> <line> [col] [--direction incoming|outgoing]"
        print "  type-hierarchy      <file> <line> [col] [--direction supertypes|subtypes]"
        print "  selection-range     <file> <line> [col]  Nested selection ranges"
        print "  workspace-symbols   [--query X] [--kind fn|class|struct|enum|trait]"
        print "  semantic-tokens     <file> [--start-line N] [--end-line N]"
        print "  inlay-hints         <file> [--start-line N] [--end-line N]"
        print "  document-formatting <file>               Format file"
        print "  document-highlight  <file> <line> [col]  Same-file references (R/W)"
        print "  type-definition     <file> <line> [col]  Find type definition"
        print "  implementation      <file> <line> [col]  Find trait implementations"
        print "  folding-range       <file>               Folding ranges"
        print "  ast-query           '<pattern>' [--files path] [--format text|json|compact]"
        print "  sem-query           '<query>' [--files path] [--format text|json|compact]"
        print "  query-schema        [ast|sem]            Query language schema"
        return 0

    val subcmd = cmd_args[0]

    # Subcommands with non-standard args (no file+line positional)
    if subcmd == "ast-query":
        return query_ast_query(cmd_args)
    if subcmd == "sem-query":
        return query_sem_query(cmd_args)
    if subcmd == "query-schema":
        return query_query_schema(cmd_args)
    if subcmd == "workspace-symbols":
        return query_workspace_symbols(cmd_args)
    if subcmd == "document-formatting" and cmd_args.len() >= 2:
        return query_document_formatting(cmd_args[1])
    if subcmd == "semantic-tokens" and cmd_args.len() >= 2:
        return query_semantic_tokens(cmd_args[1], cmd_args)
    if subcmd == "inlay-hints" and cmd_args.len() >= 2:
        return query_inlay_hints(cmd_args[1], cmd_args)
    if subcmd == "folding-range" and cmd_args.len() >= 2:
        val fr_file = sanitize_path(cmd_args[1])
        if fr_file == "":
            print "Error: invalid file path"
            return 1
        return query_folding_range(fr_file)

    if cmd_args.len() < 3:
        print "Error: {subcmd} requires <file> and <line> arguments"
        return 1

    val raw_file = cmd_args[1]
    val file = sanitize_path(raw_file)
    if file == "":
        print "Error: invalid file path"
        return 1
    val line_num = cmd_args[2].to_int()
    var col = 0
    if cmd_args.len() > 3 and not cmd_args[3].starts_with("--"):
        col = cmd_args[3].to_int()

    val symbol = extract_symbol_at(file, line_num, col)
    if symbol == "":
        print "No symbol found at {file}:{line_num}"
        return 1

    if subcmd == "definition":
        return query_definition(symbol, file)
    elif subcmd == "references":
        return query_references(symbol, file)
    elif subcmd == "hover":
        return query_hover(symbol, file, line_num)
    elif subcmd == "completions":
        var prefix = symbol
        # Check for --prefix flag
        var i = 3
        while i < cmd_args.len():
            if cmd_args[i] == "--prefix" and i + 1 < cmd_args.len():
                prefix = cmd_args[i + 1]
            i = i + 1
        return query_completions(prefix, file)
    elif subcmd == "type-at":
        return query_type_at(symbol, file, line_num)
    elif subcmd == "signature-help":
        return query_signature_help(symbol, file, line_num, col)
    elif subcmd == "rename":
        return query_rename(symbol, file, line_num, cmd_args)
    elif subcmd == "code-actions":
        return query_code_actions(file, line_num)
    elif subcmd == "call-hierarchy":
        return query_call_hierarchy(symbol, file, cmd_args)
    elif subcmd == "type-hierarchy":
        return query_type_hierarchy(symbol, file, cmd_args)
    elif subcmd == "selection-range":
        return query_selection_range(file, line_num, col)
    elif subcmd == "document-highlight":
        return query_document_highlight(file, line_num, col)
    elif subcmd == "type-definition":
        return query_type_definition(file, line_num, col)
    elif subcmd == "implementation":
        return query_implementation(file, line_num, col)
    else:
        print "Unknown query subcommand: {subcmd}"
        return 1

fn query_definition(symbol: text, file: text) -> i64:
    val clean_sym = sanitize_symbol(symbol)
    if clean_sym == "":
        print "Error: invalid symbol name"
        return 1
    engine_find_definition(file, clean_sym)

fn query_references(symbol: text, file: text) -> i64:
    val clean_sym = sanitize_symbol(symbol)
    if clean_sym == "":
        print "Error: invalid symbol name"
        return 1
    engine_find_references(file, clean_sym)

fn query_hover(symbol: text, file: text, line_num: i64) -> i64:
    val clean_sym = sanitize_symbol(symbol)
    if clean_sym == "":
        print "Error: invalid symbol name"
        return 1
    engine_hover(file, line_num, clean_sym)

fn query_completions(prefix: text, file: text) -> i64:
    val clean_prefix = sanitize_symbol(prefix)
    if clean_prefix == "":
        # Allow empty prefix to show all symbols
        engine_completions(file, 0, "")
    else:
        engine_completions(file, 0, clean_prefix)

fn query_type_at(symbol: text, file: text, line_num: i64) -> i64:
    val clean_sym = sanitize_symbol(symbol)
    if clean_sym == "":
        print "Error: invalid symbol name"
        return 1
    engine_type_at(file, line_num, clean_sym)

# --- New query subcommands ---

fn _extract_flag(cmd_args: [text], flag_name: text, default_val: text) -> text:
    # Extract a --flag value from cmd_args list
    var i = 0
    while i < cmd_args.len():
        if cmd_args[i] == flag_name and i + 1 < cmd_args.len():
            return cmd_args[i + 1]
        i = i + 1
    default_val

fn query_signature_help(symbol: text, file: text, line_num: i64, col: i64) -> i64:
    val clean_sym = sanitize_symbol(symbol)
    if clean_sym == "":
        print "Error: invalid symbol name"
        return 1
    engine_signature_help(file, line_num, col, clean_sym)

fn query_rename(symbol: text, file: text, line_num: i64, cmd_args: [text]) -> i64:
    val new_name = _extract_flag(cmd_args, "--new-name", "")
    if new_name == "":
        print "Error: --new-name <name> is required for rename"
        return 1

    val clean_sym = sanitize_symbol(symbol)
    val clean_new = sanitize_symbol(new_name)
    if clean_sym == "" or clean_new == "":
        print "Error: invalid symbol names"
        return 1

    val apply = _has_flag(cmd_args, "--apply")

    # Find all occurrences with safe_grep
    val (out, _) = safe_grep("\\b" + clean_sym + "\\b", "src/", "*.spl")
    if out.trim() == "":
        print "No occurrences found for: {clean_sym}"
        return 1

    val result_lines = out.split("\n")
    var count = 0
    var edits: [text] = []
    for line in result_lines:
        val trimmed = line.trim()
        if trimmed != "":
            # Parse file:line:content
            var colon1 = -1
            var colon2 = -1
            var ci = 0
            while ci < trimmed.len():
                if trimmed.substring(ci, ci + 1) == ":":
                    if colon1 == -1:
                        colon1 = ci
                    elif colon2 == -1:
                        colon2 = ci
                        break
                ci = ci + 1
            if colon1 > 0 and colon2 > colon1:
                val edit_file = trimmed.substring(0, colon1)
                val edit_line = trimmed.substring(colon1 + 1, colon2)
                val edit_content = trimmed.substring(colon2 + 1)
                print "{edit_file}:{edit_line}: {clean_sym} -> {clean_new}"
                edits.push(edit_file)
            else:
                print trimmed
            count = count + 1

    print ""
    print "Total occurrences: {count}"

    if apply:
        # Apply edits using safe sed-like replacement via rt_process_run
        var edited_files: [text] = []
        for edit_file in edits:
            var already_done = false
            for done in edited_files:
                if done == edit_file:
                    already_done = true
                    break
            if not already_done:
                val content = rt_file_read_text(edit_file) ?? ""
                if content != "":
                    val updated = _replace_word(content, clean_sym, clean_new)
                    rt_file_write_text(edit_file, updated)
                    edited_files.push(edit_file)
                    print "Applied: {edit_file}"
        print ""
        print "Rename applied to {edited_files.len()} files"
    else:
        print "Rename: {clean_sym} -> {clean_new} (dry-run, use --apply to write)"
    0

fn query_code_actions(file: text, line_num: i64) -> i64:
    # TODO: check/fix commands are stubs (cli_check, cli_run_fix return "not implemented").
    # When they are implemented, call them in-process instead of via subprocess.
    val check_out = ""
    val fix_out = ""

    val line_str = "{line_num}"

    var has_diagnostics = false
    if check_out.trim() != "":
        val check_lines = check_out.split("\n")
        print "--- Diagnostics ---"
        for cline in check_lines:
            val ct = cline.trim()
            if (ct != "" and ct.contains(":" + line_str + ":")):
                print ct
                has_diagnostics = true
            elif (ct != "" and ct.contains(":" + line_str + " ")):
                print ct
                has_diagnostics = true

    var has_fixes = false
    if fix_out.trim() != "":
        val fix_lines = fix_out.split("\n")
        print ""
        print "--- Suggested Fixes ---"
        for fline in fix_lines:
            val ft = fline.trim()
            if ft != "" and ft.contains(":" + line_str):
                print ft
                has_fixes = true

    if not has_diagnostics and not has_fixes:
        print "No code actions available at {file}:{line_num}"
    0

fn query_workspace_symbols(cmd_args: [text]) -> i64:
    val query = _extract_flag(cmd_args, "--query", "")
    val kind = _extract_flag(cmd_args, "--kind", "")

    if query == "" and kind == "":
        print "Error: --query <pattern> or --kind <kind> required"
        print "Kinds: fn, class, struct, enum, trait"
        return 1

    val clean_query = sanitize_symbol(query)

    var grep_pattern = ""
    if kind != "":
        val clean_kind = sanitize_symbol(kind)
        if clean_kind == "":
            print "Error: invalid kind"
            return 1
        if clean_query != "":
            grep_pattern = "^" + clean_kind + " " + clean_query
        else:
            grep_pattern = "^" + clean_kind + " "
    else:
        grep_pattern = "^fn " + clean_query + "\\|^class " + clean_query + "\\|^struct " + clean_query + "\\|^enum " + clean_query + "\\|^trait " + clean_query

    val (out, _) = safe_grep(grep_pattern, "src/", "*.spl")
    if out.trim() == "":
        print "No workspace symbols found"
        return 0

    # Limit output to 50 lines
    val result_lines = out.split("\n")
    var count = 0
    for rline in result_lines:
        if rline.trim() != "" and count < 50:
            print rline
            count = count + 1
    0

fn query_call_hierarchy(symbol: text, file: text, cmd_args: [text]) -> i64:
    val direction = _extract_flag(cmd_args, "--direction", "incoming")
    val clean_sym = sanitize_symbol(symbol)
    if clean_sym == "":
        print "Error: invalid symbol name"
        return 1

    if direction == "incoming":
        val (out, _) = safe_grep("\\b" + clean_sym + "(", "src/", "*.spl")
        if out.trim() == "":
            print "No incoming calls found for: {clean_sym}"
            return 0
        print "--- Incoming calls to {clean_sym} ---"
        val result_lines = out.split("\n")
        var count = 0
        for rline in result_lines:
            if rline.trim() != "" and count < 50:
                print rline
                count = count + 1
    elif direction == "outgoing":
        val content = query_file_read(file)
        if content == "":
            print "Could not read file: {file}"
            return 1

        val lines = content.split("\n")
        var fn_start = -1
        var li = 0
        while li < lines.len():
            val line = lines[li]
            val tl = line.trim()
            if (tl.starts_with("fn " + clean_sym + "(") or
                tl.starts_with("fn " + clean_sym + " (")):
                fn_start = li
                break
            li = li + 1

        if fn_start == -1:
            print "Could not find function body for: {clean_sym}"
            return 1

        # Extract function calls from body lines
        var seen_calls: [text] = []
        var bi = fn_start + 1
        while bi < lines.len():
            val bline = lines[bi]
            if bline.len() == 0:
                bi = bi + 1
                continue
            val first_ch = bline.substring(0, 1)
            if first_ch != " " and first_ch != "\t":
                break
            # Scan for identifier( patterns
            var ci = 0
            while ci < bline.len():
                val ch = bline.substring(ci, ci + 1)
                val is_alpha = (ch >= "a" and ch <= "z") or (ch >= "A" and ch <= "Z") or ch == "_"
                if is_alpha:
                    var end_ci = ci + 1
                    while end_ci < bline.len():
                        val wc = bline.substring(end_ci, end_ci + 1)
                        val ww = (wc >= "a" and wc <= "z") or (wc >= "A" and wc <= "Z") or (wc >= "0" and wc <= "9") or wc == "_"
                        if not ww:
                            break
                        end_ci = end_ci + 1
                    if end_ci < bline.len() and bline.substring(end_ci, end_ci + 1) == "(":
                        val call_name = bline.substring(ci, end_ci)
                        var already = false
                        for s in seen_calls:
                            if s == call_name:
                                already = true
                                break
                        if not already:
                            seen_calls.push(call_name)
                    ci = end_ci
                else:
                    ci = ci + 1
            bi = bi + 1

        if seen_calls.len() == 0:
            print "No outgoing calls found from: {clean_sym}"
            return 0
        print "--- Outgoing calls from {clean_sym} ---"
        for call_name in seen_calls:
            print call_name
    else:
        print "Error: --direction must be 'incoming' or 'outgoing'"
        return 1
    0

fn query_type_hierarchy(symbol: text, file: text, cmd_args: [text]) -> i64:
    val direction = _extract_flag(cmd_args, "--direction", "supertypes")
    val clean_sym = sanitize_symbol(symbol)
    if clean_sym == "":
        print "Error: invalid symbol name"
        return 1

    if direction == "supertypes":
        val (out, _) = safe_grep("impl.*" + clean_sym, "src/", "*.spl")
        if out.trim() == "":
            print "No supertypes found for: {clean_sym}"
            return 0
        print "--- Supertypes (trait impls) for {clean_sym} ---"
        val result_lines = out.split("\n")
        var count = 0
        for rline in result_lines:
            if rline.trim() != "" and count < 30:
                print rline
                count = count + 1
    elif direction == "subtypes":
        val (trait_out, _) = safe_grep("^trait " + clean_sym, "src/", "*.spl")
        if trait_out.trim() == "":
            print "No trait definition found for: {clean_sym}"
            return 0
        val (impls_out, _2) = safe_grep("impl " + clean_sym + " ", "src/", "*.spl")
        if impls_out.trim() == "":
            print "No subtypes (implementors) found for trait: {clean_sym}"
            return 0
        print "--- Subtypes (implementors) of trait {clean_sym} ---"
        val impl_lines = impls_out.split("\n")
        var count = 0
        for rline in impl_lines:
            if rline.trim() != "" and count < 30:
                print rline
                count = count + 1
    else:
        print "Error: --direction must be 'supertypes' or 'subtypes'"
        return 1
    0

fn query_semantic_tokens(file: text, cmd_args: [text]) -> i64:
    val clean_file = sanitize_path(file)
    if clean_file == "":
        print "Error: invalid file path"
        return 1
    val start_line_str = _extract_flag(cmd_args, "--start-line", "1")
    val end_line_str = _extract_flag(cmd_args, "--end-line", "0")
    val start_line = start_line_str.to_int()
    var end_line = end_line_str.to_int()

    val content = query_file_read(clean_file)
    if content == "":
        print "Could not read file: {clean_file}"
        return 1

    val lines = content.split("\n")
    if end_line <= 0 or end_line > lines.len():
        end_line = lines.len()

    # Build symbol sets from outline for classification
    var fn_names: [text] = []
    var type_names: [text] = []
    var param_names: [text] = []
    _collect_symbol_sets(content, fn_names, type_names, param_names)

    val keywords = "fn,class,struct,enum,trait,if,elif,else,for,while,match,case,return,val,var,use,import,export,extern,static,me,break,continue,in,not,and,or,true,false,nil,self,impl,type,alias"
    val kw_list = keywords.split(",")

    val operators = "->,:=,==,!=,>=,<=,|>,>>,~>,**,+=,-=,*=,/=,%=,??,?.,.?"
    val op_list = operators.split(",")

    var token_count = 0
    var li = start_line
    while li <= end_line and li <= lines.len():
        val line = lines[li - 1]
        var ci = 0
        while ci < line.len() and token_count < 500:
            val ch = line.substring(ci, ci + 1)

            if ch == " " or ch == "\t":
                ci = ci + 1
                continue

            # Comment
            if ch == "#":
                val comment_len = line.len() - ci
                print "{li}:{ci}:{comment_len}:comment"
                token_count = token_count + 1
                break

            # String literal
            if ch == "\"":
                var si = ci + 1
                while si < line.len():
                    val sc = line.substring(si, si + 1)
                    if sc == "\\":
                        si = si + 2
                        continue
                    if sc == "\"":
                        si = si + 1
                        break
                    si = si + 1
                val str_len = si - ci
                print "{li}:{ci}:{str_len}:string"
                token_count = token_count + 1
                ci = si
                continue

            # Number
            val is_digit = ch >= "0" and ch <= "9"
            if is_digit:
                var ni = ci + 1
                while ni < line.len():
                    val nc = line.substring(ni, ni + 1)
                    val nd = nc >= "0" and nc <= "9"
                    if (not nd and nc != "." and nc != "_" and
                        nc != "x" and nc != "b" and nc != "o" and
                        nc != "a" and nc != "c" and nc != "d" and
                        nc != "e" and nc != "f" and nc != "A" and
                        nc != "B" and nc != "C" and nc != "D" and
                        nc != "E" and nc != "F"):
                        break
                    ni = ni + 1
                val num_len = ni - ci
                print "{li}:{ci}:{num_len}:number"
                token_count = token_count + 1
                ci = ni
                continue

            # Identifier or keyword
            val is_alpha = (ch >= "a" and ch <= "z") or (ch >= "A" and ch <= "Z") or ch == "_"
            if is_alpha:
                var wi = ci + 1
                while wi < line.len():
                    val wc = line.substring(wi, wi + 1)
                    val ww = (wc >= "a" and wc <= "z") or (wc >= "A" and wc <= "Z") or (wc >= "0" and wc <= "9") or wc == "_"
                    if not ww:
                        break
                    wi = wi + 1
                val word = line.substring(ci, wi)
                val word_len = wi - ci

                val token_type = _classify_token(word, ci, line, kw_list, fn_names, type_names, param_names)
                print "{li}:{ci}:{word_len}:{token_type}"
                token_count = token_count + 1
                ci = wi
                continue

            # Operator (multi-char)
            if ci + 1 < line.len():
                val two = line.substring(ci, ci + 2)
                var is_op = false
                for op in op_list:
                    if two == op:
                        is_op = true
                        break
                if is_op:
                    print "{li}:{ci}:2:operator"
                    token_count = token_count + 1
                    ci = ci + 2
                    continue

            ci = ci + 1

        li = li + 1

    if token_count >= 500:
        print "# (truncated at 500 tokens)"
    0

fn query_inlay_hints(file: text, cmd_args: [text]) -> i64:
    val clean_file = sanitize_path(file)
    if clean_file == "":
        print "Error: invalid file path"
        return 1
    val start_line_str = _extract_flag(cmd_args, "--start-line", "1")
    val end_line_str = _extract_flag(cmd_args, "--end-line", "0")
    val start_line = start_line_str.to_int()
    var end_line = end_line_str.to_int()

    val content = query_file_read(clean_file)
    if content == "":
        print "Could not read file: {clean_file}"
        return 1

    val lines = content.split("\n")
    if end_line <= 0 or end_line > lines.len():
        end_line = lines.len()

    # Build function return type map from outline for better inference
    var fn_names: [text] = []
    var fn_returns: [text] = []
    _collect_fn_return_types(content, fn_names, fn_returns)

    var hint_count = 0
    var li = start_line
    while li <= end_line and li <= lines.len():
        val line = lines[li - 1]
        val trimmed = line.trim()

        var binding_prefix = ""
        var name_start = 0
        if trimmed.starts_with("val "):
            binding_prefix = "val"
            name_start = 4
        elif trimmed.starts_with("var "):
            binding_prefix = "var"
            name_start = 4

        if binding_prefix != "":
            val after_kw = trimmed.substring(name_start)
            var name_chars: [text] = []
            var ni = 0
            for nc in after_kw:
                val nw = (nc >= "a" and nc <= "z") or (nc >= "A" and nc <= "Z") or (nc >= "0" and nc <= "9") or nc == "_"
                if not nw:
                    break
                name_chars.push(nc)
                ni = ni + 1
            val var_name = name_chars.join("")

            if var_name != "":
                val after_name = after_kw.substring(ni).trim()
                var has_annotation = false
                if after_name.starts_with(":"):
                    if after_name.len() > 1:
                        val next = after_name.substring(1, 2)
                        if next != "=":
                            has_annotation = true

                if not has_annotation and after_name.contains("="):
                    var eq_pos = 0
                    var found_eq = false
                    var eqi = 0
                    for ec in after_name:
                        if ec == "=" and not found_eq:
                            eq_pos = eqi
                            found_eq = true
                            break
                        eqi = eqi + 1
                    if found_eq:
                        val rhs = after_name.substring(eq_pos + 1).trim()
                        val inferred = _infer_type_from_rhs(rhs, fn_names, fn_returns)
                        if inferred != "":
                            val indent_len = line.len() - trimmed.len()
                            val col_pos = indent_len + name_start + var_name.len()
                            print "{li}:{col_pos}: {var_name}: {inferred}"
                            hint_count = hint_count + 1

        li = li + 1

    if hint_count == 0:
        print "No inlay hints in range"
    0

fn _infer_type_from_rhs(rhs: text, fn_names: [text], fn_returns: [text]) -> text:
    if rhs == "":
        return ""

    val first = rhs.substring(0, 1)

    if first == "\"":
        return "text"
    if rhs == "true" or rhs == "false":
        return "bool"
    if rhs == "nil":
        return "nil"
    if first == "[":
        return "array"
    if first == "(" and rhs.contains(","):
        return "tuple"

    # Negative number
    if first == "-" and rhs.len() > 1:
        val second = rhs.substring(1, 2)
        val is_d = second >= "0" and second <= "9"
        if is_d:
            if rhs.contains("."):
                return "f64"
            return "i64"

    val is_digit = first >= "0" and first <= "9"
    if is_digit:
        if rhs.starts_with("0x") or rhs.starts_with("0b") or rhs.starts_with("0o"):
            return "i64"
        if rhs.contains("."):
            return "f64"
        return "i64"

    # Function call — look up return type from outline
    if rhs.contains("("):
        val call_name = _extract_call_name(rhs)
        if call_name != "":
            var fi = 0
            while fi < fn_names.len():
                if fn_names[fi] == call_name:
                    if fi < fn_returns.len() and fn_returns[fi] != "":
                        return fn_returns[fi]
                fi = fi + 1
        return "inferred"

    ""

fn query_selection_range(file: text, line_num: i64, col: i64) -> i64:
    val content = query_file_read(file)
    if content == "":
        print "Could not read file: {file}"
        return 1

    val lines = content.split("\n")
    if line_num < 1 or line_num > lines.len():
        print "Line {line_num} out of range (file has {lines.len()} lines)"
        return 1

    val target_line = lines[line_num - 1]
    val target_indent = _count_indent(target_line)

    # 1. Word at cursor
    var word_start = col - 1
    var word_end = col - 1
    if col > 0 and col <= target_line.len():
        for _i in range(0, col):
            if word_start <= 0:
                break
            val ch = target_line.substring(word_start - 1, word_start)
            val iw = (ch >= "a" and ch <= "z") or (ch >= "A" and ch <= "Z") or (ch >= "0" and ch <= "9") or ch == "_"
            if not iw:
                break
            word_start = word_start - 1
        for _i in range(0, 200):
            if word_end >= target_line.len():
                break
            val ch = target_line.substring(word_end, word_end + 1)
            val iw = (ch >= "a" and ch <= "z") or (ch >= "A" and ch <= "Z") or (ch >= "0" and ch <= "9") or ch == "_"
            if not iw:
                break
            word_end = word_end + 1
    print "Range: {line_num}:{word_start} - {line_num}:{word_end} (word)"

    # 2. Full line (trimmed content)
    val trim_start = target_indent
    val trim_end = target_line.len()
    print "Range: {line_num}:{trim_start} - {line_num}:{trim_end} (expression)"

    # 3. Full line including indent
    print "Range: {line_num}:0 - {line_num}:{target_line.len()} (line)"

    # 4. Block at same or deeper indent level
    var block_start = line_num
    var bi = line_num - 2
    while bi >= 0:
        val bl = lines[bi]
        if bl.trim() == "":
            bi = bi - 1
            continue
        val bi_indent = _count_indent(bl)
        if bi_indent < target_indent:
            break
        block_start = bi + 1
        bi = bi - 1
    var block_end = line_num
    var bj = line_num
    while bj < lines.len():
        val bl = lines[bj]
        if bl.trim() == "":
            bj = bj + 1
            continue
        val bj_indent = _count_indent(bl)
        if bj_indent < target_indent:
            break
        block_end = bj + 1
        bj = bj + 1
    print "Range: {block_start}:0 - {block_end}:{lines[block_end - 1].len()} (block)"

    # 5. Enclosing function or class
    var enclosing_start = -1
    var ei = line_num - 2
    while ei >= 0:
        val el = lines[ei]
        val et = el.trim()
        val starts_fn = et.starts_with("fn ")
        val starts_class = et.starts_with("class ")
        val starts_struct = et.starts_with("struct ")
        if starts_fn or starts_class or starts_struct:
            enclosing_start = ei + 1
            break
        ei = ei - 1
    if enclosing_start > 0:
        # Find end of enclosing block
        var enc_end = enclosing_start
        var ej = enclosing_start
        while ej < lines.len():
            val el = lines[ej]
            if el.trim() == "":
                ej = ej + 1
                continue
            val ej_indent = _count_indent(el)
            if ej > enclosing_start and ej_indent == 0:
                break
            enc_end = ej + 1
            ej = ej + 1
        print "Range: {enclosing_start}:0 - {enc_end}:{lines[enc_end - 1].len()} (function)"

    # 6. Entire file
    print "Range: 1:0 - {lines.len()}:{lines[lines.len() - 1].len()} (file)"
    0

fn _count_indent(line: text) -> i64:
    var count = 0
    for ch in line:
        if ch == " ":
            count = count + 1
        elif ch == "\t":
            count = count + 4
        else:
            break
    count

fn query_document_formatting(file: text) -> i64:
    val clean_file = sanitize_path(file)
    if clean_file == "":
        print "Error: invalid file path"
        return 1
    # TODO: fmt command is a stub (cli_run_fmt returns "not implemented").
    # When it is implemented, call it in-process instead of via subprocess.
    val out = ""
    val code = 0
    if out.trim() != "":
        print out
    else:
        if code == 0:
            print "File is already formatted: {clean_file}"
        else:
            print "Formatting failed for: {clean_file}"
    code

# ============================================================================
# Helper Functions
# ============================================================================

fn _has_flag(cmd_args: [text], flag_name: text) -> bool:
    for arg in cmd_args:
        if arg == flag_name:
            return true
    false

fn _replace_word(content: text, old_word: text, new_word: text) -> text:
    # Replace all whole-word occurrences of old_word with new_word
    var result: [text] = []
    var pos = 0
    while pos <= content.len() - old_word.len():
        val candidate = content.substring(pos, pos + old_word.len())
        if candidate == old_word:
            var left_ok = true
            var right_ok = true
            if pos > 0:
                val lch = content.substring(pos - 1, pos)
                val lw = (lch >= "a" and lch <= "z") or (lch >= "A" and lch <= "Z") or (lch >= "0" and lch <= "9") or lch == "_"
                if lw:
                    left_ok = false
            if pos + old_word.len() < content.len():
                val rch = content.substring(pos + old_word.len(), pos + old_word.len() + 1)
                val rw = (rch >= "a" and rch <= "z") or (rch >= "A" and rch <= "Z") or (rch >= "0" and rch <= "9") or rch == "_"
                if rw:
                    right_ok = false
            if left_ok and right_ok:
                result.push(new_word)
                pos = pos + old_word.len()
                continue
        result.push(content.substring(pos, pos + 1))
        pos = pos + 1
    # Remaining chars
    if pos < content.len():
        result.push(content.substring(pos))
    result.join("")

fn _collect_symbol_sets(content: text, fn_names: [text], type_names: [text], param_names: [text]):
    # Scan content for function names, type names, param names
    val lines = content.split("\n")
    for line in lines:
        val trimmed = line.trim()
        if trimmed.starts_with("fn ") or trimmed.starts_with("me "):
            var rest = trimmed
            if rest.starts_with("fn "):
                rest = rest.substring(3)
            elif rest.starts_with("me "):
                rest = rest.substring(3)
            val name = _extract_ident_from(rest)
            if name != "":
                fn_names.push(name)
            # Extract param names
            val params = _extract_params_from(rest)
            val param_list = params.split(",")
            for param in param_list:
                val pt = param.trim()
                val pname = _extract_ident_from(pt)
                if pname != "":
                    param_names.push(pname)
        elif trimmed.starts_with("static fn "):
            val name = _extract_ident_from(trimmed.substring(10))
            if name != "":
                fn_names.push(name)
        elif trimmed.starts_with("class "):
            val name = _extract_ident_from(trimmed.substring(6))
            if name != "":
                type_names.push(name)
        elif trimmed.starts_with("struct "):
            val name = _extract_ident_from(trimmed.substring(7))
            if name != "":
                type_names.push(name)
        elif trimmed.starts_with("enum "):
            val name = _extract_ident_from(trimmed.substring(5))
            if name != "":
                type_names.push(name)
        elif trimmed.starts_with("trait "):
            val name = _extract_ident_from(trimmed.substring(6))
            if name != "":
                type_names.push(name)

fn _classify_token(word: text, col: i64, line: text, kw_list: [text], fn_names: [text], type_names: [text], param_names: [text]) -> text:
    # Check keyword first
    for kw in kw_list:
        if word == kw:
            return "keyword"

    # Check if it's a type name (starts with uppercase)
    val first = word.substring(0, 1)
    val is_upper = first >= "A" and first <= "Z"
    if is_upper:
        for tn in type_names:
            if word == tn:
                return "type"
        return "type"

    # Check if it's a function name
    for fn_name in fn_names:
        if word == fn_name:
            # Check if followed by ( on this line
            val after_pos = col + word.len()
            if after_pos < line.len():
                val next_ch = line.substring(after_pos, after_pos + 1)
                if next_ch == "(":
                    return "function"
            return "function"

    # Check if it's a parameter
    for pn in param_names:
        if word == pn:
            return "parameter"

    # Check if preceded by . (property access)
    if col > 0:
        val prev = line.substring(col - 1, col)
        if prev == ".":
            return "property"

    # Check if self
    if word == "self":
        return "keyword"

    "variable"

fn _collect_fn_return_types(content: text, fn_names: [text], fn_returns: [text]):
    val lines = content.split("\n")
    for line in lines:
        val trimmed = line.trim()
        var rest = ""
        if trimmed.starts_with("fn "):
            rest = trimmed.substring(3)
        elif trimmed.starts_with("static fn "):
            rest = trimmed.substring(10)
        elif trimmed.starts_with("me "):
            rest = trimmed.substring(3)
        elif trimmed.starts_with("extern fn "):
            rest = trimmed.substring(10)
        if rest != "":
            val name = _extract_ident_from(rest)
            val ret = _extract_return_from(rest)
            fn_names.push(name)
            fn_returns.push(ret)

fn _extract_ident_from(s: text) -> text:
    var end_pos = 0
    while end_pos < s.len():
        val ch = s.substring(end_pos, end_pos + 1)
        val ok = (ch >= "a" and ch <= "z") or (ch >= "A" and ch <= "Z") or (ch >= "0" and ch <= "9") or ch == "_"
        if not ok:
            break
        end_pos = end_pos + 1
    if end_pos == 0:
        return ""
    s.substring(0, end_pos)

fn _extract_params_from(s: text) -> text:
    var paren_start = -1
    var pi = 0
    while pi < s.len():
        if s.substring(pi, pi + 1) == "(":
            paren_start = pi
            break
        pi = pi + 1
    if paren_start < 0:
        return ""
    var depth = 0
    var paren_end = -1
    var qi = paren_start
    while qi < s.len():
        val ch = s.substring(qi, qi + 1)
        if ch == "(":
            depth = depth + 1
        elif ch == ")":
            depth = depth - 1
            if depth == 0:
                paren_end = qi
                break
        qi = qi + 1
    if paren_end < 0:
        return ""
    s.substring(paren_start + 1, paren_end)

fn _extract_return_from(s: text) -> text:
    var ai = 0
    while ai < s.len() - 1:
        val two = s.substring(ai, ai + 2)
        if two == "->":
            val after = s.substring(ai + 2).trim()
            var end_pos = 0
            while end_pos < after.len():
                val ch = after.substring(end_pos, end_pos + 1)
                if ch == ":":
                    break
                end_pos = end_pos + 1
            return after.substring(0, end_pos).trim()
        ai = ai + 1
    ""

fn query_ast_query(cmd_args: [text]) -> i64:
    if cmd_args.len() < 2:
        print "Error: ast-query requires a pattern argument"
        print "Usage: simple query ast-query '(node_kind pred: \"value\")' [--files path] [--format text|json|compact]"
        return 1
    val query_str = cmd_args[1]
    val files_arg = _extract_flag(cmd_args, "--files", "src/")
    val format_str = _extract_flag(cmd_args, "--format", "text")
    var files: [text] = [files_arg]
    engine_ast_query(query_str, files, format_str)

fn query_sem_query(cmd_args: [text]) -> i64:
    if cmd_args.len() < 2:
        print "Error: sem-query requires a query argument"
        print "Usage: simple query sem-query 'FIND <target> WHERE <pred>' [--files path] [--format text|json|compact]"
        return 1
    val query_str = cmd_args[1]
    val files_arg = _extract_flag(cmd_args, "--files", "src/")
    val format_str = _extract_flag(cmd_args, "--format", "text")
    var files: [text] = [files_arg]
    engine_sem_query(query_str, files, format_str)

fn query_query_schema(cmd_args: [text]) -> i64:
    var kind = ""
    if cmd_args.len() >= 2:
        kind = cmd_args[1]
    engine_query_schema(kind)

fn _extract_call_name(rhs: text) -> text:
    # Extract function name from a call expression like "foo(x, y)"
    var end_pos = 0
    while end_pos < rhs.len():
        val ch = rhs.substring(end_pos, end_pos + 1)
        if ch == "(":
            break
        end_pos = end_pos + 1
    if end_pos == 0:
        return ""
    # Handle method calls: obj.method( -> take "method"
    var name_part = rhs.substring(0, end_pos)
    var dot_pos = -1
    var di = 0
    while di < name_part.len():
        if name_part.substring(di, di + 1) == ".":
            dot_pos = di
        di = di + 1
    if dot_pos >= 0:
        name_part = name_part.substring(dot_pos + 1)
    name_part.trim()
