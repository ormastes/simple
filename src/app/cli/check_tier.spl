# Project-Wide Tier Checker
#
# Scans project for tier configuration at three levels (project, module, file)
# and validates that all .spl files stay within their effective tier's grammar.
#
# Three-level resolution (highest to lowest priority):
#   1. File directive: `# tier: X` in first 5 lines
#   2. Module arch block: `arch { tier = "X" }` in nearest __init__.spl
#   3. Project config: `tier: X` in simple.sdn
#   4. Default: full
#
# Usage:
#   simple check-tier              Check all .spl files in project
#   simple check-tier src/compiler Check specific directory
#   simple check-tier --verbose    Show per-file tier assignments

extern fn rt_file_read_text(path: text) -> text
extern fn rt_file_exists(path: text) -> bool

use app.io.mod (cwd, shell)
use std.text.{NL}

# ============================================================================
# Tier keyword data (passed as parameter, no module-level mutable state)
# ============================================================================

struct TierKeywords:
    seed: [text]
    core: [text]
    full: [text]

fn load_tier_kw(sdn_path: text) -> TierKeywords:
    """Load tier_keywords.sdn and return keyword sets."""
    var seed: [text] = []
    var core: [text] = []
    var full: [text] = []

    val text_content = rt_file_read_text(sdn_path) ?? ""
    if text_content == "":
        return TierKeywords(seed: seed, core: core, full: full)

    var current_section = ""
    val lines = text_content.split("\n")
    for line in lines:
        val trimmed = line.trim()
        if trimmed == "": continue
        if trimmed.starts_with("#"): continue

        if trimmed.starts_with("["):
            var header = trimmed.replace("[", "")
            header = header.replace("]", "")
            val parts = header.split(".")
            current_section = parts[0]
            continue

        if current_section != "keywords": continue

        if trimmed.contains("="):
            val eq_idx = trimmed.index_of("=") ?? -1
            if eq_idx > 0:
                val key = trimmed.slice(0, eq_idx).trim()
                var value_part = trimmed.slice(eq_idx + 1, trimmed.len()).trim()
                value_part = value_part.replace("\"", "")

                if value_part == "seed":
                    seed = seed + [key]
                elif value_part == "core":
                    core = core + [key]
                elif value_part == "full":
                    full = full + [key]
    TierKeywords(seed: seed, core: core, full: full)

fn kw_is_allowed(keyword: text, tier: text, kw: TierKeywords) -> bool:
    """Check if a keyword is allowed in the given tier."""
    for k in kw.seed:
        if k == keyword: return true
    if tier == "seed": return false
    for k in kw.core:
        if k == keyword: return true
    if tier == "core": return false
    for k in kw.full:
        if k == keyword: return true
    false

fn kw_is_any(word: text, kw: TierKeywords) -> bool:
    """Check if a word is any known keyword."""
    for k in kw.seed:
        if k == word: return true
    for k in kw.core:
        if k == word: return true
    for k in kw.full:
        if k == word: return true
    false

fn find_word_col(line: text, word: text) -> i64:
    """Find the column position of a word in a line."""
    val idx = line.index_of(word) ?? -1
    if idx >= 0: return idx + 1
    1

# Operator tier data (hardcoded since they're character patterns, not words)
struct OpPattern:
    pattern: text
    tier: text
    name: text

fn get_core_op_patterns() -> [OpPattern]:
    """Return operator patterns that are core-tier (not available in seed)."""
    var ops: [OpPattern] = []
    ops = ops + [OpPattern(pattern: "??", tier: "core", name: "null_coalesce")]
    ops = ops + [OpPattern(pattern: ".?", tier: "core", name: "optional_chain")]
    ops = ops + [OpPattern(pattern: "?.", tier: "core", name: "optional_chain")]
    ops = ops + [OpPattern(pattern: "|>", tier: "core", name: "pipe_forward")]
    ops = ops + [OpPattern(pattern: "**", tier: "core", name: "power")]
    ops = ops + [OpPattern(pattern: "..=", tier: "core", name: "inclusive_range")]
    ops = ops + [OpPattern(pattern: ":=", tier: "core", name: "walrus")]
    ops

fn get_full_op_patterns() -> [OpPattern]:
    """Return operator patterns that are full-tier (not available in core)."""
    var ops: [OpPattern] = []
    ops = ops + [OpPattern(pattern: ".+", tier: "full", name: "broadcast_add")]
    ops = ops + [OpPattern(pattern: ".-", tier: "full", name: "broadcast_sub")]
    ops = ops + [OpPattern(pattern: ".*", tier: "full", name: "broadcast_mul")]
    ops = ops + [OpPattern(pattern: "./", tier: "full", name: "broadcast_div")]
    ops = ops + [OpPattern(pattern: ".^", tier: "full", name: "broadcast_pow")]
    ops = ops + [OpPattern(pattern: "~>", tier: "full", name: "layer_connect")]
    ops = ops + [OpPattern(pattern: "<<<", tier: "full", name: "gpu_launch_start")]
    ops = ops + [OpPattern(pattern: ">>>", tier: "full", name: "gpu_launch_end")]
    ops

fn check_line_operators(code_line: text, tier: text) -> [OpPattern]:
    """Check a code line for operator patterns not allowed in the given tier.
    Returns list of violated patterns."""
    var violations: [OpPattern] = []

    if tier == "seed":
        val core_ops = get_core_op_patterns()
        for op in core_ops:
            if code_line.contains(op.pattern):
                violations = violations + [op]

    if tier == "seed" or tier == "core":
        val full_ops = get_full_op_patterns()
        for op in full_ops:
            if code_line.contains(op.pattern):
                violations = violations + [op]

    violations

fn check_line_lambda(code_line: text, tier: text) -> bool:
    """Check if a code line contains lambda syntax (backslash + identifier).
    Lambda is core-tier, not available in seed."""
    if tier != "seed":
        return false
    # Lambda pattern: \ followed by a letter (not in a string since code_line is stripped)
    var i = 0
    val n = code_line.len()
    while i < n:
        val ch = code_line[i : i + 1]
        if ch == "\\":
            if i + 1 < n:
                val next = code_line[i + 1 : i + 2]
                # Lambda: \x or \name
                if (next >= "a" and next <= "z") or (next >= "A" and next <= "Z"):
                    return true
        i = i + 1
    false

fn strip_strings_and_comments(line: text) -> text:
    """Remove string literal contents and inline comments from a code line.
    String content is replaced with spaces; everything after # is removed."""
    var result = ""
    var in_str = false
    var i = 0
    val n = line.len()

    while i < n:
        val ch = line[i : i + 1]

        if in_str:
            if ch == "\\":
                # Skip escaped character
                result = result + "  "
                i = i + 2
                continue
            if ch == "\"":
                in_str = false
                result = result + " "
            else:
                result = result + " "
            i = i + 1
            continue

        # Not in string
        if ch == "#":
            # Inline comment - skip rest of line
            break
        if ch == "\"":
            in_str = true
            result = result + " "
            i = i + 1
            continue

        result = result + ch
        i = i + 1

    result

fn check_one_file(file_path: text, tier: text, kw: TierKeywords) -> i64:
    """Check if a file stays within the given tier's grammar.
    Returns number of violations found."""
    val source = rt_file_read_text(file_path) ?? ""
    if source == "":
        print "Error: could not read {file_path}"
        return -1

    var violations = 0
    var line_num = 1
    var in_docstring = false
    val lines = source.split("\n")

    for line in lines:
        val trimmed = line.trim()

        if trimmed == "":
            line_num = line_num + 1
            continue

        # --- Docstring tracking ---
        if in_docstring:
            if trimmed.contains("\"\"\""):
                in_docstring = false
            line_num = line_num + 1
            continue

        # Check for opening """ (docstring)
        if trimmed.contains("\"\"\""):
            val first_idx = trimmed.index_of("\"\"\"") ?? -1
            if first_idx >= 0:
                val after_first = trimmed.slice(first_idx + 3, trimmed.len())
                if not after_first.contains("\"\"\""):
                    # Opening of multi-line docstring - skip line
                    in_docstring = true
                    line_num = line_num + 1
                    continue
                # Single-line docstring (""" ... """) - skip this line entirely
                line_num = line_num + 1
                continue

        # Skip comment-only lines
        if trimmed.starts_with("#"):
            line_num = line_num + 1
            continue

        # Skip import/use/from lines - module paths contain identifiers, not keyword usage
        if trimmed.starts_with("use ") or trimmed.starts_with("import ") or trimmed.starts_with("from "):
            line_num = line_num + 1
            continue

        # Skip export lines - just re-exporting symbols
        if trimmed.starts_with("export "):
            line_num = line_num + 1
            continue

        # Strip string literal contents and inline comments
        val code_only = strip_strings_and_comments(trimmed)

        # Inline word extraction: replace punctuation with spaces, split, filter empties
        var cleaned = code_only
        cleaned = cleaned.replace("(", " ")
        cleaned = cleaned.replace(")", " ")
        cleaned = cleaned.replace(":", " ")
        cleaned = cleaned.replace(",", " ")
        cleaned = cleaned.replace(".", " ")
        cleaned = cleaned.replace("[", " ")
        cleaned = cleaned.replace("]", " ")
        cleaned = cleaned.replace("{", " ")
        cleaned = cleaned.replace("}", " ")
        cleaned = cleaned.replace("<", " ")
        cleaned = cleaned.replace(">", " ")
        cleaned = cleaned.replace("=", " ")
        cleaned = cleaned.replace("+", " ")
        cleaned = cleaned.replace("-", " ")
        cleaned = cleaned.replace("*", " ")
        cleaned = cleaned.replace("/", " ")
        cleaned = cleaned.replace("!", " ")
        cleaned = cleaned.replace("@", " ")
        cleaned = cleaned.replace("$", " ")
        cleaned = cleaned.replace("%", " ")
        cleaned = cleaned.replace("^", " ")
        cleaned = cleaned.replace("&", " ")
        cleaned = cleaned.replace("|", " ")
        cleaned = cleaned.replace("~", " ")
        cleaned = cleaned.replace("`", " ")
        cleaned = cleaned.replace("?", " ")
        cleaned = cleaned.replace(";", " ")
        cleaned = cleaned.replace("\"", " ")
        val parts = cleaned.split(" ")

        for word in parts:
            if word.len() == 0:
                continue
            if kw_is_any(word, kw):
                if not kw_is_allowed(word, tier, kw):
                    val word_col = find_word_col(line, word)
                    print "{file_path}:{line_num}:{word_col}: error: '{word}' not available in {tier} tier"
                    violations = violations + 1

        # --- Operator/construct checks (on stripped code, before punctuation replacement) ---
        val op_violations = check_line_operators(code_only, tier)
        for op in op_violations:
            val op_col = find_word_col(line, op.pattern)
            print "{file_path}:{line_num}:{op_col}: error: '{op.pattern}' ({op.name}) not available in {tier} tier"
            violations = violations + 1

        if check_line_lambda(code_only, tier):
            val lam_col = find_word_col(line, "\\")
            print "{file_path}:{line_num}:{lam_col}: error: lambda (\\x:) not available in {tier} tier"
            violations = violations + 1

        line_num = line_num + 1
    violations

# ============================================================================
# String helper (local, avoids import issues)
# ============================================================================

fn _trim(s: text) -> text:
    var start = 0
    var end = s.len()
    while start < end:
        val ch = s[start : start + 1]
        if ch == " " or ch == "\t" or ch == "\r":
            start = start + 1
        else:
            break
    while end > start:
        val ch = s[end - 1 : end]
        if ch == " " or ch == "\t" or ch == "\r":
            end = end - 1
        else:
            break
    s[start : end]

# ============================================================================
# Tier reading functions
# ============================================================================

fn read_project_tier(root: text) -> text:
    """Read tier from simple.sdn in the given root directory."""
    val sdn_path = "{root}/simple.sdn"
    if not rt_file_exists(sdn_path):
        return ""
    val content = rt_file_read_text(sdn_path) ?? ""
    if content == "":
        return ""

    var in_project = false
    val lines = content.split("\n")
    for line in lines:
        val trimmed = _trim(line)
        if trimmed == "" or trimmed.starts_with("#"):
            continue

        # Detect indent level
        var indent = 0
        var i = 0
        while i < line.len():
            val ch = line[i : i + 1]
            if ch == " ":
                indent = indent + 1
            elif ch == "\t":
                indent = indent + 4
            else:
                break
            i = i + 1

        # Top-level section headers
        if indent == 0 and trimmed.ends_with(":"):
            in_project = trimmed == "project:"
            continue

        # Look for tier key under project section
        if in_project and indent >= 2:
            if trimmed.starts_with("tier:"):
                val value = _trim(trimmed[5:])
                # Strip quotes if present
                if value.len() >= 2:
                    if (value.starts_with("\"") and value.ends_with("\"")) or (value.starts_with("'") and value.ends_with("'")):
                        return value[1 : value.len() - 1]
                return value
    ""

fn read_module_tier(init_path: text) -> text:
    """Read tier from arch { tier = "X" } in an __init__.spl file."""
    if not rt_file_exists(init_path):
        return ""
    val content = rt_file_read_text(init_path) ?? ""
    if content == "":
        return ""

    if not content.contains("arch {"):
        return ""

    val lines = content.split("\n")
    var in_arch = false
    var brace_depth = 0

    for line in lines:
        val trimmed = _trim(line)
        if trimmed.len() == 0:
            continue

        if trimmed == "arch {" or trimmed.starts_with("arch {"):
            in_arch = true
            brace_depth = 1
            continue

        if not in_arch:
            continue

        # Track brace depth
        for ch in trimmed:
            if ch == "{":
                brace_depth = brace_depth + 1
            elif ch == "}":
                brace_depth = brace_depth - 1

        if brace_depth <= 0:
            in_arch = false
            continue

        # Look for tier = "X"
        if trimmed.starts_with("tier"):
            var eq_pos = -1
            var j = 0
            while j < trimmed.len():
                val ch = trimmed[j : j + 1]
                if ch == "=":
                    eq_pos = j
                    break
                j = j + 1
            if eq_pos >= 0:
                val after = _trim(trimmed[eq_pos + 1:])
                if after.len() >= 2:
                    if (after.starts_with("\"") and after.ends_with("\"")) or (after.starts_with("'") and after.ends_with("'")):
                        return after[1 : after.len() - 1]
                return after
    ""

fn read_file_tier(file_path: text) -> text:
    """Read tier from `# tier: X` directive in first 5 lines of a .spl file."""
    val content = rt_file_read_text(file_path) ?? ""
    if content == "":
        return ""

    val lines = content.split("\n")
    var count = 0
    for line in lines:
        if count >= 5:
            break
        val trimmed = _trim(line)
        if trimmed.starts_with("# tier:"):
            val value = _trim(trimmed[7:])
            return value
        count = count + 1
    ""

# ============================================================================
# Module tier scanning - find all __init__.spl with tier config
# ============================================================================

struct ModuleTier:
    dir_path: text
    tier: text

fn scan_module_tiers(root: text) -> [ModuleTier]:
    """Find all __init__.spl files and extract tier configurations."""
    var result: [ModuleTier] = []

    val find_result = shell("find '{root}' -name '__init__.spl' -type f 2>/dev/null | sort")
    if find_result.exit_code != 0:
        return result

    val stdout = find_result.stdout
    if stdout.len() == 0:
        return result

    val files = stdout.split("\n")
    for file_path in files:
        val trimmed = _trim(file_path)
        if trimmed.len() == 0:
            continue

        val tier = read_module_tier(trimmed)
        if tier != "":
            # Extract directory path (remove /__init__.spl suffix)
            val init_suffix = "/__init__.spl"
            var dir_path = trimmed
            if dir_path.ends_with(init_suffix):
                dir_path = dir_path[0 : dir_path.len() - init_suffix.len()]
            result = result + [ModuleTier(dir_path: dir_path, tier: tier)]

    result

# ============================================================================
# Tier resolution
# ============================================================================

fn find_nearest_module_tier(file_path: text, module_tiers: [ModuleTier]) -> text:
    """Find the nearest ancestor __init__.spl with a tier setting."""
    var best_tier = ""
    var best_len = 0

    for mt in module_tiers:
        val prefix = mt.dir_path + "/"
        if file_path.starts_with(prefix):
            if mt.dir_path.len() > best_len:
                best_len = mt.dir_path.len()
                best_tier = mt.tier
    best_tier

fn resolve_effective_tier(file_path: text, project_tier: text, module_tiers: [ModuleTier]) -> text:
    """Resolve effective tier for a file using cascading priority."""
    # 1. File-level directive (highest priority)
    val file_tier = read_file_tier(file_path)
    if file_tier != "":
        return file_tier

    # 2. Nearest module-level arch block
    val mod_tier = find_nearest_module_tier(file_path, module_tiers)
    if mod_tier != "":
        return mod_tier

    # 3. Project-level config
    if project_tier != "":
        return project_tier

    # 4. Default
    "full"

# ============================================================================
# Tier ordering for constraint checking
# ============================================================================

fn tier_level(tier: text) -> i64:
    """Convert tier name to numeric level for comparison."""
    if tier == "seed": return 0
    if tier == "core": return 1
    if tier == "full": return 2
    2

# ============================================================================
# Main entry point
# ============================================================================

fn run_check_tier(args: [text]) -> i64:
    """Run project-wide tier check. Returns 0 on success, 1 on failure."""
    var root = cwd()
    var verbose = false
    var scan_dir = ""

    for arg in args:
        if arg == "--verbose" or arg == "-v":
            verbose = true
        elif arg == "-h" or arg == "--help":
            print "Usage: simple check-tier [dir] [options]"
            print ""
            print "Check all .spl files against their effective tier grammar."
            print ""
            print "Tier resolution (highest to lowest priority):"
            print "  1. File directive:  # tier: seed  (first 5 lines)"
            print "  2. Module arch:     arch { tier = \"core\" }  (__init__.spl)"
            print "  3. Project config:  tier: core  (simple.sdn)"
            print "  4. Default:         full"
            print ""
            print "Options:"
            print "  [dir]       Directory to check (default: project root)"
            print "  --verbose   Show per-file tier assignments"
            print "  -h, --help  Show this help"
            return 0
        elif not arg.starts_with("-"):
            scan_dir = arg

    # Load tier keyword definitions
    val sdn_path = "doc/spec/grammar/tier_keywords.sdn"
    val kw = load_tier_kw(sdn_path)
    if kw.seed.len() == 0 and kw.core.len() == 0 and kw.full.len() == 0:
        print "Error: could not load {sdn_path}"
        return 1

    # Read project-level tier
    val project_tier = read_project_tier(root)
    if verbose and project_tier != "":
        print "Project tier: {project_tier} (from simple.sdn)"

    # Scan all module tiers
    val module_tiers = scan_module_tiers(root)
    if verbose and module_tiers.len() > 0:
        print "Module tiers found: {module_tiers.len()}"
        for mt in module_tiers:
            var rel = mt.dir_path
            val root_prefix = root + "/"
            if rel.starts_with(root_prefix):
                rel = rel[root_prefix.len():]
            print "  {rel}: {mt.tier}"
        print ""

    # Determine which directory to scan
    var search_root = root
    if scan_dir != "":
        if scan_dir.starts_with("/"):
            search_root = scan_dir
        else:
            search_root = "{root}/{scan_dir}"

    # Find all .spl files to check
    val find_result = shell("find '{search_root}' -name '*.spl' -type f ! -name '__init__.spl' 2>/dev/null | sort")
    if find_result.exit_code != 0:
        print "Error: could not scan {search_root}"
        return 1

    val stdout = find_result.stdout
    if stdout.len() == 0:
        print "No .spl files found in {search_root}"
        return 0

    val files = stdout.split("\n")

    # Group files by effective tier for efficient checking
    var seed_files: [text] = []
    var core_files: [text] = []
    var full_files: [text] = []
    var file_count = 0

    for file_path in files:
        val trimmed = _trim(file_path)
        if trimmed.len() == 0:
            continue

        val effective = resolve_effective_tier(trimmed, project_tier, module_tiers)

        if verbose:
            var rel = trimmed
            val root_prefix = root + "/"
            if rel.starts_with(root_prefix):
                rel = rel[root_prefix.len():]
            if effective != "full":
                print "  {rel} -> {effective}"

        if effective == "seed":
            seed_files = seed_files + [trimmed]
        elif effective == "core":
            core_files = core_files + [trimmed]
        else:
            full_files = full_files + [trimmed]
        file_count = file_count + 1

    if verbose:
        print ""

    print "Tier check: {file_count} files ({seed_files.len()} seed, {core_files.len()} core, {full_files.len()} full)"

    # Check each tier group
    var total_violations = 0

    for f in seed_files:
        val v = check_one_file(f, "seed", kw)
        if v > 0:
            total_violations = total_violations + v

    for f in core_files:
        val v = check_one_file(f, "core", kw)
        if v > 0:
            total_violations = total_violations + v

    # full tier files need no checking (everything allowed)

    print ""
    if total_violations > 0:
        print "Found {total_violations} tier violation(s)"
        return 1
    else:
        print "All files pass their tier check"
        return 0

export run_check_tier
export read_project_tier, read_module_tier, read_file_tier
export resolve_effective_tier, scan_module_tiers
export ModuleTier, TierKeywords
