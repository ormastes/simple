# Test Failure Analyzer
#
# Categorize failures by root cause and generate fix recommendations.

use app.io.*
use std.spec.*

struct FailureCategory:
    name: text
    pattern: text
    count: i64
    files: [text]
    fix_command: text

fn analyze_test_failures(test_dir: text) -> [FailureCategory]:
    print "\n=== Test Failure Analysis ==="
    print "Scanning directory: {test_dir}\n"

    var categories: [FailureCategory] = []

    # Category 1: Constructor anti-pattern (.new())
    val new_pattern = detect_pattern(test_dir, "\\.new\\(")
    categories = categories + [FailureCategory(
        name: "constructor_antipattern",
        pattern: ".new()",
        count: new_pattern.count,
        files: new_pattern.files,
        fix_command: "bin/simple fix-new-constructors {test_dir}"
    )]

    # Category 2: Bare imports
    val import_pattern = detect_bare_imports(test_dir)
    categories = categories + [FailureCategory(
        name: "bare_import",
        pattern: "use module (no .* or .{})",
        count: import_pattern.count,
        files: import_pattern.files,
        fix_command: "bin/simple fix-bare-imports {test_dir} --strategy=wildcard"
    )]

    # Category 3: Inline if-else
    val inline_if = detect_pattern(test_dir, "var .* = if .* else")
    categories = categories + [FailureCategory(
        name: "inline_if_else",
        pattern: "var x = if cond: val else: val",
        count: inline_if.count,
        files: inline_if.files,
        fix_command: "bin/simple fix-inline-if {test_dir}"
    )]

    # Category 4: Static method calls
    val static_calls = detect_pattern(test_dir, "[A-Z][a-zA-Z]*\\.[a-z]")
    categories = categories + [FailureCategory(
        name: "static_method_calls",
        pattern: "ClassName.method()",
        count: static_calls.count,
        files: static_calls.files,
        fix_command: "bin/simple build --bootstrap (rebuild only)"
    )]

    print_analysis_report(categories)
    categories

struct PatternMatch:
    count: i64
    files: [text]

fn detect_pattern(dir: text, pattern: text) -> PatternMatch:
    # Use grep to find pattern occurrences
    val result = process_run("grep", ["-r", "-l", "-E", pattern, dir])
    val stdout = result.0
    var files: [text] = []

    if stdout.len() > 0:
        files = stdout.split("\n")
        # Filter empty lines
        var filtered: [text] = []
        for file in files:
            if file.trim().len() > 0:
                filtered = filtered + [file]
        files = filtered

    PatternMatch(count: files.len(), files: files)

fn detect_bare_imports(dir: text) -> PatternMatch:
    # Find "use module" without .* or .{}
    val result = process_run("grep", ["-r", "-h", "-E", "^use [a-z]", dir])
    val stdout = result.0
    var count = 0
    var files: [text] = []

    if stdout.len() > 0:
        val lines = stdout.split("\n")
        for line in lines:
            val trimmed = line.trim()
            if trimmed.len() > 0:
                # Check if it has .* or .{
                if not trimmed.contains(".*") and not trimmed.contains(".{"):
                    count = count + 1

    # Get unique files
    val file_result = process_run("grep", ["-r", "-l", "-E", "^use [a-z]", dir])
    if file_result.0.len() > 0:
        files = file_result.0.split("\n")

    PatternMatch(count: count, files: files)

fn print_analysis_report(categories: [FailureCategory]):
    print "Test Failure Analysis Report"
    print "Generated: 2026-02-07\n"
    print "Root Cause Categories:\n"

    var index = 1
    for category in categories:
        if category.count > 0:
            print "{index}. {category.name}: {category.count} occurrences across {category.files.len()} files"
            print "   â†’ Fix: {category.fix_command}\n"
            index = index + 1

    print "\nTop Failing Files:"
    # Collect files with occurrence counts across all categories
    var file_counts: Dict<text, i64> = {}
    for category in categories:
        for file in category.files:
            val prev = file_counts[file] ?? 0
            file_counts[file] = prev + 1
    # Print sorted by count (simple approach: iterate and find max)
    var shown = 0
    var used: [text] = []
    for _ in 0..10:
        var best_file = ""
        var best_count = 0
        for file in file_counts.keys():
            val c = file_counts[file] ?? 0
            val already_shown = used.contains(file)
            if c > best_count and not already_shown:
                best_file = file
                best_count = c
        if best_file != "":
            shown = shown + 1
            used.push(best_file)
            print "  {shown}. {best_file} ({best_count} categories)"

fn list_category_files(category: text, categories: [FailureCategory]):
    for cat in categories:
        if cat.name == category:
            print "\nFiles in category '{category}':"
            for file in cat.files:
                print "  - {file}"

# =========================================================================
# Exports
# =========================================================================

export analyze_test_failures
export FailureCategory
export detect_pattern
export list_category_files
