# Shared CLI Argument Parser
#
# Provides declarative CLI argument parsing with automatic help generation.
# Eliminates 280+ lines of manual argument parsing across 4+ entry points.
#
# Usage:
#   val spec = cli_spec()
#     .flag("verbose", "v", "Show detailed output")
#     .option("output", "o", "Output file path", default: "")
#     .positional("input", "Input file or directory")
#   val parsed = parse_cli_args(spec, args)
#   val verbose = parsed.flag("verbose")
#   val output = parsed.option("output")

use std.text.{NL}

# =========================================================================
# Types
# =========================================================================

struct CliFlag:
    long: text
    short: text
    description: text

struct CliOption:
    long: text
    short: text
    description: text
    default: text
    choices: [text]

struct CliPositional:
    name: text
    description: text
    required: bool

struct CliSpec:
    flags: [CliFlag]
    options: [CliOption]
    positionals: [CliPositional]
    program_name: text
    description: text

struct ParsedArgs:
    flag_values: Dict<text, bool>
    option_values: Dict<text, text>
    positional_values: [text]
    remaining: [text]

# =========================================================================
# Builder API
# =========================================================================

fn cli_spec() -> CliSpec:
    """Create a new CLI specification builder.

    Returns: Empty CLI specification
    """
    CliSpec(
        flags: [],
        options: [],
        positionals: [],
        program_name: "",
        description: ""
    )

fn cli_spec_program(spec: CliSpec, name: text, desc: text) -> CliSpec:
    """Set program name and description.

    Args:
        spec: CLI specification
        name: Program name
        desc: Program description

    Returns: Updated specification
    """
    CliSpec(
        flags: spec.flags,
        options: spec.options,
        positionals: spec.positionals,
        program_name: name,
        description: desc
    )

fn cli_spec_flag(spec: CliSpec, long: text, short: text, desc: text) -> CliSpec:
    """Add a boolean flag.

    Args:
        spec: CLI specification
        long: Long flag name (e.g., "verbose")
        short: Short flag name (e.g., "v")
        desc: Flag description

    Returns: Updated specification
    """
    var new_flags = spec.flags
    new_flags.push(CliFlag(long: long, short: short, description: desc))
    CliSpec(
        flags: new_flags,
        options: spec.options,
        positionals: spec.positionals,
        program_name: spec.program_name,
        description: spec.description
    )

fn cli_spec_option(spec: CliSpec, long: text, short: text, desc: text, default: text, choices: [text]) -> CliSpec:
    """Add a value option.

    Args:
        spec: CLI specification
        long: Long option name (e.g., "output")
        short: Short option name (e.g., "o")
        desc: Option description
        default: Default value
        choices: List of valid values (empty for no restriction)

    Returns: Updated specification
    """
    var new_options = spec.options
    new_options.push(CliOption(long: long, short: short, description: desc, default: default, choices: choices))
    CliSpec(
        flags: spec.flags,
        options: new_options,
        positionals: spec.positionals,
        program_name: spec.program_name,
        description: spec.description
    )

fn cli_spec_positional(spec: CliSpec, name: text, desc: text, required: bool) -> CliSpec:
    """Add a positional argument.

    Args:
        spec: CLI specification
        name: Argument name
        desc: Argument description
        required: Whether argument is required

    Returns: Updated specification
    """
    var new_positionals = spec.positionals
    new_positionals.push(CliPositional(name: name, description: desc, required: required))
    CliSpec(
        flags: spec.flags,
        options: spec.options,
        positionals: new_positionals,
        program_name: spec.program_name,
        description: spec.description
    )

# =========================================================================
# Parsing
# =========================================================================

fn parse_cli_args(spec: CliSpec, args: [text]) -> ParsedArgs:
    """Parse command-line arguments according to specification.

    Args:
        spec: CLI specification
        args: Command-line arguments

    Returns: Parsed arguments
    """
    var flag_values = {}
    var option_values = {}
    var positional_values: [text] = []
    var remaining: [text] = []

    # Initialize flag defaults (false)
    for flag in spec.flags:
        flag_values[flag.long] = false

    # Initialize option defaults
    for option in spec.options:
        option_values[option.long] = option.default

    var i = 0
    var skip_next = false
    while i < args.len():
        if skip_next:
            skip_next = false
            i = i + 1
            continue

        val arg = args[i]

        # Check for flags
        var matched = false
        for flag in spec.flags:
            val long_form = "--{flag.long}"
            val short_form = "-{flag.short}"
            if arg == long_form or (flag.short != "" and arg == short_form):
                flag_values[flag.long] = true
                matched = true
                break

        if matched:
            i = i + 1
            continue

        # Check for options (--key=value format)
        for option in spec.options:
            val prefix = "--{option.long}="
            if arg.starts_with(prefix):
                val value = arg[prefix.len():]
                if is_valid_choice(option.choices, value):
                    option_values[option.long] = value
                matched = true
                break

        if matched:
            i = i + 1
            continue

        # Check for options (--key value format)
        for option in spec.options:
            val long_form = "--{option.long}"
            val short_form = "-{option.short}"
            if arg == long_form or (option.short != "" and arg == short_form):
                if i + 1 < args.len():
                    val value = args[i + 1]
                    if is_valid_choice(option.choices, value):
                        option_values[option.long] = value
                    skip_next = true
                matched = true
                break

        if matched:
            i = i + 1
            continue

        # Positional or remaining
        if arg.starts_with("-"):
            remaining.push(arg)
        else:
            positional_values.push(arg)

        i = i + 1

    ParsedArgs(
        flag_values: flag_values,
        option_values: option_values,
        positional_values: positional_values,
        remaining: remaining
    )

fn is_valid_choice(choices: [text], value: text) -> bool:
    """Check if value is in allowed choices.

    Args:
        choices: List of valid values (empty = no restriction)
        value: Value to check

    Returns: True if valid
    """
    if choices.len() == 0:
        return true
    for choice in choices:
        if choice == value:
            return true
    false

# =========================================================================
# Access API
# =========================================================================

fn parsed_flag(parsed: ParsedArgs, name: text) -> bool:
    """Get boolean flag value.

    Args:
        parsed: Parsed arguments
        name: Flag name

    Returns: Flag value (false if not set)
    """
    if parsed.flag_values.has(name):
        return parsed.flag_values[name]
    false

fn parsed_option(parsed: ParsedArgs, name: text) -> text:
    """Get option value.

    Args:
        parsed: Parsed arguments
        name: Option name

    Returns: Option value (default if not set)
    """
    if parsed.option_values.has(name):
        return parsed.option_values[name]
    ""

fn parsed_positional(parsed: ParsedArgs, index: i64) -> text:
    """Get positional argument by index.

    Args:
        parsed: Parsed arguments
        index: Positional index (0-based)

    Returns: Positional value (empty if not present)
    """
    if index >= 0 and index < parsed.positional_values.len():
        return parsed.positional_values[index]
    ""

fn parsed_positionals(parsed: ParsedArgs) -> [text]:
    """Get all positional arguments.

    Args:
        parsed: Parsed arguments

    Returns: List of positional values
    """
    parsed.positional_values

fn parsed_remaining(parsed: ParsedArgs) -> [text]:
    """Get remaining unmatched arguments.

    Args:
        parsed: Parsed arguments

    Returns: List of remaining arguments
    """
    parsed.remaining

# =========================================================================
# Help Generation
# =========================================================================

fn generate_help(spec: CliSpec) -> text:
    """Generate help text from specification.

    Args:
        spec: CLI specification

    Returns: Help text
    """
    var help = ""

    # Program description
    if spec.description != "":
        help = "{help}{spec.description}{NL}{NL}"

    # Usage
    help = "{help}Usage:{NL}"
    var usage = "  {spec.program_name}"
    if spec.flags.len() > 0 or spec.options.len() > 0:
        usage = "{usage} [options]"
    for pos in spec.positionals:
        if pos.required:
            usage = "{usage} <{pos.name}>"
        else:
            usage = "{usage} [{pos.name}]"
    help = "{help}{usage}{NL}{NL}"

    # Positional arguments
    if spec.positionals.len() > 0:
        help = "{help}Arguments:{NL}"
        for pos in spec.positionals:
            val required_marker = if pos.required: "(required)" else: "(optional)"
            help = "{help}  {pos.name:<20} {pos.description} {required_marker}{NL}"
        help = "{help}{NL}"

    # Flags
    if spec.flags.len() > 0:
        help = "{help}Flags:{NL}"
        for flag in spec.flags:
            var flag_text = "  --{flag.long}"
            if flag.short != "":
                flag_text = "{flag_text}, -{flag.short}"
            help = "{help}{flag_text:<24} {flag.description}{NL}"
        help = "{help}{NL}"

    # Options
    if spec.options.len() > 0:
        help = "{help}Options:{NL}"
        for option in spec.options:
            var opt_text = "  --{option.long}=VALUE"
            if option.short != "":
                opt_text = "{opt_text}, -{option.short} VALUE"
            help = "{help}{opt_text:<24} {option.description}"
            if option.default != "":
                help = "{help} (default: {option.default})"
            if option.choices.len() > 0:
                val choices_str = option.choices.join("|")
                help = "{help} (choices: {choices_str})"
            help = "{help}{NL}"
        help = "{help}{NL}"

    help

fn print_help(spec: CliSpec):
    """Print help text to stdout.

    Args:
        spec: CLI specification
    """
    print generate_help(spec)

# =========================================================================
# Validation
# =========================================================================

fn validate_args(spec: CliSpec, parsed: ParsedArgs) -> (bool, text):
    """Validate parsed arguments against specification.

    Args:
        spec: CLI specification
        parsed: Parsed arguments

    Returns: (is_valid, error_message)
    """
    # Check required positionals
    for pos in spec.positionals:
        if pos.required:
            val pos_index = spec.positionals.index_of(pos) ?? -1
            if pos_index >= parsed.positional_values.len():
                return (false, "Missing required argument: {pos.name}")

    (true, "")

# =========================================================================
# Exports
# =========================================================================

export cli_spec
export cli_spec_program
export cli_spec_flag
export cli_spec_option
export cli_spec_positional
export parse_cli_args
export parsed_flag
export parsed_option
export parsed_positional
export parsed_positionals
export parsed_remaining
export generate_help
export print_help
export validate_args
