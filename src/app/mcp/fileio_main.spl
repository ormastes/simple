#!/usr/bin/env simple
# File I/O Protection MCP Server
# Provides protected file operations with rule-based access control

use app.mcp.fileio_protection (ProtectionEngine, RuleType, RuleAction, ProtectionResult, create_engine)
use app.mcp.fileio_temp (TempManager, create_temp_manager)
use app.mcp.helpers.{LB, RB, Q, jp, js, jo1, jo2, jo3, extract_json_string_v2, extract_json_value, extract_nested_string, make_tool_result, make_result_response, make_error_response, make_tool_schema_multi, min_int}
use app.io.mod (cli_get_args, env_get, shell, exit)
use lib.json.builder.{escape_json}
use std.string.{NL}

# Protocol auto-detection: JSON Lines (MCP SDK) vs Content-Length (LSP)
var USE_JSON_LINES = false

# Cache tool schemas to avoid rebuilding on every tools/list request
var FILEIO_TOOLS_CACHE: [String] = []
var FILEIO_TOOLS_CACHE_BUILT: Bool = false
var FILEIO_TOOLS_PAGE_CACHE: Dict<String, String> = {}
var FILEIO_INIT_CACHE: Option<String> = nil

# MCP Server state
class FileIOServer:
    engine: Option<ProtectionEngine>
    temp_manager: Option<TempManager>
    config_path: text
    temp_base: text

    # Initialize server with lazy engine/temp creation to keep startup fast
    static fn init(config_path: text) -> FileIOServer:
        FileIOServer(
            engine: nil,
            temp_manager: nil,
            config_path: config_path,
            temp_base: ".fileio_temp"
        )

    # Lazily construct the protection engine
    me ensure_engine() -> ProtectionEngine:
        match self.engine:
            case Some(e): e
            case nil:
                val eng = create_engine(self.config_path, self.temp_base)
                self.engine = Some(eng)
                eng

    # Lazily construct the temp manager
    me ensure_temp_manager() -> TempManager:
        match self.temp_manager:
            case Some(t): t
            case nil:
                val tm = create_temp_manager(self.temp_base, "session_", true, 24)
                self.temp_manager = Some(tm)
                tm

    # Handle MCP tool request
    fn handle_tool(tool_name: text, arguments: text) -> text:
        match tool_name:
            "safe_read": self.tool_safe_read(arguments)
            "safe_write": self.tool_safe_write(arguments)
            "safe_delete": self.tool_safe_delete(arguments)
            "safe_copy": self.tool_safe_copy(arguments)
            "safe_move": self.tool_safe_move(arguments)
            "safe_atomic_write": self.tool_safe_atomic_write(arguments)
            "safe_append": self.tool_safe_append(arguments)
            "list_protected_files": self.tool_list_protected_files(arguments)
            "check_protection": self.tool_check_protection(arguments)
            "add_protection_rule": self.tool_add_protection_rule(arguments)
            "list_temp_files": self.tool_list_temp_files(arguments)
            "cleanup_temp": self.tool_cleanup_temp(arguments)
            "get_temp_dir": self.tool_get_temp_dir(arguments)
            _: self.error_response("Unknown tool: " + tool_name)

    # Tool: safe_read
    fn tool_safe_read(arguments: text) -> text:
        val path = self.parse_path_arg(arguments)
        if path.len() == 0:
            return self.error_response("Missing 'path' argument")

        # Check protection
        val result = self.ensure_engine().check_path(path, "read")
        match result:
            ProtectionResult.Allowed:
                # Read file
                val content = self.read_file(path)
                self.success_response(content)

            ProtectionResult.Redirected(new_path):
                # Read from temp
                val content = self.read_file(new_path)
                self.success_response(content)

            ProtectionResult.Denied(reason):
                self.error_response("Read denied: " + reason)

            ProtectionResult.RequiresAtomic:
                # Atomic doesn't affect reads
                val content = self.read_file(path)
                self.success_response(content)

    # Tool: safe_write
    fn tool_safe_write(arguments: text) -> text:
        val path = self.parse_path_arg(arguments)
        val content = self.parse_content_arg(arguments)

        if path.len() == 0:
            return self.error_response("Missing 'path' argument")

        # Check protection
        val result = self.ensure_engine().check_path(path, "write")
        match result:
            ProtectionResult.Allowed:
                # Write file
                self.write_file(path, content)
                self.success_response("File written: " + path)

            ProtectionResult.Redirected(new_path):
                # Write to temp
                val actual_path = self.ensure_temp_manager().get_temp_path(path)
                self.write_file(actual_path, content)
                self.success_response("File written to temp: " + actual_path)

            ProtectionResult.Denied(reason):
                self.error_response("Write denied: " + reason)

            ProtectionResult.RequiresAtomic:
                self.error_response("Atomic write required (use safe_atomic_write)")

    # Tool: safe_delete
    fn tool_safe_delete(arguments: text) -> text:
        val path = self.parse_path_arg(arguments)
        if path.len() == 0:
            return self.error_response("Missing 'path' argument")

        # Check protection
        val result = self.ensure_engine().check_path(path, "delete")
        match result:
            ProtectionResult.Allowed:
                # Delete file
                self.delete_file(path)
                self.success_response("File deleted: " + path)

            ProtectionResult.Redirected(new_path):
                # Delete from temp
                val actual_path = self.ensure_temp_manager().get_temp_path(path)
                self.delete_file(actual_path)
                self.success_response("Temp file deleted: " + actual_path)

            ProtectionResult.Denied(reason):
                self.error_response("Delete denied: " + reason)

            ProtectionResult.RequiresAtomic:
                self.error_response("Cannot delete atomic-protected file")

    # Tool: safe_copy
    fn tool_safe_copy(arguments: text) -> text:
        val src = self.parse_arg(arguments, "src")
        val dest = self.parse_arg(arguments, "dest")

        if src.len() == 0 or dest.len() == 0:
            return self.error_response("Missing 'src' or 'dest' argument")

        # Check read permission on source
        val src_result = self.ensure_engine().check_path(src, "read")
        match src_result:
            ProtectionResult.Denied(reason):
                return self.error_response("Source read denied: " + reason)
            _: ()

        # Check write permission on destination
        val dest_result = self.ensure_engine().check_path(dest, "write")
        match dest_result:
            ProtectionResult.Allowed:
                self.copy_file(src, dest)
                self.success_response("File copied: {src} -> {dest}")

            ProtectionResult.Redirected(new_path):
                val actual_dest = self.ensure_temp_manager().get_temp_path(dest)
                self.copy_file(src, actual_dest)
                self.success_response("File copied to temp: {src} -> {actual_dest}")

            ProtectionResult.Denied(reason):
                self.error_response("Destination write denied: " + reason)

            ProtectionResult.RequiresAtomic:
                self.error_response("Atomic write required for destination")

    # Tool: safe_move
    fn tool_safe_move(arguments: text) -> text:
        val src = self.parse_arg(arguments, "src")
        val dest = self.parse_arg(arguments, "dest")

        if src.len() == 0 or dest.len() == 0:
            return self.error_response("Missing 'src' or 'dest' argument")

        # Check delete permission on source
        val src_result = self.ensure_engine().check_path(src, "delete")
        match src_result:
            ProtectionResult.Denied(reason):
                return self.error_response("Source delete denied: " + reason)
            _: ()

        # Check write permission on destination
        val dest_result = self.ensure_engine().check_path(dest, "write")
        match dest_result:
            ProtectionResult.Allowed:
                self.move_file(src, dest)
                self.success_response("File moved: {src} -> {dest}")

            ProtectionResult.Redirected(new_path):
                val actual_dest = self.ensure_temp_manager().get_temp_path(dest)
                self.move_file(src, actual_dest)
                self.success_response("File moved to temp: {src} -> {actual_dest}")

            ProtectionResult.Denied(reason):
                self.error_response("Destination write denied: " + reason)

            ProtectionResult.RequiresAtomic:
                self.error_response("Atomic write required for destination")

    # Tool: safe_atomic_write
    fn tool_safe_atomic_write(arguments: text) -> text:
        val path = self.parse_path_arg(arguments)
        val content = self.parse_content_arg(arguments)

        if path.len() == 0:
            return self.error_response("Missing 'path' argument")

        # Perform atomic write (write to temp, then rename)
        val temp_path = path + ".tmp"
        self.write_file(temp_path, content)
        self.move_file(temp_path, path)
        self.success_response("File written atomically: " + path)

    # Tool: safe_append
    fn tool_safe_append(arguments: text) -> text:
        val path = self.parse_path_arg(arguments)
        val content = self.parse_content_arg(arguments)

        if path.len() == 0:
            return self.error_response("Missing 'path' argument")

        # Check protection
        val result = self.ensure_engine().check_path(path, "write")
        match result:
            ProtectionResult.Allowed:
                self.append_file(path, content)
                self.success_response("Content appended: " + path)

            ProtectionResult.Redirected(new_path):
                val actual_path = self.ensure_temp_manager().get_temp_path(path)
                self.append_file(actual_path, content)
                self.success_response("Content appended to temp: " + actual_path)

            ProtectionResult.Denied(reason):
                self.error_response("Append denied: " + reason)

            ProtectionResult.RequiresAtomic:
                self.error_response("Atomic write required")

    # Tool: list_protected_files
    fn tool_list_protected_files(arguments: text) -> text:
        val pattern = self.parse_arg(arguments, "pattern")
        val search = if pattern.len() > 0: pattern else: "*"

        val files = self.ensure_engine().list_protected_files(search)
        val json = self.files_to_json(files)
        self.success_response(json)

    # Tool: check_protection
    fn tool_check_protection(arguments: text) -> text:
        val path = self.parse_path_arg(arguments)
        if path.len() == 0:
            return self.error_response("Missing 'path' argument")

        val info = self.ensure_engine().get_protection_info(path)
        self.success_response(info)

    # Tool: add_protection_rule
    fn tool_add_protection_rule(arguments: text) -> text:
        val pattern = self.parse_arg(arguments, "pattern")
        val rule_type = self.parse_arg(arguments, "type")
        val action = self.parse_arg(arguments, "action")
        val reason = self.parse_arg(arguments, "reason")

        if pattern.len() == 0:
            return self.error_response("Missing 'pattern' argument")

        val type_enum = match rule_type:
            "exact": RuleType.Exact
            "glob": RuleType.Glob
            "regex": RuleType.Regex
            _: RuleType.Exact

        val action_enum = match action:
            "deny": RuleAction.Deny
            "protect": RuleAction.Protect
            "redirect": RuleAction.Redirect
            "atomic": RuleAction.Atomic
            "allow": RuleAction.Allow
            _: RuleAction.Allow

        self.ensure_engine().add_rule(pattern, type_enum, action_enum, reason)
        self.success_response("Protection rule added: " + pattern)

    # Tool: list_temp_files
    fn tool_list_temp_files(arguments: text) -> text:
        val files = self.ensure_temp_manager().list_temp_files()
        val json = self.files_to_json(files)
        self.success_response(json)

    # Tool: cleanup_temp
    fn tool_cleanup_temp(arguments: text) -> text:
        self.ensure_temp_manager().cleanup_session()
        self.success_response("Temp files cleaned up")

    # Tool: get_temp_dir
    fn tool_get_temp_dir(arguments: text) -> text:
        val temp_dir = self.ensure_temp_manager().get_temp_dir()
        self.success_response(temp_dir)

    # Parse path argument from JSON
    fn parse_path_arg(arguments: text) -> text:
        self.parse_arg(arguments, "path")

    # Parse content argument from JSON
    fn parse_content_arg(arguments: text) -> text:
        self.parse_arg(arguments, "content")

    # Parse generic argument from JSON (simple implementation)
    fn parse_arg(arguments: text, key: text) -> text:
        # Simple JSON parsing: find "key": "value"
        val search = "\"" + key + "\""
        val idx = arguments.index_of(search)

        if not idx.?:
            return ""

        val start = idx.unwrap() + search.len()
        val rest = arguments[start:]

        # Find opening quote
        val quote_idx = rest.index_of("\"")
        if not quote_idx.?:
            return ""

        val value_start = quote_idx.unwrap() + 1
        val value_rest = rest[value_start:]

        # Find closing quote
        val close_idx = value_rest.index_of("\"")
        if not close_idx.?:
            return ""

        value_rest[0:close_idx.unwrap()]

    # Convert file list to JSON array
    fn files_to_json(files: [text]) -> text:
        if files.len() == 0:
            return "[]"

        var result = "["
        for i in 0..files.len():
            if i > 0:
                result = result + ", "
            result = result + "\"" + files[i] + "\""
        result + "]"

    # File operations
    fn read_file(path: text) -> text:
        shell("cat '{path}' 2>/dev/null || echo ''")

    fn write_file(path: text, content: text):
        # Escape content for shell
        val escaped = content.replace("'", "'\\''")
        shell("echo '{escaped}' > '{path}'")

    fn delete_file(path: text):
        shell("rm -f '{path}'")

    fn copy_file(src: text, dest: text):
        shell("cp '{src}' '{dest}'")

    fn move_file(src: text, dest: text):
        shell("mv '{src}' '{dest}'")

    fn append_file(path: text, content: text):
        val escaped = content.replace("'", "'\\''")
        shell("echo '{escaped}' >> '{path}'")

    # Response helpers
    fn success_response(data: text) -> text:
        "{\"status\": \"success\", \"data\": \"" + data + "\"}"

    fn error_response(message: text) -> text:
        "{\"status\": \"error\", \"message\": \"" + message + "\"}"

# Main entry point
fn main():
    val raw_args = cli_get_args()
    var has_server = false
    for arg in raw_args:
        if arg == "server":
            has_server = true

    if not has_server:
        print "Usage: fileio_main.spl server"
        return

    run_server()

# Run MCP server
fn run_server():
    val config_path = env_get("SIMPLE_FILEIO_CONFIG") ?? ""
    val config = if config_path.len() > 0:
        config_path
    else:
        "fileio_protection.sdn"

    val server = FileIOServer.init(config)

    var running = true
    for _iter in range(0, 999999):
        if not running:
            return
        val line = read_stdin_message()
        if line == "":
            running = false
        else:
            val method = extract_json_string_v2(line, "method")
            val id = extract_json_value(line, "id")
            var response = ""

            if method == "initialize":
                response = make_initialize_response(id)
            elif method == "initialized":
                response = ""  # Notification, no response
            elif method == "shutdown":
                response = make_result_response(id, "null")
            elif method == "exit":
                exit(0)
            elif method == "ping":
                response = make_result_response(id, LB() + RB())
            elif method == "tools/list":
                response = handle_tools_list(id)
            elif method == "tools/call":
                val tool_name = extract_nested_string(line, "params", "name")
                if tool_name == "":
                    response = make_error_response(id, -32602, "Missing tool name")
                else:
                    val args = parse_params(line)
                    val result = server.handle_tool(tool_name, args)
                    response = make_tool_result(id, result)
            elif method == "resources/list":
                response = handle_resources_list(id)
            elif method == "resources/read":
                response = make_error_response(id, -32601, "No resources available")
            elif method == "prompts/list":
                response = handle_prompts_list(id)
            elif method == "prompts/get":
                response = make_error_response(id, -32601, "No prompts available")
            elif method == "notifications/cancelled":
                response = ""  # Notification, no response
            else:
                response = make_error_response(id, -32601, "Method not found: " + method)

            if response != "":
                write_stdout_message(response)

# Helper functions
fn parse_method(json: text) -> text:
    val search = "\"method\""
    val idx = json.index_of(search)
    if not idx.?:
        return ""

    val start = idx.unwrap() + search.len()
    val rest = json[start:]
    val quote_idx = rest.index_of("\"")
    if not quote_idx.?:
        return ""

    val value_start = quote_idx.unwrap() + 1
    val value_rest = rest[value_start:]
    val close_idx = value_rest.index_of("\"")
    if not close_idx.?:
        return ""

    value_rest[0:close_idx.unwrap()]

fn parse_params(json: text) -> text:
    val search = "\"params\""
    val idx = json.index_of(search)
    if not idx.?:
        return "{}"

    val start = idx.unwrap() + search.len()
    val rest = json[start:]
    val brace_idx = rest.index_of("{")
    if not brace_idx.?:
        return "{}"

    # Simple brace matching
    var depth = 0
    var result = ""
    for i in brace_idx.unwrap()..rest.len():
        val ch = rest[i:i+1]
        result = result + ch
        if ch == "{":
            depth = depth + 1
        else if ch == "}":
            depth = depth - 1
            if depth == 0:
                break

    result

fn read_stdin_message() -> String:
    var line = input()
    if line == "":
        return ""
    if line.ends_with("\r"):
        line = line.substring(0, line.len() - 1)
    # JSON Lines mode: line starts with { (MCP SDK format)
    if line.starts_with("{"):
        USE_JSON_LINES = true
        return line
    # Content-Length mode (LSP-style framing)
    if line.starts_with("Content-Length:"):
        var len_str = line.replace("Content-Length:", "")
        len_str = len_str.trim()
        val content_length = int(len_str)
        if content_length == 0:
            return ""
        input()
        var body = input()
        return body
    ""

fn write_stdout_message(body: String):
    if USE_JSON_LINES:
        print_raw(body + NL)
    else:
        var header = "Content-Length: "
        header = header + body.len().to_string()
        header = header + "\r{NL}\r{NL}"
        print_raw(header)
        print_raw(body)

fn make_prop(name: String, desc: String) -> String:
    jp(name, jo2(jp("type", js("string")), jp("description", js(escape_json(desc)))))

fn make_initialize_response(id: String) -> String:
    val result = make_initialize_result()
    jo3(jp("jsonrpc", js("2.0")), jp("id", id), jp("result", result))

fn make_initialize_result() -> String:
    match FILEIO_INIT_CACHE:
        case Some(r): return r
        case nil: ()

    val server_protocol = "2025-06-18"

    var server_info = LB()
    server_info = server_info + jp("name", js("simple-fileio"))
    server_info = server_info + ","
    server_info = server_info + jp("version", js("1.0.0"))
    server_info = server_info + ","
    val instructions = "Protected file operations (safe_read/safe_write/etc) with rule-based access control."
    server_info = server_info + jp("instructions", js(escape_json(instructions)))
    server_info = server_info + RB()

    var tools_cap = jo1(jp("listChanged", "true"))
    var caps = jo1(jp("tools", tools_cap))

    val result = jo3(jp("protocolVersion", js(server_protocol)), jp("capabilities", caps), jp("serverInfo", server_info))
    FILEIO_INIT_CACHE = Some(result)
    result

fn handle_tools_list(id: String) -> String:
    val tools = get_tools_page_cached(0, 100)  # all tools fit in one page

    val result = jo1(jp("tools", tools))
    make_result_response(id, result)

fn handle_resources_list(id: String) -> String:
    val result = jo1(jp("resources", "[]"))
    make_result_response(id, result)

fn handle_prompts_list(id: String) -> String:
    val result = jo1(jp("prompts", "[]"))
    make_result_response(id, result)

fn get_all_tools() -> [String]:
    [
        schema_safe_read(),
        schema_safe_write(),
        schema_safe_delete(),
        schema_safe_copy(),
        schema_safe_move(),
        schema_safe_atomic_write(),
        schema_safe_append(),
        schema_list_protected_files(),
        schema_check_protection(),
        schema_add_protection_rule(),
        schema_list_temp_files(),
        schema_cleanup_temp(),
        schema_get_temp_dir()
    ]

fn get_all_tools_cached() -> [String]:
    if FILEIO_TOOLS_CACHE_BUILT:
        return FILEIO_TOOLS_CACHE
    FILEIO_TOOLS_CACHE = get_all_tools()
    FILEIO_TOOLS_CACHE_BUILT = true
    FILEIO_TOOLS_CACHE

fn get_tools_page_cached(offset: Int, page_size: Int) -> String:
    val key = offset.to_string() + ":" + page_size.to_string()
    match FILEIO_TOOLS_PAGE_CACHE.get(key):
        case Some(page): return page
        case nil: ()

    val all_tools = get_all_tools_cached()
    val total = all_tools.len()
    val end = min_int(offset + page_size, total)

    var tools = "["
    var first = true
    for i in offset..end:
        if not first:
            tools = tools + ","
        first = false
        tools = tools + all_tools[i]
    tools = tools + "]"

    FILEIO_TOOLS_PAGE_CACHE[key] = tools
    tools

fn schema_safe_read() -> String:
    val props = LB() + make_prop("path", "Path to read") + RB()
    make_tool_schema_multi("safe_read", "Read a file with protection checks", props, "[" + js("path") + "]", true, false, true)

fn schema_safe_write() -> String:
    var props = LB()
    props = props + make_prop("path", "Path to write")
    props = props + "," + make_prop("content", "Content to write")
    props = props + RB()
    make_tool_schema_multi("safe_write", "Write a file with protection checks", props, "[" + js("path") + "," + js("content") + "]", false, false, false)

fn schema_safe_delete() -> String:
    val props = LB() + make_prop("path", "Path to delete") + RB()
    make_tool_schema_multi("safe_delete", "Delete a file with protection checks", props, "[" + js("path") + "]", false, true, false)

fn schema_safe_copy() -> String:
    var props = LB()
    props = props + make_prop("src", "Source path")
    props = props + "," + make_prop("dest", "Destination path")
    props = props + RB()
    make_tool_schema_multi("safe_copy", "Copy a file with protection checks", props, "[" + js("src") + "," + js("dest") + "]", false, false, false)

fn schema_safe_move() -> String:
    var props = LB()
    props = props + make_prop("src", "Source path")
    props = props + "," + make_prop("dest", "Destination path")
    props = props + RB()
    make_tool_schema_multi("safe_move", "Move a file with protection checks", props, "[" + js("src") + "," + js("dest") + "]", false, true, false)

fn schema_safe_atomic_write() -> String:
    var props = LB()
    props = props + make_prop("path", "Path to write atomically")
    props = props + "," + make_prop("content", "Content to write")
    props = props + RB()
    make_tool_schema_multi("safe_atomic_write", "Write a file atomically with protection checks", props, "[" + js("path") + "," + js("content") + "]", false, false, false)

fn schema_safe_append() -> String:
    var props = LB()
    props = props + make_prop("path", "Path to append to")
    props = props + "," + make_prop("content", "Content to append")
    props = props + RB()
    make_tool_schema_multi("safe_append", "Append to a file with protection checks", props, "[" + js("path") + "," + js("content") + "]", false, false, false)

fn schema_list_protected_files() -> String:
    val props = LB() + make_prop("pattern", "Optional filter pattern") + RB()
    make_tool_schema_multi("list_protected_files", "List protected files or rules", props, "[]", true, false, true)

fn schema_check_protection() -> String:
    val props = LB() + make_prop("path", "Path to check") + RB()
    make_tool_schema_multi("check_protection", "Check protection status for a path", props, "[" + js("path") + "]", true, false, true)

fn schema_add_protection_rule() -> String:
    var props = LB()
    props = props + make_prop("pattern", "Path pattern")
    props = props + "," + make_prop("type", "Rule type: exact|glob|regex")
    props = props + "," + make_prop("action", "Action: allow|deny|protect|redirect|atomic")
    props = props + "," + make_prop("reason", "Optional reason")
    props = props + RB()
    make_tool_schema_multi("add_protection_rule", "Add a protection rule", props, "[" + js("pattern") + "]", false, true, false)

fn schema_list_temp_files() -> String:
    make_tool_schema_multi("list_temp_files", "List temp files created by the file I/O server", LB() + RB(), "[]", true, false, true)

fn schema_cleanup_temp() -> String:
    make_tool_schema_multi("cleanup_temp", "Clean up temp files created by the file I/O server", LB() + RB(), "[]", false, true, false)

fn schema_get_temp_dir() -> String:
    make_tool_schema_multi("get_temp_dir", "Get temp directory path", LB() + RB(), "[]", true, false, true)

extern fn rt_process_run(cmd: text, args: [text]) -> (text, text, i64)

fn get_args() -> [text]:
    cli_get_args()

fn read_line() -> text:
    input("")

fn print(msg: text):
    # Print to stdout with newline (for protocol compliance)
    print_raw(msg)
    print_raw(NL)
