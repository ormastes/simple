#!/usr/bin/env simple
# File I/O Protection MCP Server
# Provides protected file operations with rule-based access control

use app.mcp.fileio_protection (ProtectionEngine, RuleType, RuleAction, ProtectionResult, create_engine)
use app.mcp.fileio_temp (TempManager, create_temp_manager)
use app.io.mod (cli_get_args, env_get, shell)

# MCP Server state
class FileIOServer:
    engine: ProtectionEngine
    temp_manager: TempManager
    config_path: text

    # Initialize server
    static fn init(config_path: text) -> FileIOServer:
        val temp_base = ".fileio_temp"
        val engine = create_engine(config_path, temp_base)
        val temp_manager = create_temp_manager(temp_base, "session_", true, 24)

        FileIOServer(
            engine: engine,
            temp_manager: temp_manager,
            config_path: config_path
        )

    # Handle MCP tool request
    fn handle_tool(tool_name: text, arguments: text) -> text:
        match tool_name:
            "safe_read": self.tool_safe_read(arguments)
            "safe_write": self.tool_safe_write(arguments)
            "safe_delete": self.tool_safe_delete(arguments)
            "safe_copy": self.tool_safe_copy(arguments)
            "safe_move": self.tool_safe_move(arguments)
            "safe_atomic_write": self.tool_safe_atomic_write(arguments)
            "safe_append": self.tool_safe_append(arguments)
            "list_protected_files": self.tool_list_protected_files(arguments)
            "check_protection": self.tool_check_protection(arguments)
            "add_protection_rule": self.tool_add_protection_rule(arguments)
            "list_temp_files": self.tool_list_temp_files(arguments)
            "cleanup_temp": self.tool_cleanup_temp(arguments)
            "get_temp_dir": self.tool_get_temp_dir(arguments)
            _: self.error_response("Unknown tool: " + tool_name)

    # Tool: safe_read
    fn tool_safe_read(arguments: text) -> text:
        val path = self.parse_path_arg(arguments)
        if path.len() == 0:
            return self.error_response("Missing 'path' argument")

        # Check protection
        val result = self.engine.check_path(path, "read")
        match result:
            ProtectionResult.Allowed:
                # Read file
                val content = self.read_file(path)
                self.success_response(content)

            ProtectionResult.Redirected(new_path):
                # Read from temp
                val content = self.read_file(new_path)
                self.success_response(content)

            ProtectionResult.Denied(reason):
                self.error_response("Read denied: " + reason)

            ProtectionResult.RequiresAtomic:
                # Atomic doesn't affect reads
                val content = self.read_file(path)
                self.success_response(content)

    # Tool: safe_write
    fn tool_safe_write(arguments: text) -> text:
        val path = self.parse_path_arg(arguments)
        val content = self.parse_content_arg(arguments)

        if path.len() == 0:
            return self.error_response("Missing 'path' argument")

        # Check protection
        val result = self.engine.check_path(path, "write")
        match result:
            ProtectionResult.Allowed:
                # Write file
                self.write_file(path, content)
                self.success_response("File written: " + path)

            ProtectionResult.Redirected(new_path):
                # Write to temp
                val actual_path = self.temp_manager.get_temp_path(path)
                self.write_file(actual_path, content)
                self.success_response("File written to temp: " + actual_path)

            ProtectionResult.Denied(reason):
                self.error_response("Write denied: " + reason)

            ProtectionResult.RequiresAtomic:
                self.error_response("Atomic write required (use safe_atomic_write)")

    # Tool: safe_delete
    fn tool_safe_delete(arguments: text) -> text:
        val path = self.parse_path_arg(arguments)
        if path.len() == 0:
            return self.error_response("Missing 'path' argument")

        # Check protection
        val result = self.engine.check_path(path, "delete")
        match result:
            ProtectionResult.Allowed:
                # Delete file
                self.delete_file(path)
                self.success_response("File deleted: " + path)

            ProtectionResult.Redirected(new_path):
                # Delete from temp
                val actual_path = self.temp_manager.get_temp_path(path)
                self.delete_file(actual_path)
                self.success_response("Temp file deleted: " + actual_path)

            ProtectionResult.Denied(reason):
                self.error_response("Delete denied: " + reason)

            ProtectionResult.RequiresAtomic:
                self.error_response("Cannot delete atomic-protected file")

    # Tool: safe_copy
    fn tool_safe_copy(arguments: text) -> text:
        val src = self.parse_arg(arguments, "src")
        val dest = self.parse_arg(arguments, "dest")

        if src.len() == 0 or dest.len() == 0:
            return self.error_response("Missing 'src' or 'dest' argument")

        # Check read permission on source
        val src_result = self.engine.check_path(src, "read")
        match src_result:
            ProtectionResult.Denied(reason):
                return self.error_response("Source read denied: " + reason)
            _: ()

        # Check write permission on destination
        val dest_result = self.engine.check_path(dest, "write")
        match dest_result:
            ProtectionResult.Allowed:
                self.copy_file(src, dest)
                self.success_response("File copied: {src} -> {dest}")

            ProtectionResult.Redirected(new_path):
                val actual_dest = self.temp_manager.get_temp_path(dest)
                self.copy_file(src, actual_dest)
                self.success_response("File copied to temp: {src} -> {actual_dest}")

            ProtectionResult.Denied(reason):
                self.error_response("Destination write denied: " + reason)

            ProtectionResult.RequiresAtomic:
                self.error_response("Atomic write required for destination")

    # Tool: safe_move
    fn tool_safe_move(arguments: text) -> text:
        val src = self.parse_arg(arguments, "src")
        val dest = self.parse_arg(arguments, "dest")

        if src.len() == 0 or dest.len() == 0:
            return self.error_response("Missing 'src' or 'dest' argument")

        # Check delete permission on source
        val src_result = self.engine.check_path(src, "delete")
        match src_result:
            ProtectionResult.Denied(reason):
                return self.error_response("Source delete denied: " + reason)
            _: ()

        # Check write permission on destination
        val dest_result = self.engine.check_path(dest, "write")
        match dest_result:
            ProtectionResult.Allowed:
                self.move_file(src, dest)
                self.success_response("File moved: {src} -> {dest}")

            ProtectionResult.Redirected(new_path):
                val actual_dest = self.temp_manager.get_temp_path(dest)
                self.move_file(src, actual_dest)
                self.success_response("File moved to temp: {src} -> {actual_dest}")

            ProtectionResult.Denied(reason):
                self.error_response("Destination write denied: " + reason)

            ProtectionResult.RequiresAtomic:
                self.error_response("Atomic write required for destination")

    # Tool: safe_atomic_write
    fn tool_safe_atomic_write(arguments: text) -> text:
        val path = self.parse_path_arg(arguments)
        val content = self.parse_content_arg(arguments)

        if path.len() == 0:
            return self.error_response("Missing 'path' argument")

        # Perform atomic write (write to temp, then rename)
        val temp_path = path + ".tmp"
        self.write_file(temp_path, content)
        self.move_file(temp_path, path)
        self.success_response("File written atomically: " + path)

    # Tool: safe_append
    fn tool_safe_append(arguments: text) -> text:
        val path = self.parse_path_arg(arguments)
        val content = self.parse_content_arg(arguments)

        if path.len() == 0:
            return self.error_response("Missing 'path' argument")

        # Check protection
        val result = self.engine.check_path(path, "write")
        match result:
            ProtectionResult.Allowed:
                self.append_file(path, content)
                self.success_response("Content appended: " + path)

            ProtectionResult.Redirected(new_path):
                val actual_path = self.temp_manager.get_temp_path(path)
                self.append_file(actual_path, content)
                self.success_response("Content appended to temp: " + actual_path)

            ProtectionResult.Denied(reason):
                self.error_response("Append denied: " + reason)

            ProtectionResult.RequiresAtomic:
                self.error_response("Atomic write required")

    # Tool: list_protected_files
    fn tool_list_protected_files(arguments: text) -> text:
        val pattern = self.parse_arg(arguments, "pattern")
        val search = if pattern.len() > 0: pattern else: "*"

        val files = self.engine.list_protected_files(search)
        val json = self.files_to_json(files)
        self.success_response(json)

    # Tool: check_protection
    fn tool_check_protection(arguments: text) -> text:
        val path = self.parse_path_arg(arguments)
        if path.len() == 0:
            return self.error_response("Missing 'path' argument")

        val info = self.engine.get_protection_info(path)
        self.success_response(info)

    # Tool: add_protection_rule
    fn tool_add_protection_rule(arguments: text) -> text:
        val pattern = self.parse_arg(arguments, "pattern")
        val rule_type = self.parse_arg(arguments, "type")
        val action = self.parse_arg(arguments, "action")
        val reason = self.parse_arg(arguments, "reason")

        if pattern.len() == 0:
            return self.error_response("Missing 'pattern' argument")

        val type_enum = match rule_type:
            "exact": RuleType.Exact
            "glob": RuleType.Glob
            "regex": RuleType.Regex
            _: RuleType.Exact

        val action_enum = match action:
            "deny": RuleAction.Deny
            "protect": RuleAction.Protect
            "redirect": RuleAction.Redirect
            "atomic": RuleAction.Atomic
            "allow": RuleAction.Allow
            _: RuleAction.Allow

        self.engine.add_rule(pattern, type_enum, action_enum, reason)
        self.success_response("Protection rule added: " + pattern)

    # Tool: list_temp_files
    fn tool_list_temp_files(arguments: text) -> text:
        val files = self.temp_manager.list_temp_files()
        val json = self.files_to_json(files)
        self.success_response(json)

    # Tool: cleanup_temp
    fn tool_cleanup_temp(arguments: text) -> text:
        self.temp_manager.cleanup_session()
        self.success_response("Temp files cleaned up")

    # Tool: get_temp_dir
    fn tool_get_temp_dir(arguments: text) -> text:
        val temp_dir = self.temp_manager.get_temp_dir()
        self.success_response(temp_dir)

    # Parse path argument from JSON
    fn parse_path_arg(arguments: text) -> text:
        self.parse_arg(arguments, "path")

    # Parse content argument from JSON
    fn parse_content_arg(arguments: text) -> text:
        self.parse_arg(arguments, "content")

    # Parse generic argument from JSON (simple implementation)
    fn parse_arg(arguments: text, key: text) -> text:
        # Simple JSON parsing: find "key": "value"
        val search = "\"" + key + "\""
        val idx = arguments.index_of(search)

        if not idx.?:
            return ""

        val start = idx.unwrap() + search.len()
        val rest = arguments[start:]

        # Find opening quote
        val quote_idx = rest.index_of("\"")
        if not quote_idx.?:
            return ""

        val value_start = quote_idx.unwrap() + 1
        val value_rest = rest[value_start:]

        # Find closing quote
        val close_idx = value_rest.index_of("\"")
        if not close_idx.?:
            return ""

        value_rest[0:close_idx.unwrap()]

    # Convert file list to JSON array
    fn files_to_json(files: [text]) -> text:
        if files.len() == 0:
            return "[]"

        var result = "["
        for i in 0..files.len():
            if i > 0:
                result = result + ", "
            result = result + "\"" + files[i] + "\""
        result + "]"

    # File operations
    fn read_file(path: text) -> text:
        shell("cat '{path}' 2>/dev/null || echo ''")

    fn write_file(path: text, content: text):
        # Escape content for shell
        val escaped = content.replace("'", "'\\''")
        shell("echo '{escaped}' > '{path}'")

    fn delete_file(path: text):
        shell("rm -f '{path}'")

    fn copy_file(src: text, dest: text):
        shell("cp '{src}' '{dest}'")

    fn move_file(src: text, dest: text):
        shell("mv '{src}' '{dest}'")

    fn append_file(path: text, content: text):
        val escaped = content.replace("'", "'\\''")
        shell("echo '{escaped}' >> '{path}'")

    # Response helpers
    fn success_response(data: text) -> text:
        "{\"status\": \"success\", \"data\": \"" + data + "\"}"

    fn error_response(message: text) -> text:
        "{\"status\": \"error\", \"message\": \"" + message + "\"}"

# Main entry point
fn main():
    val args = get_args()

    if args.len() < 2:
        print "Usage: fileio_main.spl server"
        return

    if args[1] == "server":
        run_server()

# Run MCP server
fn run_server():
    val config_path = get_env("SIMPLE_FILEIO_CONFIG")
    val config = if config_path.len() > 0:
        config_path
    else:
        "fileio_protection.sdn"

    val server = FileIOServer.init(config)

    print "File I/O Protection MCP Server started"
    print "Config: {config}"

    # Simple REPL for testing
    loop:
        val line = read_line()
        if line.len() == 0:
            break

        # Parse JSON-RPC request (simple implementation)
        if line.contains("method"):
            val tool = parse_method(line)
            val args = parse_params(line)
            val response = server.handle_tool(tool, args)
            print response

# Helper functions
fn parse_method(json: text) -> text:
    val search = "\"method\""
    val idx = json.index_of(search)
    if not idx.?:
        return ""

    val start = idx.unwrap() + search.len()
    val rest = json[start:]
    val quote_idx = rest.index_of("\"")
    if not quote_idx.?:
        return ""

    val value_start = quote_idx.unwrap() + 1
    val value_rest = rest[value_start:]
    val close_idx = value_rest.index_of("\"")
    if not close_idx.?:
        return ""

    value_rest[0:close_idx.unwrap()]

fn parse_params(json: text) -> text:
    val search = "\"params\""
    val idx = json.index_of(search)
    if not idx.?:
        return "{}"

    val start = idx.unwrap() + search.len()
    val rest = json[start:]
    val brace_idx = rest.index_of("{")
    if not brace_idx.?:
        return "{}"

    # Simple brace matching
    var depth = 0
    var result = ""
    for i in brace_idx.unwrap()..rest.len():
        val ch = rest[i:i+1]
        result = result + ch
        if ch == "{":
            depth = depth + 1
        else if ch == "}":
            depth = depth - 1
            if depth == 0:
                break

    result

extern fn rt_process_run(cmd: text, args: [text]) -> (text, text, i64)

fn get_args() -> [text]:
    cli_get_args()

fn read_line() -> text:
    input("")

fn print(msg: text):
    # Print to stdout with newline (for protocol compliance)
    print_raw(msg)
    print_raw("\n")
