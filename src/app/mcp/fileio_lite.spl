# Lightweight File I/O MCP Server - Zero imports for fast startup
#
# Simplified version without protection engine or temp management.
# Provides basic file operations: read, write, delete, copy, append.
#
# Startup target: <100ms (vs 30s+ for full version with imports)

extern fn rt_file_read_text(path: text) -> text
extern fn rt_file_write_text(path: text, content: text) -> bool
extern fn rt_file_delete(path: text) -> bool
extern fn rt_file_copy(src: text, dst: text) -> bool
extern fn rt_process_run(cmd: text, args: [text]) -> (text, text, i64)

val SERVER_NAME = "simple-fileio-lite"
val SERVER_VERSION = "1.0.0"
val NL = "\n"

# Protocol auto-detection: JSON Lines (MCP SDK) vs Content-Length (LSP)
var USE_JSON_LINES = false

# --- JSON helpers (inlined) ---

fn Q() -> text:
    "\""

fn LB() -> text:
    "{"

fn RB() -> text:
    "}"

fn SB_L() -> text:
    "["

fn SB_R() -> text:
    "]"

fn escape_json(s: text) -> text:
    var result = ""
    for ch in s:
        if ch == "\"":
            result = result + "\\\""
        elif ch == "\\":
            result = result + "\\\\"
        elif ch == "\n":
            result = result + "\\n"
        elif ch == "\r":
            result = result + "\\r"
        elif ch == "\t":
            result = result + "\\t"
        else:
            result = result + ch
    result

fn js(s: text) -> text:
    Q() + escape_json(s) + Q()

fn jp(key: text, value: text) -> text:
    Q() + key + Q() + ":" + value

fn jo1(p1: text) -> text:
    LB() + p1 + RB()

fn jo2(p1: text, p2: text) -> text:
    LB() + p1 + "," + p2 + RB()

fn jo3(p1: text, p2: text, p3: text) -> text:
    LB() + p1 + "," + p2 + "," + p3 + RB()

fn extract_field(json: text, key: text) -> text:
    val search = Q() + key + Q() + ":"
    val idx_result = json.index_of(search)
    var idx = -1
    match idx_result:
        Some(i): idx = i
        nil: return ""

    if idx < 0:
        return ""

    val start = idx + search.len()
    val after = json.substring(start)
    val trimmed = after.trim()

    if trimmed.starts_with(Q()):
        val after_quote = trimmed.substring(1)
        val end_idx_result = after_quote.index_of(Q())
        var end_idx = -1
        match end_idx_result:
            Some(i): end_idx = i
            nil: return ""
        if end_idx < 0:
            return ""
        return trimmed.substring(1, end_idx + 1)
    else:
        var result = ""
        for ch in trimmed:
            if ch == "," or ch == RB() or ch == SB_R() or ch == " " or ch == "\n":
                break
            result = result + ch
        return result

fn extract_id(json: text) -> text:
    extract_field(json, "id")

fn extract_nested(json: text, key: text) -> text:
    val params_search = Q() + "params" + Q() + ":"
    val params_idx_result = json.index_of(params_search)
    var params_idx = -1
    match params_idx_result:
        Some(i): params_idx = i
        nil: return ""

    if params_idx < 0:
        return ""

    val params_start = params_idx + params_search.len()
    val params = json.substring(params_start)
    extract_field(params, key)

fn extract_arg(json: text, arg_name: text) -> text:
    val args_search = Q() + "arguments" + Q() + ":"
    val args_idx_result = json.index_of(args_search)
    var args_idx = -1
    match args_idx_result:
        Some(i): args_idx = i
        nil: return ""

    if args_idx < 0:
        return ""

    val args_start = args_idx + args_search.len()
    val args_section = json.substring(args_start)
    extract_field(args_section, arg_name)

fn make_json_result(id: text, result: text) -> text:
    jo3(jp("jsonrpc", js("2.0")), jp("id", id), jp("result", result))

fn make_error(id: text, code: i64, message: text) -> text:
    val err = jo2(jp("code", str(code)), jp("message", js(message)))
    jo3(jp("jsonrpc", js("2.0")), jp("id", id), jp("error", err))

fn make_tool_result(id: text, content: text) -> text:
    val result = jo2(jp("content", SB_L() + jo2(jp("type", js("text")), jp("text", js(content))) + SB_R()), jp("isError", "false"))
    make_json_result(id, result)

fn make_error_result(id: text, message: text) -> text:
    val result = jo2(jp("content", SB_L() + jo2(jp("type", js("text")), jp("text", js(message))) + SB_R()), jp("isError", "true"))
    make_json_result(id, result)

# --- Start server ---
start_server()

fn start_server():
    var running = true
    for _iter in range(0, 999999):
        if not running:
            return
        var line = read_stdin_message()
        if line == "":
            running = false
        else:
            var method = extract_field(line, "method")
            var id = extract_id(line)
            var response = ""
            if method == "initialize":
                response = make_init_response(id)
            elif method == "initialized" or method == "notifications/initialized":
                response = ""
            elif method == "shutdown":
                response = make_json_result(id, "null")
            elif method == "tools/list":
                response = make_tools_list(id)
            elif method == "tools/call":
                var tool_name = extract_nested(line, "name")
                response = dispatch_tool(id, tool_name, line)
            elif method == "resources/list":
                response = make_json_result(id, jo1(jp("resources", SB_L() + SB_R())))
            elif method == "prompts/list":
                response = make_json_result(id, jo1(jp("prompts", SB_L() + SB_R())))
            elif method == "ping":
                response = make_json_result(id, LB() + RB())
            elif method == "notifications/cancelled":
                response = ""
            else:
                if id != "" and id != "null":
                    response = make_error(id, -32601, "Method not found: " + method)
            if response != "":
                write_stdout_message(response)

# --- MCP protocol I/O ---

fn read_stdin_message() -> text:
    var line = input()
    if line == "":
        return ""
    if line.ends_with("\r"):
        line = line.substring(0, line.len() - 1)
    # JSON Lines mode: line starts with { (MCP SDK format)
    if line.starts_with(LB()):
        USE_JSON_LINES = true
        return line
    # Content-Length mode (LSP-style framing)
    if line.starts_with("Content-Length:"):
        var len_str = line.replace("Content-Length:", "")
        len_str = len_str.trim()
        val content_length = int(len_str)
        if content_length == 0:
            return ""
        input()
        var body = input()
        return body
    ""

fn write_stdout_message(body: text):
    if USE_JSON_LINES:
        print_raw(body + NL)
    else:
        var header = "Content-Length: " + str(body.len()) + "\r" + NL + "\r" + NL
        print_raw(header)
        print_raw(body)

# --- Initialize response ---

fn make_init_response(id: text) -> text:
    val caps = jo1(jp("tools", jo1(jp("listChanged", "true"))))
    val server_info = jo3(
        jp("name", js(SERVER_NAME)),
        jp("version", js(SERVER_VERSION)),
        jp("instructions", js("Lightweight file I/O server. Provides: safe_read, safe_write, safe_delete, safe_copy, safe_append (no protection engine - direct file operations)."))
    )
    val result = jo3(
        jp("protocolVersion", js("2025-06-18")),
        jp("capabilities", caps),
        jp("serverInfo", server_info)
    )
    make_json_result(id, result)

# --- Tools list ---

fn make_tools_list(id: text) -> text:
    var tools = SB_L()

    # safe_read
    var read_props = jo1(jp("path", jo2(jp("type", js("string")), jp("description", js("Path to file to read")))))
    var read_tool = jo3(
        jp("name", js("safe_read")),
        jp("description", js("Read a file from disk")),
        jp("inputSchema", jo3(jp("type", js("object")), jp("properties", read_props), jp("required", SB_L() + js("path") + SB_R())))
    )
    tools = tools + read_tool

    # safe_write
    var write_props = LB()
    write_props = write_props + jp("path", jo2(jp("type", js("string")), jp("description", js("Path to file to write"))))
    write_props = write_props + "," + jp("content", jo2(jp("type", js("string")), jp("description", js("Content to write"))))
    write_props = write_props + RB()
    var write_tool = jo3(
        jp("name", js("safe_write")),
        jp("description", js("Write content to a file (overwrites existing)")),
        jp("inputSchema", jo3(jp("type", js("object")), jp("properties", write_props), jp("required", SB_L() + js("path") + "," + js("content") + SB_R())))
    )
    tools = tools + "," + write_tool

    # safe_delete
    var delete_props = jo1(jp("path", jo2(jp("type", js("string")), jp("description", js("Path to file to delete")))))
    var delete_tool = jo3(
        jp("name", js("safe_delete")),
        jp("description", js("Delete a file from disk")),
        jp("inputSchema", jo3(jp("type", js("object")), jp("properties", delete_props), jp("required", SB_L() + js("path") + SB_R())))
    )
    tools = tools + "," + delete_tool

    # safe_copy
    var copy_props = LB()
    copy_props = copy_props + jp("source", jo2(jp("type", js("string")), jp("description", js("Source file path"))))
    copy_props = copy_props + "," + jp("destination", jo2(jp("type", js("string")), jp("description", js("Destination file path"))))
    copy_props = copy_props + RB()
    var copy_tool = jo3(
        jp("name", js("safe_copy")),
        jp("description", js("Copy a file")),
        jp("inputSchema", jo3(jp("type", js("object")), jp("properties", copy_props), jp("required", SB_L() + js("source") + "," + js("destination") + SB_R())))
    )
    tools = tools + "," + copy_tool

    # safe_append
    var append_props = LB()
    append_props = append_props + jp("path", jo2(jp("type", js("string")), jp("description", js("Path to file"))))
    append_props = append_props + "," + jp("content", jo2(jp("type", js("string")), jp("description", js("Content to append"))))
    append_props = append_props + RB()
    var append_tool = jo3(
        jp("name", js("safe_append")),
        jp("description", js("Append content to a file")),
        jp("inputSchema", jo3(jp("type", js("object")), jp("properties", append_props), jp("required", SB_L() + js("path") + "," + js("content") + SB_R())))
    )
    tools = tools + "," + append_tool

    tools = tools + SB_R()
    val result = jo1(jp("tools", tools))
    make_json_result(id, result)

# --- Tool dispatch ---

fn dispatch_tool(id: text, tool_name: text, body: text) -> text:
    if tool_name == "safe_read":
        return handle_safe_read(id, body)
    elif tool_name == "safe_write":
        return handle_safe_write(id, body)
    elif tool_name == "safe_delete":
        return handle_safe_delete(id, body)
    elif tool_name == "safe_copy":
        return handle_safe_copy(id, body)
    elif tool_name == "safe_append":
        return handle_safe_append(id, body)
    else:
        return make_error(id, -32601, "Unknown tool: " + tool_name)

# --- Tool: safe_read ---

fn handle_safe_read(id: text, body: text) -> text:
    val path = extract_arg(body, "path")
    if path == "":
        return make_error(id, -32602, "Missing required parameter: path")

    val content = rt_file_read_text(path)
    if content == "":
        return make_error_result(id, "Could not read file or file is empty: " + path)

    make_tool_result(id, content)

# --- Tool: safe_write ---

fn handle_safe_write(id: text, body: text) -> text:
    val path = extract_arg(body, "path")
    if path == "":
        return make_error(id, -32602, "Missing required parameter: path")

    val content = extract_arg(body, "content")
    if content == "":
        return make_error(id, -32602, "Missing required parameter: content")

    val success = rt_file_write_text(path, content)
    if success:
        make_tool_result(id, "File written successfully: " + path)
    else:
        make_error_result(id, "Failed to write file: " + path)

# --- Tool: safe_delete ---

fn handle_safe_delete(id: text, body: text) -> text:
    val path = extract_arg(body, "path")
    if path == "":
        return make_error(id, -32602, "Missing required parameter: path")

    val success = rt_file_delete(path)
    if success:
        make_tool_result(id, "File deleted successfully: " + path)
    else:
        make_error_result(id, "Failed to delete file (may not exist): " + path)

# --- Tool: safe_copy ---

fn handle_safe_copy(id: text, body: text) -> text:
    val source = extract_arg(body, "source")
    if source == "":
        return make_error(id, -32602, "Missing required parameter: source")

    val destination = extract_arg(body, "destination")
    if destination == "":
        return make_error(id, -32602, "Missing required parameter: destination")

    val success = rt_file_copy(source, destination)
    if success:
        make_tool_result(id, "File copied successfully: " + source + " -> " + destination)
    else:
        make_error_result(id, "Failed to copy file: " + source)

# --- Tool: safe_append ---

fn handle_safe_append(id: text, body: text) -> text:
    val path = extract_arg(body, "path")
    if path == "":
        return make_error(id, -32602, "Missing required parameter: path")

    val content = extract_arg(body, "content")
    if content == "":
        return make_error(id, -32602, "Missing required parameter: content")

    # Use shell to append (no rt_file_append available)
    val escaped_content = content.replace("'", "'\\''")
    val append_cmd = "printf '%s' '" + escaped_content + "' >> '" + path + "'"
    val (stdout, stderr, exit_code) = rt_process_run("/bin/sh", ["-c", append_cmd])

    if exit_code == 0:
        make_tool_result(id, "Content appended successfully to: " + path)
    else:
        make_error_result(id, "Failed to append to file: " + stderr)
