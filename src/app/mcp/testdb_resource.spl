# Test Database MCP Resource
#
# Provides MCP access to the unified test database
# Supports both read and write operations via JSON API

use lib.database.test.{create_test_database, TestDatabase, TestRun, TestResult, RunStatus, TestStatus}
use app.mcp.resource_utils.{
    JsonBuilder, JsonArrayBuilder, escape_json,
    extract_json_string, extract_json_float,
    current_timestamp, error_json, success_json, items_to_json
}

export get_all_runs, get_recent_runs, get_run_by_id, get_test_results
export get_test_stats, get_flaky_tests, get_slow_tests
export start_test_run, end_test_run, record_test_result

# ============================================================================
# Read Operations
# ============================================================================

# Get all test runs
fn get_all_runs(db_path: text) -> text:
    var testdb = create_test_database(db_path)
    val runs = testdb.all_runs()
    runs_to_json(runs)

# Get recent test runs (last N)
fn get_recent_runs(db_path: text, count: i64) -> text:
    var testdb = create_test_database(db_path)
    val runs = testdb.recent_runs(count)

    val arr = JsonArrayBuilder.new()
    for run in runs:
        arr.item_raw(run_to_json(run))

    JsonBuilder.object()
        .field_int("count", runs.len())
        .field_array_raw("runs", arr)
        .build()

# Get test run by ID
fn get_run_by_id(db_path: text, run_id: text) -> text:
    var testdb = create_test_database(db_path)
    val run_opt = testdb.get_run(run_id)

    if not run_opt.?:
        return error_json("Test run not found: {run_id}")

    val run = run_opt.unwrap()
    run_to_json(run)

# Get test results for a run
fn get_test_results(db_path: text, run_id: text) -> text:
    var testdb = create_test_database(db_path)
    val results = testdb.results_for_run(run_id)

    val arr = JsonArrayBuilder.new()
    for result in results:
        arr.item_raw(result_to_json(result))

    JsonBuilder.object()
        .field("run_id", run_id)
        .field_int("total", results.len())
        .field_array_raw("results", arr)
        .build()

# Get test statistics
fn get_test_stats(db_path: text) -> text:
    var testdb = create_test_database(db_path)
    val stats = testdb.stats()

    JsonBuilder.object()
        .field_int("total_runs", stats.total_runs)
        .field_int("total_tests", stats.total_tests)
        .field_int("passed", stats.passed)
        .field_int("failed", stats.failed)
        .field_float("pass_rate", stats.pass_rate)
        .field_float("avg_duration_ms", stats.avg_duration_ms)
        .build()

# Get flaky tests (tests that sometimes pass, sometimes fail)
fn get_flaky_tests(db_path: text) -> text:
    var testdb = create_test_database(db_path)
    val flaky = testdb.flaky_tests()

    JsonBuilder.object()
        .field_int("count", flaky.len())
        .field_array("tests", flaky)
        .build()

# Get slow tests (above threshold)
fn get_slow_tests(db_path: text, threshold_ms: f64) -> text:
    var testdb = create_test_database(db_path)
    val slow = testdb.slow_tests(threshold_ms)

    val arr = JsonArrayBuilder.new()
    for (test_name, duration) in slow:
        val item = JsonBuilder.object()
            .field("name", test_name)
            .field_float("duration_ms", duration)
            .build()
        arr.item_raw(item)

    JsonBuilder.object()
        .field_float("threshold_ms", threshold_ms)
        .field_int("count", slow.len())
        .field_array_raw("tests", arr)
        .build()

# ============================================================================
# Write Operations
# ============================================================================

# Start a new test run
fn start_test_run(db_path: text) -> text:
    var testdb = create_test_database(db_path)

    val run_id = testdb.start_run()
    val saved = testdb.save()

    if not saved:
        return error_json("Failed to save database")

    JsonBuilder.object()
        .field_bool("success", true)
        .field("run_id", run_id)
        .build()

# End a test run
fn end_test_run(db_path: text, run_id: text, status: text) -> text:
    var testdb = create_test_database(db_path)

    val parsed_status = parse_run_status(status)
    val ended = testdb.end_run(run_id, parsed_status)

    if not ended:
        return error_json("Failed to end run: {run_id}")

    val saved = testdb.save()
    if not saved:
        return error_json("Failed to save database")

    JsonBuilder.object()
        .field_bool("success", true)
        .field("run_id", run_id)
        .build()

# Record a test result
fn record_test_result(db_path: text, run_id: text, json: text) -> text:
    var testdb = create_test_database(db_path)

    val test_name = extract_json_string(json, "test_name")
    val status = extract_json_string(json, "status")
    val duration_ms = extract_json_float(json, "duration_ms")
    val error_message = extract_json_string(json, "error_message")

    if test_name == "":
        return error_json("Missing required field: test_name")

    val result = TestResult(
        test_name: test_name,
        run_id: run_id,
        status: parse_test_status(status),
        duration_ms: duration_ms,
        error_message: if error_message != "": Some(error_message) else: None,
        timestamp: current_timestamp()
    )

    val recorded = testdb.record_result(result)
    if not recorded:
        return error_json("Failed to record result")

    val saved = testdb.save()
    if not saved:
        return error_json("Failed to save database")

    JsonBuilder.object()
        .field_bool("success", true)
        .field("test_name", test_name)
        .build()

# ============================================================================
# JSON Conversion Helpers
# ============================================================================

# Convert list of runs to JSON
fn runs_to_json(runs: [TestRun]) -> text:
    items_to_json(runs, "runs", run_to_json)

# Convert single run to JSON
fn run_to_json(run: TestRun) -> text:
    val builder = JsonBuilder.object()
        .field("run_id", run.run_id)
        .field("start_time", run.start_time)

    match run.end_time:
        case Some(t):
            builder.field("end_time", t)
        case None:
            builder.field_null("end_time")

    builder
        .field_int("pid", run.pid)
        .field("hostname", run.hostname)
        .field("status", run_status_to_string(run.status))
        .field_int("test_count", run.test_count)
        .field_int("passed", run.passed)
        .field_int("failed", run.failed)
        .field_int("crashed", run.crashed)
        .field_int("timed_out", run.timed_out)
        .build()

# Convert single result to JSON
fn result_to_json(result: TestResult) -> text:
    val builder = JsonBuilder.object()
        .field("test_name", result.test_name)
        .field("run_id", result.run_id)
        .field("status", test_status_to_string(result.status))
        .field_float("duration_ms", result.duration_ms)

    match result.error_message:
        case Some(e):
            builder.field("error_message", e)
        case None:
            builder.field_null("error_message")

    builder
        .field("timestamp", result.timestamp)
        .build()

# ============================================================================
# Status Conversion Helpers
# ============================================================================

fn run_status_to_string(status: RunStatus) -> text:
    match status:
        case RunStatus.Running: "Running"
        case RunStatus.Completed: "Completed"
        case RunStatus.Crashed: "Crashed"
        case RunStatus.TimedOut: "TimedOut"
        case RunStatus.Interrupted: "Interrupted"

fn test_status_to_string(status: TestStatus) -> text:
    match status:
        case TestStatus.Passed: "Passed"
        case TestStatus.Failed: "Failed"
        case TestStatus.Crashed: "Crashed"
        case TestStatus.TimedOut: "TimedOut"
        case TestStatus.Skipped: "Skipped"

fn parse_run_status(s: text) -> RunStatus:
    match s:
        case "Running" | "running": RunStatus.Running
        case "Completed" | "completed": RunStatus.Completed
        case "Crashed" | "crashed": RunStatus.Crashed
        case "TimedOut" | "timed_out": RunStatus.TimedOut
        case "Interrupted" | "interrupted": RunStatus.Interrupted
        case _: RunStatus.Completed

fn parse_test_status(s: text) -> TestStatus:
    match s:
        case "Passed" | "passed": TestStatus.Passed
        case "Failed" | "failed": TestStatus.Failed
        case "Crashed" | "crashed": TestStatus.Crashed
        case "TimedOut" | "timed_out": TestStatus.TimedOut
        case "Skipped" | "skipped": TestStatus.Skipped
        case _: TestStatus.Passed
