# Test Database MCP Resource
#
# Provides MCP access to the unified test database
# Supports both read and write operations via JSON API

use lib.database.test.{create_test_database, TestDatabase, TestRun, TestResult, RunStatus, TestStatus}

export get_all_runs, get_recent_runs, get_run_by_id, get_test_results
export get_test_stats, get_flaky_tests, get_slow_tests
export start_test_run, end_test_run, record_test_result

# ============================================================================
# Read Operations
# ============================================================================

# Get all test runs
fn get_all_runs(db_path: text) -> text:
    var testdb = create_test_database(db_path)
    val runs = testdb.all_runs()

    var json = "{"
    json = json + "\"total\": {runs.len()},"
    json = json + "\"runs\": ["

    var first = true
    for run in runs:
        if not first:
            json = json + ","
        first = false
        json = json + run_to_json(run)

    json = json + "]"
    json = json + "}"
    json

# Get recent test runs (last N)
fn get_recent_runs(db_path: text, count: i64) -> text:
    var testdb = create_test_database(db_path)
    val runs = testdb.recent_runs(count)

    var json = "{"
    json = json + "\"count\": {runs.len()},"
    json = json + "\"runs\": ["

    var first = true
    for run in runs:
        if not first:
            json = json + ","
        first = false
        json = json + run_to_json(run)

    json = json + "]"
    json = json + "}"
    json

# Get test run by ID
fn get_run_by_id(db_path: text, run_id: text) -> text:
    var testdb = create_test_database(db_path)
    val run_opt = testdb.get_run(run_id)

    if not run_opt.?:
        return "{\"error\": \"Test run not found: {run_id}\"}"

    val run = run_opt.unwrap()
    run_to_json(run)

# Get test results for a run
fn get_test_results(db_path: text, run_id: text) -> text:
    var testdb = create_test_database(db_path)
    val results = testdb.results_for_run(run_id)

    var json = "{"
    json = json + "\"run_id\": \"{run_id}\","
    json = json + "\"total\": {results.len()},"
    json = json + "\"results\": ["

    var first = true
    for result in results:
        if not first:
            json = json + ","
        first = false
        json = json + result_to_json(result)

    json = json + "]"
    json = json + "}"
    json

# Get test statistics
fn get_test_stats(db_path: text) -> text:
    var testdb = create_test_database(db_path)
    val stats = testdb.stats()

    var json = "{"
    json = json + "\"total_runs\": {stats.total_runs},"
    json = json + "\"total_tests\": {stats.total_tests},"
    json = json + "\"passed\": {stats.passed},"
    json = json + "\"failed\": {stats.failed},"
    json = json + "\"pass_rate\": {stats.pass_rate},"
    json = json + "\"avg_duration_ms\": {stats.avg_duration_ms}"
    json = json + "}"
    json

# Get flaky tests (tests that sometimes pass, sometimes fail)
fn get_flaky_tests(db_path: text) -> text:
    var testdb = create_test_database(db_path)
    val flaky = testdb.flaky_tests()

    var json = "{"
    json = json + "\"count\": {flaky.len()},"
    json = json + "\"tests\": ["

    var first = true
    for test_name in flaky:
        if not first:
            json = json + ","
        first = false
        json = json + "\"{test_name}\""

    json = json + "]"
    json = json + "}"
    json

# Get slow tests (above threshold)
fn get_slow_tests(db_path: text, threshold_ms: f64) -> text:
    var testdb = create_test_database(db_path)
    val slow = testdb.slow_tests(threshold_ms)

    var json = "{"
    json = json + "\"threshold_ms\": {threshold_ms},"
    json = json + "\"count\": {slow.len()},"
    json = json + "\"tests\": ["

    var first = true
    for (test_name, duration) in slow:
        if not first:
            json = json + ","
        first = false
        json = json + "{\"name\": \"{test_name}\", \"duration_ms\": {duration}}"

    json = json + "]"
    json = json + "}"
    json

# ============================================================================
# Write Operations
# ============================================================================

# Start a new test run
fn start_test_run(db_path: text) -> text:
    var testdb = create_test_database(db_path)

    val run_id = testdb.start_run()
    val saved = testdb.save()

    if not saved:
        return "{\"error\": \"Failed to save database\"}"

    "{\"success\": true, \"run_id\": \"{run_id}\"}"

# End a test run
fn end_test_run(db_path: text, run_id: text, status: text) -> text:
    var testdb = create_test_database(db_path)

    val parsed_status = parse_run_status(status)
    val success = testdb.end_run(run_id, parsed_status)

    if not success:
        return "{\"error\": \"Failed to end run: {run_id}\"}"

    val saved = testdb.save()
    if not saved:
        return "{\"error\": \"Failed to save database\"}"

    "{\"success\": true, \"run_id\": \"{run_id}\"}"

# Record a test result
fn record_test_result(db_path: text, run_id: text, json: text) -> text:
    var testdb = create_test_database(db_path)

    val test_name = extract_json_string(json, "test_name")
    val status = extract_json_string(json, "status")
    val duration_ms = extract_json_float(json, "duration_ms")
    val error_message = extract_json_string(json, "error_message")

    if test_name == "":
        return "{\"error\": \"Missing required field: test_name\"}"

    val result = TestResult(
        test_name: test_name,
        run_id: run_id,
        status: parse_test_status(status),
        duration_ms: duration_ms,
        error_message: if error_message != "": Some(error_message) else: None,
        timestamp: current_timestamp()
    )

    val success = testdb.record_result(result)
    if not success:
        return "{\"error\": \"Failed to record result\"}"

    val saved = testdb.save()
    if not saved:
        return "{\"error\": \"Failed to save database\"}"

    "{\"success\": true, \"test_name\": \"{test_name}\"}"

# ============================================================================
# JSON Helpers
# ============================================================================

fn run_to_json(run: TestRun) -> text:
    var json = "{"
    json = json + "\"run_id\": \"{run.run_id}\","
    json = json + "\"start_time\": \"{run.start_time}\","
    json = json + "\"end_time\": "
    match run.end_time:
        Some(t): json = json + "\"{t}\","
        None: json = json + "null,"
    json = json + "\"pid\": {run.pid},"
    json = json + "\"hostname\": \"{run.hostname}\","
    json = json + "\"status\": \"{run_status_to_string(run.status)}\","
    json = json + "\"test_count\": {run.test_count},"
    json = json + "\"passed\": {run.passed},"
    json = json + "\"failed\": {run.failed},"
    json = json + "\"crashed\": {run.crashed},"
    json = json + "\"timed_out\": {run.timed_out}"
    json = json + "}"
    json

fn result_to_json(result: TestResult) -> text:
    var json = "{"
    json = json + "\"test_name\": \"{result.test_name}\","
    json = json + "\"run_id\": \"{result.run_id}\","
    json = json + "\"status\": \"{test_status_to_string(result.status)}\","
    json = json + "\"duration_ms\": {result.duration_ms},"
    json = json + "\"error_message\": "
    match result.error_message:
        Some(e): json = json + "\"{escape_json(e)}\","
        None: json = json + "null,"
    json = json + "\"timestamp\": \"{result.timestamp}\""
    json = json + "}"
    json

fn run_status_to_string(status: RunStatus) -> text:
    match status:
        RunStatus.Running: "Running"
        RunStatus.Completed: "Completed"
        RunStatus.Crashed: "Crashed"
        RunStatus.TimedOut: "TimedOut"
        RunStatus.Interrupted: "Interrupted"

fn test_status_to_string(status: TestStatus) -> text:
    match status:
        TestStatus.Passed: "Passed"
        TestStatus.Failed: "Failed"
        TestStatus.Crashed: "Crashed"
        TestStatus.TimedOut: "TimedOut"
        TestStatus.Skipped: "Skipped"

fn parse_run_status(s: text) -> RunStatus:
    match s:
        "Running" | "running": RunStatus.Running
        "Completed" | "completed": RunStatus.Completed
        "Crashed" | "crashed": RunStatus.Crashed
        "TimedOut" | "timed_out": RunStatus.TimedOut
        "Interrupted" | "interrupted": RunStatus.Interrupted
        _: RunStatus.Completed

fn parse_test_status(s: text) -> TestStatus:
    match s:
        "Passed" | "passed": TestStatus.Passed
        "Failed" | "failed": TestStatus.Failed
        "Crashed" | "crashed": TestStatus.Crashed
        "TimedOut" | "timed_out": TestStatus.TimedOut
        "Skipped" | "skipped": TestStatus.Skipped
        _: TestStatus.Passed

fn escape_json(s: text) -> text:
    var result = s
    result = result.replace("\\", "\\\\")
    result = result.replace("\"", "\\\"")
    result = result.replace("\n", "\\n")
    result = result.replace("\r", "\\r")
    result = result.replace("\t", "\\t")
    result

fn extract_json_string(json: text, key: text) -> text:
    val pattern = "\"{key}\": \""
    val start = json.find(pattern)
    if start < 0:
        return ""
    val value_start = start + pattern.len()
    val value_end = json.find("\"", value_start)
    if value_end < 0:
        return ""
    json.substring(value_start, value_end)

fn extract_json_float(json: text, key: text) -> f64:
    val pattern = "\"{key}\": "
    val start = json.find(pattern)
    if start < 0:
        return 0.0
    val value_start = start + pattern.len()
    var value_end = value_start
    while value_end < json.len():
        val ch = json.char_at(value_end)
        if (ch < '0' or ch > '9') and ch != '.':
            break
        value_end = value_end + 1
    if value_end == value_start:
        return 0.0
    val num_str = json.substring(value_start, value_end)
    num_str.parse_float() ?? 0.0

fn current_timestamp() -> text:
    "2026-02-05T00:00:00Z"
