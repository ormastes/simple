# MCP Lazy Server - Diagnostic tool handlers
# Extracted from main_lazy.spl
# Handles: simple_read, simple_check, simple_symbols, simple_status,
#          simple_edit, simple_multi_edit, simple_run, simple_api

# ============================================================================
# simple_read — Read source file with line numbers + diagnostics
# ============================================================================

fn handle_simple_read(id: text, body: text) -> text:
    val path = extract_field(body, "path")
    if path == "":
        return make_tool_error(id, -32602, "Missing required parameter: path")

    val source = file_read(path)
    if source == "":
        return make_tool_error(id, -32602, "Could not read file: " + path)

    # Add line numbers
    val lines = source.split(NL)
    var num_parts: [text] = []
    var line_num = 0
    for line in lines:
        line_num = line_num + 1
        num_parts.push(str(line_num) + " | " + line + NL)
    val numbered = num_parts.join("")

    # Run diagnostics
    val _bin = _mcp_find_simple_binary()
    val (check_out, check_exit) = shell_cmd("timeout 30 " + _bin + " check " + path + " 2>&1")

    var out_parts: [text] = []
    out_parts.push("-- " + path)
    if check_exit == 0:
        out_parts.push(" [clean]")
    else:
        out_parts.push(" [has errors]")
    out_parts.push(" --" + NL)
    out_parts.push(numbered)

    if check_exit != 0:
        out_parts.push(NL + "-- diagnostics --" + NL)
        out_parts.push(check_out)
    make_tool_result(id, out_parts.join(""))

# ============================================================================
# simple_check — Type-check source and return diagnostic output
# ============================================================================

fn handle_simple_check(id: text, body: text) -> text:
    val path = extract_field(body, "path")
    if path == "":
        return make_tool_error(id, -32602, "Missing required parameter: path")

    val _bin = _mcp_find_simple_binary()
    val (check_out, check_exit) = shell_cmd("timeout 30 " + _bin + " check " + path + " 2>&1")

    var output = ""
    if check_exit == 124:
        output = "TIMEOUT: check timed out after 30s for " + path
    elif check_exit == 0:
        output = "OK: no errors in " + path
    else:
        output = check_out
    make_tool_result(id, output)

# ============================================================================
# simple_symbols — List symbols (fn, class, struct, enum, export)
# ============================================================================

fn handle_simple_symbols(id: text, body: text) -> text:
    val path = extract_field(body, "path")
    if path == "":
        return make_tool_error(id, -32602, "Missing required parameter: path")

    val content = file_read(path)
    if content == "":
        return make_tool_error(id, -32602, "Could not read file: " + path)

    val lines = content.split(NL)
    var out_parts: [text] = []
    out_parts.push("-- symbols in " + path + " --" + NL)
    var line_num = 0

    for line in lines:
        line_num = line_num + 1
        val trimmed = line.trim()

        var kind = ""
        if trimmed.starts_with("fn "):
            kind = "fn"
        elif trimmed.starts_with("me "):
            kind = "method"
        elif trimmed.starts_with("static fn "):
            kind = "static fn"
        elif trimmed.starts_with("class "):
            kind = "class"
        elif trimmed.starts_with("struct "):
            kind = "struct"
        elif trimmed.starts_with("enum "):
            kind = "enum"
        elif trimmed.starts_with("export "):
            kind = "export"

        if kind != "":
            # Extract up to colon for signature
            val colon_idx = trimmed.index_of(":") ?? -1
            var sig = trimmed
            if colon_idx > 0:
                sig = trimmed.substring(0, colon_idx)
            out_parts.push("  " + str(line_num) + ": " + sig + NL)

    make_tool_result(id, out_parts.join(""))

# ============================================================================
# simple_status — Project diagnostic overview
# ============================================================================

fn handle_simple_status(id: text, body: text) -> text:
    val paths_str = extract_field(body, "paths")

    var file_list_str = ""
    if paths_str != "":
        file_list_str = paths_str
    else:
        # Get changed files from jj
        val (jj_out, jj_exit) = shell_cmd("timeout 10 jj --no-pager --color never diff -r @ --stat 2>/dev/null")
        if jj_exit == 0 and jj_out.trim() != "":
            file_list_str = extract_spl_from_stat(jj_out)
        else:
            # Fallback: find spl files
            val dir = extract_field(body, "directory")
            var scan_dir = "src/"
            if dir != "":
                scan_dir = dir
            val (find_out, _) = shell_cmd("timeout 10 find " + scan_dir + " -name '*.spl' -type f | sort | head -30")
            file_list_str = find_out.trim()

    if file_list_str == "":
        return make_tool_result(id, "-- Project Diagnostics --" + NL + "No .spl files found to check.")

    # Check each file
    val files = file_list_str.split(NL)
    var out_parts: [text] = []
    out_parts.push("-- Project Diagnostics --" + NL)
    var total_errors = 0
    var file_count = 0

    for fpath in files:
        val fp = fpath.trim()
        if fp == "" or not fp.ends_with(".spl"):
            continue
        file_count = file_count + 1
        val _bin = _mcp_find_simple_binary()
        val (co, ce) = shell_cmd("timeout 15 " + _bin + " check " + fp + " 2>&1")
        if ce == 0:
            out_parts.push("  " + fp + "  clean" + NL)
        else:
            total_errors = total_errors + 1
            # Count error lines
            val err_lines = co.split(NL)
            var err_count = 0
            for el in err_lines:
                val et = el.trim()
                val is_err = et.starts_with("error") or et.starts_with("Error") or et.starts_with("Type error") or et.starts_with("Parse error")
                if is_err:
                    err_count = err_count + 1
            out_parts.push("  " + fp + "  " + str(err_count) + " error(s)" + NL)

    out_parts.push("-- " + str(total_errors) + " file(s) with errors out of " + str(file_count) + " checked --")
    make_tool_result(id, out_parts.join(""))

fn extract_spl_from_stat(stat_output: text) -> text:
    var parts: [text] = []
    val lines = stat_output.split(NL)
    for line in lines:
        val t = line.trim()
        val pipe_idx = t.index_of(" |") ?? -1
        if pipe_idx > 0:
            val fname = t.substring(0, pipe_idx).trim()
            if fname.ends_with(".spl"):
                parts.push(fname)
        elif t.ends_with(".spl"):
            parts.push(t)
    parts.join(NL)

# ============================================================================
# simple_edit — Edit file (find/replace) with diagnostic check
# ============================================================================

fn handle_simple_edit(id: text, body: text) -> text:
    val path = extract_field(body, "path")
    val old_string = extract_field(body, "old_string")
    val new_string = extract_field(body, "new_string")

    if path == "":
        return make_tool_error(id, -32602, "Missing required parameter: path")
    if old_string == "":
        return make_tool_error(id, -32602, "Missing required parameter: old_string")

    val content = file_read(path)
    if content == "":
        return make_tool_error(id, -32602, "Could not read file: " + path)

    val idx = content.index_of(old_string) ?? -1
    if idx < 0:
        return make_tool_error(id, -32602, "old_string not found in file")

    # Perform replacement
    val before = content.substring(0, idx)
    val after = content.substring(idx + old_string.len())
    val new_content = before + new_string + after

    # Write file
    file_write(path, new_content)

    # Check diagnostics after edit
    val _bin = _mcp_find_simple_binary()
    val (check_out, check_exit) = shell_cmd("timeout 30 " + _bin + " check " + path + " 2>&1")

    # Find edit line number
    val before_lines = before.split(NL)
    val edit_line = before_lines.len()

    var out_parts: [text] = []
    out_parts.push("-- edit " + path + ":" + str(edit_line) + " --" + NL)
    out_parts.push("Replaced " + str(old_string.len()) + " chars with " + str(new_string.len()) + " chars" + NL)

    if check_exit == 0:
        out_parts.push("Diagnostics: clean (no errors)")
    else:
        out_parts.push(NL + "-- post-edit diagnostics --" + NL)
        out_parts.push(check_out)

    make_tool_result(id, out_parts.join(""))

# ============================================================================
# simple_multi_edit — Batch edits with single recheck
# ============================================================================

fn handle_simple_multi_edit(id: text, body: text) -> text:
    val path = extract_field(body, "path")
    val edits_str = extract_field(body, "edits")

    if path == "":
        return make_tool_error(id, -32602, "Missing required parameter: path")
    if edits_str == "":
        return make_tool_error(id, -32602, "Missing required parameter: edits")

    var content = file_read(path)
    if content == "":
        return make_tool_error(id, -32602, "Could not read file: " + path)

    # Parse and apply edits: find each old_string/new_string pair
    var edit_count = 0
    var search_pos = 0
    for _iter in range(0, 100):
        val old_key_search = "\"old_string\":"
        val old_idx = find_in_text(edits_str, old_key_search, search_pos)
        if old_idx < 0:
            break
        val old_val = extract_quoted_after(edits_str, old_idx + old_key_search.len())

        val new_key_search = "\"new_string\":"
        val new_idx = find_in_text(edits_str, new_key_search, old_idx)
        if new_idx < 0:
            break
        val new_val = extract_quoted_after(edits_str, new_idx + new_key_search.len())

        # Apply edit
        val rep_idx = content.index_of(old_val) ?? -1
        if rep_idx >= 0:
            val before = content.substring(0, rep_idx)
            val after = content.substring(rep_idx + old_val.len())
            content = before + new_val + after
            edit_count = edit_count + 1

        search_pos = new_idx + new_key_search.len() + new_val.len()

    file_write(path, content)

    val _bin = _mcp_find_simple_binary()
    val (check_out, check_exit) = shell_cmd("timeout 30 " + _bin + " check " + path + " 2>&1")

    var out_parts: [text] = []
    out_parts.push("-- multi-edit " + path + " (" + str(edit_count) + " edits applied) --" + NL)
    if check_exit == 0:
        out_parts.push("Diagnostics: clean (no errors)")
    else:
        out_parts.push(NL + "-- post-edit diagnostics --" + NL)
        out_parts.push(check_out)

    make_tool_result(id, out_parts.join(""))

fn find_in_text(haystack: text, needle: text, start: i64) -> i64:
    if start >= haystack.len():
        return -1
    val sub = haystack.substring(start)
    val idx = sub.index_of(needle) ?? -1
    if idx < 0:
        return -1
    start + idx

fn extract_quoted_after(s: text, start: i64) -> text:
    # Find opening quote after start position
    var pos = start
    for _i in range(0, 200):
        if pos >= s.len():
            return ""
        val ch = s.substring(pos, pos + 1)
        if ch == "\"":
            break
        pos = pos + 1
    pos = pos + 1
    # Read until closing quote
    var parts: [text] = []
    var escaped = false
    for _i in range(0, 50000):
        if pos >= s.len():
            break
        val ch = s.substring(pos, pos + 1)
        if escaped:
            if ch == "n":
                parts.push(NL)
            elif ch == "t":
                parts.push("\t")
            else:
                parts.push(ch)
            escaped = false
        elif ch == "\\":
            escaped = true
        elif ch == "\"":
            break
        else:
            parts.push(ch)
        pos = pos + 1
    parts.join("")

# ============================================================================
# simple_run — Execute .spl file and capture output
# ============================================================================

fn handle_simple_run(id: text, body: text) -> text:
    val path = extract_field(body, "path")
    if path == "":
        return make_tool_error(id, -32602, "Missing required parameter: path")

    val args_str = extract_field(body, "args")
    val timeout_str = extract_field(body, "timeout_sec")
    var timeout = 10
    if timeout_str != "":
        timeout = int(timeout_str)
        if timeout < 1:
            timeout = 10

    val _bin = _mcp_find_simple_binary()
    var cmd = "timeout " + str(timeout) + " " + _bin + " " + path
    if args_str != "":
        cmd = cmd + " " + args_str
    cmd = cmd + " 2>&1"

    val (run_out, run_exit) = shell_cmd(cmd)

    var out_parts: [text] = []
    out_parts.push("-- run " + path + " --" + NL)
    out_parts.push("exit_code: " + str(run_exit) + NL)

    if run_exit == 124:
        out_parts.push("TIMEOUT: process killed after " + str(timeout) + "s" + NL)

    out_parts.push(NL + "-- output --" + NL)
    out_parts.push(run_out)
    make_tool_result(id, out_parts.join(""))

# ============================================================================
# simple_api — Search module API
# ============================================================================

fn handle_simple_api(id: text, body: text) -> text:
    val module_name = extract_field(body, "module")
    val query = extract_field(body, "query")
    val visibility = extract_field(body, "visibility")

    if module_name == "" and query == "":
        return make_tool_error(id, -32602, "Provide 'module' or 'query' parameter")

    var search_cmd = ""
    if module_name != "":
        # Search for module file and grep for fn/class/struct/export
        search_cmd = "timeout 15 find src/ -name '*.spl' -path '*" + module_name + "*' | head -5 | xargs timeout 15 grep -n '^fn \\|^class \\|^struct \\|^enum \\|^export ' 2>/dev/null | head -50"
    else:
        # Search all files for query
        search_cmd = "timeout 15 grep -rn '" + query + "' src/ --include='*.spl' 2>/dev/null | head -50"

    val (api_out, _) = shell_cmd(search_cmd)

    var out_parts: [text] = []
    out_parts.push("-- simple_api")
    if module_name != "":
        out_parts.push(" module=" + module_name)
    if query != "":
        out_parts.push(" query=" + query)
    out_parts.push(" --" + NL)
    if api_out.trim() == "":
        out_parts.push("No results found.")
    else:
        out_parts.push(api_out)
    make_tool_result(id, out_parts.join(""))
