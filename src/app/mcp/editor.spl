# Editor Module for MCP Server
# Provides document management with transactional edit operations.
# Exposes edit_insert, edit_delete, edit_replace, edit_copy tools.

use core.*
use host.async_nogc_mut.io.fs.*

# Document tracked by the editor
class ManagedDocument:
    path: String
    content: String
    lines: [String]
    version: Int
    dirty: Bool

    static fn load(path: String) -> Result<ManagedDocument, String>:
        match fs_read_text(path):
            case Ok(content):
                val lines = content.split("\n")
                Ok(ManagedDocument(
                    path: path,
                    content: content,
                    lines: lines,
                    version: 1,
                    dirty: false
                ))
            case Err(e):
                Err("Failed to load {path}: {e}")

impl ManagedDocument:
    # Rebuild content from lines
    me rebuild():
        self.content = self.lines.join("\n")
        self.version = self.version + 1
        self.dirty = true

    # Save to disk
    fn save() -> Result<Nil, String>:
        match fs_write_text(self.path, self.content):
            case Ok(_):
                self.dirty = false
                Ok(nil)
            case Err(e):
                Err("Failed to save {self.path}: {e}")

    # Get line count
    fn line_count() -> Int:
        self.lines.len()

    # Get a range of lines (1-based, inclusive)
    fn get_lines(start: Int, end: Int) -> String:
        val s = (start - 1).max(0)
        val e = end.min(self.lines.len())
        var result: [String] = []
        var line_num = s + 1
        for i in s..e:
            result.push("{line_num}: {self.lines[i]}")
            line_num = line_num + 1
        result.join("\n")

# Edit operation result
class EditResult:
    success: Bool
    message: String
    affected_lines: Int

    static fn ok(message: String, affected: Int) -> EditResult:
        EditResult(success: true, message: message, affected_lines: affected)

    static fn err(message: String) -> EditResult:
        EditResult(success: false, message: message, affected_lines: 0)

# Document Manager - manages open documents
class DocumentManager:
    documents: Dict<String, ManagedDocument>

    static fn empty() -> DocumentManager:
        DocumentManager(documents: {})

impl DocumentManager:
    # Open or get a document
    fn open(path: String) -> Result<ManagedDocument, String>:
        match self.documents.get(path):
            case Some(doc):
                Ok(doc)
            case nil:
                val doc = ManagedDocument.load(path)?
                self.documents[path] = doc
                Ok(doc)

    # Close a document
    fn close(path: String):
        self.documents.remove(path)

    # Insert text at line (1-based). Inserts before the given line.
    fn insert(path: String, line: Int, text: String) -> EditResult:
        match self.open(path):
            case Ok(doc):
                val idx = (line - 1).max(0).min(doc.lines.len())
                val new_lines = text.split("\n")
                for (i, new_line) in new_lines.enumerate():
                    doc.lines.insert(idx + i, new_line)
                doc.rebuild()
                EditResult.ok("Inserted {new_lines.len()} lines at line {line}", new_lines.len())
            case Err(e):
                EditResult.err(e)

    # Delete lines [start, end] (1-based, inclusive)
    fn delete(path: String, start: Int, end: Int) -> EditResult:
        match self.open(path):
            case Ok(doc):
                val s = (start - 1).max(0)
                val e = end.min(doc.lines.len())
                val count = e - s
                if count <= 0:
                    return EditResult.err("Invalid range: {start}-{end}")
                for _ in 0..count:
                    doc.lines.remove(s)
                doc.rebuild()
                EditResult.ok("Deleted {count} lines ({start}-{end})", count)
            case Err(e):
                EditResult.err(e)

    # Replace lines [start, end] with new text
    fn replace(path: String, start: Int, end: Int, text: String) -> EditResult:
        match self.open(path):
            case Ok(doc):
                val s = (start - 1).max(0)
                val e = end.min(doc.lines.len())
                val count = e - s
                # Remove old lines
                for _ in 0..count:
                    doc.lines.remove(s)
                # Insert new lines
                val new_lines = text.split("\n")
                for (i, new_line) in new_lines.enumerate():
                    doc.lines.insert(s + i, new_line)
                doc.rebuild()
                EditResult.ok(
                    "Replaced {count} lines ({start}-{end}) with {new_lines.len()} lines",
                    new_lines.len()
                )
            case Err(e):
                EditResult.err(e)

    # Copy lines [start, end] as text
    fn copy(path: String, start: Int, end: Int) -> Result<String, String>:
        match self.open(path):
            case Ok(doc):
                Ok(doc.get_lines(start, end))
            case Err(e):
                Err(e)

    # Save a document
    fn save(path: String) -> EditResult:
        match self.documents.get(path):
            case Some(doc):
                match doc.save():
                    case Ok(_):
                        EditResult.ok("Saved {path}", 0)
                    case Err(e):
                        EditResult.err(e)
            case nil:
                EditResult.err("Document not open: {path}")
