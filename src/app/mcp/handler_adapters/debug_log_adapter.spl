# Debug Log Tool Handler Adapter - In-process dispatch for debug_log_* tools
#
# Replaces subprocess dispatch with direct function calls.
# Stateless: debug log tools use global module state in debug_log_tools.
#
# Usage:
#   val handler = create_debug_log_handler()
#   val response = handler.handle_fn("debug_log_enable", id, body)

use std.mcp.helpers.{make_error_response}
use app.mcp.debug_log_tools.{handle_debug_log_enable, handle_debug_log_disable, handle_debug_log_clear, handle_debug_log_query, handle_debug_log_tree, handle_debug_log_status, handle_debuglog_resource}
use app.mcp.services.{DebugLogToolHandler}

export create_debug_log_handler, dispatch_debuglog_resource

fn create_debug_log_handler() -> DebugLogToolHandler:
    DebugLogToolHandler(handle_fn: fn(tool_name: text, id: text, body: text) -> text: dispatch_debug_log(tool_name, id, body))

fn dispatch_debug_log(tool_name: text, id: text, body: text) -> text:
    if tool_name == "debug_log_enable":
        return handle_debug_log_enable(id, body)
    elif tool_name == "debug_log_disable":
        return handle_debug_log_disable(id, body)
    elif tool_name == "debug_log_clear":
        return handle_debug_log_clear(id, body)
    elif tool_name == "debug_log_query":
        return handle_debug_log_query(id, body)
    elif tool_name == "debug_log_tree":
        return handle_debug_log_tree(id, body)
    elif tool_name == "debug_log_status":
        return handle_debug_log_status(id, body)
    make_error_response(id, -32601, "Unknown debug_log tool: " + tool_name)

fn dispatch_debuglog_resource(uri: text) -> text:
    val query = uri.substring(12)
    handle_debuglog_resource(query)
