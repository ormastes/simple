# Diagnostic Tool Handler Adapter - In-process dispatch for simple_* tools
#
# Replaces subprocess dispatch with direct function calls.
# Handles 12 tools across read, edit, and VCS categories.
#
# Usage:
#   val handler = create_diag_handler()
#   val response = handler.handle_fn("simple_status", id, body)

use std.mcp.helpers.{make_error_response}
use app.mcp.diag_read_tools.{handle_simple_read, handle_simple_check, handle_simple_symbols, handle_simple_status, handle_expand_at}
use app.mcp.diag_edit_tools.{handle_simple_edit, handle_simple_multi_edit, handle_simple_run}
use app.mcp.diag_vcs_tools.{handle_simple_diff, handle_simple_log, handle_simple_squash, handle_simple_new}
use app.mcp.services.{DiagToolHandler}

export create_diag_handler

fn create_diag_handler() -> DiagToolHandler:
    DiagToolHandler(handle_fn: fn(tool_name: text, id: text, body: text) -> text: dispatch_diag(tool_name, id, body))

fn dispatch_diag(tool_name: text, id: text, body: text) -> text:
    if tool_name == "simple_read":
        return handle_simple_read(id, body)
    elif tool_name == "simple_check":
        return handle_simple_check(id, body)
    elif tool_name == "simple_symbols":
        return handle_simple_symbols(id, body)
    elif tool_name == "simple_status":
        return handle_simple_status(id, body)
    elif tool_name == "simple_expand_at":
        return handle_expand_at(id, body)
    elif tool_name == "simple_edit":
        return handle_simple_edit(id, body)
    elif tool_name == "simple_multi_edit":
        return handle_simple_multi_edit(id, body)
    elif tool_name == "simple_run":
        return handle_simple_run(id, body)
    elif tool_name == "simple_diff":
        return handle_simple_diff(id, body)
    elif tool_name == "simple_log":
        return handle_simple_log(id, body)
    elif tool_name == "simple_squash":
        return handle_simple_squash(id, body)
    elif tool_name == "simple_new":
        return handle_simple_new(id, body)
    make_error_response(id, -32601, "Unknown tool: " + tool_name)
