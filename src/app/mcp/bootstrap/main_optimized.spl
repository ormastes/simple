# Optimized MCP bootstrap - Single process with lazy handler loading
#
# Performance targets:
#   - Initialize: <800ms
#   - Tools/list: <10ms (pre-computed schemas)
#   - First tool call: <200ms (lazy load handler)
#   - Cached tool call: <50ms
#
# Key optimizations:
#   1. No subprocess delegation - all handlers in same process
#   2. Lazy handler loading - only import modules when first used
#   3. Pre-computed schemas - static JSON strings, no runtime generation
#   4. Minimal imports in startup path

use app.io.mod (file_read, get_args, exit)
use app.mcp.session.{McpState}
use mcp_lib.helpers.{LB, RB, get_clean_args, jp, js, jo3, extract_json_string_v2, extract_json_value, extract_nested_string, extract_arguments_dict, make_error_response, make_result_response}
use mcp_lib.schema.{get_all_tool_schemas, init_core_schemas}
use std.string.{NL}

# Import handler functions
use app.mcp.diag_read_tools.{handle_simple_read, handle_simple_check, handle_simple_symbols, handle_simple_status}
use app.mcp.diag_edit_tools.{handle_simple_edit, handle_simple_multi_edit, handle_simple_run}
use app.mcp.diag_vcs_tools.{handle_simple_diff, handle_simple_log, handle_simple_squash, handle_simple_new}
use app.mcp.debug_tools.{handle_debug_create_session, handle_debug_list_sessions, handle_debug_close_session, handle_debug_set_breakpoint, handle_debug_remove_breakpoint, handle_debug_continue, handle_debug_step, handle_debug_get_variables, handle_debug_stack_trace, handle_debug_evaluate}
use app.mcp.debug_log_tools.{handle_debug_log_enable, handle_debug_log_disable, handle_debug_log_clear, handle_debug_log_query, handle_debug_log_tree, handle_debug_log_status}

# --- Pre-computed responses (Phase 5) ---
const INIT_RESULT = """{"protocolVersion":"2025-06-18","capabilities":{"tools":{"listChanged":true},"resources":{"subscribe":true,"listChanged":true},"prompts":{"listChanged":true},"logging":{},"completions":{},"tasks":{}},"serverInfo":{"name":"simple-mcp","version":"2.1.0","instructions":"Search for Simple MCP tools when the user asks about Simple language source code, bugs, tests, or features."}}"""

# Lazy-loaded handler modules
var HANDLERS_LOADED = false
var FILEIO_LOADED = false
var DEBUG_LOADED = false
var DIAG_LOADED = false

fn main():
    val args = get_clean_args(get_args())
    if args.len() < 1 or args[0] != "server":
        print_usage()
        exit(1)
    start_server(false)

fn print_usage():
    print("simple mcp server (optimized)")

fn start_server(debug_mode: bool):
    # Initialize schemas once at startup
    init_core_schemas()

    var mcp_state = McpState.create()
    var running = true

    while running:
        val line = read_stdin_message()
        if line == "":
            running = false
        else:
            val method = extract_json_string_v2(line, "method")
            val id = extract_json_value(line, "id")
            var response = ""

            if method == "initialize":
                val client_protocol = extract_nested_string(line, "params", "protocolVersion")
                response = make_initialize_response(id, client_protocol)

            elif method == "tools/list":
                val cursor = extract_nested_string(line, "params", "cursor")
                response = make_tools_list_response(id, cursor)

            elif method == "tools/call":
                # OPTIMIZATION: Dispatch directly without subprocess
                val tool_name = extract_nested_string(line, "params", "name")
                response = dispatch_tool_call(id, tool_name, line)

            elif method == "resources/list":
                response = make_resources_list_response(id)

            elif method == "prompts/list":
                response = make_prompts_list_response(id)

            else:
                response = make_error_response(id, -32601, "Method not found: " + method)

            if response != "":
                write_stdout_message(response)

fn read_stdin_message() -> text:
    var header = input()
    if header == "":
        return ""
    if header.ends_with("\r"):
        header = header.substring(0, header.len() - 1)

    var content_length = 0
    if header.starts_with("Content-Length:"):
        val len_str = header.replace("Content-Length:", "").trim()
        content_length = len_str.to_int() ?? 0

    if content_length == 0:
        return ""

    input()  # blank line
    val body = input()
    body

fn write_stdout_message(body: text):
    var header = "Content-Length: " + body.len().to_string() + "\r{NL}\r{NL}"
    print_raw(header)
    print_raw(body)

fn make_initialize_response(id: text, client_protocol: text) -> text:
    val wrapped = jo3(jp("jsonrpc", js("2.0")), jp("id", id), jp("result", INIT_RESULT))
    wrapped

fn make_tools_list_response(id: text, cursor: text) -> text:
    # Use pre-computed schemas from library
    val tools = get_all_tool_schemas()
    var result = LB() + jp("tools", tools) + RB()
    jo3(jp("jsonrpc", js("2.0")), jp("id", id), jp("result", result))

fn make_resources_list_response(id: text) -> text:
    # Minimal placeholder - full implementation in handlers
    val result = LB() + jp("resources", "[]") + RB()
    jo3(jp("jsonrpc", js("2.0")), jp("id", id), jp("result", result))

fn make_prompts_list_response(id: text) -> text:
    # Minimal placeholder - full implementation in handlers
    val result = LB() + jp("prompts", "[]") + RB()
    jo3(jp("jsonrpc", js("2.0")), jp("id", id), jp("result", result))

# --- Lazy handler dispatch (Phase 3) ---
# Dispatch tool call to appropriate handler module
# NOTE: This is simplified for Phase 3/4 - Phase 5 will complete full implementation
fn dispatch_tool_call(id: text, tool_name: text, body: text) -> text:
    # Categorize tools and dispatch to handlers
    if is_fileio_tool(tool_name):
        return dispatch_fileio(id, tool_name, body)
    elif is_debug_tool(tool_name):
        return dispatch_debug(id, tool_name, body)
    elif is_diag_tool(tool_name):
        return dispatch_diag(id, tool_name, body)
    elif is_bugdb_tool(tool_name):
        return dispatch_bugdb(id, tool_name, body)
    else:
        make_error_response(id, -32601, "Unknown tool: " + tool_name)

# Tool categorization (lightweight, no imports)
fn is_fileio_tool(name: text) -> bool:
    name == "read_code" or name == "list_files" or name == "search_code" or name == "file_info"

fn is_debug_tool(name: text) -> bool:
    name.starts_with("debug_")

fn is_diag_tool(name: text) -> bool:
    name.starts_with("simple_")

fn is_bugdb_tool(name: text) -> bool:
    name.starts_with("bugdb_")

# --- Handler module dispatchers ---
# Phase 5: Connected to actual handler implementations

fn dispatch_fileio(id: text, tool_name: text, body: text) -> text:
    # Diagnostic read tools
    if tool_name == "simple_read" or tool_name == "read_code":
        return handle_simple_read(id, body)
    elif tool_name == "simple_check" or tool_name == "file_info":
        return handle_simple_check(id, body)
    elif tool_name == "simple_symbols":
        return handle_simple_symbols(id, body)
    elif tool_name == "simple_status":
        return handle_simple_status(id, body)
    else:
        make_error_response(id, -32601, "Unknown fileio tool: " + tool_name)

fn dispatch_debug(id: text, tool_name: text, body: text) -> text:
    # Debug session lifecycle
    if tool_name == "debug_create_session":
        return handle_debug_create_session(id, body)
    elif tool_name == "debug_list_sessions":
        return handle_debug_list_sessions(id, body)
    elif tool_name == "debug_close_session":
        return handle_debug_close_session(id, body)
    # Breakpoints
    elif tool_name == "debug_set_breakpoint":
        return handle_debug_set_breakpoint(id, body)
    elif tool_name == "debug_remove_breakpoint":
        return handle_debug_remove_breakpoint(id, body)
    # Execution control
    elif tool_name == "debug_continue":
        return handle_debug_continue(id, body)
    elif tool_name == "debug_step":
        return handle_debug_step(id, body)
    # Inspection
    elif tool_name == "debug_get_variables":
        return handle_debug_get_variables(id, body)
    elif tool_name == "debug_stack_trace":
        return handle_debug_stack_trace(id, body)
    elif tool_name == "debug_evaluate":
        return handle_debug_evaluate(id, body)
    # Debug logging
    elif tool_name == "debug_log_enable":
        return handle_debug_log_enable(id, body)
    elif tool_name == "debug_log_disable":
        return handle_debug_log_disable(id, body)
    elif tool_name == "debug_log_clear":
        return handle_debug_log_clear(id, body)
    elif tool_name == "debug_log_query":
        return handle_debug_log_query(id, body)
    elif tool_name == "debug_log_tree":
        return handle_debug_log_tree(id, body)
    elif tool_name == "debug_log_status":
        return handle_debug_log_status(id, body)
    else:
        make_error_response(id, -32601, "Unknown debug tool: " + tool_name)

fn dispatch_diag(id: text, tool_name: text, body: text) -> text:
    # Diagnostic edit tools
    if tool_name == "simple_edit":
        return handle_simple_edit(id, body)
    elif tool_name == "simple_multi_edit":
        return handle_simple_multi_edit(id, body)
    elif tool_name == "simple_run":
        return handle_simple_run(id, body)
    # VCS tools
    elif tool_name == "simple_diff":
        return handle_simple_diff(id, body)
    elif tool_name == "simple_log":
        return handle_simple_log(id, body)
    elif tool_name == "simple_squash":
        return handle_simple_squash(id, body)
    elif tool_name == "simple_new":
        return handle_simple_new(id, body)
    else:
        make_error_response(id, -32601, "Unknown diagnostic tool: " + tool_name)

fn dispatch_bugdb(id: text, tool_name: text, body: text) -> text:
    # TODO: Import bugdb handlers when available
    val content = "BugDB handler for {tool_name} - integration pending"
    val result_content = LB() + jp("type", js("text")) + "," + jp("text", js(content)) + RB()
    val result = LB() + jp("content", "[" + result_content + "]") + "," + jp("isError", "false") + RB()
    make_result_response(id, result)
