# MCP Resource Manager
#
# Manages resources (read-only contextual data) for the MCP server.
# Resources provide context to LLMs about the codebase, including:
# - File contents
# - Symbol information
# - Type information
# - Documentation
# - Project structure
#
# Supports both static resources and dynamic resource templates.

use app.io.mod (file_read, file_exists, dir_list, is_dir)

# --- Resource Types ---

# Resource information returned by resources/list
struct ResourceInfo:
    uri: text                    # Resource URI (e.g., "file:///path/to/file.spl")
    name: text                   # Human-readable name
    description: Option<text>    # Optional description
    mime_type: Option<text>      # MIME type (e.g., "text/plain", "application/json")

# Resource template for dynamic resources
struct ResourceTemplate:
    uri_template: text           # URI pattern (e.g., "symbol:///{symbol_name}")
    name: text
    description: Option<text>
    mime_type: Option<text>

# Resource content returned by resources/read
struct ResourceContent:
    uri: text
    contents: text               # Resource contents (may be large)
    mime_type: Option<text>

# --- Resource Manager ---

class ResourceManager:
    # Project root directory
    project_root: text

    # Create a new resource manager
    static fn create(project_root: text) -> ResourceManager:
        ResourceManager(project_root: project_root)

    # --- List Resources ---

    # List all available resources
    fn list_resources() -> [ResourceInfo]:
        var resources = []

        # Static resource: project info
        resources.push(ResourceInfo(
            uri: "project:///info",
            name: "Project Information",
            description: Some("Project metadata and manifest"),
            mime_type: Some("text/plain")
        ))

        # Dynamic resource templates as examples
        resources.push(ResourceInfo(
            uri: "file:///*",
            name: "File Contents",
            description: Some("Read file contents"),
            mime_type: Some("text/plain")
        ))

        resources.push(ResourceInfo(
            uri: "symbol:///*",
            name: "Symbol Information",
            description: Some("Get symbol details"),
            mime_type: Some("application/json")
        ))

        resources.push(ResourceInfo(
            uri: "type:///*",
            name: "Type Information",
            description: Some("Get type details"),
            mime_type: Some("application/json")
        ))

        resources.push(ResourceInfo(
            uri: "docs:///*",
            name: "Documentation",
            description: Some("Get documentation"),
            mime_type: Some("text/markdown")
        ))

        resources.push(ResourceInfo(
            uri: "tree:///*",
            name: "Directory Tree",
            description: Some("Get directory structure"),
            mime_type: Some("text/plain")
        ))

        resources

    # List resource templates
    fn list_templates() -> [ResourceTemplate]:
        var templates = []

        templates.push(ResourceTemplate(
            uri_template: "file:///{path}",
            name: "File Contents",
            description: Some("Read file contents by path"),
            mime_type: Some("text/plain")
        ))

        templates.push(ResourceTemplate(
            uri_template: "symbol:///{name}",
            name: "Symbol Information",
            description: Some("Get symbol details by name"),
            mime_type: Some("application/json")
        ))

        templates.push(ResourceTemplate(
            uri_template: "type:///{name}",
            name: "Type Information",
            description: Some("Get type details by name"),
            mime_type: Some("application/json")
        ))

        templates.push(ResourceTemplate(
            uri_template: "docs:///{path}",
            name: "Documentation",
            description: Some("Get documentation by path"),
            mime_type: Some("text/markdown")
        ))

        templates.push(ResourceTemplate(
            uri_template: "tree:///{path}",
            name: "Directory Tree",
            description: Some("Get directory structure"),
            mime_type: Some("text/plain")
        ))

        templates

    # --- Read Resources ---

    # Read a resource by URI
    fn read_resource(uri: text) -> Result<ResourceContent, text>:
        # Static resources
        if uri == "project:///info":
            val result = self.provide_project_info()
            if result.err.?:
                return Err(result.err.unwrap())
            return Ok(ResourceContent(
                uri: uri,
                contents: result.unwrap(),
                mime_type: Some("text/plain")
            ))

        # Dynamic resources - match by prefix
        if uri.starts_with("file://"):
            val path = uri.substring(7)  # Remove "file://"
            val result = self.provide_file_contents(path)
            if result.err.?:
                return Err(result.err.unwrap())
            return Ok(ResourceContent(
                uri: uri,
                contents: result.unwrap(),
                mime_type: self.get_mime_type_for_uri(uri)
            ))

        if uri.starts_with("symbol://"):
            val symbol_name = uri.substring(9)  # Remove "symbol://"
            val result = self.provide_symbol_info(symbol_name)
            if result.err.?:
                return Err(result.err.unwrap())
            return Ok(ResourceContent(
                uri: uri,
                contents: result.unwrap(),
                mime_type: Some("application/json")
            ))

        if uri.starts_with("type://"):
            val type_name = uri.substring(7)  # Remove "type://"
            val result = self.provide_type_info(type_name)
            if result.err.?:
                return Err(result.err.unwrap())
            return Ok(ResourceContent(
                uri: uri,
                contents: result.unwrap(),
                mime_type: Some("application/json")
            ))

        if uri.starts_with("docs://"):
            val path = uri.substring(7)  # Remove "docs://"
            val result = self.provide_documentation(path)
            if result.err.?:
                return Err(result.err.unwrap())
            return Ok(ResourceContent(
                uri: uri,
                contents: result.unwrap(),
                mime_type: Some("text/markdown")
            ))

        if uri.starts_with("tree://"):
            val path = uri.substring(7)  # Remove "tree://"
            val result = self.provide_directory_tree(path)
            if result.err.?:
                return Err(result.err.unwrap())
            return Ok(ResourceContent(
                uri: uri,
                contents: result.unwrap(),
                mime_type: Some("text/plain")
            ))

        Err("Resource not found: " + uri)

    # Get MIME type for URI
    fn get_mime_type_for_uri(uri: text) -> Option<text>:
        if uri.starts_with("file://"):
            if uri.ends_with(".spl") or uri.ends_with(".ssh"):
                return Some("text/x-simple")
            if uri.ends_with(".json"):
                return Some("application/json")
            if uri.ends_with(".md"):
                return Some("text/markdown")
            return Some("text/plain")

        if uri.starts_with("symbol://") or uri.starts_with("type://"):
            return Some("application/json")

        if uri.starts_with("docs://"):
            return Some("text/markdown")

        if uri.starts_with("tree://"):
            return Some("text/plain")

        nil

    # --- Resource Providers ---

    # Provide file contents
    fn provide_file_contents(path: text) -> Result<text, text>:
        val full_path = if path.starts_with("/"):
            path
        else:
            self.project_root + "/" + path

        if not file_exists(full_path):
            return Err("File not found: " + path)

        val contents = file_read(full_path)
        Ok(contents)

    # Provide symbol information
    fn provide_symbol_info(symbol_name: text) -> Result<text, text>:
        # Simple implementation - search for symbol in files
        var info = "Symbol: " + symbol_name + "\n"
        info = info + "Status: Symbol search not fully implemented\n"
        info = info + "Hint: Use file:// resource to read file contents"
        Ok(info)

    # Provide type information
    fn provide_type_info(type_name: text) -> Result<text, text>:
        # Simple implementation
        var info = "Type: " + type_name + "\n"
        info = info + "Status: Type search not fully implemented\n"
        info = info + "Hint: Use file:// resource to read file contents"
        Ok(info)

    # Provide documentation
    fn provide_documentation(path: text) -> Result<text, text>:
        # Look for .md files in doc/
        val doc_path = self.project_root + "/doc/" + path

        if not path.ends_with(".md"):
            val md_path = doc_path + ".md"
            if file_exists(md_path):
                return Ok(file_read(md_path))

        if file_exists(doc_path):
            return Ok(file_read(doc_path))

        Err("Documentation not found: " + path)

    # Provide directory tree
    fn provide_directory_tree(path: text) -> Result<text, text>:
        val full_path = if path.starts_with("/"):
            path
        else:
            self.project_root + "/" + path

        if not dir_exists(full_path):
            return Err("Directory not found: " + path)

        val tree = self.build_tree(full_path, 0, 3)
        Ok(tree)

    # Build directory tree recursively
    fn build_tree(path: text, indent: i64, max_depth: i64) -> text:
        if max_depth <= 0:
            return ""

        var result = ""
        val entries = dir_list(path)

        for entry in entries:
            # Skip hidden files and common build directories
            if entry.starts_with(".") or entry == "node_modules" or entry == "target":
                continue

            val full_entry = path + "/" + entry
            val prefix = repeat_string("  ", indent)

            if dir_exists(full_entry):
                result = result + prefix + entry + "/\n"
                result = result + self.build_tree(full_entry, indent + 1, max_depth - 1)
            else:
                result = result + prefix + entry + "\n"

        result

    # Provide project information
    fn provide_project_info() -> Result<text, text>:
        # Read simple.sdn or simple.toml
        val sdn_path = self.project_root + "/simple.sdn"
        val toml_path = self.project_root + "/simple.toml"

        var project_info = "Project Root: " + self.project_root + "\n\n"

        if file_exists(sdn_path):
            project_info = project_info + "Manifest: simple.sdn\n"
            project_info = project_info + file_read(sdn_path)
            return Ok(project_info)

        if file_exists(toml_path):
            project_info = project_info + "Manifest: simple.toml\n"
            project_info = project_info + file_read(toml_path)
            return Ok(project_info)

        Ok(project_info + "No manifest found")

# --- Helper Functions ---

# Check if directory exists
fn dir_exists(path: text) -> bool:
    # Use is_dir from io module which uses test -d
    is_dir(path)

# String repetition (for indentation)
fn repeat_string(s: text, count: i64) -> text:
    var result = ""
    for i in 0..count:
        result = result + s
    result
