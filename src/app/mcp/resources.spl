# MCP Resource Manager
#
# Manages resources (read-only contextual data) for the MCP server.
# Resources provide context to LLMs about the codebase, including:
# - File contents
# - Symbol information
# - Type information
# - Documentation
# - Project structure
#
# Supports both static resources and dynamic resource templates.

use app.io.mod (file_read, file_exists, dir_list, is_dir)
use app.mcp.bugdb_resource (get_all_bugs, get_open_bugs, get_critical_bugs, get_bug_stats)
# TEMPORARILY DISABLED due to parse error in lib.database.feature.spl
# use app.mcp.featuredb_resource (get_all_features, get_features_by_category, get_features_by_status, get_feature_stats)
# use app.mcp.testdb_resource (get_all_runs, get_recent_runs, get_test_stats, get_flaky_tests)

# --- Resource Types ---

# Resource information returned by resources/list
struct ResourceInfo:
    uri: text                    # Resource URI (e.g., "file:///path/to/file.spl")
    name: text                   # Human-readable name
    description: Option<text>    # Optional description
    mime_type: Option<text>      # MIME type (e.g., "text/plain", "application/json")

# Resource template for dynamic resources
struct ResourceTemplate:
    uri_template: text           # URI pattern (e.g., "symbol:///{symbol_name}")
    name: text
    description: Option<text>
    mime_type: Option<text>

# Resource content returned by resources/read
struct ResourceContent:
    uri: text
    contents: text               # Resource contents (may be large)
    mime_type: Option<text>

# --- Resource Manager ---

class ResourceManager:
    # Project root directory
    project_root: text

    # Create a new resource manager
    static fn create(project_root: text) -> ResourceManager:
        ResourceManager(project_root: project_root)

    # --- List Resources ---

    # List all available resources
    fn list_resources() -> [ResourceInfo]:
        var resources = []

        # Static resource: project info
        resources.push(ResourceInfo(
            uri: "project:///info",
            name: "Project Information",
            description: Some("Project metadata and manifest"),
            mime_type: Some("text/plain")
        ))

        # Dynamic resource templates as examples
        resources.push(ResourceInfo(
            uri: "file:///*",
            name: "File Contents",
            description: Some("Read file contents"),
            mime_type: Some("text/plain")
        ))

        resources.push(ResourceInfo(
            uri: "symbol:///*",
            name: "Symbol Information",
            description: Some("Get symbol details"),
            mime_type: Some("application/json")
        ))

        resources.push(ResourceInfo(
            uri: "type:///*",
            name: "Type Information",
            description: Some("Get type details"),
            mime_type: Some("application/json")
        ))

        resources.push(ResourceInfo(
            uri: "docs:///*",
            name: "Documentation",
            description: Some("Get documentation"),
            mime_type: Some("text/markdown")
        ))

        resources.push(ResourceInfo(
            uri: "tree:///*",
            name: "Directory Tree",
            description: Some("Get directory structure"),
            mime_type: Some("text/plain")
        ))

        resources.push(ResourceInfo(
            uri: "bugdb:///all",
            name: "All Bugs",
            description: Some("Get all bugs from bug database"),
            mime_type: Some("application/json")
        ))

        resources.push(ResourceInfo(
            uri: "bugdb:///open",
            name: "Open Bugs",
            description: Some("Get open bugs from bug database"),
            mime_type: Some("application/json")
        ))

        resources.push(ResourceInfo(
            uri: "bugdb:///critical",
            name: "Critical Bugs",
            description: Some("Get critical bugs (P0/P1) from bug database"),
            mime_type: Some("application/json")
        ))

        resources.push(ResourceInfo(
            uri: "bugdb:///stats",
            name: "Bug Statistics",
            description: Some("Get bug database statistics"),
            mime_type: Some("application/json")
        ))

        # Feature Database resources
        resources.push(ResourceInfo(
            uri: "featuredb:///all",
            name: "All Features",
            description: Some("Get all features from feature database"),
            mime_type: Some("application/json")
        ))

        resources.push(ResourceInfo(
            uri: "featuredb:///stats",
            name: "Feature Statistics",
            description: Some("Get feature database statistics"),
            mime_type: Some("application/json")
        ))

        # Test Database resources
        resources.push(ResourceInfo(
            uri: "testdb:///runs",
            name: "Test Runs",
            description: Some("Get all test runs"),
            mime_type: Some("application/json")
        ))

        resources.push(ResourceInfo(
            uri: "testdb:///stats",
            name: "Test Statistics",
            description: Some("Get test statistics"),
            mime_type: Some("application/json")
        ))

        resources.push(ResourceInfo(
            uri: "testdb:///flaky",
            name: "Flaky Tests",
            description: Some("Get flaky tests"),
            mime_type: Some("application/json")
        ))

        resources

    # List resource templates
    fn list_templates() -> [ResourceTemplate]:
        var templates = []

        templates.push(ResourceTemplate(
            uri_template: "file:///{path}",
            name: "File Contents",
            description: Some("Read file contents by path"),
            mime_type: Some("text/plain")
        ))

        templates.push(ResourceTemplate(
            uri_template: "symbol:///{name}",
            name: "Symbol Information",
            description: Some("Get symbol details by name"),
            mime_type: Some("application/json")
        ))

        templates.push(ResourceTemplate(
            uri_template: "type:///{name}",
            name: "Type Information",
            description: Some("Get type details by name"),
            mime_type: Some("application/json")
        ))

        templates.push(ResourceTemplate(
            uri_template: "docs:///{path}",
            name: "Documentation",
            description: Some("Get documentation by path"),
            mime_type: Some("text/markdown")
        ))

        templates.push(ResourceTemplate(
            uri_template: "tree:///{path}",
            name: "Directory Tree",
            description: Some("Get directory structure"),
            mime_type: Some("text/plain")
        ))

        templates.push(ResourceTemplate(
            uri_template: "bugdb:///{query}",
            name: "Bug Database",
            description: Some("Query bug database (all, open, critical, stats)"),
            mime_type: Some("application/json")
        ))

        templates

    # --- Read Resources ---

    # Read a resource by URI
    fn read_resource(uri: text) -> Result<ResourceContent, text>:
        # Static resources
        if uri == "project:///info":
            val result = self.provide_project_info()
            if result.err.?:
                return Err(result.err.unwrap())
            return Ok(ResourceContent(
                uri: uri,
                contents: result.unwrap(),
                mime_type: Some("text/plain")
            ))

        # Dynamic resources - match by prefix
        if uri.starts_with("file://"):
            val path = uri.substring(7)  # Remove "file://"
            val result = self.provide_file_contents(path)
            if result.err.?:
                return Err(result.err.unwrap())
            return Ok(ResourceContent(
                uri: uri,
                contents: result.unwrap(),
                mime_type: self.get_mime_type_for_uri(uri)
            ))

        if uri.starts_with("symbol://"):
            val symbol_name = uri.substring(9)  # Remove "symbol://"
            val result = self.provide_symbol_info(symbol_name)
            if result.err.?:
                return Err(result.err.unwrap())
            return Ok(ResourceContent(
                uri: uri,
                contents: result.unwrap(),
                mime_type: Some("application/json")
            ))

        if uri.starts_with("type://"):
            val type_name = uri.substring(7)  # Remove "type://"
            val result = self.provide_type_info(type_name)
            if result.err.?:
                return Err(result.err.unwrap())
            return Ok(ResourceContent(
                uri: uri,
                contents: result.unwrap(),
                mime_type: Some("application/json")
            ))

        if uri.starts_with("docs://"):
            val path = uri.substring(7)  # Remove "docs://"
            val result = self.provide_documentation(path)
            if result.err.?:
                return Err(result.err.unwrap())
            return Ok(ResourceContent(
                uri: uri,
                contents: result.unwrap(),
                mime_type: Some("text/markdown")
            ))

        if uri.starts_with("tree://"):
            val path = uri.substring(7)  # Remove "tree://"
            val result = self.provide_directory_tree(path)
            if result.err.?:
                return Err(result.err.unwrap())
            return Ok(ResourceContent(
                uri: uri,
                contents: result.unwrap(),
                mime_type: Some("text/plain")
            ))

        if uri.starts_with("bugdb://"):
            val query = uri.substring(8)  # Remove "bugdb://"
            val result = self.provide_bugdb_query(query)
            if result.err.?:
                return Err(result.err.unwrap())
            return Ok(ResourceContent(
                uri: uri,
                contents: result.unwrap(),
                mime_type: Some("application/json")
            ))

        # TEMPORARILY DISABLED - parse error in lib.database.feature.spl
        # if uri.starts_with("featuredb://"):
        #     val query = uri.substring(12)  # Remove "featuredb://"
        #     val result = self.provide_featuredb_query(query)
        #     if result.err.?:
        #         return Err(result.err.unwrap())
        #     return Ok(ResourceContent(
        #         uri: uri,
        #         contents: result.unwrap(),
        #         mime_type: Some("application/json")
        #     ))
        #
        # if uri.starts_with("testdb://"):
        #     val query = uri.substring(9)  # Remove "testdb://"
        #     val result = self.provide_testdb_query(query)
        #     if result.err.?:
        #         return Err(result.err.unwrap())
        #     return Ok(ResourceContent(
        #         uri: uri,
        #         contents: result.unwrap(),
        #         mime_type: Some("application/json")
        #     ))

        Err("Resource not found: " + uri)

    # Get MIME type for URI
    fn get_mime_type_for_uri(uri: text) -> Option<text>:
        if uri.starts_with("file://"):
            if uri.ends_with(".spl") or uri.ends_with(".ssh"):
                return Some("text/x-simple")
            if uri.ends_with(".json"):
                return Some("application/json")
            if uri.ends_with(".md"):
                return Some("text/markdown")
            return Some("text/plain")

        if uri.starts_with("symbol://") or uri.starts_with("type://"):
            return Some("application/json")

        if uri.starts_with("docs://"):
            return Some("text/markdown")

        if uri.starts_with("tree://"):
            return Some("text/plain")

        nil

    # --- Resource Providers ---

    # Provide file contents
    fn provide_file_contents(path: text) -> Result<text, text>:
        val full_path = if path.starts_with("/"):
            path
        else:
            self.project_root + "/" + path

        if not file_exists(full_path):
            return Err("File not found: " + path)

        val contents = file_read(full_path)
        Ok(contents)

    # Provide symbol information
    fn provide_symbol_info(symbol_name: text) -> Result<text, text>:
        # Simple implementation - search for symbol in files
        var info = "Symbol: " + symbol_name + "\n"
        info = info + "Status: Symbol search not fully implemented\n"
        info = info + "Hint: Use file:// resource to read file contents"
        Ok(info)

    # Provide type information
    fn provide_type_info(type_name: text) -> Result<text, text>:
        # Simple implementation
        var info = "Type: " + type_name + "\n"
        info = info + "Status: Type search not fully implemented\n"
        info = info + "Hint: Use file:// resource to read file contents"
        Ok(info)

    # Provide documentation
    fn provide_documentation(path: text) -> Result<text, text>:
        # Look for .md files in doc/
        val doc_path = self.project_root + "/doc/" + path

        if not path.ends_with(".md"):
            val md_path = doc_path + ".md"
            if file_exists(md_path):
                return Ok(file_read(md_path))

        if file_exists(doc_path):
            return Ok(file_read(doc_path))

        Err("Documentation not found: " + path)

    # Provide directory tree
    fn provide_directory_tree(path: text) -> Result<text, text>:
        val full_path = if path.starts_with("/"):
            path
        else:
            self.project_root + "/" + path

        if not dir_exists(full_path):
            return Err("Directory not found: " + path)

        val tree = self.build_tree(full_path, 0, 3)
        Ok(tree)

    # Build directory tree recursively
    fn build_tree(path: text, indent: i64, max_depth: i64) -> text:
        if max_depth <= 0:
            return ""

        var result = ""
        val entries = dir_list(path)

        for entry in entries:
            # Skip hidden files and common build directories
            if entry.starts_with(".") or entry == "node_modules" or entry == "target":
                continue

            val full_entry = path + "/" + entry
            val prefix = repeat_string("  ", indent)

            if dir_exists(full_entry):
                result = result + prefix + entry + "/\n"
                result = result + self.build_tree(full_entry, indent + 1, max_depth - 1)
            else:
                result = result + prefix + entry + "\n"

        result

    # Provide project information
    fn provide_project_info() -> Result<text, text>:
        # Read simple.sdn or simple.toml
        val sdn_path = self.project_root + "/simple.sdn"
        val toml_path = self.project_root + "/simple.toml"

        var project_info = "Project Root: " + self.project_root + "\n\n"

        if file_exists(sdn_path):
            project_info = project_info + "Manifest: simple.sdn\n"
            project_info = project_info + file_read(sdn_path)
            return Ok(project_info)

        if file_exists(toml_path):
            project_info = project_info + "Manifest: simple.toml\n"
            project_info = project_info + file_read(toml_path)
            return Ok(project_info)

        Ok(project_info + "No manifest found")

    # Provide bug database query results
    fn provide_bugdb_query(query: text) -> Result<text, text>:
        val db_path = self.project_root + "/doc/bug/bug_db.sdn"

        # Handle different query types
        if query == "/all" or query == "all":
            return Ok(get_all_bugs(db_path))
        elif query == "/open" or query == "open":
            return Ok(get_open_bugs(db_path))
        elif query == "/critical" or query == "critical":
            return Ok(get_critical_bugs(db_path))
        elif query == "/stats" or query == "stats":
            return Ok(get_bug_stats(db_path))
        else:
            return Err("Unknown bug database query: " + query + ". Valid queries: all, open, critical, stats")

    # TEMPORARILY DISABLED - parse error in lib.database.feature.spl
    # # Provide feature database query results
    # fn provide_featuredb_query(query: text) -> Result<text, text>:
    #     val db_path = self.project_root + "/doc/feature/feature_db.sdn"
    #
    #     if query == "/all" or query == "all":
    #         return Ok(get_all_features(db_path))
    #     elif query == "/stats" or query == "stats":
    #         return Ok(get_feature_stats(db_path))
    #     elif query.starts_with("/category/"):
    #         val category = query.substring(10)
    #         return Ok(get_features_by_category(db_path, category))
    #     elif query.starts_with("/status/"):
    #         val status = query.substring(8)
    #         return Ok(get_features_by_status(db_path, status))
    #     else:
    #         return Err("Unknown feature database query: " + query + ". Valid queries: all, stats, category/<name>, status/<name>")
    #
    # # Provide test database query results
    # fn provide_testdb_query(query: text) -> Result<text, text>:
    #     val db_path = self.project_root + "/doc/test/test_db.sdn"
    #
    #     if query == "/runs" or query == "runs":
    #         return Ok(get_all_runs(db_path))
    #     elif query == "/recent" or query == "recent":
    #         return Ok(get_recent_runs(db_path, 10))
    #     elif query == "/stats" or query == "stats":
    #         return Ok(get_test_stats(db_path))
    #     elif query == "/flaky" or query == "flaky":
    #         return Ok(get_flaky_tests(db_path))
    #     else:
    #         return Err("Unknown test database query: " + query + ". Valid queries: runs, recent, stats, flaky")

# --- Helper Functions ---

# Check if directory exists
fn dir_exists(path: text) -> bool:
    # Use is_dir from io module which uses test -d
    is_dir(path)

# String repetition (for indentation)
fn repeat_string(s: text, count: i64) -> text:
    var result = ""
    for i in 0..count:
        result = result + s
    result
