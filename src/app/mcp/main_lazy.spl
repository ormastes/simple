# Full MCP Server with Inline Tool Handlers
#
# All 34 tools implemented inline with zero module imports.
# Uses only extern fn calls for I/O — no subprocess dispatch, no hangs.
#
# Architecture:
#   - Zero imports: all JSON helpers and tool logic inlined
#   - Fast startup (~100ms), fast tool calls (<1s)
#   - Direct extern fn calls: rt_file_read_text, rt_process_run, rt_env_get, rt_file_write_text

extern fn rt_file_read_text(path: text) -> text
extern fn rt_process_run(cmd: text, args: [text]) -> (text, text, i64)
extern fn rt_env_get(name: text) -> text
extern fn rt_file_write_text(path: text, content: text) -> bool

val SERVER_NAME = "simple-mcp-full"
val SERVER_VERSION = "3.1.0"
val NL = "\n"

# Protocol auto-detection
var USE_JSON_LINES = false

# Caches
var TOOLS_CACHE = ""
var INIT_CACHE = ""

# Debug session state (lightweight in-process implementation)
class LazyBreakpoint:
    id: i64
    file: text
    line: i64
    function_name: text
    condition: text
    enabled: bool

class LazySession:
    id: text
    program: text
    target_type: text
    state: text
    breakpoints: [LazyBreakpoint]
    watches: [text]
    next_bp_id: i64

var DEBUG_SESSIONS: [LazySession] = []
var DEBUG_NEXT_SESSION_ID: i64 = 1

# Debug log state
var DEBUG_LOG_ENABLED = false
var DEBUG_LOG_PATTERN = "*"
var DEBUG_LOG_NEXT_ID: i64 = 1
var DEBUG_LOG_ENTRIES: [text] = []
var MCP_LOG_LEVEL = "info"

# --- JSON helpers (inlined for zero-import startup) ---

fn Q() -> text:
    "\""

fn LB() -> text:
    "{"

fn RB() -> text:
    "}"

fn SB_L() -> text:
    "["

fn SB_R() -> text:
    "]"

fn escape_json(s: text) -> text:
    var parts: [text] = []
    for ch in s:
        if ch == "\"":
            parts.push("\\\"")
        elif ch == "\\":
            parts.push("\\\\")
        elif ch == "\n":
            parts.push("\\n")
        elif ch == "\r":
            parts.push("\\r")
        elif ch == "\t":
            parts.push("\\t")
        else:
            parts.push(ch)
    parts.join("")

fn js(s: text) -> text:
    Q() + escape_json(s) + Q()

fn jp(key: text, value: text) -> text:
    Q() + key + Q() + ":" + value

fn jo1(p1: text) -> text:
    LB() + p1 + RB()

fn jo2(p1: text, p2: text) -> text:
    LB() + p1 + "," + p2 + RB()

fn jo3(p1: text, p2: text, p3: text) -> text:
    LB() + p1 + "," + p2 + "," + p3 + RB()

fn extract_field(json: text, key: text) -> text:
    val search = Q() + key + Q() + ":"
    val idx_result = json.index_of(search)
    var idx = -1
    match idx_result:
        Some(i): idx = i
        nil: return ""
    if idx < 0:
        return ""
    val start = idx + search.len()
    val after = json.substring(start)
    val trimmed = after.trim()
    if trimmed.starts_with(Q()):
        val after_quote = trimmed.substring(1)
        val end_idx_result = after_quote.index_of(Q())
        var end_idx = -1
        match end_idx_result:
            Some(i): end_idx = i
            nil: return ""
        if end_idx < 0:
            return ""
        return trimmed.substring(1, end_idx + 1)
    else:
        var parts: [text] = []
        for ch in trimmed:
            if ch == "," or ch == RB() or ch == SB_R() or ch == " " or ch == "\n":
                break
            parts.push(ch)
        return parts.join("")

fn extract_field_raw(json: text, key: text) -> text:
    val search = Q() + key + Q() + ":"
    val idx_result = json.index_of(search)
    var idx = -1
    match idx_result:
        Some(i): idx = i
        nil: return "null"
    if idx < 0:
        return "null"
    var start = idx + search.len()
    if start >= json.len():
        return "null"
    var rest = json.substring(start)
    rest = rest.trim()
    if rest == "":
        return "null"
    if rest.starts_with(Q()):
        var out: [text] = [Q()]
        var escaped = false
        var pos = 1
        for _i in range(0, 100000):
            if pos >= rest.len():
                break
            val ch = rest.substring(pos, pos + 1)
            out.push(ch)
            if escaped:
                escaped = false
            elif ch == "\\":
                escaped = true
            elif ch == Q():
                break
            pos = pos + 1
        return out.join("")
    var parts: [text] = []
    for ch in rest:
        if ch == "," or ch == RB() or ch == SB_R() or ch == " " or ch == "\n":
            break
        parts.push(ch)
    val raw = parts.join("")
    if raw == "":
        return "null"
    raw

fn extract_id(json: text) -> text:
    extract_field_raw(json, "id")

fn extract_nested(json: text, key: text) -> text:
    val params_search = Q() + "params" + Q() + ":"
    val params_idx_result = json.index_of(params_search)
    var params_idx = -1
    match params_idx_result:
        Some(i): params_idx = i
        nil: return ""
    if params_idx < 0:
        return ""
    val params_start = params_idx + params_search.len()
    val params = json.substring(params_start)
    extract_field(params, key)

fn make_json_result(id: text, result: text) -> text:
    jo3(jp("jsonrpc", js("2.0")), jp("id", id), jp("result", result))

fn make_error(id: text, code: i64, message: text) -> text:
    val err = jo2(jp("code", str(code)), jp("message", js(message)))
    jo3(jp("jsonrpc", js("2.0")), jp("id", id), jp("error", err))

# --- MCP Tool Result helpers ---

fn infer_json_value_type(raw: text) -> text:
    val t = raw.trim()
    if t == "":
        return "empty"
    if t.starts_with("{"):
        return "object"
    if t.starts_with("["):
        return "array"
    if t.starts_with(Q()):
        return "string"
    if t == "true" or t == "false":
        return "boolean"
    if t == "null":
        return "null"
    var has_digit = false
    var all_num = true
    for ch in t:
        if ch >= "0" and ch <= "9":
            has_digit = true
        elif ch == "." or ch == "-" or ch == "+":
            pass
        else:
            all_num = false
            break
    if has_digit and all_num:
        return "number"
    "text"

fn top_level_item_count(raw: text) -> i64:
    val t = raw.trim()
    if t == "":
        return 0
    if not t.starts_with("[") and not t.starts_with("{"):
        return 1
    var depth = 0
    var in_string = false
    var escaped = false
    var count = 0
    var saw_value = false
    for ch in t:
        if in_string:
            if escaped:
                escaped = false
            elif ch == "\\":
                escaped = true
            elif ch == Q():
                in_string = false
            continue
        if ch == Q():
            in_string = true
            if depth == 1:
                saw_value = true
        elif ch == "[" or ch == "{":
            depth = depth + 1
            if depth == 2:
                saw_value = true
        elif ch == "]" or ch == "}":
            if depth == 1 and saw_value:
                count = count + 1
                saw_value = false
            depth = depth - 1
        elif ch == "," and depth == 1:
            count = count + 1
            saw_value = false
        elif depth == 1 and ch != " " and ch != "\n" and ch != "\r" and ch != "\t":
            saw_value = true
    if t.starts_with("[") or t.starts_with("{"):
        if count < 0:
            return 0
    count

fn summarize_json_shape(raw: text, depth: i64) -> text:
    val value_type = infer_json_value_type(raw)
    if depth <= 0:
        return value_type
    if value_type == "array":
        var inner = raw.trim()
        if inner.len() >= 2:
            inner = inner.substring(1, inner.len() - 1).trim()
        var first = ""
        var d = 0
        var in_s = false
        var esc = false
        var parts: [text] = []
        for ch in inner:
            if in_s:
                parts.push(ch)
                if esc:
                    esc = false
                elif ch == "\\":
                    esc = true
                elif ch == Q():
                    in_s = false
                continue
            if ch == Q():
                in_s = true
                parts.push(ch)
            elif ch == "[" or ch == "{":
                d = d + 1
                parts.push(ch)
            elif ch == "]" or ch == "}":
                d = d - 1
                parts.push(ch)
            elif ch == "," and d == 0:
                first = parts.join("").trim()
                break
            else:
                parts.push(ch)
        if first == "":
            first = parts.join("").trim()
        var elem_shape = "unknown"
        if first != "":
            elem_shape = summarize_json_shape(first, depth - 1)
        return "array<" + elem_shape + ">"
    if value_type == "object":
        var pair_count = 0
        var in_s = false
        var esc = false
        for ch in raw:
            if in_s:
                if esc:
                    esc = false
                elif ch == "\\":
                    esc = true
                elif ch == Q():
                    in_s = false
                continue
            if ch == Q():
                in_s = true
            elif ch == ":":
                pair_count = pair_count + 1
        return "object{pairs=" + str(pair_count) + "}"
    value_type

fn make_tool_result(id: text, output: text) -> text:
    val content = SB_L() + jo2(jp("type", js("text")), jp("text", js(output))) + SB_R()
    val inferred = infer_json_value_type(output)
    val shape = summarize_json_shape(output, 2)
    val structured = jo3(
        jp("rawText", js(output)),
        jp("inferredType", js(inferred)),
        jp("shape", js(shape))
    )
    var result = jo1(jp("content", content))
    result = result.substring(0, result.len() - 1) + "," + jp("structuredContent", structured) + RB()
    make_json_result(id, result)

fn make_tool_error(id: text, code: i64, msg: text) -> text:
    val content = SB_L() + jo2(jp("type", js("text")), jp("text", js("ERROR " + str(code) + ": " + msg))) + SB_R()
    val structured = jo2(jp("code", str(code)), jp("message", js(msg)))
    var result = jo1(jp("content", content))
    result = result.substring(0, result.len() - 1) + "," + jp("isError", "true") + "," + jp("structuredContent", structured) + RB()
    make_json_result(id, result)

# --- Shell helper ---

fn shell_cmd(command: text) -> (text, i64):
    val (stdout, stderr, code) = rt_process_run("/bin/sh", ["-c", command])
    (stdout, code)

fn file_read(path: text) -> text:
    rt_file_read_text(path) ?? ""

fn file_write(path: text, content: text) -> bool:
    rt_file_write_text(path, content) ?? false

# --- Server loop ---

start_server()

fn start_server():
    var running = true
    for _iter in range(0, 999999):
        if not running:
            return
        var line = read_stdin_message()
        if line == "":
            running = false
        else:
            var method = extract_field(line, "method")
            var id = extract_id(line)
            var response = ""
            if method == "initialize":
                response = make_init_response(id)
            elif method == "initialized" or method == "notifications/initialized":
                response = ""
            elif method == "shutdown":
                response = make_json_result(id, "null")
            elif method == "tools/list":
                response = make_tools_list(id)
            elif method == "tools/call":
                var tool_name = extract_nested(line, "name")
                response = dispatch_tool(id, tool_name, line)
            elif method == "resources/list":
                response = handle_resources_list(id)
            elif method == "resources/templates/list":
                response = handle_resource_templates_list(id)
            elif method == "resources/read":
                val uri = extract_nested(line, "uri")
                response = handle_resources_read(id, uri)
            elif method == "prompts/list":
                response = handle_prompts_list(id)
            elif method == "prompts/get":
                val prompt_name = extract_nested(line, "name")
                response = handle_prompts_get(id, prompt_name, line)
            elif method == "completion/complete" or method == "completions/complete":
                response = handle_completion_req(id, line)
            elif method == "logging/setLevel":
                val level = extract_nested(line, "level")
                if level != "":
                    MCP_LOG_LEVEL = level
                response = make_json_result(id, jo1(jp("level", js(MCP_LOG_LEVEL))))
            elif method == "roots/list":
                val cwd = get_cwd()
                var root = LB()
                root = root + jp("uri", js("file://" + cwd))
                root = root + "," + jp("name", js("workspace"))
                root = root + RB()
                response = make_json_result(id, jo1(jp("roots", "[" + root + "]")))
            elif method == "ping":
                response = make_json_result(id, LB() + RB())
            elif method == "notifications/cancelled" or method == "notifications/roots/list_changed":
                response = ""
            else:
                if id != "" and id != "null":
                    response = make_error(id, -32601, "Method not found: " + method)
            if response != "":
                write_stdout_message(response)

# --- Protocol I/O ---

fn read_stdin_message() -> text:
    var line = input()
    if line == "":
        return ""
    if line.ends_with("\r"):
        line = line.substring(0, line.len() - 1)
    if line.starts_with(LB()):
        USE_JSON_LINES = true
        return line
    if line.starts_with("Content-Length:"):
        var len_str = line.replace("Content-Length:", "")
        len_str = len_str.trim()
        val content_length = int(len_str)
        if content_length == 0:
            return ""
        input()
        var body = input()
        return body
    ""

fn write_stdout_message(body: text):
    if USE_JSON_LINES:
        print_raw(body + NL)
    else:
        var header = "Content-Length: " + str(body.len()) + "\r" + NL + "\r" + NL
        print_raw(header)
        print_raw(body)

# --- Initialize response ---

fn make_init_response(id: text) -> text:
    if INIT_CACHE != "":
        return make_json_result(id, INIT_CACHE)
    var tools_cap = jo1(jp("listChanged", "true"))
    var resources_cap = jo2(jp("subscribe", "true"), jp("listChanged", "true"))
    var prompts_cap = jo1(jp("listChanged", "true"))
    var caps = jo3(
        jp("tools", tools_cap),
        jp("resources", resources_cap),
        jp("prompts", prompts_cap)
    )
    caps = caps.substring(0, caps.len() - 1) + "," + jp("logging", LB() + RB()) + "," + jp("completions", LB() + RB()) + "," + jp("roots", jo1(jp("listChanged", "false"))) + RB()
    val server_info = jo3(
        jp("name", js(SERVER_NAME)),
        jp("version", js(SERVER_VERSION)),
        jp("instructions", js("Full-featured MCP server with inline tool handlers. All 34 tools available with zero-import fast execution."))
    )
    val result = jo3(
        jp("protocolVersion", js("2025-06-18")),
        jp("capabilities", caps),
        jp("serverInfo", server_info)
    )
    INIT_CACHE = result
    make_json_result(id, result)

# --- Tools list (all 34 tools, minimal schemas) ---

fn make_tools_list(id: text) -> text:
    if TOOLS_CACHE != "":
        return make_json_result(id, TOOLS_CACHE)

    var tool_parts: [text] = []

    # Debug tools (16)
    tool_parts.push(make_tool_schema("debug_create_session", "Create a debug session"))
    tool_parts.push(make_tool_schema("debug_list_sessions", "List active debug sessions"))
    tool_parts.push(make_tool_schema("debug_close_session", "Close a debug session"))
    tool_parts.push(make_tool_schema("debug_set_breakpoint", "Set a breakpoint"))
    tool_parts.push(make_tool_schema("debug_remove_breakpoint", "Remove a breakpoint"))
    tool_parts.push(make_tool_schema("debug_continue", "Continue execution"))
    tool_parts.push(make_tool_schema("debug_step", "Step through code"))
    tool_parts.push(make_tool_schema("debug_get_variables", "Get variable values"))
    tool_parts.push(make_tool_schema("debug_stack_trace", "Get stack trace"))
    tool_parts.push(make_tool_schema("debug_evaluate", "Evaluate expression"))
    tool_parts.push(make_tool_schema("debug_set_function_breakpoint", "Set function breakpoint"))
    tool_parts.push(make_tool_schema("debug_enable_breakpoint", "Enable/disable breakpoint"))
    tool_parts.push(make_tool_schema("debug_get_source", "Get source code"))
    tool_parts.push(make_tool_schema("debug_watch", "Add watch expression"))
    tool_parts.push(make_tool_schema("debug_set_variable", "Set variable value"))
    tool_parts.push(make_tool_schema("debug_terminate", "Terminate debug session"))

    # Debug log tools (6)
    tool_parts.push(make_tool_schema("debug_log_enable", "Enable debug logging"))
    tool_parts.push(make_tool_schema("debug_log_disable", "Disable debug logging"))
    tool_parts.push(make_tool_schema("debug_log_clear", "Clear debug logs"))
    tool_parts.push(make_tool_schema("debug_log_query", "Query debug logs"))
    tool_parts.push(make_tool_schema("debug_log_tree", "Get debug log tree"))
    tool_parts.push(make_tool_schema("debug_log_status", "Get debug log status"))

    # Diagnostic read tools (4)
    tool_parts.push(make_tool_schema("simple_read", "Read Simple source with diagnostics"))
    tool_parts.push(make_tool_schema("simple_check", "Check Simple source for errors"))
    tool_parts.push(make_tool_schema("simple_symbols", "List symbols in file"))
    tool_parts.push(make_tool_schema("simple_status", "Get project status"))

    # Diagnostic edit tools (3)
    tool_parts.push(make_tool_schema("simple_edit", "Edit Simple source file"))
    tool_parts.push(make_tool_schema("simple_multi_edit", "Edit multiple files"))
    tool_parts.push(make_tool_schema("simple_run", "Run Simple code"))

    # Diagnostic VCS tools (4)
    tool_parts.push(make_tool_schema("simple_diff", "Show file diff"))
    tool_parts.push(make_tool_schema("simple_log", "Show git log"))
    tool_parts.push(make_tool_schema("simple_squash", "Squash commits"))
    tool_parts.push(make_tool_schema("simple_new", "Create new change"))

    # API search tools (1)
    tool_parts.push(make_tool_schema("simple_api", "Search module API with visibility-aware filtering"))

    val tools = SB_L() + tool_parts.join(",") + SB_R()
    val result = jo1(jp("tools", tools))
    TOOLS_CACHE = result
    make_json_result(id, result)

fn make_tool_schema(name: text, description: text) -> text:
    var props = LB() + RB()
    var req = "[]"

    if name == "debug_create_session":
        props = jo2(
            jp("program", jo2(jp("type", js("string")), jp("description", js("Path to program")))),
            jp("target_type", jo2(jp("type", js("string")), jp("description", js("interpreter|smf|native|remote"))))
        )
        req = "[" + js("program") + "]"
    elif name == "debug_close_session" or name == "debug_continue" or name == "debug_get_variables" or name == "debug_stack_trace" or name == "debug_terminate":
        props = jo1(jp("session_id", jo2(jp("type", js("string")), jp("description", js("Debug session id")))))
        req = "[" + js("session_id") + "]"
    elif name == "debug_set_breakpoint":
        var p = LB()
        p = p + jp("session_id", jo1(jp("type", js("string"))))
        p = p + "," + jp("file", jo1(jp("type", js("string"))))
        p = p + "," + jp("line", jo1(jp("type", js("string"))))
        p = p + "," + jp("condition", jo1(jp("type", js("string"))))
        p = p + RB()
        props = p
        req = "[" + js("session_id") + "," + js("file") + "," + js("line") + "]"
    elif name == "debug_remove_breakpoint":
        props = jo2(
            jp("session_id", jo1(jp("type", js("string")))),
            jp("breakpoint_id", jo1(jp("type", js("string"))))
        )
        req = "[" + js("session_id") + "," + js("breakpoint_id") + "]"
    elif name == "debug_step":
        props = jo2(
            jp("session_id", jo1(jp("type", js("string")))),
            jp("mode", jo2(jp("type", js("string")), jp("description", js("over|in|out"))))
        )
        req = "[" + js("session_id") + "," + js("mode") + "]"
    elif name == "debug_evaluate":
        props = jo2(
            jp("session_id", jo1(jp("type", js("string")))),
            jp("expression", jo1(jp("type", js("string"))))
        )
        req = "[" + js("session_id") + "," + js("expression") + "]"
    elif name == "debug_set_function_breakpoint":
        props = jo2(
            jp("session_id", jo1(jp("type", js("string")))),
            jp("function_name", jo1(jp("type", js("string"))))
        )
        req = "[" + js("session_id") + "," + js("function_name") + "]"
    elif name == "debug_enable_breakpoint":
        var p = LB()
        p = p + jp("session_id", jo1(jp("type", js("string"))))
        p = p + "," + jp("breakpoint_id", jo1(jp("type", js("string"))))
        p = p + "," + jp("enabled", jo1(jp("type", js("string"))))
        p = p + RB()
        props = p
        req = "[" + js("session_id") + "," + js("breakpoint_id") + "," + js("enabled") + "]"
    elif name == "debug_get_source":
        var p = LB()
        p = p + jp("session_id", jo1(jp("type", js("string"))))
        p = p + "," + jp("file", jo1(jp("type", js("string"))))
        p = p + "," + jp("start_line", jo1(jp("type", js("string"))))
        p = p + "," + jp("count", jo1(jp("type", js("string"))))
        p = p + RB()
        props = p
        req = "[" + js("session_id") + "," + js("file") + "]"
    elif name == "debug_watch":
        var p = LB()
        p = p + jp("session_id", jo1(jp("type", js("string"))))
        p = p + "," + jp("action", jo1(jp("type", js("string"))))
        p = p + "," + jp("expression", jo1(jp("type", js("string"))))
        p = p + RB()
        props = p
        req = "[" + js("session_id") + "," + js("action") + "]"
    elif name == "debug_set_variable":
        var p = LB()
        p = p + jp("session_id", jo1(jp("type", js("string"))))
        p = p + "," + jp("name", jo1(jp("type", js("string"))))
        p = p + "," + jp("value", jo1(jp("type", js("string"))))
        p = p + "," + jp("frame_index", jo1(jp("type", js("string"))))
        p = p + RB()
        props = p
        req = "[" + js("session_id") + "," + js("name") + "," + js("value") + "]"
    elif name == "debug_log_enable":
        props = jo1(jp("pattern", jo1(jp("type", js("string")))))
    elif name == "debug_log_query":
        var p = LB()
        p = p + jp("since_id", jo1(jp("type", js("integer"))))
        p = p + "," + jp("entry_type", jo1(jp("type", js("string"))))
        p = p + "," + jp("max_results", jo1(jp("type", js("integer"))))
        p = p + "," + jp("function_pattern", jo1(jp("type", js("string"))))
        p = p + RB()
        props = p
    elif name == "debug_log_tree":
        var p = LB()
        p = p + jp("format", jo1(jp("type", js("string"))))
        p = p + "," + jp("max_depth", jo1(jp("type", js("integer"))))
        p = p + "," + jp("since_id", jo1(jp("type", js("integer"))))
        p = p + "," + jp("expanded_groups", jo1(jp("type", js("string"))))
        p = p + RB()
        props = p
    elif name == "simple_read":
        var p = LB()
        p = p + jp("path", jo1(jp("type", js("string"))))
        p = p + "," + jp("show_hints", jo1(jp("type", js("boolean"))))
        p = p + "," + jp("fold_mode", jo1(jp("type", js("string"))))
        p = p + RB()
        props = p
        req = "[" + js("path") + "]"
    elif name == "simple_check" or name == "simple_symbols" or name == "simple_run":
        props = jo1(jp("path", jo1(jp("type", js("string")))))
        req = "[" + js("path") + "]"
    elif name == "simple_status":
        props = jo2(jp("directory", jo1(jp("type", js("string")))), jp("paths", jo1(jp("type", js("array")))))
    elif name == "simple_edit":
        var p = LB()
        p = p + jp("path", jo1(jp("type", js("string"))))
        p = p + "," + jp("old_string", jo1(jp("type", js("string"))))
        p = p + "," + jp("new_string", jo1(jp("type", js("string"))))
        p = p + RB()
        props = p
        req = "[" + js("path") + "," + js("old_string") + "," + js("new_string") + "]"
    elif name == "simple_multi_edit":
        props = jo2(jp("path", jo1(jp("type", js("string")))), jp("edits", jo1(jp("type", js("array")))))
        req = "[" + js("path") + "," + js("edits") + "]"
    elif name == "simple_diff":
        props = jo2(jp("revision", jo1(jp("type", js("string")))), jp("paths", jo1(jp("type", js("string")))))
    elif name == "simple_log":
        props = jo2(jp("limit", jo1(jp("type", js("integer")))), jp("revsets", jo1(jp("type", js("string")))))
    elif name == "simple_squash" or name == "simple_new":
        props = jo2(jp("revision", jo1(jp("type", js("string")))), jp("message", jo1(jp("type", js("string")))))
    elif name == "simple_api":
        var p = LB()
        p = p + jp("module", jo1(jp("type", js("string"))))
        p = p + "," + jp("query", jo1(jp("type", js("string"))))
        p = p + "," + jp("visibility", jo1(jp("type", js("string"))))
        p = p + RB()
        props = p

    var schema = LB()
    schema = schema + jp("type", js("object"))
    schema = schema + "," + jp("properties", props)
    schema = schema + "," + jp("required", req)
    schema = schema + RB()

    var read_only = "false"
    var destructive = "false"
    var idempotent = "true"
    if name.starts_with("simple_read") or name == "simple_check" or name == "simple_symbols" or name == "simple_status" or name == "simple_log" or name == "simple_api" or name == "debug_list_sessions" or name == "debug_get_variables" or name == "debug_stack_trace" or name == "debug_evaluate" or name == "debug_get_source" or name == "debug_log_query" or name == "debug_log_tree" or name == "debug_log_status":
        read_only = "true"
    if name == "simple_edit" or name == "simple_multi_edit" or name == "simple_squash" or name == "simple_new" or name == "debug_log_clear" or name == "debug_set_variable" or name == "debug_terminate":
        destructive = "true"
    if name == "simple_run" or name == "simple_new" or name == "simple_squash" or name == "debug_continue" or name == "debug_step":
        idempotent = "false"

    var annotations = LB()
    annotations = annotations + jp("readOnlyHint", read_only)
    annotations = annotations + "," + jp("destructiveHint", destructive)
    annotations = annotations + "," + jp("idempotentHint", idempotent)
    annotations = annotations + "," + jp("openWorldHint", "false")
    annotations = annotations + RB()

    var tool_obj = jo3(
        jp("name", js(name)),
        jp("description", js(description)),
        jp("inputSchema", schema)
    )
    tool_obj = tool_obj.substring(0, tool_obj.len() - 1) + "," + jp("annotations", annotations) + RB()
    tool_obj

# ============================================================================
# Resources / Prompts / Completion
# ============================================================================

fn make_result_response(id: text, result: text) -> text:
    make_json_result(id, result)

fn make_resource_json(uri: text, name: text, desc: text, mime: text) -> text:
    var r = LB()
    r = r + jp("uri", js(uri))
    r = r + "," + jp("name", js(name))
    if desc != "":
        r = r + "," + jp("description", js(desc))
    if mime != "":
        r = r + "," + jp("mimeType", js(mime))
    r = r + RB()
    r

fn build_resources_json() -> text:
    var r = make_resource_json("project:///info", "Project Information", "Project metadata and cwd", "text/plain")
    r = r + "," + make_resource_json("file:///*", "File Contents", "Read file contents by absolute path", "text/plain")
    r = r + "," + make_resource_json("debuglog:///status", "Debug Log Status", "Debug log status", "application/json")
    "[" + r + "]"

fn handle_resources_list(id: text) -> text:
    val result = jo1(jp("resources", build_resources_json()))
    make_result_response(id, result)

fn handle_resource_templates_list(id: text) -> text:
    var t1 = LB()
    t1 = t1 + jp("uriTemplate", js("file:///" + LB() + "path" + RB()))
    t1 = t1 + "," + jp("name", js("File Contents"))
    t1 = t1 + "," + jp("description", js("Read file contents by path"))
    t1 = t1 + "," + jp("mimeType", js("text/plain"))
    t1 = t1 + RB()

    var t2 = LB()
    t2 = t2 + jp("uriTemplate", js("project:///" + LB() + "name" + RB()))
    t2 = t2 + "," + jp("name", js("Project Info"))
    t2 = t2 + "," + jp("description", js("Read project information"))
    t2 = t2 + "," + jp("mimeType", js("text/plain"))
    t2 = t2 + RB()

    val result = jo1(jp("resourceTemplates", "[" + t1 + "," + t2 + "]"))
    make_result_response(id, result)

fn get_cwd() -> text:
    val (out, _) = shell_cmd("pwd")
    if out.ends_with(NL):
        return out.substring(0, out.len() - 1)
    out

fn make_resource_content_response(id: text, uri: text, content: text, mime: text) -> text:
    var rc = LB()
    rc = rc + jp("uri", js(uri))
    rc = rc + "," + jp("mimeType", js(mime))
    rc = rc + "," + jp("text", js(escape_json(content)))
    rc = rc + RB()
    val result = jo1(jp("contents", "[" + rc + "]"))
    make_result_response(id, result)

fn handle_resources_read(id: text, uri: text) -> text:
    if uri == "":
        return make_error(id, -32602, "Missing required parameter: uri")
    if uri == "project:///info":
        val info = "Simple MCP (main_lazy)" + NL + "Working Dir: " + get_cwd()
        return make_resource_content_response(id, uri, info, "text/plain")
    if uri.starts_with("file:///"):
        val path = uri.substring(8)
        val content = file_read(path)
        if content == "":
            return make_error(id, -32002, "File not found: " + path)
        return make_resource_content_response(id, uri, content, "text/plain")
    if uri == "debuglog:///status":
        val status_json = debug_log_status_json()
        return make_resource_content_response(id, uri, status_json, "application/json")
    make_error(id, -32002, "Resource not found: " + uri)

fn make_prompt_arg(name: text, desc: text, required: bool) -> text:
    var r = LB()
    r = r + jp("name", js(name))
    r = r + "," + jp("description", js(desc))
    var req = "false"
    if required:
        req = "true"
    r = r + "," + jp("required", req)
    r = r + RB()
    r

fn make_prompt_json(name: text, desc: text, args_json: text) -> text:
    var r = LB()
    r = r + jp("name", js(name))
    r = r + "," + jp("description", js(desc))
    r = r + "," + jp("arguments", args_json)
    r = r + RB()
    r

fn handle_prompts_list(id: text) -> text:
    val p1 = make_prompt_json("analyze-file", "Analyze a Simple source file", "[" + make_prompt_arg("path", "Path to file", true) + "]")
    val p2 = make_prompt_json("generate-tests", "Generate SSpec tests for a file", "[" + make_prompt_arg("path", "Path to file", true) + "]")
    val result = jo1(jp("prompts", "[" + p1 + "," + p2 + "]"))
    make_result_response(id, result)

fn make_prompt_response(id: text, description: text, user_content: text) -> text:
    var msg = LB()
    msg = msg + jp("role", js("user"))
    var content_obj = LB()
    content_obj = content_obj + jp("type", js("text"))
    content_obj = content_obj + "," + jp("text", js(escape_json(user_content)))
    content_obj = content_obj + RB()
    msg = msg + "," + jp("content", content_obj)
    msg = msg + RB()

    var result = LB()
    result = result + jp("description", js(escape_json(description)))
    result = result + "," + jp("messages", "[" + msg + "]")
    result = result + RB()
    make_result_response(id, result)

fn handle_prompts_get(id: text, prompt_name: text, body: text) -> text:
    if prompt_name == "":
        return make_error(id, -32602, "Missing required parameter: name")
    val path = extract_field(body, "path")
    if prompt_name == "analyze-file":
        var content = "Analyze this file for issues and improvements."
        if path != "":
            content = content + " File: " + path
        return make_prompt_response(id, "Analyze file", content)
    elif prompt_name == "generate-tests":
        var content = "Generate comprehensive SSpec tests."
        if path != "":
            content = content + " File: " + path
        return make_prompt_response(id, "Generate tests", content)
    make_error(id, -32601, "Unknown prompt: " + prompt_name)

fn handle_completion_req(id: text, body: text) -> text:
    val arg_name = extract_field(body, "name")
    val arg_value = extract_field(body, "value")
    var values = "[]"
    if arg_name == "path":
        values = "[" + js("src/") + "," + js("test/") + "," + js("doc/") + "," + js("scripts/") + "]"
    elif arg_name == "mode":
        values = "[" + js("over") + "," + js("in") + "," + js("out") + "]"
    elif arg_name == "target_type":
        values = "[" + js("interpreter") + "," + js("smf") + "," + js("native") + "," + js("remote") + "]"
    elif arg_name == "level":
        values = "[" + js("trace") + "," + js("debug") + "," + js("info") + "," + js("warn") + "," + js("error") + "]"
    elif arg_value != "":
        values = "[" + js(arg_value) + "]"

    val total = top_level_item_count(values)
    var completion = LB()
    completion = completion + jp("values", values)
    completion = completion + "," + jp("total", str(total))
    completion = completion + "," + jp("hasMore", "false")
    completion = completion + RB()
    val result = jo1(jp("completion", completion))
    make_result_response(id, result)

# ============================================================================
# Tool dispatch — inline implementations (no subprocess, no module imports)
# ============================================================================

fn dispatch_tool(id: text, tool_name: text, body: text) -> text:
    if tool_name == "":
        return make_tool_error(id, -32602, "Missing tool name")

    # Diagnostic read tools
    if tool_name == "simple_read":
        return handle_simple_read(id, body)
    elif tool_name == "simple_check":
        return handle_simple_check(id, body)
    elif tool_name == "simple_symbols":
        return handle_simple_symbols(id, body)
    elif tool_name == "simple_status":
        return handle_simple_status(id, body)

    # Diagnostic edit tools
    elif tool_name == "simple_edit":
        return handle_simple_edit(id, body)
    elif tool_name == "simple_multi_edit":
        return handle_simple_multi_edit(id, body)
    elif tool_name == "simple_run":
        return handle_simple_run(id, body)

    # VCS tools
    elif tool_name == "simple_diff":
        return handle_simple_diff(id, body)
    elif tool_name == "simple_log":
        return handle_simple_log(id, body)
    elif tool_name == "simple_squash":
        return handle_simple_squash(id, body)
    elif tool_name == "simple_new":
        return handle_simple_new(id, body)

    # API search
    elif tool_name == "simple_api":
        return handle_simple_api(id, body)

    # Debug tools
    elif tool_name == "debug_create_session":
        return handle_debug_create_session(id, body)
    elif tool_name == "debug_list_sessions":
        return handle_debug_list_sessions(id)
    elif tool_name == "debug_close_session":
        return handle_debug_close_session(id, body)
    elif tool_name == "debug_set_breakpoint":
        return handle_debug_set_breakpoint(id, body)
    elif tool_name == "debug_remove_breakpoint":
        return handle_debug_remove_breakpoint(id, body)
    elif tool_name == "debug_continue":
        return handle_debug_continue(id, body)
    elif tool_name == "debug_step":
        return handle_debug_step(id, body)
    elif tool_name == "debug_get_variables":
        return handle_debug_get_variables(id, body)
    elif tool_name == "debug_stack_trace":
        return handle_debug_stack_trace(id, body)
    elif tool_name == "debug_evaluate":
        return handle_debug_evaluate(id, body)
    elif tool_name == "debug_set_function_breakpoint":
        return handle_debug_set_function_breakpoint(id, body)
    elif tool_name == "debug_enable_breakpoint":
        return handle_debug_enable_breakpoint(id, body)
    elif tool_name == "debug_get_source":
        return handle_debug_get_source(id, body)
    elif tool_name == "debug_watch":
        return handle_debug_watch(id, body)
    elif tool_name == "debug_set_variable":
        return handle_debug_set_variable(id, body)
    elif tool_name == "debug_terminate":
        return handle_debug_terminate(id, body)
    elif tool_name == "debug_log_enable":
        return handle_debug_log_enable(id, body)
    elif tool_name == "debug_log_disable":
        return handle_debug_log_disable(id)
    elif tool_name == "debug_log_clear":
        return handle_debug_log_clear(id)
    elif tool_name == "debug_log_query":
        return handle_debug_log_query(id, body)
    elif tool_name == "debug_log_tree":
        return handle_debug_log_tree(id, body)
    elif tool_name == "debug_log_status":
        return handle_debug_log_status(id)

    make_tool_error(id, -32601, "Unknown tool: " + tool_name)

# ============================================================================
# simple_read — Read source file with line numbers + diagnostics
# ============================================================================

fn handle_simple_read(id: text, body: text) -> text:
    val path = extract_field(body, "path")
    if path == "":
        return make_tool_error(id, -32602, "Missing required parameter: path")

    val source = file_read(path)
    if source == "":
        return make_tool_error(id, -32602, "Could not read file: " + path)

    # Add line numbers
    val lines = source.split(NL)
    var num_parts: [text] = []
    var line_num = 0
    for line in lines:
        line_num = line_num + 1
        num_parts.push(str(line_num) + " | " + line + NL)
    val numbered = num_parts.join("")

    # Run diagnostics
    val (check_out, check_exit) = shell_cmd("bin/simple check " + path + " 2>&1")

    var out_parts: [text] = []
    out_parts.push("-- " + path)
    if check_exit == 0:
        out_parts.push(" [clean]")
    else:
        out_parts.push(" [has errors]")
    out_parts.push(" --" + NL)
    out_parts.push(numbered)

    if check_exit != 0:
        out_parts.push(NL + "-- diagnostics --" + NL)
        out_parts.push(check_out)
    make_tool_result(id, out_parts.join(""))

# ============================================================================
# simple_check — Type-check source and return diagnostic output
# ============================================================================

fn handle_simple_check(id: text, body: text) -> text:
    val path = extract_field(body, "path")
    if path == "":
        return make_tool_error(id, -32602, "Missing required parameter: path")

    val (check_out, check_exit) = shell_cmd("bin/simple check " + path + " 2>&1")

    var output = ""
    if check_exit == 0:
        output = "OK: no errors in " + path
    else:
        output = check_out
    make_tool_result(id, output)

# ============================================================================
# simple_symbols — List symbols (fn, class, struct, enum, export)
# ============================================================================

fn handle_simple_symbols(id: text, body: text) -> text:
    val path = extract_field(body, "path")
    if path == "":
        return make_tool_error(id, -32602, "Missing required parameter: path")

    val content = file_read(path)
    if content == "":
        return make_tool_error(id, -32602, "Could not read file: " + path)

    val lines = content.split(NL)
    var out_parts: [text] = []
    out_parts.push("-- symbols in " + path + " --" + NL)
    var line_num = 0

    for line in lines:
        line_num = line_num + 1
        val trimmed = line.trim()

        var kind = ""
        if trimmed.starts_with("fn "):
            kind = "fn"
        elif trimmed.starts_with("me "):
            kind = "method"
        elif trimmed.starts_with("static fn "):
            kind = "static fn"
        elif trimmed.starts_with("class "):
            kind = "class"
        elif trimmed.starts_with("struct "):
            kind = "struct"
        elif trimmed.starts_with("enum "):
            kind = "enum"
        elif trimmed.starts_with("export "):
            kind = "export"

        if kind != "":
            # Extract up to colon for signature
            val colon_idx = trimmed.index_of(":") ?? -1
            var sig = trimmed
            if colon_idx > 0:
                sig = trimmed.substring(0, colon_idx)
            out_parts.push("  " + str(line_num) + ": " + sig + NL)

    make_tool_result(id, out_parts.join(""))

# ============================================================================
# simple_status — Project diagnostic overview
# ============================================================================

fn handle_simple_status(id: text, body: text) -> text:
    val paths_str = extract_field(body, "paths")

    var file_list_str = ""
    if paths_str != "":
        file_list_str = paths_str
    else:
        # Get changed files from jj
        val (jj_out, jj_exit) = shell_cmd("jj --no-pager --color never diff -r @ --stat 2>/dev/null")
        if jj_exit == 0 and jj_out.trim() != "":
            file_list_str = extract_spl_from_stat(jj_out)
        else:
            # Fallback: find spl files
            val dir = extract_field(body, "directory")
            var scan_dir = "src/"
            if dir != "":
                scan_dir = dir
            val (find_out, _) = shell_cmd("find " + scan_dir + " -name '*.spl' -type f | sort | head -30")
            file_list_str = find_out.trim()

    if file_list_str == "":
        return make_tool_result(id, "-- Project Diagnostics --" + NL + "No .spl files found to check.")

    # Check each file
    val files = file_list_str.split(NL)
    var out_parts: [text] = []
    out_parts.push("-- Project Diagnostics --" + NL)
    var total_errors = 0
    var file_count = 0

    for fpath in files:
        val fp = fpath.trim()
        if fp == "" or not fp.ends_with(".spl"):
            continue
        file_count = file_count + 1
        val (co, ce) = shell_cmd("bin/simple check " + fp + " 2>&1")
        if ce == 0:
            out_parts.push("  " + fp + "  clean" + NL)
        else:
            total_errors = total_errors + 1
            # Count error lines
            val err_lines = co.split(NL)
            var err_count = 0
            for el in err_lines:
                val et = el.trim()
                val is_err = et.starts_with("error") or et.starts_with("Error") or et.starts_with("Type error") or et.starts_with("Parse error")
                if is_err:
                    err_count = err_count + 1
            out_parts.push("  " + fp + "  " + str(err_count) + " error(s)" + NL)

    out_parts.push("-- " + str(total_errors) + " file(s) with errors out of " + str(file_count) + " checked --")
    make_tool_result(id, out_parts.join(""))

fn extract_spl_from_stat(stat_output: text) -> text:
    var parts: [text] = []
    val lines = stat_output.split(NL)
    for line in lines:
        val t = line.trim()
        val pipe_idx = t.index_of(" |") ?? -1
        if pipe_idx > 0:
            val fname = t.substring(0, pipe_idx).trim()
            if fname.ends_with(".spl"):
                parts.push(fname)
        elif t.ends_with(".spl"):
            parts.push(t)
    parts.join(NL)

# ============================================================================
# simple_edit — Edit file (find/replace) with diagnostic check
# ============================================================================

fn handle_simple_edit(id: text, body: text) -> text:
    val path = extract_field(body, "path")
    val old_string = extract_field(body, "old_string")
    val new_string = extract_field(body, "new_string")

    if path == "":
        return make_tool_error(id, -32602, "Missing required parameter: path")
    if old_string == "":
        return make_tool_error(id, -32602, "Missing required parameter: old_string")

    val content = file_read(path)
    if content == "":
        return make_tool_error(id, -32602, "Could not read file: " + path)

    val idx = content.index_of(old_string) ?? -1
    if idx < 0:
        return make_tool_error(id, -32602, "old_string not found in file")

    # Perform replacement
    val before = content.substring(0, idx)
    val after = content.substring(idx + old_string.len())
    val new_content = before + new_string + after

    # Write file
    file_write(path, new_content)

    # Check diagnostics after edit
    val (check_out, check_exit) = shell_cmd("bin/simple check " + path + " 2>&1")

    # Find edit line number
    val before_lines = before.split(NL)
    val edit_line = before_lines.len()

    var out_parts: [text] = []
    out_parts.push("-- edit " + path + ":" + str(edit_line) + " --" + NL)
    out_parts.push("Replaced " + str(old_string.len()) + " chars with " + str(new_string.len()) + " chars" + NL)

    if check_exit == 0:
        out_parts.push("Diagnostics: clean (no errors)")
    else:
        out_parts.push(NL + "-- post-edit diagnostics --" + NL)
        out_parts.push(check_out)

    make_tool_result(id, out_parts.join(""))

# ============================================================================
# simple_multi_edit — Batch edits with single recheck
# ============================================================================

fn handle_simple_multi_edit(id: text, body: text) -> text:
    val path = extract_field(body, "path")
    val edits_str = extract_field(body, "edits")

    if path == "":
        return make_tool_error(id, -32602, "Missing required parameter: path")
    if edits_str == "":
        return make_tool_error(id, -32602, "Missing required parameter: edits")

    var content = file_read(path)
    if content == "":
        return make_tool_error(id, -32602, "Could not read file: " + path)

    # Parse and apply edits: find each old_string/new_string pair
    var edit_count = 0
    var search_pos = 0
    for _iter in range(0, 100):
        val old_key_search = "\"old_string\":"
        val old_idx = find_in_text(edits_str, old_key_search, search_pos)
        if old_idx < 0:
            break
        val old_val = extract_quoted_after(edits_str, old_idx + old_key_search.len())

        val new_key_search = "\"new_string\":"
        val new_idx = find_in_text(edits_str, new_key_search, old_idx)
        if new_idx < 0:
            break
        val new_val = extract_quoted_after(edits_str, new_idx + new_key_search.len())

        # Apply edit
        val rep_idx = content.index_of(old_val) ?? -1
        if rep_idx >= 0:
            val before = content.substring(0, rep_idx)
            val after = content.substring(rep_idx + old_val.len())
            content = before + new_val + after
            edit_count = edit_count + 1

        search_pos = new_idx + new_key_search.len() + new_val.len()

    file_write(path, content)

    val (check_out, check_exit) = shell_cmd("bin/simple check " + path + " 2>&1")

    var out_parts: [text] = []
    out_parts.push("-- multi-edit " + path + " (" + str(edit_count) + " edits applied) --" + NL)
    if check_exit == 0:
        out_parts.push("Diagnostics: clean (no errors)")
    else:
        out_parts.push(NL + "-- post-edit diagnostics --" + NL)
        out_parts.push(check_out)

    make_tool_result(id, out_parts.join(""))

fn find_in_text(haystack: text, needle: text, start: i64) -> i64:
    if start >= haystack.len():
        return -1
    val sub = haystack.substring(start)
    val idx = sub.index_of(needle) ?? -1
    if idx < 0:
        return -1
    start + idx

fn extract_quoted_after(s: text, start: i64) -> text:
    # Find opening quote after start position
    var pos = start
    for _i in range(0, 200):
        if pos >= s.len():
            return ""
        val ch = s.substring(pos, pos + 1)
        if ch == "\"":
            break
        pos = pos + 1
    pos = pos + 1
    # Read until closing quote
    var parts: [text] = []
    var escaped = false
    for _i in range(0, 50000):
        if pos >= s.len():
            break
        val ch = s.substring(pos, pos + 1)
        if escaped:
            if ch == "n":
                parts.push(NL)
            elif ch == "t":
                parts.push("\t")
            else:
                parts.push(ch)
            escaped = false
        elif ch == "\\":
            escaped = true
        elif ch == "\"":
            break
        else:
            parts.push(ch)
        pos = pos + 1
    parts.join("")

# ============================================================================
# simple_run — Execute .spl file and capture output
# ============================================================================

fn handle_simple_run(id: text, body: text) -> text:
    val path = extract_field(body, "path")
    if path == "":
        return make_tool_error(id, -32602, "Missing required parameter: path")

    val args_str = extract_field(body, "args")
    val timeout_str = extract_field(body, "timeout_sec")
    var timeout = 10
    if timeout_str != "":
        timeout = int(timeout_str)
        if timeout < 1:
            timeout = 10

    var cmd = "timeout " + str(timeout) + " bin/simple " + path
    if args_str != "":
        cmd = cmd + " " + args_str
    cmd = cmd + " 2>&1"

    val (run_out, run_exit) = shell_cmd(cmd)

    var out_parts: [text] = []
    out_parts.push("-- run " + path + " --" + NL)
    out_parts.push("exit_code: " + str(run_exit) + NL)

    if run_exit == 124:
        out_parts.push("TIMEOUT: process killed after " + str(timeout) + "s" + NL)

    out_parts.push(NL + "-- output --" + NL)
    out_parts.push(run_out)
    make_tool_result(id, out_parts.join(""))

# ============================================================================
# simple_diff — jj diff with file list
# ============================================================================

fn handle_simple_diff(id: text, body: text) -> text:
    val revision = extract_field(body, "revision")
    val paths_str = extract_field(body, "paths")

    var rev = "@"
    if revision != "":
        rev = revision

    var diff_cmd = "jj --no-pager --color never diff -r " + rev
    if paths_str != "":
        val path_parts = paths_str.split(",")
        for pp in path_parts:
            val pt = pp.trim()
            if pt != "":
                diff_cmd = diff_cmd + " " + pt
    diff_cmd = diff_cmd + " 2>&1"

    val (diff_out, _) = shell_cmd(diff_cmd)

    var out_parts: [text] = []
    out_parts.push("-- simple_diff -r " + rev + " --" + NL)
    out_parts.push(diff_out)
    make_tool_result(id, out_parts.join(""))

# ============================================================================
# simple_log — jj log
# ============================================================================

fn handle_simple_log(id: text, body: text) -> text:
    val limit_str = extract_field(body, "limit")
    val revsets = extract_field(body, "revsets")

    var limit = 10
    if limit_str != "":
        limit = int(limit_str)
        if limit < 1:
            limit = 10

    var log_cmd = "jj --no-pager --color never log --limit " + str(limit)
    if revsets != "":
        log_cmd = log_cmd + " -r " + revsets
    log_cmd = log_cmd + " 2>&1"

    val (log_out, _) = shell_cmd(log_cmd)

    var out_parts: [text] = []
    out_parts.push("-- simple_log --" + NL)
    out_parts.push(log_out)
    make_tool_result(id, out_parts.join(""))

# ============================================================================
# simple_squash — jj squash
# ============================================================================

fn handle_simple_squash(id: text, body: text) -> text:
    val revision = extract_field(body, "revision")
    val message = extract_field(body, "message")

    var squash_cmd = "jj --no-pager --color never squash"
    if revision != "":
        squash_cmd = squash_cmd + " -r " + revision
    if message != "":
        squash_cmd = squash_cmd + " -m '" + message + "'"
    squash_cmd = squash_cmd + " 2>&1"

    val (squash_out, squash_exit) = shell_cmd(squash_cmd)

    var out_parts: [text] = []
    out_parts.push("-- simple_squash --" + NL)
    out_parts.push(squash_out)
    if squash_exit == 0:
        out_parts.push(NL + "Squash completed successfully.")
    else:
        out_parts.push(NL + "Squash failed (exit code " + str(squash_exit) + ").")
    make_tool_result(id, out_parts.join(""))

# ============================================================================
# simple_new — jj new
# ============================================================================

fn handle_simple_new(id: text, body: text) -> text:
    val revision = extract_field(body, "revision")
    val message = extract_field(body, "message")

    var new_cmd = "jj --no-pager --color never new"
    if revision != "":
        new_cmd = new_cmd + " " + revision
    if message != "":
        new_cmd = new_cmd + " -m '" + message + "'"
    new_cmd = new_cmd + " 2>&1"

    val (new_out, new_exit) = shell_cmd(new_cmd)

    # Get revision info
    val (rev_info, _) = shell_cmd("jj --no-pager --color never log -r @ --limit 1 2>&1")

    var out_parts: [text] = []
    out_parts.push("-- simple_new --" + NL)
    out_parts.push(new_out + NL)
    out_parts.push(rev_info)
    if new_exit == 0:
        out_parts.push(NL + "New revision created.")
    else:
        out_parts.push(NL + "Failed (exit code " + str(new_exit) + ").")
    make_tool_result(id, out_parts.join(""))

# ============================================================================
# simple_api — Search module API
# ============================================================================

fn handle_simple_api(id: text, body: text) -> text:
    val module_name = extract_field(body, "module")
    val query = extract_field(body, "query")
    val visibility = extract_field(body, "visibility")

    if module_name == "" and query == "":
        return make_tool_error(id, -32602, "Provide 'module' or 'query' parameter")

    var search_cmd = ""
    if module_name != "":
        # Search for module file and grep for fn/class/struct/export
        search_cmd = "find src/ -name '*.spl' -path '*" + module_name + "*' | head -5 | xargs grep -n '^fn \\|^class \\|^struct \\|^enum \\|^export ' 2>/dev/null | head -50"
    else:
        # Search all files for query
        search_cmd = "grep -rn '" + query + "' src/ --include='*.spl' | head -50 2>/dev/null"

    val (api_out, _) = shell_cmd(search_cmd)

    var out_parts: [text] = []
    out_parts.push("-- simple_api")
    if module_name != "":
        out_parts.push(" module=" + module_name)
    if query != "":
        out_parts.push(" query=" + query)
    out_parts.push(" --" + NL)
    if api_out.trim() == "":
        out_parts.push("No results found.")
    else:
        out_parts.push(api_out)
    make_tool_result(id, out_parts.join(""))

# ============================================================================
# Debug tools (lightweight in-process stateful implementation)
# ============================================================================

fn find_session_index(session_id: text) -> i64:
    var idx = 0
    for s in DEBUG_SESSIONS:
        if s.id == session_id:
            return idx
        idx = idx + 1
    -1

fn bool_text(v: bool) -> text:
    if v:
        return "true"
    "false"

fn debug_log_add(entry_type: text, function_name: text, message: text):
    if not DEBUG_LOG_ENABLED:
        return
    var e = LB()
    e = e + jp("id", str(DEBUG_LOG_NEXT_ID))
    e = e + "," + jp("entry_type", js(entry_type))
    e = e + "," + jp("function_name", js(function_name))
    e = e + "," + jp("message", js(message))
    e = e + RB()
    DEBUG_LOG_ENTRIES = DEBUG_LOG_ENTRIES + [e]
    DEBUG_LOG_NEXT_ID = DEBUG_LOG_NEXT_ID + 1

fn handle_debug_create_session(id: text, body: text) -> text:
    val program = extract_field(body, "program")
    if program == "":
        return make_tool_error(id, -32602, "Missing required parameter: program")
    var target_type = extract_field(body, "target_type")
    if target_type == "":
        target_type = "interpreter"
    val session_id = "session_" + str(DEBUG_NEXT_SESSION_ID)
    DEBUG_NEXT_SESSION_ID = DEBUG_NEXT_SESSION_ID + 1
    val session = LazySession(
        id: session_id,
        program: program,
        target_type: target_type,
        state: "created",
        breakpoints: [],
        watches: [],
        next_bp_id: 1
    )
    DEBUG_SESSIONS = DEBUG_SESSIONS + [session]
    debug_log_add("enter", "debug_create_session", "created " + session_id)
    var r = LB()
    r = r + jp("session_id", js(session_id))
    r = r + "," + jp("program", js(program))
    r = r + "," + jp("target_type", js(target_type))
    r = r + "," + jp("state", js("created"))
    r = r + RB()
    make_tool_result(id, r)

fn handle_debug_list_sessions(id: text) -> text:
    var arr = SB_L()
    var first = true
    for s in DEBUG_SESSIONS:
        if not first:
            arr = arr + ","
        first = false
        var obj = LB()
        obj = obj + jp("session_id", js(s.id))
        obj = obj + "," + jp("program", js(s.program))
        obj = obj + "," + jp("target_type", js(s.target_type))
        obj = obj + "," + jp("state", js(s.state))
        obj = obj + RB()
        arr = arr + obj
    arr = arr + SB_R()
    make_tool_result(id, arr)

fn handle_debug_close_session(id: text, body: text) -> text:
    val session_id = extract_field(body, "session_id")
    if session_id == "":
        return make_tool_error(id, -32602, "Missing required parameter: session_id")
    var found = false
    var kept: [LazySession] = []
    for s in DEBUG_SESSIONS:
        if s.id == session_id:
            found = true
        else:
            kept = kept + [s]
    if not found:
        return make_tool_error(id, -32602, "Session not found: " + session_id)
    DEBUG_SESSIONS = kept
    debug_log_add("exit", "debug_close_session", "closed " + session_id)
    make_tool_result(id, jo2(jp("closed", js(session_id)), jp("status", js("ok"))))

fn handle_debug_set_breakpoint(id: text, body: text) -> text:
    val session_id = extract_field(body, "session_id")
    val file = extract_field(body, "file")
    val line_str = extract_field(body, "line")
    if session_id == "" or file == "" or line_str == "":
        return make_tool_error(id, -32602, "Missing required parameter: session_id/file/line")
    val idx = find_session_index(session_id)
    if idx < 0:
        return make_tool_error(id, -32602, "Session not found: " + session_id)
    var s = DEBUG_SESSIONS[idx]
    var line_num = int(line_str)
    if line_num < 1:
        line_num = 1
    val bp_id = s.next_bp_id
    s.next_bp_id = s.next_bp_id + 1
    val bp = LazyBreakpoint(
        id: bp_id,
        file: file,
        line: line_num,
        function_name: "",
        condition: extract_field(body, "condition"),
        enabled: true
    )
    s.breakpoints = s.breakpoints + [bp]
    DEBUG_SESSIONS[idx] = s
    debug_log_add("enter", "debug_set_breakpoint", session_id + " #" + str(bp_id))
    var r = LB()
    r = r + jp("breakpoint_id", str(bp_id))
    r = r + "," + jp("session_id", js(session_id))
    r = r + "," + jp("file", js(file))
    r = r + "," + jp("line", str(line_num))
    r = r + "," + jp("verified", "true")
    r = r + RB()
    make_tool_result(id, r)

fn handle_debug_remove_breakpoint(id: text, body: text) -> text:
    val session_id = extract_field(body, "session_id")
    val bp_id_str = extract_field(body, "breakpoint_id")
    if session_id == "" or bp_id_str == "":
        return make_tool_error(id, -32602, "Missing required parameter: session_id/breakpoint_id")
    val idx = find_session_index(session_id)
    if idx < 0:
        return make_tool_error(id, -32602, "Session not found: " + session_id)
    val bp_id = int(bp_id_str)
    var s = DEBUG_SESSIONS[idx]
    var found = false
    var kept: [LazyBreakpoint] = []
    for bp in s.breakpoints:
        if bp.id == bp_id:
            found = true
        else:
            kept = kept + [bp]
    if not found:
        return make_tool_error(id, -32602, "Breakpoint not found: " + bp_id_str)
    s.breakpoints = kept
    DEBUG_SESSIONS[idx] = s
    debug_log_add("exit", "debug_remove_breakpoint", session_id + " #" + bp_id_str)
    make_tool_result(id, jo2(jp("removed", js(bp_id_str)), jp("status", js("ok"))))

fn handle_debug_continue(id: text, body: text) -> text:
    val session_id = extract_field(body, "session_id")
    if session_id == "":
        return make_tool_error(id, -32602, "Missing required parameter: session_id")
    val idx = find_session_index(session_id)
    if idx < 0:
        return make_tool_error(id, -32602, "Session not found: " + session_id)
    var s = DEBUG_SESSIONS[idx]
    s.state = "running"
    DEBUG_SESSIONS[idx] = s
    debug_log_add("enter", "debug_continue", session_id)
    make_tool_result(id, jo2(jp("session_id", js(session_id)), jp("state", js("running"))))

fn handle_debug_step(id: text, body: text) -> text:
    val session_id = extract_field(body, "session_id")
    var mode = extract_field(body, "mode")
    if session_id == "" or mode == "":
        return make_tool_error(id, -32602, "Missing required parameter: session_id/mode")
    if mode != "over" and mode != "in" and mode != "out":
        return make_tool_error(id, -32602, "Invalid step mode: " + mode)
    val idx = find_session_index(session_id)
    if idx < 0:
        return make_tool_error(id, -32602, "Session not found: " + session_id)
    var s = DEBUG_SESSIONS[idx]
    s.state = "paused"
    DEBUG_SESSIONS[idx] = s
    debug_log_add("enter", "debug_step", session_id + " " + mode)
    make_tool_result(id, jo3(jp("session_id", js(session_id)), jp("mode", js(mode)), jp("state", js("paused"))))

fn handle_debug_get_variables(id: text, body: text) -> text:
    val session_id = extract_field(body, "session_id")
    if session_id == "":
        return make_tool_error(id, -32602, "Missing required parameter: session_id")
    val idx = find_session_index(session_id)
    if idx < 0:
        return make_tool_error(id, -32602, "Session not found: " + session_id)
    make_tool_result(id, jo2(jp("session_id", js(session_id)), jp("variables", SB_L() + SB_R())))

fn handle_debug_stack_trace(id: text, body: text) -> text:
    val session_id = extract_field(body, "session_id")
    if session_id == "":
        return make_tool_error(id, -32602, "Missing required parameter: session_id")
    val idx = find_session_index(session_id)
    if idx < 0:
        return make_tool_error(id, -32602, "Session not found: " + session_id)
    val s = DEBUG_SESSIONS[idx]
    var frame = LB()
    frame = frame + jp("id", "0")
    frame = frame + "," + jp("name", js("main"))
    frame = frame + "," + jp("source", js(s.program))
    frame = frame + "," + jp("line", "1")
    frame = frame + RB()
    var r = LB()
    r = r + jp("session_id", js(session_id))
    r = r + "," + jp("frames", SB_L() + frame + SB_R())
    r = r + "," + jp("total_frames", "1")
    r = r + RB()
    make_tool_result(id, r)

fn handle_debug_evaluate(id: text, body: text) -> text:
    val session_id = extract_field(body, "session_id")
    val expression = extract_field(body, "expression")
    if session_id == "" or expression == "":
        return make_tool_error(id, -32602, "Missing required parameter: session_id/expression")
    val idx = find_session_index(session_id)
    if idx < 0:
        return make_tool_error(id, -32602, "Session not found: " + session_id)
    var r = LB()
    r = r + jp("session_id", js(session_id))
    r = r + "," + jp("expression", js(expression))
    r = r + "," + jp("result", js(expression))
    r = r + "," + jp("type", js("string"))
    r = r + RB()
    make_tool_result(id, r)

fn handle_debug_set_function_breakpoint(id: text, body: text) -> text:
    val session_id = extract_field(body, "session_id")
    val function_name = extract_field(body, "function_name")
    if session_id == "" or function_name == "":
        return make_tool_error(id, -32602, "Missing required parameter: session_id/function_name")
    val idx = find_session_index(session_id)
    if idx < 0:
        return make_tool_error(id, -32602, "Session not found: " + session_id)
    var s = DEBUG_SESSIONS[idx]
    val bp_id = s.next_bp_id
    s.next_bp_id = s.next_bp_id + 1
    val bp = LazyBreakpoint(
        id: bp_id,
        file: "",
        line: 0,
        function_name: function_name,
        condition: extract_field(body, "condition"),
        enabled: true
    )
    s.breakpoints = s.breakpoints + [bp]
    DEBUG_SESSIONS[idx] = s
    var r = LB()
    r = r + jp("breakpoint_id", str(bp_id))
    r = r + "," + jp("session_id", js(session_id))
    r = r + "," + jp("function_name", js(function_name))
    r = r + "," + jp("type", js("function"))
    r = r + "," + jp("verified", "true")
    r = r + RB()
    make_tool_result(id, r)

fn handle_debug_enable_breakpoint(id: text, body: text) -> text:
    val session_id = extract_field(body, "session_id")
    val bp_id_str = extract_field(body, "breakpoint_id")
    val enabled_str = extract_field(body, "enabled")
    if session_id == "" or bp_id_str == "" or enabled_str == "":
        return make_tool_error(id, -32602, "Missing required parameter: session_id/breakpoint_id/enabled")
    val idx = find_session_index(session_id)
    if idx < 0:
        return make_tool_error(id, -32602, "Session not found: " + session_id)
    val bp_id = int(bp_id_str)
    var enabled = true
    if enabled_str == "false" or enabled_str == "0":
        enabled = false
    var s = DEBUG_SESSIONS[idx]
    var found = false
    var updated: [LazyBreakpoint] = []
    for bp in s.breakpoints:
        var nbp = bp
        if bp.id == bp_id:
            nbp.enabled = enabled
            found = true
        updated = updated + [nbp]
    if not found:
        return make_tool_error(id, -32602, "Breakpoint not found: " + bp_id_str)
    s.breakpoints = updated
    DEBUG_SESSIONS[idx] = s
    make_tool_result(id, jo3(jp("breakpoint_id", str(bp_id)), jp("enabled", bool_text(enabled)), jp("status", js("ok"))))

fn handle_debug_get_source(id: text, body: text) -> text:
    val session_id = extract_field(body, "session_id")
    val path = extract_field(body, "file")
    if session_id == "" or path == "":
        return make_tool_error(id, -32602, "Missing required parameter: session_id/file")
    val idx = find_session_index(session_id)
    if idx < 0:
        return make_tool_error(id, -32602, "Session not found: " + session_id)
    var start_line = int(extract_field(body, "start_line"))
    if start_line < 1:
        start_line = 1
    var count = int(extract_field(body, "count"))
    if count < 1:
        count = 20
    val content = file_read(path)
    if content == "":
        return make_tool_error(id, -32602, "Could not read file: " + path)
    val lines = content.split(NL)
    var end_line = start_line + count - 1
    if end_line > lines.len():
        end_line = lines.len()
    var out: [text] = []
    var i = start_line
    for _k in range(0, count + 1):
        if i > end_line:
            break
        out.push(str(i) + " | " + lines[i - 1])
        i = i + 1
    var r = LB()
    r = r + jp("session_id", js(session_id))
    r = r + "," + jp("file", js(path))
    r = r + "," + jp("start_line", str(start_line))
    r = r + "," + jp("source", js(out.join(NL)))
    r = r + RB()
    make_tool_result(id, r)

fn handle_debug_watch(id: text, body: text) -> text:
    val session_id = extract_field(body, "session_id")
    val action = extract_field(body, "action")
    if session_id == "" or action == "":
        return make_tool_error(id, -32602, "Missing required parameter: session_id/action")
    val idx = find_session_index(session_id)
    if idx < 0:
        return make_tool_error(id, -32602, "Session not found: " + session_id)
    var s = DEBUG_SESSIONS[idx]
    if action == "add":
        val expr = extract_field(body, "expression")
        if expr == "":
            return make_tool_error(id, -32602, "Missing expression for add")
        s.watches = s.watches + [expr]
        DEBUG_SESSIONS[idx] = s
        return make_tool_result(id, jo3(jp("action", js("add")), jp("expression", js(expr)), jp("success", "true")))
    elif action == "remove":
        val expr = extract_field(body, "expression")
        if expr == "":
            return make_tool_error(id, -32602, "Missing expression for remove")
        var found = false
        var kept: [text] = []
        for w in s.watches:
            if w == expr and not found:
                found = true
            else:
                kept = kept + [w]
        s.watches = kept
        DEBUG_SESSIONS[idx] = s
        return make_tool_result(id, jo3(jp("action", js("remove")), jp("expression", js(expr)), jp("success", bool_text(found))))
    elif action == "list":
        var arr = SB_L()
        var first = true
        for w in s.watches:
            if not first:
                arr = arr + ","
            first = false
            arr = arr + js(w)
        arr = arr + SB_R()
        return make_tool_result(id, jo2(jp("action", js("list")), jp("watches", arr)))
    make_tool_error(id, -32602, "Invalid action: " + action)

fn handle_debug_set_variable(id: text, body: text) -> text:
    val session_id = extract_field(body, "session_id")
    val name = extract_field(body, "name")
    val value = extract_field(body, "value")
    if session_id == "" or name == "" or value == "":
        return make_tool_error(id, -32602, "Missing required parameter: session_id/name/value")
    val idx = find_session_index(session_id)
    if idx < 0:
        return make_tool_error(id, -32602, "Session not found: " + session_id)
    var frame_index = int(extract_field(body, "frame_index"))
    if frame_index < 0:
        frame_index = 0
    var r = LB()
    r = r + jp("name", js(name))
    r = r + "," + jp("value", js(value))
    r = r + "," + jp("frame_index", str(frame_index))
    r = r + "," + jp("success", "true")
    r = r + RB()
    make_tool_result(id, r)

fn handle_debug_terminate(id: text, body: text) -> text:
    val session_id = extract_field(body, "session_id")
    if session_id == "":
        return make_tool_error(id, -32602, "Missing required parameter: session_id")
    val idx = find_session_index(session_id)
    if idx < 0:
        return make_tool_error(id, -32602, "Session not found: " + session_id)
    var s = DEBUG_SESSIONS[idx]
    s.state = "terminated"
    DEBUG_SESSIONS[idx] = s
    debug_log_add("exit", "debug_terminate", session_id)
    make_tool_result(id, jo3(jp("session_id", js(session_id)), jp("state", js("terminated")), jp("status", js("ok"))))

fn handle_debug_log_enable(id: text, body: text) -> text:
    var pattern = extract_field(body, "pattern")
    if pattern == "":
        pattern = "*"
    DEBUG_LOG_ENABLED = true
    DEBUG_LOG_PATTERN = pattern
    debug_log_add("enter", "debug_log_enable", pattern)
    var r = LB()
    r = r + jp("status", js("enabled"))
    r = r + "," + jp("filter_pattern", js(pattern))
    r = r + RB()
    make_tool_result(id, r)

fn handle_debug_log_disable(id: text) -> text:
    DEBUG_LOG_ENABLED = false
    make_tool_result(id, jo1(jp("status", js("disabled"))))

fn handle_debug_log_clear(id: text) -> text:
    DEBUG_LOG_ENTRIES = []
    DEBUG_LOG_NEXT_ID = 1
    make_tool_result(id, jo2(jp("status", js("cleared")), jp("entry_count", "0")))

fn handle_debug_log_query(id: text, body: text) -> text:
    val since_str = extract_field(body, "since_id")
    val entry_type_filter = extract_field(body, "entry_type")
    var since_id = int(since_str)
    if since_id < 0:
        since_id = 0
    var arr = SB_L()
    var first = true
    var count = 0
    for e in DEBUG_LOG_ENTRIES:
        var keep = true
        if since_id > 0:
            val eid = int(extract_field(e, "id"))
            if eid <= since_id:
                keep = false
        if keep and entry_type_filter != "":
            val t = extract_field(e, "entry_type")
            if t != entry_type_filter:
                keep = false
        if keep:
            if not first:
                arr = arr + ","
            first = false
            arr = arr + e
            count = count + 1
    arr = arr + SB_R()
    var r = LB()
    r = r + jp("count", str(count))
    r = r + "," + jp("entries", arr)
    r = r + RB()
    make_tool_result(id, r)

fn handle_debug_log_tree(id: text, body: text) -> text:
    val format = extract_field(body, "format")
    var as_json = false
    if format == "json":
        as_json = true
    if as_json:
        var tree_json = SB_L()
        var has_entries = false
        for _e in DEBUG_LOG_ENTRIES:
            has_entries = true
            break
        if has_entries:
            tree_json = tree_json + DEBUG_LOG_ENTRIES.join(",")
        tree_json = tree_json + SB_R()
        var rj = LB()
        rj = rj + jp("format", js("json"))
        rj = rj + "," + jp("tree", tree_json)
        rj = rj + RB()
        return make_tool_result(id, rj)
    var lines: [text] = []
    for e in DEBUG_LOG_ENTRIES:
        val fname = extract_field(e, "function_name")
        val msg = extract_field(e, "message")
        lines.push(">> " + fname + " - " + msg)
    var rt = LB()
    rt = rt + jp("format", js("text"))
    rt = rt + "," + jp("tree", js(lines.join(NL)))
    rt = rt + RB()
    make_tool_result(id, rt)

fn handle_debug_log_status(id: text) -> text:
    val r = debug_log_status_json()
    make_tool_result(id, r)

fn debug_log_status_json() -> text:
    var entry_count = 0
    for _e in DEBUG_LOG_ENTRIES:
        entry_count = entry_count + 1
    var r = LB()
    r = r + jp("enabled", bool_text(DEBUG_LOG_ENABLED))
    r = r + "," + jp("filter_pattern", js(DEBUG_LOG_PATTERN))
    r = r + "," + jp("entry_count", str(entry_count))
    r = r + "," + jp("stack_depth", "0")
    r = r + RB()
    r
