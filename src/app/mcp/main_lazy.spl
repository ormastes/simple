# Full MCP Server with Lazy Loading
#
# All 33 tools available, but handlers load on-demand via subprocess dispatch.
# Fast startup (~100ms) with full functionality when needed.
#
# Architecture:
#   - Main server: Minimal imports, handles protocol, dispatches to handlers
#   - Handler scripts: Load heavy modules only when their tools are called
#   - Zero startup cost for unused tools

extern fn rt_file_read_text(path: text) -> text
extern fn rt_process_run(cmd: text, args: [text]) -> (text, text, i64)
extern fn rt_env_get(name: text) -> text

val SERVER_NAME = "simple-mcp-full"
val SERVER_VERSION = "3.0.0"
val NL = "\n"

# Protocol auto-detection
var USE_JSON_LINES = false

# Handler paths (relative to SIMPLE_LIB or absolute)
val HANDLER_DEBUG = "src/app/mcp/handlers/debug_handler.spl"
val HANDLER_DEBUG_LOG = "src/app/mcp/handlers/debug_log_handler.spl"
val HANDLER_DIAG = "src/app/mcp/handlers/diag_handler.spl"

# Caches
var TOOLS_CACHE = ""
var INIT_CACHE = ""

# --- JSON helpers (inlined for zero-import startup) ---

fn Q() -> text:
    "\""

fn LB() -> text:
    "{"

fn RB() -> text:
    "}"

fn SB_L() -> text:
    "["

fn SB_R() -> text:
    "]"

fn escape_json(s: text) -> text:
    var result = ""
    for ch in s:
        if ch == "\"":
            result = result + "\\\""
        elif ch == "\\":
            result = result + "\\\\"
        elif ch == "\n":
            result = result + "\\n"
        elif ch == "\r":
            result = result + "\\r"
        elif ch == "\t":
            result = result + "\\t"
        else:
            result = result + ch
    result

fn js(s: text) -> text:
    Q() + escape_json(s) + Q()

fn jp(key: text, value: text) -> text:
    Q() + key + Q() + ":" + value

fn jo1(p1: text) -> text:
    LB() + p1 + RB()

fn jo2(p1: text, p2: text) -> text:
    LB() + p1 + "," + p2 + RB()

fn jo3(p1: text, p2: text, p3: text) -> text:
    LB() + p1 + "," + p2 + "," + p3 + RB()

fn extract_field(json: text, key: text) -> text:
    val search = Q() + key + Q() + ":"
    val idx_result = json.index_of(search)
    var idx = -1
    match idx_result:
        Some(i): idx = i
        nil: return ""
    if idx < 0:
        return ""
    val start = idx + search.len()
    val after = json.substring(start)
    val trimmed = after.trim()
    if trimmed.starts_with(Q()):
        val after_quote = trimmed.substring(1)
        val end_idx_result = after_quote.index_of(Q())
        var end_idx = -1
        match end_idx_result:
            Some(i): end_idx = i
            nil: return ""
        if end_idx < 0:
            return ""
        return trimmed.substring(1, end_idx + 1)
    else:
        var result = ""
        for ch in trimmed:
            if ch == "," or ch == RB() or ch == SB_R() or ch == " " or ch == "\n":
                break
            result = result + ch
        return result

fn extract_id(json: text) -> text:
    extract_field(json, "id")

fn extract_nested(json: text, key: text) -> text:
    val params_search = Q() + "params" + Q() + ":"
    val params_idx_result = json.index_of(params_search)
    var params_idx = -1
    match params_idx_result:
        Some(i): params_idx = i
        nil: return ""
    if params_idx < 0:
        return ""
    val params_start = params_idx + params_search.len()
    val params = json.substring(params_start)
    extract_field(params, key)

fn make_json_result(id: text, result: text) -> text:
    jo3(jp("jsonrpc", js("2.0")), jp("id", id), jp("result", result))

fn make_error(id: text, code: i64, message: text) -> text:
    val err = jo2(jp("code", str(code)), jp("message", js(message)))
    jo3(jp("jsonrpc", js("2.0")), jp("id", id), jp("error", err))

# --- Server loop ---

start_server()

fn start_server():
    var running = true
    for _iter in range(0, 999999):
        if not running:
            return
        var line = read_stdin_message()
        if line == "":
            running = false
        else:
            var method = extract_field(line, "method")
            var id = extract_id(line)
            var response = ""
            if method == "initialize":
                response = make_init_response(id)
            elif method == "initialized" or method == "notifications/initialized":
                response = ""
            elif method == "shutdown":
                response = make_json_result(id, "null")
            elif method == "tools/list":
                response = make_tools_list(id)
            elif method == "tools/call":
                var tool_name = extract_nested(line, "name")
                response = dispatch_tool(id, tool_name, line)
            elif method == "resources/list":
                response = make_json_result(id, jo1(jp("resources", SB_L() + SB_R())))
            elif method == "prompts/list":
                response = make_json_result(id, jo1(jp("prompts", SB_L() + SB_R())))
            elif method == "ping":
                response = make_json_result(id, LB() + RB())
            elif method == "notifications/cancelled":
                response = ""
            else:
                if id != "" and id != "null":
                    response = make_error(id, -32601, "Method not found: " + method)
            if response != "":
                write_stdout_message(response)

# --- Protocol I/O ---

fn read_stdin_message() -> text:
    var line = input()
    if line == "":
        return ""
    if line.ends_with("\r"):
        line = line.substring(0, line.len() - 1)
    if line.starts_with(LB()):
        USE_JSON_LINES = true
        return line
    if line.starts_with("Content-Length:"):
        var len_str = line.replace("Content-Length:", "")
        len_str = len_str.trim()
        val content_length = int(len_str)
        if content_length == 0:
            return ""
        input()
        var body = input()
        return body
    ""

fn write_stdout_message(body: text):
    if USE_JSON_LINES:
        print_raw(body + NL)
    else:
        var header = "Content-Length: " + str(body.len()) + "\r" + NL + "\r" + NL
        print_raw(header)
        print_raw(body)

# --- Initialize response ---

fn make_init_response(id: text) -> text:
    if INIT_CACHE != "":
        return make_json_result(id, INIT_CACHE)
    val caps = jo1(jp("tools", jo1(jp("listChanged", "true"))))
    val server_info = jo3(
        jp("name", js(SERVER_NAME)),
        jp("version", js(SERVER_VERSION)),
        jp("instructions", js("Full-featured MCP server with lazy loading. All 33 tools available (16 debug, 6 debug_log, 4 diag_read, 3 diag_edit, 4 diag_vcs). Tools load on first use for fast startup."))
    )
    val result = jo3(
        jp("protocolVersion", js("2025-06-18")),
        jp("capabilities", caps),
        jp("serverInfo", server_info)
    )
    INIT_CACHE = result
    make_json_result(id, result)

# --- Tools list (all 33 tools, minimal schemas) ---

fn make_tools_list(id: text) -> text:
    if TOOLS_CACHE != "":
        return make_json_result(id, TOOLS_CACHE)

    var tools = SB_L()

    # Debug tools (16)
    tools = tools + make_tool_schema("debug_create_session", "Create a debug session")
    tools = tools + "," + make_tool_schema("debug_list_sessions", "List active debug sessions")
    tools = tools + "," + make_tool_schema("debug_close_session", "Close a debug session")
    tools = tools + "," + make_tool_schema("debug_set_breakpoint", "Set a breakpoint")
    tools = tools + "," + make_tool_schema("debug_remove_breakpoint", "Remove a breakpoint")
    tools = tools + "," + make_tool_schema("debug_continue", "Continue execution")
    tools = tools + "," + make_tool_schema("debug_step", "Step through code")
    tools = tools + "," + make_tool_schema("debug_get_variables", "Get variable values")
    tools = tools + "," + make_tool_schema("debug_stack_trace", "Get stack trace")
    tools = tools + "," + make_tool_schema("debug_evaluate", "Evaluate expression")
    tools = tools + "," + make_tool_schema("debug_set_function_breakpoint", "Set function breakpoint")
    tools = tools + "," + make_tool_schema("debug_enable_breakpoint", "Enable/disable breakpoint")
    tools = tools + "," + make_tool_schema("debug_get_source", "Get source code")
    tools = tools + "," + make_tool_schema("debug_watch", "Add watch expression")
    tools = tools + "," + make_tool_schema("debug_set_variable", "Set variable value")
    tools = tools + "," + make_tool_schema("debug_terminate", "Terminate debug session")

    # Debug log tools (6)
    tools = tools + "," + make_tool_schema("debug_log_enable", "Enable debug logging")
    tools = tools + "," + make_tool_schema("debug_log_disable", "Disable debug logging")
    tools = tools + "," + make_tool_schema("debug_log_clear", "Clear debug logs")
    tools = tools + "," + make_tool_schema("debug_log_query", "Query debug logs")
    tools = tools + "," + make_tool_schema("debug_log_tree", "Get debug log tree")
    tools = tools + "," + make_tool_schema("debug_log_status", "Get debug log status")

    # Diagnostic read tools (4)
    tools = tools + "," + make_tool_schema("simple_read", "Read Simple source with diagnostics")
    tools = tools + "," + make_tool_schema("simple_check", "Check Simple source for errors")
    tools = tools + "," + make_tool_schema("simple_symbols", "List symbols in file")
    tools = tools + "," + make_tool_schema("simple_status", "Get project status")

    # Diagnostic edit tools (3)
    tools = tools + "," + make_tool_schema("simple_edit", "Edit Simple source file")
    tools = tools + "," + make_tool_schema("simple_multi_edit", "Edit multiple files")
    tools = tools + "," + make_tool_schema("simple_run", "Run Simple code")

    # Diagnostic VCS tools (4)
    tools = tools + "," + make_tool_schema("simple_diff", "Show file diff")
    tools = tools + "," + make_tool_schema("simple_log", "Show git log")
    tools = tools + "," + make_tool_schema("simple_squash", "Squash commits")
    tools = tools + "," + make_tool_schema("simple_new", "Create new change")

    tools = tools + SB_R()
    val result = jo1(jp("tools", tools))
    TOOLS_CACHE = result
    make_json_result(id, result)

fn make_tool_schema(name: text, description: text) -> text:
    jo3(
        jp("name", js(name)),
        jp("description", js(description)),
        jp("inputSchema", jo1(jp("type", js("object"))))
    )

# --- Tool dispatch (lazy loading via subprocess) ---

fn dispatch_tool(id: text, tool_name: text, body: text) -> text:
    if tool_name == "":
        return make_error(id, -32602, "Missing tool name")

    # Determine handler based on tool prefix
    var handler_script = ""
    if tool_name.starts_with("debug_log_"):
        handler_script = HANDLER_DEBUG_LOG
    elif tool_name.starts_with("debug_"):
        handler_script = HANDLER_DEBUG
    elif tool_name.starts_with("simple_"):
        handler_script = HANDLER_DIAG
    else:
        return make_error(id, -32601, "Unknown tool: " + tool_name)

    # Invoke handler subprocess (this is where lazy loading happens)
    val runtime_path = get_runtime_path()
    val handler_full_path = resolve_handler_path(handler_script)

    # Pass the full request body to the handler
    val (stdout, stderr, exit_code) = rt_process_run(
        runtime_path,
        [handler_full_path, tool_name, id, body]
    )

    if exit_code != 0:
        return make_error(id, -32603, "Handler error: " + stderr)

    # Handler returns the full JSON-RPC response
    stdout

fn get_runtime_path() -> text:
    # Try to find the runtime binary
    val simple_lib = rt_env_get("SIMPLE_LIB")
    if simple_lib != "":
        return simple_lib + "/../bin/release/simple"
    "bin/release/simple"

fn resolve_handler_path(handler: text) -> text:
    val simple_lib = rt_env_get("SIMPLE_LIB")
    if simple_lib != "":
        # Handler paths are relative to SIMPLE_LIB parent
        return simple_lib + "/../" + handler
    handler
