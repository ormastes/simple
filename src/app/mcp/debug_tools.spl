# MCP Debug Tools - Bridges DAP debug infrastructure to MCP server
#
# Provides 16 debug tools for AI agents:
# - Session lifecycle: create, list, close
# - Breakpoints: set, remove, function breakpoint, enable/disable
# - Execution: continue, step, terminate
# - Inspection: variables, stack trace, evaluate, source
# - Watches: add, remove, list
# - Variable modification: set variable

use app.mcp.helpers.{LB, RB, Q, jp, js, jo1, jo2, jo3, make_tool_schema_multi, make_tool_result, make_error_response, extract_nested_string, escape_json, parse_int}
use app.io.mod (rt_debug_set_active, rt_debug_add_breakpoint_at, rt_debug_remove_breakpoint_at, rt_debug_continue_exec, rt_debug_pause_exec, rt_debug_set_step_mode_val, rt_debug_stack_trace_lines, rt_debug_local_vars, rt_debug_get_current_file, rt_debug_get_current_line, rt_debug_add_breakpoint_rich, rt_debug_add_function_breakpoint, rt_debug_set_breakpoint_enabled, rt_debug_get_breakpoint_info, rt_debug_list_breakpoints, rt_debug_get_source_lines, rt_debug_add_watch, rt_debug_remove_watch, rt_debug_list_watches, rt_debug_set_variable, rt_debug_terminate, rt_debug_select_frame, rt_debug_get_selected_frame, rt_debug_frame_locals)

# --- Session State Types ---

enum SessionState:
    Created
    Running
    Paused
    Stopped
    Terminated

enum TargetType:
    Interpreter
    Smf
    Native
    Remote

# Breakpoint within a session
class SessionBreakpoint:
    id: Int
    file: String
    line: Int
    condition: String

# Debug session
class DebugSession:
    id: String
    program: String
    target_type: String
    state: String
    breakpoints: [SessionBreakpoint]
    next_bp_id: Int

# Session manager - holds all debug sessions
class SessionManager:
    sessions: [DebugSession]
    next_session_id: Int

    static fn empty() -> SessionManager:
        SessionManager(sessions: [], next_session_id: 1)

    me create_session(program: String, target_type: String) -> DebugSession:
        val sid = "session_" + self.next_session_id.to_string()
        self.next_session_id = self.next_session_id + 1
        val session = DebugSession(
            id: sid,
            program: program,
            target_type: target_type,
            state: "created",
            breakpoints: [],
            next_bp_id: 1
        )
        self.sessions = self.sessions + [session]
        session

    fn find_session(session_id: String) -> Int:
        # Returns index or -1 if not found
        var idx = 0
        for s in self.sessions:
            if s.id == session_id:
                return idx
            idx = idx + 1
        return -1

    me remove_session(session_id: String) -> Bool:
        var new_sessions = []
        var found = false
        for s in self.sessions:
            if s.id == session_id:
                found = true
            else:
                new_sessions = new_sessions + [s]
        self.sessions = new_sessions
        found

    fn list_sessions() -> [DebugSession]:
        self.sessions

    me add_breakpoint(session_id: String, file: String, line: Int, condition: String) -> String:
        val idx = self.find_session(session_id)
        if idx < 0:
            return ""
        var session = self.sessions[idx]
        val bp_id = session.next_bp_id
        session.next_bp_id = session.next_bp_id + 1
        val bp = SessionBreakpoint(id: bp_id, file: file, line: line, condition: condition)
        session.breakpoints = session.breakpoints + [bp]
        self.sessions[idx] = session
        bp_id.to_string()

    me remove_breakpoint(session_id: String, bp_id_str: String) -> Bool:
        val idx = self.find_session(session_id)
        if idx < 0:
            return false
        var session = self.sessions[idx]
        val bp_id_result = parse_int(bp_id_str)
        var bp_id = -1
        match bp_id_result:
            Ok(v): bp_id = v
            Err(_): return false
        var new_bps = []
        var found = false
        for bp in session.breakpoints:
            if bp.id == bp_id:
                found = true
            else:
                new_bps = new_bps + [bp]
        session.breakpoints = new_bps
        self.sessions[idx] = session
        found

    me set_state(session_id: String, new_state: String) -> Bool:
        val idx = self.find_session(session_id)
        if idx < 0:
            return false
        var session = self.sessions[idx]
        session.state = new_state
        self.sessions[idx] = session
        true

# --- Tool Schema Functions ---

fn schema_debug_create_session() -> String:
    # properties: program (string, required), target_type (string, optional)
    val p1 = jo2(jp("type", js("string")), jp("description", js("Path to the Simple program to debug")))
    val p2 = jo2(jp("type", js("string")), jp("description", js("Target type: interpreter, smf, native, remote")))
    var props = LB()
    props = props + jp("program", p1)
    props = props + ","
    props = props + jp("target_type", p2)
    props = props + RB()
    val req = "[" + js("program") + "]"
    make_tool_schema_multi("debug_create_session", "Create a new debug session for a Simple program", props, req, false, false, false)

fn schema_debug_list_sessions() -> String:
    val props = jo1("")
    make_tool_schema_multi("debug_list_sessions", "List all active debug sessions", props, "[]", true, false, true)

fn schema_debug_close_session() -> String:
    val p1 = jo2(jp("type", js("string")), jp("description", js("ID of the debug session to close")))
    val props = jo1(jp("session_id", p1))
    val req = "[" + js("session_id") + "]"
    make_tool_schema_multi("debug_close_session", "Close and clean up a debug session", props, req, false, true, true)

fn schema_debug_set_breakpoint() -> String:
    val p1 = jo2(jp("type", js("string")), jp("description", js("Debug session ID")))
    val p2 = jo2(jp("type", js("string")), jp("description", js("Source file path")))
    val p3 = jo2(jp("type", js("string")), jp("description", js("Line number")))
    val p4 = jo2(jp("type", js("string")), jp("description", js("Optional condition expression")))
    var props = LB()
    props = props + jp("session_id", p1)
    props = props + ","
    props = props + jp("file", p2)
    props = props + ","
    props = props + jp("line", p3)
    props = props + ","
    props = props + jp("condition", p4)
    props = props + RB()
    val req = "[" + js("session_id") + "," + js("file") + "," + js("line") + "]"
    make_tool_schema_multi("debug_set_breakpoint", "Set a breakpoint in a debug session", props, req, false, false, true)

fn schema_debug_remove_breakpoint() -> String:
    val p1 = jo2(jp("type", js("string")), jp("description", js("Debug session ID")))
    val p2 = jo2(jp("type", js("string")), jp("description", js("Breakpoint ID to remove")))
    var props = LB()
    props = props + jp("session_id", p1)
    props = props + ","
    props = props + jp("breakpoint_id", p2)
    props = props + RB()
    val req = "[" + js("session_id") + "," + js("breakpoint_id") + "]"
    make_tool_schema_multi("debug_remove_breakpoint", "Remove a breakpoint from a debug session", props, req, false, true, true)

fn schema_debug_continue() -> String:
    val p1 = jo2(jp("type", js("string")), jp("description", js("Debug session ID")))
    val props = jo1(jp("session_id", p1))
    val req = "[" + js("session_id") + "]"
    make_tool_schema_multi("debug_continue", "Continue execution of a paused debug session", props, req, false, false, false)

fn schema_debug_step() -> String:
    val p1 = jo2(jp("type", js("string")), jp("description", js("Debug session ID")))
    val p2 = jo2(jp("type", js("string")), jp("description", js("Step mode: over, in, out")))
    var props = LB()
    props = props + jp("session_id", p1)
    props = props + ","
    props = props + jp("mode", p2)
    props = props + RB()
    val req = "[" + js("session_id") + "," + js("mode") + "]"
    make_tool_schema_multi("debug_step", "Step execution in a debug session", props, req, false, false, false)

fn schema_debug_get_variables() -> String:
    val p1 = jo2(jp("type", js("string")), jp("description", js("Debug session ID")))
    val props = jo1(jp("session_id", p1))
    val req = "[" + js("session_id") + "]"
    make_tool_schema_multi("debug_get_variables", "Get variables in the current scope of a debug session", props, req, true, false, true)

fn schema_debug_stack_trace() -> String:
    val p1 = jo2(jp("type", js("string")), jp("description", js("Debug session ID")))
    val props = jo1(jp("session_id", p1))
    val req = "[" + js("session_id") + "]"
    make_tool_schema_multi("debug_stack_trace", "Get the call stack of a debug session", props, req, true, false, true)

fn schema_debug_evaluate() -> String:
    val p1 = jo2(jp("type", js("string")), jp("description", js("Debug session ID")))
    val p2 = jo2(jp("type", js("string")), jp("description", js("Expression to evaluate")))
    var props = LB()
    props = props + jp("session_id", p1)
    props = props + ","
    props = props + jp("expression", p2)
    props = props + RB()
    val req = "[" + js("session_id") + "," + js("expression") + "]"
    make_tool_schema_multi("debug_evaluate", "Evaluate an expression in the context of a debug session", props, req, true, false, true)

# --- Parsing Helpers ---

# Parse "name = value : type" into JSON object
# Returns: {"name":"x","value":"42","type":"Int"}
fn parse_var_entry(raw: String) -> String:
    val parts = raw.split(" = ")
    if parts.len() < 2:
        # No " = " found, return raw as name with unknown type
        var obj = LB()
        obj = obj + jp("name", js(escape_json(raw)))
        obj = obj + ","
        obj = obj + jp("value", js(""))
        obj = obj + ","
        obj = obj + jp("type", js("unknown"))
        obj = obj + RB()
        return obj
    val var_name = parts[0]
    val rest = parts[1]
    val type_parts = rest.split(" : ")
    val var_value = type_parts[0]
    var var_type = "unknown"
    if type_parts.len() >= 2:
        var_type = type_parts[1]
    var obj = LB()
    obj = obj + jp("name", js(escape_json(var_name)))
    obj = obj + ","
    obj = obj + jp("value", js(escape_json(var_value)))
    obj = obj + ","
    obj = obj + jp("type", js(escape_json(var_type)))
    obj = obj + RB()
    obj

# Parse stack frame string into JSON object
# Returns: {"id":N,"name":"raw","source":"unknown","line":0}
fn parse_stack_frame(idx: Int, raw: String) -> String:
    var obj = LB()
    obj = obj + jp("id", idx.to_string())
    obj = obj + ","
    obj = obj + jp("name", js(escape_json(raw)))
    obj = obj + ","
    obj = obj + jp("source", js("unknown"))
    obj = obj + ","
    obj = obj + jp("line", "0")
    obj = obj + RB()
    obj

# Map step mode string to integer: over=1, in=2, out=3
fn step_mode_to_int(mode: String) -> Int:
    if mode == "over":
        return 1
    if mode == "in":
        return 2
    if mode == "out":
        return 3
    return 0

# --- Expression Evaluator ---
# Pure Simple expression evaluator for interpreter mode.
# Tokenizes + recursive descent parses expressions using debug state variables.

class EvalResult:
    value: String
    new_pos: Int

fn eval_is_digit(ch) -> Bool:
    ch >= '0' and ch <= '9'

fn eval_is_alpha(ch) -> Bool:
    val code = ch as int
    val is_lower = code >= 97 and code <= 122
    if is_lower: return true
    val is_upper = code >= 65 and code <= 90
    if is_upper: return true
    if ch == '_': return true
    false

fn eval_is_alnum(ch) -> Bool:
    if eval_is_digit(ch): return true
    eval_is_alpha(ch)

fn eval_tokenize(expr: String) -> [String]:
    var tokens = []
    val length = expr.len()
    var pos = 0
    for _i in range(0, length + 1):
        if pos >= length:
            return tokens
        val ch = expr[pos]
        if ch == ' ' or ch == '\t':
            pos = pos + 1
        elif eval_is_digit(ch):
            var num_str = ch.to_string()
            var np = pos + 1
            for _j in range(0, length):
                if np >= length: break
                val nc = expr[np]
                if eval_is_digit(nc) or nc == '.':
                    num_str = num_str + nc.to_string()
                    np = np + 1
                else:
                    break
            tokens = tokens + [num_str]
            pos = np
        elif eval_is_alpha(ch):
            var id_str = ch.to_string()
            var np = pos + 1
            for _j in range(0, length):
                if np >= length: break
                val nc = expr[np]
                if eval_is_alnum(nc):
                    id_str = id_str + nc.to_string()
                    np = np + 1
                else:
                    break
            tokens = tokens + [id_str]
            pos = np
        elif ch == '"' or ch == '\'':
            val quote = ch
            var str_val = ""
            var np = pos + 1
            for _j in range(0, length):
                if np >= length: break
                val sc = expr[np]
                if sc == quote:
                    np = np + 1
                    break
                str_val = str_val + sc.to_string()
                np = np + 1
            tokens = tokens + ["Q:" + str_val]
            pos = np
        elif ch == '=':
            if pos + 1 < length:
                if expr[pos + 1] == '=':
                    tokens = tokens + ["=="]
                    pos = pos + 2
                else:
                    tokens = tokens + ["="]
                    pos = pos + 1
            else:
                tokens = tokens + ["="]
                pos = pos + 1
        elif ch == '!':
            if pos + 1 < length:
                if expr[pos + 1] == '=':
                    tokens = tokens + ["!="]
                    pos = pos + 2
                else:
                    tokens = tokens + ["!"]
                    pos = pos + 1
            else:
                tokens = tokens + ["!"]
                pos = pos + 1
        elif ch == '<':
            if pos + 1 < length:
                if expr[pos + 1] == '=':
                    tokens = tokens + ["<="]
                    pos = pos + 2
                else:
                    tokens = tokens + ["<"]
                    pos = pos + 1
            else:
                tokens = tokens + ["<"]
                pos = pos + 1
        elif ch == '>':
            if pos + 1 < length:
                if expr[pos + 1] == '=':
                    tokens = tokens + [">="]
                    pos = pos + 2
                else:
                    tokens = tokens + [">"]
                    pos = pos + 1
            else:
                tokens = tokens + [">"]
                pos = pos + 1
        elif ch == '+' or ch == '-':
            tokens = tokens + [ch.to_string()]
            pos = pos + 1
        elif ch == '*' or ch == '/':
            tokens = tokens + [ch.to_string()]
            pos = pos + 1
        elif ch == '%' or ch == '(' or ch == ')' or ch == ',':
            tokens = tokens + [ch.to_string()]
            pos = pos + 1
        else:
            pos = pos + 1
    tokens

fn eval_peek(tokens: [String], pos: Int) -> String:
    if pos >= tokens.len():
        return ""
    tokens[pos]

fn eval_lookup(var_name: String, vars_list: [String]) -> String:
    for entry in vars_list:
        val parts = entry.split(" = ")
        if parts.len() >= 2:
            if parts[0].trim() == var_name:
                val rest = parts[1]
                val type_parts = rest.split(" : ")
                val var_value = type_parts[0].trim()
                var var_type = "unknown"
                if type_parts.len() >= 2:
                    var_type = type_parts[1].trim()
                if var_type == "Int" or var_type == "i64":
                    return "i:" + var_value
                elif var_type == "Float" or var_type == "f64":
                    return "f:" + var_value
                elif var_type == "Bool":
                    return "b:" + var_value
                else:
                    return "s:" + var_value
    "e:undefined variable '" + var_name + "'"

fn eval_get_type(typed_val: String) -> String:
    if typed_val.starts_with("i:"): return "int"
    if typed_val.starts_with("f:"): return "float"
    if typed_val.starts_with("s:"): return "string"
    if typed_val.starts_with("b:"): return "bool"
    if typed_val.starts_with("n:"): return "nil"
    "error"

fn eval_get_value(typed_val: String) -> String:
    if typed_val.len() < 2: return typed_val
    typed_val.substring(2)

fn eval_arith(left: String, op: String, right: String) -> String:
    val l_val = eval_get_value(left)
    val r_val = eval_get_value(right)
    val l_int = left.starts_with("i:")
    val r_int = right.starts_with("i:")
    if l_int and r_int:
        val lv = l_val.to_int()
        val rv = r_val.to_int()
        var result = 0
        if op == "+":
            result = lv + rv
        elif op == "-":
            result = lv - rv
        elif op == "*":
            result = lv * rv
        elif op == "/":
            if rv == 0:
                return "e:division by zero"
            result = lv / rv
        elif op == "%":
            if rv == 0:
                return "e:modulo by zero"
            result = lv % rv
        return "i:" + result.to_string()
    val l_str = left.starts_with("s:")
    val r_str = right.starts_with("s:")
    if l_str and r_str and op == "+":
        return "s:" + l_val + r_val
    "e:cannot apply '" + op + "' to " + eval_get_type(left) + " and " + eval_get_type(right)

fn eval_compare(left: String, op: String, right: String) -> String:
    val l_val = eval_get_value(left)
    val r_val = eval_get_value(right)
    val l_int = left.starts_with("i:")
    val r_int = right.starts_with("i:")
    if l_int and r_int:
        val lv = l_val.to_int()
        val rv = r_val.to_int()
        var cmp = false
        if op == "==":
            cmp = lv == rv
        elif op == "!=":
            cmp = lv != rv
        elif op == "<":
            cmp = lv < rv
        elif op == ">":
            cmp = lv > rv
        elif op == "<=":
            cmp = lv <= rv
        elif op == ">=":
            cmp = lv >= rv
        if cmp: return "b:true"
        return "b:false"
    if op == "==":
        if l_val == r_val: return "b:true"
        return "b:false"
    if op == "!=":
        if l_val != r_val: return "b:true"
        return "b:false"
    "e:cannot compare " + eval_get_type(left) + " and " + eval_get_type(right)

fn eval_primary(tokens: [String], pos: Int, vars_list: [String]) -> EvalResult:
    val tok = eval_peek(tokens, pos)
    if tok == "":
        return EvalResult(value: "e:unexpected end of expression", new_pos: pos)
    if tok == "(":
        val inner = eval_expr(tokens, pos + 1, vars_list)
        if inner.value.starts_with("e:"): return inner
        var np = inner.new_pos
        if eval_peek(tokens, np) == ")": np = np + 1
        return EvalResult(value: inner.value, new_pos: np)
    if tok == "-":
        val operand = eval_primary(tokens, pos + 1, vars_list)
        if operand.value.starts_with("e:"): return operand
        if operand.value.starts_with("i:"):
            val nv = -(eval_get_value(operand.value).to_int())
            return EvalResult(value: "i:" + nv.to_string(), new_pos: operand.new_pos)
        return EvalResult(value: "e:cannot negate " + eval_get_type(operand.value), new_pos: operand.new_pos)
    if tok == "not":
        val operand = eval_expr(tokens, pos + 1, vars_list)
        if operand.value.starts_with("e:"): return operand
        if operand.value == "b:true":
            return EvalResult(value: "b:false", new_pos: operand.new_pos)
        if operand.value == "b:false":
            return EvalResult(value: "b:true", new_pos: operand.new_pos)
        return EvalResult(value: "e:cannot apply 'not' to " + eval_get_type(operand.value), new_pos: operand.new_pos)
    # Number literal
    val first_ch = tok[0]
    val is_num = first_ch >= '0' and first_ch <= '9'
    if is_num:
        if tok.contains("."):
            return EvalResult(value: "f:" + tok, new_pos: pos + 1)
        return EvalResult(value: "i:" + tok, new_pos: pos + 1)
    # String literal (tokenized as Q:content)
    if tok.starts_with("Q:"):
        return EvalResult(value: "s:" + tok.substring(2), new_pos: pos + 1)
    # Keywords
    if tok == "true": return EvalResult(value: "b:true", new_pos: pos + 1)
    if tok == "false": return EvalResult(value: "b:false", new_pos: pos + 1)
    if tok == "nil": return EvalResult(value: "n:", new_pos: pos + 1)
    # Built-in: type(expr)
    if tok == "type":
        if eval_peek(tokens, pos + 1) == "(":
            val arg = eval_expr(tokens, pos + 2, vars_list)
            var np = arg.new_pos
            if eval_peek(tokens, np) == ")": np = np + 1
            return EvalResult(value: "s:" + eval_get_type(arg.value), new_pos: np)
    # Built-in: len(expr)
    if tok == "len":
        if eval_peek(tokens, pos + 1) == "(":
            val arg = eval_expr(tokens, pos + 2, vars_list)
            var np = arg.new_pos
            if eval_peek(tokens, np) == ")": np = np + 1
            if arg.value.starts_with("s:"):
                val sv = eval_get_value(arg.value)
                return EvalResult(value: "i:" + sv.len().to_string(), new_pos: np)
            return EvalResult(value: "e:len() requires string argument", new_pos: np)
    # Built-in: str(expr)
    if tok == "str":
        if eval_peek(tokens, pos + 1) == "(":
            val arg = eval_expr(tokens, pos + 2, vars_list)
            var np = arg.new_pos
            if eval_peek(tokens, np) == ")": np = np + 1
            return EvalResult(value: "s:" + eval_get_value(arg.value), new_pos: np)
    # Variable lookup
    EvalResult(value: eval_lookup(tok, vars_list), new_pos: pos + 1)

fn eval_mul(tokens: [String], pos: Int, vars_list: [String]) -> EvalResult:
    var left = eval_primary(tokens, pos, vars_list)
    if left.value.starts_with("e:"): return left
    for _i in range(0, 50):
        val op = eval_peek(tokens, left.new_pos)
        if op == "*" or op == "/" or op == "%":
            val right = eval_primary(tokens, left.new_pos + 1, vars_list)
            if right.value.starts_with("e:"): return right
            val rv = eval_arith(left.value, op, right.value)
            left = EvalResult(value: rv, new_pos: right.new_pos)
            if left.value.starts_with("e:"): return left
        else:
            return left
    left

fn eval_add(tokens: [String], pos: Int, vars_list: [String]) -> EvalResult:
    var left = eval_mul(tokens, pos, vars_list)
    if left.value.starts_with("e:"): return left
    for _i in range(0, 50):
        val op = eval_peek(tokens, left.new_pos)
        if op == "+" or op == "-":
            val right = eval_mul(tokens, left.new_pos + 1, vars_list)
            if right.value.starts_with("e:"): return right
            val rv = eval_arith(left.value, op, right.value)
            left = EvalResult(value: rv, new_pos: right.new_pos)
            if left.value.starts_with("e:"): return left
        else:
            return left
    left

fn eval_expr(tokens: [String], pos: Int, vars_list: [String]) -> EvalResult:
    var left = eval_add(tokens, pos, vars_list)
    if left.value.starts_with("e:"): return left
    val op = eval_peek(tokens, left.new_pos)
    if op == "==" or op == "!=" or op == "<" or op == ">":
        val right = eval_add(tokens, left.new_pos + 1, vars_list)
        if right.value.starts_with("e:"): return right
        return EvalResult(value: eval_compare(left.value, op, right.value), new_pos: right.new_pos)
    if op == "<=" or op == ">=":
        val right = eval_add(tokens, left.new_pos + 1, vars_list)
        if right.value.starts_with("e:"): return right
        return EvalResult(value: eval_compare(left.value, op, right.value), new_pos: right.new_pos)
    if op == "and":
        val right = eval_expr(tokens, left.new_pos + 1, vars_list)
        if right.value.starts_with("e:"): return right
        val lb = left.value == "b:true"
        val rb = right.value == "b:true"
        val both = lb and rb
        var bv = "b:false"
        if both:
            bv = "b:true"
        return EvalResult(value: bv, new_pos: right.new_pos)
    if op == "or":
        val right = eval_expr(tokens, left.new_pos + 1, vars_list)
        if right.value.starts_with("e:"): return right
        val lb = left.value == "b:true"
        val rb = right.value == "b:true"
        val either = lb or rb
        var bv = "b:false"
        if either:
            bv = "b:true"
        return EvalResult(value: bv, new_pos: right.new_pos)
    left

fn eval_expression(expr: String, vars_list: [String]) -> String:
    val trimmed = expr.trim()
    if trimmed == "": return "e:empty expression"
    val tokens = eval_tokenize(trimmed)
    if tokens.len() == 0: return "e:empty expression"
    val result = eval_expr(tokens, 0, vars_list)
    result.value

# --- Handler Functions ---

fn handle_debug_create_session(id: String, body: String, mgr: SessionManager) -> String:
    val program = extract_nested_string(body, "arguments", "program")
    if program == "":
        return make_error_response(id, -32602, "Missing required parameter: program")
    var target_type = extract_nested_string(body, "arguments", "target_type")
    if target_type == "":
        target_type = "interpreter"
    val session = mgr.create_session(program, target_type)
    # Activate debug mode in backend
    rt_debug_set_active(true)
    var result_json = LB()
    result_json = result_json + jp("session_id", js(session.id))
    result_json = result_json + ","
    result_json = result_json + jp("program", js(session.program))
    result_json = result_json + ","
    result_json = result_json + jp("target_type", js(session.target_type))
    result_json = result_json + ","
    result_json = result_json + jp("state", js(session.state))
    result_json = result_json + RB()
    make_tool_result(id, result_json)

fn handle_debug_list_sessions(id: String, mgr: SessionManager) -> String:
    val sessions = mgr.list_sessions()
    var arr = "["
    var first = true
    for s in sessions:
        if not first:
            arr = arr + ","
        first = false
        var obj = LB()
        obj = obj + jp("session_id", js(s.id))
        obj = obj + ","
        obj = obj + jp("program", js(s.program))
        obj = obj + ","
        obj = obj + jp("target_type", js(s.target_type))
        obj = obj + ","
        obj = obj + jp("state", js(s.state))
        obj = obj + RB()
        arr = arr + obj
    arr = arr + "]"
    make_tool_result(id, arr)

fn handle_debug_close_session(id: String, body: String, mgr: SessionManager) -> String:
    val session_id = extract_nested_string(body, "arguments", "session_id")
    if session_id == "":
        return make_error_response(id, -32602, "Missing required parameter: session_id")
    val removed = mgr.remove_session(session_id)
    if not removed:
        return make_error_response(id, -32602, "Session not found: " + session_id)
    # Deactivate debug mode if no sessions remain
    val remaining = mgr.list_sessions()
    if remaining.len() == 0:
        rt_debug_set_active(false)
    var result_json = LB()
    result_json = result_json + jp("closed", js(session_id))
    result_json = result_json + ","
    result_json = result_json + jp("status", js("ok"))
    result_json = result_json + RB()
    make_tool_result(id, result_json)

fn handle_debug_set_breakpoint(id: String, body: String, mgr: SessionManager) -> String:
    val session_id = extract_nested_string(body, "arguments", "session_id")
    if session_id == "":
        return make_error_response(id, -32602, "Missing required parameter: session_id")
    val file = extract_nested_string(body, "arguments", "file")
    if file == "":
        return make_error_response(id, -32602, "Missing required parameter: file")
    val line_str = extract_nested_string(body, "arguments", "line")
    if line_str == "":
        return make_error_response(id, -32602, "Missing required parameter: line")
    val line_result = parse_int(line_str)
    var line = 0
    match line_result:
        Ok(v): line = v
        Err(e): return make_error_response(id, -32602, "Invalid line number: " + line_str)
    val condition = extract_nested_string(body, "arguments", "condition")
    val bp_id_str = mgr.add_breakpoint(session_id, file, line, condition)
    if bp_id_str == "":
        return make_error_response(id, -32602, "Session not found: " + session_id)
    # Register breakpoint in debug backend
    rt_debug_add_breakpoint_at(file, line)
    var result_json = LB()
    result_json = result_json + jp("breakpoint_id", bp_id_str)
    result_json = result_json + ","
    result_json = result_json + jp("session_id", js(session_id))
    result_json = result_json + ","
    result_json = result_json + jp("file", js(file))
    result_json = result_json + ","
    result_json = result_json + jp("line", line.to_string())
    result_json = result_json + ","
    result_json = result_json + jp("verified", "true")
    result_json = result_json + RB()
    make_tool_result(id, result_json)

fn handle_debug_remove_breakpoint(id: String, body: String, mgr: SessionManager) -> String:
    val session_id = extract_nested_string(body, "arguments", "session_id")
    if session_id == "":
        return make_error_response(id, -32602, "Missing required parameter: session_id")
    val bp_id = extract_nested_string(body, "arguments", "breakpoint_id")
    if bp_id == "":
        return make_error_response(id, -32602, "Missing required parameter: breakpoint_id")
    # Look up breakpoint file/line before removing from session
    val sess_idx = mgr.find_session(session_id)
    if sess_idx >= 0:
        val session = mgr.sessions[sess_idx]
        val bp_id_result = parse_int(bp_id)
        var bp_id_int = -1
        match bp_id_result:
            Ok(v): bp_id_int = v
            Err(_): pass
        for bp in session.breakpoints:
            if bp.id == bp_id_int:
                rt_debug_remove_breakpoint_at(bp.file, bp.line)
    val removed = mgr.remove_breakpoint(session_id, bp_id)
    if not removed:
        return make_error_response(id, -32602, "Breakpoint not found: " + bp_id)
    var result_json = LB()
    result_json = result_json + jp("removed", js(bp_id))
    result_json = result_json + ","
    result_json = result_json + jp("status", js("ok"))
    result_json = result_json + RB()
    make_tool_result(id, result_json)

fn handle_debug_continue(id: String, body: String, mgr: SessionManager) -> String:
    val session_id = extract_nested_string(body, "arguments", "session_id")
    if session_id == "":
        return make_error_response(id, -32602, "Missing required parameter: session_id")
    val found = mgr.set_state(session_id, "running")
    if not found:
        return make_error_response(id, -32602, "Session not found: " + session_id)
    # Tell backend to continue execution
    rt_debug_continue_exec()
    var result_json = LB()
    result_json = result_json + jp("session_id", js(session_id))
    result_json = result_json + ","
    result_json = result_json + jp("state", js("running"))
    result_json = result_json + RB()
    make_tool_result(id, result_json)

fn handle_debug_step(id: String, body: String, mgr: SessionManager) -> String:
    val session_id = extract_nested_string(body, "arguments", "session_id")
    if session_id == "":
        return make_error_response(id, -32602, "Missing required parameter: session_id")
    val mode = extract_nested_string(body, "arguments", "mode")
    if mode == "":
        return make_error_response(id, -32602, "Missing required parameter: mode")
    val step_int = step_mode_to_int(mode)
    if step_int == 0:
        return make_error_response(id, -32602, "Invalid step mode: " + mode + ". Must be over, in, or out")
    val found = mgr.set_state(session_id, "paused")
    if not found:
        return make_error_response(id, -32602, "Session not found: " + session_id)
    # Send step command to backend
    rt_debug_set_step_mode_val(step_int)
    var result_json = LB()
    result_json = result_json + jp("session_id", js(session_id))
    result_json = result_json + ","
    result_json = result_json + jp("mode", js(mode))
    result_json = result_json + ","
    result_json = result_json + jp("state", js("paused"))
    result_json = result_json + RB()
    make_tool_result(id, result_json)

fn handle_debug_get_variables(id: String, body: String, mgr: SessionManager) -> String:
    val session_id = extract_nested_string(body, "arguments", "session_id")
    if session_id == "":
        return make_error_response(id, -32602, "Missing required parameter: session_id")
    val idx = mgr.find_session(session_id)
    if idx < 0:
        return make_error_response(id, -32602, "Session not found: " + session_id)
    # Query backend for local variables
    val raw_vars = rt_debug_local_vars()
    var vars_arr = "["
    var first = true
    for raw in raw_vars:
        if not first:
            vars_arr = vars_arr + ","
        first = false
        vars_arr = vars_arr + parse_var_entry(raw)
    vars_arr = vars_arr + "]"
    var result_json = LB()
    result_json = result_json + jp("session_id", js(session_id))
    result_json = result_json + ","
    result_json = result_json + jp("variables", vars_arr)
    result_json = result_json + RB()
    make_tool_result(id, result_json)

fn handle_debug_stack_trace(id: String, body: String, mgr: SessionManager) -> String:
    val session_id = extract_nested_string(body, "arguments", "session_id")
    if session_id == "":
        return make_error_response(id, -32602, "Missing required parameter: session_id")
    val idx = mgr.find_session(session_id)
    if idx < 0:
        return make_error_response(id, -32602, "Session not found: " + session_id)
    val session = mgr.sessions[idx]
    # Query backend for stack trace
    val raw_frames = rt_debug_stack_trace_lines()
    var frames_arr = "["
    if raw_frames.len() > 0:
        var first = true
        var frame_idx = 0
        for raw in raw_frames:
            if not first:
                frames_arr = frames_arr + ","
            first = false
            frames_arr = frames_arr + parse_stack_frame(frame_idx, raw)
            frame_idx = frame_idx + 1
    else:
        # Fallback: use current location from backend
        val cur_file = rt_debug_get_current_file()
        val cur_line = rt_debug_get_current_line()
        var source = session.program
        if cur_file != "":
            source = cur_file
        var line_num = 1
        if cur_line > 0:
            line_num = cur_line
        var frame = LB()
        frame = frame + jp("id", "0")
        frame = frame + ","
        frame = frame + jp("name", js("main"))
        frame = frame + ","
        frame = frame + jp("source", js(escape_json(source)))
        frame = frame + ","
        frame = frame + jp("line", line_num.to_string())
        frame = frame + RB()
        frames_arr = frames_arr + frame
    frames_arr = frames_arr + "]"
    # Count frames
    var total = raw_frames.len()
    if total == 0:
        total = 1
    var result_json = LB()
    result_json = result_json + jp("session_id", js(session_id))
    result_json = result_json + ","
    result_json = result_json + jp("frames", frames_arr)
    result_json = result_json + ","
    result_json = result_json + jp("total_frames", total.to_string())
    result_json = result_json + RB()
    make_tool_result(id, result_json)

fn handle_debug_evaluate(id: String, body: String, mgr: SessionManager) -> String:
    val session_id = extract_nested_string(body, "arguments", "session_id")
    if session_id == "":
        return make_error_response(id, -32602, "Missing required parameter: session_id")
    val expression = extract_nested_string(body, "arguments", "expression")
    if expression == "":
        return make_error_response(id, -32602, "Missing required parameter: expression")
    val idx = mgr.find_session(session_id)
    if idx < 0:
        return make_error_response(id, -32602, "Session not found: " + session_id)
    val frame_str = extract_nested_string(body, "arguments", "frame_index")
    var frame_idx = 0
    if frame_str != "":
        val fr = parse_int(frame_str)
        match fr:
            Ok(v): frame_idx = v
            Err(_): pass
    # Evaluate using Pure Simple evaluator (works in interpreter mode)
    val vars_list = rt_debug_local_vars()
    val eval_typed = eval_expression(expression, vars_list)
    val eval_type = eval_get_type(eval_typed)
    val display_result = eval_get_value(eval_typed)
    var result_json = LB()
    result_json = result_json + jp("session_id", js(session_id))
    result_json = result_json + ","
    result_json = result_json + jp("expression", js(escape_json(expression)))
    result_json = result_json + ","
    result_json = result_json + jp("result", js(escape_json(display_result)))
    result_json = result_json + ","
    result_json = result_json + jp("type", js(eval_type))
    result_json = result_json + RB()
    make_tool_result(id, result_json)

# --- New Tool Schemas (Phase 1.5) ---

fn schema_debug_set_function_breakpoint() -> String:
    val p1 = jo2(jp("type", js("string")), jp("description", js("Debug session ID")))
    val p2 = jo2(jp("type", js("string")), jp("description", js("Function name to break on")))
    val p3 = jo2(jp("type", js("string")), jp("description", js("Optional condition expression")))
    var props = LB()
    props = props + jp("session_id", p1)
    props = props + ","
    props = props + jp("function_name", p2)
    props = props + ","
    props = props + jp("condition", p3)
    props = props + RB()
    val req = "[" + js("session_id") + "," + js("function_name") + "]"
    make_tool_schema_multi("debug_set_function_breakpoint", "Set a breakpoint on a function name", props, req, false, false, true)

fn schema_debug_enable_breakpoint() -> String:
    val p1 = jo2(jp("type", js("string")), jp("description", js("Debug session ID")))
    val p2 = jo2(jp("type", js("string")), jp("description", js("Breakpoint ID")))
    val p3 = jo2(jp("type", js("string")), jp("description", js("true to enable, false to disable")))
    var props = LB()
    props = props + jp("session_id", p1)
    props = props + ","
    props = props + jp("breakpoint_id", p2)
    props = props + ","
    props = props + jp("enabled", p3)
    props = props + RB()
    val req = "[" + js("session_id") + "," + js("breakpoint_id") + "," + js("enabled") + "]"
    make_tool_schema_multi("debug_enable_breakpoint", "Enable or disable a breakpoint", props, req, false, false, true)

fn schema_debug_get_source() -> String:
    val p1 = jo2(jp("type", js("string")), jp("description", js("Debug session ID")))
    val p2 = jo2(jp("type", js("string")), jp("description", js("Source file path")))
    val p3 = jo2(jp("type", js("string")), jp("description", js("Start line number")))
    val p4 = jo2(jp("type", js("string")), jp("description", js("Number of lines to read")))
    var props = LB()
    props = props + jp("session_id", p1)
    props = props + ","
    props = props + jp("file", p2)
    props = props + ","
    props = props + jp("start_line", p3)
    props = props + ","
    props = props + jp("count", p4)
    props = props + RB()
    val req = "[" + js("session_id") + "," + js("file") + "]"
    make_tool_schema_multi("debug_get_source", "Read source lines from a file", props, req, true, false, true)

fn schema_debug_watch() -> String:
    val p1 = jo2(jp("type", js("string")), jp("description", js("Debug session ID")))
    val p2 = jo2(jp("type", js("string")), jp("description", js("Action: add, remove, list")))
    val p3 = jo2(jp("type", js("string")), jp("description", js("Watch expression (for add/remove)")))
    var props = LB()
    props = props + jp("session_id", p1)
    props = props + ","
    props = props + jp("action", p2)
    props = props + ","
    props = props + jp("expression", p3)
    props = props + RB()
    val req = "[" + js("session_id") + "," + js("action") + "]"
    make_tool_schema_multi("debug_watch", "Manage watch expressions (add/remove/list)", props, req, false, false, true)

fn schema_debug_set_variable() -> String:
    val p1 = jo2(jp("type", js("string")), jp("description", js("Debug session ID")))
    val p2 = jo2(jp("type", js("string")), jp("description", js("Variable name")))
    val p3 = jo2(jp("type", js("string")), jp("description", js("New value as string")))
    val p4 = jo2(jp("type", js("string")), jp("description", js("Frame index (-1 for globals)")))
    var props = LB()
    props = props + jp("session_id", p1)
    props = props + ","
    props = props + jp("name", p2)
    props = props + ","
    props = props + jp("value", p3)
    props = props + ","
    props = props + jp("frame_index", p4)
    props = props + RB()
    val req = "[" + js("session_id") + "," + js("name") + "," + js("value") + "]"
    make_tool_schema_multi("debug_set_variable", "Set a variable value in a specific frame", props, req, false, false, false)

fn schema_debug_terminate() -> String:
    val p1 = jo2(jp("type", js("string")), jp("description", js("Debug session ID")))
    val props = jo1(jp("session_id", p1))
    val req = "[" + js("session_id") + "]"
    make_tool_schema_multi("debug_terminate", "Terminate a debug session and stop execution", props, req, false, true, false)

# --- New Handler Functions (Phase 1.5) ---

fn handle_debug_set_function_breakpoint(id: String, body: String, mgr: SessionManager) -> String:
    val session_id = extract_nested_string(body, "arguments", "session_id")
    if session_id == "":
        return make_error_response(id, -32602, "Missing required parameter: session_id")
    val func_name = extract_nested_string(body, "arguments", "function_name")
    if func_name == "":
        return make_error_response(id, -32602, "Missing required parameter: function_name")
    val idx = mgr.find_session(session_id)
    if idx < 0:
        return make_error_response(id, -32602, "Session not found: " + session_id)
    val condition = extract_nested_string(body, "arguments", "condition")
    val bp_id = rt_debug_add_function_breakpoint(func_name, condition)
    var result_json = LB()
    result_json = result_json + jp("breakpoint_id", bp_id.to_string())
    result_json = result_json + "," + jp("session_id", js(session_id))
    result_json = result_json + "," + jp("function_name", js(func_name))
    result_json = result_json + "," + jp("type", js("function"))
    result_json = result_json + "," + jp("verified", "true")
    result_json = result_json + RB()
    make_tool_result(id, result_json)

fn handle_debug_enable_breakpoint(id: String, body: String, mgr: SessionManager) -> String:
    val session_id = extract_nested_string(body, "arguments", "session_id")
    if session_id == "":
        return make_error_response(id, -32602, "Missing required parameter: session_id")
    val bp_id_str = extract_nested_string(body, "arguments", "breakpoint_id")
    if bp_id_str == "":
        return make_error_response(id, -32602, "Missing required parameter: breakpoint_id")
    val enabled_str = extract_nested_string(body, "arguments", "enabled")
    if enabled_str == "":
        return make_error_response(id, -32602, "Missing required parameter: enabled")
    val idx = mgr.find_session(session_id)
    if idx < 0:
        return make_error_response(id, -32602, "Session not found: " + session_id)
    val bp_id_result = parse_int(bp_id_str)
    var bp_id = -1
    match bp_id_result:
        Ok(v): bp_id = v
        Err(_): return make_error_response(id, -32602, "Invalid breakpoint_id: " + bp_id_str)
    var enabled_val = 1
    if enabled_str == "false" or enabled_str == "0":
        enabled_val = 0
    rt_debug_set_breakpoint_enabled(bp_id, enabled_val)
    var result_json = LB()
    result_json = result_json + jp("breakpoint_id", bp_id.to_string())
    result_json = result_json + "," + jp("enabled", enabled_str)
    result_json = result_json + "," + jp("status", js("ok"))
    result_json = result_json + RB()
    make_tool_result(id, result_json)

fn handle_debug_get_source(id: String, body: String, mgr: SessionManager) -> String:
    val session_id = extract_nested_string(body, "arguments", "session_id")
    if session_id == "":
        return make_error_response(id, -32602, "Missing required parameter: session_id")
    val src_file = extract_nested_string(body, "arguments", "file")
    if src_file == "":
        return make_error_response(id, -32602, "Missing required parameter: file")
    val idx = mgr.find_session(session_id)
    if idx < 0:
        return make_error_response(id, -32602, "Session not found: " + session_id)
    val start_str = extract_nested_string(body, "arguments", "start_line")
    var start_line = 1
    if start_str != "":
        val sr = parse_int(start_str)
        match sr:
            Ok(v): start_line = v
            Err(_): pass
    val count_str = extract_nested_string(body, "arguments", "count")
    var line_count = 20
    if count_str != "":
        val cr = parse_int(count_str)
        match cr:
            Ok(v): line_count = v
            Err(_): pass
    val source_text = rt_debug_get_source_lines(src_file, start_line, line_count)
    var result_json = LB()
    result_json = result_json + jp("session_id", js(session_id))
    result_json = result_json + "," + jp("file", js(src_file))
    result_json = result_json + "," + jp("start_line", start_line.to_string())
    result_json = result_json + "," + jp("source", js(escape_json(source_text)))
    result_json = result_json + RB()
    make_tool_result(id, result_json)

fn handle_debug_watch(id: String, body: String, mgr: SessionManager) -> String:
    val session_id = extract_nested_string(body, "arguments", "session_id")
    if session_id == "":
        return make_error_response(id, -32602, "Missing required parameter: session_id")
    val action = extract_nested_string(body, "arguments", "action")
    if action == "":
        return make_error_response(id, -32602, "Missing required parameter: action")
    val idx = mgr.find_session(session_id)
    if idx < 0:
        return make_error_response(id, -32602, "Session not found: " + session_id)
    if action == "add":
        val expr = extract_nested_string(body, "arguments", "expression")
        if expr == "":
            return make_error_response(id, -32602, "Missing expression for add")
        val added = rt_debug_add_watch(expr)
        var result_json = LB()
        result_json = result_json + jp("action", js("add"))
        result_json = result_json + "," + jp("expression", js(escape_json(expr)))
        var ok_str = "true"
        if added == 0:
            ok_str = "false"
        result_json = result_json + "," + jp("success", ok_str)
        result_json = result_json + RB()
        return make_tool_result(id, result_json)
    elif action == "remove":
        val expr = extract_nested_string(body, "arguments", "expression")
        if expr == "":
            return make_error_response(id, -32602, "Missing expression for remove")
        val removed = rt_debug_remove_watch(expr)
        var result_json = LB()
        result_json = result_json + jp("action", js("remove"))
        result_json = result_json + "," + jp("expression", js(escape_json(expr)))
        var ok_str = "true"
        if removed == 0:
            ok_str = "false"
        result_json = result_json + "," + jp("success", ok_str)
        result_json = result_json + RB()
        return make_tool_result(id, result_json)
    elif action == "list":
        val watches = rt_debug_list_watches()
        var result_json = LB()
        result_json = result_json + jp("action", js("list"))
        result_json = result_json + "," + jp("watches", watches)
        result_json = result_json + RB()
        return make_tool_result(id, result_json)
    else:
        return make_error_response(id, -32602, "Invalid action: " + action + ". Must be add, remove, or list")

fn handle_debug_set_variable(id: String, body: String, mgr: SessionManager) -> String:
    val session_id = extract_nested_string(body, "arguments", "session_id")
    if session_id == "":
        return make_error_response(id, -32602, "Missing required parameter: session_id")
    val var_name = extract_nested_string(body, "arguments", "name")
    if var_name == "":
        return make_error_response(id, -32602, "Missing required parameter: name")
    val var_value = extract_nested_string(body, "arguments", "value")
    if var_value == "":
        return make_error_response(id, -32602, "Missing required parameter: value")
    val idx = mgr.find_session(session_id)
    if idx < 0:
        return make_error_response(id, -32602, "Session not found: " + session_id)
    val frame_str = extract_nested_string(body, "arguments", "frame_index")
    var frame_idx = 0
    if frame_str != "":
        val fr = parse_int(frame_str)
        match fr:
            Ok(v): frame_idx = v
            Err(_): pass
    val ok = rt_debug_set_variable(var_name, var_value, frame_idx)
    var result_json = LB()
    result_json = result_json + jp("name", js(escape_json(var_name)))
    result_json = result_json + "," + jp("value", js(escape_json(var_value)))
    result_json = result_json + "," + jp("frame_index", frame_idx.to_string())
    var ok_str = "true"
    if ok == 0:
        ok_str = "false"
    result_json = result_json + "," + jp("success", ok_str)
    result_json = result_json + RB()
    make_tool_result(id, result_json)

fn handle_debug_terminate(id: String, body: String, mgr: SessionManager) -> String:
    val session_id = extract_nested_string(body, "arguments", "session_id")
    if session_id == "":
        return make_error_response(id, -32602, "Missing required parameter: session_id")
    val found = mgr.set_state(session_id, "terminated")
    if not found:
        return make_error_response(id, -32602, "Session not found: " + session_id)
    rt_debug_terminate()
    var result_json = LB()
    result_json = result_json + jp("session_id", js(session_id))
    result_json = result_json + "," + jp("state", js("terminated"))
    result_json = result_json + "," + jp("status", js("ok"))
    result_json = result_json + RB()
    make_tool_result(id, result_json)

# --- Exports ---

export SessionState, TargetType, SessionBreakpoint, DebugSession, SessionManager
export parse_var_entry, parse_stack_frame, step_mode_to_int
export schema_debug_create_session, schema_debug_list_sessions, schema_debug_close_session
export schema_debug_set_breakpoint, schema_debug_remove_breakpoint
export schema_debug_continue, schema_debug_step
export schema_debug_get_variables, schema_debug_stack_trace, schema_debug_evaluate
export schema_debug_set_function_breakpoint, schema_debug_enable_breakpoint
export schema_debug_get_source, schema_debug_watch
export schema_debug_set_variable, schema_debug_terminate
export handle_debug_create_session, handle_debug_list_sessions, handle_debug_close_session
export handle_debug_set_breakpoint, handle_debug_remove_breakpoint
export handle_debug_continue, handle_debug_step
export handle_debug_get_variables, handle_debug_stack_trace, handle_debug_evaluate
export handle_debug_set_function_breakpoint, handle_debug_enable_breakpoint
export handle_debug_get_source, handle_debug_watch
export handle_debug_set_variable, handle_debug_terminate
