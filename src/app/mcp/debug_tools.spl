# MCP Debug Tools - Bridges DAP debug infrastructure to MCP server
#
# Provides 16 debug tools for AI agents:
# - Session lifecycle: create, list, close
# - Breakpoints: set, remove, function breakpoint, enable/disable
# - Execution: continue, step, terminate
# - Inspection: variables, stack trace, evaluate, source
# - Watches: add, remove, list
# - Variable modification: set variable

use app.mcp.helpers.{LB, RB, Q, jp, js, jo1, jo2, jo3, make_tool_schema_multi, make_tool_result, make_error_response, extract_nested_string, escape_json, parse_int}
use app.io.mod (rt_debug_set_active, rt_debug_add_breakpoint_at, rt_debug_remove_breakpoint_at, rt_debug_continue_exec, rt_debug_pause_exec, rt_debug_set_step_mode_val, rt_debug_stack_trace_lines, rt_debug_local_vars, rt_debug_get_current_file, rt_debug_get_current_line, rt_debug_add_breakpoint_rich, rt_debug_add_function_breakpoint, rt_debug_set_breakpoint_enabled, rt_debug_get_breakpoint_info, rt_debug_list_breakpoints, rt_debug_get_source_lines, rt_debug_add_watch, rt_debug_remove_watch, rt_debug_list_watches, rt_debug_set_variable, rt_debug_eval_expression, rt_debug_terminate, rt_debug_select_frame, rt_debug_get_selected_frame, rt_debug_frame_locals)

# --- Session State Types ---

enum SessionState:
    Created
    Running
    Paused
    Stopped
    Terminated

enum TargetType:
    Interpreter
    Smf
    Native
    Remote

# Breakpoint within a session
class SessionBreakpoint:
    id: Int
    file: String
    line: Int
    condition: String

# Debug session
class DebugSession:
    id: String
    program: String
    target_type: String
    state: String
    breakpoints: [SessionBreakpoint]
    next_bp_id: Int

# Session manager - holds all debug sessions
class SessionManager:
    sessions: [DebugSession]
    next_session_id: Int

    static fn empty() -> SessionManager:
        SessionManager(sessions: [], next_session_id: 1)

    me create_session(program: String, target_type: String) -> DebugSession:
        val sid = "session_" + self.next_session_id.to_string()
        self.next_session_id = self.next_session_id + 1
        val session = DebugSession(
            id: sid,
            program: program,
            target_type: target_type,
            state: "created",
            breakpoints: [],
            next_bp_id: 1
        )
        self.sessions = self.sessions + [session]
        session

    fn find_session(session_id: String) -> Int:
        # Returns index or -1 if not found
        var idx = 0
        for s in self.sessions:
            if s.id == session_id:
                return idx
            idx = idx + 1
        return -1

    me remove_session(session_id: String) -> Bool:
        var new_sessions = []
        var found = false
        for s in self.sessions:
            if s.id == session_id:
                found = true
            else:
                new_sessions = new_sessions + [s]
        self.sessions = new_sessions
        found

    fn list_sessions() -> [DebugSession]:
        self.sessions

    me add_breakpoint(session_id: String, file: String, line: Int, condition: String) -> String:
        val idx = self.find_session(session_id)
        if idx < 0:
            return ""
        var session = self.sessions[idx]
        val bp_id = session.next_bp_id
        session.next_bp_id = session.next_bp_id + 1
        val bp = SessionBreakpoint(id: bp_id, file: file, line: line, condition: condition)
        session.breakpoints = session.breakpoints + [bp]
        self.sessions[idx] = session
        bp_id.to_string()

    me remove_breakpoint(session_id: String, bp_id_str: String) -> Bool:
        val idx = self.find_session(session_id)
        if idx < 0:
            return false
        var session = self.sessions[idx]
        val bp_id_result = parse_int(bp_id_str)
        var bp_id = -1
        match bp_id_result:
            Ok(v): bp_id = v
            Err(_): return false
        var new_bps = []
        var found = false
        for bp in session.breakpoints:
            if bp.id == bp_id:
                found = true
            else:
                new_bps = new_bps + [bp]
        session.breakpoints = new_bps
        self.sessions[idx] = session
        found

    me set_state(session_id: String, new_state: String) -> Bool:
        val idx = self.find_session(session_id)
        if idx < 0:
            return false
        var session = self.sessions[idx]
        session.state = new_state
        self.sessions[idx] = session
        true

# --- Tool Schema Functions ---

fn schema_debug_create_session() -> String:
    # properties: program (string, required), target_type (string, optional)
    val p1 = jo2(jp("type", js("string")), jp("description", js("Path to the Simple program to debug")))
    val p2 = jo2(jp("type", js("string")), jp("description", js("Target type: interpreter, smf, native, remote")))
    var props = LB()
    props = props + jp("program", p1)
    props = props + ","
    props = props + jp("target_type", p2)
    props = props + RB()
    val req = "[" + js("program") + "]"
    make_tool_schema_multi("debug_create_session", "Create a new debug session for a Simple program", props, req, false, false, false)

fn schema_debug_list_sessions() -> String:
    val props = jo1("")
    make_tool_schema_multi("debug_list_sessions", "List all active debug sessions", props, "[]", true, false, true)

fn schema_debug_close_session() -> String:
    val p1 = jo2(jp("type", js("string")), jp("description", js("ID of the debug session to close")))
    val props = jo1(jp("session_id", p1))
    val req = "[" + js("session_id") + "]"
    make_tool_schema_multi("debug_close_session", "Close and clean up a debug session", props, req, false, true, true)

fn schema_debug_set_breakpoint() -> String:
    val p1 = jo2(jp("type", js("string")), jp("description", js("Debug session ID")))
    val p2 = jo2(jp("type", js("string")), jp("description", js("Source file path")))
    val p3 = jo2(jp("type", js("string")), jp("description", js("Line number")))
    val p4 = jo2(jp("type", js("string")), jp("description", js("Optional condition expression")))
    var props = LB()
    props = props + jp("session_id", p1)
    props = props + ","
    props = props + jp("file", p2)
    props = props + ","
    props = props + jp("line", p3)
    props = props + ","
    props = props + jp("condition", p4)
    props = props + RB()
    val req = "[" + js("session_id") + "," + js("file") + "," + js("line") + "]"
    make_tool_schema_multi("debug_set_breakpoint", "Set a breakpoint in a debug session", props, req, false, false, true)

fn schema_debug_remove_breakpoint() -> String:
    val p1 = jo2(jp("type", js("string")), jp("description", js("Debug session ID")))
    val p2 = jo2(jp("type", js("string")), jp("description", js("Breakpoint ID to remove")))
    var props = LB()
    props = props + jp("session_id", p1)
    props = props + ","
    props = props + jp("breakpoint_id", p2)
    props = props + RB()
    val req = "[" + js("session_id") + "," + js("breakpoint_id") + "]"
    make_tool_schema_multi("debug_remove_breakpoint", "Remove a breakpoint from a debug session", props, req, false, true, true)

fn schema_debug_continue() -> String:
    val p1 = jo2(jp("type", js("string")), jp("description", js("Debug session ID")))
    val props = jo1(jp("session_id", p1))
    val req = "[" + js("session_id") + "]"
    make_tool_schema_multi("debug_continue", "Continue execution of a paused debug session", props, req, false, false, false)

fn schema_debug_step() -> String:
    val p1 = jo2(jp("type", js("string")), jp("description", js("Debug session ID")))
    val p2 = jo2(jp("type", js("string")), jp("description", js("Step mode: over, in, out")))
    var props = LB()
    props = props + jp("session_id", p1)
    props = props + ","
    props = props + jp("mode", p2)
    props = props + RB()
    val req = "[" + js("session_id") + "," + js("mode") + "]"
    make_tool_schema_multi("debug_step", "Step execution in a debug session", props, req, false, false, false)

fn schema_debug_get_variables() -> String:
    val p1 = jo2(jp("type", js("string")), jp("description", js("Debug session ID")))
    val props = jo1(jp("session_id", p1))
    val req = "[" + js("session_id") + "]"
    make_tool_schema_multi("debug_get_variables", "Get variables in the current scope of a debug session", props, req, true, false, true)

fn schema_debug_stack_trace() -> String:
    val p1 = jo2(jp("type", js("string")), jp("description", js("Debug session ID")))
    val props = jo1(jp("session_id", p1))
    val req = "[" + js("session_id") + "]"
    make_tool_schema_multi("debug_stack_trace", "Get the call stack of a debug session", props, req, true, false, true)

fn schema_debug_evaluate() -> String:
    val p1 = jo2(jp("type", js("string")), jp("description", js("Debug session ID")))
    val p2 = jo2(jp("type", js("string")), jp("description", js("Expression to evaluate")))
    var props = LB()
    props = props + jp("session_id", p1)
    props = props + ","
    props = props + jp("expression", p2)
    props = props + RB()
    val req = "[" + js("session_id") + "," + js("expression") + "]"
    make_tool_schema_multi("debug_evaluate", "Evaluate an expression in the context of a debug session", props, req, true, false, true)

# --- Parsing Helpers ---

# Parse "name = value : type" into JSON object
# Returns: {"name":"x","value":"42","type":"Int"}
fn parse_var_entry(raw: String) -> String:
    val parts = raw.split(" = ")
    if parts.len() < 2:
        # No " = " found, return raw as name with unknown type
        var obj = LB()
        obj = obj + jp("name", js(escape_json(raw)))
        obj = obj + ","
        obj = obj + jp("value", js(""))
        obj = obj + ","
        obj = obj + jp("type", js("unknown"))
        obj = obj + RB()
        return obj
    val var_name = parts[0]
    val rest = parts[1]
    val type_parts = rest.split(" : ")
    val var_value = type_parts[0]
    var var_type = "unknown"
    if type_parts.len() >= 2:
        var_type = type_parts[1]
    var obj = LB()
    obj = obj + jp("name", js(escape_json(var_name)))
    obj = obj + ","
    obj = obj + jp("value", js(escape_json(var_value)))
    obj = obj + ","
    obj = obj + jp("type", js(escape_json(var_type)))
    obj = obj + RB()
    obj

# Parse stack frame string into JSON object
# Returns: {"id":N,"name":"raw","source":"unknown","line":0}
fn parse_stack_frame(idx: Int, raw: String) -> String:
    var obj = LB()
    obj = obj + jp("id", idx.to_string())
    obj = obj + ","
    obj = obj + jp("name", js(escape_json(raw)))
    obj = obj + ","
    obj = obj + jp("source", js("unknown"))
    obj = obj + ","
    obj = obj + jp("line", "0")
    obj = obj + RB()
    obj

# Map step mode string to integer: over=1, in=2, out=3
fn step_mode_to_int(mode: String) -> Int:
    if mode == "over":
        return 1
    if mode == "in":
        return 2
    if mode == "out":
        return 3
    return 0

# --- Handler Functions ---

fn handle_debug_create_session(id: String, body: String, mgr: SessionManager) -> String:
    val program = extract_nested_string(body, "arguments", "program")
    if program == "":
        return make_error_response(id, -32602, "Missing required parameter: program")
    var target_type = extract_nested_string(body, "arguments", "target_type")
    if target_type == "":
        target_type = "interpreter"
    val session = mgr.create_session(program, target_type)
    # Activate debug mode in backend
    rt_debug_set_active(true)
    var result_json = LB()
    result_json = result_json + jp("session_id", js(session.id))
    result_json = result_json + ","
    result_json = result_json + jp("program", js(session.program))
    result_json = result_json + ","
    result_json = result_json + jp("target_type", js(session.target_type))
    result_json = result_json + ","
    result_json = result_json + jp("state", js(session.state))
    result_json = result_json + RB()
    make_tool_result(id, result_json)

fn handle_debug_list_sessions(id: String, mgr: SessionManager) -> String:
    val sessions = mgr.list_sessions()
    var arr = "["
    var first = true
    for s in sessions:
        if not first:
            arr = arr + ","
        first = false
        var obj = LB()
        obj = obj + jp("session_id", js(s.id))
        obj = obj + ","
        obj = obj + jp("program", js(s.program))
        obj = obj + ","
        obj = obj + jp("target_type", js(s.target_type))
        obj = obj + ","
        obj = obj + jp("state", js(s.state))
        obj = obj + RB()
        arr = arr + obj
    arr = arr + "]"
    make_tool_result(id, arr)

fn handle_debug_close_session(id: String, body: String, mgr: SessionManager) -> String:
    val session_id = extract_nested_string(body, "arguments", "session_id")
    if session_id == "":
        return make_error_response(id, -32602, "Missing required parameter: session_id")
    val removed = mgr.remove_session(session_id)
    if not removed:
        return make_error_response(id, -32602, "Session not found: " + session_id)
    # Deactivate debug mode if no sessions remain
    val remaining = mgr.list_sessions()
    if remaining.len() == 0:
        rt_debug_set_active(false)
    var result_json = LB()
    result_json = result_json + jp("closed", js(session_id))
    result_json = result_json + ","
    result_json = result_json + jp("status", js("ok"))
    result_json = result_json + RB()
    make_tool_result(id, result_json)

fn handle_debug_set_breakpoint(id: String, body: String, mgr: SessionManager) -> String:
    val session_id = extract_nested_string(body, "arguments", "session_id")
    if session_id == "":
        return make_error_response(id, -32602, "Missing required parameter: session_id")
    val file = extract_nested_string(body, "arguments", "file")
    if file == "":
        return make_error_response(id, -32602, "Missing required parameter: file")
    val line_str = extract_nested_string(body, "arguments", "line")
    if line_str == "":
        return make_error_response(id, -32602, "Missing required parameter: line")
    val line_result = parse_int(line_str)
    var line = 0
    match line_result:
        Ok(v): line = v
        Err(e): return make_error_response(id, -32602, "Invalid line number: " + line_str)
    val condition = extract_nested_string(body, "arguments", "condition")
    val bp_id_str = mgr.add_breakpoint(session_id, file, line, condition)
    if bp_id_str == "":
        return make_error_response(id, -32602, "Session not found: " + session_id)
    # Register breakpoint in debug backend
    rt_debug_add_breakpoint_at(file, line)
    var result_json = LB()
    result_json = result_json + jp("breakpoint_id", bp_id_str)
    result_json = result_json + ","
    result_json = result_json + jp("session_id", js(session_id))
    result_json = result_json + ","
    result_json = result_json + jp("file", js(file))
    result_json = result_json + ","
    result_json = result_json + jp("line", line.to_string())
    result_json = result_json + ","
    result_json = result_json + jp("verified", "true")
    result_json = result_json + RB()
    make_tool_result(id, result_json)

fn handle_debug_remove_breakpoint(id: String, body: String, mgr: SessionManager) -> String:
    val session_id = extract_nested_string(body, "arguments", "session_id")
    if session_id == "":
        return make_error_response(id, -32602, "Missing required parameter: session_id")
    val bp_id = extract_nested_string(body, "arguments", "breakpoint_id")
    if bp_id == "":
        return make_error_response(id, -32602, "Missing required parameter: breakpoint_id")
    # Look up breakpoint file/line before removing from session
    val sess_idx = mgr.find_session(session_id)
    if sess_idx >= 0:
        val session = mgr.sessions[sess_idx]
        val bp_id_result = parse_int(bp_id)
        var bp_id_int = -1
        match bp_id_result:
            Ok(v): bp_id_int = v
            Err(_): pass
        for bp in session.breakpoints:
            if bp.id == bp_id_int:
                rt_debug_remove_breakpoint_at(bp.file, bp.line)
    val removed = mgr.remove_breakpoint(session_id, bp_id)
    if not removed:
        return make_error_response(id, -32602, "Breakpoint not found: " + bp_id)
    var result_json = LB()
    result_json = result_json + jp("removed", js(bp_id))
    result_json = result_json + ","
    result_json = result_json + jp("status", js("ok"))
    result_json = result_json + RB()
    make_tool_result(id, result_json)

fn handle_debug_continue(id: String, body: String, mgr: SessionManager) -> String:
    val session_id = extract_nested_string(body, "arguments", "session_id")
    if session_id == "":
        return make_error_response(id, -32602, "Missing required parameter: session_id")
    val found = mgr.set_state(session_id, "running")
    if not found:
        return make_error_response(id, -32602, "Session not found: " + session_id)
    # Tell backend to continue execution
    rt_debug_continue_exec()
    var result_json = LB()
    result_json = result_json + jp("session_id", js(session_id))
    result_json = result_json + ","
    result_json = result_json + jp("state", js("running"))
    result_json = result_json + RB()
    make_tool_result(id, result_json)

fn handle_debug_step(id: String, body: String, mgr: SessionManager) -> String:
    val session_id = extract_nested_string(body, "arguments", "session_id")
    if session_id == "":
        return make_error_response(id, -32602, "Missing required parameter: session_id")
    val mode = extract_nested_string(body, "arguments", "mode")
    if mode == "":
        return make_error_response(id, -32602, "Missing required parameter: mode")
    val step_int = step_mode_to_int(mode)
    if step_int == 0:
        return make_error_response(id, -32602, "Invalid step mode: " + mode + ". Must be over, in, or out")
    val found = mgr.set_state(session_id, "paused")
    if not found:
        return make_error_response(id, -32602, "Session not found: " + session_id)
    # Send step command to backend
    rt_debug_set_step_mode_val(step_int)
    var result_json = LB()
    result_json = result_json + jp("session_id", js(session_id))
    result_json = result_json + ","
    result_json = result_json + jp("mode", js(mode))
    result_json = result_json + ","
    result_json = result_json + jp("state", js("paused"))
    result_json = result_json + RB()
    make_tool_result(id, result_json)

fn handle_debug_get_variables(id: String, body: String, mgr: SessionManager) -> String:
    val session_id = extract_nested_string(body, "arguments", "session_id")
    if session_id == "":
        return make_error_response(id, -32602, "Missing required parameter: session_id")
    val idx = mgr.find_session(session_id)
    if idx < 0:
        return make_error_response(id, -32602, "Session not found: " + session_id)
    # Query backend for local variables
    val raw_vars = rt_debug_local_vars()
    var vars_arr = "["
    var first = true
    for raw in raw_vars:
        if not first:
            vars_arr = vars_arr + ","
        first = false
        vars_arr = vars_arr + parse_var_entry(raw)
    vars_arr = vars_arr + "]"
    var result_json = LB()
    result_json = result_json + jp("session_id", js(session_id))
    result_json = result_json + ","
    result_json = result_json + jp("variables", vars_arr)
    result_json = result_json + RB()
    make_tool_result(id, result_json)

fn handle_debug_stack_trace(id: String, body: String, mgr: SessionManager) -> String:
    val session_id = extract_nested_string(body, "arguments", "session_id")
    if session_id == "":
        return make_error_response(id, -32602, "Missing required parameter: session_id")
    val idx = mgr.find_session(session_id)
    if idx < 0:
        return make_error_response(id, -32602, "Session not found: " + session_id)
    val session = mgr.sessions[idx]
    # Query backend for stack trace
    val raw_frames = rt_debug_stack_trace_lines()
    var frames_arr = "["
    if raw_frames.len() > 0:
        var first = true
        var frame_idx = 0
        for raw in raw_frames:
            if not first:
                frames_arr = frames_arr + ","
            first = false
            frames_arr = frames_arr + parse_stack_frame(frame_idx, raw)
            frame_idx = frame_idx + 1
    else:
        # Fallback: use current location from backend
        val cur_file = rt_debug_get_current_file()
        val cur_line = rt_debug_get_current_line()
        var source = session.program
        if cur_file != "":
            source = cur_file
        var line_num = 1
        if cur_line > 0:
            line_num = cur_line
        var frame = LB()
        frame = frame + jp("id", "0")
        frame = frame + ","
        frame = frame + jp("name", js("main"))
        frame = frame + ","
        frame = frame + jp("source", js(escape_json(source)))
        frame = frame + ","
        frame = frame + jp("line", line_num.to_string())
        frame = frame + RB()
        frames_arr = frames_arr + frame
    frames_arr = frames_arr + "]"
    # Count frames
    var total = raw_frames.len()
    if total == 0:
        total = 1
    var result_json = LB()
    result_json = result_json + jp("session_id", js(session_id))
    result_json = result_json + ","
    result_json = result_json + jp("frames", frames_arr)
    result_json = result_json + ","
    result_json = result_json + jp("total_frames", total.to_string())
    result_json = result_json + RB()
    make_tool_result(id, result_json)

fn handle_debug_evaluate(id: String, body: String, mgr: SessionManager) -> String:
    val session_id = extract_nested_string(body, "arguments", "session_id")
    if session_id == "":
        return make_error_response(id, -32602, "Missing required parameter: session_id")
    val expression = extract_nested_string(body, "arguments", "expression")
    if expression == "":
        return make_error_response(id, -32602, "Missing required parameter: expression")
    val idx = mgr.find_session(session_id)
    if idx < 0:
        return make_error_response(id, -32602, "Session not found: " + session_id)
    val frame_str = extract_nested_string(body, "arguments", "frame_index")
    var frame_idx = 0
    if frame_str != "":
        val fr = parse_int(frame_str)
        match fr:
            Ok(v): frame_idx = v
            Err(_): pass
    val eval_json = rt_debug_eval_expression(expression, frame_idx)
    val eval_result = extract_json_string_v2(eval_json, "result")
    val eval_type = extract_json_string_v2(eval_json, "type")
    val eval_error = extract_json_string_v2(eval_json, "error")
    var display_result = eval_result
    if eval_error != "":
        display_result = eval_error
    var result_json = LB()
    result_json = result_json + jp("session_id", js(session_id))
    result_json = result_json + ","
    result_json = result_json + jp("expression", js(escape_json(expression)))
    result_json = result_json + ","
    result_json = result_json + jp("result", js(escape_json(display_result)))
    result_json = result_json + ","
    result_json = result_json + jp("type", js(eval_type))
    result_json = result_json + RB()
    make_tool_result(id, result_json)

# --- New Tool Schemas (Phase 1.5) ---

fn schema_debug_set_function_breakpoint() -> String:
    val p1 = jo2(jp("type", js("string")), jp("description", js("Debug session ID")))
    val p2 = jo2(jp("type", js("string")), jp("description", js("Function name to break on")))
    val p3 = jo2(jp("type", js("string")), jp("description", js("Optional condition expression")))
    var props = LB()
    props = props + jp("session_id", p1)
    props = props + ","
    props = props + jp("function_name", p2)
    props = props + ","
    props = props + jp("condition", p3)
    props = props + RB()
    val req = "[" + js("session_id") + "," + js("function_name") + "]"
    make_tool_schema_multi("debug_set_function_breakpoint", "Set a breakpoint on a function name", props, req, false, false, true)

fn schema_debug_enable_breakpoint() -> String:
    val p1 = jo2(jp("type", js("string")), jp("description", js("Debug session ID")))
    val p2 = jo2(jp("type", js("string")), jp("description", js("Breakpoint ID")))
    val p3 = jo2(jp("type", js("string")), jp("description", js("true to enable, false to disable")))
    var props = LB()
    props = props + jp("session_id", p1)
    props = props + ","
    props = props + jp("breakpoint_id", p2)
    props = props + ","
    props = props + jp("enabled", p3)
    props = props + RB()
    val req = "[" + js("session_id") + "," + js("breakpoint_id") + "," + js("enabled") + "]"
    make_tool_schema_multi("debug_enable_breakpoint", "Enable or disable a breakpoint", props, req, false, false, true)

fn schema_debug_get_source() -> String:
    val p1 = jo2(jp("type", js("string")), jp("description", js("Debug session ID")))
    val p2 = jo2(jp("type", js("string")), jp("description", js("Source file path")))
    val p3 = jo2(jp("type", js("string")), jp("description", js("Start line number")))
    val p4 = jo2(jp("type", js("string")), jp("description", js("Number of lines to read")))
    var props = LB()
    props = props + jp("session_id", p1)
    props = props + ","
    props = props + jp("file", p2)
    props = props + ","
    props = props + jp("start_line", p3)
    props = props + ","
    props = props + jp("count", p4)
    props = props + RB()
    val req = "[" + js("session_id") + "," + js("file") + "]"
    make_tool_schema_multi("debug_get_source", "Read source lines from a file", props, req, true, false, true)

fn schema_debug_watch() -> String:
    val p1 = jo2(jp("type", js("string")), jp("description", js("Debug session ID")))
    val p2 = jo2(jp("type", js("string")), jp("description", js("Action: add, remove, list")))
    val p3 = jo2(jp("type", js("string")), jp("description", js("Watch expression (for add/remove)")))
    var props = LB()
    props = props + jp("session_id", p1)
    props = props + ","
    props = props + jp("action", p2)
    props = props + ","
    props = props + jp("expression", p3)
    props = props + RB()
    val req = "[" + js("session_id") + "," + js("action") + "]"
    make_tool_schema_multi("debug_watch", "Manage watch expressions (add/remove/list)", props, req, false, false, true)

fn schema_debug_set_variable() -> String:
    val p1 = jo2(jp("type", js("string")), jp("description", js("Debug session ID")))
    val p2 = jo2(jp("type", js("string")), jp("description", js("Variable name")))
    val p3 = jo2(jp("type", js("string")), jp("description", js("New value as string")))
    val p4 = jo2(jp("type", js("string")), jp("description", js("Frame index (-1 for globals)")))
    var props = LB()
    props = props + jp("session_id", p1)
    props = props + ","
    props = props + jp("name", p2)
    props = props + ","
    props = props + jp("value", p3)
    props = props + ","
    props = props + jp("frame_index", p4)
    props = props + RB()
    val req = "[" + js("session_id") + "," + js("name") + "," + js("value") + "]"
    make_tool_schema_multi("debug_set_variable", "Set a variable value in a specific frame", props, req, false, false, false)

fn schema_debug_terminate() -> String:
    val p1 = jo2(jp("type", js("string")), jp("description", js("Debug session ID")))
    val props = jo1(jp("session_id", p1))
    val req = "[" + js("session_id") + "]"
    make_tool_schema_multi("debug_terminate", "Terminate a debug session and stop execution", props, req, false, true, false)

# --- New Handler Functions (Phase 1.5) ---

fn handle_debug_set_function_breakpoint(id: String, body: String, mgr: SessionManager) -> String:
    val session_id = extract_nested_string(body, "arguments", "session_id")
    if session_id == "":
        return make_error_response(id, -32602, "Missing required parameter: session_id")
    val func_name = extract_nested_string(body, "arguments", "function_name")
    if func_name == "":
        return make_error_response(id, -32602, "Missing required parameter: function_name")
    val idx = mgr.find_session(session_id)
    if idx < 0:
        return make_error_response(id, -32602, "Session not found: " + session_id)
    val condition = extract_nested_string(body, "arguments", "condition")
    val bp_id = rt_debug_add_function_breakpoint(func_name, condition)
    var result_json = LB()
    result_json = result_json + jp("breakpoint_id", bp_id.to_string())
    result_json = result_json + "," + jp("session_id", js(session_id))
    result_json = result_json + "," + jp("function_name", js(func_name))
    result_json = result_json + "," + jp("type", js("function"))
    result_json = result_json + "," + jp("verified", "true")
    result_json = result_json + RB()
    make_tool_result(id, result_json)

fn handle_debug_enable_breakpoint(id: String, body: String, mgr: SessionManager) -> String:
    val session_id = extract_nested_string(body, "arguments", "session_id")
    if session_id == "":
        return make_error_response(id, -32602, "Missing required parameter: session_id")
    val bp_id_str = extract_nested_string(body, "arguments", "breakpoint_id")
    if bp_id_str == "":
        return make_error_response(id, -32602, "Missing required parameter: breakpoint_id")
    val enabled_str = extract_nested_string(body, "arguments", "enabled")
    if enabled_str == "":
        return make_error_response(id, -32602, "Missing required parameter: enabled")
    val idx = mgr.find_session(session_id)
    if idx < 0:
        return make_error_response(id, -32602, "Session not found: " + session_id)
    val bp_id_result = parse_int(bp_id_str)
    var bp_id = -1
    match bp_id_result:
        Ok(v): bp_id = v
        Err(_): return make_error_response(id, -32602, "Invalid breakpoint_id: " + bp_id_str)
    var enabled_val = 1
    if enabled_str == "false" or enabled_str == "0":
        enabled_val = 0
    rt_debug_set_breakpoint_enabled(bp_id, enabled_val)
    var result_json = LB()
    result_json = result_json + jp("breakpoint_id", bp_id.to_string())
    result_json = result_json + "," + jp("enabled", enabled_str)
    result_json = result_json + "," + jp("status", js("ok"))
    result_json = result_json + RB()
    make_tool_result(id, result_json)

fn handle_debug_get_source(id: String, body: String, mgr: SessionManager) -> String:
    val session_id = extract_nested_string(body, "arguments", "session_id")
    if session_id == "":
        return make_error_response(id, -32602, "Missing required parameter: session_id")
    val src_file = extract_nested_string(body, "arguments", "file")
    if src_file == "":
        return make_error_response(id, -32602, "Missing required parameter: file")
    val idx = mgr.find_session(session_id)
    if idx < 0:
        return make_error_response(id, -32602, "Session not found: " + session_id)
    val start_str = extract_nested_string(body, "arguments", "start_line")
    var start_line = 1
    if start_str != "":
        val sr = parse_int(start_str)
        match sr:
            Ok(v): start_line = v
            Err(_): pass
    val count_str = extract_nested_string(body, "arguments", "count")
    var line_count = 20
    if count_str != "":
        val cr = parse_int(count_str)
        match cr:
            Ok(v): line_count = v
            Err(_): pass
    val source_text = rt_debug_get_source_lines(src_file, start_line, line_count)
    var result_json = LB()
    result_json = result_json + jp("session_id", js(session_id))
    result_json = result_json + "," + jp("file", js(src_file))
    result_json = result_json + "," + jp("start_line", start_line.to_string())
    result_json = result_json + "," + jp("source", js(escape_json(source_text)))
    result_json = result_json + RB()
    make_tool_result(id, result_json)

fn handle_debug_watch(id: String, body: String, mgr: SessionManager) -> String:
    val session_id = extract_nested_string(body, "arguments", "session_id")
    if session_id == "":
        return make_error_response(id, -32602, "Missing required parameter: session_id")
    val action = extract_nested_string(body, "arguments", "action")
    if action == "":
        return make_error_response(id, -32602, "Missing required parameter: action")
    val idx = mgr.find_session(session_id)
    if idx < 0:
        return make_error_response(id, -32602, "Session not found: " + session_id)
    if action == "add":
        val expr = extract_nested_string(body, "arguments", "expression")
        if expr == "":
            return make_error_response(id, -32602, "Missing expression for add")
        val added = rt_debug_add_watch(expr)
        var result_json = LB()
        result_json = result_json + jp("action", js("add"))
        result_json = result_json + "," + jp("expression", js(escape_json(expr)))
        var ok_str = "true"
        if added == 0:
            ok_str = "false"
        result_json = result_json + "," + jp("success", ok_str)
        result_json = result_json + RB()
        return make_tool_result(id, result_json)
    elif action == "remove":
        val expr = extract_nested_string(body, "arguments", "expression")
        if expr == "":
            return make_error_response(id, -32602, "Missing expression for remove")
        val removed = rt_debug_remove_watch(expr)
        var result_json = LB()
        result_json = result_json + jp("action", js("remove"))
        result_json = result_json + "," + jp("expression", js(escape_json(expr)))
        var ok_str = "true"
        if removed == 0:
            ok_str = "false"
        result_json = result_json + "," + jp("success", ok_str)
        result_json = result_json + RB()
        return make_tool_result(id, result_json)
    elif action == "list":
        val watches = rt_debug_list_watches()
        var result_json = LB()
        result_json = result_json + jp("action", js("list"))
        result_json = result_json + "," + jp("watches", watches)
        result_json = result_json + RB()
        return make_tool_result(id, result_json)
    else:
        return make_error_response(id, -32602, "Invalid action: " + action + ". Must be add, remove, or list")

fn handle_debug_set_variable(id: String, body: String, mgr: SessionManager) -> String:
    val session_id = extract_nested_string(body, "arguments", "session_id")
    if session_id == "":
        return make_error_response(id, -32602, "Missing required parameter: session_id")
    val var_name = extract_nested_string(body, "arguments", "name")
    if var_name == "":
        return make_error_response(id, -32602, "Missing required parameter: name")
    val var_value = extract_nested_string(body, "arguments", "value")
    if var_value == "":
        return make_error_response(id, -32602, "Missing required parameter: value")
    val idx = mgr.find_session(session_id)
    if idx < 0:
        return make_error_response(id, -32602, "Session not found: " + session_id)
    val frame_str = extract_nested_string(body, "arguments", "frame_index")
    var frame_idx = 0
    if frame_str != "":
        val fr = parse_int(frame_str)
        match fr:
            Ok(v): frame_idx = v
            Err(_): pass
    val ok = rt_debug_set_variable(var_name, var_value, frame_idx)
    var result_json = LB()
    result_json = result_json + jp("name", js(escape_json(var_name)))
    result_json = result_json + "," + jp("value", js(escape_json(var_value)))
    result_json = result_json + "," + jp("frame_index", frame_idx.to_string())
    var ok_str = "true"
    if ok == 0:
        ok_str = "false"
    result_json = result_json + "," + jp("success", ok_str)
    result_json = result_json + RB()
    make_tool_result(id, result_json)

fn handle_debug_terminate(id: String, body: String, mgr: SessionManager) -> String:
    val session_id = extract_nested_string(body, "arguments", "session_id")
    if session_id == "":
        return make_error_response(id, -32602, "Missing required parameter: session_id")
    val found = mgr.set_state(session_id, "terminated")
    if not found:
        return make_error_response(id, -32602, "Session not found: " + session_id)
    rt_debug_terminate()
    var result_json = LB()
    result_json = result_json + jp("session_id", js(session_id))
    result_json = result_json + "," + jp("state", js("terminated"))
    result_json = result_json + "," + jp("status", js("ok"))
    result_json = result_json + RB()
    make_tool_result(id, result_json)

# --- Exports ---

export SessionState, TargetType, SessionBreakpoint, DebugSession, SessionManager
export parse_var_entry, parse_stack_frame, step_mode_to_int
export schema_debug_create_session, schema_debug_list_sessions, schema_debug_close_session
export schema_debug_set_breakpoint, schema_debug_remove_breakpoint
export schema_debug_continue, schema_debug_step
export schema_debug_get_variables, schema_debug_stack_trace, schema_debug_evaluate
export schema_debug_set_function_breakpoint, schema_debug_enable_breakpoint
export schema_debug_get_source, schema_debug_watch
export schema_debug_set_variable, schema_debug_terminate
export handle_debug_create_session, handle_debug_list_sessions, handle_debug_close_session
export handle_debug_set_breakpoint, handle_debug_remove_breakpoint
export handle_debug_continue, handle_debug_step
export handle_debug_get_variables, handle_debug_stack_trace, handle_debug_evaluate
export handle_debug_set_function_breakpoint, handle_debug_enable_breakpoint
export handle_debug_get_source, handle_debug_watch
export handle_debug_set_variable, handle_debug_terminate
