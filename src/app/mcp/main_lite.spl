# Lightweight MCP Server for Simple Language - Zero imports for fast startup
#
# Inlines all JSON helpers and tool handling.
# Startup target: <100ms (vs 30s+ for full server with debug tools)
#
# Tools (4): simple_read, simple_list, simple_search, simple_status

extern fn rt_file_read_text(path: text) -> text
extern fn rt_file_exists(path: text) -> bool
extern fn rt_process_run(cmd: text, args: [text]) -> text
extern fn rt_env_get(name: text) -> text

val SERVER_NAME = "simple-mcp-lite"
val SERVER_VERSION = "1.0.0"
val NL = "\n"

# Protocol auto-detection: JSON Lines (MCP SDK) vs Content-Length (LSP)
var USE_JSON_LINES = false

# --- JSON helpers (inlined) ---

fn Q() -> text:
    "\""

fn LB() -> text:
    "{"

fn RB() -> text:
    "}"

fn SB_L() -> text:
    "["

fn SB_R() -> text:
    "]"

fn escape_json(s: text) -> text:
    var result = ""
    var i = 0
    for ch in s:
        if ch == "\"":
            result = result + "\\\""
        elif ch == "\\":
            result = result + "\\\\"
        elif ch == "\n":
            result = result + "\\n"
        elif ch == "\r":
            result = result + "\\r"
        elif ch == "\t":
            result = result + "\\t"
        else:
            result = result + ch
        i = i + 1
    result

fn js(s: text) -> text:
    Q() + escape_json(s) + Q()

fn jp(key: text, value: text) -> text:
    Q() + key + Q() + ":" + value

fn jo1(p1: text) -> text:
    LB() + p1 + RB()

fn jo2(p1: text, p2: text) -> text:
    LB() + p1 + "," + p2 + RB()

fn jo3(p1: text, p2: text, p3: text) -> text:
    LB() + p1 + "," + p2 + "," + p3 + RB()

fn extract_field(json: text, key: text) -> text:
    val search = Q() + key + Q() + ":"
    val idx_result = json.index_of(search)
    var idx = -1
    match idx_result:
        Some(i): idx = i
        nil: return ""

    if idx < 0:
        return ""

    val start = idx + search.len()
    val after = json.substring(start)
    val trimmed = after.trim()

    if trimmed.starts_with(Q()):
        val after_quote = trimmed.substring(1)
        val end_idx_result = after_quote.index_of(Q())
        var end_idx = -1
        match end_idx_result:
            Some(i): end_idx = i
            nil: return ""
        if end_idx < 0:
            return ""
        return trimmed.substring(1, end_idx + 1)
    else:
        var result = ""
        for ch in trimmed:
            if ch == "," or ch == RB() or ch == SB_R() or ch == " " or ch == "\n":
                break
            result = result + ch
        return result

fn extract_id(json: text) -> text:
    extract_field(json, "id")

fn extract_nested(json: text, key: text) -> text:
    val params_search = Q() + "params" + Q() + ":"
    val params_idx_result = json.index_of(params_search)
    var params_idx = -1
    match params_idx_result:
        Some(i): params_idx = i
        nil: return ""

    if params_idx < 0:
        return ""

    val params_start = params_idx + params_search.len()
    val params = json.substring(params_start)
    extract_field(params, key)

fn extract_arg(json: text, arg_name: text) -> text:
    val args_search = Q() + "arguments" + Q() + ":"
    val args_idx_result = json.index_of(args_search)
    var args_idx = -1
    match args_idx_result:
        Some(i): args_idx = i
        nil: return ""

    if args_idx < 0:
        return ""

    val args_start = args_idx + args_search.len()
    val args_section = json.substring(args_start)
    extract_field(args_section, arg_name)

fn make_json_result(id: text, result: text) -> text:
    jo3(jp("jsonrpc", js("2.0")), jp("id", id), jp("result", result))

fn make_error(id: text, code: i64, message: text) -> text:
    val err = jo2(jp("code", str(code)), jp("message", js(message)))
    jo3(jp("jsonrpc", js("2.0")), jp("id", id), jp("error", err))

# --- Start server ---
start_server()

fn start_server():
    var running = true
    for _iter in range(0, 999999):
        if not running:
            return
        var line = read_stdin_message()
        if line == "":
            running = false
        else:
            var method = extract_field(line, "method")
            var id = extract_id(line)
            # Bug B: malformed JSON - no method or id extractable → parse error
            if method == "" and id == "":
                write_stdout_message(make_error("null", -32700, "Parse error"))
            elif id == "":
                # Bug C: JSON-RPC notification (no id) → no response
                pass_do_nothing
            else:
                var response = ""
                if method == "initialize":
                    response = make_init_response(id)
                elif method == "initialized" or method == "notifications/initialized":
                    response = ""
                elif method == "shutdown":
                    response = make_json_result(id, "null")
                elif method == "tools/list":
                    response = make_tools_list(id)
                elif method == "tools/call":
                    var tool_name = extract_nested(line, "name")
                    response = dispatch_tool(id, tool_name, line)
                elif method == "resources/list":
                    response = make_json_result(id, jo1(jp("resources", SB_L() + SB_R())))
                elif method == "prompts/list":
                    response = make_json_result(id, jo1(jp("prompts", SB_L() + SB_R())))
                elif method == "ping":
                    response = make_json_result(id, LB() + RB())
                elif method == "notifications/cancelled":
                    response = ""
                else:
                    response = make_error(id, -32601, "Method not found: " + method)
                if response != "":
                    write_stdout_message(response)

# --- MCP protocol I/O ---

fn read_stdin_message() -> text:
    var line = input()
    if line == "":
        return ""
    if line.ends_with("\r"):
        line = line.substring(0, line.len() - 1)
    # JSON Lines mode: line starts with { (MCP SDK format)
    if line.starts_with(LB()):
        USE_JSON_LINES = true
        return line
    # Content-Length mode (LSP-style framing)
    if line.starts_with("Content-Length:"):
        var len_str = line.replace("Content-Length:", "")
        len_str = len_str.trim()
        val content_length = int(len_str)
        if content_length == 0:
            return ""
        input()
        var body = input()
        return body
    ""

fn write_stdout_message(body: text):
    if USE_JSON_LINES:
        print_raw(body + NL)
    else:
        var header = "Content-Length: " + str(body.len()) + "\r" + NL + "\r" + NL
        print_raw(header)
        print_raw(body)

# --- Initialize response ---

fn make_init_response(id: text) -> text:
    val caps = jo1(jp("tools", jo1(jp("listChanged", "true"))))
    val server_info = jo3(
        jp("name", js(SERVER_NAME)),
        jp("version", js(SERVER_VERSION)),
        jp("instructions", js("Lightweight Simple MCP server. Provides: simple_read (read file), simple_list (list files), simple_search (grep), simple_status (project info)."))
    )
    val result = jo3(
        jp("protocolVersion", js("2025-06-18")),
        jp("capabilities", caps),
        jp("serverInfo", server_info)
    )
    make_json_result(id, result)

# --- Tools list ---

fn make_tools_list(id: text) -> text:
    var tools = SB_L()

    # simple_read
    var read_props = LB()
    read_props = read_props + jp("path", jo2(jp("type", js("string")), jp("description", js("Path to .spl file to read"))))
    read_props = read_props + RB()
    var read_tool = jo3(
        jp("name", js("simple_read")),
        jp("description", js("Read a Simple source file")),
        jo1(jp("properties", read_props))
    )
    read_tool = jo3(
        jp("name", js("simple_read")),
        jp("description", js("Read a Simple source file")),
        jp("inputSchema", jo3(jp("type", js("object")), jp("properties", read_props), jp("required", SB_L() + js("path") + SB_R())))
    )
    tools = tools + read_tool

    # simple_list
    var list_props = LB()
    list_props = list_props + jp("directory", jo2(jp("type", js("string")), jp("description", js("Directory to list (default: src/)"))))
    list_props = list_props + RB()
    var list_tool = jo3(
        jp("name", js("simple_list")),
        jp("description", js("List .spl files in a directory")),
        jp("inputSchema", jo2(jp("type", js("object")), jp("properties", list_props)))
    )
    tools = tools + "," + list_tool

    # simple_search
    var search_props = LB()
    search_props = search_props + jp("pattern", jo2(jp("type", js("string")), jp("description", js("Search pattern (regex)"))))
    search_props = search_props + "," + jp("directory", jo2(jp("type", js("string")), jp("description", js("Directory to search (default: src/)"))))
    search_props = search_props + RB()
    var search_tool = jo3(
        jp("name", js("simple_search")),
        jp("description", js("Search for pattern in .spl files")),
        jp("inputSchema", jo3(jp("type", js("object")), jp("properties", search_props), jp("required", SB_L() + js("pattern") + SB_R())))
    )
    tools = tools + "," + search_tool

    # simple_status
    var status_tool = jo2(
        jp("name", js("simple_status")),
        jp("description", js("Show project status (working directory, file counts)"))
    )
    status_tool = jo3(
        jp("name", js("simple_status")),
        jp("description", js("Show project status (working directory, file counts)")),
        jp("inputSchema", jo1(jp("type", js("object"))))
    )
    tools = tools + "," + status_tool

    tools = tools + SB_R()
    val result = jo1(jp("tools", tools))
    make_json_result(id, result)

# --- Tool dispatch ---

fn dispatch_tool(id: text, tool_name: text, body: text) -> text:
    if tool_name == "simple_read":
        return handle_simple_read(id, body)
    elif tool_name == "simple_list":
        return handle_simple_list(id, body)
    elif tool_name == "simple_search":
        return handle_simple_search(id, body)
    elif tool_name == "simple_status":
        return handle_simple_status(id, body)
    else:
        return make_error(id, -32601, "Unknown tool: " + tool_name)

# --- Tool: simple_read ---

fn handle_simple_read(id: text, body: text) -> text:
    val path = extract_arg(body, "path")
    # Bug A: JSON null value is extracted as literal string "null"
    if path == "" or path == "null":
        return make_error(id, -32602, "Missing required parameter: path")

    val content_opt = rt_file_read_text(path)
    var content = ""
    match content_opt:
        Some(c): content = c
        nil: return make_error(id, -32602, "Could not read file: " + path)

    if content == "":
        return make_error(id, -32602, "File is empty or not found: " + path)

    val result_text = "-- " + path + " --" + NL + content
    val result = jo2(jp("content", SB_L() + jo2(jp("type", js("text")), jp("text", js(result_text))) + SB_R()), jp("isError", "false"))
    make_json_result(id, result)

# --- Tool: simple_list ---

fn handle_simple_list(id: text, body: text) -> text:
    var directory = extract_arg(body, "directory")
    if directory == "":
        directory = "src/"

    val find_args = ["-c", "find " + directory + " -name '*.spl' -type f 2>/dev/null | sort"]
    val find_result = rt_process_run("/bin/sh", find_args)
    var output = find_result[0]

    if output == "":
        output = "No .spl files found in " + directory

    val result = jo2(jp("content", SB_L() + jo2(jp("type", js("text")), jp("text", js(output))) + SB_R()), jp("isError", "false"))
    make_json_result(id, result)

# --- Tool: simple_search ---

fn handle_simple_search(id: text, body: text) -> text:
    val pattern = extract_arg(body, "pattern")
    # Bug A: JSON null value is extracted as literal string "null"
    if pattern == "" or pattern == "null":
        return make_error(id, -32602, "Missing required parameter: pattern")

    var directory = extract_arg(body, "directory")
    if directory == "":
        directory = "src/"

    val grep_cmd = "grep -rn '" + pattern + "' " + directory + " --include='*.spl' 2>/dev/null | head -50"
    val grep_args = ["-c", grep_cmd]
    val grep_result = rt_process_run("/bin/sh", grep_args)
    var output = grep_result[0]

    if output == "":
        output = "No matches found for pattern: " + pattern

    val result = jo2(jp("content", SB_L() + jo2(jp("type", js("text")), jp("text", js(output))) + SB_R()), jp("isError", "false"))
    make_json_result(id, result)

# --- Tool: simple_status ---

fn handle_simple_status(id: text, body: text) -> text:
    val pwd_args = ["-c", "pwd"]
    val pwd_result = rt_process_run("/bin/sh", pwd_args)
    var cwd = pwd_result[0]
    if cwd.ends_with(NL):
        cwd = cwd.substring(0, cwd.len() - 1)

    val count_args = ["-c", "find src/ -name '*.spl' -type f 2>/dev/null | wc -l"]
    val count_result = rt_process_run("/bin/sh", count_args)
    var file_count = count_result[0]
    if file_count.ends_with(NL):
        file_count = file_count.substring(0, file_count.len() - 1)
    file_count = file_count.trim()

    var status = "Working Directory: " + cwd + NL
    status = status + "Simple Files: " + file_count + " .spl files in src/" + NL
    status = status + "Server: " + SERVER_NAME + " v" + SERVER_VERSION

    val result = jo2(jp("content", SB_L() + jo2(jp("type", js("text")), jp("text", js(status))) + SB_R()), jp("isError", "false"))
    make_json_result(id, result)
