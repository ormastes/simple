# MCP Diagnostic Read Tools - Read-only diagnostic tools
#
# Tools:
#   simple_read    - Read file with inline virtual text diagnostics
#   simple_check   - Structured diagnostics JSON
#   simple_symbols - File symbol listing
#   simple_status  - Project diagnostic overview

use app.io.mod (file_read, shell, cwd)
use mcp_lib.helpers.{LB, RB, Q, jp, js, jo1, jo2, jo3, parse_int, min_int, extract_arg, make_tool_result, make_error_response, make_tool_schema_multi}
use app.mcp.helpers.{escape_json, register_tool}
use app.mcp.diag_core.{DiagEntry, DiagResult, run_diagnostics, overlay_virtual_text, diag_result_to_json, severity_tag, diag_entries_to_json}
use std.text.{NL}

# ============================================================================
# Tool Schemas
# ============================================================================

fn schema_simple_read() -> text:
    val path_prop = jo2(jp("type", js("string")), jp("description", js("Path to .spl file to read")))
    val hints_prop = jo2(jp("type", js("string")), jp("description", js("Show easyfix hints (true/false, default: true)")))
    val fold_prop = jo2(jp("type", js("string")), jp("description", js("Fold mode: compact or expanded (default: compact)")))
    val offset_prop = jo2(jp("type", js("string")), jp("description", js("Start line number (1-based, default: 1)")))
    val limit_prop = jo2(jp("type", js("string")), jp("description", js("Maximum lines to show (default: all)")))
    var props = LB()
    props = props + jp("path", path_prop)
    props = props + "," + jp("show_hints", hints_prop)
    props = props + "," + jp("fold_mode", fold_prop)
    props = props + "," + jp("offset", offset_prop)
    props = props + "," + jp("limit", limit_prop)
    props = props + RB()
    make_tool_schema_multi("simple_read", "Read a Simple source file with inline virtual text diagnostics (errors, warnings, hints overlaid on source lines)", props, "[" + js("path") + "]", true, false, true)

fn schema_simple_check() -> text:
    val path_prop = jo2(jp("type", js("string")), jp("description", js("Path to .spl file to check")))
    val props = jo1(jp("path", path_prop))
    make_tool_schema_multi("simple_check", "Type-check a Simple source file and return structured diagnostics with line numbers and easyfix hints", props, "[" + js("path") + "]", true, false, true)

fn schema_simple_symbols() -> text:
    val path_prop = jo2(jp("type", js("string")), jp("description", js("Path to .spl file")))
    val props = jo1(jp("path", path_prop))
    make_tool_schema_multi("simple_symbols", "List symbols (functions, classes, structs, enums) in a Simple source file with line numbers", props, "[" + js("path") + "]", true, false, true)

fn schema_simple_status() -> text:
    val dir_prop = jo2(jp("type", js("string")), jp("description", js("Directory to scan (default: src/)")))
    val paths_prop = jo2(jp("type", js("string")), jp("description", js("Comma-separated file paths to check (overrides directory)")))
    var props = LB()
    props = props + jp("directory", dir_prop)
    props = props + "," + jp("paths", paths_prop)
    props = props + RB()
    make_tool_schema_multi("simple_status", "Show project diagnostic overview with per-file error/warning counts", props, "[]", true, false, true)

# ============================================================================
# Handlers
# ============================================================================

fn handle_simple_read(id: text, body: text) -> text:
    val path = extract_arg(body, "path")
    if path == "":
        return make_error_response(id, -32602, "Missing required parameter: path")

    val show_hints_str = extract_arg(body, "show_hints")
    var show_hints = true
    if show_hints_str == "false":
        show_hints = false

    val fold_mode = extract_arg(body, "fold_mode")
    var fold = "compact"
    if fold_mode == "expanded":
        fold = "expanded"

    val offset_str = extract_arg(body, "offset")
    var offset = 1
    if offset_str != "":
        val or_result = parse_int(offset_str)
        match or_result:
            Ok(v): offset = v
            Err(_): pass

    val limit_str = extract_arg(body, "limit")
    var limit = 0
    if limit_str != "":
        val lr = parse_int(limit_str)
        match lr:
            Ok(v): limit = v
            Err(_): pass

    # Read source
    val source = file_read(path)
    if source == "":
        return make_error_response(id, -32602, "Could not read file: " + path)

    # Run diagnostics
    val diag = run_diagnostics(path)

    # Apply offset/limit to source
    val all_lines = source.split(NL)
    var display_source = source
    if offset > 1 or limit > 0:
        var selected_lines: [text] = []
        var li = 0
        for sl in all_lines:
            li = li + 1
            if li < offset:
                continue
            val over_limit = limit > 0 and li >= offset + limit
            if over_limit:
                break
            selected_lines.push(sl)
        display_source = ""
        var first_sel = true
        for sel in selected_lines:
            if not first_sel:
                display_source = display_source + NL
            first_sel = false
            display_source = display_source + sel

    # Overlay virtual text
    val annotated = overlay_virtual_text(display_source, diag.entries, show_hints, fold)

    # Build header
    var header = "-- " + path
    if diag.error_count > 0 or diag.warning_count > 0:
        header = header + " [" + diag.error_count.to_string() + "E " + diag.warning_count.to_string() + "W]"
    else:
        header = header + " [clean]"
    header = header + " --{NL}"

    # Build footer
    var footer = "-- " + diag.error_count.to_string() + " error(s), " + diag.warning_count.to_string() + " warning(s) --"

    val output = header + annotated + footer
    make_tool_result(id, output)

fn handle_simple_check(id: text, body: text) -> text:
    val path = extract_arg(body, "path")
    if path == "":
        return make_error_response(id, -32602, "Missing required parameter: path")

    val diag = run_diagnostics(path)
    val json = diag_result_to_json(diag)
    make_tool_result(id, json)

fn handle_simple_symbols(id: text, body: text) -> text:
    val path = extract_arg(body, "path")
    if path == "":
        return make_error_response(id, -32602, "Missing required parameter: path")

    val content = file_read(path)
    if content == "":
        return make_error_response(id, -32602, "Could not read file: " + path)

    val lines = content.split(NL)
    var symbols = "["
    var first = true
    var line_num = 0

    for line in lines:
        line_num = line_num + 1
        val trimmed = line.trim()

        var kind = ""
        var name = ""
        var signature = ""

        # Functions
        if trimmed.starts_with("fn "):
            kind = "function"
            val fn_rest = trimmed.substring(3)
            name = extract_symbol_name(fn_rest)
            signature = extract_signature(trimmed)
        elif trimmed.starts_with("me "):
            kind = "method"
            val me_rest = trimmed.substring(3)
            name = extract_symbol_name(me_rest)
            signature = extract_signature(trimmed)
        elif trimmed.starts_with("static fn "):
            kind = "static_method"
            val sf_rest = trimmed.substring(10)
            name = extract_symbol_name(sf_rest)
            signature = extract_signature(trimmed)
        # Classes and structs
        elif trimmed.starts_with("class "):
            kind = "class"
            val c_rest = trimmed.substring(6)
            name = extract_symbol_name(c_rest)
            signature = trimmed
        elif trimmed.starts_with("struct "):
            kind = "struct"
            val s_rest = trimmed.substring(7)
            name = extract_symbol_name(s_rest)
            signature = trimmed
        # Enums
        elif trimmed.starts_with("enum "):
            kind = "enum"
            val e_rest = trimmed.substring(5)
            name = extract_symbol_name(e_rest)
            signature = trimmed
        # Exports
        elif trimmed.starts_with("export "):
            kind = "export"
            name = trimmed.substring(7)
            signature = trimmed

        if kind != "" and name != "":
            if not first:
                symbols = symbols + ","
            first = false
            var sym_obj = LB()
            sym_obj = sym_obj + jp("name", js(escape_json(name)))
            sym_obj = sym_obj + "," + jp("kind", js(kind))
            sym_obj = sym_obj + "," + jp("line", line_num.to_string())
            sym_obj = sym_obj + "," + jp("signature", js(escape_json(signature)))
            sym_obj = sym_obj + RB()
            symbols = symbols + sym_obj

    symbols = symbols + "]"
    make_tool_result(id, symbols)

fn handle_simple_status(id: text, body: text) -> text:
    val paths_str = extract_arg(body, "paths")
    val directory = extract_arg(body, "directory")

    var file_list: [text] = []

    if paths_str != "":
        # Use provided paths
        val parts = paths_str.split(",")
        for part in parts:
            val trimmed = part.trim()
            if trimmed != "":
                file_list.push(trimmed)
    else:
        # Use jj diff to find recently changed files, fallback to directory scan
        val jj_result = shell("jj --no-pager --color never diff -r @ --stat 2>/dev/null")
        val jj_out = jj_result.stdout ?? ""
        if jj_out.trim() != "":
            val jj_lines = jj_out.split(NL)
            for jl in jj_lines:
                val jt = jl.trim()
                if jt.ends_with(".spl") or jt.contains(".spl "):
                    # Extract filename from stat line: "path/file.spl | N +++---"
                    val pipe_idx = jt.index_of(" |") ?? -1
                    if pipe_idx > 0:
                        val fname = jt.substring(0, pipe_idx).trim()
                        if fname.ends_with(".spl"):
                            file_list.push(fname)
                    elif jt.ends_with(".spl"):
                        file_list.push(jt)
        else:
            # Fallback: scan directory
            var scan_dir = "src/"
            if directory != "":
                scan_dir = directory
            val find_result = shell("find " + scan_dir + " -name '*.spl' -type f | sort | head -50")
            val find_out = find_result.stdout ?? ""
            if find_out.trim() != "":
                val find_lines = find_out.split(NL)
                for fl in find_lines:
                    val ft = fl.trim()
                    if ft != "":
                        file_list.push(ft)

    # Run diagnostics on each file
    var output = "-- Project Diagnostics --{NL}"
    var total_errors = 0
    var total_warnings = 0
    var file_count = 0

    for fpath in file_list:
        val diag = run_diagnostics(fpath)
        file_count = file_count + 1
        total_errors = total_errors + diag.error_count
        total_warnings = total_warnings + diag.warning_count

        var status_str = ""
        if diag.error_count == 0 and diag.warning_count == 0:
            status_str = "  " + fpath + "  0E 0W  clean{NL}"
        else:
            status_str = "  " + fpath + "  " + diag.error_count.to_string() + "E " + diag.warning_count.to_string() + "W{NL}"
        output = output + status_str

    output = output + "-- total: " + total_errors.to_string() + " error(s), " + total_warnings.to_string() + " warning(s) across " + file_count.to_string() + " file(s) --"

    make_tool_result(id, output)

# ============================================================================
# Symbol extraction helpers
# ============================================================================

fn extract_symbol_name(rest: text) -> text:
    # Extract name from "name(..." or "name:" or "name " etc.
    var name = ""
    for ch in rest:
        val is_delim = ch == "(" or ch == ":" or ch == " " or ch == "<"
        if is_delim:
            break
        name = name + ch
    name

fn extract_signature(line: text) -> text:
    # Return the line up to the colon at end (function header)
    val colon_idx = line.index_of(":") ?? -1
    if colon_idx > 0:
        return line.substring(0, colon_idx)
    line

# ============================================================================
# Argument extraction helper
# ============================================================================

# extract_arg now imported from lib.mcp

# ============================================================================
# Exports
# ============================================================================

export handle_simple_read, handle_simple_check, handle_simple_symbols, handle_simple_status
export schema_simple_read, schema_simple_check, schema_simple_symbols, schema_simple_status
