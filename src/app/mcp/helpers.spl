# MCP Helpers - Compatibility layer over MCP SDK
#
# Re-exports SDK functions under the same names used by downstream MCP modules.
# Keeps unique helper functions (notifications, content types, etc.) locally.

use app.io.mod (file_read, shell, cwd)
use std.text.{NL}

# --- SDK imports (replace local duplicate implementations) ---
use std.mcp_sdk.core.json.{LB, RB, Q, jp, js, jo1, jo2, jo3, escape_json, unwrap_idx, extract_json_string, extract_json_value, extract_nested_string}
use std.mcp_sdk.core.jsonrpc.{jsonrpc_result, jsonrpc_error}
use std.mcp_sdk.core.types.{make_tool_result}

# --- Compatibility wrappers (name mismatches with SDK) ---

fn extract_json_string_v2(json: String, key: String) -> String:
    extract_json_string(json, key)

fn make_result_response(id: String, result: String) -> String:
    jsonrpc_result(id, result)

fn make_error_response(id: String, code: Int, message: String) -> String:
    jsonrpc_error(id, code, message)

# --- Local-only helpers (not in SDK) ---

# Helper: parse integer from string
fn parse_int(s: String) -> Result<Int, String>:
    var result = 0
    var i = 0
    while i < s.len():
        val ch = s[i]
        if ch >= '0' and ch <= '9':
            result = result * 10 + (ch as int - '0' as int)
        else:
            return Err("Invalid digit: " + ch.to_string())
        i = i + 1
    Ok(result)

# Helper: minimum of two integers
fn min_int(a: Int, b: Int) -> Int:
    if a < b:
        a
    else:
        b

fn unwrap_str(result: Result<String, String>) -> String:
    match result:
        case Ok(s):
            return s
        case Err(_):
            return ""

# Skip program name and script path to get clean args
fn get_clean_args(all_args: [String]) -> [String]:
    var args = []
    var start_idx = 1
    if all_args.len() > 1 and all_args[1].ends_with(".spl"):
        start_idx = 2
    var i = start_idx
    while i < all_args.len():
        args = args + [all_args[i]]
        i = i + 1
    args

# --- Arguments dict extraction (local - returns Dict for mcp_jj compat) ---

fn extract_arguments_dict(body: String) -> Dict<String, String>:
    var result: Dict<String, String> = {}

    # Find params object
    val params_search = Q() + "params" + Q() + ":"
    val params_idx = unwrap_idx(body.index_of(params_search))
    if params_idx < 0:
        return result

    val params_start = params_idx + params_search.len()
    val params_section = body.substring(params_start)

    # Find arguments object within params
    val args_search = Q() + "arguments" + Q() + ":"
    val args_idx = unwrap_idx(params_section.index_of(args_search))
    if args_idx < 0:
        return result

    val args_start = args_idx + args_search.len()
    val after_args = params_section.substring(args_start)
    val trimmed = after_args.trim()

    # Extract content between braces
    if not trimmed.starts_with(LB()):
        return result

    # Find matching closing brace
    var brace_count = 0
    var idx = 0
    var args_content = ""

    for ch in trimmed:
        if ch == LB():
            brace_count = brace_count + 1
        else if ch == RB():
            brace_count = brace_count - 1
            if brace_count == 0:
                # Extract content between braces
                args_content = trimmed.substring(1, idx)
                break
        idx = idx + 1

    if args_content == "":
        return result

    # Parse key-value pairs from args_content
    val pairs = args_content.split(",")
    for pair in pairs:
        val colon_idx = unwrap_idx(pair.index_of(":"))
        if colon_idx >= 0:
            var key = pair.substring(0, colon_idx).trim()
            var value = pair.substring(colon_idx + 1).trim()

            # Remove quotes from key and value
            if key.starts_with(Q()):
                key = key.substring(1)
            if key.ends_with(Q()):
                key = key.substring(0, key.len() - 1)

            if value.starts_with(Q()):
                value = value.substring(1)
            if value.ends_with(Q()):
                value = value.substring(0, value.len() - 1)

            result[key] = value

    result

# --- File helpers ---

fn read_file_safe(path: String) -> String:
    val content = file_read(path)
    if content == "":
        return "Error: could not read file: " + path
    content

fn list_spl_files(dir: String) -> String:
    val result = shell("find " + dir + " -name '*.spl' -type f | sort")
    if result.exit_code != 0:
        var error = LB()
        error = error + jp("error", js("Failed to list files"))
        error = error + ","
        error = error + jp("directory", js(dir))
        error = error + RB()
        return error

    val output = result.stdout ?? ""
    if output.trim() == "":
        return "[]"

    val file_paths = output.split(NL)
    var files_json = "["
    var first = true

    for file_path in file_paths:
        val trimmed = file_path.trim()
        if trimmed != "":
            if not first:
                files_json = files_json + ","
            first = false

            var file_obj = LB()
            file_obj = file_obj + jp("path", js(trimmed))
            file_obj = file_obj + RB()
            files_json = files_json + file_obj

    files_json = files_json + "]"
    files_json

# --- Flag checking ---

fn has_flag(args: [String], flag: String) -> Bool:
    for arg in args:
        if arg == flag:
            return true
    return false

fn make_tool_schema_multi(name: String, desc: String, properties_json: String, required_json: String, read_only: Bool, destructive: Bool, idempotent: Bool) -> String:
    val schema = jo3(jp("type", js("object")), jp("properties", properties_json), jp("required", required_json))

    # Build annotations object
    var annot = LB()
    var ro = "false"
    if read_only:
        ro = "true"
    annot = annot + jp("readOnlyHint", ro)
    annot = annot + ","
    var dest = "false"
    if destructive:
        dest = "true"
    annot = annot + jp("destructiveHint", dest)
    annot = annot + ","
    var idemp = "false"
    if idempotent:
        idemp = "true"
    annot = annot + jp("idempotentHint", idemp)
    annot = annot + ","
    annot = annot + jp("openWorldHint", "false")
    annot = annot + RB()

    # Return tool schema with annotations
    var result = LB()
    result = result + jp("name", js(name))
    result = result + ","
    result = result + jp("description", js(desc))
    result = result + ","
    result = result + jp("inputSchema", schema)
    result = result + ","
    result = result + jp("annotations", annot)
    result = result + RB()
    result

# --- Notification helpers ---

fn make_notification(method: String, params: String) -> String:
    var r = LB()
    r = r + jp("jsonrpc", js("2.0"))
    r = r + "," + jp("method", js(method))
    r = r + "," + jp("params", params)
    r = r + RB()
    r

fn make_notification_no_params(method: String) -> String:
    jo2(jp("jsonrpc", js("2.0")), jp("method", js(method)))

fn make_progress_notification(token: String, progress: Int, total: Int, message: String) -> String:
    var params = LB()
    params = params + jp("progressToken", js(token))
    params = params + "," + jp("progress", progress.to_string())
    if total > 0:
        params = params + "," + jp("total", total.to_string())
    if message != "":
        params = params + "," + jp("message", js(escape_json(message)))
    params = params + RB()
    make_notification("notifications/progress", params)

# --- Log level utilities ---

fn log_level_to_int(level: String) -> Int:
    if level == "debug":
        return 0
    elif level == "info":
        return 1
    elif level == "notice":
        return 2
    elif level == "warning":
        return 3
    elif level == "error":
        return 4
    elif level == "critical":
        return 5
    elif level == "alert":
        return 6
    elif level == "emergency":
        return 7
    return -1

fn make_log_notification(level: String, data: String, logger: String) -> String:
    var params = LB()
    params = params + jp("level", js(level))
    params = params + "," + jp("data", js(escape_json(data)))
    if logger != "":
        params = params + "," + jp("logger", js(escape_json(logger)))
    params = params + RB()
    make_notification("notifications/message", params)

fn make_log_notification_raw(level: String, data_json: String, logger: String) -> String:
    var params = LB()
    params = params + jp("level", js(level))
    params = params + "," + jp("data", data_json)
    if logger != "":
        params = params + "," + jp("logger", js(escape_json(logger)))
    params = params + RB()
    make_notification("notifications/message", params)

# --- List changed notifications ---

fn make_tools_list_changed() -> String:
    make_notification_no_params("notifications/tools/list_changed")

fn make_resources_list_changed() -> String:
    make_notification_no_params("notifications/resources/list_changed")

fn make_prompts_list_changed() -> String:
    make_notification_no_params("notifications/prompts/list_changed")

# --- Resource subscription notifications ---

fn make_resource_updated_notification(uri: String) -> String:
    val params = jo1(jp("uri", js(escape_json(uri))))
    make_notification("notifications/resources/updated", params)

# --- Content type helpers ---

fn make_image_content(data: String, mime_type: String) -> String:
    var r = LB()
    r = r + jp("type", js("image"))
    r = r + "," + jp("data", js(data))
    r = r + "," + jp("mimeType", js(mime_type))
    r = r + RB()
    r

fn make_audio_content(data: String, mime_type: String) -> String:
    var r = LB()
    r = r + jp("type", js("audio"))
    r = r + "," + jp("data", js(data))
    r = r + "," + jp("mimeType", js(mime_type))
    r = r + RB()
    r

fn make_resource_link_content(uri: String, name: String) -> String:
    var r = LB()
    r = r + jp("type", js("resource_link"))
    r = r + "," + jp("uri", js(escape_json(uri)))
    r = r + "," + jp("name", js(escape_json(name)))
    r = r + RB()
    r

fn make_resource_link_content_full(uri: String, name: String, title: String, description: String, mime_type: String, size: Int) -> String:
    var r = LB()
    r = r + jp("type", js("resource_link"))
    r = r + "," + jp("uri", js(escape_json(uri)))
    r = r + "," + jp("name", js(escape_json(name)))
    if title != "":
        r = r + "," + jp("title", js(escape_json(title)))
    if description != "":
        r = r + "," + jp("description", js(escape_json(description)))
    if mime_type != "":
        r = r + "," + jp("mimeType", js(mime_type))
    if size >= 0:
        r = r + "," + jp("size", size.to_string())
    r = r + RB()
    r

fn make_embedded_resource_content(uri: String, text_content: String, mime_type: String) -> String:
    var resource = LB()
    resource = resource + jp("uri", js(escape_json(uri)))
    resource = resource + "," + jp("text", js(escape_json(text_content)))
    if mime_type != "":
        resource = resource + "," + jp("mimeType", js(mime_type))
    resource = resource + RB()
    jo2(jp("type", js("resource")), jp("resource", resource))

fn make_content_annotations(audience: [String], priority: String, last_modified: String) -> String:
    var r = LB()
    var first = true
    if audience.len() > 0:
        var arr = "["
        var af = true
        for a in audience:
            if not af:
                arr = arr + ","
            af = false
            arr = arr + js(a)
        arr = arr + "]"
        r = r + jp("audience", arr)
        first = false
    if priority != "":
        if not first:
            r = r + ","
        r = r + jp("priority", priority)
        first = false
    if last_modified != "":
        if not first:
            r = r + ","
        r = r + jp("lastModified", js(last_modified))
    r = r + RB()
    r

fn make_tool_result_with_structured(id: String, content: String, structured_content: String) -> String:
    val text_obj = jo2(jp("type", js("text")), jp("text", js(escape_json(content))))
    var result = LB()
    result = result + jp("content", "[" + text_obj + "]")
    result = result + "," + jp("structuredContent", structured_content)
    result = result + RB()
    jo3(jp("jsonrpc", js("2.0")), jp("id", id), jp("result", result))

fn make_tool_schema_with_output(name: String, desc: String, properties_json: String, required_json: String, output_schema: String, read_only: Bool, destructive: Bool, idempotent: Bool) -> String:
    val schema = jo3(jp("type", js("object")), jp("properties", properties_json), jp("required", required_json))

    var annot = LB()
    var ro = "false"
    if read_only:
        ro = "true"
    annot = annot + jp("readOnlyHint", ro)
    annot = annot + ","
    var dest = "false"
    if destructive:
        dest = "true"
    annot = annot + jp("destructiveHint", dest)
    annot = annot + ","
    var idemp = "false"
    if idempotent:
        idemp = "true"
    annot = annot + jp("idempotentHint", idemp)
    annot = annot + ","
    annot = annot + jp("openWorldHint", "false")
    annot = annot + RB()

    var result = LB()
    result = result + jp("name", js(name))
    result = result + ","
    result = result + jp("description", js(desc))
    result = result + ","
    result = result + jp("inputSchema", schema)
    result = result + ","
    result = result + jp("outputSchema", output_schema)
    result = result + ","
    result = result + jp("annotations", annot)
    result = result + RB()
    result

# --- Server-to-client request helpers ---

fn make_server_request(id: String, method: String, params: String) -> String:
    var r = LB()
    r = r + jp("jsonrpc", js("2.0"))
    r = r + "," + jp("id", id)
    r = r + "," + jp("method", js(method))
    r = r + "," + jp("params", params)
    r = r + RB()
    r

fn make_sampling_request(id: String, messages: String, model_prefs: String, system_prompt: String, max_tokens: Int) -> String:
    var params = LB()
    params = params + jp("messages", messages)
    if model_prefs != "":
        params = params + "," + jp("modelPreferences", model_prefs)
    if system_prompt != "":
        params = params + "," + jp("systemPrompt", js(escape_json(system_prompt)))
    params = params + "," + jp("maxTokens", max_tokens.to_string())
    params = params + RB()
    make_server_request(id, "sampling/createMessage", params)

fn make_sampling_request_full(id: String, messages: String, model_prefs: String, system_prompt: String, max_tokens: Int, temperature: String, stop_sequences_json: String, metadata_json: String, include_context: String) -> String:
    var params = LB()
    params = params + jp("messages", messages)
    if model_prefs != "":
        params = params + "," + jp("modelPreferences", model_prefs)
    if system_prompt != "":
        params = params + "," + jp("systemPrompt", js(escape_json(system_prompt)))
    params = params + "," + jp("maxTokens", max_tokens.to_string())
    if temperature != "":
        params = params + "," + jp("temperature", temperature)
    if stop_sequences_json != "" and stop_sequences_json != "[]":
        params = params + "," + jp("stopSequences", stop_sequences_json)
    if metadata_json != "":
        params = params + "," + jp("metadata", metadata_json)
    if include_context != "":
        params = params + "," + jp("includeContext", js(include_context))
    params = params + RB()
    make_server_request(id, "sampling/createMessage", params)

fn make_elicitation_request(id: String, message: String, schema: String) -> String:
    var params = LB()
    params = params + jp("message", js(escape_json(message)))
    params = params + "," + jp("requestedSchema", schema)
    params = params + RB()
    make_server_request(id, "elicitation/create", params)

# --- Tool registration helper ---

fn register_tool(name: String, desc: String, param_names: [String], param_descs: [String], required_names: [String], read_only: Bool, destructive: Bool, idempotent: Bool) -> String:
    var props = LB()
    var first_prop = true
    var i = 0
    for pname in param_names:
        if not first_prop:
            props = props + ","
        first_prop = false
        var pdesc = ""
        if i < param_descs.len():
            pdesc = param_descs[i]
        val prop = jo2(jp("type", js("string")), jp("description", js(pdesc)))
        props = props + jp(pname, prop)
        i = i + 1
    props = props + RB()

    var req_arr = "["
    var first_req = true
    for rname in required_names:
        if not first_req:
            req_arr = req_arr + ","
        first_req = false
        req_arr = req_arr + js(rname)
    req_arr = req_arr + "]"

    make_tool_schema_multi(name, desc, props, req_arr, read_only, destructive, idempotent)

# --- Content type detection helpers ---

fn detect_file_content_type(path: String) -> String:
    if path.ends_with(".png") or path.ends_with(".jpg") or path.ends_with(".jpeg") or path.ends_with(".gif") or path.ends_with(".svg") or path.ends_with(".webp") or path.ends_with(".ico") or path.ends_with(".bmp"):
        return "image"
    if path.ends_with(".wav") or path.ends_with(".mp3") or path.ends_with(".ogg") or path.ends_with(".flac"):
        return "audio"
    "text"

fn detect_mime_type(path: String) -> String:
    if path.ends_with(".png"):
        return "image/png"
    if path.ends_with(".jpg") or path.ends_with(".jpeg"):
        return "image/jpeg"
    if path.ends_with(".gif"):
        return "image/gif"
    if path.ends_with(".svg"):
        return "image/svg+xml"
    if path.ends_with(".webp"):
        return "image/webp"
    if path.ends_with(".ico"):
        return "image/x-icon"
    if path.ends_with(".bmp"):
        return "image/bmp"
    if path.ends_with(".wav"):
        return "audio/wav"
    if path.ends_with(".mp3"):
        return "audio/mpeg"
    if path.ends_with(".ogg"):
        return "audio/ogg"
    if path.ends_with(".flac"):
        return "audio/flac"
    if path.ends_with(".spl"):
        return "text/x-simple"
    if path.ends_with(".json"):
        return "application/json"
    if path.ends_with(".md"):
        return "text/markdown"
    if path.ends_with(".html"):
        return "text/html"
    if path.ends_with(".css"):
        return "text/css"
    if path.ends_with(".js"):
        return "text/javascript"
    "text/plain"

# --- Send notification over stdio ---

fn send_notification_message(notification: String):
    var header = "Content-Length: "
    header = header + notification.len().to_string()
    header = header + "\r{NL}\r{NL}"
    print_raw(header)
    print_raw(notification)

fn send_log(level: String, data: String, logger: String, current_log_level: Int):
    val msg_level = log_level_to_int(level)
    if current_log_level < 0:
        return
    if msg_level < current_log_level:
        return
    val notification = make_log_notification(level, data, logger)
    send_notification_message(notification)

fn send_progress(token: String, progress: Int, total: Int, message: String):
    val notification = make_progress_notification(token, progress, total, message)
    send_notification_message(notification)

fn send_resource_updated(uri: String):
    val notification = make_resource_updated_notification(uri)
    send_notification_message(notification)

# --- Exports (unchanged API surface) ---

export LB, RB, Q
export parse_int, min_int, unwrap_idx, unwrap_str
export get_clean_args
export jp, js, jo1, jo2, jo3
export extract_json_string_v2, extract_json_string, extract_json_value, extract_nested_string, extract_arguments_dict
export escape_json
export read_file_safe, list_spl_files
export make_tool_result, make_result_response, make_error_response
export make_tool_schema_multi
export has_flag
# Notification helpers
export make_notification, make_notification_no_params, make_progress_notification
export log_level_to_int, make_log_notification
export make_tools_list_changed, make_resources_list_changed, make_prompts_list_changed
export make_resource_updated_notification
# Content type helpers
export make_image_content, make_audio_content, make_resource_link_content, make_resource_link_content_full
export make_embedded_resource_content, make_content_annotations
export make_tool_result_with_structured, make_tool_schema_with_output
# Server-to-client request helpers
export make_server_request, make_sampling_request, make_sampling_request_full, make_elicitation_request
# Raw JSON variants
export make_log_notification_raw
# Send helpers (stdio framed)
export send_notification_message, send_log, send_progress, send_resource_updated
# Tool registration helper
export register_tool
# Content type detection
export detect_file_content_type, detect_mime_type
