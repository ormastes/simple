# MCP Helpers - Compatibility layer over MCP SDK
#
# Re-exports SDK functions under the same names used by downstream MCP modules.
# Keeps unique helper functions (notifications, content types, etc.) locally.

use app.io.file_ops.{file_read}
use app.io.process_ops.{shell}
use std.text.{NL}

# --- SDK imports (replace local duplicate implementations) ---
use std.mcp_sdk.core.json.{jo1, jo2, jo3, escape_json, unwrap_idx, extract_json_string, extract_json_value, extract_nested_string}
use std.mcp_sdk.core.jsonrpc.{jsonrpc_result, jsonrpc_error}
use std.mcp_sdk.core.types.{make_tool_result}

# Local definitions (runtime can't re-export imported symbols)
fn LB() -> text:
    (123 as char).to_string()

fn RB() -> text:
    (125 as char).to_string()

fn Q() -> text:
    "\""

fn jp(key: text, value: text) -> text:
    Q() + key + Q() + ":" + value

fn js(value: text) -> text:
    Q() + escape_json(value) + Q()

# --- Compatibility wrappers (name mismatches with SDK) ---

fn extract_json_string_v2(json: String, key: String) -> String:
    extract_json_string(json, key)

fn make_result_response(id: String, result: String) -> String:
    jsonrpc_result(id, result)

fn make_error_response(id: String, code: Int, message: String) -> String:
    jsonrpc_error(id, code, message)

# --- Local-only helpers (not in SDK) ---

# Helper: parse integer from string
fn parse_int(s: String) -> Result<Int, String>:
    var result = 0
    var i = 0
    while i < s.len():
        val ch = s[i]
        if ch >= '0' and ch <= '9':
            result = result * 10 + (ch as int - '0' as int)
        else:
            return Err("Invalid digit: " + ch.to_string())
        i = i + 1
    Ok(result)

# Helper: minimum of two integers
fn min_int(a: Int, b: Int) -> Int:
    if a < b:
        a
    else:
        b

fn unwrap_str(result: Result<String, String>) -> String:
    match result:
        case Ok(s):
            return s
        case Err(_):
            return ""

# Skip program name and script path to get clean args
fn get_clean_args(all_args: [String]) -> [String]:
    var args = []
    var start_idx = 1
    if all_args.len() > 1 and all_args[1].ends_with(".spl"):
        start_idx = 2
    var i = start_idx
    while i < all_args.len():
        args = args + [all_args[i]]
        i = i + 1
    args

# --- Arguments dict extraction (local - returns Dict for mcp_jj compat) ---

fn extract_arguments_dict(body: String) -> Dict<String, String>:
    var result: Dict<String, String> = {}

    # Find params object
    val params_search = Q() + "params" + Q() + ":"
    val params_idx = unwrap_idx(body.index_of(params_search))
    if params_idx < 0:
        return result

    val params_start = params_idx + params_search.len()
    val params_section = body.substring(params_start)

    # Find arguments object within params
    val args_search = Q() + "arguments" + Q() + ":"
    val args_idx = unwrap_idx(params_section.index_of(args_search))
    if args_idx < 0:
        return result

    val args_start = args_idx + args_search.len()
    val after_args = params_section.substring(args_start)
    val trimmed = after_args.trim()

    # Extract content between braces
    if not trimmed.starts_with(LB()):
        return result

    # Find matching closing brace
    var brace_count = 0
    var idx = 0
    var args_content = ""

    for ch in trimmed:
        if ch == LB():
            brace_count = brace_count + 1
        else if ch == RB():
            brace_count = brace_count - 1
            if brace_count == 0:
                # Extract content between braces
                args_content = trimmed.substring(1, idx)
                break
        idx = idx + 1

    if args_content == "":
        return result

    # Parse key-value pairs from args_content
    val pairs = args_content.split(",")
    for pair in pairs:
        val colon_idx = unwrap_idx(pair.index_of(":"))
        if colon_idx >= 0:
            var key = pair.substring(0, colon_idx).trim()
            var value = pair.substring(colon_idx + 1).trim()

            # Remove quotes from key and value
            if key.starts_with(Q()):
                key = key.substring(1)
            if key.ends_with(Q()):
                key = key.substring(0, key.len() - 1)

            if value.starts_with(Q()):
                value = value.substring(1)
            if value.ends_with(Q()):
                value = value.substring(0, value.len() - 1)

            result[key] = value

    result

# --- File helpers ---

fn read_file_safe(path: String) -> String:
    val content = file_read(path)
    if content == "":
        return "Error: could not read file: " + path
    content

fn list_spl_files(dir: String) -> String:
    val result = shell("find " + dir + " -name '*.spl' -type f | sort")
    if result.exit_code != 0:
        var parts: [text] = []
        parts.push(LB())
        parts.push(jp("error", js("Failed to list files")))
        parts.push(",")
        parts.push(jp("directory", js(dir)))
        parts.push(RB())
        return parts.join("")

    val output = result.stdout ?? ""
    if output.trim() == "":
        return "[]"

    val file_paths = output.split(NL)
    var file_parts: [text] = []

    for file_path in file_paths:
        val trimmed = file_path.trim()
        if trimmed != "":
            var obj_parts: [text] = []
            obj_parts.push(LB())
            obj_parts.push(jp("path", js(trimmed)))
            obj_parts.push(RB())
            file_parts.push(obj_parts.join(""))

    "[" + file_parts.join(",") + "]"

# --- Flag checking ---

fn has_flag(args: [String], flag: String) -> Bool:
    for arg in args:
        if arg == flag:
            return true
    return false

fn make_tool_schema_multi(name: String, desc: String, properties_json: String, required_json: String, read_only: Bool, destructive: Bool, idempotent: Bool) -> String:
    val schema = jo3(jp("type", js("object")), jp("properties", properties_json), jp("required", required_json))

    # Build annotations object
    var annot_parts: [text] = []
    annot_parts.push(LB())
    var ro = "false"
    if read_only:
        ro = "true"
    annot_parts.push(jp("readOnlyHint", ro))
    annot_parts.push(",")
    var dest = "false"
    if destructive:
        dest = "true"
    annot_parts.push(jp("destructiveHint", dest))
    annot_parts.push(",")
    var idemp = "false"
    if idempotent:
        idemp = "true"
    annot_parts.push(jp("idempotentHint", idemp))
    annot_parts.push(",")
    annot_parts.push(jp("openWorldHint", "false"))
    annot_parts.push(RB())
    val annot = annot_parts.join("")

    # Return tool schema with annotations
    var parts: [text] = []
    parts.push(LB())
    parts.push(jp("name", js(name)))
    parts.push(",")
    parts.push(jp("description", js(desc)))
    parts.push(",")
    parts.push(jp("inputSchema", schema))
    parts.push(",")
    parts.push(jp("annotations", annot))
    parts.push(RB())
    parts.join("")

# --- Notification helpers ---

fn make_notification(method: String, params: String) -> String:
    var parts: [text] = []
    parts.push(LB())
    parts.push(jp("jsonrpc", js("2.0")))
    parts.push(",")
    parts.push(jp("method", js(method)))
    parts.push(",")
    parts.push(jp("params", params))
    parts.push(RB())
    parts.join("")

fn make_notification_no_params(method: String) -> String:
    jo2(jp("jsonrpc", js("2.0")), jp("method", js(method)))

fn make_progress_notification(token: String, progress: Int, total: Int, message: String) -> String:
    var parts: [text] = []
    parts.push(LB())
    parts.push(jp("progressToken", js(token)))
    parts.push(",")
    parts.push(jp("progress", progress.to_string()))
    if total > 0:
        parts.push(",")
        parts.push(jp("total", total.to_string()))
    if message != "":
        parts.push(",")
        parts.push(jp("message", js(escape_json(message))))
    parts.push(RB())
    make_notification("notifications/progress", parts.join(""))

# --- Log level utilities ---

fn log_level_to_int(level: String) -> Int:
    if level == "debug":
        return 0
    elif level == "info":
        return 1
    elif level == "notice":
        return 2
    elif level == "warning":
        return 3
    elif level == "error":
        return 4
    elif level == "critical":
        return 5
    elif level == "alert":
        return 6
    elif level == "emergency":
        return 7
    return -1

fn make_log_notification(level: String, data: String, logger: String) -> String:
    var parts: [text] = []
    parts.push(LB())
    parts.push(jp("level", js(level)))
    parts.push(",")
    parts.push(jp("data", js(escape_json(data))))
    if logger != "":
        parts.push(",")
        parts.push(jp("logger", js(escape_json(logger))))
    parts.push(RB())
    make_notification("notifications/message", parts.join(""))

fn make_log_notification_raw(level: String, data_json: String, logger: String) -> String:
    var parts: [text] = []
    parts.push(LB())
    parts.push(jp("level", js(level)))
    parts.push(",")
    parts.push(jp("data", data_json))
    if logger != "":
        parts.push(",")
        parts.push(jp("logger", js(escape_json(logger))))
    parts.push(RB())
    make_notification("notifications/message", parts.join(""))

# --- List changed notifications ---

fn make_tools_list_changed() -> String:
    make_notification_no_params("notifications/tools/list_changed")

fn make_resources_list_changed() -> String:
    make_notification_no_params("notifications/resources/list_changed")

fn make_prompts_list_changed() -> String:
    make_notification_no_params("notifications/prompts/list_changed")

# --- Resource subscription notifications ---

fn make_resource_updated_notification(uri: String) -> String:
    val params = jo1(jp("uri", js(escape_json(uri))))
    make_notification("notifications/resources/updated", params)

# --- Content type helpers ---

fn make_image_content(data: String, mime_type: String) -> String:
    var parts: [text] = []
    parts.push(LB())
    parts.push(jp("type", js("image")))
    parts.push(",")
    parts.push(jp("data", js(data)))
    parts.push(",")
    parts.push(jp("mimeType", js(mime_type)))
    parts.push(RB())
    parts.join("")

fn make_audio_content(data: String, mime_type: String) -> String:
    var parts: [text] = []
    parts.push(LB())
    parts.push(jp("type", js("audio")))
    parts.push(",")
    parts.push(jp("data", js(data)))
    parts.push(",")
    parts.push(jp("mimeType", js(mime_type)))
    parts.push(RB())
    parts.join("")

fn make_resource_link_content(uri: String, name: String) -> String:
    var parts: [text] = []
    parts.push(LB())
    parts.push(jp("type", js("resource_link")))
    parts.push(",")
    parts.push(jp("uri", js(escape_json(uri))))
    parts.push(",")
    parts.push(jp("name", js(escape_json(name))))
    parts.push(RB())
    parts.join("")

fn make_resource_link_content_full(uri: String, name: String, title: String, description: String, mime_type: String, size: Int) -> String:
    var parts: [text] = []
    parts.push(LB())
    parts.push(jp("type", js("resource_link")))
    parts.push(",")
    parts.push(jp("uri", js(escape_json(uri))))
    parts.push(",")
    parts.push(jp("name", js(escape_json(name))))
    if title != "":
        parts.push(",")
        parts.push(jp("title", js(escape_json(title))))
    if description != "":
        parts.push(",")
        parts.push(jp("description", js(escape_json(description))))
    if mime_type != "":
        parts.push(",")
        parts.push(jp("mimeType", js(mime_type)))
    if size >= 0:
        parts.push(",")
        parts.push(jp("size", size.to_string()))
    parts.push(RB())
    parts.join("")

fn make_embedded_resource_content(uri: String, text_content: String, mime_type: String) -> String:
    var parts: [text] = []
    parts.push(LB())
    parts.push(jp("uri", js(escape_json(uri))))
    parts.push(",")
    parts.push(jp("text", js(escape_json(text_content))))
    if mime_type != "":
        parts.push(",")
        parts.push(jp("mimeType", js(mime_type)))
    parts.push(RB())
    jo2(jp("type", js("resource")), jp("resource", parts.join("")))

fn make_content_annotations(audience: [String], priority: String, last_modified: String) -> String:
    var parts: [text] = []
    parts.push(LB())
    var first = true
    if audience.len() > 0:
        var arr_parts: [text] = []
        for a in audience:
            arr_parts.push(js(a))
        val arr = "[" + arr_parts.join(",") + "]"
        parts.push(jp("audience", arr))
        first = false
    if priority != "":
        if not first:
            parts.push(",")
        parts.push(jp("priority", priority))
        first = false
    if last_modified != "":
        if not first:
            parts.push(",")
        parts.push(jp("lastModified", js(last_modified)))
    parts.push(RB())
    parts.join("")

fn make_tool_result_with_structured(id: String, content: String, structured_content: String) -> String:
    val text_obj = jo2(jp("type", js("text")), jp("text", js(escape_json(content))))
    var parts: [text] = []
    parts.push(LB())
    parts.push(jp("content", "[" + text_obj + "]"))
    parts.push(",")
    parts.push(jp("structuredContent", structured_content))
    parts.push(RB())
    jo3(jp("jsonrpc", js("2.0")), jp("id", id), jp("result", parts.join("")))

fn make_tool_schema_with_output(name: String, desc: String, properties_json: String, required_json: String, output_schema: String, read_only: Bool, destructive: Bool, idempotent: Bool) -> String:
    val schema = jo3(jp("type", js("object")), jp("properties", properties_json), jp("required", required_json))

    var annot_parts: [text] = []
    annot_parts.push(LB())
    var ro = "false"
    if read_only:
        ro = "true"
    annot_parts.push(jp("readOnlyHint", ro))
    annot_parts.push(",")
    var dest = "false"
    if destructive:
        dest = "true"
    annot_parts.push(jp("destructiveHint", dest))
    annot_parts.push(",")
    var idemp = "false"
    if idempotent:
        idemp = "true"
    annot_parts.push(jp("idempotentHint", idemp))
    annot_parts.push(",")
    annot_parts.push(jp("openWorldHint", "false"))
    annot_parts.push(RB())
    val annot = annot_parts.join("")

    var parts: [text] = []
    parts.push(LB())
    parts.push(jp("name", js(name)))
    parts.push(",")
    parts.push(jp("description", js(desc)))
    parts.push(",")
    parts.push(jp("inputSchema", schema))
    parts.push(",")
    parts.push(jp("outputSchema", output_schema))
    parts.push(",")
    parts.push(jp("annotations", annot))
    parts.push(RB())
    parts.join("")

# --- Server-to-client request helpers ---

fn make_server_request(id: String, method: String, params: String) -> String:
    var parts: [text] = []
    parts.push(LB())
    parts.push(jp("jsonrpc", js("2.0")))
    parts.push(",")
    parts.push(jp("id", id))
    parts.push(",")
    parts.push(jp("method", js(method)))
    parts.push(",")
    parts.push(jp("params", params))
    parts.push(RB())
    parts.join("")

fn make_sampling_request(id: String, messages: String, model_prefs: String, system_prompt: String, max_tokens: Int) -> String:
    var parts: [text] = []
    parts.push(LB())
    parts.push(jp("messages", messages))
    if model_prefs != "":
        parts.push(",")
        parts.push(jp("modelPreferences", model_prefs))
    if system_prompt != "":
        parts.push(",")
        parts.push(jp("systemPrompt", js(escape_json(system_prompt))))
    parts.push(",")
    parts.push(jp("maxTokens", max_tokens.to_string()))
    parts.push(RB())
    make_server_request(id, "sampling/createMessage", parts.join(""))

fn make_sampling_request_full(id: String, messages: String, model_prefs: String, system_prompt: String, max_tokens: Int, temperature: String, stop_sequences_json: String, metadata_json: String, include_context: String) -> String:
    var parts: [text] = []
    parts.push(LB())
    parts.push(jp("messages", messages))
    if model_prefs != "":
        parts.push(",")
        parts.push(jp("modelPreferences", model_prefs))
    if system_prompt != "":
        parts.push(",")
        parts.push(jp("systemPrompt", js(escape_json(system_prompt))))
    parts.push(",")
    parts.push(jp("maxTokens", max_tokens.to_string()))
    if temperature != "":
        parts.push(",")
        parts.push(jp("temperature", temperature))
    if stop_sequences_json != "" and stop_sequences_json != "[]":
        parts.push(",")
        parts.push(jp("stopSequences", stop_sequences_json))
    if metadata_json != "":
        parts.push(",")
        parts.push(jp("metadata", metadata_json))
    if include_context != "":
        parts.push(",")
        parts.push(jp("includeContext", js(include_context)))
    parts.push(RB())
    make_server_request(id, "sampling/createMessage", parts.join(""))

fn make_elicitation_request(id: String, message: String, schema: String) -> String:
    var parts: [text] = []
    parts.push(LB())
    parts.push(jp("message", js(escape_json(message))))
    parts.push(",")
    parts.push(jp("requestedSchema", schema))
    parts.push(RB())
    make_server_request(id, "elicitation/create", parts.join(""))

# --- Tool registration helper ---

fn register_tool(name: String, desc: String, param_names: [String], param_descs: [String], required_names: [String], read_only: Bool, destructive: Bool, idempotent: Bool) -> String:
    var prop_parts: [text] = []
    var i = 0
    for pname in param_names:
        var pdesc = ""
        if i < param_descs.len():
            pdesc = param_descs[i]
        val prop = jo2(jp("type", js("string")), jp("description", js(pdesc)))
        prop_parts.push(jp(pname, prop))
        i = i + 1
    val props = LB() + prop_parts.join(",") + RB()

    var req_parts: [text] = []
    for rname in required_names:
        req_parts.push(js(rname))
    val req_arr = "[" + req_parts.join(",") + "]"

    make_tool_schema_multi(name, desc, props, req_arr, read_only, destructive, idempotent)

# --- Content type detection helpers ---

fn detect_file_content_type(path: String) -> String:
    if path.ends_with(".png") or path.ends_with(".jpg") or path.ends_with(".jpeg") or path.ends_with(".gif") or path.ends_with(".svg") or path.ends_with(".webp") or path.ends_with(".ico") or path.ends_with(".bmp"):
        return "image"
    if path.ends_with(".wav") or path.ends_with(".mp3") or path.ends_with(".ogg") or path.ends_with(".flac"):
        return "audio"
    "text"

fn detect_mime_type(path: String) -> String:
    if path.ends_with(".png"):
        return "image/png"
    if path.ends_with(".jpg") or path.ends_with(".jpeg"):
        return "image/jpeg"
    if path.ends_with(".gif"):
        return "image/gif"
    if path.ends_with(".svg"):
        return "image/svg+xml"
    if path.ends_with(".webp"):
        return "image/webp"
    if path.ends_with(".ico"):
        return "image/x-icon"
    if path.ends_with(".bmp"):
        return "image/bmp"
    if path.ends_with(".wav"):
        return "audio/wav"
    if path.ends_with(".mp3"):
        return "audio/mpeg"
    if path.ends_with(".ogg"):
        return "audio/ogg"
    if path.ends_with(".flac"):
        return "audio/flac"
    if path.ends_with(".spl"):
        return "text/x-simple"
    if path.ends_with(".json"):
        return "application/json"
    if path.ends_with(".md"):
        return "text/markdown"
    if path.ends_with(".html"):
        return "text/html"
    if path.ends_with(".css"):
        return "text/css"
    if path.ends_with(".js"):
        return "text/javascript"
    "text/plain"

# --- Send notification over stdio ---

fn send_notification_message(notification: String):
    var parts: [text] = []
    parts.push("Content-Length: ")
    parts.push(notification.len().to_string())
    parts.push("\r{NL}\r{NL}")
    print_raw(parts.join(""))
    print_raw(notification)

fn send_log(level: String, data: String, logger: String, current_log_level: Int):
    val msg_level = log_level_to_int(level)
    if current_log_level < 0:
        return
    if msg_level < current_log_level:
        return
    val notification = make_log_notification(level, data, logger)
    send_notification_message(notification)

fn send_progress(token: String, progress: Int, total: Int, message: String):
    val notification = make_progress_notification(token, progress, total, message)
    send_notification_message(notification)

fn send_resource_updated(uri: String):
    val notification = make_resource_updated_notification(uri)
    send_notification_message(notification)

# --- Single-property tool schema builder ---

fn make_tool_schema(name: String, desc: String, prop_name: String, prop_desc: String, required: Bool, read_only: Bool, destructive: Bool, idempotent: Bool) -> String:
    val prop = jo2(jp("type", js("string")), jp("description", js(desc)))
    val props = jo1(jp(prop_name, prop))
    var req_arr = "[]"
    if required:
        req_arr = "[" + js(prop_name) + "]"
    val schema = jo3(jp("type", js("object")), jp("properties", props), jp("required", req_arr))

    var annot_parts: [text] = []
    annot_parts.push(LB())
    var ro = "false"
    if read_only:
        ro = "true"
    annot_parts.push(jp("readOnlyHint", ro))
    annot_parts.push(",")
    var dest = "false"
    if destructive:
        dest = "true"
    annot_parts.push(jp("destructiveHint", dest))
    annot_parts.push(",")
    var idemp = "false"
    if idempotent:
        idemp = "true"
    annot_parts.push(jp("idempotentHint", idemp))
    annot_parts.push(",")
    annot_parts.push(jp("openWorldHint", "false"))
    annot_parts.push(RB())
    val annot = annot_parts.join("")

    var parts: [text] = []
    parts.push(LB())
    parts.push(jp("name", js(name)))
    parts.push(",")
    parts.push(jp("description", js(escape_json(desc))))
    parts.push(",")
    parts.push(jp("inputSchema", schema))
    parts.push(",")
    parts.push(jp("annotations", annot))
    parts.push(RB())
    parts.join("")

fn make_no_param_tool(name: String, desc: String, read_only: Bool, destructive: Bool, idempotent: Bool) -> String:
    val schema = jo2(jp("type", js("object")), jp("properties", LB() + RB()))

    var annot_parts: [text] = []
    annot_parts.push(LB())
    var ro = "false"
    if read_only:
        ro = "true"
    annot_parts.push(jp("readOnlyHint", ro))
    annot_parts.push(",")
    var dest = "false"
    if destructive:
        dest = "true"
    annot_parts.push(jp("destructiveHint", dest))
    annot_parts.push(",")
    var idemp = "false"
    if idempotent:
        idemp = "true"
    annot_parts.push(jp("idempotentHint", idemp))
    annot_parts.push(",")
    annot_parts.push(jp("openWorldHint", "false"))
    annot_parts.push(RB())
    val annot = annot_parts.join("")

    var parts: [text] = []
    parts.push(LB())
    parts.push(jp("name", js(name)))
    parts.push(",")
    parts.push(jp("description", js(escape_json(desc))))
    parts.push(",")
    parts.push(jp("inputSchema", schema))
    parts.push(",")
    parts.push(jp("annotations", annot))
    parts.push(RB())
    parts.join("")

fn make_prop(name: String, desc: String) -> String:
    jp(name, jo2(jp("type", js("string")), jp("description", js(escape_json(desc)))))

fn make_prop_bool(name: String, desc: String) -> String:
    jp(name, jo2(jp("type", js("boolean")), jp("description", js(escape_json(desc)))))

fn make_prop_int(name: String, desc: String) -> String:
    jp(name, jo2(jp("type", js("integer")), jp("description", js(escape_json(desc)))))

# --- Exports (unchanged API surface) ---

export LB, RB, Q
export parse_int, min_int, unwrap_idx, unwrap_str
export get_clean_args
export jp, js, jo1, jo2, jo3
export extract_json_string_v2, extract_json_string, extract_json_value, extract_nested_string, extract_arguments_dict
export escape_json
export read_file_safe, list_spl_files
export make_tool_result, make_result_response, make_error_response
export make_tool_schema_multi
export has_flag
# Notification helpers
export make_notification, make_notification_no_params, make_progress_notification
export log_level_to_int, make_log_notification
export make_tools_list_changed, make_resources_list_changed, make_prompts_list_changed
export make_resource_updated_notification
# Content type helpers
export make_image_content, make_audio_content, make_resource_link_content, make_resource_link_content_full
export make_embedded_resource_content, make_content_annotations
export make_tool_result_with_structured, make_tool_schema_with_output
# Server-to-client request helpers
export make_server_request, make_sampling_request, make_sampling_request_full, make_elicitation_request
# Raw JSON variants
export make_log_notification_raw
# Send helpers (stdio framed)
export send_notification_message, send_log, send_progress, send_resource_updated
# Tool registration helper
export register_tool
# Content type detection
export detect_file_content_type, detect_mime_type
# Single-property tool schema builders
export make_tool_schema, make_no_param_tool, make_prop, make_prop_bool, make_prop_int
