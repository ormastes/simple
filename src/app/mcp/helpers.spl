# MCP Helpers - Shared utility functions for MCP server
#
# Extracted from main.spl to enable reuse and reduce duplication.
# Provides JSON building, string escaping, arg parsing, and response makers.

use app.io.mod (file_read, shell, cwd)
use lib.json.builder.{escape_json}

# Brace helpers (avoid f-string interpolation issues)
fn LB() -> String:
    (123 as char).to_string()

fn RB() -> String:
    (125 as char).to_string()

fn Q() -> String:
    "\""

# Helper: parse integer from string
fn parse_int(s: String) -> Result<Int, String>:
    var result = 0
    var i = 0
    while i < s.len():
        val ch = s[i]
        if ch >= '0' and ch <= '9':
            result = result * 10 + (ch as int - '0' as int)
        else:
            return Err("Invalid digit: " + ch.to_string())
        i = i + 1
    Ok(result)

# Helper: minimum of two integers
fn min_int(a: Int, b: Int) -> Int:
    if a < b:
        a
    else:
        b

# Option unwrap helper
fn unwrap_idx(opt: Option<Int>) -> Int:
    match opt:
        case Some(i):
            return i
        case None:
            return -1

fn unwrap_str(result: Result<String, String>) -> String:
    match result:
        case Ok(s):
            return s
        case Err(_):
            return ""

# Skip program name and script path to get clean args
fn get_clean_args(all_args: [String]) -> [String]:
    var args = []
    var start_idx = 1
    if all_args.len() > 1 and all_args[1].ends_with(".spl"):
        start_idx = 2
    var i = start_idx
    while i < all_args.len():
        args = args + [all_args[i]]
        i = i + 1
    args

# --- JSON building helpers ---

fn jp(key: String, val_str: String) -> String:
    var r = Q()
    r = r + key
    r = r + Q()
    r = r + ":"
    r = r + val_str
    r

fn js(s: String) -> String:
    var r = Q()
    r = r + s
    r = r + Q()
    r

fn jo1(pair: String) -> String:
    var r = LB()
    r = r + pair
    r = r + RB()
    r

fn jo2(p1: String, p2: String) -> String:
    var r = LB()
    r = r + p1
    r = r + ","
    r = r + p2
    r = r + RB()
    r

fn jo3(p1: String, p2: String, p3: String) -> String:
    var r = LB()
    r = r + p1
    r = r + ","
    r = r + p2
    r = r + ","
    r = r + p3
    r = r + RB()
    r

# --- JSON parsing helpers ---

fn extract_json_string_v2(json: String, key: String) -> String:
    val pattern = "\"" + key + "\":"
    val idx_opt = json.index_of(pattern)

    var start_pos = -1
    match idx_opt:
        Some(pos): start_pos = pos + pattern.len()
        None: return ""

    if start_pos < 0:
        return ""

    val rest = json.substring(start_pos).trim()

    if not rest.starts_with("\""):
        return ""

    val after_quote = rest.substring(1)
    val end_opt = after_quote.index_of("\"")

    var end_pos = -1
    match end_opt:
        Some(pos): end_pos = pos
        None: return ""

    if end_pos < 0:
        return ""

    after_quote.substring(0, end_pos)

fn extract_json_string(json: String, key: String) -> String:
    val quote = "\""
    val search = quote + key + quote + ":"
    val idx_opt = json.index_of(search)

    var idx = -1
    match idx_opt:
        Some(i): idx = i
        None: idx = -1

    if idx < 0:
        return ""

    val slen = search.len()
    val start = idx + slen
    val after = json.substring(start)
    val trimmed = after.trim()

    if trimmed.starts_with(quote):
        val rest = trimmed.substring(1)
        val end_opt = rest.index_of(quote)

        var end = -1
        match end_opt:
            Some(i): end = i
            None: end = -1
        if end >= 0:
            return rest.substring(0, end)
    ""

fn extract_json_value(json: String, key: String) -> String:
    val search = Q() + key + Q() + ":"
    val idx = unwrap_idx(json.index_of(search))
    if idx < 0:
        return "null"
    val slen = search.len()
    val start = idx + slen
    val after = json.substring(start)
    val trimmed = after.trim()
    var end = 0
    for ch in trimmed:
        if ch == "," or ch == RB() or ch == "]":
            break
        end = end + 1
    trimmed.substring(0, end).trim()

fn extract_nested_string(json: String, outer_key: String, inner_key: String) -> String:
    val search = Q() + outer_key + Q() + ":"
    val idx = unwrap_idx(json.index_of(search))
    if idx < 0:
        return ""
    val slen = search.len()
    val start = idx + slen
    val after = json.substring(start)
    extract_json_string(after, inner_key)

fn extract_arguments_dict(body: String) -> Dict<String, String>:
    """Extract arguments dictionary from MCP request body.

    Parses the params.arguments object from JSON-RPC request.

    Args:
        body - Full JSON-RPC request body

    Returns:
        Dictionary of argument name -> value pairs
    """
    var result: Dict<String, String> = {}

    # Find params object
    val params_search = Q() + "params" + Q() + ":"
    val params_idx = unwrap_idx(body.index_of(params_search))
    if params_idx < 0:
        return result

    val params_start = params_idx + params_search.len()
    val params_section = body.substring(params_start)

    # Find arguments object within params
    val args_search = Q() + "arguments" + Q() + ":"
    val args_idx = unwrap_idx(params_section.index_of(args_search))
    if args_idx < 0:
        return result

    val args_start = args_idx + args_search.len()
    val after_args = params_section.substring(args_start)
    val trimmed = after_args.trim()

    # Extract content between braces
    if not trimmed.starts_with(LB()):
        return result

    # Find matching closing brace
    var brace_count = 0
    var idx = 0
    var args_content = ""

    for ch in trimmed:
        if ch == LB():
            brace_count = brace_count + 1
        else if ch == RB():
            brace_count = brace_count - 1
            if brace_count == 0:
                # Extract content between braces
                args_content = trimmed.substring(1, idx)
                break
        idx = idx + 1

    if args_content == "":
        return result

    # Parse key-value pairs from args_content
    # Simple comma-separated parsing
    val pairs = args_content.split(",")
    for pair in pairs:
        val colon_idx = unwrap_idx(pair.index_of(":"))
        if colon_idx >= 0:
            var key = pair.substring(0, colon_idx).trim()
            var value = pair.substring(colon_idx + 1).trim()

            # Remove quotes from key and value
            if key.starts_with(Q()):
                key = key.substring(1)
            if key.ends_with(Q()):
                key = key.substring(0, key.len() - 1)

            if value.starts_with(Q()):
                value = value.substring(1)
            if value.ends_with(Q()):
                value = value.substring(0, value.len() - 1)

            result[key] = value

    result

# --- String escaping ---
# escape_json imported from lib.json.builder

# --- File helpers ---

fn read_file_safe(path: String) -> String:
    val content = file_read(path)
    if content == "":
        return "Error: could not read file: " + path
    content

fn list_spl_files(dir: String) -> String:
    val result = shell("find " + dir + " -name '*.spl' -type f | sort")
    if result.exit_code != 0:
        var error = LB()
        error = error + jp("error", js("Failed to list files"))
        error = error + ","
        error = error + jp("directory", js(dir))
        error = error + RB()
        return error

    val output = result.stdout ?? ""
    if output.trim() == "":
        return "[]"

    val file_paths = output.split("\n")
    var files_json = "["
    var first = true

    for file_path in file_paths:
        val trimmed = file_path.trim()
        if trimmed != "":
            if not first:
                files_json = files_json + ","
            first = false

            var file_obj = LB()
            file_obj = file_obj + jp("path", js(trimmed))
            file_obj = file_obj + RB()
            files_json = files_json + file_obj

    files_json = files_json + "]"
    files_json

# --- Response makers ---

fn make_tool_result(id: String, content: String) -> String:
    val text_obj = jo2(jp("type", js("text")), jp("text", js(content)))
    val result = jo1(jp("content", "[" + text_obj + "]"))
    jo3(jp("jsonrpc", js("2.0")), jp("id", id), jp("result", result))

fn make_result_response(id: String, result: String) -> String:
    jo3(jp("jsonrpc", js("2.0")), jp("id", id), jp("result", result))

fn make_error_response(id: String, code: Int, message: String) -> String:
    val err = jo2(jp("code", code.to_string()), jp("message", js(escape_json(message))))
    jo3(jp("jsonrpc", js("2.0")), jp("id", id), jp("error", err))

# --- Flag checking ---

fn has_flag(args: [String], flag: String) -> Bool:
    for arg in args:
        if arg == flag:
            return true
    return false

fn make_tool_schema_multi(name: String, desc: String, properties_json: String, required_json: String, read_only: Bool, destructive: Bool, idempotent: Bool) -> String:
    val schema = jo3(jp("type", js("object")), jp("properties", properties_json), jp("required", required_json))

    # Build annotations object
    var annot = LB()
    var ro = "false"
    if read_only:
        ro = "true"
    annot = annot + jp("readOnlyHint", ro)
    annot = annot + ","
    var dest = "false"
    if destructive:
        dest = "true"
    annot = annot + jp("destructiveHint", dest)
    annot = annot + ","
    var idemp = "false"
    if idempotent:
        idemp = "true"
    annot = annot + jp("idempotentHint", idemp)
    annot = annot + ","
    annot = annot + jp("openWorldHint", "false")
    annot = annot + RB()

    # Return tool schema with annotations
    var result = LB()
    result = result + jp("name", js(name))
    result = result + ","
    result = result + jp("description", js(desc))
    result = result + ","
    result = result + jp("inputSchema", schema)
    result = result + ","
    result = result + jp("annotations", annot)
    result = result + RB()
    result

# --- Exports ---

export LB, RB, Q
export parse_int, min_int, unwrap_idx, unwrap_str
export get_clean_args
export jp, js, jo1, jo2, jo3
export extract_json_string_v2, extract_json_string, extract_json_value, extract_nested_string, extract_arguments_dict
export escape_json
export read_file_safe, list_spl_files
export make_tool_result, make_result_response, make_error_response
export make_tool_schema_multi
export has_flag
