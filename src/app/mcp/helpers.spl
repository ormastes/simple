# MCP Helpers - Shared utility functions for MCP server
#
# Extracted from main.spl to enable reuse and reduce duplication.
# Provides JSON building, string escaping, arg parsing, and response makers.

use app.io.mod (file_read, shell, cwd)
use lib.json.builder.{escape_json}

# Brace helpers (avoid f-string interpolation issues)
fn LB() -> String:
    (123 as char).to_string()

fn RB() -> String:
    (125 as char).to_string()

fn Q() -> String:
    "\""

# Helper: parse integer from string
fn parse_int(s: String) -> Result<Int, String>:
    var result = 0
    var i = 0
    while i < s.len():
        val ch = s[i]
        if ch >= '0' and ch <= '9':
            result = result * 10 + (ch as int - '0' as int)
        else:
            return Err("Invalid digit: " + ch.to_string())
        i = i + 1
    Ok(result)

# Helper: minimum of two integers
fn min_int(a: Int, b: Int) -> Int:
    if a < b:
        a
    else:
        b

# Option unwrap helper
fn unwrap_idx(opt: Option<Int>) -> Int:
    match opt:
        case Some(i):
            return i
        case nil:
            return -1

fn unwrap_str(result: Result<String, String>) -> String:
    match result:
        case Ok(s):
            return s
        case Err(_):
            return ""

# Skip program name and script path to get clean args
fn get_clean_args(all_args: [String]) -> [String]:
    var args = []
    var start_idx = 1
    if all_args.len() > 1 and all_args[1].ends_with(".spl"):
        start_idx = 2
    var i = start_idx
    while i < all_args.len():
        args = args + [all_args[i]]
        i = i + 1
    args

# --- JSON building helpers ---

fn jp(key: String, val_str: String) -> String:
    var r = Q()
    r = r + key
    r = r + Q()
    r = r + ":"
    r = r + val_str
    r

fn js(s: String) -> String:
    var r = Q()
    r = r + s
    r = r + Q()
    r

fn jo1(pair: String) -> String:
    var r = LB()
    r = r + pair
    r = r + RB()
    r

fn jo2(p1: String, p2: String) -> String:
    var r = LB()
    r = r + p1
    r = r + ","
    r = r + p2
    r = r + RB()
    r

fn jo3(p1: String, p2: String, p3: String) -> String:
    var r = LB()
    r = r + p1
    r = r + ","
    r = r + p2
    r = r + ","
    r = r + p3
    r = r + RB()
    r

# --- JSON parsing helpers ---

fn extract_json_string_v2(json: String, key: String) -> String:
    val pattern = "\"" + key + "\":"
    val idx_opt = json.index_of(pattern)

    var start_pos = -1
    match idx_opt:
        Some(pos): start_pos = pos + pattern.len()
        nil: return ""

    if start_pos < 0:
        return ""

    val rest = json.substring(start_pos).trim()

    if not rest.starts_with("\""):
        return ""

    val after_quote = rest.substring(1)
    val end_opt = after_quote.index_of("\"")

    var end_pos = -1
    match end_opt:
        Some(pos): end_pos = pos
        nil: return ""

    if end_pos < 0:
        return ""

    after_quote.substring(0, end_pos)

fn extract_json_string(json: String, key: String) -> String:
    val quote = "\""
    val search = quote + key + quote + ":"
    val idx_opt = json.index_of(search)

    var idx = -1
    match idx_opt:
        Some(i): idx = i
        nil: idx = -1

    if idx < 0:
        return ""

    val slen = search.len()
    val start = idx + slen
    val after = json.substring(start)
    val trimmed = after.trim()

    if trimmed.starts_with(quote):
        val rest = trimmed.substring(1)
        val end_opt = rest.index_of(quote)

        var end = -1
        match end_opt:
            Some(i): end = i
            nil: end = -1
        if end >= 0:
            return rest.substring(0, end)
    ""

fn extract_json_value(json: String, key: String) -> String:
    val search = Q() + key + Q() + ":"
    val idx = unwrap_idx(json.index_of(search))
    if idx < 0:
        return "null"
    val slen = search.len()
    val start = idx + slen
    val after = json.substring(start)
    val trimmed = after.trim()
    var end = 0
    for ch in trimmed:
        if ch == "," or ch == RB() or ch == "]":
            break
        end = end + 1
    trimmed.substring(0, end).trim()

fn extract_nested_string(json: String, outer_key: String, inner_key: String) -> String:
    val search = Q() + outer_key + Q() + ":"
    val idx = unwrap_idx(json.index_of(search))
    if idx < 0:
        return ""
    val slen = search.len()
    val start = idx + slen
    val after = json.substring(start)
    extract_json_string(after, inner_key)

fn extract_arguments_dict(body: String) -> Dict<String, String>:
    """Extract arguments dictionary from MCP request body.

    Parses the params.arguments object from JSON-RPC request.

    Args:
        body - Full JSON-RPC request body

    Returns:
        Dictionary of argument name -> value pairs
    """
    var result: Dict<String, String> = {}

    # Find params object
    val params_search = Q() + "params" + Q() + ":"
    val params_idx = unwrap_idx(body.index_of(params_search))
    if params_idx < 0:
        return result

    val params_start = params_idx + params_search.len()
    val params_section = body.substring(params_start)

    # Find arguments object within params
    val args_search = Q() + "arguments" + Q() + ":"
    val args_idx = unwrap_idx(params_section.index_of(args_search))
    if args_idx < 0:
        return result

    val args_start = args_idx + args_search.len()
    val after_args = params_section.substring(args_start)
    val trimmed = after_args.trim()

    # Extract content between braces
    if not trimmed.starts_with(LB()):
        return result

    # Find matching closing brace
    var brace_count = 0
    var idx = 0
    var args_content = ""

    for ch in trimmed:
        if ch == LB():
            brace_count = brace_count + 1
        else if ch == RB():
            brace_count = brace_count - 1
            if brace_count == 0:
                # Extract content between braces
                args_content = trimmed.substring(1, idx)
                break
        idx = idx + 1

    if args_content == "":
        return result

    # Parse key-value pairs from args_content
    # Simple comma-separated parsing
    val pairs = args_content.split(",")
    for pair in pairs:
        val colon_idx = unwrap_idx(pair.index_of(":"))
        if colon_idx >= 0:
            var key = pair.substring(0, colon_idx).trim()
            var value = pair.substring(colon_idx + 1).trim()

            # Remove quotes from key and value
            if key.starts_with(Q()):
                key = key.substring(1)
            if key.ends_with(Q()):
                key = key.substring(0, key.len() - 1)

            if value.starts_with(Q()):
                value = value.substring(1)
            if value.ends_with(Q()):
                value = value.substring(0, value.len() - 1)

            result[key] = value

    result

# --- String escaping ---
# escape_json imported from lib.json.builder

# --- File helpers ---

fn read_file_safe(path: String) -> String:
    val content = file_read(path)
    if content == "":
        return "Error: could not read file: " + path
    content

fn list_spl_files(dir: String) -> String:
    val result = shell("find " + dir + " -name '*.spl' -type f | sort")
    if result.exit_code != 0:
        var error = LB()
        error = error + jp("error", js("Failed to list files"))
        error = error + ","
        error = error + jp("directory", js(dir))
        error = error + RB()
        return error

    val output = result.stdout ?? ""
    if output.trim() == "":
        return "[]"

    val file_paths = output.split("\n")
    var files_json = "["
    var first = true

    for file_path in file_paths:
        val trimmed = file_path.trim()
        if trimmed != "":
            if not first:
                files_json = files_json + ","
            first = false

            var file_obj = LB()
            file_obj = file_obj + jp("path", js(trimmed))
            file_obj = file_obj + RB()
            files_json = files_json + file_obj

    files_json = files_json + "]"
    files_json

# --- Response makers ---

fn make_tool_result(id: String, content: String) -> String:
    val text_obj = jo2(jp("type", js("text")), jp("text", js(escape_json(content))))
    val result = jo1(jp("content", "[" + text_obj + "]"))
    jo3(jp("jsonrpc", js("2.0")), jp("id", id), jp("result", result))

fn make_result_response(id: String, result: String) -> String:
    jo3(jp("jsonrpc", js("2.0")), jp("id", id), jp("result", result))

fn make_error_response(id: String, code: Int, message: String) -> String:
    val err = jo2(jp("code", code.to_string()), jp("message", js(escape_json(message))))
    jo3(jp("jsonrpc", js("2.0")), jp("id", id), jp("error", err))

# --- Flag checking ---

fn has_flag(args: [String], flag: String) -> Bool:
    for arg in args:
        if arg == flag:
            return true
    return false

fn make_tool_schema_multi(name: String, desc: String, properties_json: String, required_json: String, read_only: Bool, destructive: Bool, idempotent: Bool) -> String:
    val schema = jo3(jp("type", js("object")), jp("properties", properties_json), jp("required", required_json))

    # Build annotations object
    var annot = LB()
    var ro = "false"
    if read_only:
        ro = "true"
    annot = annot + jp("readOnlyHint", ro)
    annot = annot + ","
    var dest = "false"
    if destructive:
        dest = "true"
    annot = annot + jp("destructiveHint", dest)
    annot = annot + ","
    var idemp = "false"
    if idempotent:
        idemp = "true"
    annot = annot + jp("idempotentHint", idemp)
    annot = annot + ","
    annot = annot + jp("openWorldHint", "false")
    annot = annot + RB()

    # Return tool schema with annotations
    var result = LB()
    result = result + jp("name", js(name))
    result = result + ","
    result = result + jp("description", js(desc))
    result = result + ","
    result = result + jp("inputSchema", schema)
    result = result + ","
    result = result + jp("annotations", annot)
    result = result + RB()
    result

# --- Notification helpers ---

# Build a JSON-RPC 2.0 notification (no id field)
fn make_notification(method: String, params: String) -> String:
    var r = LB()
    r = r + jp("jsonrpc", js("2.0"))
    r = r + "," + jp("method", js(method))
    r = r + "," + jp("params", params)
    r = r + RB()
    r

# Build a JSON-RPC 2.0 notification with no params
fn make_notification_no_params(method: String) -> String:
    jo2(jp("jsonrpc", js("2.0")), jp("method", js(method)))

# Send a progress notification
fn make_progress_notification(token: String, progress: Int, total: Int, message: String) -> String:
    var params = LB()
    params = params + jp("progressToken", js(token))
    params = params + "," + jp("progress", progress.to_string())
    if total > 0:
        params = params + "," + jp("total", total.to_string())
    if message != "":
        params = params + "," + jp("message", js(escape_json(message)))
    params = params + RB()
    make_notification("notifications/progress", params)

# --- Log level utilities ---

# Convert log level name to numeric priority (RFC 5424)
fn log_level_to_int(level: String) -> Int:
    if level == "debug":
        return 0
    elif level == "info":
        return 1
    elif level == "notice":
        return 2
    elif level == "warning":
        return 3
    elif level == "error":
        return 4
    elif level == "critical":
        return 5
    elif level == "alert":
        return 6
    elif level == "emergency":
        return 7
    return -1  # unknown level

# Build a log message notification (data as string)
fn make_log_notification(level: String, data: String, logger: String) -> String:
    var params = LB()
    params = params + jp("level", js(level))
    params = params + "," + jp("data", js(escape_json(data)))
    if logger != "":
        params = params + "," + jp("logger", js(escape_json(logger)))
    params = params + RB()
    make_notification("notifications/message", params)

# Build a log message notification with raw JSON data (object, array, number, etc.)
fn make_log_notification_raw(level: String, data_json: String, logger: String) -> String:
    var params = LB()
    params = params + jp("level", js(level))
    params = params + "," + jp("data", data_json)
    if logger != "":
        params = params + "," + jp("logger", js(escape_json(logger)))
    params = params + RB()
    make_notification("notifications/message", params)

# --- List changed notifications ---

fn make_tools_list_changed() -> String:
    make_notification_no_params("notifications/tools/list_changed")

fn make_resources_list_changed() -> String:
    make_notification_no_params("notifications/resources/list_changed")

fn make_prompts_list_changed() -> String:
    make_notification_no_params("notifications/prompts/list_changed")

# --- Resource subscription notifications ---

fn make_resource_updated_notification(uri: String) -> String:
    val params = jo1(jp("uri", js(escape_json(uri))))
    make_notification("notifications/resources/updated", params)

# --- Content type helpers ---

# Build ImageContent object
fn make_image_content(data: String, mime_type: String) -> String:
    var r = LB()
    r = r + jp("type", js("image"))
    r = r + "," + jp("data", js(data))
    r = r + "," + jp("mimeType", js(mime_type))
    r = r + RB()
    r

# Build AudioContent object
fn make_audio_content(data: String, mime_type: String) -> String:
    var r = LB()
    r = r + jp("type", js("audio"))
    r = r + "," + jp("data", js(data))
    r = r + "," + jp("mimeType", js(mime_type))
    r = r + RB()
    r

# Build ResourceLinkContent object (minimal - uri + name required)
fn make_resource_link_content(uri: String, name: String) -> String:
    var r = LB()
    r = r + jp("type", js("resource_link"))
    r = r + "," + jp("uri", js(escape_json(uri)))
    r = r + "," + jp("name", js(escape_json(name)))
    r = r + RB()
    r

# Build ResourceLinkContent with all optional fields
fn make_resource_link_content_full(uri: String, name: String, title: String, description: String, mime_type: String, size: Int) -> String:
    var r = LB()
    r = r + jp("type", js("resource_link"))
    r = r + "," + jp("uri", js(escape_json(uri)))
    r = r + "," + jp("name", js(escape_json(name)))
    if title != "":
        r = r + "," + jp("title", js(escape_json(title)))
    if description != "":
        r = r + "," + jp("description", js(escape_json(description)))
    if mime_type != "":
        r = r + "," + jp("mimeType", js(mime_type))
    if size >= 0:
        r = r + "," + jp("size", size.to_string())
    r = r + RB()
    r

# Build EmbeddedResourceContent object
fn make_embedded_resource_content(uri: String, text_content: String, mime_type: String) -> String:
    var resource = LB()
    resource = resource + jp("uri", js(escape_json(uri)))
    resource = resource + "," + jp("text", js(escape_json(text_content)))
    if mime_type != "":
        resource = resource + "," + jp("mimeType", js(mime_type))
    resource = resource + RB()
    jo2(jp("type", js("resource")), jp("resource", resource))

# Build content annotation object
fn make_content_annotations(audience: [String], priority: String, last_modified: String) -> String:
    var r = LB()
    var first = true
    if audience.len() > 0:
        var arr = "["
        var af = true
        for a in audience:
            if not af:
                arr = arr + ","
            af = false
            arr = arr + js(a)
        arr = arr + "]"
        r = r + jp("audience", arr)
        first = false
    if priority != "":
        if not first:
            r = r + ","
        r = r + jp("priority", priority)
        first = false
    if last_modified != "":
        if not first:
            r = r + ","
        r = r + jp("lastModified", js(last_modified))
    r = r + RB()
    r

# Build tool result with structured content
fn make_tool_result_with_structured(id: String, content: String, structured_content: String) -> String:
    val text_obj = jo2(jp("type", js("text")), jp("text", js(escape_json(content))))
    var result = LB()
    result = result + jp("content", "[" + text_obj + "]")
    result = result + "," + jp("structuredContent", structured_content)
    result = result + RB()
    jo3(jp("jsonrpc", js("2.0")), jp("id", id), jp("result", result))

# Build tool schema with outputSchema
fn make_tool_schema_with_output(name: String, desc: String, properties_json: String, required_json: String, output_schema: String, read_only: Bool, destructive: Bool, idempotent: Bool) -> String:
    val schema = jo3(jp("type", js("object")), jp("properties", properties_json), jp("required", required_json))

    # Build annotations object
    var annot = LB()
    var ro = "false"
    if read_only:
        ro = "true"
    annot = annot + jp("readOnlyHint", ro)
    annot = annot + ","
    var dest = "false"
    if destructive:
        dest = "true"
    annot = annot + jp("destructiveHint", dest)
    annot = annot + ","
    var idemp = "false"
    if idempotent:
        idemp = "true"
    annot = annot + jp("idempotentHint", idemp)
    annot = annot + ","
    annot = annot + jp("openWorldHint", "false")
    annot = annot + RB()

    var result = LB()
    result = result + jp("name", js(name))
    result = result + ","
    result = result + jp("description", js(desc))
    result = result + ","
    result = result + jp("inputSchema", schema)
    result = result + ","
    result = result + jp("outputSchema", output_schema)
    result = result + ","
    result = result + jp("annotations", annot)
    result = result + RB()
    result

# --- Server-to-client request helpers ---

# Build a JSON-RPC 2.0 request (server-to-client)
fn make_server_request(id: String, method: String, params: String) -> String:
    var r = LB()
    r = r + jp("jsonrpc", js("2.0"))
    r = r + "," + jp("id", id)
    r = r + "," + jp("method", js(method))
    r = r + "," + jp("params", params)
    r = r + RB()
    r

# Build sampling/createMessage request (basic)
fn make_sampling_request(id: String, messages: String, model_prefs: String, system_prompt: String, max_tokens: Int) -> String:
    var params = LB()
    params = params + jp("messages", messages)
    if model_prefs != "":
        params = params + "," + jp("modelPreferences", model_prefs)
    if system_prompt != "":
        params = params + "," + jp("systemPrompt", js(escape_json(system_prompt)))
    params = params + "," + jp("maxTokens", max_tokens.to_string())
    params = params + RB()
    make_server_request(id, "sampling/createMessage", params)

# Build sampling/createMessage request with all optional fields
# temperature: -1.0 means omit, stop_sequences_json: "[]" or "null" means omit,
# metadata_json: "" means omit, include_context: "" means omit
fn make_sampling_request_full(id: String, messages: String, model_prefs: String, system_prompt: String, max_tokens: Int, temperature: String, stop_sequences_json: String, metadata_json: String, include_context: String) -> String:
    var params = LB()
    params = params + jp("messages", messages)
    if model_prefs != "":
        params = params + "," + jp("modelPreferences", model_prefs)
    if system_prompt != "":
        params = params + "," + jp("systemPrompt", js(escape_json(system_prompt)))
    params = params + "," + jp("maxTokens", max_tokens.to_string())
    if temperature != "":
        params = params + "," + jp("temperature", temperature)
    if stop_sequences_json != "" and stop_sequences_json != "[]":
        params = params + "," + jp("stopSequences", stop_sequences_json)
    if metadata_json != "":
        params = params + "," + jp("metadata", metadata_json)
    if include_context != "":
        params = params + "," + jp("includeContext", js(include_context))
    params = params + RB()
    make_server_request(id, "sampling/createMessage", params)

# Build elicitation/create request
fn make_elicitation_request(id: String, message: String, schema: String) -> String:
    var params = LB()
    params = params + jp("message", js(escape_json(message)))
    params = params + "," + jp("requestedSchema", schema)
    params = params + RB()
    make_server_request(id, "elicitation/create", params)

# --- Tool registration helper ---

# Register a tool with simplified parameters (reduces boilerplate)
# Returns a tool schema JSON string ready for inclusion in tools list.
# params_list: array of [name, type, description] triples as flat string array
fn register_tool(name: String, desc: String, param_names: [String], param_descs: [String], required_names: [String], read_only: Bool, destructive: Bool, idempotent: Bool) -> String:
    var props = LB()
    var first_prop = true
    var i = 0
    for pname in param_names:
        if not first_prop:
            props = props + ","
        first_prop = false
        var pdesc = ""
        if i < param_descs.len():
            pdesc = param_descs[i]
        val prop = jo2(jp("type", js("string")), jp("description", js(pdesc)))
        props = props + jp(pname, prop)
        i = i + 1
    props = props + RB()

    var req_arr = "["
    var first_req = true
    for rname in required_names:
        if not first_req:
            req_arr = req_arr + ","
        first_req = false
        req_arr = req_arr + js(rname)
    req_arr = req_arr + "]"

    make_tool_schema_multi(name, desc, props, req_arr, read_only, destructive, idempotent)

# --- Content type detection helpers ---

# Detect content type category from file path
fn detect_file_content_type(path: String) -> String:
    if path.ends_with(".png") or path.ends_with(".jpg") or path.ends_with(".jpeg") or path.ends_with(".gif") or path.ends_with(".svg") or path.ends_with(".webp") or path.ends_with(".ico") or path.ends_with(".bmp"):
        return "image"
    if path.ends_with(".wav") or path.ends_with(".mp3") or path.ends_with(".ogg") or path.ends_with(".flac"):
        return "audio"
    "text"

# Detect MIME type for a file
fn detect_mime_type(path: String) -> String:
    # Images
    if path.ends_with(".png"):
        return "image/png"
    if path.ends_with(".jpg") or path.ends_with(".jpeg"):
        return "image/jpeg"
    if path.ends_with(".gif"):
        return "image/gif"
    if path.ends_with(".svg"):
        return "image/svg+xml"
    if path.ends_with(".webp"):
        return "image/webp"
    if path.ends_with(".ico"):
        return "image/x-icon"
    if path.ends_with(".bmp"):
        return "image/bmp"
    # Audio
    if path.ends_with(".wav"):
        return "audio/wav"
    if path.ends_with(".mp3"):
        return "audio/mpeg"
    if path.ends_with(".ogg"):
        return "audio/ogg"
    if path.ends_with(".flac"):
        return "audio/flac"
    # Text
    if path.ends_with(".spl"):
        return "text/x-simple"
    if path.ends_with(".json"):
        return "application/json"
    if path.ends_with(".md"):
        return "text/markdown"
    if path.ends_with(".html"):
        return "text/html"
    if path.ends_with(".css"):
        return "text/css"
    if path.ends_with(".js"):
        return "text/javascript"
    "text/plain"

# --- Send notification over stdio ---

# Send a JSON-RPC 2.0 notification via Content-Length framed stdio
fn send_notification_message(notification: String):
    var header = "Content-Length: "
    header = header + notification.len().to_string()
    header = header + "\r\n\r\n"
    print_raw(header)
    print_raw(notification)

# Send a log notification if level passes the threshold
fn send_log(level: String, data: String, logger: String, current_log_level: Int):
    val msg_level = log_level_to_int(level)
    if current_log_level < 0:
        return
    if msg_level < current_log_level:
        return
    val notification = make_log_notification(level, data, logger)
    send_notification_message(notification)

# Send a progress notification
fn send_progress(token: String, progress: Int, total: Int, message: String):
    val notification = make_progress_notification(token, progress, total, message)
    send_notification_message(notification)

# Send a resource updated notification
fn send_resource_updated(uri: String):
    val notification = make_resource_updated_notification(uri)
    send_notification_message(notification)

# --- Exports ---

export LB, RB, Q
export parse_int, min_int, unwrap_idx, unwrap_str
export get_clean_args
export jp, js, jo1, jo2, jo3
export extract_json_string_v2, extract_json_string, extract_json_value, extract_nested_string, extract_arguments_dict
export escape_json
export read_file_safe, list_spl_files
export make_tool_result, make_result_response, make_error_response
export make_tool_schema_multi
export has_flag
# Notification helpers
export make_notification, make_notification_no_params, make_progress_notification
export log_level_to_int, make_log_notification
export make_tools_list_changed, make_resources_list_changed, make_prompts_list_changed
export make_resource_updated_notification
# Content type helpers
export make_image_content, make_audio_content, make_resource_link_content, make_resource_link_content_full
export make_embedded_resource_content, make_content_annotations
export make_tool_result_with_structured, make_tool_schema_with_output
# Server-to-client request helpers
export make_server_request, make_sampling_request, make_sampling_request_full, make_elicitation_request
# Raw JSON variants
export make_log_notification_raw
# Send helpers (stdio framed)
export send_notification_message, send_log, send_progress, send_resource_updated
# Tool registration helper
export register_tool
# Content type detection
export detect_file_content_type, detect_mime_type
