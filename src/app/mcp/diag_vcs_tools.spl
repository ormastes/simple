# MCP Diagnostic VCS Tools - jj integration with diagnostics
#
# Tools:
#   simple_diff   - jj diff with diagnostic annotations on changed lines
#   simple_log    - jj log with per-revision error counts
#   simple_squash - jj squash with pre-check diagnostics
#   simple_new    - jj new with baseline diagnostic snapshot

use app.io.mod (file_read, shell, cwd)
use app.mcp.helpers.{LB, RB, Q, jp, js, jo1, jo2, jo3, escape_json, parse_int, min_int, make_tool_result, make_error_response, make_tool_schema_multi}
use app.mcp.diag_core.{DiagEntry, DiagResult, run_diagnostics, severity_tag, diag_entries_to_json}

# ============================================================================
# Tool Schemas
# ============================================================================

fn schema_simple_diff() -> text:
    val rev_prop = jo2(jp("type", js("string")), jp("description", js("Revision to diff (default: @)")))
    val paths_prop = jo2(jp("type", js("string")), jp("description", js("Comma-separated file paths to limit diff")))
    var props = LB()
    props = props + jp("revision", rev_prop)
    props = props + "," + jp("paths", paths_prop)
    props = props + RB()
    make_tool_schema_multi("simple_diff", "Show jj diff with inline diagnostic annotations on changed lines", props, "[]", true, false, true)

fn schema_simple_log() -> text:
    val limit_prop = jo2(jp("type", js("string")), jp("description", js("Max revisions to show (default: 10)")))
    val revsets_prop = jo2(jp("type", js("string")), jp("description", js("Revset expression to filter")))
    var props = LB()
    props = props + jp("limit", limit_prop)
    props = props + "," + jp("revsets", revsets_prop)
    props = props + RB()
    make_tool_schema_multi("simple_log", "Show jj log with diagnostic error counts per changed file", props, "[]", true, false, true)

fn schema_simple_squash() -> text:
    val rev_prop = jo2(jp("type", js("string")), jp("description", js("Revision to squash (default: @)")))
    val msg_prop = jo2(jp("type", js("string")), jp("description", js("Commit message")))
    var props = LB()
    props = props + jp("revision", rev_prop)
    props = props + "," + jp("message", msg_prop)
    props = props + RB()
    make_tool_schema_multi("simple_squash", "Squash jj revision with pre-check diagnostics warning", props, "[]", false, false, false)

fn schema_simple_new() -> text:
    val rev_prop = jo2(jp("type", js("string")), jp("description", js("Parent revision (default: @)")))
    val msg_prop = jo2(jp("type", js("string")), jp("description", js("Description for new revision")))
    var props = LB()
    props = props + jp("revision", rev_prop)
    props = props + "," + jp("message", msg_prop)
    props = props + RB()
    make_tool_schema_multi("simple_new", "Create new jj revision with baseline diagnostic snapshot", props, "[]", false, false, false)

# ============================================================================
# Local jj runner (same pattern as mcp_jj/jj_runner.spl)
# ============================================================================

fn jj_cmd(args_str: text) -> text:
    val cmd = "jj --no-pager --color never " + args_str + " 2>&1"
    val result = shell(cmd)
    result.stdout ?? ""

fn jj_cmd_exit(args_str: text) -> i64:
    val cmd = "jj --no-pager --color never " + args_str + " 2>&1"
    val result = shell(cmd)
    result.exit_code ?? 1

# ============================================================================
# Handlers
# ============================================================================

fn handle_simple_diff(id: text, body: text) -> text:
    val revision = extract_arg(body, "revision")
    val paths_str = extract_arg(body, "paths")

    var rev = "@"
    if revision != "":
        rev = revision

    # Get diff
    var diff_cmd = "diff -r " + rev
    if paths_str != "":
        val path_parts = paths_str.split(",")
        for pp in path_parts:
            val pt = pp.trim()
            if pt != "":
                diff_cmd = diff_cmd + " " + pt
    val diff_output = jj_cmd(diff_cmd)

    # Get changed .spl files from stat
    var stat_cmd = "diff -r " + rev + " --stat"
    val stat_output = jj_cmd(stat_cmd)
    val changed_files = extract_spl_files_from_stat(stat_output)

    # Run diagnostics on changed files
    var file_diags: [text] = []
    var file_diag_entries: [text] = []
    for fpath in changed_files:
        val diag = run_diagnostics(fpath)
        if diag.error_count > 0 or diag.warning_count > 0:
            file_diags.push(fpath + ": " + diag.error_count.to_string() + "E " + diag.warning_count.to_string() + "W")
        # Collect entries as line annotations
        for entry in diag.entries:
            if entry.line_num > 0:
                val tag = severity_tag(entry.severity)
                file_diag_entries.push(fpath + ":" + entry.line_num.to_string() + " " + tag + " " + entry.message)

    # Annotate diff output with diagnostics
    var output = "-- simple_diff -r " + rev + " --\n"
    output = output + diff_output

    if file_diags.len() > 0:
        output = output + "\n-- diagnostics on changed files --\n"
        for fd in file_diags:
            output = output + "  " + fd + "\n"

    if file_diag_entries.len() > 0:
        output = output + "\n-- inline diagnostics --\n"
        for fde in file_diag_entries:
            output = output + "  " + fde + "\n"

    make_tool_result(id, output)

fn handle_simple_log(id: text, body: text) -> text:
    val limit_str = extract_arg(body, "limit")
    val revsets = extract_arg(body, "revsets")

    var limit = 10
    if limit_str != "":
        val lr = parse_int(limit_str)
        match lr:
            Ok(v): limit = v
            Err(_): pass

    # Get log
    var log_cmd = "log --limit " + limit.to_string()
    if revsets != "":
        log_cmd = log_cmd + " -r " + revsets
    val log_output = jj_cmd(log_cmd)

    # Get changed files in current working copy for diagnostic counts
    val stat_output = jj_cmd("diff -r @ --stat")
    val changed_files = extract_spl_files_from_stat(stat_output)

    var total_errors = 0
    var total_warnings = 0
    var file_summaries: [text] = []
    for fpath in changed_files:
        val diag = run_diagnostics(fpath)
        total_errors = total_errors + diag.error_count
        total_warnings = total_warnings + diag.warning_count
        if diag.error_count > 0 or diag.warning_count > 0:
            file_summaries.push("  " + fpath + " " + diag.error_count.to_string() + "E " + diag.warning_count.to_string() + "W")

    var output = "-- simple_log --\n"
    output = output + log_output

    if file_summaries.len() > 0:
        output = output + "\n-- working copy diagnostics [" + total_errors.to_string() + "E " + total_warnings.to_string() + "W] --\n"
        for fs in file_summaries:
            output = output + fs + "\n"
    else:
        output = output + "\n-- working copy: clean --\n"

    make_tool_result(id, output)

fn handle_simple_squash(id: text, body: text) -> text:
    val revision = extract_arg(body, "revision")
    val message = extract_arg(body, "message")

    # Pre-check diagnostics on changed files
    val stat_output = jj_cmd("diff -r @ --stat")
    val changed_files = extract_spl_files_from_stat(stat_output)

    var total_errors = 0
    var file_warnings: [text] = []
    for fpath in changed_files:
        val diag = run_diagnostics(fpath)
        total_errors = total_errors + diag.error_count
        if diag.error_count > 0:
            file_warnings.push(fpath + ": " + diag.error_count.to_string() + " error(s)")

    # Run squash
    var squash_cmd = "squash"
    if revision != "":
        squash_cmd = squash_cmd + " -r " + revision
    if message != "":
        squash_cmd = squash_cmd + " -m '" + message + "'"
    val squash_output = jj_cmd(squash_cmd)
    val squash_exit = jj_cmd_exit(squash_cmd)

    var output = "-- simple_squash --\n"

    if total_errors > 0:
        output = output + "WARNING: " + total_errors.to_string() + " error(s) in changed files:\n"
        for fw in file_warnings:
            output = output + "  " + fw + "\n"
        output = output + "\n"

    output = output + squash_output

    if squash_exit == 0:
        output = output + "\nSquash completed successfully."
    else:
        output = output + "\nSquash failed (exit code " + squash_exit.to_string() + ")."

    make_tool_result(id, output)

fn handle_simple_new(id: text, body: text) -> text:
    val revision = extract_arg(body, "revision")
    val message = extract_arg(body, "message")

    # Create new revision
    var new_cmd = "new"
    if revision != "":
        new_cmd = new_cmd + " " + revision
    if message != "":
        new_cmd = new_cmd + " -m '" + message + "'"
    val new_output = jj_cmd(new_cmd)
    val new_exit = jj_cmd_exit(new_cmd)

    # Get baseline diagnostics for changed files
    val stat_output = jj_cmd("diff -r @ --stat")
    val changed_files = extract_spl_files_from_stat(stat_output)

    var total_errors = 0
    var total_warnings = 0
    var baseline_entries: [text] = []
    for fpath in changed_files:
        val diag = run_diagnostics(fpath)
        total_errors = total_errors + diag.error_count
        total_warnings = total_warnings + diag.warning_count
        if diag.error_count > 0 or diag.warning_count > 0:
            baseline_entries.push("  " + fpath + " " + diag.error_count.to_string() + "E " + diag.warning_count.to_string() + "W")

    # Get revision info
    val rev_info = jj_cmd("log -r @ --limit 1")

    var output = "-- simple_new --\n"
    output = output + new_output + "\n"
    output = output + rev_info

    if baseline_entries.len() > 0:
        output = output + "\n-- baseline diagnostics [" + total_errors.to_string() + "E " + total_warnings.to_string() + "W] --\n"
        for be in baseline_entries:
            output = output + be + "\n"
    else:
        output = output + "\n-- baseline: clean --\n"

    make_tool_result(id, output)

# ============================================================================
# Helpers
# ============================================================================

fn extract_spl_files_from_stat(stat_output: text) -> [text]:
    var files: [text] = []
    val lines = stat_output.split("\n")
    for line in lines:
        val t = line.trim()
        # Format: "path/file.spl | N +++---"
        val pipe_idx = t.index_of(" |") ?? -1
        if pipe_idx > 0:
            val fname = t.substring(0, pipe_idx).trim()
            if fname.ends_with(".spl"):
                files.push(fname)
        elif t.ends_with(".spl"):
            files.push(t)
    files

fn extract_arg(body: text, key: text) -> text:
    val search = "\"" + key + "\":"
    val idx = body.index_of(search) ?? -1
    if idx < 0:
        return ""
    val start = idx + search.len()
    val rest = body.substring(start).trim()
    if not rest.starts_with("\""):
        return ""
    val after_quote = rest.substring(1)
    val end_idx = after_quote.index_of("\"") ?? -1
    if end_idx < 0:
        return ""
    after_quote.substring(0, end_idx)

# ============================================================================
# Exports
# ============================================================================

export handle_simple_diff, handle_simple_log, handle_simple_squash, handle_simple_new
export schema_simple_diff, schema_simple_log, schema_simple_squash, schema_simple_new
