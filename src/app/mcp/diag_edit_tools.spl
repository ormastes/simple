# MCP Diagnostic Edit Tools - Edit with diagnostic delta
#
# Tools:
#   simple_edit       - Edit file with diagnostic delta report
#   simple_multi_edit - Batch edits with single recompile
#   simple_run        - Execute file and capture errors with source annotation

use app.io.mod (file_read, file_write, shell, cwd)
use std.mcp.helpers.{LB, RB, Q, jp, js, jo1, jo2, jo3, parse_int, min_int, extract_arg, make_tool_result, make_error_response, make_tool_schema_multi}
use app.mcp.helpers.{escape_json}
use app.mcp.diag_core.{DiagEntry, DiagResult, DiagDelta, run_diagnostics, overlay_virtual_text, compute_delta, format_delta_text, diag_result_to_json, diag_delta_to_json, severity_tag}
use std.text.{NL}

# ============================================================================
# Tool Schemas
# ============================================================================

fn schema_simple_edit() -> text:
    val path_prop = jo2(jp("type", js("string")), jp("description", js("Path to .spl file to edit")))
    val old_prop = jo2(jp("type", js("string")), jp("description", js("Text to find and replace")))
    val new_prop = jo2(jp("type", js("string")), jp("description", js("Replacement text")))
    val hints_prop = jo2(jp("type", js("string")), jp("description", js("Show easyfix hints (true/false, default: true)")))
    var props = LB()
    props = props + jp("path", path_prop)
    props = props + "," + jp("old_string", old_prop)
    props = props + "," + jp("new_string", new_prop)
    props = props + "," + jp("show_hints", hints_prop)
    props = props + RB()
    val required = "[" + js("path") + "," + js("old_string") + "," + js("new_string") + "]"
    make_tool_schema_multi("simple_edit", "Edit a Simple source file and show diagnostic delta (resolved/introduced errors)", props, required, false, false, false)

fn schema_simple_multi_edit() -> text:
    val path_prop = jo2(jp("type", js("string")), jp("description", js("Path to .spl file to edit")))
    val edits_prop = jo2(jp("type", js("string")), jp("description", js("JSON array of edits: [{old_string: ..., new_string: ...}]")))
    var props = LB()
    props = props + jp("path", path_prop)
    props = props + "," + jp("edits", edits_prop)
    props = props + RB()
    val required = "[" + js("path") + "," + js("edits") + "]"
    make_tool_schema_multi("simple_multi_edit", "Apply multiple edits to a file with single diagnostic pass and delta report", props, required, false, false, false)

fn schema_simple_run() -> text:
    val path_prop = jo2(jp("type", js("string")), jp("description", js("Path to .spl file to run")))
    val args_prop = jo2(jp("type", js("string")), jp("description", js("Arguments to pass to the program")))
    val timeout_prop = jo2(jp("type", js("string")), jp("description", js("Timeout in seconds (default: 10)")))
    var props = LB()
    props = props + jp("path", path_prop)
    props = props + "," + jp("args", args_prop)
    props = props + "," + jp("timeout_sec", timeout_prop)
    props = props + RB()
    make_tool_schema_multi("simple_run", "Execute a Simple source file and capture output with error annotations on source", props, "[" + js("path") + "]", false, false, false)

# ============================================================================
# Handlers
# ============================================================================

fn handle_simple_edit(id: text, body: text) -> text:
    val path = extract_arg(body, "path")
    val old_string = extract_arg(body, "old_string")
    val new_string = extract_arg(body, "new_string")

    if path == "":
        return make_error_response(id, -32602, "Missing required parameter: path")
    if old_string == "":
        return make_error_response(id, -32602, "Missing required parameter: old_string")

    val show_hints_str = extract_arg(body, "show_hints")
    var show_hints = true
    if show_hints_str == "false":
        show_hints = false

    # 1. Baseline diagnostics
    val baseline = run_diagnostics(path)

    # 2. Read and replace
    val content = file_read(path)
    if content == "":
        return make_error_response(id, -32602, "Could not read file: " + path)

    val idx = content.index_of(old_string) ?? -1
    if idx < 0:
        return make_error_response(id, -32602, "old_string not found in file")

    # Perform replacement
    val before = content.substring(0, idx)
    val after = content.substring(idx + old_string.len())
    val new_content = before + new_string + after

    # 3. Write file
    file_write(path, new_content)

    # 4. Post-edit diagnostics
    val current = run_diagnostics(path)

    # 5. Compute delta
    val delta = compute_delta(baseline.entries, current.entries)

    # 6. Find edit line number
    val before_lines = before.split(NL)
    val edit_line = before_lines.len()

    # 7. Format output
    var output = "-- edit " + path + ":" + edit_line.to_string() + " --{NL}"

    # Show a few lines around the edit with virtual text
    val new_lines = new_content.split(NL)
    val context_start = edit_line - 2
    val context_end = edit_line + new_string.split(NL).len() + 2
    var li = 0
    for nl in new_lines:
        li = li + 1
        if li < context_start:
            continue
        if li > context_end:
            break

        # Check for diagnostics on this line
        var line_diag = ""
        for entry in current.entries:
            if entry.line_num == li:
                val tag = severity_tag(entry.severity)
                line_diag = "  # " + tag + " " + entry.message
                break

        val line_prefix = li.to_string() + " | "
        output = output + line_prefix + nl + line_diag + NL

    output = output + NL
    output = output + format_delta_text(delta)

    make_tool_result(id, output)

fn handle_simple_multi_edit(id: text, body: text) -> text:
    val path = extract_arg(body, "path")
    val edits_str = extract_arg(body, "edits")

    if path == "":
        return make_error_response(id, -32602, "Missing required parameter: path")
    if edits_str == "":
        return make_error_response(id, -32602, "Missing required parameter: edits")

    # 1. Baseline diagnostics
    val baseline = run_diagnostics(path)

    # 2. Read content
    var content = file_read(path)
    if content == "":
        return make_error_response(id, -32602, "Could not read file: " + path)

    # 3. Parse edits from JSON-ish string and apply
    # Edits format: each edit has old_string and new_string
    # We apply from bottom of file upward to preserve line numbers
    val edit_pairs = parse_edit_pairs(edits_str)
    var edit_count = 0

    # Apply edits in reverse order (bottom-up)
    var ei = edit_pairs.len() - 1
    for _iter in range(0, edit_pairs.len()):
        if ei < 0:
            break
        val pair = edit_pairs[ei]
        val old_s = pair.old_str
        val new_s = pair.new_str
        val rep_idx = content.index_of(old_s) ?? -1
        if rep_idx >= 0:
            val before = content.substring(0, rep_idx)
            val after = content.substring(rep_idx + old_s.len())
            content = before + new_s + after
            edit_count = edit_count + 1
        ei = ei - 1

    # 4. Write file
    file_write(path, content)

    # 5. Post-edit diagnostics + delta
    val current = run_diagnostics(path)
    val delta = compute_delta(baseline.entries, current.entries)

    # 6. Format output
    var output = "-- multi-edit " + path + " (" + edit_count.to_string() + " edits applied) --{NL}"
    output = output + NL
    output = output + format_delta_text(delta)

    make_tool_result(id, output)

fn handle_simple_run(id: text, body: text) -> text:
    val path = extract_arg(body, "path")
    if path == "":
        return make_error_response(id, -32602, "Missing required parameter: path")

    val args_str = extract_arg(body, "args")
    val timeout_str = extract_arg(body, "timeout_sec")
    var timeout = 10
    if timeout_str != "":
        val tr = parse_int(timeout_str)
        match tr:
            Ok(v): timeout = v
            Err(_): pass

    # Build command
    var cmd = "timeout " + timeout.to_string() + " bin/simple " + path
    if args_str != "":
        cmd = cmd + " " + args_str
    cmd = cmd + " 2>&1"

    val result = shell(cmd)
    val exit_code = result.exit_code ?? 1
    val output = result.stdout ?? ""

    var response = "-- run " + path + " --{NL}"
    response = response + "exit_code: " + exit_code.to_string() + NL

    if exit_code == 124:
        response = response + "TIMEOUT: process killed after " + timeout.to_string() + "s{NL}"

    response = response + "{NL}-- output --{NL}"
    response = response + output

    # If error, try to find crash line and annotate source
    if exit_code != 0:
        val error_line = extract_error_line(output)
        if error_line > 0:
            val source = file_read(path)
            if source != "":
                val src_lines = source.split(NL)
                response = response + "{NL}-- source context --{NL}"
                val ctx_start = error_line - 3
                val ctx_end = error_line + 3
                var li = 0
                for sl in src_lines:
                    li = li + 1
                    if li < ctx_start:
                        continue
                    if li > ctx_end:
                        break
                    var marker = "  "
                    if li == error_line:
                        marker = "> "
                    response = response + marker + li.to_string() + " | " + sl + NL

    make_tool_result(id, response)

# ============================================================================
# Edit pair parsing
# ============================================================================

class EditPair:
    old_str: text
    new_str: text

fn parse_edit_pairs(edits_json: text) -> [EditPair]:
    # Parse simple JSON array of {old_string: "...", new_string: "..."}
    var pairs: [EditPair] = []
    var pos = 0
    val elen = edits_json.len()

    for _iter in range(0, 100):
        if pos >= elen:
            break
        # Find next old_string
        val old_key = "old_string"
        val old_search = "\"" + old_key + "\":"
        val old_idx = find_from(edits_json, old_search, pos)
        if old_idx < 0:
            break
        val old_val_start = old_idx + old_search.len()
        val old_val = extract_quoted_value(edits_json, old_val_start)

        # Find new_string after old_string
        val new_key = "new_string"
        val new_search = "\"" + new_key + "\":"
        val new_idx = find_from(edits_json, new_search, old_val_start)
        if new_idx < 0:
            break
        val new_val_start = new_idx + new_search.len()
        val new_val = extract_quoted_value(edits_json, new_val_start)

        pairs.push(EditPair(old_str: old_val, new_str: new_val))
        pos = new_val_start + new_val.len() + 2

    pairs

fn find_from(s: text, needle: text, start: i64) -> i64:
    if start >= s.len():
        return -1
    val sub = s.substring(start)
    val idx = sub.index_of(needle) ?? -1
    if idx < 0:
        return -1
    start + idx

fn extract_quoted_value(s: text, start: i64) -> text:
    # Find opening quote
    var pos = start
    for _i in range(0, 100):
        if pos >= s.len():
            return ""
        val ch = s.substring(pos, pos + 1)
        if ch == "\"":
            break
        pos = pos + 1
    pos = pos + 1  # skip opening quote

    # Find closing quote (handle escapes)
    var result = ""
    var escaped = false
    for _i in range(0, 10000):
        if pos >= s.len():
            break
        val ch = s.substring(pos, pos + 1)
        if escaped:
            result = result + ch
            escaped = false
        elif ch == "\\":
            escaped = true
        elif ch == "\"":
            break
        else:
            result = result + ch
        pos = pos + 1

    result

# ============================================================================
# Error line extraction
# ============================================================================

fn extract_error_line(output: text) -> i64:
    # Try to find "line N" or ":N:" patterns in error output
    val lines = output.split(NL)
    for line in lines:
        val t = line.trim()
        # Pattern: "at line N"
        if t.starts_with("at line "):
            val rest = t.substring(8)
            val parts = rest.split(" ")
            if parts.len() > 0:
                val lr = parse_int(parts[0])
                match lr:
                    Ok(v): return v
                    Err(_): pass

        # Pattern: "line N:" or "line N:M:"
        val line_idx = t.index_of("line ") ?? -1
        if line_idx >= 0:
            val rest = t.substring(line_idx + 5)
            val colon_idx = rest.index_of(":") ?? -1
            if colon_idx > 0:
                val num_str = rest.substring(0, colon_idx)
                val lr = parse_int(num_str)
                match lr:
                    Ok(v): return v
                    Err(_): pass

        # Pattern: "--> path:N:M"
        if t.starts_with("--> "):
            val arrow = t.substring(4)
            val parts = arrow.split(":")
            val plen = parts.len()
            if plen >= 2:
                val line_str = parts[plen - 2].trim()
                val lr = parse_int(line_str)
                match lr:
                    Ok(v): return v
                    Err(_): pass

    0

# ============================================================================
# Argument extraction helper (same as in diag_read_tools)
# ============================================================================

# extract_arg now imported from lib.mcp

# ============================================================================
# Exports
# ============================================================================

export handle_simple_edit, handle_simple_multi_edit, handle_simple_run
export schema_simple_edit, schema_simple_multi_edit, schema_simple_run
export EditPair
