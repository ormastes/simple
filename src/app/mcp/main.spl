# Full MCP Server for Simple Language
#
# All 34 tools + resources + prompts + completions.
# Protocol: JSON Lines (one JSON object per line).
#
# Tool modules are loaded on-demand via subprocess dispatch.
# Only std.mcp.helpers is imported at startup for fast initialization.
#
# Tool groups:
#   debug_*       (16) - Debug session/breakpoint/inspect tools
#   debug_log_*   (6)  - AOP debug logging tools
#   simple_read/check/symbols/status/expand_at (5)  - Diagnostic read tools
#   simple_edit/multi_edit/run       (3)  - Diagnostic edit tools
#   simple_diff/log/squash/new      (4)  - Diagnostic VCS tools

extern fn rt_file_read_text(path: text) -> text
extern fn rt_file_exists(path: text) -> bool
extern fn rt_process_run(cmd: text, args: [text]) -> text
extern fn rt_env_get(name: text) -> text

# JSON and response helpers (use std.mcp.helpers for fast load â€” no app.io.mod chain)
use std.mcp.helpers.{LB, RB, Q, jp, js, jo1, jo2, jo3, escape_json, extract_json_string_v2, extract_json_value, extract_nested_string, extract_arguments_dict, make_tool_result, make_result_response, make_error_response, min_int}

# Tool handlers loaded on-demand via subprocess dispatch (see dispatch_tool_subprocess)
val HANDLER_DEBUG = "src/app/mcp/handlers/debug_handler.spl"
val HANDLER_DEBUG_LOG = "src/app/mcp/handlers/debug_log_handler.spl"
val HANDLER_DIAG = "src/app/mcp/handlers/diag_handler.spl"

# ============================================================================
# Constants
# ============================================================================

val NL = "\n"
val SERVER_NAME = "simple-mcp"
val SERVER_VERSION = "3.0.0"

# ============================================================================
# Module state
# ============================================================================

# var PROTOCOL = create_protocol_state()  # bypassed: using direct JSON Lines I/O
var TOOLS_CACHE = ""
var INIT_CACHE = ""
var RESOURCES_CACHE = ""
var PROMPTS_CACHE = ""
# Session state removed: tool handlers run as subprocesses

# ============================================================================
# Entry point
# ============================================================================

start_server()

# ============================================================================
# Server loop
# ============================================================================

fn start_server():
    for _iter in range(0, 999999):
        val line = read_stdin_message()
        if line == "":
            return
        val method = extract_json_string_v2(line, "method")
        val id = extract_json_value(line, "id")
        val response = dispatch_method(method, id, line)
        if response == "EXIT":
            return
        if response != "":
            write_stdout_message(response)

# ============================================================================
# Method dispatch
# ============================================================================

fn dispatch_method(method: text, id: text, body: text) -> text:
    if method == "initialize":
        return handle_initialize(id)
    elif method == "initialized":
        return ""
    elif method == "tools/list":
        return handle_tools_list(id)
    elif method == "tools/call":
        val tool_name = extract_nested_string(body, "params", "name")
        return dispatch_tool(id, tool_name, body)
    elif method == "resources/list":
        return handle_resources_list(id)
    elif method == "resources/read":
        val uri = extract_nested_string(body, "params", "uri")
        return handle_resources_read(id, uri)
    elif method == "resources/templates/list":
        return handle_resource_templates_list(id)
    elif method == "prompts/list":
        return handle_prompts_list(id)
    elif method == "prompts/get":
        val prompt_name = extract_nested_string(body, "params", "name")
        return handle_prompts_get(id, prompt_name, body)
    elif method == "completion/complete":
        return handle_completion_req(id, body)
    elif method == "ping":
        return make_result_response(id, LB() + RB())
    elif method == "shutdown":
        return make_result_response(id, "null")
    elif method == "exit":
        return "EXIT"
    elif method.starts_with("notifications/"):
        return ""
    make_error_response(id, -32601, "Method not found: " + method)

# ============================================================================
# Tool dispatch
# ============================================================================

fn dispatch_tool(id: text, tool_name: text, body: text) -> text:
    if tool_name == "":
        return make_error_response(id, -32602, "Missing tool name")
    # Route to handler script based on tool prefix
    var handler_script = ""
    if tool_name.starts_with("debug_log_"):
        handler_script = HANDLER_DEBUG_LOG
    elif tool_name.starts_with("debug_"):
        handler_script = HANDLER_DEBUG
    elif tool_name.starts_with("simple_"):
        handler_script = HANDLER_DIAG
    else:
        return make_error_response(id, -32601, "Unknown tool: " + tool_name)
    dispatch_tool_subprocess(id, tool_name, body, handler_script)

fn dispatch_tool_subprocess(id: text, tool_name: text, body: text, handler_script: text) -> text:
    val runtime_path = get_runtime_path()
    val result = rt_process_run(runtime_path, [handler_script, tool_name, id, body])
    val stdout = result[0]
    val stderr = result[1]
    val exit_str = result[2]
    if exit_str != "0" and exit_str != "":
        return make_error_response(id, -32603, "Handler error: " + stderr)
    if stdout == "":
        return make_error_response(id, -32603, "Handler returned empty response")
    stdout

fn get_runtime_path() -> text:
    val simple_lib = rt_env_get("SIMPLE_LIB") ?? ""
    if simple_lib != "":
        return simple_lib + "/../bin/release/simple"
    "bin/release/simple"

# ============================================================================
# Initialize
# ============================================================================

fn handle_initialize(id: text) -> text:
    if INIT_CACHE != "":
        return make_result_response(id, INIT_CACHE)

    var tools_cap = jo1(jp("listChanged", "true"))
    var resources_cap = jo2(jp("subscribe", "true"), jp("listChanged", "true"))
    var prompts_cap = jo1(jp("listChanged", "true"))

    var caps = LB()
    caps = caps + jp("tools", tools_cap)
    caps = caps + "," + jp("resources", resources_cap)
    caps = caps + "," + jp("prompts", prompts_cap)
    caps = caps + "," + jp("logging", LB() + RB())
    caps = caps + "," + jp("completions", LB() + RB())
    caps = caps + RB()

    var info = LB()
    info = info + jp("name", js(SERVER_NAME))
    info = info + "," + jp("version", js(SERVER_VERSION))
    info = info + "," + jp("instructions", js("Simple language MCP server: 33 tools for debugging, diagnostics, editing, and version control."))
    info = info + RB()

    val result = jo3(jp("protocolVersion", js("2025-06-18")), jp("capabilities", caps), jp("serverInfo", info))
    INIT_CACHE = result
    make_result_response(id, result)

# ============================================================================
# Tools list (cached)
# ============================================================================

fn handle_tools_list(id: text) -> text:
    if TOOLS_CACHE != "":
        return make_result_response(id, TOOLS_CACHE)

    var tools = "[" + debug_tool_schemas()
    tools = tools + "," + debug_log_tool_schemas()
    tools = tools + "," + diag_tool_schemas()
    tools = tools + "]"

    val result = jo1(jp("tools", tools))
    TOOLS_CACHE = result
    make_result_response(id, result)

fn make_tool_schema(name: text, description: text) -> text:
    jo3(jp("name", js(name)), jp("description", js(description)), jp("inputSchema", jo1(jp("type", js("object")))))

fn debug_tool_schemas() -> text:
    var s = make_tool_schema("debug_create_session", "Create a debug session")
    s = s + "," + make_tool_schema("debug_list_sessions", "List active debug sessions")
    s = s + "," + make_tool_schema("debug_close_session", "Close a debug session")
    s = s + "," + make_tool_schema("debug_set_breakpoint", "Set a breakpoint")
    s = s + "," + make_tool_schema("debug_remove_breakpoint", "Remove a breakpoint")
    s = s + "," + make_tool_schema("debug_continue", "Continue execution")
    s = s + "," + make_tool_schema("debug_step", "Step through code")
    s = s + "," + make_tool_schema("debug_get_variables", "Get variable values")
    s = s + "," + make_tool_schema("debug_stack_trace", "Get stack trace")
    s = s + "," + make_tool_schema("debug_evaluate", "Evaluate expression")
    s = s + "," + make_tool_schema("debug_set_function_breakpoint", "Set function breakpoint")
    s = s + "," + make_tool_schema("debug_enable_breakpoint", "Enable/disable breakpoint")
    s = s + "," + make_tool_schema("debug_get_source", "Get source code")
    s = s + "," + make_tool_schema("debug_watch", "Add watch expression")
    s = s + "," + make_tool_schema("debug_set_variable", "Set variable value")
    s = s + "," + make_tool_schema("debug_terminate", "Terminate debug session")
    s

fn debug_log_tool_schemas() -> text:
    var s = make_tool_schema("debug_log_enable", "Enable debug logging")
    s = s + "," + make_tool_schema("debug_log_disable", "Disable debug logging")
    s = s + "," + make_tool_schema("debug_log_clear", "Clear debug logs")
    s = s + "," + make_tool_schema("debug_log_query", "Query debug logs")
    s = s + "," + make_tool_schema("debug_log_tree", "Get debug log tree")
    s = s + "," + make_tool_schema("debug_log_status", "Get debug log status")
    s

fn diag_tool_schemas() -> text:
    var s = make_tool_schema("simple_read", "Read Simple source with diagnostics")
    s = s + "," + make_tool_schema("simple_check", "Check Simple source for errors")
    s = s + "," + make_tool_schema("simple_symbols", "List symbols in file")
    s = s + "," + make_tool_schema("simple_status", "Get project status")
    s = s + "," + make_tool_schema("simple_expand_at", "Expand symbol at position")
    s = s + "," + make_tool_schema("simple_edit", "Edit Simple source file")
    s = s + "," + make_tool_schema("simple_multi_edit", "Edit multiple files")
    s = s + "," + make_tool_schema("simple_run", "Run Simple code")
    s = s + "," + make_tool_schema("simple_diff", "Show file diff")
    s = s + "," + make_tool_schema("simple_log", "Show version history")
    s = s + "," + make_tool_schema("simple_squash", "Squash commits")
    s = s + "," + make_tool_schema("simple_new", "Create new change")
    s

# ============================================================================
# Resources
# ============================================================================

fn make_resource_json(uri: text, name: text, desc: text, mime: text) -> text:
    var r = LB()
    r = r + jp("uri", js(uri))
    r = r + "," + jp("name", js(name))
    if desc != "":
        r = r + "," + jp("description", js(desc))
    if mime != "":
        r = r + "," + jp("mimeType", js(mime))
    r = r + RB()
    r

fn build_resources_json() -> text:
    var r = make_resource_json("project:///info", "Project Information", "Project metadata and manifest", "text/plain")
    r = r + "," + make_resource_json("file:///*", "File Contents", "Read file contents", "text/plain")
    r = r + "," + make_resource_json("symbol:///*", "Symbol Information", "Get symbol details", "application/json")
    r = r + "," + make_resource_json("type:///*", "Type Information", "Get type details", "application/json")
    r = r + "," + make_resource_json("docs:///*", "Documentation", "Get documentation", "text/markdown")
    r = r + "," + make_resource_json("tree:///*", "Directory Tree", "Get directory structure", "text/plain")
    # BugDB
    r = r + "," + make_resource_json("bugdb:///all", "All Bugs", "All bugs from bug database", "application/json")
    r = r + "," + make_resource_json("bugdb:///open", "Open Bugs", "Open bugs from bug database", "application/json")
    r = r + "," + make_resource_json("bugdb:///critical", "Critical Bugs", "Critical bugs (P0/P1)", "application/json")
    r = r + "," + make_resource_json("bugdb:///stats", "Bug Statistics", "Bug database statistics", "application/json")
    # FeatureDB
    r = r + "," + make_resource_json("featuredb:///all", "All Features", "All features from feature database", "application/json")
    r = r + "," + make_resource_json("featuredb:///stats", "Feature Statistics", "Feature database statistics", "application/json")
    # TestDB
    r = r + "," + make_resource_json("testdb:///runs", "Test Runs", "All test runs", "application/json")
    r = r + "," + make_resource_json("testdb:///stats", "Test Statistics", "Test statistics", "application/json")
    r = r + "," + make_resource_json("testdb:///flaky", "Flaky Tests", "Flaky tests", "application/json")
    # Debug Log
    r = r + "," + make_resource_json("debuglog:///tree", "Debug Log Tree", "Collapsible call tree from AOP debug logger", "application/json")
    r = r + "," + make_resource_json("debuglog:///entries", "Debug Log Entries", "All debug log entries", "application/json")
    r = r + "," + make_resource_json("debuglog:///status", "Debug Log Status", "Current debug logging status", "application/json")
    r = r + "," + make_resource_json("debuglog:///text", "Debug Log Text", "Plain text call tree", "text/plain")
    "[" + r + "]"

fn handle_resources_list(id: text) -> text:
    if RESOURCES_CACHE != "":
        return make_result_response(id, RESOURCES_CACHE)
    val result = jo1(jp("resources", build_resources_json()))
    RESOURCES_CACHE = result
    make_result_response(id, result)

fn handle_resource_templates_list(id: text) -> text:
    var t1 = LB()
    t1 = t1 + jp("uriTemplate", js("file:///" + LB() + "path" + RB()))
    t1 = t1 + "," + jp("name", js("File Contents"))
    t1 = t1 + "," + jp("description", js("Read file contents by path"))
    t1 = t1 + "," + jp("mimeType", js("text/plain"))
    t1 = t1 + RB()

    var t2 = LB()
    t2 = t2 + jp("uriTemplate", js("symbol:///" + LB() + "symbol_name" + RB()))
    t2 = t2 + "," + jp("name", js("Symbol Information"))
    t2 = t2 + "," + jp("description", js("Get symbol details by name"))
    t2 = t2 + "," + jp("mimeType", js("application/json"))
    t2 = t2 + RB()

    var t3 = LB()
    t3 = t3 + jp("uriTemplate", js("type:///" + LB() + "type_name" + RB()))
    t3 = t3 + "," + jp("name", js("Type Information"))
    t3 = t3 + "," + jp("description", js("Get type details by name"))
    t3 = t3 + "," + jp("mimeType", js("application/json"))
    t3 = t3 + RB()

    var t4 = LB()
    t4 = t4 + jp("uriTemplate", js("docs:///" + LB() + "path" + RB()))
    t4 = t4 + "," + jp("name", js("Documentation"))
    t4 = t4 + "," + jp("description", js("Get documentation by path"))
    t4 = t4 + "," + jp("mimeType", js("text/markdown"))
    t4 = t4 + RB()

    var t5 = LB()
    t5 = t5 + jp("uriTemplate", js("tree:///" + LB() + "path" + RB()))
    t5 = t5 + "," + jp("name", js("Directory Tree"))
    t5 = t5 + "," + jp("description", js("Get directory structure"))
    t5 = t5 + "," + jp("mimeType", js("text/plain"))
    t5 = t5 + RB()

    val templates = "[" + t1 + "," + t2 + "," + t3 + "," + t4 + "," + t5 + "]"
    val result = jo1(jp("resourceTemplates", templates))
    make_result_response(id, result)

fn handle_resources_read(id: text, uri: text) -> text:
    if uri == "":
        return make_error_response(id, -32602, "Missing required parameter: uri")

    # project:///info
    if uri == "project:///info":
        return handle_resource_project_info(id, uri)

    # file:///path
    if uri.starts_with("file:///"):
        val path = uri.substring(8)
        return handle_resource_file(id, uri, path)

    # debuglog:///... (dispatched to handler subprocess)
    if uri.starts_with("debuglog:///"):
        val log_result = rt_process_run(get_runtime_path(), [HANDLER_DEBUG_LOG, "__resource__", id, uri])
        val log_stdout = log_result[0]
        if log_stdout != "":
            return log_stdout
        return make_resource_content_response(id, uri, "[]", "application/json")

    make_error_response(id, -32002, "Resource not found: " + uri)

fn handle_resource_project_info(id: text, uri: text) -> text:
    var info = "Simple Language Compiler" + NL
    info = info + "Working Dir: " + get_cwd() + NL
    val test_file = rt_file_read_text("doc/test/test_result.md") ?? ""
    if test_file != "":
        # Show first 500 chars of test results
        var limit = test_file.len()
        if limit > 500:
            limit = 500
        info = info + NL + "Recent Test Results:" + NL
        info = info + test_file.substring(0, limit)
    make_resource_content_response(id, uri, info, "text/plain")

fn handle_resource_file(id: text, uri: text, path: text) -> text:
    val file_found = rt_file_exists(path)
    if not file_found:
        return make_error_response(id, -32002, "File not found: " + path)
    val content = rt_file_read_text(path) ?? ""
    var mime = "text/plain"
    if path.ends_with(".json"):
        mime = "application/json"
    elif path.ends_with(".md"):
        mime = "text/markdown"
    make_resource_content_response(id, uri, content, mime)

fn make_resource_content_response(id: text, uri: text, content: text, mime: text) -> text:
    var rc = LB()
    rc = rc + jp("uri", js(uri))
    rc = rc + "," + jp("mimeType", js(mime))
    rc = rc + "," + jp("text", js(escape_json(content)))
    rc = rc + RB()
    val result = jo1(jp("contents", "[" + rc + "]"))
    make_result_response(id, result)

# ============================================================================
# Prompts
# ============================================================================

fn make_prompt_arg(name: text, desc: text, required: bool) -> text:
    var r = LB()
    r = r + jp("name", js(name))
    r = r + "," + jp("description", js(desc))
    var req_str = "false"
    if required:
        req_str = "true"
    r = r + "," + jp("required", req_str)
    r = r + RB()
    r

fn make_prompt_json(name: text, desc: text, args_json: text) -> text:
    var r = LB()
    r = r + jp("name", js(name))
    r = r + "," + jp("description", js(desc))
    r = r + "," + jp("arguments", args_json)
    r = r + RB()
    r

fn build_prompts_json() -> text:
    # Refactoring prompts
    var p1 = make_prompt_json("refactor-rename", "Rename a symbol throughout the codebase", "[" + make_prompt_arg("old_name", "Current symbol name", true) + "," + make_prompt_arg("new_name", "New symbol name", true) + "," + make_prompt_arg("file", "File containing the symbol", false) + "]")
    var p2 = make_prompt_json("refactor-extract-function", "Extract code into a new function", "[" + make_prompt_arg("code", "Code to extract", true) + "," + make_prompt_arg("function_name", "Name for new function", true) + "," + make_prompt_arg("file", "File containing the code", true) + "]")
    var p3 = make_prompt_json("refactor-inline", "Inline a function or variable", "[" + make_prompt_arg("name", "Symbol to inline", true) + "," + make_prompt_arg("file", "File containing the symbol", true) + "]")
    # Code generation prompts
    var p4 = make_prompt_json("generate-tests", "Generate SSpec tests for a function or class", "[" + make_prompt_arg("target", "Function or class name", true) + "," + make_prompt_arg("file", "File containing the target", true) + "]")
    var p5 = make_prompt_json("generate-trait-impl", "Generate trait implementation for a class", "[" + make_prompt_arg("class_name", "Class name", true) + "," + make_prompt_arg("trait_name", "Trait name", true) + "," + make_prompt_arg("file", "File containing the class", true) + "]")
    var p6 = make_prompt_json("generate-constructor", "Generate constructor for a class", "[" + make_prompt_arg("class_name", "Class name", true) + "," + make_prompt_arg("file", "File containing the class", true) + "]")
    # Documentation prompts
    var p7 = make_prompt_json("docs-add-docstrings", "Add documentation comments to functions and classes", "[" + make_prompt_arg("target", "Function or class name", false) + "," + make_prompt_arg("file", "File to document", true) + "]")
    var p8 = make_prompt_json("docs-explain-code", "Explain how code works", "[" + make_prompt_arg("code", "Code to explain", false) + "," + make_prompt_arg("file", "File containing the code", false) + "]")
    var p9 = make_prompt_json("docs-generate-readme", "Generate README.md for the project", "[]")
    # Analysis prompts
    var p10 = make_prompt_json("analyze-find-bugs", "Analyze code for potential bugs", "[" + make_prompt_arg("file", "File to analyze", true) + "]")
    var p11 = make_prompt_json("analyze-suggest-improvements", "Suggest code improvements", "[" + make_prompt_arg("file", "File to analyze", true) + "]")
    var p12 = make_prompt_json("analyze-performance", "Analyze code for performance issues", "[" + make_prompt_arg("file", "File to analyze", true) + "]")

    var all = "[" + p1
    all = all + "," + p2
    all = all + "," + p3
    all = all + "," + p4
    all = all + "," + p5
    all = all + "," + p6
    all = all + "," + p7
    all = all + "," + p8
    all = all + "," + p9
    all = all + "," + p10
    all = all + "," + p11
    all = all + "," + p12
    all = all + "]"
    all

fn handle_prompts_list(id: text) -> text:
    if PROMPTS_CACHE != "":
        return make_result_response(id, PROMPTS_CACHE)
    val result = jo1(jp("prompts", build_prompts_json()))
    PROMPTS_CACHE = result
    make_result_response(id, result)

fn handle_prompts_get(id: text, prompt_name: text, body: text) -> text:
    if prompt_name == "":
        return make_error_response(id, -32602, "Missing required parameter: name")

    # Extract arguments from request
    val args_json = extract_arguments_dict(body)

    # Build prompt messages based on prompt name
    if prompt_name == "refactor-rename":
        val old_name = extract_json_string_v2(args_json, "old_name")
        val new_name = extract_json_string_v2(args_json, "new_name")
        val file = extract_json_string_v2(args_json, "file")
        var content = "Rename the symbol '" + old_name + "' to '" + new_name + "' throughout the codebase."
        if file != "":
            content = content + " Start with file: " + file
        return make_prompt_response(id, "Rename symbol", content)
    elif prompt_name == "refactor-extract-function":
        val code = extract_json_string_v2(args_json, "code")
        val fn_name = extract_json_string_v2(args_json, "function_name")
        val file = extract_json_string_v2(args_json, "file")
        val content = "Extract the following code into a new function named '" + fn_name + "' in " + file + ":" + NL + NL + code
        return make_prompt_response(id, "Extract function", content)
    elif prompt_name == "refactor-inline":
        val sym_name = extract_json_string_v2(args_json, "name")
        val file = extract_json_string_v2(args_json, "file")
        val content = "Inline the symbol '" + sym_name + "' in " + file + ". Replace all uses with the definition and remove the original."
        return make_prompt_response(id, "Inline symbol", content)
    elif prompt_name == "generate-tests":
        val target = extract_json_string_v2(args_json, "target")
        val file = extract_json_string_v2(args_json, "file")
        val content = "Generate comprehensive SSpec tests for '" + target + "' defined in " + file + ". Use describe/it blocks with expect().to_equal() matchers."
        return make_prompt_response(id, "Generate tests", content)
    elif prompt_name == "generate-trait-impl":
        val cls = extract_json_string_v2(args_json, "class_name")
        val trait_n = extract_json_string_v2(args_json, "trait_name")
        val file = extract_json_string_v2(args_json, "file")
        val content = "Generate trait implementation of '" + trait_n + "' for class '" + cls + "' in " + file + "."
        return make_prompt_response(id, "Generate trait impl", content)
    elif prompt_name == "generate-constructor":
        val cls = extract_json_string_v2(args_json, "class_name")
        val file = extract_json_string_v2(args_json, "file")
        val content = "Generate a constructor (static fn create) for class '" + cls + "' in " + file + "."
        return make_prompt_response(id, "Generate constructor", content)
    elif prompt_name == "docs-add-docstrings":
        val target = extract_json_string_v2(args_json, "target")
        val file = extract_json_string_v2(args_json, "file")
        var content = "Add documentation comments to all public functions and classes in " + file + "."
        if target != "":
            content = "Add documentation comments to '" + target + "' in " + file + "."
        return make_prompt_response(id, "Add docstrings", content)
    elif prompt_name == "docs-explain-code":
        val code = extract_json_string_v2(args_json, "code")
        val file = extract_json_string_v2(args_json, "file")
        var content = "Explain how this code works"
        if file != "":
            content = content + " (from " + file + ")"
        if code != "":
            content = content + ":" + NL + NL + code
        return make_prompt_response(id, "Explain code", content)
    elif prompt_name == "docs-generate-readme":
        return make_prompt_response(id, "Generate README", "Generate a comprehensive README.md for the Simple language compiler project.")
    elif prompt_name == "analyze-find-bugs":
        val file = extract_json_string_v2(args_json, "file")
        val content = "Analyze " + file + " for potential bugs, null pointer issues, off-by-one errors, and logic flaws."
        return make_prompt_response(id, "Find bugs", content)
    elif prompt_name == "analyze-suggest-improvements":
        val file = extract_json_string_v2(args_json, "file")
        val content = "Suggest improvements for " + file + ": refactoring opportunities, better patterns, simplifications."
        return make_prompt_response(id, "Suggest improvements", content)
    elif prompt_name == "analyze-performance":
        val file = extract_json_string_v2(args_json, "file")
        val content = "Analyze " + file + " for performance issues: unnecessary allocations, O(n^2) patterns, redundant computations."
        return make_prompt_response(id, "Analyze performance", content)
    make_error_response(id, -32601, "Unknown prompt: " + prompt_name)

fn make_prompt_response(id: text, description: text, user_content: text) -> text:
    var msg = LB()
    msg = msg + jp("role", js("user"))
    var content_obj = LB()
    content_obj = content_obj + jp("type", js("text"))
    content_obj = content_obj + "," + jp("text", js(escape_json(user_content)))
    content_obj = content_obj + RB()
    msg = msg + "," + jp("content", content_obj)
    msg = msg + RB()

    var result = LB()
    result = result + jp("description", js(escape_json(description)))
    result = result + "," + jp("messages", "[" + msg + "]")
    result = result + RB()
    make_result_response(id, result)

# ============================================================================
# Completion
# ============================================================================

fn handle_completion_req(id: text, body: text) -> text:
    # Return empty completion results
    var completion = LB()
    completion = completion + jp("values", "[]")
    completion = completion + "," + jp("total", "0")
    completion = completion + "," + jp("hasMore", "false")
    completion = completion + RB()
    val result = jo1(jp("completion", completion))
    make_result_response(id, result)

# ============================================================================
# Protocol I/O (thin delegation to lib.mcp.protocol)
# ============================================================================

fn read_stdin_message() -> text:
    """Read one JSON Lines message from stdin. Returns "" on EOF."""
    var line = input()
    if line == "":
        return ""
    if line.ends_with("\r"):
        line = line.substring(0, line.len() - 1)
    line

fn write_stdout_message(body: text):
    """Write one JSON Lines message to stdout."""
    print_raw(body + NL)

# ============================================================================
# Local helpers
# ============================================================================

fn get_cwd() -> text:
    var args: [text] = ["-c", "pwd"]
    val result = rt_process_run("/bin/sh", args)
    var out = result[0]
    if out.ends_with("\n"):
        out = out.substring(0, out.len() - 1)
    out
