# MCP (Model Context Protocol) Server for Simple Language
# Provides LLM-friendly code representation via the MCP protocol
#
# Usage:
#   simple mcp server              # Start MCP server (stdio mode)
#   simple mcp server --debug      # Start with debug logging
#   simple mcp <file.spl>          # Generate MCP preview (CLI mode)
#   simple mcp read <file.spl>     # Read file in MCP mode
#   simple mcp expand <file> <sym> # Expand specific symbol
#   simple mcp json <file.spl>     # Generate JSON output

# I/O imports
use app.io.mod (file_read, get_args, exit, shell, cwd, rt_debug_set_active, rt_debug_add_breakpoint_at, rt_debug_remove_breakpoint_at, rt_debug_continue_exec, rt_debug_pause_exec, rt_debug_set_step_mode_val, rt_debug_stack_trace_lines, rt_debug_local_vars, rt_debug_get_current_file, rt_debug_get_current_line, rt_debug_add_breakpoint_rich, rt_debug_add_function_breakpoint, rt_debug_set_breakpoint_enabled, rt_debug_get_breakpoint_info, rt_debug_list_breakpoints, rt_debug_get_source_lines, rt_debug_add_watch, rt_debug_remove_watch, rt_debug_list_watches, rt_debug_set_variable, rt_debug_eval_expression, rt_debug_terminate, rt_debug_select_frame, rt_debug_get_selected_frame, rt_debug_frame_locals)

# MCP modules
use app.mcp.resources
use app.mcp.prompts
use app.mcp.bugdb_resource
use app.mcp.helpers.{LB, RB, Q, parse_int, min_int, unwrap_idx, unwrap_str, get_clean_args, jp, js, jo1, jo2, jo3, extract_json_string_v2, extract_json_string, extract_json_value, extract_nested_string, extract_arguments_dict, escape_json, read_file_safe, list_spl_files, make_tool_result, make_result_response, make_error_response, make_tool_schema_multi, has_flag}
use app.mcp.debug_tools.{SessionManager, SessionBreakpoint, schema_debug_create_session, schema_debug_list_sessions, schema_debug_close_session, schema_debug_set_breakpoint, schema_debug_remove_breakpoint, schema_debug_continue, schema_debug_step, schema_debug_get_variables, schema_debug_stack_trace, schema_debug_evaluate, schema_debug_set_function_breakpoint, schema_debug_enable_breakpoint, schema_debug_get_source, schema_debug_watch, schema_debug_set_variable, schema_debug_terminate, handle_debug_create_session, handle_debug_list_sessions, handle_debug_close_session, handle_debug_set_breakpoint, handle_debug_remove_breakpoint, handle_debug_continue, handle_debug_step, handle_debug_get_variables, handle_debug_stack_trace, handle_debug_evaluate, handle_debug_set_function_breakpoint, handle_debug_enable_breakpoint, handle_debug_get_source, handle_debug_watch, handle_debug_set_variable, handle_debug_terminate, parse_var_entry, parse_stack_frame, step_mode_to_int}

# Main entry point
fn main():
    val raw_args = get_args()
    val args = get_clean_args(raw_args)

    if args.len() < 1:
        print_usage()
        exit(1)

    val command = args[0]

    if command == "--help" or command == "-h":
        print_usage()
        exit(0)

    elif command == "server":
        val debug_mode = has_flag(args, "--debug")
        start_server(debug_mode)

    elif command == "read":
        handle_read(args)

    elif command == "expand":
        handle_expand(args)

    elif command == "search":
        handle_search(args)

    elif command == "json":
        handle_json(args)

    else:
        handle_default_read(args)

# Print usage information
fn print_usage():
    print("MCP (Model Context Protocol) Server for Simple Language")
    print("")
    print("Usage:")
    print("  simple mcp server [--debug]          # Start MCP server (stdio)")
    print("  simple mcp <file.spl>                # Generate MCP outline")
    print("  simple mcp read <file.spl>           # Read file in MCP mode")
    print("  simple mcp expand <file.spl> <sym>   # Expand specific symbol")
    print("  simple mcp search <query>            # Search for symbols")
    print("  simple mcp json <file.spl> [--meta]  # Generate JSON output")
    print("")
    print("Server Mode:")
    print("  The server mode implements the Model Context Protocol over stdio.")
    print("  It can be used with MCP-compatible clients like Claude Code.")
    print("")
    print("Options:")
    print("  --help, -h          Show this help message")
    print("  --debug             Enable debug logging (server mode)")
    print("  --all               Show private symbols too")
    print("  --meta              Include metadata in JSON output")
    print("  --expand=<what>     What to expand: signature|body|all")
    print("  --show-coverage     Display test coverage overlays")
    print("")
    print("Examples:")
    print("  simple mcp server                    # Start MCP server")
    print("  simple mcp user.spl")
    print("  simple mcp expand user.spl User")
    print("  simple mcp json user.spl --meta")

# --- MCP JSON-RPC Server (stdio) ---

fn start_server(debug_mode: Bool):
    if debug_mode:
        debug_log("MCP server starting in debug mode")

    # Initialize resource, prompt, and debug session managers
    val project_root = get_current_dir()
    val resource_mgr = resources.ResourceManager.create(project_root)
    val prompt_mgr = prompts.PromptManager.create(project_root)
    var session_mgr = SessionManager.empty()

    if debug_mode:
        debug_log("Initialized with project root: " + project_root)

    # Send nothing until we get initialize request
    var running = true
    for _iter in range(0, 999999):
        if not running:
            return
        val line = read_stdin_message()
        if line == "":
            running = false
        else:
            # Check if this is a debug tool call (must be handled inline for session_mgr mutation)
            val method = extract_json_string_v2(line, "method")
            val id = extract_json_value(line, "id")
            var response = ""
            var is_debug = false
            var tool_name = ""
            if method == "tools/call":
                tool_name = extract_nested_string(line, "params", "name")
                is_debug = tool_name.starts_with("debug_")

            if is_debug:
                if debug_mode:
                    debug_log("Debug tool call (inline): " + tool_name)
                # INLINE debug dispatch: session_mgr mutations must stay in this scope
                if tool_name == "debug_create_session":
                    val d_program = extract_nested_string(line, "arguments", "program")
                    if d_program == "":
                        response = make_error_response(id, -32602, "Missing required parameter: program")
                    else:
                        var d_tt = extract_nested_string(line, "arguments", "target_type")
                        if d_tt == "":
                            d_tt = "interpreter"
                        val d_session = session_mgr.create_session(d_program, d_tt)
                        rt_debug_set_active(true)
                        var d_r = LB()
                        d_r = d_r + jp("session_id", js(d_session.id))
                        d_r = d_r + "," + jp("program", js(d_session.program))
                        d_r = d_r + "," + jp("target_type", js(d_session.target_type))
                        d_r = d_r + "," + jp("state", js(d_session.state))
                        d_r = d_r + RB()
                        response = make_tool_result(id, d_r)
                elif tool_name == "debug_list_sessions":
                    val d_sessions = session_mgr.list_sessions()
                    var d_arr = "["
                    var d_first = true
                    for d_s in d_sessions:
                        if not d_first:
                            d_arr = d_arr + ","
                        d_first = false
                        var d_obj = LB()
                        d_obj = d_obj + jp("session_id", js(d_s.id))
                        d_obj = d_obj + "," + jp("program", js(d_s.program))
                        d_obj = d_obj + "," + jp("target_type", js(d_s.target_type))
                        d_obj = d_obj + "," + jp("state", js(d_s.state))
                        d_obj = d_obj + RB()
                        d_arr = d_arr + d_obj
                    d_arr = d_arr + "]"
                    response = make_tool_result(id, d_arr)
                elif tool_name == "debug_close_session":
                    val d_sid = extract_nested_string(line, "arguments", "session_id")
                    if d_sid == "":
                        response = make_error_response(id, -32602, "Missing required parameter: session_id")
                    else:
                        val d_removed = session_mgr.remove_session(d_sid)
                        if not d_removed:
                            response = make_error_response(id, -32602, "Session not found: " + d_sid)
                        else:
                            val d_remaining = session_mgr.list_sessions()
                            if d_remaining.len() == 0:
                                rt_debug_set_active(false)
                            var d_r = LB()
                            d_r = d_r + jp("closed", js(d_sid))
                            d_r = d_r + "," + jp("status", js("ok"))
                            d_r = d_r + RB()
                            response = make_tool_result(id, d_r)
                elif tool_name == "debug_set_breakpoint":
                    val d_sid = extract_nested_string(line, "arguments", "session_id")
                    val d_file = extract_nested_string(line, "arguments", "file")
                    val d_line_str = extract_nested_string(line, "arguments", "line")
                    if d_sid == "":
                        response = make_error_response(id, -32602, "Missing required parameter: session_id")
                    elif d_file == "":
                        response = make_error_response(id, -32602, "Missing required parameter: file")
                    elif d_line_str == "":
                        response = make_error_response(id, -32602, "Missing required parameter: line")
                    else:
                        val d_lr = parse_int(d_line_str)
                        var d_line = 0
                        match d_lr:
                            Ok(v): d_line = v
                            Err(e): d_line = -1
                        if d_line < 0:
                            response = make_error_response(id, -32602, "Invalid line number: " + d_line_str)
                        else:
                            val d_cond = extract_nested_string(line, "arguments", "condition")
                            val d_bp_id = session_mgr.add_breakpoint(d_sid, d_file, d_line, d_cond)
                            if d_bp_id == "":
                                response = make_error_response(id, -32602, "Session not found: " + d_sid)
                            else:
                                rt_debug_add_breakpoint_at(d_file, d_line)
                                var d_r = LB()
                                d_r = d_r + jp("breakpoint_id", d_bp_id)
                                d_r = d_r + "," + jp("session_id", js(d_sid))
                                d_r = d_r + "," + jp("file", js(d_file))
                                d_r = d_r + "," + jp("line", d_line.to_string())
                                d_r = d_r + "," + jp("verified", "true")
                                d_r = d_r + RB()
                                response = make_tool_result(id, d_r)
                elif tool_name == "debug_remove_breakpoint":
                    val d_sid = extract_nested_string(line, "arguments", "session_id")
                    val d_bp_id_str = extract_nested_string(line, "arguments", "breakpoint_id")
                    if d_sid == "":
                        response = make_error_response(id, -32602, "Missing required parameter: session_id")
                    elif d_bp_id_str == "":
                        response = make_error_response(id, -32602, "Missing required parameter: breakpoint_id")
                    else:
                        val d_sidx = session_mgr.find_session(d_sid)
                        if d_sidx >= 0:
                            val d_sess = session_mgr.sessions[d_sidx]
                            val d_bpr = parse_int(d_bp_id_str)
                            var d_bpi = -1
                            match d_bpr:
                                Ok(v): d_bpi = v
                                Err(_): pass
                            for d_bp in d_sess.breakpoints:
                                if d_bp.id == d_bpi:
                                    rt_debug_remove_breakpoint_at(d_bp.file, d_bp.line)
                        val d_removed = session_mgr.remove_breakpoint(d_sid, d_bp_id_str)
                        if not d_removed:
                            response = make_error_response(id, -32602, "Breakpoint not found: " + d_bp_id_str)
                        else:
                            var d_r = LB()
                            d_r = d_r + jp("removed", js(d_bp_id_str))
                            d_r = d_r + "," + jp("status", js("ok"))
                            d_r = d_r + RB()
                            response = make_tool_result(id, d_r)
                elif tool_name == "debug_continue":
                    val d_sid = extract_nested_string(line, "arguments", "session_id")
                    if d_sid == "":
                        response = make_error_response(id, -32602, "Missing required parameter: session_id")
                    else:
                        val d_found = session_mgr.set_state(d_sid, "running")
                        if not d_found:
                            response = make_error_response(id, -32602, "Session not found: " + d_sid)
                        else:
                            rt_debug_continue_exec()
                            var d_r = LB()
                            d_r = d_r + jp("session_id", js(d_sid))
                            d_r = d_r + "," + jp("state", js("running"))
                            d_r = d_r + RB()
                            response = make_tool_result(id, d_r)
                elif tool_name == "debug_step":
                    val d_sid = extract_nested_string(line, "arguments", "session_id")
                    val d_mode = extract_nested_string(line, "arguments", "mode")
                    if d_sid == "":
                        response = make_error_response(id, -32602, "Missing required parameter: session_id")
                    elif d_mode == "":
                        response = make_error_response(id, -32602, "Missing required parameter: mode")
                    else:
                        val d_step_int = step_mode_to_int(d_mode)
                        if d_step_int == 0:
                            response = make_error_response(id, -32602, "Invalid step mode: " + d_mode + ". Must be over, in, or out")
                        else:
                            val d_found = session_mgr.set_state(d_sid, "paused")
                            if not d_found:
                                response = make_error_response(id, -32602, "Session not found: " + d_sid)
                            else:
                                rt_debug_set_step_mode_val(d_step_int)
                                var d_r = LB()
                                d_r = d_r + jp("session_id", js(d_sid))
                                d_r = d_r + "," + jp("mode", js(d_mode))
                                d_r = d_r + "," + jp("state", js("paused"))
                                d_r = d_r + RB()
                                response = make_tool_result(id, d_r)
                elif tool_name == "debug_get_variables":
                    val d_sid = extract_nested_string(line, "arguments", "session_id")
                    if d_sid == "":
                        response = make_error_response(id, -32602, "Missing required parameter: session_id")
                    else:
                        val d_idx = session_mgr.find_session(d_sid)
                        if d_idx < 0:
                            response = make_error_response(id, -32602, "Session not found: " + d_sid)
                        else:
                            val d_raw_vars = rt_debug_local_vars()
                            var d_vars = "["
                            var d_first = true
                            for d_raw in d_raw_vars:
                                if not d_first:
                                    d_vars = d_vars + ","
                                d_first = false
                                d_vars = d_vars + parse_var_entry(d_raw)
                            d_vars = d_vars + "]"
                            var d_r = LB()
                            d_r = d_r + jp("session_id", js(d_sid))
                            d_r = d_r + "," + jp("variables", d_vars)
                            d_r = d_r + RB()
                            response = make_tool_result(id, d_r)
                elif tool_name == "debug_stack_trace":
                    val d_sid = extract_nested_string(line, "arguments", "session_id")
                    if d_sid == "":
                        response = make_error_response(id, -32602, "Missing required parameter: session_id")
                    else:
                        val d_idx = session_mgr.find_session(d_sid)
                        if d_idx < 0:
                            response = make_error_response(id, -32602, "Session not found: " + d_sid)
                        else:
                            val d_sess = session_mgr.sessions[d_idx]
                            val d_raw_frames = rt_debug_stack_trace_lines()
                            var d_frames = "["
                            if d_raw_frames.len() > 0:
                                var d_first = true
                                var d_fi = 0
                                for d_raw in d_raw_frames:
                                    if not d_first:
                                        d_frames = d_frames + ","
                                    d_first = false
                                    d_frames = d_frames + parse_stack_frame(d_fi, d_raw)
                                    d_fi = d_fi + 1
                            else:
                                val d_cf = rt_debug_get_current_file()
                                val d_cl = rt_debug_get_current_line()
                                var d_source = d_sess.program
                                if d_cf != "":
                                    d_source = d_cf
                                var d_ln = 1
                                if d_cl > 0:
                                    d_ln = d_cl
                                var d_frame = LB()
                                d_frame = d_frame + jp("id", "0")
                                d_frame = d_frame + "," + jp("name", js("main"))
                                d_frame = d_frame + "," + jp("source", js(escape_json(d_source)))
                                d_frame = d_frame + "," + jp("line", d_ln.to_string())
                                d_frame = d_frame + RB()
                                d_frames = d_frames + d_frame
                            d_frames = d_frames + "]"
                            var d_total = d_raw_frames.len()
                            if d_total == 0:
                                d_total = 1
                            var d_r = LB()
                            d_r = d_r + jp("session_id", js(d_sid))
                            d_r = d_r + "," + jp("frames", d_frames)
                            d_r = d_r + "," + jp("total_frames", d_total.to_string())
                            d_r = d_r + RB()
                            response = make_tool_result(id, d_r)
                elif tool_name == "debug_evaluate":
                    val d_sid = extract_nested_string(line, "arguments", "session_id")
                    val d_expr = extract_nested_string(line, "arguments", "expression")
                    if d_sid == "":
                        response = make_error_response(id, -32602, "Missing required parameter: session_id")
                    elif d_expr == "":
                        response = make_error_response(id, -32602, "Missing required parameter: expression")
                    else:
                        val d_idx = session_mgr.find_session(d_sid)
                        if d_idx < 0:
                            response = make_error_response(id, -32602, "Session not found: " + d_sid)
                        else:
                            val d_frame_str = extract_nested_string(line, "arguments", "frame_index")
                            var d_fi = 0
                            if d_frame_str != "":
                                val d_fir = parse_int(d_frame_str)
                                match d_fir:
                                    Ok(v): d_fi = v
                                    Err(_): pass
                            val d_ej = rt_debug_eval_expression(d_expr, d_fi)
                            val d_res = extract_json_string_v2(d_ej, "result")
                            val d_typ = extract_json_string_v2(d_ej, "type")
                            val d_err = extract_json_string_v2(d_ej, "error")
                            var d_display = d_res
                            if d_err != "":
                                d_display = d_err
                            var d_r = LB()
                            d_r = d_r + jp("session_id", js(d_sid))
                            d_r = d_r + "," + jp("expression", js(escape_json(d_expr)))
                            d_r = d_r + "," + jp("result", js(escape_json(d_display)))
                            d_r = d_r + "," + jp("type", js(d_typ))
                            d_r = d_r + RB()
                            response = make_tool_result(id, d_r)
                elif tool_name == "debug_set_function_breakpoint":
                    val d_sid = extract_nested_string(line, "arguments", "session_id")
                    val d_func = extract_nested_string(line, "arguments", "function_name")
                    if d_sid == "":
                        response = make_error_response(id, -32602, "Missing required parameter: session_id")
                    elif d_func == "":
                        response = make_error_response(id, -32602, "Missing required parameter: function_name")
                    else:
                        val d_idx = session_mgr.find_session(d_sid)
                        if d_idx < 0:
                            response = make_error_response(id, -32602, "Session not found: " + d_sid)
                        else:
                            val d_cond = extract_nested_string(line, "arguments", "condition")
                            val d_bp_id = rt_debug_add_function_breakpoint(d_func, d_cond)
                            var d_r = LB()
                            d_r = d_r + jp("session_id", js(d_sid))
                            d_r = d_r + "," + jp("breakpoint_id", d_bp_id.to_string())
                            d_r = d_r + "," + jp("function_name", js(escape_json(d_func)))
                            d_r = d_r + "," + jp("type", js("function"))
                            d_r = d_r + RB()
                            response = make_tool_result(id, d_r)
                elif tool_name == "debug_enable_breakpoint":
                    val d_sid = extract_nested_string(line, "arguments", "session_id")
                    val d_bp_str = extract_nested_string(line, "arguments", "breakpoint_id")
                    val d_en_str = extract_nested_string(line, "arguments", "enabled")
                    if d_sid == "":
                        response = make_error_response(id, -32602, "Missing required parameter: session_id")
                    elif d_bp_str == "":
                        response = make_error_response(id, -32602, "Missing required parameter: breakpoint_id")
                    else:
                        val d_idx = session_mgr.find_session(d_sid)
                        if d_idx < 0:
                            response = make_error_response(id, -32602, "Session not found: " + d_sid)
                        else:
                            val d_bpr = parse_int(d_bp_str)
                            var d_bpi = 0
                            match d_bpr:
                                Ok(v): d_bpi = v
                                Err(_): pass
                            var d_en = 1
                            if d_en_str == "false" or d_en_str == "0":
                                d_en = 0
                            rt_debug_set_breakpoint_enabled(d_bpi, d_en)
                            var d_r = LB()
                            d_r = d_r + jp("session_id", js(d_sid))
                            d_r = d_r + "," + jp("breakpoint_id", d_bp_str)
                            d_r = d_r + "," + jp("enabled", d_en_str)
                            d_r = d_r + RB()
                            response = make_tool_result(id, d_r)
                elif tool_name == "debug_get_source":
                    val d_file = extract_nested_string(line, "arguments", "file")
                    val d_start_str = extract_nested_string(line, "arguments", "start_line")
                    val d_count_str = extract_nested_string(line, "arguments", "count")
                    if d_file == "":
                        response = make_error_response(id, -32602, "Missing required parameter: file")
                    else:
                        var d_start = 1
                        var d_cnt = 20
                        if d_start_str != "":
                            val d_sr = parse_int(d_start_str)
                            match d_sr:
                                Ok(v): d_start = v
                                Err(_): pass
                        if d_count_str != "":
                            val d_cr = parse_int(d_count_str)
                            match d_cr:
                                Ok(v): d_cnt = v
                                Err(_): pass
                        val d_src = rt_debug_get_source_lines(d_file, d_start, d_cnt)
                        var d_r = LB()
                        d_r = d_r + jp("file", js(escape_json(d_file)))
                        d_r = d_r + "," + jp("start_line", d_start.to_string())
                        d_r = d_r + "," + jp("count", d_cnt.to_string())
                        d_r = d_r + "," + jp("source", js(escape_json(d_src)))
                        d_r = d_r + RB()
                        response = make_tool_result(id, d_r)
                elif tool_name == "debug_watch":
                    val d_sid = extract_nested_string(line, "arguments", "session_id")
                    val d_action = extract_nested_string(line, "arguments", "action")
                    if d_sid == "":
                        response = make_error_response(id, -32602, "Missing required parameter: session_id")
                    elif d_action == "":
                        response = make_error_response(id, -32602, "Missing required parameter: action")
                    else:
                        val d_idx = session_mgr.find_session(d_sid)
                        if d_idx < 0:
                            response = make_error_response(id, -32602, "Session not found: " + d_sid)
                        else:
                            if d_action == "add":
                                val d_expr = extract_nested_string(line, "arguments", "expression")
                                val d_wid = rt_debug_add_watch(d_expr)
                                var d_r = LB()
                                d_r = d_r + jp("session_id", js(d_sid))
                                d_r = d_r + "," + jp("action", js("add"))
                                d_r = d_r + "," + jp("expression", js(escape_json(d_expr)))
                                d_r = d_r + "," + jp("watch_id", d_wid.to_string())
                                d_r = d_r + RB()
                                response = make_tool_result(id, d_r)
                            elif d_action == "remove":
                                val d_expr = extract_nested_string(line, "arguments", "expression")
                                val d_ok = rt_debug_remove_watch(d_expr)
                                var d_r = LB()
                                d_r = d_r + jp("session_id", js(d_sid))
                                d_r = d_r + "," + jp("action", js("remove"))
                                d_r = d_r + "," + jp("expression", js(escape_json(d_expr)))
                                d_r = d_r + "," + jp("removed", d_ok.to_string())
                                d_r = d_r + RB()
                                response = make_tool_result(id, d_r)
                            else:
                                val d_watches = rt_debug_list_watches()
                                var d_r = LB()
                                d_r = d_r + jp("session_id", js(d_sid))
                                d_r = d_r + "," + jp("action", js("list"))
                                d_r = d_r + "," + jp("watches", js(escape_json(d_watches)))
                                d_r = d_r + RB()
                                response = make_tool_result(id, d_r)
                elif tool_name == "debug_set_variable":
                    val d_sid = extract_nested_string(line, "arguments", "session_id")
                    val d_var = extract_nested_string(line, "arguments", "name")
                    val d_val = extract_nested_string(line, "arguments", "value")
                    if d_sid == "":
                        response = make_error_response(id, -32602, "Missing required parameter: session_id")
                    elif d_var == "":
                        response = make_error_response(id, -32602, "Missing required parameter: name")
                    else:
                        val d_idx = session_mgr.find_session(d_sid)
                        if d_idx < 0:
                            response = make_error_response(id, -32602, "Session not found: " + d_sid)
                        else:
                            val d_frame_str = extract_nested_string(line, "arguments", "frame_index")
                            var d_frame = 0
                            if d_frame_str != "":
                                val d_fr = parse_int(d_frame_str)
                                match d_fr:
                                    Ok(v): d_frame = v
                                    Err(_): pass
                            val d_ok = rt_debug_set_variable(d_var, d_val, d_frame)
                            var d_r = LB()
                            d_r = d_r + jp("session_id", js(d_sid))
                            d_r = d_r + "," + jp("name", js(escape_json(d_var)))
                            d_r = d_r + "," + jp("value", js(escape_json(d_val)))
                            d_r = d_r + "," + jp("frame_index", d_frame.to_string())
                            d_r = d_r + "," + jp("success", d_ok.to_string())
                            d_r = d_r + RB()
                            response = make_tool_result(id, d_r)
                elif tool_name == "debug_terminate":
                    val d_sid = extract_nested_string(line, "arguments", "session_id")
                    if d_sid == "":
                        response = make_error_response(id, -32602, "Missing required parameter: session_id")
                    else:
                        val d_idx = session_mgr.find_session(d_sid)
                        if d_idx < 0:
                            response = make_error_response(id, -32602, "Session not found: " + d_sid)
                        else:
                            rt_debug_terminate()
                            session_mgr.remove_session(d_sid)
                            var d_r = LB()
                            d_r = d_r + jp("session_id", js(d_sid))
                            d_r = d_r + "," + jp("status", js("terminated"))
                            d_r = d_r + RB()
                            response = make_tool_result(id, d_r)
                else:
                    response = make_error_response(id, -32602, "Unknown debug tool: " + tool_name)
            else:
                response = handle_jsonrpc(line, debug_mode, resource_mgr, prompt_mgr, session_mgr)
            if response != "":
                write_stdout_message(response)

fn debug_log(msg: String):
    eprint("DEBUG: " + msg)

fn read_stdin_message() -> String:
    # Read Content-Length header
    var header = input()
    if header == "":
        return ""

    # Strip trailing \r if present
    if header.ends_with("\r"):
        header = header.substring(0, header.len() - 1)

    # Parse content length
    var content_length = 0
    if header.starts_with("Content-Length:"):
        val len_str = header.replace("Content-Length:", "").trim()
        content_length = len_str.to_int()

    if content_length == 0:
        return ""

    # Skip blank line after headers
    input()

    # Read body (JSON-RPC body is typically one line)
    val body = input()
    body

fn write_stdout_message(body: String):
    var header = "Content-Length: "
    header = header + body.len().to_string()
    header = header + "\r\n\r\n"
    print_raw(header)
    print_raw(body)

fn handle_jsonrpc(body: String, debug_mode: Bool, resource_mgr: resources.ResourceManager, prompt_mgr: prompts.PromptManager, session_mgr: SessionManager) -> String:
    if debug_mode:
        debug_log("Request: " + body)

    # Simple JSON parsing for method extraction
    val method = extract_json_string_v2(body, "method")
    val id = extract_json_value(body, "id")

    if method == "initialize":
        return make_initialize_response(id)
    elif method == "initialized":
        return ""  # Notification, no response
    elif method == "shutdown":
        return make_result_response(id, "null")
    elif method == "exit":
        exit(0)
        return ""
    elif method == "tools/list":
        return make_tools_list_response(id)
    elif method == "tools/call":
        val tool_name = extract_nested_string(body, "params", "name")
        return handle_tool_call(id, tool_name, body, debug_mode, session_mgr)
    elif method == "resources/list":
        val cursor = extract_nested_string(body, "params", "cursor")
        return handle_resources_list_paginated(id, resource_mgr, cursor, debug_mode)
    elif method == "resources/read":
        val uri = extract_nested_string(body, "params", "uri")
        return handle_resources_read(id, uri, resource_mgr, debug_mode)
    elif method == "resources/templates/list":
        return handle_resources_templates_list(id, resource_mgr, debug_mode)
    elif method == "prompts/list":
        return handle_prompts_list(id, prompt_mgr, debug_mode)
    elif method == "prompts/get":
        val prompt_name = extract_nested_string(body, "params", "name")
        return handle_prompts_get(id, prompt_name, body, prompt_mgr, debug_mode)
    elif method == "logging/setLevel":
        val level = extract_nested_string(body, "params", "level")
        if debug_mode:
            debug_log("Log level set to: " + level)
        return make_result_response(id, "null")
    elif method == "roots/list":
        return handle_roots_list(id, debug_mode)
    else:
        if debug_mode:
            debug_log("Unknown method: " + method)
        return make_error_response(id, -32601, "Method not found: " + method)


fn make_initialize_response(id: String) -> String:
    # Server info with instructions for MCPSearch
    var server_info = LB()
    server_info = server_info + jp("name", js("simple-mcp"))
    server_info = server_info + ","
    server_info = server_info + jp("version", js("2.0.0"))
    server_info = server_info + ","
    val instructions = "Search for Simple MCP tools when the user asks about Simple language source code, bugs, tests, or features. Provides code reading (read_code, list_files, search_code, file_info), bug tracking (bugdb_get, bugdb_add, bugdb_update), and debug tools (debug_create_session, debug_list_sessions, debug_close_session, debug_set_breakpoint, debug_remove_breakpoint, debug_continue, debug_step, debug_get_variables, debug_stack_trace, debug_evaluate)."
    server_info = server_info + jp("instructions", js(instructions))
    server_info = server_info + RB()

    # Capabilities: tools, resources, prompts, logging
    var caps = LB()
    caps = caps + jp("tools", jo1(""))
    caps = caps + ","
    caps = caps + jp("resources", jo1(""))
    caps = caps + ","
    caps = caps + jp("prompts", jo1(""))
    caps = caps + ","
    caps = caps + jp("logging", jo1(""))
    caps = caps + RB()
    val result = jo3(jp("protocolVersion", js("2025-06-18")), jp("capabilities", caps), jp("serverInfo", server_info))
    jo3(jp("jsonrpc", js("2.0")), jp("id", id), jp("result", result))

fn make_tool_schema(name: String, desc: String, prop_name: String, prop_desc: String, required: Bool, read_only: Bool, destructive: Bool, idempotent: Bool) -> String:
    val prop = jo2(jp("type", js("string")), jp("description", js(prop_desc)))
    val props = jo1(jp(prop_name, prop))
    var req_arr = "[]"
    if required:
        req_arr = "[" + js(prop_name) + "]"
    val schema = jo3(jp("type", js("object")), jp("properties", props), jp("required", req_arr))

    # Build annotations object
    var annot = LB()
    var ro = "false"
    if read_only:
        ro = "true"
    annot = annot + jp("readOnlyHint", ro)
    annot = annot + ","
    var dest = "false"
    if destructive:
        dest = "true"
    annot = annot + jp("destructiveHint", dest)
    annot = annot + ","
    var idemp = "false"
    if idempotent:
        idemp = "true"
    annot = annot + jp("idempotentHint", idemp)
    annot = annot + ","
    annot = annot + jp("openWorldHint", "false")
    annot = annot + RB()

    # Return tool schema with annotations
    var result = LB()
    result = result + jp("name", js(name))
    result = result + ","
    result = result + jp("description", js(desc))
    result = result + ","
    result = result + jp("inputSchema", schema)
    result = result + ","
    result = result + jp("annotations", annot)
    result = result + RB()
    result

fn make_tools_list_response(id: String) -> String:
    # Tool annotations: (read_only, destructive, idempotent)
    val t1 = make_tool_schema("read_code", "Read a Simple language source file", "path", "File path", true, true, false, true)
    val t2 = make_tool_schema("list_files", "List Simple language files in a directory", "path", "Directory path", false, true, false, true)
    val t3 = make_tool_schema("search_code", "Search for code patterns", "query", "Search query", true, true, false, true)
    val t4 = make_tool_schema("file_info", "Get file information", "path", "File path", true, true, false, true)
    # Bug database tools
    val t5 = make_tool_schema("bugdb_get", "Get bug by ID", "id", "Bug ID", true, true, false, true)
    val t6 = make_tool_schema("bugdb_add", "Add new bug", "bug", "Bug JSON", true, false, false, false)
    val t7 = make_tool_schema("bugdb_update", "Update existing bug", "id", "Bug ID", true, false, false, true)

    # Debug tools (t8-t17) - original 10
    val t8 = schema_debug_create_session()
    val t9 = schema_debug_list_sessions()
    val t10 = schema_debug_close_session()
    val t11 = schema_debug_set_breakpoint()
    val t12 = schema_debug_remove_breakpoint()
    val t13 = schema_debug_continue()
    val t14 = schema_debug_step()
    val t15 = schema_debug_get_variables()
    val t16 = schema_debug_stack_trace()
    val t17 = schema_debug_evaluate()
    # New debug tools (t18-t23) - Phase 1.5
    val t18 = schema_debug_set_function_breakpoint()
    val t19 = schema_debug_enable_breakpoint()
    val t20 = schema_debug_get_source()
    val t21 = schema_debug_watch()
    val t22 = schema_debug_set_variable()
    val t23 = schema_debug_terminate()

    var tools = "["
    tools = tools + t1
    tools = tools + "," + t2
    tools = tools + "," + t3
    tools = tools + "," + t4
    tools = tools + "," + t5
    tools = tools + "," + t6
    tools = tools + "," + t7
    tools = tools + "," + t8
    tools = tools + "," + t9
    tools = tools + "," + t10
    tools = tools + "," + t11
    tools = tools + "," + t12
    tools = tools + "," + t13
    tools = tools + "," + t14
    tools = tools + "," + t15
    tools = tools + "," + t16
    tools = tools + "," + t17
    tools = tools + "," + t18
    tools = tools + "," + t19
    tools = tools + "," + t20
    tools = tools + "," + t21
    tools = tools + "," + t22
    tools = tools + "," + t23
    tools = tools + "]"
    val result = jo1(jp("tools", tools))
    jo3(jp("jsonrpc", js("2.0")), jp("id", id), jp("result", result))

fn handle_tool_call(id: String, tool_name: String, body: String, debug_mode: Bool, session_mgr: SessionManager) -> String:
    if debug_mode:
        debug_log("Tool call: " + tool_name)

    if tool_name == "read_code":
        val path = extract_nested_string(body, "arguments", "path")
        val content = read_file_safe(path)
        val escaped = escape_json(content)
        return make_tool_result(id, escaped)

    elif tool_name == "list_files":
        val path = extract_nested_string(body, "arguments", "path")
        var dir = path
        if dir == "":
            dir = "."
        val listing = list_spl_files(dir)
        return make_tool_result(id, listing)

    elif tool_name == "search_code":
        val query = extract_nested_string(body, "arguments", "query")
        val results = search_files(query)
        return make_tool_result(id, results)

    elif tool_name == "file_info":
        val path = extract_nested_string(body, "arguments", "path")
        val info = get_file_info(path)
        return make_tool_result(id, info)

    elif tool_name == "bugdb_get":
        val bug_id = extract_nested_string(body, "arguments", "id")
        val result = bugdb_resource.get_bug_by_id("doc/bug/bug_db.sdn", bug_id)
        return make_tool_result(id, result)

    elif tool_name == "bugdb_add":
        val bug_json = extract_nested_string(body, "arguments", "bug")
        val result = bugdb_resource.add_bug_from_json("doc/bug/bug_db.sdn", bug_json)
        return make_tool_result(id, result)

    elif tool_name == "bugdb_update":
        val bug_id = extract_nested_string(body, "arguments", "id")
        val bug_json = extract_nested_string(body, "arguments", "updates")
        val result = bugdb_resource.update_bug_from_json("doc/bug/bug_db.sdn", bug_id, bug_json)
        return make_tool_result(id, result)

    # Debug tools
    elif tool_name == "debug_create_session":
        return handle_debug_create_session(id, body, session_mgr)

    elif tool_name == "debug_list_sessions":
        return handle_debug_list_sessions(id, session_mgr)

    elif tool_name == "debug_close_session":
        return handle_debug_close_session(id, body, session_mgr)

    elif tool_name == "debug_set_breakpoint":
        return handle_debug_set_breakpoint(id, body, session_mgr)

    elif tool_name == "debug_remove_breakpoint":
        return handle_debug_remove_breakpoint(id, body, session_mgr)

    elif tool_name == "debug_continue":
        return handle_debug_continue(id, body, session_mgr)

    elif tool_name == "debug_step":
        return handle_debug_step(id, body, session_mgr)

    elif tool_name == "debug_get_variables":
        return handle_debug_get_variables(id, body, session_mgr)

    elif tool_name == "debug_stack_trace":
        return handle_debug_stack_trace(id, body, session_mgr)

    elif tool_name == "debug_evaluate":
        return handle_debug_evaluate(id, body, session_mgr)

    elif tool_name == "debug_set_function_breakpoint":
        return handle_debug_set_function_breakpoint(id, body, session_mgr)

    elif tool_name == "debug_enable_breakpoint":
        return handle_debug_enable_breakpoint(id, body, session_mgr)

    elif tool_name == "debug_get_source":
        return handle_debug_get_source(id, body, session_mgr)

    elif tool_name == "debug_watch":
        return handle_debug_watch(id, body, session_mgr)

    elif tool_name == "debug_set_variable":
        return handle_debug_set_variable(id, body, session_mgr)

    elif tool_name == "debug_terminate":
        return handle_debug_terminate(id, body, session_mgr)

    else:
        return make_error_response(id, -32602, "Unknown tool: " + tool_name)


# --- Tool implementations ---


fn search_files(query: String) -> String:
    val result = shell("grep -rn '" + query + "' --include='*.spl' . 2>/dev/null | head -50")

    val output = result.stdout ?? ""
    if output.trim() == "":
        return "[]"  # Empty array - no matches

    val match_lines = output.split("\n")
    var matches_json = "["
    var first = true

    for match_line in match_lines:
        val trimmed = match_line.trim()
        if trimmed != "":
            # Parse grep output: path:line:content
            val colon_idx = trimmed.index_of(":")
            if colon_idx.?:
                val file_path = trimmed.substring(0, colon_idx.unwrap())
                val rest = trimmed.substring(colon_idx.unwrap() + 1)
                val second_colon = rest.index_of(":")

                var line_num = "0"
                var content = rest
                if second_colon.?:
                    line_num = rest.substring(0, second_colon.unwrap())
                    content = rest.substring(second_colon.unwrap() + 1)

                if not first:
                    matches_json = matches_json + ","
                first = false

                var match_obj = LB()
                match_obj = match_obj + jp("file", js(file_path))
                match_obj = match_obj + ","
                match_obj = match_obj + jp("line", line_num)
                match_obj = match_obj + ","
                match_obj = match_obj + jp("content", js(content.trim()))
                match_obj = match_obj + RB()
                matches_json = matches_json + match_obj

    matches_json = matches_json + "]"
    matches_json

fn get_file_info(path: String) -> String:
    val content = file_read(path)
    if content == "":
        var error = LB()
        error = error + jp("error", js("Could not read file"))
        error = error + ","
        error = error + jp("path", js(path))
        error = error + RB()
        return error

    val lines = content.split("\n")
    var line_count = lines.len()
    var fn_count = 0
    var class_count = 0
    for line in lines:
        val trimmed = line.trim()
        if trimmed.starts_with("fn ") or trimmed.starts_with("me ") or trimmed.starts_with("static fn "):
            fn_count = fn_count + 1
        elif trimmed.starts_with("class ") or trimmed.starts_with("struct "):
            class_count = class_count + 1

    # Return structured JSON
    var result = LB()
    result = result + jp("path", js(path))
    result = result + ","
    result = result + jp("lines", line_count.to_string())
    result = result + ","
    result = result + jp("functions", fn_count.to_string())
    result = result + ","
    result = result + jp("classes", class_count.to_string())
    result = result + RB()
    result


# --- Resource and Prompt handlers ---

fn handle_resources_list(id: String, resource_mgr: resources.ResourceManager, debug_mode: Bool) -> String:
    handle_resources_list_paginated(id, resource_mgr, "", debug_mode)

fn handle_resources_list_paginated(id: String, resource_mgr: resources.ResourceManager, cursor: String, debug_mode: Bool) -> String:
    if debug_mode:
        debug_log("Listing resources (cursor: " + cursor + ")")

    val resource_list = resource_mgr.list_resources()

    # Pagination settings
    val page_size = 20
    var offset = 0

    # Parse cursor as offset (format: "offset:<number>")
    if cursor != "":
        if cursor.starts_with("offset:"):
            val cursor_value = cursor.substring(7)
            val parse_result = parse_int(cursor_value)
            if parse_result.ok.?:
                offset = parse_result.unwrap()

    # Calculate end index
    val total = resource_list.len()
    val end = min_int(offset + page_size, total)
    val has_more = end < total

    # Build resources JSON array with pagination
    var resources_json = "["
    var first = true

    for i in offset..end:
        val res_info = resource_list[i]

        if not first:
            resources_json = resources_json + ","
        first = false

        var res_obj = LB()
        res_obj = res_obj + jp("uri", js(res_info.uri))
        res_obj = res_obj + ","
        res_obj = res_obj + jp("name", js(res_info.name))

        if res_info.description.?:
            res_obj = res_obj + ","
            res_obj = res_obj + jp("description", js(res_info.description.unwrap()))

        if res_info.mime_type.?:
            res_obj = res_obj + ","
            res_obj = res_obj + jp("mimeType", js(res_info.mime_type.unwrap()))

        res_obj = res_obj + RB()
        resources_json = resources_json + res_obj

    resources_json = resources_json + "]"

    # Build result with optional nextCursor
    var result = LB()
    result = result + jp("resources", resources_json)

    if has_more:
        val next_cursor = "offset:" + end.to_string()
        result = result + ","
        result = result + jp("nextCursor", js(next_cursor))

    result = result + RB()

    jo3(jp("jsonrpc", js("2.0")), jp("id", id), jp("result", result))

fn handle_resources_read(id: String, uri: String, resource_mgr: resources.ResourceManager, debug_mode: Bool) -> String:
    if debug_mode:
        debug_log("Reading resource: " + uri)

    val read_result = resource_mgr.read_resource(uri)

    if read_result.err.?:
        return make_error_response(id, -32602, read_result.err.unwrap())

    val content = read_result.unwrap()
    val escaped = escape_json(content.contents)

    var res_obj = LB()
    res_obj = res_obj + jp("uri", js(content.uri))
    res_obj = res_obj + ","
    res_obj = res_obj + jp("contents", js(escaped))

    if content.mime_type.?:
        res_obj = res_obj + ","
        res_obj = res_obj + jp("mimeType", js(content.mime_type.unwrap()))

    res_obj = res_obj + RB()

    val result = jo1(jp("resource", res_obj))
    jo3(jp("jsonrpc", js("2.0")), jp("id", id), jp("result", result))

fn handle_resources_templates_list(id: String, resource_mgr: resources.ResourceManager, debug_mode: Bool) -> String:
    if debug_mode:
        debug_log("Listing resource templates")

    val templates = resource_mgr.list_templates()
    var templates_json = "["

    var first = true
    for tmpl in templates:
        if not first:
            templates_json = templates_json + ","
        first = false

        var templ_obj = LB()
        templ_obj = templ_obj + jp("uriTemplate", js(tmpl.uri_template))
        templ_obj = templ_obj + ","
        templ_obj = templ_obj + jp("name", js(tmpl.name))

        if tmpl.description.?:
            templ_obj = templ_obj + ","
            templ_obj = templ_obj + jp("description", js(tmpl.description.unwrap()))

        if tmpl.mime_type.?:
            templ_obj = templ_obj + ","
            templ_obj = templ_obj + jp("mimeType", js(tmpl.mime_type.unwrap()))

        templ_obj = templ_obj + RB()
        templates_json = templates_json + templ_obj

    templates_json = templates_json + "]"

    val result = jo1(jp("resourceTemplates", templates_json))
    jo3(jp("jsonrpc", js("2.0")), jp("id", id), jp("result", result))

fn handle_roots_list(id: String, debug_mode: Bool) -> String:
    if debug_mode:
        debug_log("Listing roots")

    # Get project root from current working directory
    var root_path = cwd()

    # Normalize path (remove trailing slash)
    if root_path.ends_with("/"):
        root_path = root_path.substring(0, root_path.len() - 1)

    # Build roots JSON array with single root
    var roots_json = "["
    var root_obj = LB()
    root_obj = root_obj + jp("uri", js("file://" + root_path))
    root_obj = root_obj + ","
    root_obj = root_obj + jp("name", js("Simple Project"))
    root_obj = root_obj + RB()
    roots_json = roots_json + root_obj
    roots_json = roots_json + "]"

    val result = jo1(jp("roots", roots_json))
    jo3(jp("jsonrpc", js("2.0")), jp("id", id), jp("result", result))

fn handle_prompts_list(id: String, prompt_mgr: prompts.PromptManager, debug_mode: Bool) -> String:
    if debug_mode:
        debug_log("Listing prompts")

    val prompt_list = prompt_mgr.list_prompts()
    var prompts_json = "["

    var first = true
    for prompt_info in prompt_list:
        if not first:
            prompts_json = prompts_json + ","
        first = false

        # Build arguments array
        var args_json = "["
        var first_arg = true
        for arg in prompt_info.arguments:
            if not first_arg:
                args_json = args_json + ","
            first_arg = false

            var arg_obj = LB()
            arg_obj = arg_obj + jp("name", js(arg.name))
            arg_obj = arg_obj + ","
            arg_obj = arg_obj + jp("description", js(arg.description))
            arg_obj = arg_obj + ","
            val req_str = if arg.required: "true" else: "false"
            arg_obj = arg_obj + jp("required", req_str)
            arg_obj = arg_obj + RB()

            args_json = args_json + arg_obj

        args_json = args_json + "]"

        var prompt_obj = LB()
        prompt_obj = prompt_obj + jp("name", js(prompt_info.name))
        prompt_obj = prompt_obj + ","
        prompt_obj = prompt_obj + jp("description", js(prompt_info.description))
        prompt_obj = prompt_obj + ","
        prompt_obj = prompt_obj + jp("arguments", args_json)
        prompt_obj = prompt_obj + RB()

        prompts_json = prompts_json + prompt_obj

    prompts_json = prompts_json + "]"

    val result = jo1(jp("prompts", prompts_json))
    jo3(jp("jsonrpc", js("2.0")), jp("id", id), jp("result", result))

fn handle_prompts_get(id: String, prompt_name: String, body: String, prompt_mgr: prompts.PromptManager, debug_mode: Bool) -> String:
    if debug_mode:
        debug_log("Getting prompt: " + prompt_name)

    # Extract arguments from request
    val arguments = extract_arguments_dict(body)

    val prompt_result = prompt_mgr.get_prompt(prompt_name, arguments)

    if prompt_result.err.?:
        return make_error_response(id, -32602, prompt_result.err.unwrap())

    val prompt_data = prompt_result.unwrap()

    # Build messages array
    var messages_json = "["
    var first_msg = true
    for msg in prompt_data.messages:
        if not first_msg:
            messages_json = messages_json + ","
        first_msg = false

        val role_str = match msg.role:
            prompts.PromptRole.User: "user"
            prompts.PromptRole.Assistant: "assistant"

        var msg_obj = LB()
        msg_obj = msg_obj + jp("role", js(role_str))
        msg_obj = msg_obj + ","
        msg_obj = msg_obj + jp("content", js(escape_json(msg.content)))
        msg_obj = msg_obj + RB()

        messages_json = messages_json + msg_obj

    messages_json = messages_json + "]"

    var result_obj = LB()
    result_obj = result_obj + jp("description", js(prompt_data.description))
    result_obj = result_obj + ","
    result_obj = result_obj + jp("messages", messages_json)
    result_obj = result_obj + RB()

    val result = jo1(jp("prompt", result_obj))
    jo3(jp("jsonrpc", js("2.0")), jp("id", id), jp("result", result))

# Get current directory (using Simple's built-in cwd)
fn get_current_dir() -> String:
    cwd()

# --- CLI mode handlers ---

# Helper: Read file or exit with error
fn read_file_or_exit(file_path: text) -> text:
    val content = file_read(file_path)
    if content == "":
        print("Error reading file: " + file_path)
        exit(1)
    content

fn handle_read(args: [String]):
    if args.len() < 2:
        print("Error: Missing file path")
        print("Usage: simple mcp read <file.spl>")
        exit(1)
    val file_path = args[1]
    val content = read_file_or_exit(file_path)
    print(content)

fn handle_expand(args: [String]):
    if args.len() < 3:
        print("Error: Missing file path or symbol name")
        print("Usage: simple mcp expand <file.spl> <symbol>")
        exit(1)
    val file_path = args[1]
    val symbol_name = args[2]
    val content = read_file_or_exit(file_path)
    # Find symbol in content (basic search)
    val lines = content.split("\n")
    var found = false
    var line_num = 0
    for line in lines:
        line_num = line_num + 1
        if line.contains(symbol_name):
            print(line_num.to_string() + ": " + line)
            found = true
    if not found:
        print("Symbol not found: " + symbol_name)

fn handle_search(args: [String]):
    if args.len() < 2:
        print("Error: Missing search query")
        print("Usage: simple mcp search <query>")
        exit(1)
    val query = args[1]
    print("Search for '" + query + "' (CLI mode)")

fn handle_json(args: [String]):
    if args.len() < 2:
        print("Error: Missing file path")
        print("Usage: simple mcp json <file.spl>")
        exit(1)
    val file_path = args[1]
    val content = read_file_or_exit(file_path)
    # Output as basic JSON
    val escaped = escape_json(content)
    val lb = LB()
    val rb = RB()
    val q = Q()
    print(lb + q + "file" + q + ":" + q + escape_json(file_path) + q + "," + q + "content" + q + ":" + q + escaped + q + rb)

fn handle_default_read(args: [String]):
    val file_path = args[0]  # After clean_args, first element is the command/file
    val content = read_file_or_exit(file_path)
    print(content)


# Entry point
main()
