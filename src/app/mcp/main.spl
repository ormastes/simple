# MCP (Model Context Protocol) Server for Simple Language
# Provides LLM-friendly code representation via the MCP protocol
#
# Usage:
#   simple mcp server              # Start MCP server (stdio mode)
#   simple mcp server --debug      # Start with debug logging
#   simple mcp <file.spl>          # Generate MCP preview (CLI mode)
#   simple mcp read <file.spl>     # Read file in MCP mode
#   simple mcp expand <file> <sym> # Expand specific symbol
#   simple mcp json <file.spl>     # Generate JSON output

# FFI declarations for system functions
extern fn sys_get_args() -> List<String>
extern fn sys_exit(code: Int)
extern fn native_fs_read_string(path: String) -> String

struct ShellResult:
    exit_code: Int
    stdout: String?
    stderr: String?

extern fn rt_shell(command: String) -> ShellResult

# Brace helpers (avoid f-string interpolation issues)
fn LB() -> String:
    123 as char

fn RB() -> String:
    125 as char

fn Q() -> String:
    "\""

# Option unwrap helper
fn unwrap_idx(opt) -> Int:
    match opt:
        case Some(i):
            return i
        case None:
            return -1

fn unwrap_str(result) -> String:
    match result:
        case Ok(s):
            return s
        case Err(_):
            return ""

# Main entry point
fn main():
    val args = sys_get_args()

    if args.len() < 2:
        print_usage()
        sys_exit(1)

    val command = args[1]

    if command == "--help" or command == "-h":
        print_usage()
        sys_exit(0)

    elif command == "server":
        val debug_mode = has_flag(args, "--debug")
        start_server(debug_mode)

    elif command == "read":
        handle_read(args)

    elif command == "expand":
        handle_expand(args)

    elif command == "search":
        handle_search(args)

    elif command == "json":
        handle_json(args)

    else:
        handle_default_read(args)

# Print usage information
fn print_usage():
    print("MCP (Model Context Protocol) Server for Simple Language")
    print("")
    print("Usage:")
    print("  simple mcp server [--debug]          # Start MCP server (stdio)")
    print("  simple mcp <file.spl>                # Generate MCP outline")
    print("  simple mcp read <file.spl>           # Read file in MCP mode")
    print("  simple mcp expand <file.spl> <sym>   # Expand specific symbol")
    print("  simple mcp search <query>            # Search for symbols")
    print("  simple mcp json <file.spl> [--meta]  # Generate JSON output")
    print("")
    print("Server Mode:")
    print("  The server mode implements the Model Context Protocol over stdio.")
    print("  It can be used with MCP-compatible clients like Claude Code.")
    print("")
    print("Options:")
    print("  --help, -h          Show this help message")
    print("  --debug             Enable debug logging (server mode)")
    print("  --all               Show private symbols too")
    print("  --meta              Include metadata in JSON output")
    print("  --expand=<what>     What to expand: signature|body|all")
    print("  --show-coverage     Display test coverage overlays")
    print("")
    print("Examples:")
    print("  simple mcp server                    # Start MCP server")
    print("  simple mcp user.spl")
    print("  simple mcp expand user.spl User")
    print("  simple mcp json user.spl --meta")

# --- MCP JSON-RPC Server (stdio) ---

fn start_server(debug_mode: Bool):
    if debug_mode:
        debug_log("MCP server starting in debug mode")

    # Send nothing until we get initialize request
    var running = true
    while running:
        val line = read_stdin_message()
        if line == "":
            running = false
        else:
            val response = handle_jsonrpc(line, debug_mode)
            if response != "":
                write_stdout_message(response)

fn debug_log(msg: String):
    eprint("DEBUG: " + msg)

fn read_stdin_message() -> String:
    # Read Content-Length header
    var header = input()
    if header == "":
        return ""

    # Strip trailing \r if present
    if header.ends_with("\r"):
        header = header.substring(0, header.len() - 1)

    # Parse content length
    var content_length = 0
    if header.starts_with("Content-Length:"):
        val len_str = header.replace("Content-Length:", "").trim()
        content_length = len_str.to_int()

    if content_length == 0:
        return ""

    # Skip blank line after headers
    input()

    # Read body (JSON-RPC body is typically one line)
    val body = input()
    body

fn write_stdout_message(body: String):
    var header = "Content-Length: "
    header = header + body.len().to_string()
    header = header + "\r\n\r\n"
    print_raw(header)
    print_raw(body)

fn handle_jsonrpc(body: String, debug_mode: Bool) -> String:
    if debug_mode:
        debug_log("Request: " + body)

    # Simple JSON parsing for method extraction
    val method = extract_json_string(body, "method")
    val id = extract_json_value(body, "id")

    if method == "initialize":
        return make_initialize_response(id)
    elif method == "initialized":
        return ""  # Notification, no response
    elif method == "shutdown":
        return make_result_response(id, "null")
    elif method == "exit":
        sys_exit(0)
        return ""
    elif method == "tools/list":
        return make_tools_list_response(id)
    elif method == "tools/call":
        val tool_name = extract_nested_string(body, "params", "name")
        return handle_tool_call(id, tool_name, body, debug_mode)
    else:
        if debug_mode:
            debug_log("Unknown method: " + method)
        return make_error_response(id, -32601, "Method not found: " + method)

fn jp(key: String, val_str: String) -> String:
    var r = Q()
    r = r + key
    r = r + Q()
    r = r + ":"
    r = r + val_str
    r

fn js(s: String) -> String:
    var r = Q()
    r = r + s
    r = r + Q()
    r

fn jo1(pair: String) -> String:
    var r = LB()
    r = r + pair
    r = r + RB()
    r

fn jo2(p1: String, p2: String) -> String:
    var r = LB()
    r = r + p1
    r = r + ","
    r = r + p2
    r = r + RB()
    r

fn jo3(p1: String, p2: String, p3: String) -> String:
    var r = LB()
    r = r + p1
    r = r + ","
    r = r + p2
    r = r + ","
    r = r + p3
    r = r + RB()
    r

fn make_initialize_response(id: String) -> String:
    val server_info = jo2(jp("name", js("simple-mcp")), jp("version", js("1.0.0")))
    val caps = jo1(jp("tools", jo1("")))
    val result = jo3(jp("protocolVersion", js("2024-11-05")), jp("capabilities", caps), jp("serverInfo", server_info))
    jo3(jp("jsonrpc", js("2.0")), jp("id", id), jp("result", result))

fn make_tool_schema(name: String, desc: String, prop_name: String, prop_desc: String, required: Bool) -> String:
    val prop = jo2(jp("type", js("string")), jp("description", js(prop_desc)))
    val props = jo1(jp(prop_name, prop))
    var req_arr = "[]"
    if required:
        req_arr = "[" + js(prop_name) + "]"
    val schema = jo3(jp("type", js("object")), jp("properties", props), jp("required", req_arr))
    jo3(jp("name", js(name)), jp("description", js(desc)), jp("inputSchema", schema))

fn make_tools_list_response(id: String) -> String:
    val t1 = make_tool_schema("read_code", "Read a Simple language source file", "path", "File path", true)
    val t2 = make_tool_schema("list_files", "List Simple language files in a directory", "path", "Directory path", false)
    val t3 = make_tool_schema("search_code", "Search for code patterns", "query", "Search query", true)
    val t4 = make_tool_schema("file_info", "Get file information", "path", "File path", true)
    var tools = "["
    tools = tools + t1
    tools = tools + ","
    tools = tools + t2
    tools = tools + ","
    tools = tools + t3
    tools = tools + ","
    tools = tools + t4
    tools = tools + "]"
    val result = jo1(jp("tools", tools))
    jo3(jp("jsonrpc", js("2.0")), jp("id", id), jp("result", result))

fn handle_tool_call(id: String, tool_name: String, body: String, debug_mode: Bool) -> String:
    if debug_mode:
        debug_log("Tool call: " + tool_name)

    if tool_name == "read_code":
        val path = extract_nested_string(body, "arguments", "path")
        val content = read_file_safe(path)
        val escaped = escape_json(content)
        return make_tool_result(id, escaped)

    elif tool_name == "list_files":
        val path = extract_nested_string(body, "arguments", "path")
        var dir = path
        if dir == "":
            dir = "."
        val listing = list_spl_files(dir)
        val escaped = escape_json(listing)
        return make_tool_result(id, escaped)

    elif tool_name == "search_code":
        val query = extract_nested_string(body, "arguments", "query")
        val results = search_files(query)
        val escaped = escape_json(results)
        return make_tool_result(id, escaped)

    elif tool_name == "file_info":
        val path = extract_nested_string(body, "arguments", "path")
        val info = get_file_info(path)
        val escaped = escape_json(info)
        return make_tool_result(id, escaped)

    else:
        return make_error_response(id, -32602, "Unknown tool: " + tool_name)

fn make_tool_result(id: String, content: String) -> String:
    val text_obj = jo2(jp("type", js("text")), jp("text", js(content)))
    val result = jo1(jp("content", "[" + text_obj + "]"))
    jo3(jp("jsonrpc", js("2.0")), jp("id", id), jp("result", result))

fn make_result_response(id: String, result: String) -> String:
    jo3(jp("jsonrpc", js("2.0")), jp("id", id), jp("result", result))

fn make_error_response(id: String, code: Int, message: String) -> String:
    val err = jo2(jp("code", code.to_string()), jp("message", js(escape_json(message))))
    jo3(jp("jsonrpc", js("2.0")), jp("id", id), jp("error", err))

# --- Tool implementations ---

fn read_file_safe(path: String) -> String:
    val content = native_fs_read_string(path)
    if content == "":
        return "Error: could not read file: " + path
    content

fn list_spl_files(dir: String) -> String:
    val result = rt_shell("find " + dir + " -name '*.spl' -type f | sort")
    if result.exit_code == 0:
        return result.stdout ?? "No .spl files found"
    "Error listing files in " + dir

fn search_files(query: String) -> String:
    val result = rt_shell("grep -rn '" + query + "' --include='*.spl' . 2>/dev/null | head -50")
    if result.exit_code == 0:
        return result.stdout ?? "No matches found"
    "No matches found for: " + query

fn get_file_info(path: String) -> String:
    val content = native_fs_read_string(path)
    if content == "":
        return "Error: could not read file: " + path
    val lines = content.split("\n")
    var line_count = lines.len()
    var fn_count = 0
    var class_count = 0
    for line in lines:
        val trimmed = line.trim()
        if trimmed.starts_with("fn ") or trimmed.starts_with("me ") or trimmed.starts_with("static fn "):
            fn_count = fn_count + 1
        elif trimmed.starts_with("class ") or trimmed.starts_with("struct "):
            class_count = class_count + 1
    "File: " + path + "\\nLines: " + line_count.to_string() + "\\nFunctions: " + fn_count.to_string() + "\\nClasses/Structs: " + class_count.to_string()

# --- JSON helpers (minimal, no library dependency) ---

fn extract_json_string(json: String, key: String) -> String:
    val search = Q() + key + Q() + ":"
    val idx = unwrap_idx(json.index_of(search))
    if idx < 0:
        return ""
    val slen = search.len()
    val start = idx + slen
    val after = json.substring(start)
    val trimmed = after.trim()
    if trimmed.starts_with(Q()):
        val rest = trimmed.substring(1)
        val end = unwrap_idx(rest.index_of(Q()))
        if end >= 0:
            return rest.substring(0, end)
    ""

fn extract_json_value(json: String, key: String) -> String:
    val search = Q() + key + Q() + ":"
    val idx = unwrap_idx(json.index_of(search))
    if idx < 0:
        return "null"
    val slen = search.len()
    val start = idx + slen
    val after = json.substring(start)
    val trimmed = after.trim()
    # Read until comma, closing brace, or end
    var end = 0
    for ch in trimmed:
        if ch == "," or ch == RB() or ch == "]":
            break
        end = end + 1
    trimmed.substring(0, end).trim()

fn extract_nested_string(json: String, outer_key: String, inner_key: String) -> String:
    val search = Q() + outer_key + Q() + ":"
    val idx = unwrap_idx(json.index_of(search))
    if idx < 0:
        return ""
    val slen = search.len()
    val start = idx + slen
    val after = json.substring(start)
    extract_json_string(after, inner_key)

fn escape_json(text: String) -> String:
    var result = text
    result = result.replace("\\", "\\\\")
    result = result.replace(Q(), "\\" + Q())
    result = result.replace("\n", "\\n")
    result = result.replace("\r", "\\r")
    result = result.replace("\t", "\\t")
    result

# --- CLI mode handlers ---

fn handle_read(args: List<String>):
    if args.len() < 3:
        print("Error: Missing file path")
        print("Usage: simple mcp read <file.spl>")
        sys_exit(1)
    val file_path = args[2]
    val content = native_fs_read_string(file_path)
    if content == "":
        print("Error reading file: " + file_path)
        sys_exit(1)
    print(content)

fn handle_expand(args: List<String>):
    if args.len() < 4:
        print("Error: Missing file path or symbol name")
        print("Usage: simple mcp expand <file.spl> <symbol>")
        sys_exit(1)
    val file_path = args[2]
    val symbol_name = args[3]
    val content = native_fs_read_string(file_path)
    if content == "":
        print("Error reading file: " + file_path)
        sys_exit(1)
    # Find symbol in content (basic search)
    val lines = content.split("\n")
    var found = false
    var line_num = 0
    for line in lines:
        line_num = line_num + 1
        if line.contains(symbol_name):
            print(line_num.to_string() + ": " + line)
            found = true
    if not found:
        print("Symbol not found: " + symbol_name)

fn handle_search(args: List<String>):
    if args.len() < 3:
        print("Error: Missing search query")
        print("Usage: simple mcp search <query>")
        sys_exit(1)
    val query = args[2]
    print("Search for '" + query + "' (CLI mode)")

fn handle_json(args: List<String>):
    if args.len() < 3:
        print("Error: Missing file path")
        print("Usage: simple mcp json <file.spl>")
        sys_exit(1)
    val file_path = args[2]
    val content = native_fs_read_string(file_path)
    if content == "":
        print("Error reading file: " + file_path)
        sys_exit(1)
    # Output as basic JSON
    val escaped = escape_json(content)
    val lb = LB()
    val rb = RB()
    val q = Q()
    print(lb + q + "file" + q + ":" + q + escape_json(file_path) + q + "," + q + "content" + q + ":" + q + escaped + q + rb)

fn handle_default_read(args: List<String>):
    val file_path = args[1]
    val content = native_fs_read_string(file_path)
    if content == "":
        print("Error reading file: " + file_path)
        sys_exit(1)
    print(content)

# Check if a flag is present in args
fn has_flag(args: List<String>, flag: String) -> Bool:
    for arg in args:
        if arg == flag:
            return true
    return false

# Entry point
main()
