# MCP (Model Context Protocol) Server for Simple Language
# Provides LLM-friendly code representation via the MCP protocol
#
# Usage:
#   simple mcp server              # Start MCP server (stdio mode)
#   simple mcp server --debug      # Start with debug logging
#   simple mcp <file.spl>          # Generate MCP preview (CLI mode)
#   simple mcp read <file.spl>     # Read file in MCP mode
#   simple mcp expand <file> <sym> # Expand specific symbol
#   simple mcp json <file.spl>     # Generate JSON output

# I/O imports
use app.io.mod (file_read, get_args, exit, shell, cwd)

# MCP modules
use app.mcp.resources
use app.mcp.prompts
use app.mcp.bugdb_resource
use app.mcp.helpers.{LB, RB, Q, parse_int, min_int, unwrap_idx, unwrap_str, get_clean_args, jp, js, jo1, jo2, jo3, extract_json_string_v2, extract_json_string, extract_json_value, extract_nested_string, escape_json, read_file_safe, list_spl_files, make_tool_result, make_result_response, make_error_response, has_flag}

# Main entry point
fn main():
    val raw_args = get_args()
    val args = get_clean_args(raw_args)

    if args.len() < 1:
        print_usage()
        exit(1)

    val command = args[0]

    if command == "--help" or command == "-h":
        print_usage()
        exit(0)

    elif command == "server":
        val debug_mode = has_flag(args, "--debug")
        start_server(debug_mode)

    elif command == "read":
        handle_read(args)

    elif command == "expand":
        handle_expand(args)

    elif command == "search":
        handle_search(args)

    elif command == "json":
        handle_json(args)

    else:
        handle_default_read(args)

# Print usage information
fn print_usage():
    print("MCP (Model Context Protocol) Server for Simple Language")
    print("")
    print("Usage:")
    print("  simple mcp server [--debug]          # Start MCP server (stdio)")
    print("  simple mcp <file.spl>                # Generate MCP outline")
    print("  simple mcp read <file.spl>           # Read file in MCP mode")
    print("  simple mcp expand <file.spl> <sym>   # Expand specific symbol")
    print("  simple mcp search <query>            # Search for symbols")
    print("  simple mcp json <file.spl> [--meta]  # Generate JSON output")
    print("")
    print("Server Mode:")
    print("  The server mode implements the Model Context Protocol over stdio.")
    print("  It can be used with MCP-compatible clients like Claude Code.")
    print("")
    print("Options:")
    print("  --help, -h          Show this help message")
    print("  --debug             Enable debug logging (server mode)")
    print("  --all               Show private symbols too")
    print("  --meta              Include metadata in JSON output")
    print("  --expand=<what>     What to expand: signature|body|all")
    print("  --show-coverage     Display test coverage overlays")
    print("")
    print("Examples:")
    print("  simple mcp server                    # Start MCP server")
    print("  simple mcp user.spl")
    print("  simple mcp expand user.spl User")
    print("  simple mcp json user.spl --meta")

# --- MCP JSON-RPC Server (stdio) ---

fn start_server(debug_mode: Bool):
    if debug_mode:
        debug_log("MCP server starting in debug mode")

    # Initialize resource and prompt managers
    val project_root = get_current_dir()
    val resource_mgr = resources.ResourceManager.create(project_root)
    val prompt_mgr = prompts.PromptManager.create(project_root)

    if debug_mode:
        debug_log("Initialized with project root: " + project_root)

    # Send nothing until we get initialize request
    var running = true
    while running:
        val line = read_stdin_message()
        if line == "":
            running = false
        else:
            val response = handle_jsonrpc(line, debug_mode, resource_mgr, prompt_mgr)
            if response != "":
                write_stdout_message(response)

fn debug_log(msg: String):
    eprint("DEBUG: " + msg)

fn read_stdin_message() -> String:
    # Read Content-Length header
    var header = input()
    if header == "":
        return ""

    # Strip trailing \r if present
    if header.ends_with("\r"):
        header = header.substring(0, header.len() - 1)

    # Parse content length
    var content_length = 0
    if header.starts_with("Content-Length:"):
        val len_str = header.replace("Content-Length:", "").trim()
        content_length = len_str.to_int()

    if content_length == 0:
        return ""

    # Skip blank line after headers
    input()

    # Read body (JSON-RPC body is typically one line)
    val body = input()
    body

fn write_stdout_message(body: String):
    var header = "Content-Length: "
    header = header + body.len().to_string()
    header = header + "\r\n\r\n"
    print_raw(header)
    print_raw(body)

fn handle_jsonrpc(body: String, debug_mode: Bool, resource_mgr: resources.ResourceManager, prompt_mgr: prompts.PromptManager) -> String:
    if debug_mode:
        debug_log("Request: " + body)

    # Simple JSON parsing for method extraction
    val method = extract_json_string_v2(body, "method")
    val id = extract_json_value(body, "id")

    if method == "initialize":
        return make_initialize_response(id)
    elif method == "initialized":
        return ""  # Notification, no response
    elif method == "shutdown":
        return make_result_response(id, "null")
    elif method == "exit":
        exit(0)
        return ""
    elif method == "tools/list":
        return make_tools_list_response(id)
    elif method == "tools/call":
        val tool_name = extract_nested_string(body, "params", "name")
        return handle_tool_call(id, tool_name, body, debug_mode)
    elif method == "resources/list":
        val cursor = extract_nested_string(body, "params", "cursor")
        return handle_resources_list_paginated(id, resource_mgr, cursor, debug_mode)
    elif method == "resources/read":
        val uri = extract_nested_string(body, "params", "uri")
        return handle_resources_read(id, uri, resource_mgr, debug_mode)
    elif method == "resources/templates/list":
        return handle_resources_templates_list(id, resource_mgr, debug_mode)
    elif method == "prompts/list":
        return handle_prompts_list(id, prompt_mgr, debug_mode)
    elif method == "prompts/get":
        val prompt_name = extract_nested_string(body, "params", "name")
        return handle_prompts_get(id, prompt_name, body, prompt_mgr, debug_mode)
    elif method == "logging/setLevel":
        val level = extract_nested_string(body, "params", "level")
        if debug_mode:
            debug_log("Log level set to: " + level)
        return make_result_response(id, "null")
    elif method == "roots/list":
        return handle_roots_list(id, debug_mode)
    else:
        if debug_mode:
            debug_log("Unknown method: " + method)
        return make_error_response(id, -32601, "Method not found: " + method)


fn make_initialize_response(id: String) -> String:
    # Server info with instructions for MCPSearch
    var server_info = LB()
    server_info = server_info + jp("name", js("simple-mcp"))
    server_info = server_info + ","
    server_info = server_info + jp("version", js("2.0.0"))
    server_info = server_info + ","
    val instructions = "Search for Simple MCP tools when the user asks about Simple language source code, bugs, tests, or features. Provides code reading (read_code, list_files, search_code, file_info), bug tracking (bugdb_get, bugdb_add, bugdb_update), feature tracking, and test result tools."
    server_info = server_info + jp("instructions", js(instructions))
    server_info = server_info + RB()

    # Capabilities: tools, resources, prompts, logging
    var caps = LB()
    caps = caps + jp("tools", jo1(""))
    caps = caps + ","
    caps = caps + jp("resources", jo1(""))
    caps = caps + ","
    caps = caps + jp("prompts", jo1(""))
    caps = caps + ","
    caps = caps + jp("logging", jo1(""))
    caps = caps + RB()
    val result = jo3(jp("protocolVersion", js("2025-06-18")), jp("capabilities", caps), jp("serverInfo", server_info))
    jo3(jp("jsonrpc", js("2.0")), jp("id", id), jp("result", result))

fn make_tool_schema(name: String, desc: String, prop_name: String, prop_desc: String, required: Bool, read_only: Bool, destructive: Bool, idempotent: Bool) -> String:
    val prop = jo2(jp("type", js("string")), jp("description", js(prop_desc)))
    val props = jo1(jp(prop_name, prop))
    var req_arr = "[]"
    if required:
        req_arr = "[" + js(prop_name) + "]"
    val schema = jo3(jp("type", js("object")), jp("properties", props), jp("required", req_arr))

    # Build annotations object
    var annot = LB()
    var ro = "false"
    if read_only:
        ro = "true"
    annot = annot + jp("readOnlyHint", ro)
    annot = annot + ","
    var dest = "false"
    if destructive:
        dest = "true"
    annot = annot + jp("destructiveHint", dest)
    annot = annot + ","
    var idemp = "false"
    if idempotent:
        idemp = "true"
    annot = annot + jp("idempotentHint", idemp)
    annot = annot + ","
    annot = annot + jp("openWorldHint", "false")
    annot = annot + RB()

    # Return tool schema with annotations
    var result = LB()
    result = result + jp("name", js(name))
    result = result + ","
    result = result + jp("description", js(desc))
    result = result + ","
    result = result + jp("inputSchema", schema)
    result = result + ","
    result = result + jp("annotations", annot)
    result = result + RB()
    result

fn make_tools_list_response(id: String) -> String:
    # Tool annotations: (read_only, destructive, idempotent)
    val t1 = make_tool_schema("read_code", "Read a Simple language source file", "path", "File path", true, true, false, true)
    val t2 = make_tool_schema("list_files", "List Simple language files in a directory", "path", "Directory path", false, true, false, true)
    val t3 = make_tool_schema("search_code", "Search for code patterns", "query", "Search query", true, true, false, true)
    val t4 = make_tool_schema("file_info", "Get file information", "path", "File path", true, true, false, true)
    # Bug database tools
    val t5 = make_tool_schema("bugdb_get", "Get bug by ID", "id", "Bug ID", true, true, false, true)
    val t6 = make_tool_schema("bugdb_add", "Add new bug", "bug", "Bug JSON", true, false, false, false)
    val t7 = make_tool_schema("bugdb_update", "Update existing bug", "id", "Bug ID", true, false, false, true)

    var tools = "["
    tools = tools + t1
    tools = tools + ","
    tools = tools + t2
    tools = tools + ","
    tools = tools + t3
    tools = tools + ","
    tools = tools + t4
    tools = tools + ","
    tools = tools + t5
    tools = tools + ","
    tools = tools + t6
    tools = tools + ","
    tools = tools + t7
    tools = tools + "]"
    val result = jo1(jp("tools", tools))
    jo3(jp("jsonrpc", js("2.0")), jp("id", id), jp("result", result))

fn handle_tool_call(id: String, tool_name: String, body: String, debug_mode: Bool) -> String:
    if debug_mode:
        debug_log("Tool call: " + tool_name)

    if tool_name == "read_code":
        val path = extract_nested_string(body, "arguments", "path")
        val content = read_file_safe(path)
        val escaped = escape_json(content)
        return make_tool_result(id, escaped)

    elif tool_name == "list_files":
        val path = extract_nested_string(body, "arguments", "path")
        var dir = path
        if dir == "":
            dir = "."
        val listing = list_spl_files(dir)
        return make_tool_result(id, listing)

    elif tool_name == "search_code":
        val query = extract_nested_string(body, "arguments", "query")
        val results = search_files(query)
        return make_tool_result(id, results)

    elif tool_name == "file_info":
        val path = extract_nested_string(body, "arguments", "path")
        val info = get_file_info(path)
        return make_tool_result(id, info)

    elif tool_name == "bugdb_get":
        val bug_id = extract_nested_string(body, "arguments", "id")
        val result = bugdb_resource.get_bug_by_id("doc/bug/bug_db.sdn", bug_id)
        return make_tool_result(id, result)

    elif tool_name == "bugdb_add":
        val bug_json = extract_nested_string(body, "arguments", "bug")
        val result = bugdb_resource.add_bug_from_json("doc/bug/bug_db.sdn", bug_json)
        return make_tool_result(id, result)

    elif tool_name == "bugdb_update":
        val bug_id = extract_nested_string(body, "arguments", "id")
        val bug_json = extract_nested_string(body, "arguments", "updates")
        val result = bugdb_resource.update_bug_from_json("doc/bug/bug_db.sdn", bug_id, bug_json)
        return make_tool_result(id, result)

    else:
        return make_error_response(id, -32602, "Unknown tool: " + tool_name)


# --- Tool implementations ---


fn search_files(query: String) -> String:
    val result = shell("grep -rn '" + query + "' --include='*.spl' . 2>/dev/null | head -50")

    val output = result.stdout ?? ""
    if output.trim() == "":
        return "[]"  # Empty array - no matches

    val match_lines = output.split("\n")
    var matches_json = "["
    var first = true

    for match_line in match_lines:
        val trimmed = match_line.trim()
        if trimmed != "":
            # Parse grep output: path:line:content
            val colon_idx = trimmed.index_of(":")
            if colon_idx.?:
                val file_path = trimmed.substring(0, colon_idx.unwrap())
                val rest = trimmed.substring(colon_idx.unwrap() + 1)
                val second_colon = rest.index_of(":")

                var line_num = "0"
                var content = rest
                if second_colon.?:
                    line_num = rest.substring(0, second_colon.unwrap())
                    content = rest.substring(second_colon.unwrap() + 1)

                if not first:
                    matches_json = matches_json + ","
                first = false

                var match_obj = LB()
                match_obj = match_obj + jp("file", js(file_path))
                match_obj = match_obj + ","
                match_obj = match_obj + jp("line", line_num)
                match_obj = match_obj + ","
                match_obj = match_obj + jp("content", js(content.trim()))
                match_obj = match_obj + RB()
                matches_json = matches_json + match_obj

    matches_json = matches_json + "]"
    matches_json

fn get_file_info(path: String) -> String:
    val content = file_read(path)
    if content == "":
        var error = LB()
        error = error + jp("error", js("Could not read file"))
        error = error + ","
        error = error + jp("path", js(path))
        error = error + RB()
        return error

    val lines = content.split("\n")
    var line_count = lines.len()
    var fn_count = 0
    var class_count = 0
    for line in lines:
        val trimmed = line.trim()
        if trimmed.starts_with("fn ") or trimmed.starts_with("me ") or trimmed.starts_with("static fn "):
            fn_count = fn_count + 1
        elif trimmed.starts_with("class ") or trimmed.starts_with("struct "):
            class_count = class_count + 1

    # Return structured JSON
    var result = LB()
    result = result + jp("path", js(path))
    result = result + ","
    result = result + jp("lines", line_count.to_string())
    result = result + ","
    result = result + jp("functions", fn_count.to_string())
    result = result + ","
    result = result + jp("classes", class_count.to_string())
    result = result + RB()
    result


# --- Resource and Prompt handlers ---

fn handle_resources_list(id: String, resource_mgr: resources.ResourceManager, debug_mode: Bool) -> String:
    handle_resources_list_paginated(id, resource_mgr, "", debug_mode)

fn handle_resources_list_paginated(id: String, resource_mgr: resources.ResourceManager, cursor: String, debug_mode: Bool) -> String:
    if debug_mode:
        debug_log("Listing resources (cursor: " + cursor + ")")

    val resource_list = resource_mgr.list_resources()

    # Pagination settings
    val page_size = 20
    var offset = 0

    # Parse cursor as offset (format: "offset:<number>")
    if cursor != "":
        if cursor.starts_with("offset:"):
            val cursor_value = cursor.substring(7)
            val parse_result = parse_int(cursor_value)
            if parse_result.ok.?:
                offset = parse_result.unwrap()

    # Calculate end index
    val total = resource_list.len()
    val end = min_int(offset + page_size, total)
    val has_more = end < total

    # Build resources JSON array with pagination
    var resources_json = "["
    var first = true

    for i in offset..end:
        val res_info = resource_list[i]

        if not first:
            resources_json = resources_json + ","
        first = false

        var res_obj = LB()
        res_obj = res_obj + jp("uri", js(res_info.uri))
        res_obj = res_obj + ","
        res_obj = res_obj + jp("name", js(res_info.name))

        if res_info.description.?:
            res_obj = res_obj + ","
            res_obj = res_obj + jp("description", js(res_info.description.unwrap()))

        if res_info.mime_type.?:
            res_obj = res_obj + ","
            res_obj = res_obj + jp("mimeType", js(res_info.mime_type.unwrap()))

        res_obj = res_obj + RB()
        resources_json = resources_json + res_obj

    resources_json = resources_json + "]"

    # Build result with optional nextCursor
    var result = LB()
    result = result + jp("resources", resources_json)

    if has_more:
        val next_cursor = "offset:" + end.to_string()
        result = result + ","
        result = result + jp("nextCursor", js(next_cursor))

    result = result + RB()

    jo3(jp("jsonrpc", js("2.0")), jp("id", id), jp("result", result))

fn handle_resources_read(id: String, uri: String, resource_mgr: resources.ResourceManager, debug_mode: Bool) -> String:
    if debug_mode:
        debug_log("Reading resource: " + uri)

    val read_result = resource_mgr.read_resource(uri)

    if read_result.err.?:
        return make_error_response(id, -32602, read_result.err.unwrap())

    val content = read_result.unwrap()
    val escaped = escape_json(content.contents)

    var res_obj = LB()
    res_obj = res_obj + jp("uri", js(content.uri))
    res_obj = res_obj + ","
    res_obj = res_obj + jp("contents", js(escaped))

    if content.mime_type.?:
        res_obj = res_obj + ","
        res_obj = res_obj + jp("mimeType", js(content.mime_type.unwrap()))

    res_obj = res_obj + RB()

    val result = jo1(jp("resource", res_obj))
    jo3(jp("jsonrpc", js("2.0")), jp("id", id), jp("result", result))

fn handle_resources_templates_list(id: String, resource_mgr: resources.ResourceManager, debug_mode: Bool) -> String:
    if debug_mode:
        debug_log("Listing resource templates")

    val templates = resource_mgr.list_templates()
    var templates_json = "["

    var first = true
    for tmpl in templates:
        if not first:
            templates_json = templates_json + ","
        first = false

        var templ_obj = LB()
        templ_obj = templ_obj + jp("uriTemplate", js(tmpl.uri_template))
        templ_obj = templ_obj + ","
        templ_obj = templ_obj + jp("name", js(tmpl.name))

        if tmpl.description.?:
            templ_obj = templ_obj + ","
            templ_obj = templ_obj + jp("description", js(tmpl.description.unwrap()))

        if tmpl.mime_type.?:
            templ_obj = templ_obj + ","
            templ_obj = templ_obj + jp("mimeType", js(tmpl.mime_type.unwrap()))

        templ_obj = templ_obj + RB()
        templates_json = templates_json + templ_obj

    templates_json = templates_json + "]"

    val result = jo1(jp("resourceTemplates", templates_json))
    jo3(jp("jsonrpc", js("2.0")), jp("id", id), jp("result", result))

fn handle_roots_list(id: String, debug_mode: Bool) -> String:
    if debug_mode:
        debug_log("Listing roots")

    # Get project root from current working directory
    var root_path = cwd()

    # Normalize path (remove trailing slash)
    if root_path.ends_with("/"):
        root_path = root_path.substring(0, root_path.len() - 1)

    # Build roots JSON array with single root
    var roots_json = "["
    var root_obj = LB()
    root_obj = root_obj + jp("uri", js("file://" + root_path))
    root_obj = root_obj + ","
    root_obj = root_obj + jp("name", js("Simple Project"))
    root_obj = root_obj + RB()
    roots_json = roots_json + root_obj
    roots_json = roots_json + "]"

    val result = jo1(jp("roots", roots_json))
    jo3(jp("jsonrpc", js("2.0")), jp("id", id), jp("result", result))

fn handle_prompts_list(id: String, prompt_mgr: prompts.PromptManager, debug_mode: Bool) -> String:
    if debug_mode:
        debug_log("Listing prompts")

    val prompt_list = prompt_mgr.list_prompts()
    var prompts_json = "["

    var first = true
    for prompt_info in prompt_list:
        if not first:
            prompts_json = prompts_json + ","
        first = false

        # Build arguments array
        var args_json = "["
        var first_arg = true
        for arg in prompt_info.arguments:
            if not first_arg:
                args_json = args_json + ","
            first_arg = false

            var arg_obj = LB()
            arg_obj = arg_obj + jp("name", js(arg.name))
            arg_obj = arg_obj + ","
            arg_obj = arg_obj + jp("description", js(arg.description))
            arg_obj = arg_obj + ","
            val req_str = if arg.required: "true" else: "false"
            arg_obj = arg_obj + jp("required", req_str)
            arg_obj = arg_obj + RB()

            args_json = args_json + arg_obj

        args_json = args_json + "]"

        var prompt_obj = LB()
        prompt_obj = prompt_obj + jp("name", js(prompt_info.name))
        prompt_obj = prompt_obj + ","
        prompt_obj = prompt_obj + jp("description", js(prompt_info.description))
        prompt_obj = prompt_obj + ","
        prompt_obj = prompt_obj + jp("arguments", args_json)
        prompt_obj = prompt_obj + RB()

        prompts_json = prompts_json + prompt_obj

    prompts_json = prompts_json + "]"

    val result = jo1(jp("prompts", prompts_json))
    jo3(jp("jsonrpc", js("2.0")), jp("id", id), jp("result", result))

fn handle_prompts_get(id: String, prompt_name: String, body: String, prompt_mgr: prompts.PromptManager, debug_mode: Bool) -> String:
    if debug_mode:
        debug_log("Getting prompt: " + prompt_name)

    # Extract arguments from request
    # TODO: Implement proper JSON argument extraction
    val arguments: Dict<String, String> = {}  # Empty for now

    val prompt_result = prompt_mgr.get_prompt(prompt_name, arguments)

    if prompt_result.err.?:
        return make_error_response(id, -32602, prompt_result.err.unwrap())

    val prompt_data = prompt_result.unwrap()

    # Build messages array
    var messages_json = "["
    var first_msg = true
    for msg in prompt_data.messages:
        if not first_msg:
            messages_json = messages_json + ","
        first_msg = false

        val role_str = match msg.role:
            prompts.PromptRole.User: "user"
            prompts.PromptRole.Assistant: "assistant"

        var msg_obj = LB()
        msg_obj = msg_obj + jp("role", js(role_str))
        msg_obj = msg_obj + ","
        msg_obj = msg_obj + jp("content", js(escape_json(msg.content)))
        msg_obj = msg_obj + RB()

        messages_json = messages_json + msg_obj

    messages_json = messages_json + "]"

    var result_obj = LB()
    result_obj = result_obj + jp("description", js(prompt_data.description))
    result_obj = result_obj + ","
    result_obj = result_obj + jp("messages", messages_json)
    result_obj = result_obj + RB()

    val result = jo1(jp("prompt", result_obj))
    jo3(jp("jsonrpc", js("2.0")), jp("id", id), jp("result", result))

# Get current directory (using Simple's built-in cwd)
fn get_current_dir() -> String:
    cwd()

# --- CLI mode handlers ---

# Helper: Read file or exit with error
fn read_file_or_exit(file_path: text) -> text:
    val content = file_read(file_path)
    if content == "":
        print("Error reading file: " + file_path)
        exit(1)
    content

fn handle_read(args: [String]):
    if args.len() < 2:
        print("Error: Missing file path")
        print("Usage: simple mcp read <file.spl>")
        exit(1)
    val file_path = args[1]
    val content = read_file_or_exit(file_path)
    print(content)

fn handle_expand(args: [String]):
    if args.len() < 3:
        print("Error: Missing file path or symbol name")
        print("Usage: simple mcp expand <file.spl> <symbol>")
        exit(1)
    val file_path = args[1]
    val symbol_name = args[2]
    val content = read_file_or_exit(file_path)
    # Find symbol in content (basic search)
    val lines = content.split("\n")
    var found = false
    var line_num = 0
    for line in lines:
        line_num = line_num + 1
        if line.contains(symbol_name):
            print(line_num.to_string() + ": " + line)
            found = true
    if not found:
        print("Symbol not found: " + symbol_name)

fn handle_search(args: [String]):
    if args.len() < 2:
        print("Error: Missing search query")
        print("Usage: simple mcp search <query>")
        exit(1)
    val query = args[1]
    print("Search for '" + query + "' (CLI mode)")

fn handle_json(args: [String]):
    if args.len() < 2:
        print("Error: Missing file path")
        print("Usage: simple mcp json <file.spl>")
        exit(1)
    val file_path = args[1]
    val content = read_file_or_exit(file_path)
    # Output as basic JSON
    val escaped = escape_json(content)
    val lb = LB()
    val rb = RB()
    val q = Q()
    print(lb + q + "file" + q + ":" + q + escape_json(file_path) + q + "," + q + "content" + q + ":" + q + escaped + q + rb)

fn handle_default_read(args: [String]):
    val file_path = args[0]  # After clean_args, first element is the command/file
    val content = read_file_or_exit(file_path)
    print(content)


# Entry point
main()
