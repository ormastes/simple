# File I/O Protection Engine
# Provides rule-based access control for file operations

export ProtectionEngine, ProtectionRule, RuleType, RuleAction, ProtectionResult
export create_engine

# Rule matching types
enum RuleType:
    Exact      # Exact path match
    Glob       # Glob pattern (*.sdn)
    Regex      # Regex pattern

# Protection actions
enum RuleAction:
    Deny       # Reject operation
    Protect    # Allow read, deny write/delete
    Redirect   # Redirect to temp directory
    Atomic     # Require atomic writes
    Allow      # Allow all operations

# Protection result
enum ProtectionResult:
    Allowed
    Denied(reason: text)
    Redirected(new_path: text)
    RequiresAtomic

# Protection rule
struct ProtectionRule:
    pattern: text
    rule_type: RuleType
    action: RuleAction
    reason: text

# Protection engine
class ProtectionEngine:
    rules: [ProtectionRule]
    temp_base: text

    # Check if path matches a rule
    fn matches_rule(path: text, rule: ProtectionRule) -> bool:
        match rule.rule_type:
            RuleType.Exact:
                # Normalize paths for comparison
                val norm_path = self.normalize_path(path)
                val norm_pattern = self.normalize_path(rule.pattern)
                norm_path == norm_pattern
            RuleType.Glob:
                self.glob_match(path, rule.pattern)
            RuleType.Regex:
                self.regex_match(path, rule.pattern)

    # Normalize path (resolve relative, remove trailing slash)
    fn normalize_path(path: text) -> text:
        var result = path

        # Remove trailing slash
        if result.ends_with("/") and result.len() > 1:
            result = result[0:-1]

        # Resolve relative paths (basic implementation)
        if result.starts_with("./"):
            result = result[2:]

        result

    # Glob pattern matching
    fn glob_match(path: text, pattern: text) -> bool:
        # Simple glob matching: * matches any characters
        # TODO: Full glob implementation with ?, [], {}

        if not pattern.contains("*"):
            return path == pattern

        val parts = pattern.split("*")
        if parts.len() == 0:
            return true

        var pos = 0
        for i in 0..parts.len():
            val part = parts[i]
            if part.len() == 0:
                continue

            val idx = path[pos:].index_of(part)
            if not idx.?:
                return false

            pos = pos + idx.unwrap() + part.len()

        true

    # Regex pattern matching
    fn regex_match(path: text, pattern: text) -> bool:
        # TODO: Implement regex matching
        # For now, fall back to glob matching
        self.glob_match(path, pattern)

    # Find first matching rule for path
    fn find_rule(path: text) -> ProtectionRule?:
        for rule in self.rules:
            if self.matches_rule(path, rule):
                return Some(rule)
        None

    # Check path against protection rules
    fn check_path(path: text, operation: text) -> ProtectionResult:
        val rule_opt = self.find_rule(path)

        if not rule_opt.?:
            return ProtectionResult.Allowed

        val rule = rule_opt.unwrap()

        match rule.action:
            RuleAction.Allow:
                ProtectionResult.Allowed

            RuleAction.Deny:
                ProtectionResult.Denied(rule.reason)

            RuleAction.Protect:
                # Allow read operations, deny write/delete
                if operation == "read" or operation == "list":
                    ProtectionResult.Allowed
                else:
                    ProtectionResult.Denied("File is protected: " + rule.reason)

            RuleAction.Redirect:
                # Redirect to temp directory
                val temp_path = self.get_temp_path(path)
                ProtectionResult.Redirected(temp_path)

            RuleAction.Atomic:
                ProtectionResult.RequiresAtomic

    # Get temp path for redirected file
    fn get_temp_path(path: text) -> text:
        # Extract filename from path
        val parts = path.split("/")
        val filename = if parts.len() > 0:
            parts[parts.len() - 1]
        else:
            path

        self.temp_base + "/" + filename

    # Add a protection rule
    me add_rule(pattern: text, rule_type: RuleType, action: RuleAction, reason: text):
        val rule = ProtectionRule(
            pattern: pattern,
            rule_type: rule_type,
            action: action,
            reason: reason
        )
        self.rules.push(rule)

    # List all protected files matching a pattern
    fn list_protected_files(pattern: text) -> [text]:
        var result = []

        for rule in self.rules:
            if rule.action == RuleAction.Protect or rule.action == RuleAction.Deny:
                if pattern == "*" or rule.pattern.contains(pattern):
                    result.push(rule.pattern)

        result

    # Get protection info for a path
    fn get_protection_info(path: text) -> text:
        val rule_opt = self.find_rule(path)

        if not rule_opt.?:
            return "No protection (allowed)"

        val rule = rule_opt.unwrap()
        val action_str = match rule.action:
            RuleAction.Allow: "Allow"
            RuleAction.Deny: "Deny"
            RuleAction.Protect: "Protect (read-only)"
            RuleAction.Redirect: "Redirect to temp"
            RuleAction.Atomic: "Atomic writes only"

        "{action_str}: {rule.reason}"

# Create protection engine from SDN config
fn create_engine(config_path: text, temp_base: text) -> ProtectionEngine:
    val engine = ProtectionEngine(
        rules: [],
        temp_base: temp_base
    )

    # Load config if it exists
    if file_exists(config_path):
        load_config(engine, config_path)
    else:
        # Add default rules if no config
        add_default_rules(engine)

    engine

# Load protection rules from SDN config
fn load_config(engine: ProtectionEngine, config_path: text):
    val content = file_read(config_path)
    val lines = content.split("\n")

    var in_table = false
    var columns = []

    for line in lines:
        val trimmed = line.trim()

        # Skip comments and empty lines
        if trimmed.starts_with("#") or trimmed.len() == 0:
            continue

        # Parse table header
        if trimmed.contains("|") and trimmed.starts_with("protected_paths"):
            val parts = trimmed.split("|")
            if parts.len() >= 2:
                columns = parts[1].split(",").map(\c: c.trim())
                in_table = true
            continue

        # Parse table row
        if in_table:
            if not trimmed.contains(","):
                in_table = false
                continue

            val values = trimmed.split(",").map(\v: v.trim())
            if values.len() >= 4:
                val pattern = values[0].replace("\"", "")
                val type_str = values[1]
                val action_str = values[2]
                val reason = values[3].replace("\"", "")

                val rule_type = match type_str:
                    "exact": RuleType.Exact
                    "glob": RuleType.Glob
                    "regex": RuleType.Regex
                    _: RuleType.Exact

                val action = match action_str:
                    "deny": RuleAction.Deny
                    "protect": RuleAction.Protect
                    "redirect": RuleAction.Redirect
                    "atomic": RuleAction.Atomic
                    "allow": RuleAction.Allow
                    _: RuleAction.Allow

                engine.add_rule(pattern, rule_type, action, reason)

# Add default protection rules
fn add_default_rules(engine: ProtectionEngine):
    # Protect critical files
    engine.add_rule("/", RuleType.Exact, RuleAction.Deny, "Root directory")
    engine.add_rule("CLAUDE.md", RuleType.Exact, RuleAction.Protect, "Project instructions")
    engine.add_rule("*.sdn", RuleType.Glob, RuleAction.Atomic, "Database files require atomic writes")
    engine.add_rule("*.lock", RuleType.Glob, RuleAction.Deny, "Lock files managed by system")
    engine.add_rule("src/", RuleType.Exact, RuleAction.Protect, "Source code directory")
    engine.add_rule("test/", RuleType.Exact, RuleAction.Protect, "Test directory")
    engine.add_rule("doc/", RuleType.Exact, RuleAction.Allow, "Documentation can be modified")

# Helper function to check if file exists
fn file_exists(path: text) -> bool:
    val result = shell("test -f '{path}' && echo yes || echo no")
    result.trim() == "yes"

# Helper function to read file
fn file_read(path: text) -> text:
    shell("cat '{path}'")

# Helper function to run shell command
extern fn rt_process_run(cmd: text, args: [text]) -> (text, text, i64)

fn shell(cmd: text) -> text:
    val (stdout, stderr, exit_code) = rt_process_run("sh", ["-c", cmd])
    if exit_code == 0:
        stdout
    else:
        ""
