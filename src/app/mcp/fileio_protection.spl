# File I/O Protection Engine
# Provides rule-based access control for file operations

use std.io_runtime.{file_exists, file_read}
use std.path.{normalize_path, basename}
use std.glob.{glob_match}
use std.src.core.regex.{compile}

export ProtectionEngine, ProtectionRule, RuleType, RuleAction, ProtectionResult
export create_engine

# Rule matching types
enum RuleType:
    Exact      # Exact path match
    Glob       # Glob pattern (*.sdn)
    Regex      # Regex pattern

# Protection actions
enum RuleAction:
    Deny       # Reject operation
    Protect    # Allow read, deny write/delete
    Redirect   # Redirect to temp directory
    Atomic     # Require atomic writes
    Allow      # Allow all operations

# Protection result
enum ProtectionResult:
    Allowed
    Denied(reason: text)
    Redirected(new_path: text)
    RequiresAtomic

# Protection rule
struct ProtectionRule:
    pattern: text
    rule_type: RuleType
    action: RuleAction
    reason: text

# Protection engine
class ProtectionEngine:
    rules: [ProtectionRule]
    temp_base: text

    # Check if path matches a rule
    fn matches_rule(path: text, rule: ProtectionRule) -> bool:
        match rule.rule_type:
            RuleType.Exact:
                # Normalize paths for comparison
                val norm_path = normalize_path(path)
                val norm_pattern = normalize_path(rule.pattern)
                norm_path == norm_pattern
            RuleType.Glob:
                glob_match(path, rule.pattern)
            RuleType.Regex:
                # Full path match using regex
                val pattern = compile(rule.pattern)
                val m = pattern.match(path)
                if m.is_some():
                    # Check if matched entire string
                    m.start == 0 and m.end == path.len()
                else:
                    false

    # Find first matching rule for path
    fn find_rule(path: text) -> ProtectionRule?:
        for rule in self.rules:
            if self.matches_rule(path, rule):
                return Some(rule)
        None

    # Check path against protection rules
    fn check_path(path: text, operation: text) -> ProtectionResult:
        val rule_opt = self.find_rule(path)

        if not rule_opt.?:
            return ProtectionResult.Allowed

        val rule = rule_opt.unwrap()

        match rule.action:
            RuleAction.Allow:
                ProtectionResult.Allowed

            RuleAction.Deny:
                ProtectionResult.Denied(rule.reason)

            RuleAction.Protect:
                # Allow read operations, deny write/delete
                if operation == "read" or operation == "list":
                    ProtectionResult.Allowed
                else:
                    ProtectionResult.Denied("File is protected: " + rule.reason)

            RuleAction.Redirect:
                # Redirect to temp directory
                val temp_path = self.get_temp_path(path)
                ProtectionResult.Redirected(temp_path)

            RuleAction.Atomic:
                ProtectionResult.RequiresAtomic

    # Get temp path for redirected file
    fn get_temp_path(path: text) -> text:
        val filename = basename(path)
        self.temp_base + "/" + filename

    # Add a protection rule
    me add_rule(pattern: text, rule_type: RuleType, action: RuleAction, reason: text):
        val rule = ProtectionRule(
            pattern: pattern,
            rule_type: rule_type,
            action: action,
            reason: reason
        )
        self.rules.push(rule)

    # List all protected files matching a pattern
    fn list_protected_files(pattern: text) -> [text]:
        var result = []

        for rule in self.rules:
            if rule.action == RuleAction.Protect or rule.action == RuleAction.Deny:
                if pattern == "*" or rule.pattern.contains(pattern):
                    result.push(rule.pattern)

        result

    # Get protection info for a path
    fn get_protection_info(path: text) -> text:
        val rule_opt = self.find_rule(path)

        if not rule_opt.?:
            return "No protection (allowed)"

        val rule = rule_opt.unwrap()
        val action_str = match rule.action:
            RuleAction.Allow: "Allow"
            RuleAction.Deny: "Deny"
            RuleAction.Protect: "Protect (read-only)"
            RuleAction.Redirect: "Redirect to temp"
            RuleAction.Atomic: "Atomic writes only"

        "{action_str}: {rule.reason}"

# Create protection engine from SDN config
fn create_engine(config_path: text, temp_base: text) -> ProtectionEngine:
    val engine = ProtectionEngine(
        rules: [],
        temp_base: temp_base
    )

    # Load config if it exists
    if file_exists(config_path):
        load_config(engine, config_path)
    else:
        # Add default rules if no config
        add_default_rules(engine)

    engine

# Load protection rules from SDN config
fn load_config(engine: ProtectionEngine, config_path: text):
    val content = file_read(config_path)
    val lines = content.split("\n")

    var in_table = false
    var columns = []

    for line in lines:
        val trimmed = line.trim()

        # Skip comments and empty lines
        if trimmed.starts_with("#") or trimmed.len() == 0:
            continue

        # Parse table header
        if trimmed.contains("|") and trimmed.starts_with("protected_paths"):
            val parts = trimmed.split("|")
            if parts.len() >= 2:
                columns = parts[1].split(",").map(\c: c.trim())
                in_table = true
            continue

        # Parse table row
        if in_table:
            if not trimmed.contains(","):
                in_table = false
                continue

            val values = trimmed.split(",").map(\v: v.trim())
            if values.len() >= 4:
                val pattern = values[0].replace("\"", "")
                val type_str = values[1]
                val action_str = values[2]
                val reason = values[3].replace("\"", "")

                val rule_type = match type_str:
                    "exact": RuleType.Exact
                    "glob": RuleType.Glob
                    "regex": RuleType.Regex
                    _: RuleType.Exact

                val action = match action_str:
                    "deny": RuleAction.Deny
                    "protect": RuleAction.Protect
                    "redirect": RuleAction.Redirect
                    "atomic": RuleAction.Atomic
                    "allow": RuleAction.Allow
                    _: RuleAction.Allow

                engine.add_rule(pattern, rule_type, action, reason)

# Add default protection rules
fn add_default_rules(engine: ProtectionEngine):
    # Protect critical files
    engine.add_rule("/", RuleType.Exact, RuleAction.Deny, "Root directory")
    engine.add_rule("CLAUDE.md", RuleType.Exact, RuleAction.Protect, "Project instructions")
    engine.add_rule("*.sdn", RuleType.Glob, RuleAction.Atomic, "Database files require atomic writes")
    engine.add_rule("*.lock", RuleType.Glob, RuleAction.Deny, "Lock files managed by system")
    engine.add_rule("src/", RuleType.Exact, RuleAction.Protect, "Source code directory")
    engine.add_rule("test/", RuleType.Exact, RuleAction.Protect, "Test directory")
    engine.add_rule("doc/", RuleType.Exact, RuleAction.Allow, "Documentation can be modified")

