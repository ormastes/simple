# MCP Prompt Manager
#
# Manages prompt templates for the MCP server.
# Prompts provide pre-built interaction templates for common tasks:
# - Refactoring prompts (rename, extract function, etc.)
# - Code generation prompts (implement trait, add tests, etc.)
# - Documentation prompts (add docstrings, explain code, etc.)
# - Analysis prompts (find bugs, suggest improvements, etc.)
#
# Prompts can have arguments that are filled in by the user.

use app.io
use std.string.{NL}

# --- Prompt Types ---

# Prompt argument definition
struct PromptArgument:
    name: text
    description: text
    required: bool

# Prompt information returned by prompts/list
struct PromptInfo:
    name: text
    description: text
    arguments: [PromptArgument]

# Prompt message (user or assistant)
enum PromptRole:
    User
    Assistant

struct PromptMessage:
    role: PromptRole
    content: text
    role_str: text

fn make_user_message(content: text) -> PromptMessage:
    PromptMessage(role: PromptRole.User, content: content, role_str: "user")

fn make_assistant_message(content: text) -> PromptMessage:
    PromptMessage(role: PromptRole.Assistant, content: content, role_str: "assistant")

# Prompt result returned by prompts/get
struct PromptResult:
    description: text
    messages: [PromptMessage]

# --- Prompt Manager ---

class PromptManager:
    # Project root directory
    project_root: text
    prompts_cache: Option<[PromptInfo]>

    # Create a new prompt manager
    static fn create(project_root: text) -> PromptManager:
        PromptManager(
            project_root: project_root,
            prompts_cache: nil
        )

    # --- List Prompts ---

    # List all available prompts
    fn list_prompts() -> [PromptInfo]:
        match self.prompts_cache:
            case Some(p): return p
            case nil: ()

        var prompts: [PromptInfo] = []

        # --- Refactoring Prompts ---
        prompts.push(PromptInfo(
            name: "refactor-rename",
            description: "Rename a symbol throughout the codebase",
            arguments: [
                PromptArgument(name: "old_name", description: "Current symbol name", required: true),
                PromptArgument(name: "new_name", description: "New symbol name", required: true),
                PromptArgument(name: "file", description: "File containing the symbol", required: false)
            ]
        ))

        prompts.push(PromptInfo(
            name: "refactor-extract-function",
            description: "Extract code into a new function",
            arguments: [
                PromptArgument(name: "code", description: "Code to extract", required: true),
                PromptArgument(name: "function_name", description: "Name for new function", required: true),
                PromptArgument(name: "file", description: "File containing the code", required: true)
            ]
        ))

        prompts.push(PromptInfo(
            name: "refactor-inline",
            description: "Inline a function or variable",
            arguments: [
                PromptArgument(name: "name", description: "Symbol to inline", required: true),
                PromptArgument(name: "file", description: "File containing the symbol", required: true)
            ]
        ))

        # --- Code Generation Prompts ---
        prompts.push(PromptInfo(
            name: "generate-tests",
            description: "Generate SSpec tests for a function or class",
            arguments: [
                PromptArgument(name: "target", description: "Function or class name", required: true),
                PromptArgument(name: "file", description: "File containing the target", required: true)
            ]
        ))

        prompts.push(PromptInfo(
            name: "generate-trait-impl",
            description: "Generate trait implementation for a class",
            arguments: [
                PromptArgument(name: "class_name", description: "Class name", required: true),
                PromptArgument(name: "trait_name", description: "Trait name", required: true),
                PromptArgument(name: "file", description: "File containing the class", required: true)
            ]
        ))

        prompts.push(PromptInfo(
            name: "generate-constructor",
            description: "Generate constructor for a class",
            arguments: [
                PromptArgument(name: "class_name", description: "Class name", required: true),
                PromptArgument(name: "file", description: "File containing the class", required: true)
            ]
        ))

        # --- Documentation Prompts ---
        prompts.push(PromptInfo(
            name: "docs-add-docstrings",
            description: "Add documentation comments to functions and classes",
            arguments: [
                PromptArgument(name: "target", description: "Function or class name", required: false),
                PromptArgument(name: "file", description: "File to document", required: true)
            ]
        ))

        prompts.push(PromptInfo(
            name: "docs-explain-code",
            description: "Explain how code works",
            arguments: [
                PromptArgument(name: "code", description: "Code to explain", required: false),
                PromptArgument(name: "file", description: "File containing the code", required: false)
            ]
        ))

        prompts.push(PromptInfo(
            name: "docs-generate-readme",
            description: "Generate README.md for the project",
            arguments: []
        ))

        # --- Analysis Prompts ---
        prompts.push(PromptInfo(
            name: "analyze-find-bugs",
            description: "Analyze code for potential bugs",
            arguments: [
                PromptArgument(name: "file", description: "File to analyze", required: true)
            ]
        ))

        prompts.push(PromptInfo(
            name: "analyze-suggest-improvements",
            description: "Suggest code improvements",
            arguments: [
                PromptArgument(name: "file", description: "File to analyze", required: true)
            ]
        ))

        prompts.push(PromptInfo(
            name: "analyze-performance",
            description: "Analyze code for performance issues",
            arguments: [
                PromptArgument(name: "file", description: "File to analyze", required: true)
            ]
        ))

        self.prompts_cache = Some(prompts)
        prompts

    # --- Get Prompt ---

    # Get a prompt by name with arguments
    fn get_prompt(name: text, arguments: Dict<text, text>) -> Result<PromptResult, text>:
        # Dispatch to appropriate prompt template
        if name == "refactor-rename":
            return self.prompt_refactor_rename(arguments)
        elif name == "refactor-extract-function":
            return self.prompt_refactor_extract_function(arguments)
        elif name == "refactor-inline":
            return self.prompt_refactor_inline(arguments)
        elif name == "generate-tests":
            return self.prompt_generate_tests(arguments)
        elif name == "generate-trait-impl":
            return self.prompt_generate_trait_impl(arguments)
        elif name == "generate-constructor":
            return self.prompt_generate_constructor(arguments)
        elif name == "docs-add-docstrings":
            return self.prompt_docs_add_docstrings(arguments)
        elif name == "docs-explain-code":
            return self.prompt_docs_explain_code(arguments)
        elif name == "docs-generate-readme":
            return self.prompt_docs_generate_readme(arguments)
        elif name == "analyze-find-bugs":
            return self.prompt_analyze_find_bugs(arguments)
        elif name == "analyze-suggest-improvements":
            return self.prompt_analyze_suggest_improvements(arguments)
        elif name == "analyze-performance":
            return self.prompt_analyze_performance(arguments)
        else:
            return Err("Prompt not found: " + name)

    # --- Prompt Templates ---

    # Refactor: Rename
    fn prompt_refactor_rename(args: Dict<String, String>) -> Result<PromptResult, String>:
        if not args.contains("old_name"):
            return Err("Missing required argument: old_name")
        if not args.contains("new_name"):
            return Err("Missing required argument: new_name")

        val old_name = args["old_name"]
        val new_name = args["new_name"]
        val file = args.get("file") ?? "the codebase"

        var content = "Rename the symbol '" + old_name + "' to '" + new_name + "' in " + file + ". Please:{NL}"
        content = content + "1. Find all occurrences of '" + old_name + "'{NL}"
        content = content + "2. Rename to '" + new_name + "' while preserving functionality{NL}"
        content = content + "3. Update any documentation or comments{NL}"
        content = content + "4. Ensure no naming conflicts are introduced"

        Ok(PromptResult(
            description: "Rename symbol '" + old_name + "' to '" + new_name + "'",
            messages: [make_user_message(content)]
        ))

    # Refactor: Extract Function
    fn prompt_refactor_extract_function(args: Dict<String, String>) -> Result<PromptResult, String>:
        if not args.contains("code"):
            return Err("Missing required argument: code")
        if not args.contains("function_name"):
            return Err("Missing required argument: function_name")
        if not args.contains("file"):
            return Err("Missing required argument: file")

        val code = args["code"]
        val function_name = args["function_name"]
        val file = args["file"]

        var content = "Extract the following code from " + file + " into a new function named '" + function_name + "':{NL}{NL}"
        content = content + "```simple{NL}" + code + "{NL}```{NL}{NL}"
        content = content + "Please:{NL}"
        content = content + "1. Create a new function with appropriate parameters{NL}"
        content = content + "2. Infer parameter types from usage{NL}"
        content = content + "3. Determine the return type{NL}"
        content = content + "4. Replace the original code with a call to the new function{NL}"
        content = content + "5. Add appropriate documentation comments"

        Ok(PromptResult(
            description: "Extract code into function '" + function_name + "'",
            messages: [make_user_message(content)]
        ))

    # Refactor: Inline
    fn prompt_refactor_inline(args: Dict<String, String>) -> Result<PromptResult, String>:
        if not args.contains("name"):
            return Err("Missing required argument: name")
        if not args.contains("file"):
            return Err("Missing required argument: file")

        val name = args["name"]
        val file = args["file"]

        var content = "Inline the symbol '" + name + "' in " + file + ". Please:{NL}"
        content = content + "1. Find the definition of '" + name + "'{NL}"
        content = content + "2. Replace all usages with the inline code{NL}"
        content = content + "3. Remove the original definition{NL}"
        content = content + "4. Ensure the code still works correctly"

        Ok(PromptResult(
            description: "Inline symbol '" + name + "'",
            messages: [make_user_message(content)]
        ))

    # Generate: Tests
    fn prompt_generate_tests(args: Dict<String, String>) -> Result<PromptResult, String>:
        if not args.contains("target"):
            return Err("Missing required argument: target")
        if not args.contains("file"):
            return Err("Missing required argument: file")

        val target = args["target"]
        val file = args["file"]

        var content = "Generate comprehensive SSpec tests for '" + target + "' in " + file + ". Please:{NL}"
        content = content + "1. Read the implementation of '" + target + "'{NL}"
        content = content + "2. Identify edge cases and important scenarios{NL}"
        content = content + "3. Write tests using the SSpec framework (it/describe blocks){NL}"
        content = content + "4. Include positive and negative test cases{NL}"
        content = content + "5. Test boundary conditions{NL}"
        content = content + "6. Follow Simple's testing conventions in CLAUDE.md"

        Ok(PromptResult(
            description: "Generate SSpec tests for '" + target + "'",
            messages: [make_user_message(content)]
        ))

    # Generate: Trait Implementation
    fn prompt_generate_trait_impl(args: Dict<String, String>) -> Result<PromptResult, String>:
        if not args.contains("class_name"):
            return Err("Missing required argument: class_name")
        if not args.contains("trait_name"):
            return Err("Missing required argument: trait_name")
        if not args.contains("file"):
            return Err("Missing required argument: file")

        val class_name = args["class_name"]
        val trait_name = args["trait_name"]
        val file = args["file"]

        var content = "Implement the trait '" + trait_name + "' for the class '" + class_name + "' in " + file + ". Please:{NL}"
        content = content + "1. Find the trait definition for '" + trait_name + "'{NL}"
        content = content + "2. Find the class definition for '" + class_name + "'{NL}"
        content = content + "3. Implement all required trait methods{NL}"
        content = content + "4. Use idiomatic Simple code{NL}"
        content = content + "5. Add documentation comments for each method"

        Ok(PromptResult(
            description: "Implement trait '" + trait_name + "' for '" + class_name + "'",
            messages: [make_user_message(content)]
        ))

    # Generate: Constructor
    fn prompt_generate_constructor(args: Dict<String, String>) -> Result<PromptResult, String>:
        if not args.contains("class_name"):
            return Err("Missing required argument: class_name")
        if not args.contains("file"):
            return Err("Missing required argument: file")

        val class_name = args["class_name"]
        val file = args["file"]

        var content = "Generate a constructor (static factory method) for the class '" + class_name + "' in " + file + ". Please:{NL}"
        content = content + "1. Read the class definition{NL}"
        content = content + "2. Create a static fn with appropriate parameters for all fields{NL}"
        content = content + "3. Use the direct construction pattern: ClassName(field: value, ...){NL}"
        content = content + "4. Add parameter validation if needed{NL}"
        content = content + "5. Add documentation comments{NL}"
        content = content + "6. Follow Simple's constructor conventions"

        Ok(PromptResult(
            description: "Generate constructor for '" + class_name + "'",
            messages: [make_user_message(content)]
        ))

    # Docs: Add Docstrings
    fn prompt_docs_add_docstrings(args: Dict<String, String>) -> Result<PromptResult, String>:
        if not args.contains("file"):
            return Err("Missing required argument: file")

        val target = args.get("target") ?? "all functions and classes"
        val file = args["file"]

        var content = "Add documentation comments to " + target + " in " + file + ". Please:{NL}"
        content = content + "1. For each function/method: describe what it does, parameters, and return value{NL}"
        content = content + "2. For each class: describe its purpose and usage{NL}"
        content = content + "3. Use clear, concise language{NL}"
        content = content + "4. Include examples where helpful{NL}"
        content = content + "5. Follow Simple's documentation style"

        Ok(PromptResult(
            description: "Add documentation to " + target + " in " + file,
            messages: [make_user_message(content)]
        ))

    # Docs: Explain Code
    fn prompt_docs_explain_code(args: Dict<String, String>) -> Result<PromptResult, String>:
        val code = args.get("code")
        val file = args.get("file")

        var content = ""
        if code.?:
            content = "Explain the following Simple code:{NL}{NL}"
            content = content + "```simple{NL}" + code.unwrap() + "{NL}```{NL}{NL}"
            content = content + "Please provide:{NL}"
            content = content + "1. A high-level summary of what the code does{NL}"
            content = content + "2. An explanation of key logic and algorithms{NL}"
            content = content + "3. Any notable patterns or techniques used{NL}"
            content = content + "4. Potential improvements or concerns"
        elif file.?:
            content = "Explain the code in " + file.unwrap() + ". Please provide:{NL}"
            content = content + "1. An overview of the file's purpose{NL}"
            content = content + "2. Key functions and classes{NL}"
            content = content + "3. How different parts interact{NL}"
            content = content + "4. The overall architecture"
        else:
            content = "Please provide code to explain via the 'code' or 'file' argument"

        Ok(PromptResult(
            description: "Explain Simple code",
            messages: [make_user_message(content)]
        ))

    # Docs: Generate README
    fn prompt_docs_generate_readme(args: Dict<String, String>) -> Result<PromptResult, String>:
        var content = "Generate a comprehensive README.md for this Simple project. Please:{NL}"
        content = content + "1. Read the project structure and main files{NL}"
        content = content + "2. Identify the project's purpose{NL}"
        content = content + "3. Include sections for:{NL}"
        content = content + "   - Project description{NL}"
        content = content + "   - Installation instructions{NL}"
        content = content + "   - Usage examples{NL}"
        content = content + "   - API documentation (if applicable){NL}"
        content = content + "   - Testing instructions{NL}"
        content = content + "   - Contributing guidelines{NL}"
        content = content + "4. Use clear, professional language{NL}"
        content = content + "5. Include code examples where appropriate"

        Ok(PromptResult(
            description: "Generate README.md for the project",
            messages: [make_user_message(content)]
        ))

    # Analyze: Find Bugs
    fn prompt_analyze_find_bugs(args: Dict<String, String>) -> Result<PromptResult, String>:
        if not args.contains("file"):
            return Err("Missing required argument: file")

        val file = args["file"]

        var content = "Analyze " + file + " for potential bugs. Please look for:{NL}"
        content = content + "1. Off-by-one errors{NL}"
        content = content + "2. Null/None dereferences{NL}"
        content = content + "3. Resource leaks{NL}"
        content = content + "4. Race conditions (if concurrent){NL}"
        content = content + "5. Logic errors{NL}"
        content = content + "6. Type mismatches{NL}"
        content = content + "7. Unhandled error cases{NL}{NL}"
        content = content + "For each issue found, explain:{NL}"
        content = content + "- What the bug is{NL}"
        content = content + "- Where it occurs (line number){NL}"
        content = content + "- Why it's problematic{NL}"
        content = content + "- How to fix it"

        Ok(PromptResult(
            description: "Analyze " + file + " for potential bugs",
            messages: [make_user_message(content)]
        ))

    # Analyze: Suggest Improvements
    fn prompt_analyze_suggest_improvements(args: Dict<String, String>) -> Result<PromptResult, String>:
        if not args.contains("file"):
            return Err("Missing required argument: file")

        val file = args["file"]

        var content = "Analyze " + file + " and suggest improvements. Consider:{NL}"
        content = content + "1. Code clarity and readability{NL}"
        content = content + "2. Performance optimizations{NL}"
        content = content + "3. Better error handling{NL}"
        content = content + "4. Idiomatic Simple patterns{NL}"
        content = content + "5. Code duplication (DRY principle){NL}"
        content = content + "6. Function/class design{NL}"
        content = content + "7. Documentation quality{NL}{NL}"
        content = content + "For each suggestion:{NL}"
        content = content + "- Explain the current issue{NL}"
        content = content + "- Propose a specific improvement{NL}"
        content = content + "- Explain why it's better"

        Ok(PromptResult(
            description: "Suggest improvements for " + file,
            messages: [make_user_message(content)]
        ))

    # Analyze: Performance
    fn prompt_analyze_performance(args: Dict<String, String>) -> Result<PromptResult, String>:
        if not args.contains("file"):
            return Err("Missing required argument: file")

        val file = args["file"]

        var content = "Analyze " + file + " for performance issues. Look for:{NL}"
        content = content + "1. Inefficient algorithms (wrong time complexity){NL}"
        content = content + "2. Unnecessary allocations{NL}"
        content = content + "3. Redundant computations{NL}"
        content = content + "4. Inefficient data structures{NL}"
        content = content + "5. Missing caching opportunities{NL}"
        content = content + "6. Unnecessary copying{NL}"
        content = content + "7. Blocking operations that could be async{NL}{NL}"
        content = content + "For each issue:{NL}"
        content = content + "- Identify the performance problem{NL}"
        content = content + "- Estimate the impact (complexity analysis){NL}"
        content = content + "- Suggest an optimized alternative{NL}"
        content = content + "- Explain the trade-offs"

        Ok(PromptResult(
            description: "Analyze " + file + " for performance issues",
            messages: [make_user_message(content)]
        ))
