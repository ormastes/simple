# MCP Prompt Manager
#
# Manages prompt templates for the MCP server.
# Prompts provide pre-built interaction templates for common tasks:
# - Refactoring prompts (rename, extract function, etc.)
# - Code generation prompts (implement trait, add tests, etc.)
# - Documentation prompts (add docstrings, explain code, etc.)
# - Analysis prompts (find bugs, suggest improvements, etc.)
#
# Prompts can have arguments that are filled in by the user.

use app.io

# --- Prompt Types ---

# Prompt argument definition
struct PromptArgument:
    name: String
    description: String
    required: Bool

# Prompt information returned by prompts/list
struct PromptInfo:
    name: String
    description: String
    arguments: [PromptArgument]

# Prompt message (user or assistant)
enum PromptRole:
    User
    Assistant

struct PromptMessage:
    role: PromptRole
    content: String
    role_str: String

fn make_user_message(content: String) -> PromptMessage:
    PromptMessage(role: PromptRole.User, content: content, role_str: "user")

fn make_assistant_message(content: String) -> PromptMessage:
    PromptMessage(role: PromptRole.Assistant, content: content, role_str: "assistant")

# Prompt result returned by prompts/get
struct PromptResult:
    description: String
    messages: [PromptMessage]

# --- Prompt Manager ---

class PromptManager:
    # Project root directory
    project_root: String

    # Create a new prompt manager
    static fn create(project_root: String) -> PromptManager:
        PromptManager(project_root: project_root)

    # --- List Prompts ---

    # List all available prompts
    fn list_prompts() -> [PromptInfo]:
        var prompts: [PromptInfo] = []

        # --- Refactoring Prompts ---
        prompts.push(PromptInfo(
            name: "refactor-rename",
            description: "Rename a symbol throughout the codebase",
            arguments: [
                PromptArgument(name: "old_name", description: "Current symbol name", required: true),
                PromptArgument(name: "new_name", description: "New symbol name", required: true),
                PromptArgument(name: "file", description: "File containing the symbol", required: false)
            ]
        ))

        prompts.push(PromptInfo(
            name: "refactor-extract-function",
            description: "Extract code into a new function",
            arguments: [
                PromptArgument(name: "code", description: "Code to extract", required: true),
                PromptArgument(name: "function_name", description: "Name for new function", required: true),
                PromptArgument(name: "file", description: "File containing the code", required: true)
            ]
        ))

        prompts.push(PromptInfo(
            name: "refactor-inline",
            description: "Inline a function or variable",
            arguments: [
                PromptArgument(name: "name", description: "Symbol to inline", required: true),
                PromptArgument(name: "file", description: "File containing the symbol", required: true)
            ]
        ))

        # --- Code Generation Prompts ---
        prompts.push(PromptInfo(
            name: "generate-tests",
            description: "Generate SSpec tests for a function or class",
            arguments: [
                PromptArgument(name: "target", description: "Function or class name", required: true),
                PromptArgument(name: "file", description: "File containing the target", required: true)
            ]
        ))

        prompts.push(PromptInfo(
            name: "generate-trait-impl",
            description: "Generate trait implementation for a class",
            arguments: [
                PromptArgument(name: "class_name", description: "Class name", required: true),
                PromptArgument(name: "trait_name", description: "Trait name", required: true),
                PromptArgument(name: "file", description: "File containing the class", required: true)
            ]
        ))

        prompts.push(PromptInfo(
            name: "generate-constructor",
            description: "Generate constructor for a class",
            arguments: [
                PromptArgument(name: "class_name", description: "Class name", required: true),
                PromptArgument(name: "file", description: "File containing the class", required: true)
            ]
        ))

        # --- Documentation Prompts ---
        prompts.push(PromptInfo(
            name: "docs-add-docstrings",
            description: "Add documentation comments to functions and classes",
            arguments: [
                PromptArgument(name: "target", description: "Function or class name", required: false),
                PromptArgument(name: "file", description: "File to document", required: true)
            ]
        ))

        prompts.push(PromptInfo(
            name: "docs-explain-code",
            description: "Explain how code works",
            arguments: [
                PromptArgument(name: "code", description: "Code to explain", required: false),
                PromptArgument(name: "file", description: "File containing the code", required: false)
            ]
        ))

        prompts.push(PromptInfo(
            name: "docs-generate-readme",
            description: "Generate README.md for the project",
            arguments: []
        ))

        # --- Analysis Prompts ---
        prompts.push(PromptInfo(
            name: "analyze-find-bugs",
            description: "Analyze code for potential bugs",
            arguments: [
                PromptArgument(name: "file", description: "File to analyze", required: true)
            ]
        ))

        prompts.push(PromptInfo(
            name: "analyze-suggest-improvements",
            description: "Suggest code improvements",
            arguments: [
                PromptArgument(name: "file", description: "File to analyze", required: true)
            ]
        ))

        prompts.push(PromptInfo(
            name: "analyze-performance",
            description: "Analyze code for performance issues",
            arguments: [
                PromptArgument(name: "file", description: "File to analyze", required: true)
            ]
        ))

        prompts

    # --- Get Prompt ---

    # Get a prompt by name with arguments
    fn get_prompt(name: String, arguments: Dict<String, String>) -> Result<PromptResult, String>:
        # Dispatch to appropriate prompt template
        if name == "refactor-rename":
            return self.prompt_refactor_rename(arguments)
        elif name == "refactor-extract-function":
            return self.prompt_refactor_extract_function(arguments)
        elif name == "refactor-inline":
            return self.prompt_refactor_inline(arguments)
        elif name == "generate-tests":
            return self.prompt_generate_tests(arguments)
        elif name == "generate-trait-impl":
            return self.prompt_generate_trait_impl(arguments)
        elif name == "generate-constructor":
            return self.prompt_generate_constructor(arguments)
        elif name == "docs-add-docstrings":
            return self.prompt_docs_add_docstrings(arguments)
        elif name == "docs-explain-code":
            return self.prompt_docs_explain_code(arguments)
        elif name == "docs-generate-readme":
            return self.prompt_docs_generate_readme(arguments)
        elif name == "analyze-find-bugs":
            return self.prompt_analyze_find_bugs(arguments)
        elif name == "analyze-suggest-improvements":
            return self.prompt_analyze_suggest_improvements(arguments)
        elif name == "analyze-performance":
            return self.prompt_analyze_performance(arguments)
        else:
            return Err("Prompt not found: " + name)

    # --- Prompt Templates ---

    # Refactor: Rename
    fn prompt_refactor_rename(args: Dict<String, String>) -> Result<PromptResult, String>:
        if not args.contains("old_name"):
            return Err("Missing required argument: old_name")
        if not args.contains("new_name"):
            return Err("Missing required argument: new_name")

        val old_name = args["old_name"]
        val new_name = args["new_name"]
        val file = args.get("file") ?? "the codebase"

        var content = "Rename the symbol '" + old_name + "' to '" + new_name + "' in " + file + ". Please:\n"
        content = content + "1. Find all occurrences of '" + old_name + "'\n"
        content = content + "2. Rename to '" + new_name + "' while preserving functionality\n"
        content = content + "3. Update any documentation or comments\n"
        content = content + "4. Ensure no naming conflicts are introduced"

        Ok(PromptResult(
            description: "Rename symbol '" + old_name + "' to '" + new_name + "'",
            messages: [make_user_message(content)]
        ))

    # Refactor: Extract Function
    fn prompt_refactor_extract_function(args: Dict<String, String>) -> Result<PromptResult, String>:
        if not args.contains("code"):
            return Err("Missing required argument: code")
        if not args.contains("function_name"):
            return Err("Missing required argument: function_name")
        if not args.contains("file"):
            return Err("Missing required argument: file")

        val code = args["code"]
        val function_name = args["function_name"]
        val file = args["file"]

        var content = "Extract the following code from " + file + " into a new function named '" + function_name + "':\n\n"
        content = content + "```simple\n" + code + "\n```\n\n"
        content = content + "Please:\n"
        content = content + "1. Create a new function with appropriate parameters\n"
        content = content + "2. Infer parameter types from usage\n"
        content = content + "3. Determine the return type\n"
        content = content + "4. Replace the original code with a call to the new function\n"
        content = content + "5. Add appropriate documentation comments"

        Ok(PromptResult(
            description: "Extract code into function '" + function_name + "'",
            messages: [make_user_message(content)]
        ))

    # Refactor: Inline
    fn prompt_refactor_inline(args: Dict<String, String>) -> Result<PromptResult, String>:
        if not args.contains("name"):
            return Err("Missing required argument: name")
        if not args.contains("file"):
            return Err("Missing required argument: file")

        val name = args["name"]
        val file = args["file"]

        var content = "Inline the symbol '" + name + "' in " + file + ". Please:\n"
        content = content + "1. Find the definition of '" + name + "'\n"
        content = content + "2. Replace all usages with the inline code\n"
        content = content + "3. Remove the original definition\n"
        content = content + "4. Ensure the code still works correctly"

        Ok(PromptResult(
            description: "Inline symbol '" + name + "'",
            messages: [make_user_message(content)]
        ))

    # Generate: Tests
    fn prompt_generate_tests(args: Dict<String, String>) -> Result<PromptResult, String>:
        if not args.contains("target"):
            return Err("Missing required argument: target")
        if not args.contains("file"):
            return Err("Missing required argument: file")

        val target = args["target"]
        val file = args["file"]

        var content = "Generate comprehensive SSpec tests for '" + target + "' in " + file + ". Please:\n"
        content = content + "1. Read the implementation of '" + target + "'\n"
        content = content + "2. Identify edge cases and important scenarios\n"
        content = content + "3. Write tests using the SSpec framework (it/describe blocks)\n"
        content = content + "4. Include positive and negative test cases\n"
        content = content + "5. Test boundary conditions\n"
        content = content + "6. Follow Simple's testing conventions in CLAUDE.md"

        Ok(PromptResult(
            description: "Generate SSpec tests for '" + target + "'",
            messages: [make_user_message(content)]
        ))

    # Generate: Trait Implementation
    fn prompt_generate_trait_impl(args: Dict<String, String>) -> Result<PromptResult, String>:
        if not args.contains("class_name"):
            return Err("Missing required argument: class_name")
        if not args.contains("trait_name"):
            return Err("Missing required argument: trait_name")
        if not args.contains("file"):
            return Err("Missing required argument: file")

        val class_name = args["class_name"]
        val trait_name = args["trait_name"]
        val file = args["file"]

        var content = "Implement the trait '" + trait_name + "' for the class '" + class_name + "' in " + file + ". Please:\n"
        content = content + "1. Find the trait definition for '" + trait_name + "'\n"
        content = content + "2. Find the class definition for '" + class_name + "'\n"
        content = content + "3. Implement all required trait methods\n"
        content = content + "4. Use idiomatic Simple code\n"
        content = content + "5. Add documentation comments for each method"

        Ok(PromptResult(
            description: "Implement trait '" + trait_name + "' for '" + class_name + "'",
            messages: [make_user_message(content)]
        ))

    # Generate: Constructor
    fn prompt_generate_constructor(args: Dict<String, String>) -> Result<PromptResult, String>:
        if not args.contains("class_name"):
            return Err("Missing required argument: class_name")
        if not args.contains("file"):
            return Err("Missing required argument: file")

        val class_name = args["class_name"]
        val file = args["file"]

        var content = "Generate a constructor (static factory method) for the class '" + class_name + "' in " + file + ". Please:\n"
        content = content + "1. Read the class definition\n"
        content = content + "2. Create a static fn with appropriate parameters for all fields\n"
        content = content + "3. Use the direct construction pattern: ClassName(field: value, ...)\n"
        content = content + "4. Add parameter validation if needed\n"
        content = content + "5. Add documentation comments\n"
        content = content + "6. Follow Simple's constructor conventions"

        Ok(PromptResult(
            description: "Generate constructor for '" + class_name + "'",
            messages: [make_user_message(content)]
        ))

    # Docs: Add Docstrings
    fn prompt_docs_add_docstrings(args: Dict<String, String>) -> Result<PromptResult, String>:
        if not args.contains("file"):
            return Err("Missing required argument: file")

        val target = args.get("target") ?? "all functions and classes"
        val file = args["file"]

        var content = "Add documentation comments to " + target + " in " + file + ". Please:\n"
        content = content + "1. For each function/method: describe what it does, parameters, and return value\n"
        content = content + "2. For each class: describe its purpose and usage\n"
        content = content + "3. Use clear, concise language\n"
        content = content + "4. Include examples where helpful\n"
        content = content + "5. Follow Simple's documentation style"

        Ok(PromptResult(
            description: "Add documentation to " + target + " in " + file,
            messages: [make_user_message(content)]
        ))

    # Docs: Explain Code
    fn prompt_docs_explain_code(args: Dict<String, String>) -> Result<PromptResult, String>:
        val code = args.get("code")
        val file = args.get("file")

        var content = ""
        if code.?:
            content = "Explain the following Simple code:\n\n"
            content = content + "```simple\n" + code.unwrap() + "\n```\n\n"
            content = content + "Please provide:\n"
            content = content + "1. A high-level summary of what the code does\n"
            content = content + "2. An explanation of key logic and algorithms\n"
            content = content + "3. Any notable patterns or techniques used\n"
            content = content + "4. Potential improvements or concerns"
        elif file.?:
            content = "Explain the code in " + file.unwrap() + ". Please provide:\n"
            content = content + "1. An overview of the file's purpose\n"
            content = content + "2. Key functions and classes\n"
            content = content + "3. How different parts interact\n"
            content = content + "4. The overall architecture"
        else:
            content = "Please provide code to explain via the 'code' or 'file' argument"

        Ok(PromptResult(
            description: "Explain Simple code",
            messages: [make_user_message(content)]
        ))

    # Docs: Generate README
    fn prompt_docs_generate_readme(args: Dict<String, String>) -> Result<PromptResult, String>:
        var content = "Generate a comprehensive README.md for this Simple project. Please:\n"
        content = content + "1. Read the project structure and main files\n"
        content = content + "2. Identify the project's purpose\n"
        content = content + "3. Include sections for:\n"
        content = content + "   - Project description\n"
        content = content + "   - Installation instructions\n"
        content = content + "   - Usage examples\n"
        content = content + "   - API documentation (if applicable)\n"
        content = content + "   - Testing instructions\n"
        content = content + "   - Contributing guidelines\n"
        content = content + "4. Use clear, professional language\n"
        content = content + "5. Include code examples where appropriate"

        Ok(PromptResult(
            description: "Generate README.md for the project",
            messages: [make_user_message(content)]
        ))

    # Analyze: Find Bugs
    fn prompt_analyze_find_bugs(args: Dict<String, String>) -> Result<PromptResult, String>:
        if not args.contains("file"):
            return Err("Missing required argument: file")

        val file = args["file"]

        var content = "Analyze " + file + " for potential bugs. Please look for:\n"
        content = content + "1. Off-by-one errors\n"
        content = content + "2. Null/None dereferences\n"
        content = content + "3. Resource leaks\n"
        content = content + "4. Race conditions (if concurrent)\n"
        content = content + "5. Logic errors\n"
        content = content + "6. Type mismatches\n"
        content = content + "7. Unhandled error cases\n\n"
        content = content + "For each issue found, explain:\n"
        content = content + "- What the bug is\n"
        content = content + "- Where it occurs (line number)\n"
        content = content + "- Why it's problematic\n"
        content = content + "- How to fix it"

        Ok(PromptResult(
            description: "Analyze " + file + " for potential bugs",
            messages: [make_user_message(content)]
        ))

    # Analyze: Suggest Improvements
    fn prompt_analyze_suggest_improvements(args: Dict<String, String>) -> Result<PromptResult, String>:
        if not args.contains("file"):
            return Err("Missing required argument: file")

        val file = args["file"]

        var content = "Analyze " + file + " and suggest improvements. Consider:\n"
        content = content + "1. Code clarity and readability\n"
        content = content + "2. Performance optimizations\n"
        content = content + "3. Better error handling\n"
        content = content + "4. Idiomatic Simple patterns\n"
        content = content + "5. Code duplication (DRY principle)\n"
        content = content + "6. Function/class design\n"
        content = content + "7. Documentation quality\n\n"
        content = content + "For each suggestion:\n"
        content = content + "- Explain the current issue\n"
        content = content + "- Propose a specific improvement\n"
        content = content + "- Explain why it's better"

        Ok(PromptResult(
            description: "Suggest improvements for " + file,
            messages: [make_user_message(content)]
        ))

    # Analyze: Performance
    fn prompt_analyze_performance(args: Dict<String, String>) -> Result<PromptResult, String>:
        if not args.contains("file"):
            return Err("Missing required argument: file")

        val file = args["file"]

        var content = "Analyze " + file + " for performance issues. Look for:\n"
        content = content + "1. Inefficient algorithms (wrong time complexity)\n"
        content = content + "2. Unnecessary allocations\n"
        content = content + "3. Redundant computations\n"
        content = content + "4. Inefficient data structures\n"
        content = content + "5. Missing caching opportunities\n"
        content = content + "6. Unnecessary copying\n"
        content = content + "7. Blocking operations that could be async\n\n"
        content = content + "For each issue:\n"
        content = content + "- Identify the performance problem\n"
        content = content + "- Estimate the impact (complexity analysis)\n"
        content = content + "- Suggest an optimized alternative\n"
        content = content + "- Explain the trade-offs"

        Ok(PromptResult(
            description: "Analyze " + file + " for performance issues",
            messages: [make_user_message(content)]
        ))
