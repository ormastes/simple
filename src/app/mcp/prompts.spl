# MCP Prompt Manager
#
# Manages prompt templates for the MCP server.
# Prompts provide pre-built interaction templates for common tasks:
# - Refactoring prompts (rename, extract function, etc.)
# - Code generation prompts (implement trait, add tests, etc.)
# - Documentation prompts (add docstrings, explain code, etc.)
# - Analysis prompts (find bugs, suggest improvements, etc.)
#
# Prompts can have arguments that are filled in by the user.

use app.io
use std.text.{NL}

# --- Prompt Types ---

# Prompt argument definition
struct PromptArgument:
    name: text
    description: text
    required: bool

# Prompt information returned by prompts/list
struct PromptInfo:
    name: text
    description: text
    arguments: [PromptArgument]

# Prompt message (user or assistant)
enum PromptRole:
    User
    Assistant

struct PromptMessage:
    role: PromptRole
    content: text
    role_str: text

fn make_user_message(content: text) -> PromptMessage:
    PromptMessage(role: PromptRole.User, content: content, role_str: "user")

fn make_assistant_message(content: text) -> PromptMessage:
    PromptMessage(role: PromptRole.Assistant, content: content, role_str: "assistant")

# Prompt result returned by prompts/get
struct PromptResult:
    description: text
    messages: [PromptMessage]

# --- Prompt Manager ---

class PromptManager:
    # Project root directory
    project_root: text
    prompts_cache: Option<[PromptInfo]>

    # Create a new prompt manager
    static fn create(project_root: text) -> PromptManager:
        PromptManager(
            project_root: project_root,
            prompts_cache: nil
        )

    # --- List Prompts ---

    # List all available prompts
    fn list_prompts() -> [PromptInfo]:
        match self.prompts_cache:
            case Some(p): return p
            case nil: ()

        var prompts: [PromptInfo] = []

        # --- Refactoring Prompts ---
        prompts.push(PromptInfo(
            name: "refactor-rename",
            description: "Rename a symbol throughout the codebase",
            arguments: [
                PromptArgument(name: "old_name", description: "Current symbol name", required: true),
                PromptArgument(name: "new_name", description: "New symbol name", required: true),
                PromptArgument(name: "file", description: "File containing the symbol", required: false)
            ]
        ))

        prompts.push(PromptInfo(
            name: "refactor-extract-function",
            description: "Extract code into a new function",
            arguments: [
                PromptArgument(name: "code", description: "Code to extract", required: true),
                PromptArgument(name: "function_name", description: "Name for new function", required: true),
                PromptArgument(name: "file", description: "File containing the code", required: true)
            ]
        ))

        prompts.push(PromptInfo(
            name: "refactor-inline",
            description: "Inline a function or variable",
            arguments: [
                PromptArgument(name: "name", description: "Symbol to inline", required: true),
                PromptArgument(name: "file", description: "File containing the symbol", required: true)
            ]
        ))

        # --- Code Generation Prompts ---
        prompts.push(PromptInfo(
            name: "generate-tests",
            description: "Generate SSpec tests for a function or class",
            arguments: [
                PromptArgument(name: "target", description: "Function or class name", required: true),
                PromptArgument(name: "file", description: "File containing the target", required: true)
            ]
        ))

        prompts.push(PromptInfo(
            name: "generate-trait-impl",
            description: "Generate trait implementation for a class",
            arguments: [
                PromptArgument(name: "class_name", description: "Class name", required: true),
                PromptArgument(name: "trait_name", description: "Trait name", required: true),
                PromptArgument(name: "file", description: "File containing the class", required: true)
            ]
        ))

        prompts.push(PromptInfo(
            name: "generate-constructor",
            description: "Generate constructor for a class",
            arguments: [
                PromptArgument(name: "class_name", description: "Class name", required: true),
                PromptArgument(name: "file", description: "File containing the class", required: true)
            ]
        ))

        # --- Documentation Prompts ---
        prompts.push(PromptInfo(
            name: "docs-add-docstrings",
            description: "Add documentation comments to functions and classes",
            arguments: [
                PromptArgument(name: "target", description: "Function or class name", required: false),
                PromptArgument(name: "file", description: "File to document", required: true)
            ]
        ))

        prompts.push(PromptInfo(
            name: "docs-explain-code",
            description: "Explain how code works",
            arguments: [
                PromptArgument(name: "code", description: "Code to explain", required: false),
                PromptArgument(name: "file", description: "File containing the code", required: false)
            ]
        ))

        prompts.push(PromptInfo(
            name: "docs-generate-readme",
            description: "Generate README.md for the project",
            arguments: []
        ))

        # --- Analysis Prompts ---
        prompts.push(PromptInfo(
            name: "analyze-find-bugs",
            description: "Analyze code for potential bugs",
            arguments: [
                PromptArgument(name: "file", description: "File to analyze", required: true)
            ]
        ))

        prompts.push(PromptInfo(
            name: "analyze-suggest-improvements",
            description: "Suggest code improvements",
            arguments: [
                PromptArgument(name: "file", description: "File to analyze", required: true)
            ]
        ))

        prompts.push(PromptInfo(
            name: "analyze-performance",
            description: "Analyze code for performance issues",
            arguments: [
                PromptArgument(name: "file", description: "File to analyze", required: true)
            ]
        ))

        self.prompts_cache = Some(prompts)
        prompts

    # --- Get Prompt ---

    # Get a prompt by name with arguments
    fn get_prompt(name: text, arguments: Dict<text, text>) -> Result<PromptResult, text>:
        # Dispatch to appropriate prompt template
        if name == "refactor-rename":
            return self.prompt_refactor_rename(arguments)
        elif name == "refactor-extract-function":
            return self.prompt_refactor_extract_function(arguments)
        elif name == "refactor-inline":
            return self.prompt_refactor_inline(arguments)
        elif name == "generate-tests":
            return self.prompt_generate_tests(arguments)
        elif name == "generate-trait-impl":
            return self.prompt_generate_trait_impl(arguments)
        elif name == "generate-constructor":
            return self.prompt_generate_constructor(arguments)
        elif name == "docs-add-docstrings":
            return self.prompt_docs_add_docstrings(arguments)
        elif name == "docs-explain-code":
            return self.prompt_docs_explain_code(arguments)
        elif name == "docs-generate-readme":
            return self.prompt_docs_generate_readme(arguments)
        elif name == "analyze-find-bugs":
            return self.prompt_analyze_find_bugs(arguments)
        elif name == "analyze-suggest-improvements":
            return self.prompt_analyze_suggest_improvements(arguments)
        elif name == "analyze-performance":
            return self.prompt_analyze_performance(arguments)
        else:
            return Err("Prompt not found: " + name)

    # --- Prompt Templates ---

    # Refactor: Rename
    fn prompt_refactor_rename(args: Dict<String, String>) -> Result<PromptResult, String>:
        if not args.contains("old_name"):
            return Err("Missing required argument: old_name")
        if not args.contains("new_name"):
            return Err("Missing required argument: new_name")

        val old_name = args["old_name"]
        val new_name = args["new_name"]
        val file = args.get("file") ?? "the codebase"

        var parts = []
        parts.append("Rename the symbol '" + old_name + "' to '" + new_name + "' in " + file + ". Please:{NL}")
        parts.append("1. Find all occurrences of '" + old_name + "'{NL}")
        parts.append("2. Rename to '" + new_name + "' while preserving functionality{NL}")
        parts.append("3. Update any documentation or comments{NL}")
        parts.append("4. Ensure no naming conflicts are introduced")
        val content = parts.join("")

        Ok(PromptResult(
            description: "Rename symbol '" + old_name + "' to '" + new_name + "'",
            messages: [make_user_message(content)]
        ))

    # Refactor: Extract Function
    fn prompt_refactor_extract_function(args: Dict<String, String>) -> Result<PromptResult, String>:
        if not args.contains("code"):
            return Err("Missing required argument: code")
        if not args.contains("function_name"):
            return Err("Missing required argument: function_name")
        if not args.contains("file"):
            return Err("Missing required argument: file")

        val code = args["code"]
        val function_name = args["function_name"]
        val file = args["file"]

        var parts = []
        parts.append("Extract the following code from " + file + " into a new function named '" + function_name + "':{NL}{NL}")
        parts.append("```simple{NL}" + code + "{NL}```{NL}{NL}")
        parts.append("Please:{NL}")
        parts.append("1. Create a new function with appropriate parameters{NL}")
        parts.append("2. Infer parameter types from usage{NL}")
        parts.append("3. Determine the return type{NL}")
        parts.append("4. Replace the original code with a call to the new function{NL}")
        parts.append("5. Add appropriate documentation comments")
        val content = parts.join("")

        Ok(PromptResult(
            description: "Extract code into function '" + function_name + "'",
            messages: [make_user_message(content)]
        ))

    # Refactor: Inline
    fn prompt_refactor_inline(args: Dict<String, String>) -> Result<PromptResult, String>:
        if not args.contains("name"):
            return Err("Missing required argument: name")
        if not args.contains("file"):
            return Err("Missing required argument: file")

        val name = args["name"]
        val file = args["file"]

        var parts = []
        parts.append("Inline the symbol '" + name + "' in " + file + ". Please:{NL}")
        parts.append("1. Find the definition of '" + name + "'{NL}")
        parts.append("2. Replace all usages with the inline code{NL}")
        parts.append("3. Remove the original definition{NL}")
        parts.append("4. Ensure the code still works correctly")
        val content = parts.join("")

        Ok(PromptResult(
            description: "Inline symbol '" + name + "'",
            messages: [make_user_message(content)]
        ))

    # Generate: Tests
    fn prompt_generate_tests(args: Dict<String, String>) -> Result<PromptResult, String>:
        if not args.contains("target"):
            return Err("Missing required argument: target")
        if not args.contains("file"):
            return Err("Missing required argument: file")

        val target = args["target"]
        val file = args["file"]

        var parts = []
        parts.append("Generate comprehensive SSpec tests for '" + target + "' in " + file + ". Please:{NL}")
        parts.append("1. Read the implementation of '" + target + "'{NL}")
        parts.append("2. Identify edge cases and important scenarios{NL}")
        parts.append("3. Write tests using the SSpec framework (it/describe blocks){NL}")
        parts.append("4. Include positive and negative test cases{NL}")
        parts.append("5. Test boundary conditions{NL}")
        parts.append("6. Follow Simple's testing conventions in CLAUDE.md")
        val content = parts.join("")

        Ok(PromptResult(
            description: "Generate SSpec tests for '" + target + "'",
            messages: [make_user_message(content)]
        ))

    # Generate: Trait Implementation
    fn prompt_generate_trait_impl(args: Dict<String, String>) -> Result<PromptResult, String>:
        if not args.contains("class_name"):
            return Err("Missing required argument: class_name")
        if not args.contains("trait_name"):
            return Err("Missing required argument: trait_name")
        if not args.contains("file"):
            return Err("Missing required argument: file")

        val class_name = args["class_name"]
        val trait_name = args["trait_name"]
        val file = args["file"]

        var parts = []
        parts.append("Implement the trait '" + trait_name + "' for the class '" + class_name + "' in " + file + ". Please:{NL}")
        parts.append("1. Find the trait definition for '" + trait_name + "'{NL}")
        parts.append("2. Find the class definition for '" + class_name + "'{NL}")
        parts.append("3. Implement all required trait methods{NL}")
        parts.append("4. Use idiomatic Simple code{NL}")
        parts.append("5. Add documentation comments for each method")
        val content = parts.join("")

        Ok(PromptResult(
            description: "Implement trait '" + trait_name + "' for '" + class_name + "'",
            messages: [make_user_message(content)]
        ))

    # Generate: Constructor
    fn prompt_generate_constructor(args: Dict<String, String>) -> Result<PromptResult, String>:
        if not args.contains("class_name"):
            return Err("Missing required argument: class_name")
        if not args.contains("file"):
            return Err("Missing required argument: file")

        val class_name = args["class_name"]
        val file = args["file"]

        var parts = []
        parts.append("Generate a constructor (static factory method) for the class '" + class_name + "' in " + file + ". Please:{NL}")
        parts.append("1. Read the class definition{NL}")
        parts.append("2. Create a static fn with appropriate parameters for all fields{NL}")
        parts.append("3. Use the direct construction pattern: ClassName(field: value, ...){NL}")
        parts.append("4. Add parameter validation if needed{NL}")
        parts.append("5. Add documentation comments{NL}")
        parts.append("6. Follow Simple's constructor conventions")
        val content = parts.join("")

        Ok(PromptResult(
            description: "Generate constructor for '" + class_name + "'",
            messages: [make_user_message(content)]
        ))

    # Docs: Add Docstrings
    fn prompt_docs_add_docstrings(args: Dict<String, String>) -> Result<PromptResult, String>:
        if not args.contains("file"):
            return Err("Missing required argument: file")

        val target = args.get("target") ?? "all functions and classes"
        val file = args["file"]

        var parts = []
        parts.append("Add documentation comments to " + target + " in " + file + ". Please:{NL}")
        parts.append("1. For each function/method: describe what it does, parameters, and return value{NL}")
        parts.append("2. For each class: describe its purpose and usage{NL}")
        parts.append("3. Use clear, concise language{NL}")
        parts.append("4. Include examples where helpful{NL}")
        parts.append("5. Follow Simple's documentation style")
        val content = parts.join("")

        Ok(PromptResult(
            description: "Add documentation to " + target + " in " + file,
            messages: [make_user_message(content)]
        ))

    # Docs: Explain Code
    fn prompt_docs_explain_code(args: Dict<String, String>) -> Result<PromptResult, String>:
        val code = args.get("code")
        val file = args.get("file")

        var content = ""
        if code.?:
            var parts = []
            parts.append("Explain the following Simple code:{NL}{NL}")
            parts.append("```simple{NL}" + code.unwrap() + "{NL}```{NL}{NL}")
            parts.append("Please provide:{NL}")
            parts.append("1. A high-level summary of what the code does{NL}")
            parts.append("2. An explanation of key logic and algorithms{NL}")
            parts.append("3. Any notable patterns or techniques used{NL}")
            parts.append("4. Potential improvements or concerns")
            content = parts.join("")
        elif file.?:
            var parts = []
            parts.append("Explain the code in " + file.unwrap() + ". Please provide:{NL}")
            parts.append("1. An overview of the file's purpose{NL}")
            parts.append("2. Key functions and classes{NL}")
            parts.append("3. How different parts interact{NL}")
            parts.append("4. The overall architecture")
            content = parts.join("")
        else:
            content = "Please provide code to explain via the 'code' or 'file' argument"

        Ok(PromptResult(
            description: "Explain Simple code",
            messages: [make_user_message(content)]
        ))

    # Docs: Generate README
    fn prompt_docs_generate_readme(args: Dict<String, String>) -> Result<PromptResult, String>:
        var parts = []
        parts.append("Generate a comprehensive README.md for this Simple project. Please:{NL}")
        parts.append("1. Read the project structure and main files{NL}")
        parts.append("2. Identify the project's purpose{NL}")
        parts.append("3. Include sections for:{NL}")
        parts.append("   - Project description{NL}")
        parts.append("   - Installation instructions{NL}")
        parts.append("   - Usage examples{NL}")
        parts.append("   - API documentation (if applicable){NL}")
        parts.append("   - Testing instructions{NL}")
        parts.append("   - Contributing guidelines{NL}")
        parts.append("4. Use clear, professional language{NL}")
        parts.append("5. Include code examples where appropriate")
        val content = parts.join("")

        Ok(PromptResult(
            description: "Generate README.md for the project",
            messages: [make_user_message(content)]
        ))

    # Analyze: Find Bugs
    fn prompt_analyze_find_bugs(args: Dict<String, String>) -> Result<PromptResult, String>:
        if not args.contains("file"):
            return Err("Missing required argument: file")

        val file = args["file"]

        var parts = []
        parts.append("Analyze " + file + " for potential bugs. Please look for:{NL}")
        parts.append("1. Off-by-one errors{NL}")
        parts.append("2. Null/None dereferences{NL}")
        parts.append("3. Resource leaks{NL}")
        parts.append("4. Race conditions (if concurrent){NL}")
        parts.append("5. Logic errors{NL}")
        parts.append("6. Type mismatches{NL}")
        parts.append("7. Unhandled error cases{NL}{NL}")
        parts.append("For each issue found, explain:{NL}")
        parts.append("- What the bug is{NL}")
        parts.append("- Where it occurs (line number){NL}")
        parts.append("- Why it's problematic{NL}")
        parts.append("- How to fix it")
        val content = parts.join("")

        Ok(PromptResult(
            description: "Analyze " + file + " for potential bugs",
            messages: [make_user_message(content)]
        ))

    # Analyze: Suggest Improvements
    fn prompt_analyze_suggest_improvements(args: Dict<String, String>) -> Result<PromptResult, String>:
        if not args.contains("file"):
            return Err("Missing required argument: file")

        val file = args["file"]

        var parts = []
        parts.append("Analyze " + file + " and suggest improvements. Consider:{NL}")
        parts.append("1. Code clarity and readability{NL}")
        parts.append("2. Performance optimizations{NL}")
        parts.append("3. Better error handling{NL}")
        parts.append("4. Idiomatic Simple patterns{NL}")
        parts.append("5. Code duplication (DRY principle){NL}")
        parts.append("6. Function/class design{NL}")
        parts.append("7. Documentation quality{NL}{NL}")
        parts.append("For each suggestion:{NL}")
        parts.append("- Explain the current issue{NL}")
        parts.append("- Propose a specific improvement{NL}")
        parts.append("- Explain why it's better")
        val content = parts.join("")

        Ok(PromptResult(
            description: "Suggest improvements for " + file,
            messages: [make_user_message(content)]
        ))

    # Analyze: Performance
    fn prompt_analyze_performance(args: Dict<String, String>) -> Result<PromptResult, String>:
        if not args.contains("file"):
            return Err("Missing required argument: file")

        val file = args["file"]

        var parts = []
        parts.append("Analyze " + file + " for performance issues. Look for:{NL}")
        parts.append("1. Inefficient algorithms (wrong time complexity){NL}")
        parts.append("2. Unnecessary allocations{NL}")
        parts.append("3. Redundant computations{NL}")
        parts.append("4. Inefficient data structures{NL}")
        parts.append("5. Missing caching opportunities{NL}")
        parts.append("6. Unnecessary copying{NL}")
        parts.append("7. Blocking operations that could be async{NL}{NL}")
        parts.append("For each issue:{NL}")
        parts.append("- Identify the performance problem{NL}")
        parts.append("- Estimate the impact (complexity analysis){NL}")
        parts.append("- Suggest an optimized alternative{NL}")
        parts.append("- Explain the trade-offs")
        val content = parts.join("")

        Ok(PromptResult(
            description: "Analyze " + file + " for performance issues",
            messages: [make_user_message(content)]
        ))
