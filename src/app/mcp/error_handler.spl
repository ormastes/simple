# MCP Error Handler
# Pure Simple implementation of MCP error types and validation

export ErrorCategory, McpError, ValidationLimits, InputValidator
export mcp_error, default_validation_limits, strict_validation_limits, input_validator

# ============================================================================
# ERROR CATEGORY
# ============================================================================

enum ErrorCategory:
    ParseError
    InvalidRequest
    MethodNotFound
    InvalidParams
    InternalError
    Timeout
    TooManyRequests
    Validation
    Network

impl ErrorCategory:
    fn to_string() -> text:
        match self:
            case ErrorCategory.ParseError: "parse_error"
            case ErrorCategory.InvalidRequest: "invalid_request"
            case ErrorCategory.MethodNotFound: "method_not_found"
            case ErrorCategory.InvalidParams: "invalid_params"
            case ErrorCategory.InternalError: "internal_error"
            case ErrorCategory.Timeout: "timeout"
            case ErrorCategory.TooManyRequests: "too_many_requests"
            case ErrorCategory.Validation: "validation"
            case ErrorCategory.Network: "network"

    fn to_json_rpc_code() -> i64:
        match self:
            case ErrorCategory.ParseError: -32700
            case ErrorCategory.InvalidRequest: -32600
            case ErrorCategory.MethodNotFound: -32601
            case ErrorCategory.InvalidParams: -32602
            case ErrorCategory.InternalError: -32603
            case ErrorCategory.Timeout: -32000
            case ErrorCategory.TooManyRequests: -32001
            case ErrorCategory.Validation: -32002
            case ErrorCategory.Network: -32003

# ============================================================================
# MCP ERROR
# ============================================================================

class McpError:
    pub category: ErrorCategory
    pub message: text
    pub recoverable: bool
    pub details: text

# Helper function for creating McpError (works around static method limitation)
fn mcp_error(category: ErrorCategory, message: text) -> McpError:
    McpError(
        category: category,
        message: message,
        recoverable: true,
        details: ""
    )

impl McpError:
    fn with_details(details_text: text) -> McpError:
        McpError(
            category: self.category,
            message: self.message,
            recoverable: self.recoverable,
            details: details_text
        )

    fn as_unrecoverable() -> McpError:
        McpError(
            category: self.category,
            message: self.message,
            recoverable: false,
            details: self.details
        )

    fn to_json_rpc() -> text:
        val code = self.category.to_json_rpc_code()
        val cat_str = self.category.to_string()
        "{\"code\": {code}, \"message\": \"{self.message}\", \"data\": {\"category\": \"{cat_str}\", \"details\": \"{self.details}\"}}"

# ============================================================================
# VALIDATION LIMITS
# ============================================================================

class ValidationLimits:
    pub max_content_length: i64
    pub max_string_length: i64
    pub max_uri_length: i64
    pub max_tool_name_length: i64
    pub max_array_length: i64

# Helper functions for creating ValidationLimits (work around static method limitation)
fn default_validation_limits() -> ValidationLimits:
    ValidationLimits(
        max_content_length: 1048576,      # 1MB
        max_string_length: 65536,         # 64KB
        max_uri_length: 2048,             # 2KB
        max_tool_name_length: 256,        # 256 chars
        max_array_length: 1000            # 1000 items
    )

fn strict_validation_limits() -> ValidationLimits:
    ValidationLimits(
        max_content_length: 524288,       # 512KB
        max_string_length: 32768,         # 32KB
        max_uri_length: 1024,             # 1KB
        max_tool_name_length: 128,        # 128 chars
        max_array_length: 500             # 500 items
    )

# ============================================================================
# INPUT VALIDATOR
# ============================================================================

class InputValidator:
    pub limits: ValidationLimits

# Helper function for creating InputValidator (works around static method limitation)
fn input_validator() -> InputValidator:
    InputValidator(limits: default_validation_limits())

impl InputValidator:
    # Content length validation
    fn validate_content_length(length: i64) -> McpError?:
        if length < 0:
            return mcp_error(ErrorCategory.Validation, "Content length cannot be negative")
        if length > self.limits.max_content_length:
            return mcp_error(ErrorCategory.Validation, "Content length exceeds maximum of {self.limits.max_content_length}")
        nil

    # String validation
    fn validate_string(s: text) -> McpError?:
        val length = s.len()
        if length > self.limits.max_string_length:
            return mcp_error(ErrorCategory.Validation, "String length {length} exceeds maximum of {self.limits.max_string_length}")
        nil

    # URI validation
    fn validate_uri(uri: text) -> McpError?:
        if uri.len() == 0:
            return mcp_error(ErrorCategory.Validation, "URI cannot be empty")

        if uri.len() > self.limits.max_uri_length:
            return mcp_error(ErrorCategory.Validation, "URI length exceeds maximum of {self.limits.max_uri_length}")

        # Check for valid URI scheme (workaround: multi-line and/or not supported)
        val is_file = uri.starts_with("file://")
        val is_symbol = uri.starts_with("symbol://")
        val is_project = uri.starts_with("project://")
        val is_http = uri.starts_with("http://")
        val is_https = uri.starts_with("https://")
        val is_valid_scheme = is_file or is_symbol or is_project or is_http or is_https

        if not is_valid_scheme:
            return mcp_error(ErrorCategory.Validation, "Invalid URI scheme")

        nil

    # Tool name validation
    fn validate_tool_name(name: text) -> McpError?:
        if name.len() == 0:
            return mcp_error(ErrorCategory.Validation, "Tool name cannot be empty")

        if name.len() > self.limits.max_tool_name_length:
            return mcp_error(ErrorCategory.Validation, "Tool name length exceeds maximum of {self.limits.max_tool_name_length}")

        # Tool names can contain alphanumeric, slashes, hyphens, underscores
        var i = 0
        while i < name.len():
            val ch = name[i:i+1]
            val is_lower = ch >= "a" and ch <= "z"
            val is_upper = ch >= "A" and ch <= "Z"
            val is_digit = ch >= "0" and ch <= "9"
            val is_special = ch == "/" or ch == "-" or ch == "_"
            val is_valid = is_lower or is_upper or is_digit or is_special
            if not is_valid:
                return mcp_error(ErrorCategory.Validation, "Tool name contains invalid character: {ch}")
            i = i + 1

        nil

    # Array validation
    fn validate_array_length(length: i64) -> McpError?:
        if length < 0:
            return mcp_error(ErrorCategory.Validation, "Array length cannot be negative")
        if length > self.limits.max_array_length:
            return mcp_error(ErrorCategory.Validation, "Array length {length} exceeds maximum of {self.limits.max_array_length}")
        nil

    # Parameter validation
    fn validate_params(params: {text: text}) -> McpError?:
        # Validate all parameter values as strings
        for key in params.keys():
            val value = params[key] ?? ""
            val err = self.validate_string(value)
            match err:
                case nil: pass
                case _: return err
        nil
