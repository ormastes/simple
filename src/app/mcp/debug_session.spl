# MCP Debug Session Types
#
# Session state types, breakpoint tracking, and session management
# for the MCP debug tools subsystem.

# --- Session State Types ---

enum SessionState:
    Created
    Running
    Paused
    Stopped
    Terminated

enum TargetType:
    Interpreter
    Smf
    Native
    Remote

# Breakpoint within a session
class SessionBreakpoint:
    id: Int
    file: String
    line: Int
    condition: String

class SessionDataBreakpoint:
    id: Int
    name: String
    access_type: String
    condition: String
    last_value: String
    enabled: Bool

# Debug session
class DebugSession:
    id: String
    program: String
    target_type: String
    state: String
    breakpoints: [SessionBreakpoint]
    data_breakpoints: [SessionDataBreakpoint]
    next_bp_id: Int
    next_data_bp_id: Int

# Session manager - holds all debug sessions
class SessionManager:
    sessions: [DebugSession]
    next_session_id: Int

    fn parse_int_local(s: String) -> Int:
        if s == "":
            return -1
        var n = 0
        for ch in s:
            if ch < "0" or ch > "9":
                return -1
            n = n * 10 + (ch as int - "0" as int)
        n

    static fn empty() -> SessionManager:
        SessionManager(sessions: [], next_session_id: 1)

    me create_session(program: String, target_type: String) -> DebugSession:
        val sid = "session_" + self.next_session_id.to_string()
        self.next_session_id = self.next_session_id + 1
        val session = DebugSession(
            id: sid,
            program: program,
            target_type: target_type,
            state: "created",
            breakpoints: [],
            data_breakpoints: [],
            next_bp_id: 1,
            next_data_bp_id: 1
        )
        self.sessions = self.sessions + [session]
        session

    fn find_session(session_id: String) -> Int:
        # Returns index or -1 if not found
        var idx = 0
        for s in self.sessions:
            if s.id == session_id:
                return idx
            idx = idx + 1
        return -1

    me remove_session(session_id: String) -> Bool:
        var new_sessions = []
        var found = false
        for s in self.sessions:
            if s.id == session_id:
                found = true
            else:
                new_sessions = new_sessions + [s]
        self.sessions = new_sessions
        found

    fn list_sessions() -> [DebugSession]:
        self.sessions

    me add_breakpoint(session_id: String, file: String, line: Int, condition: String) -> String:
        val idx = self.find_session(session_id)
        if idx < 0:
            return ""
        var session = self.sessions[idx]
        val bp_id = session.next_bp_id
        session.next_bp_id = session.next_bp_id + 1
        val bp = SessionBreakpoint(id: bp_id, file: file, line: line, condition: condition)
        session.breakpoints = session.breakpoints + [bp]
        self.sessions[idx] = session
        bp_id.to_string()

    me remove_breakpoint(session_id: String, bp_id_str: String) -> Bool:
        val idx = self.find_session(session_id)
        if idx < 0:
            return false
        var session = self.sessions[idx]
        val bp_id = self.parse_int_local(bp_id_str)
        if bp_id < 0:
            return false
        var new_bps = []
        var found = false
        for bp in session.breakpoints:
            if bp.id == bp_id:
                found = true
            else:
                new_bps = new_bps + [bp]
        session.breakpoints = new_bps
        self.sessions[idx] = session
        found

    me set_state(session_id: String, new_state: String) -> Bool:
        val idx = self.find_session(session_id)
        if idx < 0:
            return false
        var session = self.sessions[idx]
        session.state = new_state
        self.sessions[idx] = session
        true

    me add_data_breakpoint(session_id: String, name: String, access_type: String, condition: String) -> String:
        val idx = self.find_session(session_id)
        if idx < 0:
            return ""
        var session = self.sessions[idx]
        val bp_id = session.next_data_bp_id
        session.next_data_bp_id = session.next_data_bp_id + 1
        val bp = SessionDataBreakpoint(
            id: bp_id,
            name: name,
            access_type: access_type,
            condition: condition,
            last_value: "",
            enabled: true
        )
        session.data_breakpoints = session.data_breakpoints + [bp]
        self.sessions[idx] = session
        bp_id.to_string()

    me remove_data_breakpoint(session_id: String, bp_id_str: String) -> Bool:
        val idx = self.find_session(session_id)
        if idx < 0:
            return false
        var session = self.sessions[idx]
        val bp_id = self.parse_int_local(bp_id_str)
        if bp_id < 0:
            return false
        var new_bps = []
        var found = false
        for bp in session.data_breakpoints:
            if bp.id == bp_id:
                found = true
            else:
                new_bps = new_bps + [bp]
        session.data_breakpoints = new_bps
        self.sessions[idx] = session
        found

# --- Exports ---

export SessionState, TargetType, SessionBreakpoint, SessionDataBreakpoint, DebugSession, SessionManager
