# Simple CLI - feature-gen command
# Generates feature documentation from feature_db.sdn

use std.cli.cli_util (get_cli_args, parse_csv_fields)
use app.io.mod (file_exists, file_read, file_write, dir_create)
use std.text.{NL}
use std.log.{error}

val FEATURE_DB_PATH = "doc/feature/feature_db.sdn"
val FEATURE_MD_PATH = "doc/feature/feature.md"
val PENDING_MD_PATH = "doc/feature/pending_feature.md"
val CATEGORY_DIR = "doc/feature/category"

fn print_help():
    print "Usage: simple feature-gen [options]"
    print ""
    print "Generate feature documentation from feature_db.sdn."
    print ""
    print "Outputs:"
    print "  doc/feature/feature.md           Category index"
    print "  doc/feature/pending_feature.md   Incomplete features"
    print "  doc/feature/category/*.md        Per-category pages"
    print ""
    print "Options:"
    print "  -h, --help   Show this help"

struct Feature:
    id: text
    category: text
    name: text
    description: text
    spec: text
    mode_interpreter: text
    mode_jit: text
    mode_smf_cranelift: text
    mode_smf_llvm: text
    platforms: text
    status: text
    valid: bool

fn load_features() -> [Feature]:
    if not file_exists(FEATURE_DB_PATH):
        error("feature_gen", "{FEATURE_DB_PATH} not found")
        return []

    val content = file_read(FEATURE_DB_PATH)
    val lines = content.split(NL)
    var features: [Feature] = []
    var in_table = false

    for line in lines:
        val trimmed = line.trim()
        if trimmed.starts_with("features |"):
            in_table = true
            continue
        if not in_table or trimmed == "" or trimmed.starts_with("#"):
            if in_table and trimmed != "" and not trimmed.starts_with("#") and not trimmed.starts_with(" "):
                in_table = false
            continue

        val fields = parse_csv_fields(trimmed)
        if fields.len() >= 12:
            features.push(Feature(
                id: fields[0],
                category: fields[1],
                name: fields[2],
                description: fields[3],
                spec: fields[4],
                mode_interpreter: fields[5],
                mode_jit: fields[6],
                mode_smf_cranelift: fields[7],
                mode_smf_llvm: fields[8],
                platforms: fields[9],
                status: fields[10],
                valid: fields[11] == "true"
            ))

    features

fn get_categories(features: [Feature]) -> [text]:
    var cats: [text] = []
    var seen: Dict<text, bool> = {}
    for f in features:
        if f.valid and not seen.contains_key(f.category):
            cats.push(f.category)
            seen[f.category] = true
    cats

fn count_status(features: [Feature], category: text, status: text) -> i64:
    var count = 0
    for f in features:
        if f.valid and f.category == category and f.status == status:
            count = count + 1
    count

fn count_all_valid(features: [Feature], category: text) -> i64:
    var count = 0
    for f in features:
        if f.valid and f.category == category:
            count = count + 1
    count

fn find_last_id(features: [Feature]) -> text:
    var last = ""
    for f in features:
        if f.valid:
            last = f.id
    if last == "": "0" else: last

fn sanitize_category(cat: text) -> text:
    cat.replace(" ", "_")

# --- Generate feature.md ---

fn generate_feature_md(features: [Feature]) -> text:
    val cats = get_categories(features)
    val last_id = find_last_id(features)

    var lines: [text] = []
    lines.push("# Feature Categories")
    lines.push("")
    lines.push("Last ID: `{last_id}`")
    lines.push("")
    lines.push("| Category | Features | Skips | Ignores | Fails |")
    lines.push("|----------|----------|-------|---------|-------|")

    for cat in cats:
        val total = count_all_valid(features, cat)
        val complete = count_status(features, cat, "complete")
        val skipped = count_status(features, cat, "skipped")
        val ignored = count_status(features, cat, "ignored")
        val failed = count_status(features, cat, "failed")
        val safe_cat = sanitize_category(cat)
        lines.push("| [{cat}](category/{safe_cat}.md) | {total} | {skipped} | {ignored} | {failed} |")

    lines.push("")
    lines.join(NL)

# --- Generate pending_feature.md ---

fn generate_pending_md(features: [Feature]) -> text:
    var pending: [Feature] = []
    for f in features:
        if f.valid and f.status != "complete":
            pending.push(f)

    val total_valid = {
        var c = 0
        for f in features:
            if f.valid:
                c = c + 1
        c
    }
    val complete_count = total_valid - pending.len()
    val pct = if total_valid > 0: (complete_count * 100) / total_valid else: 0

    var failed = 0
    var in_progress = 0
    var planned = 0
    var ignored = 0
    for f in pending:
        match f.status:
            case "failed": failed = failed + 1
            case "in_progress": in_progress = in_progress + 1
            case "planned": planned = planned + 1
            case "ignored": ignored = ignored + 1
            case _: pass

    var lines: [text] = []
    lines.push("# Pending Features")
    lines.push("")
    lines.push("**Generated:** 2026-02-03")
    lines.push("**Total Pending:** {pending.len()} features")
    lines.push("")
    lines.push("## Summary")
    lines.push("")
    lines.push("| Status | Count | Priority |")
    lines.push("|--------|-------|---------|")
    lines.push("| Failed | {failed} | \U0001F534 Critical |")
    lines.push("| In Progress | {in_progress} | \U0001F7E1 High |")
    lines.push("| Planned | {planned} | \U0001F7E2 Medium |")
    lines.push("| Ignored | {ignored} | \u26AA Low |")
    lines.push("")
    lines.push("**Completion:** {pct}.0% ({complete_count} complete / {total_valid} total)")
    lines.push("")
    lines.push("---")
    lines.push("")
    lines.push("## Progress by Category")
    lines.push("")
    lines.push("| Category | Total | Complete | Pending | % Complete |")
    lines.push("|----------|-------|----------|---------|------------|")

    val cats = get_categories(features)
    for cat in cats:
        val total = count_all_valid(features, cat)
        val comp = count_status(features, cat, "complete")
        val pend = total - comp
        if pend > 0:
            val cat_pct = if total > 0: (comp * 100) / total else: 0
            lines.push("| {cat} | {total} | {comp} | {pend} | {cat_pct}% |")

    lines.push("")
    lines.push("---")
    lines.push("")
    lines.push("## Implementation Priority")
    lines.push("")

    # Critical (failed)
    lines.push("### Critical (Do First)")
    lines.push("")
    for f in pending:
        if f.status == "failed":
            lines.push("- **{f.id}** {f.name} ({f.category}): {f.description}")
    lines.push("")

    # High (in_progress)
    lines.push("### High (Next Sprint)")
    for f in pending:
        if f.status == "in_progress":
            lines.push("- **{f.id}** {f.name} ({f.category}): {f.description}")
    lines.push("3. Planned features with dependencies")
    lines.push("")

    # Medium (planned)
    lines.push("### Medium (Backlog)")
    lines.push("")
    for f in pending:
        if f.status == "planned":
            lines.push("- **{f.id}** {f.name} ({f.category}): {f.description}")
    lines.push("")

    # Low (ignored)
    lines.push("### Low (Future)")
    lines.push("")
    for f in pending:
        if f.status == "ignored":
            lines.push("- **{f.id}** {f.name} ({f.category}): {f.description}")
    lines.push("")

    lines.join(NL)

# --- Generate category/*.md ---

fn generate_category_md(features: [Feature], category: text) -> text:
    var lines: [text] = []
    lines.push("# {category}")
    lines.push("")
    lines.push("## Features")
    lines.push("")
    lines.push("| ID | Feature | Description | Modes | Platforms | Spec |")
    lines.push("|----|---------|-------------|-------|-----------|------|")

    for f in features:
        if f.valid and f.category == category:
            val modes = "interpreter:{f.mode_interpreter}, jit:{f.mode_jit}, smf_cranelift:{f.mode_smf_cranelift}, smf_llvm:{f.mode_smf_llvm}"
            val plat = if f.platforms == "": "-" else: f.platforms
            val spec_link = if f.spec != "": "[{f.spec}](../../{f.spec}#feature-{f.id})" else: "-"
            lines.push("| <a id=\"feature-{f.id}\"></a>{f.id} | {f.name} | {f.description} | {modes} | {plat} | {spec_link} |")

    lines.push("")
    lines.join(NL)

fn main() -> i64:
    val args = get_cli_args()

    for arg in args:
        if arg == "-h" or arg == "--help":
            print_help()
            return 0

    val features = load_features()
    if features.len() == 0:
        print "No features found in {FEATURE_DB_PATH}"
        return 1

    # Generate feature.md
    val feature_md = generate_feature_md(features)
    file_write(FEATURE_MD_PATH, feature_md)
    print "Generated {FEATURE_MD_PATH}"

    # Generate pending_feature.md
    val pending_md = generate_pending_md(features)
    file_write(PENDING_MD_PATH, pending_md)
    print "Generated {PENDING_MD_PATH}"

    # Generate category pages
    dir_create(CATEGORY_DIR, true)
    val cats = get_categories(features)
    for cat in cats:
        val safe_cat = sanitize_category(cat)
        val path = "{CATEGORY_DIR}/{safe_cat}.md"
        val cat_md = generate_category_md(features, cat)
        file_write(path, cat_md)
        print "Generated {path}"

    print "Done. Generated docs for {features.len()} features in {cats.len()} categories."
    0
