# FFI Wrapper Build Script (Simple)
#
# Builds the simple-ffi-wrapper library using cargo.
#
# Usage:
#   simple build.spl [--release]

use std.db_atomic.{atomic_write, DbConfig}

extern fn rt_env_cwd() -> text
extern fn rt_env_get(name: text) -> text
extern fn rt_file_exists(path: text) -> bool
extern fn rt_file_read_text(path: text) -> text
extern fn rt_file_copy(src: text, dst: text) -> bool
extern fn rt_dir_create(path: text, recursive: bool) -> bool
extern fn rt_process_run(cmd: text, args: [text]) -> text

fn main():
    val args = get_args()
    val release = args.contains("--release")
    val profile = if release: "release" else: "debug"

    # TODO: Replace direct FFI call with wrapper (env_cwd) from app.io or compiler.ffi
    val script_dir = rt_env_cwd()
    val build_dir = script_dir + "/build"

    print "Building simple-ffi-wrapper ({profile})..."
    print ""

    # Create build directory
    # TODO: Replace direct FFI call with wrapper (dir_create) from app.io or compiler.ffi
    rt_dir_create(build_dir, true)

    # Create Cargo.toml
    val cargo_toml = "[package]
name = \"simple-ffi-wrapper\"
version = \"0.1.0\"
edition = \"2021\"

[lib]
crate-type = [\"cdylib\", \"rlib\"]

[dependencies]
bdwgc-alloc = \"0.6\"
glob = \"0.3\"
hostname = \"0.4\"
libc = \"0.2\"
"
    # Atomically write Cargo.toml (build config - important for reproducibility)
    val write_result = atomic_write(build_dir + "/Cargo.toml", cargo_toml, DbConfig.defaults())
    if write_result.err.?:
        eprintln("[ERROR] Failed to write Cargo.toml: {write_result.unwrap_err()}")
        return

    # Create src directory
    # TODO: Replace direct FFI call with wrapper (dir_create) from app.io or compiler.ffi
    rt_dir_create(build_dir + "/src", true)

    # Copy source files (rename .txt to .rs)
    copy_source(script_dir, build_dir, "lib.txt", "lib.rs")
    copy_source(script_dir, build_dir, "gc.txt", "gc.rs")
    copy_source(script_dir, build_dir, "env.txt", "env.rs")
    copy_source(script_dir, build_dir, "file_io.txt", "file_io.rs")
    copy_source(script_dir, build_dir, "runtime_value.txt", "runtime_value.rs")
    copy_source(script_dir, build_dir, "bootstrap_ffi.txt", "bootstrap_ffi.rs")

    # Build with cargo
    val cargo_args = if release:
        ["build", "--release", "--manifest-path", build_dir + "/Cargo.toml"]
    else:
        ["build", "--manifest-path", build_dir + "/Cargo.toml"]

    print "Running cargo build..."
    # TODO: Replace direct FFI call with wrapper (process_run) from app.io or compiler.ffi
    val result = rt_process_run("cargo", cargo_args)
    print result

    # Copy output to lib/
    val lib_dir = if release:
        build_dir + "/target/release"
    else:
        build_dir + "/target/debug"

    # TODO: Replace direct FFI call with wrapper (dir_create) from app.io or compiler.ffi
    rt_dir_create(script_dir + "/lib", true)

    val so_file = lib_dir + "/libsimple_ffi_wrapper.so"
    # TODO: Replace direct FFI call with wrapper (file_exists) from app.io or compiler.ffi
    if rt_file_exists(so_file):
        # TODO: Replace direct FFI call with wrapper (file_copy) from app.io or compiler.ffi
        rt_file_copy(so_file, script_dir + "/lib/libsimple_ffi_wrapper.so")
        print "Built: lib/libsimple_ffi_wrapper.so"

    val dylib_file = lib_dir + "/libsimple_ffi_wrapper.dylib"
    # TODO: Replace direct FFI call with wrapper (file_exists) from app.io or compiler.ffi
    if rt_file_exists(dylib_file):
        # TODO: Replace direct FFI call with wrapper (file_copy) from app.io or compiler.ffi
        rt_file_copy(dylib_file, script_dir + "/lib/libsimple_ffi_wrapper.dylib")
        print "Built: lib/libsimple_ffi_wrapper.dylib"

    val a_file = lib_dir + "/libsimple_ffi_wrapper.a"
    # TODO: Replace direct FFI call with wrapper (file_exists) from app.io or compiler.ffi
    if rt_file_exists(a_file):
        # TODO: Replace direct FFI call with wrapper (file_copy) from app.io or compiler.ffi
        rt_file_copy(a_file, script_dir + "/lib/libsimple_ffi_wrapper.a")
        print "Built: lib/libsimple_ffi_wrapper.a"

    print ""
    print "Build complete!"
    print "Library files are in: {script_dir}/lib/"

fn copy_source(script_dir: text, build_dir: text, src_name: text, dst_name: text):
    val src_path = script_dir + "/src/" + src_name
    val dst_path = build_dir + "/src/" + dst_name
    # TODO: Replace direct FFI call with wrapper (file_exists) from app.io or compiler.ffi
    if rt_file_exists(src_path):
        # TODO: Replace direct FFI call with wrapper (file_copy) from app.io or compiler.ffi
        rt_file_copy(src_path, dst_path)
        print "  Copied {dst_name}"
    else:
        print "  WARNING: {src_name} not found"

fn get_args() -> [text]:
    # TODO: Get actual CLI args
    []
