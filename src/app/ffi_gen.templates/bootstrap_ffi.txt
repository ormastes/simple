//! Bootstrap FFI - All FFI functions in one file
//!
//! This is the embedded bootstrap FFI source that provides all extern functions
//! needed by the Simple runtime. Includes interpreter and compiler support.

use std::ffi::{CStr, CString};
use std::os::raw::c_char;
use std::process::{Command, Stdio};
use std::time::{SystemTime, UNIX_EPOCH};
use std::sync::atomic::{AtomicBool, AtomicI64, Ordering};
use std::path::Path;
use std::fs;
use std::env;
use std::collections::HashMap;

// libc for mmap syscalls
use libc::{c_int, c_void, size_t, mmap, munmap, mprotect, madvise, msync, mlock, munlock, open, close, sysconf};

// Cranelift imports for compiler
use cranelift_codegen::ir::{AbiParam, InstBuilder, UserFuncName};
use cranelift_codegen::ir::types::I64;
use cranelift_codegen::settings::{self, Configurable};
use cranelift_module::{FuncId, Linkage, Module};
use cranelift_object::{ObjectBuilder, ObjectModule};
use cranelift_frontend::{FunctionBuilder, FunctionBuilderContext};

// =============================================================================
// Process Execution
// =============================================================================

#[no_mangle]
pub unsafe extern "C" fn rt_process_run(
    cmd_ptr: *const c_char, cmd_len: usize, _args_ptr: *const c_char,
) -> *mut c_char {
    if cmd_ptr.is_null() { return std::ptr::null_mut(); }
    let cmd = String::from_utf8_lossy(std::slice::from_raw_parts(cmd_ptr as *const u8, cmd_len));
    match Command::new(cmd.as_ref()).stdout(Stdio::piped()).stderr(Stdio::piped()).output() {
        Ok(o) => CString::new(String::from_utf8_lossy(&o.stdout).to_string()).ok().map(|c| c.into_raw()).unwrap_or(std::ptr::null_mut()),
        Err(_) => std::ptr::null_mut(),
    }
}

#[no_mangle]
pub unsafe extern "C" fn rt_process_run_timeout(
    cmd_ptr: *const c_char, cmd_len: usize, args_ptr: *const c_char, _timeout_ms: i64,
) -> *mut c_char { rt_process_run(cmd_ptr, cmd_len, args_ptr) }

#[no_mangle]
pub unsafe extern "C" fn rt_process_run_with_limits(
    cmd_ptr: *const c_char, cmd_len: usize, args_ptr: *const c_char,
    _timeout_ms: i64, _memory_bytes: i64, _cpu_seconds: i64, _max_fds: i64, _max_procs: i64,
) -> *mut c_char { rt_process_run(cmd_ptr, cmd_len, args_ptr) }

#[no_mangle]
pub unsafe extern "C" fn rt_process_output(
    cmd_ptr: *const c_char, cmd_len: usize, args_ptr: *const c_char,
) -> *mut c_char { rt_process_run(cmd_ptr, cmd_len, args_ptr) }

#[no_mangle]
pub unsafe extern "C" fn rt_shell(cmd_ptr: *const c_char, cmd_len: usize) -> *mut c_char {
    if cmd_ptr.is_null() { return std::ptr::null_mut(); }
    let cmd = String::from_utf8_lossy(std::slice::from_raw_parts(cmd_ptr as *const u8, cmd_len));
    match Command::new("sh").arg("-c").arg(cmd.as_ref()).stdout(Stdio::piped()).stderr(Stdio::piped()).output() {
        Ok(o) => CString::new(String::from_utf8_lossy(&o.stdout).to_string()).ok().map(|c| c.into_raw()).unwrap_or(std::ptr::null_mut()),
        Err(_) => std::ptr::null_mut(),
    }
}

#[no_mangle]
pub unsafe extern "C" fn rt_shell_exec(cmd_ptr: *const c_char, cmd_len: usize) -> i64 {
    if cmd_ptr.is_null() { return -1; }
    let cmd = String::from_utf8_lossy(std::slice::from_raw_parts(cmd_ptr as *const u8, cmd_len));
    Command::new("sh").arg("-c").arg(cmd.as_ref()).status().map(|s| s.code().unwrap_or(-1) as i64).unwrap_or(-1)
}

#[no_mangle]
pub unsafe extern "C" fn rt_eprintln(msg_ptr: *const c_char, msg_len: usize) {
    if !msg_ptr.is_null() {
        let msg = String::from_utf8_lossy(std::slice::from_raw_parts(msg_ptr as *const u8, msg_len));
        eprintln!("{}", msg);
    }
}

// =============================================================================
// Time Operations
// =============================================================================

#[no_mangle] pub extern "C" fn rt_time_now_unix_micros() -> i64 {
    SystemTime::now().duration_since(UNIX_EPOCH).map(|d| d.as_micros() as i64).unwrap_or(0)
}
#[no_mangle] pub extern "C" fn _current_time_unix() -> i64 {
    SystemTime::now().duration_since(UNIX_EPOCH).map(|d| d.as_secs() as i64).unwrap_or(0)
}
#[no_mangle] pub extern "C" fn rt_current_time_ms() -> i64 {
    SystemTime::now().duration_since(UNIX_EPOCH).map(|d| d.as_millis() as i64).unwrap_or(0)
}

fn micros_to_ymd_hms(micros: i64) -> (i32,i32,i32,i32,i32,i32) {
    let secs = micros / 1_000_000; let days = secs / 86400; let tod = secs % 86400;
    let h = (tod/3600) as i32; let m = ((tod%3600)/60) as i32; let s = (tod%60) as i32;
    let mut y = 1970i32; let mut rd = days as i32;
    loop { let diy = if (y%4==0&&y%100!=0)||(y%400==0) {366} else {365}; if rd < diy { break; } rd -= diy; y += 1; }
    let mut mo = 1i32;
    loop { let dim = match mo { 1|3|5|7|8|10|12=>31, 4|6|9|11=>30, 2=>if (y%4==0&&y%100!=0)||(y%400==0) {29} else {28}, _=>30 }; if rd < dim { break; } rd -= dim; mo += 1; }
    (y, mo, rd+1, h, m, s)
}
#[no_mangle] pub extern "C" fn rt_timestamp_get_year(micros: i64) -> i32 { micros_to_ymd_hms(micros).0 }
#[no_mangle] pub extern "C" fn rt_timestamp_get_month(micros: i64) -> i32 { micros_to_ymd_hms(micros).1 }
#[no_mangle] pub extern "C" fn rt_timestamp_get_day(micros: i64) -> i32 { micros_to_ymd_hms(micros).2 }
#[no_mangle] pub extern "C" fn rt_timestamp_get_hour(micros: i64) -> i32 { micros_to_ymd_hms(micros).3 }
#[no_mangle] pub extern "C" fn rt_timestamp_get_minute(micros: i64) -> i32 { micros_to_ymd_hms(micros).4 }
#[no_mangle] pub extern "C" fn rt_timestamp_get_second(micros: i64) -> i32 { micros_to_ymd_hms(micros).5 }

// =============================================================================
// System Operations
// =============================================================================

#[no_mangle] pub extern "C" fn rt_getpid() -> i64 { std::process::id() as i64 }
#[no_mangle] pub extern "C" fn rt_hostname() -> *mut c_char {
    hostname::get().ok().and_then(|n| CString::new(n.to_string_lossy().to_string()).ok()).map(|c| c.into_raw()).unwrap_or_else(|| CString::new("unknown").unwrap().into_raw())
}
#[no_mangle] pub extern "C" fn rt_system_cpu_count() -> i64 { std::thread::available_parallelism().map(|n| n.get() as i64).unwrap_or(1) }

#[no_mangle]
pub unsafe extern "C" fn rt_path_basename(path_ptr: *const c_char, path_len: usize) -> *mut c_char {
    if path_ptr.is_null() { return std::ptr::null_mut(); }
    let p = String::from_utf8_lossy(std::slice::from_raw_parts(path_ptr as *const u8, path_len));
    Path::new(p.as_ref()).file_name().and_then(|s| CString::new(s.to_string_lossy().to_string()).ok()).map(|c| c.into_raw()).unwrap_or(std::ptr::null_mut())
}

#[no_mangle] pub extern "C" fn sys_get_args() -> *mut c_char {
    CString::new(env::args().collect::<Vec<_>>().join("\n")).ok().map(|c| c.into_raw()).unwrap_or(std::ptr::null_mut())
}
#[no_mangle] pub extern "C" fn rt_cli_get_args() -> *mut c_char { sys_get_args() }
#[no_mangle] pub extern "C" fn sys_exit(code: i64) { std::process::exit(code as i32); }
#[no_mangle] pub extern "C" fn rt_cli_exit(code: i64) { sys_exit(code); }

#[no_mangle]
pub unsafe extern "C" fn rt_cli_file_exists(path_ptr: *const c_char, path_len: usize) -> bool {
    if path_ptr.is_null() { return false; }
    let p = String::from_utf8_lossy(std::slice::from_raw_parts(path_ptr as *const u8, path_len));
    Path::new(p.as_ref()).exists()
}

#[no_mangle]
pub unsafe extern "C" fn rt_cli_read_file(path_ptr: *const c_char, path_len: usize) -> *mut c_char {
    if path_ptr.is_null() { return std::ptr::null_mut(); }
    let p = String::from_utf8_lossy(std::slice::from_raw_parts(path_ptr as *const u8, path_len));
    fs::read_to_string(p.as_ref()).ok().and_then(|c| CString::new(c).ok()).map(|c| c.into_raw()).unwrap_or(std::ptr::null_mut())
}

// =============================================================================
// Directory Operations
// =============================================================================

#[no_mangle]
pub unsafe extern "C" fn rt_dir_list(path_ptr: *const c_char, path_len: usize) -> *mut c_char {
    if path_ptr.is_null() { return std::ptr::null_mut(); }
    let p = String::from_utf8_lossy(std::slice::from_raw_parts(path_ptr as *const u8, path_len));
    fs::read_dir(p.as_ref()).ok().map(|e| e.filter_map(|e| e.ok()).map(|e| e.file_name().to_string_lossy().to_string()).collect::<Vec<_>>().join("\n"))
        .and_then(|s| CString::new(s).ok()).map(|c| c.into_raw()).unwrap_or(std::ptr::null_mut())
}

#[no_mangle]
pub unsafe extern "C" fn rt_dir_walk(path_ptr: *const c_char, path_len: usize) -> *mut c_char {
    if path_ptr.is_null() { return std::ptr::null_mut(); }
    let p = String::from_utf8_lossy(std::slice::from_raw_parts(path_ptr as *const u8, path_len));
    fn walk(dir: &Path, r: &mut Vec<String>) {
        if let Ok(e) = fs::read_dir(dir) { for e in e.filter_map(|e| e.ok()) { let p = e.path(); r.push(p.to_string_lossy().to_string()); if p.is_dir() { walk(&p, r); } } }
    }
    let mut r = Vec::new(); walk(Path::new(p.as_ref()), &mut r);
    CString::new(r.join("\n")).ok().map(|c| c.into_raw()).unwrap_or(std::ptr::null_mut())
}

#[no_mangle]
pub unsafe extern "C" fn rt_dir_remove(path_ptr: *const c_char, path_len: usize) -> bool {
    if path_ptr.is_null() { return false; }
    let p = String::from_utf8_lossy(std::slice::from_raw_parts(path_ptr as *const u8, path_len));
    fs::remove_dir(p.as_ref()).is_ok()
}

#[no_mangle]
pub unsafe extern "C" fn rt_package_remove_dir_all(path_ptr: *const c_char, path_len: usize) -> bool {
    if path_ptr.is_null() { return false; }
    let p = String::from_utf8_lossy(std::slice::from_raw_parts(path_ptr as *const u8, path_len));
    fs::remove_dir_all(p.as_ref()).is_ok()
}

#[no_mangle]
pub unsafe extern "C" fn rt_package_is_dir(path_ptr: *const c_char, path_len: usize) -> bool {
    if path_ptr.is_null() { return false; }
    let p = String::from_utf8_lossy(std::slice::from_raw_parts(path_ptr as *const u8, path_len));
    Path::new(p.as_ref()).is_dir()
}

#[no_mangle]
pub unsafe extern "C" fn rt_package_file_size(path_ptr: *const c_char, path_len: usize) -> i64 {
    if path_ptr.is_null() { return -1; }
    let p = String::from_utf8_lossy(std::slice::from_raw_parts(path_ptr as *const u8, path_len));
    fs::metadata(p.as_ref()).map(|m| m.len() as i64).unwrap_or(-1)
}

// =============================================================================
// File Operations
// =============================================================================

#[no_mangle]
pub unsafe extern "C" fn rt_file_exists(path_ptr: *const c_char, path_len: usize) -> bool {
    if path_ptr.is_null() { return false; }
    let p = String::from_utf8_lossy(std::slice::from_raw_parts(path_ptr as *const u8, path_len));
    Path::new(p.as_ref()).exists()
}

#[no_mangle]
pub unsafe extern "C" fn rt_file_read_text(path_ptr: *const c_char, path_len: usize) -> *mut c_char {
    if path_ptr.is_null() { return std::ptr::null_mut(); }
    let p = String::from_utf8_lossy(std::slice::from_raw_parts(path_ptr as *const u8, path_len));
    fs::read_to_string(p.as_ref()).ok().and_then(|c| CString::new(c).ok()).map(|c| c.into_raw()).unwrap_or(std::ptr::null_mut())
}

#[no_mangle]
pub unsafe extern "C" fn rt_file_write_text(path_ptr: *const c_char, path_len: usize, content_ptr: *const c_char, content_len: usize) -> bool {
    if path_ptr.is_null() || content_ptr.is_null() { return false; }
    let p = String::from_utf8_lossy(std::slice::from_raw_parts(path_ptr as *const u8, path_len));
    let c = String::from_utf8_lossy(std::slice::from_raw_parts(content_ptr as *const u8, content_len));
    fs::write(p.as_ref(), c.as_ref()).is_ok()
}

#[no_mangle]
pub unsafe extern "C" fn rt_file_copy(src_ptr: *const c_char, src_len: usize, dst_ptr: *const c_char, dst_len: usize) -> bool {
    if src_ptr.is_null() || dst_ptr.is_null() { return false; }
    let s = String::from_utf8_lossy(std::slice::from_raw_parts(src_ptr as *const u8, src_len));
    let d = String::from_utf8_lossy(std::slice::from_raw_parts(dst_ptr as *const u8, dst_len));
    fs::copy(s.as_ref(), d.as_ref()).is_ok()
}

#[no_mangle]
pub unsafe extern "C" fn rt_file_delete(path_ptr: *const c_char, path_len: usize) -> bool {
    if path_ptr.is_null() { return false; }
    let p = String::from_utf8_lossy(std::slice::from_raw_parts(path_ptr as *const u8, path_len));
    fs::remove_file(p.as_ref()).is_ok()
}

#[no_mangle]
pub unsafe extern "C" fn rt_file_append_text(path_ptr: *const c_char, path_len: usize, content_ptr: *const c_char, content_len: usize) -> bool {
    if path_ptr.is_null() || content_ptr.is_null() { return false; }
    let p = String::from_utf8_lossy(std::slice::from_raw_parts(path_ptr as *const u8, path_len));
    let c = String::from_utf8_lossy(std::slice::from_raw_parts(content_ptr as *const u8, content_len));
    use std::io::Write;
    std::fs::OpenOptions::new().append(true).create(true).open(p.as_ref()).and_then(|mut f| f.write_all(c.as_bytes())).is_ok()
}

#[no_mangle]
pub unsafe extern "C" fn rt_file_remove(path_ptr: *const c_char, path_len: usize) -> bool {
    rt_file_delete(path_ptr, path_len)
}

#[no_mangle]
pub unsafe extern "C" fn rt_file_modified_time(path_ptr: *const c_char, path_len: usize) -> i64 {
    if path_ptr.is_null() { return 0; }
    let p = String::from_utf8_lossy(std::slice::from_raw_parts(path_ptr as *const u8, path_len));
    fs::metadata(p.as_ref()).and_then(|m| m.modified()).ok()
        .and_then(|t| t.duration_since(std::time::UNIX_EPOCH).ok())
        .map(|d| d.as_micros() as i64).unwrap_or(0)
}

#[no_mangle]
pub unsafe extern "C" fn rt_file_atomic_write(path_ptr: *const c_char, path_len: usize, content_ptr: *const c_char, content_len: usize) -> bool {
    if path_ptr.is_null() || content_ptr.is_null() { return false; }
    let p = String::from_utf8_lossy(std::slice::from_raw_parts(path_ptr as *const u8, path_len));
    let c = String::from_utf8_lossy(std::slice::from_raw_parts(content_ptr as *const u8, content_len));
    let tmp = format!("{}.tmp", p);
    if fs::write(&tmp, c.as_ref()).is_ok() { fs::rename(&tmp, p.as_ref()).is_ok() } else { false }
}

#[no_mangle]
pub unsafe extern "C" fn rt_file_read_lines(path_ptr: *const c_char, path_len: usize) -> *mut c_char {
    rt_file_read_text(path_ptr, path_len)
}

#[no_mangle]
pub unsafe extern "C" fn rt_file_hash_sha256(path_ptr: *const c_char, path_len: usize) -> *mut c_char {
    if path_ptr.is_null() { return std::ptr::null_mut(); }
    let p = String::from_utf8_lossy(std::slice::from_raw_parts(path_ptr as *const u8, path_len));
    // Simple hash placeholder - returns file size as hex
    fs::metadata(p.as_ref()).ok().map(|m| format!("{:016x}", m.len()))
        .and_then(|s| CString::new(s).ok()).map(|c| c.into_raw()).unwrap_or(std::ptr::null_mut())
}

// Alias for rt_file_hash_sha256
#[no_mangle]
pub unsafe extern "C" fn rt_file_hash_sha(path_ptr: *const c_char, path_len: usize) -> *mut c_char {
    rt_file_hash_sha256(path_ptr, path_len)
}

#[no_mangle]
pub unsafe extern "C" fn rt_file_size(path_ptr: *const c_char, path_len: usize) -> i64 {
    if path_ptr.is_null() { return -1; }
    let p = String::from_utf8_lossy(std::slice::from_raw_parts(path_ptr as *const u8, path_len));
    fs::metadata(p.as_ref()).map(|m| m.len() as i64).unwrap_or(-1)
}

// File locking stubs (would need fs2 crate for real implementation)
#[no_mangle]
pub unsafe extern "C" fn rt_file_lock(path_ptr: *const c_char, path_len: usize) -> bool {
    if path_ptr.is_null() { return false; }
    let p = String::from_utf8_lossy(std::slice::from_raw_parts(path_ptr as *const u8, path_len));
    // Stub: just check file exists
    Path::new(p.as_ref()).exists()
}

#[no_mangle]
pub unsafe extern "C" fn rt_file_unlock(path_ptr: *const c_char, path_len: usize) -> bool {
    if path_ptr.is_null() { return false; }
    let p = String::from_utf8_lossy(std::slice::from_raw_parts(path_ptr as *const u8, path_len));
    // Stub: just check file exists
    Path::new(p.as_ref()).exists()
}

// Aliases for compatibility
#[no_mangle]
pub unsafe extern "C" fn rt_read_file(path_ptr: *const c_char, path_len: usize) -> *mut c_char {
    rt_file_read_text(path_ptr, path_len)
}

#[no_mangle]
pub unsafe extern "C" fn rt_write_file(path_ptr: *const c_char, path_len: usize, content_ptr: *const c_char, content_len: usize) -> bool {
    rt_file_write_text(path_ptr, path_len, content_ptr, content_len)
}

// =============================================================================
// Memory Mapping (mmap) - Minimal Syscall Wrappers
// =============================================================================

/// Map memory (libc mmap) - 1-line wrapper
#[no_mangle]
pub extern "C" fn rt_mmap(
    addr: i64,
    length: i64,
    prot: c_int,
    flags: c_int,
    fd: c_int,
    offset: i64,
) -> i64 {
    unsafe {
        mmap(addr as *mut c_void, length as size_t, prot, flags, fd, offset) as i64
    }
}

/// Unmap memory (libc munmap) - 1-line wrapper
#[no_mangle]
pub extern "C" fn rt_munmap(addr: i64, length: i64) -> c_int {
    unsafe { munmap(addr as *mut c_void, length as size_t) }
}

/// Change protection (libc mprotect) - 1-line wrapper
#[no_mangle]
pub extern "C" fn rt_mprotect(addr: i64, length: i64, prot: c_int) -> c_int {
    unsafe { mprotect(addr as *mut c_void, length as size_t, prot) }
}

/// Memory advice (libc madvise) - 1-line wrapper
#[no_mangle]
pub extern "C" fn rt_madvise(addr: i64, length: i64, advice: c_int) -> c_int {
    unsafe { madvise(addr as *mut c_void, length as size_t, advice) }
}

/// Sync to disk (libc msync) - 1-line wrapper
#[no_mangle]
pub extern "C" fn rt_msync(addr: i64, length: i64, flags: c_int) -> c_int {
    unsafe { msync(addr as *mut c_void, length as size_t, flags) }
}

/// Lock in RAM (libc mlock) - 1-line wrapper
#[no_mangle]
pub extern "C" fn rt_mlock(addr: i64, length: i64) -> c_int {
    unsafe { mlock(addr as *const c_void, length as size_t) }
}

/// Unlock memory (libc munlock) - 1-line wrapper
#[no_mangle]
pub extern "C" fn rt_munlock(addr: i64, length: i64) -> c_int {
    unsafe { munlock(addr as *const c_void, length as size_t) }
}

/// Get page size (libc sysconf) - 1-line wrapper
#[no_mangle]
pub extern "C" fn rt_page_size() -> i64 {
    unsafe { sysconf(libc::_SC_PAGESIZE) }
}

/// Open file (libc open) - direct wrapper
#[no_mangle]
pub unsafe extern "C" fn rt_open_fd(path: *const i8, flags: c_int, mode: c_int) -> c_int {
    open(path, flags, mode as libc::mode_t)
}

/// Close file (libc close) - 1-line wrapper
#[no_mangle]
pub extern "C" fn rt_close_fd(fd: c_int) -> c_int {
    unsafe { close(fd) }
}

// =============================================================================
// High-Level mmap Functions (using raw syscalls above)
// =============================================================================

/// Map file into memory - opens, mmaps, closes fd
#[no_mangle]
pub unsafe extern "C" fn rt_mmap_file(
    path_ptr: *const c_char,
    path_len: usize,
    prot: c_int,
    flags: c_int,
    offset: i64,
    length: i64,
) -> (i64, i64) {
    if path_ptr.is_null() {
        return (0, 0);
    }

    // Convert path to CString
    let path_slice = std::slice::from_raw_parts(path_ptr as *const u8, path_len);
    let path_cstr = match CString::new(path_slice) {
        Ok(s) => s,
        Err(_) => return (0, 0),
    };

    // Open file
    let fd = open(path_cstr.as_ptr() as *const i8, libc::O_RDONLY, 0);
    if fd < 0 {
        return (0, 0);
    }

    // Get file size if length == 0
    let actual_length = if length == 0 {
        let stat_result = libc::fstat(fd, &mut std::mem::zeroed());
        if stat_result != 0 {
            close(fd);
            return (0, 0);
        }
        let mut stat: libc::stat = std::mem::zeroed();
        libc::fstat(fd, &mut stat);
        stat.st_size
    } else {
        length
    };

    // Call mmap
    let addr = mmap(
        std::ptr::null_mut(),
        actual_length as size_t,
        prot,
        flags,
        fd,
        offset,
    ) as i64;

    // Close fd (mmap keeps reference)
    close(fd);

    // Check for error
    if addr == -1 {
        return (0, 0);
    }

    (addr, actual_length)
}

/// Read bytes from mapped memory
#[no_mangle]
pub unsafe extern "C" fn rt_mmap_read_bytes(
    address: i64,
    offset: i64,
    length: i64,
) -> *mut u8 {
    if address == 0 || length == 0 {
        return std::ptr::null_mut();
    }

    let src = (address + offset) as *const u8;
    let mut result = Vec::with_capacity(length as usize);
    std::ptr::copy_nonoverlapping(src, result.as_mut_ptr(), length as usize);
    result.set_len(length as usize);

    // Convert to heap-allocated slice
    let boxed = result.into_boxed_slice();
    Box::into_raw(boxed) as *mut u8
}

/// Read string from mapped memory
#[no_mangle]
pub unsafe extern "C" fn rt_mmap_read_string(
    address: i64,
    offset: i64,
    max_length: i64,
) -> *mut c_char {
    if address == 0 {
        return std::ptr::null_mut();
    }

    let ptr = (address + offset) as *const u8;
    let max_len = if max_length == 0 { 4096 } else { max_length as usize };

    // Find string length (until null terminator or max_length)
    let mut len = 0;
    while len < max_len {
        if *ptr.add(len) == 0 {
            break;
        }
        len += 1;
    }

    // Create slice and convert to string
    let slice = std::slice::from_raw_parts(ptr, len);
    match String::from_utf8_lossy(slice).into_owned() {
        s => CString::new(s).ok().map(|c| c.into_raw()).unwrap_or(std::ptr::null_mut()),
    }
}

/// Get file size for mmap
#[no_mangle]
pub unsafe extern "C" fn rt_file_size_for_mmap(path_ptr: *const c_char, path_len: usize) -> i64 {
    if path_ptr.is_null() {
        return -1;
    }

    let path_slice = std::slice::from_raw_parts(path_ptr as *const u8, path_len);
    let path_cstr = match CString::new(path_slice) {
        Ok(s) => s,
        Err(_) => return -1,
    };

    let mut stat: libc::stat = std::mem::zeroed();
    if libc::stat(path_cstr.as_ptr() as *const i8, &mut stat) == 0 {
        stat.st_size
    } else {
        -1
    }
}

/// Get page size (wrapper for rt_page_size)
#[no_mangle]
pub extern "C" fn rt_get_page_size() -> i64 {
    rt_page_size()
}

/// Memory sync (wrapper)
#[no_mangle]
pub extern "C" fn rt_msync_wrapper(address: i64, size: i64, is_async: bool) -> bool {
    let flags = if is_async { libc::MS_ASYNC } else { libc::MS_SYNC };
    rt_msync(address, size, flags) == 0
}

// =============================================================================
// Directory Creation
// =============================================================================

#[no_mangle]
pub unsafe extern "C" fn rt_dir_create(path_ptr: *const c_char, path_len: usize, recursive: bool) -> bool {
    if path_ptr.is_null() { return false; }
    let p = String::from_utf8_lossy(std::slice::from_raw_parts(path_ptr as *const u8, path_len));
    if recursive { fs::create_dir_all(p.as_ref()).is_ok() } else { fs::create_dir(p.as_ref()).is_ok() }
}

#[no_mangle]
pub unsafe extern "C" fn rt_dir_create_all(path_ptr: *const c_char, path_len: usize) -> bool {
    if path_ptr.is_null() { return false; }
    let p = String::from_utf8_lossy(std::slice::from_raw_parts(path_ptr as *const u8, path_len));
    fs::create_dir_all(p.as_ref()).is_ok()
}

// =============================================================================
// Environment
// =============================================================================

#[no_mangle]
pub extern "C" fn rt_env_cwd() -> *mut c_char {
    env::current_dir().ok().and_then(|p| CString::new(p.to_string_lossy().to_string()).ok()).map(|c| c.into_raw()).unwrap_or(std::ptr::null_mut())
}

#[no_mangle]
pub extern "C" fn rt_env_home() -> *mut c_char {
    env::var("HOME").or_else(|_| env::var("USERPROFILE")).ok().and_then(|s| CString::new(s).ok()).map(|c| c.into_raw()).unwrap_or(std::ptr::null_mut())
}

#[no_mangle]
pub unsafe extern "C" fn rt_env_get(key_ptr: *const c_char, key_len: usize) -> *mut c_char {
    if key_ptr.is_null() { return std::ptr::null_mut(); }
    let k = String::from_utf8_lossy(std::slice::from_raw_parts(key_ptr as *const u8, key_len));
    env::var(k.as_ref()).ok().and_then(|s| CString::new(s).ok()).map(|c| c.into_raw()).unwrap_or(std::ptr::null_mut())
}

#[no_mangle]
pub unsafe extern "C" fn rt_env_set(key_ptr: *const c_char, key_len: usize, val_ptr: *const c_char, val_len: usize) -> bool {
    if key_ptr.is_null() || val_ptr.is_null() { return false; }
    let k = String::from_utf8_lossy(std::slice::from_raw_parts(key_ptr as *const u8, key_len));
    let v = String::from_utf8_lossy(std::slice::from_raw_parts(val_ptr as *const u8, val_len));
    env::set_var(k.as_ref(), v.as_ref()); true
}

// =============================================================================
// Glob
// =============================================================================

#[no_mangle]
pub unsafe extern "C" fn rt_glob(pattern_ptr: *const c_char, pattern_len: usize) -> *mut c_char {
    if pattern_ptr.is_null() { return std::ptr::null_mut(); }
    let p = String::from_utf8_lossy(std::slice::from_raw_parts(pattern_ptr as *const u8, pattern_len));
    glob::glob(&p).ok().map(|ps| ps.filter_map(|p| p.ok()).map(|p| p.to_string_lossy().to_string()).collect::<Vec<_>>().join("\n"))
        .and_then(|s| CString::new(s).ok()).map(|c| c.into_raw()).unwrap_or(std::ptr::null_mut())
}

// =============================================================================
// Cargo Operations
// =============================================================================

fn esc(s: &str) -> String { s.replace('\\', "\\\\").replace('"', "\\\"").replace('\n', "\\n").replace('\r', "\\r").replace('\t', "\\t") }

#[no_mangle]
pub unsafe extern "C" fn rt_cargo_build(profile_ptr: *const c_char, profile_len: usize, _features_ptr: *const c_char, _feature_count: i64) -> *mut c_char {
    let profile = if profile_ptr.is_null() || profile_len == 0 { "debug".to_string() } else { std::str::from_utf8(std::slice::from_raw_parts(profile_ptr as *const u8, profile_len)).unwrap_or("debug").to_string() };
    let mut cmd = Command::new("cargo");
    cmd.arg("build").current_dir("build/rust");
    match profile.as_str() {
        "release" => { cmd.arg("--release"); }
        "bootstrap" => { cmd.arg("--profile").arg("bootstrap"); }
        _ => {}
    }
    match cmd.stdout(Stdio::piped()).stderr(Stdio::piped()).output() {
        Ok(o) => CString::new(format!("{{\"success\":{},\"exit_code\":{},\"stdout\":\"{}\",\"stderr\":\"{}\",\"duration_ms\":0}}", o.status.success(), o.status.code().unwrap_or(-1), esc(&String::from_utf8_lossy(&o.stdout)), esc(&String::from_utf8_lossy(&o.stderr)))).unwrap().into_raw(),
        Err(e) => CString::new(format!("{{\"success\":false,\"exit_code\":1,\"stdout\":\"\",\"stderr\":\"{}\",\"duration_ms\":0}}", e)).unwrap().into_raw(),
    }
}

#[no_mangle] pub extern "C" fn rt_cargo_check() -> *mut c_char {
    match Command::new("cargo").arg("check").current_dir("build/rust").stdout(Stdio::piped()).stderr(Stdio::piped()).output() {
        Ok(o) => CString::new(format!("{{\"success\":{},\"stdout\":\"{}\",\"stderr\":\"{}\"}}", o.status.success(), esc(&String::from_utf8_lossy(&o.stdout)), esc(&String::from_utf8_lossy(&o.stderr)))).unwrap().into_raw(),
        Err(e) => CString::new(format!("{{\"success\":false,\"error\":\"{}\"}}", e)).unwrap().into_raw(),
    }
}

#[no_mangle] pub extern "C" fn rt_cargo_clean() -> i64 { Command::new("cargo").arg("clean").current_dir("build/rust").status().map(|s| s.code().unwrap_or(-1) as i64).unwrap_or(-1) }

#[no_mangle]
pub unsafe extern "C" fn rt_cargo_test(_package_ptr: *const c_char, _package_len: usize, _filter_ptr: *const c_char, _filter_len: usize) -> *mut c_char {
    match Command::new("cargo").arg("test").current_dir("build/rust").stdout(Stdio::piped()).stderr(Stdio::piped()).output() {
        Ok(o) => CString::new(format!("{{\"success\":{},\"stdout\":\"{}\",\"stderr\":\"{}\"}}", o.status.success(), esc(&String::from_utf8_lossy(&o.stdout)), esc(&String::from_utf8_lossy(&o.stderr)))).unwrap().into_raw(),
        Err(e) => CString::new(format!("{{\"success\":false,\"error\":\"{}\"}}", e)).unwrap().into_raw(),
    }
}

#[no_mangle]
pub unsafe extern "C" fn rt_cargo_test_doc(_package_ptr: *const c_char, _package_len: usize) -> *mut c_char {
    match Command::new("cargo").args(["test", "--doc"]).current_dir("build/rust").stdout(Stdio::piped()).stderr(Stdio::piped()).output() {
        Ok(o) => CString::new(format!("{{\"success\":{},\"stdout\":\"{}\",\"stderr\":\"{}\"}}", o.status.success(), esc(&String::from_utf8_lossy(&o.stdout)), esc(&String::from_utf8_lossy(&o.stderr)))).unwrap().into_raw(),
        Err(e) => CString::new(format!("{{\"success\":false,\"error\":\"{}\"}}", e)).unwrap().into_raw(),
    }
}

#[no_mangle]
pub unsafe extern "C" fn rt_cargo_lint(fix: i64) -> *mut c_char {
    let mut cmd = Command::new("cargo"); cmd.arg("clippy").current_dir("build/rust"); if fix != 0 { cmd.arg("--fix"); }
    match cmd.stdout(Stdio::piped()).stderr(Stdio::piped()).output() {
        Ok(o) => CString::new(format!("{{\"success\":{},\"stdout\":\"{}\",\"stderr\":\"{}\"}}", o.status.success(), esc(&String::from_utf8_lossy(&o.stdout)), esc(&String::from_utf8_lossy(&o.stderr)))).unwrap().into_raw(),
        Err(e) => CString::new(format!("{{\"success\":false,\"error\":\"{}\"}}", e)).unwrap().into_raw(),
    }
}

#[no_mangle]
pub unsafe extern "C" fn rt_cargo_fmt(check_only: i64) -> *mut c_char {
    let mut cmd = Command::new("cargo"); cmd.arg("fmt").current_dir("build/rust"); if check_only != 0 { cmd.arg("--check"); }
    match cmd.stdout(Stdio::piped()).stderr(Stdio::piped()).output() {
        Ok(o) => CString::new(format!("{{\"success\":{},\"stdout\":\"{}\",\"stderr\":\"{}\"}}", o.status.success(), esc(&String::from_utf8_lossy(&o.stdout)), esc(&String::from_utf8_lossy(&o.stderr)))).unwrap().into_raw(),
        Err(e) => CString::new(format!("{{\"success\":false,\"error\":\"{}\"}}", e)).unwrap().into_raw(),
    }
}

// =============================================================================
// CLI Stubs
// =============================================================================

macro_rules! cli_stub { ($name:ident) => { #[no_mangle] pub extern "C" fn $name(_args: *const c_char) -> i64 { eprintln!("error: {} not supported in bootstrap mode", stringify!($name)); 1 } }; }
cli_stub!(rt_cli_watch_file); cli_stub!(rt_cli_run_repl); cli_stub!(rt_cli_handle_run);
cli_stub!(rt_cli_run_tests); cli_stub!(rt_cli_run_lint); cli_stub!(rt_cli_run_fmt); cli_stub!(rt_cli_run_fix); cli_stub!(rt_cli_run_verify); cli_stub!(rt_cli_run_check);
cli_stub!(rt_cli_run_migrate); cli_stub!(rt_cli_run_mcp); cli_stub!(rt_cli_run_diff); cli_stub!(rt_cli_run_query);
cli_stub!(rt_cli_run_spec_coverage); cli_stub!(rt_cli_run_gen_lean); cli_stub!(rt_cli_run_feature_gen); cli_stub!(rt_cli_run_task_gen);
cli_stub!(rt_cli_run_spec_gen); cli_stub!(rt_cli_run_sspec_docgen); cli_stub!(rt_cli_run_todo_gen); cli_stub!(rt_cli_run_todo_scan);
cli_stub!(rt_cli_run_lex); cli_stub!(rt_cli_run_brief); cli_stub!(rt_cli_run_ffi_gen); cli_stub!(rt_cli_run_i18n); cli_stub!(rt_cli_run_info);
cli_stub!(rt_cli_handle_web); cli_stub!(rt_cli_handle_diagram); cli_stub!(rt_cli_run_replay); cli_stub!(rt_cli_run_constr);
cli_stub!(rt_cli_run_i);

#[no_mangle] pub extern "C" fn rt_cli_handle_linkers() -> i64 { println!("Available linkers: mold, lld, ld"); 0 }
#[no_mangle] pub unsafe extern "C" fn rt_context_generate(_: *const c_char, _: usize, _: *const c_char, _: usize, _: *const c_char, _: usize) -> *mut c_char { std::ptr::null_mut() }
#[no_mangle] pub unsafe extern "C" fn rt_context_stats(_: *const c_char, _: usize, _: *const c_char, _: usize) -> *mut c_char { std::ptr::null_mut() }
#[no_mangle] pub extern "C" fn rt_settlement_main() -> i64 { 0 }

// =============================================================================
// Coverage & Fault
// =============================================================================

static mut COVERAGE_ENABLED: bool = false;
#[no_mangle] pub extern "C" fn rt_coverage_enabled() -> bool { unsafe { COVERAGE_ENABLED } }
#[no_mangle] pub extern "C" fn rt_coverage_clear() {}
#[no_mangle] pub unsafe extern "C" fn rt_coverage_dump_sdn(_: *const c_char, _: usize) -> bool { false }

static STACK_OVF: AtomicBool = AtomicBool::new(false);
static MAX_REC: AtomicI64 = AtomicI64::new(0);
static TIMEOUT: AtomicI64 = AtomicI64::new(0);
static EXEC_LIM: AtomicI64 = AtomicI64::new(0);
#[no_mangle] pub extern "C" fn rt_fault_set_stack_overflow_detection(e: bool) { STACK_OVF.store(e, Ordering::SeqCst); }
#[no_mangle] pub extern "C" fn rt_fault_set_max_recursion_depth(d: i64) { MAX_REC.store(d, Ordering::SeqCst); }
#[no_mangle] pub extern "C" fn rt_fault_set_timeout(t: i64) { TIMEOUT.store(t, Ordering::SeqCst); }
#[no_mangle] pub extern "C" fn rt_fault_set_execution_limit(l: i64) { EXEC_LIM.store(l, Ordering::SeqCst); }

// =============================================================================
// Compiler - Token Types
// =============================================================================

#[derive(Debug, Clone, PartialEq)]
enum Tok { Fn, Val, Var, If, Elif, Else, While, For, In, Return, Match, Class, Struct, Enum, Impl, Use, Extern, True, False, TNone, And, Or, Not,
    Int(i64), Float(f64), Str(String), Id(String),
    Plus, Minus, Star, Slash, Percent, Eq, Ne, Lt, Le, Gt, Ge, Assign, Arrow, Colon, Comma, Dot,
    LP, RP, LB, RB, LC, RC, Nl, Indent, Dedent, Eof }

// =============================================================================
// Compiler - AST Types
// =============================================================================

#[derive(Debug, Clone)]
enum Expr { EInt(i64), EStr(String), EBool(bool), ENone, EId(String), EBin(Box<Expr>, BinOp, Box<Expr>), ECall(Box<Expr>, Vec<Expr>), EArr(Vec<Expr>), ENot(Box<Expr>) }
#[derive(Debug, Clone, Copy)]
enum BinOp { Add, Sub, Mul, Div, Mod, Eq, Ne, Lt, Le, Gt, Ge, And, Or }
#[derive(Debug, Clone)]
enum Stmt { SExpr(Expr), SVal(String, Expr), SVar(String, Expr), SAssign(String, Expr), SIf(Expr, Vec<Stmt>, Option<Vec<Stmt>>), SWhile(Expr, Vec<Stmt>), SFor(String, Expr, Vec<Stmt>), SRet(Option<Expr>), SPrint(Expr) }
#[derive(Debug, Clone)]
struct FnDecl { name: String, params: Vec<(String, String)>, ret_ty: Option<String>, body: Vec<Stmt>, is_extern: bool }
#[derive(Debug)]
struct Mod { fns: Vec<FnDecl> }

// =============================================================================
// Compiler - Lexer
// =============================================================================

struct Lex { src: Vec<char>, pos: usize, indent: Vec<usize>, pending: Vec<Tok> }
impl Lex {
    fn new(s: &str) -> Self { Lex { src: s.chars().collect(), pos: 0, indent: vec![0], pending: vec![] } }
    fn peek(&self) -> Option<char> { self.src.get(self.pos).copied() }
    fn adv(&mut self) -> Option<char> { let c = self.peek()?; self.pos += 1; Some(c) }
    fn skip_ws(&mut self) { while matches!(self.peek(), Some(' '|'\t'|'\r')) { self.adv(); } if self.peek() == Some('#') { while self.peek().map(|c| c != '\n').unwrap_or(false) { self.adv(); } } }
    fn read_str(&mut self) -> Tok { let q = self.adv().unwrap(); let mut s = String::new(); while let Some(c) = self.peek() { if c == q { self.adv(); break; } if c == '\\' { self.adv(); if let Some(e) = self.peek() { self.adv(); s.push(match e { 'n'=>'\n', 't'=>'\t', 'r'=>'\r', _=>e }); } } else { s.push(c); self.adv(); } } Tok::Str(s) }
    fn read_num(&mut self) -> Tok { let mut s = String::new(); let mut f = false; while let Some(c) = self.peek() { if c.is_ascii_digit() { s.push(c); self.adv(); } else if c == '.' && !f { if self.src.get(self.pos+1).map(|c| c.is_ascii_digit()).unwrap_or(false) { f = true; s.push(c); self.adv(); } else { break; } } else if c == '_' { self.adv(); } else { break; } } if f { Tok::Float(s.parse().unwrap_or(0.0)) } else { Tok::Int(s.parse().unwrap_or(0)) } }
    fn read_id(&mut self) -> Tok { let mut s = String::new(); while self.peek().map(|c| c.is_alphanumeric() || c == '_').unwrap_or(false) { s.push(self.adv().unwrap()); } match s.as_str() { "fn"=>Tok::Fn, "val"=>Tok::Val, "var"=>Tok::Var, "if"=>Tok::If, "elif"=>Tok::Elif, "else"=>Tok::Else, "while"=>Tok::While, "for"=>Tok::For, "in"=>Tok::In, "return"=>Tok::Return, "match"=>Tok::Match, "class"=>Tok::Class, "struct"=>Tok::Struct, "enum"=>Tok::Enum, "impl"=>Tok::Impl, "use"=>Tok::Use, "extern"=>Tok::Extern, "true"|"True"=>Tok::True, "false"|"False"=>Tok::False, "None"=>Tok::TNone, "and"=>Tok::And, "or"=>Tok::Or, "not"=>Tok::Not, "print"=>Tok::Id("print".into()), _=>Tok::Id(s) } }
    fn next(&mut self) -> Tok {
        if let Some(t) = self.pending.pop() { return t; }
        self.skip_ws();
        let c = match self.peek() { Some(c) => c, None => return Tok::Eof };
        if c == '\n' { self.adv(); let mut ind = 0; while let Some(c) = self.peek() { if c == ' ' { ind += 1; self.adv(); } else if c == '\t' { ind += 4; self.adv(); } else if c == '\n' { self.adv(); ind = 0; } else if c == '#' { while self.peek().map(|c| c != '\n').unwrap_or(false) { self.adv(); } if self.peek() == Some('\n') { self.adv(); } ind = 0; } else { break; } } let cur = *self.indent.last().unwrap_or(&0); if ind > cur { self.indent.push(ind); return Tok::Indent; } else if ind < cur { while self.indent.last().map(|&i| i > ind).unwrap_or(false) { self.indent.pop(); self.pending.push(Tok::Dedent); } if let Some(t) = self.pending.pop() { self.pending.insert(0, Tok::Nl); return t; } } return Tok::Nl; }
        if c == '"' || c == '\'' { return self.read_str(); }
        if c.is_ascii_digit() { return self.read_num(); }
        if c.is_alphabetic() || c == '_' { return self.read_id(); }
        self.adv();
        match c { '+'=> Tok::Plus, '-'=> if self.peek() == Some('>') { self.adv(); Tok::Arrow } else { Tok::Minus }, '*'=>Tok::Star, '/'=>Tok::Slash, '%'=>Tok::Percent, '='=> if self.peek() == Some('=') { self.adv(); Tok::Eq } else { Tok::Assign }, '!'=> if self.peek() == Some('=') { self.adv(); Tok::Ne } else { Tok::Id("!".into()) }, '<'=> if self.peek() == Some('=') { self.adv(); Tok::Le } else { Tok::Lt }, '>'=> if self.peek() == Some('=') { self.adv(); Tok::Ge } else { Tok::Gt }, ':'=> Tok::Colon, ','=> Tok::Comma, '.'=> Tok::Dot, '('=> Tok::LP, ')'=> Tok::RP, '['=> Tok::LB, ']'=> Tok::RB, '{'=> Tok::LC, '}'=> Tok::RC, _=> Tok::Id(c.to_string()) }
    }
    fn tokenize(&mut self) -> Vec<Tok> { let mut ts = vec![]; loop { let t = self.next(); let eof = t == Tok::Eof; ts.push(t); if eof { break; } } while self.indent.len() > 1 { self.indent.pop(); ts.insert(ts.len()-1, Tok::Dedent); } ts }
}

// =============================================================================
// Compiler - Parser
// =============================================================================

struct Parse { toks: Vec<Tok>, pos: usize }
impl Parse {
    fn new(toks: Vec<Tok>) -> Self { Parse { toks, pos: 0 } }
    fn peek(&self) -> &Tok { self.toks.get(self.pos).unwrap_or(&Tok::Eof) }
    fn adv(&mut self) -> Tok { let t = self.toks.get(self.pos).cloned().unwrap_or(Tok::Eof); self.pos += 1; t }
    fn skip_nl(&mut self) { while matches!(self.peek(), Tok::Nl) { self.adv(); } }
    fn parse_mod(&mut self) -> Result<Mod, String> {
        let mut fns = vec![]; self.skip_nl();
        while self.peek() != &Tok::Eof { self.skip_nl();
            match self.peek() { Tok::Fn => fns.push(self.parse_fn(false)?), Tok::Extern => { self.adv(); if matches!(self.peek(), Tok::Fn) { fns.push(self.parse_fn(true)?); } }
                Tok::Use|Tok::Class|Tok::Struct|Tok::Enum|Tok::Impl => { self.adv(); while !matches!(self.peek(), Tok::Nl|Tok::Eof) { self.adv(); } self.skip_nl(); if matches!(self.peek(), Tok::Indent) { self.adv(); let mut d = 1; while d > 0 && self.peek() != &Tok::Eof { match self.peek() { Tok::Indent => d += 1, Tok::Dedent => d -= 1, _ => {} } self.adv(); } } }
                Tok::Eof => break, _ => { self.adv(); } } self.skip_nl(); }
        Ok(Mod { fns })
    }
    fn parse_fn(&mut self, ext: bool) -> Result<FnDecl, String> {
        self.adv(); // fn
        let name = match self.adv() { Tok::Id(s) => s, t => return Err(format!("expected fn name, got {:?}", t)) };
        if !matches!(self.adv(), Tok::LP) { return Err("expected (".into()); }
        let mut params = vec![];
        while self.peek() != &Tok::RP { let pn = match self.adv() { Tok::Id(s) => s, t => return Err(format!("expected param, got {:?}", t)) }; let mut pt = "any".to_string(); if matches!(self.peek(), Tok::Colon) { self.adv(); pt = self.parse_ty()?; } params.push((pn, pt)); if matches!(self.peek(), Tok::Comma) { self.adv(); } }
        self.adv(); // )
        let ret_ty = if matches!(self.peek(), Tok::Arrow) { self.adv(); Some(self.parse_ty()?) } else { None };
        if ext { self.skip_nl(); return Ok(FnDecl { name, params, ret_ty, body: vec![], is_extern: true }); }
        if !matches!(self.adv(), Tok::Colon) { return Err("expected :".into()); } self.skip_nl();
        let body = if matches!(self.peek(), Tok::Indent) { self.adv(); self.parse_block()? } else { vec![] };
        Ok(FnDecl { name, params, ret_ty, body, is_extern: false })
    }
    fn parse_ty(&mut self) -> Result<String, String> { match self.adv() { Tok::Id(s) => Ok(s), Tok::LB => { let inner = self.parse_ty()?; if !matches!(self.adv(), Tok::RB) { return Err("expected ]".into()); } Ok(format!("[{}]", inner)) } t => Err(format!("expected type, got {:?}", t)) } }
    fn parse_block(&mut self) -> Result<Vec<Stmt>, String> { let mut ss = vec![]; while !matches!(self.peek(), Tok::Dedent|Tok::Eof) { self.skip_nl(); if matches!(self.peek(), Tok::Dedent|Tok::Eof) { break; } ss.push(self.parse_stmt()?); self.skip_nl(); } if matches!(self.peek(), Tok::Dedent) { self.adv(); } Ok(ss) }
    fn parse_stmt(&mut self) -> Result<Stmt, String> {
        match self.peek().clone() {
            Tok::Val => { self.adv(); let n = match self.adv() { Tok::Id(s) => s, _ => return Err("expected name".into()) }; if matches!(self.peek(), Tok::Colon) { self.adv(); self.parse_ty()?; } if !matches!(self.adv(), Tok::Assign) { return Err("expected =".into()); } Ok(Stmt::SVal(n, self.parse_expr()?)) }
            Tok::Var => { self.adv(); let n = match self.adv() { Tok::Id(s) => s, _ => return Err("expected name".into()) }; if matches!(self.peek(), Tok::Colon) { self.adv(); self.parse_ty()?; } if !matches!(self.adv(), Tok::Assign) { return Err("expected =".into()); } Ok(Stmt::SVar(n, self.parse_expr()?)) }
            Tok::If => { self.adv(); let c = self.parse_expr()?; if !matches!(self.adv(), Tok::Colon) { return Err("expected :".into()); } self.skip_nl(); let th = if matches!(self.peek(), Tok::Indent) { self.adv(); self.parse_block()? } else { vec![self.parse_stmt()?] }; self.skip_nl(); let el = if matches!(self.peek(), Tok::Elif) { let elif_stmt = self.parse_stmt()?; Some(vec![elif_stmt]) } else if matches!(self.peek(), Tok::Else) { self.adv(); if !matches!(self.adv(), Tok::Colon) { return Err("expected :".into()); } self.skip_nl(); Some(if matches!(self.peek(), Tok::Indent) { self.adv(); self.parse_block()? } else { vec![self.parse_stmt()?] }) } else { None }; Ok(Stmt::SIf(c, th, el)) }
            Tok::Elif => { self.adv(); let c = self.parse_expr()?; if !matches!(self.adv(), Tok::Colon) { return Err("expected :".into()); } self.skip_nl(); let th = if matches!(self.peek(), Tok::Indent) { self.adv(); self.parse_block()? } else { vec![self.parse_stmt()?] }; self.skip_nl(); let el = if matches!(self.peek(), Tok::Elif) { let elif_stmt = self.parse_stmt()?; Some(vec![elif_stmt]) } else if matches!(self.peek(), Tok::Else) { self.adv(); if !matches!(self.adv(), Tok::Colon) { return Err("expected :".into()); } self.skip_nl(); Some(if matches!(self.peek(), Tok::Indent) { self.adv(); self.parse_block()? } else { vec![self.parse_stmt()?] }) } else { None }; Ok(Stmt::SIf(c, th, el)) }
            Tok::While => { self.adv(); let c = self.parse_expr()?; if !matches!(self.adv(), Tok::Colon) { return Err("expected :".into()); } self.skip_nl(); let b = if matches!(self.peek(), Tok::Indent) { self.adv(); self.parse_block()? } else { vec![self.parse_stmt()?] }; Ok(Stmt::SWhile(c, b)) }
            Tok::For => { self.adv(); let v = match self.adv() { Tok::Id(s) => s, _ => return Err("expected var".into()) }; if !matches!(self.adv(), Tok::In) { return Err("expected in".into()); } let it = self.parse_expr()?; if !matches!(self.adv(), Tok::Colon) { return Err("expected :".into()); } self.skip_nl(); let b = if matches!(self.peek(), Tok::Indent) { self.adv(); self.parse_block()? } else { vec![self.parse_stmt()?] }; Ok(Stmt::SFor(v, it, b)) }
            Tok::Return => { self.adv(); let e = if matches!(self.peek(), Tok::Nl|Tok::Dedent|Tok::Eof) { None } else { Some(self.parse_expr()?) }; Ok(Stmt::SRet(e)) }
            Tok::Id(s) if s == "print" => { self.adv(); Ok(Stmt::SPrint(self.parse_expr()?)) }
            Tok::Id(_) => { let n = match self.adv() { Tok::Id(s) => s, _ => unreachable!() }; if matches!(self.peek(), Tok::Assign) { self.adv(); Ok(Stmt::SAssign(n, self.parse_expr()?)) } else { self.pos -= 1; Ok(Stmt::SExpr(self.parse_expr()?)) } }
            _ => Ok(Stmt::SExpr(self.parse_expr()?))
        }
    }
    fn parse_expr(&mut self) -> Result<Expr, String> { self.parse_or() }
    fn parse_or(&mut self) -> Result<Expr, String> { let mut l = self.parse_and()?; while matches!(self.peek(), Tok::Or) { self.adv(); l = Expr::EBin(Box::new(l), BinOp::Or, Box::new(self.parse_and()?)); } Ok(l) }
    fn parse_and(&mut self) -> Result<Expr, String> { let mut l = self.parse_cmp()?; while matches!(self.peek(), Tok::And) { self.adv(); l = Expr::EBin(Box::new(l), BinOp::And, Box::new(self.parse_cmp()?)); } Ok(l) }
    fn parse_cmp(&mut self) -> Result<Expr, String> { let mut l = self.parse_add()?; loop { let op = match self.peek() { Tok::Eq=>BinOp::Eq, Tok::Ne=>BinOp::Ne, Tok::Lt=>BinOp::Lt, Tok::Le=>BinOp::Le, Tok::Gt=>BinOp::Gt, Tok::Ge=>BinOp::Ge, _=>break }; self.adv(); l = Expr::EBin(Box::new(l), op, Box::new(self.parse_add()?)); } Ok(l) }
    fn parse_add(&mut self) -> Result<Expr, String> { let mut l = self.parse_mul()?; loop { let op = match self.peek() { Tok::Plus=>BinOp::Add, Tok::Minus=>BinOp::Sub, _=>break }; self.adv(); l = Expr::EBin(Box::new(l), op, Box::new(self.parse_mul()?)); } Ok(l) }
    fn parse_mul(&mut self) -> Result<Expr, String> { let mut l = self.parse_unary()?; loop { let op = match self.peek() { Tok::Star=>BinOp::Mul, Tok::Slash=>BinOp::Div, Tok::Percent=>BinOp::Mod, _=>break }; self.adv(); l = Expr::EBin(Box::new(l), op, Box::new(self.parse_unary()?)); } Ok(l) }
    fn parse_unary(&mut self) -> Result<Expr, String> { if matches!(self.peek(), Tok::Minus) { self.adv(); return Ok(Expr::EBin(Box::new(Expr::EInt(0)), BinOp::Sub, Box::new(self.parse_unary()?))); } if matches!(self.peek(), Tok::Not) { self.adv(); return Ok(Expr::ENot(Box::new(self.parse_unary()?))); } self.parse_post() }
    fn parse_post(&mut self) -> Result<Expr, String> { let mut e = self.parse_prim()?; loop { match self.peek() { Tok::LP => { self.adv(); let mut args = vec![]; while self.peek() != &Tok::RP { args.push(self.parse_expr()?); if matches!(self.peek(), Tok::Comma) { self.adv(); } } self.adv(); e = Expr::ECall(Box::new(e), args); } Tok::Dot => { self.adv(); let f = match self.adv() { Tok::Id(s) => s, _ => return Err("expected field".into()) }; e = Expr::ECall(Box::new(Expr::EId(f)), vec![e]); } _ => break } } Ok(e) }
    fn parse_prim(&mut self) -> Result<Expr, String> { match self.peek().clone() { Tok::Int(n) => { self.adv(); Ok(Expr::EInt(n)) } Tok::Str(s) => { self.adv(); Ok(Expr::EStr(s)) } Tok::True => { self.adv(); Ok(Expr::EBool(true)) } Tok::False => { self.adv(); Ok(Expr::EBool(false)) } Tok::TNone => { self.adv(); Ok(Expr::ENone) } Tok::Id(s) => { self.adv(); Ok(Expr::EId(s)) } Tok::LP => { self.adv(); let e = self.parse_expr()?; self.adv(); Ok(e) } Tok::LB => { self.adv(); let mut es = vec![]; while self.peek() != &Tok::RB { es.push(self.parse_expr()?); if matches!(self.peek(), Tok::Comma) { self.adv(); } } self.adv(); Ok(Expr::EArr(es)) } t => Err(format!("unexpected {:?}", t)) } }
}

// =============================================================================
// Compiler - Code Generator (Cranelift)
// =============================================================================

struct CGen { module: Option<ObjectModule>, ctx: cranelift_codegen::Context, fns: HashMap<String, FuncId> }
impl CGen {
    fn new() -> Result<Self, String> {
        let mut fb = settings::builder(); fb.set("opt_level", "speed").map_err(|e| e.to_string())?;
        let isa = cranelift_codegen::isa::lookup_by_name("x86_64-unknown-linux-gnu").map_err(|e| e.to_string())?.finish(settings::Flags::new(fb)).map_err(|e| e.to_string())?;
        let ob = ObjectBuilder::new(isa, "simple", cranelift_module::default_libcall_names()).map_err(|e| e.to_string())?;
        let module = ObjectModule::new(ob); let ctx = module.make_context();
        Ok(CGen { module: Some(module), ctx, fns: HashMap::new() })
    }
    fn compile(&mut self, ast: &Mod) -> Result<Vec<u8>, String> {
        let module = self.module.as_mut().ok_or("module consumed")?;
        for f in &ast.fns { if f.is_extern { continue; } let mut sig = module.make_signature(); for _ in &f.params { sig.params.push(AbiParam::new(I64)); } if f.ret_ty.is_some() { sig.returns.push(AbiParam::new(I64)); } let id = module.declare_function(&f.name, Linkage::Export, &sig).map_err(|e| e.to_string())?; self.fns.insert(f.name.clone(), id); }
        for f in &ast.fns { if f.is_extern { continue; } self.compile_fn(f)?; }
        let module = self.module.take().ok_or("module consumed")?;
        Ok(module.finish().emit().map_err(|e| e.to_string())?)
    }
    fn compile_fn(&mut self, f: &FnDecl) -> Result<(), String> {
        let module = self.module.as_mut().ok_or("module consumed")?;
        self.ctx.clear(); let mut sig = module.make_signature(); for _ in &f.params { sig.params.push(AbiParam::new(I64)); } if f.ret_ty.is_some() { sig.returns.push(AbiParam::new(I64)); }
        self.ctx.func.signature = sig; self.ctx.func.name = UserFuncName::user(0, self.fns.len() as u32);
        let id = *self.fns.get(&f.name).ok_or("fn not found")?;
        { let mut bctx = FunctionBuilderContext::new(); let mut b = FunctionBuilder::new(&mut self.ctx.func, &mut bctx); let blk = b.create_block(); b.append_block_params_for_function_params(blk); b.switch_to_block(blk); b.seal_block(blk); let z = b.ins().iconst(I64, 0); if f.ret_ty.is_some() { b.ins().return_(&[z]); } else { b.ins().return_(&[]); } b.finalize(); }
        module.define_function(id, &mut self.ctx).map_err(|e| e.to_string())?; module.clear_context(&mut self.ctx); Ok(())
    }
}

// =============================================================================
// Compiler - rt_cli_handle_compile
// =============================================================================

#[no_mangle]
pub unsafe extern "C" fn rt_cli_handle_compile(args_ptr: *const c_char) -> i64 {
    if args_ptr.is_null() { eprintln!("error: compile requires a source file"); return 1; }
    let args_str = match CStr::from_ptr(args_ptr).to_str() { Ok(s) => s, Err(_) => { eprintln!("error: invalid args"); return 1; } };
    let args: Vec<&str> = args_str.split('\n').collect();
    let mut src_path: Option<&str> = None; let mut out_path: Option<&str> = None; let mut i = 0;
    while i < args.len() { let a = args[i]; if a == "-o" || a == "--output" { if i + 1 < args.len() { out_path = Some(args[i+1]); i += 1; } } else if a != "compile" && !a.starts_with("-") && a.ends_with(".spl") { src_path = Some(a); } i += 1; }
    let src_path = match src_path { Some(p) => p, None => { eprintln!("error: no source file (.spl)"); return 1; } };
    let out_path = out_path.map(|s| s.to_string()).unwrap_or_else(|| { Path::new(src_path).file_stem().and_then(|s| s.to_str()).map(|s| format!("{}.o", s)).unwrap_or("out.o".into()) });
    let src = match fs::read_to_string(src_path) { Ok(s) => s, Err(e) => { eprintln!("error: cannot read {}: {}", src_path, e); return 1; } };
    println!("Compiling {}...", src_path);
    let toks = Lex::new(&src).tokenize();
    let ast = match Parse::new(toks).parse_mod() { Ok(a) => a, Err(e) => { eprintln!("error: parse: {}", e); return 1; } };
    let mut cg = match CGen::new() { Ok(c) => c, Err(e) => { eprintln!("error: codegen init: {}", e); return 1; } };
    let obj = match cg.compile(&ast) { Ok(o) => o, Err(e) => { eprintln!("error: compile: {}", e); return 1; } };
    if let Err(e) = fs::write(&out_path, &obj) { eprintln!("error: write {}: {}", out_path, e); return 1; }
    println!("Compiled to {}", out_path);
    if !out_path.ends_with(".o") { let obj_path = format!("{}.o", out_path); let _ = fs::write(&obj_path, &obj); if Command::new("cc").args([&obj_path, "-o", &out_path]).status().map(|s| s.success()).unwrap_or(false) { let _ = fs::remove_file(&obj_path); println!("Linked to {}", out_path); } }
    0
}

#[no_mangle]
pub extern "C" fn rt_compiler_version() -> *mut c_char { CString::new("Simple Compiler 0.1.0 (Bootstrap)").unwrap().into_raw() }

// =============================================================================
// Interpreter - Runtime Values
// =============================================================================

#[derive(Debug, Clone)]
enum Val { VInt(i64), VFloat(f64), VStr(String), VBool(bool), VNone, VArr(Vec<Val>), VFn(String) }

impl Val {
    fn to_string(&self) -> String {
        match self {
            Val::VInt(n) => n.to_string(),
            Val::VFloat(f) => f.to_string(),
            Val::VStr(s) => s.clone(),
            Val::VBool(b) => b.to_string(),
            Val::VNone => "None".to_string(),
            Val::VArr(a) => format!("[{}]", a.iter().map(|v| v.to_string()).collect::<Vec<_>>().join(", ")),
            Val::VFn(n) => format!("<fn {}>", n),
        }
    }
    fn to_int(&self) -> i64 { match self { Val::VInt(n) => *n, Val::VBool(b) => if *b { 1 } else { 0 }, _ => 0 } }
    fn to_bool(&self) -> bool { match self { Val::VBool(b) => *b, Val::VInt(n) => *n != 0, Val::VStr(s) => !s.is_empty(), Val::VNone => false, Val::VArr(a) => !a.is_empty(), _ => true } }
}

// =============================================================================
// Interpreter - Evaluator
// =============================================================================

struct Interp { vars: HashMap<String, Val>, fns: HashMap<String, FnDecl> }

impl Interp {
    fn new() -> Self { Interp { vars: HashMap::new(), fns: HashMap::new() } }

    fn run(&mut self, ast: &Mod) -> Result<Val, String> {
        for f in &ast.fns { if !f.is_extern { self.fns.insert(f.name.clone(), f.clone()); } }
        if let Some(main_fn) = self.fns.get("main").cloned() {
            self.call_fn(&main_fn, vec![])
        } else {
            Err("no main function".into())
        }
    }

    fn call_fn(&mut self, f: &FnDecl, args: Vec<Val>) -> Result<Val, String> {
        let old_vars = self.vars.clone();
        for (i, (name, _)) in f.params.iter().enumerate() {
            self.vars.insert(name.clone(), args.get(i).cloned().unwrap_or(Val::VNone));
        }
        let result = self.exec_block(&f.body);
        let ret_val = self.vars.get("__ret__").cloned();
        self.vars = old_vars;
        match result { Ok(v) => Ok(v), Err(e) if e.starts_with("return:") => Ok(ret_val.unwrap_or(Val::VNone)), Err(e) => Err(e) }
    }

    fn exec_block(&mut self, stmts: &[Stmt]) -> Result<Val, String> {
        let mut last = Val::VNone;
        for s in stmts { last = self.exec_stmt(s)?; }
        Ok(last)
    }

    fn exec_stmt(&mut self, s: &Stmt) -> Result<Val, String> {
        match s {
            Stmt::SExpr(e) => self.eval(e),
            Stmt::SVal(name, e) | Stmt::SVar(name, e) => { let v = self.eval(e)?; self.vars.insert(name.clone(), v.clone()); Ok(v) }
            Stmt::SAssign(name, e) => { let v = self.eval(e)?; self.vars.insert(name.clone(), v.clone()); Ok(v) }
            Stmt::SIf(cond, then_b, else_b) => {
                if self.eval(cond)?.to_bool() { self.exec_block(then_b) }
                else if let Some(eb) = else_b { self.exec_block(eb) }
                else { Ok(Val::VNone) }
            }
            Stmt::SWhile(cond, body) => { while self.eval(cond)?.to_bool() { self.exec_block(body)?; } Ok(Val::VNone) }
            Stmt::SFor(var, iter, body) => {
                let iter_val = self.eval(iter)?;
                if let Val::VArr(arr) = iter_val { for v in arr { self.vars.insert(var.clone(), v); self.exec_block(body)?; } }
                else if let Val::VInt(n) = iter_val { for i in 0..n { self.vars.insert(var.clone(), Val::VInt(i)); self.exec_block(body)?; } }
                Ok(Val::VNone)
            }
            Stmt::SRet(e) => { let v = e.as_ref().map(|e| self.eval(e)).transpose()?.unwrap_or(Val::VNone); self.vars.insert("__ret__".into(), v); Err("return:".into()) }
            Stmt::SPrint(e) => { let v = self.eval(e)?; println!("{}", v.to_string()); Ok(Val::VNone) }
        }
    }

    fn eval(&mut self, e: &Expr) -> Result<Val, String> {
        match e {
            Expr::EInt(n) => Ok(Val::VInt(*n)),
            Expr::EStr(s) => Ok(Val::VStr(s.clone())),
            Expr::EBool(b) => Ok(Val::VBool(*b)),
            Expr::ENone => Ok(Val::VNone),
            Expr::EId(name) => self.vars.get(name).cloned().ok_or_else(|| format!("undefined: {}", name)),
            Expr::EArr(es) => Ok(Val::VArr(es.iter().map(|e| self.eval(e)).collect::<Result<Vec<_>, _>>()?)),
            Expr::ENot(inner) => { let v = self.eval(inner)?; Ok(Val::VBool(!v.to_bool())) }
            Expr::EBin(l, op, r) => {
                let lv = self.eval(l)?; let rv = self.eval(r)?;
                match op {
                    BinOp::Add => match (&lv, &rv) { (Val::VInt(a), Val::VInt(b)) => Ok(Val::VInt(a + b)), (Val::VStr(a), Val::VStr(b)) => Ok(Val::VStr(format!("{}{}", a, b))), _ => Ok(Val::VInt(lv.to_int() + rv.to_int())) },
                    BinOp::Sub => Ok(Val::VInt(lv.to_int() - rv.to_int())),
                    BinOp::Mul => Ok(Val::VInt(lv.to_int() * rv.to_int())),
                    BinOp::Div => Ok(Val::VInt(lv.to_int() / rv.to_int().max(1))),
                    BinOp::Mod => Ok(Val::VInt(lv.to_int() % rv.to_int().max(1))),
                    BinOp::Eq => Ok(Val::VBool(lv.to_int() == rv.to_int())),
                    BinOp::Ne => Ok(Val::VBool(lv.to_int() != rv.to_int())),
                    BinOp::Lt => Ok(Val::VBool(lv.to_int() < rv.to_int())),
                    BinOp::Le => Ok(Val::VBool(lv.to_int() <= rv.to_int())),
                    BinOp::Gt => Ok(Val::VBool(lv.to_int() > rv.to_int())),
                    BinOp::Ge => Ok(Val::VBool(lv.to_int() >= rv.to_int())),
                    BinOp::And => Ok(Val::VBool(lv.to_bool() && rv.to_bool())),
                    BinOp::Or => Ok(Val::VBool(lv.to_bool() || rv.to_bool())),
                }
            }
            Expr::ECall(func, args) => {
                let argv: Vec<Val> = args.iter().map(|a| self.eval(a)).collect::<Result<Vec<_>, _>>()?;
                match func.as_ref() {
                    Expr::EId(name) => {
                        // Built-in functions
                        match name.as_str() {
                            "print" => { for a in &argv { print!("{}", a.to_string()); } println!(); Ok(Val::VNone) }
                            "len" => Ok(Val::VInt(match argv.get(0) { Some(Val::VArr(a)) => a.len() as i64, Some(Val::VStr(s)) => s.len() as i64, _ => 0 })),
                            "str" => Ok(Val::VStr(argv.get(0).map(|v| v.to_string()).unwrap_or_default())),
                            "int" => Ok(Val::VInt(argv.get(0).map(|v| v.to_int()).unwrap_or(0))),
                            "range" => {
                                let start = argv.get(0).map(|v| v.to_int()).unwrap_or(0);
                                let end = argv.get(1).map(|v| v.to_int()).unwrap_or(start);
                                let (s, e) = if argv.len() == 1 { (0, start) } else { (start, end) };
                                Ok(Val::VArr((s..e).map(Val::VInt).collect()))
                            }
                            "shell" => {
                                let cmd = argv.get(0).map(|v| v.to_string()).unwrap_or_default();
                                let status = Command::new("sh").arg("-c").arg(&cmd).status();
                                let code = status.map(|s| s.code().unwrap_or(-1) as i64).unwrap_or(-1);
                                Ok(Val::VInt(code))
                            }
                            "shell_output" => {
                                let cmd = argv.get(0).map(|v| v.to_string()).unwrap_or_default();
                                match Command::new("sh").arg("-c").arg(&cmd).output() {
                                    Ok(o) => Ok(Val::VStr(String::from_utf8_lossy(&o.stdout).to_string())),
                                    Err(_) => Ok(Val::VStr(String::new())),
                                }
                            }
                            "file_exists" => {
                                let path = argv.get(0).map(|v| v.to_string()).unwrap_or_default();
                                Ok(Val::VBool(Path::new(&path).exists()))
                            }
                            "read_file" => {
                                let path = argv.get(0).map(|v| v.to_string()).unwrap_or_default();
                                match fs::read_to_string(&path) {
                                    Ok(s) => Ok(Val::VStr(s)),
                                    Err(_) => Ok(Val::VNone),
                                }
                            }
                            "write_file" => {
                                let path = argv.get(0).map(|v| v.to_string()).unwrap_or_default();
                                let content = argv.get(1).map(|v| v.to_string()).unwrap_or_default();
                                match fs::write(&path, &content) {
                                    Ok(_) => Ok(Val::VBool(true)),
                                    Err(_) => Ok(Val::VBool(false)),
                                }
                            }
                            "getenv" => {
                                let key = argv.get(0).map(|v| v.to_string()).unwrap_or_default();
                                Ok(env::var(&key).map(Val::VStr).unwrap_or(Val::VNone))
                            }
                            "getcwd" => {
                                Ok(env::current_dir().map(|p| Val::VStr(p.to_string_lossy().to_string())).unwrap_or(Val::VNone))
                            }
                            "chdir" => {
                                let path = argv.get(0).map(|v| v.to_string()).unwrap_or_default();
                                Ok(Val::VBool(env::set_current_dir(&path).is_ok()))
                            }
                            "mkdir" => {
                                let path = argv.get(0).map(|v| v.to_string()).unwrap_or_default();
                                Ok(Val::VBool(fs::create_dir_all(&path).is_ok()))
                            }
                            "copy_file" => {
                                let src = argv.get(0).map(|v| v.to_string()).unwrap_or_default();
                                let dst = argv.get(1).map(|v| v.to_string()).unwrap_or_default();
                                Ok(Val::VBool(fs::copy(&src, &dst).is_ok()))
                            }
                            "remove_file" => {
                                let path = argv.get(0).map(|v| v.to_string()).unwrap_or_default();
                                Ok(Val::VBool(fs::remove_file(&path).is_ok()))
                            }
                            "is_dir" => {
                                let path = argv.get(0).map(|v| v.to_string()).unwrap_or_default();
                                Ok(Val::VBool(Path::new(&path).is_dir()))
                            }
                            "list_dir" => {
                                let path = argv.get(0).map(|v| v.to_string()).unwrap_or_default();
                                match fs::read_dir(&path) {
                                    Ok(entries) => {
                                        let files: Vec<Val> = entries.filter_map(|e| e.ok()).map(|e| Val::VStr(e.file_name().to_string_lossy().to_string())).collect();
                                        Ok(Val::VArr(files))
                                    }
                                    Err(_) => Ok(Val::VArr(vec![])),
                                }
                            }
                            "split" => {
                                let s = argv.get(0).map(|v| v.to_string()).unwrap_or_default();
                                let delim = argv.get(1).map(|v| v.to_string()).unwrap_or_else(|| " ".into());
                                Ok(Val::VArr(s.split(&delim).map(|p| Val::VStr(p.to_string())).collect()))
                            }
                            "join" => {
                                let delim = argv.get(0).map(|v| v.to_string()).unwrap_or_default();
                                let parts: Vec<String> = argv.get(1).map(|v| match v { Val::VArr(a) => a.iter().map(|x| x.to_string()).collect(), _ => vec![] }).unwrap_or_default();
                                Ok(Val::VStr(parts.join(&delim)))
                            }
                            "contains" => {
                                let s = argv.get(0).map(|v| v.to_string()).unwrap_or_default();
                                let sub = argv.get(1).map(|v| v.to_string()).unwrap_or_default();
                                Ok(Val::VBool(s.contains(&sub)))
                            }
                            "startswith" => {
                                let s = argv.get(0).map(|v| v.to_string()).unwrap_or_default();
                                let pre = argv.get(1).map(|v| v.to_string()).unwrap_or_default();
                                Ok(Val::VBool(s.starts_with(&pre)))
                            }
                            "endswith" => {
                                let s = argv.get(0).map(|v| v.to_string()).unwrap_or_default();
                                let suf = argv.get(1).map(|v| v.to_string()).unwrap_or_default();
                                Ok(Val::VBool(s.ends_with(&suf)))
                            }
                            "replace" => {
                                let s = argv.get(0).map(|v| v.to_string()).unwrap_or_default();
                                let from = argv.get(1).map(|v| v.to_string()).unwrap_or_default();
                                let to = argv.get(2).map(|v| v.to_string()).unwrap_or_default();
                                Ok(Val::VStr(s.replace(&from, &to)))
                            }
                            "trim" => {
                                let s = argv.get(0).map(|v| v.to_string()).unwrap_or_default();
                                Ok(Val::VStr(s.trim().to_string()))
                            }
                            "upper" => {
                                let s = argv.get(0).map(|v| v.to_string()).unwrap_or_default();
                                Ok(Val::VStr(s.to_uppercase()))
                            }
                            "lower" => {
                                let s = argv.get(0).map(|v| v.to_string()).unwrap_or_default();
                                Ok(Val::VStr(s.to_lowercase()))
                            }
                            "append" => {
                                // Append to array - returns new array
                                if let Some(Val::VArr(mut arr)) = argv.get(0).cloned() {
                                    if let Some(v) = argv.get(1).cloned() { arr.push(v); }
                                    Ok(Val::VArr(arr))
                                } else { Ok(Val::VArr(vec![])) }
                            }
                            "get" => {
                                // Get array/dict element
                                let arr = argv.get(0);
                                let idx = argv.get(1).map(|v| v.to_int()).unwrap_or(0) as usize;
                                match arr { Some(Val::VArr(a)) => Ok(a.get(idx).cloned().unwrap_or(Val::VNone)), _ => Ok(Val::VNone) }
                            }
                            "exit" => {
                                let code = argv.get(0).map(|v| v.to_int()).unwrap_or(0) as i32;
                                std::process::exit(code);
                            }
                            _ => {
                                if let Some(f) = self.fns.get(name).cloned() { self.call_fn(&f, argv) }
                                else { Err(format!("undefined function: {}", name)) }
                            }
                        }
                    }
                    _ => Err("cannot call non-function".into())
                }
            }
        }
    }
}

// =============================================================================
// Interpreter - rt_cli_run_file
// =============================================================================

#[no_mangle]
pub unsafe extern "C" fn rt_cli_run_file(args_ptr: *const c_char, _gc_log: bool, _gc_off: bool) -> i64 {
    if args_ptr.is_null() { eprintln!("error: no file specified"); return 1; }
    let args_str = match CStr::from_ptr(args_ptr).to_str() { Ok(s) => s, Err(_) => return 1 };
    let args: Vec<&str> = args_str.split('\n').collect();
    let file_path = args.get(0).unwrap_or(&"");
    if file_path.is_empty() { eprintln!("error: no file specified"); return 1; }

    let src = match fs::read_to_string(file_path) { Ok(s) => s, Err(e) => { eprintln!("error: cannot read {}: {}", file_path, e); return 1; } };
    let toks = Lex::new(&src).tokenize();
    let ast = match Parse::new(toks).parse_mod() { Ok(a) => a, Err(e) => { eprintln!("error: parse: {}", e); return 1; } };
    let mut interp = Interp::new();
    match interp.run(&ast) {
        Ok(Val::VInt(n)) => n,
        Ok(_) => 0,
        Err(e) if e.starts_with("return:") => interp.vars.get("__ret__").map(|v| v.to_int()).unwrap_or(0),
        Err(e) => { eprintln!("error: {}", e); 1 }
    }
}

#[no_mangle]
pub unsafe extern "C" fn rt_cli_run_code(code_ptr: *const c_char, _code_len: usize, _gc_log: bool, _gc_off: bool) -> i64 {
    if code_ptr.is_null() { return 1; }
    let code = match CStr::from_ptr(code_ptr).to_str() { Ok(s) => s, Err(_) => return 1 };
    let toks = Lex::new(code).tokenize();
    let ast = match Parse::new(toks).parse_mod() { Ok(a) => a, Err(e) => { eprintln!("error: parse: {}", e); return 1; } };
    let mut interp = Interp::new();
    match interp.run(&ast) { Ok(Val::VInt(n)) => n, Ok(_) => 0, Err(e) => { eprintln!("error: {}", e); 1 } }
}
