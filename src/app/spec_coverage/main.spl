# Simple CLI - spec-coverage command
# Compare spec features against test results for coverage analysis

use app.cli_util (get_cli_args, parse_csv_fields)
use app.io.mod (file_exists, file_read, file_write)
use std.text.{NL}
use std.log.{error}

val FEATURE_DB_PATH = "doc/feature/feature_db.sdn"
val TEST_DB_PATH = "doc/test/test_db.sdn"

fn print_help():
    print "Usage: simple spec-coverage [options]"
    print ""
    print "Analyze specification coverage against test results."
    print ""
    print "Options:"
    print "  --by-category    Show coverage by category"
    print "  --missing        Show incomplete features"
    print "  --report=<fmt>   Output format: text (default), markdown"
    print "  -h, --help       Show this help"

struct FeatureInfo:
    id: text
    category: text
    name: text
    status: text
    valid: bool

fn load_features() -> [FeatureInfo]:
    if not file_exists(FEATURE_DB_PATH):
        return []

    val content = file_read(FEATURE_DB_PATH)
    val lines = content.split(NL)
    var features: [FeatureInfo] = []
    var in_table = false

    for line in lines:
        val trimmed = line.trim()
        if trimmed.starts_with("features |"):
            in_table = true
            continue
        if not in_table or trimmed == "" or trimmed.starts_with("#"):
            if in_table and trimmed != "" and not trimmed.starts_with("#") and not trimmed.starts_with(" "):
                in_table = false
            continue

        val fields = parse_csv_fields(trimmed)
        if fields.len() >= 12:
            features.push(FeatureInfo(
                id: fields[0],
                category: fields[1],
                name: fields[2],
                status: fields[10],
                valid: fields[11] == "true"
            ))

    features

fn display_summary(features: [FeatureInfo]):
    var total = 0
    var complete = 0
    var in_progress = 0
    var planned = 0
    var failed = 0

    for f in features:
        if not f.valid: continue
        total = total + 1
        match f.status:
            case "complete": complete = complete + 1
            case "in_progress": in_progress = in_progress + 1
            case "planned": planned = planned + 1
            case "failed": failed = failed + 1
            case _: pass

    val pct = if total > 0: (complete * 100) / total else: 0

    print "Simple Language Specification Coverage"
    print ""
    print "Total features: {total}"
    print "Implemented: {complete} ({pct}%)"
    if in_progress > 0:
        val ip_pct = (in_progress * 100) / total
        print "In Progress: {in_progress} ({ip_pct}%)"
    if planned > 0:
        val pl_pct = (planned * 100) / total
        print "Planned: {planned} ({pl_pct}%)"
    if failed > 0:
        val f_pct = (failed * 100) / total
        print "Failed: {failed} ({f_pct}%)"
    print ""
    print "Overall Coverage: {pct}%"

fn display_by_category(features: [FeatureInfo]):
    # Collect categories
    var cats: [text] = []
    var seen: Dict<text, bool> = {}
    for f in features:
        if f.valid and not seen.contains_key(f.category):
            cats.push(f.category)
            seen[f.category] = true

    print ""
    print "Coverage by Category:"
    print ""

    for cat in cats:
        var total = 0
        var complete = 0
        for f in features:
            if f.valid and f.category == cat:
                total = total + 1
                if f.status == "complete":
                    complete = complete + 1
        val pct = if total > 0: (complete * 100) / total else: 0
        print "  {cat}: {pct}% ({complete}/{total})"

fn display_missing(features: [FeatureInfo]):
    print ""
    print "Missing/Incomplete Features:"
    print ""

    for f in features:
        if f.valid and f.status != "complete":
            val status_label = match f.status:
                case "in_progress": "In Progress"
                case "planned": "Planned"
                case "failed": "Failed"
                case _: f.status
            print "  - {f.name} (ID: {f.id}, Category: {f.category})"
            print "    Status: {status_label}"

fn main() -> i64:
    val args = get_cli_args()

    var by_category = false
    var show_missing = false
    var report_format = "text"

    for arg in args:
        if arg == "-h" or arg == "--help":
            print_help()
            return 0
        elif arg == "--by-category":
            by_category = true
        elif arg == "--missing":
            show_missing = true
        elif arg.starts_with("--report="):
            report_format = arg[9:]

    val features = load_features()
    if features.len() == 0:
        error("spec_coverage", "no features found in {FEATURE_DB_PATH}")
        return 1

    display_summary(features)

    if by_category:
        display_by_category(features)

    if show_missing:
        display_missing(features)

    0
