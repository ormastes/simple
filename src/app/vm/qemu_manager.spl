# QEMU VM Manager
#
# Reusable module for QEMU VM lifecycle management.
# Provides start/stop/exec/copy operations for FreeBSD, Windows, and macOS VMs.
#
# Usage:
#   use app.vm.qemu_manager.{VmConfig, vm_start, vm_stop, vm_exec, vm_copy_to}

extern fn rt_file_read_text(path: text) -> text
extern fn rt_file_exists(path: text) -> bool

use app.io.file_shell.{shell, shell_output, file_write, file_delete}

# ============================================================================
# VM Configuration
# ============================================================================

struct VmConfig:
    name: text
    image_path: text
    ssh_port: i64
    ssh_user: text
    ram_mb: i64
    cpus: i64
    pid_file: text
    extra_args: [text]

fn default_ssh_opts() -> text:
    "-o BatchMode=yes -o NumberOfPasswordPrompts=0 -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null -o ConnectTimeout=5 -o ConnectionAttempts=1 -o LogLevel=ERROR"

# ============================================================================
# VM Lifecycle
# ============================================================================

fn vm_start(config: VmConfig) -> bool:
    # Check if already running
    if vm_is_running(config):
        print "[vm] {config.name} already running"
        return true

    # Build QEMU command
    var cmd = "qemu-system-x86_64"
    cmd = cmd + " -machine type=q35,accel=kvm:tcg"
    cmd = cmd + " -cpu host"
    cmd = cmd + " -smp {config.cpus}"
    cmd = cmd + " -m {config.ram_mb}M"
    cmd = cmd + " -drive file={config.image_path},if=virtio,format=qcow2"
    cmd = cmd + " -netdev user,id=net0,hostfwd=tcp::{config.ssh_port}-:22"
    cmd = cmd + " -device virtio-net-pci,netdev=net0"
    cmd = cmd + " -display none"
    cmd = cmd + " -daemonize"
    cmd = cmd + " -pidfile {config.pid_file}"

    # Add extra platform-specific args
    for arg in config.extra_args:
        cmd = cmd + " " + arg

    print "[vm] Starting {config.name}..."
    val (out, err, exit_code) = shell(cmd)
    if exit_code != 0:
        print "[vm] Error starting {config.name}: {err}"
        return false

    # Wait briefly for PID file
    shell("sleep 2")

    if rt_file_exists(config.pid_file):
        val pid = shell_output("cat {config.pid_file}").trim()
        print "[vm] {config.name} started (PID: {pid})"
        return true

    print "[vm] Error: PID file not created for {config.name}"
    false

fn vm_stop(config: VmConfig) -> bool:
    if not rt_file_exists(config.pid_file):
        print "[vm] {config.name} not running (no PID file)"
        return true

    val pid = shell_output("cat {config.pid_file}").trim()
    val (out, err, exit_code) = shell("kill {pid} 2>/dev/null")
    file_delete(config.pid_file)

    if exit_code == 0:
        print "[vm] {config.name} stopped (PID: {pid})"
        return true

    # Process may already be dead
    print "[vm] {config.name} stop: process {pid} may already be gone"
    true

fn vm_is_running(config: VmConfig) -> bool:
    if not rt_file_exists(config.pid_file):
        return false
    val pid = shell_output("cat {config.pid_file}").trim()
    if pid == "":
        return false
    val (out, err, exit_code) = shell("kill -0 {pid} 2>/dev/null")
    exit_code == 0

# ============================================================================
# SSH Operations
# ============================================================================

fn vm_wait_ssh(config: VmConfig, timeout_secs: i64) -> bool:
    val ssh_opts = default_ssh_opts()
    print "[vm] Waiting for SSH on {config.name} (port {config.ssh_port})..."
    for i in range(1, timeout_secs + 1):
        val (out, err, exit_code) = shell("ssh {ssh_opts} -p {config.ssh_port} {config.ssh_user}@localhost 'echo ready' 2>/dev/null")
        if exit_code == 0:
            print "[vm] SSH ready after {i} seconds"
            return true
        shell("sleep 1")
    print "[vm] SSH timeout after {timeout_secs} seconds"
    false

fn vm_exec(config: VmConfig, command: text) -> (text, text, i64):
    val ssh_opts = default_ssh_opts()
    val cmd = "ssh {ssh_opts} -p {config.ssh_port} {config.ssh_user}@localhost '{command}'"
    shell(cmd)

fn vm_copy_to(config: VmConfig, local: text, remote: text) -> bool:
    val ssh_opts = default_ssh_opts()
    val cmd = "scp {ssh_opts} -P {config.ssh_port} '{local}' {config.ssh_user}@localhost:'{remote}'"
    val (out, err, exit_code) = shell(cmd)
    if exit_code != 0:
        print "[vm] Copy to {config.name} failed: {err}"
        return false
    true

fn vm_copy_from(config: VmConfig, remote: text, local: text) -> bool:
    val ssh_opts = default_ssh_opts()
    val cmd = "scp {ssh_opts} -P {config.ssh_port} {config.ssh_user}@localhost:'{remote}' '{local}'"
    val (out, err, exit_code) = shell(cmd)
    if exit_code != 0:
        print "[vm] Copy from {config.name} failed: {err}"
        return false
    true

# ============================================================================
# Convenience Constructors
# ============================================================================

fn freebsd_config() -> VmConfig:
    val home = shell_output("echo $HOME").trim()
    VmConfig(
        name: "freebsd",
        image_path: "{home}/vms/freebsd/FreeBSD-14.3-RELEASE-amd64.qcow2",
        ssh_port: 2222,
        ssh_user: "root",
        ram_mb: 4096,
        cpus: 4,
        pid_file: "/tmp/freebsd-qemu.pid",
        extra_args: []
    )

fn windows_config() -> VmConfig:
    val home = shell_output("echo $HOME").trim()
    VmConfig(
        name: "windows",
        image_path: "{home}/vms/windows/windows11.qcow2",
        ssh_port: 2223,
        ssh_user: "user",
        ram_mb: 8192,
        cpus: 4,
        pid_file: "/tmp/windows-qemu.pid",
        extra_args: []
    )

fn macos_config() -> VmConfig:
    val home = shell_output("echo $HOME").trim()
    VmConfig(
        name: "macos",
        image_path: "{home}/vms/macos/mac_hdd_ng.img",
        ssh_port: 2224,
        ssh_user: "user",
        ram_mb: 8192,
        cpus: 4,
        pid_file: "/tmp/macos-qemu.pid",
        extra_args: []
    )

export VmConfig, vm_start, vm_stop, vm_is_running, vm_wait_ssh
export vm_exec, vm_copy_to, vm_copy_from
export freebsd_config, windows_config, macos_config, default_ssh_opts
