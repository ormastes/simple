# Proof Checker
#
# Scans verification directories for .lean files, uses Lake to type-check
# each file, counts sorry keywords for pending proofs, and falls back to
# static analysis if Lean 4 is not installed.

use app.io.mod.{shell, file_exists, file_read, dir_walk}
use app.verify.lake_runner.{LakeRunner}

# ============================================================================
# Proof Status
# ============================================================================

enum ProofStatus:
    """Status of a single proof obligation."""
    Verified        # Lean type-checked, no sorry
    Pending         # Contains sorry (proof not completed)
    Failed          # Type-check error
    Skipped         # Not checked (Lean not available, static only)

impl ProofStatus:
    fn to_text() -> text:
        match self:
            case Verified: "verified"
            case Pending: "pending"
            case Failed: "failed"
            case Skipped: "skipped"

    fn is_success() -> bool:
        match self:
            case Verified: true
            case Pending: true
            case _: false

# ============================================================================
# Proof Result
# ============================================================================

struct ProofResult:
    """Result of checking a single file."""
    file_path: text
    status: ProofStatus
    sorry_count: i64
    error_message: text
    theorem_count: i64

impl ProofResult:
    fn summary_line() -> text:
        val status_str = self.status.to_text()
        var detail = ""
        if self.sorry_count > 0:
            detail = " ({self.sorry_count} sorry)"
        if self.error_message.len() > 0:
            detail = "{detail} - {self.error_message}"
        "[{status_str}] {self.file_path}: {self.theorem_count} theorems{detail}"

# ============================================================================
# Check Result (aggregate)
# ============================================================================

struct CheckResult:
    """Aggregate result of checking all files."""
    file_results: [ProofResult]

impl CheckResult:
    fn verified_count() -> i64:
        var count = 0
        for r in self.file_results:
            if r.status == ProofStatus.Verified:
                count = count + 1
        count

    fn pending_count() -> i64:
        var count = 0
        for r in self.file_results:
            if r.status == ProofStatus.Pending:
                count = count + 1
        count

    fn failure_count() -> i64:
        var count = 0
        for r in self.file_results:
            if r.status == ProofStatus.Failed:
                count = count + 1
        count

    fn skipped_count() -> i64:
        var count = 0
        for r in self.file_results:
            if r.status == ProofStatus.Skipped:
                count = count + 1
        count

    fn total_sorry_count() -> i64:
        var count = 0
        for r in self.file_results:
            count = count + r.sorry_count
        count

    fn total_theorem_count() -> i64:
        var count = 0
        for r in self.file_results:
            count = count + r.theorem_count
        count

    fn summary() -> text:
        val total = self.file_results.len()
        val verified = self.verified_count()
        val pending = self.pending_count()
        val failed = self.failure_count()
        val skipped = self.skipped_count()
        val theorems = self.total_theorem_count()
        val sorries = self.total_sorry_count()
        var lines: [text] = []
        lines = lines.push("Proof Check Summary")
        lines = lines.push("===================")
        lines = lines.push("Files checked: {total}")
        lines = lines.push("  Verified:  {verified}")
        lines = lines.push("  Pending:   {pending}")
        lines = lines.push("  Failed:    {failed}")
        lines = lines.push("  Skipped:   {skipped}")
        lines = lines.push("")
        lines = lines.push("Theorems: {theorems}")
        lines = lines.push("Pending proofs (sorry): {sorries}")
        lines.join("\n")

# ============================================================================
# Proof Checker
# ============================================================================

class ProofChecker:
    """Checks Lean proof files for correctness."""
    project_dir: text
    lake: LakeRunner

fn ProofChecker__new(project_dir: text) -> ProofChecker:
    ProofChecker(
        project_dir: project_dir,
        lake: LakeRunner__new(project_dir)
    )

impl ProofChecker:
    fn check_all() -> CheckResult:
        """Check all .lean files in the project directory."""
        val lean_files = _find_lean_files(self.project_dir)
        var results: [ProofResult] = []

        for file_path in lean_files:
            val result = self._check_file(file_path)
            results = results.push(result)

        CheckResult(file_results: results)

    fn _check_file(path: text) -> ProofResult:
        """Check a single .lean file."""
        val content = file_read(path)
        val sorry_count = _count_sorry(content)
        val theorem_count = _count_theorems(content)

        if self.lake.is_available():
            # Use Lake to type-check
            val check_result = self.lake.check_file(path)
            match check_result:
                case Ok(_):
                    val status = if sorry_count > 0:
                        ProofStatus.Pending
                    else:
                        ProofStatus.Verified
                    ProofResult(
                        file_path: path,
                        status: status,
                        sorry_count: sorry_count,
                        error_message: "",
                        theorem_count: theorem_count
                    )
                case Err(msg):
                    ProofResult(
                        file_path: path,
                        status: ProofStatus.Failed,
                        sorry_count: sorry_count,
                        error_message: msg,
                        theorem_count: theorem_count
                    )
        else:
            # Fall back to static analysis
            _static_check(path, content, sorry_count, theorem_count)

    fn summary() -> text:
        """Run check_all and return summary."""
        val result = self.check_all()
        result.summary()

# ============================================================================
# Helpers
# ============================================================================

fn _find_lean_files(dir: text) -> [text]:
    """Find all .lean files in the directory tree."""
    val all_files = dir_walk(dir)
    var lean_files: [text] = []
    for f in all_files:
        if f.ends_with(".lean"):
            lean_files = lean_files.push(f)
    lean_files

fn _count_sorry(content: text) -> i64:
    """Count the number of sorry keywords in content."""
    var count = 0
    val lines = content.split("\n")
    for line in lines:
        val trimmed = line.trim()
        # Skip comments
        if trimmed.starts_with("--"):
            pass
        else:
            # Count occurrences of sorry as a word
            if trimmed.contains("sorry"):
                count = count + 1
    count

fn _count_theorems(content: text) -> i64:
    """Count the number of theorem declarations in content."""
    var count = 0
    val lines = content.split("\n")
    for line in lines:
        val trimmed = line.trim()
        if trimmed.starts_with("theorem "):
            count = count + 1
    count

fn _static_check(path: text, content: text, sorry_count: i64, theorem_count: i64) -> ProofResult:
    """Perform static analysis when Lean is not available."""
    # Check for basic syntax issues
    var error = ""
    val lines = content.split("\n")
    var paren_depth = 0

    for line in lines:
        val trimmed = line.trim()
        if trimmed.starts_with("--"):
            pass
        else:
            for ch in trimmed:
                if ch == "(":
                    paren_depth = paren_depth + 1
                elif ch == ")":
                    paren_depth = paren_depth - 1

    if paren_depth != 0:
        error = "Unbalanced parentheses"

    val status = if error.len() > 0:
        ProofStatus.Failed
    elif sorry_count > 0:
        ProofStatus.Pending
    else:
        ProofStatus.Skipped

    ProofResult(
        file_path: path,
        status: status,
        sorry_count: sorry_count,
        error_message: error,
        theorem_count: theorem_count
    )

# ============================================================================
# Exports
# ============================================================================

export ProofStatus, ProofResult, CheckResult, ProofChecker
