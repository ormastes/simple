#!/usr/bin/env simple
# Generic Syntax Migration Verification
# Checks for remaining [] syntax in generics (excluding intentional examples)
# Migrated from script/verify/verify_generic_syntax.sh

use app.io
use app.utils.colors (success, error, warning)
use std.string.{NL}
use std.log.{info}

export main, verify_generics

# Excluded patterns (intentional examples of deprecated syntax)
val EXCLUDE_PATTERNS = [
    "doc/examples/error_messages_demo.spl",  # Intentional error examples
    "test/fixtures/",                         # Test fixtures may have old syntax
    "MIGRATION_",                             # Migration documentation
    "FAQ.md"                                  # FAQ examples
]

struct VerifyResult:
    total_issues: i64
    stdlib_issues: i64
    compiler_issues: i64

fn main():
    val result = verify_generics()
    if not result:
        exit(1)

fn verify_generics() -> bool:
    """Verify generic syntax migration is complete"""

    print "=== Generic Syntax Migration Verification ==="
    print ""

    info("verify", "Checking Simple stdlib for deprecated generic syntax...")
    print ""

    # Check stdlib files
    val stdlib_issues = check_stdlib_files()

    info("verify", "Checking compiler/runtime Rust code for patterns...")
    print ""

    # Check Rust code
    val compiler_issues = check_compiler_files()

    val total_issues = stdlib_issues + compiler_issues

    # Print summary
    print ""
    print "=== Verification Summary ==="
    print ""

    if total_issues == 0:
        print success("✓ No deprecated generic syntax found!")
        print "All files use the new <> syntax for generics."
        print ""
        print "Breakdown:"
        print "  Simple stdlib: ✓ Clean"
        print "  Compiler code: ✓ Clean"
        return true
    else:
        print error("✗ Found {total_issues} file(s) with potential issues")
        print ""
        print "Breakdown:"
        if stdlib_issues > 0:
            print warning("  Simple stdlib: {stdlib_issues} file(s)")
        else:
            print "  Simple stdlib: ✓ Clean"

        if compiler_issues > 0:
            print warning("  Compiler code: {compiler_issues} file(s)")
        else:
            print "  Compiler code: ✓ Clean"

        print ""
        print "Action required:"
        print "  1. Review files listed above"
        print "  2. Run migration tool: simple migrate --fix-generics <path>"
        print "  3. Or update manually if false positive"
        print ""
        return false

fn check_stdlib_files() -> i64:
    """Check Simple stdlib files for deprecated generic syntax"""
    var issues = 0

    val stdlib_path = "simple/std_lib/src"
    if not is_dir(stdlib_path):
        return 0

    val files = find_spl_files(stdlib_path)

    for file in files:
        if should_exclude(file):
            continue

        val content = file_read(file)
        if content.len() == 0:
            continue

        # Check for patterns like: Type[T], fn name[T], struct Name[T]
        val lines = content.split(NL)
        var found_issues = false

        for i in 0..lines.len():
            val line = lines[i]

            # Look for generic declarations with []
            if has_deprecated_generic_decl(line) or has_deprecated_generic_type(line):
                if not found_issues:
                    print warning("⚠  {file}")
                    found_issues = true

                val line_num = i + 1
                print "  {line_num}: {line.trim()}"

                # Show up to 3 lines
                if i >= 3:
                    break

        if found_issues:
            print ""
            issues = issues + 1

    issues

fn check_compiler_files() -> i64:
    """Check Rust compiler files for patterns that might generate old syntax"""
    var issues = 0

    val compiler_path = "src"
    if not is_dir(compiler_path):
        return 0

    val files = find_rs_files(compiler_path)

    for file in files:
        val content = file_read(file)
        if content.len() == 0:
            continue

        # Check for string literals with [T] pattern in format macros
        if content.contains("[T]") and
           (content.contains("format!") or
            content.contains("write!") or
            content.contains("writeln!")):
            print warning("⚠  {file}")
            print "  Contains string literals with [T] pattern in format macros"
            issues = issues + 1

    issues

fn find_spl_files(directory: text) -> [text]:
    """Find all .spl files recursively"""
    val (stdout, _, code) = process_run("find",
        [directory, "-name", "*.spl", "-type", "f"])

    if code != 0:
        return []

    val lines = stdout.split(NL)
    var files = []
    for line in lines:
        val trimmed = line.trim()
        if trimmed.len() > 0:
            files = files + [trimmed]
    files

fn find_rs_files(directory: text) -> [text]:
    """Find all .rs files recursively"""
    val (stdout, _, code) = process_run("find",
        [directory, "-name", "*.rs", "-type", "f"])

    if code != 0:
        return []

    val lines = stdout.split(NL)
    var files = []
    for line in lines:
        val trimmed = line.trim()
        if trimmed.len() > 0:
            files = files + [trimmed]
    files

fn should_exclude(path: text) -> bool:
    """Check if path should be excluded"""
    for pattern in EXCLUDE_PATTERNS:
        if path.contains(pattern):
            return true
    false

fn has_deprecated_generic_decl(line: text) -> bool:
    """Check for deprecated generic declarations like: fn name[T], struct Foo[T]"""
    val keywords = ["fn ", "struct ", "class ", "enum ", "trait ", "impl "]

    for keyword in keywords:
        if line.contains(keyword):
            # Look for pattern: keyword identifier[
            val keyword_idx = line.find(keyword)
            if keyword_idx >= 0:
                val after_keyword = line.substring(keyword_idx + keyword.len(), line.len())
                # Check for identifier followed by [
                if contains_identifier_bracket(after_keyword):
                    return true

    false

fn has_deprecated_generic_type(line: text) -> bool:
    """Check for deprecated generic type usage like: List[T], Option[T]"""
    val generic_types = ["List[", "Option[", "Result[", "Dict[", "Map[",
                        "Set[", "Vec[", "Promise[", "Future[", "Gpu["]

    for generic_type in generic_types:
        if line.contains(generic_type):
            return true

    false

fn contains_identifier_bracket(text: text) -> bool:
    """Check if text contains pattern: identifier["""
    # Simple heuristic: look for word characters followed by [
    var in_identifier = false
    var identifier_found = false

    for i in 0..text.len():
        val ch = text[i]

        if (ch >= 'a' and ch <= 'z') or (ch >= 'A' and ch <= 'Z') or ch == '_':
            in_identifier = true
            identifier_found = true
        elif ch >= '0' and ch <= '9':
            if in_identifier:
                continue  # Part of identifier
            else:
                in_identifier = false
        elif ch == '[':
            if identifier_found:
                return true
            in_identifier = false
        elif ch == ' ' or ch == '\t':
            if in_identifier:
                # Space after identifier
                identifier_found = false
            in_identifier = false
        else:
            in_identifier = false

    false
