# SDoctest Documentation Generator
#
# Generates doc/test/sdoctest_result.md from test results.

use app.io.mod (file_atomic_write)
use sdoctest.types.*
use std.string.{NL}

# =========================================================================
# Public API
# =========================================================================

fn generate_sdoctest_report(result: SdoctestRunResult, report_path: text):
    var content = "# SDoctest Results{NL}{NL}"
    content = content + "> Auto-generated by sdoctest runner. Do not edit manually.{NL}{NL}"

    # Summary
    content = content + "## Summary{NL}{NL}"
    content = content + "| Metric | Count |{NL}"
    content = content + "|--------|-------|{NL}"
    content = content + "| Total blocks | {result.total} |{NL}"
    content = content + "| Passed | {result.passed} |{NL}"
    content = content + "| Failed | {result.failed} |{NL}"
    content = content + "| Skipped | {result.skipped} |{NL}"
    content = content + "| Errors | {result.errors} |{NL}"
    if result.accepted > 0:
        content = content + "| Accepted (fail-as-success) | {result.accepted} |{NL}"
    content = content + "| Duration | {result.duration_ms}ms |{NL}"
    content = content + NL

    val status_emoji = if result.is_ok(): "PASS" else: "FAIL"
    content = content + "**Status: {status_emoji}**{NL}{NL}"

    # Per-file breakdown
    content = content + "## Files{NL}{NL}"
    if result.accepted > 0:
        content = content + "| File | Total | Passed | Failed | Accepted | Skipped | Duration |{NL}"
        content = content + "|------|-------|--------|--------|----------|---------|----------|{NL}"
        for fr in result.files:
            content = content + "| {fr.source_file} | {fr.total} | {fr.passed} | {fr.failed} | {fr.accepted} | {fr.skipped} | {fr.duration_ms}ms |{NL}"
    else:
        content = content + "| File | Total | Passed | Failed | Skipped | Duration |{NL}"
        content = content + "|------|-------|--------|--------|---------|----------|{NL}"
        for fr in result.files:
            content = content + "| {fr.source_file} | {fr.total} | {fr.passed} | {fr.failed} | {fr.skipped} | {fr.duration_ms}ms |{NL}"

    content = content + NL

    # Failure details
    var has_failures = false
    for fr in result.files:
        for br in fr.blocks:
            if br.status == BlockStatus.Failed or br.status == BlockStatus.Error:
                if not has_failures:
                    content = content + "## Failures{NL}{NL}"
                    has_failures = true
                val status_str = if br.status == BlockStatus.Failed: "FAILED" else: "ERROR"
                content = content + "### {fr.source_file}:{br.block.line_number} ({status_str}){NL}{NL}"
                content = content + "```{NL}{br.error}{NL}```{NL}{NL}"
                if br.stderr.trim() != "":
                    val stderr_preview = truncate_text(br.stderr.trim(), 500)
                    content = content + "**Stderr:**{NL}```{NL}{stderr_preview}{NL}```{NL}{NL}"

    file_atomic_write(report_path, content)

# =========================================================================
# Helpers
# =========================================================================

fn truncate_text(s: text, max_len: i64) -> text:
    if s.len() <= max_len:
        return s
    s[0:max_len] + "... (truncated)"

# =========================================================================
# Exports
# =========================================================================

export generate_sdoctest_report
