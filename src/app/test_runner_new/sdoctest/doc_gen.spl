# SDoctest Documentation Generator
#
# Generates doc/test/sdoctest_result.md from test results.

use app.io.mod (file_atomic_write)
use sdoctest.types.*

# =========================================================================
# Public API
# =========================================================================

fn generate_sdoctest_report(result: SdoctestRunResult, report_path: text):
    var content = "# SDoctest Results\n\n"
    content = content + "> Auto-generated by sdoctest runner. Do not edit manually.\n\n"

    # Summary
    content = content + "## Summary\n\n"
    content = content + "| Metric | Count |\n"
    content = content + "|--------|-------|\n"
    content = content + "| Total blocks | {result.total} |\n"
    content = content + "| Passed | {result.passed} |\n"
    content = content + "| Failed | {result.failed} |\n"
    content = content + "| Skipped | {result.skipped} |\n"
    content = content + "| Errors | {result.errors} |\n"
    if result.accepted > 0:
        content = content + "| Accepted (fail-as-success) | {result.accepted} |\n"
    content = content + "| Duration | {result.duration_ms}ms |\n"
    content = content + "\n"

    val status_emoji = if result.is_ok(): "PASS" else: "FAIL"
    content = content + "**Status: {status_emoji}**\n\n"

    # Per-file breakdown
    content = content + "## Files\n\n"
    if result.accepted > 0:
        content = content + "| File | Total | Passed | Failed | Accepted | Skipped | Duration |\n"
        content = content + "|------|-------|--------|--------|----------|---------|----------|\n"
        for fr in result.files:
            content = content + "| {fr.source_file} | {fr.total} | {fr.passed} | {fr.failed} | {fr.accepted} | {fr.skipped} | {fr.duration_ms}ms |\n"
    else:
        content = content + "| File | Total | Passed | Failed | Skipped | Duration |\n"
        content = content + "|------|-------|--------|--------|---------|----------|\n"
        for fr in result.files:
            content = content + "| {fr.source_file} | {fr.total} | {fr.passed} | {fr.failed} | {fr.skipped} | {fr.duration_ms}ms |\n"

    content = content + "\n"

    # Failure details
    var has_failures = false
    for fr in result.files:
        for br in fr.blocks:
            if br.status == BlockStatus.Failed or br.status == BlockStatus.Error:
                if not has_failures:
                    content = content + "## Failures\n\n"
                    has_failures = true
                val status_str = if br.status == BlockStatus.Failed: "FAILED" else: "ERROR"
                content = content + "### {fr.source_file}:{br.block.line_number} ({status_str})\n\n"
                content = content + "```\n{br.error}\n```\n\n"
                if br.stderr.trim() != "":
                    val stderr_preview = truncate_text(br.stderr.trim(), 500)
                    content = content + "**Stderr:**\n```\n{stderr_preview}\n```\n\n"

    file_atomic_write(report_path, content)

# =========================================================================
# Helpers
# =========================================================================

fn truncate_text(s: text, max_len: i64) -> text:
    if s.len() <= max_len:
        return s
    s[0:max_len] + "... (truncated)"

# =========================================================================
# Exports
# =========================================================================

export generate_sdoctest_report
