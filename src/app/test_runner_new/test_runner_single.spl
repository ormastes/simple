# test_runner_single.spl - Lightweight single-file test entry point
#
# Used when running a single test file: bin/simple test path/to/spec.spl
# Skips database, coverage, doc generation, sdoctest, and parallel overhead.
#
# Imports 6 modules vs test_runner_main.spl's 29+, cutting startup from ~56s to <2s.

use app.io.env_ops.{env_set}
use app.io.cli_ops.{cli_get_args}
use test_runner_types.*
use test_runner_args.parse_test_args
use test_runner_files.{discover_test_files, file_has_di_test_tag, print_discovery_summary}
use test_runner_execute.{run_test_file_interpreter, run_test_file_smf, run_test_file_native, run_test_file_safe_mode, run_test_file_composite}
use test_runner_output.{print_result, print_summary}

# =========================================================================
# Helpers (inlined from test_runner_main.spl to avoid extra import)
# =========================================================================

fn mode_to_str(mode: TestExecutionMode) -> text:
    match mode:
        case TestExecutionMode.Interpreter:
            "interpreter"
        case TestExecutionMode.Smf:
            "smf"
        case TestExecutionMode.Native:
            "native"
        case TestExecutionMode.Composite(spec):
            spec

fn get_cli_args_single() -> [str]:
    val all_args = cli_get_args()
    var args: [str] = []
    var start_idx = 1
    if all_args.len() > 1 and all_args[1].ends_with("test_runner_single.spl"):
        start_idx = 2
    var i = start_idx
    while i < all_args.len():
        args = args.push(all_args[i])
        i = i + 1
    args

# =========================================================================
# Single Test Execution
# =========================================================================

fn run_one_test(file_path: text, options: TestOptions) -> TestFileResult:
    val mode_str = mode_to_str(options.mode)
    env_set("SIMPLE_RUNTIME_MODE", mode_str)

    val is_system = file_path.contains("/system/") or file_path.contains("/feature/")
    if is_system:
        env_set("SIMPLE_SYSTEM_TEST", "1")
    else:
        env_set("SIMPLE_SYSTEM_TEST", "0")
    if is_system and file_has_di_test_tag(file_path):
        env_set("SIMPLE_DI_TEST", "1")
    else:
        env_set("SIMPLE_DI_TEST", "0")

    var effective_options = options
    if options.fuzz_mode:
        val fuzz_timeout = options.fuzz_time_secs + 30
        if fuzz_timeout > effective_options.timeout:
            effective_options.timeout = fuzz_timeout
    if options.chaos_mode:
        var chaos_timeout = options.chaos_trials * 2
        if chaos_timeout < 300:
            chaos_timeout = 300
        if chaos_timeout > effective_options.timeout:
            effective_options.timeout = chaos_timeout

    if effective_options.safe_mode:
        return run_test_file_safe_mode(file_path, effective_options)
    match effective_options.mode:
        case TestExecutionMode.Interpreter:
            run_test_file_interpreter(file_path, effective_options)
        case TestExecutionMode.Smf:
            run_test_file_smf(file_path, effective_options)
        case TestExecutionMode.Native:
            run_test_file_native(file_path, effective_options)
        case TestExecutionMode.Composite(spec):
            run_test_file_composite(file_path, effective_options, spec)

# =========================================================================
# Main Entry Point
# =========================================================================

fn main() -> i64:
    env_set("SIMPLE_TEST_RUNNER_RUST", "1")

    val all_args = get_cli_args_single()

    # Filter out "test" command if present (from CLI dispatch)
    var args: [str] = []
    var skip_first = all_args.len() > 0 and all_args[0] == "test"
    var i = 0
    if skip_first:
        i = 1
    while i < all_args.len():
        args = args.push(all_args[i])
        i = i + 1

    val options = parse_test_args(args)

    val mode_str = mode_to_str(options.mode)
    env_set("SIMPLE_TEST_MODE", mode_str)

    print "Simple Test Runner v0.4.0"
    print ""

    val files = discover_test_files(options.path, options)

    if options.list:
        print_discovery_summary(files, options)
        return 0

    if files.len() == 0:
        print "No test files found in {options.path}"
        return 1

    var results: [TestFileResult] = []
    var total_passed = 0
    var total_failed = 0
    var total_skipped = 0
    var total_pending = 0
    var total_timed_out = 0
    var total_duration_ms = 0

    for file_path in files:
        val result = run_one_test(file_path, options)
        print_result(result, options.format)
        results = results.push(result)
        total_passed = total_passed + result.passed
        total_failed = total_failed + result.failed
        total_skipped = total_skipped + result.skipped
        total_pending = total_pending + result.pending
        if result.timed_out:
            total_timed_out = total_timed_out + 1
        total_duration_ms = total_duration_ms + result.duration_ms
        if options.fail_fast and (result.failed > 0 or result.timed_out):
            break

    val run_result = TestRunResult(
        files: results,
        total_passed: total_passed,
        total_failed: total_failed,
        total_skipped: total_skipped,
        total_pending: total_pending,
        total_timed_out: total_timed_out,
        total_duration_ms: total_duration_ms
    )

    print ""
    print_summary(run_result, options.format)

    if run_result.is_ok():
        return 0
    return 1
