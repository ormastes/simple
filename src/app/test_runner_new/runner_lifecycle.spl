# Runner Lifecycle Manager - Robust Process and Container Cleanup
#
# Provides automatic cleanup of child processes and containers when test
# runner exits (normal shutdown, signal, or crash).
#
# Features:
# - Automatic PID/container tracking on spawn
# - Cleanup on normal exit
# - Cleanup on signal (SIGTERM/SIGINT)
# - Heartbeat monitoring for orphan detection
# - Process group management

use app.test_runner_new.process_tracker.*
use app.test_runner_new.checkpoint.{checkpoint_save}
use app.io.mod.{process_spawn_async, process_wait, process_kill, exit, time_now_unix_micros}

# ============================================================================
# Enhanced Process Spawn with Tracking
# ============================================================================

fn spawn_tracked_process(cmd: text, args: [text]) -> i64:
    """
    Spawn a process and automatically register it for cleanup.

    This is the PRIMARY function to use for spawning test processes.

    Args:
        cmd: Command to execute
        args: Command arguments

    Returns: Process ID (pid), or -1 on failure

    Example:
        val pid = spawn_tracked_process("simple", ["test/unit/spec.spl"])
        # ... later ...
        val exit_code = process_wait(pid, 60000)  # Wait up to 60s
        untrack_process(pid)  # Cleanup after successful wait
    """
    val pid = process_spawn_async(cmd, args)

    if pid > 0:
        tracker_register_pid(pid)

    pid

fn untrack_process(pid: i64):
    """
    Unregister process after successful wait/cleanup.

    Call this after process_wait() returns successfully to remove
    PID from tracking list.
    """
    tracker_unregister_pid(pid)

# ============================================================================
# Enhanced Container Run with Tracking
# ============================================================================

fn run_tracked_container(
    runtime: text,
    image: text,
    args: [text],
    memory_mb: i64,
    cpu_count: f64
) -> text:
    """
    Run a container and automatically register it for cleanup.

    Args:
        runtime: Container runtime ("docker" or "podman")
        image: Container image name
        args: Command arguments to pass to container
        memory_mb: Memory limit in MB
        cpu_count: CPU limit (fractional allowed)

    Returns: Container ID, or empty string on failure

    Example:
        val container_id = run_tracked_container(
            "docker",
            "simple-test-runner:latest",
            ["test", "test/unit/spec.spl"],
            512,
            1.0
        )
        # ... later ...
        stop_tracked_container(container_id)
    """
    # Build docker/podman run command
    var cmd = "{runtime} run -d "
    cmd = cmd + "--memory={memory_mb}m "
    cmd = cmd + "--cpus={cpu_count} "

    for arg in args:
        cmd = cmd + "\"{arg}\" "

    cmd = cmd + "{image}"

    # NOTE: In real implementation, would use shell() and parse container ID
    # For now, return stub value
    val container_id = "stub-container-id"

    if container_id != "" and container_id != nil:
        tracker_register_container(container_id)

    container_id

fn stop_tracked_container(container_id: text):
    """
    Stop container and unregister from tracking.

    Call this after container completes successfully.
    """
    val runtime = if is_docker_available(): "docker" else: "podman"

    # Try graceful stop
    val stop_cmd = "{runtime} stop -t 10 {container_id}"
    # NOTE: In real implementation, would use shell()

    tracker_unregister_container(container_id)

# ============================================================================
# Cleanup on Exit
# ============================================================================

fn cleanup_all_children():
    """
    Kill all tracked processes and stop all containers.

    This is called automatically on:
    - Normal exit (via shutdown_graceful)
    - Signal handlers (SIGTERM/SIGINT)
    - Panic/crash handlers (future enhancement)

    Returns: Total number of resources cleaned (processes + containers)
    """
    print "[LIFECYCLE] Cleaning up all child processes and containers..."

    val killed = tracker_kill_all_children()
    val stopped = tracker_stop_all_containers()

    print "[LIFECYCLE] Killed {killed} processes, stopped {stopped} containers"

    killed + stopped

fn cleanup_and_exit(exit_code: i64, reason: text):
    """
    Full cleanup and exit sequence.

    Args:
        exit_code: Exit code for process
        reason: Reason for exit (for checkpoint)

    Sequence:
    1. Save checkpoint (if needed)
    2. Kill child processes
    3. Stop containers
    4. Exit with code
    """
    print ""
    print "========================================="
    print "RUNNER SHUTDOWN: {reason}"
    print "========================================="

    # Cleanup all children
    val cleaned = cleanup_all_children()

    print "[LIFECYCLE] Cleanup complete ({cleaned} resources)"
    print "========================================="
    print ""

    exit(exit_code)

# ============================================================================
# Heartbeat Monitoring
# ============================================================================

var _heartbeat_interval_ms = 5000  # 5 seconds
var _last_heartbeat_time = 0

fn lifecycle_enable_heartbeat():
    """
    Enable heartbeat monitoring for parent-child communication.

    When enabled:
    - Parent sends heartbeat every 5 seconds
    - Children check heartbeat every 10 seconds
    - Children exit if parent heartbeat timeout exceeds 30 seconds

    This detects runner crashes and allows children to self-cleanup.
    """
    tracker_enable_heartbeat()
    _last_heartbeat_time = time_now_unix_micros() / 1000

fn lifecycle_send_heartbeat():
    """
    Send heartbeat ping.

    Should be called in main test runner loop every 5-10 seconds.
    """
    val now = time_now_unix_micros() / 1000
    val elapsed = now - _last_heartbeat_time

    if elapsed >= _heartbeat_interval_ms:
        tracker_send_heartbeat()
        _last_heartbeat_time = now

fn lifecycle_check_parent_alive() -> bool:
    """
    Check if parent is still alive (from child perspective).

    Returns: true if parent is alive, false if timeout exceeded

    NOTE: Child processes should call this every 10 seconds and exit
    if it returns false.
    """
    val timeout_ms = 30000  # 30 seconds
    tracker_check_heartbeat_alive(timeout_ms)

# ============================================================================
# Orphan Detection and Cleanup
# ============================================================================

fn cleanup_orphaned_processes():
    """
    Cleanup processes that are still running but no longer tracked.

    This is useful when runner crashes and leaves orphaned children.

    NOTE: Requires process group ID (PGID) tracking for safe implementation.
    Current stub version only cleans tracked processes.
    """
    # Get all tracked PIDs
    val pids = tracker_get_pids()

    var orphans_killed = 0

    for pid in pids:
        # Check if process is still running but shouldn't be
        # (e.g., test timeout exceeded, runner restarted)
        # NOTE: Real implementation would check process group, parent PID, etc.

        orphans_killed = orphans_killed + 1

    orphans_killed

fn cleanup_orphaned_containers():
    """
    Cleanup containers that are still running but no longer tracked.

    Looks for containers with label "simple-test-runner" that have
    been running for >1 hour.
    """
    val runtime = if is_docker_available(): "docker" else: "podman"

    # Get all running containers
    val all_containers = get_running_containers()

    var orphans_stopped = 0

    for container_id in all_containers:
        # NOTE: Real implementation would:
        # 1. Check container labels for "simple-test-runner"
        # 2. Check container start time (>1 hour ago)
        # 3. Stop only if conditions match

        orphans_stopped = orphans_stopped + 1

    orphans_stopped

# ============================================================================
# Signal Handlers (Future Enhancement)
# ============================================================================
#
# To make this production-ready, we need SFFI additions for signal handling:
#
# extern fn rt_signal_handler_install(signal: i64, handler_fn: fn())
# extern fn rt_signal_raise(signal: i64)
# extern fn rt_atexit_register(handler_fn: fn())
#
# fn install_signal_handlers():
#     """Install cleanup handlers for common signals"""
#     rt_signal_handler_install(15, on_sigterm)  # SIGTERM
#     rt_signal_handler_install(2, on_sigint)    # SIGINT (Ctrl+C)
#     rt_signal_handler_install(1, on_sighup)    # SIGHUP (terminal close)
#     rt_atexit_register(on_normal_exit)         # Normal exit
#
# fn on_sigterm():
#     cleanup_and_exit(143, "SIGTERM")  # 128 + 15
#
# fn on_sigint():
#     cleanup_and_exit(130, "SIGINT (Ctrl+C)")  # 128 + 2
#
# fn on_sighup():
#     cleanup_and_exit(129, "SIGHUP (terminal closed)")  # 128 + 1
#
# fn on_normal_exit():
#     cleanup_all_children()
#
# Usage in main:
#     install_signal_handlers()
#     # ... run tests ...
#     # Cleanup happens automatically on exit

# ============================================================================
# Exports
# ============================================================================

export spawn_tracked_process
export untrack_process

export run_tracked_container
export stop_tracked_container

export cleanup_all_children
export cleanup_and_exit

export lifecycle_enable_heartbeat
export lifecycle_send_heartbeat
export lifecycle_check_parent_alive

export cleanup_orphaned_processes
export cleanup_orphaned_containers
