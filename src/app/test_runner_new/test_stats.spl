# Test Statistics Module
#
# Centralized statistics functions: percentiles, outlier detection,
# regression detection, and descriptive statistics.

# =========================================================================
# Types
# =========================================================================

struct TimingStats:
    mean: f64
    median: f64
    std_dev: f64
    cv_pct: f64
    min: f64
    max: f64
    iqr: f64
    p25: f64
    p50: f64
    p75: f64
    p90: f64
    p95: f64
    p99: f64
    count: i64

struct OutlierResult:
    inliers: List<f64>
    outliers: List<f64>

enum OutlierMethod:
    IQR
    MAD
    ZScore

# =========================================================================
# Core Statistics
# =========================================================================

fn compute_statistics(samples: List<f64>) -> TimingStats:
    if samples.len() == 0:
        return TimingStats(
            mean: 0.0, median: 0.0, std_dev: 0.0, cv_pct: 0.0,
            min: 0.0, max: 0.0, iqr: 0.0,
            p25: 0.0, p50: 0.0, p75: 0.0, p90: 0.0, p95: 0.0, p99: 0.0,
            count: 0
        )

    val sorted = sort_f64(samples)
    val n = sorted.len()
    val mean_val = compute_mean(sorted)
    val std_val = compute_std_dev(sorted, mean_val)
    val cv = if mean_val > 0.001: (std_val / mean_val) * 100.0 else: 0.0
    val p25 = percentile_at(sorted, 0.25)
    val p50 = percentile_at(sorted, 0.50)
    val p75 = percentile_at(sorted, 0.75)
    val p90 = percentile_at(sorted, 0.90)
    val p95 = percentile_at(sorted, 0.95)
    val p99 = percentile_at(sorted, 0.99)

    TimingStats(
        mean: mean_val,
        median: p50,
        std_dev: std_val,
        cv_pct: cv,
        min: sorted[0],
        max: sorted[n - 1],
        iqr: p75 - p25,
        p25: p25,
        p50: p50,
        p75: p75,
        p90: p90,
        p95: p95,
        p99: p99,
        count: n
    )

fn compute_mean(samples: List<f64>) -> f64:
    if samples.len() == 0:
        return 0.0
    var sum = 0.0
    for s in samples:
        sum = sum + s
    sum / samples.len().to_float()

fn compute_std_dev(samples: List<f64>, mean: f64) -> f64:
    if samples.len() < 2:
        return 0.0
    var sum_sq = 0.0
    for s in samples:
        val diff = s - mean
        sum_sq = sum_sq + diff * diff
    val variance = sum_sq / (samples.len() - 1).to_float()
    sqrt_f64(variance)

fn sqrt_f64(x: f64) -> f64:
    if x <= 0.0:
        return 0.0
    # Newton's method
    var guess = x / 2.0
    if guess < 1.0:
        guess = 1.0
    var i = 0
    while i < 20:
        val next = (guess + x / guess) / 2.0
        if abs_f64(next - guess) < 0.0000001:
            return next
        guess = next
        i = i + 1
    guess

fn abs_f64(x: f64) -> f64:
    if x < 0.0:
        return 0.0 - x
    x

# =========================================================================
# Percentile Computation
# =========================================================================

fn compute_percentiles(samples: List<f64>) -> (f64, f64, f64, f64):
    if samples.len() == 0:
        return (0.0, 0.0, 0.0, 0.0)
    if samples.len() == 1:
        val v = samples[0]
        return (v, v, v, v)
    val sorted = sort_f64(samples)
    val p50 = percentile_at(sorted, 0.50)
    val p90 = percentile_at(sorted, 0.90)
    val p95 = percentile_at(sorted, 0.95)
    val p99 = percentile_at(sorted, 0.99)
    (p50, p90, p95, p99)

fn percentile_at(sorted: List<f64>, p: f64) -> f64:
    val n = sorted.len()
    if n == 0:
        return 0.0
    if n == 1:
        return sorted[0]
    val rank = p * (n - 1).to_float()
    val lower = rank.to_int()
    val upper = lower + 1
    if upper >= n:
        return sorted[n - 1]
    val frac = rank - lower.to_float()
    sorted[lower] * (1.0 - frac) + sorted[upper] * frac

# =========================================================================
# Sorting
# =========================================================================

fn sort_f64(items: List<f64>) -> List<f64>:
    var result: List<f64> = []
    for item in items:
        result.push(item)
    var i = 1
    while i < result.len():
        val key = result[i]
        var j = i - 1
        while j >= 0 and result[j] > key:
            result[j + 1] = result[j]
            j = j - 1
        result[j + 1] = key
        i = i + 1
    result

# =========================================================================
# Outlier Detection
# =========================================================================

fn detect_outliers(samples: List<f64>, method: OutlierMethod) -> OutlierResult:
    match method:
        case OutlierMethod.IQR: detect_outliers_iqr(samples, 1.5)
        case OutlierMethod.MAD: detect_outliers_mad(samples)
        case OutlierMethod.ZScore: detect_outliers_zscore(samples)

fn detect_outliers_iqr(samples: List<f64>, multiplier: f64) -> OutlierResult:
    if samples.len() < 4:
        return OutlierResult(inliers: samples, outliers: [])
    val sorted = sort_f64(samples)
    val q1 = percentile_at(sorted, 0.25)
    val q3 = percentile_at(sorted, 0.75)
    val iqr = q3 - q1
    val lower_bound = q1 - multiplier * iqr
    val upper_bound = q3 + multiplier * iqr
    var inliers: List<f64> = []
    var outliers: List<f64> = []
    for v in sorted:
        if v >= lower_bound and v <= upper_bound:
            inliers.push(v)
        else:
            outliers.push(v)
    if inliers.len() == 0:
        return OutlierResult(inliers: samples, outliers: [])
    OutlierResult(inliers: inliers, outliers: outliers)

fn detect_outliers_mad(samples: List<f64>) -> OutlierResult:
    if samples.len() < 4:
        return OutlierResult(inliers: samples, outliers: [])
    val sorted = sort_f64(samples)
    val median = percentile_at(sorted, 0.50)
    # Compute MAD (Median Absolute Deviation)
    var abs_devs: List<f64> = []
    for v in sorted:
        abs_devs.push(abs_f64(v - median))
    val sorted_devs = sort_f64(abs_devs)
    val mad = percentile_at(sorted_devs, 0.50)
    # Modified Z-score threshold: 3.5
    val threshold = 3.5
    val scale = if mad > 0.001: mad else: 0.001
    var inliers: List<f64> = []
    var outliers: List<f64> = []
    for v in sorted:
        val modified_z = 0.6745 * abs_f64(v - median) / scale
        if modified_z <= threshold:
            inliers.push(v)
        else:
            outliers.push(v)
    if inliers.len() == 0:
        return OutlierResult(inliers: samples, outliers: [])
    OutlierResult(inliers: inliers, outliers: outliers)

fn detect_outliers_zscore(samples: List<f64>) -> OutlierResult:
    if samples.len() < 4:
        return OutlierResult(inliers: samples, outliers: [])
    val mean_val = compute_mean(samples)
    val std_val = compute_std_dev(samples, mean_val)
    if std_val < 0.001:
        return OutlierResult(inliers: samples, outliers: [])
    val threshold = 3.0
    var inliers: List<f64> = []
    var outliers: List<f64> = []
    for v in samples:
        val z = abs_f64(v - mean_val) / std_val
        if z <= threshold:
            inliers.push(v)
        else:
            outliers.push(v)
    if inliers.len() == 0:
        return OutlierResult(inliers: samples, outliers: [])
    OutlierResult(inliers: inliers, outliers: outliers)

# =========================================================================
# Regression Detection
# =========================================================================

fn has_regression(new_value: f64, baseline_mean: f64, baseline_std_dev: f64, threshold: f64) -> bool:
    if baseline_mean < 0.001:
        return false
    val z = (new_value - baseline_mean) / (if baseline_std_dev > 0.001: baseline_std_dev else: baseline_mean * 0.1)
    z > threshold

fn has_significant_change(new_value: f64, baseline: f64, threshold_pct: f64) -> bool:
    if baseline < 0.001:
        return false
    val change_pct = abs_f64(new_value - baseline) / baseline * 100.0
    change_pct > threshold_pct

# =========================================================================
# Flaky Detection
# =========================================================================

fn detect_flaky_test(total_runs: i64, last_10_runs: text, failure_rate_pct: f64) -> bool:
    if total_runs < 5:
        return false
    if failure_rate_pct < 5.0 or failure_rate_pct > 95.0:
        return false
    # Check last_10_runs has both pass and fail
    val has_pass = last_10_runs.contains("pass")
    val has_fail = last_10_runs.contains("fail")
    has_pass and has_fail

export TimingStats, OutlierResult, OutlierMethod
export compute_statistics, compute_mean, compute_std_dev, sqrt_f64, abs_f64
export compute_percentiles, percentile_at, sort_f64
export detect_outliers, detect_outliers_iqr, detect_outliers_mad, detect_outliers_zscore
export has_regression, has_significant_change
export detect_flaky_test
