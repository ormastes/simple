# Documentation Generator
#
# Generates markdown reports from test results and feature database.
# Output files:
#   - doc/test/test_result.md    (test results summary)
#   - doc/feature/feature.md     (feature index)
#   - doc/feature/pending_feature.md (incomplete features)
#   - doc/feature/category/*.md  (per-category details)

use app.io.mod (file_atomic_write, dir_create_all, time_now_unix_micros)
use test_db_types.*
use test_db_compat.TestDatabase  # Using compatibility layer
use lib.database.feature.{FeatureDatabase, Feature, FeatureStatus, status_to_string}

# Helper: Get feature status as string for compatibility
fn feature_status_str(f: Feature) -> text:
    status_to_string(f.pure_status)

# =========================================================================
# Test Result Report
# =========================================================================

fn generate_test_result_md(db: TestDatabase) -> text:
    var lines: [text] = []
    lines.push("# Test Results")
    lines.push("")
    lines.push("*Auto-generated by Simple test runner (unified database)*")
    lines.push("")

    # Summary - use query API
    val (total_tests, passed, failed, skipped) = db.test_count_by_status()

    lines.push("## Summary")
    lines.push("")
    lines.push("| Metric | Count |")
    lines.push("|--------|-------|")
    lines.push("| Total | {total_tests} |")
    lines.push("| Passed | {passed} |")
    lines.push("| Failed | {failed} |")
    lines.push("| Skipped | {skipped} |")
    lines.push("")

    # Flaky tests section - use query API
    val flaky_names = db.flaky_test_names()
    if flaky_names.len() > 0:
        lines.push("## Flaky Tests")
        lines.push("")
        lines.push("Tests detected as flaky (high variance in execution time):")
        lines.push("")
        for name in flaky_names:
            lines.push("- {name}")
        lines.push("")

    # Recent runs - use query API
    val recent_runs = db.list_runs("")
    if recent_runs.len() > 0:
        lines.push("## Recent Runs")
        lines.push("")
        lines.push("| Run ID | Status | Tests | Passed | Failed | Timed Out |")
        lines.push("|--------|--------|-------|--------|--------|-----------|")
        var count = 0
        var i = recent_runs.len() - 1
        while i >= 0 and count < 10:
            val r = recent_runs[i]
            lines.push("| {r.run_id} | {r.status} | {r.test_count} | {r.passed} | {r.failed} | {r.timed_out} |")
            count = count + 1
            i = i - 1
        lines.push("")

    # Test details - use query API
    val all_tests = db.all_test_info()
    if all_tests.len() > 0:
        lines.push("## Test Details")
        lines.push("")
        lines.push("| Test | Status | Runs | Mean (ms) | p50 (ms) |")
        lines.push("|------|--------|------|-----------|----------|")
        for t in all_tests:
            if t.total_runs > 0:
                val mean_str = "{t.mean_duration}"
                val p50_str = "{t.p50_duration}"
                lines.push("| {t.test_name} | {t.status} | {t.total_runs} | {mean_str} | {p50_str} |")
        lines.push("")

    # Slowest tests (p50 > 1000ms)
    var slow_tests = all_tests.filter(\t: t.p50_duration > 1000.0)
    if slow_tests.len() > 0:
        lines.push("## Slowest Tests (p50 > 1s)")
        lines.push("")
        lines.push("| Test | p50 (ms) | Mean (ms) | Runs |")
        lines.push("|------|----------|-----------|------|")
        var slow_count = 0
        for t in slow_tests:
            if slow_count >= 20:
                break
            val p50_str = "{t.p50_duration}"
            val mean_str = "{t.mean_duration}"
            lines.push("| {t.test_name} | {p50_str} | {mean_str} | {t.total_runs} |")
            slow_count = slow_count + 1
        lines.push("")

    # Failed tests
    val failed_tests = db.tests_by_status("failed")
    if failed_tests.len() > 0:
        lines.push("## Failed Tests")
        lines.push("")
        for t in failed_tests:
            lines.push("- {t.test_name}")
        lines.push("")

    lines.join("\n")

# =========================================================================
# Feature Index Report
# =========================================================================

fn generate_feature_md(fdb: FeatureDatabase) -> text:
    var lines: [text] = []
    lines.push("# Feature Index")
    lines.push("")
    lines.push("*Auto-generated by Simple test runner*")
    lines.push("")

    val categories = fdb.all_categories()
    lines.push("| Category | Total | Complete | Failed | Planned | Ignored |")
    lines.push("|----------|-------|----------|--------|---------|---------|")

    for cat in categories:
        val features = fdb.features_by_category(cat)
        var complete = 0
        var failed = 0
        var planned = 0
        var ignored = 0
        for f in features:
            val status = feature_status_str(f)
            match status:
                case "done": complete = complete + 1
                case "failed": failed = failed + 1
                case "planned": planned = planned + 1
                case "in_progress": planned = planned + 1
                case _: ()
        val total = features.len()
        val safe_name = cat.replace(" ", "_")
        lines.push("| [{cat}](category/{safe_name}.md) | {total} | {complete} | {failed} | {planned} | {ignored} |")

    lines.push("")
    lines.join("\n")

# =========================================================================
# H9: Pending Feature Report (category grouping + priority emoji)
# =========================================================================

fn generate_pending_feature_md(fdb: FeatureDatabase) -> text:
    var lines: [text] = []
    lines.push("# Pending Features")
    lines.push("")
    lines.push("*Auto-generated by Simple test runner*")
    lines.push("")

    val total = fdb.all_features().len()
    val complete = fdb.count_by_status(FeatureStatus.Done)
    val failed = fdb.count_by_status(FeatureStatus.Failed)
    val in_progress = fdb.count_by_status(FeatureStatus.InProgress)
    val planned = fdb.count_by_status(FeatureStatus.Planned)
    val ignored = 0  # No ignored status in unified DB yet

    # Overall completion percentage
    val pending_total = total - complete - ignored
    val completion_pct = if total > 0: (complete * 100) / total else: 0

    lines.push("## Summary")
    lines.push("")
    lines.push("**Completion: {completion_pct}%** ({complete}/{total} features)")
    lines.push("")
    lines.push("| Status | Count | Priority |")
    lines.push("|--------|-------|----------|")
    lines.push("| Failed | {failed} | Critical |")
    lines.push("| In Progress | {in_progress} | High |")
    lines.push("| Planned | {planned} | Medium |")
    lines.push("| Ignored | {ignored} | Low |")
    lines.push("| **Total Pending** | **{pending_total}** | |")
    lines.push("")

    # Progress by category table
    val categories = fdb.all_categories()
    lines.push("## Progress by Category")
    lines.push("")
    lines.push("| Category | Complete | Failed | In Progress | Planned | Total | % |")
    lines.push("|----------|----------|--------|-------------|---------|-------|---|")
    for cat in categories:
        val features = fdb.features_by_category(cat)
        var cat_complete = 0
        var cat_failed = 0
        var cat_in_progress = 0
        var cat_planned = 0
        for f in features:
            val status = feature_status_str(f)
            match status:
                case "done": cat_complete = cat_complete + 1
                case "failed": cat_failed = cat_failed + 1
                case "in_progress": cat_in_progress = cat_in_progress + 1
                case "planned": cat_planned = cat_planned + 1
                case _: ()
        val cat_total = features.len()
        val cat_pct = if cat_total > 0: (cat_complete * 100) / cat_total else: 0
        lines.push("| {cat} | {cat_complete} | {cat_failed} | {cat_in_progress} | {cat_planned} | {cat_total} | {cat_pct}% |")
    lines.push("")

    # Failed features (critical) with priority emoji
    if failed > 0:
        lines.push("## Failed Features")
        lines.push("")
        for cat in categories:
            var cat_failed_features: [Feature] = []
            for f in fdb.features_by_category(cat):
                if feature_status_str(f) == "failed":
                    cat_failed_features.push(f)
            if cat_failed_features.len() > 0:
                lines.push("### {cat}")
                lines.push("")
                for f in cat_failed_features:
                    val spec_link = if f.spec_file != "": " ([spec]({f.spec_file}))" else: ""
                    lines.push("- **{f.id}** {f.name}{spec_link}")
                lines.push("")

    # In progress features
    if in_progress > 0:
        lines.push("## In Progress Features")
        lines.push("")
        for cat in categories:
            var cat_ip_features: [Feature] = []
            for f in fdb.features_by_category(cat):
                if feature_status_str(f) == "in_progress":
                    cat_ip_features.push(f)
            if cat_ip_features.len() > 0:
                lines.push("### {cat}")
                lines.push("")
                for f in cat_ip_features:
                    val spec_link = if f.spec_file != "": " ([spec]({f.spec_file}))" else: ""
                    lines.push("- **{f.id}** {f.name}{spec_link}")
                lines.push("")

    # Planned features
    if planned > 0:
        lines.push("## Planned Features")
        lines.push("")
        for cat in categories:
            var cat_planned_features: [Feature] = []
            for f in fdb.features_by_category(cat):
                if feature_status_str(f) == "planned":
                    cat_planned_features.push(f)
            if cat_planned_features.len() > 0:
                lines.push("### {cat}")
                lines.push("")
                for f in cat_planned_features:
                    val spec_link = if f.spec_file != "": " ([spec]({f.spec_file}))" else: ""
                    lines.push("- **{f.id}** {f.name}{spec_link}")
                lines.push("")

    lines.join("\n")

# =========================================================================
# H10: Category Reports (with subcategory hierarchy)
# =========================================================================

fn generate_category_md(fdb: FeatureDatabase, category: text) -> text:
    var lines: [text] = []
    lines.push("# {category}")
    lines.push("")

    val features = fdb.features_by_category(category)

    # H10: Detect subcategories (dot-separated)
    var subcategories: Dict<text, bool> = {}
    for f in features:
        val parts = f.id.split(".")
        if parts.len() >= 2:
            subcategories[parts[0]] = true

    # Generate subcategory links if present
    if subcategories.len() > 1:
        lines.push("## Subcategories")
        lines.push("")
        for subcat in subcategories.keys():
            lines.push("- [{subcat}](#{subcat})")
        lines.push("")

    lines.push("| ID | Feature | Description | Pure | Hybrid | LLVM | Status | Spec |")
    lines.push("|----|---------|-------------|------|--------|------|--------|------|")

    for f in features:
        val pure = status_to_string(f.pure_status)
        val hybrid = status_to_string(f.hybrid_status)
        val llvm = status_to_string(f.llvm_status)
        val status = feature_status_str(f)
        val sb = status_badge(status)
        # Spec links with relative path
        val spec_link = if f.spec_file != "": "[spec](../../{f.spec_file})" else: ""
        lines.push("| <a id=\"feature-{f.id}\"></a>{f.id} | {f.name} | {f.description} | {pure} | {hybrid} | {llvm} | {sb} | {spec_link} |")

    lines.push("")
    lines.join("\n")

fn mode_badge(mode: text) -> text:
    if mode == "supported":
        return "supported"
    "not_supported"

fn status_badge(status: text) -> text:
    match status:
        case "done": "âœ… done"
        case "failed": "âŒ **FAILED**"
        case "in_progress": "ğŸ”¨ in_progress"
        case "planned": "ğŸ“‹ planned"
        case "blocked": "ğŸš« blocked"
        case _: status

# =========================================================================
# Generate All Docs
# =========================================================================

fn generate_all_docs(db: TestDatabase, fdb: FeatureDatabase):
    # Test result documentation (now using unified database query API)
    val test_result = generate_test_result_md(db)
    file_atomic_write("doc/test/test_result.md", test_result)

    # Feature documentation
    val feature_md = generate_feature_md(fdb)
    file_atomic_write("doc/feature/feature.md", feature_md)

    val pending_md = generate_pending_feature_md(fdb)
    file_atomic_write("doc/feature/pending_feature.md", pending_md)

    # Per-category feature docs
    dir_create_all("doc/feature/category")
    val categories = fdb.categories()
    for cat in categories:
        val cat_md = generate_category_md(fdb, cat)
        val safe_name = cat.replace(" ", "_")
        file_atomic_write("doc/feature/category/{safe_name}.md", cat_md)

export generate_test_result_md, generate_feature_md
export generate_pending_feature_md, generate_category_md
export generate_all_docs
