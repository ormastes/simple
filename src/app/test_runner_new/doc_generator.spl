# Documentation Generator
#
# Generates markdown reports from test results and feature database.
# Output files:
#   - doc/test/test_result.md    (test results summary)
#   - doc/feature/feature.md     (feature index)
#   - doc/feature/pending_feature.md (incomplete features)
#   - doc/feature/category/*.md  (per-category details)

extern fn rt_file_atomic_write(path: text, content: text) -> bool
extern fn rt_dir_create_all(path: text) -> bool
extern fn rt_time_now_unix_micros() -> i64

use test_db_types.*
use test_db_core.TestDatabase
use feature_db.{FeatureDatabase, FeatureRecord}

# =========================================================================
# Test Result Report
# =========================================================================

fn generate_test_result_md(db: TestDatabase) -> text:
    var lines: List<text> = []
    lines.push("# Test Results")
    lines.push("")
    lines.push("*Auto-generated by Simple test runner*")
    lines.push("")

    # Summary
    var total_tests = db.tests.len()
    var passed = 0
    var failed = 0
    var skipped = 0

    for t in db.tests:
        val status = db.interner.get(t.status_str)
        if status == "passed":
            passed = passed + 1
        elif status == "failed":
            failed = failed + 1
        elif status == "skipped" or status == "ignored":
            skipped = skipped + 1

    lines.push("## Summary")
    lines.push("")
    lines.push("| Metric | Count |")
    lines.push("|--------|-------|")
    lines.push("| Total | {total_tests} |")
    lines.push("| Passed | {passed} |")
    lines.push("| Failed | {failed} |")
    lines.push("| Skipped | {skipped} |")
    lines.push("")

    # Recent runs
    if db.test_runs.len() > 0:
        lines.push("## Recent Runs")
        lines.push("")
        lines.push("| Run ID | Status | Tests | Passed | Failed | Timed Out |")
        lines.push("|--------|--------|-------|--------|--------|-----------|")
        var count = 0
        var i = db.test_runs.len() - 1
        while i >= 0 and count < 10:
            val r = db.test_runs[i]
            lines.push("| {r.run_id} | {r.status} | {r.test_count} | {r.passed} | {r.failed} | {r.timed_out} |")
            count = count + 1
            i = i - 1
        lines.push("")

    # Failed tests
    var failed_tests: List<text> = []
    var idx = 0
    for t in db.tests:
        val status = db.interner.get(t.status_str)
        if status == "failed":
            val name = db.interner.get(t.name_str)
            failed_tests.push(name)
        idx = idx + 1

    if failed_tests.len() > 0:
        lines.push("## Failed Tests")
        lines.push("")
        for name in failed_tests:
            lines.push("- {name}")
        lines.push("")

    lines.join("\n")

# =========================================================================
# Feature Index Report
# =========================================================================

fn generate_feature_md(fdb: FeatureDatabase) -> text:
    var lines: List<text> = []
    lines.push("# Feature Index")
    lines.push("")
    lines.push("*Auto-generated by Simple test runner*")
    lines.push("")

    val categories = fdb.categories()
    lines.push("| Category | Total | Complete | Failed | Planned | Ignored |")
    lines.push("|----------|-------|----------|--------|---------|---------|")

    for cat in categories:
        val features = fdb.features_by_category(cat)
        var complete = 0
        var failed = 0
        var planned = 0
        var ignored = 0
        for f in features:
            match f.status:
                case "complete": complete = complete + 1
                case "failed": failed = failed + 1
                case "planned": planned = planned + 1
                case "in_progress": planned = planned + 1
                case "ignored": ignored = ignored + 1
                case _: ()
        val total = features.len()
        lines.push("| {cat} | {total} | {complete} | {failed} | {planned} | {ignored} |")

    lines.push("")
    lines.join("\n")

# =========================================================================
# Pending Feature Report
# =========================================================================

fn generate_pending_feature_md(fdb: FeatureDatabase) -> text:
    var lines: List<text> = []
    lines.push("# Pending Features")
    lines.push("")
    lines.push("*Auto-generated by Simple test runner*")
    lines.push("")

    val total = fdb.features.len()
    val complete = fdb.count_by_status("complete")
    val failed = fdb.count_by_status("failed")
    val in_progress = fdb.count_by_status("in_progress")
    val planned = fdb.count_by_status("planned")
    val ignored = fdb.count_by_status("ignored")

    lines.push("## Summary")
    lines.push("")
    lines.push("| Status | Count |")
    lines.push("|--------|-------|")
    lines.push("| Complete | {complete} |")
    lines.push("| Failed | {failed} |")
    lines.push("| In Progress | {in_progress} |")
    lines.push("| Planned | {planned} |")
    lines.push("| Ignored | {ignored} |")
    lines.push("| **Total** | **{total}** |")
    lines.push("")

    # Failed features (critical)
    if failed > 0:
        lines.push("## Failed Features")
        lines.push("")
        for f in fdb.features:
            if f.valid and f.status == "failed":
                lines.push("- **{f.id}** {f.name} ({f.category})")
        lines.push("")

    # In progress features
    if in_progress > 0:
        lines.push("## In Progress Features")
        lines.push("")
        for f in fdb.features:
            if f.valid and f.status == "in_progress":
                lines.push("- **{f.id}** {f.name} ({f.category})")
        lines.push("")

    # Planned features
    if planned > 0:
        lines.push("## Planned Features")
        lines.push("")
        for f in fdb.features:
            if f.valid and f.status == "planned":
                lines.push("- **{f.id}** {f.name} ({f.category})")
        lines.push("")

    lines.join("\n")

# =========================================================================
# Category Reports
# =========================================================================

fn generate_category_md(fdb: FeatureDatabase, category: text) -> text:
    var lines: List<text> = []
    lines.push("# {category}")
    lines.push("")

    val features = fdb.features_by_category(category)

    lines.push("| ID | Feature | Description | Interp | JIT | SMF-CL | SMF-LLVM | Status |")
    lines.push("|----|---------|-------------|--------|-----|--------|----------|--------|")

    for f in features:
        if f.status != "ignored":
            val interp = mode_badge(f.mode_interpreter)
            val jit = mode_badge(f.mode_jit)
            val smf_cl = mode_badge(f.mode_smf_cranelift)
            val smf_llvm = mode_badge(f.mode_smf_llvm)
            val status_badge = status_badge(f.status)
            lines.push("| <a id=\"feature-{f.id}\"></a>{f.id} | {f.name} | {f.description} | {interp} | {jit} | {smf_cl} | {smf_llvm} | {status_badge} |")

    lines.push("")
    lines.join("\n")

fn mode_badge(mode: text) -> text:
    if mode == "supported":
        return "supported"
    "not_supported"

fn status_badge(status: text) -> text:
    match status:
        case "complete": "complete"
        case "failed": "**FAILED**"
        case "in_progress": "in_progress"
        case "planned": "planned"
        case _: status

# =========================================================================
# Generate All Docs
# =========================================================================

fn generate_all_docs(db: TestDatabase, fdb: FeatureDatabase):
    # Test result
    val test_result = generate_test_result_md(db)
    rt_file_atomic_write("doc/test/test_result.md", test_result)

    # Feature index
    val feature_md = generate_feature_md(fdb)
    rt_file_atomic_write("doc/feature/feature.md", feature_md)

    # Pending features
    val pending_md = generate_pending_feature_md(fdb)
    rt_file_atomic_write("doc/feature/pending_feature.md", pending_md)

    # Per-category docs
    rt_dir_create_all("doc/feature/category")
    val categories = fdb.categories()
    for cat in categories:
        val cat_md = generate_category_md(fdb, cat)
        val safe_name = cat.replace(" ", "_")
        rt_file_atomic_write("doc/feature/category/{safe_name}.md", cat_md)

export generate_test_result_md, generate_feature_md
export generate_pending_feature_md, generate_category_md
export generate_all_docs
