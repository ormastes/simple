# Test Runner Main Orchestration
#
# Main test runner entry point and orchestration logic.

use app.cli_util (get_cli_args)

use test_runner_types.*
use test_runner_args.parse_test_args
use test_runner_files.{discover_test_files, print_discovery_summary}
use test_runner_execute.{run_test_file_interpreter, run_test_file_smf, run_test_file_native}
use test_runner_output.{print_result, print_summary}
use test_runner_db.write_test_db_run

# =========================================================================
# Environment Variable Propagation
# =========================================================================

fn propagate_env_vars(options: TestOptions):
    # Set SIMPLE_TEST_MODE for child processes
    val mode_str = mode_to_str(options.mode)
    rt_env_set("SIMPLE_TEST_MODE", mode_str)

    if options.only_slow:
        rt_env_set("SIMPLE_TEST_FILTER", "slow")
    elif options.only_skipped:
        rt_env_set("SIMPLE_TEST_FILTER", "skipped")

    if options.show_tags:
        rt_env_set("SIMPLE_TEST_SHOW_TAGS", "1")

# =========================================================================
# Runner
# =========================================================================

fn run_tests(options: TestOptions) -> TestRunResult:
    val files = discover_test_files(options.path, options)

    if options.list:
        print_discovery_summary(files, options)
        return TestRunResult(files: [], total_passed: 0, total_failed: 0, total_skipped: 0, total_timed_out: 0, total_duration_ms: 0)

    if files.len() == 0:
        print "No test files found in {options.path}"
        return TestRunResult(files: [], total_passed: 0, total_failed: 0, total_skipped: 0, total_timed_out: 0, total_duration_ms: 0)

    # Propagate env vars
    propagate_env_vars(options)

    val mode_name = mode_to_str(options.mode)
    print "Running {files.len()} test file(s) [mode: {mode_name}]..."
    if options.has_seed:
        print "Seed: {options.seed}"
    print ""

    var results: List<TestFileResult> = []
    var total_passed = 0
    var total_failed = 0
    var total_skipped = 0
    var total_timed_out = 0
    var total_duration_ms = 0

    for file_path in files:
        val result = run_single_test(file_path, options)
        print_result(result, options.format)

        total_passed = total_passed + result.passed
        total_failed = total_failed + result.failed
        total_skipped = total_skipped + result.skipped
        if result.timed_out:
            total_timed_out = total_timed_out + 1
        total_duration_ms = total_duration_ms + result.duration_ms
        results.push(result)

        if options.fail_fast and (result.failed > 0 or result.timed_out):
            print ""
            print "Stopping early (--fail-fast)"
            break

    TestRunResult(
        files: results,
        total_passed: total_passed,
        total_failed: total_failed,
        total_skipped: total_skipped,
        total_timed_out: total_timed_out,
        total_duration_ms: total_duration_ms
    )

fn mode_to_str(mode: TestExecutionMode) -> text:
    match mode:
        case TestExecutionMode.Interpreter:
            "interpreter"
        case TestExecutionMode.Smf:
            "smf"
        case TestExecutionMode.Native:
            "native"

fn run_single_test(file_path: text, options: TestOptions) -> TestFileResult:
    match options.mode:
        case TestExecutionMode.Interpreter:
            run_test_file_interpreter(file_path, options)
        case TestExecutionMode.Smf:
            run_test_file_smf(file_path, options)
        case TestExecutionMode.Native:
            run_test_file_native(file_path, options)

# =========================================================================
# Main Entry Point
# =========================================================================

fn main() -> i64:
    # Set recursion guard so child processes use Rust runner
    rt_env_set("SIMPLE_TEST_RUNNER_RUST", "1")

    val all_args = get_cli_args()

    # Filter out "test" command if present (from CLI dispatch)
    var args: List<str> = []
    var skip_first = all_args.len() > 0 and all_args[0] == "test"
    var i = 0
    if skip_first:
        i = 1
    while i < all_args.len():
        args.push(all_args[i])
        i = i + 1

    val options = parse_test_args(args)

    print "Simple Test Runner v0.3.0"
    print ""

    val run_start = rt_time_now_unix_micros()
    val result = run_tests(options)
    val run_end = rt_time_now_unix_micros()

    print_summary(result, options.format)

    # DISABLED: Test DB writes use unsafe file append without locking
    # This causes race conditions with Rust test runner and database corruption
    # TODO: Re-enable after implementing rt_file_atomic_write() FFI
    # See: doc/report/test_db_consistency_analysis_2026-01-30.md
    #
    # if not options.list and result.files.len() > 0:
    #     write_test_db_run(result, run_start, run_end)

    if result.is_ok():
        return 0
    return 1

# =========================================================================
# Exports
# =========================================================================

export propagate_env_vars, run_tests, mode_to_str, run_single_test
export main
