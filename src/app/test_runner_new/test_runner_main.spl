# Test Runner Main Orchestration
#
# Main test runner entry point and orchestration logic.
# Supports DB writes, parallel execution, feature DB, and doc generation.

use app.cli_util (get_cli_args)

use test_runner_types.*
use test_runner_args.parse_test_args
use test_runner_files.{discover_test_files, print_discovery_summary}
use test_runner_execute.{run_test_file_interpreter, run_test_file_smf, run_test_file_native}
use test_runner_output.{print_result, print_summary}
use test_db_core.TestDatabase
use feature_db.FeatureDatabase
use doc_generator.generate_all_docs
use rust_test_runner.{run_rust_tests, RustTestResult}

# =========================================================================
# Environment Variable Propagation
# =========================================================================

fn propagate_env_vars(options: TestOptions):
    # Set SIMPLE_TEST_MODE for child processes
    val mode_str = mode_to_str(options.mode)
    rt_env_set("SIMPLE_TEST_MODE", mode_str)

    if options.only_slow:
        rt_env_set("SIMPLE_TEST_FILTER", "slow")
    elif options.only_skipped:
        rt_env_set("SIMPLE_TEST_FILTER", "skipped")

    if options.show_tags:
        rt_env_set("SIMPLE_TEST_SHOW_TAGS", "1")

# =========================================================================
# Runner
# =========================================================================

fn run_tests(options: TestOptions) -> TestRunResult:
    val files = discover_test_files(options.path, options)

    if options.list:
        print_discovery_summary(files, options)
        return TestRunResult(files: [], total_passed: 0, total_failed: 0, total_skipped: 0, total_timed_out: 0, total_duration_ms: 0)

    if files.len() == 0:
        print "No test files found in {options.path}"
        return TestRunResult(files: [], total_passed: 0, total_failed: 0, total_skipped: 0, total_timed_out: 0, total_duration_ms: 0)

    # Propagate env vars
    propagate_env_vars(options)

    val mode_name = mode_to_str(options.mode)
    print "Running {files.len()} test file(s) [mode: {mode_name}]..."
    if options.has_seed:
        print "Seed: {options.seed}"
    print ""

    var results: List<TestFileResult> = []
    var total_passed = 0
    var total_failed = 0
    var total_skipped = 0
    var total_timed_out = 0
    var total_duration_ms = 0

    for file_path in files:
        val result = run_single_test(file_path, options)
        print_result(result, options.format)

        total_passed = total_passed + result.passed
        total_failed = total_failed + result.failed
        total_skipped = total_skipped + result.skipped
        if result.timed_out:
            total_timed_out = total_timed_out + 1
        total_duration_ms = total_duration_ms + result.duration_ms
        results.push(result)

        if options.fail_fast and (result.failed > 0 or result.timed_out):
            print ""
            print "Stopping early (--fail-fast)"
            break

    TestRunResult(
        files: results,
        total_passed: total_passed,
        total_failed: total_failed,
        total_skipped: total_skipped,
        total_timed_out: total_timed_out,
        total_duration_ms: total_duration_ms
    )

fn mode_to_str(mode: TestExecutionMode) -> text:
    match mode:
        case TestExecutionMode.Interpreter:
            "interpreter"
        case TestExecutionMode.Smf:
            "smf"
        case TestExecutionMode.Native:
            "native"

fn run_single_test(file_path: text, options: TestOptions) -> TestFileResult:
    match options.mode:
        case TestExecutionMode.Interpreter:
            run_test_file_interpreter(file_path, options)
        case TestExecutionMode.Smf:
            run_test_file_smf(file_path, options)
        case TestExecutionMode.Native:
            run_test_file_native(file_path, options)

# =========================================================================
# Main Entry Point
# =========================================================================

fn main() -> i64:
    # Set recursion guard so child processes use Rust runner
    rt_env_set("SIMPLE_TEST_RUNNER_RUST", "1")

    val all_args = get_cli_args()

    # Filter out "test" command if present (from CLI dispatch)
    var args: List<str> = []
    var skip_first = all_args.len() > 0 and all_args[0] == "test"
    var i = 0
    if skip_first:
        i = 1
    while i < all_args.len():
        args.push(all_args[i])
        i = i + 1

    val options = parse_test_args(args)

    print "Simple Test Runner v0.4.0"
    print ""

    val run_start = rt_time_now_unix_micros()
    val result = run_tests(options)
    val run_end = rt_time_now_unix_micros()

    print_summary(result, options.format)

    # Write test DB (now with proper file locking and atomic writes)
    if not options.list and result.files.len() > 0:
        update_test_database(result, run_start, run_end)

    if result.is_ok():
        return 0
    return 1

# =========================================================================
# Test Database Update
# =========================================================================

fn update_test_database(result: TestRunResult, run_start: i64, run_end: i64):
    val db_result = TestDatabase.load()
    if db_result.err.?:
        print "Warning: Could not load test database: {db_result.unwrap_err()}"
        return

    val db = db_result.unwrap()

    # Start run tracking
    val run_id = db.start_run()

    # Update individual test results
    for file_result in result.files:
        # For now, record file-level results
        # Individual test results require output parsing (future enhancement)
        val status = if file_result.failed > 0:
            TestStatus.Failed
        elif file_result.timed_out:
            TestStatus.Failed
        else:
            TestStatus.Passed

        val suite_name = "default"
        val category = "Unknown"
        val duration = file_result.duration_ms.to_float()

        db.update_test_result(
            file_result.path,
            file_result.path,
            suite_name,
            category,
            status,
            duration
        )

    # Complete run
    val total = result.total_passed + result.total_failed
    db.complete_run(run_id, total, result.total_passed, result.total_failed, result.total_timed_out)

    # Save database
    val save_result = db.save()
    if save_result.err.?:
        print "Warning: Could not save test database: {save_result.unwrap_err()}"
        return

    # Generate documentation
    val fdb = FeatureDatabase.load()
    generate_all_docs(db, fdb)

# =========================================================================
# Exports
# =========================================================================

export propagate_env_vars, run_tests, mode_to_str, run_single_test
export update_test_database
export main
