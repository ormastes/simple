# Test Runner Database Operations
#
# Test database tracking, file locking, and result persistence.

use test_runner_types.*

# =========================================================================
# Database Operations
# =========================================================================

fn write_test_db_run(result: TestRunResult, start_time: i64, end_time: i64):
    val run_id = start_time
    val start_iso = micros_to_iso(start_time)
    val end_iso = micros_to_iso(end_time)
    val test_count = result.total_passed + result.total_failed
    val passed = result.total_passed
    val failed = result.total_failed
    val timed_out = result.total_timed_out

    # Use atomic update with file locking (same as Rust implementation)
    val db_path = "doc/test/test_db.sdn"
    val result_opt = atomic_update_file_test_db(
        db_path,
        run_id,
        start_iso,
        end_iso,
        test_count,
        passed,
        failed,
        timed_out
    )

    match result_opt:
        case Ok(_):
            # Success - database updated atomically
            return
        case Err(e):
            # Log error but don't fail the test run
            print "Warning: Failed to update test database: {e}"

# Atomic file update for test database
# Uses file locking + atomic write (same pattern as Rust unified_db)
fn atomic_update_file_test_db(
    path: str,
    run_id: i64,
    start_time: str,
    end_time: str,
    test_count: i64,
    passed: i64,
    failed: i64,
    timed_out: i64
) -> Result<(), str>:
    # Acquire lock
    val lock_path_result = acquire_file_lock(path, 10)
    if lock_path_result.is_err():
        return Err("Failed to acquire lock")

    val lock_path = lock_path_result.unwrap()

    # Read existing content
    var content = ""
    if rt_file_exists(path):
        content = rt_file_read_text(path)

    # Build new test_runs row
    val row = "        {run_id}, \"{start_time}\", \"{end_time}\", 0, \"simple-runner\", \"completed\", {test_count}, {passed}, {failed}, 0, {timed_out}\n"

    # Append to test_runs table
    var new_content = ""
    if content.trim() == "":
        # Create new database with test_runs table
        val header = "test_runs |run_id, start_time, end_time, pid, hostname, status, test_count, passed, failed, crashed, timed_out|\n"
        new_content = header + row
    elif content.contains("test_runs |"):
        # Append to existing test_runs table
        new_content = content.trim() + "\n" + row
    else:
        # Add test_runs table at the end
        val header = "\ntest_runs |run_id, start_time, end_time, pid, hostname, status, test_count, passed, failed, crashed, timed_out|\n"
        new_content = content.trim() + "\n" + header + row

    # Atomic write
    val success = rt_file_atomic_write(path, new_content)

    # Release lock
    rt_file_unlock(lock_path)

    if success:
        return Ok(())
    else:
        return Err("Failed to write file")

# Acquire file lock with timeout
fn acquire_file_lock(path: str, timeout_secs: i64) -> Result<str, str>:
    # Note: rt_file_lock returns Result, we just pass it through
    # In the future when try-catch is implemented, we can add error handling here
    val lock_path = rt_file_lock(path, timeout_secs)
    Ok(lock_path)

fn micros_to_iso(micros: i64) -> str:
    # Simple approximation - just use the unix timestamp
    val secs = micros / 1000000
    "{secs}"

# =========================================================================
# Environment Variable Propagation
# =========================================================================

# =========================================================================
# Exports
# =========================================================================

export write_test_db_run
export atomic_update_file_test_db
export acquire_file_lock
export micros_to_iso
