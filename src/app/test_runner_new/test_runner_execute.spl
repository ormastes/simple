# Test Runner Execution
#
# Test execution functions for interpreter, SMF, and native modes.

use test_runner_types.*
use test_runner_files.{strip_ansi, read_file_content}
use app.io.mod (file_exists, env_get, time_now_unix_micros, process_run_timeout, process_run_with_limits, file_write, eprintln)

# =========================================================================
# Binary Location Discovery
# =========================================================================

fn find_simple_new_binary() -> text:
    if file_exists("./rust/target/bootstrap/simple_new1_"):
        return "./rust/target/bootstrap/simple_new1_"
    if file_exists("./rust/target/bootstrap/simple_new1"):
        return "./rust/target/bootstrap/simple_new1"
    ""

fn find_runtime_lib_dir() -> text:
    val env_path = env_get("SIMPLE_RUNTIME_PATH")
    if env_path != "" and env_path != nil:
        return env_path
    if file_exists("rust/target/debug/libsimple_compiler.so"):
        return "rust/target/debug"
    if file_exists("rust/target/release/libsimple_compiler.so"):
        return "rust/target/release"
    "rust/target/debug"

fn find_simple_binary() -> text:
    # Try multiple locations for the runtime binary
    val candidates = [
        "./rust/target/debug/simple_runtime",
        "./rust/target/release/simple_runtime",
        "rust/target/debug/simple_runtime",
        "rust/target/release/simple_runtime",
    ]

    for candidate in candidates:
        if file_exists(candidate):
            return candidate

    # Fallback to debug (will fail if it doesn't exist, but that's expected)
    "./rust/target/debug/simple_runtime"

fn extract_error_message(output: text) -> text:
    # Extract first meaningful error message from test output
    val lines = output.split("\n")
    var error_lines: [text] = []

    for line in lines:
        val clean = strip_ansi(line).trim()

        # Look for error patterns
        if clean.contains("semantic:") or clean.contains("parse error:") or clean.contains("compile failed:") or clean.contains("ERROR:"):
            error_lines.push(clean)
            if error_lines.len() >= 3:  # Limit to first 3 error lines
                break
        elif clean.starts_with("Error:") or clean.starts_with("error:"):
            error_lines.push(clean)
            if error_lines.len() >= 3:
                break
        elif clean.contains("unsupported path call:") or clean.contains("not found"):
            error_lines.push(clean)
            if error_lines.len() >= 3:
                break

    # Join error lines with semicolon separator
    if error_lines.len() > 0:
        error_lines[0:3].join("; ")
    else:
        ""

fn parse_test_output(output: text) -> (i64, i64, i64):
    var total_passed = 0
    var total_failed = 0
    var total_skipped = 0
    val lines = output.split("\n")
    for line in lines:
        val clean = strip_ansi(line)
        if clean.contains("examples") and clean.contains("failure"):
            val examples_count = extract_number_before(clean, "examples")
            val failures_count = extract_number_before(clean, "failure")
            if examples_count >= 0 and failures_count >= 0:
                val passed = examples_count - failures_count
                if passed > 0:
                    total_passed = total_passed + passed
                total_failed = total_failed + failures_count
        # Count skipped/pending
        if clean.contains("pending") or clean.contains("skipped"):
            val skip_count = extract_number_before(clean, "pending")
            if skip_count < 0:
                val skip_count2 = extract_number_before(clean, "skipped")
                if skip_count2 > 0:
                    total_skipped = total_skipped + skip_count2
            elif skip_count > 0:
                total_skipped = total_skipped + skip_count
    (total_passed, total_failed, total_skipped)

fn extract_number_before(s: text, keyword: text) -> i64:
    val idx_opt = s.index_of(keyword)
    val idx = idx_opt ?? -1
    if idx < 0:
        return -1
    var end = idx - 1
    # Skip whitespace
    while end >= 0:
        val ch = s[end:end + 1]
        if ch != " ":
            break
        end = end - 1
    if end < 0:
        return -1
    # Collect digits backwards
    var start = end
    while start >= 0:
        val ch = s[start:start + 1]
        if ch < "0" or ch > "9":
            break
        start = start - 1
    start = start + 1
    if start > end:
        return -1
    val num_str = s[start:end + 1]
    to_int(num_str)

fn build_child_args(file_path: text, options: TestOptions) -> [text]:
    # Run test file directly WITHOUT "test" command to avoid infinite recursion
    # The SSpec DSL is activated automatically when the file is loaded
    var args: [text] = [file_path]
    if options.gc_log:
        args.push("--gc-log")
    if options.gc_off:
        args.push("--gc=off")
    args

fn make_result_from_output(file_path: text, stdout: text, stderr: text, exit_code: i32, duration_ms: i64, timeout_secs: i64) -> TestFileResult:
    # Check for timeout
    if exit_code == -1:
        return TestFileResult(path: file_path, passed: 0, failed: 1, skipped: 0, duration_ms: duration_ms, error: "TIMEOUT after {timeout_secs}s", timed_out: true)

    val combined = stdout + "\n" + stderr
    val (passed, failed, skipped) = parse_test_output(combined)

    if passed == 0 and failed == 0:
        if exit_code == 0:
            return TestFileResult(path: file_path, passed: 1, failed: 0, skipped: skipped, duration_ms: duration_ms, error: "", timed_out: false)
        else:
            # Extract error message from output
            val extracted_error = extract_error_message(combined)
            val error_msg = if extracted_error != "":
                extracted_error
            else:
                "Process exited with code {exit_code}"
            return TestFileResult(path: file_path, passed: 0, failed: 1, skipped: skipped, duration_ms: duration_ms, error: error_msg, timed_out: false)

    # Extract error messages when tests fail
    var error = ""
    if failed > 0:
        error = extract_error_message(combined)
    elif exit_code != 0:
        error = "Process exited with code {exit_code}"

    TestFileResult(path: file_path, passed: passed, failed: failed, skipped: skipped, duration_ms: duration_ms, error: error, timed_out: false)

fn run_test_file_interpreter(file_path: text, options: TestOptions) -> TestFileResult:
    val binary = find_simple_binary()
    val child_args = build_child_args(file_path, options)
    val timeout_ms = options.timeout * 1000
    val start = time_now_unix_micros()
    val (stdout, stderr, exit_code) = process_run_timeout(binary, child_args, timeout_ms)
    val end = time_now_unix_micros()
    val duration_ms = (end - start) / 1000
    make_result_from_output(file_path, stdout, stderr, exit_code, duration_ms, options.timeout)

fn run_test_file_smf(file_path: text, options: TestOptions) -> TestFileResult:
    val binary = find_simple_binary()
    val smf_path = file_path.replace(".spl", ".smf")
    val start = time_now_unix_micros()
    val timeout_ms = options.timeout * 1000

    # Check if pre-compiled .smf bytecode exists
    if file_exists(smf_path):
        # Run pre-compiled SMF bytecode directly (no "test" command to avoid recursion)
        var run_args: [text] = [smf_path]
        if options.gc_log:
            run_args.push("--gc-log")
        if options.gc_off:
            run_args.push("--gc=off")
        val (stdout, stderr, exit_code) = process_run_timeout(binary, run_args, timeout_ms)
        val end = time_now_unix_micros()
        val duration_ms = (end - start) / 1000
        return make_result_from_output(file_path, stdout, stderr, exit_code, duration_ms, options.timeout)

    # No .smf file found - run .spl source directly (interpreter fallback)
    # Use file_path directly instead of "test" command to avoid infinite recursion
    var run_args: [text] = [file_path]
    if options.gc_log:
        run_args.push("--gc-log")
    if options.gc_off:
        run_args.push("--gc=off")

    # Debug: Check if binary exists
    if not file_exists(binary):
        eprintln("ERROR: Binary not found: " + binary)

    val (stdout, stderr, exit_code) = process_run_timeout(binary, run_args, timeout_ms)
    val end = time_now_unix_micros()
    val duration_ms = (end - start) / 1000

    make_result_from_output(file_path, stdout, stderr, exit_code, duration_ms, options.timeout)

fn run_test_file_native_old(file_path: text, options: TestOptions) -> TestFileResult:
    val binary = find_simple_binary()
    val start = time_now_unix_micros()
    val timeout_ms = options.timeout * 1000

    # Run file directly instead of "test" command to avoid infinite recursion
    var run_args: [text] = [file_path]
    if options.gc_log:
        run_args.push("--gc-log")
    if options.gc_off:
        run_args.push("--gc=off")
    val (stdout, stderr, exit_code) = process_run_timeout(binary, run_args, timeout_ms)
    val end = time_now_unix_micros()
    val duration_ms = (end - start) / 1000

    make_result_from_output(file_path, stdout, stderr, exit_code, duration_ms, options.timeout)

fn preprocess_sspec_file(file_path: text) -> text:
    """Wrap SSpec file content in fn main() for native compilation.
    Returns path to temporary wrapped file, or original path if not SSpec."""
    if not file_path.ends_with("_spec.spl"):
        return file_path

    val content = read_file_content(file_path)
    if content == "":
        return file_path

    # Split into imports/top-level-defs and body, wrap body in fn main():
    val lines = content.split("\n")
    var imports = ""
    var top_level = ""
    var body = ""
    var in_docstring = false
    var in_top_fn = false
    var top_fn_indent = 0

    for line in lines:
        val trimmed = line.trim()

        # Track multi-line docstrings (""")
        if trimmed.starts_with("\"\"\""):
            # Toggle docstring state. A line with """ toggles in/out.
            # If we see """ at start of line and we're NOT in a function body,
            # treat docstrings at top level as body (they'll go into main).
            if in_docstring:
                in_docstring = false
                if in_top_fn:
                    top_level = top_level + line + "\n"
                else:
                    body = body + "    " + line + "\n"
                continue
            else:
                in_docstring = true
                if in_top_fn:
                    top_level = top_level + line + "\n"
                else:
                    body = body + "    " + line + "\n"
                continue

        if in_docstring:
            if in_top_fn:
                top_level = top_level + line + "\n"
            else:
                body = body + "    " + line + "\n"
            continue

        # Import/use statements go before fn main()
        if trimmed.starts_with("import ") or trimmed.starts_with("use "):
            imports = imports + line + "\n"
            continue

        # Top-level function definitions (at column 0 only) stay outside main
        if not in_top_fn:
            val line_indent = line.len() - trimmed.len()
            if line_indent == 0:
                if trimmed.starts_with("fn ") or trimmed.starts_with("async fn ") or trimmed.starts_with("static fn "):
                    in_top_fn = true
                    top_fn_indent = 0
                    top_level = top_level + line + "\n"
                    continue

        # If we're inside a top-level function definition, keep collecting
        # lines until we see a line at the same or lesser indentation (not blank)
        if in_top_fn:
            if trimmed.len() == 0:
                top_level = top_level + "\n"
                continue
            val current_indent = line.len() - trimmed.len()
            if current_indent > top_fn_indent:
                top_level = top_level + line + "\n"
                continue
            else:
                # This line is at same/lesser indent â€” end of function
                in_top_fn = false
                # Fall through to body processing

        # Everything else goes into fn main() body
        if trimmed.len() > 0:
            body = body + "    " + line + "\n"
        else:
            body = body + "\n"

    val wrapped = imports + "\n" + top_level + "\nfn main():\n" + body
    val tmp_path = "/tmp/sspec_wrapped_" + file_path.replace("/", "_")
    file_write(tmp_path, wrapped)
    tmp_path

fn run_test_file_native(file_path: text, options: TestOptions) -> TestFileResult:
    val binary = find_simple_binary()
    val start = time_now_unix_micros()

    # Native mode: Run test file directly WITHOUT "test" command to avoid recursion
    # The test will execute as a standalone program
    val timeout_ms = options.timeout * 1000
    var run_args: [text] = [file_path]
    if options.gc_log:
        run_args.push("--gc-log")
    if options.gc_off:
        run_args.push("--gc=off")
    val (stdout, stderr, exit_code) = process_run_timeout(binary, run_args, timeout_ms)
    val end = time_now_unix_micros()
    val duration_ms = (end - start) / 1000

    make_result_from_output(file_path, stdout, stderr, exit_code, duration_ms, options.timeout)

# =========================================================================
# G1: Safe mode execution with resource limits
# =========================================================================

fn run_test_file_safe_mode(file_path: text, options: TestOptions) -> TestFileResult:
    val binary = find_simple_binary()
    val start = time_now_unix_micros()
    val timeout_ms = options.timeout * 1000
    val memory_bytes = 512 * 1024 * 1024
    val cpu_seconds = 30
    val max_fds = 256
    val max_procs = 64

    var run_args: [text] = [file_path]
    if options.gc_log:
        run_args.push("--gc-log")
    if options.gc_off:
        run_args.push("--gc=off")

    val (stdout, stderr, exit_code) = process_run_with_limits(
        binary, run_args, timeout_ms, memory_bytes, cpu_seconds, max_fds, max_procs
    )
    val end = time_now_unix_micros()
    val duration_ms = (end - start) / 1000

    make_result_from_output(file_path, stdout, stderr, exit_code, duration_ms, options.timeout)

# =========================================================================
# G3: Static test listing (parse source without execution)
# =========================================================================

fn list_tests_static(files: [text]) -> [text]:
    var test_names: [text] = []
    for file_path in files:
        val content = read_file_content(file_path)
        if content == "":
            continue
        val lines = content.split("\n")
        for line in lines:
            val trimmed = line.trim()
            # Match: it "...", slow_it "...", test "..."
            val name = extract_static_test_name(trimmed)
            if name != "":
                test_names.push("{file_path}::{name}")
    test_names

fn extract_static_test_name(line: text) -> text:
    # it "description"
    if line.starts_with("it \""):
        val end = line.index_of("\"", 4) ?? -1
        if end > 4:
            return line[4:end]
    # slow_it "description"
    if line.starts_with("slow_it \""):
        val end = line.index_of("\"", 9) ?? -1
        if end > 9:
            return "[slow] " + line[9:end]
    # test "description"
    if line.starts_with("test \""):
        val end = line.index_of("\"", 6) ?? -1
        if end > 6:
            return line[6:end]
    ""

# =========================================================================
# Exports
# =========================================================================

export find_simple_new_binary, find_runtime_lib_dir, find_simple_binary
export parse_test_output, extract_number_before
export build_child_args, make_result_from_output
export run_test_file_interpreter, run_test_file_smf
export run_test_file_native_old, run_test_file_native
export preprocess_sspec_file
export run_test_file_safe_mode
export list_tests_static, extract_static_test_name
