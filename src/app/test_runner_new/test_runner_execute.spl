# Test Runner Execution
#
# Core test execution modes: interpreter, SMF, native, and safe mode.
#
# NOTE: PID tracking for self-protection would require refactoring to use
# rt_process_spawn_async + rt_process_wait instead of process_run_timeout.
# Current implementation uses synchronous execution which doesn't expose PIDs.
# This is a future enhancement for Week 1 completion.
#
# Split into:
#   - test_executor_parsing.spl: binary discovery, output parsing, coverage wrappers, static listing
#   - test_executor_composite.spl: composite/baremetal/remote/QEMU platform execution
#   - test_runner_execute.spl (this file): core execution modes (interpreter, SMF, native, safe)

use test_runner_types.*
use test_runner_files.{strip_ansi, read_file_content}
use app.io.file_ops.{file_exists, file_write, file_delete}
use app.io.time_ops.{time_now_unix_micros}
use app.io.process_ops.{process_run_timeout, process_run_with_limits}

# Import from split-out files (same directory, but need use for re-export)
use test_executor_parsing.{
    find_simple_new_binary, find_runtime_lib_dir, find_simple_binary,
    extract_error_message, parse_test_output,
    extract_number_before, extract_number_after_colon,
    build_child_args, make_result_from_output,
    coverage_wrapper_suffix, build_coverage_wrapper,
    extract_coverage_sdn, strip_coverage_blocks,
    COVERAGE_BEGIN, COVERAGE_END,
    list_tests_static, extract_static_test_name
}
use test_executor_composite.{
    run_test_file_composite,
    extract_base_runtime, extract_platform_layer, extract_arch_from_spec,
    run_test_file_baremetal, run_test_file_remote,
    run_test_file_baremetal_via_interpreter, run_test_file_baremetal_qemu,
    find_baremetal_elf, qemu_binary_for_arch, qemu_machine_for_arch
}

# =========================================================================
# Core Execution Modes
# =========================================================================

fn run_test_file_interpreter(file_path: text, options: TestOptions) -> TestFileResult:
    val binary = find_simple_binary()
    val (wrapped_path, cleanup_path) = build_coverage_wrapper(file_path, options)
    val child_args = build_child_args(wrapped_path, options)
    val timeout_ms = options.timeout * 1000
    val start = time_now_unix_micros()
    var stdout = ""
    var stderr = ""
    var exit_code = 0
    if options.max_mem_gb > 0 and not options.no_limits:
        val memory_bytes = options.max_mem_gb * 1024 * 1024 * 1024
        val result = process_run_with_limits(binary, child_args, timeout_ms, memory_bytes, 0, 0, 0)
        stdout = result.stdout
        stderr = result.stderr
        exit_code = result.exit_code
        if result.limit_exceeded:
            val end2 = time_now_unix_micros()
            val dur = (end2 - start) / 1000
            if cleanup_path != "" and not options.keep_artifacts:
                if file_exists(cleanup_path):
                    file_delete(cleanup_path)
            return TestFileResult(path: file_path, passed: 0, failed: 1, skipped: 0, pending: 0,
                duration_ms: dur, error: "Memory limit exceeded ({options.max_mem_gb}GB)", timed_out: false)
    else:
        val (out, err, code) = process_run_timeout(binary, child_args, timeout_ms)
        stdout = out
        stderr = err
        exit_code = code
    val end = time_now_unix_micros()
    val duration_ms = (end - start) / 1000
    if options.coverage:
        val combined = stdout + "\n" + stderr
        val sdn = extract_coverage_sdn(combined)
        # MEMORY DEBUG: record_coverage_sdn commented out (GROUP 3 isolation)
        # record_coverage_sdn(sdn)
        stdout = strip_coverage_blocks(stdout)
        stderr = strip_coverage_blocks(stderr)

    if cleanup_path != "" and not options.keep_artifacts:
        if file_exists(cleanup_path):
            file_delete(cleanup_path)

    make_result_from_output(file_path, stdout, stderr, exit_code, duration_ms, options.timeout)

fn run_test_file_smf(file_path: text, options: TestOptions) -> TestFileResult:
    if options.coverage:
        return run_test_file_native(file_path, options)

    val binary = find_simple_binary()
    val smf_path = file_path.replace(".spl", ".smf")
    val start = time_now_unix_micros()
    val timeout_ms = options.timeout * 1000

    # Check if pre-compiled .smf bytecode exists
    if file_exists(smf_path):
        # Run pre-compiled SMF bytecode directly (no "test" command to avoid recursion)
        var run_args: [text] = [smf_path]
        if options.gc_log:
            run_args.push("--gc-log")
        if options.gc_off:
            run_args.push("--gc=off")
        var stdout = ""
        var stderr = ""
        var exit_code = 0
        if options.max_mem_gb > 0 and not options.no_limits:
            val memory_bytes = options.max_mem_gb * 1024 * 1024 * 1024
            val result = process_run_with_limits(binary, run_args, timeout_ms, memory_bytes, 0, 0, 0)
            stdout = result.stdout
            stderr = result.stderr
            exit_code = result.exit_code
            if result.limit_exceeded:
                val end2 = time_now_unix_micros()
                val dur = (end2 - start) / 1000
                return TestFileResult(path: file_path, passed: 0, failed: 1, skipped: 0, pending: 0,
                    duration_ms: dur, error: "Memory limit exceeded ({options.max_mem_gb}GB)", timed_out: false)
        else:
            val (out, err, code) = process_run_timeout(binary, run_args, timeout_ms)
            stdout = out
            stderr = err
            exit_code = code
        val end = time_now_unix_micros()
        val duration_ms = (end - start) / 1000
        if options.coverage:
            val combined = stdout + "\n" + stderr
            val sdn = extract_coverage_sdn(combined)
            # record_coverage_sdn(sdn)  # Deferred: coverage import removed for startup perf
            stdout = strip_coverage_blocks(stdout)
            stderr = strip_coverage_blocks(stderr)
        return make_result_from_output(file_path, stdout, stderr, exit_code, duration_ms, options.timeout)

    # No .smf file found - run .spl source directly (interpreter fallback)
    # Use file_path directly instead of "test" command to avoid infinite recursion
    var run_args: [text] = [file_path]
    if options.gc_log:
        run_args.push("--gc-log")
    if options.gc_off:
        run_args.push("--gc=off")

    # Debug: Check if binary exists
    if not file_exists(binary):
        print "ERROR: Binary not found: {binary}"

    var stdout = ""
    var stderr = ""
    var exit_code = 0
    if options.max_mem_gb > 0 and not options.no_limits:
        val memory_bytes = options.max_mem_gb * 1024 * 1024 * 1024
        val result = process_run_with_limits(binary, run_args, timeout_ms, memory_bytes, 0, 0, 0)
        stdout = result.stdout
        stderr = result.stderr
        exit_code = result.exit_code
        if result.limit_exceeded:
            val end2 = time_now_unix_micros()
            val dur = (end2 - start) / 1000
            return TestFileResult(path: file_path, passed: 0, failed: 1, skipped: 0, pending: 0,
                duration_ms: dur, error: "Memory limit exceeded ({options.max_mem_gb}GB)", timed_out: false)
    else:
        val (out, err, code) = process_run_timeout(binary, run_args, timeout_ms)
        stdout = out
        stderr = err
        exit_code = code
    val end = time_now_unix_micros()
    val duration_ms = (end - start) / 1000

    if options.coverage:
        val combined = stdout + "\n" + stderr
        val sdn = extract_coverage_sdn(combined)
        # MEMORY DEBUG: record_coverage_sdn commented out (GROUP 3 isolation)
        # record_coverage_sdn(sdn)
        stdout = strip_coverage_blocks(stdout)
        stderr = strip_coverage_blocks(stderr)

    make_result_from_output(file_path, stdout, stderr, exit_code, duration_ms, options.timeout)

fn run_test_file_native_old(file_path: text, options: TestOptions) -> TestFileResult:
    val binary = find_simple_binary()
    val start = time_now_unix_micros()
    val timeout_ms = options.timeout * 1000

    # Run file directly instead of "test" command to avoid infinite recursion
    var run_args: [text] = [file_path]
    if options.gc_log:
        run_args.push("--gc-log")
    if options.gc_off:
        run_args.push("--gc=off")
    val (stdout, stderr, exit_code) = process_run_timeout(binary, run_args, timeout_ms)
    val end = time_now_unix_micros()
    val duration_ms = (end - start) / 1000

    make_result_from_output(file_path, stdout, stderr, exit_code, duration_ms, options.timeout)

fn preprocess_sspec_file(file_path: text) -> text:
    """Wrap SSpec file content in fn main() for native compilation.
    Returns path to temporary wrapped file, or original path if not SSpec."""
    if not file_path.ends_with("_spec.spl"):
        return file_path

    val content = read_file_content(file_path)
    if content == "":
        return file_path

    # Split into imports/top-level-defs and body, wrap body in fn main():
    val lines = content.split("\n")
    var imports = ""
    var top_level = ""
    var body = ""
    var in_docstring = false
    var in_top_fn = false
    var top_fn_indent = 0

    for line in lines:
        val trimmed = line.trim()

        # Track multi-line docstrings (""")
        if trimmed.starts_with("\"\"\""):
            # Toggle docstring state. A line with """ toggles in/out.
            # If we see """ at start of line and we're NOT in a function body,
            # treat docstrings at top level as body (they'll go into main).
            if in_docstring:
                in_docstring = false
                if in_top_fn:
                    top_level = top_level + line + "\n"
                else:
                    body = body + "    " + line + "\n"
                continue
            else:
                in_docstring = true
                if in_top_fn:
                    top_level = top_level + line + "\n"
                else:
                    body = body + "    " + line + "\n"
                continue

        if in_docstring:
            if in_top_fn:
                top_level = top_level + line + "\n"
            else:
                body = body + "    " + line + "\n"
            continue

        # Import/use statements go before fn main()
        if trimmed.starts_with("import ") or trimmed.starts_with("use "):
            imports = imports + line + "\n"
            continue

        # Top-level function definitions (at column 0 only) stay outside main
        if not in_top_fn:
            val line_indent = line.len() - trimmed.len()
            if line_indent == 0:
                if trimmed.starts_with("fn ") or trimmed.starts_with("async fn ") or trimmed.starts_with("static fn "):
                    in_top_fn = true
                    top_fn_indent = 0
                    top_level = top_level + line + "\n"
                    continue

        # If we're inside a top-level function definition, keep collecting
        # lines until we see a line at the same or lesser indentation (not blank)
        if in_top_fn:
            if trimmed.len() == 0:
                top_level = top_level + "\n"
                continue
            val current_indent = line.len() - trimmed.len()
            if current_indent > top_fn_indent:
                top_level = top_level + line + "\n"
                continue
            else:
                # This line is at same/lesser indent â€” end of function
                in_top_fn = false
                # Fall through to body processing

        # Everything else goes into fn main() body
        if trimmed.len() > 0:
            body = body + "    " + line + "\n"
        else:
            body = body + "\n"

    val wrapped = imports + "\n" + top_level + "\nfn main():\n" + body
    val tmp_path = "/tmp/sspec_wrapped_" + file_path.replace("/", "_")
    file_write(tmp_path, wrapped)
    tmp_path

fn run_test_file_native(file_path: text, options: TestOptions) -> TestFileResult:
    val binary = find_simple_binary()
    val start = time_now_unix_micros()
    val timeout_ms = options.timeout * 1000

    # Native mode: Compile test file to .smf, then run the .smf
    # Step 1: Preprocess SSpec files (wrap in fn main())
    val (wrapped_path, cleanup_path) = build_coverage_wrapper(file_path, options)
    val source_path = preprocess_sspec_file(wrapped_path)

    # Step 2: Compile to .smf via 'simple compile'
    val smf_path = file_path.replace(".spl", ".smf")
    var compile_args: [text] = ["compile", source_path, "-o", smf_path]
    if options.verbose:
        compile_args.push("--verbose")
        print "[native] Compiling {file_path} to {smf_path}"

    val (compile_stdout, compile_stderr, compile_exit) = process_run_timeout(binary, compile_args, timeout_ms)

    if compile_exit != 0:
        val end = time_now_unix_micros()
        val duration_ms = (end - start) / 1000
        val error_msg = "Compilation failed: {compile_stderr}"
        if cleanup_path != "" and not options.keep_artifacts:
            if file_exists(cleanup_path):
                file_delete(cleanup_path)
        return TestFileResult(
            path: file_path,
            passed: 0,
            failed: 1,
            skipped: 0,
            pending: 0,
            duration_ms: duration_ms,
            error: error_msg,
            timed_out: false
        )

    # Step 3: Run the compiled .smf
    if options.verbose:
        print "[native] Running {smf_path}"

    var run_args: [text] = [smf_path]
    if options.gc_log:
        run_args.push("--gc-log")
    if options.gc_off:
        run_args.push("--gc=off")

    var stdout = ""
    var stderr = ""
    var exit_code = 0
    if options.max_mem_gb > 0 and not options.no_limits:
        val memory_bytes = options.max_mem_gb * 1024 * 1024 * 1024
        val result = process_run_with_limits(binary, run_args, timeout_ms, memory_bytes, 0, 0, 0)
        stdout = result.stdout
        stderr = result.stderr
        exit_code = result.exit_code
        if result.limit_exceeded:
            val end2 = time_now_unix_micros()
            val dur = (end2 - start) / 1000
            if not options.keep_artifacts:
                if file_exists(smf_path):
                    file_delete(smf_path)
                if cleanup_path != "" and file_exists(cleanup_path):
                    file_delete(cleanup_path)
            return TestFileResult(path: file_path, passed: 0, failed: 1, skipped: 0, pending: 0,
                duration_ms: dur, error: "Memory limit exceeded ({options.max_mem_gb}GB)", timed_out: false)
    else:
        val (out, err, code) = process_run_timeout(binary, run_args, timeout_ms)
        stdout = out
        stderr = err
        exit_code = code
    val end = time_now_unix_micros()
    val duration_ms = (end - start) / 1000

    # Clean up .smf artifact unless keeping
    if not options.keep_artifacts:
        if file_exists(smf_path):
            file_delete(smf_path)
        if cleanup_path != "" and file_exists(cleanup_path):
            file_delete(cleanup_path)

    if options.coverage:
        val combined = stdout + "\n" + stderr
        val sdn = extract_coverage_sdn(combined)
        # MEMORY DEBUG: record_coverage_sdn commented out (GROUP 3 isolation)
        # record_coverage_sdn(sdn)
        stdout = strip_coverage_blocks(stdout)
        stderr = strip_coverage_blocks(stderr)

    make_result_from_output(file_path, stdout, stderr, exit_code, duration_ms, options.timeout)

# =========================================================================
# G1: Safe mode execution with resource limits
# =========================================================================

fn run_test_file_safe_mode(file_path: text, options: TestOptions) -> TestFileResult:
    val binary = find_simple_binary()
    val start = time_now_unix_micros()
    val timeout_ms = options.timeout * 1000
    val memory_bytes = 512 * 1024 * 1024
    val cpu_seconds = 30
    val max_fds = 256
    val max_procs = 64

    var run_args: [text] = [file_path]
    if options.gc_log:
        run_args.push("--gc-log")
    if options.gc_off:
        run_args.push("--gc=off")

    val result = process_run_with_limits(
        binary, run_args, timeout_ms, memory_bytes, cpu_seconds, max_fds, max_procs
    )
    val end = time_now_unix_micros()
    val duration_ms = (end - start) / 1000

    if result.limit_exceeded:
        return TestFileResult(
            path: file_path,
            passed: 0,
            failed: 1,
            skipped: 0,
            pending: 0,
            duration_ms: duration_ms,
            error: "Resource limit exceeded: {result.limit_type}",
            timed_out: result.limit_type.contains("timeout")
        )

    make_result_from_output(file_path, result.stdout, result.stderr, result.exit_code, duration_ms, options.timeout)

# =========================================================================
# Exports - includes re-exports from split-out files for backward compat
# =========================================================================

# Re-export from test_executor_parsing.spl
export find_simple_new_binary, find_runtime_lib_dir, find_simple_binary
export parse_test_output, extract_number_before, extract_number_after_colon
export build_child_args, make_result_from_output
export list_tests_static, extract_static_test_name

# Re-export from test_executor_composite.spl
export run_test_file_composite
export extract_base_runtime, extract_platform_layer, extract_arch_from_spec
export run_test_file_baremetal, run_test_file_remote
export run_test_file_baremetal_via_interpreter, run_test_file_baremetal_qemu
export find_baremetal_elf, qemu_binary_for_arch, qemu_machine_for_arch

# Exports from this file
export run_test_file_interpreter, run_test_file_smf
export run_test_file_native_old, run_test_file_native
export preprocess_sspec_file
export run_test_file_safe_mode
