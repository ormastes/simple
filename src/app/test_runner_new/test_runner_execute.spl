# Test Runner Execution
#
# Test execution functions for interpreter, SMF, and native modes.
#
# NOTE: PID tracking for self-protection would require refactoring to use
# rt_process_spawn_async + rt_process_wait instead of process_run_timeout.
# Current implementation uses synchronous execution which doesn't expose PIDs.
# This is a future enhancement for Week 1 completion.

use test_runner_types.*
use test_runner_files.{strip_ansi, read_file_content}
use test_runner_coverage.{record_coverage_sdn}
use app.io.mod (file_exists, env_get, time_now_unix_micros, process_run_timeout, process_run_with_limits, file_write, file_delete)
use std.string.{NL}

# =========================================================================
# Binary Location Discovery
# =========================================================================

val COVERAGE_BEGIN = "__SIMPLE_COVERAGE_SDN_BEGIN__"
val COVERAGE_END = "__SIMPLE_COVERAGE_SDN_END__"

fn find_simple_new_binary() -> text:
    if file_exists("./rust/target/bootstrap/simple_new1_"):
        return "./rust/target/bootstrap/simple_new1_"
    if file_exists("./rust/target/bootstrap/simple_new1"):
        return "./rust/target/bootstrap/simple_new1"
    ""

fn find_runtime_lib_dir() -> text:
    val env_path = env_get("SIMPLE_RUNTIME_PATH")
    if env_path != "" and env_path != nil:
        return env_path
    if file_exists("rust/target/debug/libsimple_compiler.so"):
        return "rust/target/debug"
    if file_exists("rust/target/release/libsimple_compiler.so"):
        return "rust/target/release"
    "rust/target/debug"

fn find_simple_binary() -> text:
    # Check environment variable first
    val env_path = env_get("SIMPLE_RUNTIME")
    if env_path != "" and env_path != nil:
        if file_exists(env_path):
            return env_path

    # Try multiple locations for the bootstrap binary
    val candidates = [
        "bin/release/simple",
        "./bin/release/simple",
        "bin/release/linux-x86_64/simple",
        "./bin/release/linux-x86_64/simple",
        "bin/simple",
        "./bin/simple",
        "./rust/target/debug/simple",
        "./rust/target/release/simple",
        "rust/target/debug/simple",
        "rust/target/release/simple",
    ]

    for candidate in candidates:
        if file_exists(candidate):
            return candidate

    # Fallback to bin/release/simple (primary location in pure Simple setup)
    "bin/release/simple"

fn extract_error_message(output: text) -> text:
    # Extract first meaningful error message from test output
    val lines = output.split(NL)
    var error_lines: [text] = []

    for line in lines:
        val clean = strip_ansi(line).trim()

        # Look for error patterns
        if clean.contains("semantic:") or clean.contains("parse error:") or clean.contains("compile failed:") or clean.contains("ERROR:"):
            error_lines.push(clean)
            if error_lines.len() >= 3:  # Limit to first 3 error lines
                break
        elif clean.starts_with("Error:") or clean.starts_with("error:"):
            error_lines.push(clean)
            if error_lines.len() >= 3:
                break
        elif clean.contains("unsupported path call:") or clean.contains("not found"):
            error_lines.push(clean)
            if error_lines.len() >= 3:
                break

    # Join error lines with semicolon separator
    if error_lines.len() > 0:
        error_lines[0:3].join("; ")
    else:
        ""

fn parse_test_output(output: text) -> (i64, i64, i64, i64):
    var total_passed = 0
    var total_failed = 0
    var total_skipped = 0
    var total_pending = 0
    val lines = output.split(NL)
    for line in lines:
        val clean = strip_ansi(line)
        if clean.contains("examples") and clean.contains("failure"):
            val examples_count = extract_number_before(clean, "examples")
            val failures_count = extract_number_before(clean, "failure")
            if examples_count >= 0 and failures_count >= 0:
                val passed = examples_count - failures_count
                if passed > 0:
                    total_passed = total_passed + passed
                total_failed = total_failed + failures_count
        # Parse summary line: "Pending: N" from spec.spl print_summary
        if clean.trim().starts_with("Pending:"):
            val pending_count = extract_number_after_colon(clean, "Pending:")
            if pending_count > 0:
                total_pending = total_pending + pending_count
        # Count individual "... pending" test lines
        elif clean.contains("... pending"):
            total_pending = total_pending + 1
        # Count skipped (separate from pending)
        if clean.contains("skipped"):
            val skip_count2 = extract_number_before(clean, "skipped")
            if skip_count2 > 0:
                total_skipped = total_skipped + skip_count2
    (total_passed, total_failed, total_skipped, total_pending)

fn extract_number_after_colon(s: text, prefix: text) -> i64:
    val idx_opt = s.index_of(prefix)
    val idx = idx_opt ?? -1
    if idx < 0:
        return -1
    val after = s[idx + prefix.len():].trim()
    if after.len() == 0:
        return -1
    # Collect digits from start
    var end_pos = 0
    while end_pos < after.len():
        val ch = after[end_pos:end_pos + 1]
        if ch < "0" or ch > "9":
            break
        end_pos = end_pos + 1
    if end_pos == 0:
        return -1
    val num_str = after[0:end_pos]
    to_int(num_str)

fn extract_number_before(s: text, keyword: text) -> i64:
    val idx_opt = s.index_of(keyword)
    val idx = idx_opt ?? -1
    if idx < 0:
        return -1
    var end = idx - 1
    # Skip whitespace
    while end >= 0:
        val ch = s[end:end + 1]
        if ch != " ":
            break
        end = end - 1
    if end < 0:
        return -1
    # Collect digits backwards
    var start = end
    while start >= 0:
        val ch = s[start:start + 1]
        if ch < "0" or ch > "9":
            break
        start = start - 1
    start = start + 1
    if start > end:
        return -1
    val num_str = s[start:end + 1]
    to_int(num_str)

fn build_child_args(file_path: text, options: TestOptions) -> [text]:
    # Run test file directly WITHOUT "test" command to avoid infinite recursion
    # The SSpec DSL is activated automatically when the file is loaded
    var args: [text] = [file_path]
    if options.gc_log:
        args.push("--gc-log")
    if options.gc_off:
        args.push("--gc=off")
    args

fn coverage_wrapper_suffix(file_path: text) -> text:
    if file_path.ends_with("_spec.spl"):
        "_spec.spl"
    else:
        ".spl"

fn build_coverage_wrapper(file_path: text, options: TestOptions) -> (text, text):
    if not options.coverage:
        return (file_path, "")
    val content = read_file_content(file_path)
    if content == "":
        return (file_path, "")

    var base = file_path.replace("/", "_")
    base = base.replace(".spl", "")
    val tmp_path = "/tmp/simple_cov_" + base + coverage_wrapper_suffix(file_path)

    var lines: [text] = []
    lines.push(content)
    lines.push("")
    lines.push("# === Coverage Dump (auto-generated) ===")
    lines.push("extern fn rt_coverage_enabled() -> bool")
    lines.push("extern fn rt_coverage_dump_sdn() -> text")
    lines.push("")
    lines.push("fn __simple_cov_dump():")
    lines.push("    if not rt_coverage_enabled():")
    lines.push("        return")
    lines.push("    val sdn = rt_coverage_dump_sdn()")
    lines.push("    print \"" + COVERAGE_BEGIN + "\"")
    lines.push("    print sdn")
    lines.push("    print \"" + COVERAGE_END + "\"")
    lines.push("")
    lines.push("__simple_cov_dump()")

    val wrapped = lines.join(NL)
    file_write(tmp_path, wrapped)
    (tmp_path, tmp_path)

fn extract_coverage_sdn(output: text) -> text:
    val lines = output.split(NL)
    var in_block = false
    var sdn_lines: [text] = []
    for line in lines:
        val clean = strip_ansi(line).trim()
        if clean == COVERAGE_BEGIN:
            in_block = true
            continue
        if clean == COVERAGE_END:
            in_block = false
            continue
        if in_block:
            sdn_lines.push(line)
    sdn_lines.join(NL)

fn strip_coverage_blocks(output: text) -> text:
    val lines = output.split(NL)
    var in_block = false
    var kept: [text] = []
    for line in lines:
        val clean = strip_ansi(line).trim()
        if clean == COVERAGE_BEGIN:
            in_block = true
            continue
        if clean == COVERAGE_END:
            in_block = false
            continue
        if not in_block:
            kept.push(line)
    kept.join(NL)

fn make_result_from_output(file_path: text, stdout: text, stderr: text, exit_code: i32, duration_ms: i64, timeout_secs: i64) -> TestFileResult:
    # Check for timeout
    if exit_code == -1:
        return TestFileResult(path: file_path, passed: 0, failed: 1, skipped: 0, pending: 0, duration_ms: duration_ms, error: "TIMEOUT after {timeout_secs}s", timed_out: true)

    val combined = stdout + NL + stderr
    val (passed, failed, skipped, pending) = parse_test_output(combined)

    if passed == 0 and failed == 0:
        if exit_code == 0:
            return TestFileResult(path: file_path, passed: 1, failed: 0, skipped: skipped, pending: pending, duration_ms: duration_ms, error: "", timed_out: false)
        else:
            # Extract error message from output
            val extracted_error = extract_error_message(combined)
            val error_msg = if extracted_error != "":
                extracted_error
            else:
                "Process exited with code {exit_code}"
            return TestFileResult(path: file_path, passed: 0, failed: 1, skipped: skipped, pending: pending, duration_ms: duration_ms, error: error_msg, timed_out: false)

    # Extract error messages when tests fail
    var error = ""
    if failed > 0:
        error = extract_error_message(combined)
    elif exit_code != 0:
        error = "Process exited with code {exit_code}"

    TestFileResult(path: file_path, passed: passed, failed: failed, skipped: skipped, pending: pending, duration_ms: duration_ms, error: error, timed_out: false)

fn run_test_file_interpreter(file_path: text, options: TestOptions) -> TestFileResult:
    val binary = find_simple_binary()
    val (wrapped_path, cleanup_path) = build_coverage_wrapper(file_path, options)
    val child_args = build_child_args(wrapped_path, options)
    val timeout_ms = options.timeout * 1000
    val start = time_now_unix_micros()
    var (stdout, stderr, exit_code) = process_run_timeout(binary, child_args, timeout_ms)
    val end = time_now_unix_micros()
    val duration_ms = (end - start) / 1000
    if options.coverage:
        val combined = stdout + NL + stderr
        val sdn = extract_coverage_sdn(combined)
        record_coverage_sdn(sdn)
        stdout = strip_coverage_blocks(stdout)
        stderr = strip_coverage_blocks(stderr)

    if cleanup_path != "" and not options.keep_artifacts:
        if file_exists(cleanup_path):
            file_delete(cleanup_path)

    make_result_from_output(file_path, stdout, stderr, exit_code, duration_ms, options.timeout)

fn run_test_file_smf(file_path: text, options: TestOptions) -> TestFileResult:
    if options.coverage:
        return run_test_file_native(file_path, options)

    val binary = find_simple_binary()
    val smf_path = file_path.replace(".spl", ".smf")
    val start = time_now_unix_micros()
    val timeout_ms = options.timeout * 1000

    # Check if pre-compiled .smf bytecode exists
    if file_exists(smf_path):
        # Run pre-compiled SMF bytecode directly (no "test" command to avoid recursion)
        var run_args: [text] = [smf_path]
        if options.gc_log:
            run_args.push("--gc-log")
        if options.gc_off:
            run_args.push("--gc=off")
        var (stdout, stderr, exit_code) = process_run_timeout(binary, run_args, timeout_ms)
        val end = time_now_unix_micros()
        val duration_ms = (end - start) / 1000
        if options.coverage:
            val combined = stdout + NL + stderr
            val sdn = extract_coverage_sdn(combined)
            record_coverage_sdn(sdn)
            stdout = strip_coverage_blocks(stdout)
            stderr = strip_coverage_blocks(stderr)
        return make_result_from_output(file_path, stdout, stderr, exit_code, duration_ms, options.timeout)

    # No .smf file found - run .spl source directly (interpreter fallback)
    # Use file_path directly instead of "test" command to avoid infinite recursion
    var run_args: [text] = [file_path]
    if options.gc_log:
        run_args.push("--gc-log")
    if options.gc_off:
        run_args.push("--gc=off")

    # Debug: Check if binary exists
    if not file_exists(binary):
        print "ERROR: Binary not found: {binary}"

    var (stdout, stderr, exit_code) = process_run_timeout(binary, run_args, timeout_ms)
    val end = time_now_unix_micros()
    val duration_ms = (end - start) / 1000

    if options.coverage:
        val combined = stdout + NL + stderr
        val sdn = extract_coverage_sdn(combined)
        record_coverage_sdn(sdn)
        stdout = strip_coverage_blocks(stdout)
        stderr = strip_coverage_blocks(stderr)

    make_result_from_output(file_path, stdout, stderr, exit_code, duration_ms, options.timeout)

fn run_test_file_native_old(file_path: text, options: TestOptions) -> TestFileResult:
    val binary = find_simple_binary()
    val start = time_now_unix_micros()
    val timeout_ms = options.timeout * 1000

    # Run file directly instead of "test" command to avoid infinite recursion
    var run_args: [text] = [file_path]
    if options.gc_log:
        run_args.push("--gc-log")
    if options.gc_off:
        run_args.push("--gc=off")
    val (stdout, stderr, exit_code) = process_run_timeout(binary, run_args, timeout_ms)
    val end = time_now_unix_micros()
    val duration_ms = (end - start) / 1000

    make_result_from_output(file_path, stdout, stderr, exit_code, duration_ms, options.timeout)

fn preprocess_sspec_file(file_path: text) -> text:
    """Wrap SSpec file content in fn main() for native compilation.
    Returns path to temporary wrapped file, or original path if not SSpec."""
    if not file_path.ends_with("_spec.spl"):
        return file_path

    val content = read_file_content(file_path)
    if content == "":
        return file_path

    # Split into imports/top-level-defs and body, wrap body in fn main():
    val lines = content.split(NL)
    var imports = ""
    var top_level = ""
    var body = ""
    var in_docstring = false
    var in_top_fn = false
    var top_fn_indent = 0

    for line in lines:
        val trimmed = line.trim()

        # Track multi-line docstrings (""")
        if trimmed.starts_with("\"\"\""):
            # Toggle docstring state. A line with """ toggles in/out.
            # If we see """ at start of line and we're NOT in a function body,
            # treat docstrings at top level as body (they'll go into main).
            if in_docstring:
                in_docstring = false
                if in_top_fn:
                    top_level = top_level + line + NL
                else:
                    body = body + "    " + line + NL
                continue
            else:
                in_docstring = true
                if in_top_fn:
                    top_level = top_level + line + NL
                else:
                    body = body + "    " + line + NL
                continue

        if in_docstring:
            if in_top_fn:
                top_level = top_level + line + NL
            else:
                body = body + "    " + line + NL
            continue

        # Import/use statements go before fn main()
        if trimmed.starts_with("import ") or trimmed.starts_with("use "):
            imports = imports + line + NL
            continue

        # Top-level function definitions (at column 0 only) stay outside main
        if not in_top_fn:
            val line_indent = line.len() - trimmed.len()
            if line_indent == 0:
                if trimmed.starts_with("fn ") or trimmed.starts_with("async fn ") or trimmed.starts_with("static fn "):
                    in_top_fn = true
                    top_fn_indent = 0
                    top_level = top_level + line + NL
                    continue

        # If we're inside a top-level function definition, keep collecting
        # lines until we see a line at the same or lesser indentation (not blank)
        if in_top_fn:
            if trimmed.len() == 0:
                top_level = top_level + NL
                continue
            val current_indent = line.len() - trimmed.len()
            if current_indent > top_fn_indent:
                top_level = top_level + line + NL
                continue
            else:
                # This line is at same/lesser indent â€” end of function
                in_top_fn = false
                # Fall through to body processing

        # Everything else goes into fn main() body
        if trimmed.len() > 0:
            body = body + "    " + line + NL
        else:
            body = body + NL

    val wrapped = imports + NL + top_level + "{NL}fn main():{NL}" + body
    val tmp_path = "/tmp/sspec_wrapped_" + file_path.replace("/", "_")
    file_write(tmp_path, wrapped)
    tmp_path

fn run_test_file_native(file_path: text, options: TestOptions) -> TestFileResult:
    val binary = find_simple_binary()
    val start = time_now_unix_micros()
    val timeout_ms = options.timeout * 1000

    # Native mode: Compile test file to .smf, then run the .smf
    # Step 1: Preprocess SSpec files (wrap in fn main())
    val (wrapped_path, cleanup_path) = build_coverage_wrapper(file_path, options)
    val source_path = preprocess_sspec_file(wrapped_path)

    # Step 2: Compile to .smf via 'simple compile'
    val smf_path = file_path.replace(".spl", ".smf")
    var compile_args: [text] = ["compile", source_path, "-o", smf_path]
    if options.verbose:
        compile_args.push("--verbose")
        print "[native] Compiling {file_path} to {smf_path}"

    val (compile_stdout, compile_stderr, compile_exit) = process_run_timeout(binary, compile_args, timeout_ms)

    if compile_exit != 0:
        val end = time_now_unix_micros()
        val duration_ms = (end - start) / 1000
        val error_msg = "Compilation failed: {compile_stderr}"
        if cleanup_path != "" and not options.keep_artifacts:
            if file_exists(cleanup_path):
                file_delete(cleanup_path)
        return TestFileResult(
            path: file_path,
            passed: 0,
            failed: 1,
            skipped: 0,
            pending: 0,
            duration_ms: duration_ms,
            error: error_msg,
            timed_out: false
        )

    # Step 3: Run the compiled .smf
    if options.verbose:
        print "[native] Running {smf_path}"

    var run_args: [text] = [smf_path]
    if options.gc_log:
        run_args.push("--gc-log")
    if options.gc_off:
        run_args.push("--gc=off")

    var (stdout, stderr, exit_code) = process_run_timeout(binary, run_args, timeout_ms)
    val end = time_now_unix_micros()
    val duration_ms = (end - start) / 1000

    # Clean up .smf artifact unless keeping
    if not options.keep_artifacts:
        if file_exists(smf_path):
            file_delete(smf_path)
        if cleanup_path != "" and file_exists(cleanup_path):
            file_delete(cleanup_path)

    if options.coverage:
        val combined = stdout + NL + stderr
        val sdn = extract_coverage_sdn(combined)
        record_coverage_sdn(sdn)
        stdout = strip_coverage_blocks(stdout)
        stderr = strip_coverage_blocks(stderr)

    make_result_from_output(file_path, stdout, stderr, exit_code, duration_ms, options.timeout)

# =========================================================================
# G1: Safe mode execution with resource limits
# =========================================================================

fn run_test_file_safe_mode(file_path: text, options: TestOptions) -> TestFileResult:
    val binary = find_simple_binary()
    val start = time_now_unix_micros()
    val timeout_ms = options.timeout * 1000
    val memory_bytes = 512 * 1024 * 1024
    val cpu_seconds = 30
    val max_fds = 256
    val max_procs = 64

    var run_args: [text] = [file_path]
    if options.gc_log:
        run_args.push("--gc-log")
    if options.gc_off:
        run_args.push("--gc=off")

    val result = process_run_with_limits(
        binary, run_args, timeout_ms, memory_bytes, cpu_seconds, max_fds, max_procs
    )
    val end = time_now_unix_micros()
    val duration_ms = (end - start) / 1000

    if result.limit_exceeded:
        return TestFileResult(
            path: file_path,
            passed: 0,
            failed: 1,
            skipped: 0,
            pending: 0,
            duration_ms: duration_ms,
            error: "Resource limit exceeded: {result.limit_type}",
            timed_out: result.limit_type.contains("timeout")
        )

    make_result_from_output(file_path, result.stdout, result.stderr, result.exit_code, duration_ms, options.timeout)

# =========================================================================
# G3: Static test listing (parse source without execution)
# =========================================================================

fn list_tests_static(files: [text]) -> [text]:
    var test_names: [text] = []
    for file_path in files:
        val content = read_file_content(file_path)
        if content == "":
            continue
        val lines = content.split(NL)
        for line in lines:
            val trimmed = line.trim()
            # Match: it "...", slow_it "...", test "..."
            val name = extract_static_test_name(trimmed)
            if name != "":
                test_names.push("{file_path}::{name}")
    test_names

fn extract_static_test_name(line: text) -> text:
    # it "description"
    if line.starts_with("it \""):
        val end = line.index_of("\"", 4) ?? -1
        if end > 4:
            return line[4:end]
    # slow_it "description"
    if line.starts_with("slow_it \""):
        val end = line.index_of("\"", 9) ?? -1
        if end > 9:
            return "[slow] " + line[9:end]
    # test "description"
    if line.starts_with("test \""):
        val end = line.index_of("\"", 6) ?? -1
        if end > 6:
            return line[6:end]
    # pending_on "description"
    if line.starts_with("pending_on \""):
        val end = line.index_of("\"", 12) ?? -1
        if end > 12:
            return "[pending] " + line[12:end]
    ""

# =========================================================================
# Composite Platform Execution
# =========================================================================

fn run_test_file_composite(file_path: text, options: TestOptions, spec: text) -> TestFileResult:
    """Execute test in composite platform mode."""
    val start = time_now_unix_micros()
    val base = extract_base_runtime(spec)
    val platform = extract_platform_layer(spec)
    val arch = extract_arch_from_spec(spec)

    # Dispatch to platform-specific runner
    if platform == "baremetal":
        return run_test_file_baremetal(file_path, options, base, arch)
    if platform == "remote":
        return run_test_file_remote(file_path, options, base, arch)

    val end = time_now_unix_micros()
    val duration_ms = (end - start) / 1000
    TestFileResult(path: file_path, passed: 0, failed: 1, skipped: 0, pending: 0,
        duration_ms: duration_ms, error: "Unknown platform: {platform}", timed_out: false)

fn extract_base_runtime(spec: text) -> text:
    """Extract base runtime from composite spec (e.g. 'interpreter' from 'interpreter(baremetal(riscv32))')."""
    val paren = spec.index_of("(") ?? -1
    if paren > 0:
        return spec[0:paren].trim()
    spec.trim()

fn extract_platform_layer(spec: text) -> text:
    """Extract platform layer from composite spec (e.g. 'baremetal' from 'interpreter(baremetal(riscv32))')."""
    val paren = spec.index_of("(") ?? -1
    if paren < 0: return ""
    val after = spec[paren + 1:]
    val paren2 = after.index_of("(") ?? -1
    if paren2 > 0: return after[0:paren2].trim()
    val close = after.index_of(")") ?? -1
    if close > 0: return after[0:close].trim()
    ""

fn extract_arch_from_spec(spec: text) -> text:
    """Extract target architecture from composite spec."""
    if spec.contains("riscv32"): return "riscv32"
    if spec.contains("arm32"): return "arm32"
    if spec.contains("aarch64"): return "aarch64"
    if spec.contains("x86_64"): return "x86_64"
    if spec.contains("x86"): return "x86"
    "host"

fn run_test_file_baremetal(file_path: text, options: TestOptions, base: text, arch: text) -> TestFileResult:
    """Stub: Execute test on bare-metal target via QEMU.
    Future: cross-compile -> QEMU -> parse semihost output."""
    val start = time_now_unix_micros()
    val end = time_now_unix_micros()
    val duration_ms = (end - start) / 1000
    TestFileResult(path: file_path, passed: 0, failed: 0, skipped: 0, pending: 1,
        duration_ms: duration_ms, error: "baremetal({arch}) not yet implemented", timed_out: false)

fn run_test_file_remote(file_path: text, options: TestOptions, base: text, arch: text) -> TestFileResult:
    """Stub: Execute test on remote target via GDB MI.
    Future: upload to remote -> GDB MI -> parse results."""
    val start = time_now_unix_micros()
    val end = time_now_unix_micros()
    val duration_ms = (end - start) / 1000
    TestFileResult(path: file_path, passed: 0, failed: 0, skipped: 0, pending: 1,
        duration_ms: duration_ms, error: "remote({arch}) not yet implemented", timed_out: false)

# =========================================================================
# Exports
# =========================================================================

export find_simple_new_binary, find_runtime_lib_dir, find_simple_binary
export parse_test_output, extract_number_before, extract_number_after_colon
export build_child_args, make_result_from_output
export run_test_file_interpreter, run_test_file_smf
export run_test_file_native_old, run_test_file_native
export preprocess_sspec_file
export run_test_file_safe_mode
export run_test_file_composite
export extract_base_runtime, extract_platform_layer, extract_arch_from_spec
export run_test_file_baremetal, run_test_file_remote
export list_tests_static, extract_static_test_name
