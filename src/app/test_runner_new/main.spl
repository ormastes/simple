# Simple Test Runner (Written in Simple)
#
# Usage:
#   simple_old src/app/test_runner_new/main.spl [path] [options]
#
# Options:
#   --unit              Run unit tests only
#   --integration       Run integration tests only
#   --system            Run system tests only
#   --fail-fast         Stop on first failure
#   --tag <name>        Filter by tag
#   --mode <mode>       Execution mode: interpreter (default), smf, native
#   --mode=<mode>       Equals syntax also supported
#   --timeout <secs>    Timeout per test file (default: 120)
#   --list              List test files without running
#   --list-ignored      List ignored tests
#   --only-slow         Run only slow tests
#   --only-skipped      Run only skipped tests
#   --show-tags         Show tags in output
#   --seed <N>          Shuffle tests deterministically
#   --safe-mode/--safe  Run in safe mode (subprocess, already default)
#   --force-rebuild     Force rebuild cached artifacts
#   --keep-artifacts    Keep compiled artifacts after run
#   --all               Run all tests including slow
#   --format doc        Nested RSpec-style output
#   --list-skip-features  List features from .skip files
#   --planned-only/--pending  Filter skip features to planned only
#   --gc-log            Enable GC logging
#   --gc=off            Disable GC

use app.cli_util (get_cli_args)

# FFI declarations
extern fn rt_dir_walk(path: str) -> List<str>
extern fn rt_path_basename(path: str) -> str
extern fn rt_process_run(cmd: str, args: List<str>) -> (str, str, i32)
extern fn rt_process_run_timeout(cmd: str, args: List<str>, timeout_ms: i64) -> (str, str, i32)
extern fn rt_file_exists(path: str) -> bool
extern fn rt_file_read_text(path: str) -> str
extern fn rt_file_write_text(path: str, content: str) -> bool
extern fn rt_file_append_text(path: str, content: str) -> bool
extern fn rt_time_now_unix_micros() -> i64
extern fn rt_env_set(key: str, value: str) -> bool
extern fn rt_env_get(key: str) -> str

# =========================================================================
# Types
# =========================================================================

enum TestExecutionMode:
    Interpreter
    Smf
    Native

enum TestLevel:
    All
    Unit
    Integration
    System

enum OutputFormat:
    Default
    Doc

struct TestOptions:
    path: str
    level: TestLevel
    tag: str
    fail_fast: bool
    mode: TestExecutionMode
    timeout: i64
    list: bool
    list_ignored: bool
    only_slow: bool
    only_skipped: bool
    show_tags: bool
    gc_log: bool
    gc_off: bool
    seed: i64
    has_seed: bool
    safe_mode: bool
    force_rebuild: bool
    keep_artifacts: bool
    run_all: bool
    format: OutputFormat
    list_skip_features: bool
    planned_only: bool

struct TestFileResult:
    path: str
    passed: i64
    failed: i64
    skipped: i64
    duration_ms: i64
    error: str
    timed_out: bool

impl TestFileResult:
    fn is_ok() -> bool:
        self.failed == 0 and self.error == "" and not self.timed_out

struct TestRunResult:
    files: List<TestFileResult>
    total_passed: i64
    total_failed: i64
    total_skipped: i64
    total_timed_out: i64
    total_duration_ms: i64

impl TestRunResult:
    fn is_ok() -> bool:
        self.total_failed == 0 and self.total_timed_out == 0

struct SkipFeatureInfo:
    file_path: str
    title: str
    feature_ids: str
    category: str
    status: str

# =========================================================================
# Argument Parsing
# =========================================================================

fn parse_mode_str(m: str) -> TestExecutionMode:
    if m == "native" or m == "binary":
        return TestExecutionMode.Native
    if m == "smf" or m == "loader":
        return TestExecutionMode.Smf
    TestExecutionMode.Interpreter

fn parse_test_args(args: List<str>) -> TestOptions:
    var path = ""
    var level = TestLevel.All
    var tag = ""
    var fail_fast = false
    var mode = TestExecutionMode.Interpreter
    var timeout = 120
    var list = false
    var list_ignored = false
    var only_slow = false
    var only_skipped = false
    var show_tags = false
    var gc_log = false
    var gc_off = false
    var seed = 0
    var has_seed = false
    var safe_mode = false
    var force_rebuild = false
    var keep_artifacts = false
    var run_all = false
    var format = OutputFormat.Default
    var list_skip_features = false
    var planned_only = false

    var i = 0
    while i < args.len():
        val arg = args[i]
        if arg == "--unit":
            level = TestLevel.Unit
        elif arg == "--integration":
            level = TestLevel.Integration
        elif arg == "--system":
            level = TestLevel.System
        elif arg == "--fail-fast":
            fail_fast = true
        elif arg == "--list":
            list = true
        elif arg == "--list-ignored":
            list = true
            list_ignored = true
        elif arg == "--only-slow":
            only_slow = true
        elif arg == "--only-skipped":
            only_skipped = true
        elif arg == "--show-tags":
            show_tags = true
        elif arg == "--gc-log":
            gc_log = true
        elif arg == "--gc=off" or arg == "--gc=OFF":
            gc_off = true
        elif arg == "--safe-mode" or arg == "--safe":
            safe_mode = true
        elif arg == "--force-rebuild":
            force_rebuild = true
        elif arg == "--keep-artifacts":
            keep_artifacts = true
        elif arg == "--all":
            run_all = true
        elif arg == "--list-skip-features" or arg == "--skip-features":
            list_skip_features = true
            only_skipped = true
            list = true
        elif arg == "--planned-only" or arg == "--pending":
            planned_only = true
        elif arg == "--tag":
            i = i + 1
            if i < args.len():
                tag = args[i]
        elif arg == "--doc":
            format = OutputFormat.Doc
        elif arg == "--format":
            i = i + 1
            if i < args.len():
                if args[i] == "doc":
                    format = OutputFormat.Doc
        elif arg == "--mode":
            i = i + 1
            if i < args.len():
                mode = parse_mode_str(args[i])
        elif arg.starts_with("--mode="):
            val m = arg.replace("--mode=", "")
            mode = parse_mode_str(m)
        elif arg == "--timeout":
            i = i + 1
            if i < args.len():
                timeout = to_int(args[i])
        elif arg == "--seed":
            i = i + 1
            if i < args.len():
                seed = to_int(args[i])
                has_seed = true
        elif not arg.starts_with("-") and path == "":
            path = arg
        i = i + 1

    if path == "":
        path = "test/"

    TestOptions(
        path: path,
        level: level,
        tag: tag,
        fail_fast: fail_fast,
        mode: mode,
        timeout: timeout,
        list: list,
        list_ignored: list_ignored,
        only_slow: only_slow,
        only_skipped: only_skipped,
        show_tags: show_tags,
        gc_log: gc_log,
        gc_off: gc_off,
        seed: seed,
        has_seed: has_seed,
        safe_mode: safe_mode,
        force_rebuild: force_rebuild,
        keep_artifacts: keep_artifacts,
        run_all: run_all,
        format: format,
        list_skip_features: list_skip_features,
        planned_only: planned_only
    )

# =========================================================================
# ANSI Stripping
# =========================================================================

fn strip_ansi(s: str) -> str:
    # ANSI codes like ESC[32m contain digits but are separated from content
    # by the 'm' terminator, so extract_number_before won't pick them up
    # because it scans backwards from keyword and stops at non-digit chars.
    # A full implementation needs char code access (ESC = 0x1b = 27).
    # TODO: Implement proper ANSI stripping when rt_char_code FFI is available
    s

# =========================================================================
# Discovery
# =========================================================================

fn is_test_file(path: str) -> bool:
    val name = rt_path_basename(path)
    if not name.ends_with(".spl"):
        return false
    name.contains("_spec.") or name.contains("_test.")

fn matches_level(path: str, level: TestLevel) -> bool:
    match level:
        case TestLevel.All:
            true
        case TestLevel.Unit:
            not path.contains("/integration/") and not path.contains("/system/")
        case TestLevel.Integration:
            path.contains("/integration/")
        case TestLevel.System:
            path.contains("/system/")

fn read_file_content(file_path: str) -> str:
    val result = rt_file_read_text(file_path)
    result ?? ""

fn file_has_slow_test(file_path: str) -> bool:
    val content = read_file_content(file_path)
    content.contains("slow_it ")

fn file_has_skip_tag(file_path: str) -> bool:
    val content = read_file_content(file_path)
    content.contains("tag: \"skip\"") or content.contains("tag: 'skip'")

fn file_has_ignored_test(file_path: str) -> bool:
    val content = read_file_content(file_path)
    content.contains("slow_it ") or content.contains("tag: \"skip\"") or content.contains("tag: 'skip'")

fn file_has_tag(file_path: str, tag: str) -> bool:
    if tag == "":
        return true
    val content = read_file_content(file_path)
    content.contains("tag: \"{tag}\"") or content.contains("tag: '{tag}'")

fn discover_test_files(base_path: str, options: TestOptions) -> List<str>:
    # If path is a single file, use it directly
    if base_path.ends_with(".spl"):
        if rt_file_exists(base_path) and is_test_file(base_path):
            return [base_path]
        return []
    val all_files = rt_dir_walk(base_path)
    var test_files: List<str> = []
    for f in all_files:
        if not is_test_file(f):
            continue
        if not matches_level(f, options.level):
            continue
        # --list-ignored: only show files with ignored tests
        if options.list_ignored and not file_has_ignored_test(f):
            continue
        # Filter by --only-slow (unless --all)
        if options.only_slow and not options.run_all and not file_has_slow_test(f):
            continue
        # Filter by --only-skipped
        if options.only_skipped and not file_has_skip_tag(f):
            continue
        # Filter by --tag
        if options.tag != "" and not file_has_tag(f, options.tag):
            continue
        test_files.push(f)

    # Apply seed shuffle
    if options.has_seed:
        test_files = shuffle_files(test_files, options.seed)

    test_files

# =========================================================================
# Deterministic Shuffle (hash-based, matches Rust runner)
# =========================================================================

fn simple_hash(s: str, seed: i64) -> i64:
    # Simple hash using small multipliers to avoid overflow
    var hash = seed * 31 + 7
    var i = 0
    while i < s.len():
        val ch = s[i:i + 1]
        var byte_val = 0
        if ch >= "a" and ch <= "z":
            byte_val = 97
        elif ch >= "A" and ch <= "Z":
            byte_val = 65
        elif ch >= "0" and ch <= "9":
            byte_val = 48
        elif ch == "/":
            byte_val = 47
        elif ch == "_":
            byte_val = 95
        elif ch == ".":
            byte_val = 46
        else:
            byte_val = 42
        hash = (hash * 31 + byte_val) % 1000000007
        i = i + 1
    hash

fn shuffle_files(files: List<str>, seed: i64) -> List<str>:
    # Compute hashes for each file
    var hashes: List<i64> = []
    for f in files:
        hashes.push(simple_hash(f, seed))

    # Selection sort by hash
    var n = files.len()
    var idx: List<i64> = []
    var j = 0
    while j < n:
        idx.push(j)
        j = j + 1

    var ii = 0
    while ii < n - 1:
        var min_pos = ii
        var jj = ii + 1
        while jj < n:
            if hashes[idx[jj]] < hashes[idx[min_pos]]:
                min_pos = jj
            jj = jj + 1
        if min_pos != ii:
            val tmp = idx[ii]
            idx[ii] = idx[min_pos]
            idx[min_pos] = tmp
        ii = ii + 1

    var result: List<str> = []
    var k = 0
    while k < n:
        result.push(files[idx[k]])
        k = k + 1
    result

# =========================================================================
# Skip Features
# =========================================================================

fn extract_skip_feature_info(file_path: str) -> SkipFeatureInfo:
    val content = read_file_content(file_path)
    val lines = content.split("\n")
    var title = ""
    var feature_ids = ""
    var category = ""
    var status = "Unknown"

    for line in lines:
        val trimmed = line.trim()
        if trimmed.starts_with("# ") and title == "":
            title = trimmed.replace("# ", "")
        elif trimmed.starts_with("**Feature IDs:**"):
            feature_ids = trimmed.replace("**Feature IDs:**", "").trim()
        elif trimmed.starts_with("**Category:**"):
            category = trimmed.replace("**Category:**", "").trim()
        elif trimmed.starts_with("**Status:**"):
            status = trimmed.replace("**Status:**", "").trim()

    SkipFeatureInfo(
        file_path: file_path,
        title: title,
        feature_ids: feature_ids,
        category: category,
        status: status
    )

fn print_skip_features(files: List<str>, planned_only: bool):
    var features: List<SkipFeatureInfo> = []
    for f in files:
        val info = extract_skip_feature_info(f)
        if planned_only:
            val s = info.status.lower()
            if s.contains("planned") or s.contains("tbd") or s == "unknown":
                features.push(info)
        else:
            features.push(info)

    var label = "Skipped Features"
    if planned_only:
        label = "Planned Features"
    print ""
    print "{label} ({features.len()} of {files.len()} files)"
    print "==============================================================="
    print ""

    for feat in features:
        var line = "  {feat.title}"
        if feat.feature_ids != "":
            line = line + " ({feat.feature_ids})"
        print line
        print "    File:     {feat.file_path}"
        if feat.category != "":
            print "    Category: {feat.category}"
        print "    Status:   {feat.status}"
        print ""

    print "Total: {features.len()} features"

# =========================================================================
# Discovery Summary / List Mode
# =========================================================================

fn print_discovery_summary(files: List<str>, options: TestOptions):
    if options.list_skip_features:
        print_skip_features(files, options.planned_only)
        return

    print "Discovered {files.len()} test file(s)"
    for f in files:
        if options.show_tags:
            var tags: List<str> = []
            if file_has_slow_test(f):
                tags.push("slow")
            if file_has_skip_tag(f):
                tags.push("skip")
            if tags.len() > 0:
                val tag_str = tags.join(", ")
                print "  {f}  [{tag_str}]"
            else:
                print "  {f}"
        else:
            print "  {f}"

# =========================================================================
# Execution
# =========================================================================

fn find_simple_new_binary() -> str:
    if rt_file_exists("./target/bootstrap/simple_new1_"):
        return "./target/bootstrap/simple_new1_"
    if rt_file_exists("./target/bootstrap/simple_new1"):
        return "./target/bootstrap/simple_new1"
    ""

fn find_runtime_lib_dir() -> str:
    val env_path = rt_env_get("SIMPLE_RUNTIME_PATH")
    if env_path != "" and env_path != nil:
        return env_path
    if rt_file_exists("target/debug/libsimple_compiler.so"):
        return "target/debug"
    if rt_file_exists("target/release/libsimple_compiler.so"):
        return "target/release"
    "target/debug"

fn find_simple_binary() -> str:
    if rt_file_exists("./target/debug/simple_old"):
        return "./target/debug/simple_old"
    if rt_file_exists("./target/release/simple_old"):
        return "./target/release/simple_old"
    "./target/debug/simple_old"

fn parse_test_output(output: str) -> (i64, i64, i64):
    var total_passed = 0
    var total_failed = 0
    var total_skipped = 0
    val lines = output.split("\n")
    for line in lines:
        val clean = strip_ansi(line)
        if clean.contains("examples") and clean.contains("failure"):
            val examples_count = extract_number_before(clean, "examples")
            val failures_count = extract_number_before(clean, "failure")
            if examples_count >= 0 and failures_count >= 0:
                val passed = examples_count - failures_count
                if passed > 0:
                    total_passed = total_passed + passed
                total_failed = total_failed + failures_count
        # Count skipped/pending
        if clean.contains("pending") or clean.contains("skipped"):
            val skip_count = extract_number_before(clean, "pending")
            if skip_count < 0:
                val skip_count2 = extract_number_before(clean, "skipped")
                if skip_count2 > 0:
                    total_skipped = total_skipped + skip_count2
            elif skip_count > 0:
                total_skipped = total_skipped + skip_count
    (total_passed, total_failed, total_skipped)

fn extract_number_before(s: str, keyword: str) -> i64:
    val idx_opt = s.index_of(keyword)
    val idx = idx_opt ?? -1
    if idx < 0:
        return -1
    var end = idx - 1
    # Skip whitespace
    while end >= 0:
        val ch = s[end:end + 1]
        if ch != " ":
            break
        end = end - 1
    if end < 0:
        return -1
    # Collect digits backwards
    var start = end
    while start >= 0:
        val ch = s[start:start + 1]
        if ch < "0" or ch > "9":
            break
        start = start - 1
    start = start + 1
    if start > end:
        return -1
    val num_str = s[start:end + 1]
    to_int(num_str)

fn build_child_args(file_path: str, options: TestOptions) -> List<str>:
    # Prepend "test" to ensure SSpec DSL is activated
    # This makes subprocess run: simple_old test file_path
    # instead of: simple_old file_path
    var args: List<str> = ["test", file_path]
    if options.gc_log:
        args.push("--gc-log")
    if options.gc_off:
        args.push("--gc=off")
    args

fn make_result_from_output(file_path: str, stdout: str, stderr: str, exit_code: i32, duration_ms: i64, timeout_secs: i64) -> TestFileResult:
    # Check for timeout
    if exit_code == -1:
        return TestFileResult(path: file_path, passed: 0, failed: 1, skipped: 0, duration_ms: duration_ms, error: "TIMEOUT after {timeout_secs}s", timed_out: true)

    val combined = stdout + "\n" + stderr
    val (passed, failed, skipped) = parse_test_output(combined)

    if passed == 0 and failed == 0:
        if exit_code == 0:
            return TestFileResult(path: file_path, passed: 1, failed: 0, skipped: skipped, duration_ms: duration_ms, error: "", timed_out: false)
        else:
            return TestFileResult(path: file_path, passed: 0, failed: 1, skipped: skipped, duration_ms: duration_ms, error: "Process exited with code {exit_code}", timed_out: false)

    var error = ""
    if exit_code != 0 and failed == 0:
        error = "Process exited with code {exit_code}"

    TestFileResult(path: file_path, passed: passed, failed: failed, skipped: skipped, duration_ms: duration_ms, error: error, timed_out: false)

fn run_test_file_interpreter(file_path: str, options: TestOptions) -> TestFileResult:
    val binary = find_simple_binary()
    val child_args = build_child_args(file_path, options)
    val timeout_ms = options.timeout * 1000
    val start = rt_time_now_unix_micros()
    val (stdout, stderr, exit_code) = rt_process_run_timeout(binary, child_args, timeout_ms)
    val end = rt_time_now_unix_micros()
    val duration_ms = (end - start) / 1000
    make_result_from_output(file_path, stdout, stderr, exit_code, duration_ms, options.timeout)

fn run_test_file_smf(file_path: str, options: TestOptions) -> TestFileResult:
    val binary = find_simple_binary()
    val smf_path = file_path.replace(".spl", ".smf")
    val start = rt_time_now_unix_micros()

    # SMF mode doesn't support SSpec DSL compilation
    # Run tests directly using "test" command instead
    val timeout_ms = options.timeout * 1000
    var run_args: List<str> = ["test", file_path]
    if options.gc_log:
        run_args.push("--gc-log")
    if options.gc_off:
        run_args.push("--gc=off")
    val (stdout, stderr, exit_code) = rt_process_run_timeout(binary, run_args, timeout_ms)
    val end = rt_time_now_unix_micros()
    val duration_ms = (end - start) / 1000

    make_result_from_output(file_path, stdout, stderr, exit_code, duration_ms, options.timeout)

fn run_test_file_native_old(file_path: str, options: TestOptions) -> TestFileResult:
    val binary = find_simple_binary()
    val start = rt_time_now_unix_micros()

    # Native mode doesn't support SSpec DSL compilation
    # Run tests directly using "test" command instead
    val timeout_ms = options.timeout * 1000
    var run_args: List<str> = ["test", file_path]
    if options.gc_log:
        run_args.push("--gc-log")
    if options.gc_off:
        run_args.push("--gc=off")
    val (stdout, stderr, exit_code) = rt_process_run_timeout(binary, run_args, timeout_ms)
    val end = rt_time_now_unix_micros()
    val duration_ms = (end - start) / 1000

    make_result_from_output(file_path, stdout, stderr, exit_code, duration_ms, options.timeout)

fn preprocess_sspec_file(file_path: str) -> str:
    """Wrap SSpec file content in fn main() for native compilation.
    Returns path to temporary wrapped file, or original path if not SSpec."""
    if not file_path.ends_with("_spec.spl"):
        return file_path

    val content = read_file_content(file_path)
    if content == "":
        return file_path

    # Split into imports/top-level-defs and body, wrap body in fn main():
    val lines = content.split("\n")
    var imports = ""
    var top_level = ""
    var body = ""
    var in_docstring = false
    var in_top_fn = false
    var top_fn_indent = 0

    for line in lines:
        val trimmed = line.trim()

        # Track multi-line docstrings (""")
        if trimmed.starts_with("\"\"\""):
            # Toggle docstring state. A line with """ toggles in/out.
            # If we see """ at start of line and we're NOT in a function body,
            # treat docstrings at top level as body (they'll go into main).
            if in_docstring:
                in_docstring = false
                if in_top_fn:
                    top_level = top_level + line + "\n"
                else:
                    body = body + "    " + line + "\n"
                continue
            else:
                in_docstring = true
                if in_top_fn:
                    top_level = top_level + line + "\n"
                else:
                    body = body + "    " + line + "\n"
                continue

        if in_docstring:
            if in_top_fn:
                top_level = top_level + line + "\n"
            else:
                body = body + "    " + line + "\n"
            continue

        # Import/use statements go before fn main()
        if trimmed.starts_with("import ") or trimmed.starts_with("use "):
            imports = imports + line + "\n"
            continue

        # Top-level function definitions (at column 0 only) stay outside main
        if not in_top_fn:
            val line_indent = line.len() - trimmed.len()
            if line_indent == 0:
                if trimmed.starts_with("fn ") or trimmed.starts_with("async fn ") or trimmed.starts_with("static fn "):
                    in_top_fn = true
                    top_fn_indent = 0
                    top_level = top_level + line + "\n"
                    continue

        # If we're inside a top-level function definition, keep collecting
        # lines until we see a line at the same or lesser indentation (not blank)
        if in_top_fn:
            if trimmed.len() == 0:
                top_level = top_level + "\n"
                continue
            val current_indent = line.len() - trimmed.len()
            if current_indent > top_fn_indent:
                top_level = top_level + line + "\n"
                continue
            else:
                # This line is at same/lesser indent â€” end of function
                in_top_fn = false
                # Fall through to body processing

        # Everything else goes into fn main() body
        if trimmed.len() > 0:
            body = body + "    " + line + "\n"
        else:
            body = body + "\n"

    val wrapped = imports + "\n" + top_level + "\nfn main():\n" + body
    val tmp_path = "/tmp/sspec_wrapped_" + file_path.replace("/", "_")
    rt_file_write_text(tmp_path, wrapped)
    tmp_path

fn run_test_file_native(file_path: str, options: TestOptions) -> TestFileResult:
    val binary = find_simple_binary()
    val start = rt_time_now_unix_micros()

    # Native mode doesn't support SSpec DSL compilation
    # Run tests directly using "test" command instead
    val timeout_ms = options.timeout * 1000
    var run_args: List<str> = ["test", file_path]
    if options.gc_log:
        run_args.push("--gc-log")
    if options.gc_off:
        run_args.push("--gc=off")
    val (stdout, stderr, exit_code) = rt_process_run_timeout(binary, run_args, timeout_ms)
    val end = rt_time_now_unix_micros()
    val duration_ms = (end - start) / 1000

    make_result_from_output(file_path, stdout, stderr, exit_code, duration_ms, options.timeout)

# =========================================================================
# Output Formatting
# =========================================================================

fn print_result_default(result: TestFileResult):
    if result.timed_out:
        print "  TOUT  {result.path} ({result.duration_ms}ms)"
        print "        Error: {result.error}"
    elif result.is_ok():
        var msg = "  PASS  {result.path} ({result.passed} passed"
        if result.skipped > 0:
            msg = msg + ", {result.skipped} skipped"
        msg = msg + ", {result.duration_ms}ms)"
        print msg
    else:
        var msg = "  FAIL  {result.path} ({result.passed} passed, {result.failed} failed"
        if result.skipped > 0:
            msg = msg + ", {result.skipped} skipped"
        msg = msg + ", {result.duration_ms}ms)"
        print msg
        if result.error != "":
            print "        Error: {result.error}"

fn print_result_doc(result: TestFileResult):
    val name = rt_path_basename(result.path)
    if result.timed_out:
        print "  {name}"
        print "    TIMEOUT ({result.duration_ms}ms)"
    elif result.is_ok():
        print "  {name}"
        print "    {result.passed} examples, 0 failures ({result.duration_ms}ms)"
    else:
        print "  {name}"
        print "    {result.passed + result.failed} examples, {result.failed} failures ({result.duration_ms}ms)"

fn print_result(result: TestFileResult, format: OutputFormat):
    match format:
        case OutputFormat.Default:
            print_result_default(result)
        case OutputFormat.Doc:
            print_result_doc(result)

fn print_summary(result: TestRunResult, format: OutputFormat):
    print ""
    print "========================================="
    val total = result.total_passed + result.total_failed
    var summary = "Results: {total} total, {result.total_passed} passed, {result.total_failed} failed"
    if result.total_skipped > 0:
        summary = summary + ", {result.total_skipped} skipped"
    if result.total_timed_out > 0:
        summary = summary + ", {result.total_timed_out} timed out"
    print summary
    print "Time:    {result.total_duration_ms}ms"
    print "========================================="
    if result.is_ok():
        print "All tests passed!"
    else:
        print "Some tests failed."

# =========================================================================
# Test DB Writing (doc/test/test_db.sdn)
# =========================================================================

# Atomic database write using file locking
# Mirrors Rust test_db logic for consistency and safety
fn write_test_db_run(result: TestRunResult, start_time: i64, end_time: i64):
    val run_id = start_time
    val start_iso = micros_to_iso(start_time)
    val end_iso = micros_to_iso(end_time)
    val test_count = result.total_passed + result.total_failed
    val passed = result.total_passed
    val failed = result.total_failed
    val timed_out = result.total_timed_out

    # Use atomic update with file locking (same as Rust implementation)
    val db_path = "doc/test/test_db.sdn"
    val result_opt = atomic_update_file_test_db(
        db_path,
        run_id,
        start_iso,
        end_iso,
        test_count,
        passed,
        failed,
        timed_out
    )

    match result_opt:
        case Ok(_):
            # Success - database updated atomically
            return
        case Err(e):
            # Log error but don't fail the test run
            print "Warning: Failed to update test database: {e}"

# Atomic file update for test database
# Uses file locking + atomic write (same pattern as Rust unified_db)
fn atomic_update_file_test_db(
    path: str,
    run_id: i64,
    start_time: str,
    end_time: str,
    test_count: i64,
    passed: i64,
    failed: i64,
    timed_out: i64
) -> Result<(), str>:
    # Acquire lock
    val lock_path_result = acquire_file_lock(path, 10)
    if lock_path_result.is_err():
        return Err("Failed to acquire lock")

    val lock_path = lock_path_result.unwrap()

    # Read existing content
    var content = ""
    if rt_file_exists(path):
        content = rt_file_read_text(path)

    # Build new test_runs row
    val row = "        {run_id}, \"{start_time}\", \"{end_time}\", 0, \"simple-runner\", \"completed\", {test_count}, {passed}, {failed}, 0, {timed_out}\n"

    # Append to test_runs table
    var new_content = ""
    if content.trim() == "":
        # Create new database with test_runs table
        val header = "test_runs |run_id, start_time, end_time, pid, hostname, status, test_count, passed, failed, crashed, timed_out|\n"
        new_content = header + row
    elif content.contains("test_runs |"):
        # Append to existing test_runs table
        new_content = content.trim() + "\n" + row
    else:
        # Add test_runs table at the end
        val header = "\ntest_runs |run_id, start_time, end_time, pid, hostname, status, test_count, passed, failed, crashed, timed_out|\n"
        new_content = content.trim() + "\n" + header + row

    # Atomic write
    val success = rt_file_atomic_write(path, new_content)

    # Release lock
    rt_file_unlock(lock_path)

    if success:
        return Ok(())
    else:
        return Err("Failed to write file")

# Acquire file lock with timeout
fn acquire_file_lock(path: str, timeout_secs: i64) -> Result<str, str>:
    # Note: rt_file_lock returns Result, we just pass it through
    # In the future when try-catch is implemented, we can add error handling here
    val lock_path = rt_file_lock(path, timeout_secs)
    Ok(lock_path)

fn micros_to_iso(micros: i64) -> str:
    # Simple approximation - just use the unix timestamp
    val secs = micros / 1000000
    "{secs}"

# =========================================================================
# Environment Variable Propagation
# =========================================================================

fn propagate_env_vars(options: TestOptions):
    # Set SIMPLE_TEST_MODE for child processes
    val mode_str = mode_to_str(options.mode)
    rt_env_set("SIMPLE_TEST_MODE", mode_str)

    if options.only_slow:
        rt_env_set("SIMPLE_TEST_FILTER", "slow")
    elif options.only_skipped:
        rt_env_set("SIMPLE_TEST_FILTER", "skipped")

    if options.show_tags:
        rt_env_set("SIMPLE_TEST_SHOW_TAGS", "1")

# =========================================================================
# Runner
# =========================================================================

fn run_tests(options: TestOptions) -> TestRunResult:
    val files = discover_test_files(options.path, options)

    if options.list:
        print_discovery_summary(files, options)
        return TestRunResult(files: [], total_passed: 0, total_failed: 0, total_skipped: 0, total_timed_out: 0, total_duration_ms: 0)

    if files.len() == 0:
        print "No test files found in {options.path}"
        return TestRunResult(files: [], total_passed: 0, total_failed: 0, total_skipped: 0, total_timed_out: 0, total_duration_ms: 0)

    # Propagate env vars
    propagate_env_vars(options)

    val mode_name = mode_to_str(options.mode)
    print "Running {files.len()} test file(s) [mode: {mode_name}]..."
    if options.has_seed:
        print "Seed: {options.seed}"
    print ""

    var results: List<TestFileResult> = []
    var total_passed = 0
    var total_failed = 0
    var total_skipped = 0
    var total_timed_out = 0
    var total_duration_ms = 0

    for file_path in files:
        val result = run_single_test(file_path, options)
        print_result(result, options.format)

        total_passed = total_passed + result.passed
        total_failed = total_failed + result.failed
        total_skipped = total_skipped + result.skipped
        if result.timed_out:
            total_timed_out = total_timed_out + 1
        total_duration_ms = total_duration_ms + result.duration_ms
        results.push(result)

        if options.fail_fast and (result.failed > 0 or result.timed_out):
            print ""
            print "Stopping early (--fail-fast)"
            break

    TestRunResult(
        files: results,
        total_passed: total_passed,
        total_failed: total_failed,
        total_skipped: total_skipped,
        total_timed_out: total_timed_out,
        total_duration_ms: total_duration_ms
    )

fn mode_to_str(mode: TestExecutionMode) -> str:
    match mode:
        case TestExecutionMode.Interpreter:
            "interpreter"
        case TestExecutionMode.Smf:
            "smf"
        case TestExecutionMode.Native:
            "native"

fn run_single_test(file_path: str, options: TestOptions) -> TestFileResult:
    match options.mode:
        case TestExecutionMode.Interpreter:
            run_test_file_interpreter(file_path, options)
        case TestExecutionMode.Smf:
            run_test_file_smf(file_path, options)
        case TestExecutionMode.Native:
            run_test_file_native(file_path, options)

# =========================================================================
# Main Entry Point
# =========================================================================

fn main() -> i64:
    # Set recursion guard so child processes use Rust runner
    rt_env_set("SIMPLE_TEST_RUNNER_RUST", "1")

    val all_args = get_cli_args()

    # Filter out "test" command if present (from CLI dispatch)
    var args: List<str> = []
    var skip_first = all_args.len() > 0 and all_args[0] == "test"
    var i = if skip_first then 1 else 0
    while i < all_args.len():
        args.push(all_args[i])
        i = i + 1

    val options = parse_test_args(args)

    print "Simple Test Runner v0.3.0"
    print ""

    val run_start = rt_time_now_unix_micros()
    val result = run_tests(options)
    val run_end = rt_time_now_unix_micros()

    print_summary(result, options.format)

    # DISABLED: Test DB writes use unsafe file append without locking
    # This causes race conditions with Rust test runner and database corruption
    # TODO: Re-enable after implementing rt_file_atomic_write() FFI
    # See: doc/report/test_db_consistency_analysis_2026-01-30.md
    #
    # if not options.list and result.files.len() > 0:
    #     write_test_db_run(result, run_start, run_end)

    if result.is_ok():
        return 0
    return 1
