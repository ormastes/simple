# Test Executor Composite Platform Support
#
# Composite platform execution: baremetal, remote, QEMU targets.
#
# Split from test_runner_execute.spl for maintainability.

use test_runner_types.*
use test_executor_parsing.{find_simple_binary, build_child_args, make_result_from_output}
use app.io.file_ops.{file_exists}
use app.io.time_ops.{time_now_unix_micros}
use app.io.process_ops.{process_run_timeout}

# =========================================================================
# Composite Platform Execution
# =========================================================================

fn run_test_file_composite(file_path: text, options: TestOptions, spec: text) -> TestFileResult:
    """Execute test in composite platform mode."""
    val start = time_now_unix_micros()
    val base = extract_base_runtime(spec)
    val platform = extract_platform_layer(spec)
    val arch = extract_arch_from_spec(spec)

    # Dispatch to platform-specific runner
    if platform == "baremetal":
        return run_test_file_baremetal(file_path, options, base, arch)
    if platform == "remote":
        return run_test_file_remote(file_path, options, base, arch)

    val end = time_now_unix_micros()
    val duration_ms = (end - start) / 1000
    TestFileResult(path: file_path, passed: 0, failed: 1, skipped: 0, pending: 0,
        duration_ms: duration_ms, error: "Unknown platform: {platform}", timed_out: false)

fn extract_base_runtime(spec: text) -> text:
    """Extract base runtime from composite spec (e.g. 'interpreter' from 'interpreter(baremetal(riscv32))')."""
    val paren = spec.index_of("(") ?? -1
    if paren > 0:
        return spec[0:paren].trim()
    spec.trim()

fn extract_platform_layer(spec: text) -> text:
    """Extract platform layer from composite spec (e.g. 'baremetal' from 'interpreter(baremetal(riscv32))')."""
    val paren = spec.index_of("(") ?? -1
    if paren < 0: return ""
    val after = spec[paren + 1:]
    val paren2 = after.index_of("(") ?? -1
    if paren2 > 0: return after[0:paren2].trim()
    val close = after.index_of(")") ?? -1
    if close > 0: return after[0:close].trim()
    ""

fn extract_arch_from_spec(spec: text) -> text:
    """Extract target architecture from composite spec."""
    if spec.contains("riscv32"): return "riscv32"
    if spec.contains("arm32"): return "arm32"
    if spec.contains("aarch64"): return "aarch64"
    if spec.contains("x86_64"): return "x86_64"
    if spec.contains("x86"): return "x86"
    "host"

fn run_test_file_baremetal(file_path: text, options: TestOptions, base: text, arch: text) -> TestFileResult:
    """Execute test on bare-metal target.

    Strategy:
    - .spl files: always run via host interpreter (they may invoke QEMU themselves)
    - .elf files: run directly on QEMU with semihosting
    """
    # All .spl test files run via the host interpreter.
    # Tests that need QEMU invoke it themselves (via rt_process_run_timeout).
    # Pure-logic tests just check constants and run without QEMU.
    if file_path.ends_with(".spl"):
        return run_test_file_baremetal_via_interpreter(file_path, options, arch)

    # For ELF files, run directly on QEMU
    if file_path.ends_with(".elf"):
        return run_test_file_baremetal_qemu(file_path, options, arch, file_path)

    # Fallback: interpreter
    run_test_file_baremetal_via_interpreter(file_path, options, arch)

fn run_test_file_baremetal_via_interpreter(file_path: text, options: TestOptions, arch: text) -> TestFileResult:
    """Run baremetal logic test via host interpreter."""
    val binary = find_simple_binary()
    val child_args = build_child_args(file_path, options)
    val timeout_ms = options.timeout * 1000
    val start = time_now_unix_micros()
    val (stdout, stderr, exit_code) = process_run_timeout(binary, child_args, timeout_ms)
    val end = time_now_unix_micros()
    val duration_ms = (end - start) / 1000
    make_result_from_output(file_path, stdout, stderr, exit_code, duration_ms, options.timeout)

fn find_baremetal_elf(spec_file: text, arch: text) -> text:
    """Find prebuilt ELF for a baremetal spec file."""
    val base_dir = "examples/09_embedded/baremetal/baremetal"
    # Check for C test ELF in riscv32_test directory
    if arch == "riscv32":
        val elf = "{base_dir}/riscv32_test/test_riscv32_intensive.elf"
        if file_exists(elf):
            return elf
    # Check for SSpec-format semihost ELF
    if arch == "riscv32":
        val elf = "{base_dir}/hello_riscv32_sspec.elf"
        if file_exists(elf):
            return elf
    # Check for basic semihost ELF
    if arch == "riscv32":
        val elf = "{base_dir}/hello_riscv32_semihost.elf"
        if file_exists(elf):
            return elf
    ""

fn qemu_binary_for_arch(arch: text) -> text:
    """Get QEMU system binary for target architecture."""
    if arch == "riscv32": return "qemu-system-riscv32"
    if arch == "riscv64": return "qemu-system-riscv64"
    if arch == "arm32": return "qemu-system-arm"
    if arch == "aarch64": return "qemu-system-aarch64"
    if arch == "x86": return "qemu-system-i386"
    if arch == "x86_64": return "qemu-system-x86_64"
    ""

fn qemu_machine_for_arch(arch: text) -> text:
    """Get QEMU machine type for target architecture."""
    if arch == "riscv32": return "virt"
    if arch == "riscv64": return "virt"
    if arch == "arm32": return "virt"
    if arch == "aarch64": return "virt"
    if arch == "x86": return "pc"
    if arch == "x86_64": return "q35"
    "virt"

fn run_test_file_baremetal_qemu(file_path: text, options: TestOptions, arch: text, elf_path: text) -> TestFileResult:
    """Execute a prebuilt ELF on QEMU with semihosting and parse results."""
    val start = time_now_unix_micros()
    val qemu_bin = qemu_binary_for_arch(arch)
    val machine = qemu_machine_for_arch(arch)

    if qemu_bin == "":
        val end = time_now_unix_micros()
        val duration_ms = (end - start) / 1000
        return TestFileResult(path: file_path, passed: 0, failed: 1, skipped: 0, pending: 0,
            duration_ms: duration_ms, error: "No QEMU binary for arch: {arch}", timed_out: false)

    # Build QEMU command args
    var qemu_args: [text] = [
        "-M", machine,
        "-bios", "none",
        "-kernel", elf_path,
        "-nographic",
        "-semihosting-config", "enable=on,target=native",
    ]

    val timeout_ms = options.timeout * 1000
    val (stdout, stderr, exit_code) = process_run_timeout(qemu_bin, qemu_args, timeout_ms)
    val end = time_now_unix_micros()
    val duration_ms = (end - start) / 1000

    # Parse SSpec-format output from QEMU semihosting
    make_result_from_output(file_path, stdout, stderr, exit_code, duration_ms, options.timeout)

fn run_test_file_remote(file_path: text, options: TestOptions, base: text, arch: text) -> TestFileResult:
    """Execute test on remote target via QEMU.

    For .spl files: run via host interpreter (same as baremetal mode).
    For .elf files: launch QEMU with semihosting, capture output, parse results.
    """
    val start = time_now_unix_micros()

    # .spl files run via host interpreter — they may invoke QEMU themselves
    if file_path.ends_with(".spl"):
        return run_test_file_baremetal_via_interpreter(file_path, options, arch)

    # .elf files run directly on QEMU with semihosting
    if file_path.ends_with(".elf"):
        return run_test_file_baremetal_qemu(file_path, options, arch, file_path)

    # Unknown file type — try to find a prebuilt ELF for this spec
    val elf_path = find_baremetal_elf(file_path, arch)
    if elf_path != "":
        return run_test_file_baremetal_qemu(file_path, options, arch, elf_path)

    # Fallback: run via host interpreter
    run_test_file_baremetal_via_interpreter(file_path, options, arch)

# =========================================================================
# Exports
# =========================================================================

export run_test_file_composite
export extract_base_runtime, extract_platform_layer, extract_arch_from_spec
export run_test_file_baremetal, run_test_file_remote
export run_test_file_baremetal_via_interpreter, run_test_file_baremetal_qemu
export find_baremetal_elf, qemu_binary_for_arch, qemu_machine_for_arch
