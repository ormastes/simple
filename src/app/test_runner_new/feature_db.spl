# Feature Database
#
# Parse and update feature_db.sdn from test results.

extern fn rt_file_exists(path: text) -> bool
extern fn rt_file_read_text(path: text) -> text
extern fn rt_file_atomic_write(path: text, content: text) -> bool

use test_db_lock.FileLock

# =========================================================================
# Constants
# =========================================================================

val FEATURE_DB_PATH = "doc/feature/feature_db.sdn"

# =========================================================================
# Feature Record
# =========================================================================

struct FeatureRecord:
    id: text
    category: text
    name: text
    description: text
    spec: text
    mode_interpreter: text
    mode_jit: text
    mode_smf_cranelift: text
    mode_smf_llvm: text
    platforms: text
    status: text
    valid: bool

# =========================================================================
# Feature Database
# =========================================================================

struct FeatureDatabase:
    features: List<FeatureRecord>

impl FeatureDatabase:
    static fn empty() -> FeatureDatabase:
        FeatureDatabase(features: [])

    static fn load() -> FeatureDatabase:
        if not rt_file_exists(FEATURE_DB_PATH):
            return FeatureDatabase.empty()

        val content = rt_file_read_text(FEATURE_DB_PATH)
        FeatureDatabase.parse(content)

    static fn parse(content: text) -> FeatureDatabase:
        var features: List<FeatureRecord> = []
        val lines = content.split("\n")
        var in_table = false

        for line in lines:
            val trimmed = line.trim()
            if trimmed.starts_with("features |"):
                in_table = true
                continue
            if not in_table or trimmed == "" or trimmed.starts_with("#"):
                # If we hit another table header, stop
                if in_table and trimmed != "" and not trimmed.starts_with("#") and not trimmed.starts_with(" "):
                    in_table = false
                continue

            val fields = parse_feature_fields(trimmed)
            if fields.len() >= 12:
                features.push(FeatureRecord(
                    id: fields[0],
                    category: fields[1],
                    name: fields[2],
                    description: fields[3],
                    spec: fields[4],
                    mode_interpreter: fields[5],
                    mode_jit: fields[6],
                    mode_smf_cranelift: fields[7],
                    mode_smf_llvm: fields[8],
                    platforms: fields[9],
                    status: fields[10],
                    valid: fields[11] == "true"
                ))

        FeatureDatabase(features: features)

    fn find_by_id(id: text) -> i64:
        var i = 0
        while i < self.features.len():
            if self.features[i].id == id:
                return i
            i = i + 1
        -1

    me update_feature(id: text, status: text):
        val idx = self.find_by_id(id)
        if idx >= 0:
            self.features[idx].status = status
            self.features[idx].valid = true

    me mark_invalid(id: text):
        val idx = self.find_by_id(id)
        if idx >= 0:
            self.features[idx].valid = false

    fn save() -> Result<(), text>:
        val lock_result = FileLock.acquire(FEATURE_DB_PATH, 10)
        if lock_result.err.?:
            return Err(lock_result.unwrap_err())
        val lock = lock_result.unwrap()

        val content = self.serialize()
        val success = rt_file_atomic_write(FEATURE_DB_PATH, content)
        lock.release()

        if success:
            Ok(())
        else:
            Err("Failed to write {FEATURE_DB_PATH}")

    fn serialize() -> text:
        var lines: List<text> = []
        lines.push("features |id, category, name, description, spec, mode_interpreter, mode_jit, mode_smf_cranelift, mode_smf_llvm, platforms, status, valid|")

        for f in self.features:
            val valid_str = if f.valid: "true" else: "false"
            val desc = quote_if_needed(f.description)
            val name = quote_if_needed(f.name)
            val cat = quote_if_needed(f.category)
            val spec = quote_if_needed(f.spec)
            lines.push("    {f.id}, {cat}, {name}, {desc}, {spec}, {f.mode_interpreter}, {f.mode_jit}, {f.mode_smf_cranelift}, {f.mode_smf_llvm}, {f.platforms}, {f.status}, {valid_str}")

        lines.join("\n") + "\n"

    # -----------------------------------------------------------------
    # Category helpers
    # -----------------------------------------------------------------

    fn categories() -> List<text>:
        var cats: List<text> = []
        var seen: Dict<text, bool> = {}
        for f in self.features:
            if not seen.contains_key(f.category):
                cats.push(f.category)
                seen[f.category] = true
        cats

    fn features_by_category(category: text) -> List<FeatureRecord>:
        var result: List<FeatureRecord> = []
        for f in self.features:
            if f.category == category and f.valid:
                result.push(f)
        result

    fn count_by_status(status: text) -> i64:
        var count = 0
        for f in self.features:
            if f.valid and f.status == status:
                count = count + 1
        count

# =========================================================================
# Helpers
# =========================================================================

fn parse_feature_fields(line: text) -> List<text>:
    # Reuse CSV-like parsing with quote support
    var fields: List<text> = []
    var i = 0
    var current = ""
    var in_quote = false

    while i < line.len():
        val ch = line[i]
        if in_quote:
            if ch == "\\" and i + 1 < line.len():
                current = current + line[i + 1]
                i = i + 2
                continue
            if ch == "\"":
                in_quote = false
                i = i + 1
                continue
            current = current + ch
        else:
            if ch == "\"":
                in_quote = true
                i = i + 1
                continue
            if ch == ",":
                fields.push(current.trim())
                current = ""
                i = i + 1
                continue
            current = current + ch
        i = i + 1

    fields.push(current.trim())
    fields

fn quote_if_needed(s: text) -> text:
    if s == "":
        return ""
    if s.contains(",") or s.contains("\"") or s.contains("\n"):
        val escaped = s.replace("\\", "\\\\").replace("\"", "\\\"")
        return "\"{escaped}\""
    s

export FeatureDatabase, FeatureRecord, FEATURE_DB_PATH
