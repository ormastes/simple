# Test Database Validation
#
# Validates run record integrity: stale runs, dead processes,
# timestamp consistency, count consistency, status consistency.
#
# Simplified version for interpreter mode - only includes
# validate_run_record (no TestDatabase/StringInterner dependencies).

use app.io.mod (time_now_unix_micros, is_dir)
use app.test_runner_new.test_db_compat (parse_rfc3339_to_micros)
use app.test_runner_new.test_db_types (RunRecord)

# =========================================================================
# Validation Issue
# =========================================================================

struct ValidationIssue:
    violation_type: text
    severity: text
    message: text
    auto_fixable: bool

# =========================================================================
# Validation Report
# =========================================================================

struct ValidationReport:
    violations: List<ValidationIssue>
    auto_fixable: bool

impl ValidationReport:
    fn has_violations() -> bool:
        self.violations.len() > 0

    fn max_severity() -> text:
        var has_critical = false
        var has_error = false
        var has_warning = false

        for v in self.violations:
            if v.severity == "Critical":
                has_critical = true
            elif v.severity == "Error":
                has_error = true
            elif v.severity == "Warning":
                has_warning = true

        if has_critical:
            "Critical"
        elif has_error:
            "Error"
        elif has_warning:
            "Warning"
        else:
            "Info"

# =========================================================================
# Process Existence Check
# =========================================================================

fn process_exists(pid: i64) -> bool:
    # Check if process exists via /proc filesystem (Linux)
    is_dir("/proc/{pid}")

# =========================================================================
# Run Record Validation
# =========================================================================

fn validate_run_record(run: RunRecord) -> ValidationReport:
    var violations: List<ValidationIssue> = []
    var any_auto_fixable = false

    val now_micros = time_now_unix_micros()
    val start_micros = parse_rfc3339_to_micros(run.start_time)
    val end_micros = if run.end_time != "": parse_rfc3339_to_micros(run.end_time) else: 0

    # Check stale running (>2 hours old)
    if run.status == "Running":
        val age_hours = (now_micros - start_micros) / (3600 * 1000000)
        if age_hours > 2:
            violations.push(ValidationIssue(
                violation_type: "StaleRunning",
                severity: "Warning",
                message: "Run {run.run_id} has been running for {age_hours} hours (>2 hour threshold)",
                auto_fixable: true
            ))
            any_auto_fixable = true

    # Check dead process
    if run.status == "Running":
        if not process_exists(run.pid):
            violations.push(ValidationIssue(
                violation_type: "DeadProcess",
                severity: "Error",
                message: "Run {run.run_id} process {run.pid} no longer exists",
                auto_fixable: true
            ))
            any_auto_fixable = true

    # Check timestamp consistency
    if run.end_time != "" and start_micros > 0 and end_micros > 0:
        if end_micros < start_micros:
            violations.push(ValidationIssue(
                violation_type: "TimestampInconsistent",
                severity: "Error",
                message: "Run {run.run_id} end_time ({run.end_time}) before start_time ({run.start_time})",
                auto_fixable: false
            ))

    # Check future timestamps
    if start_micros > now_micros:
        violations.push(ValidationIssue(
            violation_type: "FutureTimestamp",
            severity: "Critical",
            message: "Run {run.run_id} has future start_time ({run.start_time})",
            auto_fixable: false
        ))

    # Check count consistency
    val sum_counts = run.passed + run.failed + run.crashed + run.timed_out
    if sum_counts > run.test_count:
        violations.push(ValidationIssue(
            violation_type: "CountInconsistent",
            severity: "Error",
            message: "Run {run.run_id} count sum ({sum_counts}) > test_count ({run.test_count})",
            auto_fixable: false
        ))

    # Check status consistency
    if run.status == "Completed" or run.status == "Crashed":
        if run.end_time == "":
            violations.push(ValidationIssue(
                violation_type: "StatusInconsistent",
                severity: "Error",
                message: "Run {run.run_id} has status {run.status} but no end_time",
                auto_fixable: false
            ))
    elif run.status == "Running":
        if run.end_time != "":
            violations.push(ValidationIssue(
                violation_type: "StatusInconsistent",
                severity: "Warning",
                message: "Run {run.run_id} has status Running but has end_time",
                auto_fixable: false
            ))

    # Check invalid timestamp format (if parse returned 0 for non-empty string)
    if run.start_time != "" and start_micros == 0:
        violations.push(ValidationIssue(
            violation_type: "InvalidValue",
            severity: "Error",
            message: "Run {run.run_id} has invalid start_time format: {run.start_time}",
            auto_fixable: false
        ))

    ValidationReport(
        violations: violations,
        auto_fixable: any_auto_fixable
    )

export ValidationIssue, ValidationReport
export validate_run_record, process_exists
