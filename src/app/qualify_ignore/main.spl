# Simple CLI - qualify-ignore command
# Scan test files for unqualified #[ignore] annotations

use app.cli_util (get_cli_args)

extern fn rt_file_exists(path: text) -> bool
extern fn rt_file_read_text(path: text) -> text
extern fn rt_file_write_text(path: text, content: text) -> bool
extern fn rt_env_cwd() -> text
extern fn rt_dir_walk(path: text) -> [text]

fn print_help():
    print "Usage: simple qualify-ignore [path] [options]"
    print ""
    print "Scan test files for #[ignore] without qualification reason."
    print ""
    print "Arguments:"
    print "  [path]           Directory to scan (default: test/)"
    print ""
    print "Options:"
    print "  --fix            Add placeholder reason to unqualified ignores"
    print "  --strict         Exit with error if unqualified ignores found"
    print "  -h, --help       Show this help"

fn scan_file(path: text) -> [(i64, text)]:
    val content = rt_file_read_text(path)
    val lines = content.split("\n")
    var issues = []
    var line_num = 1

    for line in lines:
        val trimmed = line.trim()
        if trimmed == "#[ignore]" or trimmed == "# ignore" or trimmed == "skip":
            issues.push((line_num, trimmed))
        line_num = line_num + 1

    issues

fn fix_file(path: text) -> i64:
    val content = rt_file_read_text(path)
    val lines = content.split("\n")
    var result = []
    var fixed = 0

    for line in lines:
        val trimmed = line.trim()
        if trimmed == "#[ignore]":
            result.push(line.replace("#[ignore]", "#[ignore = \"TODO: add reason\"]"))
            fixed = fixed + 1
        else:
            result.push(line)

    if fixed > 0:
        rt_file_write_text(path, result.join("\n"))

    fixed

fn main() -> i64:
    val args = get_cli_args()

    var scan_path = ""
    var fix_mode = false
    var strict = false

    for arg in args:
        if arg == "-h" or arg == "--help":
            print_help()
            return 0
        elif arg == "--fix":
            fix_mode = true
        elif arg == "--strict":
            strict = true
        elif not arg.starts_with("-"):
            scan_path = arg

    val cwd = rt_env_cwd()
    if scan_path == "":
        scan_path = "{cwd}/test"

    if not rt_file_exists(scan_path):
        print "error: path not found: {scan_path}"
        return 1

    val files = rt_dir_walk(scan_path)
    var total_issues = 0
    var total_fixed = 0

    for file in files:
        if not file.ends_with(".spl") and not file.ends_with(".rs"):
            pass
        else:
            if fix_mode:
                val fixed = fix_file(file)
                if fixed > 0:
                    val display = if file.starts_with(cwd): file[cwd.len() + 1:] else: file
                    print "Fixed {fixed} unqualified ignore(s) in {display}"
                    total_fixed = total_fixed + fixed
            else:
                val issues = scan_file(file)
                if issues.len() > 0:
                    val display = if file.starts_with(cwd): file[cwd.len() + 1:] else: file
                    for (line_num, line_text) in issues:
                        print "{display}:{line_num}: unqualified ignore: {line_text}"
                    total_issues = total_issues + issues.len()

    if fix_mode:
        print ""
        print "Fixed {total_fixed} unqualified ignore(s)"
    else:
        if total_issues == 0:
            print "All ignores are qualified."
        else:
            print ""
            print "Found {total_issues} unqualified ignore(s)"
            if strict:
                return 1

    0
