# tools_jj_git.spl - Git interop tools (5 tools)
#
# Tools: git_fetch, git_push, git_clone, git_remote, git_export

use app.mcp_jj.helpers.{LB, RB, Q, jp, js, jo1, jo2, jo3, escape_json, make_tool_result, make_error_response, make_tool_schema_multi, make_tool_schema, make_no_param_tool, make_prop, make_prop_bool, make_prop_int, extract_nested_string, extract_arguments_dict}
use app.mcp_jj.jj_runner.{JjResult, jj_run, jj_run_with_args, shell_quote}

# --- 31. jj_git_fetch ---

fn schema_jj_git_fetch() -> String:
    make_tool_schema("jj_git_fetch", "Fetch from a git remote", "remote", "Remote to fetch from (default: origin)", false, false, false, true)

fn handle_jj_git_fetch(id: String, body: String, repo_path: String) -> String:
    val remote = extract_nested_string(body, "arguments", "remote")
    var cmd = "git fetch"
    if remote != "":
        cmd = cmd + " --remote " + remote
    val result = jj_run(cmd, repo_path)
    if result.success:
        make_tool_result(id, result.stdout + result.stderr)
    else:
        make_error_response(id, -32603, result.stderr)

# --- 32. jj_git_push ---

fn schema_jj_git_push() -> String:
    var props = LB()
    props = props + make_prop("remote", "Remote to push to (default: origin)")
    props = props + "," + make_prop("bookmark", "Bookmark to push")
    props = props + "," + make_prop_bool("all", "Push all bookmarks")
    props = props + "," + make_prop("change", "Push this change's bookmark")
    props = props + RB()
    make_tool_schema_multi("jj_git_push", "Push to a git remote", props, "[]", false, false, false)

fn handle_jj_git_push(id: String, body: String, repo_path: String) -> String:
    val remote = extract_nested_string(body, "arguments", "remote")
    val bookmark = extract_nested_string(body, "arguments", "bookmark")
    val all = extract_nested_string(body, "arguments", "all")
    val change = extract_nested_string(body, "arguments", "change")
    var cmd = "git push"
    if remote != "":
        cmd = cmd + " --remote " + remote
    if bookmark != "":
        cmd = cmd + " --bookmark " + bookmark
    if all == "true":
        cmd = cmd + " --all"
    if change != "":
        cmd = cmd + " --change " + change
    val result = jj_run(cmd, repo_path)
    if result.success:
        make_tool_result(id, result.stdout + result.stderr)
    else:
        make_error_response(id, -32603, result.stderr)

# --- 33. jj_git_clone ---

fn schema_jj_git_clone() -> String:
    var props = LB()
    props = props + make_prop("url", "URL of the git repository to clone")
    props = props + "," + make_prop("destination", "Directory to clone into")
    props = props + "," + make_prop_bool("colocate", "Create a colocated jj+git repository")
    props = props + RB()
    make_tool_schema_multi("jj_git_clone", "Clone a git repository into a new jj repository", props, "[" + js("url") + "]", false, false, false)

fn handle_jj_git_clone(id: String, body: String, repo_path: String) -> String:
    val url = extract_nested_string(body, "arguments", "url")
    val destination = extract_nested_string(body, "arguments", "destination")
    val colocate = extract_nested_string(body, "arguments", "colocate")
    if url == "":
        return make_error_response(id, -32602, "Missing required parameter: url")
    var cmd = "git clone"
    if colocate == "true":
        cmd = cmd + " --colocate"
    cmd = cmd + " " + url
    if destination != "":
        cmd = cmd + " " + destination
    val result = jj_run(cmd, repo_path)
    if result.success:
        make_tool_result(id, result.stdout + result.stderr)
    else:
        make_error_response(id, -32603, result.stderr)

# --- 34. jj_git_remote ---

fn schema_jj_git_remote() -> String:
    var props = LB()
    props = props + make_prop("action", "Action to perform: add, list, remove, or rename")
    props = props + "," + make_prop("name", "Remote name")
    props = props + "," + make_prop("url", "Remote URL (for add)")
    props = props + "," + make_prop("new_name", "New remote name (for rename)")
    props = props + RB()
    make_tool_schema_multi("jj_git_remote", "Manage git remotes", props, "[" + js("action") + "]", false, false, false)

fn handle_jj_git_remote(id: String, body: String, repo_path: String) -> String:
    val action = extract_nested_string(body, "arguments", "action")
    val name = extract_nested_string(body, "arguments", "name")
    val url = extract_nested_string(body, "arguments", "url")
    val new_name = extract_nested_string(body, "arguments", "new_name")
    if action == "":
        return make_error_response(id, -32602, "Missing required parameter: action")
    var cmd = "git remote"
    if action == "add":
        if name == "" or url == "":
            return make_error_response(id, -32602, "Remote add requires name and url")
        cmd = cmd + " add " + name + " " + url
    elif action == "list":
        cmd = cmd + " list"
    elif action == "remove":
        if name == "":
            return make_error_response(id, -32602, "Remote remove requires name")
        cmd = cmd + " remove " + name
    elif action == "rename":
        if name == "" or new_name == "":
            return make_error_response(id, -32602, "Remote rename requires name and new_name")
        cmd = cmd + " rename " + name + " " + new_name
    else:
        return make_error_response(id, -32602, "Invalid action. Use: add, list, remove, rename")
    val result = jj_run(cmd, repo_path)
    if result.success:
        make_tool_result(id, result.stdout + result.stderr)
    else:
        make_error_response(id, -32603, result.stderr)

# --- 35. jj_git_export ---

fn schema_jj_git_export() -> String:
    make_no_param_tool("jj_git_export", "Export jj changes to the underlying git repository refs", false, false, true)

fn handle_jj_git_export(id: String, body: String, repo_path: String) -> String:
    val result = jj_run("git export", repo_path)
    if result.success:
        make_tool_result(id, result.stdout + result.stderr)
    else:
        make_error_response(id, -32603, result.stderr)

export schema_jj_git_fetch, schema_jj_git_push, schema_jj_git_clone
export schema_jj_git_remote, schema_jj_git_export
export handle_jj_git_fetch, handle_jj_git_push, handle_jj_git_clone
export handle_jj_git_remote, handle_jj_git_export
