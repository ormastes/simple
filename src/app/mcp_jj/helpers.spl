# helpers.spl - MCP helpers for jj-git server
#
# Re-exports from app.mcp.helpers and adds jj-specific utilities.

use app.mcp.helpers.{LB, RB, Q, parse_int, min_int, unwrap_idx, unwrap_str, get_clean_args, jp, js, jo1, jo2, jo3, extract_json_string_v2, extract_json_string, extract_json_value, extract_nested_string, extract_arguments_dict, escape_json, make_tool_result, make_result_response, make_error_response, make_tool_schema_multi, has_flag, make_notification, make_notification_no_params}
use app.mcp_jj.jj_runner.{JjResult}
# Note: escape_json already imported from app.mcp.helpers above

# Re-export everything from app.mcp.helpers
export LB, RB, Q
export parse_int, min_int, unwrap_idx, unwrap_str
export get_clean_args
export jp, js, jo1, jo2, jo3
export extract_json_string_v2, extract_json_string, extract_json_value, extract_nested_string, extract_arguments_dict
export escape_json
export make_tool_result, make_result_response, make_error_response
export make_tool_schema_multi
export has_flag
export make_notification, make_notification_no_params

# --- jj-specific tool schema builder ---

fn make_tool_schema(name: String, desc: String, prop_name: String, prop_desc: String, required: Bool, read_only: Bool, destructive: Bool, idempotent: Bool) -> String:
    val prop = jo2(jp("type", js("string")), jp("description", js(desc)))
    val props = jo1(jp(prop_name, prop))
    var req_arr = "[]"
    if required:
        req_arr = "[" + js(prop_name) + "]"
    val schema = jo3(jp("type", js("object")), jp("properties", props), jp("required", req_arr))

    var annot = LB()
    var ro = "false"
    if read_only:
        ro = "true"
    annot = annot + jp("readOnlyHint", ro)
    annot = annot + ","
    var dest = "false"
    if destructive:
        dest = "true"
    annot = annot + jp("destructiveHint", dest)
    annot = annot + ","
    var idemp = "false"
    if idempotent:
        idemp = "true"
    annot = annot + jp("idempotentHint", idemp)
    annot = annot + ","
    annot = annot + jp("openWorldHint", "false")
    annot = annot + RB()

    var result = LB()
    result = result + jp("name", js(name))
    result = result + ","
    result = result + jp("description", js(escape_json(desc)))
    result = result + ","
    result = result + jp("inputSchema", schema)
    result = result + ","
    result = result + jp("annotations", annot)
    result = result + RB()
    result

fn make_no_param_tool(name: String, desc: String, read_only: Bool, destructive: Bool, idempotent: Bool) -> String:
    val schema = jo2(jp("type", js("object")), jp("properties", LB() + RB()))

    var annot = LB()
    var ro = "false"
    if read_only:
        ro = "true"
    annot = annot + jp("readOnlyHint", ro)
    annot = annot + ","
    var dest = "false"
    if destructive:
        dest = "true"
    annot = annot + jp("destructiveHint", dest)
    annot = annot + ","
    var idemp = "false"
    if idempotent:
        idemp = "true"
    annot = annot + jp("idempotentHint", idemp)
    annot = annot + ","
    annot = annot + jp("openWorldHint", "false")
    annot = annot + RB()

    var result = LB()
    result = result + jp("name", js(name))
    result = result + ","
    result = result + jp("description", js(escape_json(desc)))
    result = result + ","
    result = result + jp("inputSchema", schema)
    result = result + ","
    result = result + jp("annotations", annot)
    result = result + RB()
    result

fn make_prop(name: String, desc: String) -> String:
    jp(name, jo2(jp("type", js("string")), jp("description", js(escape_json(desc)))))

fn make_prop_bool(name: String, desc: String) -> String:
    jp(name, jo2(jp("type", js("boolean")), jp("description", js(escape_json(desc)))))

fn make_prop_int(name: String, desc: String) -> String:
    jp(name, jo2(jp("type", js("integer")), jp("description", js(escape_json(desc)))))

fn handle_jj_result(id: String, result: JjResult) -> String:
    """Handle JjResult and return appropriate MCP response.
    
    Args:
        id: Request ID
        result: Result from jj_run
    
    Returns:
        JSON response (either success or error)
    """
    if result.success:
        make_tool_result(id, result.stdout + result.stderr)
    else:
        make_error_response(id, -32603, result.stderr)

fn truncate_output(output: String) -> String:
    """Truncate large command output to avoid hanging on giant diffs."""
    val max_chars = 50000
    if output.len() <= max_chars:
        return output
    val truncated = output.substring(0, max_chars)
    truncated + "\n\n[... output truncated at 50000 chars. Use --summary flag to see only changed file list ...]"

fn handle_jj_result_stdout(id: String, result: JjResult) -> String:
    """Handle JjResult (stdout only) and return appropriate MCP response.

    Args:
        id: Request ID
        result: Result from jj_run

    Returns:
        JSON response (either success or error)
    """
    if result.success:
        make_tool_result(id, truncate_output(result.stdout))
    else:
        make_error_response(id, -32603, result.stderr)

export make_tool_schema, make_no_param_tool, make_prop, make_prop_bool, make_prop_int, handle_jj_result, handle_jj_result_stdout, truncate_output
