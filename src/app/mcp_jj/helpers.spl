# helpers.spl - MCP helpers for jj-git server
#
# Re-exports from app.mcp.helpers and adds jj-specific utilities.

use app.mcp.helpers.{LB, RB, Q, parse_int, min_int, unwrap_idx, unwrap_str, get_clean_args, jp, js, jo1, jo2, jo3, extract_json_string_v2, extract_json_string, extract_json_value, extract_nested_string, extract_arguments_dict, escape_json, make_tool_result, make_result_response, make_error_response, make_tool_schema_multi, has_flag, make_notification, make_notification_no_params}
use lib.json.builder.{escape_json as esc_json}

# Re-export everything from app.mcp.helpers
export LB, RB, Q
export parse_int, min_int, unwrap_idx, unwrap_str
export get_clean_args
export jp, js, jo1, jo2, jo3
export extract_json_string_v2, extract_json_string, extract_json_value, extract_nested_string, extract_arguments_dict
export escape_json
export make_tool_result, make_result_response, make_error_response
export make_tool_schema_multi
export has_flag
export make_notification, make_notification_no_params

# --- jj-specific tool schema builder ---

fn make_tool_schema(name: String, desc: String, prop_name: String, prop_desc: String, required: Bool, read_only: Bool, destructive: Bool, idempotent: Bool) -> String:
    val prop = jo2(jp("type", js("string")), jp("description", js(desc)))
    val props = jo1(jp(prop_name, prop))
    var req_arr = "[]"
    if required:
        req_arr = "[" + js(prop_name) + "]"
    val schema = jo3(jp("type", js("object")), jp("properties", props), jp("required", req_arr))

    var annot = LB()
    var ro = "false"
    if read_only:
        ro = "true"
    annot = annot + jp("readOnlyHint", ro)
    annot = annot + ","
    var dest = "false"
    if destructive:
        dest = "true"
    annot = annot + jp("destructiveHint", dest)
    annot = annot + ","
    var idemp = "false"
    if idempotent:
        idemp = "true"
    annot = annot + jp("idempotentHint", idemp)
    annot = annot + ","
    annot = annot + jp("openWorldHint", "false")
    annot = annot + RB()

    var result = LB()
    result = result + jp("name", js(name))
    result = result + ","
    result = result + jp("description", js(esc_json(desc)))
    result = result + ","
    result = result + jp("inputSchema", schema)
    result = result + ","
    result = result + jp("annotations", annot)
    result = result + RB()
    result

fn make_no_param_tool(name: String, desc: String, read_only: Bool, destructive: Bool, idempotent: Bool) -> String:
    val schema = jo2(jp("type", js("object")), jp("properties", LB() + RB()))

    var annot = LB()
    var ro = "false"
    if read_only:
        ro = "true"
    annot = annot + jp("readOnlyHint", ro)
    annot = annot + ","
    var dest = "false"
    if destructive:
        dest = "true"
    annot = annot + jp("destructiveHint", dest)
    annot = annot + ","
    var idemp = "false"
    if idempotent:
        idemp = "true"
    annot = annot + jp("idempotentHint", idemp)
    annot = annot + ","
    annot = annot + jp("openWorldHint", "false")
    annot = annot + RB()

    var result = LB()
    result = result + jp("name", js(name))
    result = result + ","
    result = result + jp("description", js(esc_json(desc)))
    result = result + ","
    result = result + jp("inputSchema", schema)
    result = result + ","
    result = result + jp("annotations", annot)
    result = result + RB()
    result

fn make_prop(name: String, desc: String) -> String:
    jp(name, jo2(jp("type", js("string")), jp("description", js(esc_json(desc)))))

fn make_prop_bool(name: String, desc: String) -> String:
    jp(name, jo2(jp("type", js("boolean")), jp("description", js(esc_json(desc)))))

fn make_prop_int(name: String, desc: String) -> String:
    jp(name, jo2(jp("type", js("integer")), jp("description", js(esc_json(desc)))))

export make_tool_schema, make_no_param_tool, make_prop, make_prop_bool, make_prop_int
