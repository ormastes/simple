# MCP Server for Jujutsu (jj) with Git Compatibility Layer
#
# Provides:
#   - 48 native jj_* tools
#   - 27 git_* compatibility tools (translates git commands to jj)
#   - 5 resources (status, log, bookmarks, conflicts, op-log)
#   - 4 prompts (workflow, git-to-jj, revset-reference, concepts)
#
# Usage:
#   simple src/app/mcp_jj/main.spl server     # Start MCP server (stdio)
#   simple src/app/mcp_jj/main.spl version     # Show jj version

use app.io.mod (get_args, exit)
use app.mcp.helpers.{get_clean_args, extract_json_string_v2, extract_json_value, extract_nested_string, make_result_response, make_error_response, jp, js, jo1, unwrap_idx}
use std.mcp.protocol.{create_protocol_state, protocol_read_message, protocol_write_message}
use std.mcp_sdk.server.builder.{ServerConfig, server_config, server_set_instructions, server_add_tool_json}
use std.mcp_sdk.server.router.{handle_method}
use jj_runner.{get_default_repo_path, get_jj_version, is_jj_repo}
use tools_jj.{get_all_jj_tool_schemas, handle_jj_tool}
use tools_git.{get_all_git_tool_schemas, handle_git_tool}
use resources.{get_all_resources, read_resource}
use prompts.{get_all_prompts, get_prompt}
use std.text.{NL}

# Protocol state
var PROTOCOL = create_protocol_state()

fn main():
    val raw_args = get_args()
    val args = get_clean_args(raw_args)

    if args.len() < 1:
        print_usage()
        exit(1)

    val command = args[0]

    if command == "--help" or command == "-h":
        print_usage()
        exit(0)
    elif command == "server":
        start_server()
    elif command == "version":
        print(get_jj_version())
    else:
        print_usage()
        exit(1)

fn print_usage():
    print("jj-git MCP Server - Jujutsu with Git Compatibility Layer")
    print("")
    print("Usage:")
    print("  simple src/app/mcp_jj/main.spl server   # Start MCP server (stdio)")
    print("  simple src/app/mcp_jj/main.spl version   # Show jj version")
    print("")
    print("Environment:")
    print("  JJ_MCP_REPO_PATH      Default repository path (default: cwd)")
    print("  JJ_MCP_SHOW_WARNINGS  Show git compat warnings (default: true)")

# --- Server config (built once at startup) ---

fn build_server_config() -> ServerConfig:
    val instructions = "This MCP server provides Jujutsu (jj) version control tools. It includes 48 native jj_* tools for full jj functionality, plus 27 git_* compatibility tools that translate git commands to jj equivalents with helpful warnings. Use jj_* tools for best results. If you see git_* tools being called, the response will include a warning explaining the jj equivalent."
    var cfg = server_config("jj-git-mcp", "1.0.0")
    cfg = server_set_instructions(cfg, instructions)

    # Register all tool schemas
    val jj_tools = get_all_jj_tool_schemas()
    var i = 0
    while i < jj_tools.len():
        cfg = server_add_tool_json(cfg, "", jj_tools[i])
        i = i + 1
    val git_tools = get_all_git_tool_schemas()
    i = 0
    while i < git_tools.len():
        cfg = server_add_tool_json(cfg, "", git_tools[i])
        i = i + 1

    cfg

# --- Server loop ---

fn start_server():
    val CFG = build_server_config()
    var repo_path = ""

    var running = true
    for _iter in range(0, 999999):
        if not running:
            return
        val line = read_stdin_message()
        if line == "":
            running = false
        else:
            val method = extract_json_string_v2(line, "method")
            val id = extract_json_value(line, "id")
            var response = ""

            # Resources/prompts list handled locally (existing modules)
            if method == "resources/list":
                if repo_path == "":
                    repo_path = get_default_repo_path()
                response = handle_resources_list(id, repo_path)
            elif method == "prompts/list":
                response = handle_prompts_list(id)
            else:
                # SDK router handles builtins + returns sentinels for custom dispatch
                response = handle_method(CFG, method, id, line)
                if response == "TOOLS_CALL":
                    if repo_path == "":
                        repo_path = get_default_repo_path()
                    val tool_name = extract_nested_string(line, "params", "name")
                    response = handle_tool_call(id, tool_name, line, repo_path)
                    # Check if git_set_working_dir changed the repo path
                    if tool_name == "git_set_working_dir":
                        val new_path = extract_repo_path_change(response)
                        if new_path != "":
                            repo_path = new_path
                elif response == "RESOURCES_READ":
                    if repo_path == "":
                        repo_path = get_default_repo_path()
                    val uri = extract_nested_string(line, "params", "uri")
                    response = handle_resources_read(id, uri, repo_path)
                elif response == "PROMPTS_GET":
                    val prompt_name = extract_nested_string(line, "params", "name")
                    response = handle_prompts_get(id, prompt_name)
                elif response == "EXIT":
                    exit(0)

            if response != "":
                write_stdout_message(response)

# --- Protocol I/O ---

fn read_stdin_message() -> String:
    protocol_read_message(PROTOCOL)

fn write_stdout_message(body: String):
    protocol_write_message(PROTOCOL, body)

# --- Tool dispatch ---

fn handle_tool_call(id: String, tool_name: String, body: String, repo_path: String) -> String:
    # Try jj_* tools first
    if tool_name.starts_with("jj_"):
        val result = handle_jj_tool(id, tool_name, body, repo_path)
        if result != "":
            return result

    # Try git_* tools
    if tool_name.starts_with("git_"):
        val result = handle_git_tool(id, tool_name, body, repo_path)
        if result != "":
            return result

    make_error_response(id, -32602, "Unknown tool: " + tool_name)

fn extract_repo_path_change(response: String) -> String:
    val marker = "SET_REPO_PATH:"
    val idx = unwrap_idx(response.index_of(marker))
    if idx < 0:
        return ""
    val after = response.substring(idx + marker.len())
    val end_idx = unwrap_idx(after.index_of("\""))
    if end_idx < 0:
        return after.trim()
    after.substring(0, end_idx).trim()

# --- Resources ---

fn handle_resources_list(id: String, repo_path: String) -> String:
    val resources_json = get_all_resources(repo_path)
    val result = jo1(jp("resources", resources_json))
    make_result_response(id, result)

fn handle_resources_read(id: String, uri: String, repo_path: String) -> String:
    val content = read_resource(uri, repo_path)
    if content == "":
        return make_error_response(id, -32602, "Resource not found: " + uri)
    val result = jo1(jp("contents", "[" + content + "]"))
    make_result_response(id, result)

# --- Prompts ---

fn handle_prompts_list(id: String) -> String:
    val prompts_json = get_all_prompts()
    val result = jo1(jp("prompts", prompts_json))
    make_result_response(id, result)

fn handle_prompts_get(id: String, prompt_name: String) -> String:
    val content = get_prompt(prompt_name)
    if content == "":
        return make_error_response(id, -32602, "Prompt not found: " + prompt_name)
    make_result_response(id, content)

export main
