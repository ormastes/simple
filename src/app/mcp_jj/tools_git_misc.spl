# tools_git_misc.spl - Miscellaneous git compatibility tools (8 tools)
#
# Tools: reset, clean, stash, revert, bisect, config, worktree, set_working_dir

use app.mcp_jj.helpers.{LB, RB, Q, jp, js, jo1, jo2, jo3, escape_json, make_tool_result, make_error_response, make_tool_schema_multi, make_tool_schema, make_no_param_tool, make_prop, make_prop_bool, make_prop_int, extract_nested_string, extract_arguments_dict}
use app.mcp_jj.jj_runner.{JjResult, jj_run, jj_run_with_args, shell_quote}
use app.mcp_jj.warning.{git_compat_warning, git_compat_warning_no_equiv, show_warnings}
use std.text.{NL}

# =============================================================================
# Tool 20: git_reset -> jj restore / jj abandon
# =============================================================================

fn schema_git_reset() -> String:
    var props = LB()
    props = props + make_prop("mode", "Reset mode: hard, soft, mixed (default: mixed)")
    props = props + "," + make_prop("revision", "Revision to reset to")
    props = props + RB()
    make_tool_schema_multi("git_reset", "[Git compat] Reset changes (translates to jj restore/abandon)", props, "[]", false, true, false)

fn handle_git_reset(id: String, body: String, repo_path: String) -> String:
    val args = extract_arguments_dict(body)
    val mode = args.get("mode") ?? "mixed"
    val revision = args.get("revision") ?? ""
    val warning = git_compat_warning("git_reset", "jj restore/abandon", "jj_restore")
    if mode == "hard":
        # hard reset -> jj restore (discard all changes)
        var cmd = "restore"
        if revision != "":
            cmd = cmd + " --from " + shell_quote(revision)
        val result = jj_run(cmd, repo_path)
        if result.success:
            var msg = warning
            msg = msg + "Note: 'git reset --hard' translates to 'jj restore' which discards working copy changes.{NL}"
            msg = msg + result.stdout
            make_tool_result(id, msg)
        else:
            make_error_response(id, -32603, result.stderr)
    else:
        # soft/mixed - explain the jj model
        var msg = warning
        msg = msg + "Note: 'git reset --" + mode + "' has no direct jj equivalent because jj has no staging area.{NL}{NL}"
        msg = msg + "In jj, the equivalent operations are:{NL}"
        msg = msg + "  - 'jj restore' - Discard changes in working copy (like --hard){NL}"
        msg = msg + "  - 'jj abandon' - Abandon a change entirely (removes it from history){NL}"
        msg = msg + "  - 'jj squash' - Fold changes into parent (like soft reset + recommit){NL}"
        msg = msg + "  - 'jj split' - Split a change into multiple parts{NL}{NL}"
        msg = msg + "Since jj has no index/staging area, soft and mixed resets are not applicable.{NL}"
        msg = msg + "Use 'jj_restore' or 'jj_abandon' for native jj operations.{NL}"
        make_tool_result(id, msg)

# =============================================================================
# Tool 21: git_clean -> explanation only
# =============================================================================

fn schema_git_clean() -> String:
    make_no_param_tool("git_clean", "[Git compat] Remove untracked files (no jj equivalent)", true, false, true)

fn handle_git_clean(id: String, body: String, repo_path: String) -> String:
    val warning = git_compat_warning_no_equiv("git_clean", "jj has no concept of untracked files. All files in the working copy are part of the current change. Use .gitignore to exclude files.")
    make_tool_result(id, warning)

# =============================================================================
# Tool 22: git_stash -> explanation only
# =============================================================================

fn schema_git_stash() -> String:
    make_tool_schema("git_stash", "[Git compat] Stash changes (not needed in jj - working copy is already a change)", "action", "Action: save, pop, list, drop (not applicable in jj)", false, true, false, true)

fn handle_git_stash(id: String, body: String, repo_path: String) -> String:
    val action = extract_nested_string(body, "arguments", "action")
    val warning = git_compat_warning_no_equiv("git_stash", "Stashing is not needed in jj because the working copy IS a commit (change).")
    var msg = warning
    msg = msg + "{NL}In jj, the equivalent workflows are:{NL}"
    msg = msg + "  - 'git stash' -> Not needed. Your working copy changes are always saved as the current change.{NL}"
    msg = msg + "  - 'git stash pop' -> Use 'jj new' to start a new change, then 'jj squash' to merge later.{NL}"
    msg = msg + "  - 'git stash list' -> Use 'jj log' to see all changes.{NL}"
    msg = msg + "  - 'git stash drop' -> Use 'jj abandon' to remove unwanted changes.{NL}{NL}"
    msg = msg + "Workflow for temporarily setting aside work:{NL}"
    msg = msg + "  1. 'jj new' - Creates a new empty change (your current work is preserved in the previous change){NL}"
    msg = msg + "  2. Do other work...{NL}"
    msg = msg + "  3. 'jj edit <previous-change>' - Go back to your original work{NL}"
    make_tool_result(id, msg)

# =============================================================================
# Tool 23: git_revert -> jj revert
# =============================================================================

fn schema_git_revert() -> String:
    make_tool_schema("git_revert", "[Git compat] Revert a commit (translates to jj revert)", "revision", "Revision to revert (required)", true, false, false, false)

fn handle_git_revert(id: String, body: String, repo_path: String) -> String:
    val revision = extract_nested_string(body, "arguments", "revision")
    if revision == "":
        return make_error_response(id, -32602, "Missing required parameter: revision")
    handle_git_result_simple(id, jj_run("revert -r " + shell_quote(revision), repo_path), "git_revert", "jj revert", "jj_revert")

# =============================================================================
# Tool 24: git_bisect -> manual workflow explanation
# =============================================================================

fn schema_git_bisect() -> String:
    make_no_param_tool("git_bisect", "[Git compat] Binary search for bugs (no built-in jj bisect)", true, false, true)

fn handle_git_bisect(id: String, body: String, repo_path: String) -> String:
    val warning = git_compat_warning_no_equiv("git_bisect", "jj does not have a built-in bisect command.")
    var msg = warning
    msg = msg + "{NL}Manual bisect workflow in jj:{NL}{NL}"
    msg = msg + "1. Find the range of changes to bisect:{NL}"
    msg = msg + "   jj log -r 'good_rev::bad_rev'{NL}{NL}"
    msg = msg + "2. Edit the middle change:{NL}"
    msg = msg + "   jj edit <middle_change_id>{NL}{NL}"
    msg = msg + "3. Test the change, then narrow the range:{NL}"
    msg = msg + "   - If bad: focus on the first half{NL}"
    msg = msg + "   - If good: focus on the second half{NL}{NL}"
    msg = msg + "4. Repeat until you find the culprit.{NL}{NL}"
    msg = msg + "Tip: You can also use revset expressions to filter changes:{NL}"
    msg = msg + "   jj log -r 'good_rev::bad_rev & author(name)'{NL}"
    make_tool_result(id, msg)

# =============================================================================
# Tool 25: git_config -> jj config
# =============================================================================

fn schema_git_config() -> String:
    var props = LB()
    props = props + make_prop("action", "Action: get, set, list (default: list)")
    props = props + "," + make_prop("name", "Config key name (e.g. user.name)")
    props = props + "," + make_prop("value", "Config value (for set)")
    props = props + RB()
    make_tool_schema_multi("git_config", "[Git compat] Manage configuration (translates to jj config)", props, "[]", false, false, true)

fn handle_git_config(id: String, body: String, repo_path: String) -> String:
    val args = extract_arguments_dict(body)
    val action = args.get("action") ?? "list"
    val name = args.get("name") ?? ""
    val value = args.get("value") ?? ""
    val warning = git_compat_warning("git_config", "jj config", "jj_config")
    if action == "list":
        val result = jj_run("config list", repo_path)
        if result.success:
            make_tool_result(id, warning + result.stdout)
        else:
            make_error_response(id, -32603, result.stderr)
    elif action == "get":
        if name == "":
            return make_error_response(id, -32602, "Missing required parameter: name (for get)")
        val result = jj_run("config get " + shell_quote(name), repo_path)
        if result.success:
            make_tool_result(id, warning + result.stdout)
        else:
            make_error_response(id, -32603, result.stderr)
    elif action == "set":
        if name == "" or value == "":
            return make_error_response(id, -32602, "Missing required parameters: name, value (for set)")
        val result = jj_run("config set --user " + shell_quote(name) + " " + shell_quote(value), repo_path)
        if result.success:
            make_tool_result(id, warning + result.stdout)
        else:
            make_error_response(id, -32603, result.stderr)
    else:
        make_error_response(id, -32602, "Unknown action: " + action + ". Use: get, set, list")

# =============================================================================
# Tool 26: git_worktree -> jj workspace
# =============================================================================

fn schema_git_worktree() -> String:
    var props = LB()
    props = props + make_prop("action", "Action: add, list, forget (default: list)")
    props = props + "," + make_prop("path", "Path for new workspace (for add)")
    props = props + "," + make_prop("name", "Workspace name")
    props = props + RB()
    make_tool_schema_multi("git_worktree", "[Git compat] Manage worktrees (translates to jj workspace)", props, "[]", false, false, false)

fn handle_git_worktree(id: String, body: String, repo_path: String) -> String:
    val args = extract_arguments_dict(body)
    val action = args.get("action") ?? "list"
    val path = args.get("path") ?? ""
    val name = args.get("name") ?? ""
    val warning = git_compat_warning("git_worktree", "jj workspace", "jj_workspace")
    if action == "list":
        val result = jj_run("workspace list", repo_path)
        if result.success:
            make_tool_result(id, warning + result.stdout)
        else:
            make_error_response(id, -32603, result.stderr)
    elif action == "add":
        if path == "":
            return make_error_response(id, -32602, "Missing required parameter: path (for add)")
        var cmd = "workspace add " + shell_quote(path)
        if name != "":
            cmd = cmd + " --name " + shell_quote(name)
        val result = jj_run(cmd, repo_path)
        if result.success:
            make_tool_result(id, warning + result.stdout)
        else:
            make_error_response(id, -32603, result.stderr)
    elif action == "forget":
        if name == "":
            return make_error_response(id, -32602, "Missing required parameter: name (for forget)")
        val result = jj_run("workspace forget " + shell_quote(name), repo_path)
        if result.success:
            make_tool_result(id, warning + result.stdout)
        else:
            make_error_response(id, -32603, result.stderr)
    else:
        make_error_response(id, -32602, "Unknown action: " + action + ". Use: add, list, forget")

# =============================================================================
# Tool 27: git_set_working_dir -> state change
# =============================================================================

fn schema_git_set_working_dir() -> String:
    make_tool_schema("git_set_working_dir", "[Git compat] Set the working directory for git/jj commands", "path", "Absolute path to repository directory (required)", true, false, false, true)

fn handle_git_set_working_dir(id: String, body: String, repo_path: String) -> String:
    val path = extract_nested_string(body, "arguments", "path")
    if path == "":
        return make_error_response(id, -32602, "Missing required parameter: path")
    # Return success with the path - main.spl will detect and update state
    make_tool_result(id, "SET_REPO_PATH:" + path)

export schema_git_reset, handle_git_reset
export schema_git_clean, handle_git_clean
export schema_git_stash, handle_git_stash
export schema_git_revert, handle_git_revert
export schema_git_bisect, handle_git_bisect
export schema_git_config, handle_git_config
export schema_git_worktree, handle_git_worktree
export schema_git_set_working_dir, handle_git_set_working_dir
