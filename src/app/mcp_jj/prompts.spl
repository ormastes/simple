# prompts.spl - MCP Prompts for jj-git server
#
# Provides 4 prompts:
#   jj-workflow       - Standard jj workflow guide
#   git-to-jj         - Git to jj translation guide
#   revset-reference   - Revset language quick reference
#   jj-concepts        - Key jj concepts explained

use app.mcp.helpers.{LB, RB, Q, jp, js, jo1, jo2, jo3, escape_json}
use std.string.{NL}

fn get_all_prompts() -> String:
    var prompts = "["

    # jj-workflow
    var p1 = LB()
    p1 = p1 + jp("name", js("jj-workflow"))
    p1 = p1 + "," + jp("description", js("Standard Jujutsu (jj) workflow guide: creating changes, describing, pushing"))
    p1 = p1 + RB()
    prompts = prompts + p1

    # git-to-jj
    var p2 = LB()
    p2 = p2 + jp("name", js("git-to-jj"))
    p2 = p2 + "," + jp("description", js("Translation guide from Git commands and concepts to jj equivalents"))
    p2 = p2 + RB()
    prompts = prompts + "," + p2

    # revset-reference
    var p3 = LB()
    p3 = p3 + jp("name", js("revset-reference"))
    p3 = p3 + "," + jp("description", js("Revset expression language quick reference for querying commits"))
    p3 = p3 + RB()
    prompts = prompts + "," + p3

    # jj-concepts
    var p4 = LB()
    p4 = p4 + jp("name", js("jj-concepts"))
    p4 = p4 + "," + jp("description", js("Key Jujutsu concepts: working copy as commit, change IDs, operations, conflicts"))
    p4 = p4 + RB()
    prompts = prompts + "," + p4

    prompts = prompts + "]"
    prompts

fn get_prompt(name: String) -> String:
    if name == "jj-workflow":
        return make_prompt_response(get_jj_workflow_content())
    elif name == "git-to-jj":
        return make_prompt_response(get_git_to_jj_content())
    elif name == "revset-reference":
        return make_prompt_response(get_revset_reference_content())
    elif name == "jj-concepts":
        return make_prompt_response(get_jj_concepts_content())
    else:
        return ""

fn make_prompt_response(content: String) -> String:
    var msg = LB()
    msg = msg + jp("role", js("user"))
    var text_content = LB()
    text_content = text_content + jp("type", js("text"))
    text_content = text_content + "," + jp("text", js(escape_json(content)))
    text_content = text_content + RB()
    msg = msg + "," + jp("content", text_content)
    msg = msg + RB()

    var result = LB()
    result = result + jp("messages", "[" + msg + "]")
    result = result + RB()
    result

fn get_jj_workflow_content() -> String:
    var s = "# Jujutsu (jj) Workflow Guide{NL}{NL}"
    s = s + "## Basic Workflow{NL}{NL}"
    s = s + "1. **Start working**: Your working copy IS already a commit in jj.{NL}"
    s = s + "   Just start editing files - changes are automatically tracked.{NL}{NL}"
    s = s + "2. **Describe your change**:{NL}"
    s = s + "   ```{NL}   jj describe -m 'Add feature X'{NL}   ```{NL}{NL}"
    s = s + "3. **Create a new change** (when ready to start next task):{NL}"
    s = s + "   ```{NL}   jj new -m 'Next task'{NL}   ```{NL}{NL}"
    s = s + "4. **Push to remote**:{NL}"
    s = s + "   ```{NL}   jj bookmark set main -r @-{NL}"
    s = s + "   jj git push --bookmark main{NL}   ```{NL}{NL}"
    s = s + "## Key Differences from Git{NL}{NL}"
    s = s + "- No staging area (no `git add`){NL}"
    s = s + "- Working copy is always a commit{NL}"
    s = s + "- No stash needed (just `jj new` to start fresh){NL}"
    s = s + "- Branches are called 'bookmarks'{NL}"
    s = s + "- Every operation is undoable (`jj op undo`){NL}"
    s = s + "- Conflicts are stored in commits (not blocking){NL}{NL}"
    s = s + "## Common Operations{NL}{NL}"
    s = s + "| Task | Command |{NL}"
    s = s + "|------|--------|{NL}"
    s = s + "| See status | `jj status` or `jj st` |{NL}"
    s = s + "| See log | `jj log` |{NL}"
    s = s + "| See diff | `jj diff` |{NL}"
    s = s + "| Describe change | `jj describe -m 'msg'` |{NL}"
    s = s + "| New change | `jj new` |{NL}"
    s = s + "| Squash into parent | `jj squash` |{NL}"
    s = s + "| Edit older change | `jj edit <rev>` |{NL}"
    s = s + "| Undo last operation | `jj op undo` |{NL}"
    s = s + "| Rebase | `jj rebase -d <dest>` |{NL}"
    s

fn get_git_to_jj_content() -> String:
    var s = "# Git to Jujutsu (jj) Translation Guide{NL}{NL}"
    s = s + "| Git Command | jj Equivalent | Notes |{NL}"
    s = s + "|-------------|---------------|-------|{NL}"
    s = s + "| `git status` | `jj status` | Direct |{NL}"
    s = s + "| `git add .` | (automatic) | jj tracks all changes |{NL}"
    s = s + "| `git commit -m 'msg'` | `jj commit -m 'msg'` | Or `jj describe` + `jj new` |{NL}"
    s = s + "| `git commit --amend` | `jj describe -m 'msg'` | Amend = update description |{NL}"
    s = s + "| `git log` | `jj log` | Better default output |{NL}"
    s = s + "| `git diff` | `jj diff` | No staged/unstaged distinction |{NL}"
    s = s + "| `git diff --staged` | `jj diff` | No staging area in jj |{NL}"
    s = s + "| `git show <rev>` | `jj show <rev>` | Direct |{NL}"
    s = s + "| `git blame` | `jj file annotate` | Direct |{NL}"
    s = s + "| `git branch` | `jj bookmark list` | Branches = bookmarks |{NL}"
    s = s + "| `git branch <name>` | `jj bookmark create <name>` | Create bookmark |{NL}"
    s = s + "| `git checkout <rev>` | `jj new <rev>` or `jj edit <rev>` | new=child, edit=direct |{NL}"
    s = s + "| `git merge <branch>` | `jj new @ <branch>` | Multi-parent change |{NL}"
    s = s + "| `git rebase -i` | `jj rebase` + `jj squash` | No interactive mode |{NL}"
    s = s + "| `git cherry-pick` | `jj duplicate` | Direct |{NL}"
    s = s + "| `git fetch` | `jj git fetch` | Direct |{NL}"
    s = s + "| `git pull` | `jj git fetch` | Fetch is sufficient |{NL}"
    s = s + "| `git push` | `jj git push` | Direct |{NL}"
    s = s + "| `git remote` | `jj git remote` | Direct |{NL}"
    s = s + "| `git tag` | `jj tag list` | List only |{NL}"
    s = s + "| `git reset --hard` | `jj restore` | Restore from parent |{NL}"
    s = s + "| `git reset --soft` | (not needed) | Working copy is commit |{NL}"
    s = s + "| `git clean` | (not needed) | No untracked concept |{NL}"
    s = s + "| `git stash` | `jj new` | Not needed |{NL}"
    s = s + "| `git revert` | `jj revert` | Direct |{NL}"
    s = s + "| `git worktree` | `jj workspace` | Direct |{NL}"
    s = s + "| `git config` | `jj config` | Direct |{NL}"
    s

fn get_revset_reference_content() -> String:
    var s = "# Revset Expression Reference{NL}{NL}"
    s = s + "Revsets are jj's powerful query language for selecting commits.{NL}{NL}"
    s = s + "## Basic Symbols{NL}{NL}"
    s = s + "| Symbol | Meaning |{NL}"
    s = s + "|--------|--------|{NL}"
    s = s + "| `@` | Working copy commit |{NL}"
    s = s + "| `@-` | Parent of working copy |{NL}"
    s = s + "| `root()` | Root commit |{NL}"
    s = s + "| `<change_id>` | Specific change by ID |{NL}"
    s = s + "| `<bookmark>` | Bookmark name |{NL}{NL}"
    s = s + "## Operators{NL}{NL}"
    s = s + "| Operator | Meaning |{NL}"
    s = s + "|----------|--------|{NL}"
    s = s + "| `x-` | Parents of x |{NL}"
    s = s + "| `x+` | Children of x |{NL}"
    s = s + "| `::x` | Ancestors of x (inclusive) |{NL}"
    s = s + "| `x::` | Descendants of x (inclusive) |{NL}"
    s = s + "| `x::y` | x to y (DAG range) |{NL}"
    s = s + "| `x \\| y` | Union of x and y |{NL}"
    s = s + "| `x & y` | Intersection |{NL}"
    s = s + "| `x ~ y` | Difference (x minus y) |{NL}"
    s = s + "| `!x` | Negation |{NL}{NL}"
    s = s + "## Functions{NL}{NL}"
    s = s + "| Function | Meaning |{NL}"
    s = s + "|----------|--------|{NL}"
    s = s + "| `ancestors(x)` | All ancestors |{NL}"
    s = s + "| `descendants(x)` | All descendants |{NL}"
    s = s + "| `parents(x)` | Direct parents |{NL}"
    s = s + "| `children(x)` | Direct children |{NL}"
    s = s + "| `heads(x)` | Heads of set |{NL}"
    s = s + "| `roots(x)` | Roots of set |{NL}"
    s = s + "| `all()` | All commits |{NL}"
    s = s + "| `mine()` | My commits |{NL}"
    s = s + "| `empty()` | Empty commits |{NL}"
    s = s + "| `description(pattern)` | Match description |{NL}"
    s = s + "| `author(pattern)` | Match author |{NL}"
    s = s + "| `committer(pattern)` | Match committer |{NL}"
    s = s + "| `file(path)` | Commits touching path |{NL}"
    s = s + "| `conflict()` | Commits with conflicts |{NL}"
    s = s + "| `present(x)` | x if it exists, else empty |{NL}{NL}"
    s = s + "## Examples{NL}{NL}"
    s = s + "```{NL}"
    s = s + "# Recent commits{NL}"
    s = s + "jj log -r '@ | @-'{NL}{NL}"
    s = s + "# All my commits on main{NL}"
    s = s + "jj log -r 'mine() & ::main'{NL}{NL}"
    s = s + "# Commits with conflicts{NL}"
    s = s + "jj log -r 'conflict()'{NL}{NL}"
    s = s + "# Commits touching a file{NL}"
    s = s + "jj log -r 'file(src/main.rs)'{NL}"
    s = s + "```{NL}"
    s

fn get_jj_concepts_content() -> String:
    var s = "# Key Jujutsu (jj) Concepts{NL}{NL}"
    s = s + "## 1. Working Copy is a Commit{NL}{NL}"
    s = s + "In jj, your working copy IS a commit. There's no staging area.{NL}"
    s = s + "Every change you make is automatically part of the current commit.{NL}"
    s = s + "When you run `jj new`, you create a new empty commit on top.{NL}{NL}"
    s = s + "## 2. Change IDs vs Commit IDs{NL}{NL}"
    s = s + "jj has two types of identifiers:{NL}"
    s = s + "- **Change ID**: Stable identifier that follows a change through rebases/amends.{NL}"
    s = s + "  Shown as letters (e.g., `kkmpptxz`). Stays the same even after rewriting.{NL}"
    s = s + "- **Commit ID**: Git-compatible SHA hash. Changes when commit is rewritten.{NL}{NL}"
    s = s + "Use change IDs for day-to-day work - they're shorter and more stable.{NL}{NL}"
    s = s + "## 3. Operations and Undo{NL}{NL}"
    s = s + "Every jj command that modifies the repo creates an 'operation'.{NL}"
    s = s + "Operations form a log (`jj op log`) and can be undone:{NL}"
    s = s + "```{NL}"
    s = s + "jj op undo    # Undo last operation{NL}"
    s = s + "jj op restore <op-id>  # Restore to any point{NL}"
    s = s + "```{NL}"
    s = s + "This makes jj very safe - almost nothing is irreversible.{NL}{NL}"
    s = s + "## 4. Conflicts are First-Class{NL}{NL}"
    s = s + "Unlike git, conflicts in jj are stored IN commits.{NL}"
    s = s + "You can:{NL}"
    s = s + "- Continue working with conflicts present{NL}"
    s = s + "- Rebase conflicted commits{NL}"
    s = s + "- Resolve conflicts at any time{NL}"
    s = s + "- Check conflicts: `jj resolve --list`{NL}{NL}"
    s = s + "## 5. Bookmarks (not Branches){NL}{NL}"
    s = s + "jj calls branches 'bookmarks'. They're just named pointers to commits.{NL}"
    s = s + "Unlike git branches, bookmarks don't automatically move on commit.{NL}"
    s = s + "You explicitly set them: `jj bookmark set main -r @`{NL}{NL}"
    s = s + "## 6. Anonymous Branches{NL}{NL}"
    s = s + "You can work without any bookmarks. jj tracks all changes by their{NL}"
    s = s + "change IDs. Bookmarks are only needed for pushing to remotes.{NL}{NL}"
    s = s + "## 7. Revsets{NL}{NL}"
    s = s + "jj has a powerful query language called 'revsets' for selecting commits.{NL}"
    s = s + "See the revset-reference prompt for details.{NL}"
    s

export get_all_prompts, get_prompt
