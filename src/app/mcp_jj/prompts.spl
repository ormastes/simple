# prompts.spl - MCP Prompts for jj-git server
#
# Provides 4 prompts:
#   jj-workflow       - Standard jj workflow guide
#   git-to-jj         - Git to jj translation guide
#   revset-reference   - Revset language quick reference
#   jj-concepts        - Key jj concepts explained

use app.mcp.helpers.{LB, RB, Q, jp, js, jo1, jo2, jo3, escape_json}
use std.text.{NL}

fn get_all_prompts() -> String:
    var parts = []
    parts.append("[")

    # jj-workflow
    var p1_parts = []
    p1_parts.append(LB())
    p1_parts.append(jp("name", js("jj-workflow")))
    p1_parts.append(",")
    p1_parts.append(jp("description", js("Standard Jujutsu (jj) workflow guide: creating changes, describing, pushing")))
    p1_parts.append(RB())
    parts.append(p1_parts.join(""))

    # git-to-jj
    var p2_parts = []
    p2_parts.append(LB())
    p2_parts.append(jp("name", js("git-to-jj")))
    p2_parts.append(",")
    p2_parts.append(jp("description", js("Translation guide from Git commands and concepts to jj equivalents")))
    p2_parts.append(RB())
    parts.append(",")
    parts.append(p2_parts.join(""))

    # revset-reference
    var p3_parts = []
    p3_parts.append(LB())
    p3_parts.append(jp("name", js("revset-reference")))
    p3_parts.append(",")
    p3_parts.append(jp("description", js("Revset expression language quick reference for querying commits")))
    p3_parts.append(RB())
    parts.append(",")
    parts.append(p3_parts.join(""))

    # jj-concepts
    var p4_parts = []
    p4_parts.append(LB())
    p4_parts.append(jp("name", js("jj-concepts")))
    p4_parts.append(",")
    p4_parts.append(jp("description", js("Key Jujutsu concepts: working copy as commit, change IDs, operations, conflicts")))
    p4_parts.append(RB())
    parts.append(",")
    parts.append(p4_parts.join(""))

    parts.append("]")
    val prompts = parts.join("")
    prompts

fn get_prompt(name: String) -> String:
    if name == "jj-workflow":
        return make_prompt_response(get_jj_workflow_content())
    elif name == "git-to-jj":
        return make_prompt_response(get_git_to_jj_content())
    elif name == "revset-reference":
        return make_prompt_response(get_revset_reference_content())
    elif name == "jj-concepts":
        return make_prompt_response(get_jj_concepts_content())
    else:
        return ""

fn make_prompt_response(content: String) -> String:
    var tc_parts = []
    tc_parts.append(LB())
    tc_parts.append(jp("type", js("text")))
    tc_parts.append(",")
    tc_parts.append(jp("text", js(escape_json(content))))
    tc_parts.append(RB())
    val text_content = tc_parts.join("")

    var msg_parts = []
    msg_parts.append(LB())
    msg_parts.append(jp("role", js("user")))
    msg_parts.append(",")
    msg_parts.append(jp("content", text_content))
    msg_parts.append(RB())
    val msg = msg_parts.join("")

    var parts = []
    parts.append(LB())
    parts.append(jp("messages", "[" + msg + "]"))
    parts.append(RB())
    val result = parts.join("")
    result

fn get_jj_workflow_content() -> String:
    var parts = []
    parts.append("# Jujutsu (jj) Workflow Guide{NL}{NL}")
    parts.append("## Basic Workflow{NL}{NL}")
    parts.append("1. **Start working**: Your working copy IS already a commit in jj.{NL}")
    parts.append("   Just start editing files - changes are automatically tracked.{NL}{NL}")
    parts.append("2. **Describe your change**:{NL}")
    parts.append("   ```{NL}   jj describe -m 'Add feature X'{NL}   ```{NL}{NL}")
    parts.append("3. **Create a new change** (when ready to start next task):{NL}")
    parts.append("   ```{NL}   jj new -m 'Next task'{NL}   ```{NL}{NL}")
    parts.append("4. **Push to remote**:{NL}")
    parts.append("   ```{NL}   jj bookmark set main -r @-{NL}")
    parts.append("   jj git push --bookmark main{NL}   ```{NL}{NL}")
    parts.append("## Key Differences from Git{NL}{NL}")
    parts.append("- No staging area (no `git add`){NL}")
    parts.append("- Working copy is always a commit{NL}")
    parts.append("- No stash needed (just `jj new` to start fresh){NL}")
    parts.append("- Branches are called 'bookmarks'{NL}")
    parts.append("- Every operation is undoable (`jj op undo`){NL}")
    parts.append("- Conflicts are stored in commits (not blocking){NL}{NL}")
    parts.append("## Common Operations{NL}{NL}")
    parts.append("| Task | Command |{NL}")
    parts.append("|------|--------|{NL}")
    parts.append("| See status | `jj status` or `jj st` |{NL}")
    parts.append("| See log | `jj log` |{NL}")
    parts.append("| See diff | `jj diff` |{NL}")
    parts.append("| Describe change | `jj describe -m 'msg'` |{NL}")
    parts.append("| New change | `jj new` |{NL}")
    parts.append("| Squash into parent | `jj squash` |{NL}")
    parts.append("| Edit older change | `jj edit <rev>` |{NL}")
    parts.append("| Undo last operation | `jj op undo` |{NL}")
    parts.append("| Rebase | `jj rebase -d <dest>` |{NL}")
    val s = parts.join("")
    s

fn get_git_to_jj_content() -> String:
    var parts = []
    parts.append("# Git to Jujutsu (jj) Translation Guide{NL}{NL}")
    parts.append("| Git Command | jj Equivalent | Notes |{NL}")
    parts.append("|-------------|---------------|-------|{NL}")
    parts.append("| `git status` | `jj status` | Direct |{NL}")
    parts.append("| `git add .` | (automatic) | jj tracks all changes |{NL}")
    parts.append("| `git commit -m 'msg'` | `jj commit -m 'msg'` | Or `jj describe` + `jj new` |{NL}")
    parts.append("| `git commit --amend` | `jj describe -m 'msg'` | Amend = update description |{NL}")
    parts.append("| `git log` | `jj log` | Better default output |{NL}")
    parts.append("| `git diff` | `jj diff` | No staged/unstaged distinction |{NL}")
    parts.append("| `git diff --staged` | `jj diff` | No staging area in jj |{NL}")
    parts.append("| `git show <rev>` | `jj show <rev>` | Direct |{NL}")
    parts.append("| `git blame` | `jj file annotate` | Direct |{NL}")
    parts.append("| `git branch` | `jj bookmark list` | Branches = bookmarks |{NL}")
    parts.append("| `git branch <name>` | `jj bookmark create <name>` | Create bookmark |{NL}")
    parts.append("| `git checkout <rev>` | `jj new <rev>` or `jj edit <rev>` | new=child, edit=direct |{NL}")
    parts.append("| `git merge <branch>` | `jj new @ <branch>` | Multi-parent change |{NL}")
    parts.append("| `git rebase -i` | `jj rebase` + `jj squash` | No interactive mode |{NL}")
    parts.append("| `git cherry-pick` | `jj duplicate` | Direct |{NL}")
    parts.append("| `git fetch` | `jj git fetch` | Direct |{NL}")
    parts.append("| `git pull` | `jj git fetch` | Fetch is sufficient |{NL}")
    parts.append("| `git push` | `jj git push` | Direct |{NL}")
    parts.append("| `git remote` | `jj git remote` | Direct |{NL}")
    parts.append("| `git tag` | `jj tag list` | List only |{NL}")
    parts.append("| `git reset --hard` | `jj restore` | Restore from parent |{NL}")
    parts.append("| `git reset --soft` | (not needed) | Working copy is commit |{NL}")
    parts.append("| `git clean` | (not needed) | No untracked concept |{NL}")
    parts.append("| `git stash` | `jj new` | Not needed |{NL}")
    parts.append("| `git revert` | `jj revert` | Direct |{NL}")
    parts.append("| `git worktree` | `jj workspace` | Direct |{NL}")
    parts.append("| `git config` | `jj config` | Direct |{NL}")
    val s = parts.join("")
    s

fn get_revset_reference_content() -> String:
    var parts = []
    parts.append("# Revset Expression Reference{NL}{NL}")
    parts.append("Revsets are jj's powerful query language for selecting commits.{NL}{NL}")
    parts.append("## Basic Symbols{NL}{NL}")
    parts.append("| Symbol | Meaning |{NL}")
    parts.append("|--------|--------|{NL}")
    parts.append("| `@` | Working copy commit |{NL}")
    parts.append("| `@-` | Parent of working copy |{NL}")
    parts.append("| `root()` | Root commit |{NL}")
    parts.append("| `<change_id>` | Specific change by ID |{NL}")
    parts.append("| `<bookmark>` | Bookmark name |{NL}{NL}")
    parts.append("## Operators{NL}{NL}")
    parts.append("| Operator | Meaning |{NL}")
    parts.append("|----------|--------|{NL}")
    parts.append("| `x-` | Parents of x |{NL}")
    parts.append("| `x+` | Children of x |{NL}")
    parts.append("| `::x` | Ancestors of x (inclusive) |{NL}")
    parts.append("| `x::` | Descendants of x (inclusive) |{NL}")
    parts.append("| `x::y` | x to y (DAG range) |{NL}")
    parts.append("| `x \\| y` | Union of x and y |{NL}")
    parts.append("| `x & y` | Intersection |{NL}")
    parts.append("| `x ~ y` | Difference (x minus y) |{NL}")
    parts.append("| `!x` | Negation |{NL}{NL}")
    parts.append("## Functions{NL}{NL}")
    parts.append("| Function | Meaning |{NL}")
    parts.append("|----------|--------|{NL}")
    parts.append("| `ancestors(x)` | All ancestors |{NL}")
    parts.append("| `descendants(x)` | All descendants |{NL}")
    parts.append("| `parents(x)` | Direct parents |{NL}")
    parts.append("| `children(x)` | Direct children |{NL}")
    parts.append("| `heads(x)` | Heads of set |{NL}")
    parts.append("| `roots(x)` | Roots of set |{NL}")
    parts.append("| `all()` | All commits |{NL}")
    parts.append("| `mine()` | My commits |{NL}")
    parts.append("| `empty()` | Empty commits |{NL}")
    parts.append("| `description(pattern)` | Match description |{NL}")
    parts.append("| `author(pattern)` | Match author |{NL}")
    parts.append("| `committer(pattern)` | Match committer |{NL}")
    parts.append("| `file(path)` | Commits touching path |{NL}")
    parts.append("| `conflict()` | Commits with conflicts |{NL}")
    parts.append("| `present(x)` | x if it exists, else empty |{NL}{NL}")
    parts.append("## Examples{NL}{NL}")
    parts.append("```{NL}")
    parts.append("# Recent commits{NL}")
    parts.append("jj log -r '@ | @-'{NL}{NL}")
    parts.append("# All my commits on main{NL}")
    parts.append("jj log -r 'mine() & ::main'{NL}{NL}")
    parts.append("# Commits with conflicts{NL}")
    parts.append("jj log -r 'conflict()'{NL}{NL}")
    parts.append("# Commits touching a file{NL}")
    parts.append("jj log -r 'file(src/main.rs)'{NL}")
    parts.append("```{NL}")
    val s = parts.join("")
    s

fn get_jj_concepts_content() -> String:
    var parts = []
    parts.append("# Key Jujutsu (jj) Concepts{NL}{NL}")
    parts.append("## 1. Working Copy is a Commit{NL}{NL}")
    parts.append("In jj, your working copy IS a commit. There's no staging area.{NL}")
    parts.append("Every change you make is automatically part of the current commit.{NL}")
    parts.append("When you run `jj new`, you create a new empty commit on top.{NL}{NL}")
    parts.append("## 2. Change IDs vs Commit IDs{NL}{NL}")
    parts.append("jj has two types of identifiers:{NL}")
    parts.append("- **Change ID**: Stable identifier that follows a change through rebases/amends.{NL}")
    parts.append("  Shown as letters (e.g., `kkmpptxz`). Stays the same even after rewriting.{NL}")
    parts.append("- **Commit ID**: Git-compatible SHA hash. Changes when commit is rewritten.{NL}{NL}")
    parts.append("Use change IDs for day-to-day work - they're shorter and more stable.{NL}{NL}")
    parts.append("## 3. Operations and Undo{NL}{NL}")
    parts.append("Every jj command that modifies the repo creates an 'operation'.{NL}")
    parts.append("Operations form a log (`jj op log`) and can be undone:{NL}")
    parts.append("```{NL}")
    parts.append("jj op undo    # Undo last operation{NL}")
    parts.append("jj op restore <op-id>  # Restore to any point{NL}")
    parts.append("```{NL}")
    parts.append("This makes jj very safe - almost nothing is irreversible.{NL}{NL}")
    parts.append("## 4. Conflicts are First-Class{NL}{NL}")
    parts.append("Unlike git, conflicts in jj are stored IN commits.{NL}")
    parts.append("You can:{NL}")
    parts.append("- Continue working with conflicts present{NL}")
    parts.append("- Rebase conflicted commits{NL}")
    parts.append("- Resolve conflicts at any time{NL}")
    parts.append("- Check conflicts: `jj resolve --list`{NL}{NL}")
    parts.append("## 5. Bookmarks (not Branches){NL}{NL}")
    parts.append("jj calls branches 'bookmarks'. They're just named pointers to commits.{NL}")
    parts.append("Unlike git branches, bookmarks don't automatically move on commit.{NL}")
    parts.append("You explicitly set them: `jj bookmark set main -r @`{NL}{NL}")
    parts.append("## 6. Anonymous Branches{NL}{NL}")
    parts.append("You can work without any bookmarks. jj tracks all changes by their{NL}")
    parts.append("change IDs. Bookmarks are only needed for pushing to remotes.{NL}{NL}")
    parts.append("## 7. Revsets{NL}{NL}")
    parts.append("jj has a powerful query language called 'revsets' for selecting commits.{NL}")
    parts.append("See the revset-reference prompt for details.{NL}")
    val s = parts.join("")
    s

export get_all_prompts, get_prompt
