# tools_git.spl - All 27 git compatibility tools (consolidated for fast startup)
#
# Categories:
#   Core (9): status, init, clone, add, commit, log, diff, show, blame
#   Branch (5): branch, checkout, merge, rebase, cherry_pick
#   Sync (5): fetch, pull, push, remote, tag
#   Misc (8): reset, clean, stash, revert, bisect, config, worktree, set_working_dir

use app.mcp.helpers.{LB, RB, Q, jp, js, jo1, jo2, jo3, escape_json, make_tool_result, make_error_response, make_tool_schema_multi, extract_nested_string, extract_arguments_dict}
use jj_runner.{JjResult, jj_run, jj_run_with_args, shell_quote}
use warning.{git_compat_warning, git_compat_warning_no_equiv, show_warnings}

# --- jj-specific tool schema helpers (inlined from helpers.spl) ---

fn make_tool_schema(name: String, desc: String, prop_name: String, prop_desc: String, required: Bool, read_only: Bool, destructive: Bool, idempotent: Bool) -> String:
    val prop = jo2(jp("type", js("string")), jp("description", js(desc)))
    val props = jo1(jp(prop_name, prop))
    var req_arr = "[]"
    if required:
        req_arr = "[" + js(prop_name) + "]"
    val schema = jo3(jp("type", js("object")), jp("properties", props), jp("required", req_arr))
    var annot = LB()
    var ro = "false"
    if read_only:
        ro = "true"
    annot = annot + jp("readOnlyHint", ro) + ","
    var dest = "false"
    if destructive:
        dest = "true"
    annot = annot + jp("destructiveHint", dest) + ","
    var idemp = "false"
    if idempotent:
        idemp = "true"
    annot = annot + jp("idempotentHint", idemp) + ","
    annot = annot + jp("openWorldHint", "false") + RB()
    var result = LB()
    result = result + jp("name", js(name)) + ","
    result = result + jp("description", js(escape_json(desc))) + ","
    result = result + jp("inputSchema", schema) + ","
    result = result + jp("annotations", annot) + RB()
    result

fn make_no_param_tool(name: String, desc: String, read_only: Bool, destructive: Bool, idempotent: Bool) -> String:
    val schema = jo2(jp("type", js("object")), jp("properties", LB() + RB()))
    var annot = LB()
    var ro = "false"
    if read_only:
        ro = "true"
    annot = annot + jp("readOnlyHint", ro) + ","
    var dest = "false"
    if destructive:
        dest = "true"
    annot = annot + jp("destructiveHint", dest) + ","
    var idemp = "false"
    if idempotent:
        idemp = "true"
    annot = annot + jp("idempotentHint", idemp) + ","
    annot = annot + jp("openWorldHint", "false") + RB()
    var result = LB()
    result = result + jp("name", js(name)) + ","
    result = result + jp("description", js(escape_json(desc))) + ","
    result = result + jp("inputSchema", schema) + ","
    result = result + jp("annotations", annot) + RB()
    result

fn make_prop(name: String, desc: String) -> String:
    jp(name, jo2(jp("type", js("string")), jp("description", js(escape_json(desc)))))

fn make_prop_bool(name: String, desc: String) -> String:
    jp(name, jo2(jp("type", js("boolean")), jp("description", js(escape_json(desc)))))

fn make_prop_int(name: String, desc: String) -> String:
    jp(name, jo2(jp("type", js("integer")), jp("description", js(escape_json(desc)))))

# =============================================================================
# CORE TOOLS (9 tools)
# =============================================================================

# --- Tool 1: git_status -> jj status ---

fn schema_git_status() -> String:
    make_no_param_tool("git_status", "[Git compat] Show repository status (translates to jj status)", true, false, true)

fn handle_git_status(id: String, body: String, repo_path: String) -> String:
    val result = jj_run("status", repo_path)
    if result.success:
        val warning = git_compat_warning("git_status", "jj status", "jj_status")
        make_tool_result(id, warning + result.stdout)
    else:
        make_error_response(id, -32603, result.stderr)

# --- Tool 2: git_init -> jj git init ---

fn schema_git_init() -> String:
    make_tool_schema("git_init", "[Git compat] Initialize a new repository (translates to jj git init)", "path", "Directory to initialize (default: current directory)", false, false, false, false)

fn handle_git_init(id: String, body: String, repo_path: String) -> String:
    val path = extract_nested_string(body, "arguments", "path")
    var cmd = "git init"
    if path != "":
        cmd = cmd + " " + shell_quote(path)
    val result = jj_run(cmd, repo_path)
    if result.success:
        val warning = git_compat_warning("git_init", "jj git init", "jj_init")
        var msg = warning
        msg = msg + result.stdout
        msg = msg + "\nNote: jj does not support bare repositories. A colocated git+jj repo was created."
        make_tool_result(id, msg)
    else:
        make_error_response(id, -32603, result.stderr)

# --- Tool 3: git_clone -> jj git clone ---

fn schema_git_clone() -> String:
    var props = LB()
    props = props + make_prop("url", "Repository URL to clone")
    props = props + "," + make_prop("destination", "Local directory name")
    props = props + "," + make_prop_bool("colocate", "Create colocated git+jj repo (default: true)")
    props = props + RB()
    val required = "[" + js("url") + "]"
    make_tool_schema_multi("git_clone", "[Git compat] Clone a repository (translates to jj git clone)", props, required, false, false, false)

fn handle_git_clone(id: String, body: String, repo_path: String) -> String:
    val args = extract_arguments_dict(body)
    val url = args.get("url") ?? ""
    if url == "":
        return make_error_response(id, -32602, "Missing required parameter: url")
    val destination = args.get("destination") ?? ""
    val colocate = args.get("colocate") ?? ""
    var cmd = "git clone"
    if colocate != "false":
        cmd = cmd + " --colocate"
    cmd = cmd + " " + shell_quote(url)
    if destination != "":
        cmd = cmd + " " + shell_quote(destination)
    val result = jj_run(cmd, repo_path)
    if result.success:
        val warning = git_compat_warning("git_clone", "jj git clone", "jj_clone")
        make_tool_result(id, warning + result.stdout)
    else:
        make_error_response(id, -32603, result.stderr)

# --- Tool 4: git_add -> jj file track ---

fn schema_git_add() -> String:
    make_tool_schema("git_add", "[Git compat] Stage files (translates to jj file track). Note: jj auto-tracks all changes in working copy.", "paths", "File paths to add (space-separated)", false, false, false, true)

fn handle_git_add(id: String, body: String, repo_path: String) -> String:
    val paths = extract_nested_string(body, "arguments", "paths")
    var cmd = "file track"
    if paths != "":
        cmd = cmd + " " + paths
    val result = jj_run(cmd, repo_path)
    val warning = git_compat_warning("git_add", "jj file track", "jj_track")
    var msg = warning
    msg = msg + "Note: In jj, all file changes in the working copy are automatically included in the current change. "
    msg = msg + "'jj file track' is only needed for newly created files that match .gitignore patterns.\n"
    if result.success:
        msg = msg + result.stdout
    else:
        msg = msg + "Command output: " + result.stderr
    make_tool_result(id, msg)

# --- Tool 5: git_commit -> jj commit / jj describe ---

fn schema_git_commit() -> String:
    var props = LB()
    props = props + make_prop("message", "Commit message")
    props = props + "," + make_prop_bool("amend", "Amend previous commit (translates to jj describe)")
    props = props + RB()
    make_tool_schema_multi("git_commit", "[Git compat] Commit changes (translates to jj commit/describe)", props, "[]", false, false, false)

fn handle_git_commit(id: String, body: String, repo_path: String) -> String:
    val args = extract_arguments_dict(body)
    val message = args.get("message") ?? ""
    val amend = args.get("amend") ?? ""
    if amend == "true":
        # amend translates to jj describe
        var cmd = "describe"
        if message != "":
            cmd = cmd + " -m " + shell_quote(message)
        val result = jj_run(cmd, repo_path)
        if result.success:
            val warning = git_compat_warning("git_commit --amend", "jj describe", "jj_describe")
            make_tool_result(id, warning + result.stdout)
        else:
            make_error_response(id, -32603, result.stderr)
    else:
        var cmd = "commit"
        if message != "":
            cmd = cmd + " -m " + shell_quote(message)
        val result = jj_run(cmd, repo_path)
        if result.success:
            val warning = git_compat_warning("git_commit", "jj commit", "jj_commit")
            make_tool_result(id, warning + result.stdout)
        else:
            make_error_response(id, -32603, result.stderr)

# --- Tool 6: git_log -> jj log ---

fn schema_git_log() -> String:
    var props = LB()
    props = props + make_prop("count", "Number of commits to show")
    props = props + "," + make_prop("author", "Filter by author name or email")
    props = props + "," + make_prop("since", "Show commits after date (e.g. 2024-01-01)")
    props = props + "," + make_prop("until", "Show commits before date")
    props = props + "," + make_prop_bool("oneline", "One line per commit")
    props = props + RB()
    make_tool_schema_multi("git_log", "[Git compat] Show commit log (translates to jj log)", props, "[]", true, false, true)

fn handle_git_log(id: String, body: String, repo_path: String) -> String:
    val args = extract_arguments_dict(body)
    val count = args.get("count") ?? ""
    val author = args.get("author") ?? ""
    val since = args.get("since") ?? ""
    val until_val = args.get("until") ?? ""
    val oneline = args.get("oneline") ?? ""
    var cmd = "log"
    if count != "":
        cmd = cmd + " -n " + count
    if author != "":
        cmd = cmd + " --revisions " + shell_quote("author(" + author + ")")
    if oneline == "true":
        cmd = cmd + " --template builtin_log_oneline"
    val result = jj_run(cmd, repo_path)
    if result.success:
        val warning = git_compat_warning("git_log", "jj log", "jj_log")
        var msg = warning
        if since != "" or until_val != "":
            msg = msg + "Note: Date-based filtering in jj uses revset expressions. Use 'jj log --revisions' with date filters.\n"
        msg = msg + result.stdout
        make_tool_result(id, msg)
    else:
        make_error_response(id, -32603, result.stderr)

# --- Tool 7: git_diff -> jj diff ---

fn schema_git_diff() -> String:
    var props = LB()
    props = props + make_prop("revision", "Revision to diff (default: working copy)")
    props = props + "," + make_prop_bool("staged", "Show staged changes only (ignored in jj - all changes are in working copy)")
    props = props + "," + make_prop("paths", "Restrict diff to specific paths (space-separated)")
    props = props + RB()
    make_tool_schema_multi("git_diff", "[Git compat] Show changes (translates to jj diff)", props, "[]", true, false, true)

fn handle_git_diff(id: String, body: String, repo_path: String) -> String:
    val args = extract_arguments_dict(body)
    val revision = args.get("revision") ?? ""
    val staged = args.get("staged") ?? ""
    val paths = args.get("paths") ?? ""
    var cmd = "diff"
    if revision != "":
        cmd = cmd + " -r " + shell_quote(revision)
    if paths != "":
        cmd = cmd + " " + paths
    val result = jj_run(cmd, repo_path)
    if result.success:
        val warning = git_compat_warning("git_diff", "jj diff", "jj_diff")
        var msg = warning
        if staged == "true":
            msg = msg + "Note: jj has no staging area. All working copy changes are part of the current change. The --staged flag was ignored.\n"
        msg = msg + result.stdout
        make_tool_result(id, msg)
    else:
        make_error_response(id, -32603, result.stderr)

# --- Tool 8: git_show -> jj show ---

fn schema_git_show() -> String:
    make_tool_schema("git_show", "[Git compat] Show commit details (translates to jj show)", "revision", "Commit hash or ref", false, true, false, true)

fn handle_git_show(id: String, body: String, repo_path: String) -> String:
    val revision = extract_nested_string(body, "arguments", "revision")
    var cmd = "show"
    if revision != "":
        cmd = cmd + " " + shell_quote(revision)
    val result = jj_run(cmd, repo_path)
    if result.success:
        val warning = git_compat_warning("git_show", "jj show", "jj_show")
        make_tool_result(id, warning + result.stdout)
    else:
        make_error_response(id, -32603, result.stderr)

# --- Tool 9: git_blame -> jj file annotate ---

fn schema_git_blame() -> String:
    var props = LB()
    props = props + make_prop("path", "File path to annotate (required)")
    props = props + "," + make_prop("revision", "Revision to annotate from")
    props = props + RB()
    val required = "[" + js("path") + "]"
    make_tool_schema_multi("git_blame", "[Git compat] Show file annotation (translates to jj file annotate)", props, required, true, false, true)

fn handle_git_blame(id: String, body: String, repo_path: String) -> String:
    val args = extract_arguments_dict(body)
    val path = args.get("path") ?? ""
    val revision = args.get("revision") ?? ""
    if path == "":
        return make_error_response(id, -32602, "Missing required parameter: path")
    var cmd = "file annotate"
    if revision != "":
        cmd = cmd + " -r " + shell_quote(revision)
    cmd = cmd + " " + shell_quote(path)
    val result = jj_run(cmd, repo_path)
    if result.success:
        val warning = git_compat_warning("git_blame", "jj file annotate", "jj_annotate")
        make_tool_result(id, warning + result.stdout)
    else:
        make_error_response(id, -32603, result.stderr)

# =============================================================================
# BRANCH TOOLS (5 tools)
# =============================================================================

# --- Tool 10: git_branch -> jj bookmark ---

fn schema_git_branch() -> String:
    var props = LB()
    props = props + make_prop("action", "Action: list, create, delete, rename (default: list)")
    props = props + "," + make_prop("name", "Branch/bookmark name")
    props = props + "," + make_prop("new_name", "New name (for rename)")
    props = props + "," + make_prop("revision", "Revision to point the bookmark to")
    props = props + RB()
    make_tool_schema_multi("git_branch", "[Git compat] Manage branches (translates to jj bookmark)", props, "[]", false, false, false)

fn handle_git_branch(id: String, body: String, repo_path: String) -> String:
    val args = extract_arguments_dict(body)
    val action = args.get("action") ?? "list"
    val name = args.get("name") ?? ""
    val new_name = args.get("new_name") ?? ""
    val revision = args.get("revision") ?? ""
    val warning = git_compat_warning("git_branch", "jj bookmark", "jj_bookmark")
    if action == "list":
        val result = jj_run("bookmark list", repo_path)
        if result.success:
            make_tool_result(id, warning + "Note: Git branches are called 'bookmarks' in jj.\n" + result.stdout)
        else:
            make_error_response(id, -32603, result.stderr)
    elif action == "create":
        if name == "":
            return make_error_response(id, -32602, "Missing required parameter: name (for create)")
        var cmd = "bookmark create " + shell_quote(name)
        if revision != "":
            cmd = cmd + " -r " + shell_quote(revision)
        val result = jj_run(cmd, repo_path)
        if result.success:
            make_tool_result(id, warning + result.stdout)
        else:
            make_error_response(id, -32603, result.stderr)
    elif action == "delete":
        if name == "":
            return make_error_response(id, -32602, "Missing required parameter: name (for delete)")
        val result = jj_run("bookmark delete " + shell_quote(name), repo_path)
        if result.success:
            make_tool_result(id, warning + result.stdout)
        else:
            make_error_response(id, -32603, result.stderr)
    elif action == "rename":
        if name == "" or new_name == "":
            return make_error_response(id, -32602, "Missing required parameters: name, new_name (for rename)")
        val result = jj_run("bookmark rename " + shell_quote(name) + " " + shell_quote(new_name), repo_path)
        if result.success:
            make_tool_result(id, warning + result.stdout)
        else:
            make_error_response(id, -32603, result.stderr)
    else:
        make_error_response(id, -32602, "Unknown action: " + action + ". Use: list, create, delete, rename")

# --- Tool 11: git_checkout -> jj new / jj edit ---

fn schema_git_checkout() -> String:
    var props = LB()
    props = props + make_prop("revision", "Branch name, commit hash, or ref to checkout (required)")
    props = props + "," + make_prop_bool("create", "Create a new branch (translates to jj new)")
    props = props + RB()
    val required = "[" + js("revision") + "]"
    make_tool_schema_multi("git_checkout", "[Git compat] Switch to revision (translates to jj new/edit)", props, required, false, false, false)

fn handle_git_checkout(id: String, body: String, repo_path: String) -> String:
    val args = extract_arguments_dict(body)
    val revision = args.get("revision") ?? ""
    val create = args.get("create") ?? ""
    if revision == "":
        return make_error_response(id, -32602, "Missing required parameter: revision")
    var cmd = "new"
    if create != "true":
        # Default behavior: jj new creates a new change on top of revision
        cmd = "new"
    val result = jj_run(cmd + " " + shell_quote(revision), repo_path)
    if result.success:
        val warning = git_compat_warning("git_checkout", "jj new", "jj_new")
        var msg = warning
        msg = msg + "Note: In jj, 'checkout' does not exist. Instead:\n"
        msg = msg + "  - 'jj new REV' creates a new empty change on top of REV (like git checkout + new commit)\n"
        msg = msg + "  - 'jj edit REV' edits an existing change directly\n"
        msg = msg + "The working copy always represents the current change.\n"
        msg = msg + result.stdout
        make_tool_result(id, msg)
    else:
        make_error_response(id, -32603, result.stderr)

# --- Tool 12: git_merge -> jj new with multiple parents ---

fn schema_git_merge() -> String:
    make_tool_schema("git_merge", "[Git compat] Merge branches (translates to jj new with multiple parents)", "branches", "Branches to merge (space-separated, required)", true, false, false, false)

fn handle_git_merge(id: String, body: String, repo_path: String) -> String:
    val branches = extract_nested_string(body, "arguments", "branches")
    if branches == "":
        return make_error_response(id, -32602, "Missing required parameter: branches")
    # In jj, merging is done by creating a new change with multiple parents
    val cmd = "new @ " + branches
    val result = jj_run(cmd, repo_path)
    if result.success:
        val warning = git_compat_warning("git_merge", "jj new (multi-parent)", "jj_new")
        var msg = warning
        msg = msg + "Note: In jj, merging creates a new change with multiple parents.\n"
        msg = msg + "The command 'jj new @ branch1 branch2' creates a merge change.\n"
        msg = msg + result.stdout
        make_tool_result(id, msg)
    else:
        make_error_response(id, -32603, result.stderr)

# --- Tool 13: git_rebase -> jj rebase ---

fn schema_git_rebase() -> String:
    var props = LB()
    props = props + make_prop("destination", "Destination revision to rebase onto (required)")
    props = props + "," + make_prop("source", "Source revision to rebase (default: current change)")
    props = props + RB()
    val required = "[" + js("destination") + "]"
    make_tool_schema_multi("git_rebase", "[Git compat] Rebase changes (translates to jj rebase)", props, required, false, true, false)

fn handle_git_rebase(id: String, body: String, repo_path: String) -> String:
    val args = extract_arguments_dict(body)
    val destination = args.get("destination") ?? ""
    val source = args.get("source") ?? ""
    if destination == "":
        return make_error_response(id, -32602, "Missing required parameter: destination")
    var cmd = "rebase -d " + shell_quote(destination)
    if source != "":
        cmd = cmd + " -s " + shell_quote(source)
    val result = jj_run(cmd, repo_path)
    if result.success:
        val warning = git_compat_warning("git_rebase", "jj rebase", "jj_rebase")
        var msg = warning
        msg = msg + "Note: jj rebase does not support interactive mode. All rebasing is automatic.\n"
        msg = msg + result.stdout
        make_tool_result(id, msg)
    else:
        make_error_response(id, -32603, result.stderr)

# --- Tool 14: git_cherry_pick -> jj duplicate ---

fn schema_git_cherry_pick() -> String:
    make_tool_schema("git_cherry_pick", "[Git compat] Cherry-pick commits (translates to jj duplicate)", "revisions", "Revisions to cherry-pick (space-separated, required)", true, false, false, false)

fn handle_git_cherry_pick(id: String, body: String, repo_path: String) -> String:
    val revisions = extract_nested_string(body, "arguments", "revisions")
    if revisions == "":
        return make_error_response(id, -32602, "Missing required parameter: revisions")
    val result = jj_run("duplicate " + revisions, repo_path)
    if result.success:
        val warning = git_compat_warning("git_cherry_pick", "jj duplicate", "jj_duplicate")
        var msg = warning
        msg = msg + "Note: 'jj duplicate' creates copies of changes. Unlike git cherry-pick, it preserves the original.\n"
        msg = msg + result.stdout
        make_tool_result(id, msg)
    else:
        make_error_response(id, -32603, result.stderr)

# =============================================================================
# SYNC TOOLS (5 tools)
# =============================================================================

# --- Tool 15: git_fetch -> jj git fetch ---

fn schema_git_fetch() -> String:
    make_tool_schema("git_fetch", "[Git compat] Fetch from remote (translates to jj git fetch)", "remote", "Remote name (default: origin)", false, false, false, true)

fn handle_git_fetch(id: String, body: String, repo_path: String) -> String:
    val remote = extract_nested_string(body, "arguments", "remote")
    var cmd = "git fetch"
    if remote != "":
        cmd = cmd + " --remote " + shell_quote(remote)
    val result = jj_run(cmd, repo_path)
    if result.success:
        val warning = git_compat_warning("git_fetch", "jj git fetch", "jj_fetch")
        make_tool_result(id, warning + result.stdout)
    else:
        make_error_response(id, -32603, result.stderr)

# --- Tool 16: git_pull -> jj git fetch (no pull in jj) ---

fn schema_git_pull() -> String:
    make_tool_schema("git_pull", "[Git compat] Pull from remote (translates to jj git fetch - no pull in jj)", "remote", "Remote name (default: origin)", false, false, false, true)

fn handle_git_pull(id: String, body: String, repo_path: String) -> String:
    val remote = extract_nested_string(body, "arguments", "remote")
    var cmd = "git fetch"
    if remote != "":
        cmd = cmd + " --remote " + shell_quote(remote)
    val result = jj_run(cmd, repo_path)
    if result.success:
        val warning = git_compat_warning("git_pull", "jj git fetch", "jj_fetch")
        var msg = warning
        msg = msg + "Note: jj has no 'pull' command. 'jj git fetch' is sufficient because:\n"
        msg = msg + "  - jj automatically rebases your work on top of fetched changes\n"
        msg = msg + "  - There is no separate merge/rebase step needed after fetching\n"
        msg = msg + result.stdout
        make_tool_result(id, msg)
    else:
        make_error_response(id, -32603, result.stderr)

# --- Tool 17: git_push -> jj git push ---

fn schema_git_push() -> String:
    var props = LB()
    props = props + make_prop("remote", "Remote name (default: origin)")
    props = props + "," + make_prop("bookmark", "Bookmark (branch) name to push")
    props = props + "," + make_prop_bool("all", "Push all bookmarks")
    props = props + RB()
    make_tool_schema_multi("git_push", "[Git compat] Push to remote (translates to jj git push)", props, "[]", false, false, false)

fn handle_git_push(id: String, body: String, repo_path: String) -> String:
    val args = extract_arguments_dict(body)
    val remote = args.get("remote") ?? ""
    val bookmark = args.get("bookmark") ?? ""
    val all = args.get("all") ?? ""
    var cmd = "git push"
    if remote != "":
        cmd = cmd + " --remote " + shell_quote(remote)
    if all == "true":
        cmd = cmd + " --all"
    elif bookmark != "":
        cmd = cmd + " --bookmark " + shell_quote(bookmark)
    val result = jj_run(cmd, repo_path)
    if result.success:
        val warning = git_compat_warning("git_push", "jj git push", "jj_push")
        make_tool_result(id, warning + result.stdout)
    else:
        make_error_response(id, -32603, result.stderr)

# --- Tool 18: git_remote -> jj git remote ---

fn schema_git_remote() -> String:
    var props = LB()
    props = props + make_prop("action", "Action: add, list, remove, rename (required)")
    props = props + "," + make_prop("name", "Remote name")
    props = props + "," + make_prop("url", "Remote URL (for add)")
    props = props + "," + make_prop("new_name", "New name (for rename)")
    props = props + RB()
    val required = "[" + js("action") + "]"
    make_tool_schema_multi("git_remote", "[Git compat] Manage remotes (translates to jj git remote)", props, required, false, false, false)

fn handle_git_remote(id: String, body: String, repo_path: String) -> String:
    val args = extract_arguments_dict(body)
    val action = args.get("action") ?? ""
    val name = args.get("name") ?? ""
    val url = args.get("url") ?? ""
    val new_name = args.get("new_name") ?? ""
    if action == "":
        return make_error_response(id, -32602, "Missing required parameter: action")
    val warning = git_compat_warning("git_remote", "jj git remote", "jj_remote")
    if action == "list":
        val result = jj_run("git remote list", repo_path)
        if result.success:
            make_tool_result(id, warning + result.stdout)
        else:
            make_error_response(id, -32603, result.stderr)
    elif action == "add":
        if name == "" or url == "":
            return make_error_response(id, -32602, "Missing required parameters: name, url (for add)")
        val result = jj_run("git remote add " + shell_quote(name) + " " + shell_quote(url), repo_path)
        if result.success:
            make_tool_result(id, warning + result.stdout)
        else:
            make_error_response(id, -32603, result.stderr)
    elif action == "remove":
        if name == "":
            return make_error_response(id, -32602, "Missing required parameter: name (for remove)")
        val result = jj_run("git remote remove " + shell_quote(name), repo_path)
        if result.success:
            make_tool_result(id, warning + result.stdout)
        else:
            make_error_response(id, -32603, result.stderr)
    elif action == "rename":
        if name == "" or new_name == "":
            return make_error_response(id, -32602, "Missing required parameters: name, new_name (for rename)")
        val result = jj_run("git remote rename " + shell_quote(name) + " " + shell_quote(new_name), repo_path)
        if result.success:
            make_tool_result(id, warning + result.stdout)
        else:
            make_error_response(id, -32603, result.stderr)
    else:
        make_error_response(id, -32602, "Unknown action: " + action + ". Use: add, list, remove, rename")

# --- Tool 19: git_tag -> jj tag list (list only) ---

fn schema_git_tag() -> String:
    make_no_param_tool("git_tag", "[Git compat] List tags (translates to jj tag list). Note: jj only supports listing tags.", true, false, true)

fn handle_git_tag(id: String, body: String, repo_path: String) -> String:
    val result = jj_run("tag list", repo_path)
    if result.success:
        val warning = git_compat_warning("git_tag", "jj tag list", "jj_tag")
        var msg = warning
        msg = msg + "Note: jj currently only supports listing tags. Creating/deleting tags must be done via the underlying git repo.\n"
        msg = msg + result.stdout
        make_tool_result(id, msg)
    else:
        make_error_response(id, -32603, result.stderr)

# =============================================================================
# MISC TOOLS (8 tools)
# =============================================================================

# --- Tool 20: git_reset -> jj restore / jj abandon ---

fn schema_git_reset() -> String:
    var props = LB()
    props = props + make_prop("mode", "Reset mode: hard, soft, mixed (default: mixed)")
    props = props + "," + make_prop("revision", "Revision to reset to")
    props = props + RB()
    make_tool_schema_multi("git_reset", "[Git compat] Reset changes (translates to jj restore/abandon)", props, "[]", false, true, false)

fn handle_git_reset(id: String, body: String, repo_path: String) -> String:
    val args = extract_arguments_dict(body)
    val mode = args.get("mode") ?? "mixed"
    val revision = args.get("revision") ?? ""
    val warning = git_compat_warning("git_reset", "jj restore/abandon", "jj_restore")
    if mode == "hard":
        # hard reset -> jj restore (discard all changes)
        var cmd = "restore"
        if revision != "":
            cmd = cmd + " --from " + shell_quote(revision)
        val result = jj_run(cmd, repo_path)
        if result.success:
            var msg = warning
            msg = msg + "Note: 'git reset --hard' translates to 'jj restore' which discards working copy changes.\n"
            msg = msg + result.stdout
            make_tool_result(id, msg)
        else:
            make_error_response(id, -32603, result.stderr)
    else:
        # soft/mixed - explain the jj model
        var msg = warning
        msg = msg + "Note: 'git reset --" + mode + "' has no direct jj equivalent because jj has no staging area.\n\n"
        msg = msg + "In jj, the equivalent operations are:\n"
        msg = msg + "  - 'jj restore' - Discard changes in working copy (like --hard)\n"
        msg = msg + "  - 'jj abandon' - Abandon a change entirely (removes it from history)\n"
        msg = msg + "  - 'jj squash' - Fold changes into parent (like soft reset + recommit)\n"
        msg = msg + "  - 'jj split' - Split a change into multiple parts\n\n"
        msg = msg + "Since jj has no index/staging area, soft and mixed resets are not applicable.\n"
        msg = msg + "Use 'jj_restore' or 'jj_abandon' for native jj operations.\n"
        make_tool_result(id, msg)

# --- Tool 21: git_clean -> explanation only ---

fn schema_git_clean() -> String:
    make_no_param_tool("git_clean", "[Git compat] Remove untracked files (no jj equivalent)", true, false, true)

fn handle_git_clean(id: String, body: String, repo_path: String) -> String:
    val warning = git_compat_warning_no_equiv("git_clean", "jj has no concept of untracked files. All files in the working copy are part of the current change. Use .gitignore to exclude files.")
    make_tool_result(id, warning)

# --- Tool 22: git_stash -> explanation only ---

fn schema_git_stash() -> String:
    make_tool_schema("git_stash", "[Git compat] Stash changes (not needed in jj - working copy is already a change)", "action", "Action: save, pop, list, drop (not applicable in jj)", false, true, false, true)

fn handle_git_stash(id: String, body: String, repo_path: String) -> String:
    val action = extract_nested_string(body, "arguments", "action")
    val warning = git_compat_warning_no_equiv("git_stash", "Stashing is not needed in jj because the working copy IS a commit (change).")
    var msg = warning
    msg = msg + "\nIn jj, the equivalent workflows are:\n"
    msg = msg + "  - 'git stash' -> Not needed. Your working copy changes are always saved as the current change.\n"
    msg = msg + "  - 'git stash pop' -> Use 'jj new' to start a new change, then 'jj squash' to merge later.\n"
    msg = msg + "  - 'git stash list' -> Use 'jj log' to see all changes.\n"
    msg = msg + "  - 'git stash drop' -> Use 'jj abandon' to remove unwanted changes.\n\n"
    msg = msg + "Workflow for temporarily setting aside work:\n"
    msg = msg + "  1. 'jj new' - Creates a new empty change (your current work is preserved in the previous change)\n"
    msg = msg + "  2. Do other work...\n"
    msg = msg + "  3. 'jj edit <previous-change>' - Go back to your original work\n"
    make_tool_result(id, msg)

# --- Tool 23: git_revert -> jj revert ---

fn schema_git_revert() -> String:
    make_tool_schema("git_revert", "[Git compat] Revert a commit (translates to jj revert)", "revision", "Revision to revert (required)", true, false, false, false)

fn handle_git_revert(id: String, body: String, repo_path: String) -> String:
    val revision = extract_nested_string(body, "arguments", "revision")
    if revision == "":
        return make_error_response(id, -32602, "Missing required parameter: revision")
    val result = jj_run("revert -r " + shell_quote(revision), repo_path)
    if result.success:
        val warning = git_compat_warning("git_revert", "jj revert", "jj_revert")
        make_tool_result(id, warning + result.stdout)
    else:
        make_error_response(id, -32603, result.stderr)

# --- Tool 24: git_bisect -> manual workflow explanation ---

fn schema_git_bisect() -> String:
    make_no_param_tool("git_bisect", "[Git compat] Binary search for bugs (no built-in jj bisect)", true, false, true)

fn handle_git_bisect(id: String, body: String, repo_path: String) -> String:
    val warning = git_compat_warning_no_equiv("git_bisect", "jj does not have a built-in bisect command.")
    var msg = warning
    msg = msg + "\nManual bisect workflow in jj:\n\n"
    msg = msg + "1. Find the range of changes to bisect:\n"
    msg = msg + "   jj log -r 'good_rev::bad_rev'\n\n"
    msg = msg + "2. Edit the middle change:\n"
    msg = msg + "   jj edit <middle_change_id>\n\n"
    msg = msg + "3. Test the change, then narrow the range:\n"
    msg = msg + "   - If bad: focus on the first half\n"
    msg = msg + "   - If good: focus on the second half\n\n"
    msg = msg + "4. Repeat until you find the culprit.\n\n"
    msg = msg + "Tip: You can also use revset expressions to filter changes:\n"
    msg = msg + "   jj log -r 'good_rev::bad_rev & author(name)'\n"
    make_tool_result(id, msg)

# --- Tool 25: git_config -> jj config ---

fn schema_git_config() -> String:
    var props = LB()
    props = props + make_prop("action", "Action: get, set, list (default: list)")
    props = props + "," + make_prop("name", "Config key name (e.g. user.name)")
    props = props + "," + make_prop("value", "Config value (for set)")
    props = props + RB()
    make_tool_schema_multi("git_config", "[Git compat] Manage configuration (translates to jj config)", props, "[]", false, false, true)

fn handle_git_config(id: String, body: String, repo_path: String) -> String:
    val args = extract_arguments_dict(body)
    val action = args.get("action") ?? "list"
    val name = args.get("name") ?? ""
    val value = args.get("value") ?? ""
    val warning = git_compat_warning("git_config", "jj config", "jj_config")
    if action == "list":
        val result = jj_run("config list", repo_path)
        if result.success:
            make_tool_result(id, warning + result.stdout)
        else:
            make_error_response(id, -32603, result.stderr)
    elif action == "get":
        if name == "":
            return make_error_response(id, -32602, "Missing required parameter: name (for get)")
        val result = jj_run("config get " + shell_quote(name), repo_path)
        if result.success:
            make_tool_result(id, warning + result.stdout)
        else:
            make_error_response(id, -32603, result.stderr)
    elif action == "set":
        if name == "" or value == "":
            return make_error_response(id, -32602, "Missing required parameters: name, value (for set)")
        val result = jj_run("config set --user " + shell_quote(name) + " " + shell_quote(value), repo_path)
        if result.success:
            make_tool_result(id, warning + result.stdout)
        else:
            make_error_response(id, -32603, result.stderr)
    else:
        make_error_response(id, -32602, "Unknown action: " + action + ". Use: get, set, list")

# --- Tool 26: git_worktree -> jj workspace ---

fn schema_git_worktree() -> String:
    var props = LB()
    props = props + make_prop("action", "Action: add, list, forget (default: list)")
    props = props + "," + make_prop("path", "Path for new workspace (for add)")
    props = props + "," + make_prop("name", "Workspace name")
    props = props + RB()
    make_tool_schema_multi("git_worktree", "[Git compat] Manage worktrees (translates to jj workspace)", props, "[]", false, false, false)

fn handle_git_worktree(id: String, body: String, repo_path: String) -> String:
    val args = extract_arguments_dict(body)
    val action = args.get("action") ?? "list"
    val path = args.get("path") ?? ""
    val name = args.get("name") ?? ""
    val warning = git_compat_warning("git_worktree", "jj workspace", "jj_workspace")
    if action == "list":
        val result = jj_run("workspace list", repo_path)
        if result.success:
            make_tool_result(id, warning + result.stdout)
        else:
            make_error_response(id, -32603, result.stderr)
    elif action == "add":
        if path == "":
            return make_error_response(id, -32602, "Missing required parameter: path (for add)")
        var cmd = "workspace add " + shell_quote(path)
        if name != "":
            cmd = cmd + " --name " + shell_quote(name)
        val result = jj_run(cmd, repo_path)
        if result.success:
            make_tool_result(id, warning + result.stdout)
        else:
            make_error_response(id, -32603, result.stderr)
    elif action == "forget":
        if name == "":
            return make_error_response(id, -32602, "Missing required parameter: name (for forget)")
        val result = jj_run("workspace forget " + shell_quote(name), repo_path)
        if result.success:
            make_tool_result(id, warning + result.stdout)
        else:
            make_error_response(id, -32603, result.stderr)
    else:
        make_error_response(id, -32602, "Unknown action: " + action + ". Use: add, list, forget")

# --- Tool 27: git_set_working_dir -> state change ---

fn schema_git_set_working_dir() -> String:
    make_tool_schema("git_set_working_dir", "[Git compat] Set the working directory for git/jj commands", "path", "Absolute path to repository directory (required)", true, false, false, true)

fn handle_git_set_working_dir(id: String, body: String, repo_path: String) -> String:
    val path = extract_nested_string(body, "arguments", "path")
    if path == "":
        return make_error_response(id, -32602, "Missing required parameter: path")
    # Return success with the path - main.spl will detect and update state
    make_tool_result(id, "SET_REPO_PATH:" + path)

# =============================================================================
# COLLECTOR FUNCTIONS
# =============================================================================

fn get_all_git_tool_schemas() -> [String]:
    var tools: [String] = []
    tools.push(schema_git_status())
    tools.push(schema_git_init())
    tools.push(schema_git_clone())
    tools.push(schema_git_add())
    tools.push(schema_git_commit())
    tools.push(schema_git_log())
    tools.push(schema_git_diff())
    tools.push(schema_git_show())
    tools.push(schema_git_blame())
    tools.push(schema_git_branch())
    tools.push(schema_git_checkout())
    tools.push(schema_git_merge())
    tools.push(schema_git_rebase())
    tools.push(schema_git_cherry_pick())
    tools.push(schema_git_fetch())
    tools.push(schema_git_pull())
    tools.push(schema_git_push())
    tools.push(schema_git_remote())
    tools.push(schema_git_tag())
    tools.push(schema_git_reset())
    tools.push(schema_git_clean())
    tools.push(schema_git_stash())
    tools.push(schema_git_revert())
    tools.push(schema_git_bisect())
    tools.push(schema_git_config())
    tools.push(schema_git_worktree())
    tools.push(schema_git_set_working_dir())
    tools

fn handle_git_tool(id: String, tool_name: String, body: String, repo_path: String) -> String:
    if tool_name == "git_status":
        return handle_git_status(id, body, repo_path)
    elif tool_name == "git_init":
        return handle_git_init(id, body, repo_path)
    elif tool_name == "git_clone":
        return handle_git_clone(id, body, repo_path)
    elif tool_name == "git_add":
        return handle_git_add(id, body, repo_path)
    elif tool_name == "git_commit":
        return handle_git_commit(id, body, repo_path)
    elif tool_name == "git_log":
        return handle_git_log(id, body, repo_path)
    elif tool_name == "git_diff":
        return handle_git_diff(id, body, repo_path)
    elif tool_name == "git_show":
        return handle_git_show(id, body, repo_path)
    elif tool_name == "git_blame":
        return handle_git_blame(id, body, repo_path)
    elif tool_name == "git_branch":
        return handle_git_branch(id, body, repo_path)
    elif tool_name == "git_checkout":
        return handle_git_checkout(id, body, repo_path)
    elif tool_name == "git_merge":
        return handle_git_merge(id, body, repo_path)
    elif tool_name == "git_rebase":
        return handle_git_rebase(id, body, repo_path)
    elif tool_name == "git_cherry_pick":
        return handle_git_cherry_pick(id, body, repo_path)
    elif tool_name == "git_fetch":
        return handle_git_fetch(id, body, repo_path)
    elif tool_name == "git_pull":
        return handle_git_pull(id, body, repo_path)
    elif tool_name == "git_push":
        return handle_git_push(id, body, repo_path)
    elif tool_name == "git_remote":
        return handle_git_remote(id, body, repo_path)
    elif tool_name == "git_tag":
        return handle_git_tag(id, body, repo_path)
    elif tool_name == "git_reset":
        return handle_git_reset(id, body, repo_path)
    elif tool_name == "git_clean":
        return handle_git_clean(id, body, repo_path)
    elif tool_name == "git_stash":
        return handle_git_stash(id, body, repo_path)
    elif tool_name == "git_revert":
        return handle_git_revert(id, body, repo_path)
    elif tool_name == "git_bisect":
        return handle_git_bisect(id, body, repo_path)
    elif tool_name == "git_config":
        return handle_git_config(id, body, repo_path)
    elif tool_name == "git_worktree":
        return handle_git_worktree(id, body, repo_path)
    elif tool_name == "git_set_working_dir":
        return handle_git_set_working_dir(id, body, repo_path)
    else:
        return ""

# =============================================================================
# EXPORTS
# =============================================================================

export schema_git_status, handle_git_status
export schema_git_init, handle_git_init
export schema_git_clone, handle_git_clone
export schema_git_add, handle_git_add
export schema_git_commit, handle_git_commit
export schema_git_log, handle_git_log
export schema_git_diff, handle_git_diff
export schema_git_show, handle_git_show
export schema_git_blame, handle_git_blame
export schema_git_branch, handle_git_branch
export schema_git_checkout, handle_git_checkout
export schema_git_merge, handle_git_merge
export schema_git_rebase, handle_git_rebase
export schema_git_cherry_pick, handle_git_cherry_pick
export schema_git_fetch, handle_git_fetch
export schema_git_pull, handle_git_pull
export schema_git_push, handle_git_push
export schema_git_remote, handle_git_remote
export schema_git_tag, handle_git_tag
export schema_git_reset, handle_git_reset
export schema_git_clean, handle_git_clean
export schema_git_stash, handle_git_stash
export schema_git_revert, handle_git_revert
export schema_git_bisect, handle_git_bisect
export schema_git_config, handle_git_config
export schema_git_worktree, handle_git_worktree
export schema_git_set_working_dir, handle_git_set_working_dir
export get_all_git_tool_schemas, handle_git_tool
