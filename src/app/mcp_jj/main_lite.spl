# Lightweight MCP Server for Jujutsu (jj) - Zero imports for fast startup
#
# Inlines all JSON helpers, jj runner, and tool handling.
# Startup target: <10ms (vs 30s+ for full server with 19 file imports)
#
# Tools (10): jj_status, jj_log, jj_diff, jj_show, jj_new, jj_describe,
#             jj_commit, jj_bookmark_list, jj_git_push, jj_git_fetch
# Resources (2): jj://status, jj://log

extern fn rt_process_run(cmd: text, args: [text]) -> text
extern fn rt_env_get(name: text) -> text

val SERVER_NAME = "jj-mcp-lite"
val SERVER_VERSION = "1.0.0"
val NL = "\n"

# --- jj command runner (inlined) ---

fn jj_run_in(jj_args: text, repo_path: text) -> text:
    var cmd_str = "jj --no-pager --color never"
    if repo_path != "" and repo_path != ".":
        cmd_str = cmd_str + " -R '" + repo_path + "'"
    cmd_str = cmd_str + " " + jj_args
    var all_args: [text] = ["-c", cmd_str + " 2>&1"]
    val result = rt_process_run("/bin/sh", all_args)
    result[0]

fn get_default_repo_path() -> text:
    val env_path = rt_env_get("JJ_MCP_REPO_PATH") ?? ""
    if env_path != "":
        return env_path
    var pwd_args: [text] = ["-c", "pwd"]
    val result = rt_process_run("/bin/sh", pwd_args)
    var out = result[0]
    if out.ends_with(NL):
        out = out.substring(0, out.len() - 1)
    out

# Protocol auto-detection: JSON Lines (MCP SDK) vs Content-Length (LSP)
var USE_JSON_LINES = false

# --- Start server ---
start_server()

fn start_server():
    var repo_path = ""
    var running = true
    for _iter in range(0, 999999):
        if not running:
            return
        var line = read_stdin_message()
        if line == "":
            running = false
        else:
            var method = extract_field(line, "method")
            var id = extract_id(line)
            var response = ""
            if method == "initialize":
                response = make_init_response(id)
            elif method == "initialized" or method == "notifications/initialized":
                response = ""
            elif method == "shutdown":
                response = make_json_result(id, "null")
            elif method == "tools/list":
                response = make_tools_list(id)
            elif method == "tools/call":
                if repo_path == "":
                    repo_path = get_default_repo_path()
                var tool_name = extract_nested(line, "name")
                response = dispatch_tool(id, tool_name, line, repo_path)
            elif method == "resources/list":
                if repo_path == "":
                    repo_path = get_default_repo_path()
                response = handle_resources_list(id, repo_path)
            elif method == "resources/read":
                if repo_path == "":
                    repo_path = get_default_repo_path()
                var uri = extract_nested(line, "uri")
                response = handle_resources_read(id, uri, repo_path)
            elif method == "prompts/list":
                response = make_json_result(id, "{\"prompts\":[]}")
            elif method == "ping":
                response = make_json_result(id, "{}")
            elif method == "notifications/cancelled":
                response = ""
            else:
                if id != "" and id != "null":
                    response = make_error(id, -32601, "Method not found: " + method)
            if response != "":
                write_stdout_message(response)

# --- MCP protocol I/O ---

fn read_stdin_message() -> text:
    var line = input()
    if line == "":
        return ""
    if line.ends_with("\r"):
        line = line.substring(0, line.len() - 1)
    # JSON Lines mode: line starts with { (MCP SDK format)
    if line.starts_with("{"):
        USE_JSON_LINES = true
        return line
    # Content-Length mode (LSP-style framing)
    if line.starts_with("Content-Length:"):
        var len_str = line.replace("Content-Length:", "")
        len_str = len_str.trim()
        val content_length = int(len_str)
        if content_length == 0:
            return ""
        input()
        var body = input()
        return body
    ""

fn write_stdout_message(body: text):
    if USE_JSON_LINES:
        print_raw(body + NL)
    else:
        var header = "Content-Length: " + str(body.len()) + "\r{NL}\r{NL}"
        print_raw(header)
        print_raw(body)

# --- JSON helpers ---

fn js(s: text) -> text:
    "\"" + s + "\""

fn extract_field(json_str: text, field: text) -> text:
    var search = "\"" + field + "\":"
    var idx = find_in(json_str, search)
    if idx < 0:
        return ""
    var rest = json_str.substring(idx + search.len(), json_str.len())
    rest = rest.trim()
    if rest.starts_with("\""):
        var end = find_in(rest.substring(1, rest.len()), "\"")
        if end >= 0:
            return rest.substring(1, end + 1)
    ""

fn extract_nested(json_str: text, field: text) -> text:
    var search = "\"" + field + "\":"
    var idx = find_in(json_str, search)
    if idx < 0:
        return ""
    var rest = json_str.substring(idx + search.len(), json_str.len())
    rest = rest.trim()
    if rest.starts_with("\""):
        var end = find_in(rest.substring(1, rest.len()), "\"")
        if end >= 0:
            return rest.substring(1, end + 1)
    ""

fn extract_id(json_str: text) -> text:
    var search = "\"id\":"
    var idx = find_in(json_str, search)
    if idx < 0:
        return "null"
    var rest = json_str.substring(idx + search.len(), json_str.len())
    rest = rest.trim()
    if rest.starts_with("\""):
        var end = find_in(rest.substring(1, rest.len()), "\"")
        if end >= 0:
            return "\"" + rest.substring(1, end + 1) + "\""
    var end_pos = 0
    for _i in range(0, rest.len()):
        if end_pos >= rest.len():
            break
        var ch = rest.substring(end_pos, end_pos + 1)
        if (ch >= "0" and ch <= "9") or ch == "-":
            end_pos = end_pos + 1
        else:
            break
    if end_pos > 0:
        return rest.substring(0, end_pos)
    "null"

fn find_in(haystack: text, needle: text) -> i64:
    var i = 0
    for _iter in range(0, haystack.len()):
        if i > haystack.len() - needle.len():
            break
        if haystack.substring(i, i + needle.len()) == needle:
            return i
        i = i + 1
    -1

fn extract_arg_value(body: text, arg_name: text) -> text:
    var search = "\"" + arg_name + "\":"
    var idx = find_in(body, search)
    if idx < 0:
        return ""
    var rest = body.substring(idx + search.len(), body.len())
    rest = rest.trim()
    if rest.starts_with("\""):
        var end = find_in(rest.substring(1, rest.len()), "\"")
        if end >= 0:
            return rest.substring(1, end + 1)
    ""

fn escape_json(s: text) -> text:
    var result = ""
    var i = 0
    for _iter in range(0, s.len()):
        if i >= s.len():
            break
        var ch = s.substring(i, i + 1)
        if ch == "\\":
            result = result + "\\\\"
        elif ch == "\"":
            result = result + "\\\""
        elif ch == NL:
            result = result + "\\n"
        elif ch == "\t":
            result = result + "\\t"
        elif ch == "\r":
            result = result + "\\r"
        else:
            result = result + ch
        i = i + 1
    result

# --- Response builders ---
# NOTE: In Simple, }} is escape for }. Use string concat to avoid ambiguity.

fn make_init_response(id: text) -> text:
    var caps = "\"tools\":{\"listChanged\":true}"
    caps = caps + ",\"resources\":{\"listChanged\":true}"
    caps = caps + ",\"prompts\":{\"listChanged\":true}"
    caps = caps + ",\"logging\":{}"
    val instructions = "Lightweight jj MCP server. Provides core jj tools: status, log, diff, show, new, describe, commit, bookmark_list, git_push, git_fetch."
    var info = "\"name\":\"" + SERVER_NAME + "\",\"version\":\"" + SERVER_VERSION + "\",\"instructions\":\"" + escape_json(instructions) + "\""
    var result = "{\"protocolVersion\":\"2025-06-18\",\"capabilities\":{" + caps + "},\"serverInfo\":{" + info + "}" + "}"
    "{\"jsonrpc\":\"2.0\",\"id\":" + id + ",\"result\":" + result + "}"

fn make_json_result(id: text, result: text) -> text:
    "{\"jsonrpc\":\"2.0\",\"id\":" + id + ",\"result\":" + result + "}"

fn make_error(id: text, code: i64, msg: text) -> text:
    var err = "{\"code\":" + str(code) + ",\"message\":" + js(escape_json(msg)) + "}"
    "{\"jsonrpc\":\"2.0\",\"id\":" + id + ",\"error\":" + err + "}"

fn make_text_result(id: text, content: text) -> text:
    var escaped = escape_json(content)
    var inner = "{\"type\":\"text\",\"text\":" + js(escaped) + "}"
    var result = "{\"content\":[" + inner + "],\"isError\":false}"
    make_json_result(id, result)

# --- Tool schema builder ---

fn make_tool_schema(name: text, desc: text, props: text, req: text) -> text:
    var schema = "{\"type\":\"object\",\"properties\":{" + props + "},\"required\":[" + req + "]}"
    "{\"name\":\"" + name + "\",\"description\":\"" + escape_json(desc) + "\",\"inputSchema\":" + schema + "}"

# --- Tool list (10 core jj tools) ---

fn make_tools_list(id: text) -> text:
    var t1 = make_tool_schema("jj_status", "Show working copy status and tracked file changes", "", "")
    var t2 = make_tool_schema("jj_log", "Show commit history log", "\"revisions\":{\"type\":\"string\",\"description\":\"Revset expression to filter commits\"},\"limit\":{\"type\":\"string\",\"description\":\"Max number of commits to show\"}", "")
    var t3 = make_tool_schema("jj_diff", "Show changes in a revision or between revisions", "\"revision\":{\"type\":\"string\",\"description\":\"Revision to show diff for (default: @)\"},\"from\":{\"type\":\"string\",\"description\":\"Show diff from this revision\"},\"to\":{\"type\":\"string\",\"description\":\"Show diff to this revision\"}", "")
    var t4 = make_tool_schema("jj_show", "Show commit details and diff for a revision", "\"revision\":{\"type\":\"string\",\"description\":\"Revision to show (default: @)\"}", "")
    var t5 = make_tool_schema("jj_new", "Create a new empty change", "\"revisions\":{\"type\":\"string\",\"description\":\"Parent revision(s) for the new change\"},\"message\":{\"type\":\"string\",\"description\":\"Description for the new change\"}", "")
    var t6 = make_tool_schema("jj_describe", "Update the description of a change", "\"revision\":{\"type\":\"string\",\"description\":\"Revision to describe (default: @)\"},\"message\":{\"type\":\"string\",\"description\":\"New description text\"}", "")
    var t7 = make_tool_schema("jj_commit", "Commit current changes and start a new change", "\"message\":{\"type\":\"string\",\"description\":\"Commit message\"}", "")
    var t8 = make_tool_schema("jj_bookmark_list", "List all bookmarks in the repository", "\"all_remotes\":{\"type\":\"string\",\"description\":\"Set to true to show bookmarks from all remotes\"}", "")
    var t9 = make_tool_schema("jj_git_push", "Push bookmarks to a git remote", "\"remote\":{\"type\":\"string\",\"description\":\"Remote to push to (default: origin)\"},\"bookmark\":{\"type\":\"string\",\"description\":\"Bookmark to push\"},\"change\":{\"type\":\"string\",\"description\":\"Push this change bookmark\"}", "")
    var t10 = make_tool_schema("jj_git_fetch", "Fetch from a git remote", "\"remote\":{\"type\":\"string\",\"description\":\"Remote to fetch from (default: origin)\"}", "")
    var tools = "[" + t1 + "," + t2 + "," + t3 + "," + t4 + "," + t5 + "," + t6 + "," + t7 + "," + t8 + "," + t9 + "," + t10 + "]"
    make_json_result(id, "{\"tools\":" + tools + "}")

# --- Tool dispatch ---

fn dispatch_tool(id: text, tool_name: text, body: text, repo_path: text) -> text:
    if tool_name == "jj_status":
        return handle_jj_status(id, body, repo_path)
    elif tool_name == "jj_log":
        return handle_jj_log(id, body, repo_path)
    elif tool_name == "jj_diff":
        return handle_jj_diff(id, body, repo_path)
    elif tool_name == "jj_show":
        return handle_jj_show(id, body, repo_path)
    elif tool_name == "jj_new":
        return handle_jj_new(id, body, repo_path)
    elif tool_name == "jj_describe":
        return handle_jj_describe(id, body, repo_path)
    elif tool_name == "jj_commit":
        return handle_jj_commit(id, body, repo_path)
    elif tool_name == "jj_bookmark_list":
        return handle_jj_bookmark_list(id, body, repo_path)
    elif tool_name == "jj_git_push":
        return handle_jj_git_push(id, body, repo_path)
    elif tool_name == "jj_git_fetch":
        return handle_jj_git_fetch(id, body, repo_path)
    else:
        return make_error(id, -32601, "Unknown tool: " + tool_name)

# --- Tool handlers ---

fn handle_jj_result(id: text, output: text) -> text:
    if output == "" or output == nil:
        return make_text_result(id, "(no output)")
    make_text_result(id, output)

fn handle_jj_status(id: text, body: text, repo_path: text) -> text:
    handle_jj_result(id, jj_run_in("status", repo_path))

fn handle_jj_log(id: text, body: text, repo_path: text) -> text:
    val revisions = extract_arg_value(body, "revisions")
    val limit = extract_arg_value(body, "limit")
    var cmd = "log"
    if revisions != "":
        cmd = cmd + " -r " + revisions
    if limit != "":
        cmd = cmd + " -n " + limit
    handle_jj_result(id, jj_run_in(cmd, repo_path))

fn handle_jj_diff(id: text, body: text, repo_path: text) -> text:
    val revision = extract_arg_value(body, "revision")
    val from = extract_arg_value(body, "from")
    val to = extract_arg_value(body, "to")
    var cmd = "diff"
    if revision != "":
        cmd = cmd + " -r " + revision
    if from != "":
        cmd = cmd + " --from " + from
    if to != "":
        cmd = cmd + " --to " + to
    handle_jj_result(id, jj_run_in(cmd, repo_path))

fn handle_jj_show(id: text, body: text, repo_path: text) -> text:
    val revision = extract_arg_value(body, "revision")
    var cmd = "show"
    if revision != "":
        cmd = cmd + " " + revision
    handle_jj_result(id, jj_run_in(cmd, repo_path))

fn handle_jj_new(id: text, body: text, repo_path: text) -> text:
    val revisions = extract_arg_value(body, "revisions")
    val message = extract_arg_value(body, "message")
    var cmd = "new"
    if message != "":
        cmd = cmd + " -m '" + message + "'"
    if revisions != "":
        cmd = cmd + " " + revisions
    handle_jj_result(id, jj_run_in(cmd, repo_path))

fn handle_jj_describe(id: text, body: text, repo_path: text) -> text:
    val revision = extract_arg_value(body, "revision")
    val message = extract_arg_value(body, "message")
    var cmd = "describe"
    if revision != "":
        cmd = cmd + " -r " + revision
    if message != "":
        cmd = cmd + " -m '" + message + "'"
    handle_jj_result(id, jj_run_in(cmd, repo_path))

fn handle_jj_commit(id: text, body: text, repo_path: text) -> text:
    val message = extract_arg_value(body, "message")
    var cmd = "commit"
    if message != "":
        cmd = cmd + " -m '" + message + "'"
    handle_jj_result(id, jj_run_in(cmd, repo_path))

fn handle_jj_bookmark_list(id: text, body: text, repo_path: text) -> text:
    val all_remotes = extract_arg_value(body, "all_remotes")
    var cmd = "bookmark list"
    if all_remotes == "true":
        cmd = cmd + " --all-remotes"
    handle_jj_result(id, jj_run_in(cmd, repo_path))

fn handle_jj_git_push(id: text, body: text, repo_path: text) -> text:
    val remote = extract_arg_value(body, "remote")
    val bookmark = extract_arg_value(body, "bookmark")
    val change = extract_arg_value(body, "change")
    var cmd = "git push"
    if remote != "":
        cmd = cmd + " --remote " + remote
    if bookmark != "":
        cmd = cmd + " --bookmark " + bookmark
    if change != "":
        cmd = cmd + " --change " + change
    handle_jj_result(id, jj_run_in(cmd, repo_path))

fn handle_jj_git_fetch(id: text, body: text, repo_path: text) -> text:
    val remote = extract_arg_value(body, "remote")
    var cmd = "git fetch"
    if remote != "":
        cmd = cmd + " --remote " + remote
    handle_jj_result(id, jj_run_in(cmd, repo_path))

# --- Resources ---

fn handle_resources_list(id: text, repo_path: text) -> text:
    var r1 = "{\"uri\":\"jj://status\",\"name\":\"Working Copy Status\",\"description\":\"Current jj working copy status\",\"mimeType\":\"text/plain\"}"
    var r2 = "{\"uri\":\"jj://log\",\"name\":\"Recent Log\",\"description\":\"Recent jj commit history (last 20)\",\"mimeType\":\"text/plain\"}"
    make_json_result(id, "{\"resources\":[" + r1 + "," + r2 + "]}")

fn handle_resources_read(id: text, uri: text, repo_path: text) -> text:
    var content = ""
    if uri == "jj://status":
        content = jj_run_in("status", repo_path)
    elif uri == "jj://log":
        content = jj_run_in("log -n 20", repo_path)
    else:
        return make_error(id, -32602, "Resource not found: " + uri)
    var escaped = escape_json(content)
    var item = "{\"uri\":" + js(uri) + ",\"mimeType\":\"text/plain\",\"text\":" + js(escaped) + "}"
    make_json_result(id, "{\"contents\":[" + item + "]}")
