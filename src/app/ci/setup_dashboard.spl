#!/usr/bin/env simple
# Dashboard CI/CD Setup Script
# Helps configure GitHub Actions and Jenkins/Hudson for Dashboard CLI
# Usage: setup_dashboard [github|jenkins|both|env|test|help]
# Migrated from scripts/build/setup-dashboard-ci.sh

use app.io
use app.utils.colors (success, error, warning, info)

export main, setup_dashboard

fn main():
    val args = get_args()
    val command = if args.len() > 0:
        args[0]
    else:
        "both"

    match command:
        "github": setup_github_actions()
        "jenkins": setup_jenkins()
        "both":
            setup_github_actions()
            print ""
            setup_jenkins()
        "env": setup_environment()
        "test":
            setup_environment()
            print ""
            test_build()
        "help": show_usage()
        "--help": show_usage()
        "-h": show_usage()
        _:
            print error("Unknown command: {command}")
            show_usage()
            exit(1)

    print ""
    print success("Setup completed!")
    print ""
    print "Next steps:"
    print "1. Review configuration: doc/guide/dashboard_cicd.md"
    print "2. Push changes to repository"
    print "3. Monitor builds in GitHub Actions or Jenkins"
    print ""

fn setup_dashboard():
    """Main setup function"""
    main()

fn print_header(title: text):
    """Print section header"""
    print info("===================================")
    print info(title)
    print info("===================================")

fn check_file(path: text) -> bool:
    """Check if file exists and print status"""
    if file_exists(path):
        print success("Found: {path}")
        return true
    else:
        print error("Missing: {path}")
        return false

fn setup_github_actions():
    """Setup GitHub Actions"""
    print_header("Setting up GitHub Actions")

    val workflow_file = ".github/workflows/dashboard-ci.yml"

    if not check_file(workflow_file):
        print error("Workflow file not found!")
        return

    print ""
    print info("GitHub Actions Configuration:")
    print "- Workflow file: {workflow_file}"
    print "- Triggers: Push to main/develop, PRs"
    print "- Platforms: Ubuntu, macOS, Windows"
    print ""
    print "Steps to activate:"
    print "1. Push changes to GitHub"
    print "2. Go to repository → Actions tab"
    print "3. Click 'Dashboard CI/CD' workflow"
    print ""

    # Check if git remote exists
    val (remote_out, _, remote_code) = process_run("git", ["remote", "get-url", "origin"])
    if remote_code == 0:
        val remote = remote_out.trim()
        print success("Git remote: {remote}")
    else:
        print warning("No git remote configured")

    print "Optional: Enable branch protection"
    print "1. Go to Settings → Branches"
    print "2. Add rule for 'main' branch"
    print "3. Check 'Require status checks to pass'"
    print "4. Select 'Dashboard CI/CD' checks"
    print ""

    print success("GitHub Actions setup complete!")

fn setup_jenkins():
    """Setup Jenkins/Hudson"""
    print_header("Setting up Jenkins/Hudson")

    val jenkinsfile = "Jenkinsfile-dashboard"

    if not check_file(jenkinsfile):
        print error("Jenkinsfile not found!")
        return

    print success("Found: {jenkinsfile}")
    print ""
    print info("Jenkins Configuration Steps:")
    print ""
    print "1. Create New Pipeline Job:"
    print "   - Go to Jenkins home"
    print "   - Click 'New Item'"
    print "   - Name: 'Dashboard-CI-CD'"
    print "   - Select 'Pipeline'"
    print "   - Click 'OK'"
    print ""
    print "2. Configure Pipeline:"
    print "   - Pipeline section → 'Pipeline script from SCM'"
    print "   - SCM: 'Git'"

    val (remote_out, _, _) = process_run("git", ["remote", "get-url", "origin"])
    val repo_url = if remote_out.trim().len() > 0:
        remote_out.trim()
    else:
        "https://github.com/org/repo"

    print "   - Repository URL: {repo_url}"
    print "   - Credentials: (configure if private repo)"
    print "   - Branch: */main"
    print "   - Script Path: Jenkinsfile-dashboard"
    print ""
    print "3. Build Triggers:"
    print "   - GitHub hook trigger (recommended)"
    print "   - OR Poll SCM: H/15 * * * *"
    print ""
    print "4. Verify Rust on agents:"

    # Check local Rust installation
    val (rustc_out, _, rustc_code) = process_run("rustc", ["--version"])
    if rustc_code == 0:
        val rust_version = rustc_out.trim()
        print success("   {rust_version}")
    else:
        print warning("   Rust not found on this system")
        print "   Install on Jenkins agents with:"
        print "   curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh"

    print ""
    print "5. Optional: Configure Notifications"
    print "   - Email: Manage Jenkins → Configure System"
    print "   - Slack: Install Slack plugin and configure webhook"
    print ""

    print success("Jenkins setup instructions complete!")

fn setup_environment() -> bool:
    """Verify build environment"""
    print_header("Verifying Build Environment")

    print ""
    print info("Checking prerequisites:")
    print ""

    var all_ok = true

    # Check Rust
    val (rustc_out, _, rustc_code) = process_run("rustc", ["--version"])
    if rustc_code == 0:
        val rust_version = rustc_out.trim()
        print success("{rust_version}")
    else:
        print error("Rust not installed")
        print "  Install: https://rustup.rs/"
        all_ok = false

    # Check Cargo
    val (cargo_out, _, cargo_code) = process_run("cargo", ["--version"])
    if cargo_code == 0:
        val cargo_version = cargo_out.trim()
        print success("{cargo_version}")
    else:
        print error("Cargo not installed")
        all_ok = false

    # Check Git
    val (git_out, _, git_code) = process_run("git", ["--version"])
    if git_code == 0:
        val git_version = git_out.trim()
        print success("{git_version}")
    else:
        print error("Git not installed")
        all_ok = false

    # Check dashboard files
    print ""
    print info("Checking dashboard files:")
    val dashboard_files = [
        "src/app/dashboard/main.spl",
        "src/lib/std/src/tooling/dashboard/notify.spl",
        "src/lib/std/src/tooling/dashboard/alert_rules.spl",
        "src/lib/std/src/tooling/dashboard/compare.spl",
        "src/lib/std/src/tooling/dashboard/query.spl"
    ]

    for file in dashboard_files:
        if not check_file(file):
            all_ok = false

    print ""
    if all_ok:
        print success("Environment verification complete!")
    else:
        print error("Environment verification failed - please fix missing dependencies")

    all_ok

fn test_build() -> bool:
    """Test dashboard build"""
    print_header("Testing Dashboard Build")

    print ""
    print info("Building dashboard...")

    # Check if simple compiler exists
    if not file_exists("target/debug/simple"):
        print warning("Simple compiler not found, building...")
        val (build_out, _, _) = process_run("cargo", ["build"])
        val lines = build_out.split("\n")
        val total = lines.len()
        val start = if total > 5: total - 5 else: 0
        for i in start..total:
            print lines[i]

    # Compile dashboard
    val (_, stderr, compile_code) = process_run("./target/debug/simple",
        ["compile", "src/app/dashboard/main.spl"])

    if compile_code != 0:
        print error("Dashboard compilation failed")
        print stderr
        return false

    print success("Dashboard compiled successfully")

    # Check binary
    if file_exists("src/app/dashboard/main.smf"):
        val size = file_size("src/app/dashboard/main.smf")
        val size_str = format_size(size)
        print success("Binary created ({size_str})")

    # Run dashboard
    print ""
    print info("Running dashboard...")
    val (run_out, _, run_code) = process_run("./target/debug/simple",
        ["src/app/dashboard/main.spl"])

    if run_code == 0:
        # Print first 20 lines
        val lines = run_out.split("\n")
        val limit = if lines.len() > 20: 20 else: lines.len()
        for i in 0..limit:
            print lines[i]

        print success("Dashboard executed successfully")
    else:
        print error("Dashboard execution failed")
        return false

    print ""
    print success("Build test complete!")
    true

fn show_usage():
    """Show usage information"""
    print "Usage: setup_dashboard [command]"
    print ""
    print "Commands:"
    print "  github   - Setup GitHub Actions"
    print "  jenkins  - Setup Jenkins/Hudson"
    print "  both     - Setup both GitHub Actions and Jenkins"
    print "  env      - Verify build environment"
    print "  test     - Test dashboard build locally"
    print "  help     - Show this help message"
    print ""

fn format_size(bytes: i64) -> text:
    """Format byte size as human readable"""
    if bytes < 1024:
        return "{bytes}B"

    val kb = bytes / 1024
    if kb < 1024:
        return "{kb}KB"

    val mb = kb / 1024
    if mb < 1024:
        return "{mb}MB"

    val gb = mb / 1024
    "{gb}GB"
