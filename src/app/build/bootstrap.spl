# Bootstrap Pipeline
#
# 3-stage self-compilation verification for the Simple compiler.
# Ensures the compiler can compile itself consistently.
#
# Stage 1: Pre-built bootstrap binary → simple_new1 (copy)
# Stage 2: simple_new1 compiles src/app/cli/main.spl → simple_new2.smf
# Stage 3: simple_new2.smf compiles src/app/cli/main.spl → simple_new3.smf
# Verify: Stage2 == Stage3 (binary reproducibility)

use app.build.types (BuildProfile)
use std.log.{error}

# Bootstrap stage
enum BootstrapStage:
    Stage1    # Pre-built binary → simple_new1
    Stage2    # simple_new1 → simple_new2
    Stage3    # simple_new2 → simple_new3

# Bootstrap configuration
struct BootstrapConfig:
    profile: BuildProfile      # Build profile (usually Bootstrap)
    verify: bool               # Verify stage2 == stage3
    keep_artifacts: bool       # Keep intermediate binaries
    workspace_root: text       # Workspace root directory
    output_dir: text           # Where to place stage outputs

# Bootstrap result for a single stage
struct StageResult:
    stage: BootstrapStage
    success: bool
    binary_path: text
    binary_size: i64
    build_duration_ms: i64
    hash: text                 # SHA256 hash of binary

impl StageResult:
    fn summary() -> text:
        val status = if self.success: "+" else: "x"
        "Stage {stage_name(self.stage)}: {status} ({self.binary_size} bytes, {self.build_duration_ms}ms)"

# Bootstrap pipeline result
struct BootstrapResult:
    stage1: StageResult
    stage2: StageResult
    stage3: StageResult
    verified: bool             # Stage2 == Stage3
    overall_success: bool

impl BootstrapResult:
    fn summary() -> text:
        var parts = [
            self.stage1.summary(),
            self.stage2.summary(),
            self.stage3.summary()
        ]

        if self.verified:
            parts = parts.merge(["+ Verification: Stage2 == Stage3"])
        else:
            parts = parts.merge(["x Verification: Stage2 != Stage3"])

        parts.join("\n")

use app.io.mod (file_exists, file_size_raw, file_copy, file_delete, dir_create, process_run, file_hash_sha256, shell, time_now_unix_micros)

# Bootstrap class
class Bootstrap:
    # Run complete 3-stage bootstrap pipeline
    static fn run(config: BootstrapConfig) -> BootstrapResult:
        print "Starting 3-Stage Bootstrap Pipeline"
        print "===================================="
        print ""

        # Create output directory
        dir_create(config.output_dir, false)

        # Stage 1: Pre-built binary → simple_new1
        print "Stage 1: Using pre-built bootstrap binary..."
        val stage1_result = run_stage1(config)
        print stage1_result.summary()

        if not stage1_result.success:
            return BootstrapResult(
                stage1: stage1_result,
                stage2: empty_stage_result(BootstrapStage.Stage2),
                stage3: empty_stage_result(BootstrapStage.Stage3),
                verified: false,
                overall_success: false
            )

        # Stage 2: simple_new1 → simple_new2
        print "\nStage 2: Compiling with simple_new1..."
        val stage2_result = run_stage2(config, stage1_result)
        print stage2_result.summary()

        if not stage2_result.success:
            return BootstrapResult(
                stage1: stage1_result,
                stage2: stage2_result,
                stage3: empty_stage_result(BootstrapStage.Stage3),
                verified: false,
                overall_success: false
            )

        # Stage 3: simple_new2 → simple_new3
        print "\nStage 3: Compiling with simple_new2..."
        val stage3_result = run_stage3(config, stage2_result)
        print stage3_result.summary()

        if not stage3_result.success:
            return BootstrapResult(
                stage1: stage1_result,
                stage2: stage2_result,
                stage3: stage3_result,
                verified: false,
                overall_success: false
            )

        # Verification: Stage2 == Stage3
        print "\nVerification: Comparing stage2 and stage3..."
        var verified = true
        if config.verify:
            verified = verify_stages(stage2_result, stage3_result)
        else:
            verified = true

        if verified:
            print "+ Verification passed: stage2 == stage3"
        else:
            print "x Verification failed: stage2 != stage3"

        # Cleanup if requested
        if not config.keep_artifacts:
            cleanup_artifacts(config, stage1_result, stage2_result, stage3_result)

        val s1_ok = stage1_result.success
        val s2_ok = stage2_result.success
        val s3_ok = stage3_result.success
        val s12 = s1_ok and s2_ok
        val s123 = s12 and s3_ok
        val overall_success = s123 and verified

        BootstrapResult(
            stage1: stage1_result,
            stage2: stage2_result,
            stage3: stage3_result,
            verified: verified,
            overall_success: overall_success
        )

    # Quick bootstrap with defaults
    static fn quick() -> BootstrapResult:
        Bootstrap.run(default_bootstrap_config())

# Stage 1: Use pre-built bootstrap binary
fn run_stage1(config: BootstrapConfig) -> StageResult:
    val start_time = current_time_ms()

    # Find the pre-built bootstrap binary
    var bootstrap_path = "bin/release/simple"
    if not file_exists(bootstrap_path):
        bootstrap_path = "./bin/release/simple"

    if not file_exists(bootstrap_path):
        error("build", "Pre-built bootstrap binary not found")
        print "  Expected: bin/release/simple"
        return StageResult(
            stage: BootstrapStage.Stage1,
            success: false,
            binary_path: "",
            binary_size: 0,
            build_duration_ms: current_time_ms() - start_time,
            hash: ""
        )

    # Copy to stage1 output
    val stage1_path = "{config.output_dir}/simple_new1"
    if not file_copy(bootstrap_path, stage1_path):
        error("build", "Failed to copy bootstrap binary to {stage1_path}")
        return StageResult(
            stage: BootstrapStage.Stage1,
            success: false,
            binary_path: "",
            binary_size: 0,
            build_duration_ms: current_time_ms() - start_time,
            hash: ""
        )

    # Make executable
    shell("chmod +x {stage1_path}")

    val binary_size = file_size_raw(stage1_path)
    val hash = file_hash_sha256(stage1_path)

    print "  Copied pre-built binary ({binary_size} bytes)"

    StageResult(
        stage: BootstrapStage.Stage1,
        success: true,
        binary_path: stage1_path,
        binary_size: binary_size,
        build_duration_ms: current_time_ms() - start_time,
        hash: hash
    )

# Stage 2: Use stage1 binary to compile the compiler
fn run_stage2(config: BootstrapConfig, stage1: StageResult) -> StageResult:
    val start_time = current_time_ms()

    # Stage 2: Use stage1 binary to compile the compiler to a native executable.
    # SIMPLE_COMPILE_RUST=1 tells the binary to use its native Cranelift backend.
    # Building as native executable (not SMF) so it includes the full compiler.
    val stage2_path = "{config.output_dir}/simple_new2"
    val stage1_binary = stage1.binary_path

    # Use stage1 binary to compile the compiler to native executable
    val compile_cmd = "SIMPLE_COMPILE_RUST=1 {stage1_binary} compile src/app/cli/main.spl --format=native -o {stage2_path}"
    val compile_result = shell(compile_cmd)

    if compile_result.exit_code != 0:
        error("build", "Stage 2 compilation failed")
        if compile_result.stderr != "":
            print "  {compile_result.stderr}"
        return StageResult(
            stage: BootstrapStage.Stage2,
            success: false,
            binary_path: "",
            binary_size: 0,
            build_duration_ms: current_time_ms() - start_time,
            hash: ""
        )

    val binary_size = file_size_raw(stage2_path)
    val hash = file_hash_sha256(stage2_path)

    StageResult(
        stage: BootstrapStage.Stage2,
        success: true,
        binary_path: stage2_path,
        binary_size: binary_size,
        build_duration_ms: current_time_ms() - start_time,
        hash: hash
    )

# Stage 3: Use stage2 to compile the compiler
fn run_stage3(config: BootstrapConfig, stage2: StageResult) -> StageResult:
    val start_time = current_time_ms()

    # Stage 3: Use stage2 binary to compile again.
    # If stage2 == stage3 (hash match), the compiler is reproducible.
    val stage3_path = "{config.output_dir}/simple_new3"
    val stage2_binary = stage2.binary_path

    # Make stage2 binary executable
    shell("chmod +x {stage2_binary}")

    # Use stage2 binary directly to compile the compiler
    val compile_cmd = "SIMPLE_COMPILE_RUST=1 {stage2_binary} compile src/app/cli/main.spl --format=native -o {stage3_path}"
    val compile_result = shell(compile_cmd)

    if compile_result.exit_code != 0:
        error("build", "Stage 3 compilation failed")
        if compile_result.stderr != "":
            print "  {compile_result.stderr}"
        return StageResult(
            stage: BootstrapStage.Stage3,
            success: false,
            binary_path: "",
            binary_size: 0,
            build_duration_ms: current_time_ms() - start_time,
            hash: ""
        )

    val binary_size = file_size_raw(stage3_path)
    val hash = file_hash_sha256(stage3_path)

    StageResult(
        stage: BootstrapStage.Stage3,
        success: true,
        binary_path: stage3_path,
        binary_size: binary_size,
        build_duration_ms: current_time_ms() - start_time,
        hash: hash
    )

# Verify that stage2 and stage3 are identical
fn verify_stages(stage2: StageResult, stage3: StageResult) -> bool:
    # Compare SHA256 hashes
    if stage2.hash != stage3.hash:
        print "Hash mismatch:"
        print "  Stage2: {stage2.hash}"
        print "  Stage3: {stage3.hash}"
        return false

    # Compare file sizes
    if stage2.binary_size != stage3.binary_size:
        print "Size mismatch:"
        print "  Stage2: {stage2.binary_size} bytes"
        print "  Stage3: {stage3.binary_size} bytes"
        return false

    true

# Cleanup intermediate artifacts
fn cleanup_artifacts(config: BootstrapConfig, stage1: StageResult, stage2: StageResult, stage3: StageResult):
    print "\nCleaning up intermediate artifacts..."

    if stage1.binary_path.len() > 0:
        file_delete(stage1.binary_path)

    if stage2.binary_path.len() > 0:
        file_delete(stage2.binary_path)

    # Keep stage3 as the final bootstrap binary
    print "Kept final binary: {stage3.binary_path}"

# Helper: Empty stage result
fn empty_stage_result(stage: BootstrapStage) -> StageResult:
    StageResult(
        stage: stage,
        success: false,
        binary_path: "",
        binary_size: 0,
        build_duration_ms: 0,
        hash: ""
    )

# Helper: Current time in milliseconds
fn current_time_ms() -> i64:
    time_now_unix_micros() / 1000

# Helper: Stage name to string
fn stage_name(stage: BootstrapStage) -> text:
    match stage:
        case BootstrapStage.Stage1: "1"
        case BootstrapStage.Stage2: "2"
        case BootstrapStage.Stage3: "3"

# Print bootstrap result
fn print_bootstrap_result(result: BootstrapResult):
    print "\n=========================================="
    print "Bootstrap Pipeline Result"
    print "=========================================="
    print ""
    print result.summary()
    print ""

    if result.overall_success:
        print "+ Bootstrap pipeline completed successfully"
        print ""
        print "Final binary:"
        print "  Path: {result.stage3.binary_path}"
        print "  Size: {result.stage3.binary_size} bytes"
        print "  Hash: {result.stage3.hash}"
    else:
        print "x Bootstrap pipeline failed"

# Default bootstrap configuration
fn default_bootstrap_config() -> BootstrapConfig:
    BootstrapConfig(
        profile: BuildProfile.Bootstrap,
        verify: true,
        keep_artifacts: true,
        workspace_root: ".",
        output_dir: "build/bootstrap"
    )
