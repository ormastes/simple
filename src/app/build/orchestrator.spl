# Build Orchestrator - OPTIMIZED VERSION
#
# Orchestrates build operations with proper sequencing
#
# Build pipeline:
# 1. Run FFI generator to create Rust code in build/rust/ffi_gen/
# 2. Run cargo build on the generated workspace
#
# OPTIMIZATIONS APPLIED:
# 1. Use .? existence check instead of .len() > 0
# 2. Cache string splits to avoid repeated parsing
# 3. Batch string building for error messages

use app.build.types (BuildConfig, BuildResult, BuildProfile, profile_to_string)
use app.build.cargo (Cargo, print_build_result)
use app.io.io (file_exists, process_run)

# Run FFI generator to create Rust workspace
fn run_ffi_generator(verbose: bool) -> bool:
    if verbose:
        print "Running FFI generator..."

    # Check if ffi_gen workspace already exists and is up to date
    if file_exists("build/rust/ffi_gen/src/lib.rs"):
        if verbose:
            print "FFI workspace exists, checking if regeneration needed..."
        # For now, always regenerate to ensure consistency
        # TODO: Add incremental check based on spec file timestamps

    # Run the FFI generator directly via runtime with the script path
    # This avoids interpreter mode limitations by running as a subprocess
    # Use --gen-workspace to create multi-crate workspace (NOT --gen-all)
    var args: [text] = ["src/app/ffi_gen/main.spl", "--gen-workspace"]
    if verbose:
        args = args.push("--verbose")

    val (stdout, stderr, exit_code) = process_run("./bin/simple_runtime", args)

    if exit_code == 0:
        if verbose:
            print "✓ FFI generation complete"
            # OPTIMIZATION: Use .? existence check
            if stdout.?:
                print stdout
        true
    else:
        # OPTIMIZATION: Build error message as list then join once
        var error_lines = [
            "✗ FFI generation failed with exit code {exit_code}",
            "  Command: ./bin/simple_runtime {args.join(' ')}"
        ]

        # OPTIMIZATION: Use .? and cache split result
        if stderr.?:
            error_lines.push("  Error output:")
            val stderr_lines = stderr.split("\n")
            for line in stderr_lines:
                if line.?:
                    error_lines.push("    {line}")

        if stdout.?:
            error_lines.push("  Standard output:")
            val stdout_lines = stdout.split("\n")
            for line in stdout_lines:
                if line.?:
                    error_lines.push("    {line}")

        error_lines.push("")
        error_lines.push("  Hint: FFI generation is required before building")
        error_lines.push("  Try running: ./bin/simple src/app/ffi_gen/main.spl --gen-workspace")

        # OPTIMIZATION: Single print call
        print error_lines.join("\n")
        false

# Orchestrate a build
fn orchestrate_build(config: BuildConfig) -> BuildResult:
    if config.verbose:
        # OPTIMIZATION: Build verbose output as batch
        var info_lines = [
            "Building with profile: {profile_to_string(config.profile)}",
            "Workspace root: {config.workspace_root}"
        ]

        # OPTIMIZATION: Use .? check
        if config.features.?:
            info_lines.push("Features: {config.features}")

        print info_lines.join("\n")

    # Step 1: Run FFI generator to create Rust code
    if not run_ffi_generator(config.verbose):
        return BuildResult(
            success: false,
            exit_code: 1,
            stdout: "",
            stderr: "FFI generation failed",
            duration_ms: 0
        )

    # Step 2: Execute cargo build
    val result = Cargo.build(config)

    # Print result
    print_build_result(result)

    result

# Orchestrate tests
fn orchestrate_test(config: BuildConfig) -> i64:
    if config.verbose:
        print "Running tests..."

    # First ensure we have a debug build
    if config.verbose:
        print "Ensuring debug build exists..."

    var build_config = config
    build_config.profile = BuildProfile.Debug

    val build_result = Cargo.build(build_config)
    if not build_result.success:
        print "Build failed, cannot run tests"
        return 1

    # Run tests
    val test_result = Cargo.test_workspace()

    if test_result.success:
        print "All tests passed: {test_result.tests_passed}/{test_result.tests_run}"
        return 0
    else:
        print "Tests failed: {test_result.tests_failed}/{test_result.tests_run}"
        return 1

# Clean build artifacts
fn orchestrate_clean(verbose: bool) -> i64:
    if verbose:
        print "Cleaning build artifacts..."

    val exit_code = Cargo.clean()

    if exit_code == 0:
        print "Clean complete"
    else:
        print "Clean failed"

    exit_code
