# Simple (.spl) replacement for script/build_type_database.sh
# Build Type Database
#
# Scans source code for struct/class definitions and extracts field names.
# Output: build/type_database.txt (format: TypeName:field1,field2,field3)

use app.io.mod.{shell, shell_output, file_read, file_write, file_exists, dir_create_all, exit}
use std.string.{trim, contains, starts_with, split}

val OUTPUT_FILE = "build/type_database.txt"

fn is_upper(ch: text) -> bool:
    val uppers = "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
    return contains(uppers, ch)

fn extract_types_from_file(path: text) -> [text]:
    var results = [text]
    val content = file_read(path)
    val lines = split(content, "\n")

    var type_name = ""
    var fields = ""
    var in_type = false

    for line in lines:
        val trimmed = trim(line)

        # Check for struct/class definition
        if (starts_with(trimmed, "struct ") or
            starts_with(trimmed, "class ")):
            # End previous type if any
            if in_type and type_name != "" and fields != "":
                results = results + ["{type_name}:{fields}"]
            # Parse new type
            var parts = split(trimmed, " ")
            if parts.len() >= 2:
                var name_part = parts[1]
                # Remove trailing colon
                if name_part.len() > 0:
                    var last_ch = name_part[name_part.len() - 1]
                    if last_ch == ":":
                        name_part = name_part[0:name_part.len() - 1]
                # Check starts with uppercase
                if name_part.len() > 0 and is_upper(name_part[0]):
                    type_name = name_part
                    fields = ""
                    in_type = true
                else:
                    in_type = false
            continue

        # Check for field definition (indented, lowercase start, has colon)
        if in_type:
            if trimmed == "":
                # Empty line ends type
                if type_name != "" and fields != "":
                    results = results + ["{type_name}:{fields}"]
                type_name = ""
                fields = ""
                in_type = false
                continue

            # Non-indented line ends type
            if line.len() > 0 and line[0] != " " and line[0] != "\t":
                if type_name != "" and fields != "":
                    results = results + ["{type_name}:{fields}"]
                type_name = ""
                fields = ""
                in_type = false
                continue

            # Check for field: indented, has colon, starts with lowercase
            if trimmed.len() > 0 and contains(trimmed, ":"):
                val first_ch = trimmed[0]
                val lowers = "abcdefghijklmnopqrstuvwxyz_"
                if contains(lowers, first_ch):
                    val field_parts = split(trimmed, ":")
                    if field_parts.len() >= 2:
                        val field_name = trim(field_parts[0])
                        # Skip fn/me/static declarations
                        if (not starts_with(field_name, "fn ") and
                            not starts_with(field_name, "me ") and
                            not starts_with(field_name, "static ")):
                            if fields == "":
                                fields = field_name
                            else:
                                fields = "{fields},{field_name}"

    # Flush last type
    if in_type and type_name != "" and fields != "":
        results = results + ["{type_name}:{fields}"]

    return results

fn main():
    dir_create_all("build")

    print "=== Building Type Database ==="
    print "Scanning src/ and test/lib for type definitions..."
    print ""

    # Find all .spl files using shell find
    val file_list = trim(shell_output("find src test/lib -name '*.spl' -type f 2>/dev/null"))
    val files = split(file_list, "\n")

    var all_entries = [text]

    for file in files:
        val f = trim(file)
        if f == "":
            continue
        val entries = extract_types_from_file(f)
        for entry in entries:
            all_entries = all_entries + [entry]

    # Sort and deduplicate
    var seen = [text]
    var unique = [text]
    for entry in all_entries:
        var is_dup = false
        for s in seen:
            if s == entry:
                is_dup = true
        if not is_dup:
            seen = seen + [entry]
            unique = unique + [entry]

    # Sort by writing to file and using sort
    var content = ""
    for entry in unique:
        content = "{content}{entry}\n"
    file_write(OUTPUT_FILE, content)

    # Use shell sort for proper ordering
    shell("sort -u {OUTPUT_FILE} -o {OUTPUT_FILE}")

    val total = trim(shell_output("wc -l < {OUTPUT_FILE}"))
    print "Found {total} type definitions"
    print "Output: {OUTPUT_FILE}"
    print ""
    print "Sample entries:"
    val sample = shell_output("head -20 {OUTPUT_FILE}")
    print sample

main()
