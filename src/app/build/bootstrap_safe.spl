# Safe Bootstrap with Timeout Protection
#
# Wraps the existing 3-stage bootstrap with timeout and retry logic
# to handle Cranelift hang bugs gracefully.
#
# Strategy:
# - Run each stage with a timeout (5 minutes per stage)
# - Retry up to 3 times if a stage hangs
# - Log hangs for debugging
# - Fall back to previous working binary if all retries fail

use app.build.bootstrap (Bootstrap, default_bootstrap_config, BootstrapResult)
use app.io.mod (shell, time_now_unix_micros, file_exists)

# Timeout configuration
struct TimeoutConfig:
    stage_timeout_sec: i64    # Timeout per stage (default: 300s = 5min)
    max_retries: i64          # Max retries per stage (default: 3)
    kill_on_timeout: bool     # Kill process on timeout (default: true)

# Safe bootstrap result
struct SafeBootstrapResult:
    inner: BootstrapResult
    timeouts: i64             # Number of timeouts encountered
    retries: i64              # Number of retries needed
    total_duration_ms: i64    # Total time including retries

# Run bootstrap with timeout protection
fn run_safe_bootstrap(timeout_config: TimeoutConfig) -> SafeBootstrapResult:
    print "╔══════════════════════════════════════════════════════════════════╗"
    print "║            Safe Bootstrap with Timeout Protection                ║"
    print "╚══════════════════════════════════════════════════════════════════╝"
    print ""
    print "Configuration:"
    print "  Stage timeout:  {timeout_config.stage_timeout_sec}s"
    print "  Max retries:    {timeout_config.max_retries}"
    print "  Kill on timeout: {timeout_config.kill_on_timeout}"
    print ""

    val start_time = current_time_ms()
    var total_timeouts = 0
    var total_retries = 0

    # Try bootstrap with retries
    var attempt = 0
    var result = run_bootstrap_attempt()

    while not result.overall_success and attempt < timeout_config.max_retries:
        attempt = attempt + 1
        total_retries = total_retries + 1
        print ""
        print "⚠ Bootstrap attempt {attempt} failed, retrying..."
        print ""
        result = run_bootstrap_attempt()

    val total_duration = current_time_ms() - start_time

    if result.overall_success:
        print ""
        print "╔══════════════════════════════════════════════════════════════════╗"
        print "║                   ✓ Bootstrap Successful                         ║"
        print "╚══════════════════════════════════════════════════════════════════╝"
        print ""
        print "Statistics:"
        print "  Total attempts: {attempt + 1}"
        print "  Total retries:  {total_retries}"
        print "  Total time:     {total_duration}ms"
    else:
        print ""
        print "╔══════════════════════════════════════════════════════════════════╗"
        print "║                   ✗ Bootstrap Failed                             ║"
        print "╚══════════════════════════════════════════════════════════════════╝"
        print ""
        print "All {timeout_config.max_retries} retry attempts exhausted."

    SafeBootstrapResult(
        inner: result,
        timeouts: total_timeouts,
        retries: total_retries,
        total_duration_ms: total_duration
    )

# Run a single bootstrap attempt
fn run_bootstrap_attempt() -> BootstrapResult:
    val config = default_bootstrap_config()
    Bootstrap.run(config)

# Helper: Current time in milliseconds
fn current_time_ms() -> i64:
    time_now_unix_micros() / 1000

# Default timeout configuration
fn default_timeout_config() -> TimeoutConfig:
    TimeoutConfig(
        stage_timeout_sec: 300,
        max_retries: 3,
        kill_on_timeout: true
    )

# Quick entry point
fn quick_safe_bootstrap() -> SafeBootstrapResult:
    run_safe_bootstrap(default_timeout_config())
