# Multi-Phase Bootstrap Pipeline (Seed Compiler Path)
#
# Builds the Simple compiler from source using the seed C++ transpiler,
# producing working native binaries through a 4-phase chain:
#
#   Phase 0: Prerequisites check (seed_cpp, clang++, runtime libs)
#   Phase 1 (Core1): seed_cpp transpiles compiler_core → C++ → clang++ → native
#   Phase 2 (Core2): Core1 recompiles compiler_core (reproducibility check)
#   Phase 3 (Full1): Core2 compiles the full compiler
#   Phase 4 (Full2): Full1 recompiles itself (reproducibility check)
#
# The seed compiler (seed_cpp) is a minimal C++ program that reads Core Simple
# source and emits C++ code, which is then compiled with clang++ and linked
# against the Simple runtime library and startup CRT.
#
# Key insight: seed_cpp handles forward declarations via two-pass compilation
# (collects all struct/fn signatures first, then emits bodies), so file
# ordering only needs to avoid putting main.spl before its dependencies.

use app.build.types (BuildProfile)
use app.io.mod (file_exists, file_size_raw, file_copy, file_delete, dir_create,
                  dir_walk, file_hash_sha256, shell, shell_bool, shell_output_trimmed,
                  time_now_unix_micros, file_read_text)
use std.string.{NL}

# Bootstrap phase
enum BootstrapPhase:
    Phase0    # Prerequisites check
    Phase1    # Core1: seed_cpp → C++ → clang → native
    Phase2    # Core2: Core1 recompiles compiler_core
    Phase3    # Full1: Core2 compiles full compiler
    Phase4    # Full2: Full1 recompiles itself (reproducibility)

# Compilation backend
enum CompilationBackend:
    SeedCpp     # seed_cpp → C++ → clang++ (bootstrap)
    Native      # Self-hosted compiler → C → clang (later phases)
    Interpreter # Fallback: interpreter verification

# Multi-phase bootstrap configuration
struct MultiphaseConfig:
    profile: BuildProfile
    verify_reproducibility: bool    # Core1==Core2 and Full1==Full2 check
    keep_artifacts: bool            # Keep intermediate binaries
    workspace_root: text
    output_dir: text
    seed_cpp_path: text             # Path to seed_cpp binary
    clang_path: text                # Path to clang++
    runtime_lib: text               # Path to libspl_runtime.a
    crt_lib: text                   # Path to libspl_crt_linux_x86_64.a
    compiler_core_dir: text         # Path to src/compiler_core/
    seed_include_dir: text          # Path to seed/ (for runtime.h)

# Phase result
struct PhaseResult:
    phase: BootstrapPhase
    success: bool
    binary_path: text
    binary_size: i64
    compile_duration_ms: i64
    hash: text
    backend: CompilationBackend

impl PhaseResult:
    fn summary() -> text:
        val status = if self.success: "OK" else: "FAIL"
        val backend_name = backend_to_string(self.backend)
        "{status} Phase {phase_name(self.phase)}: {self.binary_size} bytes, {self.compile_duration_ms}ms ({backend_name})"

# Multi-phase bootstrap result
struct MultiphaseResult:
    phase0: PhaseResult
    phase1: PhaseResult
    phase2: PhaseResult
    phase3: PhaseResult
    phase4: PhaseResult
    verified: bool
    overall_success: bool

impl MultiphaseResult:
    fn summary() -> text:
        var lines = [
            self.phase0.summary(),
            self.phase1.summary(),
            self.phase2.summary(),
            self.phase3.summary()
        ]

        if self.phase4.success:
            lines = lines + [self.phase4.summary()]

        if self.verified:
            lines = lines + ["OK Verification: reproducible builds confirmed"]
        else:
            lines = lines + ["FAIL Verification: builds not reproducible"]

        lines.join(NL)

# ============================================================================
# File Discovery and Ordering
# ============================================================================

# Discover all .spl files in a directory recursively
fn discover_spl_files(dir: text) -> [text]:
    val all_files = dir_walk(dir)
    var spl_files: [text] = []
    for f in all_files:
        if f.ends_with(".spl"):
            spl_files.push(f)
    spl_files

# Extract module names from use statements in a source file
fn extract_deps_from_file(file_path: text) -> [text]:
    val source = file_read_text(file_path)
    if source == nil:
        return []
    var deps: [text] = []
    val lines = source.split(NL)
    for line in lines:
        val trimmed = line.trim()
        if trimmed.starts_with("use "):
            val rest = trimmed.substring(4).trim()
            # Extract the module path (before any parentheses or braces)
            var mod_path = rest
            val paren_idx = rest.index_of("(") ?? -1
            if paren_idx >= 0:
                mod_path = rest.substring(0, paren_idx).trim()
            val brace_idx = rest.index_of("{") ?? -1
            if brace_idx >= 0:
                val candidate = rest.substring(0, brace_idx).trim()
                if candidate.len() < mod_path.len():
                    mod_path = candidate
            if mod_path.ends_with("."):
                mod_path = mod_path.substring(0, mod_path.len() - 1)
            if mod_path.ends_with("*"):
                continue
            if mod_path.len() > 0:
                deps.push(mod_path)
    deps

# Convert a module path like "compiler_core.lexer_desugared" to a file path
fn module_to_file(mod_path: text, base_dir: text) -> text:
    # Try direct mapping: dots → slashes
    val rel = mod_path.replace(".", "/")
    val candidate = "{base_dir}/{rel}.spl"
    if file_exists(candidate):
        return candidate
    # Try as directory with __init__.spl
    val init_candidate = "{base_dir}/{rel}/__init__.spl"
    if file_exists(init_candidate):
        return init_candidate
    ""

# Build dependency-ordered file list for seed_cpp compilation
# Strategy: BFS from files with no internal deps, main.spl always last
fn build_ordered_file_list(base_dir: text) -> [text]:
    val all_files = discover_spl_files(base_dir)
    var main_file = ""
    var init_file = ""
    var other_files: [text] = []

    for f in all_files:
        if f.ends_with("/main.spl"):
            main_file = f
        elif f.ends_with("/__init__.spl"):
            init_file = f
        else:
            other_files.push(f)

    # Simple ordering: __init__.spl first (if exists), then other files sorted,
    # then main.spl last. seed_cpp does two-pass (signatures then bodies),
    # so circular deps within compilation are handled by C++ compilation model.
    var ordered: [text] = []

    if init_file != "":
        ordered.push(init_file)

    # Sort other files for deterministic builds
    var sorted = other_files.sort()
    for f in sorted:
        ordered.push(f)

    if main_file != "":
        ordered.push(main_file)

    ordered

# ============================================================================
# Multi-phase bootstrap orchestrator
# ============================================================================

class MultiphaseBootstrap:
    # Run complete multi-phase bootstrap
    static fn run(config: MultiphaseConfig) -> MultiphaseResult:
        print "================================================================"
        print "    Multi-Phase Bootstrap Pipeline (Seed Compiler Path)"
        print "================================================================"
        print ""
        print "Strategy: seed_cpp -> C++ -> clang++ -> native binary"
        print "Chain:    Core1 -> Core2 -> Full1 -> Full2 (reproducibility)"
        print ""

        dir_create(config.output_dir, true)

        # Phase 0: Prerequisites
        print "Phase 0: Prerequisites Check"
        print "----------------------------------------------------------------"
        val phase0_result = run_phase0(config)
        print phase0_result.summary()
        print ""

        if not phase0_result.success:
            return early_exit(phase0_result)

        # Phase 1: Core1 — seed_cpp transpiles compiler_core
        print "Phase 1: Core1 (seed_cpp -> C++ -> clang++ -> native)"
        print "----------------------------------------------------------------"
        val phase1_result = run_phase1_seed(config)
        print phase1_result.summary()
        print ""

        if not phase1_result.success:
            print "  Phase 1 failed. Attempting interpreter fallback..."
            val fallback = run_interpreter_fallback(config)
            return early_exit_after_phase1(phase0_result, fallback)

        # Phase 2: Core2 — Core1 recompiles compiler_core
        print "Phase 2: Core2 (Core1 compiles compiler_core)"
        print "----------------------------------------------------------------"
        val phase2_result = run_phase2_core(config, phase1_result)
        print phase2_result.summary()
        print ""

        if not phase2_result.success:
            return early_exit_after_phase2(phase0_result, phase1_result, phase2_result)

        # Verify Core1 == Core2 (reproducibility)
        var core_verified = true
        if config.verify_reproducibility:
            print "Verification: Comparing Core1 and Core2"
            print "----------------------------------------------------------------"
            core_verified = verify_phases(phase1_result, phase2_result)
            if core_verified:
                print "  OK Core reproducibility verified"
            else:
                print "  WARN Core hashes differ (expected for different compilation paths)"
            print ""

        # Phase 3: Full1 — Core2 compiles the full compiler
        print "Phase 3: Full1 (Core2 compiles full compiler)"
        print "----------------------------------------------------------------"
        val phase3_result = run_phase3_full(config, phase2_result)
        print phase3_result.summary()
        print ""

        if not phase3_result.success:
            return early_exit_after_phase3(phase0_result, phase1_result, phase2_result, phase3_result)

        # Phase 4: Full2 — Full1 recompiles itself
        var phase4_result = empty_phase_result(BootstrapPhase.Phase4, CompilationBackend.Native)
        var full_verified = true
        print "Phase 4: Full2 (Full1 recompiles itself)"
        print "----------------------------------------------------------------"
        phase4_result = run_phase4_full(config, phase3_result)
        print phase4_result.summary()
        print ""

        if phase4_result.success and config.verify_reproducibility:
            print "Verification: Comparing Full1 and Full2"
            print "----------------------------------------------------------------"
            full_verified = verify_phases(phase3_result, phase4_result)
            if full_verified:
                print "  OK Full compiler reproducibility verified"
            else:
                print "  FAIL Full compiler hashes differ"
            print ""

        # Final summary
        print "================================================================"
        print "                    Bootstrap Complete"
        print "================================================================"
        print ""

        val final_binary = if phase4_result.success: phase4_result else: phase3_result
        print "Final binary:"
        print "  Path:    {final_binary.binary_path}"
        print "  Size:    {final_binary.binary_size} bytes"
        print "  Hash:    {final_binary.hash}"
        print "  Backend: {backend_to_string(final_binary.backend)}"
        print ""

        val p01 = phase0_result.success and phase1_result.success
        val p012 = p01 and phase2_result.success
        val p0123 = p012 and phase3_result.success
        val verified = if config.verify_reproducibility: full_verified else: true
        val overall_success = p0123 and verified

        MultiphaseResult(
            phase0: phase0_result,
            phase1: phase1_result,
            phase2: phase2_result,
            phase3: phase3_result,
            phase4: phase4_result,
            verified: verified,
            overall_success: overall_success
        )

# ============================================================================
# Phase Implementations
# ============================================================================

# Phase 0: Verify all prerequisites exist
fn run_phase0(config: MultiphaseConfig) -> PhaseResult:
    val start_time = current_time_ms()
    var all_ok = true

    # Check bin/release/simple (runtime interpreter)
    if file_exists("bin/release/simple"):
        val size = file_size_raw("bin/release/simple")
        print "  OK bin/release/simple ({size} bytes)"
    else:
        print "  FAIL bin/release/simple not found"
        all_ok = false

    # Check seed_cpp
    if file_exists(config.seed_cpp_path):
        val size = file_size_raw(config.seed_cpp_path)
        print "  OK {config.seed_cpp_path} ({size} bytes)"
    else:
        print "  FAIL {config.seed_cpp_path} not found"
        print "    Build it: cd seed/build && cmake .. && cmake --build . --parallel"
        all_ok = false

    # Check clang++
    val clang_check = shell("which {config.clang_path} 2>/dev/null")
    if clang_check.exit_code == 0:
        val version_result = shell("{config.clang_path} --version 2>/dev/null | head -1")
        val version_line = version_result.stdout.trim()
        print "  OK {config.clang_path} found ({version_line})"
    else:
        print "  FAIL {config.clang_path} not found"
        all_ok = false

    # Check runtime library
    if file_exists(config.runtime_lib):
        val size = file_size_raw(config.runtime_lib)
        print "  OK {config.runtime_lib} ({size} bytes)"
    else:
        print "  FAIL {config.runtime_lib} not found"
        all_ok = false

    # Check CRT startup library
    if file_exists(config.crt_lib):
        val size = file_size_raw(config.crt_lib)
        print "  OK {config.crt_lib} ({size} bytes)"
    else:
        print "  FAIL {config.crt_lib} not found"
        all_ok = false

    # Check compiler_core directory
    val core_files = discover_spl_files(config.compiler_core_dir)
    if core_files.len() > 0:
        print "  OK {config.compiler_core_dir} ({core_files.len()} .spl files)"
    else:
        print "  FAIL {config.compiler_core_dir} has no .spl files"
        all_ok = false

    # Check seed include dir (for runtime.h)
    if file_exists("{config.seed_include_dir}/runtime.h"):
        print "  OK {config.seed_include_dir}/runtime.h found"
    else:
        print "  WARN {config.seed_include_dir}/runtime.h not found (may not be needed)"

    if not all_ok:
        return PhaseResult(
            phase: BootstrapPhase.Phase0,
            success: false,
            binary_path: "",
            binary_size: 0,
            compile_duration_ms: current_time_ms() - start_time,
            hash: "",
            backend: CompilationBackend.SeedCpp
        )

    PhaseResult(
        phase: BootstrapPhase.Phase0,
        success: true,
        binary_path: "bin/release/simple",
        binary_size: file_size_raw("bin/release/simple"),
        compile_duration_ms: current_time_ms() - start_time,
        hash: file_hash_sha256("bin/release/simple"),
        backend: CompilationBackend.Interpreter
    )

# Phase 1: seed_cpp transpiles compiler_core → C++ → clang++ → native binary
fn run_phase1_seed(config: MultiphaseConfig) -> PhaseResult:
    val start_time = current_time_ms()
    val core1_cpp = "{config.output_dir}/core1.cpp"
    val core1_bin = "{config.output_dir}/core1"

    # Step 1: Build ordered file list
    print "  Discovering compiler_core files..."
    val ordered_files = build_ordered_file_list(config.compiler_core_dir)
    print "  Found {ordered_files.len()} files"

    # Step 2: Run seed_cpp to transpile to C++
    var file_args = ""
    for f in ordered_files:
        file_args = file_args + " " + f
    val seed_cmd = "{config.seed_cpp_path}{file_args} > {core1_cpp}"
    print "  Running seed_cpp..."
    val seed_result = shell(seed_cmd)

    if seed_result.exit_code != 0:
        print "  FAIL seed_cpp transpilation failed"
        if seed_result.stderr != "":
            print "  stderr: {seed_result.stderr}"
        return fail_phase(BootstrapPhase.Phase1, CompilationBackend.SeedCpp, start_time)

    if not file_exists(core1_cpp):
        print "  FAIL {core1_cpp} not created"
        return fail_phase(BootstrapPhase.Phase1, CompilationBackend.SeedCpp, start_time)

    val cpp_size = file_size_raw(core1_cpp)
    print "  Generated C++ ({cpp_size} bytes)"

    if cpp_size < 1000:
        print "  FAIL C++ output too small ({cpp_size} bytes) — likely empty/stub"
        return fail_phase(BootstrapPhase.Phase1, CompilationBackend.SeedCpp, start_time)

    # Step 3: Compile C++ with clang++
    val compile_cmd = "{config.clang_path} -std=c++20 -O2 -o {core1_bin} {core1_cpp} -I{config.seed_include_dir} -L{config.seed_include_dir}/build -lspl_runtime -lm -lpthread"
    print "  Compiling C++ with clang++..."
    val compile_result = shell(compile_cmd)

    if compile_result.exit_code != 0:
        print "  FAIL clang++ compilation failed"
        if compile_result.stderr != "":
            # Print first few lines of error
            val err_lines = compile_result.stderr.split(NL)
            var shown = 0
            for err_line in err_lines:
                if shown < 20:
                    print "    {err_line}"
                    shown = shown + 1
            if err_lines.len() > 20:
                print "    ... ({err_lines.len() - 20} more lines)"
        return fail_phase(BootstrapPhase.Phase1, CompilationBackend.SeedCpp, start_time)

    # Step 4: Link with startup CRT if available
    # The CRT provides _start for freestanding binaries; skip if not needed
    # (clang++ already provides standard C++ startup)

    # Step 5: Verify binary
    shell("chmod +x {core1_bin}")

    if not file_exists(core1_bin):
        print "  FAIL {core1_bin} not created"
        return fail_phase(BootstrapPhase.Phase1, CompilationBackend.SeedCpp, start_time)

    val bin_size = file_size_raw(core1_bin)
    print "  Core1 binary: {bin_size} bytes"

    if bin_size < 10000:
        print "  WARN Binary unusually small ({bin_size} bytes)"

    # Step 6: Smoke test
    val smoke_result = shell("{core1_bin} --version 2>/dev/null")
    if smoke_result.exit_code == 0:
        print "  Smoke test: {smoke_result.stdout.trim()}"
    else:
        print "  WARN Smoke test failed (--version not supported, may be OK)"

    val hash = file_hash_sha256(core1_bin)

    PhaseResult(
        phase: BootstrapPhase.Phase1,
        success: true,
        binary_path: core1_bin,
        binary_size: bin_size,
        compile_duration_ms: current_time_ms() - start_time,
        hash: hash,
        backend: CompilationBackend.SeedCpp
    )

# Phase 2: Core1 recompiles compiler_core (reproducibility)
fn run_phase2_core(config: MultiphaseConfig, phase1: PhaseResult) -> PhaseResult:
    val start_time = current_time_ms()
    val core2_bin = "{config.output_dir}/core2"

    # Use Core1 to compile compiler_core
    val ordered_files = build_ordered_file_list(config.compiler_core_dir)
    var file_args = ""
    for f in ordered_files:
        file_args = file_args + " " + f

    val compile_cmd = "{phase1.binary_path} compile{file_args} -o {core2_bin}"
    print "  Running Core1 to compile compiler_core..."
    val compile_result = shell(compile_cmd)

    if compile_result.exit_code != 0:
        print "  FAIL Core1 compilation failed"
        if compile_result.stderr != "":
            val err_lines = compile_result.stderr.split(NL)
            var shown = 0
            for err_line in err_lines:
                if shown < 10:
                    print "    {err_line}"
                    shown = shown + 1
        return fail_phase(BootstrapPhase.Phase2, CompilationBackend.Native, start_time)

    shell("chmod +x {core2_bin}")

    if not file_exists(core2_bin):
        print "  FAIL {core2_bin} not created"
        return fail_phase(BootstrapPhase.Phase2, CompilationBackend.Native, start_time)

    val bin_size = file_size_raw(core2_bin)
    val hash = file_hash_sha256(core2_bin)
    print "  Core2 binary: {bin_size} bytes"

    PhaseResult(
        phase: BootstrapPhase.Phase2,
        success: true,
        binary_path: core2_bin,
        binary_size: bin_size,
        compile_duration_ms: current_time_ms() - start_time,
        hash: hash,
        backend: CompilationBackend.Native
    )

# Phase 3: Core2 compiles the full compiler
fn run_phase3_full(config: MultiphaseConfig, phase2: PhaseResult) -> PhaseResult:
    val start_time = current_time_ms()
    val full1_bin = "{config.output_dir}/full1"

    val compile_cmd = "{phase2.binary_path} compile src/app/cli/main.spl -o {full1_bin}"
    print "  Running Core2 to compile full compiler..."
    val compile_result = shell(compile_cmd)

    if compile_result.exit_code != 0:
        print "  FAIL Core2 compilation of full compiler failed"
        if compile_result.stderr != "":
            val err_lines = compile_result.stderr.split(NL)
            var shown = 0
            for err_line in err_lines:
                if shown < 10:
                    print "    {err_line}"
                    shown = shown + 1
        return fail_phase(BootstrapPhase.Phase3, CompilationBackend.Native, start_time)

    shell("chmod +x {full1_bin}")

    if not file_exists(full1_bin):
        print "  FAIL {full1_bin} not created"
        return fail_phase(BootstrapPhase.Phase3, CompilationBackend.Native, start_time)

    val bin_size = file_size_raw(full1_bin)
    val hash = file_hash_sha256(full1_bin)
    print "  Full1 binary: {bin_size} bytes"

    # Smoke test
    val smoke_result = shell("{full1_bin} --version 2>/dev/null")
    if smoke_result.exit_code == 0:
        print "  Smoke test: {smoke_result.stdout.trim()}"

    PhaseResult(
        phase: BootstrapPhase.Phase3,
        success: true,
        binary_path: full1_bin,
        binary_size: bin_size,
        compile_duration_ms: current_time_ms() - start_time,
        hash: hash,
        backend: CompilationBackend.Native
    )

# Phase 4: Full1 recompiles itself (reproducibility)
fn run_phase4_full(config: MultiphaseConfig, phase3: PhaseResult) -> PhaseResult:
    val start_time = current_time_ms()
    val full2_bin = "{config.output_dir}/full2"

    val compile_cmd = "{phase3.binary_path} compile src/app/cli/main.spl -o {full2_bin}"
    print "  Running Full1 to recompile itself..."
    val compile_result = shell(compile_cmd)

    if compile_result.exit_code != 0:
        print "  FAIL Full1 self-recompilation failed"
        if compile_result.stderr != "":
            val err_lines = compile_result.stderr.split(NL)
            var shown = 0
            for err_line in err_lines:
                if shown < 10:
                    print "    {err_line}"
                    shown = shown + 1
        return fail_phase(BootstrapPhase.Phase4, CompilationBackend.Native, start_time)

    shell("chmod +x {full2_bin}")

    if not file_exists(full2_bin):
        print "  FAIL {full2_bin} not created"
        return fail_phase(BootstrapPhase.Phase4, CompilationBackend.Native, start_time)

    val bin_size = file_size_raw(full2_bin)
    val hash = file_hash_sha256(full2_bin)
    print "  Full2 binary: {bin_size} bytes"

    PhaseResult(
        phase: BootstrapPhase.Phase4,
        success: true,
        binary_path: full2_bin,
        binary_size: bin_size,
        compile_duration_ms: current_time_ms() - start_time,
        hash: hash,
        backend: CompilationBackend.Native
    )

# ============================================================================
# Interpreter Fallback
# ============================================================================

# If the seed_cpp path fails, verify the compiler works through the interpreter
fn run_interpreter_fallback(config: MultiphaseConfig) -> PhaseResult:
    val start_time = current_time_ms()
    print "  Running interpreter verification..."

    # Run a small subset of tests to verify the interpreter works
    val test_result = shell("bin/release/simple test --only-fast 2>&1 | tail -5")
    if test_result.exit_code == 0:
        print "  OK Interpreter tests passed"
        print "  {test_result.stdout.trim()}"
    else:
        print "  WARN Some interpreter tests may have failed"

    # Hash source files for integrity
    val source_hash = shell("find src/compiler_core/ -name '*.spl' -exec sha256sum {} + | sort | sha256sum | cut -d' ' -f1")
    val hash = source_hash.stdout.trim()
    print "  Source integrity hash: {hash}"

    PhaseResult(
        phase: BootstrapPhase.Phase1,
        success: false,
        binary_path: "",
        binary_size: 0,
        compile_duration_ms: current_time_ms() - start_time,
        hash: hash,
        backend: CompilationBackend.Interpreter
    )

# ============================================================================
# Helpers
# ============================================================================

# Verify that two phase results produce identical binaries
fn verify_phases(phase_a: PhaseResult, phase_b: PhaseResult) -> bool:
    if phase_a.hash != phase_b.hash:
        print "  Hash mismatch:"
        print "    {phase_name(phase_a.phase)}: {phase_a.hash}"
        print "    {phase_name(phase_b.phase)}: {phase_b.hash}"
        return false

    if phase_a.binary_size != phase_b.binary_size:
        print "  Size mismatch:"
        print "    {phase_name(phase_a.phase)}: {phase_a.binary_size} bytes"
        print "    {phase_name(phase_b.phase)}: {phase_b.binary_size} bytes"
        return false

    print "  Hashes match: {phase_a.hash}"
    print "  Sizes match:  {phase_a.binary_size} bytes"
    true

# Empty phase result
fn empty_phase_result(phase: BootstrapPhase, backend: CompilationBackend) -> PhaseResult:
    PhaseResult(
        phase: phase,
        success: false,
        binary_path: "",
        binary_size: 0,
        compile_duration_ms: 0,
        hash: "",
        backend: backend
    )

# Failed phase result
fn fail_phase(phase: BootstrapPhase, backend: CompilationBackend, start_time: i64) -> PhaseResult:
    PhaseResult(
        phase: phase,
        success: false,
        binary_path: "",
        binary_size: 0,
        compile_duration_ms: current_time_ms() - start_time,
        hash: "",
        backend: backend
    )

# Current time in milliseconds
fn current_time_ms() -> i64:
    time_now_unix_micros() / 1000

# Phase name
fn phase_name(phase: BootstrapPhase) -> text:
    match phase:
        case BootstrapPhase.Phase0: "Phase0"
        case BootstrapPhase.Phase1: "Phase1-Core1"
        case BootstrapPhase.Phase2: "Phase2-Core2"
        case BootstrapPhase.Phase3: "Phase3-Full1"
        case BootstrapPhase.Phase4: "Phase4-Full2"

# Backend name
fn backend_to_string(backend: CompilationBackend) -> text:
    match backend:
        case CompilationBackend.SeedCpp: "seed_cpp->C++->clang++"
        case CompilationBackend.Native: "self-hosted->native"
        case CompilationBackend.Interpreter: "interpreter"

# ============================================================================
# Early exit helpers
# ============================================================================

fn early_exit(phase0: PhaseResult) -> MultiphaseResult:
    MultiphaseResult(
        phase0: phase0,
        phase1: empty_phase_result(BootstrapPhase.Phase1, CompilationBackend.SeedCpp),
        phase2: empty_phase_result(BootstrapPhase.Phase2, CompilationBackend.Native),
        phase3: empty_phase_result(BootstrapPhase.Phase3, CompilationBackend.Native),
        phase4: empty_phase_result(BootstrapPhase.Phase4, CompilationBackend.Native),
        verified: false,
        overall_success: false
    )

fn early_exit_after_phase1(phase0: PhaseResult, phase1: PhaseResult) -> MultiphaseResult:
    MultiphaseResult(
        phase0: phase0,
        phase1: phase1,
        phase2: empty_phase_result(BootstrapPhase.Phase2, CompilationBackend.Native),
        phase3: empty_phase_result(BootstrapPhase.Phase3, CompilationBackend.Native),
        phase4: empty_phase_result(BootstrapPhase.Phase4, CompilationBackend.Native),
        verified: false,
        overall_success: false
    )

fn early_exit_after_phase2(phase0: PhaseResult, phase1: PhaseResult, phase2: PhaseResult) -> MultiphaseResult:
    MultiphaseResult(
        phase0: phase0,
        phase1: phase1,
        phase2: phase2,
        phase3: empty_phase_result(BootstrapPhase.Phase3, CompilationBackend.Native),
        phase4: empty_phase_result(BootstrapPhase.Phase4, CompilationBackend.Native),
        verified: false,
        overall_success: false
    )

fn early_exit_after_phase3(phase0: PhaseResult, phase1: PhaseResult, phase2: PhaseResult, phase3: PhaseResult) -> MultiphaseResult:
    MultiphaseResult(
        phase0: phase0,
        phase1: phase1,
        phase2: phase2,
        phase3: phase3,
        phase4: empty_phase_result(BootstrapPhase.Phase4, CompilationBackend.Native),
        verified: false,
        overall_success: false
    )

# ============================================================================
# Default configuration
# ============================================================================

fn default_multiphase_config() -> MultiphaseConfig:
    MultiphaseConfig(
        profile: BuildProfile.Bootstrap,
        verify_reproducibility: true,
        keep_artifacts: true,
        workspace_root: ".",
        output_dir: "build/bootstrap",
        seed_cpp_path: "seed/build/seed_cpp",
        clang_path: "clang++",
        runtime_lib: "seed/build/libspl_runtime.a",
        crt_lib: "seed/build/startup/libspl_crt_linux_x86_64.a",
        compiler_core_dir: "src/compiler_core",
        seed_include_dir: "seed"
    )

# Quick entry point
fn quick_multiphase_bootstrap() -> MultiphaseResult:
    MultiphaseBootstrap.run(default_multiphase_config())

# ============================================================================
# 8-Stage Build Pipeline
# ============================================================================
#
# A cleaner pipeline with 8 distinct named stages:
#
#   check → bootstrap → build → seed → core1 → core2 → full1 → full2
#
# check:     Verify prerequisites (clang, cmake, runtime.h, src/compiler_core/)
# bootstrap: Verify pre-built binary bin/release/simple exists and is valid
# build:     Build seed_cpp from C++ source via cmake + clang
# seed:      Run seed_cpp to transpile compiler_core → core1.cpp
# core1:     Compile core1.cpp → native core1 binary via clang++
# core2:     Core1 recompiles compiler_core (reproducibility check)
# full1:     Core2 compiles full compiler (src/app/cli/main.spl)
# full2:     Full1 recompiles itself (reproducibility, hash should match full1)

# Pipeline stage
enum PipelineStage:
    Check
    Bootstrap
    Build
    Seed
    Core1
    Core2
    Full1
    Full2

# Pipeline configuration
struct PipelineConfig:
    profile: BuildProfile
    verify_reproducibility: bool
    keep_artifacts: bool
    workspace_root: text
    output_dir: text
    seed_dir: text               # Path to seed/ (CMakeLists.txt location)
    seed_build_dir: text         # Path to seed/build/ (cmake output)
    clang_path: text             # clang++ path
    cmake_path: text             # cmake path
    compiler_core_dir: text      # src/compiler_core/
    seed_include_dir: text       # seed/ (for runtime.h)
    to_stage_idx: i64            # Stop after this stage index (7 = Full2)
    from_stage_idx: i64          # Start from this stage index (0 = Check)

# Stage result
struct StageResult:
    stage_idx: i64
    success: bool
    binary_path: text
    binary_size: i64
    duration_ms: i64
    hash: text
    output_text: text            # Any notable output (version, etc.)

impl StageResult:
    fn summary() -> text:
        val status = if self.success: "OK" else: "FAIL"
        val stage = index_to_stage(self.stage_idx)
        "{status} [{stage_name(stage)}]: {self.binary_size} bytes, {self.duration_ms}ms"

# Pipeline result
struct PipelineResult:
    stages: [StageResult]
    verified_core: bool          # core1 == core2?
    verified_full: bool          # full1 == full2?
    overall_success: bool

impl PipelineResult:
    fn summary() -> text:
        var lines: [text] = []
        for s in self.stages:
            lines.push(s.summary())
        if self.verified_core:
            lines.push("OK Verification: core reproducible builds confirmed")
        if self.verified_full:
            lines.push("OK Verification: full reproducible builds confirmed")
        lines.join(NL)

# ============================================================================
# Pipeline Stage Helpers
# ============================================================================

fn stage_name(stage: PipelineStage) -> text:
    match stage:
        case PipelineStage.Check: "check"
        case PipelineStage.Bootstrap: "bootstrap"
        case PipelineStage.Build: "build"
        case PipelineStage.Seed: "seed"
        case PipelineStage.Core1: "core1"
        case PipelineStage.Core2: "core2"
        case PipelineStage.Full1: "full1"
        case PipelineStage.Full2: "full2"
        case _: "unknown"

fn stage_index(stage: PipelineStage) -> i64:
    match stage:
        case PipelineStage.Check: 0
        case PipelineStage.Bootstrap: 1
        case PipelineStage.Build: 2
        case PipelineStage.Seed: 3
        case PipelineStage.Core1: 4
        case PipelineStage.Core2: 5
        case PipelineStage.Full1: 6
        case PipelineStage.Full2: 7
        case _: -1

fn index_to_stage(idx: i64) -> PipelineStage:
    if idx == 0: return PipelineStage.Check
    if idx == 1: return PipelineStage.Bootstrap
    if idx == 2: return PipelineStage.Build
    if idx == 3: return PipelineStage.Seed
    if idx == 4: return PipelineStage.Core1
    if idx == 5: return PipelineStage.Core2
    if idx == 6: return PipelineStage.Full1
    if idx == 7: return PipelineStage.Full2
    PipelineStage.Check

fn parse_stage(name: text) -> PipelineStage:
    match name:
        case "check": PipelineStage.Check
        case "bootstrap": PipelineStage.Bootstrap
        case "build": PipelineStage.Build
        case "seed": PipelineStage.Seed
        case "core1": PipelineStage.Core1
        case "core2": PipelineStage.Core2
        case "full1": PipelineStage.Full1
        case "full2": PipelineStage.Full2
        case _: PipelineStage.Check

fn stage_in_range(stage: PipelineStage, from_idx: i64, to_idx: i64) -> bool:
    val idx = stage_index(stage)
    idx >= from_idx and idx <= to_idx

fn empty_stage_result(stage: PipelineStage) -> StageResult:
    StageResult(
        stage: stage,
        success: false,
        binary_path: "",
        binary_size: 0,
        duration_ms: 0,
        hash: "",
        output_text: ""
    )

fn fail_stage(stage: PipelineStage, start_time: i64) -> StageResult:
    StageResult(
        stage: stage,
        success: false,
        binary_path: "",
        binary_size: 0,
        duration_ms: current_time_ms() - start_time,
        hash: "",
        output_text: ""
    )

# ============================================================================
# 8 Stage Implementations
# ============================================================================

# Stage: check — verify clang++, cmake, runtime.h exist
fn run_check(config: PipelineConfig) -> StageResult:
    val start_time = current_time_ms()
    var all_ok = true

    # Check clang++
    val clang_check = shell("which {config.clang_path} 2>/dev/null")
    if clang_check.exit_code == 0:
        val version_result = shell("{config.clang_path} --version 2>/dev/null | head -1")
        val version_line = version_result.stdout.trim()
        print "  OK {config.clang_path} found ({version_line})"
    else:
        print "  FAIL {config.clang_path} not found"
        all_ok = false

    # Check cmake
    val cmake_check = shell("which {config.cmake_path} 2>/dev/null")
    if cmake_check.exit_code == 0:
        val version_result = shell("{config.cmake_path} --version 2>/dev/null | head -1")
        val version_line = version_result.stdout.trim()
        print "  OK {config.cmake_path} found ({version_line})"
    else:
        print "  FAIL {config.cmake_path} not found"
        all_ok = false

    # Check ninja
    val ninja_check = shell("ninja --version 2>/dev/null")
    if ninja_check.exit_code == 0:
        val ninja_version = ninja_check.stdout.trim()
        print "  OK ninja found ({ninja_version})"
    else:
        print "  FAIL ninja not found (required as cmake generator)"
        all_ok = false

    # Check runtime.h
    if file_exists("{config.seed_include_dir}/runtime.h"):
        print "  OK {config.seed_include_dir}/runtime.h found"
    else:
        print "  FAIL {config.seed_include_dir}/runtime.h not found"
        all_ok = false

    # Check compiler_core directory
    val core_files = discover_spl_files(config.compiler_core_dir)
    if core_files.len() > 0:
        print "  OK {config.compiler_core_dir} ({core_files.len()} .spl files)"
    else:
        print "  FAIL {config.compiler_core_dir} has no .spl files"
        all_ok = false

    if not all_ok:
        return fail_stage(PipelineStage.Check, start_time)

    StageResult(
        stage_idx: 0,
        success: true,
        binary_path: "",
        binary_size: 0,
        duration_ms: current_time_ms() - start_time,
        hash: "",
        output_text: "Prerequisites verified"
    )

# Stage: bootstrap — verify pre-built binary bin/release/simple exists
fn run_bootstrap(config: PipelineConfig) -> StageResult:
    val start_time = current_time_ms()

    if not file_exists("bin/release/simple"):
        print "  FAIL bin/release/simple not found"
        return fail_stage(PipelineStage.Bootstrap, start_time)

    val size = file_size_raw("bin/release/simple")
    val hash = file_hash_sha256("bin/release/simple")
    print "  OK bin/release/simple ({size} bytes, hash: {hash})"

    StageResult(
        stage_idx: 1,
        success: true,
        binary_path: "bin/release/simple",
        binary_size: size,
        duration_ms: current_time_ms() - start_time,
        hash: hash,
        output_text: ""
    )

# Stage: build — build seed_cpp from C++ source via cmake + clang
fn run_build(config: PipelineConfig) -> StageResult:
    val start_time = current_time_ms()

    # Step 1: cmake configure (use Ninja for fast multi-core builds)
    val cmake_configure = "cmake -G Ninja -S {config.seed_dir} -B {config.seed_build_dir}"
    print "  Configuring: {cmake_configure}"
    val configure_result = shell(cmake_configure)

    if configure_result.exit_code != 0:
        print "  FAIL cmake configure failed"
        if configure_result.stderr != "":
            val err_lines = configure_result.stderr.split(NL)
            var shown = 0
            for err_line in err_lines:
                if shown < 10:
                    print "    {err_line}"
                    shown = shown + 1
        return fail_stage(PipelineStage.Build, start_time)

    # Step 2: cmake build
    val cmake_build = "cmake --build {config.seed_build_dir} --target seed_cpp --parallel"
    print "  Building: {cmake_build}"
    val build_result = shell(cmake_build)

    if build_result.exit_code != 0:
        print "  FAIL cmake build failed"
        if build_result.stderr != "":
            val err_lines = build_result.stderr.split(NL)
            var shown = 0
            for err_line in err_lines:
                if shown < 10:
                    print "    {err_line}"
                    shown = shown + 1
        return fail_stage(PipelineStage.Build, start_time)

    # Verify seed_cpp binary was produced
    val seed_cpp_path = "{config.seed_build_dir}/seed_cpp"
    if not file_exists(seed_cpp_path):
        print "  FAIL {seed_cpp_path} not created"
        return fail_stage(PipelineStage.Build, start_time)

    val size = file_size_raw(seed_cpp_path)
    val hash = file_hash_sha256(seed_cpp_path)
    print "  OK seed_cpp built ({size} bytes)"

    StageResult(
        stage_idx: 2,
        success: true,
        binary_path: seed_cpp_path,
        binary_size: size,
        duration_ms: current_time_ms() - start_time,
        hash: hash,
        output_text: ""
    )

# Stage: seed — run seed_cpp to transpile compiler_core → core1.cpp
fn run_seed(config: PipelineConfig) -> StageResult:
    val start_time = current_time_ms()
    val core1_cpp = "{config.output_dir}/core1.cpp"
    val seed_cpp_path = "{config.seed_build_dir}/seed_cpp"

    # Discover and order .spl files
    print "  Discovering compiler_core files..."
    val ordered_files = build_ordered_file_list(config.compiler_core_dir)
    print "  Found {ordered_files.len()} files"

    # Run seed_cpp to transpile
    var file_args = ""
    for f in ordered_files:
        file_args = file_args + " " + f
    val seed_cmd = "{seed_cpp_path}{file_args} > {core1_cpp}"
    print "  Running seed_cpp..."
    val seed_result = shell(seed_cmd)

    if seed_result.exit_code != 0:
        print "  FAIL seed_cpp transpilation failed"
        if seed_result.stderr != "":
            print "  stderr: {seed_result.stderr}"
        return fail_stage(PipelineStage.Seed, start_time)

    if not file_exists(core1_cpp):
        print "  FAIL {core1_cpp} not created"
        return fail_stage(PipelineStage.Seed, start_time)

    val cpp_size = file_size_raw(core1_cpp)
    print "  Generated C++ ({cpp_size} bytes)"

    if cpp_size < 1000:
        print "  FAIL C++ output too small ({cpp_size} bytes) — likely empty/stub"
        return fail_stage(PipelineStage.Seed, start_time)

    val hash = file_hash_sha256(core1_cpp)

    StageResult(
        stage_idx: 3,
        success: true,
        binary_path: core1_cpp,
        binary_size: cpp_size,
        duration_ms: current_time_ms() - start_time,
        hash: hash,
        output_text: ""
    )

# Stage: core1 — compile core1.cpp → native core1 binary via clang++
fn run_core1(config: PipelineConfig) -> StageResult:
    val start_time = current_time_ms()
    val core1_cpp = "{config.output_dir}/core1.cpp"
    val core1_bin = "{config.output_dir}/core1"

    val compile_cmd = "{config.clang_path} -std=c++20 -O2 -o {core1_bin} {core1_cpp} -I{config.seed_include_dir} -L{config.seed_build_dir} -lspl_runtime -lm -lpthread"
    print "  Compiling C++ with clang++..."
    val compile_result = shell(compile_cmd)

    if compile_result.exit_code != 0:
        print "  FAIL clang++ compilation failed"
        if compile_result.stderr != "":
            val err_lines = compile_result.stderr.split(NL)
            var shown = 0
            for err_line in err_lines:
                if shown < 20:
                    print "    {err_line}"
                    shown = shown + 1
            if err_lines.len() > 20:
                print "    ... ({err_lines.len() - 20} more lines)"
        return fail_stage(PipelineStage.Core1, start_time)

    shell("chmod +x {core1_bin}")

    if not file_exists(core1_bin):
        print "  FAIL {core1_bin} not created"
        return fail_stage(PipelineStage.Core1, start_time)

    val bin_size = file_size_raw(core1_bin)
    print "  Core1 binary: {bin_size} bytes"

    if bin_size < 10000:
        print "  WARN Binary unusually small ({bin_size} bytes)"

    # Smoke test
    val smoke_result = shell("{core1_bin} --version 2>/dev/null")
    var output_text = ""
    if smoke_result.exit_code == 0:
        output_text = smoke_result.stdout.trim()
        print "  Smoke test: {output_text}"
    else:
        print "  WARN Smoke test failed (--version not supported, may be OK)"

    val hash = file_hash_sha256(core1_bin)

    StageResult(
        stage_idx: 4,
        success: true,
        binary_path: core1_bin,
        binary_size: bin_size,
        duration_ms: current_time_ms() - start_time,
        hash: hash,
        output_text: output_text
    )

# Stage: core2 — core1 recompiles compiler_core (reproducibility check)
fn run_core2(config: PipelineConfig, core1_result: StageResult) -> StageResult:
    val start_time = current_time_ms()
    val core2_bin = "{config.output_dir}/core2"

    val ordered_files = build_ordered_file_list(config.compiler_core_dir)
    var file_args = ""
    for f in ordered_files:
        file_args = file_args + " " + f

    val compile_cmd = "{core1_result.binary_path} compile{file_args} -o {core2_bin}"
    print "  Running Core1 to compile compiler_core..."
    val compile_result = shell(compile_cmd)

    if compile_result.exit_code != 0:
        print "  FAIL Core1 compilation failed"
        if compile_result.stderr != "":
            val err_lines = compile_result.stderr.split(NL)
            var shown = 0
            for err_line in err_lines:
                if shown < 10:
                    print "    {err_line}"
                    shown = shown + 1
        return fail_stage(PipelineStage.Core2, start_time)

    shell("chmod +x {core2_bin}")

    if not file_exists(core2_bin):
        print "  FAIL {core2_bin} not created"
        return fail_stage(PipelineStage.Core2, start_time)

    val bin_size = file_size_raw(core2_bin)
    val hash = file_hash_sha256(core2_bin)
    print "  Core2 binary: {bin_size} bytes"

    StageResult(
        stage_idx: 5,
        success: true,
        binary_path: core2_bin,
        binary_size: bin_size,
        duration_ms: current_time_ms() - start_time,
        hash: hash,
        output_text: ""
    )

# Stage: full1 — core2 compiles full compiler
fn run_full1(config: PipelineConfig, core2_result: StageResult) -> StageResult:
    val start_time = current_time_ms()
    val full1_bin = "{config.output_dir}/full1"

    val compile_cmd = "{core2_result.binary_path} compile src/app/cli/main.spl -o {full1_bin}"
    print "  Running Core2 to compile full compiler..."
    val compile_result = shell(compile_cmd)

    if compile_result.exit_code != 0:
        print "  FAIL Core2 compilation of full compiler failed"
        if compile_result.stderr != "":
            val err_lines = compile_result.stderr.split(NL)
            var shown = 0
            for err_line in err_lines:
                if shown < 10:
                    print "    {err_line}"
                    shown = shown + 1
        return fail_stage(PipelineStage.Full1, start_time)

    shell("chmod +x {full1_bin}")

    if not file_exists(full1_bin):
        print "  FAIL {full1_bin} not created"
        return fail_stage(PipelineStage.Full1, start_time)

    val bin_size = file_size_raw(full1_bin)
    val hash = file_hash_sha256(full1_bin)
    print "  Full1 binary: {bin_size} bytes"

    # Smoke test
    var output_text = ""
    val smoke_result = shell("{full1_bin} --version 2>/dev/null")
    if smoke_result.exit_code == 0:
        output_text = smoke_result.stdout.trim()
        print "  Smoke test: {output_text}"

    StageResult(
        stage_idx: 6,
        success: true,
        binary_path: full1_bin,
        binary_size: bin_size,
        duration_ms: current_time_ms() - start_time,
        hash: hash,
        output_text: output_text
    )

# Stage: full2 — full1 recompiles itself (reproducibility check)
fn run_full2(config: PipelineConfig, full1_result: StageResult) -> StageResult:
    val start_time = current_time_ms()
    val full2_bin = "{config.output_dir}/full2"

    val compile_cmd = "{full1_result.binary_path} compile src/app/cli/main.spl -o {full2_bin}"
    print "  Running Full1 to recompile itself..."
    val compile_result = shell(compile_cmd)

    if compile_result.exit_code != 0:
        print "  FAIL Full1 self-recompilation failed"
        if compile_result.stderr != "":
            val err_lines = compile_result.stderr.split(NL)
            var shown = 0
            for err_line in err_lines:
                if shown < 10:
                    print "    {err_line}"
                    shown = shown + 1
        return fail_stage(PipelineStage.Full2, start_time)

    shell("chmod +x {full2_bin}")

    if not file_exists(full2_bin):
        print "  FAIL {full2_bin} not created"
        return fail_stage(PipelineStage.Full2, start_time)

    val bin_size = file_size_raw(full2_bin)
    val hash = file_hash_sha256(full2_bin)
    print "  Full2 binary: {bin_size} bytes"

    StageResult(
        stage_idx: 7,
        success: true,
        binary_path: full2_bin,
        binary_size: bin_size,
        duration_ms: current_time_ms() - start_time,
        hash: hash,
        output_text: ""
    )

# ============================================================================
# Pipeline Stage Verification
# ============================================================================

fn verify_stages(stage_a: StageResult, stage_b: StageResult) -> bool:
    if stage_a.hash != stage_b.hash:
        print "  Hash mismatch:"
        print "    {stage_name(stage_a.stage)}: {stage_a.hash}"
        print "    {stage_name(stage_b.stage)}: {stage_b.hash}"
        return false

    if stage_a.binary_size != stage_b.binary_size:
        print "  Size mismatch:"
        print "    {stage_name(stage_a.stage)}: {stage_a.binary_size} bytes"
        print "    {stage_name(stage_b.stage)}: {stage_b.binary_size} bytes"
        return false

    print "  Hashes match: {stage_a.hash}"
    print "  Sizes match:  {stage_a.binary_size} bytes"
    true

# ============================================================================
# Pipeline Orchestrator
# ============================================================================

class Pipeline:
    static fn run(config: PipelineConfig) -> PipelineResult:
        print "@@@ LOADED FIXED VERSION @@@"
        print "@@@ from_stage_idx: {config.from_stage_idx} @@@"
        print "@@@ to_stage_idx: {config.to_stage_idx} @@@"
        val from_stage = index_to_stage(config.from_stage_idx)
        val to_stage = index_to_stage(config.to_stage_idx)
        print "@@@ from_stage after conversion: {from_stage} @@@"
        print "@@@ to_stage after conversion: {to_stage} @@@"
        print "================================================================"
        print "    8-Stage Build Pipeline"
        print "================================================================"
        print ""
        print "Stages: check -> bootstrap -> build -> seed -> core1 -> core2 -> full1 -> full2"
        print "Range:  {stage_name(from_stage)} -> {stage_name(to_stage)}"
        print ""

        dir_create(config.output_dir, true)

        var stages: [StageResult] = []
        var verified_core = false
        var verified_full = false

        # Track results needed for later stages
        var core1_result = empty_stage_result(PipelineStage.Core1)
        var core2_result = empty_stage_result(PipelineStage.Core2)
        var full1_result = empty_stage_result(PipelineStage.Full1)

        # Stage: check
        if stage_in_range(PipelineStage.Check, config.from_stage_idx, config.to_stage_idx):
            print "[check] Verifying prerequisites"
            print "----------------------------------------------------------------"
            val result = run_check(config)
            print result.summary()
            print ""
            stages.push(result)
            if not result.success:
                return PipelineResult(stages: stages, verified_core: false, verified_full: false, overall_success: false)

        # Stage: bootstrap
        if stage_in_range(PipelineStage.Bootstrap, config.from_stage_idx, config.to_stage_idx):
            print "[bootstrap] Verifying pre-built binary"
            print "----------------------------------------------------------------"
            val result = run_bootstrap(config)
            print result.summary()
            print ""
            stages.push(result)
            if not result.success:
                return PipelineResult(stages: stages, verified_core: false, verified_full: false, overall_success: false)

        # Stage: build
        if stage_in_range(PipelineStage.Build, config.from_stage_idx, config.to_stage_idx):
            print "[build] Building seed_cpp via cmake"
            print "----------------------------------------------------------------"
            val result = run_build(config)
            print result.summary()
            print ""
            stages.push(result)
            if not result.success:
                return PipelineResult(stages: stages, verified_core: false, verified_full: false, overall_success: false)

        # Stage: seed
        if stage_in_range(PipelineStage.Seed, config.from_stage_idx, config.to_stage_idx):
            print "[seed] Transpiling compiler_core to C++"
            print "----------------------------------------------------------------"
            val result = run_seed(config)
            print result.summary()
            print ""
            stages.push(result)
            if not result.success:
                return PipelineResult(stages: stages, verified_core: false, verified_full: false, overall_success: false)

        # Stage: core1
        if stage_in_range(PipelineStage.Core1, config.from_stage_idx, config.to_stage_idx):
            print "[core1] Compiling core1.cpp to native binary"
            print "----------------------------------------------------------------"
            val result = run_core1(config)
            print result.summary()
            print ""
            stages.push(result)
            core1_result = result
            if not result.success:
                return PipelineResult(stages: stages, verified_core: false, verified_full: false, overall_success: false)

        # Stage: core2
        if stage_in_range(PipelineStage.Core2, config.from_stage_idx, config.to_stage_idx):
            print "[core2] Core1 recompiles compiler_core"
            print "----------------------------------------------------------------"
            val result = run_core2(config, core1_result)
            print result.summary()
            print ""
            stages.push(result)
            core2_result = result
            if not result.success:
                return PipelineResult(stages: stages, verified_core: false, verified_full: false, overall_success: false)

            # Verify core reproducibility
            if config.verify_reproducibility and core1_result.success:
                print "Verification: Comparing core1 and core2"
                print "----------------------------------------------------------------"
                verified_core = verify_stages(core1_result, core2_result)
                if verified_core:
                    print "  OK Core reproducibility verified"
                else:
                    print "  WARN Core hashes differ (expected for different compilation paths)"
                print ""

        # Stage: full1
        if stage_in_range(PipelineStage.Full1, config.from_stage_idx, config.to_stage_idx):
            print "[full1] Core2 compiles full compiler"
            print "----------------------------------------------------------------"
            val result = run_full1(config, core2_result)
            print result.summary()
            print ""
            stages.push(result)
            full1_result = result
            if not result.success:
                return PipelineResult(stages: stages, verified_core: verified_core, verified_full: false, overall_success: false)

        # Stage: full2
        if stage_in_range(PipelineStage.Full2, config.from_stage_idx, config.to_stage_idx):
            print "[full2] Full1 recompiles itself"
            print "----------------------------------------------------------------"
            val result = run_full2(config, full1_result)
            print result.summary()
            print ""
            stages.push(result)
            if not result.success:
                return PipelineResult(stages: stages, verified_core: verified_core, verified_full: false, overall_success: false)

            # Verify full reproducibility
            if config.verify_reproducibility and full1_result.success and result.success:
                print "Verification: Comparing full1 and full2"
                print "----------------------------------------------------------------"
                verified_full = verify_stages(full1_result, result)
                if verified_full:
                    print "  OK Full compiler reproducibility verified"
                else:
                    print "  FAIL Full compiler hashes differ"
                print ""

        # Final summary
        print "================================================================"
        print "                    Pipeline Complete"
        print "================================================================"
        print ""

        # Find last successful stage for summary
        var last_binary = ""
        var last_size: i64 = 0
        var last_hash = ""
        var idx = stages.len() - 1
        while idx >= 0:
            val s = stages[idx]
            if s.success and s.binary_path != "":
                last_binary = s.binary_path
                last_size = s.binary_size
                last_hash = s.hash
                idx = -1  # break
            else:
                idx = idx - 1

        if last_binary != "":
            print "Final artifact:"
            print "  Path: {last_binary}"
            print "  Size: {last_size} bytes"
            print "  Hash: {last_hash}"
            print ""

        PipelineResult(
            stages: stages,
            verified_core: verified_core,
            verified_full: verified_full,
            overall_success: true
        )

# ============================================================================
# Pipeline Configuration
# ============================================================================

fn default_pipeline_config() -> PipelineConfig:
    val bootstrap_profile = BuildProfile.Bootstrap
    PipelineConfig(
        profile: bootstrap_profile,
        verify_reproducibility: true,
        keep_artifacts: true,
        workspace_root: ".",
        output_dir: "build/bootstrap",
        seed_dir: "seed",
        seed_build_dir: "seed/build",
        clang_path: "clang++",
        cmake_path: "cmake",
        compiler_core_dir: "src/compiler_core",
        seed_include_dir: "seed",
        to_stage_idx: 7,
        from_stage_idx: 0
    )

fn parse_pipeline_args(args: [text]) -> PipelineConfig:
    var config = default_pipeline_config()
    var i = 0
    while i < args.len():
        val arg = args[i]
        if arg.starts_with("--from="):
            val stage = parse_stage(arg.substring(7))
            config.from_stage_idx = stage_index(stage)
        elif arg.starts_with("--to="):
            val stage = parse_stage(arg.substring(5))
            config.to_stage_idx = stage_index(stage)
        elif arg.starts_with("--output="):
            config.output_dir = arg.substring(9)
        elif arg.starts_with("--clang="):
            config.clang_path = arg.substring(8)
        elif arg.starts_with("--cmake="):
            config.cmake_path = arg.substring(8)
        elif arg == "--no-verify":
            config.verify_reproducibility = false
        elif arg == "--no-artifacts":
            config.keep_artifacts = false
        i = i + 1
    config
