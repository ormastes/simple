# Multi-Phase Bootstrap Pipeline (Seed Compiler Path)
#
# Builds the Simple compiler from source using the seed C++ transpiler,
# producing working native binaries through a 4-phase chain:
#
#   Phase 0: Prerequisites check (seed_cpp, clang++, runtime libs)
#   Phase 1 (Core1): seed_cpp transpiles compiler_core → C++ → clang++ → native
#   Phase 2 (Core2): Core1 recompiles compiler_core (reproducibility check)
#   Phase 3 (Full1): Core2 compiles the full compiler
#   Phase 4 (Full2): Full1 recompiles itself (reproducibility check)
#
# The seed compiler (seed_cpp) is a minimal C++ program that reads Core Simple
# source and emits C++ code, which is then compiled with clang++ and linked
# against the Simple runtime library and startup CRT.
#
# Key insight: seed_cpp handles forward declarations via two-pass compilation
# (collects all struct/fn signatures first, then emits bodies), so file
# ordering only needs to avoid putting main.spl before its dependencies.

use app.build.types (BuildProfile)
use app.io.mod (file_exists, file_size_raw, file_copy, file_delete, dir_create,
                  dir_walk, file_hash_sha256, shell, shell_bool, shell_output_trimmed,
                  time_now_unix_micros, file_read_text)

# Bootstrap phase
enum BootstrapPhase:
    Phase0    # Prerequisites check
    Phase1    # Core1: seed_cpp → C++ → clang → native
    Phase2    # Core2: Core1 recompiles compiler_core
    Phase3    # Full1: Core2 compiles full compiler
    Phase4    # Full2: Full1 recompiles itself (reproducibility)

# Compilation backend
enum CompilationBackend:
    SeedCpp     # seed_cpp → C++ → clang++ (bootstrap)
    Native      # Self-hosted compiler → C → clang (later phases)
    Interpreter # Fallback: interpreter verification

# Multi-phase bootstrap configuration
struct MultiphaseConfig:
    profile: BuildProfile
    verify_reproducibility: bool    # Core1==Core2 and Full1==Full2 check
    keep_artifacts: bool            # Keep intermediate binaries
    workspace_root: text
    output_dir: text
    seed_cpp_path: text             # Path to seed_cpp binary
    clang_path: text                # Path to clang++
    runtime_lib: text               # Path to libspl_runtime.a
    crt_lib: text                   # Path to libspl_crt_linux_x86_64.a
    compiler_core_dir: text         # Path to src/compiler_core/
    seed_include_dir: text          # Path to seed/ (for runtime.h)

# Phase result
struct PhaseResult:
    phase: BootstrapPhase
    success: bool
    binary_path: text
    binary_size: i64
    compile_duration_ms: i64
    hash: text
    backend: CompilationBackend

impl PhaseResult:
    fn summary() -> text:
        val status = if self.success: "OK" else: "FAIL"
        val backend_name = backend_to_string(self.backend)
        "{status} Phase {phase_name(self.phase)}: {self.binary_size} bytes, {self.compile_duration_ms}ms ({backend_name})"

# Multi-phase bootstrap result
struct MultiphaseResult:
    phase0: PhaseResult
    phase1: PhaseResult
    phase2: PhaseResult
    phase3: PhaseResult
    phase4: PhaseResult
    verified: bool
    overall_success: bool

impl MultiphaseResult:
    fn summary() -> text:
        var lines = [
            self.phase0.summary(),
            self.phase1.summary(),
            self.phase2.summary(),
            self.phase3.summary()
        ]

        if self.phase4.success:
            lines = lines + [self.phase4.summary()]

        if self.verified:
            lines = lines + ["OK Verification: reproducible builds confirmed"]
        else:
            lines = lines + ["FAIL Verification: builds not reproducible"]

        lines.join("\n")

# ============================================================================
# File Discovery and Ordering
# ============================================================================

# Discover all .spl files in a directory recursively
fn discover_spl_files(dir: text) -> [text]:
    val all_files = dir_walk(dir)
    var spl_files: [text] = []
    for f in all_files:
        if f.ends_with(".spl"):
            spl_files.push(f)
    spl_files

# Extract module names from use statements in a source file
fn extract_deps_from_file(file_path: text) -> [text]:
    val source = file_read_text(file_path)
    if source == nil:
        return []
    var deps: [text] = []
    val lines = source.split("\n")
    for line in lines:
        val trimmed = line.trim()
        if trimmed.starts_with("use "):
            val rest = trimmed.substring(4).trim()
            # Extract the module path (before any parentheses or braces)
            var mod_path = rest
            val paren_idx = rest.index_of("(") ?? -1
            if paren_idx >= 0:
                mod_path = rest.substring(0, paren_idx).trim()
            val brace_idx = rest.index_of("{") ?? -1
            if brace_idx >= 0:
                val candidate = rest.substring(0, brace_idx).trim()
                if candidate.len() < mod_path.len():
                    mod_path = candidate
            if mod_path.ends_with("."):
                mod_path = mod_path.substring(0, mod_path.len() - 1)
            if mod_path.ends_with("*"):
                continue
            if mod_path.len() > 0:
                deps.push(mod_path)
    deps

# Convert a module path like "compiler_core.lexer_desugared" to a file path
fn module_to_file(mod_path: text, base_dir: text) -> text:
    # Try direct mapping: dots → slashes
    val rel = mod_path.replace(".", "/")
    val candidate = "{base_dir}/{rel}.spl"
    if file_exists(candidate):
        return candidate
    # Try as directory with __init__.spl
    val init_candidate = "{base_dir}/{rel}/__init__.spl"
    if file_exists(init_candidate):
        return init_candidate
    ""

# Build dependency-ordered file list for seed_cpp compilation
# Strategy: BFS from files with no internal deps, main.spl always last
fn build_ordered_file_list(base_dir: text) -> [text]:
    val all_files = discover_spl_files(base_dir)
    var main_file = ""
    var init_file = ""
    var other_files: [text] = []

    for f in all_files:
        if f.ends_with("/main.spl"):
            main_file = f
        elif f.ends_with("/__init__.spl"):
            init_file = f
        else:
            other_files.push(f)

    # Simple ordering: __init__.spl first (if exists), then other files sorted,
    # then main.spl last. seed_cpp does two-pass (signatures then bodies),
    # so circular deps within compilation are handled by C++ compilation model.
    var ordered: [text] = []

    if init_file != "":
        ordered.push(init_file)

    # Sort other files for deterministic builds
    var sorted = other_files.sort()
    for f in sorted:
        ordered.push(f)

    if main_file != "":
        ordered.push(main_file)

    ordered

# ============================================================================
# Multi-phase bootstrap orchestrator
# ============================================================================

class MultiphaseBootstrap:
    # Run complete multi-phase bootstrap
    static fn run(config: MultiphaseConfig) -> MultiphaseResult:
        print "================================================================"
        print "    Multi-Phase Bootstrap Pipeline (Seed Compiler Path)"
        print "================================================================"
        print ""
        print "Strategy: seed_cpp -> C++ -> clang++ -> native binary"
        print "Chain:    Core1 -> Core2 -> Full1 -> Full2 (reproducibility)"
        print ""

        dir_create(config.output_dir, true)

        # Phase 0: Prerequisites
        print "Phase 0: Prerequisites Check"
        print "----------------------------------------------------------------"
        val phase0_result = run_phase0(config)
        print phase0_result.summary()
        print ""

        if not phase0_result.success:
            return early_exit(phase0_result)

        # Phase 1: Core1 — seed_cpp transpiles compiler_core
        print "Phase 1: Core1 (seed_cpp -> C++ -> clang++ -> native)"
        print "----------------------------------------------------------------"
        val phase1_result = run_phase1_seed(config)
        print phase1_result.summary()
        print ""

        if not phase1_result.success:
            print "  Phase 1 failed. Attempting interpreter fallback..."
            val fallback = run_interpreter_fallback(config)
            return early_exit_after_phase1(phase0_result, fallback)

        # Phase 2: Core2 — Core1 recompiles compiler_core
        print "Phase 2: Core2 (Core1 compiles compiler_core)"
        print "----------------------------------------------------------------"
        val phase2_result = run_phase2_core(config, phase1_result)
        print phase2_result.summary()
        print ""

        if not phase2_result.success:
            return early_exit_after_phase2(phase0_result, phase1_result, phase2_result)

        # Verify Core1 == Core2 (reproducibility)
        var core_verified = true
        if config.verify_reproducibility:
            print "Verification: Comparing Core1 and Core2"
            print "----------------------------------------------------------------"
            core_verified = verify_phases(phase1_result, phase2_result)
            if core_verified:
                print "  OK Core reproducibility verified"
            else:
                print "  WARN Core hashes differ (expected for different compilation paths)"
            print ""

        # Phase 3: Full1 — Core2 compiles the full compiler
        print "Phase 3: Full1 (Core2 compiles full compiler)"
        print "----------------------------------------------------------------"
        val phase3_result = run_phase3_full(config, phase2_result)
        print phase3_result.summary()
        print ""

        if not phase3_result.success:
            return early_exit_after_phase3(phase0_result, phase1_result, phase2_result, phase3_result)

        # Phase 4: Full2 — Full1 recompiles itself
        var phase4_result = empty_phase_result(BootstrapPhase.Phase4, CompilationBackend.Native)
        var full_verified = true
        print "Phase 4: Full2 (Full1 recompiles itself)"
        print "----------------------------------------------------------------"
        phase4_result = run_phase4_full(config, phase3_result)
        print phase4_result.summary()
        print ""

        if phase4_result.success and config.verify_reproducibility:
            print "Verification: Comparing Full1 and Full2"
            print "----------------------------------------------------------------"
            full_verified = verify_phases(phase3_result, phase4_result)
            if full_verified:
                print "  OK Full compiler reproducibility verified"
            else:
                print "  FAIL Full compiler hashes differ"
            print ""

        # Final summary
        print "================================================================"
        print "                    Bootstrap Complete"
        print "================================================================"
        print ""

        val final_binary = if phase4_result.success: phase4_result else: phase3_result
        print "Final binary:"
        print "  Path:    {final_binary.binary_path}"
        print "  Size:    {final_binary.binary_size} bytes"
        print "  Hash:    {final_binary.hash}"
        print "  Backend: {backend_to_string(final_binary.backend)}"
        print ""

        val p01 = phase0_result.success and phase1_result.success
        val p012 = p01 and phase2_result.success
        val p0123 = p012 and phase3_result.success
        val verified = if config.verify_reproducibility: full_verified else: true
        val overall_success = p0123 and verified

        MultiphaseResult(
            phase0: phase0_result,
            phase1: phase1_result,
            phase2: phase2_result,
            phase3: phase3_result,
            phase4: phase4_result,
            verified: verified,
            overall_success: overall_success
        )

# ============================================================================
# Phase Implementations
# ============================================================================

# Phase 0: Verify all prerequisites exist
fn run_phase0(config: MultiphaseConfig) -> PhaseResult:
    val start_time = current_time_ms()
    var all_ok = true

    # Check bin/release/simple (runtime interpreter)
    if file_exists("bin/release/simple"):
        val size = file_size_raw("bin/release/simple")
        print "  OK bin/release/simple ({size} bytes)"
    else:
        print "  FAIL bin/release/simple not found"
        all_ok = false

    # Check seed_cpp
    if file_exists(config.seed_cpp_path):
        val size = file_size_raw(config.seed_cpp_path)
        print "  OK {config.seed_cpp_path} ({size} bytes)"
    else:
        print "  FAIL {config.seed_cpp_path} not found"
        print "    Build it: cd seed/build && cmake .. && cmake --build . --parallel"
        all_ok = false

    # Check clang++
    val clang_check = shell("which {config.clang_path} 2>/dev/null")
    if clang_check.exit_code == 0:
        val version_result = shell("{config.clang_path} --version 2>/dev/null | head -1")
        val version_line = version_result.stdout.trim()
        print "  OK {config.clang_path} found ({version_line})"
    else:
        print "  FAIL {config.clang_path} not found"
        all_ok = false

    # Check runtime library
    if file_exists(config.runtime_lib):
        val size = file_size_raw(config.runtime_lib)
        print "  OK {config.runtime_lib} ({size} bytes)"
    else:
        print "  FAIL {config.runtime_lib} not found"
        all_ok = false

    # Check CRT startup library
    if file_exists(config.crt_lib):
        val size = file_size_raw(config.crt_lib)
        print "  OK {config.crt_lib} ({size} bytes)"
    else:
        print "  FAIL {config.crt_lib} not found"
        all_ok = false

    # Check compiler_core directory
    val core_files = discover_spl_files(config.compiler_core_dir)
    if core_files.len() > 0:
        print "  OK {config.compiler_core_dir} ({core_files.len()} .spl files)"
    else:
        print "  FAIL {config.compiler_core_dir} has no .spl files"
        all_ok = false

    # Check seed include dir (for runtime.h)
    if file_exists("{config.seed_include_dir}/runtime.h"):
        print "  OK {config.seed_include_dir}/runtime.h found"
    else:
        print "  WARN {config.seed_include_dir}/runtime.h not found (may not be needed)"

    if not all_ok:
        return PhaseResult(
            phase: BootstrapPhase.Phase0,
            success: false,
            binary_path: "",
            binary_size: 0,
            compile_duration_ms: current_time_ms() - start_time,
            hash: "",
            backend: CompilationBackend.SeedCpp
        )

    PhaseResult(
        phase: BootstrapPhase.Phase0,
        success: true,
        binary_path: "bin/release/simple",
        binary_size: file_size_raw("bin/release/simple"),
        compile_duration_ms: current_time_ms() - start_time,
        hash: file_hash_sha256("bin/release/simple"),
        backend: CompilationBackend.Interpreter
    )

# Phase 1: seed_cpp transpiles compiler_core → C++ → clang++ → native binary
fn run_phase1_seed(config: MultiphaseConfig) -> PhaseResult:
    val start_time = current_time_ms()
    val core1_cpp = "{config.output_dir}/core1.cpp"
    val core1_bin = "{config.output_dir}/core1"

    # Step 1: Build ordered file list
    print "  Discovering compiler_core files..."
    val ordered_files = build_ordered_file_list(config.compiler_core_dir)
    print "  Found {ordered_files.len()} files"

    # Step 2: Run seed_cpp to transpile to C++
    var file_args = ""
    for f in ordered_files:
        file_args = file_args + " " + f
    val seed_cmd = "{config.seed_cpp_path}{file_args} > {core1_cpp}"
    print "  Running seed_cpp..."
    val seed_result = shell(seed_cmd)

    if seed_result.exit_code != 0:
        print "  FAIL seed_cpp transpilation failed"
        if seed_result.stderr != "":
            print "  stderr: {seed_result.stderr}"
        return fail_phase(BootstrapPhase.Phase1, CompilationBackend.SeedCpp, start_time)

    if not file_exists(core1_cpp):
        print "  FAIL {core1_cpp} not created"
        return fail_phase(BootstrapPhase.Phase1, CompilationBackend.SeedCpp, start_time)

    val cpp_size = file_size_raw(core1_cpp)
    print "  Generated C++ ({cpp_size} bytes)"

    if cpp_size < 1000:
        print "  FAIL C++ output too small ({cpp_size} bytes) — likely empty/stub"
        return fail_phase(BootstrapPhase.Phase1, CompilationBackend.SeedCpp, start_time)

    # Step 3: Compile C++ with clang++
    val compile_cmd = "{config.clang_path} -std=c++20 -O2 -o {core1_bin} {core1_cpp} -I{config.seed_include_dir} -L{config.seed_include_dir}/build -lspl_runtime -lm -lpthread"
    print "  Compiling C++ with clang++..."
    val compile_result = shell(compile_cmd)

    if compile_result.exit_code != 0:
        print "  FAIL clang++ compilation failed"
        if compile_result.stderr != "":
            # Print first few lines of error
            val err_lines = compile_result.stderr.split("\n")
            var shown = 0
            for err_line in err_lines:
                if shown < 20:
                    print "    {err_line}"
                    shown = shown + 1
            if err_lines.len() > 20:
                print "    ... ({err_lines.len() - 20} more lines)"
        return fail_phase(BootstrapPhase.Phase1, CompilationBackend.SeedCpp, start_time)

    # Step 4: Link with startup CRT if available
    # The CRT provides _start for freestanding binaries; skip if not needed
    # (clang++ already provides standard C++ startup)

    # Step 5: Verify binary
    shell("chmod +x {core1_bin}")

    if not file_exists(core1_bin):
        print "  FAIL {core1_bin} not created"
        return fail_phase(BootstrapPhase.Phase1, CompilationBackend.SeedCpp, start_time)

    val bin_size = file_size_raw(core1_bin)
    print "  Core1 binary: {bin_size} bytes"

    if bin_size < 10000:
        print "  WARN Binary unusually small ({bin_size} bytes)"

    # Step 6: Smoke test
    val smoke_result = shell("{core1_bin} --version 2>/dev/null")
    if smoke_result.exit_code == 0:
        print "  Smoke test: {smoke_result.stdout.trim()}"
    else:
        print "  WARN Smoke test failed (--version not supported, may be OK)"

    val hash = file_hash_sha256(core1_bin)

    PhaseResult(
        phase: BootstrapPhase.Phase1,
        success: true,
        binary_path: core1_bin,
        binary_size: bin_size,
        compile_duration_ms: current_time_ms() - start_time,
        hash: hash,
        backend: CompilationBackend.SeedCpp
    )

# Phase 2: Core1 recompiles compiler_core (reproducibility)
fn run_phase2_core(config: MultiphaseConfig, phase1: PhaseResult) -> PhaseResult:
    val start_time = current_time_ms()
    val core2_bin = "{config.output_dir}/core2"

    # Use Core1 to compile compiler_core
    val ordered_files = build_ordered_file_list(config.compiler_core_dir)
    var file_args = ""
    for f in ordered_files:
        file_args = file_args + " " + f

    val compile_cmd = "{phase1.binary_path} compile{file_args} -o {core2_bin}"
    print "  Running Core1 to compile compiler_core..."
    val compile_result = shell(compile_cmd)

    if compile_result.exit_code != 0:
        print "  FAIL Core1 compilation failed"
        if compile_result.stderr != "":
            val err_lines = compile_result.stderr.split("\n")
            var shown = 0
            for err_line in err_lines:
                if shown < 10:
                    print "    {err_line}"
                    shown = shown + 1
        return fail_phase(BootstrapPhase.Phase2, CompilationBackend.Native, start_time)

    shell("chmod +x {core2_bin}")

    if not file_exists(core2_bin):
        print "  FAIL {core2_bin} not created"
        return fail_phase(BootstrapPhase.Phase2, CompilationBackend.Native, start_time)

    val bin_size = file_size_raw(core2_bin)
    val hash = file_hash_sha256(core2_bin)
    print "  Core2 binary: {bin_size} bytes"

    PhaseResult(
        phase: BootstrapPhase.Phase2,
        success: true,
        binary_path: core2_bin,
        binary_size: bin_size,
        compile_duration_ms: current_time_ms() - start_time,
        hash: hash,
        backend: CompilationBackend.Native
    )

# Phase 3: Core2 compiles the full compiler
fn run_phase3_full(config: MultiphaseConfig, phase2: PhaseResult) -> PhaseResult:
    val start_time = current_time_ms()
    val full1_bin = "{config.output_dir}/full1"

    val compile_cmd = "{phase2.binary_path} compile src/app/cli/main.spl -o {full1_bin}"
    print "  Running Core2 to compile full compiler..."
    val compile_result = shell(compile_cmd)

    if compile_result.exit_code != 0:
        print "  FAIL Core2 compilation of full compiler failed"
        if compile_result.stderr != "":
            val err_lines = compile_result.stderr.split("\n")
            var shown = 0
            for err_line in err_lines:
                if shown < 10:
                    print "    {err_line}"
                    shown = shown + 1
        return fail_phase(BootstrapPhase.Phase3, CompilationBackend.Native, start_time)

    shell("chmod +x {full1_bin}")

    if not file_exists(full1_bin):
        print "  FAIL {full1_bin} not created"
        return fail_phase(BootstrapPhase.Phase3, CompilationBackend.Native, start_time)

    val bin_size = file_size_raw(full1_bin)
    val hash = file_hash_sha256(full1_bin)
    print "  Full1 binary: {bin_size} bytes"

    # Smoke test
    val smoke_result = shell("{full1_bin} --version 2>/dev/null")
    if smoke_result.exit_code == 0:
        print "  Smoke test: {smoke_result.stdout.trim()}"

    PhaseResult(
        phase: BootstrapPhase.Phase3,
        success: true,
        binary_path: full1_bin,
        binary_size: bin_size,
        compile_duration_ms: current_time_ms() - start_time,
        hash: hash,
        backend: CompilationBackend.Native
    )

# Phase 4: Full1 recompiles itself (reproducibility)
fn run_phase4_full(config: MultiphaseConfig, phase3: PhaseResult) -> PhaseResult:
    val start_time = current_time_ms()
    val full2_bin = "{config.output_dir}/full2"

    val compile_cmd = "{phase3.binary_path} compile src/app/cli/main.spl -o {full2_bin}"
    print "  Running Full1 to recompile itself..."
    val compile_result = shell(compile_cmd)

    if compile_result.exit_code != 0:
        print "  FAIL Full1 self-recompilation failed"
        if compile_result.stderr != "":
            val err_lines = compile_result.stderr.split("\n")
            var shown = 0
            for err_line in err_lines:
                if shown < 10:
                    print "    {err_line}"
                    shown = shown + 1
        return fail_phase(BootstrapPhase.Phase4, CompilationBackend.Native, start_time)

    shell("chmod +x {full2_bin}")

    if not file_exists(full2_bin):
        print "  FAIL {full2_bin} not created"
        return fail_phase(BootstrapPhase.Phase4, CompilationBackend.Native, start_time)

    val bin_size = file_size_raw(full2_bin)
    val hash = file_hash_sha256(full2_bin)
    print "  Full2 binary: {bin_size} bytes"

    PhaseResult(
        phase: BootstrapPhase.Phase4,
        success: true,
        binary_path: full2_bin,
        binary_size: bin_size,
        compile_duration_ms: current_time_ms() - start_time,
        hash: hash,
        backend: CompilationBackend.Native
    )

# ============================================================================
# Interpreter Fallback
# ============================================================================

# If the seed_cpp path fails, verify the compiler works through the interpreter
fn run_interpreter_fallback(config: MultiphaseConfig) -> PhaseResult:
    val start_time = current_time_ms()
    print "  Running interpreter verification..."

    # Run a small subset of tests to verify the interpreter works
    val test_result = shell("bin/release/simple test --only-fast 2>&1 | tail -5")
    if test_result.exit_code == 0:
        print "  OK Interpreter tests passed"
        print "  {test_result.stdout.trim()}"
    else:
        print "  WARN Some interpreter tests may have failed"

    # Hash source files for integrity
    val source_hash = shell("find src/compiler_core/ -name '*.spl' -exec sha256sum {} + | sort | sha256sum | cut -d' ' -f1")
    val hash = source_hash.stdout.trim()
    print "  Source integrity hash: {hash}"

    PhaseResult(
        phase: BootstrapPhase.Phase1,
        success: false,
        binary_path: "",
        binary_size: 0,
        compile_duration_ms: current_time_ms() - start_time,
        hash: hash,
        backend: CompilationBackend.Interpreter
    )

# ============================================================================
# Helpers
# ============================================================================

# Verify that two phase results produce identical binaries
fn verify_phases(phase_a: PhaseResult, phase_b: PhaseResult) -> bool:
    if phase_a.hash != phase_b.hash:
        print "  Hash mismatch:"
        print "    {phase_name(phase_a.phase)}: {phase_a.hash}"
        print "    {phase_name(phase_b.phase)}: {phase_b.hash}"
        return false

    if phase_a.binary_size != phase_b.binary_size:
        print "  Size mismatch:"
        print "    {phase_name(phase_a.phase)}: {phase_a.binary_size} bytes"
        print "    {phase_name(phase_b.phase)}: {phase_b.binary_size} bytes"
        return false

    print "  Hashes match: {phase_a.hash}"
    print "  Sizes match:  {phase_a.binary_size} bytes"
    true

# Empty phase result
fn empty_phase_result(phase: BootstrapPhase, backend: CompilationBackend) -> PhaseResult:
    PhaseResult(
        phase: phase,
        success: false,
        binary_path: "",
        binary_size: 0,
        compile_duration_ms: 0,
        hash: "",
        backend: backend
    )

# Failed phase result
fn fail_phase(phase: BootstrapPhase, backend: CompilationBackend, start_time: i64) -> PhaseResult:
    PhaseResult(
        phase: phase,
        success: false,
        binary_path: "",
        binary_size: 0,
        compile_duration_ms: current_time_ms() - start_time,
        hash: "",
        backend: backend
    )

# Current time in milliseconds
fn current_time_ms() -> i64:
    time_now_unix_micros() / 1000

# Phase name
fn phase_name(phase: BootstrapPhase) -> text:
    match phase:
        case BootstrapPhase.Phase0: "Phase0"
        case BootstrapPhase.Phase1: "Phase1-Core1"
        case BootstrapPhase.Phase2: "Phase2-Core2"
        case BootstrapPhase.Phase3: "Phase3-Full1"
        case BootstrapPhase.Phase4: "Phase4-Full2"

# Backend name
fn backend_to_string(backend: CompilationBackend) -> text:
    match backend:
        case CompilationBackend.SeedCpp: "seed_cpp->C++->clang++"
        case CompilationBackend.Native: "self-hosted->native"
        case CompilationBackend.Interpreter: "interpreter"

# ============================================================================
# Early exit helpers
# ============================================================================

fn early_exit(phase0: PhaseResult) -> MultiphaseResult:
    MultiphaseResult(
        phase0: phase0,
        phase1: empty_phase_result(BootstrapPhase.Phase1, CompilationBackend.SeedCpp),
        phase2: empty_phase_result(BootstrapPhase.Phase2, CompilationBackend.Native),
        phase3: empty_phase_result(BootstrapPhase.Phase3, CompilationBackend.Native),
        phase4: empty_phase_result(BootstrapPhase.Phase4, CompilationBackend.Native),
        verified: false,
        overall_success: false
    )

fn early_exit_after_phase1(phase0: PhaseResult, phase1: PhaseResult) -> MultiphaseResult:
    MultiphaseResult(
        phase0: phase0,
        phase1: phase1,
        phase2: empty_phase_result(BootstrapPhase.Phase2, CompilationBackend.Native),
        phase3: empty_phase_result(BootstrapPhase.Phase3, CompilationBackend.Native),
        phase4: empty_phase_result(BootstrapPhase.Phase4, CompilationBackend.Native),
        verified: false,
        overall_success: false
    )

fn early_exit_after_phase2(phase0: PhaseResult, phase1: PhaseResult, phase2: PhaseResult) -> MultiphaseResult:
    MultiphaseResult(
        phase0: phase0,
        phase1: phase1,
        phase2: phase2,
        phase3: empty_phase_result(BootstrapPhase.Phase3, CompilationBackend.Native),
        phase4: empty_phase_result(BootstrapPhase.Phase4, CompilationBackend.Native),
        verified: false,
        overall_success: false
    )

fn early_exit_after_phase3(phase0: PhaseResult, phase1: PhaseResult, phase2: PhaseResult, phase3: PhaseResult) -> MultiphaseResult:
    MultiphaseResult(
        phase0: phase0,
        phase1: phase1,
        phase2: phase2,
        phase3: phase3,
        phase4: empty_phase_result(BootstrapPhase.Phase4, CompilationBackend.Native),
        verified: false,
        overall_success: false
    )

# ============================================================================
# Default configuration
# ============================================================================

fn default_multiphase_config() -> MultiphaseConfig:
    MultiphaseConfig(
        profile: BuildProfile.Bootstrap,
        verify_reproducibility: true,
        keep_artifacts: true,
        workspace_root: ".",
        output_dir: "build/bootstrap",
        seed_cpp_path: "seed/build/seed_cpp",
        clang_path: "clang++",
        runtime_lib: "seed/build/libspl_runtime.a",
        crt_lib: "seed/build/startup/libspl_crt_linux_x86_64.a",
        compiler_core_dir: "src/compiler_core",
        seed_include_dir: "seed"
    )

# Quick entry point
fn quick_multiphase_bootstrap() -> MultiphaseResult:
    MultiphaseBootstrap.run(default_multiphase_config())
