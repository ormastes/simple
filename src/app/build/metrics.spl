# Build Metrics - OPTIMIZED VERSION
#
# Tracks build performance and provides detailed timing analysis
# This version includes performance optimizations from the perf analyzer

use app.build.types (BuildResult, TestResult)

# Build metrics
struct BuildMetrics:
    total_duration_ms: i64
    compile_duration_ms: i64
    link_duration_ms: i64
    test_duration_ms: i64
    artifact_size_bytes: i64
    cache_hit_count: i64
    cache_miss_count: i64
    parallel_jobs: i64

impl BuildMetrics:
    fn summary() -> text:
        # OPTIMIZATION: Reduce repeated divisions by caching
        val ms_to_sec = 1000
        val total_sec = self.total_duration_ms / ms_to_sec
        val compile_sec = self.compile_duration_ms / ms_to_sec
        val link_sec = self.link_duration_ms / ms_to_sec

        val cache_total = self.cache_hit_count + self.cache_miss_count
        val cache_rate_text = if cache_total > 0:
            val cache_rate = (self.cache_hit_count * 100) / cache_total
            "{cache_rate}%"
        else:
            "N/A"

        "Build: {total_sec}s (compile: {compile_sec}s, link: {link_sec}s), cache: {cache_rate_text}"

# Metric collection result
struct MetricsResult:
    success: bool
    metrics: BuildMetrics
    timestamp: i64
    profile: text

impl MetricsResult:
    fn report() -> text:
        val time_str = format_timestamp(self.timestamp)
        "Metrics at {time_str}:\n{self.metrics.summary()}"

# Metrics history entry
struct MetricsEntry:
    timestamp: i64
    profile: text
    total_duration_ms: i64
    success: bool

# Metrics tracker
class MetricsTracker:
    # Record build metrics
    static fn record(result: BuildResult, profile: text) -> MetricsResult:
        # OPTIMIZATION: Get current time once
        val now = current_time_ms()

        val metrics = BuildMetrics(
            total_duration_ms: result.duration_ms,
            compile_duration_ms: result.duration_ms,  # TODO: Parse from output
            link_duration_ms: 0,  # TODO: Parse from output
            test_duration_ms: 0,
            artifact_size_bytes: 0,  # TODO: Get from file system
            cache_hit_count: 0,  # TODO: Parse from cargo output
            cache_miss_count: 0,
            parallel_jobs: 4  # TODO: Get from config
        )

        MetricsResult(
            success: result.success,
            metrics: metrics,
            timestamp: now,
            profile: profile
        )

    # Record test metrics
    static fn record_test(result: TestResult) -> MetricsResult:
        # OPTIMIZATION: Get current time once
        val now = current_time_ms()

        val metrics = BuildMetrics(
            total_duration_ms: 0,  # Test result doesn't track duration yet
            compile_duration_ms: 0,
            link_duration_ms: 0,
            test_duration_ms: 0,
            artifact_size_bytes: 0,
            cache_hit_count: 0,
            cache_miss_count: 0,
            parallel_jobs: 4
        )

        MetricsResult(
            success: result.success,
            metrics: metrics,
            timestamp: now,
            profile: "test"
        )

    # Get recent metrics history
    static fn get_history(limit: i64) -> [MetricsEntry]:
        # TODO: Load from metrics database
        # For now, return empty list
        []

    # Analyze trends - OPTIMIZED VERSION
    static fn analyze_trends(history: [MetricsEntry]) -> text:
        # OPTIMIZATION: Cache array length to avoid repeated calls
        val history_len = history.len()

        if history_len == 0:
            return "No metrics history available"

        # Calculate average duration
        var total_duration: i64 = 0
        for entry in history:
            total_duration = total_duration + entry.total_duration_ms

        # OPTIMIZATION: Use cached length
        val avg_duration = total_duration / history_len

        # OPTIMIZATION: Cache conversion factor and reuse
        val ms_to_sec = 1000
        val avg_sec = avg_duration / ms_to_sec

        # OPTIMIZATION: Use cached length for indexing
        val latest = history[history_len - 1]
        val latest_sec = latest.total_duration_ms / ms_to_sec

        # Compare
        val trend_text = if latest.total_duration_ms > avg_duration:
            val diff = latest.total_duration_ms - avg_duration
            val diff_sec = diff / ms_to_sec
            "slower ({diff_sec}s)"
        else if latest.total_duration_ms < avg_duration:
            val diff = avg_duration - latest.total_duration_ms
            val diff_sec = diff / ms_to_sec
            "faster ({diff_sec}s)"
        else:
            "same"

        "Latest: {latest_sec}s, Average: {avg_sec}s (trend: {trend_text})"

# Print metrics - OPTIMIZED VERSION
fn print_metrics(result: MetricsResult):
    # OPTIMIZATION: Build all strings then print once (reduces I/O calls)
    var lines = [
        "",
        "==========================================",
        "Build Metrics",
        "==========================================",
        "",
        result.report(),
        "",
        "Performance breakdown:",
        "  Total:     {result.metrics.total_duration_ms}ms",
        "  Compile:   {result.metrics.compile_duration_ms}ms",
        "  Link:      {result.metrics.link_duration_ms}ms"
    ]

    val cache_total = result.metrics.cache_hit_count + result.metrics.cache_miss_count
    if cache_total > 0:
        lines.push("")
        lines.push("Cache statistics:")
        lines.push("  Hits:      {result.metrics.cache_hit_count}")
        lines.push("  Misses:    {result.metrics.cache_miss_count}")

    # OPTIMIZATION: Single print call instead of multiple
    print lines.join("\n")

# Helper function
fn format_timestamp(ts: i64) -> text:
    # TODO: Format timestamp properly
    "{ts}"

fn current_time_ms() -> i64:
    # TODO: Get actual time
    0
