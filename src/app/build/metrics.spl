# Build Metrics - OPTIMIZED VERSION
#
# Tracks build performance and provides detailed timing analysis
# This version includes performance optimizations from the perf analyzer

export BuildMetrics, MetricsResult, MetricsTracker, MetricsConfig, default_metrics_config

use app.build.types (BuildResult, TestResult)
use app.io.{current_time_ms, file_exists, file_read, file_write, file_size, dir_create_all}
use std.string.{NL}

# Build metrics
struct BuildMetrics:
    total_duration_ms: i64
    compile_duration_ms: i64
    link_duration_ms: i64
    test_duration_ms: i64
    artifact_size_bytes: i64
    cache_hit_count: i64
    cache_miss_count: i64
    parallel_jobs: i64

impl BuildMetrics:
    fn summary() -> text:
        # OPTIMIZATION: Reduce repeated divisions by caching
        val ms_to_sec = 1000
        val total_sec = self.total_duration_ms / ms_to_sec
        val compile_sec = self.compile_duration_ms / ms_to_sec
        val link_sec = self.link_duration_ms / ms_to_sec

        val cache_total = self.cache_hit_count + self.cache_miss_count
        val cache_rate_text = if cache_total > 0:
            val cache_rate = (self.cache_hit_count * 100) / cache_total
            "{cache_rate}%"
        else:
            "N/A"

        "Build: {total_sec}s (compile: {compile_sec}s, link: {link_sec}s), cache: {cache_rate_text}"

# Metric collection result
struct MetricsResult:
    success: bool
    metrics: BuildMetrics
    timestamp: i64
    profile: text

impl MetricsResult:
    fn report() -> text:
        val time_str = format_timestamp(self.timestamp)
        "Metrics at {time_str}:{NL}{self.metrics.summary()}"

# Metrics history entry
struct MetricsEntry:
    timestamp: i64
    profile: text
    total_duration_ms: i64
    success: bool

# Metrics tracker
class MetricsTracker:
    # Record build metrics
    static fn record(result: BuildResult, profile: text) -> MetricsResult:
        val now = current_time_ms()

        # Parse compile/link durations from output if available
        val compile_ms = parse_duration_from_output(result.stdout, "Compiling")
        val link_ms = parse_duration_from_output(result.stdout, "Linking")

        # Get artifact size if build succeeded
        var artifact_bytes: i64 = 0
        if result.success:
            val artifact_path = "build/rust/ffi_gen/target/{profile}/simple"
            if file_exists(artifact_path):
                artifact_bytes = file_size(artifact_path)

        val metrics = BuildMetrics(
            total_duration_ms: result.duration_ms,
            compile_duration_ms: compile_ms,
            link_duration_ms: link_ms,
            test_duration_ms: 0,
            artifact_size_bytes: artifact_bytes,
            cache_hit_count: 0,
            cache_miss_count: 0,
            parallel_jobs: 4
        )

        val metrics_result = MetricsResult(
            success: result.success,
            metrics: metrics,
            timestamp: now,
            profile: profile
        )

        # Save to history
        save_metrics_entry(metrics_result)

        metrics_result

    # Record test metrics
    static fn record_test(result: TestResult) -> MetricsResult:
        # OPTIMIZATION: Get current time once
        val now = current_time_ms()

        val metrics = BuildMetrics(
            total_duration_ms: 0,  # Test result doesn't track duration yet
            compile_duration_ms: 0,
            link_duration_ms: 0,
            test_duration_ms: 0,
            artifact_size_bytes: 0,
            cache_hit_count: 0,
            cache_miss_count: 0,
            parallel_jobs: 4
        )

        MetricsResult(
            success: result.success,
            metrics: metrics,
            timestamp: now,
            profile: "test"
        )

    # Get recent metrics history
    static fn get_history(limit: i64) -> [MetricsEntry]:
        val metrics_path = "build/metrics_history.sdn"
        if not file_exists(metrics_path):
            return []
        val content = file_read(metrics_path)
        var entries: [MetricsEntry] = []
        val lines = content.split(NL)
        for line in lines:
            val trimmed = line.trim()
            if trimmed.len() == 0:
                continue
            if trimmed.starts_with("#"):
                continue
            # Format: timestamp|profile|duration_ms|success
            val parts = trimmed.split("|")
            if parts.len() >= 4:
                entries.push(MetricsEntry(
                    timestamp: int(parts[0]),
                    profile: parts[1],
                    total_duration_ms: int(parts[2]),
                    success: parts[3] == "true"
                ))
        # Return last N entries
        if entries.len() <= limit:
            return entries
        entries[entries.len() - limit:]

    # Analyze trends - OPTIMIZED VERSION
    static fn analyze_trends(history: [MetricsEntry]) -> text:
        # OPTIMIZATION: Cache array length to avoid repeated calls
        val history_len = history.len()

        if history_len == 0:
            return "No metrics history available"

        # Calculate average duration
        var total_duration: i64 = 0
        for entry in history:
            total_duration = total_duration + entry.total_duration_ms

        # OPTIMIZATION: Use cached length
        val avg_duration = total_duration / history_len

        # OPTIMIZATION: Cache conversion factor and reuse
        val ms_to_sec = 1000
        val avg_sec = avg_duration / ms_to_sec

        # OPTIMIZATION: Use cached length for indexing
        val latest = history[history_len - 1]
        val latest_sec = latest.total_duration_ms / ms_to_sec

        # Compare
        val trend_text = if latest.total_duration_ms > avg_duration:
            val diff = latest.total_duration_ms - avg_duration
            val diff_sec = diff / ms_to_sec
            "slower ({diff_sec}s)"
        else if latest.total_duration_ms < avg_duration:
            val diff = avg_duration - latest.total_duration_ms
            val diff_sec = diff / ms_to_sec
            "faster ({diff_sec}s)"
        else:
            "same"

        "Latest: {latest_sec}s, Average: {avg_sec}s (trend: {trend_text})"

# Print metrics - OPTIMIZED VERSION
fn print_metrics(result: MetricsResult):
    # OPTIMIZATION: Build all strings then print once (reduces I/O calls)
    var lines = [
        "",
        "==========================================",
        "Build Metrics",
        "==========================================",
        "",
        result.report(),
        "",
        "Performance breakdown:",
        "  Total:     {result.metrics.total_duration_ms}ms",
        "  Compile:   {result.metrics.compile_duration_ms}ms",
        "  Link:      {result.metrics.link_duration_ms}ms"
    ]

    val cache_total = result.metrics.cache_hit_count + result.metrics.cache_miss_count
    if cache_total > 0:
        lines.push("")
        lines.push("Cache statistics:")
        lines.push("  Hits:      {result.metrics.cache_hit_count}")
        lines.push("  Misses:    {result.metrics.cache_miss_count}")

    # OPTIMIZATION: Single print call instead of multiple
    print lines.join(NL)

# Helper function
fn format_timestamp(ts: i64) -> text:
    # Convert milliseconds to seconds for display
    val seconds = ts / 1000
    "{seconds}s"

# Save metrics entry to history
fn save_metrics_entry(result: MetricsResult):
    val metrics_path = "build/metrics_history.sdn"
    dir_create_all("build")
    val success_str = if result.success: "true" else: "false"
    val line = "{result.timestamp}|{result.profile}|{result.metrics.total_duration_ms}|{success_str}{NL}"
    if file_exists(metrics_path):
        val existing = file_read(metrics_path)
        file_write(metrics_path, existing + line)
    else:
        file_write(metrics_path, "# Metrics history (timestamp|profile|duration_ms|success){NL}" + line)

# Metrics configuration
struct MetricsConfig:
    enabled: bool
    output_file: text
    track_cache: bool
    track_size: bool
    save_history: bool

# Parse duration in milliseconds from build output for a given phase
fn parse_duration_from_output(output: text, phase: text) -> i64:
    # Look for lines like "Compiling in 5.2s" or "Linking in 1.3s"
    val lines = output.split(NL)
    for line in lines:
        if line.contains(phase):
            # Try to find a number followed by 's'
            val idx = line.index_of("in ")
            if idx >= 0:
                val rest = line[idx + 3:]
                val s_idx = rest.index_of("s")
                if s_idx >= 0:
                    val num_str = rest[0:s_idx].trim()
                    # Simple integer parse (no float parsing available)
                    val as_int = int(num_str)
                    return as_int * 1000
    0

fn default_metrics_config() -> MetricsConfig:
    """Create default metrics configuration."""
    MetricsConfig(
        enabled: true,
        output_file: "",
        track_cache: true,
        track_size: true,
        save_history: true
    )
