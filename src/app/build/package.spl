# Package Integration
#
# Integrates the build system with package creation.
# Creates distributable packages from build artifacts.

use app.io.{file_read_lines, file_exists, file_size, file_copy, dir_create, process_run, file_hash_sha256, current_time_ms, host_os, host_arch, dir_walk}

# Read project version from simple.sdn
fn read_project_version() -> text:
    if val Some(lines) = file_read_lines("simple.sdn"):
        for line in lines:
            val trimmed = line.trim()
            if trimmed.starts_with("version:"):
                return trimmed.replace("version:", "").trim()
    "0.0.0"

# Package type
enum PackageType:
    Bootstrap    # Minimal runtime + core libs (~10 MB)
    Full         # Complete source distribution (~50 MB)
    Custom       # User-defined package contents

# Package configuration
struct PackageConfig:
    package_type: PackageType
    version: text
    platform: text
    output_path: text
    include_sources: bool
    include_tests: bool
    compress: bool

# Package result
struct PackageResult:
    success: bool
    package_path: text
    package_size: i64
    checksum: text
    build_duration_ms: i64

impl PackageResult:
    fn summary() -> text:
        if self.success:
            "✓ Package created: {self.package_path} ({self.package_size} bytes)"
        else:
            "✗ Package creation failed"

# Package class
class Package:
    # Create a package with configuration
    static fn create(config: PackageConfig) -> PackageResult:
        print "Creating {config.package_type} package..."
        print "Version: {config.version}"
        print "Platform: {config.platform}"

        val pkg_type_str = "{config.package_type}"
        if pkg_type_str.contains("Bootstrap"):
            create_bootstrap_package(config)
        elif pkg_type_str.contains("Full"):
            create_full_package(config)
        elif pkg_type_str.contains("Custom"):
            create_custom_package(config)
        else:
            PackageResult(success: false, package_path: "", package_size: 0, checksum: "", build_duration_ms: 0)

    # Quick bootstrap package
    static fn bootstrap() -> PackageResult:
        val config = default_package_bootstrap_config()
        Package.create(config)

    # Quick full package
    static fn full() -> PackageResult:
        val config = default_full_config()
        Package.create(config)

# Create bootstrap package (minimal distribution)
fn create_bootstrap_package(config: PackageConfig) -> PackageResult:
    val start_time = current_time_ms()

    # Step 1: Verify pre-built runtime exists
    print "\nStep 1: Verifying pre-built runtime..."
    val runtime_src = "bin/release/simple"

    if not file_exists(runtime_src):
        print "✗ Pre-built runtime not found at: {runtime_src}"
        print "  Please ensure bin/release/simple exists"
        return PackageResult(
            success: false,
            package_path: "",
            package_size: 0,
            checksum: "",
            build_duration_ms: current_time_ms() - start_time
        )

    print "✓ Pre-built runtime found"

    # Step 2: Create package directory structure
    print "\nStep 2: Creating package structure..."
    val pkg_dir = "package_tmp"
    dir_create(pkg_dir, false)
    dir_create("{pkg_dir}/bin", false)
    dir_create("{pkg_dir}/lib", false)
    dir_create("{pkg_dir}/lib/simple", false)

    # Step 3: Copy runtime binary
    print "\nStep 3: Copying runtime binary..."
    val runtime_dst = "{pkg_dir}/bin/simple"

    if not file_copy(runtime_src, runtime_dst):
        print "✗ Failed to copy runtime binary"
        return PackageResult(
            success: false,
            package_path: "",
            package_size: 0,
            checksum: "",
            build_duration_ms: current_time_ms() - start_time
        )

    print "✓ Runtime binary copied"

    # Step 4: Copy essential libraries
    print "\nStep 4: Copying standard library..."
    copy_stdlib(pkg_dir)

    # Step 5: Create package archive
    print "\nStep 5: Creating archive..."
    val package_name = "simple-bootstrap-{config.version}-{config.platform}.tar.gz"
    val output_path = if config.output_path.len() > 0:
        config.output_path
    else:
        package_name

    val (stdout, stderr, exit_code) = process_run("tar", [
        "-czf", output_path,
        "-C", pkg_dir,
        "."
    ])

    if exit_code != 0:
        print "✗ Failed to create archive"
        return PackageResult(
            success: false,
            package_path: "",
            package_size: 0,
            checksum: "",
            build_duration_ms: current_time_ms() - start_time
        )

    # Step 6: Calculate checksum
    val package_size = file_size(output_path)
    val checksum = file_hash_sha256(output_path)

    # Cleanup temporary directory
    cleanup_package_dir(pkg_dir)

    print "✓ Package created successfully"

    PackageResult(
        success: true,
        package_path: output_path,
        package_size: package_size,
        checksum: checksum,
        build_duration_ms: current_time_ms() - start_time
    )

# Create full package (source distribution)
fn create_full_package(config: PackageConfig) -> PackageResult:
    val start_time = current_time_ms()

    print "\nCreating full source package..."

    val package_name = "simple-full-{config.version}.tar.gz"
    val output_path = if config.output_path.len() > 0:
        config.output_path
    else:
        package_name

    # Create tarball of entire source tree
    var args = ["-czf", output_path]

    # Exclude patterns
    args = args.merge(["--exclude=.git"])
    args = args.merge(["--exclude=build/rust/ffi_gen/target"])
    args = args.merge(["--exclude=*.pyc"])
    args = args.merge(["--exclude=__pycache__"])
    args = args.merge(["--exclude=.DS_Store"])
    args = args.merge(["--exclude=package_tmp"])

    # Include sources
    args = args.merge(["."])

    val (stdout, stderr, exit_code) = process_run("tar", args)

    if exit_code != 0:
        print "✗ Failed to create archive"
        return PackageResult(
            success: false,
            package_path: "",
            package_size: 0,
            checksum: "",
            build_duration_ms: current_time_ms() - start_time
        )

    val package_size = file_size(output_path)
    val checksum = file_hash_sha256(output_path)

    print "✓ Package created successfully"

    PackageResult(
        success: true,
        package_path: output_path,
        package_size: package_size,
        checksum: checksum,
        build_duration_ms: current_time_ms() - start_time
    )

# Create custom package
fn create_custom_package(config: PackageConfig) -> PackageResult:
    val start_time = current_time_ms()
    print "\nCreating custom package..."

    val package_name = "simple-custom-{config.version}-{config.platform}.tar.gz"
    val output_path = if config.output_path.len() > 0:
        config.output_path
    else:
        package_name

    # Create temporary directory
    val pkg_dir = "package_tmp_custom"
    dir_create(pkg_dir, false)
    dir_create("{pkg_dir}/bin", false)

    # Always copy runtime
    val runtime_src = "bin/release/simple"
    if file_exists(runtime_src):
        file_copy(runtime_src, "{pkg_dir}/bin/simple")

    # Copy sources if requested
    if config.include_sources:
        dir_create("{pkg_dir}/src", false)
        val src_files = dir_walk("src")
        for src_file in src_files:
            if src_file.ends_with(".spl"):
                val dst = "{pkg_dir}/{src_file}"
                val last_slash = dst.last_index_of("/")
                if last_slash >= 0:
                    dir_create(dst[0:last_slash], true)
                file_copy(src_file, dst)

    # Copy tests if requested
    if config.include_tests:
        dir_create("{pkg_dir}/test", false)
        val test_files = dir_walk("test")
        for test_file in test_files:
            if test_file.ends_with(".spl"):
                val dst = "{pkg_dir}/{test_file}"
                val last_slash = dst.last_index_of("/")
                if last_slash >= 0:
                    dir_create(dst[0:last_slash], true)
                file_copy(test_file, dst)

    # Create archive
    val result = process_run("tar", ["-czf", output_path, "-C", pkg_dir, "."])
    cleanup_package_dir(pkg_dir)

    if result[2] != 0:
        return PackageResult(
            success: false,
            package_path: "",
            package_size: 0,
            checksum: "",
            build_duration_ms: current_time_ms() - start_time
        )

    val package_size = file_size(output_path)
    val checksum = file_hash_sha256(output_path)

    print "Custom package created successfully"

    PackageResult(
        success: true,
        package_path: output_path,
        package_size: package_size,
        checksum: checksum,
        build_duration_ms: current_time_ms() - start_time
    )

# Copy standard library files
fn copy_stdlib(pkg_dir: text):
    val std_src = "src/std"
    val std_dst = "{pkg_dir}/lib/simple/std"
    dir_create("{pkg_dir}/lib/simple/std", false)
    val files = dir_walk(std_src)
    var copied = 0
    for src_file in files:
        if src_file.ends_with(".spl"):
            # Compute relative path
            val rel = src_file[std_src.len():]
            val dst_file = std_dst + rel
            # Ensure parent directory exists
            val last_slash = dst_file.last_index_of("/")
            if last_slash >= 0:
                val parent = dst_file[0:last_slash]
                dir_create(parent, true)
            file_copy(src_file, dst_file)
            copied = copied + 1
    print "  Copied {copied} stdlib files"

# Cleanup package temporary directory
fn cleanup_package_dir(pkg_dir: text):
    val result = process_run("rm", ["-rf", pkg_dir])
    print "  Cleaned up: {pkg_dir}"

# Helper: Detect platform
fn detect_platform() -> text:
    val os = host_os()
    val arch = host_arch()
    "{os}-{arch}"

# Print package result
fn print_package_result(result: PackageResult):
    print "\n=========================================="
    print "Package Creation Result"
    print "=========================================="
    print ""
    print result.summary()

    if result.success:
        print ""
        print "Package details:"
        print "  Path: {result.package_path}"
        print "  Size: {result.package_size} bytes"
        print "  Checksum: {result.checksum}"
        print "  Duration: {result.build_duration_ms}ms"
        print ""
        print "Installation:"
        print "  tar -xzf {result.package_path}"
        print "  cd simple-*"
        print "  ./bin/simple --version"

# Default configurations
fn default_package_bootstrap_config() -> PackageConfig:
    PackageConfig(
        package_type: PackageType.Bootstrap,
        version: read_project_version(),
        platform: detect_platform(),
        output_path: "",
        include_sources: false,
        include_tests: false,
        compress: true
    )

fn default_full_config() -> PackageConfig:
    PackageConfig(
        package_type: PackageType.Full,
        version: read_project_version(),
        platform: detect_platform(),
        output_path: "",
        include_sources: true,
        include_tests: true,
        compress: true
    )

# Helper: Package type to string
fn package_type_to_string(pkg_type: PackageType) -> text:
    val s = "{pkg_type}"
    if s.contains("Bootstrap"):
        "bootstrap"
    elif s.contains("Full"):
        "full"
    elif s.contains("Custom"):
        "custom"
    else:
        "unknown"
