# Duplication Check - Build System Integration
#
# Runs code duplication detection as part of quality phase

use app.io.{shell, file_exists, file_read}
use std.text.{NL}

struct DuplicationCheckConfig:
    enabled: bool
    fail_on_duplicates: bool
    max_allowed: i64
    min_tokens: i64
    min_lines: i64
    min_impact: i64
    report_path: text

struct DuplicationCheckResult:
    success: bool
    duplicate_groups: i64
    total_lines: i64
    exit_code: i64
    message: text

fn default_duplication_config() -> DuplicationCheckConfig:
    """Default configuration for duplication checking."""
    DuplicationCheckConfig(
        enabled: true,
        fail_on_duplicates: false,
        max_allowed: 0,
        min_tokens: 30,
        min_lines: 5,
        min_impact: 100,
        report_path: "doc/analysis/duplicate_db.sdn"
    )

fn run_duplication_check(config: DuplicationCheckConfig) -> DuplicationCheckResult:
    """Run duplication detection and return results.

    Args:
        config: Duplication check configuration

    Returns:
        Result with success status and metrics
    """
    if not config.enabled:
        return DuplicationCheckResult(
            success: true,
            duplicate_groups: 0,
            total_lines: 0,
            exit_code: 0,
            message: "Duplication check disabled"
        )

    print "Running duplication check..."

    # Build command with options
    var cmd = "bin/simple duplicate-check src/"
    cmd = cmd + " --min-tokens={config.min_tokens}"
    cmd = cmd + " --min-lines={config.min_lines}"
    cmd = cmd + " --min-impact={config.min_impact}"
    cmd = cmd + " --format=sdn"

    # Run duplicate-check command
    val result = shell(cmd)

    # Parse results from SDN database
    var duplicate_groups = 0
    var total_lines = 0

    if file_exists(config.report_path):
        val content = file_read(config.report_path)
        val lines = content.split(NL)

        for line in lines:
            val trimmed = line.trim()
            if trimmed.starts_with("total_groups:"):
                val parts = trimmed.split(":")
                if parts.len() >= 2:
                    duplicate_groups = int(parts[1].trim())
            elif trimmed.starts_with("total_lines:"):
                val parts = trimmed.split(":")
                if parts.len() >= 2:
                    total_lines = int(parts[1].trim())

    # Determine success based on configuration
    var success = true
    var message = "No code duplication detected"

    if duplicate_groups > 0:
        message = "Found {duplicate_groups} duplicate groups ({total_lines} lines)"

        if config.fail_on_duplicates and duplicate_groups > config.max_allowed:
            success = false
            message = "FAILED: {duplicate_groups} duplicate groups exceed limit of {config.max_allowed}"

    DuplicationCheckResult(
        success: success,
        duplicate_groups: duplicate_groups,
        total_lines: total_lines,
        exit_code: if success: 0 else: 1,
        message: message
    )

fn print_duplication_summary(result: DuplicationCheckResult):
    """Print duplication check summary."""
    print ""
    print "Duplication Check Results:"
    print "  Duplicate groups: {result.duplicate_groups}"
    print "  Total duplicated lines: {result.total_lines}"
    print "  Status: {result.message}"

    if not result.success:
        print ""
        print "  Run 'bin/simple duplicate-check src/' to see details"

export DuplicationCheckConfig, DuplicationCheckResult
export default_duplication_config, run_duplication_check, print_duplication_summary
