# Simple (.spl) replacement for script/build_custom_qemu.sh
#
# Build Custom QEMU with Simple Language Semihosting Support
#
# Adds support for string interning operations (0x100-0x104) to QEMU RISC-V
#
# Timeline: 8-12 hours (mostly compilation time)
# Result: Custom qemu-system-riscv32 with string table support

use app.io.mod.{shell, shell_bool, shell_output, cwd, file_exists, is_dir, dir_create_all, exit}
use std.string.{contains, trim}
use std.path.{join}
use std.log.{error}

fn check_prerequisites():
    # Returns true if all prerequisites are met
    print "-> Checking prerequisites..."

    if not shell_bool("command -v gcc"):
        error("build", "gcc not found")
        print "Install: sudo apt install build-essential"
        return false

    if not shell_bool("command -v pkg-config"):
        error("build", "pkg-config not found")
        print "Install: sudo apt install pkg-config"
        return false

    if not shell_bool("pkg-config --exists glib-2.0"):
        error("build", "glib-2.0 not found")
        print "Install: sudo apt install libglib2.0-dev"
        return false

    print "* Prerequisites OK"
    print ""
    return true

fn download_qemu_source(qemu_dir: text, source_dir: text):
    # Downloads and extracts QEMU source if not present
    if not is_dir(source_dir):
        print "-> QEMU source not found, downloading..."
        val download_dir = join(qemu_dir, "downloads")
        dir_create_all(download_dir)

        val tarball = join(download_dir, "qemu-8.2.0.tar.xz")
        if not file_exists(tarball):
            val dl_result = shell("curl -L --progress-bar -o {tarball} https://download.qemu.org/qemu-8.2.0.tar.xz")
            if dl_result.exit_code != 0:
                error("build", "Failed to download QEMU source")
                exit(1)

        val extract_result = shell("cd {download_dir} && tar -xf qemu-8.2.0.tar.xz")
        if extract_result.exit_code != 0:
            error("build", "Failed to extract QEMU source")
            exit(1)
        print "* QEMU source extracted"
    else:
        print "* QEMU source found at {source_dir}"
    print ""

fn apply_patch(source_dir: text):
    val patch_file = join(source_dir, "simple-semihosting-full.patch")

    print "-> Applying Simple language semihosting patch..."

    if not file_exists(patch_file):
        error("build", "Full patch not found at {patch_file}")
        print "   Expected: resources/qemu/downloads/qemu-8.2.0/simple-semihosting-full.patch"
        exit(1)

    # Try dry-run first
    val dry_run = shell("cd {source_dir} && patch -p1 --dry-run < {patch_file} > /dev/null 2>&1")
    if dry_run.exit_code == 0:
        val apply_result = shell("cd {source_dir} && patch -p1 < {patch_file}")
        if apply_result.exit_code != 0:
            error("build", "Patch failed to apply")
            print "Manual patching required - see: {patch_file}"
            exit(1)
        print "* Patch applied successfully"
    else:
        # Check if patch already applied
        val semi_file = join(source_dir, "semihosting/arm-compat-semi.c")
        if file_exists(semi_file):
            val grep_check = shell("grep -q TARGET_SYS_WRITE_HANDLE {semi_file}")
            if grep_check.exit_code == 0:
                print "* Patch already applied"
            else:
                error("build", "Patch failed to apply")
                print "Manual patching required - see: {patch_file}"
                exit(1)
        else:
            error("build", "Patch failed to apply")
            print "Manual patching required - see: {patch_file}"
            exit(1)
    print ""

fn configure_qemu(source_dir: text, build_dir: text, install_dir: text):
    print "-> Configuring QEMU..."

    dir_create_all(build_dir)

    val configure_cmd = "{source_dir}/configure --target-list=riscv32-softmmu,riscv64-softmmu --prefix={install_dir} --enable-debug --disable-werror"
    val config_result = shell("cd {build_dir} && {configure_cmd}")
    if config_result.exit_code != 0:
        error("build", "QEMU configuration failed")
        exit(1)

    print "* Configuration complete"
    print ""

fn build_qemu(build_dir: text):
    print "-> Building QEMU (this will take 30-60 minutes)..."
    val nproc = trim(shell_output("nproc"))
    print "   Parallel jobs: {nproc}"
    print ""

    val build_result = shell("cd {build_dir} && make -j{nproc}")
    if build_result.exit_code != 0:
        error("build", "QEMU build failed")
        exit(1)

    print ""
    print "* Build complete"
    print ""

fn install_qemu(build_dir: text):
    print "-> Installing..."

    val install_result = shell("cd {build_dir} && make install")
    if install_result.exit_code != 0:
        error("build", "QEMU installation failed")
        exit(1)

    print "* Installation complete"
    print ""

fn create_symlinks(qemu_dir: text, install_dir: text):
    print "-> Creating symlink in resources/qemu/bin/..."

    val bin_dir = join(qemu_dir, "bin")
    dir_create_all(bin_dir)

    shell("ln -sf {install_dir}/bin/qemu-system-riscv32 {bin_dir}/qemu-system-riscv32-simple")
    shell("ln -sf {install_dir}/bin/qemu-system-riscv64 {bin_dir}/qemu-system-riscv64-simple")

    print "* Symlinks created"
    print ""

fn test_qemu(qemu_dir: text):
    print "-> Testing custom QEMU..."

    val qemu_bin = join(qemu_dir, "bin/qemu-system-riscv32-simple")
    val version = trim(shell_output("{qemu_bin} --version | head -1"))
    print version
    print ""

fn main():
    val project_root = cwd()
    val qemu_dir = join(project_root, "resources/qemu")
    val source_dir = join(qemu_dir, "downloads/qemu-8.2.0")
    val build_dir = join(qemu_dir, "build/qemu-8.2.0-simple")
    val install_dir = join(qemu_dir, "install/qemu-8.2.0-simple")

    print "+================================================================+"
    print "|  Custom QEMU Build - Simple Language Semihosting Support       |"
    print "+================================================================+"
    print ""

    # Step 1: Check prerequisites
    val prereqs_ok = check_prerequisites()
    if not prereqs_ok:
        exit(1)

    # Step 2: Download QEMU source
    download_qemu_source(qemu_dir, source_dir)

    # Step 3: Apply patch
    apply_patch(source_dir)

    # Step 4: Configure QEMU
    configure_qemu(source_dir, build_dir, install_dir)

    # Step 5: Build QEMU
    build_qemu(build_dir)

    # Step 6: Install
    install_qemu(build_dir)

    # Step 7: Create symlinks
    create_symlinks(qemu_dir, install_dir)

    # Step 8: Test
    test_qemu(qemu_dir)

    print "+================================================================+"
    print "|  Build Complete!                                               |"
    print "+================================================================+"
    print ""
    print "Custom QEMU installed to:"
    print "  {install_dir}"
    print ""
    print "Symlinks created:"
    print "  {qemu_dir}/bin/qemu-system-riscv32-simple"
    print "  {qemu_dir}/bin/qemu-system-riscv64-simple"
    print ""
    print "Test with interned binary:"
    print "  resources/qemu/bin/qemu-system-riscv32-simple \\"
    print "    -M virt -bios none \\"
    print "    -kernel examples/baremetal/hello_riscv32_interned.elf \\"
    print "    -nographic \\"
    print "    -semihosting-config enable=on"
    print ""
    print "Note: Full string table support requires additional implementation."
    print "      Current patch allows program to continue (returns success stub)."

main()
