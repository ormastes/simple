# Cargo Wrapper
#
# Simple wrapper around Rust cargo FFI functions

use app.build.types (BuildResult, BuildError, TestResult, TestError, BuildConfig, profile_to_string)

# FFI declarations - these return dicts
extern fn rt_cargo_build(profile: text, features: [text], feature_count: i64) -> dict
extern fn rt_cargo_test(package: text, filter: text) -> dict
extern fn rt_cargo_test_doc(package: text) -> dict
extern fn rt_cargo_clean() -> i64
extern fn rt_cargo_check() -> dict
extern fn rt_cargo_lint(fix: i64) -> dict
extern fn rt_cargo_fmt(check_only: i64) -> dict

# Helper: Convert dict to BuildResult
fn dict_to_build_result(d: dict) -> BuildResult:
    BuildResult(
        success: d["success"],
        exit_code: d["exit_code"],
        stdout: d["stdout"],
        stderr: d["stderr"],
        duration_ms: d["duration_ms"]
    )

# Helper: Convert dict to TestResult
fn dict_to_test_result(d: dict) -> TestResult:
    TestResult(
        success: d["success"],
        exit_code: d["exit_code"],
        stdout: d["stdout"],
        stderr: d["stderr"],
        tests_run: d["tests_run"],
        tests_passed: d["tests_passed"],
        tests_failed: d["tests_failed"]
    )

# Cargo class - static methods for cargo operations
class Cargo:
    # Build with given configuration
    static fn build(config: BuildConfig) -> BuildResult:
        val profile_str = profile_to_string(config.profile)
        val feature_count = config.features.len()
        val result_dict = rt_cargo_build(profile_str, config.features, feature_count)
        dict_to_build_result(result_dict)

    # Run tests
    static fn test(package: text, filter: text) -> TestResult:
        val result_dict = rt_cargo_test(package, filter)
        dict_to_test_result(result_dict)

    # Run all workspace tests
    static fn test_workspace() -> TestResult:
        val result_dict = rt_cargo_test("", "")
        dict_to_test_result(result_dict)

    # Run doc-tests only
    static fn test_doc(package: text) -> TestResult:
        val result_dict = rt_cargo_test_doc(package)
        dict_to_test_result(result_dict)

    # Run clippy linter
    static fn lint(fix: bool) -> BuildResult:
        val fix_flag = if fix: 1 else: 0
        val result_dict = rt_cargo_lint(fix_flag)
        dict_to_build_result(result_dict)

    # Run rustfmt
    static fn fmt(check_only: bool) -> BuildResult:
        val check_flag = if check_only: 1 else: 0
        val result_dict = rt_cargo_fmt(check_flag)
        dict_to_build_result(result_dict)

    # Clean build artifacts
    static fn clean() -> i64:
        rt_cargo_clean()

    # Check without building
    static fn check() -> BuildResult:
        val result_dict = rt_cargo_check()
        dict_to_build_result(result_dict)

# Print build result
fn print_build_result(result: BuildResult):
    if result.success:
        print "Build succeeded in {result.duration_ms}ms"
        if result.stdout.len() > 0:
            print result.stdout
    else:
        print "Build failed with exit code {result.exit_code}"
        if result.stderr.len() > 0:
            print result.stderr

# Print test result
fn print_test_result(result: TestResult):
    if result.stdout.len() > 0:
        print result.stdout
    if result.success:
        print "Tests passed: {result.tests_passed}/{result.tests_run}"
        if result.tests_failed > 0:
            print "Tests failed: {result.tests_failed}"
    else:
        print "Tests failed with exit code {result.exit_code}"
        if result.stderr.len() > 0:
            print result.stderr

# Check if build succeeded
fn is_build_success(result: BuildResult) -> bool:
    result.success

# Check if tests passed
fn is_test_success(result: TestResult) -> bool:
    result.success
