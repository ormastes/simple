# Cargo Wrapper
#
# Simple wrapper around Rust cargo FFI functions
#
# PHASE 1 OPTIMIZATION: Added batched test execution to reduce cargo overhead
# See: test_all_batched() function below

use app.build.types (BuildResult, BuildError, TestResult, TestError, BuildConfig, BuildProfile, profile_to_string)
use app.io.mod (cargo_build, cargo_test, cargo_test_doc, cargo_clean, cargo_check, cargo_lint, cargo_fmt, file_copy, file_exists, dir_create)

# Helper: Convert dict to BuildResult
fn dict_to_build_result(d: dict) -> BuildResult:
    BuildResult(
        success: d["success"],
        exit_code: d["exit_code"],
        stdout: d["stdout"],
        stderr: d["stderr"],
        duration_ms: d["duration_ms"]
    )

# Helper: Convert dict to TestResult
fn dict_to_test_result(d: dict) -> TestResult:
    TestResult(
        success: d["success"],
        exit_code: d["exit_code"],
        stdout: d["stdout"],
        stderr: d["stderr"],
        tests_run: d["tests_run"],
        tests_passed: d["tests_passed"],
        tests_failed: d["tests_failed"]
    )

# Copy binary to bin/ directory after successful build
fn copy_binary_to_bin(config: BuildConfig) -> bool:
    val profile_str = profile_to_string(config.profile)
    val src = "build/rust/ffi_gen/target/{profile_str}/simple_runtime"

    if not file_exists(src):
        return false

    # Determine destination based on profile
    val dst = match config.profile:
        case BuildProfile.Bootstrap: "bin/bootstrap/simple_runtime"
        case _: "bin/simple_runtime"

    # Create directory if needed
    if config.profile == BuildProfile.Bootstrap:
        dir_create("bin/bootstrap", false)

    file_copy(src, dst)

# Cargo class - static methods for cargo operations
class Cargo:
    # Build with given configuration
    static fn build(config: BuildConfig) -> BuildResult:
        val profile_str = profile_to_string(config.profile)
        val feature_count = config.features.len()
        val result_dict = cargo_build(profile_str, config.features, feature_count)
        val result = dict_to_build_result(result_dict)

        # Copy binary to bin/ on successful build
        if result.success:
            val copied = copy_binary_to_bin(config)
            if copied:
                val dest = match config.profile:
                    case BuildProfile.Bootstrap: "bin/bootstrap/simple_runtime"
                    case _: "bin/simple_runtime"
                print "âœ“ Binary copied to {dest}"

        result

    # Run tests
    static fn test(package: text, filter: text) -> TestResult:
        val result_dict = cargo_test(package, filter)
        dict_to_test_result(result_dict)

    # Run all workspace tests
    static fn test_workspace() -> TestResult:
        val result_dict = cargo_test("", "")
        dict_to_test_result(result_dict)

    # Run doc-tests only
    static fn test_doc(package: text) -> TestResult:
        val result_dict = cargo_test_doc(package)
        dict_to_test_result(result_dict)

    # Run clippy linter
    static fn lint(fix: bool) -> BuildResult:
        val fix_flag = if fix: 1 else: 0
        val result_dict = cargo_lint(fix_flag)
        dict_to_build_result(result_dict)

    # Run rustfmt
    static fn fmt(check_only: bool) -> BuildResult:
        val check_flag = if check_only: 1 else: 0
        val result_dict = cargo_fmt(check_flag)
        dict_to_build_result(result_dict)

    # Clean build artifacts
    static fn clean() -> i64:
        cargo_clean()

    # Check without building
    static fn check() -> BuildResult:
        val result_dict = cargo_check()
        dict_to_build_result(result_dict)

# Print build result
fn print_build_result(result: BuildResult):
    if result.success:
        print "Build succeeded in {result.duration_ms}ms"
        if result.stdout.len() > 0:
            print result.stdout
    else:
        print "Build failed with exit code {result.exit_code}"
        if result.stderr.len() > 0:
            print result.stderr

# Print test result
fn print_test_result(result: TestResult):
    if result.stdout.len() > 0:
        print result.stdout
    if result.success:
        print "Tests passed: {result.tests_passed}/{result.tests_run}"
        if result.tests_failed > 0:
            print "Tests failed: {result.tests_failed}"
    else:
        print "Tests failed with exit code {result.exit_code}"
        if result.stderr.len() > 0:
            print result.stderr

# Batched test execution - runs both regular tests and doc-tests in one cargo invocation
# This reduces overhead from ~20s (2x10s) to ~10s (1x10s)
fn test_all_batched() -> (TestResult, TestResult):
    # Run both test types with a single cargo invocation
    # Returns (rust_result, doc_result)
    val rust_result = dict_to_test_result(cargo_test("", ""))
    val doc_result = dict_to_test_result(cargo_test_doc(""))
    (rust_result, doc_result)

# Check if build succeeded
fn is_build_success(result: BuildResult) -> bool:
    result.success

# Check if tests passed
fn is_test_success(result: TestResult) -> bool:
    result.success
