# Simple (.spl) replacement for scripts/build-cross-compile-all.sh
#
# Cross-compile seed + full Simple compiler for all 8 target platforms.
#
# Usage:
#   bin/simple run src/app/build/cross_compile.spl [--seed-only] [--targets=linux-arm64,windows-x86]
#
# Requirements:
#   - CMake toolchain files at seed/cmake/toolchains/*.cmake
#   - Cross-compilers: aarch64-linux-gnu-gcc, riscv64-linux-gnu-gcc,
#     x86_64-w64-mingw32-gcc, i686-w64-mingw32-gcc, clang
#   - Sysroots at /opt/sysroots/ (or /tmp/ paths for CI)
#   - Native bin/release/linux-x86_64/simple for full compiler builds

use app.io.mod.{shell, shell_bool, shell_output, env_get, cwd, file_exists, dir_create_all, is_dir, get_args, exit}
use std.text.{contains, starts_with, ends_with, trim, split, replace}
use std.path.{join}

val ALL_TARGETS = "linux-x86_64 linux-arm64 linux-riscv64 windows-x86_64 windows-x86 freebsd-x86_64 freebsd-x86 macos-arm64"

fn parse_arguments():
    val args = get_args()
    var seed_only = false
    var targets_str = ""

    for arg in args:
        if arg == "--seed-only":
            seed_only = true
        else if starts_with(arg, "--targets="):
            var t = arg
            t = replace(t, "--targets=", "")
            targets_str = t

    if targets_str == "":
        targets_str = ALL_TARGETS
    else:
        targets_str = replace(targets_str, ",", " ")

    return [seed_only, targets_str]

fn build_seed_for_target(project_dir: text, toolchain_dir: text, build_dir: text, target: text):
    # Returns "pass", "fail", or "skip"
    val toolchain = join(toolchain_dir, "{target}.cmake")
    if not file_exists(toolchain):
        print "SKIP {target}: no toolchain file at {toolchain}"
        return "skip"

    print "Building seed for {target}... "
    val target_build = join(build_dir, target)
    shell("rm -rf {target_build}")

    val cmake_config = shell("cmake -B {target_build} {project_dir}/seed -DCMAKE_TOOLCHAIN_FILE={toolchain} > {target_build}.cmake.log 2>&1")
    if cmake_config.exit_code != 0:
        print "FAIL (configure)"
        return "fail"

    val cmake_build = shell("cmake --build {target_build} --target seed --target seed_cpp --target spl_runtime >> {target_build}.cmake.log 2>&1")
    if cmake_build.exit_code != 0:
        print "FAIL (build)"
        return "fail"

    print "OK"
    # Also try building the CRT (may not exist for all platforms)
    shell("cmake --build {target_build} --target all >> {target_build}.cmake.log 2>&1")
    return "pass"

fn get_compiler_config(target: text, common_cflags: text, basename: text):
    # Returns [cc, cflags, output_name, extra]
    if target == "linux-x86_64":
        return ["clang", common_cflags, basename, "-lm"]
    else if target == "linux-arm64":
        return ["aarch64-linux-gnu-gcc", common_cflags, basename, "-lm"]
    else if target == "linux-riscv64":
        return ["riscv64-linux-gnu-gcc", common_cflags, basename, "-lm"]
    else if target == "windows-x86_64":
        return ["x86_64-w64-mingw32-gcc", common_cflags, "{basename}.exe", ""]
    else if target == "windows-x86":
        return ["i686-w64-mingw32-gcc", common_cflags, "{basename}.exe", ""]
    else if target == "freebsd-x86_64":
        var sysroot = ""
        if is_dir("/opt/sysroots/freebsd-x86_64/usr/include"):
            sysroot = "/opt/sysroots/freebsd-x86_64"
        else if is_dir("/tmp/freebsd-sysroot/usr/include"):
            sysroot = "/tmp/freebsd-sysroot"
        val cflags = "{common_cflags} --target=x86_64-unknown-freebsd14 --sysroot={sysroot} -fuse-ld=lld"
        return ["clang", cflags, basename, "-lm"]
    else if target == "freebsd-x86":
        var sysroot = ""
        if is_dir("/opt/sysroots/freebsd-x86/usr/include"):
            sysroot = "/opt/sysroots/freebsd-x86"
        else if is_dir("/tmp/freebsd-i386-sysroot/usr/include"):
            sysroot = "/tmp/freebsd-i386-sysroot"
        val cflags = "{common_cflags} --target=i686-unknown-freebsd13 --sysroot={sysroot} -fuse-ld=lld"
        return ["clang", cflags, basename, "-lm"]
    else if target == "macos-arm64":
        var sdk = ""
        if is_dir("/opt/sysroots/macos/MacOSX14.5.sdk/usr/include"):
            sdk = "/opt/sysroots/macos/MacOSX14.5.sdk"
        else if is_dir("/tmp/macos-sdk/MacOSX14.5.sdk/usr/include"):
            sdk = "/tmp/macos-sdk/MacOSX14.5.sdk"
        val cflags = "{common_cflags} --target=aarch64-apple-darwin -isysroot {sdk} -fuse-ld=lld"
        return ["clang", cflags, basename, ""]
    else:
        return ["", "", "", ""]

fn main():
    val project_dir = cwd()
    val build_dir = join(project_dir, "build")
    val toolchain_dir = join(project_dir, "seed/cmake/toolchains")

    val parsed = parse_arguments()
    val seed_only = parsed[0]
    val targets_str = parsed[1]

    print "====================================="
    print "  Simple Cross-Compilation Builder"
    print "====================================="
    print "Targets: {targets_str}"
    print "Seed only: {seed_only}"
    print ""

    var pass_count = 0
    var fail_count = 0
    var skip_count = 0

    # Phase 1: Build seed for each target
    print "--- Phase 1: Cross-compile seed ---"
    val targets = split(targets_str, " ")
    for target in targets:
        if target == "":
            pass_dn
        else:
            val result = build_seed_for_target(project_dir, toolchain_dir, build_dir, target)
            if result == "pass":
                pass_count = pass_count + 1
            else if result == "fail":
                fail_count = fail_count + 1
            else:
                skip_count = skip_count + 1

    print ""
    print "Seed results: {pass_count} pass, {fail_count} fail, {skip_count} skip"
    print ""

    if seed_only == true:
        print "Done (seed only)."
        exit(fail_count)

    # Phase 2: Cross-compile Simple programs via C codegen
    print "--- Phase 2: Cross-compile Simple programs via C codegen ---"

    var native_simple = join(project_dir, "bin/release/linux-x86_64/simple")
    if not file_exists(native_simple):
        native_simple = join(project_dir, "bin/release/simple")

    if not file_exists(native_simple):
        print "WARNING: No native Simple compiler found. Skipping C codegen phase."
        print ""
        print "====================================="
        print "  Cross-Compilation Summary"
        print "====================================="
        print "Seed:     {pass_count} pass, {fail_count} fail, {skip_count} skip"
        print "====================================="
        exit(fail_count)

    print "Using native compiler: {native_simple}"

    val source_file = env_get("SOURCE_FILE")
    if source_file == "":
        print "No SOURCE_FILE specified. Skipping C codegen cross-compilation."
        print "Usage: SOURCE_FILE=myapp.spl bin/simple run src/app/build/cross_compile.spl"
        print ""
        print "====================================="
        print "  Cross-Compilation Summary"
        print "====================================="
        print "Seed:     {pass_count} pass, {fail_count} fail, {skip_count} skip"
        print "====================================="
        exit(fail_count)

    # Generate C code once using native compiler
    val gen_c = "/tmp/simple_cross_generated.c"
    print "Generating C code from {source_file}... "
    val gen_result = shell("{native_simple} {project_dir}/src/app/compile/gen_c_only.spl {source_file} {gen_c} 2>/dev/null")
    if gen_result.exit_code != 0:
        print "FAIL"
        print "C code generation failed. Source may use features not yet supported by c_codegen."
        exit(1)
    print "OK"

    var output_dir = env_get("OUTPUT_DIR")
    if output_dir == "":
        output_dir = join(project_dir, "build/cross-output")

    var full_pass = 0
    var full_fail = 0

    # Extract basename from source_file
    val source_parts = split(source_file, "/")
    var raw_basename = source_parts[source_parts.len() - 1]
    raw_basename = replace(raw_basename, ".spl", "")

    val common_cflags = "-std=gnu11 -O2 -Wno-return-type"

    for target in targets:
        if target == "":
            pass_dn
        else:
            print "Building {raw_basename} for {target}... "

            val config = get_compiler_config(target, common_cflags, raw_basename)
            val cc = config[0]
            val cflags = config[1]
            val output_name = config[2]
            val extra = config[3]

            if cc == "":
                print "SKIP (unknown target)"
            else:
                val target_dir = join(output_dir, target)
                dir_create_all(target_dir)

                val build_result = shell("{cc} {cflags} -o {target_dir}/{output_name} {gen_c} {extra} 2>{target_dir}/build.log")
                if build_result.exit_code == 0:
                    val size_result = shell_output("wc -c < {target_dir}/{output_name}")
                    var size = trim(size_result)
                    print "OK ({size} bytes)"
                    full_pass = full_pass + 1
                else:
                    print "FAIL (see {target_dir}/build.log)"
                    full_fail = full_fail + 1

    print ""
    print "Cross-compile results: {full_pass} pass, {full_fail} fail"
    print ""

    # Summary
    print "====================================="
    print "  Cross-Compilation Summary"
    print "====================================="
    print "Seed:      {pass_count} pass, {fail_count} fail, {skip_count} skip"
    print "Programs:  {full_pass} pass, {full_fail} fail"
    print "====================================="
    print ""
    print "Note: The full 'simple' compiler binary is a Rust-based interpreter/JIT."
    print "Cross-compiling it requires Rust cross-compilation (not yet automated)."
    print "The C codegen path works for Simple programs that use supported features."

    val total_fail = fail_count + full_fail
    exit(total_fail)

main()
