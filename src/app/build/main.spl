# Simple Build System
#
# Main entry point for the build command

use app.build.config (parse_build_args)
use app.build.orchestrator (orchestrate_build, orchestrate_test, orchestrate_clean)
use app.build.test (TestOrchestrator, TestConfig, default_test_config)
use app.build.coverage (Coverage, CoverageConfig, default_coverage_config)
use app.build.quality (Lint, Format, Check, LintConfig, FormatConfig, CheckConfig, default_lint_config, default_format_config, default_check_config)
use app.build.bootstrap_simple (Bootstrap, default_bootstrap_config)
use app.build.package (Package, default_bootstrap_config as default_package_bootstrap_config, default_full_config)
use app.build.metrics (MetricsTracker, print_metrics)
use app.build.watch (WatchOrchestrator, default_watch_config, print_watch_result)
use app.build.incremental (IncrementalBuild, default_incremental_config, print_incremental_result)
use app.build.cargo (Cargo, print_build_result, print_test_result)

fn print_help():
    print "Simple Build System"
    print ""
    print "Usage:"
    print "  simple build [options]          Build the project"
    print "  simple build test               Run tests"
    print "  simple build clean              Clean build artifacts"
    print "  simple build check              Run all quality checks"
    print "  simple build coverage           Generate coverage report"
    print "  simple build lint               Run linter"
    print "  simple build fmt                Format code"
    print "  simple build bootstrap          Run bootstrap pipeline"
    print "  simple build bootstrap-rebuild  Rebuild from bootstrap binary"
    print "  simple build package            Create packages"
    print ""
    print "Rust Subproject:"
    print "  simple build rust               Build Rust workspace"
    print "  simple build rust test          Run Rust workspace tests"
    print "  simple build rust test --doc    Run Rust doc-tests"
    print "  simple build rust test -p <pkg> Run tests for specific crate"
    print "  simple build rust lint          Run clippy on Rust code"
    print "  simple build rust fmt           Run rustfmt on Rust code"
    print "  simple build rust check         Check Rust code (no build)"
    print "  simple build rust clean         Clean Rust build artifacts"
    print ""
    print "Advanced Features:"
    print "  simple build watch              Watch mode (auto-rebuild on changes)"
    print "  simple build incremental        Incremental build (only rebuild changed)"
    print "  simple build metrics            Show build metrics"
    print ""
    print "Options:"
    print "  --profile=<profile>             Build profile: debug, release, bootstrap"
    print "  --release                       Build with release profile"
    print "  --bootstrap                     Build with bootstrap profile"
    print "  --features=<features>           Comma-separated feature flags"
    print "  --verbose, -v                   Verbose output"
    print "  --metrics                       Show build metrics"
    print "  --incremental                   Use incremental builds"
    print "  --help, -h                      Show this help"
    print ""
    print "MIR Optimization:"
    print "  --opt-level=<level>             Optimization level: none, size, speed, aggressive"
    print "  -O0                             No optimization (fastest compile)"
    print "  -Os                             Optimize for size"
    print "  -O2                             Optimize for speed (default release)"
    print "  -O3                             Aggressive optimization (maximum performance)"
    print "  --show-opt-stats                Display optimization statistics"
    print ""
    print "Examples:"
    print "  simple build                    # Build with debug profile (no optimization)"
    print "  simple build --release          # Build with release profile (speed optimization)"
    print "  simple build --bootstrap        # Bootstrap build (size optimization)"
    print "  simple build -O3                # Build with aggressive optimization"
    print "  simple build --opt-level=size   # Optimize for binary size"
    print "  simple build -O2 --show-opt-stats  # Show optimization statistics"
    print "  simple build test               # Run all tests"
    print "  simple build rust test          # Run Rust workspace tests"
    print "  simple build rust test --doc    # Run Rust doc-tests"
    print "  simple build rust lint          # Run clippy linter"
    print "  simple build rust fmt           # Format Rust code"
    print "  simple build check              # Run all checks"
    print "  simple build watch              # Watch and auto-rebuild"
    print "  simple build clean              # Clean build artifacts"

# Handle `simple build rust <subcommand>` routing
fn handle_rust_subcommand(args: [text]) -> i64:
    if args.len() == 0:
        # `simple build rust` = build Rust workspace
        val config = parse_build_args([])
        val result = Cargo.build(config)
        print_build_result(result)
        if result.success:
            return 0
        else:
            return result.exit_code

    val cmd = args[0]
    match cmd:
        case "test":
            return handle_rust_test(args[1:])
        case "lint":
            val fix = args.len() > 1 and args[1] == "--fix"
            val result = Cargo.lint(fix)
            print_build_result(result)
            if result.success:
                return 0
            else:
                return result.exit_code
        case "fmt":
            val check_only = args.len() > 1 and args[1] == "--check"
            val result = Cargo.fmt(check_only)
            print_build_result(result)
            if result.success:
                return 0
            else:
                return result.exit_code
        case "check":
            val result = Cargo.check()
            print_build_result(result)
            if result.success:
                return 0
            else:
                return result.exit_code
        case "clean":
            val exit_code = Cargo.clean()
            if exit_code == 0:
                print "Rust build artifacts cleaned."
            else:
                print "Failed to clean Rust build artifacts."
            return exit_code
        case _:
            print "Unknown rust subcommand: {cmd}"
            print "Run 'simple build --help' for usage."
            return 1

# Handle `simple build rust test` with options
fn handle_rust_test(args: [text]) -> i64:
    var doc_only = false
    var package = ""
    var filter = ""
    var i = 0
    while i < args.len():
        val arg = args[i]
        if arg == "--doc":
            doc_only = true
        elif arg == "-p" and i + 1 < args.len():
            i = i + 1
            package = args[i]
        else:
            filter = arg
        i = i + 1

    if doc_only:
        print "=== Running Rust Doc-Tests ==="
        val result = Cargo.test_doc(package)
        print_test_result(result)
        if result.success:
            return 0
        else:
            return result.exit_code
    else:
        print "=== Running Rust Tests ==="
        val result = Cargo.test(package, filter)
        print_test_result(result)
        if result.success:
            return 0
        else:
            return result.exit_code

use app.io.mod (file_exists, file_size_raw)

# Rebuild entire compiler from bootstrap binary
fn handle_bootstrap_rebuild(args: [text]) -> i64:
    print "=== Rebuilding Compiler from Bootstrap Binary ==="
    print ""

    # Verify bootstrap binary exists
    if not file_exists("bin/bootstrap/simple_runtime"):
        print "✗ Bootstrap binary not found at bin/bootstrap/simple_runtime"
        print "  Run 'simple build --bootstrap' first."
        return 1

    print "✓ Bootstrap binary found (minimal 9.3 MB runtime)"
    print ""

    # Note: Currently rebuilds using Rust cargo
    # Future: Use bootstrap binary to compile the compiler itself
    print "Step 1: Building release runtime with Rust..."
    val config = parse_build_args(["--release"])

    val result = orchestrate_build(config)

    if not result.success:
        print "✗ Build failed"
        return result.exit_code

    print ""
    print "✓ Compiler rebuild complete"
    print "  Binary location: bin/simple_runtime"
    val size = file_size_raw("bin/simple_runtime")
    print "  Binary size: {size} bytes (~{size / 1024 / 1024} MB)"
    return 0

fn main(args: [text]) -> i64:
    # Check for subcommands
    if args.len() > 0:
        val cmd = args[0]
        match cmd:
            case "--help" | "-h":
                print_help()
                return 0
            case "rust":
                return handle_rust_subcommand(args[1:])
            case "test":
                val test_config = default_test_config()
                val result = TestOrchestrator.run(test_config)
                if result.all_passed():
                    return 0
                else:
                    return 1
            case "clean":
                val config = parse_build_args(args[1:])
                return orchestrate_clean(config.verbose)
            case "coverage":
                val cov_config = default_coverage_config()
                val result = Coverage.run(cov_config)
                if result.success:
                    return 0
                else:
                    return 1
            case "lint":
                val lint_config = default_lint_config()
                val result = Lint.run(lint_config)
                if result.success:
                    return 0
                else:
                    return 1
            case "fmt":
                val fmt_config = default_format_config()
                val result = Format.run(fmt_config)
                if result.success:
                    return 0
                else:
                    return 1
            case "check":
                val check_config = default_check_config()
                val result = Check.run(check_config)
                if result.overall_success:
                    return 0
                else:
                    return 1
            case "bootstrap":
                val bootstrap_config = default_bootstrap_config()
                val result = Bootstrap.run(bootstrap_config)
                if result.overall_success:
                    return 0
                else:
                    return 1
            case "bootstrap-rebuild":
                return handle_bootstrap_rebuild(args[1:])
            case "package" | "package-bootstrap":
                val result = Package.bootstrap()
                if result.success:
                    return 0
                else:
                    return 1
            case "package-full":
                val result = Package.full()
                if result.success:
                    return 0
                else:
                    return 1
            case "watch":
                val watch_config = default_watch_config()
                val result = WatchOrchestrator.start(watch_config)
                print_watch_result(result)
                return 0
            case "incremental":
                val incremental_config = default_incremental_config()
                val result = IncrementalBuild.quick()
                print_incremental_result(result)
                if result.success:
                    return 0
                else:
                    return 1
            case "metrics":
                # Show metrics from last build
                print "Build metrics:"
                print "(Note: Metrics tracking not yet fully implemented)"
                return 0
            case _:
                # Treat as build options
                ()

    # Parse configuration
    val config = parse_build_args(args)

    # Execute build
    val result = orchestrate_build(config)

    if result.success:
        return 0
    else:
        return result.exit_code
