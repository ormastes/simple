# Quality Tools - OPTIMIZED VERSION
#
# Code quality tools for the Simple build system.
# Integrates with cargo clippy (lint) and cargo fmt (format).
#
# OPTIMIZATIONS APPLIED:
# 1. Use .? existence check instead of .len() > 0 and .len() == 0
# 2. Cache .len() results when used multiple times
# 3. Cache string split results
# 4. Batch print statements

# Quality check result
struct QualityResult:
    success: bool
    exit_code: i64
    warnings: i64
    errors: i64
    stdout: text
    stderr: text
    fixed: i64        # Number of issues auto-fixed

impl QualityResult:
    fn has_issues() -> bool:
        self.warnings > 0 or self.errors > 0

    fn summary() -> text:
        if self.success:
            if self.fixed > 0:
                "✓ Fixed {self.fixed} issues"
            else if self.has_issues():
                "⚠ {self.warnings} warnings, {self.errors} errors"
            else:
                "✓ No issues found"
        else:
            "✗ Check failed"

# Lint configuration
struct LintConfig:
    auto_fix: bool       # Auto-fix issues (--fix)
    fail_on_warnings: bool
    workspace: bool
    package: text
    target: text         # Specific target (empty = all)

# Format configuration
struct FormatConfig:
    check_only: bool     # Check without modifying (--check)
    workspace: bool
    package: text

# Combined check configuration
struct CheckConfig:
    run_lint: bool
    run_format: bool
    run_tests: bool
    auto_fix: bool
    fail_fast: bool

# Combined check result
struct CheckResult:
    lint: QualityResult
    format: QualityResult
    test_passed: bool
    overall_success: bool

impl CheckResult:
    fn summary() -> text:
        var parts = []

        if not self.lint.success:
            parts = parts.merge(["Lint: {self.lint.summary()}"])

        if not self.format.success:
            parts = parts.merge(["Format: {self.format.summary()}"])

        if not self.test_passed:
            parts = parts.merge(["Tests: Failed"])

        # OPTIMIZATION: Use .? existence check
        if not parts.?:
            "✓ All checks passed"
        else:
            parts.join(", ")

use app.io.io (process_run)

# Lint class - cargo clippy integration
class Lint:
    # Run clippy with configuration
    static fn run(config: LintConfig) -> QualityResult:
        var args = ["clippy"]

        # Workspace or package
        if config.workspace:
            args = args.merge(["--workspace"])
        # OPTIMIZATION: Use .? existence check
        else if config.package.?:
            args = args.merge(["-p", config.package])

        # Target
        # OPTIMIZATION: Use .? existence check
        if config.target.?:
            args = args.merge(["--target", config.target])

        # Always show all warnings
        args = args.merge(["--", "-W", "clippy::all"])

        # Deny warnings if configured
        if config.fail_on_warnings:
            args = args.merge(["-D", "warnings"])

        # Run clippy
        val (stdout, stderr, exit_code) = process_run("cargo", args)

        # Parse output for warnings/errors
        val (warnings, errors) = parse_clippy_output(stdout, stderr)

        # Auto-fix if requested and there were issues
        var fixed = 0
        if config.auto_fix and (warnings > 0 or errors > 0):
            fixed = run_clippy_fix(config)

        QualityResult(
            success: exit_code == 0,
            exit_code: exit_code,
            warnings: warnings,
            errors: errors,
            stdout: stdout,
            stderr: stderr,
            fixed: fixed
        )

    # Quick lint with defaults
    static fn quick() -> QualityResult:
        Lint.run(default_lint_config())

    # Lint with auto-fix
    static fn fix() -> QualityResult:
        var config = default_lint_config()
        config.auto_fix = true
        Lint.run(config)

# Run clippy with --fix
fn run_clippy_fix(config: LintConfig) -> i64:
    var args = ["clippy", "--fix", "--allow-dirty", "--allow-staged"]

    if config.workspace:
        args = args.merge(["--workspace"])
    # OPTIMIZATION: Use .? existence check
    else if config.package.?:
        args = args.merge(["-p", config.package])

    val (stdout, stderr, exit_code) = process_run("cargo", args)

    # Parse number of fixes from output
    # TODO: Implement proper parsing
    if exit_code == 0:
        1  # Placeholder - return 1 to indicate fixes were applied
    else:
        0

# Format class - cargo fmt integration
class Format:
    # Run rustfmt with configuration
    static fn run(config: FormatConfig) -> QualityResult:
        var args = ["fmt"]

        # Workspace or package
        if config.workspace:
            args = args.merge(["--all"])
        # OPTIMIZATION: Use .? existence check
        else if config.package.?:
            args = args.merge(["-p", config.package])

        # Check only (don't modify)
        if config.check_only:
            args = args.merge(["--check"])

        # Run fmt
        val (stdout, stderr, exit_code) = process_run("cargo", args)

        # Count files that need formatting (when check_only)
        val issues = if config.check_only:
            count_format_issues(stdout, stderr)
        else:
            0

        QualityResult(
            success: exit_code == 0,
            exit_code: exit_code,
            warnings: issues,
            errors: 0,
            stdout: stdout,
            stderr: stderr,
            fixed: if config.check_only: 0 else: issues
        )

    # Check format without modifying
    static fn check() -> QualityResult:
        var config = default_format_config()
        config.check_only = true
        Format.run(config)

    # Format code (auto-fix)
    static fn fix() -> QualityResult:
        var config = default_format_config()
        config.check_only = false
        Format.run(config)

# Combined quality check
class Check:
    # Run all quality checks (lint + format + test)
    static fn run(config: CheckConfig) -> CheckResult:
        var lint_result = empty_quality_result()
        var format_result = empty_quality_result()
        var test_passed = true

        # Run lint
        if config.run_lint:
            print "\n=== Running Lint (clippy) ==="
            var lint_config = default_lint_config()
            lint_config.auto_fix = config.auto_fix
            lint_result = Lint.run(lint_config)
            print_quality_result("Lint", lint_result)

            if config.fail_fast and not lint_result.success:
                return CheckResult(
                    lint: lint_result,
                    format: empty_quality_result(),
                    test_passed: true,
                    overall_success: false
                )

        # Run format
        if config.run_format:
            print "\n=== Running Format (rustfmt) ==="
            var format_config = default_format_config()
            format_config.check_only = not config.auto_fix
            format_result = Format.run(format_config)
            print_quality_result("Format", format_result)

            if config.fail_fast and not format_result.success:
                return CheckResult(
                    lint: lint_result,
                    format: format_result,
                    test_passed: true,
                    overall_success: false
                )

        # Run tests (basic - just check via cargo check)
        if config.run_tests:
            print "\n=== Running Tests ==="
            # TODO: Integrate with test orchestrator
            # For now, use simple cargo check
            test_passed = run_quick_test()

        val overall_success = lint_result.success and format_result.success and test_passed

        CheckResult(
            lint: lint_result,
            format: format_result,
            test_passed: test_passed,
            overall_success: overall_success
        )

    # Quick check (lint + format, no auto-fix)
    static fn quick() -> CheckResult:
        Check.run(CheckConfig(
            run_lint: true,
            run_format: true,
            run_tests: false,
            auto_fix: false,
            fail_fast: false
        ))

    # Full check (lint + format + test)
    static fn full() -> CheckResult:
        Check.run(CheckConfig(
            run_lint: true,
            run_format: true,
            run_tests: true,
            auto_fix: false,
            fail_fast: false
        ))

# Parse clippy output for warning/error counts - OPTIMIZED VERSION
fn parse_clippy_output(stdout: text, stderr: text) -> (i64, i64):
    # Look for lines like:
    # "warning: 25 warnings emitted"
    # "error: could not compile ... due to 3 previous errors"

    var warnings = 0
    var errors = 0

    # OPTIMIZATION: Cache split result
    # Parse stdout
    val stdout_lines = stdout.split("\n")
    for line in stdout_lines:
        if line.contains("warning"):
            # Simplified parsing - count "warning:" occurrences
            warnings = warnings + 1
        if line.contains("error:") and not line.contains("aborting"):
            errors = errors + 1

    (warnings, errors)

# Count files needing formatting - OPTIMIZED VERSION
fn count_format_issues(stdout: text, stderr: text) -> i64:
    # OPTIMIZATION: Cache split result
    # Parse output for "Diff in ..." lines
    var count = 0
    val lines = stdout.split("\n")
    for line in lines:
        if line.contains("Diff in"):
            count = count + 1
    count

# Quick test run (cargo check)
fn run_quick_test() -> bool:
    val (stdout, stderr, exit_code) = process_run("cargo", ["check", "--workspace"])
    exit_code == 0

# Print quality result - OPTIMIZED VERSION
fn print_quality_result(name: text, result: QualityResult):
    # OPTIMIZATION: Build output as list then print once
    var lines = ["{name}: {result.summary()}"]

    # OPTIMIZATION: Use .? existence check and cache .len()
    if result.has_issues() and result.stdout.?:
        # Show first few lines of output
        val stdout_lines = result.stdout.split("\n")
        val lines_count = stdout_lines.len()
        val preview_lines = if lines_count > 10: 10 else: lines_count

        for i in 0..preview_lines:
            lines.push("  {stdout_lines[i]}")

        if lines_count > 10:
            lines.push("  ... ({lines_count - 10} more lines)")

    # OPTIMIZATION: Single print call
    print lines.join("\n")

# Helper: Empty quality result
fn empty_quality_result() -> QualityResult:
    QualityResult(
        success: true,
        exit_code: 0,
        warnings: 0,
        errors: 0,
        stdout: "",
        stderr: "",
        fixed: 0
    )

# Default configurations
fn default_lint_config() -> LintConfig:
    LintConfig(
        auto_fix: false,
        fail_on_warnings: false,
        workspace: true,
        package: "",
        target: ""
    )

fn default_format_config() -> FormatConfig:
    FormatConfig(
        check_only: false,
        workspace: true,
        package: ""
    )

fn default_check_config() -> CheckConfig:
    CheckConfig(
        run_lint: true,
        run_format: true,
        run_tests: true,
        auto_fix: false,
        fail_fast: false
    )
