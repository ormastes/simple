# Bare-Metal Build Module
#
# Build commands for bare-metal targets (QEMU, embedded hardware).
#
# Usage:
#   simple build --target=baremetal-x86 --board=qemu_x86
#   simple test --baremetal --timeout=30000

from std.common.target import {Target, TargetArch, TargetOS}
from app.linker_gen.parser import {parse_board, BoardConfig, QemuConfig}
from app.linker_gen.main import {generate_linker_script}
from app.build.types import {BuildResult, BuildConfig, BuildProfile, TestResult}
from app.io.mod import {dir_create, file_write, process_run, current_time_ms}

export BaremetalConfig, BaremetalBuilder, QemuRunner

# Bare-metal build configuration
struct BaremetalConfig:
    target: Target              # Target triple
    board_file: text            # Path to board SDN file
    board: BoardConfig?         # Parsed board config
    output_dir: text            # Output directory
    linker_script: text         # Generated linker script path
    entry_point: text           # Kernel entry point

impl BaremetalConfig:
    # Create default config for QEMU x86
    static fn qemu_x86() -> BaremetalConfig:
        val target = Target(
            arch: TargetArch.X86,
            os: TargetOS.BareMetal,
            wasm_runtime: nil
        )
        BaremetalConfig(
            target: target,
            board_file: "boards/qemu_x86.sdn",
            board: nil,
            output_dir: "build/baremetal",
            linker_script: "build/baremetal/linker.ld",
            entry_point: "_start"
        )

    # Load board configuration
    me load_board() -> Result<(), text>:
        val result = parse_board(self.board_file)
        match result:
            case Ok(board):
                self.board = Some(board)
                Ok(())
            case Err(e):
                Err(e.message())

    # Generate linker script from board config
    me generate_linker() -> Result<text, text>:
        if not self.board.?:
            return Err("Board not loaded")
        val script = generate_linker_script(self.board.unwrap())
        Ok(script)

# Bare-metal builder
class BaremetalBuilder:
    config: BaremetalConfig

impl BaremetalBuilder:
    static fn new(config: BaremetalConfig) -> BaremetalBuilder:
        BaremetalBuilder(config: config)

    # Build a bare-metal binary
    fn build(source_files: [text]) -> BuildResult:
        # Create output directory
        dir_create(self.config.output_dir, true)

        # Load board and generate linker script
        match self.config.load_board():
            case Err(msg):
                return BuildResult(
                    success: false,
                    exit_code: 1,
                    stdout: "",
                    stderr: "Failed to load board: {msg}",
                    duration_ms: 0
                )
            case Ok(_): pass

        match self.config.generate_linker():
            case Err(msg):
                return BuildResult(
                    success: false,
                    exit_code: 1,
                    stdout: "",
                    stderr: "Failed to generate linker script: {msg}",
                    duration_ms: 0
                )
            case Ok(script):
                if not file_write(self.config.linker_script, script):
                    return BuildResult(
                        success: false,
                        exit_code: 1,
                        stdout: "",
                        stderr: "Failed to write linker script",
                        duration_ms: 0
                    )

        val start_time = current_time_ms()

        # Step 1: Compile Simple source → LLVM IR
        var llvm_ir_files: [text] = []
        var all_stdout = ""
        var all_stderr = ""

        for source_file in source_files:
            match self.compile_to_llvm_ir(source_file):
                case Ok((ir_file, stdout, stderr)):
                    llvm_ir_files.push(ir_file)
                    all_stdout = all_stdout + stdout
                    all_stderr = all_stderr + stderr
                case Err((msg, stdout, stderr)):
                    val end_time = current_time_ms()
                    return BuildResult(
                        success: false,
                        exit_code: 1,
                        stdout: all_stdout + stdout,
                        stderr: all_stderr + stderr + "\nFailed to compile {source_file}: {msg}",
                        duration_ms: end_time - start_time
                    )

        # Step 2: Compile LLVM IR → object files
        var object_files: [text] = []
        for ir_file in llvm_ir_files:
            match self.compile_to_object(ir_file):
                case Ok((obj_file, stdout, stderr)):
                    object_files.push(obj_file)
                    all_stdout = all_stdout + stdout
                    all_stderr = all_stderr + stderr
                case Err((msg, stdout, stderr)):
                    val end_time = current_time_ms()
                    return BuildResult(
                        success: false,
                        exit_code: 1,
                        stdout: all_stdout + stdout,
                        stderr: all_stderr + stderr + "\nFailed to compile {ir_file}: {msg}",
                        duration_ms: end_time - start_time
                    )

        # Step 3: Link object files → ELF binary
        match self.link_to_elf(object_files):
            case Ok((elf_file, stdout, stderr)):
                val end_time = current_time_ms()
                all_stdout = all_stdout + stdout
                all_stderr = all_stderr + stderr
                return BuildResult(
                    success: true,
                    exit_code: 0,
                    stdout: all_stdout + "\nBinary: {elf_file}",
                    stderr: all_stderr,
                    duration_ms: end_time - start_time
                )
            case Err((msg, stdout, stderr)):
                val end_time = current_time_ms()
                return BuildResult(
                    success: false,
                    exit_code: 1,
                    stdout: all_stdout + stdout,
                    stderr: all_stderr + stderr + "\nFailed to link: {msg}",
                    duration_ms: end_time - start_time
                )

    # Compile Simple source to LLVM IR
    fn compile_to_llvm_ir(source_file: text) -> Result<(text, text, text), (text, text, text)>:
        # Output file: source.spl → source.ll
        val base_name = source_file.replace(".spl", "")
        val ir_file = "{self.config.output_dir}/{base_name}.ll"

        # TODO: When simple CLI supports bare-metal compilation, use:
        #   simple compile --target=baremetal-x86 --emit=llvm-ir source.spl -o output.ll
        # For now, use bootstrap simple to compile with bare-metal flags
        val target_triple = self.config.target.triple()
        var args: [text] = [
            "compile",
            "--target", target_triple,
            "--emit", "llvm-ir",
            "-o", ir_file,
            source_file
        ]

        val (stdout, stderr, exit_code) = process_run("simple", args)

        if exit_code == 0:
            Ok((ir_file, stdout, stderr))
        else:
            Err(("Compilation failed", stdout, stderr))

    # Compile LLVM IR to object file using llc
    fn compile_to_object(ir_file: text) -> Result<(text, text, text), (text, text, text)>:
        # Output file: source.ll → source.o
        val obj_file = ir_file.replace(".ll", ".o")

        # llc flags:
        #   --filetype=obj - output object file instead of assembly
        #   --relocation-model=static - no position-independent code (bare-metal)
        var args: [text] = [
            "--filetype=obj",
            "--relocation-model=static",
            ir_file,
            "-o", obj_file
        ]

        val (stdout, stderr, exit_code) = process_run("llc", args)

        if exit_code == 0:
            Ok((obj_file, stdout, stderr))
        else:
            Err(("llc compilation failed", stdout, stderr))

    # Link object files to ELF binary using ld
    fn link_to_elf(object_files: [text]) -> Result<(text, text, text), (text, text, text)>:
        val elf_file = "{self.config.output_dir}/kernel.elf"

        # ld flags:
        #   -T linker.ld - use linker script
        #   -nostdlib - don't link standard library
        #   --entry=_start - set entry point
        var args: [text] = [
            "-T", self.config.linker_script,
            "-nostdlib",
            "--entry={self.config.entry_point}"
        ]

        # Add all object files
        for obj_file in object_files:
            args.push(obj_file)

        # Output file
        args.push("-o")
        args.push(elf_file)

        val (stdout, stderr, exit_code) = process_run("ld", args)

        if exit_code == 0:
            Ok((elf_file, stdout, stderr))
        else:
            Err(("Linking failed", stdout, stderr))

# QEMU test runner
class QemuRunner:
    config: BaremetalConfig
    timeout_ms: i64
    qemu_path: text

impl QemuRunner:
    static fn new(config: BaremetalConfig, timeout_ms: i64) -> QemuRunner:
        QemuRunner(
            config: config,
            timeout_ms: timeout_ms,
            qemu_path: "qemu-system-i386"  # Default for x86
        )

    # Get QEMU executable for target architecture
    fn qemu_executable() -> text:
        match self.config.target.arch:
            case TargetArch.X86: "qemu-system-i386"
            case TargetArch.X86_64: "qemu-system-x86_64"
            case TargetArch.Arm: "qemu-system-arm"
            case TargetArch.Aarch64: "qemu-system-aarch64"
            case TargetArch.Riscv32: "qemu-system-riscv32"
            case TargetArch.Riscv64: "qemu-system-riscv64"
            case _: "qemu-system-i386"

    # Build QEMU command line arguments
    fn build_args(kernel_path: text) -> [text]:
        var args: [text] = []

        if self.config.board.?:
            val qemu = self.config.board.unwrap().qemu
            if qemu.?:
                val q = qemu.unwrap()
                args.push("-machine")
                args.push(q.machine)
                args.push("-cpu")
                args.push(q.cpu)
                args.push("-m")
                args.push(q.memory)
                args.push("-serial")
                args.push(q.serial)

                # ISA debug exit device (for test exit codes)
                if q.isa_debug_exit_enabled:
                    args.push("-device")
                    args.push("isa-debug-exit,iobase=0xF4,iosize=0x04")

        # Kernel binary
        args.push("-kernel")
        args.push(kernel_path)

        # No display (headless)
        args.push("-display")
        args.push("none")

        # Disable default devices
        args.push("-nodefaults")

        args

    # Run kernel in QEMU and capture output
    # TODO: Add proper timeout support via SFFI when available
    fn run(kernel_path: text) -> TestResult:
        val qemu = self.qemu_executable()
        val args = self.build_args(kernel_path)

        val start_time = current_time_ms()
        # Note: For now, rely on QEMU's own exit mechanism (isa-debug-exit device)
        # The kernel must call the exit port or QEMU will run indefinitely
        # TODO: Implement proper rt_process_run_timeout in SFFI
        val (stdout, stderr, exit_code) = process_run(qemu, args)
        val end_time = current_time_ms()

        # Check if execution took too long (approximate timeout detection)
        val duration_ms = end_time - start_time
        if duration_ms > self.timeout_ms:
            return TestResult(
                success: false,
                exit_code: -1,
                stdout: stdout,
                stderr: "QEMU execution exceeded timeout ({duration_ms}ms > {self.timeout_ms}ms)",
                tests_run: 0,
                tests_passed: 0,
                tests_failed: 0
            )

        # Parse test results from serial output
        parse_test_output(stdout, exit_code)

# Parse bare-metal test output from serial
# Expected format (SSpec-compatible):
#   [TEST START]
#   [PASS] test_name
#   [FAIL] test_name: error message
#   [TEST END] passed=N failed=M
fn parse_test_output(output: text, exit_code: i64) -> TestResult:
    var tests_run: i64 = 0
    var tests_passed: i64 = 0
    var tests_failed: i64 = 0

    for line in output.lines():
        val trimmed = line.trim()
        if trimmed.starts_with("[PASS]"):
            tests_run = tests_run + 1
            tests_passed = tests_passed + 1
        elif trimmed.starts_with("[FAIL]"):
            tests_run = tests_run + 1
            tests_failed = tests_failed + 1
        elif trimmed.starts_with("[TEST END]"):
            # Parse final counts if provided
            # Format: [TEST END] passed=N failed=M
            val parts = trimmed.split(" ")
            for part in parts:
                if part.starts_with("passed="):
                    tests_passed = part.substring(7).parse_int() ?? tests_passed
                elif part.starts_with("failed="):
                    tests_failed = part.substring(7).parse_int() ?? tests_failed
            tests_run = tests_passed + tests_failed

    # QEMU exit code handling:
    # isa-debug-exit returns (value << 1) | 1
    # So exit code 0 becomes 1, exit code 1 becomes 3
    val adjusted_exit = if exit_code > 0: (exit_code - 1) / 2 else: 0

    TestResult(
        success: tests_failed == 0 and adjusted_exit == 0,
        exit_code: adjusted_exit,
        stdout: output,
        stderr: "",
        tests_run: tests_run,
        tests_passed: tests_passed,
        tests_failed: tests_failed
    )
