# Bare-Metal Build Module
#
# Build commands for bare-metal targets (ARM, x86_64, RISC-V).
# Uses static linker scripts and crt0.s startup code.
#
# Usage:
#   simple build baremetal --target=arm
#   simple build baremetal --target=x86_64
#   simple build baremetal --target=riscv

use std.text.{NL}
use app.build.types.{BuildResult, TestResult}
use app.io.mod.{dir_create, file_write, file_exists, process_run, current_time_ms}

export BaremetalConfig, BaremetalBuilder, QemuRunner
export baremetal_config_arm, baremetal_config_x86_64, baremetal_config_riscv

# Bare-metal target architectures
enum BaremetalTarget:
    Arm           # ARM Cortex-M (versatilepb in QEMU)
    X86_64        # x86_64 with multiboot2
    Riscv         # RISC-V 64-bit (virt machine)

# Bare-metal build configuration
class BaremetalConfig:
    target: BaremetalTarget
    output_dir: text
    linker_script: text
    crt0_path: text
    entry_point: text

impl BaremetalConfig:
    # Create ARM Cortex-M config
    static fn arm() -> BaremetalConfig:
        BaremetalConfig(
            target: BaremetalTarget.Arm,
            output_dir: "build/baremetal-arm",
            linker_script: "src/compiler/baremetal/arm/linker.ld",
            crt0_path: "src/compiler/baremetal/arm/crt0.s",
            entry_point: "reset_handler"
        )

    # Create x86_64 config
    static fn x86_64() -> BaremetalConfig:
        BaremetalConfig(
            target: BaremetalTarget.X86_64,
            output_dir: "build/baremetal-x86_64",
            linker_script: "src/compiler/baremetal/x86_64/linker.ld",
            crt0_path: "src/compiler/baremetal/x86_64/crt0.s",
            entry_point: "_start"
        )

    # Create RISC-V config
    static fn riscv() -> BaremetalConfig:
        BaremetalConfig(
            target: BaremetalTarget.Riscv,
            output_dir: "build/baremetal-riscv",
            linker_script: "src/compiler/baremetal/riscv/linker.ld",
            crt0_path: "src/compiler/baremetal/riscv/crt0.s",
            entry_point: "_start"
        )

    # Get target triple
    fn target_triple() -> text:
        match self.target:
            case BaremetalTarget.Arm: "armv7m-none-eabi"
            case BaremetalTarget.X86_64: "x86_64-unknown-none"
            case BaremetalTarget.Riscv: "riscv64gc-unknown-none-elf"

# Factory functions (exported)
fn baremetal_config_arm() -> BaremetalConfig:
    BaremetalConfig.arm()

fn baremetal_config_x86_64() -> BaremetalConfig:
    BaremetalConfig.x86_64()

fn baremetal_config_riscv() -> BaremetalConfig:
    BaremetalConfig.riscv()

# Bare-metal builder
class BaremetalBuilder:
    config: BaremetalConfig

impl BaremetalBuilder:
    static fn new(config: BaremetalConfig) -> BaremetalBuilder:
        BaremetalBuilder(config: config)

    # Build a bare-metal binary
    fn build(source_files: [text]) -> BuildResult:
        # Create output directory
        dir_create(self.config.output_dir, true)

        # Verify linker script exists
        if not file_exists(self.config.linker_script):
            return BuildResult(
                success: false,
                exit_code: 1,
                stdout: "",
                stderr: "Linker script not found: {self.config.linker_script}",
                duration_ms: 0
            )

        # Verify crt0.s exists
        if not file_exists(self.config.crt0_path):
            return BuildResult(
                success: false,
                exit_code: 1,
                stdout: "",
                stderr: "Startup code not found: {self.config.crt0_path}",
                duration_ms: 0
            )

        val start_time = current_time_ms()

        # Step 1: Assemble crt0.s
        val crt0_result = self.assemble_crt0()
        if not crt0_result.success:
            return crt0_result

        # Step 2: Compile Simple source files to object files
        var object_files: [text] = [crt0_result.stdout]  # crt0.o path
        var all_stdout = crt0_result.stdout + NL
        var all_stderr = crt0_result.stderr

        for source_file in source_files:
            val obj_result = self.compile_source(source_file)
            if not obj_result.success:
                return BuildResult(
                    success: false,
                    exit_code: obj_result.exit_code,
                    stdout: all_stdout + obj_result.stdout,
                    stderr: all_stderr + obj_result.stderr,
                    duration_ms: current_time_ms() - start_time
                )
            object_files.push(obj_result.stdout)  # object file path
            all_stdout = all_stdout + obj_result.stdout + NL
            all_stderr = all_stderr + obj_result.stderr

        # Step 3: Link object files to ELF binary
        val link_result = self.link_to_elf(object_files)
        val end_time = current_time_ms()

        if link_result.success:
            BuildResult(
                success: true,
                exit_code: 0,
                stdout: all_stdout + link_result.stdout + "{NL}Binary: {link_result.stdout}",
                stderr: all_stderr + link_result.stderr,
                duration_ms: end_time - start_time
            )
        else:
            BuildResult(
                success: false,
                exit_code: link_result.exit_code,
                stdout: all_stdout + link_result.stdout,
                stderr: all_stderr + link_result.stderr + "{NL}Linking failed",
                duration_ms: end_time - start_time
            )

    # Assemble crt0.s to crt0.o
    fn assemble_crt0() -> BuildResult:
        val obj_file = "{self.config.output_dir}/crt0.o"

        var assembler = "arm-none-eabi-as"
        var args: [text] = []

        match self.config.target:
            case BaremetalTarget.Arm:
                assembler = "arm-none-eabi-as"
                args = ["-mcpu=cortex-m4", "-mthumb", "-o", obj_file, self.config.crt0_path]
            case BaremetalTarget.X86_64:
                assembler = "as"
                args = ["--64", "-o", obj_file, self.config.crt0_path]
            case BaremetalTarget.Riscv:
                assembler = "riscv64-unknown-elf-as"
                args = ["-march=rv64gc", "-mabi=lp64d", "-o", obj_file, self.config.crt0_path]

        val (stdout, stderr, exit_code) = process_run(assembler, args)

        if exit_code == 0:
            BuildResult(success: true, exit_code: 0, stdout: obj_file, stderr: stderr, duration_ms: 0)
        else:
            BuildResult(success: false, exit_code: exit_code, stdout: stdout, stderr: "Assembly failed: {stderr}", duration_ms: 0)

    # Compile Simple source to object file
    # For now, this is a placeholder - actual compilation would use Simple compiler
    fn compile_source(source_file: text) -> BuildResult:
        # Extract base name
        var base_name = source_file
        if base_name.contains("/"):
            val parts = base_name.split("/")
            base_name = parts[parts.len() - 1]
        if base_name.ends_with(".spl"):
            base_name = base_name[0:base_name.len() - 4]

        val obj_file = "{self.config.output_dir}/{base_name}.o"

        # TODO: Use actual Simple compiler when bare-metal backend is integrated
        # For now, return a placeholder result
        val msg = "Compilation not yet implemented - needs Simple compiler with bare-metal backend"
        BuildResult(success: false, exit_code: 1, stdout: obj_file, stderr: msg, duration_ms: 0)

    # Link object files to ELF binary using linker script
    fn link_to_elf(object_files: [text]) -> BuildResult:
        val elf_file = "{self.config.output_dir}/kernel.elf"

        var linker = "ld"
        var args: [text] = ["-T", self.config.linker_script, "-nostdlib", "--entry={self.config.entry_point}"]

        # Target-specific linker flags
        match self.config.target:
            case BaremetalTarget.Arm:
                linker = "arm-none-eabi-ld"
            case BaremetalTarget.X86_64:
                linker = "ld"
            case BaremetalTarget.Riscv:
                linker = "riscv64-unknown-elf-ld"

        # Add all object files
        for obj_file in object_files:
            args.push(obj_file)

        # Output file
        args.push("-o")
        args.push(elf_file)

        val (stdout, stderr, exit_code) = process_run(linker, args)

        if exit_code == 0:
            BuildResult(success: true, exit_code: 0, stdout: elf_file, stderr: stderr, duration_ms: 0)
        else:
            BuildResult(success: false, exit_code: exit_code, stdout: stdout, stderr: "Linking failed: {stderr}", duration_ms: 0)

# QEMU test runner
class QemuRunner:
    config: BaremetalConfig
    timeout_ms: i64

impl QemuRunner:
    static fn new(config: BaremetalConfig, timeout_ms: i64) -> QemuRunner:
        QemuRunner(config: config, timeout_ms: timeout_ms)

    # Get QEMU executable for target architecture
    fn qemu_executable() -> text:
        match self.config.target:
            case BaremetalTarget.Arm: "qemu-system-arm"
            case BaremetalTarget.X86_64: "qemu-system-x86_64"
            case BaremetalTarget.Riscv: "qemu-system-riscv64"

    # Build QEMU command line arguments
    fn build_args(kernel_path: text) -> [text]:
        var args: [text] = []

        match self.config.target:
            case BaremetalTarget.Arm:
                args = ["-M", "versatilepb", "-nographic", "-serial", "stdio", "-kernel", kernel_path]
            case BaremetalTarget.X86_64:
                args = ["-kernel", kernel_path, "-serial", "stdio", "-display", "none", "-device", "isa-debug-exit,iobase=0xf4,iosize=0x04"]
            case BaremetalTarget.Riscv:
                args = ["-M", "virt", "-bios", "none", "-nographic", "-serial", "stdio", "-kernel", kernel_path]

        args

    # Run kernel in QEMU and capture output
    fn run(kernel_path: text) -> TestResult:
        val qemu = self.qemu_executable()
        val args = self.build_args(kernel_path)

        val start_time = current_time_ms()
        val (stdout, stderr, exit_code) = process_run(qemu, args)
        val end_time = current_time_ms()

        # Check if execution took too long
        val duration_ms = end_time - start_time
        if duration_ms > self.timeout_ms:
            return TestResult(
                success: false,
                exit_code: -1,
                stdout: stdout,
                stderr: "QEMU execution exceeded timeout ({duration_ms}ms > {self.timeout_ms}ms)",
                tests_run: 0,
                tests_passed: 0,
                tests_failed: 0
            )

        # Parse test results from serial output
        parse_test_output(stdout, exit_code)

# Parse bare-metal test output from serial
# Expected format (SSpec-compatible):
#   [TEST START]
#   [PASS] test_name
#   [FAIL] test_name: error message
#   [TEST END] passed=N failed=M
fn parse_test_output(output: text, exit_code: i64) -> TestResult:
    var tests_run: i64 = 0
    var tests_passed: i64 = 0
    var tests_failed: i64 = 0

    val lines = output.split(NL)
    for line in lines:
        val trimmed = line.trim()
        if trimmed.starts_with("[PASS]"):
            tests_run = tests_run + 1
            tests_passed = tests_passed + 1
        elif trimmed.starts_with("[FAIL]"):
            tests_run = tests_run + 1
            tests_failed = tests_failed + 1
        elif trimmed.starts_with("[TEST END]"):
            # Parse final counts if provided
            val parts = trimmed.split(" ")
            for part in parts:
                if part.starts_with("passed="):
                    val num_str = part[7:]
                    val parsed = int(num_str)
                    tests_passed = parsed
                elif part.starts_with("failed="):
                    val num_str = part[7:]
                    val parsed = int(num_str)
                    tests_failed = parsed
            tests_run = tests_passed + tests_failed

    # QEMU exit code handling:
    # isa-debug-exit returns (value << 1) | 1
    # So exit code 0 becomes 1, exit code 1 becomes 3
    var adjusted_exit = 0
    if exit_code > 0:
        adjusted_exit = (exit_code - 1) / 2

    TestResult(
        success: tests_failed == 0 and adjusted_exit == 0,
        exit_code: adjusted_exit,
        stdout: output,
        stderr: "",
        tests_run: tests_run,
        tests_passed: tests_passed,
        tests_failed: tests_failed
    )
