# @no_alloc
# Alloc import checker — static analysis for baremetal builds
#
# Scans source files for heap-allocating stdlib imports and reports errors
# when such imports appear in a no-alloc build configuration.

extern fn rt_file_read_text(path: text) -> text

export AllocCheckError, alloc_check_error_new
export alloc_annotation_from_source, check_alloc_imports

# Error produced when an @alloc module is imported in a no-alloc build
struct AllocCheckError:
    file_path: text
    imported_module: text
    message: text

# Construct an AllocCheckError with a standard message
fn alloc_check_error_new(file_path: text, imported_module: text) -> AllocCheckError:
    AllocCheckError(
        file_path: file_path,
        imported_module: imported_module,
        message: "alloc module '" + imported_module + "' imported in no-alloc build"
    )

# Read source text and return its alloc annotation.
# Returns "@alloc", "@no_alloc", or "" if the file is untagged.
fn alloc_annotation_from_source(source_text: text) -> text:
    val lines = source_text.split("\n")
    if lines.len() == 0:
        return ""
    val first = lines[0]
    if first == "# @alloc":
        return "@alloc"
    if first == "# @no_alloc":
        return "@no_alloc"
    ""

# Map a use-spec prefix to a source file path.
# "std.string.{...}" -> "src/std/string.spl"
# Returns "" when the module is unknown.
fn _extract_module_path(use_spec: text) -> text:
    if use_spec.starts_with("std.string"):
        return "src/std/string.spl"
    if use_spec.starts_with("std.text"):
        return "src/std/text.spl"
    if use_spec.starts_with("std.array"):
        return "src/std/array.spl"
    if use_spec.starts_with("std.path"):
        return "src/std/path.spl"
    if use_spec.starts_with("std.effects"):
        return "src/std/effects.spl"
    ""

# Try to read a module file.  Returns "" if the file cannot be read.
fn _try_read_module(path: text) -> text:
    val content = rt_file_read_text(path)
    content ?? ""

# Check a source file's imports against alloc annotations.
# source_text   — full text of the file being analysed
# alloc_allowed — when true, no errors are ever produced
# Returns a (possibly empty) list of AllocCheckError values.
fn check_alloc_imports(source_text: text, alloc_allowed: bool) -> [AllocCheckError]:
    var errors: [AllocCheckError] = []
    if alloc_allowed:
        return errors
    val lines = source_text.split("\n")
    for line in lines:
        val trimmed = line.trim()
        if trimmed.starts_with("use std."):
            val after_use = trimmed[4:trimmed.len()]
            val module_path = _extract_module_path(after_use)
            if module_path.len() > 0:
                val module_text = _try_read_module(module_path)
                if module_text.len() > 0:
                    val annotation = alloc_annotation_from_source(module_text)
                    if annotation == "@alloc":
                        errors = errors + [alloc_check_error_new("(source)", module_path)]
    errors
