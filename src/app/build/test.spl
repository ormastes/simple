# Test Orchestrator
#
# Unified test orchestration for the Simple build system.
# Runs Rust tests, doc-tests, and Simple tests in parallel.

use app.build.types (TestConfig, TestResult, TestResults)
use app.build.cargo (Cargo, print_test_result)

# FFI for Simple test runner integration
extern fn rt_cli_run_tests(args: [text], gc_log: bool, gc_off: bool) -> i64

# Test orchestrator class
class TestOrchestrator:
    # Run all tests (Rust + doc + Simple) in parallel or serial
    static fn run(config: TestConfig) -> TestResults:
        val start_time = current_time_ms()

        if config.parallel:
            run_parallel_impl(config, start_time)
        else:
            run_serial_impl(config, start_time)

# Run tests in parallel using async/futures
fn run_parallel_impl(config: TestConfig, start_time: i64) -> TestResults:
    # TODO: Implement async/parallel execution when futures are ready
    # For now, fall back to serial execution
    run_serial_impl(config, start_time)

# Run tests serially
fn run_serial_impl(config: TestConfig, start_time: i64) -> TestResults:
        var rust_result = empty_test_result()
        var doc_result = empty_test_result()
        var simple_result = empty_test_result()

        # Run Rust tests (unless doc_only or simple_only)
        if not config.doc_only and not config.simple_only:
            print "\n=== Running Rust Tests ==="
            rust_result = run_rust_tests(config)
            print_test_result(rust_result)

            if config.fail_fast and not rust_result.success:
                val total_duration = current_time_ms() - start_time
                return TestResults(
                    rust: rust_result,
                    doc: empty_test_result(),
                    simple: empty_test_result(),
                    total_duration_ms: total_duration
                )

        # Run doc-tests (unless rust_only or simple_only)
        if not config.rust_only and not config.simple_only:
            print "\n=== Running Doc-Tests ==="
            doc_result = run_doc_tests(config)
            print_test_result(doc_result)

            if config.fail_fast and not doc_result.success:
                val total_duration = current_time_ms() - start_time
                return TestResults(
                    rust: rust_result,
                    doc: doc_result,
                    simple: empty_test_result(),
                    total_duration_ms: total_duration
                )

        # Run Simple tests (unless rust_only or doc_only)
        if not config.rust_only and not config.doc_only:
            print "\n=== Running Simple Tests ==="
            simple_result = run_simple_tests(config)
            print_test_result(simple_result)

        val total_duration = current_time_ms() - start_time

        TestResults(
            rust: rust_result,
            doc: doc_result,
            simple: simple_result,
            total_duration_ms: total_duration
        )

# Run Rust workspace tests via cargo
fn run_rust_tests(config: TestConfig) -> TestResult:
    val package = ""  # Empty = all workspace tests
    Cargo.test(package, config.filter)

# Run doc-tests via cargo
fn run_doc_tests(config: TestConfig) -> TestResult:
    # Doc-tests are run separately with --doc flag
    # We'll need to add a cargo.test_doc() method
    # For now, return empty result
    # TODO: Implement cargo test --doc support
    empty_test_result()

# Run Simple/SSpec tests via test runner
fn run_simple_tests(config: TestConfig) -> TestResult:
    # Build args for Simple test runner
    var args = []

    # Add filter if specified
    if config.filter.len() > 0:
        args = args.merge([config.filter])

    # Add level filter
    if config.level.len() > 0 and config.level != "all":
        args = args.merge(["--level", config.level])

    # Add tag filter
    if config.tag.len() > 0:
        args = args.merge(["--tag", config.tag])

    # Add fail-fast
    if config.fail_fast:
        args = args.merge(["--fail-fast"])

    # Add timeout
    if config.timeout > 0:
        args = args.merge(["--timeout", config.timeout.to_string()])

    # Run via FFI (this calls the Rust test runner which then runs Simple tests)
    val exit_code = rt_cli_run_tests(args, false, false)

    # Parse result (simplified - the actual test runner writes to test_db.sdn)
    # TODO: Parse test_db.sdn for detailed results
    if exit_code == 0:
        TestResult(
            success: true,
            exit_code: 0,
            stdout: "",
            stderr: "",
            tests_run: 0,   # TODO: Get from test_db.sdn
            tests_passed: 0, # TODO: Get from test_db.sdn
            tests_failed: 0
        )
    else:
        TestResult(
            success: false,
            exit_code: exit_code,
            stdout: "",
            stderr: "",
            tests_run: 0,
            tests_passed: 0,
            tests_failed: 0
        )

# Helper: Create empty test result
fn empty_test_result() -> TestResult:
    TestResult(
        success: true,
        exit_code: 0,
        stdout: "",
        stderr: "",
        tests_run: 0,
        tests_passed: 0,
        tests_failed: 0
    )

# Helper: Get current time in milliseconds
fn current_time_ms() -> i64:
    # TODO: Use proper time FFI
    0

# Print combined test results
fn print_test_results(results: TestResults):
    print "\n=========================================="
    print "Test Results Summary"
    print "=========================================="

    print "\nRust Tests:"
    print "  Run: {results.rust.tests_run}, Passed: {results.rust.tests_passed}, Failed: {results.rust.tests_failed}"

    print "\nDoc-Tests:"
    print "  Run: {results.doc.tests_run}, Passed: {results.doc.tests_passed}, Failed: {results.doc.tests_failed}"

    print "\nSimple Tests:"
    print "  Run: {results.simple.tests_run}, Passed: {results.simple.tests_passed}, Failed: {results.simple.tests_failed}"

    print "\nTotal:"
    print "  Run: {results.total_tests()}, Passed: {results.total_passed()}, Failed: {results.total_failed()}"
    print "  Duration: {results.total_duration_ms}ms"

    if results.all_passed():
        print "\n✓ All tests passed!"
    else:
        print "\n✗ Some tests failed"

# Default test configuration
fn default_test_config() -> TestConfig:
    TestConfig(
        filter: "",
        level: "all",
        tag: "",
        fail_fast: false,
        timeout: 0,
        parallel: false,  # Serial by default (parallel needs async support)
        rust_only: false,
        doc_only: false,
        simple_only: false
    )
