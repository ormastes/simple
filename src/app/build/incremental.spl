# Incremental Build System
#
# Tracks dependencies and only rebuilds changed components

export IncrementalConfig, IncrementalResult, default_incremental_config

use app.build.types (BuildConfig, BuildResult, BuildProfile)
use app.build.cargo (Cargo)
use app.io.{current_time_ms, file_hash_sha256, file_exists, dir_create_all, file_read, file_write}
use std.string.{NL}

# Dependency graph node
struct DepNode:
    module: text
    dependencies: [text]
    last_modified: i64
    hash: text

# Build cache entry
struct CacheEntry:
    module: text
    profile: text
    source_hash: text
    output_path: text
    timestamp: i64

# Incremental build configuration
struct IncrementalConfig:
    enabled: bool
    cache_dir: text
    track_deps: bool
    verify_hash: bool
    max_cache_size_mb: i64

# Incremental build result
struct IncrementalResult:
    success: bool
    modules_built: i64
    modules_cached: i64
    modules_skipped: i64
    cache_hit_rate: f64
    duration_ms: i64

impl IncrementalResult:
    fn summary() -> text:
        val total = self.modules_built + self.modules_cached + self.modules_skipped
        val cache_pct = if total > 0:
            (self.modules_cached * 100) / total
        else:
            0
        "Built {self.modules_built}/{total} modules ({cache_pct}% cached)"

# Incremental build orchestrator
class IncrementalBuild:
    # Build with incremental compilation
    static fn build(config: BuildConfig, incremental_config: IncrementalConfig) -> IncrementalResult:
        if not incremental_config.enabled:
            # Fall back to full build
            val result = Cargo.build(config)
            return IncrementalResult(
                success: result.success,
                modules_built: 1,  # Assume 1 for full build
                modules_cached: 0,
                modules_skipped: 0,
                cache_hit_rate: 0.0,
                duration_ms: result.duration_ms
            )

        # Load dependency graph
        val dep_graph = load_dependency_graph()

        # Load cache
        val cache = load_build_cache(incremental_config.cache_dir)

        # Determine what needs rebuilding
        val to_rebuild = find_modules_to_rebuild(dep_graph, cache)

        # Build only changed modules selectively
        val start_time = current_time_ms()
        val result = if to_rebuild.len() == 0:
            # Nothing changed - skip build entirely
            BuildResult(success: true, output: "No modules changed")
        elif to_rebuild.len() < dep_graph.total_modules() / 2:
            # Less than half changed - build selectively
            Cargo.build_modules(config, to_rebuild)
        else:
            # Most modules changed - full build is faster
            Cargo.build(config)
        val duration = current_time_ms() - start_time

        # Update cache
        if result.success:
            update_build_cache(cache, dep_graph, incremental_config.cache_dir)

        IncrementalResult(
            success: result.success,
            modules_built: to_rebuild.len(),
            modules_cached: dep_graph.len() - to_rebuild.len(),
            modules_skipped: 0,
            cache_hit_rate: calculate_cache_hit_rate(to_rebuild.len(), dep_graph.len()),
            duration_ms: duration
        )

    # Quick incremental build
    static fn quick() -> IncrementalResult:
        val config = BuildConfig(
            profile: BuildProfile.Debug,
            features: [],
            workspace_root: "build/rust/ffi_gen",
            target_dir: "build/rust/ffi_gen/target",
            jobs: 4,
            verbose: false
        )

        val incremental_config = default_incremental_config()
        IncrementalBuild.build(config, incremental_config)

    # Clean incremental cache
    static fn clean_cache(cache_dir: text) -> bool:
        val cache_path = "{cache_dir}/build_cache.sdn"
        if file_exists(cache_path):
            file_write(cache_path, "# Build cache cleared{NL}")
        print "Cleaning incremental cache: {cache_dir}"
        true

# Dependency graph builder
class DepGraphBuilder:
    # Build dependency graph from source files
    static fn build_graph(root: text) -> [DepNode]:
        val graph_path = "{root}/build/dep_graph.sdn"
        if file_exists(graph_path):
            return load_dependency_graph()
        []

    # Update dependency graph
    static fn update_graph(graph: [DepNode], changes: [text]) -> [DepNode]:
        # Mark changed modules and their dependents for rebuild
        var changed_set: Dict<text, bool> = {}
        for change in changes:
            changed_set[change] = true
        # Update hashes for changed modules
        var updated: [DepNode] = []
        for node in graph:
            if changed_set.has(node.module):
                val new_hash = file_hash_sha256(node.module)
                updated.push(DepNode(
                    module: node.module,
                    dependencies: node.dependencies,
                    last_modified: current_time_ms(),
                    hash: new_hash
                ))
            else:
                updated.push(node)
        updated

# Cache manager
class CacheManager:
    # Load build cache
    static fn load(cache_dir: text) -> [CacheEntry]:
        val cache_path = "{cache_dir}/build_cache.sdn"
        if not file_exists(cache_path):
            return []
        val content = file_read(cache_path)
        # Parse SDN cache entries (one per line: module|profile|hash|output|timestamp)
        var entries: [CacheEntry] = []
        val lines = content.split(NL)
        for line in lines:
            val trimmed = line.trim()
            if trimmed.len() == 0:
                continue
            if trimmed.starts_with("#"):
                continue
            val parts = trimmed.split("|")
            if parts.len() >= 5:
                entries.push(CacheEntry(
                    module: parts[0],
                    profile: parts[1],
                    source_hash: parts[2],
                    output_path: parts[3],
                    timestamp: int(parts[4])
                ))
        entries

    # Save build cache
    static fn save(cache: [CacheEntry], cache_dir: text) -> bool:
        dir_create_all(cache_dir)
        val cache_path = "{cache_dir}/build_cache.sdn"
        var lines: [text] = ["# Build cache (module|profile|hash|output|timestamp)"]
        for entry in cache:
            lines.push("{entry.module}|{entry.profile}|{entry.source_hash}|{entry.output_path}|{entry.timestamp}")
        file_write(cache_path, lines.join(NL) + NL)
        true

    # Verify cache entry is valid
    static fn verify(entry: CacheEntry, source_path: text) -> bool:
        if not file_exists(source_path):
            return false
        val current_hash = file_hash_sha256(source_path)
        current_hash == entry.source_hash

    # Prune old cache entries
    static fn prune(cache: [CacheEntry], max_size_mb: i64) -> [CacheEntry]:
        # Keep only entries within size limit (approximate by count)
        # Each entry ~100 bytes, so max_entries ~ max_size_mb * 10000
        val max_entries = max_size_mb * 10000
        if cache.len() <= max_entries:
            return cache
        # Sort by timestamp (newest first) and truncate
        # Simple approach: just keep the last max_entries entries
        cache[cache.len() - max_entries:]

# Load dependency graph
fn load_dependency_graph() -> [DepNode]:
    val graph_path = "build/dep_graph.sdn"
    if not file_exists(graph_path):
        return []
    val content = file_read(graph_path)
    var nodes: [DepNode] = []
    val lines = content.split(NL)
    for line in lines:
        val trimmed = line.trim()
        if trimmed.len() == 0:
            continue
        if trimmed.starts_with("#"):
            continue
        # Format: module|dep1,dep2,...|last_modified|hash
        val parts = trimmed.split("|")
        if parts.len() >= 4:
            val deps = if parts[1].len() > 0: parts[1].split(",") else: []
            nodes.push(DepNode(
                module: parts[0],
                dependencies: deps,
                last_modified: int(parts[2]),
                hash: parts[3]
            ))
    nodes

# Load build cache
fn load_build_cache(cache_dir: text) -> [CacheEntry]:
    CacheManager.load(cache_dir)

# Find modules that need rebuilding
fn find_modules_to_rebuild(dep_graph: [DepNode], cache: [CacheEntry]) -> [text]:
    # Build cache lookup by module name
    var cache_map: Dict<text, CacheEntry> = {}
    for entry in cache:
        cache_map[entry.module] = entry
    # Check each module against cache
    var to_rebuild: [text] = []
    for node in dep_graph:
        if not cache_map.has(node.module):
            to_rebuild.push(node.module)
            continue
        val cached = cache_map[node.module]
        if cached.source_hash != node.hash:
            to_rebuild.push(node.module)
            continue
        # Check if any dependency needs rebuilding
        var dep_changed = false
        for dep in node.dependencies:
            if not cache_map.has(dep):
                dep_changed = true
                break
            if cache_map[dep].source_hash != node.hash:
                dep_changed = true
                break
        if dep_changed:
            to_rebuild.push(node.module)
    to_rebuild

# Update build cache after successful build
fn update_build_cache(cache: [CacheEntry], dep_graph: [DepNode], cache_dir: text):
    val now = current_time_ms()
    var updated_cache: [CacheEntry] = []
    for node in dep_graph:
        updated_cache.push(CacheEntry(
            module: node.module,
            profile: "default",
            source_hash: node.hash,
            output_path: "build/{node.module}",
            timestamp: now
        ))
    CacheManager.save(updated_cache, cache_dir)

# Calculate cache hit rate
fn calculate_cache_hit_rate(modules_built: i64, total_modules: i64) -> f64:
    if total_modules == 0:
        return 0.0
    val cached = total_modules - modules_built
    (cached * 100) / total_modules

# Default incremental configuration
fn default_incremental_config() -> IncrementalConfig:
    IncrementalConfig(
        enabled: true,
        cache_dir: "build/rust/ffi_gen/target/incremental",
        track_deps: true,
        verify_hash: true,
        max_cache_size_mb: 1024
    )

# Print incremental result
fn print_incremental_result(result: IncrementalResult):
    print ""
    print "=========================================="
    print "Incremental Build Result"
    print "=========================================="
    print ""
    print result.summary()
    print ""
    print "Statistics:"
    print "  Modules built:   {result.modules_built}"
    print "  Modules cached:  {result.modules_cached}"
    print "  Modules skipped: {result.modules_skipped}"
    print "  Duration:        {result.duration_ms}ms"

    if result.modules_cached > 0:
        val total = result.modules_built + result.modules_cached
        val saved_pct = (result.modules_cached * 100) / total
        print ""
        print "Time saved by caching: ~{saved_pct}%"
