# Database Health Check - CLI Command
#
# Checks all SDN databases for common issues:
# - Missing/corrupt files
# - Duplicate primary keys
# - Invalid column values
# - Orphaned references
# - Stale running entries
#
# Usage:
#   simple check-dbs              # Check all databases
#   simple check-dbs --db=bug     # Check specific database
#   simple check-dbs --verbose    # Show all checks (not just failures)
#   simple check-dbs --json       # JSON output

use app.cli_util.{get_cli_args}
use lib.database.checker.{DbIssue, DbCheckReport, check_sdn_parse,
    count_by_severity, format_issue}
use lib.database.bug.{load_bug_database, BugDatabase}
use lib.database.feature.{load_feature_database, FeatureDatabase}
use lib.database.test.{load_test_database, TestDatabase}
use lib.database.todo.{load_todo_database, TodoDatabase}

# Direct extern declarations for bootstrap runtime compatibility
extern fn rt_file_exists(path: text) -> bool
fn file_exists(path: text) -> bool:
    rt_file_exists(path)

# ============================================================================
# Database Registry
# ============================================================================

struct DbEntry:
    name: text
    path: text

fn get_db_entries() -> [DbEntry]:
    [
        DbEntry(name: "bug", path: "doc/bug/bug_db.sdn"),
        DbEntry(name: "feature", path: "doc/feature/feature_db.sdn"),
        DbEntry(name: "test", path: "doc/test/test_db.sdn"),
        DbEntry(name: "todo", path: "doc/todo/todo_db.sdn")
    ]

# ============================================================================
# Check Functions
# ============================================================================

fn check_bug_db(path: text) -> [DbIssue]:
    var issues: [DbIssue] = []

    # File-level checks
    val parse_issues = check_sdn_parse(path, "bug")
    for issue in parse_issues:
        issues.push(issue)
    if parse_issues.len() > 0:
        return issues

    # Load and validate
    val db_opt = load_bug_database(path)
    if not db_opt.?:
        issues.push(DbIssue(
            db_name: "bug",
            severity: "error",
            issue_type: "load_failed",
            message: "Failed to load bug database from {path}",
            auto_fixable: false
        ))
        return issues

    val db = db_opt.unwrap()
    val db_issues = db.validate()
    for issue in db_issues:
        issues.push(issue)

    issues

fn check_feature_db(path: text) -> [DbIssue]:
    var issues: [DbIssue] = []

    val parse_issues = check_sdn_parse(path, "feature")
    for issue in parse_issues:
        issues.push(issue)
    if parse_issues.len() > 0:
        return issues

    val db_opt = load_feature_database(path)
    if not db_opt.?:
        issues.push(DbIssue(
            db_name: "feature",
            severity: "error",
            issue_type: "load_failed",
            message: "Failed to load feature database from {path}",
            auto_fixable: false
        ))
        return issues

    val db = db_opt.unwrap()
    val db_issues = db.validate()
    for issue in db_issues:
        issues.push(issue)

    issues

fn check_test_db(path: text) -> [DbIssue]:
    var issues: [DbIssue] = []

    val parse_issues = check_sdn_parse(path, "test")
    for issue in parse_issues:
        issues.push(issue)
    if parse_issues.len() > 0:
        return issues

    val db_opt = load_test_database(path)
    if not db_opt.?:
        issues.push(DbIssue(
            db_name: "test",
            severity: "error",
            issue_type: "load_failed",
            message: "Failed to load test database from {path}",
            auto_fixable: false
        ))
        return issues

    val db = db_opt.unwrap()
    val db_issues = db.validate()
    for issue in db_issues:
        issues.push(issue)

    issues

fn check_todo_db(path: text) -> [DbIssue]:
    var issues: [DbIssue] = []

    val parse_issues = check_sdn_parse(path, "todo")
    for issue in parse_issues:
        issues.push(issue)
    if parse_issues.len() > 0:
        return issues

    val db_opt = load_todo_database(path)
    if not db_opt.?:
        issues.push(DbIssue(
            db_name: "todo",
            severity: "error",
            issue_type: "load_failed",
            message: "Failed to load todo database from {path}",
            auto_fixable: false
        ))
        return issues

    val db = db_opt.unwrap()
    val db_issues = db.validate()
    for issue in db_issues:
        issues.push(issue)

    issues

fn check_one_db(entry: DbEntry) -> [DbIssue]:
    match entry.name:
        "bug": check_bug_db(entry.path)
        "feature": check_feature_db(entry.path)
        "test": check_test_db(entry.path)
        "todo": check_todo_db(entry.path)
        _: []

# ============================================================================
# Output Formatting
# ============================================================================

fn print_report(all_issues: [DbIssue], verbose: bool):
    val errors = count_by_severity(all_issues, "error")
    val warnings = count_by_severity(all_issues, "warning")
    val infos = count_by_severity(all_issues, "info")

    if all_issues.len() == 0:
        print "All databases healthy. No issues found."
        return

    # Print issues grouped by database
    var current_db = ""
    for issue in all_issues:
        if issue.db_name != current_db:
            current_db = issue.db_name
            print ""
            print "--- {current_db} ---"

        if verbose or issue.severity != "info":
            print "  {format_issue(issue)}"

    # Summary
    print ""
    print "Summary: {errors} error(s), {warnings} warning(s), {infos} info(s)"

fn print_json_report(all_issues: [DbIssue]):
    print "{"
    print "  \"issues\": ["
    var i = 0
    for issue in all_issues:
        val comma = if i < all_issues.len() - 1: "," else: ""
        val fixable_str = if issue.auto_fixable: "true" else: "false"
        print "    {"
        print "      \"db_name\": \"{issue.db_name}\","
        print "      \"severity\": \"{issue.severity}\","
        print "      \"issue_type\": \"{issue.issue_type}\","
        print "      \"message\": \"{issue.message}\","
        print "      \"auto_fixable\": {fixable_str}"
        print "    }{comma}"
        i = i + 1
    print "  ],"
    val errors = count_by_severity(all_issues, "error")
    val warnings = count_by_severity(all_issues, "warning")
    val infos = count_by_severity(all_issues, "info")
    print "  \"summary\": {"
    print "    \"errors\": {errors},"
    print "    \"warnings\": {warnings},"
    print "    \"infos\": {infos},"
    print "    \"total\": {all_issues.len()}"
    print "  }"
    print "}"

# ============================================================================
# Main
# ============================================================================

fn main() -> i64:
    val args = get_cli_args()

    # Parse flags
    var verbose = false
    var json_out = false
    var db_filter = ""

    for arg in args:
        if arg == "--verbose" or arg == "-v":
            verbose = true
        elif arg == "--json":
            json_out = true
        elif arg.starts_with("--db="):
            db_filter = arg[5:]

    val entries = get_db_entries()

    # Collect all issues
    var all_issues: [DbIssue] = []

    for entry in entries:
        if db_filter != "" and entry.name != db_filter:
            continue

        if not json_out:
            print "Checking {entry.name} database ({entry.path})..."

        val issues = check_one_db(entry)
        for issue in issues:
            all_issues.push(issue)

    # Output
    if json_out:
        print_json_report(all_issues)
    else:
        print_report(all_issues, verbose)

    # Exit code
    val errors = count_by_severity(all_issues, "error")
    val warnings = count_by_severity(all_issues, "warning")
    if errors > 0 or warnings > 0:
        return 1
    0
