# Distribution Builder for Rust-Free Packaging
#
# Creates distribution packages that hide Rust implementation:
# - Pre-compiled runtime binaries
# - 100% Simple source code visible
# - Multi-platform support
# - Minimal download size

# Direct extern fn declarations (bootstrap runtime compatibility)
use std.string.{NL}

extern fn rt_process_run(cmd: text, args: [text]) -> (text, text, i64)
extern fn rt_file_exists(path: text) -> bool
extern fn rt_dir_create(path: text) -> bool
extern fn rt_file_read_text(path: text) -> text
extern fn rt_file_write_text(path: text, content: text) -> bool

# ===========================================================================
# Platform Detection
# ===========================================================================

enum Platform:
    LinuxX64
    LinuxArm64
    DarwinX64      # macOS Intel
    DarwinArm64    # macOS Apple Silicon
    WindowsX64
    WindowsArm64

fn Platform__all() -> [Platform]:
    [
        Platform.LinuxX64,
        Platform.LinuxArm64,
        Platform.DarwinX64,
        Platform.DarwinArm64,
        Platform.WindowsX64,
        Platform.WindowsArm64
    ]


impl Platform:
    fn to_string() -> text:
        match self:
            case Platform.LinuxX64: "linux-x86_64"
            case Platform.LinuxArm64: "linux-aarch64"
            case Platform.DarwinX64: "darwin-x86_64"
            case Platform.DarwinArm64: "darwin-arm64"
            case Platform.WindowsX64: "windows-x86_64"
            case Platform.WindowsArm64: "windows-aarch64"
    fn rust_target() -> text:
        match self:
            case Platform.LinuxX64: "x86_64-unknown-linux-gnu"
            case Platform.LinuxArm64: "aarch64-unknown-linux-gnu"
            case Platform.DarwinX64: "x86_64-apple-darwin"
            case Platform.DarwinArm64: "aarch64-apple-darwin"
            case Platform.WindowsX64: "x86_64-pc-windows-msvc"
            case Platform.WindowsArm64: "aarch64-pc-windows-msvc"
    fn binary_extension() -> text:
        match self:
            case Platform.WindowsX64 | Platform.WindowsArm64: ".exe"
            case _: ""
    fn is_windows() -> bool:
        match self:
            case Platform.WindowsX64 | Platform.WindowsArm64: true
            case _: false
    fn is_macos() -> bool:
        match self:
            case Platform.DarwinX64 | Platform.DarwinArm64: true
            case _: false
    fn is_linux() -> bool:
        match self:
            case Platform.LinuxX64 | Platform.LinuxArm64: true
            case _: false
    fn archive_extension() -> text:
        match self:
            case Platform.WindowsX64 | Platform.WindowsArm64: ".zip"
            case _: ".tar.gz"
    fn wrapper_name() -> text:
        match self:
            case Platform.WindowsX64 | Platform.WindowsArm64: "simple.bat"
            case _: "simple"
# ===========================================================================
# Distribution Configuration
# ===========================================================================

struct DistConfig:
    version: text
    output_dir: text
    strip_binaries: bool
    exclude_patterns: [text]  # Patterns to exclude from distribution

fn DistConfig__default() -> DistConfig:
    DistConfig(
        version: "0.5.0",
        output_dir: "dist",
        strip_binaries: true,
        exclude_patterns: [
            "examples/*/data/",
            "examples/*/data/*",
            "*.arrow",
            "*.parquet",
            "*.h5",
            "*.hdf5"
        ]
    )

# ===========================================================================
# Distribution Builder
# ===========================================================================

class DistributionBuilder:
    config: DistConfig

    static fn new(config: DistConfig) -> DistributionBuilder:
        DistributionBuilder(config: config)

    # Build distribution for all platforms
    fn build_all():
        print "======================================"
        print "Simple Distribution Builder"
        print "======================================"
        print "Version: {self.config.version}"
        print ""

        var success_count = 0
        var total_count = 0

        # Build for all platforms
        for platform in Platform__all():
            total_count = total_count + 1
            val result = self.build_platform(platform)
            if result:
                success_count = success_count + 1

        print ""
        print "======================================"
        if success_count == total_count:
            print "Success! All {total_count} distributions created"
        else:
            print "Completed: {success_count}/{total_count} distributions"
        print "======================================"

    # Build distribution for a single platform
    fn build_platform(platform: Platform) -> bool:
        print "Building for {platform.to_string()}..."

        val platform_name = platform.to_string()
        val pkg_dir = "{self.config.output_dir}/simple-{self.config.version}-{platform_name}"

        # Create package structure
        print "  Creating directories..."
        self.create_dirs(pkg_dir)

        # Copy runtime binary
        print "  Copying runtime binary..."
        val binary_ok = self.copy_runtime(platform, pkg_dir)
        if not binary_ok:
            return false

        # Copy Simple sources
        print "  Copying Simple sources..."
        self.copy_sources(pkg_dir)

        # Create wrapper script
        print "  Creating wrapper script..."
        self.create_wrapper(pkg_dir, platform)

        # Create archive
        print "  Creating archive..."
        self.create_archive(platform_name, pkg_dir, platform)

        true

    fn create_dirs(pkg_dir: text):
        # Use mkdir -p to create nested directories
        rt_process_run("mkdir", ["-p", pkg_dir])
        rt_process_run("mkdir", ["-p", "{pkg_dir}/bin"])
        rt_process_run("mkdir", ["-p", "{pkg_dir}/lib"])
        rt_process_run("mkdir", ["-p", "{pkg_dir}/src"])
        rt_process_run("mkdir", ["-p", "{pkg_dir}/examples"])

    fn copy_runtime(platform: Platform, pkg_dir: text) -> bool:
        # Determine runtime binary name
        val runtime_name = "simple{platform.binary_extension()}"
        val dst = "{pkg_dir}/bin/{runtime_name}"

        # Try multiple runtime locations
        val candidates = [
            "bin/release/{runtime_name}",
            "bin/release/simple",
            "release/simple-0.4.0-beta/bin/simple",
            "bin/simple_local"
        ]

        for src in candidates:
            val (stdout, stderr, exit) = rt_process_run("cp", [src, dst])
            if exit == 0:
                return true

        print "    ERROR: No runtime binary found for {platform.to_string()}"
        false

    fn copy_sources(pkg_dir: text):
        # Copy Simple source files only (not Rust!)
        # Use rsync for better control over exclusions

        # Copy src directories (no exclusions needed)
        rt_process_run("cp", ["-r", "src/compiler", "{pkg_dir}/src/"])
        rt_process_run("cp", ["-r", "src/app", "{pkg_dir}/src/"])
        rt_process_run("cp", ["-r", "src/lib", "{pkg_dir}/src/"])
        rt_process_run("cp", ["-r", "lib", "{pkg_dir}/"])

        # Copy examples with exclusions
        self.copy_with_exclusions("examples", "{pkg_dir}/examples")

    fn copy_with_exclusions(src: text, dst: text):
        # Build rsync command with exclusions
        var cmd = "rsync -a"

        # Add exclusion patterns
        cmd = cmd + " --exclude='examples/*/data/'"
        cmd = cmd + " --exclude='examples/*/data/*'"
        cmd = cmd + " --exclude='*.arrow'"
        cmd = cmd + " --exclude='*.parquet'"
        cmd = cmd + " --exclude='*.h5'"
        cmd = cmd + " --exclude='*.hdf5'"

        # Add source and destination
        cmd = cmd + " {src}/ {dst}"

        # Execute rsync via shell
        val (stdout, stderr, exit) = rt_process_run("sh", ["-c", cmd])
        if exit != 0:
            print "    Warning: rsync failed, falling back to cp"
            # Fallback to cp -r if rsync not available
            rt_process_run("cp", ["-r", src, dst])

    fn create_wrapper(pkg_dir: text, platform: Platform):
        if platform.is_windows():
            # Windows batch file wrapper
            var script = "@echo off{NL}"
            script = script + "setlocal{NL}"
            script = script + "set SCRIPT_DIR=%~dp0{NL}"
            script = script + "\"%SCRIPT_DIR%simple.exe\" %*{NL}"
            script = script + "endlocal{NL}"

            rt_file_write_text("{pkg_dir}/bin/simple.bat", script)
        else:
            # Unix shell script wrapper - just ensure executable
            rt_process_run("chmod", ["+x", "{pkg_dir}/bin/simple"])

    fn create_archive(name: text, pkg_dir: text, platform: Platform):
        val pkg_name = "simple-{self.config.version}-{name}"

        if platform.is_windows():
            # Create .zip archive for Windows
            # Use --symlinks to preserve symlinks without following them
            # Use -0 for store-only (no compression) for faster creation
            val archive = "{pkg_name}.zip"
            val (stdout, stderr, exit) = rt_process_run("sh", ["-c", "cd {self.config.output_dir} && zip -0 -r -q --symlinks {archive} {pkg_name}"])
            if exit == 0:
                print "  Archive: {self.config.output_dir}/{archive}"
            else:
                print "  Archive failed: {stderr}"
        else:
            # Create .tar.gz archive for Unix
            val archive = "{self.config.output_dir}/{pkg_name}.tar.gz"
            rt_process_run("tar", ["-czf", archive, "-C", self.config.output_dir, pkg_name])
            print "  Archive: {archive}"

# ===========================================================================
# Main Entry Point
# ===========================================================================

fn main():
    val config = DistConfig__default()
    val builder = DistributionBuilder__new(config)
    builder.build_all()
