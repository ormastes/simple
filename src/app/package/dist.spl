# Distribution Builder for Rust-Free Packaging
#
# Creates distribution packages that hide Rust implementation:
# - Pre-compiled runtime binaries
# - 100% Simple source code visible
# - Multi-platform support
# - Minimal download size

# Direct extern fn declarations (bootstrap runtime compatibility)
extern fn rt_process_run(cmd: text, args: [text]) -> (text, text, i64)
extern fn rt_file_exists(path: text) -> bool
extern fn rt_dir_create(path: text) -> bool
extern fn rt_file_read_text(path: text) -> text
extern fn rt_file_write_text(path: text, content: text) -> bool

# ===========================================================================
# Platform Detection
# ===========================================================================

enum Platform:
    LinuxX64
    LinuxArm64
    DarwinX64      # macOS Intel
    DarwinArm64    # macOS Apple Silicon
    WindowsX64
    WindowsArm64

impl Platform:
    fn to_string() -> text:
        match self:
            case Platform.LinuxX64: "linux-x86_64"
            case Platform.LinuxArm64: "linux-aarch64"
            case Platform.DarwinX64: "darwin-x86_64"
            case Platform.DarwinArm64: "darwin-arm64"
            case Platform.WindowsX64: "windows-x86_64"
            case Platform.WindowsArm64: "windows-aarch64"

    fn rust_target() -> text:
        match self:
            case Platform.LinuxX64: "x86_64-unknown-linux-gnu"
            case Platform.LinuxArm64: "aarch64-unknown-linux-gnu"
            case Platform.DarwinX64: "x86_64-apple-darwin"
            case Platform.DarwinArm64: "aarch64-apple-darwin"
            case Platform.WindowsX64: "x86_64-pc-windows-msvc"
            case Platform.WindowsArm64: "aarch64-pc-windows-msvc"

    fn binary_extension() -> text:
        match self:
            case Platform.WindowsX64 | Platform.WindowsArm64: ".exe"
            case _: ""

    static fn all() -> [Platform]:
        [
            Platform.LinuxX64,
            Platform.LinuxArm64,
            Platform.DarwinX64,
            Platform.DarwinArm64,
            Platform.WindowsX64,
            Platform.WindowsArm64
        ]

# ===========================================================================
# Distribution Configuration
# ===========================================================================

struct DistConfig:
    version: text
    output_dir: text
    strip_binaries: bool

impl DistConfig:
    static fn default() -> DistConfig:
        DistConfig(
            version: "0.5.0",
            output_dir: "dist",
            strip_binaries: true
        )

# ===========================================================================
# Distribution Builder
# ===========================================================================

class DistributionBuilder:
    config: DistConfig

    static fn new(config: DistConfig) -> DistributionBuilder:
        DistributionBuilder(config: config)

    # Build distribution for all platforms
    fn build_all():
        print "======================================"
        print "Simple Distribution Builder"
        print "======================================"
        print "Version: {self.config.version}"
        print ""

        # Build for current platform only (for now)
        val platform = Platform.LinuxX64
        val result = self.build_platform(platform)

        if result:
            print ""
            print "======================================"
            print "Success! Distribution created"
            print "======================================"
        else:
            print ""
            print "======================================"
            print "Failed to create distribution"
            print "======================================"

    # Build distribution for a single platform
    fn build_platform(platform: Platform) -> bool:
        print "Building for {platform.to_string()}..."

        val platform_name = platform.to_string()
        val pkg_dir = "{self.config.output_dir}/simple-{self.config.version}-{platform_name}"

        # Create package structure
        print "  Creating directories..."
        self.create_dirs(pkg_dir)

        # Copy runtime binary
        print "  Copying runtime binary..."
        val binary_ok = self.copy_runtime(platform, pkg_dir)
        if not binary_ok:
            return false

        # Copy Simple sources
        print "  Copying Simple sources..."
        self.copy_sources(pkg_dir)

        # Create wrapper script
        print "  Creating wrapper script..."
        self.create_wrapper(pkg_dir)

        # Create archive
        print "  Creating archive..."
        self.create_archive(platform_name, pkg_dir)

        true

    fn create_dirs(pkg_dir: text):
        rt_dir_create(pkg_dir)
        rt_dir_create("{pkg_dir}/bin")
        rt_dir_create("{pkg_dir}/lib")
        rt_dir_create("{pkg_dir}/src")
        rt_dir_create("{pkg_dir}/examples")

    fn copy_runtime(platform: Platform, pkg_dir: text) -> bool:
        # Try multiple runtime locations
        val candidates = [
            "bin/bootstrap/simple_runtime",
            "release/simple-0.4.0-beta/bin/simple_runtime",
            "bin/simple_runtime_local"
        ]

        for src in candidates:
            print "    Trying: {src}"
            val dst = "{pkg_dir}/bin/simple_runtime"
            val (stdout, stderr, exit) = rt_process_run("cp", [src, dst])
            print "      Exit code: {exit}"
            if stderr != "":
                print "      Error: {stderr}"
            if exit == 0:
                print "    Using runtime: {src}"
                return true

        print "    ERROR: No runtime binary found"
        false

    fn copy_sources(pkg_dir: text):
        # Copy Simple source files only (not Rust!)
        rt_process_run("cp", ["-r", "src/compiler", "{pkg_dir}/src/"])
        rt_process_run("cp", ["-r", "src/app", "{pkg_dir}/src/"])
        rt_process_run("cp", ["-r", "src/lib", "{pkg_dir}/src/"])
        rt_process_run("cp", ["-r", "lib", "{pkg_dir}/"])
        rt_process_run("cp", ["-r", "examples", "{pkg_dir}/"])

    fn create_wrapper(pkg_dir: text):
        # Create wrapper script (multiline concatenation)
        var script = "#!/bin/sh\n"
        script = script + "SCRIPT_DIR=\"$(cd \"$(dirname \"$0\")\" && pwd)\"\n"
        script = script + "exec \"$SCRIPT_DIR/simple_runtime\" \"$@\"\n"

        rt_file_write_text("{pkg_dir}/bin/simple", script)
        rt_process_run("chmod", ["+x", "{pkg_dir}/bin/simple"])

    fn create_archive(name: text, pkg_dir: text):
        val archive = "{self.config.output_dir}/simple-{self.config.version}-{name}.tar.gz"
        rt_process_run("tar", ["-czf", archive, "-C", self.config.output_dir, "simple-{self.config.version}-{name}"])
        print "  Archive: {archive}"

# ===========================================================================
# Main Entry Point
# ===========================================================================

fn main():
    val config = DistConfig.default()
    val builder = DistributionBuilder.new(config)
    builder.build_all()
