# Package Build Logic
# Creates SPK files for distribution

use app.ioimport std.env
use app.ioimport std.package_ffi
use std.log.{error, warn, info}

class PackageBuild:
    static fn run(args: [text]):
        var package_type = "bootstrap"
        var output_path = ""
        var platform = detect_platform()

        # Parse arguments
        for arg in args:
            if arg.starts_with("--type="):
                package_type = arg[7:]
            else if arg.starts_with("--output="):
                output_path = arg[9:]
            else if arg.starts_with("--platform="):
                platform = arg[11:]

        # Validate package type
        if package_type != "bootstrap" and package_type != "full":
            error("package", "Invalid package type '{package_type}'. Must be 'bootstrap' or 'full'.")
            return

        # Generate default output path if not specified
        if output_path == "":
            val version = get_version()
            output_path = "simple-{package_type}-{version}-{platform}.spk"

        info("package", "Building {package_type} package for {platform}...")
        info("package", "Output: {output_path}")

        if package_type == "bootstrap":
            build_bootstrap(output_path, platform)
        else:
            build_full(output_path, platform)

        info("package", "Package built successfully: {output_path}")

fn build_bootstrap(output_path: text, platform: text):
    # Get version
    val version = get_version()

    # Create temporary directory
    val tmp_dir = "/tmp/simple-bootstrap-build"
    dir_remove_all(tmp_dir) if file_exists(tmp_dir)
    dir_create_all(tmp_dir)

    # Create directory structure
    dir_create_all(tmp_dir + "/bin")
    dir_create_all(tmp_dir + "/lib/simple/stdlib")
    dir_create_all(tmp_dir + "/lib/simple/app")

    # Copy runtime binary
    val runtime_src = "rust/target/release-opt/simple"
    val runtime_dst = tmp_dir + "/bin/simple"

    if not file_exists(runtime_src):
        error("package", "Runtime binary not found at {runtime_src}")
        error("package", "Please build with: cd rust && cargo build --profile release-opt")
        return

    fs.copy_file(runtime_src, runtime_dst)
    fs.set_permissions(runtime_dst, 0o755)

    # Copy stdlib files (essential subset)
    val stdlib_files = ["core.spl", "io.spl", "json.spl", "http.spl"]
    for file in stdlib_files:
        val src = "src/std/{file}"
        val dst = tmp_dir + "/lib/simple/stdlib/{file}"
        if file_exists(src):
            fs.copy_file(src, dst)
        else:
            print "Warning: stdlib file not found: {src}"

    # Copy essential apps
    val app_dirs = ["cli", "run", "compile", "check", "repl"]
    for app in app_dirs:
        val src = "src/app/{app}"
        val dst = tmp_dir + "/lib/simple/app/{app}"
        if file_exists(src):
            fs.copy_dir(src, dst)
        else:
            print "Warning: app directory not found: {src}"

    # Generate manifest
    val manifest = PackageManifest.generate_bootstrap(version, platform)

    # Get runtime file info
    val runtime_size = file_size(runtime_dst)
    val runtime_checksum = calculate_checksum(runtime_dst)

    manifest.runtime_size = runtime_size
    manifest.runtime_checksum = runtime_checksum

    # Write manifest
    val manifest_path = tmp_dir + "/manifest.sdn"
    file_write(manifest_path, manifest.to_sdn())

    # Create SPK file using tarball as interim format
    # Proper SPK binary format requires FFI for structured binary packing.
    eprint("[WARNING] Using tar archive as SPK format; proper SPK binary format requires FFI support")
    print "Creating SPK archive..."
    val tar_cmd = "tar -czf {output_path} -C {tmp_dir} ."
    val tar_result = shell(tar_cmd)
    if tar_result.exit_code != 0:
        eprint("[ERROR] Failed to create SPK archive: {tar_result.stderr}")

    # Cleanup
    dir_remove_all(tmp_dir)

fn build_full(output_path: text, platform: text):
    print "Building full package..."

    # Full package is just a tarball of the entire source tree
    val version = get_version()

    val tar_cmd = """
tar -czf {output_path} \
  --exclude='.git' \
  --exclude='rust/target' \
  --exclude='__pycache__' \
  --exclude='*.pyc' \
  --exclude='.DS_Store' \
  --transform='s,^,simple-{version}/,' \
  .
"""

    # process_run(tar_cmd)

fn get_version() -> text:
    # Try to read from VERSION file
    if file_exists("VERSION"):
        return file_read("VERSION").trim()

    # Fallback to Cargo.toml
    if file_exists("rust/driver/Cargo.toml"):
        val content = file_read("rust/driver/Cargo.toml")
        # Simple parsing - look for version = "x.y.z"
        for line in content.split("\n"):
            if line.starts_with("version = "):
                return line.split("\"")[1]

    "0.3.0"  # Fallback

fn calculate_checksum(file_path: text) -> text:
    # Calculate SHA256 checksum via FFI
    package_ffi.calculate_checksum(file_path)
