# Package Manifest Operations
# Parse and generate manifest.sdn files

use app.io.{file_read, shell_output_trimmed}
use package.types.{PackageInfo, Manifest, Dependency, DependencySource, GitRef, Version, VersionConstraint}
use package.semver.{parse_version, parse_constraint}

class PackageManifest:
    name: text
    version: text
    package_type: text  # "bootstrap" or "full"
    platform: text
    build_timestamp: text
    build_profile: text
    build_commit: text
    runtime_binary: text
    runtime_size: i64
    runtime_checksum: text
    stdlib_files: [text]
    app_dirs: [text]

    static fn from_file(path: text) -> PackageManifest:
        val content = file_read(path)
        val parsed_result = parse_manifest_string(content)
        if parsed_result.is_err():
            return PackageManifest.generate_bootstrap("0.0.0", "unknown")
        val parsed = parsed_result.unwrap()

        PackageManifest(
            name: parsed.package.name,
            version: parsed.package.version.to_string(),
            package_type: "full",
            platform: "unknown",
            build_timestamp: "",
            build_profile: "release-opt",
            build_commit: "",
            runtime_binary: "simple",
            runtime_size: 0,
            runtime_checksum: "",
            stdlib_files: [],
            app_dirs: []
        )

    static fn generate_bootstrap(version: text, platform: text) -> PackageManifest:
        PackageManifest(
            name: "simple-bootstrap",
            version: version,
            package_type: "bootstrap",
            platform: platform,
            build_timestamp: current_timestamp(),
            build_profile: "release-opt",
            build_commit: get_git_commit(),
            runtime_binary: "simple",
            runtime_size: 0,  # Will be filled during build
            runtime_checksum: "",  # Will be filled during build
            stdlib_files: ["core.spl", "io.spl", "json.spl", "http.spl"],
            app_dirs: ["cli", "run", "compile", "check", "repl"]
        )

    fn to_sdn() -> text:
        """
package:
  name: {self.name}
  version: {self.version}
  type: {self.package_type}
  platform: {self.platform}

build:
  timestamp: {self.build_timestamp}
  profile: {self.build_profile}
  commit: {self.build_commit}

runtime:
  binary: {self.runtime_binary}
  size: {self.runtime_size}
  checksum: {self.runtime_checksum}

contents:
  stdlib: {format_list(self.stdlib_files)}
  apps: {format_list(self.app_dirs)}

install:
  default_prefix: ~/.local
  system_prefix: /usr/local
  binaries:
    - name: simple
      target: lib/simple/simple
      type: symlink

  paths:
    runtime: lib/simple/
    stdlib: lib/simple/stdlib/
    apps: lib/simple/app/
"""

fn format_list(items: [text]) -> text:
    if items.is_empty():
        return "[]"

    var parts = []
    for item in items:
        parts.push("    " + item + ",")
    "[\n" + parts.join("\n") + "\n  ]"

fn current_timestamp() -> text:
    shell_output_trimmed("date -u +%Y-%m-%dT%H:%M:%SZ", "unknown")

fn get_git_commit() -> text:
    shell_output_trimmed("git rev-parse HEAD 2>/dev/null", "unknown")

# ============================================================================
# Manifest Parsing (for package.sdn format)
# ============================================================================

fn parse_manifest_string(content: text) -> Result<Manifest, text>:
    """Parse a manifest from SDN string

    Expected format:
        package:
          name: myapp
          version: 1.0.0
          description: My app
          authors: [Alice, Bob]
          license: MIT
          repository: https://github.com/user/repo
          homepage: https://example.com

        dependencies:
          http: ^1.0
          json: ~2.0.0

        dev_dependencies:
          test: ^1.0
    """
    var name = ""
    var version_str = ""
    var description: text? = nil
    var authors: [text] = []
    var license: text? = nil
    var repository: text? = nil
    var homepage: text? = nil
    var dependencies: [Dependency] = []
    var dev_dependencies: [Dependency] = []

    var section = ""
    var current_dep_name = ""
    var current_dep_is_dev = false
    var current_dep_version = ""
    var current_dep_git = ""
    var current_dep_path = ""
    var current_dep_ref_type = ""
    var current_dep_ref_value = ""
    var current_dep_optional = false

    val lines = content.split("\n")
    for raw_line in lines:
        val line = raw_line.trim()
        if line == "":
            continue
        val indent = leading_space_count(raw_line)

        # New top-level section.
        if indent == 0 and line.ends_with(":"):
            if current_dep_name != "":
                val dep_result = build_manifest_dependency(
                    current_dep_name, current_dep_version, current_dep_git, current_dep_path,
                    current_dep_ref_type, current_dep_ref_value, current_dep_optional
                )
                if dep_result.is_err():
                    return Err(dep_result.unwrap_err())
                if current_dep_is_dev:
                    dev_dependencies.push(dep_result.unwrap())
                else:
                    dependencies.push(dep_result.unwrap())
                current_dep_name = ""
            section = line.substring(0, line.length - 1)
            continue

        if section == "package":
            val sep = line.find(":")
            if sep < 0:
                continue
            val key = line.substring(0, sep).trim()
            val value = line.substring(sep + 1).trim()
            if key == "name":
                name = value
            elif key == "version":
                version_str = value
            elif key == "description":
                description = Some(value)
            elif key == "authors":
                authors = parse_inline_text_array(value)
            elif key == "license":
                license = Some(value)
            elif key == "repository":
                repository = Some(value)
            elif key == "homepage":
                homepage = Some(value)
            continue

        if section != "dependencies" and section != "dev_dependencies":
            continue

        # Dependency entry line (either inline or start of nested block).
        if indent <= 2 and line.contains(":"):
            if current_dep_name != "":
                val dep_result = build_manifest_dependency(
                    current_dep_name, current_dep_version, current_dep_git, current_dep_path,
                    current_dep_ref_type, current_dep_ref_value, current_dep_optional
                )
                if dep_result.is_err():
                    return Err(dep_result.unwrap_err())
                if current_dep_is_dev:
                    dev_dependencies.push(dep_result.unwrap())
                else:
                    dependencies.push(dep_result.unwrap())
                current_dep_name = ""

            val sep = line.find(":")
            val dep_name = line.substring(0, sep).trim()
            val dep_value = line.substring(sep + 1).trim()
            if dep_value != "":
                val dep_result = build_manifest_dependency(dep_name, dep_value, "", "", "", "", false)
                if dep_result.is_err():
                    return Err(dep_result.unwrap_err())
                if section == "dev_dependencies":
                    dev_dependencies.push(dep_result.unwrap())
                else:
                    dependencies.push(dep_result.unwrap())
            else:
                current_dep_name = dep_name
                current_dep_is_dev = section == "dev_dependencies"
                current_dep_version = ""
                current_dep_git = ""
                current_dep_path = ""
                current_dep_ref_type = ""
                current_dep_ref_value = ""
                current_dep_optional = false
            continue

        # Nested dependency fields.
        if current_dep_name != "" and line.contains(":"):
            val sep = line.find(":")
            val key = line.substring(0, sep).trim()
            val value = line.substring(sep + 1).trim()
            if key == "version":
                current_dep_version = value
            elif key == "git":
                current_dep_git = value
            elif key == "path":
                current_dep_path = value
            elif key == "tag":
                current_dep_ref_type = "tag"
                current_dep_ref_value = value
            elif key == "branch":
                current_dep_ref_type = "branch"
                current_dep_ref_value = value
            elif key == "commit":
                current_dep_ref_type = "commit"
                current_dep_ref_value = value
            elif key == "optional":
                current_dep_optional = value == "true"

    if current_dep_name != "":
        val dep_result = build_manifest_dependency(
            current_dep_name, current_dep_version, current_dep_git, current_dep_path,
            current_dep_ref_type, current_dep_ref_value, current_dep_optional
        )
        if dep_result.is_err():
            return Err(dep_result.unwrap_err())
        if current_dep_is_dev:
            dev_dependencies.push(dep_result.unwrap())
        else:
            dependencies.push(dep_result.unwrap())

    if name == "":
        return Err("Missing required package name")
    if version_str == "":
        return Err("Missing required package version")
    if not is_valid_package_name(name):
        return Err("Invalid package name: {name}")

    val (ver_ok, ver_opt, ver_err) = parse_version(version_str)
    if not ver_ok:
        return Err("Invalid version '{version_str}': {ver_err}")
    val version = ver_opt.unwrap()

    val pkg_info = PackageInfo(
        name: name,
        version: version,
        description: description,
        authors: authors,
        license: license,
        repository: repository,
        homepage: homepage
    )

    Ok(Manifest(
        package: pkg_info,
        dependencies: dependencies,
        dev_dependencies: dev_dependencies
    ))

fn is_valid_package_name(name: text) -> bool:
    if name == "":
        return false
    for ch in name:
        if (ch >= "a" and ch <= "z") or (ch >= "0" and ch <= "9") or ch == "-" or ch == "_":
            pass
        else:
            return false
    true

fn leading_space_count(s: text) -> i64:
    var c = 0
    for ch in s:
        if ch == " ":
            c = c + 1
        else:
            break
    c

fn parse_inline_text_array(raw: text) -> [text]:
    val trimmed = raw.trim()
    if not trimmed.starts_with("[") or not trimmed.ends_with("]"):
        return []
    val inner = trimmed.substring(1, trimmed.length - 1).trim()
    if inner == "":
        return []
    var values: [text] = []
    for part in inner.split(","):
        val value = part.trim()
        if value != "":
            values.push(value)
    values

fn build_manifest_dependency(name: text, version_field: text, git_url: text, path_value: text, ref_type: text, ref_value: text, optional: bool) -> Result<Dependency, text>:
    if path_value != "":
        return Ok(Dependency(
            name: name,
            constraint: VersionConstraint.Any,
            source: DependencySource.Path(path: path_value),
            optional: optional
        ))

    if git_url != "":
        var ref = GitRef.Branch(name: "main")
        if ref_type == "tag":
            ref = GitRef.Tag(name: ref_value)
        elif ref_type == "branch":
            ref = GitRef.Branch(name: ref_value)
        elif ref_type == "commit":
            ref = GitRef.Commit(hash: ref_value)
        return Ok(Dependency(
            name: name,
            constraint: VersionConstraint.Any,
            source: DependencySource.Git(url: git_url, ref: ref),
            optional: optional
        ))

    val version_text = if version_field == "" then "*" else version_field
    val (ok, constraint_opt, err) = parse_constraint(version_text)
    if not ok:
        return Err("Invalid constraint for '{name}': {err}")
    Ok(Dependency(
        name: name,
        constraint: constraint_opt.unwrap(),
        source: DependencySource.Registry,
        optional: optional
    ))

export PackageManifest, parse_manifest_string
