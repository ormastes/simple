# Package Installation Logic
# Extracts and installs SPK packages

use app.ioimport std.env
use app.ioimport std.package_ffi

class PackageInstall:
    static fn run(args: [text]):
        if args.is_empty():
            print "Error: No package file specified"
            print "Usage: simple package install <package.spk> [options]"
            return

        val package_path = args[0]
        val install_args = args[1:]

        if not file_exists(package_path):
            print "Error: Package file not found: {package_path}"
            return

        # Parse installation options
        var is_dry_run = false
        for arg in install_args:
            if arg == "--dry-run":
                is_dry_run = true

        val paths = PackagePaths.from_args(install_args)

        if is_dry_run:
            print "DRY RUN - No files will be modified"

        print "Installing package: {package_path}"
        print "Install prefix: {paths.prefix}"
        print "Platform: {paths.platform}"
        print ""

        # Extract package to temporary directory
        val tmp_dir = "/tmp/simple-install-{process.pid()}"
        dir_create_all(tmp_dir)

        print "Extracting package..."
        val tar_cmd = "tar -xzf {package_path} -C {tmp_dir}"
        # process_run(tar_cmd)

        # Read manifest
        val manifest_path = tmp_dir + "/manifest.sdn"
        if not file_exists(manifest_path):
            print "Error: Invalid package - missing manifest.sdn"
            dir_remove_all(tmp_dir)
            return

        val manifest = PackageManifest.from_file(manifest_path)

        print "Package: {manifest.name} v{manifest.version}"
        print "Type: {manifest.package_type}"
        print "Platform: {manifest.platform}"
        print ""

        # Verify platform compatibility
        if manifest.platform != "all" and manifest.platform != paths.platform:
            print "Warning: Platform mismatch!"
            print "  Package: {manifest.platform}"
            print "  System:  {paths.platform}"
            print ""

        # Create installation directories
        print "Creating directories..."
        create_install_dirs(paths, is_dry_run)

        # Install runtime binary
        print "Installing runtime binary..."
        install_runtime(tmp_dir, paths, is_dry_run)

        # Install stdlib
        print "Installing stdlib..."
        install_stdlib(tmp_dir, paths, is_dry_run)

        # Install apps
        print "Installing apps..."
        install_apps(tmp_dir, paths, is_dry_run)

        # Create symlinks
        print "Creating symlinks..."
        create_symlinks(paths, is_dry_run)

        # Install manifest
        if not is_dry_run:
            fs.copy_file(manifest_path, paths.manifest_path())

        # Configure PATH
        print ""
        print "Installation complete!"
        print ""
        configure_path(paths)

        # Cleanup
        dir_remove_all(tmp_dir)

fn create_install_dirs(paths: PackagePaths, dry_run: bool):
    val dirs = [
        paths.bin_dir(),
        paths.lib_dir(),
        paths.stdlib_dir(),
        paths.app_dir(),
        paths.config_dir(),
        paths.cache_dir()
    ]

    for dir in dirs:
        if dry_run:
            print "  Would create: {dir}"
        else:
            dir_create_all(dir)

fn install_runtime(tmp_dir: text, paths: PackagePaths, dry_run: bool):
    val src = tmp_dir + "/bin/simple_runtime"
    val dst = paths.runtime_path()

    if dry_run:
        print "  Would install: {src} -> {dst}"
    else:
        fs.copy_file(src, dst)
        fs.set_permissions(dst, 0o755)

fn install_stdlib(tmp_dir: text, paths: PackagePaths, dry_run: bool):
    val src_dir = tmp_dir + "/lib/simple/stdlib"

    if not file_exists(src_dir):
        return

    val files = fs.list_files(src_dir)
    for file in files:
        val src = src_dir + "/" + file
        val dst = paths.stdlib_dir() + "/" + file

        if dry_run:
            print "  Would install: {file}"
        else:
            fs.copy_file(src, dst)

fn install_apps(tmp_dir: text, paths: PackagePaths, dry_run: bool):
    val src_dir = tmp_dir + "/lib/simple/app"

    if not file_exists(src_dir):
        return

    val app_dirs = fs.list_dirs(src_dir)
    for app in app_dirs:
        val src = src_dir + "/" + app
        val dst = paths.app_dir() + "/" + app

        if dry_run:
            print "  Would install: {app}/"
        else:
            fs.copy_dir(src, dst)

fn create_symlinks(paths: PackagePaths, dry_run: bool):
    val symlink = paths.bin_dir() + "/simple"
    val target = paths.runtime_path()

    if dry_run:
        print "  Would create symlink: {symlink} -> {target}"
    else:
        # Remove existing symlink if present
        if file_exists(symlink):
            file_delete(symlink)

        fs.create_symlink(target, symlink)

fn configure_path(paths: PackagePaths):
    val bin_dir = paths.bin_dir()

    # Check if bin_dir is already in PATH
    val current_path = env.get("PATH") ?? ""
    if current_path.contains(bin_dir):
        print "PATH is already configured."
        print "You can now run: simple --version"
        return

    # Detect shell
    val shell = env.get("SHELL") ?? ""

    print "To use Simple, add the following to your PATH:"
    print ""
    print "  export PATH=\"{bin_dir}:\$PATH\""
    print ""

    if shell.contains("bash"):
        print "For bash, add to ~/.bashrc or ~/.profile:"
        print "  echo 'export PATH=\"{bin_dir}:\$PATH\"' >> ~/.bashrc"
        print "  source ~/.bashrc"
    else if shell.contains("zsh"):
        print "For zsh, add to ~/.zshrc:"
        print "  echo 'export PATH=\"{bin_dir}:\$PATH\"' >> ~/.zshrc"
        print "  source ~/.zshrc"
    else if shell.contains("fish"):
        print "For fish, run:"
        print "  fish_add_path {bin_dir}"
    else:
        print "Or add it to your shell's configuration file and restart your shell."

    print ""
