# Complete FFI Test - All 11 Functions
# Calls extern functions directly

use app.io
print "Testing All 11 Package FFI Functions"
print "======================================"

var passed = 0
var failed = 0

# Test 1: rt_package_exists
print "\n1. rt_package_exists"
# TODO: Replace direct FFI call with wrapper (package_exists) from app.io or compiler.ffi
val exists_result = rt_package_exists("/tmp")
if exists_result == 1:
    print "   ✓ Works (returns 1 for existing path)"
    passed = passed + 1
else:
    print "   ✗ Failed"
    failed = failed + 1

# Test 2: rt_package_is_dir
print "\n2. rt_package_is_dir"
# TODO: Replace direct FFI call with wrapper (package_is_dir) from app.io or compiler.ffi
val isdir_result = rt_package_is_dir("/tmp")
if isdir_result == 1:
    print "   ✓ Works (returns 1 for directory)"
    passed = passed + 1
else:
    print "   ✗ Failed"
    failed = failed + 1

# Test 3: rt_package_mkdir_all
print "\n3. rt_package_mkdir_all"
val test_dir = "/tmp/ffi-all-test/nested/deep"
# Clean up first
# TODO: Replace direct FFI call with wrapper (package_exists) from app.io or compiler.ffi
if rt_package_exists("/tmp/ffi-all-test") == 1:
    # TODO: Replace direct FFI call with wrapper (package_remove_dir_all) from app.io or compiler.ffi
    rt_package_remove_dir_all("/tmp/ffi-all-test")
# TODO: Replace direct FFI call with wrapper (package_mkdir_all) from app.io or compiler.ffi
val mkdir_result = rt_package_mkdir_all(test_dir)
if mkdir_result == 0:
    print "   ✓ Works (returns 0 on success)"
    passed = passed + 1
else:
    print "   ✗ Failed (returned " + mkdir_result.to_string() + ")"
    failed = failed + 1

# Test 4: rt_package_file_size
print "\n4. rt_package_file_size"
# TODO: Replace direct FFI call with wrapper (package_file_size) from app.io or compiler.ffi
val size = rt_package_file_size("/etc/passwd")
if size > 0:
    print "   ✓ Works (size: " + size.to_string() + " bytes)"
    passed = passed + 1
else:
    print "   ✗ Failed"
    failed = failed + 1

# Test 5: rt_package_copy_file
print "\n5. rt_package_copy_file"
val copy_dest = "/tmp/ffi-all-test/passwd_copy"
# TODO: Replace direct FFI call with wrapper (package_copy_file) from app.io or compiler.ffi
val copy_result = rt_package_copy_file("/etc/passwd", copy_dest)
if copy_result == 0:
    print "   ✓ Works (returns 0 on success)"
    passed = passed + 1
else:
    print "   ✗ Failed"
    failed = failed + 1

# Test 6: rt_package_chmod
print "\n6. rt_package_chmod"
# TODO: Replace direct FFI call with wrapper (package_chmod) from app.io or compiler.ffi
val chmod_result = rt_package_chmod(copy_dest, 0o644)
if chmod_result == 0:
    print "   ✓ Works (returns 0 on success)"
    passed = passed + 1
else:
    print "   ✗ Failed"
    failed = failed + 1

# Test 7: rt_package_sha256
print "\n7. rt_package_sha256"
val checksum = rt_package_sha256(copy_dest)
if checksum.starts_with("sha256:"):
    print "   ✓ Works (checksum format correct)"
    passed = passed + 1
else:
    print "   ✗ Failed (bad format: " + checksum + ")"
    failed = failed + 1

# Test 8: rt_package_create_symlink
print "\n8. rt_package_create_symlink"
val link_path = "/tmp/ffi-all-test/link"
# TODO: Replace direct FFI call with wrapper (package_create_symlink) from app.io or compiler.ffi
val symlink_result = rt_package_create_symlink(copy_dest, link_path)
if symlink_result == 0:
    print "   ✓ Works (returns 0 on success)"
    passed = passed + 1
else:
    print "   ✗ Failed"
    failed = failed + 1

# Test 9: rt_package_create_tarball
print "\n9. rt_package_create_tarball"
val tarball_path = "/tmp/ffi-all-test.tar.gz"
# TODO: Replace direct FFI call with wrapper (package_create_tarball) from app.io or compiler.ffi
val create_tar_result = rt_package_create_tarball("/tmp/ffi-all-test", tarball_path)
if create_tar_result == 0:
    # TODO: Replace direct FFI call with wrapper (package_file_size) from app.io or compiler.ffi
    val tar_size = rt_package_file_size(tarball_path)
    print "   ✓ Works (tarball: " + tar_size.to_string() + " bytes)"
    passed = passed + 1
else:
    print "   ✗ Failed"
    failed = failed + 1

# Test 10: rt_package_extract_tarball
print "\n10. rt_package_extract_tarball"
val extract_dir = "/tmp/ffi-all-test-extract"
# TODO: Replace direct FFI call with wrapper (package_mkdir_all) from app.io or compiler.ffi
rt_package_mkdir_all(extract_dir)
# TODO: Replace direct FFI call with wrapper (package_extract_tarball) from app.io or compiler.ffi
val extract_result = rt_package_extract_tarball(tarball_path, extract_dir)
if extract_result == 0:
    print "   ✓ Works (returns 0 on success)"
    passed = passed + 1
else:
    print "   ✗ Failed"
    failed = failed + 1

# Test 11: rt_package_remove_dir_all
print "\n11. rt_package_remove_dir_all"
# TODO: Replace direct FFI call with wrapper (package_remove_dir_all) from app.io or compiler.ffi
val remove_result = rt_package_remove_dir_all("/tmp/ffi-all-test")
if remove_result == 0:
    # TODO: Replace direct FFI call with wrapper (package_exists) from app.io or compiler.ffi
    if rt_package_exists("/tmp/ffi-all-test") == 0:
        print "   ✓ Works (directory removed)"
        passed = passed + 1
    else:
        print "   ✗ Remove succeeded but dir still exists"
        failed = failed + 1
else:
    print "   ✗ Failed"
    failed = failed + 1

# Cleanup
# TODO: Replace direct FFI call with wrapper (package_remove_dir_all) from app.io or compiler.ffi
rt_package_remove_dir_all(extract_dir)

# Summary
print "\n======================================"
print "Results: " + passed.to_string() + "/11 tests passed"
if failed == 0:
    print "✅ ALL 11 FFI FUNCTIONS WORKING!"
else:
    print "❌ " + failed.to_string() + " tests failed"
print "======================================"
