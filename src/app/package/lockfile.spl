# Lockfile Parser and Generator
# Handles simple.lock file operations

import std.package_ffi

use package.types
use package.semver

# ============================================================================
# Lockfile Parsing
# ============================================================================

fn parse_lockfile_file(path: text) -> Result<Lockfile, text>:
    """Parse a lockfile from disk"""
    if rt_package_exists(path) == 0:
        return Err("Lockfile not found: {path}")

    val content = rt_file_read_text(path)
    if content.is_err():
        return Err("Failed to read lockfile: {path}")

    parse_lockfile_string(content.unwrap())

fn parse_lockfile_string(content: text) -> Result<Lockfile, text>:
    """Parse a lockfile from SDN string"""
    # Parse SDN content
    val sdn = parse_sdn(content)?

    # Parse lockfile version (required)
    val version = sdn.get_int("lockfile_version")?
    if version != 1:
        return Err("Unsupported lockfile version: {version}")

    # Parse generation timestamp (required)
    val generated = sdn.get_string("generated")?

    # Parse packages table
    val packages = parse_packages_table(sdn)?

    Ok(Lockfile(
        version: version,
        generated: generated,
        packages: packages
    ))

fn parse_packages_table(sdn: SdnValue) -> Result<[LockedPackage], text>:
    """Parse the packages table from lockfile"""
    val table = sdn.get_table("packages")?

    var packages = []

    # Each row in the table is a package
    for row in table.rows:
        val pkg = parse_locked_package(row)?
        packages.push(pkg)

    Ok(packages)

fn parse_locked_package(row: SdnTableRow) -> Result<LockedPackage, text>:
    """Parse a single locked package from table row

    Columns: name, version, source, checksum, deps (optional)
    """
    val name = row.get_string("name")?
    val version_str = row.get_string("version")?
    val version = parse_version(version_str)?
    val source = row.get_string("source")?
    val checksum = row.get_string("checksum")?

    # Dependencies are optional
    val dependencies = row.get_string_array_opt("deps").unwrap_or([])

    Ok(LockedPackage(
        name: name,
        version: version,
        source: source,
        checksum: checksum,
        dependencies: dependencies
    ))

# ============================================================================
# Lockfile Generation
# ============================================================================

fn generate_lockfile(resolved: [ResolvedDependency]) -> Lockfile:
    """Generate a lockfile from resolved dependencies"""
    var packages = []

    for dep in resolved:
        val pkg = locked_package_from_resolved(dep)
        packages.push(pkg)

    Lockfile(
        version: 1,
        generated: current_iso8601_timestamp(),
        packages: packages
    )

fn locked_package_from_resolved(dep: ResolvedDependency) -> LockedPackage:
    """Convert resolved dependency to locked package"""
    val source_str = dependency_source_to_string(dep.source)
    val checksum = dep.checksum.unwrap_or("sha256:unknown")

    LockedPackage(
        name: dep.name,
        version: dep.version,
        source: source_str,
        checksum: checksum,
        dependencies: []  # Will be populated by resolver
    )

fn dependency_source_to_string(source: DependencySource) -> text:
    """Convert dependency source to lockfile format"""
    match source:
        DependencySource.Registry:
            "registry"

        DependencySource.Git(url, ref):
            val ref_str = match ref:
                GitRef.Tag(name): "tags/{name}"
                GitRef.Branch(name): "branch/{name}"
                GitRef.Commit(hash): hash

            "git+{url}#{ref_str}"

        DependencySource.Path(path):
            "path+{path}"

# ============================================================================
# Lockfile Serialization
# ============================================================================

fn lockfile_to_string(lockfile: Lockfile) -> text:
    """Serialize lockfile to SDN format"""
    var result = "# Generated by Simple Package Manager\n"
    result = result + "# Do not edit manually\n\n"

    # Metadata
    result = result + "lockfile_version: {lockfile.version}\n"
    result = result + "generated: {lockfile.generated}\n\n"

    # Packages table
    result = result + "packages |name, version, source, checksum, deps|\n"

    for pkg in lockfile.packages:
        val deps_str = format_dependencies_array(pkg.dependencies)
        result = result + "  {pkg.name}, {pkg.version.to_string()}, {pkg.source}, {pkg.checksum}, {deps_str}\n"

    result

fn format_dependencies_array(deps: [text]) -> text:
    """Format dependencies array for table"""
    if deps.is_empty():
        return "[]"

    var result = "["
    for i in 0..deps.length:
        if i > 0:
            result = result + ", "
        result = result + deps[i]
    result = result + "]"
    result

fn write_lockfile(lockfile: Lockfile, path: text) -> Result<(), text>:
    """Write lockfile to disk"""
    val content = lockfile_to_string(lockfile)

    match rt_file_write_text(path, content):
        0: Ok(())
        _: Err("Failed to write lockfile to {path}")

# ============================================================================
# Lockfile Validation
# ============================================================================

fn validate_lockfile(lockfile: Lockfile) -> bool:
    """Validate lockfile integrity

    Checks:
        - All packages have valid checksums
        - All dependency references exist
        - No circular dependencies
    """
    # Check all packages have checksums
    for pkg in lockfile.packages:
        if not validate_checksum(pkg.checksum):
            return false

    # Check all dependency references exist
    for pkg in lockfile.packages:
        for dep_ref in pkg.dependencies:
            val dep_name = extract_package_name_from_ref(dep_ref)
            if not lockfile.has_package(dep_name):
                return false

    true

fn validate_checksum(checksum: text) -> bool:
    """Validate checksum format (must be sha256:hex)"""
    if not checksum.starts_with("sha256:"):
        return false

    # Check length (sha256: + 64 hex chars = 71)
    if checksum.length < 71:
        return false

    true

fn extract_package_name_from_ref(ref: text) -> text:
    """Extract package name from reference like 'http@1.1.0'"""
    val parts = ref.split("@")
    if parts.length > 0:
        parts[0]
    else:
        ref

# ============================================================================
# Lockfile Utilities
# ============================================================================

fn lockfile_path() -> text:
    """Get standard lockfile path for current directory"""
    "./simple.lock"

fn has_lockfile() -> bool:
    """Check if lockfile exists in current directory"""
    rt_package_exists(lockfile_path()) == 1

fn current_iso8601_timestamp() -> text:
    """Get current timestamp in ISO 8601 format"""
    # TODO: Use proper time library when available
    # For now, use FFI function
    val now_micros = rt_time_now_unix_micros()
    format_iso8601_from_micros(now_micros)

fn format_iso8601_from_micros(micros: i64) -> text:
    """Format Unix microseconds as ISO 8601"""
    # Simplified for now - will need proper datetime formatting
    # Format: 2026-02-01T12:34:56Z

    val seconds = micros / 1000000

    # Extract components (simplified)
    val year = rt_timestamp_get_year(micros)
    val month = rt_timestamp_get_month(micros)
    val day = rt_timestamp_get_day(micros)
    val hour = rt_timestamp_get_hour(micros)
    val minute = rt_timestamp_get_minute(micros)
    val second = rt_timestamp_get_second(micros)

    # Format with zero padding
    "{year:04}-{month:02}-{day:02}T{hour:02}:{minute:02}:{second:02}Z"

# ============================================================================
# SDN Helper Types (Placeholder)
# ============================================================================

struct SdnTableRow:
    """Table row from SDN"""
    data: text    # Placeholder

    fn get_string(key: text) -> Result<text, text>:
        Err("Not implemented")

    fn get_string_array_opt(key: text) -> [text]?:
        None

struct SdnTable:
    """Table from SDN"""
    rows: [SdnTableRow]

# Extension to SdnValue for table support
impl SdnValue:
    fn get_int(key: text) -> Result<i64, text>:
        Err("Not implemented")

    fn get_table(key: text) -> Result<SdnTable, text>:
        Err("Not implemented")

# ============================================================================
# Lockfile Comparison (for updates)
# ============================================================================

fn compare_lockfiles(old: Lockfile, new: Lockfile) -> LockfileChanges:
    """Compare two lockfiles to find changes"""
    var added = []
    var removed = []
    var updated = []

    # Find added packages
    for pkg in new.packages:
        if not old.has_package(pkg.name):
            added.push(pkg.name)

    # Find removed packages
    for pkg in old.packages:
        if not new.has_package(pkg.name):
            removed.push(pkg.name)

    # Find updated packages
    for new_pkg in new.packages:
        match old.find_package(new_pkg.name):
            Some(old_pkg):
                if not version_equal(new_pkg.version, old_pkg.version):
                    updated.push((new_pkg.name, old_pkg.version, new_pkg.version))
            None:
                pass  # Already in added list

    LockfileChanges(
        added: added,
        removed: removed,
        updated: updated
    )

struct LockfileChanges:
    """Changes between two lockfiles"""
    added: [text]
    removed: [text]
    updated: [(text, Version, Version)]  # (name, old_version, new_version)

    fn has_changes() -> bool:
        not (self.added.is_empty() and
             self.removed.is_empty() and
             self.updated.is_empty())

    fn summary() -> text:
        var result = ""

        if not self.added.is_empty():
            result = result + "Added {self.added.length} packages\n"

        if not self.removed.is_empty():
            result = result + "Removed {self.removed.length} packages\n"

        if not self.updated.is_empty():
            result = result + "Updated {self.updated.length} packages\n"

        result
