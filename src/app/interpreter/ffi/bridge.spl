# FFI Bridge
#
# Bridge between interpreter and compiled code.

from ..core import {Value, InterpreterError}

export call_native, register_native, NativeFunction, NativeRegistry

# Type alias for native function signature
type NativeFunction = Fn(Array<Value>) -> Result<Value, InterpreterError>

# Registry of native functions
struct NativeRegistry:
    functions: Dict<String, NativeFunction>

impl NativeRegistry:
    static fn new() -> NativeRegistry:
        return NativeRegistry {
            functions: Dict.new()
        }

    fn register(name: String, func: NativeFunction):
        self.functions.set(name, func)

    fn get(name: &str) -> Option<&NativeFunction>:
        return self.functions.get(name)

    fn has(name: &str) -> bool:
        return self.functions.contains_key(name)

# Global native function registry
static mut NATIVE_REGISTRY: Option<NativeRegistry> = nil

# Initialize the registry
fn init_registry():
    unsafe:
        if NATIVE_REGISTRY.is_none():
            NATIVE_REGISTRY = Some(NativeRegistry.new())

# Register a native function
fn register_native(name: String, func: NativeFunction):
    init_registry()
    unsafe:
        if value Some(ref mut registry) = NATIVE_REGISTRY:
            registry.register(name, func)

# Call a native function by name
fn call_native(name: &str, args: Array<Value>) -> Result<Value, InterpreterError>:
    init_registry()
    unsafe:
        if value Some(ref registry) = NATIVE_REGISTRY:
            match registry.get(name):
                case Some(func):
                    return func(args)
                case nil:
                    return Err(InterpreterError.NameError("unknown native: {name}".to_string()))
        else:
            return Err(InterpreterError.RuntimeError("native registry not initialized".to_string()))

# Check if a native function exists
fn has_native(name: &str) -> bool:
    init_registry()
    unsafe:
        if value Some(ref registry) = NATIVE_REGISTRY:
            return registry.has(name)
        return false

# Convert interpreter Value to native representation
fn value_to_native(value: &Value) -> NativeValue:
    match value.data:
        case RuntimeValue.Nil:
            return NativeValue.Null
        case RuntimeValue.Bool(b):
            return NativeValue.Bool(b)
        case RuntimeValue.Int(n):
            return NativeValue.Int(n)
        case RuntimeValue.Float(f):
            return NativeValue.Float(f)
        case RuntimeValue.String(s):
            return NativeValue.String(s.clone())
        case RuntimeValue.Array(arr):
            val native_arr: Array<NativeValue> = arr.iter().map(|v| value_to_native(v)).collect()
            return NativeValue.Array(native_arr)
        case _:
            return NativeValue.Opaque(Box.new(val.clone()))

# Convert native representation back to Value
fn native_to_value(native: NativeValue) -> Value:
    match native:
        case NativeValue.Null:
            return Value.null()
        case NativeValue.Bool(b):
            return Value.bool(b)
        case NativeValue.Int(n):
            return Value.int(n)
        case NativeValue.Float(f):
            return Value.float(f)
        case NativeValue.String(s):
            return Value.string(s)
        case NativeValue.Array(arr):
            val values: Array<Value> = arr.iter().map(|v| native_to_value(v.clone())).collect()
            return Value.array(values)
        case NativeValue.Opaque(value):
            return *val

# Native value representation for FFI
enum NativeValue:
    Null
    Bool(bool)
    Int(i64)
    Float(f64)
    String(String)
    Array(Array<NativeValue>)
    Opaque(Box<Value>)

# Call into compiled Simple module
fn call_compiled_function(module: &str, function: &str, args: Array<Value>) -> Result<Value, InterpreterError>:
    # Load compiled module using extern library loading
    import .extern.{load_library, resolve_symbol}

    # Determine library path based on platform
    val lib_path = get_module_library_path(module)

    # Load the library
    val lib = match load_library(&lib_path):
        case Ok(l): l
        case Err(e): return Err(e)

    # Simple function names are mangled: simple_<module>_<function>
    val symbol_name = "simple_{module}_{function}"

    # Resolve the function symbol
    val symbol = match resolve_symbol(&lib, &symbol_name):
        case Ok(s): s
        case Err(e): return Err(e)

    # Call the function with marshalling
    # Simple ABI: all args passed as u64, returns u64
    return symbol.call(args)

# Get the library path for a compiled Simple module
fn get_module_library_path(module: &str) -> String:
    # Platform-specific library naming
    #[cfg(target_os = "linux")]
    return "lib{module}.so"

    #[cfg(target_os = "macos")]
    return "lib{module}.dylib"

    #[cfg(target_os = "windows")]
    return "{module}.dll"

# Cache of loaded compiled modules
static mut COMPILED_MODULES: Option<Dict<String, ExternLib>> = nil

fn get_or_load_module(module: &str) -> Result<&ExternLib, InterpreterError>:
    import .extern.{load_library, ExternLib}

    unsafe:
        if COMPILED_MODULES.is_none():
            COMPILED_MODULES = Some(Dict.new())

        if value Some(ref mut cache) = COMPILED_MODULES:
            # Check cache first
            if value Some(lib) = cache.get(module):
                return Ok(lib)

            # Load and cache
            val lib_path = get_module_library_path(module)
            match load_library(&lib_path):
                case Ok(lib):
                    cache.set(module.to_string(), lib)
                    return Ok(cache.get(module).unwrap())
                case Err(e):
                    return Err(e)

    return Err(InterpreterError.LoadError("failed to initialize module cache".to_string()))
