# External Library Loading
#
# Dynamic loading of external native libraries.

import ..core.{Value, InterpreterError}

export load_library, resolve_symbol, ExternLib, Symbol

# A loaded external library
struct ExternLib:
    path: String
    handle: RawPtr
    symbols: Dict<String, Symbol>

impl ExternLib:
    fn new(path: &str) -> Result<ExternLib, String>:
        # Load the library
        match dlopen(path):
            case Ok(handle):
                return Ok(ExternLib {
                    path: path.to_string(),
                    handle: handle,
                    symbols: Dict.new()
                })
            case Err(e):
                return Err(e)

    fn close():
        dlclose(self.handle)

    fn get_symbol(name: &str) -> Result<Symbol, String>:
        # Check cache
        if value Some(sym) = self.symbols.get(name):
            return Ok(sym.clone())

        # Resolve symbol
        match dlsym(self.handle, name):
            case Ok(ptr):
                value sym = Symbol { name: name.to_string(), ptr: ptr }
                self.symbols.set(name.to_string(), sym.clone())
                return Ok(sym)
            case Err(e):
                return Err(e)

# A resolved symbol
struct Symbol:
    name: String
    ptr: RawPtr

impl Symbol:
    fn call(args: Array<Value>) -> Result<Value, InterpreterError>:
        # FFI call with argument marshalling
        # Uses platform-specific function pointer calls for common signatures
        # For complex signatures, requires libffi integration

        # Marshal arguments to C types
        var c_args: Array<u64> = []
        for arg in args:
            match marshal_arg(&arg):
                case Ok(value): c_args.push(value)
                case Err(e): return Err(InterpreterError.FFIError(e))

        # Call based on argument count (common cases)
        value result = match c_args.len():
            case 0: call_ffi_0(self.ptr)
            case 1: call_ffi_1(self.ptr, c_args[0])
            case 2: call_ffi_2(self.ptr, c_args[0], c_args[1])
            case 3: call_ffi_3(self.ptr, c_args[0], c_args[1], c_args[2])
            case 4: call_ffi_4(self.ptr, c_args[0], c_args[1], c_args[2], c_args[3])
            case _: return Err(InterpreterError.FFIError(
                "FFI calls with more than 4 arguments require libffi".to_string()
            ))

        # Default: return as integer (caller should know the type)
        return Ok(Value.int(result as i64))

    fn call_with_signature(args: Array<Value>, ret_type: CType, arg_types: Array<CType>) -> Result<Value, InterpreterError>:
        # Full FFI call with type information
        if args.len() != arg_types.len():
            return Err(InterpreterError.FFIError("argument count mismatch".to_string()))

        # Marshal each argument according to its type
        var c_args: Array<u64> = []
        for i in 0..args.len():
            match value_to_c(&args[i], &arg_types[i]):
                case Ok(bytes):
                    # Pack bytes into u64 (little-endian)
                    var value: u64 = 0
                    for j in 0..min(bytes.len(), 8):
                        value = value | ((bytes[j] as u64) << (j * 8))
                    c_args.push(value)
                case Err(e):
                    return Err(InterpreterError.FFIError(e))

        # Call function
        value raw_result = match c_args.len():
            case 0: call_ffi_0(self.ptr)
            case 1: call_ffi_1(self.ptr, c_args[0])
            case 2: call_ffi_2(self.ptr, c_args[0], c_args[1])
            case 3: call_ffi_3(self.ptr, c_args[0], c_args[1], c_args[2])
            case 4: call_ffi_4(self.ptr, c_args[0], c_args[1], c_args[2], c_args[3])
            case _: return Err(InterpreterError.FFIError(
                "FFI calls with more than 4 arguments require libffi".to_string()
            ))

        # Convert result based on return type
        value result_bytes = raw_result.to_le_bytes().to_vec()
        match c_to_value(&result_bytes, &ret_type):
            case Ok(value): return Ok(value)
            case Err(e): return Err(InterpreterError.FFIError(e))

# Marshal a Simple value to a u64 for FFI
fn marshal_arg(value: &Value) -> Result<u64, String>:
    match value.data.clone():
        case RuntimeValue.Nil: return Ok(0u64)
        case RuntimeValue.Bool(b): return Ok(if b: 1u64 else: 0u64)
        case RuntimeValue.Int(n): return Ok(n as u64)
        case RuntimeValue.Float(f):
            # Bit-cast float to u64
            value bits = f.to_bits()
            return Ok(bits)
        case RuntimeValue.String(s):
            # Return pointer to string data (caller must ensure lifetime)
            return Ok(s.as_ptr() as u64)
        case _:
            return Err("cannot marshal complex type to FFI".to_string())

# Platform-specific FFI call trampolines
extern fn call_ffi_0(ptr: RawPtr) -> u64
extern fn call_ffi_1(ptr: RawPtr, a1: u64) -> u64
extern fn call_ffi_2(ptr: RawPtr, a1: u64, a2: u64) -> u64
extern fn call_ffi_3(ptr: RawPtr, a1: u64, a2: u64, a3: u64) -> u64
extern fn call_ffi_4(ptr: RawPtr, a1: u64, a2: u64, a3: u64, a4: u64) -> u64

fn min(a: usize, b: usize) -> usize:
    if a < b: a else: b

# Registry of loaded libraries
static mut EXTERN_LIBS: Option<Dict<String, ExternLib>> = None

fn init_libs():
    unsafe:
        if EXTERN_LIBS.is_none():
            EXTERN_LIBS = Some(Dict.new())

# Load an external library
fn load_library(path: &str) -> Result<ExternLib, InterpreterError>:
    init_libs()

    # Check if already loaded
    unsafe:
        if value Some(ref libs) = EXTERN_LIBS:
            if value Some(lib) = libs.get(path):
                return Ok(lib.clone())

    # Load new library
    match ExternLib.new(path):
        case Ok(lib):
            unsafe:
                if value Some(ref mut libs) = EXTERN_LIBS:
                    libs.set(path.to_string(), lib.clone())
            return Ok(lib)
        case Err(e):
            return Err(InterpreterError.LoadError(e))

# Resolve a symbol from a library
fn resolve_symbol(lib: &ExternLib, name: &str) -> Result<Symbol, InterpreterError>:
    match lib.get_symbol(name):
        case Ok(sym):
            return Ok(sym)
        case Err(e):
            return Err(InterpreterError.SymbolError(e))

# Unload a library
fn unload_library(path: &str):
    unsafe:
        if value Some(ref mut libs) = EXTERN_LIBS:
            if value Some(lib) = libs.remove(path):
                lib.close()

# Platform-specific dynamic loading
#[cfg(target_os = "linux")]
extern fn dlopen(path: &str) -> Result<RawPtr, String>
extern fn dlclose(handle: RawPtr)
extern fn dlsym(handle: RawPtr, name: &str) -> Result<RawPtr, String>

#[cfg(target_os = "macos")]
extern fn dlopen(path: &str) -> Result<RawPtr, String>
extern fn dlclose(handle: RawPtr)
extern fn dlsym(handle: RawPtr, name: &str) -> Result<RawPtr, String>

#[cfg(target_os = "windows")]
extern fn LoadLibraryA(path: &str) -> Result<RawPtr, String>
extern fn FreeLibrary(handle: RawPtr)
extern fn GetProcAddress(handle: RawPtr, name: &str) -> Result<RawPtr, String>

# Windows compatibility shims
#[cfg(target_os = "windows")]
fn dlopen(path: &str) -> Result<RawPtr, String>:
    return LoadLibraryA(path)

#[cfg(target_os = "windows")]
fn dlclose(handle: RawPtr):
    FreeLibrary(handle)

#[cfg(target_os = "windows")]
fn dlsym(handle: RawPtr, name: &str) -> Result<RawPtr, String>:
    return GetProcAddress(handle, name)

# Type definitions for FFI
type RawPtr = u64  # Or platform-appropriate size

# C type mappings
enum CType:
    Void
    Bool
    Char
    Short
    Int
    Long
    LongLong
    Float
    Double
    Pointer(Box<CType>)
    Array(Box<CType>, usize)
    Struct(Array<(String, CType)>)

# Convert Simple value to C type
fn value_to_c(value: &Value, ctype: &CType) -> Result<Array<u8>, String>:
    match (val.data.clone(), ctype):
        case (RuntimeValue.Bool(b), CType.Bool):
            return Ok([if b: 1u8 else: 0u8])

        case (RuntimeValue.Int(n), CType.Char):
            return Ok([(n as u8)])

        case (RuntimeValue.Int(n), CType.Short):
            value bytes = (n as i16).to_le_bytes()
            return Ok(bytes.to_vec())

        case (RuntimeValue.Int(n), CType.Int):
            value bytes = (n as i32).to_le_bytes()
            return Ok(bytes.to_vec())

        case (RuntimeValue.Int(n), CType.Long):
            value bytes = (n as i64).to_le_bytes()
            return Ok(bytes.to_vec())

        case (RuntimeValue.Int(n), CType.LongLong):
            value bytes = (n as i64).to_le_bytes()
            return Ok(bytes.to_vec())

        case (RuntimeValue.Float(f), CType.Float):
            value bytes = (f as f32).to_le_bytes()
            return Ok(bytes.to_vec())

        case (RuntimeValue.Float(f), CType.Double):
            value bytes = f.to_le_bytes()
            return Ok(bytes.to_vec())

        case (RuntimeValue.Int(n), CType.Pointer(_)):
            value bytes = (n as u64).to_le_bytes()
            return Ok(bytes.to_vec())

        case (RuntimeValue.Nil, CType.Pointer(_)):
            value bytes = 0u64.to_le_bytes()
            return Ok(bytes.to_vec())

        case _:
            return Err("cannot convert value to C type".to_string())

# Convert C data to Simple value
fn c_to_value(data: &Array<u8>, ctype: &CType) -> Result<Value, String>:
    match ctype:
        case CType.Void:
            return Ok(Value.null())

        case CType.Bool:
            if data.len() < 1:
                return Err("insufficient data for bool".to_string())
            return Ok(Value.bool(data[0] != 0))

        case CType.Char:
            if data.len() < 1:
                return Err("insufficient data for char".to_string())
            return Ok(Value.int(data[0] as i64))

        case CType.Short:
            if data.len() < 2:
                return Err("insufficient data for short".to_string())
            value bytes: [u8; 2] = [data[0], data[1]]
            value n = i16.from_le_bytes(bytes)
            return Ok(Value.int(n as i64))

        case CType.Int:
            if data.len() < 4:
                return Err("insufficient data for int".to_string())
            value bytes: [u8; 4] = [data[0], data[1], data[2], data[3]]
            value n = i32.from_le_bytes(bytes)
            return Ok(Value.int(n as i64))

        case CType.Long:
            if data.len() < 8:
                return Err("insufficient data for long".to_string())
            value bytes: [u8; 8] = [data[0], data[1], data[2], data[3], data[4], data[5], data[6], data[7]]
            value n = i64.from_le_bytes(bytes)
            return Ok(Value.int(n))

        case CType.LongLong:
            if data.len() < 8:
                return Err("insufficient data for long long".to_string())
            value bytes: [u8; 8] = [data[0], data[1], data[2], data[3], data[4], data[5], data[6], data[7]]
            value n = i64.from_le_bytes(bytes)
            return Ok(Value.int(n))

        case CType.Float:
            if data.len() < 4:
                return Err("insufficient data for float".to_string())
            value bytes: [u8; 4] = [data[0], data[1], data[2], data[3]]
            value f = f32.from_le_bytes(bytes)
            return Ok(Value.float(f as f64))

        case CType.Double:
            if data.len() < 8:
                return Err("insufficient data for double".to_string())
            value bytes: [u8; 8] = [data[0], data[1], data[2], data[3], data[4], data[5], data[6], data[7]]
            value f = f64.from_le_bytes(bytes)
            return Ok(Value.float(f))

        case CType.Pointer(_):
            if data.len() < 8:
                return Err("insufficient data for pointer".to_string())
            value bytes: [u8; 8] = [data[0], data[1], data[2], data[3], data[4], data[5], data[6], data[7]]
            value ptr = u64.from_le_bytes(bytes)
            return Ok(Value.int(ptr as i64))

        case _:
            return Err("cannot convert C type to value".to_string())
