# Vertical Slice: Expression Evaluator via FFI
#
# Validates the Phase 0 FFI design by evaluating simple expressions
# (integer literals, binary arithmetic) using opaque AST handles.
# This is a proof-of-concept, not a full evaluator.

from ast_ffi import {
    rt_ast_expr_tag,
    rt_ast_expr_int_value, rt_ast_expr_float_value,
    rt_ast_expr_string_value, rt_ast_expr_bool_value,
    rt_ast_expr_ident_name,
    rt_ast_expr_binary_op, rt_ast_expr_binary_left, rt_ast_expr_binary_right,
    rt_ast_expr_unary_op, rt_ast_expr_unary_operand,
    rt_ast_expr_free
}
from env_ffi import {rt_env_get_var}
from error_ffi import {
    rt_error_semantic, rt_error_type_mismatch,
    rt_error_division_by_zero, rt_error_throw
}

export eval_expr_simple

# Result type for evaluation
enum EvalResult:
    IntVal(i64)
    FloatVal(f64)
    StringVal(text)
    BoolVal(bool)
    NilVal

# Evaluate an expression given an AST handle and an env handle.
# Supports: Integer, Float, String, Bool, Nil, Identifier, Binary, Unary
fn eval_expr_simple(expr_handle: i64, env_handle: i64) -> EvalResult:
    # TODO: Replace direct FFI call with wrapper (ast_expr_tag) from app.io or compiler.ffi
    val tag = rt_ast_expr_tag(expr_handle)

    match tag:
        case "Integer":
            # TODO: Replace direct FFI call with wrapper (ast_expr_int_value) from app.io or compiler.ffi
            val v = rt_ast_expr_int_value(expr_handle)
            EvalResult.IntVal(v)

        case "Float":
            # TODO: Replace direct FFI call with wrapper (ast_expr_float_value) from app.io or compiler.ffi
            val v = rt_ast_expr_float_value(expr_handle)
            EvalResult.FloatVal(v)

        case "String":
            # TODO: Replace direct FFI call with wrapper (ast_expr_string_value) from app.io or compiler.ffi
            val v = rt_ast_expr_string_value(expr_handle)
            EvalResult.StringVal(v)

        case "Bool":
            # TODO: Replace direct FFI call with wrapper (ast_expr_bool_value) from app.io or compiler.ffi
            val v = rt_ast_expr_bool_value(expr_handle)
            EvalResult.BoolVal(v)

        case "Nil":
            EvalResult.NilVal

        case "Identifier":
            # TODO: Replace direct FFI call with wrapper (ast_expr_ident_name) from app.io or compiler.ffi
            val name = rt_ast_expr_ident_name(expr_handle)
            # TODO: Replace direct FFI call with wrapper (env_get_var) from app.io or compiler.ffi
            val v = rt_env_get_var(env_handle, name)
            # Return the value from environment
            # For now, treat as int (vertical slice limitation)
            if v is i64:
                EvalResult.IntVal(v)
            elif v is f64:
                EvalResult.FloatVal(v)
            elif v is text:
                EvalResult.StringVal(v)
            elif v is bool:
                EvalResult.BoolVal(v)
            else:
                EvalResult.NilVal

        case "Binary":
            # TODO: Replace direct FFI call with wrapper (ast_expr_binary_op) from app.io or compiler.ffi
            val op = rt_ast_expr_binary_op(expr_handle)
            # TODO: Replace direct FFI call with wrapper (ast_expr_binary_left) from app.io or compiler.ffi
            val left_handle = rt_ast_expr_binary_left(expr_handle)
            # TODO: Replace direct FFI call with wrapper (ast_expr_binary_right) from app.io or compiler.ffi
            val right_handle = rt_ast_expr_binary_right(expr_handle)

            val left = eval_expr_simple(left_handle, env_handle)
            val right = eval_expr_simple(right_handle, env_handle)

            # Free child handles after evaluation
            # TODO: Replace direct FFI call with wrapper (ast_expr_free) from app.io or compiler.ffi
            rt_ast_expr_free(left_handle)
            # TODO: Replace direct FFI call with wrapper (ast_expr_free) from app.io or compiler.ffi
            rt_ast_expr_free(right_handle)

            eval_binary(op, left, right)

        case "Unary":
            # TODO: Replace direct FFI call with wrapper (ast_expr_unary_op) from app.io or compiler.ffi
            val op = rt_ast_expr_unary_op(expr_handle)
            # TODO: Replace direct FFI call with wrapper (ast_expr_unary_operand) from app.io or compiler.ffi
            val operand_handle = rt_ast_expr_unary_operand(expr_handle)
            val operand = eval_expr_simple(operand_handle, env_handle)
            # TODO: Replace direct FFI call with wrapper (ast_expr_free) from app.io or compiler.ffi
            rt_ast_expr_free(operand_handle)
            eval_unary(op, operand)

        case _:
            # TODO: Replace direct FFI call with wrapper (error_semantic) from app.io or compiler.ffi
            val err = rt_error_semantic("eval_expr_simple: unsupported expression tag: {tag}")
            # TODO: Replace direct FFI call with wrapper (error_throw) from app.io or compiler.ffi
            rt_error_throw(err)
            EvalResult.NilVal  # unreachable

# Evaluate a binary operation on two evaluated values
fn eval_binary(op: text, left: EvalResult, right: EvalResult) -> EvalResult:
    match (left, right):
        case (EvalResult.IntVal(l), EvalResult.IntVal(r)):
            match op:
                case "+": EvalResult.IntVal(l + r)
                case "-": EvalResult.IntVal(l - r)
                case "*": EvalResult.IntVal(l * r)
                case "/":
                    if r == 0:
                        # TODO: Replace direct FFI call with wrapper (error_division_by_zero) from app.io or compiler.ffi
                        val err = rt_error_division_by_zero()
                        # TODO: Replace direct FFI call with wrapper (error_throw) from app.io or compiler.ffi
                        rt_error_throw(err)
                        EvalResult.NilVal  # unreachable
                    else:
                        EvalResult.IntVal(l / r)
                case "%":
                    if r == 0:
                        # TODO: Replace direct FFI call with wrapper (error_division_by_zero) from app.io or compiler.ffi
                        val err = rt_error_division_by_zero()
                        # TODO: Replace direct FFI call with wrapper (error_throw) from app.io or compiler.ffi
                        rt_error_throw(err)
                        EvalResult.NilVal
                    else:
                        EvalResult.IntVal(l % r)
                case "**": EvalResult.IntVal(pow(l, r))
                case "==": EvalResult.BoolVal(l == r)
                case "!=": EvalResult.BoolVal(l != r)
                case "<": EvalResult.BoolVal(l < r)
                case ">": EvalResult.BoolVal(l > r)
                case "<=": EvalResult.BoolVal(l <= r)
                case ">=": EvalResult.BoolVal(l >= r)
                case _:
                    # TODO: Replace direct FFI call with wrapper (error_semantic) from app.io or compiler.ffi
                    val err = rt_error_semantic("unsupported binary op for integers: {op}")
                    # TODO: Replace direct FFI call with wrapper (error_throw) from app.io or compiler.ffi
                    rt_error_throw(err)
                    EvalResult.NilVal

        case (EvalResult.FloatVal(l), EvalResult.FloatVal(r)):
            match op:
                case "+": EvalResult.FloatVal(l + r)
                case "-": EvalResult.FloatVal(l - r)
                case "*": EvalResult.FloatVal(l * r)
                case "/": EvalResult.FloatVal(l / r)
                case "==": EvalResult.BoolVal(l == r)
                case "!=": EvalResult.BoolVal(l != r)
                case "<": EvalResult.BoolVal(l < r)
                case ">": EvalResult.BoolVal(l > r)
                case _:
                    # TODO: Replace direct FFI call with wrapper (error_semantic) from app.io or compiler.ffi
                    val err = rt_error_semantic("unsupported binary op for floats: {op}")
                    # TODO: Replace direct FFI call with wrapper (error_throw) from app.io or compiler.ffi
                    rt_error_throw(err)
                    EvalResult.NilVal

        case (EvalResult.StringVal(l), EvalResult.StringVal(r)):
            match op:
                case "+": EvalResult.StringVal(l + r)
                case "==": EvalResult.BoolVal(l == r)
                case "!=": EvalResult.BoolVal(l != r)
                case _:
                    # TODO: Replace direct FFI call with wrapper (error_semantic) from app.io or compiler.ffi
                    val err = rt_error_semantic("unsupported binary op for strings: {op}")
                    # TODO: Replace direct FFI call with wrapper (error_throw) from app.io or compiler.ffi
                    rt_error_throw(err)
                    EvalResult.NilVal

        case (EvalResult.BoolVal(l), EvalResult.BoolVal(r)):
            match op:
                case "and": EvalResult.BoolVal(l and r)
                case "or": EvalResult.BoolVal(l or r)
                case "==": EvalResult.BoolVal(l == r)
                case "!=": EvalResult.BoolVal(l != r)
                case _:
                    # TODO: Replace direct FFI call with wrapper (error_semantic) from app.io or compiler.ffi
                    val err = rt_error_semantic("unsupported binary op for bools: {op}")
                    # TODO: Replace direct FFI call with wrapper (error_throw) from app.io or compiler.ffi
                    rt_error_throw(err)
                    EvalResult.NilVal

        case _:
            # TODO: Replace direct FFI call with wrapper (error_type_mismatch) from app.io or compiler.ffi
            val err = rt_error_type_mismatch("binary op type mismatch for op: {op}")
            # TODO: Replace direct FFI call with wrapper (error_throw) from app.io or compiler.ffi
            rt_error_throw(err)
            EvalResult.NilVal

# Evaluate a unary operation
fn eval_unary(op: text, operand: EvalResult) -> EvalResult:
    match (op, operand):
        case ("-", EvalResult.IntVal(v)):
            EvalResult.IntVal(-v)
        case ("-", EvalResult.FloatVal(v)):
            EvalResult.FloatVal(-v)
        case ("not", EvalResult.BoolVal(v)):
            EvalResult.BoolVal(not v)
        case _:
            # TODO: Replace direct FFI call with wrapper (error_type_mismatch) from app.io or compiler.ffi
            val err = rt_error_type_mismatch("unsupported unary op: {op}")
            # TODO: Replace direct FFI call with wrapper (error_throw) from app.io or compiler.ffi
            rt_error_throw(err)
            EvalResult.NilVal
