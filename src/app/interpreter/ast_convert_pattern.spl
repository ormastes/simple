# AST Pattern and Literal Conversion
#
# Shared conversion functions for patterns and literals.
# Extracted to avoid circular dependencies between stmt and expr modules.

import parser.treesitter.tree.{Tree, Node, NodeId, NodeArena}
import interpreter.ast_types.*

# =============================================================================
# Literal Conversion
# =============================================================================

fn convert_literal(tree: &Tree, node: Node) -> Result<Literal, String>:
    match node.kind:
        case "integer":
            match i64.parse(node.text):
                case Ok(n): return Ok(Literal.Int(n))
                case Err(_): return Err("Invalid integer")
        case "float":
            match f64.parse(node.text):
                case Ok(f): return Ok(Literal.Float(f))
                case Err(_): return Err("Invalid float")
        case "string":
            return Ok(Literal.String(unescape_string(node.text)))
        case "boolean" | "true":
            return Ok(Literal.Bool(true))
        case "false":
            return Ok(Literal.Bool(false))
        case "nil" | "none":
            return Ok(Literal.Nil)
        case _:
            return Err("Unknown literal kind: {node.kind}")

# =============================================================================
# Pattern Conversion
# =============================================================================

fn convert_pattern(tree: &Tree, node: Node) -> Result<Pattern, String>:
    match node.kind:
        case "wildcard" | "_":
            return Ok(Pattern.Wildcard)
        case "identifier":
            return Ok(Pattern.Identifier(node.text.clone()))
        case "literal":
            match convert_literal(tree, node):
                case Ok(lit): return Ok(Pattern.Literal(lit))
                case Err(e): return Err(e)
        case "integer" | "float" | "string" | "boolean" | "nil":
            match convert_literal(tree, node):
                case Ok(lit): return Ok(Pattern.Literal(lit))
                case Err(e): return Err(e)
        case "tuple_pattern":
            var patterns: Array<Pattern> = []
            for child_id in node.children:
                match tree.get_node(child_id):
                    case Some(child):
                        match convert_pattern(tree, child):
                            case Ok(p): patterns.push(p)
                            case Err(_): pass
                    case nil: pass
            return Ok(Pattern.Tuple(patterns))
        case "struct_pattern":
            return convert_struct_pattern(tree, node)
        case "enum_pattern":
            return convert_enum_pattern(tree, node)
        case _:
            # Default to identifier pattern
            return Ok(Pattern.Identifier(node.text.clone()))

fn convert_struct_pattern(tree: &Tree, node: Node) -> Result<Pattern, String>:
    var name = ""
    var fields: Array<(String, Pattern)> = []

    for child_id in node.children:
        match tree.get_node(child_id):
            case Some(child):
                match child.kind:
                    case "type_identifier":
                        name = child.text.clone()
                    case "field_pattern":
                        match convert_field_pattern(tree, child):
                            case Ok(fp): fields.push(fp)
                            case Err(_): pass
            case nil: pass

    return Ok(Pattern.Struct {
        name: name,
        fields: fields
    })

fn convert_field_pattern(tree: &Tree, node: Node) -> Result<(String, Pattern), String>:
    var name = ""
    var pattern: Option<Pattern> = nil

    for child_id in node.children:
        match tree.get_node(child_id):
            case Some(child):
                match child.kind:
                    case "identifier":
                        if name.is_empty():
                            name = child.text.clone()
                        else:
                            pattern = Some(Pattern.Identifier(child.text.clone()))
                    case _:
                        match convert_pattern(tree, child):
                            case Ok(p): pattern = Some(p)
                            case Err(_): pass
            case nil: pass

    match pattern:
        case Some(p): return Ok((name, p))
        case nil: return Ok((name.clone(), Pattern.Identifier(name)))

fn convert_enum_pattern(tree: &Tree, node: Node) -> Result<Pattern, String>:
    var variant = ""
    var data: Option<Box<Pattern>> = nil

    for child_id in node.children:
        match tree.get_node(child_id):
            case Some(child):
                match child.kind:
                    case "identifier" | "variant_name":
                        variant = child.text.clone()
                    case _:
                        match convert_pattern(tree, child):
                            case Ok(p): data = Some(Box.new(p))
                            case Err(_): pass
            case nil: pass

    return Ok(Pattern.Enum {
        variant: variant,
        data: data
    })

# =============================================================================
# Utility Functions
# =============================================================================

fn unescape_string(s: String) -> String:
    # Remove surrounding quotes and unescape
    var result = s
    if result.starts_with("\"") and result.ends_with("\""):
        result = result.slice(1, result.len() - 1)
    elif result.starts_with("'") and result.ends_with("'"):
        result = result.slice(1, result.len() - 1)

    # Unescape common sequences
    result = result.replace("\\n", "\n")
    result = result.replace("\\t", "\t")
    result = result.replace("\\r", "\r")
    result = result.replace("\\\\", "\\")
    result = result.replace("\\\"", "\"")
    result = result.replace("\\'", "'")

    return result

# =============================================================================
# Exports
# =============================================================================

export convert_literal
export convert_pattern, convert_struct_pattern, convert_field_pattern, convert_enum_pattern
export unescape_string
