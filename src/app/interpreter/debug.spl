# Debugger Infrastructure
#
# Interactive debugger for Simple language interpreter.
# Supports breakpoints, stepping, stack inspection, and watch expressions.

export DebugLevel, StepMode, Breakpoint, StackFrame, Debugger
export debugger_create, debugger_should_break

# ============================================================================
# Debug Level
# ============================================================================

enum DebugLevel:
    Off
    Error
    Warn
    Info
    Debug
    Trace

# ============================================================================
# Step Mode
# ============================================================================

enum StepMode:
    Continue      # Run until next breakpoint
    StepOver     # Execute next statement, skip into functions
    StepInto     # Execute next statement, enter functions
    StepOut      # Run until current function returns

# ============================================================================
# Breakpoint
# ============================================================================

struct Breakpoint:
    file: text
    line: i64
    enabled: bool
    condition: text?  # Optional condition expression
    hit_count: i64

impl Breakpoint:
    static fn new(file: text, line: i64) -> Breakpoint:
        Breakpoint(file: file, line: line, enabled: true, condition: nil, hit_count: 0)

# ============================================================================
# Stack Frame
# ============================================================================

struct StackFrame:
    function_name: text
    file: text
    line: i64
    locals: {text: Any}  # Local variables

impl StackFrame:
    static fn new(function_name: text, file: text, line: i64) -> StackFrame:
        StackFrame(function_name: function_name, file: file, line: line, locals: {})

# ============================================================================
# Debugger
# ============================================================================

class Debugger:
    """Interactive debugger for Simple interpreter.

    Features:
    - Breakpoints with optional conditions
    - Step over/into/out
    - Stack frame inspection
    - Watch expressions
    - Variable inspection
    """
    level: DebugLevel
    breakpoints: [Breakpoint]
    stack: [StackFrame]
    step_mode: StepMode
    step_target_depth: i64
    watches: [(text, text)]  # (name, expression)
    enabled: bool

impl Debugger:
    static fn new() -> Debugger:
        """Create a new debugger instance."""
        Debugger(
            level: DebugLevel.Info,
            breakpoints: [],
            stack: [],
            step_mode: StepMode.Continue,
            step_target_depth: -1,
            watches: [],
            enabled: false
        )

    me enable():
        """Enable debugger."""
        self.enabled = true

    me disable():
        """Disable debugger."""
        self.enabled = false

    fn is_enabled() -> bool:
        """Check if debugger is enabled."""
        self.enabled

    # ========================================================================
    # Breakpoints
    # ========================================================================

    me add_breakpoint(file: text, line: i64) -> i64:
        """Add a breakpoint. Returns breakpoint index."""
        val bp = Breakpoint.new(file, line)
        self.breakpoints.push(bp)
        self.breakpoints.len() - 1

    me remove_breakpoint(idx: i64) -> bool:
        """Remove a breakpoint by index."""
        if idx >= 0 and idx < self.breakpoints.len():
            var new_bps: [Breakpoint] = []
            for i in 0..self.breakpoints.len():
                if i != idx:
                    new_bps.push(self.breakpoints[i])
            self.breakpoints = new_bps
            true
        else:
            false

    me toggle_breakpoint(idx: i64):
        """Toggle breakpoint enabled/disabled."""
        if idx >= 0 and idx < self.breakpoints.len():
            val bp = self.breakpoints[idx]
            self.breakpoints[idx] = Breakpoint(
                file: bp.file,
                line: bp.line,
                enabled: not bp.enabled,
                condition: bp.condition,
                hit_count: bp.hit_count
            )

    fn has_breakpoint(file: text, line: i64) -> bool:
        """Check if there's an enabled breakpoint at location."""
        for bp in self.breakpoints:
            if bp.file == file and bp.line == line and bp.enabled:
                return true
        false

    fn list_breakpoints() -> [Breakpoint]:
        """Get all breakpoints."""
        self.breakpoints

    # ========================================================================
    # Stack Management
    # ========================================================================

    me push_frame(function_name: text, file: text, line: i64):
        """Push a new stack frame."""
        val frame = StackFrame.new(function_name, file, line)
        self.stack.push(frame)

    me pop_frame():
        """Pop the top stack frame."""
        if self.stack.?:
            self.stack = self.stack[0:self.stack.len()-1]

    fn get_stack_trace() -> [StackFrame]:
        """Get the current stack trace."""
        self.stack

    fn current_frame() -> StackFrame?:
        """Get the current (top) stack frame."""
        if self.stack.?:
            self.stack[self.stack.len() - 1]
        else:
            nil

    fn stack_depth() -> i64:
        """Get current stack depth."""
        self.stack.len()

    # ========================================================================
    # Stepping
    # ========================================================================

    me step_over():
        """Step over next statement."""
        self.step_mode = StepMode.StepOver
        self.step_target_depth = self.stack_depth()

    me step_into():
        """Step into next statement."""
        self.step_mode = StepMode.StepInto

    me step_out():
        """Step out of current function."""
        self.step_mode = StepMode.StepOut
        self.step_target_depth = self.stack_depth() - 1

    me continue_execution():
        """Continue execution until next breakpoint."""
        self.step_mode = StepMode.Continue

    fn should_break(file: text, line: i64) -> bool:
        """Check if execution should break at this location."""
        if not self.enabled:
            return false

        # Check breakpoints
        if self.has_breakpoint(file, line):
            return true

        # Check step mode
        match self.step_mode:
            StepMode.Continue:
                false
            StepMode.StepOver:
                if self.stack_depth() <= self.step_target_depth:
                    self.step_mode = StepMode.Continue
                    true
                else:
                    false
            StepMode.StepInto:
                self.step_mode = StepMode.Continue
                true
            StepMode.StepOut:
                if self.stack_depth() <= self.step_target_depth:
                    self.step_mode = StepMode.Continue
                    true
                else:
                    false

    # ========================================================================
    # Watch Expressions
    # ========================================================================

    me add_watch(name: text, expr: text):
        """Add a watch expression."""
        self.watches.push((name, expr))

    me remove_watch(name: text):
        """Remove a watch expression."""
        var new_watches: [(text, text)] = []
        for w in self.watches:
            if w.0 != name:
                new_watches.push(w)
        self.watches = new_watches

    fn get_watches() -> [(text, text)]:
        """Get all watch expressions."""
        self.watches

# ============================================================================
# Global Debugger Instance
# ============================================================================

var global_debugger: Debugger? = nil

fn debugger_create() -> Debugger:
    """Get or create the global debugger instance."""
    if global_debugger == nil:
        global_debugger = Debugger.new()
    global_debugger

fn debugger_should_break(file: text, line: i64) -> bool:
    """Check if debugger should break at location."""
    if global_debugger == nil:
        return false
    global_debugger.should_break(file, line)
