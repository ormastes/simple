# AST Conversion Module
#
# Converts parse tree (CST) to interpreter AST (expressions and statements).

import parser.treesitter.tree.{Tree, Node, NodeId, NodeArena}

export tree_to_module, tree_to_expression
export Module, Statement, Expr, Literal, BinaryOp, UnaryOp
export LetBinding, Block, MatchCase, Pattern

# =============================================================================
# AST Types
# =============================================================================

# Module represents a complete source file
struct Module:
    statements: Array<Statement>
    imports: Array<Import>

struct Import:
    path: String
    names: Array<String>
    alias: Option<String>

# Statement types
enum Statement:
    Let(LetBinding)
    Return(Option<Expr>)
    If { cond: Expr, then_block: Block, else_block: Option<Block> }
    Match { value: Expr, cases: Array<MatchCase> }
    For { pattern: Pattern, iterable: Expr, body: Block }
    While { cond: Expr, body: Block }
    Loop(Block)
    Break
    Continue
    Expression(Expr)
    FunctionDef { name: String, params: Array<Param>, return_type: Option<String>, body: Block }
    StructDef { name: String, fields: Array<StructField> }
    EnumDef { name: String, variants: Array<EnumVariant> }
    ImplDef { type_name: String, trait_name: Option<String>, methods: Array<Statement> }
    Export { names: Array<String> }
    Pass

struct LetBinding:
    name: String
    type_annotation: Option<String>
    value: Expr
    mutable: bool

struct Block:
    statements: Array<Statement>

struct MatchCase:
    pattern: Pattern
    guard: Option<Expr>
    body: Block

struct Param:
    name: String
    type_annotation: Option<String>
    default_value: Option<Expr>

struct StructField:
    name: String
    type_annotation: String
    default_value: Option<Expr>

struct EnumVariant:
    name: String
    fields: Option<Array<StructField>>

# Pattern types for match expressions
enum Pattern:
    Wildcard
    Identifier(String)
    Literal(Literal)
    Tuple(Array<Pattern>)
    Struct { name: String, fields: Array<(String, Pattern)> }
    Enum { variant: String, data: Option<Box<Pattern>> }

# Expression types
enum Expr:
    Literal(Literal)
    Identifier(String)
    Binary { op: BinaryOp, left: Box<Expr>, right: Box<Expr> }
    Unary { op: UnaryOp, operand: Box<Expr> }
    Call { callee: Box<Expr>, args: Array<Expr> }
    MethodCall { object: Box<Expr>, method: String, args: Array<Expr> }
    Index { collection: Box<Expr>, index: Box<Expr> }
    Field { object: Box<Expr>, field: String }
    Array(Array<Expr>)
    Dict(Array<(Expr, Expr)>)
    Tuple(Array<Expr>)
    Lambda { params: Array<String>, body: Box<Expr> }
    If { cond: Box<Expr>, then_expr: Box<Expr>, else_expr: Box<Expr> }
    Match { value: Box<Expr>, cases: Array<(Pattern, Expr)> }
    Range { start: Box<Expr>, end: Box<Expr>, inclusive: bool }
    Await(Box<Expr>)
    Try(Box<Expr>)

# Literal values
enum Literal:
    Nil
    Bool(bool)
    Int(i64)
    Float(f64)
    String(String)
    Char(char)

# Binary operators
enum BinaryOp:
    Add, Sub, Mul, Div, Mod, Pow
    Eq, NotEq, Lt, LtEq, Gt, GtEq
    And, Or
    BitAnd, BitOr, BitXor, Shl, Shr

# Unary operators
enum UnaryOp:
    Neg, Not, BitNot, Ref, Deref

# =============================================================================
# Conversion Functions
# =============================================================================

# Convert parse tree to module
fn tree_to_module(tree: Tree) -> Result<Module, String>:
    val root = match tree.root():
        case Some(node): node
        case None: return Err("Empty parse tree")

    if root.kind != "module":
        return Err("Expected module node, got: {root.kind}")

    var statements: Array<Statement> = []
    var imports: Array<Import> = []

    for child_id in root.children:
        match tree.get_node(child_id):
            case Some(child):
                match child.kind:
                    case "import_statement":
                        match convert_import(&tree, child):
                            case Ok(imp): imports.push(imp)
                            case Err(e): return Err(e)
                    case "function_def" | "struct_def" | "enum_def" | "impl_def" |
                         "let_statement" | "expression_statement" | "return_statement" |
                         "if_statement" | "match_statement" | "for_statement" |
                         "while_statement" | "loop_statement":
                        match convert_statement(&tree, child):
                            case Ok(stmt): statements.push(stmt)
                            case Err(e): return Err(e)
                    case "newline" | "comment" | "empty":
                        pass  # Skip whitespace/comments
                    case _:
                        # Try to convert as statement
                        match convert_statement(&tree, child):
                            case Ok(stmt): statements.push(stmt)
                            case Err(_): pass
            case None:
                pass

    return Ok(Module {
        statements: statements,
        imports: imports
    })

# Convert parse tree to single expression
fn tree_to_expression(tree: Tree) -> Result<Expr, String>:
    val root = match tree.root():
        case Some(node): node
        case None: return Err("Empty parse tree")

    # Find the expression node
    match root.kind:
        case "module":
            # Look for first expression in module
            for child_id in root.children:
                match tree.get_node(child_id):
                    case Some(child):
                        match convert_expression(&tree, child):
                            case Ok(expr): return Ok(expr)
                            case Err(_): pass
                    case None: pass
            return Err("No expression found in parse tree")
        case _:
            return convert_expression(&tree, root)

# =============================================================================
# Internal Conversion Helpers
# =============================================================================

fn convert_import(tree: &Tree, node: Node) -> Result<Import, String>:
    var path = ""
    var names: Array<String> = []
    var alias: Option<String> = None

    for child_id in node.children:
        match tree.get_node(child_id):
            case Some(child):
                match child.kind:
                    case "module_path":
                        path = child.text.clone()
                    case "import_names":
                        names = parse_import_names(tree, child)
                    case "import_alias":
                        alias = Some(child.text.clone())
                    case _: pass
            case None: pass

    return Ok(Import {
        path: path,
        names: names,
        alias: alias
    })

fn parse_import_names(tree: &Tree, node: Node) -> Array<String>:
    var names: Array<String> = []
    for child_id in node.children:
        match tree.get_node(child_id):
            case Some(child):
                if child.kind == "identifier":
                    names.push(child.text.clone())
            case None: pass
    return names

fn convert_statement(tree: &Tree, node: Node) -> Result<Statement, String>:
    match node.kind:
        case "let_statement" | "val_statement":
            return convert_let_statement(tree, node)
        case "var_statement":
            return convert_var_statement(tree, node)
        case "return_statement":
            return convert_return_statement(tree, node)
        case "if_statement":
            return convert_if_statement(tree, node)
        case "match_statement":
            return convert_match_statement(tree, node)
        case "for_statement":
            return convert_for_statement(tree, node)
        case "while_statement":
            return convert_while_statement(tree, node)
        case "loop_statement":
            return convert_loop_statement(tree, node)
        case "break_statement":
            return Ok(Statement.Break)
        case "continue_statement":
            return Ok(Statement.Continue)
        case "pass_statement":
            return Ok(Statement.Pass)
        case "function_def":
            return convert_function_def(tree, node)
        case "struct_def":
            return convert_struct_def(tree, node)
        case "enum_def":
            return convert_enum_def(tree, node)
        case "impl_def":
            return convert_impl_def(tree, node)
        case "expression_statement":
            for child_id in node.children:
                match tree.get_node(child_id):
                    case Some(child):
                        match convert_expression(tree, child):
                            case Ok(expr): return Ok(Statement.Expression(expr))
                            case Err(e): return Err(e)
                    case None: pass
            return Err("Empty expression statement")
        case _:
            # Try as expression
            match convert_expression(tree, node):
                case Ok(expr): return Ok(Statement.Expression(expr))
                case Err(e): return Err("Unknown statement kind: {node.kind}")

fn convert_let_statement(tree: &Tree, node: Node) -> Result<Statement, String>:
    var name = ""
    var type_annotation: Option<String> = None
    var value: Option<Expr> = None

    for child_id in node.children:
        match tree.get_node(child_id):
            case Some(child):
                match child.kind:
                    case "identifier":
                        name = child.text.clone()
                    case "type_annotation":
                        type_annotation = Some(child.text.clone())
                    case _:
                        match convert_expression(tree, child):
                            case Ok(expr): value = Some(expr)
                            case Err(_): pass
            case None: pass

    match value:
        case Some(v):
            return Ok(Statement.Let(LetBinding {
                name: name,
                type_annotation: type_annotation,
                value: v,
                mutable: false
            }))
        case None:
            return Err("Let statement missing value")

fn convert_var_statement(tree: &Tree, node: Node) -> Result<Statement, String>:
    var name = ""
    var type_annotation: Option<String> = None
    var value: Option<Expr> = None

    for child_id in node.children:
        match tree.get_node(child_id):
            case Some(child):
                match child.kind:
                    case "identifier":
                        name = child.text.clone()
                    case "type_annotation":
                        type_annotation = Some(child.text.clone())
                    case _:
                        match convert_expression(tree, child):
                            case Ok(expr): value = Some(expr)
                            case Err(_): pass
            case None: pass

    match value:
        case Some(v):
            return Ok(Statement.Let(LetBinding {
                name: name,
                type_annotation: type_annotation,
                value: v,
                mutable: true
            }))
        case None:
            return Err("Var statement missing value")

fn convert_return_statement(tree: &Tree, node: Node) -> Result<Statement, String>:
    for child_id in node.children:
        match tree.get_node(child_id):
            case Some(child):
                match convert_expression(tree, child):
                    case Ok(expr): return Ok(Statement.Return(Some(expr)))
                    case Err(_): pass
            case None: pass

    return Ok(Statement.Return(None))

fn convert_if_statement(tree: &Tree, node: Node) -> Result<Statement, String>:
    var cond: Option<Expr> = None
    var then_block: Option<Block> = None
    var else_block: Option<Block> = None

    for child_id in node.children:
        match tree.get_node(child_id):
            case Some(child):
                match child.kind:
                    case "condition":
                        match convert_expression(tree, child):
                            case Ok(expr): cond = Some(expr)
                            case Err(_): pass
                    case "then_block" | "block":
                        if cond.is_some() and then_block.is_none():
                            match convert_block(tree, child):
                                case Ok(blk): then_block = Some(blk)
                                case Err(_): pass
                    case "else_block":
                        match convert_block(tree, child):
                            case Ok(blk): else_block = Some(blk)
                            case Err(_): pass
                    case _:
                        if cond.is_none():
                            match convert_expression(tree, child):
                                case Ok(expr): cond = Some(expr)
                                case Err(_): pass
            case None: pass

    match (cond, then_block):
        case (Some(c), Some(tb)):
            return Ok(Statement.If {
                cond: c,
                then_block: tb,
                else_block: else_block
            })
        case _:
            return Err("If statement missing condition or body")

fn convert_match_statement(tree: &Tree, node: Node) -> Result<Statement, String>:
    var value: Option<Expr> = None
    var cases: Array<MatchCase> = []

    for child_id in node.children:
        match tree.get_node(child_id):
            case Some(child):
                match child.kind:
                    case "match_value":
                        match convert_expression(tree, child):
                            case Ok(expr): value = Some(expr)
                            case Err(_): pass
                    case "case_clause":
                        match convert_case_clause(tree, child):
                            case Ok(mc): cases.push(mc)
                            case Err(_): pass
                    case _:
                        if value.is_none():
                            match convert_expression(tree, child):
                                case Ok(expr): value = Some(expr)
                                case Err(_): pass
            case None: pass

    match value:
        case Some(v):
            return Ok(Statement.Match {
                value: v,
                cases: cases
            })
        case None:
            return Err("Match statement missing value")

fn convert_case_clause(tree: &Tree, node: Node) -> Result<MatchCase, String>:
    var pattern: Option<Pattern> = None
    var guard: Option<Expr> = None
    var body: Option<Block> = None

    for child_id in node.children:
        match tree.get_node(child_id):
            case Some(child):
                match child.kind:
                    case "pattern":
                        match convert_pattern(tree, child):
                            case Ok(p): pattern = Some(p)
                            case Err(_): pass
                    case "guard":
                        match convert_expression(tree, child):
                            case Ok(expr): guard = Some(expr)
                            case Err(_): pass
                    case "block":
                        match convert_block(tree, child):
                            case Ok(blk): body = Some(blk)
                            case Err(_): pass
                    case _:
                        if pattern.is_none():
                            match convert_pattern(tree, child):
                                case Ok(p): pattern = Some(p)
                                case Err(_): pass
            case None: pass

    match (pattern, body):
        case (Some(p), Some(b)):
            return Ok(MatchCase {
                pattern: p,
                guard: guard,
                body: b
            })
        case _:
            return Err("Case clause missing pattern or body")

fn convert_for_statement(tree: &Tree, node: Node) -> Result<Statement, String>:
    var pattern: Option<Pattern> = None
    var iterable: Option<Expr> = None
    var body: Option<Block> = None

    for child_id in node.children:
        match tree.get_node(child_id):
            case Some(child):
                match child.kind:
                    case "pattern" | "identifier":
                        match convert_pattern(tree, child):
                            case Ok(p): pattern = Some(p)
                            case Err(_): pass
                    case "iterable":
                        match convert_expression(tree, child):
                            case Ok(expr): iterable = Some(expr)
                            case Err(_): pass
                    case "block":
                        match convert_block(tree, child):
                            case Ok(blk): body = Some(blk)
                            case Err(_): pass
                    case _:
                        if iterable.is_none() and pattern.is_some():
                            match convert_expression(tree, child):
                                case Ok(expr): iterable = Some(expr)
                                case Err(_): pass
            case None: pass

    match (pattern, iterable, body):
        case (Some(p), Some(i), Some(b)):
            return Ok(Statement.For {
                pattern: p,
                iterable: i,
                body: b
            })
        case _:
            return Err("For statement missing pattern, iterable, or body")

fn convert_while_statement(tree: &Tree, node: Node) -> Result<Statement, String>:
    var cond: Option<Expr> = None
    var body: Option<Block> = None

    for child_id in node.children:
        match tree.get_node(child_id):
            case Some(child):
                match child.kind:
                    case "condition":
                        match convert_expression(tree, child):
                            case Ok(expr): cond = Some(expr)
                            case Err(_): pass
                    case "block":
                        match convert_block(tree, child):
                            case Ok(blk): body = Some(blk)
                            case Err(_): pass
                    case _:
                        if cond.is_none():
                            match convert_expression(tree, child):
                                case Ok(expr): cond = Some(expr)
                                case Err(_): pass
            case None: pass

    match (cond, body):
        case (Some(c), Some(b)):
            return Ok(Statement.While {
                cond: c,
                body: b
            })
        case _:
            return Err("While statement missing condition or body")

fn convert_loop_statement(tree: &Tree, node: Node) -> Result<Statement, String>:
    for child_id in node.children:
        match tree.get_node(child_id):
            case Some(child):
                if child.kind == "block":
                    match convert_block(tree, child):
                        case Ok(blk): return Ok(Statement.Loop(blk))
                        case Err(e): return Err(e)
            case None: pass

    return Err("Loop statement missing body")

fn convert_function_def(tree: &Tree, node: Node) -> Result<Statement, String>:
    var name = ""
    var params: Array<Param> = []
    var return_type: Option<String> = None
    var body: Option<Block> = None

    for child_id in node.children:
        match tree.get_node(child_id):
            case Some(child):
                match child.kind:
                    case "identifier" | "function_name":
                        name = child.text.clone()
                    case "parameters":
                        params = convert_parameters(tree, child)
                    case "return_type":
                        return_type = Some(child.text.clone())
                    case "block":
                        match convert_block(tree, child):
                            case Ok(blk): body = Some(blk)
                            case Err(_): pass
            case None: pass

    match body:
        case Some(b):
            return Ok(Statement.FunctionDef {
                name: name,
                params: params,
                return_type: return_type,
                body: b
            })
        case None:
            return Err("Function missing body")

fn convert_parameters(tree: &Tree, node: Node) -> Array<Param>:
    var params: Array<Param> = []

    for child_id in node.children:
        match tree.get_node(child_id):
            case Some(child):
                if child.kind == "parameter":
                    match convert_parameter(tree, child):
                        case Ok(p): params.push(p)
                        case Err(_): pass
            case None: pass

    return params

fn convert_parameter(tree: &Tree, node: Node) -> Result<Param, String>:
    var name = ""
    var type_annotation: Option<String> = None
    var default_value: Option<Expr> = None

    for child_id in node.children:
        match tree.get_node(child_id):
            case Some(child):
                match child.kind:
                    case "identifier":
                        name = child.text.clone()
                    case "type_annotation":
                        type_annotation = Some(child.text.clone())
                    case "default_value":
                        match convert_expression(tree, child):
                            case Ok(expr): default_value = Some(expr)
                            case Err(_): pass
            case None: pass

    return Ok(Param {
        name: name,
        type_annotation: type_annotation,
        default_value: default_value
    })

fn convert_struct_def(tree: &Tree, node: Node) -> Result<Statement, String>:
    var name = ""
    var fields: Array<StructField> = []

    for child_id in node.children:
        match tree.get_node(child_id):
            case Some(child):
                match child.kind:
                    case "identifier" | "type_identifier":
                        name = child.text.clone()
                    case "struct_field":
                        match convert_struct_field(tree, child):
                            case Ok(f): fields.push(f)
                            case Err(_): pass
            case None: pass

    return Ok(Statement.StructDef {
        name: name,
        fields: fields
    })

fn convert_struct_field(tree: &Tree, node: Node) -> Result<StructField, String>:
    var name = ""
    var type_annotation = ""

    for child_id in node.children:
        match tree.get_node(child_id):
            case Some(child):
                match child.kind:
                    case "identifier":
                        name = child.text.clone()
                    case "type_annotation" | "type":
                        type_annotation = child.text.clone()
            case None: pass

    return Ok(StructField {
        name: name,
        type_annotation: type_annotation,
        default_value: None
    })

fn convert_enum_def(tree: &Tree, node: Node) -> Result<Statement, String>:
    var name = ""
    var variants: Array<EnumVariant> = []

    for child_id in node.children:
        match tree.get_node(child_id):
            case Some(child):
                match child.kind:
                    case "identifier" | "type_identifier":
                        name = child.text.clone()
                    case "enum_variant":
                        match convert_enum_variant(tree, child):
                            case Ok(v): variants.push(v)
                            case Err(_): pass
            case None: pass

    return Ok(Statement.EnumDef {
        name: name,
        variants: variants
    })

fn convert_enum_variant(tree: &Tree, node: Node) -> Result<EnumVariant, String>:
    var name = ""
    var fields: Option<Array<StructField>> = None

    for child_id in node.children:
        match tree.get_node(child_id):
            case Some(child):
                match child.kind:
                    case "identifier":
                        name = child.text.clone()
                    case "variant_fields":
                        fields = Some(convert_variant_fields(tree, child))
            case None: pass

    return Ok(EnumVariant {
        name: name,
        fields: fields
    })

fn convert_variant_fields(tree: &Tree, node: Node) -> Array<StructField>:
    var fields: Array<StructField> = []

    for child_id in node.children:
        match tree.get_node(child_id):
            case Some(child):
                if child.kind == "struct_field":
                    match convert_struct_field(tree, child):
                        case Ok(f): fields.push(f)
                        case Err(_): pass
            case None: pass

    return fields

fn convert_impl_def(tree: &Tree, node: Node) -> Result<Statement, String>:
    var type_name = ""
    var trait_name: Option<String> = None
    var methods: Array<Statement> = []

    for child_id in node.children:
        match tree.get_node(child_id):
            case Some(child):
                match child.kind:
                    case "type_identifier":
                        type_name = child.text.clone()
                    case "trait_name":
                        trait_name = Some(child.text.clone())
                    case "function_def":
                        match convert_function_def(tree, child):
                            case Ok(stmt): methods.push(stmt)
                            case Err(_): pass
            case None: pass

    return Ok(Statement.ImplDef {
        type_name: type_name,
        trait_name: trait_name,
        methods: methods
    })

fn convert_block(tree: &Tree, node: Node) -> Result<Block, String>:
    var statements: Array<Statement> = []

    for child_id in node.children:
        match tree.get_node(child_id):
            case Some(child):
                match convert_statement(tree, child):
                    case Ok(stmt): statements.push(stmt)
                    case Err(_): pass
            case None: pass

    return Ok(Block { statements: statements })

fn convert_pattern(tree: &Tree, node: Node) -> Result<Pattern, String>:
    match node.kind:
        case "wildcard" | "_":
            return Ok(Pattern.Wildcard)
        case "identifier":
            return Ok(Pattern.Identifier(node.text.clone()))
        case "literal":
            match convert_literal(tree, node):
                case Ok(lit): return Ok(Pattern.Literal(lit))
                case Err(e): return Err(e)
        case "integer" | "float" | "string" | "boolean" | "nil":
            match convert_literal(tree, node):
                case Ok(lit): return Ok(Pattern.Literal(lit))
                case Err(e): return Err(e)
        case "tuple_pattern":
            var patterns: Array<Pattern> = []
            for child_id in node.children:
                match tree.get_node(child_id):
                    case Some(child):
                        match convert_pattern(tree, child):
                            case Ok(p): patterns.push(p)
                            case Err(_): pass
                    case None: pass
            return Ok(Pattern.Tuple(patterns))
        case "struct_pattern":
            return convert_struct_pattern(tree, node)
        case "enum_pattern":
            return convert_enum_pattern(tree, node)
        case _:
            # Default to identifier pattern
            return Ok(Pattern.Identifier(node.text.clone()))

fn convert_struct_pattern(tree: &Tree, node: Node) -> Result<Pattern, String>:
    var name = ""
    var fields: Array<(String, Pattern)> = []

    for child_id in node.children:
        match tree.get_node(child_id):
            case Some(child):
                match child.kind:
                    case "type_identifier":
                        name = child.text.clone()
                    case "field_pattern":
                        match convert_field_pattern(tree, child):
                            case Ok(fp): fields.push(fp)
                            case Err(_): pass
            case None: pass

    return Ok(Pattern.Struct {
        name: name,
        fields: fields
    })

fn convert_field_pattern(tree: &Tree, node: Node) -> Result<(String, Pattern), String>:
    var name = ""
    var pattern: Option<Pattern> = None

    for child_id in node.children:
        match tree.get_node(child_id):
            case Some(child):
                match child.kind:
                    case "identifier":
                        if name.is_empty():
                            name = child.text.clone()
                        else:
                            pattern = Some(Pattern.Identifier(child.text.clone()))
                    case _:
                        match convert_pattern(tree, child):
                            case Ok(p): pattern = Some(p)
                            case Err(_): pass
            case None: pass

    match pattern:
        case Some(p): return Ok((name, p))
        case None: return Ok((name.clone(), Pattern.Identifier(name)))

fn convert_enum_pattern(tree: &Tree, node: Node) -> Result<Pattern, String>:
    var variant = ""
    var data: Option<Box<Pattern>> = None

    for child_id in node.children:
        match tree.get_node(child_id):
            case Some(child):
                match child.kind:
                    case "identifier" | "variant_name":
                        variant = child.text.clone()
                    case _:
                        match convert_pattern(tree, child):
                            case Ok(p): data = Some(Box.new(p))
                            case Err(_): pass
            case None: pass

    return Ok(Pattern.Enum {
        variant: variant,
        data: data
    })

fn convert_expression(tree: &Tree, node: Node) -> Result<Expr, String>:
    match node.kind:
        # Literals
        case "integer":
            match node.text.parse.<i64>():
                case Ok(n): return Ok(Expr.Literal(Literal.Int(n)))
                case Err(_): return Err("Invalid integer: {node.text}")
        case "float":
            match node.text.parse.<f64>():
                case Ok(f): return Ok(Expr.Literal(Literal.Float(f)))
                case Err(_): return Err("Invalid float: {node.text}")
        case "string":
            val s = unescape_string(node.text)
            return Ok(Expr.Literal(Literal.String(s)))
        case "boolean" | "true" | "false":
            val b = node.text == "true"
            return Ok(Expr.Literal(Literal.Bool(b)))
        case "nil" | "none":
            return Ok(Expr.Literal(Literal.Nil))

        # Identifier
        case "identifier":
            return Ok(Expr.Identifier(node.text.clone()))

        # Binary expressions
        case "binary_expression":
            return convert_binary_expression(tree, node)

        # Unary expressions
        case "unary_expression":
            return convert_unary_expression(tree, node)

        # Call expressions
        case "call_expression":
            return convert_call_expression(tree, node)

        # Method call
        case "method_call":
            return convert_method_call(tree, node)

        # Index expression
        case "index_expression":
            return convert_index_expression(tree, node)

        # Field access
        case "field_expression":
            return convert_field_expression(tree, node)

        # Array literal
        case "array" | "array_literal":
            return convert_array_literal(tree, node)

        # Dict literal
        case "dict" | "dict_literal":
            return convert_dict_literal(tree, node)

        # Tuple literal
        case "tuple" | "tuple_literal":
            return convert_tuple_literal(tree, node)

        # Lambda
        case "lambda" | "lambda_expression":
            return convert_lambda(tree, node)

        # If expression
        case "if_expression":
            return convert_if_expression(tree, node)

        # Match expression
        case "match_expression":
            return convert_match_expression(tree, node)

        # Range
        case "range_expression":
            return convert_range_expression(tree, node)

        # Parenthesized expression
        case "parenthesized_expression":
            for child_id in node.children:
                match tree.get_node(child_id):
                    case Some(child):
                        match convert_expression(tree, child):
                            case Ok(expr): return Ok(expr)
                            case Err(_): pass
                    case None: pass
            return Err("Empty parenthesized expression")

        # Await expression
        case "await_expression":
            for child_id in node.children:
                match tree.get_node(child_id):
                    case Some(child):
                        match convert_expression(tree, child):
                            case Ok(expr): return Ok(Expr.Await(Box.new(expr)))
                            case Err(_): pass
                    case None: pass
            return Err("Await missing expression")

        # Try expression
        case "try_expression":
            for child_id in node.children:
                match tree.get_node(child_id):
                    case Some(child):
                        match convert_expression(tree, child):
                            case Ok(expr): return Ok(Expr.Try(Box.new(expr)))
                            case Err(_): pass
                    case None: pass
            return Err("Try missing expression")

        case _:
            return Err("Unknown expression kind: {node.kind}")

fn convert_literal(tree: &Tree, node: Node) -> Result<Literal, String>:
    match node.kind:
        case "integer":
            match node.text.parse.<i64>():
                case Ok(n): return Ok(Literal.Int(n))
                case Err(_): return Err("Invalid integer")
        case "float":
            match node.text.parse.<f64>():
                case Ok(f): return Ok(Literal.Float(f))
                case Err(_): return Err("Invalid float")
        case "string":
            return Ok(Literal.String(unescape_string(node.text)))
        case "boolean" | "true":
            return Ok(Literal.Bool(true))
        case "false":
            return Ok(Literal.Bool(false))
        case "nil" | "none":
            return Ok(Literal.Nil)
        case _:
            return Err("Unknown literal kind: {node.kind}")

fn convert_binary_expression(tree: &Tree, node: Node) -> Result<Expr, String>:
    var left: Option<Expr> = None
    var op: Option<BinaryOp> = None
    var right: Option<Expr> = None

    for child_id in node.children:
        match tree.get_node(child_id):
            case Some(child):
                match child.kind:
                    case "+" | "plus": op = Some(BinaryOp.Add)
                    case "-" | "minus": op = Some(BinaryOp.Sub)
                    case "*" | "star": op = Some(BinaryOp.Mul)
                    case "/" | "slash": op = Some(BinaryOp.Div)
                    case "%" | "percent": op = Some(BinaryOp.Mod)
                    case "**" | "power": op = Some(BinaryOp.Pow)
                    case "==" | "eq": op = Some(BinaryOp.Eq)
                    case "!=" | "not_eq": op = Some(BinaryOp.NotEq)
                    case "<" | "lt": op = Some(BinaryOp.Lt)
                    case "<=" | "lt_eq": op = Some(BinaryOp.LtEq)
                    case ">" | "gt": op = Some(BinaryOp.Gt)
                    case ">=" | "gt_eq": op = Some(BinaryOp.GtEq)
                    case "and": op = Some(BinaryOp.And)
                    case "or": op = Some(BinaryOp.Or)
                    case "&" | "bit_and": op = Some(BinaryOp.BitAnd)
                    case "|" | "bit_or": op = Some(BinaryOp.BitOr)
                    case "^" | "bit_xor": op = Some(BinaryOp.BitXor)
                    case "<<" | "shl": op = Some(BinaryOp.Shl)
                    case ">>" | "shr": op = Some(BinaryOp.Shr)
                    case _:
                        match convert_expression(tree, child):
                            case Ok(expr):
                                if left.is_none():
                                    left = Some(expr)
                                else:
                                    right = Some(expr)
                            case Err(_): pass
            case None: pass

    match (left, op, right):
        case (Some(l), Some(o), Some(r)):
            return Ok(Expr.Binary {
                op: o,
                left: Box.new(l),
                right: Box.new(r)
            })
        case _:
            return Err("Incomplete binary expression")

fn convert_unary_expression(tree: &Tree, node: Node) -> Result<Expr, String>:
    var op: Option<UnaryOp> = None
    var operand: Option<Expr> = None

    for child_id in node.children:
        match tree.get_node(child_id):
            case Some(child):
                match child.kind:
                    case "-" | "minus": op = Some(UnaryOp.Neg)
                    case "not" | "!": op = Some(UnaryOp.Not)
                    case "~": op = Some(UnaryOp.BitNot)
                    case "&": op = Some(UnaryOp.Ref)
                    case "*": op = Some(UnaryOp.Deref)
                    case _:
                        match convert_expression(tree, child):
                            case Ok(expr): operand = Some(expr)
                            case Err(_): pass
            case None: pass

    match (op, operand):
        case (Some(o), Some(e)):
            return Ok(Expr.Unary {
                op: o,
                operand: Box.new(e)
            })
        case _:
            return Err("Incomplete unary expression")

fn convert_call_expression(tree: &Tree, node: Node) -> Result<Expr, String>:
    var callee: Option<Expr> = None
    var args: Array<Expr> = []

    for child_id in node.children:
        match tree.get_node(child_id):
            case Some(child):
                match child.kind:
                    case "arguments" | "argument_list":
                        args = convert_arguments(tree, child)
                    case _:
                        if callee.is_none():
                            match convert_expression(tree, child):
                                case Ok(expr): callee = Some(expr)
                                case Err(_): pass
            case None: pass

    match callee:
        case Some(c):
            return Ok(Expr.Call {
                callee: Box.new(c),
                args: args
            })
        case None:
            return Err("Call missing callee")

fn convert_arguments(tree: &Tree, node: Node) -> Array<Expr>:
    var args: Array<Expr> = []

    for child_id in node.children:
        match tree.get_node(child_id):
            case Some(child):
                match convert_expression(tree, child):
                    case Ok(expr): args.push(expr)
                    case Err(_): pass
            case None: pass

    return args

fn convert_method_call(tree: &Tree, node: Node) -> Result<Expr, String>:
    var object: Option<Expr> = None
    var method = ""
    var args: Array<Expr> = []

    for child_id in node.children:
        match tree.get_node(child_id):
            case Some(child):
                match child.kind:
                    case "identifier":
                        if object.is_some():
                            method = child.text.clone()
                    case "arguments" | "argument_list":
                        args = convert_arguments(tree, child)
                    case _:
                        if object.is_none():
                            match convert_expression(tree, child):
                                case Ok(expr): object = Some(expr)
                                case Err(_): pass
            case None: pass

    match object:
        case Some(o):
            return Ok(Expr.MethodCall {
                object: Box.new(o),
                method: method,
                args: args
            })
        case None:
            return Err("Method call missing object")

fn convert_index_expression(tree: &Tree, node: Node) -> Result<Expr, String>:
    var collection: Option<Expr> = None
    var index: Option<Expr> = None

    for child_id in node.children:
        match tree.get_node(child_id):
            case Some(child):
                match convert_expression(tree, child):
                    case Ok(expr):
                        if collection.is_none():
                            collection = Some(expr)
                        else:
                            index = Some(expr)
                    case Err(_): pass
            case None: pass

    match (collection, index):
        case (Some(c), Some(i)):
            return Ok(Expr.Index {
                collection: Box.new(c),
                index: Box.new(i)
            })
        case _:
            return Err("Incomplete index expression")

fn convert_field_expression(tree: &Tree, node: Node) -> Result<Expr, String>:
    var object: Option<Expr> = None
    var field = ""

    for child_id in node.children:
        match tree.get_node(child_id):
            case Some(child):
                match child.kind:
                    case "identifier":
                        if object.is_some():
                            field = child.text.clone()
                    case _:
                        if object.is_none():
                            match convert_expression(tree, child):
                                case Ok(expr): object = Some(expr)
                                case Err(_): pass
            case None: pass

    match object:
        case Some(o):
            return Ok(Expr.Field {
                object: Box.new(o),
                field: field
            })
        case None:
            return Err("Field access missing object")

fn convert_array_literal(tree: &Tree, node: Node) -> Result<Expr, String>:
    var elements: Array<Expr> = []

    for child_id in node.children:
        match tree.get_node(child_id):
            case Some(child):
                match convert_expression(tree, child):
                    case Ok(expr): elements.push(expr)
                    case Err(_): pass
            case None: pass

    return Ok(Expr.Array(elements))

fn convert_dict_literal(tree: &Tree, node: Node) -> Result<Expr, String>:
    var pairs: Array<(Expr, Expr)> = []

    for child_id in node.children:
        match tree.get_node(child_id):
            case Some(child):
                if child.kind == "dict_entry" or child.kind == "key_value_pair":
                    match convert_dict_entry(tree, child):
                        case Ok(pair): pairs.push(pair)
                        case Err(_): pass
            case None: pass

    return Ok(Expr.Dict(pairs))

fn convert_dict_entry(tree: &Tree, node: Node) -> Result<(Expr, Expr), String>:
    var key: Option<Expr> = None
    var value: Option<Expr> = None

    for child_id in node.children:
        match tree.get_node(child_id):
            case Some(child):
                match convert_expression(tree, child):
                    case Ok(expr):
                        if key.is_none():
                            key = Some(expr)
                        else:
                            value = Some(expr)
                    case Err(_): pass
            case None: pass

    match (key, value):
        case (Some(k), Some(v)): return Ok((k, v))
        case _: return Err("Incomplete dict entry")

fn convert_tuple_literal(tree: &Tree, node: Node) -> Result<Expr, String>:
    var elements: Array<Expr> = []

    for child_id in node.children:
        match tree.get_node(child_id):
            case Some(child):
                match convert_expression(tree, child):
                    case Ok(expr): elements.push(expr)
                    case Err(_): pass
            case None: pass

    return Ok(Expr.Tuple(elements))

fn convert_lambda(tree: &Tree, node: Node) -> Result<Expr, String>:
    var params: Array<String> = []
    var body: Option<Expr> = None

    for child_id in node.children:
        match tree.get_node(child_id):
            case Some(child):
                match child.kind:
                    case "parameters" | "lambda_parameters":
                        params = convert_lambda_params(tree, child)
                    case "identifier":
                        if body.is_none():
                            params.push(child.text.clone())
                    case _:
                        match convert_expression(tree, child):
                            case Ok(expr): body = Some(expr)
                            case Err(_): pass
            case None: pass

    match body:
        case Some(b):
            return Ok(Expr.Lambda {
                params: params,
                body: Box.new(b)
            })
        case None:
            return Err("Lambda missing body")

fn convert_lambda_params(tree: &Tree, node: Node) -> Array<String>:
    var params: Array<String> = []

    for child_id in node.children:
        match tree.get_node(child_id):
            case Some(child):
                if child.kind == "identifier":
                    params.push(child.text.clone())
            case None: pass

    return params

fn convert_if_expression(tree: &Tree, node: Node) -> Result<Expr, String>:
    var cond: Option<Expr> = None
    var then_expr: Option<Expr> = None
    var else_expr: Option<Expr> = None

    for child_id in node.children:
        match tree.get_node(child_id):
            case Some(child):
                match convert_expression(tree, child):
                    case Ok(expr):
                        if cond.is_none():
                            cond = Some(expr)
                        elif then_expr.is_none():
                            then_expr = Some(expr)
                        else:
                            else_expr = Some(expr)
                    case Err(_): pass
            case None: pass

    match (cond, then_expr, else_expr):
        case (Some(c), Some(t), Some(e)):
            return Ok(Expr.If {
                cond: Box.new(c),
                then_expr: Box.new(t),
                else_expr: Box.new(e)
            })
        case _:
            return Err("Incomplete if expression")

fn convert_match_expression(tree: &Tree, node: Node) -> Result<Expr, String>:
    var value: Option<Expr> = None
    var cases: Array<(Pattern, Expr)> = []

    for child_id in node.children:
        match tree.get_node(child_id):
            case Some(child):
                match child.kind:
                    case "case_clause":
                        match convert_match_arm(tree, child):
                            case Ok(arm): cases.push(arm)
                            case Err(_): pass
                    case _:
                        if value.is_none():
                            match convert_expression(tree, child):
                                case Ok(expr): value = Some(expr)
                                case Err(_): pass
            case None: pass

    match value:
        case Some(v):
            return Ok(Expr.Match {
                value: Box.new(v),
                cases: cases
            })
        case None:
            return Err("Match expression missing value")

fn convert_match_arm(tree: &Tree, node: Node) -> Result<(Pattern, Expr), String>:
    var pattern: Option<Pattern> = None
    var body: Option<Expr> = None

    for child_id in node.children:
        match tree.get_node(child_id):
            case Some(child):
                match child.kind:
                    case "pattern":
                        match convert_pattern(tree, child):
                            case Ok(p): pattern = Some(p)
                            case Err(_): pass
                    case _:
                        if pattern.is_some():
                            match convert_expression(tree, child):
                                case Ok(expr): body = Some(expr)
                                case Err(_): pass
                        else:
                            match convert_pattern(tree, child):
                                case Ok(p): pattern = Some(p)
                                case Err(_): pass
            case None: pass

    match (pattern, body):
        case (Some(p), Some(b)): return Ok((p, b))
        case _: return Err("Incomplete match arm")

fn convert_range_expression(tree: &Tree, node: Node) -> Result<Expr, String>:
    var start: Option<Expr> = None
    var end: Option<Expr> = None
    var inclusive = false

    for child_id in node.children:
        match tree.get_node(child_id):
            case Some(child):
                match child.kind:
                    case ".." | "range_op":
                        inclusive = false
                    case "..=" | "inclusive_range_op":
                        inclusive = true
                    case _:
                        match convert_expression(tree, child):
                            case Ok(expr):
                                if start.is_none():
                                    start = Some(expr)
                                else:
                                    end = Some(expr)
                            case Err(_): pass
            case None: pass

    match (start, end):
        case (Some(s), Some(e)):
            return Ok(Expr.Range {
                start: Box.new(s),
                end: Box.new(e),
                inclusive: inclusive
            })
        case _:
            return Err("Incomplete range expression")

# =============================================================================
# Utility Functions
# =============================================================================

fn unescape_string(s: String) -> String:
    # Remove surrounding quotes and unescape
    var result = s
    if result.starts_with("\"") and result.ends_with("\""):
        result = result.slice(1, result.len() - 1)
    elif result.starts_with("'") and result.ends_with("'"):
        result = result.slice(1, result.len() - 1)

    # Unescape common sequences
    result = result.replace("\\n", "\n")
    result = result.replace("\\t", "\t")
    result = result.replace("\\r", "\r")
    result = result.replace("\\\\", "\\")
    result = result.replace("\\\"", "\"")
    result = result.replace("\\'", "'")

    return result
