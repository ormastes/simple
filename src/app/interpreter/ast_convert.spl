# AST Conversion Module
#
# Converts parse tree (CST) to interpreter AST (expressions and statements).
#
# This module has been refactored into separate components:
# - ast_types: Core AST type definitions
# - ast_convert_stmt: Statement and pattern conversion
# - ast_convert_expr: Expression conversion
#
# This file re-exports all public APIs for backward compatibility.

import parser.treesitter.tree.{Tree, Node, NodeId, NodeArena}
import interpreter.ast_types.*
import interpreter.ast_convert_stmt.*
import interpreter.ast_convert_expr.*

# =============================================================================
# Top-Level Conversion Functions
# =============================================================================

# Convert parse tree to module
fn tree_to_module(tree: Tree) -> Result<Module, String>:
    val root = match tree.root():
        case Some(node): node
        case nil: return Err("Empty parse tree")

    if root.kind != "module":
        return Err("Expected module node, got: {root.kind}")

    var statements: Array<Statement> = []
    var imports: Array<Import> = []

    for child_id in root.children:
        match tree.get_node(child_id):
            case Some(child):
                match child.kind:
                    case "import_statement":
                        match convert_import(&tree, child):
                            case Ok(imp): imports.push(imp)
                            case Err(e): return Err(e)
                    case "function_def" | "struct_def" | "enum_def" | "impl_def" |
                         "let_statement" | "expression_statement" | "return_statement" |
                         "if_statement" | "match_statement" | "for_statement" |
                         "while_statement" | "loop_statement":
                        match convert_statement(&tree, child):
                            case Ok(stmt): statements.push(stmt)
                            case Err(e): return Err(e)
                    case "newline" | "comment" | "empty":
                        pass  # Skip whitespace/comments
                    case _:
                        # Try to convert as statement
                        match convert_statement(&tree, child):
                            case Ok(stmt): statements.push(stmt)
                            case Err(_): pass
            case nil:
                pass

    return Ok(Module {
        statements: statements,
        imports: imports
    })

# Convert parse tree to single expression
fn tree_to_expression(tree: Tree) -> Result<Expr, String>:
    val root = match tree.root():
        case Some(node): node
        case nil: return Err("Empty parse tree")

    # Find the expression node
    match root.kind:
        case "module":
            # Look for first expression in module
            for child_id in root.children:
                match tree.get_node(child_id):
                    case Some(child):
                        match convert_expression(&tree, child):
                            case Ok(expr): return Ok(expr)
                            case Err(_): pass
                    case nil: pass
            return Err("No expression found in parse tree")
        case _:
            return convert_expression(&tree, root)

# =============================================================================
# Re-exports
# =============================================================================

# Export top-level functions
export tree_to_module, tree_to_expression

# Re-export types from ast_types
export Module, Import
export Statement, LetBinding, Block, MatchCase
export Param, StructField, EnumVariant
export Pattern
export Expr
export Literal
export BinaryOp, UnaryOp

# Re-export pattern/literal converters (shared, for advanced usage)
export convert_literal
export convert_pattern, convert_struct_pattern, convert_field_pattern, convert_enum_pattern
export unescape_string

# Re-export statement converters (internal, for advanced usage)
export convert_import, parse_import_names
export convert_statement
export convert_let_statement, convert_var_statement, convert_return_statement
export convert_if_statement, convert_match_statement, convert_case_clause
export convert_for_statement, convert_while_statement, convert_loop_statement
export convert_function_def, convert_parameters, convert_parameter
export convert_struct_def, convert_struct_field
export convert_enum_def, convert_enum_variant, convert_variant_fields
export convert_impl_def
export convert_block

# Re-export expression converters (internal, for advanced usage)
export convert_expression
export convert_binary_expression, convert_unary_expression
export convert_call_expression, convert_arguments
export convert_method_call
export convert_index_expression, convert_field_expression
export convert_array_literal
export convert_dict_literal, convert_dict_entry
export convert_tuple_literal
export convert_lambda, convert_lambda_params
export convert_if_expression
export convert_match_expression, convert_match_arm
export convert_range_expression
