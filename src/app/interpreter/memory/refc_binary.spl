# Reference-Counted Binaries
#
# Large values (>= 64 bytes) are stored in a shared heap with reference
# counting instead of being copied between actors. This enables zero-copy
# message passing for large data.
#
# Inspired by Erlang's Refc Binary optimization:
# "Binary terms > 64 bytes are not stored in process private heap.
#  They are called Refc Binary and stored in a large Shared Heap
#  accessible by all processes."
# â€” Erlang Efficiency Guide
#
# Benefits:
# - Zero-copy for large messages between actors
# - Reduced memory usage (one copy instead of N)
# - Faster message passing for large payloads
# - Automatic cleanup via reference counting
#
# Trade-offs:
# - Small overhead for reference count operations
# - Shared heap requires synchronization
# - Fragmentation possible in shared heap

export RefcBinary, BinaryRef, SharedHeap, SharedHeapConfig, SharedHeapStats
export SMALL_BINARY_THRESHOLD, copy_strategy

# ============================================================================
# Configuration
# ============================================================================

# Threshold for reference-counted vs copied binaries
# Values smaller than this are copied (fast for small data)
# Values >= this are reference counted (zero-copy)
val SMALL_BINARY_THRESHOLD: i64 = 64

# Maximum size for a single binary (prevent memory exhaustion)
val MAX_BINARY_SIZE: i64 = 1024 * 1024 * 1024  # 1 GB

# Default shared heap size
val DEFAULT_SHARED_HEAP_SIZE: i64 = 64 * 1024 * 1024  # 64 MB

struct SharedHeapConfig:
    """Configuration for the shared binary heap."""
    initial_size: i64       # Initial heap size in bytes
    max_size: i64           # Maximum heap size
    grow_factor: f64        # Growth factor when expanding (e.g., 1.5)
    gc_threshold: f64       # GC when usage exceeds this ratio (0.0-1.0)
    defrag_threshold: f64   # Defragment when fragmentation exceeds this

fn SharedHeapConfig__default() -> SharedHeapConfig:
    SharedHeapConfig(
        initial_size: DEFAULT_SHARED_HEAP_SIZE,
        max_size: DEFAULT_SHARED_HEAP_SIZE * 4,
        grow_factor: 1.5,
        gc_threshold: 0.8,
        defrag_threshold: 0.3
    )

fn SharedHeapConfig__small() -> SharedHeapConfig:
    """Smaller shared heap for testing."""
    SharedHeapConfig(
        initial_size: 1024 * 1024,  # 1 MB
        max_size: 16 * 1024 * 1024,  # 16 MB
        grow_factor: 2.0,
        gc_threshold: 0.75,
        defrag_threshold: 0.25
    )

fn SharedHeapConfig__large() -> SharedHeapConfig:
    """Larger shared heap for heavy workloads."""
    SharedHeapConfig(
        initial_size: 256 * 1024 * 1024,  # 256 MB
        max_size: 1024 * 1024 * 1024,     # 1 GB
        grow_factor: 1.25,
        gc_threshold: 0.85,
        defrag_threshold: 0.4
    )

# ============================================================================
# Copy Strategy
# ============================================================================

enum CopyStrategy:
    """Strategy for handling value transfer between actors."""
    DeepCopy    # Copy entire value (for small values)
    ShareRef    # Share reference (for large values)
    Hybrid      # Auto-select based on size

impl CopyStrategy:
    fn should_share(size: i64) -> bool:
        """Determine if value should be shared based on strategy."""
        match self:
            case DeepCopy: false
            case ShareRef: true
            case Hybrid: size >= SMALL_BINARY_THRESHOLD
fn copy_strategy(size: i64) -> CopyStrategy:
    """Get recommended copy strategy for given size."""
    if size < SMALL_BINARY_THRESHOLD:
        CopyStrategy.DeepCopy
    else:
        CopyStrategy.ShareRef

# ============================================================================
# Binary Reference
# ============================================================================

struct BinaryRef:
    """Lightweight reference to a RefcBinary.

    This is what actors hold - a small handle that points to
    the actual data in the shared heap. Multiple BinaryRefs
    can point to the same RefcBinary.

    Size: ~24 bytes (fits in actor heap efficiently)
    """
    id: i64             # Unique binary ID
    offset: i64         # Offset in shared heap
    length: i64         # Length of data in bytes

fn BinaryRef__new(id: i64, offset: i64, length: i64) -> BinaryRef:
    BinaryRef(id: id, offset: offset, length: length)


impl BinaryRef:
    fn size() -> i64:
        """Size of the referenced data."""
        self.length
    fn is_small() -> bool:
        """Check if this is a small binary (should have been copied)."""
        self.length < SMALL_BINARY_THRESHOLD
impl Display for BinaryRef:
    fn fmt() -> text:
        "BinaryRef(id={self.id}, len={self.length})"
impl Eq for BinaryRef:
    fn eq(other: BinaryRef) -> bool:
        self.id == other.id
impl Hash for BinaryRef:
    fn hash() -> i64:
        self.id
# ============================================================================
# Reference-Counted Binary
# ============================================================================

struct RefcBinary:
    """Reference-counted binary data in shared heap.

    The actual binary data with metadata. Stored in the shared heap
    and accessed via BinaryRef handles. Reference count tracks how
    many actors are using this binary.

    Memory layout:
    - Header: id, refcount, length, flags (~32 bytes)
    - Data: variable length byte array

    Thread safety:
    - refcount uses atomic operations
    - data is immutable after creation
    """
    id: i64                 # Unique identifier
    refcount: i64           # Number of references (atomic in real impl)
    length: i64             # Length in bytes
    capacity: i64           # Allocated capacity (>= length)
    hash_cache: i64?        # Cached hash value (computed lazily)
    created_at: i64         # Creation timestamp
    last_accessed: i64      # Last access timestamp (for LRU)

    # Flags
    is_pinned: bool         # Prevent GC collection
    is_sub_binary: bool     # Reference to part of another binary
    parent_id: i64?         # Parent binary ID (if sub-binary)

    # Data pointer (in real impl, this would be actual memory)
    data_ptr: i64           # Opaque pointer to data

fn RefcBinary__new(id: i64, length: i64, data_ptr: i64) -> RefcBinary:
    RefcBinary(
        id: id,
        refcount: 1,
        length: length,
        capacity: length,
        hash_cache: nil,
        created_at: current_time_ms(),
        last_accessed: current_time_ms(),
        is_pinned: false,
        is_sub_binary: false,
        parent_id: nil,
        data_ptr: data_ptr
    )

fn RefcBinary__sub_binary(id: i64, parent_id: i64, offset: i64, length: i64, data_ptr: i64) -> RefcBinary:
    """Create a sub-binary referencing part of a parent binary."""
    RefcBinary(
        id: id,
        refcount: 1,
        length: length,
        capacity: length,
        hash_cache: nil,
        created_at: current_time_ms(),
        last_accessed: current_time_ms(),
        is_pinned: false,
        is_sub_binary: true,
        parent_id: Some(parent_id),
        data_ptr: data_ptr
    )


impl RefcBinary:
    me incref() -> i64:
        """Increment reference count. Returns new count."""
        self.refcount = self.refcount + 1
        self.last_accessed = current_time_ms()
        self.refcount
    me decref() -> i64:
        """Decrement reference count. Returns new count."""
        self.refcount = self.refcount - 1
        self.refcount
    fn can_collect() -> bool:
        """Check if this binary can be garbage collected."""
        self.refcount <= 0 and not self.is_pinned
    me pin():
        """Pin binary to prevent garbage collection."""
        self.is_pinned = true
    me unpin():
        """Unpin binary to allow garbage collection."""
        self.is_pinned = false
    fn total_size() -> i64:
        """Total memory used including header."""
        val header_size: i64 = 64  # Approximate header size
        header_size + self.capacity
    fn age_ms() -> i64:
        """Age since creation in milliseconds."""
        current_time_ms() - self.created_at
    fn idle_time_ms() -> i64:
        """Time since last access in milliseconds."""
        current_time_ms() - self.last_accessed
    fn to_ref(offset: i64) -> BinaryRef:
        """Create a BinaryRef pointing to this binary."""
        BinaryRef__new(self.id, offset, self.length)
impl Display for RefcBinary:
    fn fmt() -> text:
        "RefcBinary(id={self.id}, len={self.length}, refs={self.refcount})"
# ============================================================================
# Shared Heap Statistics
# ============================================================================

struct SharedHeapStats:
    """Statistics for shared binary heap."""
    # Memory usage
    total_size: i64
    used_size: i64
    free_size: i64
    peak_usage: i64

    # Binary counts
    binary_count: i64
    sub_binary_count: i64
    pinned_count: i64

    # Operations
    total_allocations: i64
    total_deallocations: i64
    total_incref: i64
    total_decref: i64

    # GC
    gc_count: i64
    gc_bytes_reclaimed: i64
    defrag_count: i64

    # Fragmentation
    fragment_count: i64
    largest_free_block: i64

fn SharedHeapStats__new() -> SharedHeapStats:
    SharedHeapStats(
        total_size: 0,
        used_size: 0,
        free_size: 0,
        peak_usage: 0,
        binary_count: 0,
        sub_binary_count: 0,
        pinned_count: 0,
        total_allocations: 0,
        total_deallocations: 0,
        total_incref: 0,
        total_decref: 0,
        gc_count: 0,
        gc_bytes_reclaimed: 0,
        defrag_count: 0,
        fragment_count: 0,
        largest_free_block: 0
    )


impl SharedHeapStats:
    fn utilization() -> f64:
        """Heap utilization percentage."""
        if self.total_size == 0:
            0.0
        else:
            (self.used_size as f64) / (self.total_size as f64) * 100.0
    fn fragmentation() -> f64:
        """Fragmentation ratio (0.0 = none, 1.0 = severe)."""
        if self.free_size == 0:
            0.0
        else:
            1.0 - ((self.largest_free_block as f64) / (self.free_size as f64))
    fn avg_binary_size() -> f64:
        """Average binary size."""
        if self.binary_count == 0:
            0.0
        else:
            (self.used_size as f64) / (self.binary_count as f64)
impl Display for SharedHeapStats:
    fn fmt() -> text:
        "SharedHeapStats(used={self.used_size}/{self.total_size}, binaries={self.binary_count})"
# ============================================================================
# Shared Heap
# ============================================================================

struct SharedHeap:
    """Shared heap for reference-counted binaries.

    All large binaries are stored here, shared across all actors.
    Reference counting ensures binaries are freed when no longer used.

    Thread safety:
    - Allocation/deallocation protected by lock (in real impl)
    - Reference count operations are atomic
    - Binary data is immutable after creation

    Example:
        val heap = SharedHeap__new(SharedHeapConfig__default())

        # Allocate a binary
        val binary = heap.allocate(data_ptr, 1024)
        val ref = binary.to_ref(heap.offset_of(binary))

        # Share reference with another actor
        send(other_actor, ref)
        heap.incref(ref.id)

        # Release when done
        heap.decref(ref.id)
    """
    config: SharedHeapConfig
    stats: SharedHeapStats

    # Binary storage
    binaries: Dict<i64, RefcBinary>
    next_binary_id: i64

    # Free list (simplified - real impl would use more sophisticated allocator)
    free_blocks: [(i64, i64)]  # (offset, size) pairs
    next_offset: i64

    # State
    is_collecting: bool

fn SharedHeap__new(config: SharedHeapConfig) -> SharedHeap:
    var stats = SharedHeapStats__new()
    stats.total_size = config.initial_size
    stats.free_size = config.initial_size
    stats.largest_free_block = config.initial_size

    SharedHeap(
        config: config,
        stats: stats,
        binaries: {},
        next_binary_id: 0,
        free_blocks: [(0, config.initial_size)],
        next_offset: 0,
        is_collecting: false
    )

fn SharedHeap__default() -> SharedHeap:
    SharedHeap__new(SharedHeapConfig__default())


impl SharedHeap:
    me allocate(data_ptr: i64, size: i64) -> AllocResult:
        """Allocate a new binary in the shared heap.

        Returns AllocResult with either the BinaryRef or an error.
        """
        if size <= 0:
            return AllocResult.InvalidSize

        if size > MAX_BINARY_SIZE:
            return AllocResult.TooLarge

        # Check if we have space
        if self.stats.used_size + size > self.config.max_size:
            # Try GC first
            self.collect_garbage()

            if self.stats.used_size + size > self.config.max_size:
                return AllocResult.OutOfMemory

        # Find a free block (first-fit)
        val block = self.find_free_block(size)
        if not block.?:
            # Try defragmentation
            self.defragment()
            val block2 = self.find_free_block(size)
            if not block2.?:
                return AllocResult.OutOfMemory

        value (offset, _) = block ?? (self.next_offset, size)

        # Create binary
        val id = self.next_binary_id
        self.next_binary_id = self.next_binary_id + 1

        val binary = RefcBinary__new(id, size, data_ptr)
        self.binaries[id] = binary

        # Update stats
        self.stats.used_size = self.stats.used_size + size
        self.stats.free_size = self.stats.free_size - size
        self.stats.binary_count = self.stats.binary_count + 1
        self.stats.total_allocations = self.stats.total_allocations + 1

        if self.stats.used_size > self.stats.peak_usage:
            self.stats.peak_usage = self.stats.used_size

        # Check if GC needed
        val usage_ratio = (self.stats.used_size as f64) / (self.stats.total_size as f64)
        if usage_ratio > self.config.gc_threshold:
            self.collect_garbage()

        val ref = BinaryRef__new(id, offset, size)
        AllocResult.Success(ref)
    me allocate_sub_binary(parent_id: i64, offset: i64, length: i64) -> AllocResult:
        """Allocate a sub-binary referencing part of an existing binary.

        Sub-binaries don't allocate new data - they reference a slice
        of the parent binary's data. The parent is kept alive via refcount.
        """
        val parent = self.binaries.get(parent_id)
        if not parent.?:
            return AllocResult.ParentNotFound

        var parent_binary = parent.unwrap()

        if offset + length > parent_binary.length:
            return AllocResult.InvalidRange

        # Increment parent refcount
        parent_binary.incref()

        # Create sub-binary
        val id = self.next_binary_id
        self.next_binary_id = self.next_binary_id + 1

        # Data pointer is parent's data_ptr + offset
        val sub_data_ptr = parent_binary.data_ptr + offset
        val sub = RefcBinary__sub_binary(id, parent_id, offset, length, sub_data_ptr)
        self.binaries[id] = sub

        self.stats.sub_binary_count = self.stats.sub_binary_count + 1
        self.stats.binary_count = self.stats.binary_count + 1

        val ref = BinaryRef__new(id, 0, length)
        AllocResult.Success(ref)
    fn find_free_block(size: i64) -> (i64, i64)?:
        """Find a free block that can fit the requested size."""
        for i in 0..self.free_blocks.len():
            value (offset, block_size) = self.free_blocks[i]
            if block_size >= size:
                return Some((offset, block_size))
        nil
    me incref(binary_id: i64) -> bool:
        """Increment reference count for a binary."""
        val binary = self.binaries.get(binary_id)
        if binary.?:
            var b = binary.unwrap()
            b.incref()
            self.stats.total_incref = self.stats.total_incref + 1
            true
        else:
            false
    me decref(binary_id: i64) -> bool:
        """Decrement reference count. May trigger deallocation."""
        val binary = self.binaries.get(binary_id)
        if binary.?:
            var b = binary.unwrap()
            val new_count = b.decref()
            self.stats.total_decref = self.stats.total_decref + 1

            if new_count <= 0 and not b.is_pinned:
                self.deallocate(binary_id)
            true
        else:
            false
    me deallocate(binary_id: i64):
        """Deallocate a binary (internal use)."""
        val binary = self.binaries.get(binary_id)
        if not binary.?:
            return

        val b = binary.unwrap()

        # If sub-binary, decref parent
        if b.is_sub_binary and b.parent_id.?:
            self.decref(b.parent_id.unwrap())
            self.stats.sub_binary_count = self.stats.sub_binary_count - 1
        else:
            # Return space to free list
            self.stats.used_size = self.stats.used_size - b.capacity
            self.stats.free_size = self.stats.free_size + b.capacity

        # Remove from storage
        self.binaries = self.binaries.remove(binary_id)
        self.stats.binary_count = self.stats.binary_count - 1
        self.stats.total_deallocations = self.stats.total_deallocations + 1
    me collect_garbage() -> i64:
        """Collect unreferenced binaries. Returns bytes reclaimed."""
        if self.is_collecting:
            return 0

        self.is_collecting = true
        var reclaimed: i64 = 0
        var to_remove: [i64] = []

        # Find binaries with zero references
        for (id, binary) in self.binaries.entries():
            if binary.can_collect():
                to_remove = to_remove.push(id)
                reclaimed = reclaimed + binary.capacity

        # Remove them
        for id in to_remove:
            self.deallocate(id)

        self.stats.gc_count = self.stats.gc_count + 1
        self.stats.gc_bytes_reclaimed = self.stats.gc_bytes_reclaimed + reclaimed
        self.is_collecting = false

        reclaimed
    me defragment():
        """Defragment the heap by compacting free blocks."""
        # Merge adjacent free blocks (simplified)
        if self.free_blocks.len() < 2:
            return

        # Sort by offset
        self.free_blocks = self.free_blocks.sort_by(\a, b: a.0 - b.0)

        var merged: [(i64, i64)] = []
        var current = self.free_blocks[0]

        for i in 1..self.free_blocks.len():
            value (offset, size) = self.free_blocks[i]
            value (curr_offset, curr_size) = current

            if curr_offset + curr_size == offset:
                # Adjacent - merge
                current = (curr_offset, curr_size + size)
            else:
                merged = merged.push(current)
                current = (offset, size)

        merged = merged.push(current)
        self.free_blocks = merged

        # Update largest free block
        var largest: i64 = 0
        for (_, size) in self.free_blocks:
            if size > largest:
                largest = size
        self.stats.largest_free_block = largest
        self.stats.fragment_count = self.free_blocks.len()
        self.stats.defrag_count = self.stats.defrag_count + 1
    me pin(binary_id: i64) -> bool:
        """Pin a binary to prevent garbage collection."""
        val binary = self.binaries.get(binary_id)
        if binary.?:
            var b = binary.unwrap()
            if not b.is_pinned:
                b.pin()
                self.stats.pinned_count = self.stats.pinned_count + 1
            true
        else:
            false
    me unpin(binary_id: i64) -> bool:
        """Unpin a binary to allow garbage collection."""
        val binary = self.binaries.get(binary_id)
        if binary.?:
            var b = binary.unwrap()
            if b.is_pinned:
                b.unpin()
                self.stats.pinned_count = self.stats.pinned_count - 1
            true
        else:
            false
    fn get(binary_id: i64) -> RefcBinary?:
        """Get a binary by ID."""
        self.binaries.get(binary_id)
    fn get_ref(binary_id: i64) -> BinaryRef?:
        """Get a BinaryRef for a binary."""
        val binary = self.binaries.get(binary_id)
        if binary.?:
            val b = binary.unwrap()
            Some(BinaryRef__new(b.id, 0, b.length))
        else:
            nil
    fn contains(binary_id: i64) -> bool:
        """Check if binary exists in heap."""
        self.binaries.get(binary_id).?
    fn get_stats() -> SharedHeapStats:
        """Get heap statistics."""
        self.stats
    fn binary_count() -> i64:
        """Number of binaries in heap."""
        self.stats.binary_count
impl Display for SharedHeap:
    fn fmt() -> text:
        "SharedHeap(binaries={self.binary_count()}, used={self.stats.used_size})"
# ============================================================================
# Allocation Result
# ============================================================================

enum AllocResult:
    """Result of binary allocation."""
    Success(ref: BinaryRef)
    OutOfMemory
    TooLarge
    InvalidSize
    ParentNotFound
    InvalidRange

impl AllocResult:
    fn is_success() -> bool:
        match self:
            case Success(_): true
            case _: false
    fn unwrap() -> BinaryRef:
        match self:
            case Success(ref): ref
            case _: panic("AllocResult.unwrap() on failure")
    fn ref() -> BinaryRef?:
        match self:
            case Success(ref): Some(ref)
            case _: nil
impl Display for AllocResult:
    fn fmt() -> text:
        match self:
            case Success(ref): "Success({ref})"
            case OutOfMemory: "OutOfMemory"
            case TooLarge: "TooLarge"
            case InvalidSize: "InvalidSize"
            case ParentNotFound: "ParentNotFound"
            case InvalidRange: "InvalidRange"
# ============================================================================
# Global Shared Heap
# ============================================================================

# Global shared heap instance (initialized on first use)
var GLOBAL_SHARED_HEAP: SharedHeap? = nil

fn get_shared_heap() -> SharedHeap:
    """Get the global shared heap, initializing if needed."""
    if not GLOBAL_SHARED_HEAP.?:
        GLOBAL_SHARED_HEAP = Some(SharedHeap__default())
    GLOBAL_SHARED_HEAP__unwrap()

fn shared_heap_allocate(data_ptr: i64, size: i64) -> AllocResult:
    """Allocate in the global shared heap."""
    var heap = get_shared_heap()
    heap.allocate(data_ptr, size)

fn shared_heap_incref(binary_id: i64) -> bool:
    """Increment refcount in global shared heap."""
    var heap = get_shared_heap()
    heap.incref(binary_id)

fn shared_heap_decref(binary_id: i64) -> bool:
    """Decrement refcount in global shared heap."""
    var heap = get_shared_heap()
    heap.decref(binary_id)

# ============================================================================
# Helper Functions
# ============================================================================

fn current_time_ms() -> i64:
    """Get current time in milliseconds (placeholder)."""
    0
