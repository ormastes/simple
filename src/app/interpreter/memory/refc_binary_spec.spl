# RefcBinary Tests
#
# Tests for reference-counted binaries and shared heap.

from refc_binary import {
    RefcBinary,
    BinaryRef,
    SharedHeap,
    SharedHeapConfig,
    SharedHeapStats,
    AllocResult,
    CopyStrategy,
    SMALL_BINARY_THRESHOLD,
    copy_strategy
}

describe "CopyStrategy":
    it "recommends deep copy for small values":
        val strategy = copy_strategy(32)
        assert strategy == CopyStrategy.DeepCopy

    it "recommends share ref for large values":
        val strategy = copy_strategy(128)
        assert strategy == CopyStrategy.ShareRef

    it "uses threshold of 64 bytes":
        assert copy_strategy(63) == CopyStrategy.DeepCopy
        assert copy_strategy(64) == CopyStrategy.ShareRef

    it "determines sharing based on strategy":
        assert not CopyStrategy.DeepCopy.should_share(1000)
        assert CopyStrategy.ShareRef.should_share(10)
        assert not CopyStrategy.Hybrid.should_share(32)
        assert CopyStrategy.Hybrid.should_share(128)

describe "BinaryRef":
    it "creates reference":
        val ref = BinaryRef.new(1, 100, 256)

        assert ref.id == 1
        assert ref.offset == 100
        assert ref.length == 256

    it "reports size":
        val ref = BinaryRef.new(1, 0, 1024)
        assert ref.size() == 1024

    it "identifies small binaries":
        val small = BinaryRef.new(1, 0, 32)
        val large = BinaryRef.new(2, 0, 128)

        assert small.is_small()
        assert not large.is_small()

    it "compares for equality":
        val ref1 = BinaryRef.new(1, 0, 100)
        val ref2 = BinaryRef.new(1, 50, 200)
        val ref3 = BinaryRef.new(2, 0, 100)

        assert ref1.eq(ref2)  # Same ID
        assert not ref1.eq(ref3)  # Different ID

    it "formats for display":
        val ref = BinaryRef.new(42, 0, 256)
        val str = ref.fmt()

        assert str.contains("BinaryRef")
        assert str.contains("42")
        assert str.contains("256")

describe "RefcBinary":
    it "creates with initial refcount of 1":
        val binary = RefcBinary.new(1, 1024, 0)

        assert binary.id == 1
        assert binary.refcount == 1
        assert binary.length == 1024

    it "increments refcount":
        var binary = RefcBinary.new(1, 100, 0)

        val count = binary.incref()

        assert count == 2
        assert binary.refcount == 2

    it "decrements refcount":
        var binary = RefcBinary.new(1, 100, 0)
        binary.incref()

        val count = binary.decref()

        assert count == 1

    it "checks if can collect":
        var binary = RefcBinary.new(1, 100, 0)

        assert not binary.can_collect()

        binary.decref()
        assert binary.can_collect()

    it "respects pinning":
        var binary = RefcBinary.new(1, 100, 0)
        binary.decref()
        binary.pin()

        assert not binary.can_collect()

        binary.unpin()
        assert binary.can_collect()

    it "creates sub-binary":
        val sub = RefcBinary.sub_binary(2, 1, 10, 50, 0)

        assert sub.id == 2
        assert sub.is_sub_binary
        assert sub.parent_id == Some(1)
        assert sub.length == 50

    it "calculates total size":
        val binary = RefcBinary.new(1, 1024, 0)
        val total = binary.total_size()

        # Header (~64) + capacity (1024)
        assert total >= 1024

    it "creates ref from binary":
        val binary = RefcBinary.new(1, 256, 0)
        val ref = binary.to_ref(100)

        assert ref.id == 1
        assert ref.offset == 100
        assert ref.length == 256

describe "SharedHeapConfig":
    it "creates default config":
        val config = SharedHeapConfig.default()

        assert config.initial_size == 64 * 1024 * 1024
        assert config.gc_threshold == 0.8

    it "creates small config":
        val config = SharedHeapConfig.small()

        assert config.initial_size == 1024 * 1024

    it "creates large config":
        val config = SharedHeapConfig.large()

        assert config.initial_size == 256 * 1024 * 1024

describe "SharedHeap - Allocation":
    it "allocates binary":
        var heap = SharedHeap.new(SharedHeapConfig.small())

        val result = heap.allocate(0, 1024)

        assert result.is_success()
        val ref = result.unwrap()
        assert ref.length == 1024

    it "tracks allocation stats":
        var heap = SharedHeap.new(SharedHeapConfig.small())

        heap.allocate(0, 1000)
        heap.allocate(0, 2000)

        val stats = heap.get_stats()
        assert stats.binary_count == 2
        assert stats.used_size == 3000
        assert stats.total_allocations == 2

    it "rejects zero size":
        var heap = SharedHeap.new(SharedHeapConfig.small())

        val result = heap.allocate(0, 0)

        assert result == AllocResult.InvalidSize

    it "rejects too large":
        var heap = SharedHeap.new(SharedHeapConfig.small())

        val result = heap.allocate(0, 2 * 1024 * 1024 * 1024)  # 2 GB

        assert result == AllocResult.TooLarge

    it "returns out of memory when full":
        val config = SharedHeapConfig(
            initial_size: 1000,
            max_size: 1000,
            grow_factor: 1.5,
            gc_threshold: 0.99,
            defrag_threshold: 0.3
        )
        var heap = SharedHeap.new(config)

        heap.allocate(0, 900)
        val result = heap.allocate(0, 200)

        assert result == AllocResult.OutOfMemory

describe "SharedHeap - Sub-binaries":
    it "allocates sub-binary":
        var heap = SharedHeap.new(SharedHeapConfig.small())

        val parent_result = heap.allocate(0, 1024)
        val parent_ref = parent_result.unwrap()

        val sub_result = heap.allocate_sub_binary(parent_ref.id, 100, 200)

        assert sub_result.is_success()
        val sub_ref = sub_result.unwrap()
        assert sub_ref.length == 200

    it "fails for nonexistent parent":
        var heap = SharedHeap.new(SharedHeapConfig.small())

        val result = heap.allocate_sub_binary(999, 0, 100)

        assert result == AllocResult.ParentNotFound

    it "fails for invalid range":
        var heap = SharedHeap.new(SharedHeapConfig.small())

        val parent_result = heap.allocate(0, 100)
        val parent_ref = parent_result.unwrap()

        val result = heap.allocate_sub_binary(parent_ref.id, 50, 100)  # 50 + 100 > 100

        assert result == AllocResult.InvalidRange

    it "tracks sub-binary count":
        var heap = SharedHeap.new(SharedHeapConfig.small())

        val parent_result = heap.allocate(0, 1024)
        val parent_ref = parent_result.unwrap()

        heap.allocate_sub_binary(parent_ref.id, 0, 100)
        heap.allocate_sub_binary(parent_ref.id, 100, 200)

        val stats = heap.get_stats()
        assert stats.sub_binary_count == 2

describe "SharedHeap - Reference Counting":
    it "increments refcount":
        var heap = SharedHeap.new(SharedHeapConfig.small())

        val result = heap.allocate(0, 100)
        val ref = result.unwrap()

        assert heap.incref(ref.id)

        val binary = heap.get(ref.id)
        assert binary.?.refcount == 2

    it "decrements refcount":
        var heap = SharedHeap.new(SharedHeapConfig.small())

        val result = heap.allocate(0, 100)
        val ref = result.unwrap()
        heap.incref(ref.id)

        assert heap.decref(ref.id)

        val binary = heap.get(ref.id)
        assert binary.?.refcount == 1

    it "deallocates when refcount reaches zero":
        var heap = SharedHeap.new(SharedHeapConfig.small())

        val result = heap.allocate(0, 100)
        val ref = result.unwrap()

        heap.decref(ref.id)

        assert not heap.contains(ref.id)
        assert heap.get_stats().binary_count == 0

    it "tracks incref/decref stats":
        var heap = SharedHeap.new(SharedHeapConfig.small())

        val result = heap.allocate(0, 100)
        val ref = result.unwrap()

        heap.incref(ref.id)
        heap.incref(ref.id)
        heap.decref(ref.id)

        val stats = heap.get_stats()
        assert stats.total_incref == 2
        assert stats.total_decref == 1

describe "SharedHeap - Garbage Collection":
    it "collects unreferenced binaries":
        var heap = SharedHeap.new(SharedHeapConfig.small())

        heap.allocate(0, 1000)
        heap.allocate(0, 2000)

        # Decref both to make them collectible
        heap.decref(0)
        heap.decref(1)

        val reclaimed = heap.collect_garbage()

        assert reclaimed == 3000
        assert heap.binary_count() == 0

    it "preserves referenced binaries":
        var heap = SharedHeap.new(SharedHeapConfig.small())

        val result = heap.allocate(0, 1000)
        val ref = result.unwrap()
        heap.incref(ref.id)  # Extra reference

        heap.decref(ref.id)  # Drop one reference
        heap.collect_garbage()

        assert heap.contains(ref.id)

    it "preserves pinned binaries":
        var heap = SharedHeap.new(SharedHeapConfig.small())

        val result = heap.allocate(0, 1000)
        val ref = result.unwrap()
        heap.pin(ref.id)
        heap.decref(ref.id)  # Refcount = 0

        heap.collect_garbage()

        assert heap.contains(ref.id)  # Still there because pinned

describe "SharedHeap - Pinning":
    it "pins binary":
        var heap = SharedHeap.new(SharedHeapConfig.small())

        val result = heap.allocate(0, 100)
        val ref = result.unwrap()

        assert heap.pin(ref.id)

        val stats = heap.get_stats()
        assert stats.pinned_count == 1

    it "unpins binary":
        var heap = SharedHeap.new(SharedHeapConfig.small())

        val result = heap.allocate(0, 100)
        val ref = result.unwrap()

        heap.pin(ref.id)
        heap.unpin(ref.id)

        val stats = heap.get_stats()
        assert stats.pinned_count == 0

describe "SharedHeap - Statistics":
    it "tracks peak usage":
        var heap = SharedHeap.new(SharedHeapConfig.small())

        heap.allocate(0, 1000)
        heap.allocate(0, 2000)
        heap.decref(0)
        heap.collect_garbage()

        val stats = heap.get_stats()
        assert stats.peak_usage == 3000

    it "calculates utilization":
        var heap = SharedHeap.new(SharedHeapConfig.small())

        heap.allocate(0, 512 * 1024)  # 512 KB of 1 MB

        val stats = heap.get_stats()
        val util = stats.utilization()
        assert util > 40.0 and util < 60.0

    it "calculates fragmentation":
        val stats = SharedHeapStats.new()
        # Fragmentation depends on free block distribution
        val frag = stats.fragmentation()
        assert frag >= 0.0 and frag <= 1.0

describe "SharedHeap - Defragmentation":
    it "merges adjacent free blocks":
        var heap = SharedHeap.new(SharedHeapConfig.small())

        # Allocate and free multiple binaries
        heap.allocate(0, 100)
        heap.allocate(0, 100)
        heap.allocate(0, 100)

        heap.decref(0)
        heap.decref(1)
        heap.decref(2)

        heap.defragment()

        val stats = heap.get_stats()
        assert stats.defrag_count == 1

describe "SharedHeap - Queries":
    it "gets binary by ID":
        var heap = SharedHeap.new(SharedHeapConfig.small())

        val result = heap.allocate(0, 256)
        val ref = result.unwrap()

        val binary = heap.get(ref.id)

        assert binary.?
        assert binary.unwrap().length == 256

    it "gets ref for binary":
        var heap = SharedHeap.new(SharedHeapConfig.small())

        heap.allocate(0, 256)

        val ref = heap.get_ref(0)

        assert ref.?
        assert ref.unwrap().length == 256

    it "checks containment":
        var heap = SharedHeap.new(SharedHeapConfig.small())

        heap.allocate(0, 100)

        assert heap.contains(0)
        assert not heap.contains(999)

describe "AllocResult":
    it "checks success":
        val success = AllocResult.Success(BinaryRef.new(1, 0, 100))
        val failure = AllocResult.OutOfMemory

        assert success.is_success()
        assert not failure.is_success()

    it "unwraps success":
        val result = AllocResult.Success(BinaryRef.new(1, 0, 100))
        val ref = result.unwrap()

        assert ref.id == 1

    it "gets optional ref":
        val success = AllocResult.Success(BinaryRef.new(1, 0, 100))
        val failure = AllocResult.OutOfMemory

        assert success.ref().?
        assert not failure.ref().?

    it "formats for display":
        val success = AllocResult.Success(BinaryRef.new(1, 0, 100))
        val failure = AllocResult.OutOfMemory

        assert success.fmt().contains("Success")
        assert failure.fmt() == "OutOfMemory"
