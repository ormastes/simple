# Debugging Support
#
# Debug printing, tracing, and breakpoints.

import ..core.{Interpreter, Value, InterpreterError}
import std.io

export debug_print, set_trace, Debugger, DebugLevel

# Debug output levels
enum DebugLevel:
    Off
    Error
    Warn
    Info
    Debug
    Trace

# Global debug state
static mut DEBUG_LEVEL: DebugLevel = DebugLevel.Off
static mut TRACE_ENABLED: bool = false

# Set debug level
fn set_debug_level(level: DebugLevel):
    unsafe:
        DEBUG_LEVEL = level

# Get current debug level
fn get_debug_level() -> DebugLevel:
    unsafe:
        return DEBUG_LEVEL.clone()

# Enable/disable tracing
fn set_trace(enabled: bool):
    unsafe:
        TRACE_ENABLED = enabled

# Check if tracing is enabled
fn is_trace_enabled() -> bool:
    unsafe:
        return TRACE_ENABLED

# Debug print (respects debug level)
fn debug_print(level: DebugLevel, msg: &str):
    if should_print(level):
        val prefix = match level:
            case DebugLevel.Error: "[ERROR]"
            case DebugLevel.Warn: "[WARN]"
            case DebugLevel.Info: "[INFO]"
            case DebugLevel.Debug: "[DEBUG]"
            case DebugLevel.Trace: "[TRACE]"
            case _: ""

        io.println("{prefix} {msg}")

fn should_print(level: DebugLevel) -> bool:
    val current = get_debug_level()
    return level_to_int(level) <= level_to_int(current)

fn level_to_int(level: DebugLevel) -> i32:
    match level:
        case DebugLevel.Off: 0
        case DebugLevel.Error: 1
        case DebugLevel.Warn: 2
        case DebugLevel.Info: 3
        case DebugLevel.Debug: 4
        case DebugLevel.Trace: 5

# Debugger instance
struct Debugger:
    breakpoints: Dict<String, Breakpoint>
    watch_expressions: Array<String>
    call_stack: Array<StackFrame>
    is_stepping: bool
    step_mode: StepMode

enum StepMode:
    Continue
    StepOver
    StepInto
    StepOut

struct Breakpoint:
    file: String
    line: u32
    condition: Option<String>
    hit_count: u32
    enabled: bool

struct StackFrame:
    fn_name: String
    file: String
    line: u32
    locals: Dict<String, Value>

impl Debugger:
    static fn new() -> Debugger:
        return Debugger {
            breakpoints: Dict.new(),
            watch_expressions: [],
            call_stack: [],
            is_stepping: false,
            step_mode: StepMode.Continue
        }

    # Breakpoint management
    fn add_breakpoint(file: &str, line: u32, condition: Option<String>):
        val key = "{file}:{line}"
        self.breakpoints.set(key, Breakpoint {
            file: file.to_string(),
            line: line,
            condition: condition,
            hit_count: 0,
            enabled: true
        })

    fn remove_breakpoint(file: &str, line: u32):
        val key = "{file}:{line}"
        self.breakpoints.remove(&key)

    fn toggle_breakpoint(file: &str, line: u32):
        val key = "{file}:{line}"
        if val Some(bp) = self.breakpoints.get_mut(&key):
            bp.enabled = not bp.enabled

    fn has_breakpoint(file: &str, line: u32) -> bool:
        val key = "{file}:{line}"
        if val Some(bp) = self.breakpoints.get(&key):
            return bp.enabled
        return false

    # Watch expressions
    fn add_watch(expr: String):
        self.watch_expressions.push(expr)

    fn remove_watch(idx: usize):
        if idx < self.watch_expressions.len():
            self.watch_expressions.remove(idx)

    fn evaluate_watches(interp: &Interpreter) -> Array:
        val results = []

        for expr in self.watch_expressions:
            val result = interp.eval_expression_string(&expr)
            if result.is_ok():
                val v = result.unwrap()
                results.push((expr.clone(), Ok(v)))
            else:
                val e = result.unwrap_err()
                results.push((expr.clone(), Err(e.to_string())))

        return results

    # Call stack management
    fn push_frame(frame: StackFrame):
        self.call_stack.push(frame)

    fn pop_frame():
        self.call_stack.pop()

    fn current_frame() -> Option<&StackFrame>:
        if self.call_stack.is_empty():
            return None
        return Some(&self.call_stack[self.call_stack.len() - 1])

    fn get_stack_trace() -> Array<String>:
        val trace = []
        for (i, frame) in self.call_stack.iter().enumerate().rev():
            trace.push("  #{i}: {frame.fn_name} at {frame.file}:{frame.line}")
        return trace

    # Stepping control
    fn step_over():
        self.is_stepping = true
        self.step_mode = StepMode.StepOver

    fn step_into():
        self.is_stepping = true
        self.step_mode = StepMode.StepInto

    fn step_out():
        self.is_stepping = true
        self.step_mode = StepMode.StepOut

    fn continue_execution():
        self.is_stepping = false
        self.step_mode = StepMode.Continue

    # Check if should break
    fn should_break(file: &str, line: u32) -> bool:
        # Check breakpoints
        if self.has_breakpoint(file, line):
            val key = "{file}:{line}"
            if val Some(bp) = self.breakpoints.get_mut(&key):
                bp.hit_count += 1
                return true

        # Check stepping
        if self.is_stepping:
            match self.step_mode:
                case StepMode.StepInto:
                    return true
                case StepMode.StepOver:
                    # Break at same or lower stack depth
                    return true  # Simplified
                case StepMode.StepOut:
                    # Break when we leave current function
                    return false  # Simplified
                case _:
                    return false

        return false

# REPL debugger commands
fn handle_debug_command(debugger: &mut Debugger, interp: &Interpreter, cmd: &str) -> Result<String, String>:
    val parts = cmd.split_whitespace().collect()
    if parts.is_empty():
        return Ok("".to_string())

    match parts[0].as_str():
        case "break" | "b":
            if parts.len() < 2:
                return Err("Usage: break <file>:<line>".to_string())
            # Parse file:line
            val loc = parts[1].split(":")
            if loc.len() != 2:
                return Err("Invalid breakpoint format".to_string())
            val file = loc[0]
            val parse_result = loc[1].parse()
            if not parse_result.is_ok():
                return Err("Invalid line number".to_string())
            val line = parse_result.unwrap()
            debugger.add_breakpoint(file, line, None)
            return Ok("Breakpoint set at {file}:{line}".to_string())

        case "delete" | "d":
            if parts.len() < 2:
                return Err("Usage: delete <file>:<line>".to_string())
            val loc = parts[1].split(":")
            if loc.len() != 2:
                return Err("Invalid breakpoint format".to_string())
            val file = loc[0]
            val parse_result = loc[1].parse()
            if not parse_result.is_ok():
                return Err("Invalid line number".to_string())
            val line = parse_result.unwrap()
            debugger.remove_breakpoint(file, line)
            return Ok("Breakpoint removed".to_string())

        case "continue" | "c":
            debugger.continue_execution()
            return Ok("Continuing...".to_string())

        case "step" | "s":
            debugger.step_into()
            return Ok("Stepping into...".to_string())

        case "next" | "n":
            debugger.step_over()
            return Ok("Stepping over...".to_string())

        case "finish" | "f":
            debugger.step_out()
            return Ok("Stepping out...".to_string())

        case "backtrace" | "bt":
            val trace = debugger.get_stack_trace()
            return Ok(trace.join("\n"))

        case "print" | "p":
            if parts.len() < 2:
                return Err("Usage: print <expr>".to_string())
            val expr = parts[1..].join(" ")
            val result = interp.eval_expression_string(&expr)
            if result.is_ok():
                return Ok(result.unwrap().to_string())
            else:
                return Err(result.unwrap_err().to_string())

        case "watch" | "w":
            if parts.len() < 2:
                return Err("Usage: watch <expr>".to_string())
            val expr = parts[1..].join(" ")
            debugger.add_watch(expr)
            return Ok("Watch added".to_string())

        case "help" | "h":
            return Ok(
                "Debug commands:\n" +
                "  break <file>:<line>  - Set breakpoint\n" +
                "  delete <file>:<line> - Remove breakpoint\n" +
                "  continue             - Continue execution\n" +
                "  step                 - Step into\n" +
                "  next                 - Step over\n" +
                "  finish               - Step out\n" +
                "  backtrace            - Show call stack\n" +
                "  print <expr>         - Evaluate expression\n" +
                "  watch <expr>         - Add watch expression"
            )

        case _:
            return Err("Unknown command: {parts[0]}. Type 'help' for commands.".to_string())
