# Debugging Support (Simple Version)
#
# Debug printing, tracing, and breakpoints for Simple interpreter.

# ============================================================================
# Enums
# ============================================================================

enum DebugLevel:
    Off
    Error
    Warn
    Info
    Debug
    Trace

enum StepMode:
    Continue
    StepOver
    StepInto
    StepOut

# ============================================================================
# Classes
# ============================================================================

class Breakpoint:
    file: text
    line: i64
    condition: text  # Empty string means no condition
    hit_count: i64
    enabled: bool

class StackFrame:
    fn_name: text
    file: text
    line: i64
    locals: [text]  # Array of "name=value" strings

class Debugger:
    breakpoints: [Breakpoint]
    watch_expressions: [text]
    call_stack: [StackFrame]
    is_stepping: bool
    step_mode: StepMode

# ============================================================================
# Global State (module-level variables)
# ============================================================================

var g_debug_level = DebugLevel.Off
var g_trace_enabled = false

# ============================================================================
# Debug Level Functions
# ============================================================================

fn set_debug_level(level: DebugLevel):
    g_debug_level = level

fn get_debug_level() -> DebugLevel:
    g_debug_level

fn level_to_int(level: DebugLevel) -> i64:
    if level == DebugLevel.Off:
        return 0
    if level == DebugLevel.Error:
        return 1
    if level == DebugLevel.Warn:
        return 2
    if level == DebugLevel.Info:
        return 3
    if level == DebugLevel.Debug:
        return 4
    if level == DebugLevel.Trace:
        return 5
    0  # Default

fn should_print(level: DebugLevel) -> bool:
    val current_int = level_to_int(g_debug_level)
    val level_int = level_to_int(level)
    level_int <= current_int

# ============================================================================
# Trace Functions
# ============================================================================

fn set_trace(enabled: bool):
    g_trace_enabled = enabled

fn is_trace_enabled() -> bool:
    g_trace_enabled

# ============================================================================
# Debug Print
# ============================================================================

fn debug_print(level: DebugLevel, msg: text):
    if not should_print(level):
        return

    var prefix = ""
    if level == DebugLevel.Error:
        prefix = "[ERROR]"
    if level == DebugLevel.Warn:
        prefix = "[WARN]"
    if level == DebugLevel.Info:
        prefix = "[INFO]"
    if level == DebugLevel.Debug:
        prefix = "[DEBUG]"
    if level == DebugLevel.Trace:
        prefix = "[TRACE]"

    print "{prefix} {msg}"

# ============================================================================
# Debugger Factory and Methods
# ============================================================================

fn debugger_new() -> Debugger:
    Debugger(
        breakpoints: [],
        watch_expressions: [],
        call_stack: [],
        is_stepping: false,
        step_mode: StepMode.Continue
    )

# Breakpoint management

fn debugger_add_breakpoint(debugger: Debugger, file: text, line: i64, condition: text):
    val bp = Breakpoint(
        file: file,
        line: line,
        condition: condition,
        hit_count: 0,
        enabled: true
    )
    debugger.breakpoints.push(bp)

fn debugger_remove_breakpoint(debugger: Debugger, file: text, line: i64):
    var new_breakpoints = []
    for bp in debugger.breakpoints:
        if bp.file != file or bp.line != line:
            new_breakpoints.push(bp)
    debugger.breakpoints = new_breakpoints

fn debugger_toggle_breakpoint(debugger: Debugger, file: text, line: i64):
    for bp in debugger.breakpoints:
        if bp.file == file and bp.line == line:
            bp.enabled = not bp.enabled

fn debugger_has_breakpoint(debugger: Debugger, file: text, line: i64) -> bool:
    for bp in debugger.breakpoints:
        if bp.file == file and bp.line == line and bp.enabled:
            return true
    false

fn debugger_list_breakpoints(debugger: Debugger) -> [text]:
    var result = []
    for bp in debugger.breakpoints:
        val status = if bp.enabled: "enabled" else: "disabled"
        result.push("{bp.file}:{bp.line} ({status}, hit {bp.hit_count} times)")
    result

# Watch expressions

fn debugger_add_watch(debugger: Debugger, expr: text):
    debugger.watch_expressions.push(expr)

fn debugger_remove_watch(debugger: Debugger, idx: i64):
    if idx >= 0 and idx < debugger.watch_expressions.len():
        var new_watches = []
        for i in 0..debugger.watch_expressions.len():
            if i != idx:
                new_watches.push(debugger.watch_expressions[i])
        debugger.watch_expressions = new_watches

fn debugger_list_watches(debugger: Debugger) -> [text]:
    debugger.watch_expressions

# Call stack management

fn debugger_push_frame(debugger: Debugger, frame: StackFrame):
    debugger.call_stack.push(frame)

fn debugger_pop_frame(debugger: Debugger):
    if debugger.call_stack.len() > 0:
        debugger.call_stack.pop()

fn debugger_current_frame(debugger: Debugger) -> StackFrame:
    if debugger.call_stack.len() == 0:
        return StackFrame(fn_name: "", file: "", line: 0, locals: [])
    debugger.call_stack[debugger.call_stack.len() - 1]

fn debugger_get_stack_trace(debugger: Debugger) -> [text]:
    var trace = []
    val depth = debugger.call_stack.len()
    for i in 0..depth:
        val idx = depth - 1 - i
        val frame = debugger.call_stack[idx]
        trace.push("  #{i}: {frame.fn_name} at {frame.file}:{frame.line}")
    trace

# Stepping control

fn debugger_step_over(debugger: Debugger):
    debugger.is_stepping = true
    debugger.step_mode = StepMode.StepOver

fn debugger_step_into(debugger: Debugger):
    debugger.is_stepping = true
    debugger.step_mode = StepMode.StepInto

fn debugger_step_out(debugger: Debugger):
    debugger.is_stepping = true
    debugger.step_mode = StepMode.StepOut

fn debugger_continue_execution(debugger: Debugger):
    debugger.is_stepping = false
    debugger.step_mode = StepMode.Continue

# Should break check

fn debugger_should_break(debugger: Debugger, file: text, line: i64) -> bool:
    # Check breakpoints
    for bp in debugger.breakpoints:
        if bp.file == file and bp.line == line and bp.enabled:
            bp.hit_count = bp.hit_count + 1
            return true

    # Check stepping
    if debugger.is_stepping:
        if debugger.step_mode == StepMode.StepInto:
            return true
        if debugger.step_mode == StepMode.StepOver:
            return true  # Simplified: break at every line
        if debugger.step_mode == StepMode.StepOut:
            return false  # Simplified: don't break until we exit

    false

# ============================================================================
# Command Handler
# ============================================================================

fn handle_debug_command(debugger: Debugger, cmd: text) -> text:
    """
    Handle debug commands. Returns result message or error message.
    """
    val parts = cmd.split(" ")
    if parts.len() == 0:
        return ""

    val command = parts[0]

    # break <file>:<line>
    if command == "break" or command == "b":
        if parts.len() < 2:
            return "ERROR: Usage: break <file>:<line>"
        val location = parts[1]
        val loc_parts = location.split(":")
        if loc_parts.len() != 2:
            return "ERROR: Invalid breakpoint format"
        val file = loc_parts[0]
        val line = int(loc_parts[1])
        debugger_add_breakpoint(debugger, file, line, "")
        return "Breakpoint set at {file}:{line}"

    # delete <file>:<line>
    if command == "delete" or command == "d":
        if parts.len() < 2:
            return "ERROR: Usage: delete <file>:<line>"
        val location = parts[1]
        val loc_parts = location.split(":")
        if loc_parts.len() != 2:
            return "ERROR: Invalid breakpoint format"
        val file = loc_parts[0]
        val line = int(loc_parts[1])
        debugger_remove_breakpoint(debugger, file, line)
        return "Breakpoint removed"

    # continue
    if command == "continue" or command == "c":
        debugger_continue_execution(debugger)
        return "Continuing..."

    # step
    if command == "step" or command == "s":
        debugger_step_into(debugger)
        return "Stepping into..."

    # next
    if command == "next" or command == "n":
        debugger_step_over(debugger)
        return "Stepping over..."

    # finish
    if command == "finish" or command == "f":
        debugger_step_out(debugger)
        return "Stepping out..."

    # backtrace
    if command == "backtrace" or command == "bt":
        val trace = debugger_get_stack_trace(debugger)
        var result = "Call stack:\n"
        for line in trace:
            result = result + line + "\n"
        return result

    # print <expr>
    if command == "print" or command == "p":
        if parts.len() < 2:
            return "ERROR: Usage: print <expr>"
        var expr = ""
        for i in 1..parts.len():
            if i > 1:
                expr = expr + " "
            expr = expr + parts[i]
        return "EXPR: {expr}"  # Simplified: just echo the expression

    # watch <expr>
    if command == "watch" or command == "w":
        if parts.len() < 2:
            return "ERROR: Usage: watch <expr>"
        var expr = ""
        for i in 1..parts.len():
            if i > 1:
                expr = expr + " "
            expr = expr + parts[i]
        debugger_add_watch(debugger, expr)
        return "Watch added"

    # help
    if command == "help" or command == "h":
        var help_text = "Debug commands:\n"
        help_text = help_text + "  break <file>:<line>  - Set breakpoint\n"
        help_text = help_text + "  delete <file>:<line> - Remove breakpoint\n"
        help_text = help_text + "  continue             - Continue execution\n"
        help_text = help_text + "  step                 - Step into\n"
        help_text = help_text + "  next                 - Step over\n"
        help_text = help_text + "  finish               - Step out\n"
        help_text = help_text + "  backtrace            - Show call stack\n"
        help_text = help_text + "  print <expr>         - Evaluate expression\n"
        help_text = help_text + "  watch <expr>         - Add watch expression\n"
        help_text = help_text + "  help                 - Show this help"
        return help_text

    # Unknown command
    "ERROR: Unknown command: {command}. Type 'help' for commands."

# ============================================================================
# Exports
# ============================================================================

export DebugLevel, StepMode, Breakpoint, StackFrame, Debugger
export set_debug_level, get_debug_level, level_to_int, should_print
export set_trace, is_trace_enabled
export debug_print
export debugger_new
export debugger_add_breakpoint, debugger_remove_breakpoint, debugger_toggle_breakpoint
export debugger_has_breakpoint, debugger_list_breakpoints
export debugger_add_watch, debugger_remove_watch, debugger_list_watches
export debugger_push_frame, debugger_pop_frame, debugger_current_frame, debugger_get_stack_trace
export debugger_step_over, debugger_step_into, debugger_step_out, debugger_continue_execution
export debugger_should_break
export handle_debug_command
