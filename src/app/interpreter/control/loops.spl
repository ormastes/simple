# Loop Statements
#
# for, while, loop evaluation with break/continue.
# Supports while-val pattern binding, for with destructuring,
# auto_enumerate, and suspension (for~/while~).
# Port of exec_for, exec_while, exec_loop from interpreter_control.rs

from ..core import {Interpreter, Value, InterpreterError}
from ..expr import {evaluate}
from match import {match_pattern, bind_pattern}

export eval_for, eval_while, eval_loop, ControlFlow

# Control flow signals
enum ControlFlow:
    Continue
    Break(Value)
    Return(Value)

# ================================================================
# For Loop
# ================================================================

# Evaluate a for loop with pattern binding and auto_enumerate support
fn eval_for(interp: Interpreter, pattern: Pattern, iterable_expr: Expr,
            body: Block, is_suspend: bool, auto_enumerate: bool) -> Result<Value, InterpreterError>:
    val iterable = evaluate(interp, iterable_expr)?

    # For for~ (is_suspend), await the iterable if it's a Promise
    val iterable = if is_suspend: iterable.await_if_promise()? else: iterable

    # Check if iterating over a Dict (already returns (key, value) tuples)
    val is_dict_iteration = iterable.is_dict()

    # Convert to iterable sequence
    val items = get_iterable(iterable)?

    var index = 0
    for item in items:
        # For for~ (is_suspend), await each item
        val item = if is_suspend: item.await_if_promise()? else: item

        # Create the value to bind - either (index, item) tuple or just item
        val bind_value = if auto_enumerate and not is_dict_iteration:
            Value.tuple([Value.int(index), item])
        else:
            item

        # Use pattern binding to handle all pattern types
        interp.env.push_scope()
        val matched = bind_pattern(interp, pattern, bind_value)
        if not matched:
            interp.env.pop_scope()
            index = index + 1
            continue

        # Execute body
        match eval_loop_body(interp, body):
            case Ok(ControlFlow.Continue):
                interp.env.pop_scope()
                index = index + 1
                continue
            case Ok(ControlFlow.Break(value)):
                interp.env.pop_scope()
                return Ok(value)
            case Ok(ControlFlow.Return(value)):
                interp.env.pop_scope()
                return Err(InterpreterError.Return(value))
            case Err(e):
                interp.env.pop_scope()
                return Err(e)

        interp.env.pop_scope()
        index = index + 1

    Ok(Value.nil())

# ================================================================
# While Loop
# ================================================================

# Evaluate a while loop with optional while-val pattern binding
fn eval_while(interp: Interpreter, condition: Expr, body: Block,
              let_pattern: Pattern?, is_suspend: bool) -> Result<Value, InterpreterError>:

    # Handle while-val: while val Some(x) = expr:
    if let_pattern.?:
        val pattern = let_pattern.unwrap()
        loop:
            val value = evaluate(interp, condition)?
            val bindings = match_pattern(value, pattern)?
            if not bindings.?:
                break
            # Pattern matched - add bindings and execute body
            interp.env.push_scope()
            for (name, val) in bindings.unwrap():
                interp.env.define(name, val)
            match eval_loop_body(interp, body):
                case Ok(ControlFlow.Continue):
                    interp.env.pop_scope()
                    continue
                case Ok(ControlFlow.Break(value)):
                    interp.env.pop_scope()
                    return Ok(value)
                case Ok(ControlFlow.Return(value)):
                    interp.env.pop_scope()
                    return Err(InterpreterError.Return(value))
                case Err(e):
                    interp.env.pop_scope()
                    return Err(e)
            interp.env.pop_scope()
        return Ok(Value.nil())

    # Normal while loop
    loop:
        val cond_val = evaluate(interp, condition)?
        val cond_val = if is_suspend: cond_val.await_if_promise()? else: cond_val

        if not cond_val.is_truthy():
            break

        match eval_loop_body(interp, body):
            case Ok(ControlFlow.Continue):
                continue
            case Ok(ControlFlow.Break(value)):
                return Ok(value)
            case Ok(ControlFlow.Return(value)):
                return Err(InterpreterError.Return(value))
            case Err(e):
                return Err(e)

    Ok(Value.nil())

# ================================================================
# Infinite Loop
# ================================================================

# Evaluate an infinite loop (loop: body)
fn eval_loop(interp: Interpreter, body: Block) -> Result<Value, InterpreterError>:
    loop:
        match eval_loop_body(interp, body):
            case Ok(ControlFlow.Continue):
                continue
            case Ok(ControlFlow.Break(value)):
                return Ok(value)
            case Ok(ControlFlow.Return(value)):
                return Err(InterpreterError.Return(value))
            case Err(e):
                return Err(e)

# ================================================================
# Loop Body Execution Helper
# ================================================================

# Execute loop body and handle break/continue
fn eval_loop_body(interp: Interpreter, body: Block) -> Result<ControlFlow, InterpreterError>:
    for stmt in body.statements:
        match interp.eval_stmt(stmt):
            case Ok(_):
                pass
            case Err(InterpreterError.Break):
                return Ok(ControlFlow.Break(Value.nil()))
            case Err(InterpreterError.BreakValue(value)):
                return Ok(ControlFlow.Break(value))
            case Err(InterpreterError.Continue):
                return Ok(ControlFlow.Continue)
            case Err(InterpreterError.Return(value)):
                return Ok(ControlFlow.Return(value))
            case Err(e):
                return Err(e)

    Ok(ControlFlow.Continue)

# ================================================================
# Iterable Conversion
# ================================================================

# Convert a value to an iterable sequence
fn get_iterable(value: Value) -> Result<[Value], InterpreterError>:
    match value:
        case Value.Array(arr):
            Ok(arr)
        case Value.Tuple(items):
            Ok(items)
        case Value.String(s):
            # Iterate over characters
            Ok(s.chars().map(\c: Value.string(c)))
        case Value.Dict(d):
            # Iterate over (key, value) tuples
            Ok(d.entries().map(\e: Value.tuple([e.0, e.1])))
        case Value.Set(s):
            Ok(s.to_array())
        case Value.Range(start, end, inclusive):
            if inclusive:
                Ok([for i in start..=end: Value.int(i)])
            else:
                Ok([for i in start..end: Value.int(i)])
        case Value.Int(n):
            # Range iteration: 0..n
            if n < 0:
                return Err(InterpreterError.ValueError("negative range"))
            Ok([for i in 0..n: Value.int(i)])
        case _:
            Err(InterpreterError.TypeError("value is not iterable"))
