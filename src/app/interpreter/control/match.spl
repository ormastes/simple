# Pattern Matching
#
# Full pattern matching implementation with all pattern types:
# Wildcard, Identifier, MutIdentifier, MoveIdentifier, Literal,
# Enum (with payload), Tuple, Array (with rest/spread), Struct,
# Or, Typed, Range, FString patterns, Guards, Exhaustiveness checking.
# Port of interpreter_patterns.rs and exec_match from interpreter_control.rs

from ..core import {Interpreter, Value, InterpreterError}
from ..expr import {evaluate}

export eval_match, eval_match_expr, eval_case
export match_pattern, bind_pattern
export is_catch_all_pattern, check_enum_exhaustiveness

# ================================================================
# Match Statement
# ================================================================

# Evaluate a match expression
fn eval_match(interp: Interpreter, scrutinee: Expr, arms: [MatchArm]) -> Result<Value, InterpreterError>:
    val value = evaluate(interp, scrutinee)?

    for arm in arms:
        val bindings = match_pattern(value, arm.pattern)?
        if bindings.?:
            # Check guard if present
            if arm.guard.?:
                interp.env.push_scope()
                for (name, val) in bindings.unwrap():
                    interp.env.define(name, val)
                val guard_result = evaluate(interp, arm.guard.unwrap())?
                if not guard_result.is_truthy():
                    interp.env.pop_scope()
                    continue
                val result = interp.eval_block(arm.body)
                interp.env.pop_scope()
                return result
            else:
                interp.env.push_scope()
                for (name, val) in bindings.unwrap():
                    interp.env.define(name, val)
                val result = interp.eval_block(arm.body)
                interp.env.pop_scope()
                return result

    # No arm matched
    Err(InterpreterError.MatchError("non-exhaustive match"))

# Evaluate match as expression (returns value of matched arm)
fn eval_match_expr(interp: Interpreter, scrutinee: Expr, arms: [MatchArm]) -> Result<Value, InterpreterError>:
    val value = evaluate(interp, scrutinee)?

    for arm in arms:
        val bindings = match_pattern(value, arm.pattern)?
        if bindings.?:
            if arm.guard.?:
                interp.env.push_scope()
                for (name, val) in bindings.unwrap():
                    interp.env.define(name, val)
                val guard_result = evaluate(interp, arm.guard.unwrap())?
                if not guard_result.is_truthy():
                    interp.env.pop_scope()
                    continue
                val result = interp.eval_block_value(arm.body)
                interp.env.pop_scope()
                return result
            else:
                interp.env.push_scope()
                for (name, val) in bindings.unwrap():
                    interp.env.define(name, val)
                val result = interp.eval_block_value(arm.body)
                interp.env.pop_scope()
                return result

    Ok(Value.nil())

# Evaluate a single case clause
fn eval_case(interp: Interpreter, value: Value, pattern: Pattern,
             guard: Expr?, body: Block) -> Result<Value?, InterpreterError>:
    val bindings = match_pattern(value, pattern)?
    if not bindings.?:
        return Ok(None)

    interp.env.push_scope()
    for (name, val) in bindings.unwrap():
        interp.env.define(name, val)

    if guard.?:
        val guard_result = evaluate(interp, guard.unwrap())?
        if not guard_result.is_truthy():
            interp.env.pop_scope()
            return Ok(None)

    val result = interp.eval_block_value(body)?
    interp.env.pop_scope()
    Ok(Some(result))

# ================================================================
# Pattern Matching Core
# ================================================================

# Match a pattern against a value, returning bindings if successful
fn match_pattern(value: Value, pattern: Pattern) -> Result<[(text, Value)]?, InterpreterError>:
    match pattern:
        # Wildcard matches anything
        case Pattern.Wildcard:
            Ok(Some([]))

        # Identifier binding (also checks if it's a unit enum variant)
        case Pattern.Identifier(name):
            # Check if this identifier is a known enum variant
            if value.is_enum():
                val enum_name = value.enum_name()
                if is_known_variant(enum_name, name):
                    # Unit variant pattern - must match variant name and have no payload
                    if value.variant_name() == name and not value.has_payload():
                        return Ok(Some([]))
                    return Ok(None)
            # Normal identifier - bind the value
            Ok(Some([(name, value)]))

        # Mutable identifier binding
        case Pattern.MutIdentifier(name):
            Ok(Some([(name, value)]))

        # Move identifier binding (ownership transfer)
        case Pattern.MoveIdentifier(name):
            Ok(Some([(name, value)]))

        # Literal patterns
        case Pattern.Literal(lit_expr):
            match_literal(value, lit_expr)

        # Enum patterns: EnumName.Variant(payload)
        case Pattern.Enum(enum_name, variant, payload_patterns):
            match_enum(value, enum_name, variant, payload_patterns)

        # Tuple patterns: (a, b, c)
        case Pattern.Tuple(patterns):
            match_sequence(value, patterns, true)

        # Array patterns: [a, b, c] or [first, ..rest]
        case Pattern.Array(patterns):
            match_sequence(value, patterns, false)

        # Struct patterns: Point { x, y }
        case Pattern.Struct(name, field_patterns):
            match_struct(value, name, field_patterns)

        # Or patterns: pattern1 | pattern2
        case Pattern.Or(patterns):
            for pat in patterns:
                val result = match_pattern(value, pat)?
                if result.?:
                    return Ok(result)
            Ok(None)

        # Typed patterns: pattern: Type
        case Pattern.Typed(inner_pattern, type_name):
            if value.matches_type(type_name):
                match_pattern(value, inner_pattern)
            else:
                Ok(None)

        # Range patterns: 1..10 or 1..=10
        case Pattern.Range(start_expr, end_expr, inclusive):
            match_range(value, start_expr, end_expr, inclusive)

        # Rest/spread pattern: .. or ..rest
        case Pattern.Rest:
            Ok(Some([]))

        case _:
            Err(InterpreterError.NotImplemented("pattern type"))

# ================================================================
# Pattern Matching Helpers
# ================================================================

# Match a literal pattern
fn match_literal(value: Value, lit_expr: Expr) -> Result<[(text, Value)]?, InterpreterError>:
    match lit_expr:
        case Expr.Integer(n):
            if value.is_int() and value.as_int() == n:
                Ok(Some([]))
            else:
                Ok(None)
        case Expr.Float(f):
            if value.is_float() and (value.as_float() - f).abs() < 1e-10:
                Ok(Some([]))
            else:
                Ok(None)
        case Expr.String(s):
            if value.is_string() and value.as_string() == s:
                Ok(Some([]))
            else:
                Ok(None)
        case Expr.Bool(b):
            if value.is_bool() and value.as_bool() == b:
                Ok(Some([]))
            else:
                Ok(None)
        case Expr.Nil:
            if value.is_nil() or (value.is_enum() and value.variant_name() == "None"):
                Ok(Some([]))
            else:
                Ok(None)
        case Expr.Symbol(sym):
            if value.is_symbol() and value.as_symbol() == sym:
                Ok(Some([]))
            else:
                Ok(None)
        case _:
            Ok(None)

# Match an enum pattern
fn match_enum(value: Value, enum_name: text, variant: text,
              payload_patterns: [Pattern]?) -> Result<[(text, Value)]?, InterpreterError>:
    # Special case: Nil matches Option::None
    if value.is_nil() and (enum_name == "Option" or enum_name == "_") and variant == "None":
        if not payload_patterns.? or payload_patterns.unwrap().len() == 0:
            return Ok(Some([]))

    if not value.is_enum():
        return Ok(None)

    val value_enum = value.enum_name()
    val value_variant = value.variant_name()

    # Handle "_" placeholder for unqualified variants
    val enum_matches = enum_name == "_" or enum_name == value_enum
    if not enum_matches or variant != value_variant:
        return Ok(None)

    # Both have no payload
    if (not payload_patterns.? or payload_patterns.unwrap().len() == 0) and not value.has_payload():
        return Ok(Some([]))

    # Pattern has payload patterns, value has payload
    if payload_patterns.? and value.has_payload():
        val patterns = payload_patterns.unwrap()
        val payload = value.payload()
        if patterns.len() == 1:
            # Single payload - match directly
            return match_pattern(payload, patterns[0])
        else:
            # Multiple payload patterns - payload should be a tuple
            if payload.is_tuple():
                val elements = payload.as_tuple()
                if patterns.len() == elements.len():
                    var all_bindings = []
                    for i in 0..patterns.len():
                        val result = match_pattern(elements[i], patterns[i])?
                        if not result.?:
                            return Ok(None)
                        all_bindings = all_bindings + result.unwrap()
                    return Ok(Some(all_bindings))
            return Ok(None)

    # Pattern has no payload but value does - match any payload
    if (not payload_patterns.? or payload_patterns.unwrap().len() == 0) and value.has_payload():
        return Ok(Some([]))

    Ok(None)

# Match a sequence (tuple or array) pattern with rest support
fn match_sequence(value: Value, patterns: [Pattern], is_tuple: bool) -> Result<[(text, Value)]?, InterpreterError>:
    val values = if is_tuple:
        if not value.is_tuple(): return Ok(None)
        value.as_tuple()
    else:
        if not value.is_array(): return Ok(None)
        value.as_array()

    # Check for Rest pattern (e.g., [first, ..rest])
    val rest_index = patterns.find_index(\p: p.is_rest())

    if rest_index.?:
        val rest_idx = rest_index.unwrap()
        val before_rest = patterns[0..rest_idx]
        val after_rest = if rest_idx + 1 < patterns.len(): patterns[rest_idx + 1..] else: []

        val min_needed = before_rest.len() + after_rest.len()
        if values.len() < min_needed:
            return Ok(None)

        var all_bindings = []

        # Match patterns before rest
        for i in 0..before_rest.len():
            val result = match_pattern(values[i], before_rest[i])?
            if not result.?:
                return Ok(None)
            all_bindings = all_bindings + result.unwrap()

        # Match patterns after rest (from the end)
        for i in 0..after_rest.len():
            val val_idx = values.len() - after_rest.len() + i
            val result = match_pattern(values[val_idx], after_rest[i])?
            if not result.?:
                return Ok(None)
            all_bindings = all_bindings + result.unwrap()

        # Collect rest elements
        val rest_start = before_rest.len()
        val rest_end = values.len() - after_rest.len()
        val rest_values = values[rest_start..rest_end]
        all_bindings.push(("__rest__", Value.array(rest_values)))

        Ok(Some(all_bindings))
    else:
        # No rest pattern - exact match required
        if patterns.len() != values.len():
            return Ok(None)

        var all_bindings = []
        for i in 0..patterns.len():
            val result = match_pattern(values[i], patterns[i])?
            if not result.?:
                return Ok(None)
            all_bindings = all_bindings + result.unwrap()

        Ok(Some(all_bindings))

# Match a struct pattern: StructName { field1: pat1, field2: pat2 }
fn match_struct(value: Value, name: text,
                field_patterns: [(text, Pattern)]) -> Result<[(text, Value)]?, InterpreterError>:
    if not value.is_object():
        return Ok(None)

    val class_name = value.class_name()
    if class_name != name:
        return Ok(None)

    var all_bindings = []
    for (field_name, field_pattern) in field_patterns:
        val field_val = value.get_field(field_name)
        if not field_val.?:
            return Ok(None)
        val result = match_pattern(field_val.unwrap(), field_pattern)?
        if not result.?:
            return Ok(None)
        all_bindings = all_bindings + result.unwrap()

    Ok(Some(all_bindings))

# Match a range pattern: 1..10 or 1..=10
fn match_range(value: Value, start_expr: Expr, end_expr: Expr,
               inclusive: bool) -> Result<[(text, Value)]?, InterpreterError>:
    if not value.is_int():
        return Ok(None)

    val v = value.as_int()
    val start = match start_expr:
        case Expr.Integer(n): n
        case _: return Ok(None)
    val end = match end_expr:
        case Expr.Integer(n): n
        case _: return Ok(None)

    val matches = if inclusive:
        v >= start and v <= end
    else:
        v >= start and v < end

    if matches: Ok(Some([])) else: Ok(None)

# ================================================================
# Pattern Binding (for for-loops and let statements)
# ================================================================

# Bind a value to a pattern in the current environment
# Returns true if pattern matched, false otherwise
fn bind_pattern(interp: Interpreter, pattern: Pattern, value: Value) -> bool:
    val bindings = match_pattern(value, pattern)
    match bindings:
        case Ok(Some(binds)):
            for (name, val) in binds:
                interp.env.define(name, val)
            true
        case _:
            false

# ================================================================
# Exhaustiveness Checking
# ================================================================

# Check if a pattern is a catch-all that covers any value
fn is_catch_all_pattern(pattern: Pattern) -> bool:
    match pattern:
        case Pattern.Wildcard: true
        case Pattern.Identifier(_): true
        case Pattern.MutIdentifier(_): true
        case Pattern.MoveIdentifier(_): true
        case Pattern.Or(patterns):
            patterns.any(\p: is_catch_all_pattern(p))
        case Pattern.Typed(inner, _):
            is_catch_all_pattern(inner)
        case _: false

# Check if a match covers all enum variants
# Returns None if exhaustive, Some(missing_variants) if not
fn check_enum_exhaustiveness(enum_name: text, arm_patterns: [Pattern],
                              all_variants: [text]) -> [text]?:
    var covered = []
    var has_catch_all = false

    for pattern in arm_patterns:
        if is_catch_all_pattern(pattern):
            has_catch_all = true
        else:
            val variant = extract_covered_variant(pattern)
            if variant.? and not covered.contains(variant.unwrap()):
                covered.push(variant.unwrap())
            # For Or patterns, collect all sub-variants
            if pattern.is_or():
                for sub_pat in pattern.or_patterns():
                    val v = extract_covered_variant(sub_pat)
                    if v.? and not covered.contains(v.unwrap()):
                        covered.push(v.unwrap())

    if has_catch_all:
        return None

    val missing = all_variants.filter(\v: not covered.contains(v))
    if missing.len() == 0: None else: Some(missing)

# Extract covered variant name from a pattern
fn extract_covered_variant(pattern: Pattern) -> text?:
    match pattern:
        case Pattern.Enum(_, variant, _): Some(variant)
        case Pattern.Or(patterns):
            if patterns.len() > 0:
                extract_covered_variant(patterns[0])
            else:
                None
        case Pattern.Typed(inner, _):
            extract_covered_variant(inner)
        case _: None

# ================================================================
# Helpers
# ================================================================

# Check if an identifier is a known enum variant
fn is_known_variant(enum_name: text, variant_name: text) -> bool:
    # This would check the enum registry
    # For now, delegate to the runtime's enum registry
    false
