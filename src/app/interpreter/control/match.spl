# Pattern Matching
#
# match expression and case clause evaluation.

import ..core.{Interpreter, Value, InterpreterError}
import ..expr.{evaluate}

export eval_match, eval_case

# Evaluate a match expression
fn eval_match(interp: &Interpreter, scrutinee: &Expr, arms: &Array<MatchArm>) -> Result<Value, InterpreterError>:
    # Evaluate the value being matched
    value value = evaluate(interp, scrutinee)?

    # Try each arm
    for arm in arms:
        if value Some(result) = try_match_arm(interp, &val, arm)?:
            return Ok(result)

    # No arm matched - this should be caught by exhaustiveness checker
    return Err(InterpreterError.MatchError("non-exhaustive match".to_string()))

# Evaluate a single case clause
fn eval_case(interp: &Interpreter, value: &Value, pattern: &Pattern, guard: Option<&Expr>, body: &Expr) -> Result<Option<Value>, InterpreterError>:
    # Try to match the pattern
    value bindings = match_pattern(val, pattern)?

    match bindings:
        case Some(binds):
            # Pattern matched, check guard
            if value Some(guard_expr) = guard:
                # Temporarily bind pattern variables
                interp.env.push_scope()
                for (name, bound_val) in binds:
                    interp.env.define_str(name, bound_val)

                value guard_result = evaluate(interp, guard_expr)?
                if not guard_result.is_truthy():
                    interp.env.pop_scope()
                    return Ok(None)  # Guard failed

                # Guard passed, evaluate body
                value result = evaluate(interp, body)?
                interp.env.pop_scope()
                return Ok(Some(result))
            else:
                # No guard, evaluate body with bindings
                interp.env.push_scope()
                for (name, bound_val) in binds:
                    interp.env.define_str(name, bound_val)

                value result = evaluate(interp, body)?
                interp.env.pop_scope()
                return Ok(Some(result))

        case None:
            return Ok(None)  # Pattern didn't match

# Try to match a single arm
fn try_match_arm(interp: &Interpreter, value: &Value, arm: &MatchArm) -> Result<Option<Value>, InterpreterError>:
    return eval_case(interp, value, &arm.pattern, arm.guard.as_ref(), &arm.body)

# Pattern matching returns bindings if successful
fn match_pattern(value: &Value, pattern: &Pattern) -> Result<Option<Array<(String, Value)>>, InterpreterError>:
    match pattern:
        case Pattern.Wildcard:
            return Ok(Some([]))

        case Pattern.Identifier(name):
            return Ok(Some([(name.clone(), value.clone())]))

        case Pattern.Literal(lit):
            if matches_literal(val, lit):
                return Ok(Some([]))
            return Ok(None)

        case Pattern.Tuple(patterns):
            return match_tuple(val, patterns)

        case Pattern.Struct { name, fields }:
            return match_struct(val, name, fields)

        case Pattern.Enum { variant, data }:
            return match_enum(val, variant, data)

        case Pattern.Or(left, right):
            if value Some(binds) = match_pattern(val, left)?:
                return Ok(Some(binds))
            return match_pattern(val, right)

        case _:
            return Err(InterpreterError.NotImplemented("pattern".to_string()))

# Check if value matches literal pattern
fn matches_literal(value: &Value, lit: &Literal) -> bool:
    match (val.data.clone(), lit):
        case (RuntimeValue.Int(n), Literal.Int(m)):
            return n == *m
        case (RuntimeValue.Float(f), Literal.Float(g)):
            return f == *g
        case (RuntimeValue.Bool(b), Literal.Bool(c)):
            return b == *c
        case (RuntimeValue.String(s), Literal.String(t)):
            return s == *t
        case (RuntimeValue.Nil, Literal.Nil):
            return true
        case _:
            return false

# Match tuple pattern
fn match_tuple(value: &Value, patterns: &Array<Pattern>) -> Result<Option<Array<(String, Value)>>, InterpreterError>:
    match value.as_array():
        case Some(arr):
            if arr.len() != patterns.len():
                return Ok(None)

            value all_bindings: Array<(String, Value)> = []
            for i in 0..patterns.len():
                match match_pattern(&arr[i], &patterns[i])?:
                    case Some(binds):
                        all_bindings.extend(binds)
                    case None:
                        return Ok(None)

            return Ok(Some(all_bindings))

        case None:
            return Ok(None)

# Match struct pattern
fn match_struct(value: &Value, name: &str, field_patterns: &Array<(String, Pattern)>) -> Result<Option<Array<(String, Value)>>, InterpreterError>:
    match value.data.clone():
        case RuntimeValue.Struct { name: struct_name, fields }:
            # Check struct name matches
            if struct_name != name:
                return Ok(None)

            # Match all field patterns
            value all_bindings: Array<(String, Value)> = []
            for (field_name, field_pattern) in field_patterns:
                match fields.get(field_name):
                    case Some(field_val):
                        match match_pattern(field_val, field_pattern)?:
                            case Some(binds):
                                all_bindings.extend(binds)
                            case None:
                                return Ok(None)
                    case None:
                        return Ok(None)  # Field doesn't exist

            return Ok(Some(all_bindings))

        case RuntimeValue.Object { class, fields, methods }:
            # Also match objects (classes are like structs)
            if class != name:
                return Ok(None)

            value all_bindings: Array<(String, Value)> = []
            for (field_name, field_pattern) in field_patterns:
                match fields.get(field_name):
                    case Some(field_val):
                        match match_pattern(field_val, field_pattern)?:
                            case Some(binds):
                                all_bindings.extend(binds)
                            case None:
                                return Ok(None)
                    case None:
                        return Ok(None)

            return Ok(Some(all_bindings))

        case _:
            return Ok(None)

# Match enum pattern
fn match_enum(value: &Value, variant: &str, data_pattern: Option<&Pattern>) -> Result<Option<Array<(String, Value)>>, InterpreterError>:
    match value.data.clone():
        case RuntimeValue.Enum { variant: v, data }:
            if v != variant:
                return Ok(None)

            match (data_pattern, data):
                case (Some(pat), Some(d)):
                    return match_pattern(&*d, pat)
                case (None, None):
                    return Ok(Some([]))
                case _:
                    return Ok(None)

        case _:
            return Ok(None)
