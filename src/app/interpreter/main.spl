# Simple Language Interpreter
#
# Self-hosted interpreter for Simple language.
# This is the CLI entry point for running Simple programs.
#
# Usage:
#   simple_interpret script.spl [args...]
#   simple_interpret --repl
#   simple_interpret --eval "expression"
#
# This interpreter can interpret itself (self-hosting).

import std.args
import std.io
import io.fs
use app.io.mod (rt_debug_stack_trace_lines)

from core import {Interpreter, InterpreterError, Value}
from parser import {SimpleParser, ParseError}
from ast_convert import {tree_to_module, tree_to_expression}

fn format_runtime_error(prefix: text, err: InterpreterError) -> text:
    var message = "{prefix}: {err}"
    val frames = rt_debug_stack_trace_lines()
    if frames.len() > 0:
        message = message + "\nCall stack:"
        for frame in frames:
            message = message + "\n  " + frame
    message

fn main() -> i32:
    val args = args.get_args()

    if args.len() < 2:
        print_usage()
        return 1

    val cmd = args[1]

    match cmd:
        case "--help" | "-h":
            print_usage()
            return 0

        case "--version" | "-v":
            print("Simple Interpreter v0.1.0")
            return 0

        case "--repl":
            return run_repl()

        case "--eval" | "-e":
            if args.len() < 3:
                io.eprintln("Error: --eval requires an expression")
                return 1
            return eval_expr(args[2])

        case _:
            # Treat as script file
            val script_path = cmd
            val script_args = args.slice(2, args.len())
            return run_script(script_path, script_args)

fn print_usage():
    print("Simple Interpreter - Self-hosted interpreter for Simple language")
    print("")
    print("Usage:")
    print("  simple_interpret <script.spl> [args...]  Run a Simple script")
    print("  simple_interpret --repl                  Start interactive REPL")
    print("  simple_interpret --eval <expr>           Evaluate expression")
    print("  simple_interpret --help                  Show this help")
    print("  simple_interpret --version               Show version")

fn run_script(path: String, script_args: Array<String>) -> i32:
    var interp = Interpreter.new()

    # Check if file exists
    if not fs.exists(path):
        io.eprintln("Error: File not found: {path}")
        return 1

    # Load script source
    val source = fs.read_text(path)
    if source.is_empty():
        io.eprintln("Error: Could not read file or file is empty: {path}")
        return 1

    # Parse script into AST
    var parser = SimpleParser.new()
    val parse_result = parser.parse(source)

    match parse_result:
        case Err(err):
            io.eprintln("Parse error: {err}")
            return 1
        case Ok(tree):
            pass

    val tree = parse_result.unwrap()

    # Convert parse tree to module (list of statements)
    val module_result = tree_to_module(tree)

    match module_result:
        case Err(err):
            io.eprintln("AST conversion error: {err}")
            return 1
        case Ok(module):
            pass

    val module = module_result.unwrap()

    # Set script arguments in environment
    val args_array = script_args.iter()
        .map(|arg| Value.string(arg))
        .collect()
    interp.env.define_global("__args__".to_string(), Value.array(args_array))
    interp.env.define_global("__file__".to_string(), Value.string(path))

    # Execute all statements in the module
    var exit_code: i32 = 0

    for stmt in module.statements:
        match interp.eval_stmt(&stmt):
            case Ok(_):
                pass
            case Err(InterpreterError.Return(value)):
                # Top-level return sets exit code
                match value.as_int():
                    case Some(code): exit_code = code as i32
                    case nil: pass
                break
            case Err(err):
                io.eprintln(format_runtime_error("Runtime error", err))
                return 1

    return exit_code

fn run_repl() -> i32:
    var interp = Interpreter.new()
    var parser = SimpleParser.new()

    print("Simple REPL v0.1.0")
    print("Type 'exit' to quit, 'help' for commands")
    print("")

    loop:
        io.print(">>> ")
        io.flush()

        val line = io.read_line()
        if line is nil:
            break

        val input = line.unwrap().trim()

        match input:
            case "exit" | "quit":
                break
            case "help":
                print_repl_help()
            case "":
                pass  # Empty line
            case _:
                # Try to evaluate as expression first, then as statement
                val result = eval_repl_input(&mut interp, &mut parser, input)
                match result:
                    case Ok(value):
                        if not value.is_nil():
                            print("{value}")
                    case Err(err):
                        io.eprintln(format_runtime_error("Error", err))

    return 0

fn eval_repl_input(interp: &mut Interpreter, parser: &mut SimpleParser, input: String) -> Result<Value, String>:
    # Try parsing as expression first
    match parser.parse_expression(input):
        case Ok(tree):
            match tree_to_expression(tree):
                case Ok(expr):
                    match interp.eval_expr(&expr):
                        case Ok(value): return Ok(value)
                        case Err(err): return Err(err.to_string())
                case Err(e):
                    pass  # Fall through to try as statement
        case Err(_):
            pass  # Fall through to try as statement

    # Try parsing as statement
    match parser.parse_statement(input):
        case Ok(tree):
            match tree_to_module(tree):
                case Ok(module):
                    for stmt in module.statements:
                        match interp.eval_stmt(&stmt):
                            case Ok(value): return Ok(value)
                            case Err(InterpreterError.Return(value)): return Ok(value)
                            case Err(err): return Err(err.to_string())
                    return Ok(Value.null())
                case Err(e):
                    return Err(e)
        case Err(e):
            return Err("Parse error: {e}")

fn print_repl_help():
    print("REPL Commands:")
    print("  exit, quit  Exit the REPL")
    print("  help        Show this help")
    print("")
    print("Enter Simple expressions to evaluate them.")

fn eval_expr(input: String) -> i32:
    var interp = Interpreter.new()
    var parser = SimpleParser.new()

    # Parse the input as an expression
    val parse_result = parser.parse_expression(input)

    match parse_result:
        case Err(err):
            io.eprintln("Parse error: {err}")
            return 1
        case Ok(tree):
            pass

    val tree = parse_result.unwrap()

    # Convert to expression AST
    val convert_result = tree_to_expression(tree)

    match convert_result:
        case Err(err):
            io.eprintln("AST conversion error: {err}")
            return 1
        case Ok(expr):
            pass

    val expr = convert_result.unwrap()

    # Evaluate and print result
    match interp.eval_expr(&expr):
        case Ok(value):
            print("{value}")
            return 0
        case Err(err):
            io.eprintln(format_runtime_error("Runtime error", err))
            return 1
