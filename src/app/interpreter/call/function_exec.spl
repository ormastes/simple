# Function Execution
#
# Core function execution with argument binding, scope management,
# captured environments for closures, async/Promise support.
# Port of rust/compiler/src/interpreter_call/core/function_exec.rs,
# arg_binding.rs, lambda.rs, async_support.rs

from ..core import {Interpreter, Value, InterpreterError}
from ..core.execution_guard import {push_call_depth, ExecutionGuard}
from arg_binding import {bind_args, bind_named_args}

export exec_function, exec_function_with_captured_env
export exec_function_with_values, exec_lambda

# ================================================================
# Function Execution
# ================================================================

# Execute a function definition with arguments
fn exec_function(interp: Interpreter, func_def: FunctionDef, args: [Value],
                 named_args: Dict<text, Value>, self_value: Value?) -> Result<Value, InterpreterError>:
    # Stack overflow detection (configurable via fault_detection module)
    val guard = push_call_depth(func_def.name ?? "anonymous")
        .map_err(\e: InterpreterError.StackOverflow(e))?

    # Save const/immutable state (prevent leaking from caller to callee)
    val saved_consts = interp.const_names.clone()
    val saved_immutables = interp.immutable_vars.clone()
    interp.const_names = {}
    interp.immutable_vars = {}

    # Create new scope
    interp.env.push_scope()

    # Bind self if this is a method call
    if self_value.?:
        interp.env.define("self", self_value.unwrap())
        # Also bind fields into scope for convenience
        val self_val = self_value.unwrap()
        if self_val.is_object():
            for (name, value) in self_val.fields():
                interp.env.define(name, value)

    # Bind arguments to parameters
    bind_args(interp, func_def.params, args, named_args)?

    # Execute body
    val result = interp.eval_block_fn(func_def.body)

    # Pop scope
    interp.env.pop_scope()

    # Restore const/immutable state
    interp.const_names = saved_consts
    interp.immutable_vars = saved_immutables

    # Guard auto-decrements recursion depth when it goes out of scope

    # Handle result
    match result:
        case Ok((control, implicit_val)):
            match control:
                case Control.Return(val): Ok(val)
                case _: Ok(implicit_val ?? Value.nil())
        case Err(InterpreterError.Return(val)):
            Ok(val)
        case Err(e):
            Err(e)

# Execute function with a captured environment (closures/decorators)
fn exec_function_with_captured_env(interp: Interpreter, func_def: FunctionDef,
                                    args: [Value], named_args: Dict<text, Value>,
                                    captured_env: Environment) -> Result<Value, InterpreterError>:
    # Save current environment
    val saved_env = interp.env.clone()

    # Restore captured environment (closure semantics)
    interp.env = captured_env.clone()

    # Execute function in captured context
    val result = exec_function(interp, func_def, args, named_args, None)

    # Restore original environment
    interp.env = saved_env

    result

# Execute with pre-evaluated arguments and optional self
fn exec_function_with_values(interp: Interpreter, func_def: FunctionDef,
                              args: [Value], self_value: Value?) -> Result<Value, InterpreterError>:
    exec_function(interp, func_def, args, {}, self_value)

# ================================================================
# Lambda Execution
# ================================================================

# Execute a lambda/closure with arguments
fn exec_lambda(interp: Interpreter, params: [text], body: Expr,
               args: [Value], captured_env: Environment) -> Result<Value, InterpreterError>:
    # Check arity
    if args.len() != params.len():
        return Err(InterpreterError.ArityError(
            "lambda expects {params.len()} arguments, got {args.len()}"))

    # Save current environment
    val saved_env = interp.env.clone()

    # Restore captured environment
    interp.env = captured_env.clone()

    # Create new scope for parameters
    interp.env.push_scope()

    # Bind parameters
    for i in 0..params.len():
        interp.env.define(params[i], args[i])

    # Execute body
    val result = interp.eval_expr(body)

    # Restore environment
    interp.env.pop_scope()
    interp.env = saved_env

    result
