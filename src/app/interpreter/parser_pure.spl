# Pure Simple Parser Wrapper for Interpreter
#
# Uses the patched lib.parser instead of TreeSitter runtime parser

use lib.parser.parser (parse, parse_expr)
use lib.parser.parser (ParseError as LibParseError)
use lib.parser.ast (Expr, Stmt, Module)

export PureSimpleParser, ParseError

# Re-export lib.parser's ParseError directly
# struct ParseError:
#     message: text
#     line: i64
#     column: i64

# Alias the error type
type ParseError = LibParseError

# Parser wrapper that uses our patched lib.parser
struct PureSimpleParser:
    dummy: i64  # Placeholder

impl PureSimpleParser:
    static fn new() -> PureSimpleParser:
        PureSimpleParser(dummy: 0)

    # Parse a complete module/file
    fn parse_module(source: text) -> Result<Module, ParseError>:
        parse(source)

    # Parse a single expression
    fn parse_expression(source: text) -> Result<Expr, ParseError>:
        parse_expr(source)

    # Parse a single statement (parse as module, extract first stmt)
    fn parse_statement(source: text) -> Result<Stmt, ParseError>:
        match parse(source):
            case Ok(module):
                if module.statements.len() > 0:
                    Ok(module.statements[0])
                else:
                    val err = ParseError(message: "No statements found", line: 0, column: 0)
                    Err(err)
            case Err(e):
                Err(e)
