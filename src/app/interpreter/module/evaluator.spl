# Module Evaluator
#
# Top-level module evaluation: two-pass registration of all items
# (functions, classes, enums, structs, traits, impls, decorators,
# macros, units, modules), then main function discovery and execution.
# Port of evaluate_module_impl from rust/compiler/src/interpreter_eval.rs

from ..core import {Interpreter, Value, InterpreterError}
from ..expr import {evaluate}
from ..call import {evaluate_call, exec_function}

export evaluate_module, ModuleState

# Prelude extern functions (always available without import)
val PRELUDE_EXTERN_FUNCTIONS = [
    "print", "print_raw", "eprint", "eprint_raw", "dprint", "input",
    "println", "eprintln",
    "abs", "min", "max", "sqrt", "floor", "ceil", "pow",
    "to_string", "to_int",
    "exit", "panic",
    "memory_usage", "memory_limit", "memory_usage_percent",
    "is_memory_limited", "default_memory_limit",
    "format_bytes", "parse_memory_size",
]

# Module evaluation state
class ModuleState:
    functions: Dict<text, FunctionDef>
    classes: Dict<text, ClassDef>
    enums: Dict<text, EnumDef>
    impl_methods: Dict<text, [FunctionDef]>
    extern_functions: Dict<text, ExternDef>
    macros: Dict<text, MacroDef>
    traits: Dict<text, TraitDef>
    trait_impls: Dict<(text, text), [FunctionDef]>
    units: Dict<text, UnitDef>
    unit_families: Dict<text, UnitFamilyInfo>
    exports: Dict<text, Value>  # Exported items for import system

impl ModuleState:
    static fn empty() -> ModuleState:
        ModuleState(
            functions: {}, classes: {}, enums: {},
            impl_methods: {}, extern_functions: {},
            macros: {}, traits: {}, trait_impls: {},
            units: {}, unit_families: {}, exports: {})

# ================================================================
# Main Module Evaluator
# ================================================================

# Evaluate a module (list of top-level nodes) and return exit code
fn evaluate_module(interp: Interpreter, items: [Node]) -> Result<i32, InterpreterError>:
    # Clear state from previous runs
    interp.clear_module_state()

    # Initialize prelude extern functions
    for name in PRELUDE_EXTERN_FUNCTIONS:
        interp.register_extern(name)

    var state = ModuleState.empty()

    # ================================================================
    # First pass: register all functions (needed for decorator lookup)
    # ================================================================
    for item in items:
        match item:
            case Node.Function(f):
                state.functions[f.name] = f
            case _:
                pass

    # ================================================================
    # Second pass: process all top-level items
    # ================================================================
    for item in items:
        match item:
            # Functions (may have decorators)
            case Node.Function(f):
                if f.decorators.len() > 0:
                    val decorated = apply_decorators(interp, f, state)?
                    interp.env.define(f.name, decorated)
                else:
                    # Register non-decorated functions in environment
                    val func_value = Value.function(f.name, f, interp.env.clone())
                    interp.env.define(f.name, func_value)

            # Structs
            case Node.Struct(s):
                interp.env.define(s.name, Value.constructor(s.name))
                state.classes[s.name] = struct_to_class(s)

            # Enums
            case Node.Enum(e):
                state.enums[e.name] = e
                interp.env.define(e.name, Value.enum_type(e.name))

            # Classes
            case Node.Class(c):
                # Inject mixin fields and methods
                val final_class = inject_mixins(interp, c, state)
                state.classes[final_class.name] = final_class
                interp.env.define(final_class.name, Value.constructor(final_class.name))

            # Impl blocks
            case Node.Impl(impl_block):
                register_impl(interp, impl_block, state)?

            # Extern declarations
            case Node.Extern(ext):
                state.extern_functions[ext.name] = ext
                interp.register_extern(ext.name)

            # Macros
            case Node.Macro(m):
                state.macros[m.name] = m

            # Traits
            case Node.Trait(t):
                state.traits[t.name] = t
                interp.env.define(t.name, Value.nil())

            # Mixins
            case Node.Mixin(mixin_def):
                interp.register_mixin(mixin_def)

            # Actors (treated as classes)
            case Node.Actor(a):
                state.classes[a.name] = actor_to_class(a)
                interp.env.define(a.name, Value.constructor(a.name))

            # Type aliases
            case Node.TypeAlias(t):
                interp.env.define(t.name, Value.nil())

            # Units
            case Node.Unit(u):
                state.units[u.suffix] = u
                interp.env.define(u.name, Value.nil())

            # Unit families
            case Node.UnitFamily(uf):
                register_unit_family(interp, uf, state)

            # Compound units
            case Node.CompoundUnit(cu):
                interp.env.define(cu.name, Value.nil())

            # Let bindings (module-level variables)
            case Node.Let(let_stmt):
                val value = evaluate(interp, let_stmt.value)?
                interp.env.define(let_stmt.name, value)
                interp.register_module_global(let_stmt.name, value)

            # Const declarations
            case Node.Const(c):
                val value = evaluate(interp, c.value)?
                interp.env.define(c.name, value)
                interp.register_const(c.name)

            # Static declarations
            case Node.Static(s):
                val value = evaluate(interp, s.value)?
                interp.env.define(s.name, value)

            # Executable statements at module level
            case Node.Assignment(_) | Node.If(_) | Node.For(_)
               | Node.While(_) | Node.Loop(_) | Node.Match(_)
               | Node.Context(_) | Node.With(_):
                val result = interp.exec_node(item)?
                match result:
                    case Control.Return(val):
                        return val.as_int() ?? 0
                    case _:
                        pass

            # Return at module level
            case Node.Return(ret):
                if ret.value.?:
                    val val = evaluate(interp, ret.value.unwrap())?
                    return val.as_int() ?? 0
                return Ok(0)

            # Expression statements
            case Node.Expression(expr):
                interp.eval_expr(expr)?

            # Break/continue at module level is an error
            case Node.Break(_):
                return Err(InterpreterError.SemanticError("break outside of loop"))
            case Node.Continue(_):
                return Err(InterpreterError.SemanticError("continue outside of loop"))

            # Assert at module level
            case Node.Assert(assert_stmt):
                val cond = evaluate(interp, assert_stmt.condition)?
                if not cond.is_truthy():
                    val msg = if assert_stmt.message.?:
                        "Assertion violation: {assert_stmt.message.unwrap()}"
                    else:
                        "Assertion violation: condition failed"
                    return Err(InterpreterError.AssertionError(msg))

            # Use/import statements
            case Node.UseStmt(use_stmt):
                eval_use_stmt(interp, use_stmt)?

            # Interface bindings
            case Node.InterfaceBinding(binding):
                interp.register_interface_binding(binding.interface_name, binding.impl_type)

            # Module declarations
            case Node.ModDecl(mod_decl):
                if mod_decl.body.?:
                    eval_inline_module(interp, mod_decl, state)?

            # Export statements - collect exported items
            case Node.ExportUseStmt(export_use):
                eval_export_use_stmt(interp, export_use, state)?

            case Node.StructuredExportStmt(structured_export):
                eval_structured_export_stmt(interp, structured_export, state)?

            # No-ops in interpreter
            case Node.Pass(_) | Node.Skip(_) | Node.Guard(_)
               | Node.Defer(_) | Node.Mixin(_) | Node.Bitfield(_)
               | Node.AopAdvice(_) | Node.DiBinding(_)
               | Node.ArchitectureRule(_) | Node.MockDecl(_)
               | Node.LeanBlock(_) | Node.Assume(_) | Node.Admit(_)
               | Node.ProofHint(_) | Node.Calc(_)
               | Node.ClassAlias(_) | Node.FunctionAlias(_)
               | Node.MultiUse(_) | Node.CommonUseStmt(_)
               | Node.AutoImportStmt(_) | Node.RequiresCapabilities(_)
               | Node.HandlePool(_) | Node.LiteralFunction(_):
                pass

    # ================================================================
    # Store module exports for import system
    # ================================================================
    interp.set_module_exports(Value.dict(state.exports))

    # ================================================================
    # Execute main function if present
    # ================================================================
    if state.functions.has("main"):
        val main_func = state.functions["main"]
        val result = exec_function(interp, main_func, [], {}, None)?
        # Await if async
        val result = result.await_if_promise()?
        match result:
            case Value.Tuple(t) if t.len() == 0: Ok(0)
            case Value.Nil: Ok(0)
            case _: Ok(result.as_int() ?? 0)
    else:
        # Fall back to checking for `main = <value>` binding
        val main_val = interp.env.get("main") ?? Value.int(0)
        val main_val = main_val.await_if_promise()?
        Ok(main_val.as_int() ?? 0)

# ================================================================
# Decorator Application
# ================================================================

fn apply_decorators(interp: Interpreter, func: FunctionDef,
                    state: ModuleState) -> Result<Value, InterpreterError>:
    var decorated = Value.function(func.name, func, interp.env.clone())

    # Apply decorators in reverse order (outermost last)
    for decorator in func.decorators.reversed():
        # Skip compiler directives
        if decorator.name == "extern" or decorator.name == "deprecated":
            continue

        val decorator_fn = evaluate(interp, decorator.name_expr)?

        # If decorator has arguments, call it first to get actual decorator
        val actual_decorator = if decorator.args.?:
            var arg_values = []
            for arg in decorator.args.unwrap():
                arg_values.push(evaluate(interp, arg.value)?)
            interp.call_value(decorator_fn, arg_values)?
        else:
            decorator_fn

        # Call the decorator with the current function value
        decorated = interp.call_value(actual_decorator, [decorated])?

    Ok(decorated)

# ================================================================
# Impl Registration
# ================================================================

fn register_impl(interp: Interpreter, impl_block: ImplBlock,
                 state: ModuleState) -> Result<(), InterpreterError>:
    val type_name = impl_block.target_type_name

    # Add methods to impl_methods registry
    if not state.impl_methods.has(type_name):
        state.impl_methods[type_name] = []
    for method in impl_block.methods:
        state.impl_methods[type_name].push(method)

        # Register static methods as module-level callable functions
        # so Type.method() can be dispatched via "Type.method" key
        if method.is_static:
            val static_key = "{type_name}.{method.name}"
            state.functions[static_key] = method
            interp.env.define(static_key,
                Value.function(method.name, method, interp.env.clone()))
            # Also register with double-underscore convention for desugared code
            val desugar_key = "{type_name}__{method.name}"
            state.functions[desugar_key] = method
            interp.env.define(desugar_key,
                Value.function(method.name, method, interp.env.clone()))

    # Also add to class definition if it exists
    if state.classes.has(type_name):
        state.classes[type_name].methods = state.classes[type_name].methods + impl_block.methods

    # If this is a trait implementation, verify and register
    if impl_block.trait_name.?:
        val trait_name = impl_block.trait_name.unwrap()
        if state.traits.has(trait_name):
            val trait_def = state.traits[trait_name]
            # Check all abstract methods are implemented
            val impl_method_names = impl_block.methods.map(\m: m.name)
            for trait_method in trait_def.methods:
                if trait_method.is_abstract and not impl_method_names.contains(trait_method.name):
                    return Err(InterpreterError.SemanticError(
                        "type '{type_name}' missing required method '{trait_method.name}' for trait '{trait_name}'"))

            # Build combined methods: impl + default trait methods
            var combined = impl_block.methods
            for trait_method in trait_def.methods:
                if not trait_method.is_abstract and not impl_method_names.contains(trait_method.name):
                    combined.push(trait_method)
                    state.impl_methods[type_name].push(trait_method)

            state.trait_impls[(trait_name, type_name)] = combined

    Ok(())

# ================================================================
# Use Statement
# ================================================================

fn eval_use_stmt(interp: Interpreter, use_stmt: UseStmt) -> Result<(), InterpreterError>:
    val binding_name = use_stmt.binding_name()

    match interp.load_module(use_stmt):
        case Ok(module_value):
            # Unpack based on import type
            match use_stmt.target:
                case ImportTarget.Group(items):
                    if module_value.is_dict():
                        for item in items:
                            val item_name = item.name()
                            val local_name = item.local_name()
                            val export_val = module_value.dict_get(Value.string(item_name))
                            if export_val.?:
                                interp.env.define(local_name, export_val.unwrap())
                                interp.register_module_global(local_name, export_val.unwrap())

                case ImportTarget.Glob:
                    if module_value.is_dict():
                        for (name, value) in module_value.dict_entries_raw():
                            interp.env.define(name, value)
                            interp.register_module_global(name, value)

                case ImportTarget.Single(_) | ImportTarget.Aliased(_, _):
                    pass  # Don't unpack, just bind

            interp.env.define(binding_name, module_value)
            interp.register_module_global(binding_name, module_value)

        case Err(e):
            # Module loading failed - use empty dict as fallback
            val empty = Value.dict({})
            interp.env.define(binding_name, empty)

    Ok(())

# ================================================================
# Inline Module
# ================================================================

fn eval_inline_module(interp: Interpreter, mod_decl: ModDecl,
                      state: ModuleState) -> Result<(), InterpreterError>:
    var module_dict = {}

    for item in mod_decl.body.unwrap():
        match item:
            case Node.Function(f):
                val prefixed = "{mod_decl.name}.{f.name}"
                state.functions[prefixed] = f
                module_dict[f.name] = Value.function(f.name, f, interp.env.clone())

            case Node.Class(c):
                val prefixed = "{mod_decl.name}.{c.name}"
                state.classes[prefixed] = c
                state.classes[c.name] = c
                module_dict[c.name] = Value.constructor(c.name)

            case Node.Struct(s):
                val class_def = struct_to_class(s)
                val prefixed = "{mod_decl.name}.{s.name}"
                state.classes[prefixed] = class_def
                state.classes[s.name] = class_def
                module_dict[s.name] = Value.constructor(s.name)

            case Node.Enum(e):
                val prefixed = "{mod_decl.name}.{e.name}"
                state.enums[prefixed] = e
                state.enums[e.name] = e
                for variant in e.variants:
                    module_dict[variant.name] = Value.enum_variant_constructor(e.name, variant.name)

            case Node.Const(c):
                val value = evaluate(interp, c.value)?
                module_dict[c.name] = value

            case _:
                pass

    interp.env.define(mod_decl.name, Value.dict(module_dict))
    Ok(())

# ================================================================
# Export Statement Processing
# ================================================================

# Process export use statement: export foo, bar, baz
fn eval_export_use_stmt(interp: Interpreter, export_use: ExportUseStmt,
                        state: ModuleState) -> Result<(), InterpreterError>:
    # Export simple names - look up in current environment
    for name in export_use.names:
        # Try to get value from environment
        val value = interp.env.get(name)
        if value.?:
            state.exports[name] = value.unwrap()
        else:
            # Try to get function from state
            if state.functions.has(name):
                val func = state.functions[name]
                state.exports[name] = Value.function(name, func, interp.env.clone())
            else:
                if state.classes.has(name):
                    state.exports[name] = Value.constructor(name)
                else:
                    if state.enums.has(name):
                        val enum_def = state.enums[name]
                        state.exports[name] = Value.enum_type(name)

    Ok(())

# Process structured export statement: export { x, y as z }
fn eval_structured_export_stmt(interp: Interpreter, structured_export: StructuredExportStmt,
                                state: ModuleState) -> Result<(), InterpreterError>:
    # Process each export item with optional aliasing
    for item in structured_export.items:
        val source_name = item.name()
        val export_name = item.local_name()

        # Try to get value from environment
        val value = interp.env.get(source_name)
        if value.?:
            state.exports[export_name] = value.unwrap()
        else:
            # Try to get function from state
            if state.functions.has(source_name):
                val func = state.functions[source_name]
                state.exports[export_name] = Value.function(source_name, func, interp.env.clone())
            else:
                if state.classes.has(source_name):
                    state.exports[export_name] = Value.constructor(source_name)
                else:
                    if state.enums.has(source_name):
                        state.exports[export_name] = Value.enum_type(source_name)

    Ok(())

# ================================================================
# Helpers
# ================================================================

fn struct_to_class(s: StructDef) -> ClassDef:
    ClassDef(
        name: s.name, fields: s.fields, methods: s.methods,
        generic_params: s.generic_params, parent: None,
        visibility: s.visibility, attributes: s.attributes)

fn actor_to_class(a: ActorDef) -> ClassDef:
    ClassDef(
        name: a.name, fields: a.fields, methods: a.methods,
        generic_params: [], parent: None,
        visibility: a.visibility, attributes: [])

fn inject_mixins(interp: Interpreter, class_def: ClassDef,
                 state: ModuleState) -> ClassDef:
    if class_def.mixins.len() == 0:
        return class_def

    var mixin_fields = []
    var mixin_methods = []
    var seen_fields = class_def.fields.map(\f: f.name).to_set()
    var seen_methods = class_def.methods.map(\m: m.name).to_set()
    var seen_mixins = {}
    var queue = class_def.mixins.map(\m: m.name)

    while queue.len() > 0:
        val mixin_name = queue.pop_front()
        if seen_mixins.has(mixin_name):
            continue  # Diamond dedup
        seen_mixins[mixin_name] = true

        val mixin_def = interp.get_mixin(mixin_name)
        if mixin_def.?:
            val mixin = mixin_def.unwrap()
            # Queue transitive dependencies
            for req in mixin.required_mixins:
                queue.push(req)
            # Collect fields (dedup)
            for field in mixin.fields:
                if not seen_fields.contains(field.name):
                    seen_fields.add(field.name)
                    mixin_fields.push(field)
            # Collect methods (skip if already defined)
            for method in mixin.methods:
                if not seen_methods.contains(method.name):
                    seen_methods.add(method.name)
                    mixin_methods.push(method)

    var updated = class_def
    updated.fields = mixin_fields + class_def.fields
    updated.methods = class_def.methods + mixin_methods
    updated

fn register_unit_family(interp: Interpreter, uf: UnitFamilyDef, state: ModuleState):
    var conversions = {}
    for variant in uf.variants:
        state.units[variant.suffix] = UnitDef(
            name: "{uf.name}_{variant.suffix}",
            base_types: [uf.base_type],
            suffix: variant.suffix,
            visibility: uf.visibility)
        conversions[variant.suffix] = variant.factor
    state.unit_families[uf.name] = UnitFamilyInfo(
        base_type: uf.base_type,
        conversions: conversions)
    interp.env.define(uf.name, Value.nil())
