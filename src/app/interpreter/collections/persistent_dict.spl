# Persistent Dictionary (HAMT)
#
# Hash Array Mapped Trie implementation for immutable dictionaries.
# Provides O(log32 n) operations with structural sharing.
#
# Key features:
# - Immutable: Updates return new dict, original unchanged
# - Structural sharing: Only modified path is copied (~7 nodes max)
# - Memory efficient: Shared nodes between versions
# - Thread-safe: No locks needed for concurrent reads
#
# Based on Phil Bagwell's "Ideal Hash Trees" (2001) and
# Clojure's persistent hash map implementation.
#
# Performance:
# - get: O(log32 n) ≈ O(7) for billions of entries
# - set: O(log32 n) with ~7 node copies
# - Memory: Only changed path duplicated

export PersistentDict, PersistentDictIter

# ============================================================================
# Constants
# ============================================================================

# Branching factor: 32 children per node (5 bits per level)
val BITS_PER_LEVEL: i64 = 5
val BRANCH_FACTOR: i64 = 32  # 2^5
val MASK: i64 = 31           # 0b11111 - mask for 5 bits

# Maximum depth: 64-bit hash / 5 bits per level ≈ 13 levels
val MAX_DEPTH: i64 = 13

# ============================================================================
# HAMT Node Types
# ============================================================================

enum HamtNode<K, V>:
    """Node in the Hash Array Mapped Trie.

    Variants:
    - Empty: No entries (used as sentinel)
    - Leaf: Single key-value pair
    - Branch: Internal node with bitmap and children
    - Collision: Multiple entries with same hash (rare)
    """
    Empty

    Leaf(hash: i64, key: K, value: V)

    Branch(
        bitmap: i32,              # Which slots are occupied (32 bits)
        children: [HamtNode<K, V>]  # Compressed array of children
    )

    Collision(
        hash: i64,
        entries: [(K, V)]         # All entries with this hash
    )

impl HamtNode<K, V>:
    # --------------------------------------------------------------------------
    # Node queries
    # --------------------------------------------------------------------------

    fn is_empty() -> bool:
        match self:
            case Empty: true
            case _: false

    fn is_leaf() -> bool:
        match self:
            case Leaf(_, _, _): true
            case _: false

    fn count() -> i64:
        """Count entries in this subtree."""
        match self:
            case Empty: 0
            case Leaf(_, _, _): 1
            case Branch(_, children):
                var total: i64 = 0
                for child in children:
                    total = total + child.count()
                total
            case Collision(_, entries): entries.len()

    # --------------------------------------------------------------------------
    # Lookup
    # --------------------------------------------------------------------------

    fn find(hash: i64, key: K, depth: i64) -> V?:
        """Find value for key at given depth.

        Args:
            hash: Pre-computed hash of key
            key: Key to find
            depth: Current depth in trie (0 = root)

        Returns:
            Some(value) if found, None otherwise
        """
        match self:
            case Empty:
                None

            case Leaf(leaf_hash, leaf_key, value):
                if hash == leaf_hash and key == leaf_key:
                    Some(value)
                else:
                    None

            case Branch(bitmap, children):
                val idx = index_at_depth(hash, depth)
                val bit = 1 << idx

                if (bitmap & bit) == 0:
                    # Slot is empty
                    None
                else:
                    # Slot occupied, recurse
                    val child_idx = popcount(bitmap & (bit - 1))
                    children[child_idx].find(hash, key, depth + 1)

            case Collision(col_hash, entries):
                if hash != col_hash:
                    None
                else:
                    # Linear search through collision list
                    for (k, v) in entries:
                        if k == key:
                            return Some(v)
                    None

    # --------------------------------------------------------------------------
    # Insert/Update
    # --------------------------------------------------------------------------

    fn insert(hash: i64, key: K, value: V, depth: i64) -> HamtNode<K, V>:
        """Insert or update key-value pair.

        Returns a new node with the entry added/updated.
        The original node is unchanged (structural sharing).

        Args:
            hash: Pre-computed hash of key
            key: Key to insert
            value: Value to insert
            depth: Current depth in trie
        """
        match self:
            case Empty:
                # Empty -> Leaf
                HamtNode.Leaf(hash, key, value)

            case Leaf(leaf_hash, leaf_key, leaf_value):
                if hash == leaf_hash:
                    if key == leaf_key:
                        # Same key, update value
                        HamtNode.Leaf(hash, key, value)
                    else:
                        # Hash collision, create Collision node
                        HamtNode.Collision(hash, [(leaf_key, leaf_value), (key, value)])
                else:
                    # Different hash, create Branch node
                    self.split_leaf(leaf_hash, leaf_key, leaf_value, hash, key, value, depth)

            case Branch(bitmap, children):
                val idx = index_at_depth(hash, depth)
                val bit = 1 << idx

                if (bitmap & bit) == 0:
                    # Slot empty, add new leaf
                    val child_idx = popcount(bitmap & (bit - 1))
                    val new_child = HamtNode.Leaf(hash, key, value)
                    val new_children = array_insert(children, child_idx, new_child)
                    HamtNode.Branch(bitmap | bit, new_children)
                else:
                    # Slot occupied, recurse and update
                    val child_idx = popcount(bitmap & (bit - 1))
                    val new_child = children[child_idx].insert(hash, key, value, depth + 1)
                    val new_children = array_update(children, child_idx, new_child)
                    HamtNode.Branch(bitmap, new_children)

            case Collision(col_hash, entries):
                if hash == col_hash:
                    # Add to collision list (or update existing)
                    var new_entries: [(K, V)] = []
                    var found = false
                    for (k, v) in entries:
                        if k == key:
                            new_entries = new_entries.push((key, value))
                            found = true
                        else:
                            new_entries = new_entries.push((k, v))
                    if not found:
                        new_entries = new_entries.push((key, value))
                    HamtNode.Collision(col_hash, new_entries)
                else:
                    # Different hash, need to expand to Branch
                    # This is rare - convert collision to branch first
                    var branch = self.collision_to_branch(depth)
                    branch.insert(hash, key, value, depth)

    fn split_leaf(leaf_hash: i64, leaf_key: K, leaf_value: V,
                  new_hash: i64, new_key: K, new_value: V, depth: i64) -> HamtNode<K, V>:
        """Split a leaf node when hashes differ.

        Creates a branch node containing both entries.
        May need to recurse if indices collide at this level.
        """
        if depth >= MAX_DEPTH:
            # At max depth, create collision
            HamtNode.Collision(leaf_hash, [(leaf_key, leaf_value), (new_key, new_value)])
        else:
            val idx1 = index_at_depth(leaf_hash, depth)
            val idx2 = index_at_depth(new_hash, depth)

            if idx1 == idx2:
                # Same index at this level, recurse
                val child = HamtNode.Empty.split_leaf(
                    leaf_hash, leaf_key, leaf_value,
                    new_hash, new_key, new_value,
                    depth + 1
                )
                val bit = 1 << idx1
                HamtNode.Branch(bit, [child])
            else:
                # Different indices, create branch with two children
                val leaf1 = HamtNode.Leaf(leaf_hash, leaf_key, leaf_value)
                val leaf2 = HamtNode.Leaf(new_hash, new_key, new_value)
                val bit1 = 1 << idx1
                val bit2 = 1 << idx2

                if idx1 < idx2:
                    HamtNode.Branch(bit1 | bit2, [leaf1, leaf2])
                else:
                    HamtNode.Branch(bit1 | bit2, [leaf2, leaf1])

    fn collision_to_branch(depth: i64) -> HamtNode<K, V>:
        """Convert a collision node to a branch node."""
        match self:
            case Collision(hash, entries):
                var result: HamtNode<K, V> = HamtNode.Empty
                for (k, v) in entries:
                    result = result.insert(hash, k, v, depth)
                result
            case _:
                self  # Not a collision, return as-is

    # --------------------------------------------------------------------------
    # Remove
    # --------------------------------------------------------------------------

    fn remove(hash: i64, key: K, depth: i64) -> HamtNode<K, V>:
        """Remove a key from the trie.

        Returns a new node without the entry.
        Returns Empty if the node becomes empty.
        """
        match self:
            case Empty:
                HamtNode.Empty

            case Leaf(leaf_hash, leaf_key, _):
                if hash == leaf_hash and key == leaf_key:
                    HamtNode.Empty
                else:
                    self  # Key not found, return unchanged

            case Branch(bitmap, children):
                val idx = index_at_depth(hash, depth)
                val bit = 1 << idx

                if (bitmap & bit) == 0:
                    # Key not in this branch
                    self
                else:
                    val child_idx = popcount(bitmap & (bit - 1))
                    val new_child = children[child_idx].remove(hash, key, depth + 1)

                    if new_child.is_empty():
                        # Child became empty, remove from branch
                        val new_bitmap = bitmap & (not bit)
                        if new_bitmap == 0:
                            HamtNode.Empty
                        elif popcount(new_bitmap) == 1 and children.len() == 2:
                            # Only one child left, check if we can collapse
                            val remaining_idx = if child_idx == 0: 1 else: 0
                            val remaining = children[remaining_idx]
                            if remaining.is_leaf():
                                remaining  # Collapse to leaf
                            else:
                                val new_children = array_remove(children, child_idx)
                                HamtNode.Branch(new_bitmap, new_children)
                        else:
                            val new_children = array_remove(children, child_idx)
                            HamtNode.Branch(new_bitmap, new_children)
                    else:
                        # Update child
                        val new_children = array_update(children, child_idx, new_child)
                        HamtNode.Branch(bitmap, new_children)

            case Collision(col_hash, entries):
                if hash != col_hash:
                    self
                else:
                    var new_entries: [(K, V)] = []
                    for (k, v) in entries:
                        if k != key:
                            new_entries = new_entries.push((k, v))

                    if new_entries.len() == 0:
                        HamtNode.Empty
                    elif new_entries.len() == 1:
                        value (k, v) = new_entries[0]
                        HamtNode.Leaf(col_hash, k, v)
                    else:
                        HamtNode.Collision(col_hash, new_entries)

    # --------------------------------------------------------------------------
    # Iteration
    # --------------------------------------------------------------------------

    fn collect_entries(result: [(K, V)]) -> [(K, V)]:
        """Collect all entries into a list."""
        match self:
            case Empty:
                result
            case Leaf(_, key, value):
                result.push((key, value))
            case Branch(_, children):
                var acc = result
                for child in children:
                    acc = child.collect_entries(acc)
                acc
            case Collision(_, entries):
                var acc = result
                for entry in entries:
                    acc = acc.push(entry)
                acc

# ============================================================================
# PersistentDict - Public API
# ============================================================================

struct PersistentDict<K, V>:
    """Immutable persistent dictionary using HAMT.

    All operations return a new dictionary, leaving the original unchanged.
    Memory efficient through structural sharing.

    Example:
        val dict1 = PersistentDict.new()
        val dict2 = dict1.set("key", "value")
        val dict3 = dict2.set("other", "data")

        # dict1 is still empty
        # dict2 has one entry
        # dict3 has two entries
        # dict2 and dict3 share most of their structure
    """
    root: HamtNode<K, V>
    size: i64

impl PersistentDict<K, V>:
    # --------------------------------------------------------------------------
    # Construction
    # --------------------------------------------------------------------------

    static fn new() -> PersistentDict<K, V>:
        """Create an empty persistent dictionary."""
        PersistentDict(
            root: HamtNode.Empty,
            size: 0
        )

    static fn from_entries(entries: [(K, V)]) -> PersistentDict<K, V>:
        """Create a dictionary from a list of key-value pairs."""
        var dict = PersistentDict.new()
        for (key, value) in entries:
            dict = dict.set(key, value)
        dict

    # --------------------------------------------------------------------------
    # Queries
    # --------------------------------------------------------------------------

    fn len() -> i64:
        """Number of entries in the dictionary."""
        self.size

    fn is_empty() -> bool:
        """Check if dictionary is empty."""
        self.size == 0

    fn get(key: K) -> V?:
        """Get value for key, or None if not found.

        Time: O(log32 n) ≈ O(7) for practical sizes
        """
        val hash = compute_hash(key)
        self.root.find(hash, key, 0)

    fn contains(key: K) -> bool:
        """Check if key exists in dictionary."""
        self.get(key).?

    fn get_or(key: K, default: V) -> V:
        """Get value for key, or default if not found."""
        self.get(key) ?? default

    # --------------------------------------------------------------------------
    # Modification (returns new dict)
    # --------------------------------------------------------------------------

    fn set(key: K, value: V) -> PersistentDict<K, V>:
        """Set a key-value pair, returning a new dictionary.

        The original dictionary is unchanged.

        Time: O(log32 n) with ~7 node copies
        Memory: Only the modified path is duplicated
        """
        val hash = compute_hash(key)
        val existed = self.root.find(hash, key, 0).?
        val new_root = self.root.insert(hash, key, value, 0)
        val new_size = if existed: self.size else: self.size + 1
        PersistentDict(root: new_root, size: new_size)

    fn remove(key: K) -> PersistentDict<K, V>:
        """Remove a key, returning a new dictionary.

        The original dictionary is unchanged.
        Returns self if key doesn't exist.
        """
        val hash = compute_hash(key)
        if not self.root.find(hash, key, 0).?:
            return self  # Key not found, return unchanged

        val new_root = self.root.remove(hash, key, 0)
        PersistentDict(root: new_root, size: self.size - 1)

    fn update(key: K, f: fn(V?) -> V) -> PersistentDict<K, V>:
        """Update a value using a function.

        The function receives the current value (or None if not present)
        and returns the new value.
        """
        val current = self.get(key)
        val new_value = f(current)
        self.set(key, new_value)

    # --------------------------------------------------------------------------
    # Bulk operations
    # --------------------------------------------------------------------------

    fn merge(other: PersistentDict<K, V>) -> PersistentDict<K, V>:
        """Merge another dictionary into this one.

        On key conflicts, values from `other` take precedence.
        """
        var result = self
        for (key, value) in other.entries():
            result = result.set(key, value)
        result

    fn filter(predicate: fn(K, V) -> bool) -> PersistentDict<K, V>:
        """Keep only entries matching the predicate."""
        var result = PersistentDict.new()
        for (key, value) in self.entries():
            if predicate(key, value):
                result = result.set(key, value)
        result

    fn map_values<U>(f: fn(V) -> U) -> PersistentDict<K, U>:
        """Transform all values using a function."""
        var result: PersistentDict<K, U> = PersistentDict.new()
        for (key, value) in self.entries():
            result = result.set(key, f(value))
        result

    # --------------------------------------------------------------------------
    # Conversion
    # --------------------------------------------------------------------------

    fn entries() -> [(K, V)]:
        """Get all entries as a list of (key, value) pairs."""
        self.root.collect_entries([])

    fn keys() -> [K]:
        """Get all keys as a list."""
        var result: [K] = []
        for (key, _) in self.entries():
            result = result.push(key)
        result

    fn values() -> [V]:
        """Get all values as a list."""
        var result: [V] = []
        for (_, value) in self.entries():
            result = result.push(value)
        result

    fn to_dict() -> Dict<K, V>:
        """Convert to a regular mutable Dict."""
        var result: Dict<K, V> = {}
        for (key, value) in self.entries():
            result[key] = value
        result

    static fn from_dict(dict: Dict<K, V>) -> PersistentDict<K, V>:
        """Create from a regular Dict."""
        var result = PersistentDict.new()
        for key in dict.keys():
            result = result.set(key, dict[key])
        result

# ============================================================================
# Iterator
# ============================================================================

struct PersistentDictIter<K, V>:
    """Iterator over PersistentDict entries."""
    entries: [(K, V)]
    index: i64

impl PersistentDictIter<K, V>:
    static fn new(dict: PersistentDict<K, V>) -> PersistentDictIter<K, V>:
        PersistentDictIter(
            entries: dict.entries(),
            index: 0
        )

    fn next() -> (K, V)?:
        if self.index >= self.entries.len():
            None
        else:
            val entry = self.entries[self.index]
            self.index = self.index + 1
            Some(entry)

    fn has_next() -> bool:
        self.index < self.entries.len()

impl Iterable<(K, V)> for PersistentDict<K, V>:
    fn iter() -> PersistentDictIter<K, V>:
        PersistentDictIter.new(self)

# ============================================================================
# Helper Functions
# ============================================================================

fn index_at_depth(hash: i64, depth: i64) -> i64:
    """Extract the index for a given depth level.

    Each level uses 5 bits of the hash.
    """
    (hash >> (depth * BITS_PER_LEVEL)) & MASK

fn popcount(x: i32) -> i64:
    """Count number of set bits (population count).

    Used to compute compressed array index from bitmap.
    """
    # Brian Kernighan's algorithm
    var count: i64 = 0
    var n = x
    while n != 0:
        n = n & (n - 1)
        count = count + 1
    count

fn compute_hash<K>(key: K) -> i64:
    """Compute hash for a key.

    Uses the key's hash() method if available,
    otherwise falls back to identity for integers.
    """
    key.hash()

fn array_insert<T>(arr: [T], index: i64, value: T) -> [T]:
    """Insert value at index, returning new array."""
    var result: [T] = []
    for i in 0..arr.len():
        if i == index:
            result = result.push(value)
        result = result.push(arr[i])
    if index >= arr.len():
        result = result.push(value)
    result

fn array_update<T>(arr: [T], index: i64, value: T) -> [T]:
    """Update value at index, returning new array."""
    var result: [T] = []
    for i in 0..arr.len():
        if i == index:
            result = result.push(value)
        else:
            result = result.push(arr[i])
    result

fn array_remove<T>(arr: [T], index: i64) -> [T]:
    """Remove value at index, returning new array."""
    var result: [T] = []
    for i in 0..arr.len():
        if i != index:
            result = result.push(arr[i])
    result

# ============================================================================
# Display / Debug
# ============================================================================

impl Display for PersistentDict<K, V>:
    fn fmt() -> text:
        if self.is_empty():
            "PersistentDict{}"
        else:
            var parts: [text] = []
            for (key, value) in self.entries():
                parts = parts.push("{key}: {value}")
            "PersistentDict{" + parts.join(", ") + "}"

impl Debug for PersistentDict<K, V>:
    fn debug() -> text:
        "PersistentDict(size={self.size})"
