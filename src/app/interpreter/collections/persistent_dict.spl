# Persistent Dictionary (HAMT)
#
# Hash Array Mapped Trie implementation for immutable dictionaries.
# Provides O(log32 n) operations with structural sharing.
#
# Key features:
# - Immutable: Updates return new dict, original unchanged
# - Structural sharing: Only modified path is copied (~7 nodes max)
# - Memory efficient: Shared nodes between versions
# - Thread-safe: No locks needed for concurrent reads
#
# Based on Phil Bagwell's "Ideal Hash Trees" (2001) and
# Clojure's persistent hash map implementation.
#
# Performance:
# - get: O(log32 n) â‰ˆ O(7) for billions of entries
# - set: O(log32 n) with ~7 node copies
# - Memory: Only changed path duplicated

# Import and re-export from submodules
use app.interpreter.collections.persistent_dict.node.{HamtNode}
use app.interpreter.collections.persistent_dict.dict.{PersistentDict}
use app.interpreter.collections.persistent_dict.iter.{PersistentDictIter}
use app.interpreter.collections.persistent_dict.helpers.{
    BITS_PER_LEVEL, BRANCH_FACTOR, MASK, MAX_DEPTH
}

# Re-export main types
export PersistentDict, PersistentDictIter

# ============================================================================
# Module-Level Factory Functions (Workaround for static method call limitation)
# ============================================================================

# TODO: Remove these once static method calls are supported in interpreter
fn dict_empty<K, V>() -> PersistentDict<K, V>:
    """Create an empty persistent dictionary.

    Workaround for static method call limitation. Use this instead of:
        PersistentDict<K, V>.empty()
    """
    # Direct construction to avoid static method call
    PersistentDict(
        root: HamtNode.Empty,
        size: 0
    )

fn dict_from_entries<K, V>(entries: [(K, V)]) -> PersistentDict<K, V>:
    """Create dictionary from key-value pairs.

    Workaround for static method call limitation. Use this instead of:
        PersistentDict<K, V>.from_entries(entries)
    """
    # Build dict by inserting each entry
    var dict = dict_empty<K, V>()
    for (key, value) in entries:
        dict = dict.set(key, value)
    dict

fn dict_from_dict<K, V>(dict: Dict<K, V>) -> PersistentDict<K, V>:
    """Create persistent dictionary from regular Dict.

    Workaround for static method call limitation. Use this instead of:
        PersistentDict<K, V>.from_dict(dict)
    """
    # Build persistent dict from regular dict entries
    var pdict = dict_empty<K, V>()
    for (key, value) in dict:
        pdict = pdict.set(key, value)
    pdict

export dict_empty, dict_from_entries, dict_from_dict
