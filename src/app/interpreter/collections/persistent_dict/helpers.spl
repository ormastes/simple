# Persistent Dictionary Helpers
#
# Helper functions for HAMT operations.

# ============================================================================
# Constants
# ============================================================================

# Branching factor: 32 children per node (5 bits per level)
val BITS_PER_LEVEL: i64 = 5
val BRANCH_FACTOR: i64 = 32  # 2^5
val MASK: i64 = 31           # 0b11111 - mask for 5 bits

# Maximum depth: 64-bit hash / 5 bits per level ≈ 13 levels
val MAX_DEPTH: i64 = 13

# ============================================================================
# Helper Functions
# ============================================================================

fn index_at_depth(hash: i64, depth: i64) -> i64:
    """Extract the index for a given depth level.

    Each level uses 5 bits of the hash.
    """
    (hash >> (depth * BITS_PER_LEVEL)) & MASK

fn popcount(x: i32) -> i64:
    """Count number of set bits (population count).

    Used to compute compressed array index from bitmap.
    """
    # Brian Kernighan's algorithm
    var count: i64 = 0
    var n = x
    while n != 0:
        n = n & (n - 1)
        count = count + 1
    count

fn compute_hash<K>(key: K) -> i64:
    """Compute hash for a key.

    Uses the key's hash() method if available,
    otherwise falls back to identity for integers.
    """
    key.hash()

fn array_insert<T>(arr: [T], index: i64, value: T) -> [T]:
    """Insert value at index, returning new array.

    Optimized with ArrayBuilder - O(n) with single allocation.
    Previous implementation was O(n²) due to repeated push allocations.
    """
    var builder = ArrayBuilder.with_capacity(arr.len() + 1)

    # Copy elements before insertion point
    for i in 0..index:
        builder.push_unchecked(arr[i])

    # Insert new value
    builder.push_unchecked(value)

    # Copy remaining elements
    for i in index..arr.len():
        builder.push_unchecked(arr[i])

    builder.build()

fn array_update<T>(arr: [T], index: i64, value: T) -> [T]:
    """Update value at index, returning new array.

    Optimized with ArrayBuilder - O(n) with single allocation.
    """
    var builder = ArrayBuilder.with_capacity(arr.len())

    for i in 0..arr.len():
        if i == index:
            builder.push_unchecked(value)
        else:
            builder.push_unchecked(arr[i])

    builder.build()

fn array_remove<T>(arr: [T], index: i64) -> [T]:
    """Remove value at index, returning new array.

    Optimized with ArrayBuilder - O(n) with single allocation.
    """
    var builder = ArrayBuilder.with_capacity(arr.len() - 1)

    for i in 0..arr.len():
        if i != index:
            builder.push_unchecked(arr[i])

    builder.build()


export BITS_PER_LEVEL, BRANCH_FACTOR, MASK, MAX_DEPTH
export index_at_depth, popcount, compute_hash
export array_insert, array_update, array_remove
