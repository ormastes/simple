# HAMT Node Types
#
# Hash Array Mapped Trie node implementations.

use std.array_builder.ArrayBuilder
use app.interpreter.collections.persistent_dict.helpers.{
    BITS_PER_LEVEL, BRANCH_FACTOR, MASK, MAX_DEPTH,
    index_at_depth, popcount, compute_hash,
    array_insert, array_update, array_remove
}

enum HamtNode<K, V>:
    """Node in the Hash Array Mapped Trie.

    Variants:
    - Empty: No entries (used as sentinel)
    - Leaf: Single key-value pair
    - Branch: Internal node with bitmap and children
    - Collision: Multiple entries with same hash (rare)
    """
    Empty

    Leaf(hash: i64, key: K, value: V)

    Branch(
        bitmap: i32,              # Which slots are occupied (32 bits)
        children: [HamtNode<K, V>]  # Compressed array of children
    )

    Collision(
        hash: i64,
        entries: [(K, V)]         # All entries with this hash
    )

impl HamtNode<K, V>:
    # --------------------------------------------------------------------------
    # Node queries
    # --------------------------------------------------------------------------

    fn is_empty() -> bool:
        match self:
            case Empty: true
            case _: false

    fn is_leaf() -> bool:
        match self:
            case Leaf(_, _, _): true
            case _: false

    fn count() -> i64:
        """Count entries in this subtree."""
        match self:
            case Empty: 0
            case Leaf(_, _, _): 1
            case Branch(_, children):
                var total: i64 = 0
                for child in children:
                    total = total + child.count()
                total
            case Collision(_, entries): entries.len()

    # --------------------------------------------------------------------------
    # Lookup
    # --------------------------------------------------------------------------

    fn find(hash: i64, key: K, depth: i64) -> V?:
        """Find value for key at given depth.

        Args:
            hash: Pre-computed hash of key
            key: Key to find
            depth: Current depth in trie (0 = root)

        Returns:
            Some(value) if found, None otherwise
        """
        match self:
            case Empty:
                None

            case Leaf(leaf_hash, leaf_key, value):
                if hash == leaf_hash and key == leaf_key:
                    Some(value)
                else:
                    None

            case Branch(bitmap, children):
                val idx = index_at_depth(hash, depth)
                val bit = 1 << idx

                if (bitmap & bit) == 0:
                    # Slot is empty
                    None
                else:
                    # Slot occupied, recurse
                    val child_idx = popcount(bitmap & (bit - 1))
                    children[child_idx].find(hash, key, depth + 1)

            case Collision(col_hash, entries):
                if hash != col_hash:
                    None
                else:
                    # Linear search through collision list
                    for (k, v) in entries:
                        if k == key:
                            return Some(v)
                    None

    # --------------------------------------------------------------------------
    # Insert/Update
    # --------------------------------------------------------------------------

    fn insert(hash: i64, key: K, value: V, depth: i64) -> HamtNode<K, V>:
        """Insert or update key-value pair.

        Returns a new node with the entry added/updated.
        The original node is unchanged (structural sharing).

        Args:
            hash: Pre-computed hash of key
            key: Key to insert
            value: Value to insert
            depth: Current depth in trie
        """
        match self:
            case Empty:
                # Empty -> Leaf
                HamtNode.Leaf(hash, key, value)

            case Leaf(leaf_hash, leaf_key, leaf_value):
                if hash == leaf_hash:
                    if key == leaf_key:
                        # Same key, update value
                        HamtNode.Leaf(hash, key, value)
                    else:
                        # Hash collision, create Collision node
                        HamtNode.Collision(hash, [(leaf_key, leaf_value), (key, value)])
                else:
                    # Different hash, create Branch node
                    self.split_leaf(leaf_hash, leaf_key, leaf_value, hash, key, value, depth)

            case Branch(bitmap, children):
                val idx = index_at_depth(hash, depth)
                val bit = 1 << idx

                if (bitmap & bit) == 0:
                    # Slot empty, add new leaf
                    val child_idx = popcount(bitmap & (bit - 1))
                    val new_child = HamtNode.Leaf(hash, key, value)
                    val new_children = array_insert(children, child_idx, new_child)
                    HamtNode.Branch(bitmap | bit, new_children)
                else:
                    # Slot occupied, recurse and update
                    val child_idx = popcount(bitmap & (bit - 1))
                    val new_child = children[child_idx].insert(hash, key, value, depth + 1)
                    val new_children = array_update(children, child_idx, new_child)
                    HamtNode.Branch(bitmap, new_children)

            case Collision(col_hash, entries):
                if hash == col_hash:
                    # Add to collision list (or update existing)
                    var new_entries: [(K, V)] = []
                    var found = false
                    for (k, v) in entries:
                        if k == key:
                            new_entries = new_entries.push((key, value))
                            found = true
                        else:
                            new_entries = new_entries.push((k, v))
                    if not found:
                        new_entries = new_entries.push((key, value))
                    HamtNode.Collision(col_hash, new_entries)
                else:
                    # Different hash, need to expand to Branch
                    # This is rare - convert collision to branch first
                    var branch = self.collision_to_branch(depth)
                    branch.insert(hash, key, value, depth)

    fn split_leaf(leaf_hash: i64, leaf_key: K, leaf_value: V,
                  new_hash: i64, new_key: K, new_value: V, depth: i64) -> HamtNode<K, V>:
        """Split a leaf node when hashes differ.

        Creates a branch node containing both entries.
        May need to recurse if indices collide at this level.
        """
        if depth >= MAX_DEPTH:
            # At max depth, create collision
            HamtNode.Collision(leaf_hash, [(leaf_key, leaf_value), (new_key, new_value)])
        else:
            val idx1 = index_at_depth(leaf_hash, depth)
            val idx2 = index_at_depth(new_hash, depth)

            if idx1 == idx2:
                # Same index at this level, recurse
                val child = HamtNode.split_leaf(
                    leaf_hash, leaf_key, leaf_value,
                    new_hash, new_key, new_value,
                    depth + 1
                )
                val bit = 1 << idx1
                HamtNode.Branch(bit, [child])
            else:
                # Different indices, create branch with two children
                val leaf1 = HamtNode.Leaf(leaf_hash, leaf_key, leaf_value)
                val leaf2 = HamtNode.Leaf(new_hash, new_key, new_value)
                val bit1 = 1 << idx1
                val bit2 = 1 << idx2

                if idx1 < idx2:
                    HamtNode.Branch(bit1 | bit2, [leaf1, leaf2])
                else:
                    HamtNode.Branch(bit1 | bit2, [leaf2, leaf1])

    fn collision_to_branch(depth: i64) -> HamtNode<K, V>:
        """Convert a collision node to a branch node."""
        match self:
            case Collision(hash, entries):
                var result: HamtNode<K, V> = HamtNode.Empty
                for (k, v) in entries:
                    result = result.insert(hash, k, v, depth)
                result
            case _:
                self  # Not a collision, return as-is

    # --------------------------------------------------------------------------
    # Remove
    # --------------------------------------------------------------------------

    fn remove(hash: i64, key: K, depth: i64) -> HamtNode<K, V>:
        """Remove a key from the trie.

        Returns a new node without the entry.
        Returns Empty if the node becomes empty.
        """
        match self:
            case Empty:
                HamtNode.Empty

            case Leaf(leaf_hash, leaf_key, _):
                if hash == leaf_hash and key == leaf_key:
                    HamtNode.Empty
                else:
                    self  # Key not found, return unchanged

            case Branch(bitmap, children):
                val idx = index_at_depth(hash, depth)
                val bit = 1 << idx

                if (bitmap & bit) == 0:
                    # Key not in this branch
                    self
                else:
                    val child_idx = popcount(bitmap & (bit - 1))
                    val new_child = children[child_idx].remove(hash, key, depth + 1)

                    if new_child.is_empty():
                        # Child became empty, remove from branch
                        val new_bitmap = bitmap & (not bit)
                        if new_bitmap == 0:
                            HamtNode.Empty
                        elif popcount(new_bitmap) == 1 and children.len() == 2:
                            # Only one child left, check if we can collapse
                            val remaining_idx = if child_idx == 0: 1 else: 0
                            val remaining = children[remaining_idx]
                            if remaining.is_leaf():
                                remaining  # Collapse to leaf
                            else:
                                val new_children = array_remove(children, child_idx)
                                HamtNode.Branch(new_bitmap, new_children)
                        else:
                            val new_children = array_remove(children, child_idx)
                            HamtNode.Branch(new_bitmap, new_children)
                    else:
                        # Update child
                        val new_children = array_update(children, child_idx, new_child)
                        HamtNode.Branch(bitmap, new_children)

            case Collision(col_hash, entries):
                if hash != col_hash:
                    self
                else:
                    var new_entries: [(K, V)] = []
                    for (k, v) in entries:
                        if k != key:
                            new_entries = new_entries.push((k, v))

                    if new_entries.len() == 0:
                        HamtNode.Empty
                    elif new_entries.len() == 1:
                        value (k, v) = new_entries[0]
                        HamtNode.Leaf(col_hash, k, v)
                    else:
                        HamtNode.Collision(col_hash, new_entries)

    # --------------------------------------------------------------------------
    # Iteration
    # --------------------------------------------------------------------------

    fn collect_entries(result: [(K, V)]) -> [(K, V)]:
        """Collect all entries into a list."""
        match self:
            case Empty:
                result
            case Leaf(_, key, value):
                result.push((key, value))
            case Branch(_, children):
                var acc = result
                for child in children:
                    acc = child.collect_entries(acc)
                acc
            case Collision(_, entries):
                var acc = result
                for entry in entries:
                    acc = acc.push(entry)
                acc


export HamtNode
