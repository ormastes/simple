# Persistent Symbol Table
#
# Immutable symbol table using persistent data structures.
# Enables efficient undo/redo and concurrent compilation.
#
# Benefits:
# - Structural sharing: scope changes don't copy entire table
# - Thread-safe: no locks needed for concurrent reads
# - Time-travel: keep old versions for error reporting
# - Memory efficient: versions share most nodes

from persistent_dict import {PersistentDict}
from ..core.symbol import {SymbolId, intern, resolve}

export PersistentSymbolTable, PersistentScope, SymbolEntry

# ============================================================================
# Symbol Entry
# ============================================================================

struct SymbolEntry:
    """A symbol in the table."""
    id: SymbolId
    name: SymbolId          # Interned name
    kind: SymbolKind
    scope_id: i64
    is_public: bool
    is_mutable: bool

enum SymbolKind:
    """Kind of symbol."""
    Function
    Method
    Variable
    Parameter
    Field
    Class
    Struct
    Enum
    EnumVariant
    Trait
    TypeAlias
    TypeParam
    Const
    Module
    Import

# ============================================================================
# Persistent Scope
# ============================================================================

struct PersistentScope:
    """A lexical scope with persistent bindings."""
    id: i64
    parent_id: i64?
    kind: ScopeKind
    bindings: PersistentDict<i64, SymbolId>  # name_id -> symbol_id

enum ScopeKind:
    Module
    Function
    Block
    Loop
    Match
    Class
    Impl

impl PersistentScope:
    static fn new(id: i64, parent_id: i64?, kind: ScopeKind) -> PersistentScope:
        PersistentScope(
            id: id,
            parent_id: parent_id,
            kind: kind,
            bindings: PersistentDict.new()
        )

    fn define(name_id: i64, symbol_id: SymbolId) -> PersistentScope:
        """Define a binding, returning new scope."""
        PersistentScope(
            id: self.id,
            parent_id: self.parent_id,
            kind: self.kind,
            bindings: self.bindings.set(name_id, symbol_id)
        )

    fn lookup(name_id: i64) -> SymbolId?:
        """Look up a binding in this scope only."""
        self.bindings.get(name_id)

# ============================================================================
# Persistent Symbol Table
# ============================================================================

struct PersistentSymbolTable:
    """Immutable symbol table with structural sharing.

    All modifications return a new table, leaving the original unchanged.
    This enables:
    - Concurrent compilation without locks
    - Keeping snapshots for error messages
    - Efficient undo/redo in IDE
    """
    symbols: PersistentDict<i64, SymbolEntry>
    scopes: PersistentDict<i64, PersistentScope>
    current_scope_id: i64
    next_symbol_id: i64
    next_scope_id: i64

impl PersistentSymbolTable:
    static fn new() -> PersistentSymbolTable:
        """Create a new symbol table with a root module scope."""
        val root_scope = PersistentScope.new(0, None, ScopeKind.Module)

        PersistentSymbolTable(
            symbols: PersistentDict.new(),
            scopes: PersistentDict<i64, PersistentScope>.new().set(0, root_scope),
            current_scope_id: 0,
            next_symbol_id: 0,
            next_scope_id: 1
        )

    # --------------------------------------------------------------------------
    # Symbol definition
    # --------------------------------------------------------------------------

    fn define(name: text, kind: SymbolKind, is_public: bool, is_mutable: bool) -> (PersistentSymbolTable, SymbolId):
        """Define a new symbol, returning (new_table, symbol_id)."""
        val name_id = intern(name)
        val symbol_id = SymbolId(id: self.next_symbol_id)

        val entry = SymbolEntry(
            id: symbol_id,
            name: name_id,
            kind: kind,
            scope_id: self.current_scope_id,
            is_public: is_public,
            is_mutable: is_mutable
        )

        # Update symbols map
        val new_symbols = self.symbols.set(symbol_id.id, entry)

        # Update current scope's bindings
        val current_scope = self.scopes.get(self.current_scope_id).unwrap()
        val new_scope = current_scope.define(name_id.id, symbol_id)
        val new_scopes = self.scopes.set(self.current_scope_id, new_scope)

        val new_table = PersistentSymbolTable(
            symbols: new_symbols,
            scopes: new_scopes,
            current_scope_id: self.current_scope_id,
            next_symbol_id: self.next_symbol_id + 1,
            next_scope_id: self.next_scope_id
        )

        (new_table, symbol_id)

    # --------------------------------------------------------------------------
    # Symbol lookup
    # --------------------------------------------------------------------------

    fn lookup(name: text) -> SymbolId?:
        """Look up a symbol by name, searching scope chain."""
        val name_id = intern(name)
        self.lookup_by_id(name_id.id)

    fn lookup_by_id(name_id: i64) -> SymbolId?:
        """Look up a symbol by interned name id."""
        var scope_id: i64? = Some(self.current_scope_id)

        while scope_id.?:
            val scope = self.scopes.get(scope_id.unwrap())
            if scope.?:
                val sym = scope.unwrap().lookup(name_id)
                if sym.?:
                    return sym
                scope_id = scope.unwrap().parent_id
            else:
                break

        None

    fn get(id: SymbolId) -> SymbolEntry?:
        """Get symbol by id."""
        self.symbols.get(id.id)

    fn get_name(id: SymbolId) -> text?:
        """Get the name of a symbol."""
        val entry = self.get(id)
        if entry.?:
            resolve(entry.unwrap().name)
        else:
            None

    # --------------------------------------------------------------------------
    # Scope management
    # --------------------------------------------------------------------------

    fn push_scope(kind: ScopeKind) -> PersistentSymbolTable:
        """Push a new scope, returning new table."""
        val new_scope_id = self.next_scope_id
        val new_scope = PersistentScope.new(new_scope_id, Some(self.current_scope_id), kind)

        PersistentSymbolTable(
            symbols: self.symbols,
            scopes: self.scopes.set(new_scope_id, new_scope),
            current_scope_id: new_scope_id,
            next_symbol_id: self.next_symbol_id,
            next_scope_id: self.next_scope_id + 1
        )

    fn pop_scope() -> PersistentSymbolTable:
        """Pop current scope, returning new table."""
        val current_scope = self.scopes.get(self.current_scope_id)
        if current_scope.? and current_scope.unwrap().parent_id.?:
            PersistentSymbolTable(
                symbols: self.symbols,
                scopes: self.scopes,
                current_scope_id: current_scope.unwrap().parent_id.unwrap(),
                next_symbol_id: self.next_symbol_id,
                next_scope_id: self.next_scope_id
            )
        else:
            self  # At root, can't pop

    fn current_scope() -> PersistentScope?:
        """Get the current scope."""
        self.scopes.get(self.current_scope_id)

    # --------------------------------------------------------------------------
    # Queries
    # --------------------------------------------------------------------------

    fn symbol_count() -> i64:
        """Number of symbols defined."""
        self.symbols.len()

    fn scope_count() -> i64:
        """Number of scopes created."""
        self.scopes.len()

    fn all_symbols() -> [SymbolEntry]:
        """Get all symbols (for debugging/analysis)."""
        var result: [SymbolEntry] = []
        for (_, entry) in self.symbols.entries():
            result = result.push(entry)
        result

    fn symbols_in_scope(scope_id: i64) -> [SymbolEntry]:
        """Get all symbols defined in a specific scope."""
        var result: [SymbolEntry] = []
        for (_, entry) in self.symbols.entries():
            if entry.scope_id == scope_id:
                result = result.push(entry)
        result

# ============================================================================
# Display
# ============================================================================

impl Display for PersistentSymbolTable:
    fn fmt() -> text:
        "PersistentSymbolTable(symbols={self.symbol_count()}, scopes={self.scope_count()})"

impl Display for SymbolEntry:
    fn fmt() -> text:
        val name_str = resolve(self.name) ?? "<unknown>"
        "Symbol({name_str}, {self.kind})"

impl Display for SymbolKind:
    fn fmt() -> text:
        match self:
            case Function: "function"
            case Method: "method"
            case Variable: "variable"
            case Parameter: "parameter"
            case Field: "field"
            case Class: "class"
            case Struct: "struct"
            case Enum: "enum"
            case EnumVariant: "variant"
            case Trait: "trait"
            case TypeAlias: "type"
            case TypeParam: "type_param"
            case Const: "const"
            case Module: "module"
            case Import: "import"
