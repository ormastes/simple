# Actor Heap Isolation
#
# Per-actor heap management for isolated garbage collection.
# Inspired by Erlang's process heap model.
#
# Benefits:
# - GC only affects individual actor (no global pauses)
# - Pre-sized heaps can avoid GC entirely for short-lived actors
# - Memory isolation prevents actors from affecting each other
# - Predictable latency for soft real-time systems
#
# References:
# - Erlang GC: https://www.erlang.org/doc/apps/erts/garbagecollection.html
# - Erlang Processes: https://www.erlang.org/doc/system/eff_guide_processes.html

# ============================================================================
# Constants
# ============================================================================

# Default heap sizes (in bytes)
val DEFAULT_HEAP_SIZE: i64 = 2048           # 2 KB initial
val DEFAULT_MAX_HEAP_SIZE: i64 = 16777216   # 16 MB max
val MIN_HEAP_SIZE: i64 = 512                # 512 bytes min
val HEAP_GROWTH_FACTOR: f64 = 1.5           # Grow by 50%

# Getter functions for constants (workaround for nested module export limitation)
fn get_default_heap_size() -> i64: DEFAULT_HEAP_SIZE
fn get_default_max_heap_size() -> i64: DEFAULT_MAX_HEAP_SIZE
fn get_min_heap_size() -> i64: MIN_HEAP_SIZE
fn get_heap_growth_factor() -> f64: HEAP_GROWTH_FACTOR

# GC thresholds
val GC_THRESHOLD_PERCENT: i64 = 80          # Trigger GC at 80% full
val PROMOTION_AGE: i64 = 2                  # Survive 2 GCs to become old

# ============================================================================
# Heap Configuration
# ============================================================================

struct HeapConfig:
    """Configuration for actor heap.

    Use this to tune heap behavior for different workloads:
    - Short-lived actors: Large initial size, no GC needed
    - Long-lived actors: Smaller initial, let it grow
    - Memory-constrained: Set max_size limit
    """
    initial_size: i64       # Initial heap size in bytes
    max_size: i64           # Maximum heap size (0 = unlimited)
    gc_enabled: bool        # Enable garbage collection
    generational: bool      # Use generational GC
    pretenure_threshold: i64  # Size above which objects go directly to old gen

fn HeapConfig__default() -> HeapConfig:
    """Default configuration suitable for most actors."""
    HeapConfig(
        initial_size: 2048,           # DEFAULT_HEAP_SIZE (inlined due to nested module bug)
        max_size: 16777216,           # DEFAULT_MAX_HEAP_SIZE (inlined)
        gc_enabled: true,
        generational: true,
        pretenure_threshold: 1024  # 1KB objects go to old gen
    )

fn HeapConfig__no_gc(size: i64) -> HeapConfig:
    """Configuration for short-lived actors that won't need GC.

    Pre-allocate enough memory so GC never runs.
    Actor terminates before heap is full.
    """
    HeapConfig(
        initial_size: size,
        max_size: size,
        gc_enabled: false,
        generational: false,
        pretenure_threshold: 0
    )

fn HeapConfig__small() -> HeapConfig:
    """Small heap for lightweight actors."""
    HeapConfig(
        initial_size: 512,  # MIN_HEAP_SIZE (inlined due to nested module bug)
        max_size: 65536,  # 64 KB max
        gc_enabled: true,
        generational: false,  # Too small for generations
        pretenure_threshold: 0
    )

fn HeapConfig__large() -> HeapConfig:
    """Large heap for data-intensive actors."""
    HeapConfig(
        initial_size: 65536,  # 64 KB initial
        max_size: 0,          # Unlimited
        gc_enabled: true,
        generational: true,
        pretenure_threshold: 4096
    )


impl HeapConfig:
    fn with_initial_size(size: i64) -> HeapConfig:
        """Set initial heap size."""
        HeapConfig(
            initial_size: if size < MIN_HEAP_SIZE: MIN_HEAP_SIZE else: size,
            max_size: self.max_size,
            gc_enabled: self.gc_enabled,
            generational: self.generational,
            pretenure_threshold: self.pretenure_threshold
        )
    fn with_max_size(size: i64) -> HeapConfig:
        """Set maximum heap size (0 = unlimited)."""
        HeapConfig(
            initial_size: self.initial_size,
            max_size: size,
            gc_enabled: self.gc_enabled,
            generational: self.generational,
            pretenure_threshold: self.pretenure_threshold
        )
    fn without_gc() -> HeapConfig:
        """Disable garbage collection."""
        HeapConfig(
            initial_size: self.initial_size,
            max_size: self.max_size,
            gc_enabled: false,
            generational: false,
            pretenure_threshold: self.pretenure_threshold
        )
# ============================================================================
# Heap Statistics
# ============================================================================

struct HeapStats:
    """Statistics about heap usage and GC activity."""
    # Current state
    used_bytes: i64
    allocated_bytes: i64
    object_count: i64

    # GC history
    gc_count: i64
    gc_total_time_us: i64
    gc_last_time_us: i64
    gc_max_time_us: i64

    # Generational stats
    young_gen_size: i64
    old_gen_size: i64
    promotions: i64

    # Peak usage
    peak_used_bytes: i64
    peak_object_count: i64

fn HeapStats__new() -> HeapStats:
    HeapStats(
        used_bytes: 0,
        allocated_bytes: 0,
        object_count: 0,
        gc_count: 0,
        gc_total_time_us: 0,
        gc_last_time_us: 0,
        gc_max_time_us: 0,
        young_gen_size: 0,
        old_gen_size: 0,
        promotions: 0,
        peak_used_bytes: 0,
        peak_object_count: 0
    )


impl HeapStats:
    fn usage_percent() -> i64:
        """Get heap usage as percentage."""
        if self.allocated_bytes == 0:
            0
        else:
            (self.used_bytes * 100) / self.allocated_bytes
    fn avg_gc_time_us() -> i64:
        """Average GC pause time in microseconds."""
        if self.gc_count == 0:
            0
        else:
            self.gc_total_time_us / self.gc_count
    fn should_gc(config: HeapConfig) -> bool:
        """Check if GC should be triggered."""
        if not config.gc_enabled:
            false
        else:
            self.usage_percent() >= GC_THRESHOLD_PERCENT
impl Display for HeapStats:
    fn fmt() -> text:
        val used_kb = self.used_bytes / 1024
        val alloc_kb = self.allocated_bytes / 1024
        "HeapStats(used={used_kb}KB/{alloc_kb}KB, gc_count={self.gc_count}, avg_gc={self.avg_gc_time_us()}us)"
# ============================================================================
# Heap Generation (for generational GC)
# ============================================================================

enum HeapGeneration:
    """Generation for generational garbage collection.

    Young generation: Recently allocated objects (most become garbage quickly)
    Old generation: Long-lived objects (collected less frequently)
    """
    Young
    Old

struct GenerationInfo:
    """Information about a generation."""
    generation: HeapGeneration
    size: i64
    used: i64
    object_count: i64
    gc_count: i64

# ============================================================================
# Actor Heap
# ============================================================================

struct ActorHeap:
    """Per-actor isolated heap.

    Each actor has its own heap that is:
    - Isolated: GC only affects this actor
    - Configurable: Size and behavior can be tuned
    - Monitored: Stats available for debugging

    Example:
        # Short-lived actor with pre-sized heap (no GC)
        val heap = ActorHeap__new(HeapConfig__no_gc(10240))

        # Long-lived actor with generational GC
        val heap = ActorHeap__new(HeapConfig__default())
    """
    config: HeapConfig
    stats: HeapStats

    # Memory regions (represented abstractly - actual impl in runtime)
    young_generation: HeapRegion
    old_generation: HeapRegion?

    # State
    is_collecting: bool
    generation_count: i64

struct HeapRegion:
    """A region of heap memory."""
    base: i64           # Base address (abstract)
    size: i64           # Total size
    used: i64           # Used bytes
    object_count: i64   # Number of objects

fn HeapRegion__new(size: i64) -> HeapRegion:
    HeapRegion(
        base: 0,
        size: size,
        used: 0,
        object_count: 0
    )


impl HeapRegion:
    fn available() -> i64:
        """Available space in region."""
        self.size - self.used
    fn usage_percent() -> i64:
        """Usage as percentage."""
        if self.size == 0: 0 else: (self.used * 100) / self.size
fn ActorHeap__new(config: HeapConfig) -> ActorHeap:
    """Create a new actor heap with given configuration."""
    val young_size = config.initial_size
    val old_gen = if config.generational: Some(HeapRegion__new(config.initial_size / 2)) else: nil

    ActorHeap(
        config: config,
        stats: HeapStats__new(),
        young_generation: HeapRegion__new(young_size),
        old_generation: old_gen,
        is_collecting: false,
        generation_count: 0
    )

fn ActorHeap__with_size(size: i64) -> ActorHeap:
    """Create heap with specific initial size."""
    ActorHeap__new(HeapConfig__default().with_initial_size(size))

fn ActorHeap__no_gc(size: i64) -> ActorHeap:
    """Create heap that won't need GC (for short-lived actors)."""
    ActorHeap__new(HeapConfig__no_gc(size))


impl ActorHeap:
    me allocate(size: i64) -> AllocationResult:
        """Allocate memory from this heap.

        Returns AllocationResult indicating success or failure.
        May trigger GC if heap is full.
        """
        # Check if we need GC
        if self.stats.should_gc(self.config):
            self.collect_garbage()

        # Try to allocate from young generation
        if self.young_generation.available() >= size:
            self.young_generation.used = self.young_generation.used + size
            self.young_generation.object_count = self.young_generation.object_count + 1
            self.update_stats_after_alloc(size)
            return AllocationResult.Success(self.young_generation.base + self.young_generation.used - size)

        # Check if object should go directly to old generation
        if size >= self.config.pretenure_threshold and self.old_generation.?:
            val old = self.old_generation.unwrap()
            if old.available() >= size:
                self.old_generation = Some(HeapRegion(
                    base: old.base,
                    size: old.size,
                    used: old.used + size,
                    object_count: old.object_count + 1
                ))
                self.update_stats_after_alloc(size)
                return AllocationResult.Success(old.base + old.used)

        # Try to grow heap
        if self.can_grow(size):
            self.grow_heap(size)
            return self.allocate(size)  # Retry after growing

        # Out of memory
        AllocationResult.OutOfMemory(size)
    me update_stats_after_alloc(size: i64):
        """Update statistics after successful allocation."""
        self.stats.used_bytes = self.stats.used_bytes + size
        self.stats.object_count = self.stats.object_count + 1

        if self.stats.used_bytes > self.stats.peak_used_bytes:
            self.stats.peak_used_bytes = self.stats.used_bytes
        if self.stats.object_count > self.stats.peak_object_count:
            self.stats.peak_object_count = self.stats.object_count
    fn can_grow(needed: i64) -> bool:
        """Check if heap can grow to accommodate needed bytes."""
        if self.config.max_size == 0:
            true  # Unlimited
        else:
            val current = self.stats.allocated_bytes
            val new_size = ((current as f64) * HEAP_GROWTH_FACTOR) as i64
            new_size <= self.config.max_size
    me grow_heap(needed: i64):
        """Grow the heap to accommodate more allocations."""
        val current = self.young_generation.size
        val growth = ((current as f64) * (HEAP_GROWTH_FACTOR - 1.0)) as i64
        val new_size = current + (if growth > needed: growth else: needed)

        self.young_generation = HeapRegion(
            base: self.young_generation.base,
            size: new_size,
            used: self.young_generation.used,
            object_count: self.young_generation.object_count
        )
        self.stats.allocated_bytes = new_size
    me collect_garbage():
        """Run garbage collection on this heap.

        Only collects garbage for THIS actor - other actors unaffected.
        """
        if not self.config.gc_enabled or self.is_collecting:
            return

        self.is_collecting = true
        val start_time = current_time_us()

        if self.config.generational:
            self.collect_young_generation()
            self.generation_count = self.generation_count + 1

            # Full GC every 10 young GCs
            if self.generation_count % 10 == 0:
                self.collect_old_generation()
        else:
            self.collect_full()

        val gc_time = current_time_us() - start_time
        self.update_gc_stats(gc_time)
        self.is_collecting = false
    me collect_young_generation():
        """Collect young generation only.

        Most objects die young, so this is fast and effective.
        Survivors are promoted to old generation.
        """
        # Simplified simulation - actual impl in runtime
        val survivors = self.young_generation.object_count / 10  # ~10% survive
        val survivor_bytes = self.young_generation.used / 10

        # Promote survivors to old generation
        if self.old_generation.? and survivors > 0:
            val old = self.old_generation.unwrap()
            self.old_generation = Some(HeapRegion(
                base: old.base,
                size: old.size,
                used: old.used + survivor_bytes,
                object_count: old.object_count + survivors
            ))
            self.stats.promotions = self.stats.promotions + survivors

        # Clear young generation
        self.young_generation = HeapRegion(
            base: self.young_generation.base,
            size: self.young_generation.size,
            used: survivor_bytes,  # Keep promoted data temporarily
            object_count: survivors
        )

        self.stats.young_gen_size = self.young_generation.used
    me collect_old_generation():
        """Collect old generation (full GC).

        Only runs occasionally as old generation grows slower.
        """
        if not self.old_generation.?:
            return

        val old = self.old_generation.unwrap()
        val survivors = old.object_count * 9 / 10  # ~90% survive in old gen
        val survivor_bytes = old.used * 9 / 10

        self.old_generation = Some(HeapRegion(
            base: old.base,
            size: old.size,
            used: survivor_bytes,
            object_count: survivors
        ))

        self.stats.old_gen_size = survivor_bytes
    me collect_full():
        """Full heap collection (non-generational)."""
        val survivors = self.young_generation.object_count / 2
        val survivor_bytes = self.young_generation.used / 2

        self.young_generation = HeapRegion(
            base: self.young_generation.base,
            size: self.young_generation.size,
            used: survivor_bytes,
            object_count: survivors
        )

        self.stats.used_bytes = survivor_bytes
        self.stats.object_count = survivors
    me update_gc_stats(gc_time_us: i64):
        """Update GC statistics after collection."""
        self.stats.gc_count = self.stats.gc_count + 1
        self.stats.gc_total_time_us = self.stats.gc_total_time_us + gc_time_us
        self.stats.gc_last_time_us = gc_time_us

        if gc_time_us > self.stats.gc_max_time_us:
            self.stats.gc_max_time_us = gc_time_us
    fn get_stats() -> HeapStats:
        """Get current heap statistics."""
        self.stats
    fn usage_percent() -> i64:
        """Get heap usage as percentage."""
        self.stats.usage_percent()
    fn is_healthy() -> bool:
        """Check if heap is in healthy state."""
        self.usage_percent() < GC_THRESHOLD_PERCENT and self.stats.gc_max_time_us < 10000
    fn should_grow() -> bool:
        """Check if heap should be grown proactively."""
        self.usage_percent() > 60
# ============================================================================
# Allocation Result
# ============================================================================

enum AllocationResult:
    """Result of heap allocation."""
    Success(address: i64)
    OutOfMemory(requested: i64)
    GcRequired

impl AllocationResult:
    fn is_success() -> bool:
        match self:
            case Success(_): true
            case _: false
    fn address() -> i64?:
        match self:
            case Success(addr): Some(addr)
            case _: nil
# ============================================================================
# Helper Functions
# ============================================================================

fn current_time_us() -> i64:
    """Get current time in microseconds (placeholder - use FFI)."""
    # In real impl, this would call rt_time_now_us()
    0

# ============================================================================
# Display
# ============================================================================

impl Display for ActorHeap:
    fn fmt() -> text:
        val used_kb = self.stats.used_bytes / 1024
        val alloc_kb = self.stats.allocated_bytes / 1024
        "ActorHeap({used_kb}KB/{alloc_kb}KB, gc={self.stats.gc_count})"
impl Display for HeapConfig:
    fn fmt() -> text:
        val init_kb = self.initial_size / 1024
        val max_kb = if self.max_size == 0: "unlimited" else: "{self.max_size / 1024}KB"
        "HeapConfig(init={init_kb}KB, max={max_kb}, gc={self.gc_enabled})"

# ============================================================================
# Exports
# ============================================================================

export ActorHeap, HeapConfig, HeapStats, HeapGeneration, AllocationResult, HeapRegion
export ActorHeap__new, HeapStats__new, HeapRegion__new
export HeapConfig__default, HeapConfig__small, HeapConfig__large, HeapConfig__no_gc
export ActorHeap__with_size, ActorHeap__no_gc
export get_default_heap_size, get_default_max_heap_size, get_min_heap_size, get_heap_growth_factor