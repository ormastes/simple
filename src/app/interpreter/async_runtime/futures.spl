# Futures and Async/Await
#
# Async function execution and await handling.

import ..core.{Interpreter, Value, InterpreterError}

export eval_async, eval_await, Future, FutureState

# Future states
enum FutureState:
    Pending
    Ready(Value)
    Failed(InterpreterError)

# A future representing an async computation
struct Future:
    state: FutureState
    body: Option<Box<Expr>>
    result: Option<Value>

impl Future:
    fn new(body: &Expr) -> Future:
        return Future {
            state: FutureState.Pending,
            body: Some(Box.new(body.clone())),
            result: None
        }

    fn is_ready() -> bool:
        match self.state:
            case FutureState.Ready(_): return true
            case _: return false

    fn is_pending() -> bool:
        match self.state:
            case FutureState.Pending: return true
            case _: return false

    fn get_result() -> Option<Value>:
        match self.state:
            case FutureState.Ready(value): return Some(value)
            case _: return None

# Evaluate an async expression - creates a future
fn eval_async(interp: &Interpreter, body: &Expr) -> Result<Value, InterpreterError>:
    value future = Future.new(body)
    return Ok(Value.future(future))

# Await a future - blocks until ready
fn eval_await(interp: &Interpreter, future_expr: &Expr) -> Result<Value, InterpreterError>:
    value future_val = interp.evaluate(future_expr)?

    match future_val.as_future():
        case Some(future):
            return await_future(interp, future)
        case None:
            return Err(InterpreterError.TypeError("cannot await non-future".to_string()))

# Actually await the future
fn await_future(interp: &Interpreter, future: &mut Future) -> Result<Value, InterpreterError>:
    # If already ready, return result
    if value Some(result) = future.get_result():
        return Ok(result)

    # Otherwise, execute the body
    match future.body.take():
        case Some(body):
            match interp.evaluate(&*body):
                case Ok(value):
                    future.state = FutureState.Ready(val.clone())
                    return Ok(value)
                case Err(e):
                    future.state = FutureState.Failed(e.clone())
                    return Err(e)

        case None:
            return Err(InterpreterError.RuntimeError("future already consumed".to_string()))

# Poll a future without blocking
fn poll_future(future: &mut Future) -> FutureState:
    return future.state.clone()

# Create a completed future
fn completed_future(value: Value) -> Future:
    return Future {
        state: FutureState.Ready(value),
        body: None,
        result: None
    }

# Create a failed future
fn failed_future(err: InterpreterError) -> Future:
    return Future {
        state: FutureState.Failed(err),
        body: None,
        result: None
    }

# Join multiple futures
fn join_all(interp: &Interpreter, futures: Array<Future>) -> Result<Array<Value>, InterpreterError>:
    value results: Array<Value> = []

    for mut future in futures:
        value result = await_future(interp, &mut future)?
        results.push(result)

    return Ok(results)

# Select first completed future
fn select_first(interp: &Interpreter, futures: Array<Future>) -> Result<(usize, Value), InterpreterError>:
    # Poll-based implementation for proper async behavior
    loop:
        # First pass: check if any future is already ready
        for (idx, future) in futures.iter().enumerate():
            if future.is_ready():
                value value = future.get_result().unwrap()
                return Ok((idx, value))

        # Second pass: try to make progress on pending futures
        var made_progress = false
        for (idx, mut future) in futures.iter_mut().enumerate():
            if future.is_pending():
                # Try to poll the future
                match poll_and_advance(interp, &mut future):
                    case Ok(true):
                        made_progress = true
                        # Check if it completed
                        if future.is_ready():
                            value value = future.get_result().unwrap()
                            return Ok((idx, value))
                    case Ok(false):
                        pass  # Still pending
                    case Err(e):
                        return Err(e)

        # If no progress was made and none are ready, await the first pending
        if not made_progress:
            for (idx, mut future) in futures.iter_mut().enumerate():
                if future.is_pending():
                    value value = await_future(interp, &mut future)?
                    return Ok((idx, value))

        # If all futures completed but we haven't returned, check again
        # This handles race conditions

# Poll a future and try to advance it
fn poll_and_advance(interp: &Interpreter, future: &mut Future) -> Result<bool, InterpreterError>:
    if not future.is_pending():
        return Ok(false)

    # Try to execute one step of the future body
    match future.body.as_ref():
        case Some(body):
            # For simple futures, we execute the whole body
            # A more sophisticated implementation would use coroutines
            match interp.evaluate(&*body):
                case Ok(value):
                    future.state = FutureState.Ready(value)
                    future.body = None
                    return Ok(true)
                case Err(e):
                    future.state = FutureState.Failed(e)
                    future.body = None
                    return Ok(true)
        case None:
            return Ok(false)
