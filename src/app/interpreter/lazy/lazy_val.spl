# Lazy Values
#
# Scala-style lazy evaluation - values computed on first access.
# Subsequent accesses return cached result without recomputation.
#
# Benefits:
# - Deferred computation: expensive operations only run when needed
# - Memoization: results cached automatically
# - Infinite structures: represent unbounded data
# - Cycle detection: prevents infinite loops in lazy dependencies
#
# Inspired by:
# - Scala lazy value: https://docs.scala-lang.org/tour/lazy-evaluation.html
# - Haskell thunks: https://wiki.haskell.org/Thunk
# - Erlang lazy evaluation patterns
#
# Example:
#     value expensive = Lazy.new(\: compute_heavy())
#     # ... later, only if needed ...
#     value result = expensive.force()  # Computed here, cached
#     value result2 = expensive.force() # Returns cached value

export Lazy, LazyState, LazyError, LazyStats
export lazy, force, is_evaluated, map_lazy, flat_map_lazy

# ============================================================================
# Lazy State
# ============================================================================

enum LazyState<T>:
    """State of a lazy value."""
    Pending         # Not yet evaluated, thunk stored separately
    Evaluating      # Currently being evaluated (cycle detection)
    Ready(value: T) # Evaluated, value cached
    Failed(error: text)  # Evaluation failed

impl LazyState<T>:
    fn is_pending() -> bool:
        match self:
            case Pending: true
            case _: false

    fn is_ready() -> bool:
        match self:
            case Ready(_): true
            case _: false

    fn is_evaluating() -> bool:
        match self:
            case Evaluating: true
            case _: false

    fn is_failed() -> bool:
        match self:
            case Failed(_): true
            case _: false

# ============================================================================
# Lazy Error
# ============================================================================

enum LazyError:
    """Errors that can occur during lazy evaluation."""
    CycleDetected       # Circular dependency in lazy values
    EvaluationFailed(message: text)  # Thunk threw an error
    AlreadyFailed       # Attempted to force a failed lazy value
    InvalidState        # Internal error

impl LazyError:
    fn message() -> text:
        match self:
            case CycleDetected: "Cycle detected in lazy evaluation"
            case EvaluationFailed(msg): "Evaluation failed: {msg}"
            case AlreadyFailed: "Lazy value already failed"
            case InvalidState: "Invalid lazy state"

impl Display for LazyError:
    fn fmt() -> text:
        self.message()

# ============================================================================
# Lazy Statistics
# ============================================================================

struct LazyStats:
    """Statistics for lazy evaluation."""
    total_created: i64
    total_forced: i64
    cache_hits: i64
    cache_misses: i64
    cycles_detected: i64
    evaluation_failures: i64
    total_evaluation_time_ms: i64

impl LazyStats:
    static fn new() -> LazyStats:
        LazyStats(
            total_created: 0,
            total_forced: 0,
            cache_hits: 0,
            cache_misses: 0,
            cycles_detected: 0,
            evaluation_failures: 0,
            total_evaluation_time_ms: 0
        )

    fn hit_rate() -> f64:
        """Cache hit rate (0.0 to 1.0)."""
        value total = self.cache_hits + self.cache_misses
        if total == 0:
            0.0
        else:
            (self.cache_hits as f64) / (total as f64)

    fn avg_evaluation_time_ms() -> f64:
        """Average evaluation time per miss."""
        if self.cache_misses == 0:
            0.0
        else:
            (self.total_evaluation_time_ms as f64) / (self.cache_misses as f64)

impl Display for LazyStats:
    fn fmt() -> text:
        "LazyStats(created={self.total_created}, forced={self.total_forced}, hit_rate={self.hit_rate()})"

# Global statistics
var GLOBAL_LAZY_STATS: LazyStats = LazyStats.new()

fn get_lazy_stats() -> LazyStats:
    """Get global lazy evaluation statistics."""
    GLOBAL_LAZY_STATS

fn reset_lazy_stats():
    """Reset global statistics."""
    GLOBAL_LAZY_STATS = LazyStats.new()

# ============================================================================
# Lazy Value
# ============================================================================

struct Lazy<T>:
    """A lazily evaluated value.

    The value is not computed until first accessed via force().
    After evaluation, the result is cached for subsequent accesses.

    Thread safety:
    - In single-threaded context: safe
    - In multi-threaded context: would need synchronization (not implemented)

    Example:
        # Create lazy value
        value lazy_sum = Lazy.new(\: expensive_sum(1, 1000000))

        # Value not computed yet
        assert not lazy_sum.is_evaluated()

        # Force evaluation
        value result = lazy_sum.force()  # Computed here

        # Cached for subsequent access
        value result2 = lazy_sum.force()  # Returns cached value
        assert lazy_sum.is_evaluated()
    """
    id: i64
    state: LazyState<T>
    thunk: fn() -> T       # The computation to perform
    created_at: i64
    evaluated_at: i64?

impl Lazy<T>:
    static fn new(thunk: fn() -> T) -> Lazy<T>:
        """Create a new lazy value with the given thunk."""
        GLOBAL_LAZY_STATS.total_created = GLOBAL_LAZY_STATS.total_created + 1

        Lazy(
            id: GLOBAL_LAZY_STATS.total_created,
            state: LazyState.Pending,
            thunk: thunk,
            created_at: current_time_ms(),
            evaluated_at: None
        )

    static fn of(value: T) -> Lazy<T>:
        """Create an already-evaluated lazy value.

        Useful for wrapping constants or pre-computed values.
        """
        GLOBAL_LAZY_STATS.total_created = GLOBAL_LAZY_STATS.total_created + 1

        Lazy(
            id: GLOBAL_LAZY_STATS.total_created,
            state: LazyState.Ready(value),
            thunk: \: value,  # Dummy thunk
            created_at: current_time_ms(),
            evaluated_at: Some(current_time_ms())
        )

    static fn failed(error: text) -> Lazy<T>:
        """Create a lazy value that always fails."""
        GLOBAL_LAZY_STATS.total_created = GLOBAL_LAZY_STATS.total_created + 1

        Lazy(
            id: GLOBAL_LAZY_STATS.total_created,
            state: LazyState.Failed(error),
            thunk: \: panic(error),
            created_at: current_time_ms(),
            evaluated_at: None
        )

    # --------------------------------------------------------------------------
    # Evaluation
    # --------------------------------------------------------------------------

    me force() -> Result<T, LazyError>:
        """Force evaluation of the lazy value.

        Returns the cached value if already evaluated.
        Detects cycles if the value depends on itself.
        """
        GLOBAL_LAZY_STATS.total_forced = GLOBAL_LAZY_STATS.total_forced + 1

        match self.state:
            case Ready(value):
                # Already evaluated - cache hit
                GLOBAL_LAZY_STATS.cache_hits = GLOBAL_LAZY_STATS.cache_hits + 1
                Ok(value)

            case Evaluating:
                # Cycle detected!
                GLOBAL_LAZY_STATS.cycles_detected = GLOBAL_LAZY_STATS.cycles_detected + 1
                self.state = LazyState.Failed("Cycle detected")
                Err(LazyError.CycleDetected)

            case Failed(msg):
                # Previous evaluation failed
                Err(LazyError.AlreadyFailed)

            case Pending:
                # Need to evaluate - cache miss
                GLOBAL_LAZY_STATS.cache_misses = GLOBAL_LAZY_STATS.cache_misses + 1

                # Mark as evaluating (for cycle detection)
                self.state = LazyState.Evaluating
                value start_time = current_time_ms()

                # Try to evaluate
                # In a real impl, this would catch exceptions
                value result = self.thunk()

                value eval_time = current_time_ms() - start_time
                GLOBAL_LAZY_STATS.total_evaluation_time_ms =
                    GLOBAL_LAZY_STATS.total_evaluation_time_ms + eval_time

                # Cache the result
                self.state = LazyState.Ready(result)
                self.evaluated_at = Some(current_time_ms())

                Ok(result)

    me force_or_default(default: T) -> T:
        """Force evaluation, returning default on error."""
        match self.force():
            case Ok(value): value
            case Err(_): default

    me force_unchecked() -> T:
        """Force evaluation, panicking on error."""
        match self.force():
            case Ok(value): value
            case Err(e): panic(e.message())

    # --------------------------------------------------------------------------
    # Queries
    # --------------------------------------------------------------------------

    fn is_evaluated() -> bool:
        """Check if the value has been evaluated."""
        self.state.is_ready()

    fn is_pending() -> bool:
        """Check if the value is pending evaluation."""
        self.state.is_pending()

    fn is_failed() -> bool:
        """Check if evaluation failed."""
        self.state.is_failed()

    fn get() -> T?:
        """Get the value if already evaluated, without forcing."""
        match self.state:
            case Ready(value): Some(value)
            case _: None

    fn age_ms() -> i64:
        """Time since creation."""
        current_time_ms() - self.created_at

    # --------------------------------------------------------------------------
    # Transformations (lazy)
    # --------------------------------------------------------------------------

    fn map<U>(f: fn(T) -> U) -> Lazy<U>:
        """Transform the lazy value, lazily.

        The transformation is not applied until the result is forced.
        """
        value self_ref = self
        Lazy.new(\:
            value value = self_ref.force_unchecked()
            f(value)
        )

    fn flat_map<U>(f: fn(T) -> Lazy<U>) -> Lazy<U>:
        """Chain lazy computations.

        The inner lazy value is also forced lazily.
        """
        value self_ref = self
        Lazy.new(\:
            value value = self_ref.force_unchecked()
            value inner = f(value)
            inner.force_unchecked()
        )

    fn zip<U>(other: Lazy<U>) -> Lazy<(T, U)>:
        """Combine two lazy values into a lazy pair."""
        value self_ref = self
        Lazy.new(\:
            value a = self_ref.force_unchecked()
            value b = other.force_unchecked()
            (a, b)
        )

    fn filter(predicate: fn(T) -> bool) -> Lazy<T?>:
        """Filter the lazy value."""
        value self_ref = self
        Lazy.new(\:
            value value = self_ref.force_unchecked()
            if predicate(value):
                Some(value)
            else:
                None
        )

impl Display for Lazy<T>:
    fn fmt() -> text:
        match self.state:
            case Pending: "Lazy(<pending>)"
            case Evaluating: "Lazy(<evaluating>)"
            case Ready(_): "Lazy(<ready>)"
            case Failed(e): "Lazy(<failed: {e}>)"

# ============================================================================
# Convenience Functions
# ============================================================================

fn lazy<T>(thunk: fn() -> T) -> Lazy<T>:
    """Create a lazy value (shorthand for Lazy.new)."""
    Lazy.new(thunk)

fn force<T>(lazy_val: Lazy<T>) -> Result<T, LazyError>:
    """Force a lazy value (shorthand)."""
    var l = lazy_val
    l.force()

fn is_evaluated<T>(lazy_val: Lazy<T>) -> bool:
    """Check if lazy value is evaluated."""
    lazy_val.is_evaluated()

fn map_lazy<T, U>(lazy_val: Lazy<T>, f: fn(T) -> U) -> Lazy<U>:
    """Map over a lazy value."""
    lazy_val.map(f)

fn flat_map_lazy<T, U>(lazy_val: Lazy<T>, f: fn(T) -> Lazy<U>) -> Lazy<U>:
    """Flat map over a lazy value."""
    lazy_val.flat_map(f)

# ============================================================================
# Memoization
# ============================================================================

struct Memo<K, V>:
    """Memoization cache for functions.

    Caches results of function calls by argument.
    Useful for expensive pure functions.

    Example:
        value fib_memo = Memo<i64, i64>.new()

        fn fib(n: i64) -> i64:
            fib_memo.get_or_compute(n, \:
                if n <= 1: n
                else: fib(n - 1) + fib(n - 2)
            )
    """
    cache: Dict<K, Lazy<V>>
    stats: MemoStats

impl Memo<K, V>:
    static fn new() -> Memo<K, V>:
        Memo(
            cache: {},
            stats: MemoStats.new()
        )

    me get_or_compute(key: K, compute: fn() -> V) -> V:
        """Get cached value or compute and cache it."""
        self.stats.total_lookups = self.stats.total_lookups + 1

        value existing = self.cache.get(key)
        if existing.?:
            self.stats.cache_hits = self.stats.cache_hits + 1
            var lazy_val = existing.unwrap()
            lazy_val.force_unchecked()
        else:
            self.stats.cache_misses = self.stats.cache_misses + 1
            value lazy_val = Lazy.new(compute)
            self.cache[key] = lazy_val
            var lv = lazy_val
            lv.force_unchecked()

    fn get(key: K) -> V?:
        """Get cached value if present."""
        value existing = self.cache.get(key)
        if existing.?:
            existing.unwrap().get()
        else:
            None

    fn contains(key: K) -> bool:
        """Check if key is in cache."""
        self.cache.get(key).?

    me clear():
        """Clear the cache."""
        self.cache = {}
        self.stats.clears = self.stats.clears + 1

    fn size() -> i64:
        """Number of cached entries."""
        self.cache.len()

    fn get_stats() -> MemoStats:
        """Get memoization statistics."""
        self.stats

struct MemoStats:
    """Statistics for memoization."""
    total_lookups: i64
    cache_hits: i64
    cache_misses: i64
    clears: i64

impl MemoStats:
    static fn new() -> MemoStats:
        MemoStats(
            total_lookups: 0,
            cache_hits: 0,
            cache_misses: 0,
            clears: 0
        )

    fn hit_rate() -> f64:
        if self.total_lookups == 0:
            0.0
        else:
            (self.cache_hits as f64) / (self.total_lookups as f64)

# ============================================================================
# Helper Functions
# ============================================================================

fn current_time_ms() -> i64:
    """Get current time in milliseconds (placeholder)."""
    0
