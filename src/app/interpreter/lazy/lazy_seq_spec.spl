# Lazy Sequence Tests
#
# Tests for lazy/infinite sequences.

from lazy_seq import {
    LazySeq,
    LazySeqNode,
    SeqIterator,
    naturals,
    naturals_from,
    fibonacci,
    primes,
    repeat,
    cycle,
    range_lazy,
    range_step
}

describe "LazySeq - Creation":
    it "creates empty sequence":
        val seq = LazySeq<i64>.empty()

        assert seq.is_empty()

    it "creates single element":
        val seq = LazySeq.single(42)

        assert not seq.is_empty()
        assert seq.head() == Some(42)
        assert seq.tail().is_empty()

    it "creates from array":
        val seq = LazySeq.from_array([1, 2, 3])

        assert seq.head() == Some(1)
        assert seq.tail().head() == Some(2)
        assert seq.tail().tail().head() == Some(3)

    it "creates with cons":
        val tail = LazySeq.single(2)
        val seq = LazySeq.cons(1, tail)

        assert seq.head() == Some(1)
        assert seq.tail().head() == Some(2)

    it "creates with iterate":
        val seq = LazySeq.iterate(1, \x: x * 2)

        assert seq.head() == Some(1)
        assert seq.tail().head() == Some(2)
        assert seq.tail().tail().head() == Some(4)

    it "creates with unfold":
        val seq = LazySeq.unfold(0, \n:
            if n < 3:
                Some((n * 10, n + 1))
            else:
                None
        )

        val arr = seq.to_array()
        assert arr == [0, 10, 20]

    it "creates with generate":
        val seq = LazySeq.generate(\i:
            if i < 3:
                Some(i * i)
            else:
                None
        )

        val arr = seq.to_array()
        assert arr == [0, 1, 4]

    it "creates repeat":
        val seq = LazySeq.repeat_val(5)

        assert seq.take(4).to_array() == [5, 5, 5, 5]

    it "creates repeat_n":
        val seq = LazySeq.repeat_n(7, 3)

        assert seq.to_array() == [7, 7, 7]

describe "LazySeq - Basic Operations":
    it "gets head":
        val seq = LazySeq.from_array([10, 20, 30])

        assert seq.head() == Some(10)

    it "returns None for empty head":
        val seq = LazySeq<i64>.empty()

        assert seq.head() == None

    it "gets tail":
        val seq = LazySeq.from_array([1, 2, 3])
        val tail = seq.tail()

        assert tail.head() == Some(2)

    it "gets head_tail together":
        val seq = LazySeq.from_array([1, 2, 3])

        match seq.head_tail():
            case Some((h, t)):
                assert h == 1
                assert t.head() == Some(2)
            case None:
                assert false

    it "gets nth element":
        val seq = LazySeq.from_array([10, 20, 30, 40, 50])

        assert seq.nth(0) == Some(10)
        assert seq.nth(2) == Some(30)
        assert seq.nth(4) == Some(50)
        assert seq.nth(10) == None

describe "LazySeq - Transformations":
    it "maps elements":
        val seq = LazySeq.from_array([1, 2, 3])
        val doubled = seq.map(\x: x * 2)

        assert doubled.to_array() == [2, 4, 6]

    it "filters elements":
        val seq = LazySeq.from_array([1, 2, 3, 4, 5, 6])
        val evens = seq.filter(\x: x % 2 == 0)

        assert evens.to_array() == [2, 4, 6]

    it "flat_maps elements":
        val seq = LazySeq.from_array([1, 2, 3])
        val expanded = seq.flat_map(\x: LazySeq.from_array([x, x * 10]))

        assert expanded.to_array() == [1, 10, 2, 20, 3, 30]

    it "takes first n elements":
        val seq = naturals()
        val first5 = seq.take(5)

        assert first5.to_array() == [0, 1, 2, 3, 4]

    it "drops first n elements":
        val seq = LazySeq.from_array([1, 2, 3, 4, 5])
        val dropped = seq.drop(2)

        assert dropped.to_array() == [3, 4, 5]

    it "takes while predicate":
        val seq = LazySeq.from_array([1, 2, 3, 10, 4, 5])
        val small = seq.take_while(\x: x < 5)

        assert small.to_array() == [1, 2, 3]

    it "drops while predicate":
        val seq = LazySeq.from_array([1, 2, 3, 10, 4, 5])
        val rest = seq.drop_while(\x: x < 5)

        assert rest.to_array() == [10, 4, 5]

    it "zips two sequences":
        val seq1 = LazySeq.from_array([1, 2, 3])
        val seq2 = LazySeq.from_array(["a", "b", "c"])
        val zipped = seq1.zip(seq2)

        assert zipped.to_array() == [(1, "a"), (2, "b"), (3, "c")]

    it "zips with shorter sequence":
        val seq1 = LazySeq.from_array([1, 2, 3, 4, 5])
        val seq2 = LazySeq.from_array(["a", "b"])
        val zipped = seq1.zip(seq2)

        assert zipped.to_array() == [(1, "a"), (2, "b")]

    it "zips with index":
        val seq = LazySeq.from_array(["a", "b", "c"])
        val indexed = seq.zip_with_index()

        val arr = indexed.take(3).to_array()
        assert arr == [("a", 0), ("b", 1), ("c", 2)]

    it "concatenates sequences":
        val seq1 = LazySeq.from_array([1, 2])
        val seq2 = LazySeq.from_array([3, 4])
        val concat = seq1.concat(seq2)

        assert concat.to_array() == [1, 2, 3, 4]

    it "interleaves sequences":
        val seq1 = LazySeq.from_array([1, 3, 5])
        val seq2 = LazySeq.from_array([2, 4, 6])
        val interleaved = seq1.interleave(seq2)

        assert interleaved.to_array() == [1, 2, 3, 4, 5, 6]

describe "LazySeq - Terminal Operations":
    it "converts to array":
        val seq = LazySeq.from_array([1, 2, 3])

        assert seq.to_array() == [1, 2, 3]

    it "converts to array with limit":
        val seq = naturals()

        assert seq.to_array_n(5) == [0, 1, 2, 3, 4]

    it "folds elements":
        val seq = LazySeq.from_array([1, 2, 3, 4])
        val sum = seq.fold(0, \acc, x: acc + x)

        assert sum == 10

    it "reduces elements":
        val seq = LazySeq.from_array([1, 2, 3, 4])
        val product = seq.reduce(\a, b: a * b)

        assert product == Some(24)

    it "reduces empty sequence":
        val seq = LazySeq<i64>.empty()
        val result = seq.reduce(\a, b: a + b)

        assert result == None

    it "finds element":
        val seq = LazySeq.from_array([1, 5, 10, 15, 20])
        val found = seq.find(\x: x > 8)

        assert found == Some(10)

    it "finds nothing":
        val seq = LazySeq.from_array([1, 2, 3])
        val found = seq.find(\x: x > 100)

        assert found == None

    it "checks exists":
        val seq = LazySeq.from_array([1, 2, 3, 4, 5])

        assert seq.exists(\x: x == 3)
        assert not seq.exists(\x: x == 10)

    it "checks forall":
        val seq = LazySeq.from_array([2, 4, 6, 8])

        assert seq.forall(\x: x % 2 == 0)
        assert not seq.forall(\x: x < 5)

    it "counts elements":
        val seq = LazySeq.from_array([1, 2, 3, 4, 5])

        assert seq.count() == 5

    it "checks contains":
        val seq = LazySeq.from_array([1, 2, 3])

        assert seq.contains(2)
        assert not seq.contains(10)

describe "LazySeq - Laziness":
    it "doesn't evaluate until needed":
        var evaluated = false
        val seq = LazySeq.iterate(0, \x:
            evaluated = true
            x + 1
        )

        assert not evaluated  # Just creating doesn't evaluate

        seq.head()  # Force first element
        # First element is seed, so still no evaluation needed

    it "evaluates incrementally":
        var count = 0
        val seq = LazySeq.generate(\i:
            count = count + 1
            if i < 100:
                Some(i)
            else:
                None
        )

        # Take only 3
        val first3 = seq.take(3).to_array()

        assert first3 == [0, 1, 2]
        assert count == 4  # One extra to check for end

describe "Standard Sequences - Naturals":
    it "generates natural numbers":
        val first10 = naturals().take(10).to_array()

        assert first10 == [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]

    it "generates from starting point":
        val first5 = naturals_from(100).take(5).to_array()

        assert first5 == [100, 101, 102, 103, 104]

describe "Standard Sequences - Fibonacci":
    it "generates fibonacci numbers":
        val first10 = fibonacci().take(10).to_array()

        assert first10 == [0, 1, 1, 2, 3, 5, 8, 13, 21, 34]

describe "Standard Sequences - Primes":
    it "generates prime numbers":
        val first10 = primes().take(10).to_array()

        assert first10 == [2, 3, 5, 7, 11, 13, 17, 19, 23, 29]

describe "Standard Sequences - Repeat":
    it "repeats value infinitely":
        val first5 = repeat(42).take(5).to_array()

        assert first5 == [42, 42, 42, 42, 42]

describe "Standard Sequences - Cycle":
    it "cycles through array":
        val first8 = cycle([1, 2, 3]).take(8).to_array()

        assert first8 == [1, 2, 3, 1, 2, 3, 1, 2]

    it "handles empty array":
        val seq = cycle([])

        assert seq.is_empty()

describe "Standard Sequences - Range":
    it "creates lazy range":
        val seq = range_lazy(0, 5)

        assert seq.to_array() == [0, 1, 2, 3, 4]

    it "creates empty range":
        val seq = range_lazy(5, 5)

        assert seq.is_empty()

    it "creates range with step":
        val seq = range_step(0, 10, 2)

        assert seq.to_array() == [0, 2, 4, 6, 8]

    it "creates reverse range":
        val seq = range_step(10, 0, -2)

        assert seq.to_array() == [10, 8, 6, 4, 2]

describe "SeqIterator":
    it "iterates over sequence":
        val seq = LazySeq.from_array([1, 2, 3])
        var iter = SeqIterator.new(seq)

        assert iter.has_next()
        assert iter.next() == Some(1)
        assert iter.next() == Some(2)
        assert iter.next() == Some(3)
        assert not iter.has_next()
        assert iter.next() == None

describe "LazySeq - Complex Examples":
    it "finds first 5 primes greater than 100":
        val result = primes()
            .filter(\p: p > 100)
            .take(5)
            .to_array()

        assert result == [101, 103, 107, 109, 113]

    it "computes sum of first 100 naturals":
        val sum = naturals()
            .take(101)  # 0 to 100
            .fold(0, \acc, x: acc + x)

        assert sum == 5050

    it "finds first fibonacci > 1000":
        val result = fibonacci()
            .find(\x: x > 1000)

        assert result == Some(1597)

    it "generates pairs":
        val pairs = naturals()
            .take(3)
            .flat_map(\x:
                naturals().take(3).map(\y: (x, y))
            )
            .to_array()

        assert pairs == [
            (0, 0), (0, 1), (0, 2),
            (1, 0), (1, 1), (1, 2),
            (2, 0), (2, 1), (2, 2)
        ]

    it "composes multiple transformations":
        val result = naturals()
            .map(\x: x * x)       # Squares
            .filter(\x: x % 2 == 0)  # Even squares
            .take(5)
            .to_array()

        assert result == [0, 4, 16, 36, 64]
