# Lazy Evaluation
#
# Scala-style lazy evaluation and infinite sequences.
#
# Key components:
# - lazy_val: Lazy values with memoization
# - lazy_seq: Lazy/infinite sequences
#
# Benefits:
# - Deferred computation: only compute when needed
# - Memoization: cache results automatically
# - Infinite structures: represent unbounded data
# - Memory efficient: only computed elements stored
#
# Examples:
#     # Lazy value
#     val expensive = Lazy.new(\: heavy_computation())
#     val result = expensive.force()  # Computed here, cached
#
#     # Infinite sequence
#     val evens = naturals().filter(\x: x % 2 == 0).take(10).to_array()
#     # [0, 2, 4, 6, 8, 10, 12, 14, 16, 18]

from lazy_val import {
    Lazy,
    LazyState,
    LazyError,
    LazyStats,
    Memo,
    MemoStats,
    lazy,
    force,
    is_evaluated,
    map_lazy,
    flat_map_lazy,
    get_lazy_stats,
    reset_lazy_stats
}

from lazy_seq import {
    LazySeq,
    LazySeqNode,
    SeqIterator,
    naturals,
    naturals_from,
    fibonacci,
    primes,
    repeat,
    cycle,
    range_lazy,
    range_step
}

# Lazy values
export Lazy, LazyState, LazyError, LazyStats
export Memo, MemoStats
export lazy, force, is_evaluated, map_lazy, flat_map_lazy
export get_lazy_stats, reset_lazy_stats

# Lazy sequences
export LazySeq, LazySeqNode, SeqIterator
export naturals, naturals_from, fibonacci, primes
export repeat, cycle, range_lazy, range_step
