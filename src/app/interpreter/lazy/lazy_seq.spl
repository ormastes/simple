# Lazy Sequences
#
# Infinite and lazy sequences that compute elements on demand.
# Inspired by Scala's LazyList and Haskell's lazy lists.
#
# Benefits:
# - Represent infinite sequences (naturals, fibonacci, etc.)
# - Memory efficient: only computed elements are stored
# - Composable: map, filter, take, etc. are all lazy
# - Short-circuit evaluation: stop as soon as result is found
#
# References:
# - Scala LazyList: https://docs.scala-lang.org/overviews/collections-2.13/concrete-immutable-collection-classes.html
# - Haskell lists: https://wiki.haskell.org/Lazy_evaluation
#
# Example:
#     # Infinite sequence of natural numbers
#     value naturals = LazySeq.iterate(0, \x: x + 1)
#
#     # Take first 10 even numbers
#     value first_evens = naturals
#         .filter(\x: x % 2 == 0)
#         .take(10)
#         .to_array()
#
#     # [0, 2, 4, 6, 8, 10, 12, 14, 16, 18]

from lazy_val import {Lazy, LazyState, lazy}

export LazySeq, LazySeqNode, SeqIterator
export naturals, fibonacci, repeat, cycle, range_lazy

# ============================================================================
# Lazy Sequence Node
# ============================================================================

enum LazySeqNode<T>:
    """A node in a lazy sequence."""
    Empty                           # End of sequence
    Cons(head: T, tail: Lazy<LazySeqNode<T>>)  # Element + lazy tail

impl LazySeqNode<T>:
    fn is_empty() -> bool:
        match self:
            case Empty: true
            case _: false

    fn head() -> T?:
        match self:
            case Cons(h, _): Some(h)
            case Empty: None

    fn tail() -> LazySeqNode<T>?:
        match self:
            case Cons(_, t):
                var tail_lazy = t
                match tail_lazy.force():
                    case Ok(node): Some(node)
                    case Err(_): None
            case Empty: None

# ============================================================================
# Lazy Sequence
# ============================================================================

struct LazySeq<T>:
    """A lazy sequence that computes elements on demand.

    Elements are only computed when accessed. Previous elements
    are cached (memoized) for subsequent access.

    Can represent infinite sequences:
        val naturals = LazySeq.iterate(0, \x: x + 1)
        # Infinite sequence: 0, 1, 2, 3, ...

    All operations (map, filter, etc.) are lazy:
        val evens = naturals.filter(\x: x % 2 == 0)
        # Still infinite, still lazy

    Force evaluation with take() or to_array():
        val first_10 = evens.take(10).to_array()
        # [0, 2, 4, 6, 8, 10, 12, 14, 16, 18]
    """
    node: Lazy<LazySeqNode<T>>

impl LazySeq<T>:
    # --------------------------------------------------------------------------
    # Constructors
    # --------------------------------------------------------------------------

    static fn empty() -> LazySeq<T>:
        """Create an empty lazy sequence."""
        LazySeq(node: Lazy.of(LazySeqNode.Empty))

    static fn single(value: T) -> LazySeq<T>:
        """Create a lazy sequence with a single element."""
        LazySeq(node: Lazy.of(
            LazySeqNode.Cons(value, Lazy.of(LazySeqNode.Empty))
        ))

    static fn cons(head: T, tail: LazySeq<T>) -> LazySeq<T>:
        """Prepend an element to a lazy sequence."""
        LazySeq(node: Lazy.of(
            LazySeqNode.Cons(head, tail.node)
        ))

    static fn from_array(arr: [T]) -> LazySeq<T>:
        """Create a lazy sequence from an array."""
        if arr.len() == 0:
            LazySeq.empty()
        else:
            LazySeq.from_array_helper(arr, 0)

    static fn from_array_helper(arr: [T], index: i64) -> LazySeq<T>:
        """Helper for from_array."""
        if index >= arr.len():
            LazySeq.empty()
        else:
            val head = arr[index]
            val tail = lazy(\: LazySeq.from_array_helper(arr, index + 1).force_node())
            LazySeq(node: Lazy.of(LazySeqNode.Cons(head, tail)))

    static fn iterate(seed: T, f: fn(T) -> T) -> LazySeq<T>:
        """Create infinite sequence by repeatedly applying function.

        iterate(0, \x: x + 1) produces: 0, 1, 2, 3, ...
        iterate(1, \x: x * 2) produces: 1, 2, 4, 8, ...
        """
        val tail = lazy(\: LazySeq.iterate(f(seed), f).force_node())
        LazySeq(node: Lazy.of(LazySeqNode.Cons(seed, tail)))

    static fn unfold<S>(seed: S, f: fn(S) -> (T, S)?) -> LazySeq<T>:
        """Create sequence by unfolding a state.

        The function returns (element, new_state) or None to end.
        """
        val result = f(seed)
        match result:
            case Some((value, new_state)):
                val tail = lazy(\: LazySeq.unfold(new_state, f).force_node())
                LazySeq(node: Lazy.of(LazySeqNode.Cons(value, tail)))
            case None:
                LazySeq.empty()

    static fn generate(f: fn(i64) -> T?) -> LazySeq<T>:
        """Create sequence from index function.

        Returns None to end the sequence.
        """
        LazySeq.generate_helper(f, 0)

    static fn generate_helper(f: fn(i64) -> T?, index: i64) -> LazySeq<T>:
        """Helper for generate."""
        val result = f(index)
        match result:
            case Some(value):
                val tail = lazy(\: LazySeq.generate_helper(f, index + 1).force_node())
                LazySeq(node: Lazy.of(LazySeqNode.Cons(value, tail)))
            case None:
                LazySeq.empty()

    static fn repeat_val(value: T) -> LazySeq<T>:
        """Create infinite sequence of the same value."""
        val tail = lazy(\: LazySeq.repeat_val(value).force_node())
        LazySeq(node: Lazy.of(LazySeqNode.Cons(value, tail)))

    static fn repeat_n(value: T, n: i64) -> LazySeq<T>:
        """Create sequence of value repeated n times."""
        if n <= 0:
            LazySeq.empty()
        else:
            val tail = lazy(\: LazySeq.repeat_n(value, n - 1).force_node())
            LazySeq(node: Lazy.of(LazySeqNode.Cons(value, tail)))

    # --------------------------------------------------------------------------
    # Core operations
    # --------------------------------------------------------------------------

    fn force_node() -> LazySeqNode<T>:
        """Force evaluation of the head node."""
        var n = self.node
        match n.force():
            case Ok(node): node
            case Err(_): LazySeqNode.Empty

    fn is_empty() -> bool:
        """Check if sequence is empty (forces head)."""
        self.force_node().is_empty()

    fn head() -> T?:
        """Get first element (forces head)."""
        self.force_node().head()

    fn tail() -> LazySeq<T>:
        """Get sequence without first element."""
        val node = self.force_node()
        match node:
            case Cons(_, t):
                LazySeq(node: t)
            case Empty:
                LazySeq.empty()

    fn head_tail() -> (T, LazySeq<T>)?:
        """Get head and tail together."""
        val node = self.force_node()
        match node:
            case Cons(h, t):
                Some((h, LazySeq(node: t)))
            case Empty:
                None

    # --------------------------------------------------------------------------
    # Transformations (all lazy)
    # --------------------------------------------------------------------------

    fn map<U>(f: fn(T) -> U) -> LazySeq<U>:
        """Transform each element lazily."""
        val self_ref = self
        val node = lazy(\:
            val n = self_ref.force_node()
            match n:
                case Cons(head, tail):
                    val new_tail = lazy(\: LazySeq(node: tail).map(f).force_node())
                    LazySeqNode.Cons(f(head), new_tail)
                case Empty:
                    LazySeqNode.Empty
        )
        LazySeq(node: node)

    fn filter(predicate: fn(T) -> bool) -> LazySeq<T>:
        """Keep elements matching predicate lazily."""
        val self_ref = self
        val node = lazy(\:
            self_ref.filter_helper(predicate)
        )
        LazySeq(node: node)

    fn filter_helper(predicate: fn(T) -> bool) -> LazySeqNode<T>:
        """Helper for filter."""
        val n = self.force_node()
        match n:
            case Cons(head, tail):
                if predicate(head):
                    val new_tail = lazy(\: LazySeq(node: tail).filter(predicate).force_node())
                    LazySeqNode.Cons(head, new_tail)
                else:
                    LazySeq(node: tail).filter_helper(predicate)
            case Empty:
                LazySeqNode.Empty

    fn flat_map<U>(f: fn(T) -> LazySeq<U>) -> LazySeq<U>:
        """Map and flatten lazily."""
        val self_ref = self
        val node = lazy(\:
            val n = self_ref.force_node()
            match n:
                case Cons(head, tail):
                    val inner = f(head)
                    inner.concat(LazySeq(node: tail).flat_map(f)).force_node()
                case Empty:
                    LazySeqNode.Empty
        )
        LazySeq(node: node)

    fn take(n: i64) -> LazySeq<T>:
        """Take first n elements lazily."""
        if n <= 0:
            return LazySeq.empty()

        val self_ref = self
        val node = lazy(\:
            val nd = self_ref.force_node()
            match nd:
                case Cons(head, tail):
                    val new_tail = lazy(\: LazySeq(node: tail).take(n - 1).force_node())
                    LazySeqNode.Cons(head, new_tail)
                case Empty:
                    LazySeqNode.Empty
        )
        LazySeq(node: node)

    fn drop(n: i64) -> LazySeq<T>:
        """Drop first n elements lazily."""
        if n <= 0:
            return self

        val self_ref = self
        val node = lazy(\:
            var current = self_ref
            var remaining = n
            while remaining > 0 and not current.is_empty():
                current = current.tail()
                remaining = remaining - 1
            current.force_node()
        )
        LazySeq(node: node)

    fn take_while(predicate: fn(T) -> bool) -> LazySeq<T>:
        """Take elements while predicate is true."""
        val self_ref = self
        val node = lazy(\:
            val n = self_ref.force_node()
            match n:
                case Cons(head, tail):
                    if predicate(head):
                        val new_tail = lazy(\: LazySeq(node: tail).take_while(predicate).force_node())
                        LazySeqNode.Cons(head, new_tail)
                    else:
                        LazySeqNode.Empty
                case Empty:
                    LazySeqNode.Empty
        )
        LazySeq(node: node)

    fn drop_while(predicate: fn(T) -> bool) -> LazySeq<T>:
        """Drop elements while predicate is true."""
        val self_ref = self
        val node = lazy(\:
            var current = self_ref
            while not current.is_empty():
                val h = current.head()
                if h.? and predicate(h.unwrap()):
                    current = current.tail()
                else:
                    break
            current.force_node()
        )
        LazySeq(node: node)

    fn zip<U>(other: LazySeq<U>) -> LazySeq<(T, U)>:
        """Zip two sequences lazily."""
        val self_ref = self
        val node = lazy(\:
            val n1 = self_ref.force_node()
            val n2 = other.force_node()
            match (n1, n2):
                case (Cons(h1, t1), Cons(h2, t2)):
                    val new_tail = lazy(\:
                        LazySeq(node: t1).zip(LazySeq(node: t2)).force_node()
                    )
                    LazySeqNode.Cons((h1, h2), new_tail)
                case _:
                    LazySeqNode.Empty
        )
        LazySeq(node: node)

    fn zip_with_index() -> LazySeq<(T, i64)>:
        """Zip with indices lazily."""
        self.zip(naturals())

    fn concat(other: LazySeq<T>) -> LazySeq<T>:
        """Concatenate two sequences lazily."""
        val self_ref = self
        val node = lazy(\:
            val n = self_ref.force_node()
            match n:
                case Cons(head, tail):
                    val new_tail = lazy(\: LazySeq(node: tail).concat(other).force_node())
                    LazySeqNode.Cons(head, new_tail)
                case Empty:
                    other.force_node()
        )
        LazySeq(node: node)

    fn interleave(other: LazySeq<T>) -> LazySeq<T>:
        """Interleave two sequences lazily."""
        val self_ref = self
        val node = lazy(\:
            val n = self_ref.force_node()
            match n:
                case Cons(head, tail):
                    val new_tail = lazy(\: other.interleave(LazySeq(node: tail)).force_node())
                    LazySeqNode.Cons(head, new_tail)
                case Empty:
                    other.force_node()
        )
        LazySeq(node: node)

    # --------------------------------------------------------------------------
    # Terminal operations (force evaluation)
    # --------------------------------------------------------------------------

    fn to_array() -> [T]:
        """Convert to array (forces all elements).

        WARNING: Will not terminate on infinite sequences!
        Use take() first to limit.
        """
        var result: [T] = []
        var current = self
        while not current.is_empty():
            val h = current.head()
            if h.?:
                result = result.push(h.unwrap())
            current = current.tail()
        result

    fn to_array_n(max_elements: i64) -> [T]:
        """Convert to array with maximum elements."""
        self.take(max_elements).to_array()

    fn fold<U>(initial: U, f: fn(U, T) -> U) -> U:
        """Fold over sequence (forces all elements).

        WARNING: Will not terminate on infinite sequences!
        """
        var acc = initial
        var current = self
        while not current.is_empty():
            val h = current.head()
            if h.?:
                acc = f(acc, h.unwrap())
            current = current.tail()
        acc

    fn reduce(f: fn(T, T) -> T) -> T?:
        """Reduce sequence to single value."""
        if self.is_empty():
            return None

        var acc = self.head().unwrap()
        var current = self.tail()
        while not current.is_empty():
            val h = current.head()
            if h.?:
                acc = f(acc, h.unwrap())
            current = current.tail()
        Some(acc)

    fn for_each(f: fn(T)):
        """Apply function to each element.

        WARNING: Will not terminate on infinite sequences!
        """
        var current = self
        while not current.is_empty():
            val h = current.head()
            if h.?:
                f(h.unwrap())
            current = current.tail()

    fn find(predicate: fn(T) -> bool) -> T?:
        """Find first element matching predicate."""
        var current = self
        while not current.is_empty():
            val h = current.head()
            if h.? and predicate(h.unwrap()):
                return h
            current = current.tail()
        None

    fn exists(predicate: fn(T) -> bool) -> bool:
        """Check if any element matches predicate."""
        self.find(predicate).?

    fn forall(predicate: fn(T) -> bool) -> bool:
        """Check if all elements match predicate.

        WARNING: Will not terminate on infinite sequences!
        """
        var current = self
        while not current.is_empty():
            val h = current.head()
            if h.? and not predicate(h.unwrap()):
                return false
            current = current.tail()
        true

    fn count() -> i64:
        """Count elements.

        WARNING: Will not terminate on infinite sequences!
        """
        self.fold(0, \acc, _: acc + 1)

    fn nth(n: i64) -> T?:
        """Get nth element (0-indexed)."""
        self.drop(n).head()

    fn contains(value: T) -> bool:
        """Check if sequence contains value."""
        self.exists(\x: x == value)

# ============================================================================
# Standard Infinite Sequences
# ============================================================================

fn naturals() -> LazySeq<i64>:
    """Infinite sequence of natural numbers: 0, 1, 2, 3, ..."""
    LazySeq.iterate(0, \x: x + 1)

fn naturals_from(start: i64) -> LazySeq<i64>:
    """Infinite sequence starting from a number."""
    LazySeq.iterate(start, \x: x + 1)

fn fibonacci() -> LazySeq<i64>:
    """Infinite Fibonacci sequence: 0, 1, 1, 2, 3, 5, 8, ..."""
    LazySeq.unfold((0, 1), \state:
        value (a, b) = state
        Some((a, (b, a + b)))
    )

fn primes() -> LazySeq<i64>:
    """Infinite sequence of prime numbers (simple sieve)."""
    sieve(naturals_from(2))

fn sieve(seq: LazySeq<i64>) -> LazySeq<i64>:
    """Sieve of Eratosthenes helper."""
    val ht = seq.head_tail()
    match ht:
        case Some((p, rest)):
            val filtered = rest.filter(\x: x % p != 0)
            val tail = lazy(\: sieve(filtered).force_node())
            LazySeq(node: Lazy.of(LazySeqNode.Cons(p, tail)))
        case None:
            LazySeq.empty()

fn repeat<T>(value: T) -> LazySeq<T>:
    """Infinite sequence of the same value."""
    LazySeq.repeat_val(value)

fn cycle<T>(arr: [T]) -> LazySeq<T>:
    """Cycle through array elements infinitely."""
    if arr.len() == 0:
        return LazySeq.empty()
    cycle_helper(arr, 0)

fn cycle_helper<T>(arr: [T], index: i64) -> LazySeq<T>:
    """Helper for cycle."""
    val actual_index = index % arr.len()
    val tail = lazy(\: cycle_helper(arr, actual_index + 1).force_node())
    LazySeq(node: Lazy.of(LazySeqNode.Cons(arr[actual_index], tail)))

fn range_lazy(start: i64, end: i64) -> LazySeq<i64>:
    """Lazy range [start, end)."""
    if start >= end:
        LazySeq.empty()
    else:
        val tail = lazy(\: range_lazy(start + 1, end).force_node())
        LazySeq(node: Lazy.of(LazySeqNode.Cons(start, tail)))

fn range_step(start: i64, end: i64, step: i64) -> LazySeq<i64>:
    """Lazy range with step."""
    if step > 0 and start >= end:
        LazySeq.empty()
    else if step < 0 and start <= end:
        LazySeq.empty()
    else if step == 0:
        LazySeq.empty()
    else:
        val tail = lazy(\: range_step(start + step, end, step).force_node())
        LazySeq(node: Lazy.of(LazySeqNode.Cons(start, tail)))

# ============================================================================
# Sequence Iterator
# ============================================================================

struct SeqIterator<T>:
    """Iterator over a lazy sequence.

    Allows stateful iteration with has_next/next pattern.
    """
    current: LazySeq<T>

impl SeqIterator<T>:
    static fn new(seq: LazySeq<T>) -> SeqIterator<T>:
        SeqIterator(current: seq)

    fn has_next() -> bool:
        not self.current.is_empty()

    me next() -> T?:
        val ht = self.current.head_tail()
        match ht:
            case Some((head, tail)):
                self.current = tail
                Some(head)
            case None:
                None

# ============================================================================
# Display
# ============================================================================

impl Display for LazySeq<T>:
    fn fmt() -> text:
        if self.is_empty():
            "LazySeq()"
        else:
            val first_few = self.take(5).to_array()
            val preview = first_few.join(", ")
            "LazySeq({preview}, ...)"
