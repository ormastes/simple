# Lazy Values
#
# Scala-style lazy evaluation - values computed on first access.
# Subsequent accesses return cached result without recomputation.
#
# Benefits:
# - Deferred computation: expensive operations only run when needed
# - Memoization: results cached automatically
# - Infinite structures: represent unbounded data
# - Cycle detection: prevents infinite loops in lazy dependencies
#
# Inspired by:
# - Scala lazy value: https://docs.scala-lang.org/tour/lazy-evaluation.html
# - Haskell thunks: https://wiki.haskell.org/Thunk
# - Erlang lazy evaluation patterns
#
# Example:
#     value expensive = Lazy.new(\: compute_heavy())
#     # ... later, only if needed ...
#     value result = expensive.force()  # Computed here, cached
#     value result2 = expensive.force() # Returns cached value

export Lazy, LazyState, LazyError, LazyStats, Memo, MemoStats
export lazy, force, is_evaluated, map_lazy, flat_map_lazy
export get_lazy_stats, reset_lazy_stats, current_time_ms

# ============================================================================
# Lazy State
# ============================================================================

enum LazyState<T>:
    """State of a lazy value."""
    Pending         # Not yet evaluated, thunk stored separately
    Evaluating      # Currently being evaluated (cycle detection)
    Ready(value: T) # Evaluated, value cached
    Failed(error: text)  # Evaluation failed

impl LazyState:
    fn is_pending() -> bool:
        match self:
            case Pending: true
            case _: false
    fn is_ready() -> bool:
        match self:
            case Ready(_): true
            case _: false
    fn is_evaluating() -> bool:
        match self:
            case Evaluating: true
            case _: false
    fn is_failed() -> bool:
        match self:
            case Failed(_): true
            case _: false
# ============================================================================
# Lazy Error
# ============================================================================

enum LazyError:
    """Errors that can occur during lazy evaluation."""
    CycleDetected       # Circular dependency in lazy values
    EvaluationFailed(message: text)  # Thunk threw an error
    AlreadyFailed       # Attempted to force a failed lazy value
    InvalidState        # Internal error

impl LazyError:
    fn message() -> text:
        match self:
            case CycleDetected: "Cycle detected in lazy evaluation"
            case EvaluationFailed(msg): "Evaluation failed: {msg}"
            case AlreadyFailed: "Lazy value already failed"
            case InvalidState: "Invalid lazy state"
impl Display for LazyError:
    fn fmt() -> text:
        self.message()
# ============================================================================
# Lazy Statistics
# ============================================================================

struct LazyStats:
    """Statistics for lazy evaluation."""
    total_created: i64
    total_forced: i64
    cache_hits: i64
    cache_misses: i64
    cycles_detected: i64
    evaluation_failures: i64
    total_evaluation_time_ms: i64

fn LazyStats__new() -> LazyStats:
    LazyStats(
        total_created: 0,
        total_forced: 0,
        cache_hits: 0,
        cache_misses: 0,
        cycles_detected: 0,
        evaluation_failures: 0,
        total_evaluation_time_ms: 0
    )


impl LazyStats:
    fn hit_rate() -> f64:
        """Cache hit rate (0.0 to 1.0)."""
        val total = self.cache_hits + self.cache_misses
        if total == 0:
            0.0
        else:
            (self.cache_hits as f64) / (total as f64)
    fn avg_evaluation_time_ms() -> f64:
        """Average evaluation time per miss."""
        if self.cache_misses == 0:
            0.0
        else:
            (self.total_evaluation_time_ms as f64) / (self.cache_misses as f64)
impl Display for LazyStats:
    fn fmt() -> text:
        "LazyStats(created={self.total_created}, forced={self.total_forced}, hit_rate={self.hit_rate()})"
# Global lazy ID counter
var _lazy_next_id: i64 = 0

fn _next_lazy_id() -> i64:
    _lazy_next_id = _lazy_next_id + 1
    _lazy_next_id

# Global statistics (tracked per-instance, aggregated on request)
fn get_lazy_stats() -> LazyStats:
    """Get global lazy evaluation statistics (placeholder)."""
    LazyStats__new()

fn reset_lazy_stats():
    """Reset global statistics (placeholder)."""
    pass

# ============================================================================
# Lazy Value
# ============================================================================

struct Lazy<T>:
    """A lazily evaluated value.

    The value is not computed until first accessed via force().
    After evaluation, the result is cached for subsequent accesses.

    Thread safety:
    - In single-threaded context: safe
    - In multi-threaded context: would need synchronization (not implemented)

    Example:
        # Create lazy value
        val lazy_sum = Lazy__new(\: expensive_sum(1, 1000000))

        # Value not computed yet
        assert not lazy_sum.is_evaluated()

        # Force evaluation
        val result = lazy_sum.force()  # Computed here

        # Cached for subsequent access
        val result2 = lazy_sum.force()  # Returns cached value
        assert lazy_sum.is_evaluated()
    """
    id: i64
    state: LazyState<T>
    thunk: fn() -> T       # The computation to perform
    created_at: i64
    evaluated_at: i64?

fn Lazy__new<T>(thunk: fn() -> T) -> Lazy<T>:
    """Create a new lazy value with the given thunk."""
    Lazy(
        id: _next_lazy_id(),
        state: LazyState.Pending,
        thunk: thunk,
        created_at: current_time_ms(),
        evaluated_at: nil
    )

fn Lazy__of<T>(value: T) -> Lazy<T>:
    """Create an already-evaluated lazy value.

    Useful for wrapping constants or pre-computed values.
    """
    Lazy(
        id: _next_lazy_id(),
        state: LazyState.Ready(value),
        thunk: \: value,  # Dummy thunk
        created_at: current_time_ms(),
        evaluated_at: Some(current_time_ms())
    )

fn Lazy__failed<T>(error: text) -> Lazy<T>:
    """Create a lazy value that always fails."""
    Lazy(
        id: _next_lazy_id(),
        state: LazyState.Failed(error),
        thunk: \: panic(error),
        created_at: current_time_ms(),
        evaluated_at: nil
    )


impl Lazy:
    me force() -> Result<T, LazyError>:
        """Force evaluation of the lazy value.

        Returns the cached value if already evaluated.
        Detects cycles if the value depends on itself.
        """
        match self.state:
            case Ready(value):
                Ok(value)

            case Evaluating:
                # Cycle detected!
                self.state = LazyState.Failed("Cycle detected")
                Err(LazyError.CycleDetected)

            case Failed(msg):
                Err(LazyError.AlreadyFailed)

            case Pending:
                # Mark as evaluating (for cycle detection)
                self.state = LazyState.Evaluating

                # Evaluate the thunk
                val thunk_fn = self.thunk
                val result = thunk_fn()

                # Cache the result
                self.state = LazyState.Ready(result)
                self.evaluated_at = Some(current_time_ms())

                Ok(result)
    me force_or_default(default: T) -> T:
        """Force evaluation, returning default on error."""
        match self.force():
            case Ok(value): value
            case Err(_): default
    me force_unchecked() -> T:
        """Force evaluation, panicking on error."""
        match self.force():
            case Ok(value): value
            case Err(e): panic(e.message())
    fn is_evaluated() -> bool:
        """Check if the value has been evaluated."""
        self.state.is_ready()
    fn is_pending() -> bool:
        """Check if the value is pending evaluation."""
        self.state.is_pending()
    fn is_failed() -> bool:
        """Check if evaluation failed."""
        self.state.is_failed()
    fn get() -> T?:
        """Get the value if already evaluated, without forcing."""
        match self.state:
            case Ready(value): Some(value)
            case _: nil
    fn age_ms() -> i64:
        """Time since creation."""
        current_time_ms() - self.created_at
    fn map<U>(f: fn(T) -> U) -> Lazy<U>:
        """Transform the lazy value, lazily.

        The transformation is not applied until the result is forced.
        """
        val self_ref = self
        Lazy__new(\:
            val value = self_ref.force_unchecked()
            f(value)
        )
    fn flat_map<U>(f: fn(T) -> Lazy<U>) -> Lazy<U>:
        """Chain lazy computations.

        The inner lazy value is also forced lazily.
        """
        val self_ref = self
        Lazy__new(\:
            val value = self_ref.force_unchecked()
            val inner = f(value)
            inner.force_unchecked()
        )
    fn zip<U>(other: Lazy<U>) -> Lazy<(T, U)>:
        """Combine two lazy values into a lazy pair."""
        val self_ref = self
        Lazy__new(\:
            val a = self_ref.force_unchecked()
            val b = other.force_unchecked()
            (a, b)
        )
    fn filter(predicate: fn(T) -> bool) -> Lazy<T?>:
        """Filter the lazy value."""
        val self_ref = self
        Lazy__new(\:
            val value = self_ref.force_unchecked()
            if predicate(value):
                Some(value)
            else:
                nil
        )
impl Display for Lazy:
    fn fmt() -> text:
        match self.state:
            case Pending: "Lazy(<pending>)"
            case Evaluating: "Lazy(<evaluating>)"
            case Ready(_): "Lazy(<ready>)"
            case Failed(e): "Lazy(<failed: {e}>)"
# ============================================================================
# Convenience Functions
# ============================================================================

fn lazy<T>(thunk: fn() -> T) -> Lazy<T>:
    """Create a lazy value (shorthand for Lazy.new)."""
    Lazy__new(thunk)

fn force<T>(lazy_val: Lazy<T>) -> Result<T, LazyError>:
    """Force a lazy value (shorthand)."""
    var l = lazy_val
    l.force()

fn is_evaluated<T>(lazy_val: Lazy<T>) -> bool:
    """Check if lazy value is evaluated."""
    lazy_val.is_evaluated()

fn map_lazy<T, U>(lazy_val: Lazy<T>, f: fn(T) -> U) -> Lazy<U>:
    """Map over a lazy value."""
    lazy_val.map(f)

fn flat_map_lazy<T, U>(lazy_val: Lazy<T>, f: fn(T) -> Lazy<U>) -> Lazy<U>:
    """Flat map over a lazy value."""
    lazy_val.flat_map(f)

# ============================================================================
# Memoization
# ============================================================================

struct Memo<K, V>:
    """Memoization cache for functions.

    Caches results of function calls by argument.
    Useful for expensive pure functions.

    Example:
        val fib_memo = Memo<i64, i64>.new()

        fn fib(n: i64) -> i64:
            fib_memo.get_or_compute(n, \:
                if n <= 1: n
                else: fib(n - 1) + fib(n - 2)
            )
    """
    cache: Dict<K, Lazy<V>>
    stats: MemoStats

fn Memo__new<K, V>() -> Memo<K, V>:
    Memo(
        cache: {},
        stats: MemoStats__new()
    )


impl Memo:
    me get_or_compute(key: K, compute: fn() -> V) -> V:
        """Get cached value or compute and cache it."""
        self.stats.total_lookups = self.stats.total_lookups + 1

        val existing = self.cache.get(key)
        match existing:
            case Some(cached):
                self.stats.cache_hits = self.stats.cache_hits + 1
                var lazy_val = cached
                lazy_val.force_unchecked()
            case _:
                self.stats.cache_misses = self.stats.cache_misses + 1
                val lazy_val = Lazy__new(compute)
                self.cache[key] = lazy_val
                var lv = lazy_val
                lv.force_unchecked()
    fn get(key: K) -> V?:
        """Get cached value if present."""
        match self.cache.get(key):
            case Some(cached):
                cached.get()
            case _:
                nil
    fn contains(key: K) -> bool:
        """Check if key is in cache."""
        self.cache.get(key).?
    me clear():
        """Clear the cache."""
        self.cache = {}
        self.stats.clears = self.stats.clears + 1
    fn size() -> i64:
        """Number of cached entries."""
        self.cache.len()
    fn get_stats() -> MemoStats:
        """Get memoization statistics."""
        self.stats
struct MemoStats:
    """Statistics for memoization."""
    total_lookups: i64
    cache_hits: i64
    cache_misses: i64
    clears: i64

fn MemoStats__new() -> MemoStats:
    MemoStats(
        total_lookups: 0,
        cache_hits: 0,
        cache_misses: 0,
        clears: 0
    )


impl MemoStats:
    fn hit_rate() -> f64:
        if self.total_lookups == 0:
            0.0
        else:
            (self.cache_hits as f64) / (self.total_lookups as f64)
# ============================================================================
# Helper Functions
# ============================================================================

fn current_time_ms() -> i64:
    """Get current time in milliseconds (placeholder)."""
    0
