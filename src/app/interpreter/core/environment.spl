# Environment - Variable Bindings
#
# Manages variable scopes and bindings using interned symbols.
#
# Performance optimization: Uses SymbolId (i64) instead of String keys.
# - Comparison: O(1) integer compare vs O(n) string compare
# - Hashing: Direct use of id vs computing string hash
# - Memory: One interned string vs many duplicate strings

from value import {Value}
from symbol import {SymbolId, intern, resolve, GLOBAL_INTERNER}

export Environment, Scope, Binding, EnvironmentWithInterner

# ============================================================================
# Binding - A single variable binding
# ============================================================================

struct Binding:
    """A variable binding in a scope."""
    name: SymbolId      # Interned name (was: String)
    value: Value
    mutable: bool

impl Binding:
    fn name_str() -> text:
        """Get the string representation of the binding name."""
        resolve(self.name) ?? "<unknown>"

# ============================================================================
# Scope - A lexical scope (block)
# ============================================================================

struct Scope:
    """A single scope (lexical block)."""
    bindings: Dict<i64, Binding>    # SymbolId.id -> Binding (was: Dict<String, Binding>)
    parent: Option<&Scope>

impl Scope:
    static fn new() -> Scope:
        """Create a new empty scope."""
        Scope(
            bindings: {},
            parent: None
        )

    static fn with_parent(parent: &Scope) -> Scope:
        """Create a new scope with a parent."""
        Scope(
            bindings: {},
            parent: Some(parent)
        )

    me define(name: SymbolId, value: Value, mutable: bool):
        """Define a variable in this scope."""
        self.bindings[name.id] = Binding {
            name: name,
            value: value,
            mutable: mutable
        }

    me define_str(name: text, value: Value, mutable: bool):
        """Define a variable by string name (auto-interns)."""
        val sym = intern(name)
        self.define(sym, value, mutable)

    fn get(name: SymbolId) -> Binding?:
        """Look up a binding by SymbolId."""
        if self.bindings[name.id].?:
            return Some(self.bindings[name.id])
        if self.parent.?:
            return self.parent.unwrap().get(name)
        None

    fn get_str(name: text) -> Binding?:
        """Look up a binding by string name.

        First checks if the string is interned. If not, the binding
        cannot exist (all bindings use interned symbols).
        """
        val sym = GLOBAL_INTERNER.get_or_none(name)
        if sym.?:
            self.get(sym.unwrap())
        else:
            None

    me set(name: SymbolId, value: Value) -> Result<(), text>:
        """Set a variable's value."""
        if self.bindings[name.id].?:
            val current_binding = self.bindings[name.id]
            if not current_binding.mutable:
                val name_str = resolve(name) ?? "<unknown>"
                return Err("Cannot assign to immutable variable: {name_str}")
            self.bindings[name.id] = Binding {
                name: current_binding.name,
                value: value,
                mutable: current_binding.mutable
            }
            return Ok(())
        if self.parent.?:
            return self.parent.unwrap().set(name, value)
        val name_str = resolve(name) ?? "<unknown>"
        Err("Undefined variable: {name_str}")

    me set_str(name: text, value: Value) -> Result<(), text>:
        """Set a variable's value by string name."""
        val sym = GLOBAL_INTERNER.get_or_none(name)
        if sym.?:
            self.set(sym.unwrap(), value)
        else:
            Err("Undefined variable: {name}")

# ============================================================================
# Environment - Stack of scopes
# ============================================================================

struct Environment:
    """The environment (stack of scopes)."""
    scopes: [Scope]
    globals: Scope

impl Environment:
    static fn new() -> Environment:
        """Create a new environment with an empty scope."""
        Environment(
            scopes: [Scope.new()],
            globals: Scope.new()
        )

    # ------------------------------------------------------------------------
    # Scope management
    # ------------------------------------------------------------------------

    me push_scope():
        """Enter a new scope."""
        val parent = self.current_scope()
        self.scopes = self.scopes.push(Scope.with_parent(parent))

    me pop_scope():
        """Exit current scope."""
        if self.scopes.len() > 1:
            self.scopes = self.scopes[0:self.scopes.len() - 1]

    fn current_scope() -> &Scope:
        """Get current scope (immutable)."""
        &self.scopes[self.scopes.len() - 1]

    me current_scope_mut() -> &Scope:
        """Get current scope (mutable)."""
        val idx = self.scopes.len() - 1
        &self.scopes[idx]

    # ------------------------------------------------------------------------
    # Variable operations (SymbolId)
    # ------------------------------------------------------------------------

    me define(name: SymbolId, value: Value):
        """Define a mutable variable in current scope."""
        self.current_scope_mut().define(name, value, true)

    me define_const(name: SymbolId, value: Value):
        """Define an immutable variable in current scope."""
        self.current_scope_mut().define(name, value, false)

    fn get(name: SymbolId) -> Value?:
        """Get a variable's value by SymbolId."""
        if val Some(current_binding) = self.current_scope().get(name):
            return Some(current_binding.value.clone())
        if val Some(current_binding) = self.globals.get(name):
            return Some(current_binding.value.clone())
        None

    me set(name: SymbolId, value: Value) -> Result<(), text>:
        """Set a variable's value."""
        self.current_scope_mut().set(name, value)

    me define_global(name: SymbolId, value: Value):
        """Define a global variable."""
        self.globals.define(name, value, true)

    # ------------------------------------------------------------------------
    # Variable operations (String - convenience wrappers)
    # ------------------------------------------------------------------------

    me define_str(name: text, value: Value):
        """Define a mutable variable by string name (auto-interns)."""
        self.define(intern(name), value)

    me define_const_str(name: text, value: Value):
        """Define an immutable variable by string name (auto-interns)."""
        self.define_const(intern(name), value)

    fn get_str(name: text) -> Value?:
        """Get a variable's value by string name."""
        val sym = GLOBAL_INTERNER.get_or_none(name)
        if sym.?:
            self.get(sym.unwrap())
        else:
            None

    me set_str(name: text, value: Value) -> Result<(), text>:
        """Set a variable's value by string name."""
        val sym = GLOBAL_INTERNER.get_or_none(name)
        if sym.?:
            self.set(sym.unwrap(), value)
        else:
            Err("Undefined variable: {name}")

    me define_global_str(name: text, value: Value):
        """Define a global variable by string name (auto-interns)."""
        self.define_global(intern(name), value)

# ============================================================================
# EnvironmentWithInterner - Environment bundled with interner reference
# ============================================================================

struct EnvironmentWithInterner:
    """Environment with explicit interner reference.

    Useful when passing environment between modules or actors
    where the global interner might not be appropriate.
    """
    env: Environment
    interner: &SymbolInterner

impl EnvironmentWithInterner:
    static fn new() -> EnvironmentWithInterner:
        EnvironmentWithInterner(
            env: Environment.new(),
            interner: &GLOBAL_INTERNER
        )

    static fn with_interner(interner: &SymbolInterner) -> EnvironmentWithInterner:
        EnvironmentWithInterner(
            env: Environment.new(),
            interner: interner
        )

    fn intern(s: text) -> SymbolId:
        self.interner.intern(s)

    fn resolve(id: SymbolId) -> text?:
        self.interner.resolve(id)
