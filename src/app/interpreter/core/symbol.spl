# Symbol Interning
#
# Efficient string interning for identifier lookups.
# Replaces String keys with i64 SymbolIds for O(1) comparison and hashing.
#
# Benefits:
# - Comparison: O(n) string compare -> O(1) integer compare
# - Hashing: String hash computation -> direct use of id
# - Memory: Many duplicate "foo" strings -> one "foo" + SymbolId(42)
#
# Inspired by Erlang atoms and Lisp symbols.

export SymbolId, SymbolInterner, GLOBAL_INTERNER

# ============================================================================
# SymbolId - Interned string reference
# ============================================================================

struct SymbolId:
    """Unique identifier for an interned string.

    SymbolId is a lightweight handle (8 bytes) that references a string
    in the global interner. Two SymbolIds are equal iff they refer to
    the same string, enabling O(1) equality checks.
    """
    id: i64

impl SymbolId:
    static fn invalid() -> SymbolId:
        """Create an invalid symbol (id = -1)."""
        SymbolId(id: -1)

    fn is_valid() -> bool:
        """Check if this symbol is valid."""
        self.id >= 0

    fn to_i64() -> i64:
        """Get the raw id for use as Dict key."""
        self.id

impl Eq for SymbolId:
    fn eq(other: SymbolId) -> bool:
        self.id == other.id

impl Hash for SymbolId:
    fn hash() -> i64:
        # Direct use of id as hash - already unique
        self.id

impl Display for SymbolId:
    fn fmt() -> text:
        if self.id >= 0:
            # Resolve through global interner
            GLOBAL_INTERNER.resolve(self) ?? "<invalid>"
        else:
            "<invalid>"

impl Debug for SymbolId:
    fn debug() -> text:
        "SymbolId({self.id})"

# ============================================================================
# SymbolInterner - String intern table
# ============================================================================

struct SymbolInterner:
    """Central table for string interning.

    Maintains bidirectional mapping:
    - strings: SymbolId -> text (for resolving)
    - map: text -> SymbolId (for interning)

    Thread-safety: Currently single-threaded. For multi-threaded use,
    wrap in Mutex or use per-actor interners with global fallback.
    """
    strings: [text]
    map: Dict<text, SymbolId>

impl SymbolInterner:
    static fn new() -> SymbolInterner:
        """Create a new empty interner."""
        SymbolInterner(
            strings: [],
            map: {}
        )

    me intern(s: text) -> SymbolId:
        """Intern a string, returning its SymbolId.

        If the string is already interned, returns the existing SymbolId.
        Otherwise, allocates a new SymbolId and stores the string.

        Time: O(1) amortized (hash table lookup/insert)
        """
        # Check if already interned
        if self.map[s].?:
            return self.map[s]

        # Allocate new id
        val id = SymbolId(id: self.strings.len())
        self.strings = self.strings.push(s)
        self.map[s] = id
        id

    fn resolve(id: SymbolId) -> text?:
        """Resolve a SymbolId back to its string.

        Returns None if the id is invalid or out of range.

        Time: O(1) (array index)
        """
        if id.id < 0 or id.id >= self.strings.len():
            return None
        Some(self.strings[id.id])

    fn contains(s: text) -> bool:
        """Check if a string is already interned."""
        self.map[s].?

    fn len() -> i64:
        """Number of interned strings."""
        self.strings.len()

    fn get_or_none(s: text) -> SymbolId?:
        """Get SymbolId if already interned, None otherwise.

        Unlike intern(), this does not add the string to the table.
        """
        if self.map[s].?:
            Some(self.map[s])
        else:
            None

# ============================================================================
# Global Interner
# ============================================================================

# Global interner instance for the interpreter.
# All identifier strings should be interned through this.
var GLOBAL_INTERNER: SymbolInterner = SymbolInterner.new()

fn intern(s: text) -> SymbolId:
    """Intern a string using the global interner.

    Convenience function for: GLOBAL_INTERNER.intern(s)
    """
    GLOBAL_INTERNER.intern(s)

fn resolve(id: SymbolId) -> text?:
    """Resolve a SymbolId using the global interner.

    Convenience function for: GLOBAL_INTERNER.resolve(id)
    """
    GLOBAL_INTERNER.resolve(id)

# ============================================================================
# Pre-interned symbols (common identifiers)
# ============================================================================

# Pre-intern common identifiers to avoid repeated lookups
fn init_common_symbols():
    """Pre-intern commonly used symbols.

    Call this at interpreter startup to ensure common symbols
    have predictable low ids.
    """
    # Keywords and builtins
    GLOBAL_INTERNER.intern("self")
    GLOBAL_INTERNER.intern("true")
    GLOBAL_INTERNER.intern("false")
    GLOBAL_INTERNER.intern("nil")
    GLOBAL_INTERNER.intern("None")
    GLOBAL_INTERNER.intern("Some")
    GLOBAL_INTERNER.intern("Ok")
    GLOBAL_INTERNER.intern("Err")

    # Common variable names
    GLOBAL_INTERNER.intern("x")
    GLOBAL_INTERNER.intern("y")
    GLOBAL_INTERNER.intern("i")
    GLOBAL_INTERNER.intern("n")
    GLOBAL_INTERNER.intern("s")
    GLOBAL_INTERNER.intern("result")
    GLOBAL_INTERNER.intern("value")
    GLOBAL_INTERNER.intern("item")
    GLOBAL_INTERNER.intern("index")
    GLOBAL_INTERNER.intern("key")

    # Common method names
    GLOBAL_INTERNER.intern("new")
    GLOBAL_INTERNER.intern("init")
    GLOBAL_INTERNER.intern("get")
    GLOBAL_INTERNER.intern("set")
    GLOBAL_INTERNER.intern("len")
    GLOBAL_INTERNER.intern("push")
    GLOBAL_INTERNER.intern("pop")
    GLOBAL_INTERNER.intern("map")
    GLOBAL_INTERNER.intern("filter")
    GLOBAL_INTERNER.intern("fold")

export intern, resolve, init_common_symbols
