# Main Evaluation Loop
#
# Core interpreter evaluation logic.

from environment import {Environment}
from symbol import {intern, init_common_symbols}
from value import {Value, RuntimeValue}
import ..expr.{eval_expr}
import ..control.{eval_control}

export Interpreter, eval_statement, eval_expression

# Main interpreter struct
struct Interpreter:
    env: Environment
    debug: bool

impl Interpreter:
    static fn new() -> Interpreter:
        # Initialize common symbols for performance
        init_common_symbols()
        Interpreter(
            env: Environment.new(),
            debug: false
        )

    static fn with_debug(debug: bool) -> Interpreter:
        init_common_symbols()
        Interpreter(
            env: Environment.new(),
            debug: debug
        )

    # Evaluate a statement
    fn eval_stmt(stmt: &Statement) -> Result<Value, InterpreterError>:
        if self.debug:
            print("Evaluating: {stmt}")

        match stmt:
            case Statement.Let(binding):
                return self.eval_let(binding)

            case Statement.Return(expr):
                return self.eval_return(expr)

            case Statement.If(cond, then_block, else_block):
                return eval_control.eval_if(self, cond, then_block, else_block)

            case Statement.Match(value, cases):
                return eval_control.eval_match(self, value, cases)

            case Statement.For(pattern, iterable, body):
                return eval_control.eval_for(self, pattern, iterable, body)

            case Statement.While(cond, body):
                return eval_control.eval_while(self, cond, body)

            case Statement.Expression(expr):
                return self.eval_expr(expr)

            case _:
                return Err(InterpreterError.NotImplemented(stmt.to_string()))

    # Evaluate an expression
    fn eval_expr(expr: &Expr) -> Result<Value, InterpreterError>:
        return eval_expr.evaluate(self, expr)

    # Evaluate val binding
    me eval_let(binding: &LetBinding) -> Result<Value, InterpreterError>:
        val value = self.eval_expr(&binding.value)?
        # Use interned symbol for variable name (performance optimization)
        val name_sym = intern(binding.name)
        self.env.define(name_sym, value.clone())
        Ok(Value.nil())

    # Evaluate return statement
    fn eval_return(expr: &Option<Expr>) -> Result<Value, InterpreterError>:
        match expr:
            case Some(e):
                val value = self.eval_expr(&e)?
                return Err(InterpreterError.Return(value))
            case None:
                return Err(InterpreterError.Return(Value.nil()))

# Convenience functions
fn eval_statement(interp: &Interpreter, stmt: &Statement) -> Result<Value, InterpreterError>:
    return interp.eval_stmt(stmt)

fn eval_expression(interp: &Interpreter, expr: &Expr) -> Result<Value, InterpreterError>:
    return interp.eval_expr(expr)

# Error type
enum InterpreterError:
    Return(Value)              # Control flow for return
    Break                      # Control flow for break
    Continue                   # Control flow for continue
    NameError(String)          # Undefined variable
    TypeError(String)          # Type mismatch
    ValueError(String)         # Invalid value
    IndexError(String)         # Index out of bounds
    IoError(String)            # I/O error
    NotImplemented(String)     # Feature not implemented
