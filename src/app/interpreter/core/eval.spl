# Main Evaluation Loop
#
# Core interpreter evaluation logic.

from environment import {Environment}
from symbol import {intern, init_common_symbols}
from value import {Value, RuntimeValue}
from ..expr import {eval_expr}
from ..control import {eval_control}
# Lazy and PersistentDict imports - modules exist but not yet fully integrated
# from ..lazy import {Lazy}
# from ..collections.persistent_dict import {PersistentDict}
eprint("eval: Lazy and PersistentDict not yet integrated; module caching disabled")

export Interpreter, eval_statement, eval_expression

# Main interpreter struct
struct Interpreter:
    env: Environment
    debug: bool
    # Module cache requires Lazy and PersistentDict integration
    # module_cache: PersistentDict<text, Lazy<Value>>  # Lazy module cache: path -> deferred module

impl Interpreter:
    static fn new() -> Interpreter:
        # Initialize common symbols for performance
        init_common_symbols()
        Interpreter(
            env: Environment.new(),
            debug: false
        )

    static fn with_debug(debug: bool) -> Interpreter:
        init_common_symbols()
        Interpreter(
            env: Environment.new(),
            debug: debug
        )

    # Module cache requires Lazy and PersistentDict integration
    # fn get_or_load_module(path: text, loader: fn() -> Value) -> Result<Value, InterpreterError>:
    #     """Get a cached module or lazily load it on first access.
    #
    #     Uses Lazy to defer module evaluation until first use.
    #     Subsequent accesses return the cached result.
    #     """
    #     val cached = self.module_cache.get(path)
    #     if cached.?:
    #         val lazy_mod = cached.unwrap()
    #         match lazy_mod.force():
    #             case Ok(v): return Ok(v)
    #             case Err(e): return Err(InterpreterError.IoError(e.message()))
    #     # Create lazy value for this module and cache it
    #     val lazy_mod = Lazy.of(loader)
    #     self.module_cache = self.module_cache.set(path, lazy_mod)
    #     match lazy_mod.force():
    #         case Ok(v): Ok(v)
    #         case Err(e): Err(InterpreterError.IoError(e.message()))

    # Evaluate a statement
    fn eval_stmt(stmt: &Statement) -> Result<Value, InterpreterError>:
        if self.debug:
            print("Evaluating: {stmt}")

        match stmt:
            case Statement.Let(binding):
                return self.eval_let(binding)

            case Statement.Return(expr):
                return self.eval_return(expr)

            case Statement.If(cond, then_block, else_block):
                return eval_control.eval_if(self, cond, then_block, else_block)

            case Statement.Match(value, cases):
                return eval_control.eval_match(self, value, cases)

            case Statement.For(pattern, iterable, body):
                return eval_control.eval_for(self, pattern, iterable, body)

            case Statement.While(cond, body):
                return eval_control.eval_while(self, cond, body)

            case Statement.With(items, body):
                return eval_control.eval_with(self, items, body)

            case Statement.Expression(expr):
                return self.eval_expr(expr)

            case _:
                return Err(InterpreterError.NotImplemented(stmt.to_string()))

    # Evaluate an expression
    fn eval_expr(expr: &Expr) -> Result<Value, InterpreterError>:
        return eval_expr.evaluate(self, expr)

    # Evaluate value binding
    me eval_let(binding: &LetBinding) -> Result<Value, InterpreterError>:
        val value = self.eval_expr(&binding.value)?
        # Use interned symbol for variable name (performance optimization)
        val name_sym = intern(binding.name)
        self.env.define(name_sym, value.clone())
        Ok(Value.null())

    # Evaluate return statement
    fn eval_return(expr: &Option<Expr>) -> Result<Value, InterpreterError>:
        match expr:
            case Some(e):
                val value = self.eval_expr(&e)?
                return Err(InterpreterError.Return(value))
            case nil:
                return Err(InterpreterError.Return(Value.null()))

# Convenience functions
fn eval_statement(interp: &Interpreter, stmt: &Statement) -> Result<Value, InterpreterError>:
    return interp.eval_stmt(stmt)

fn eval_expression(interp: &Interpreter, expr: &Expr) -> Result<Value, InterpreterError>:
    return interp.eval_expr(expr)

# Error type
enum InterpreterError:
    Return(Value)              # Control flow for return
    Break                      # Control flow for break
    BreakValue(Value)          # Control flow for break with value
    Continue                   # Control flow for continue
    NameError(String)          # Undefined variable
    TypeError(String)          # Type mismatch
    ValueError(String)         # Invalid value
    IndexError(String)         # Index out of bounds
    IoError(String)            # I/O error
    NotImplemented(String)     # Feature not implemented
    StackOverflow(String)      # Recursion depth exceeded
    RuntimeError(String)       # Timeout, interrupt, execution limit
    ArityError(String)         # Wrong number of arguments
