# Runtime Values
#
# Value representation for the interpreter.

export Value, ValueKind, RuntimeValue

# Value kinds
enum ValueKind:
    Nil
    Bool
    Int
    Float
    String
    Array
    Dict
    Tuple
    Struct
    Enum
    Function
    Closure
    Object

# Main value type
struct Value:
    kind: ValueKind
    data: RuntimeValue

# Runtime value variants
enum RuntimeValue:
    Nil
    Bool(bool)
    Int(i64)
    Float(f64)
    String(String)
    Array(Array<Value>)
    Dict(Dict<Value, Value>)
    Tuple(Array<Value>)
    Struct(String, Dict<String, Value>)
    Enum(String, Option<Box<Value>>)
    Function(String, Array<String>, Box<Block>)
    Closure(Box<RuntimeValue>, Box<Environment>)
    Object(String, Dict<String, Value>)

impl Value:
    # Constructors
    fn null() -> Value:
        return Value { kind: ValueKind.Nil, data: RuntimeValue.Nil }

    fn bool(b: bool) -> Value:
        return Value { kind: ValueKind.Bool, data: RuntimeValue.Bool(b) }

    fn int(n: i64) -> Value:
        return Value { kind: ValueKind.Int, data: RuntimeValue.Int(n) }

    fn float(f: f64) -> Value:
        return Value { kind: ValueKind.Float, data: RuntimeValue.Float(f) }

    fn string(s: String) -> Value:
        return Value { kind: ValueKind.String, data: RuntimeValue.String(s) }

    fn array(arr: Array<Value>) -> Value:
        return Value { kind: ValueKind.Array, data: RuntimeValue.Array(arr) }

    fn dict(d: Dict<Value, Value>) -> Value:
        return Value { kind: ValueKind.Dict, data: RuntimeValue.Dict(d) }

    fn tuple(items: Array<Value>) -> Value:
        return Value { kind: ValueKind.Tuple, data: RuntimeValue.Tuple(items) }

    # Type checks
    fn is_nil() -> bool:
        return self.kind == ValueKind.Nil

    fn is_bool() -> bool:
        return self.kind == ValueKind.Bool

    fn is_int() -> bool:
        return self.kind == ValueKind.Int

    fn is_float() -> bool:
        return self.kind == ValueKind.Float

    fn is_string() -> bool:
        return self.kind == ValueKind.String

    fn is_array() -> bool:
        return self.kind == ValueKind.Array

    fn is_truthy() -> bool:
        match self.data:
            case RuntimeValue.Nil: return false
            case RuntimeValue.Bool(b): return b
            case RuntimeValue.Int(n): return n != 0
            case RuntimeValue.Float(f): return f != 0.0
            case RuntimeValue.String(s): return not s.is_empty()
            case RuntimeValue.Array(arr): return not arr.is_empty()
            case _: return true

    # Type conversions
    fn as_bool() -> Option<bool>:
        match self.data:
            case RuntimeValue.Bool(b): return Some(b)
            case _: return nil

    fn as_int() -> Option<i64>:
        match self.data:
            case RuntimeValue.Int(n): return Some(n)
            case _: return nil

    fn as_float() -> Option<f64>:
        match self.data:
            case RuntimeValue.Float(f): return Some(f)
            case RuntimeValue.Int(n): return Some(n as f64)
            case _: return nil

    fn as_string() -> Option<&String>:
        match self.data:
            case RuntimeValue.String(s): return Some(&s)
            case _: return nil

    fn as_array() -> Option<&Array<Value>>:
        match self.data:
            case RuntimeValue.Array(arr): return Some(&arr)
            case _: return nil

impl Clone for Value:
    fn clone() -> Value:
        # Deep clone is handled by RuntimeValue.clone()
        # which recursively clones all nested values
        return Value { kind: self.kind.clone(), data: self.data.clone() }

impl Display for Value:
    fn fmt() -> String:
        match self.data:
            case RuntimeValue.Nil:
                return "nil".to_string()

            case RuntimeValue.Bool(b):
                return "{b}".to_string()

            case RuntimeValue.Int(n):
                return "{n}".to_string()

            case RuntimeValue.Float(f):
                return "{f}".to_string()

            case RuntimeValue.String(s):
                return "\"{s}\"".to_string()

            case RuntimeValue.Array(arr):
                return format_array(arr)

            case RuntimeValue.Tuple(items):
                return format_tuple(items)

            case RuntimeValue.Dict(d):
                return format_dict(d)

            case RuntimeValue.Struct(name, fields):
                return format_struct(name, fields)

            case RuntimeValue.Enum(variant, data):
                return format_enum(variant, data)

            case RuntimeValue.Function(name, params, _):
                val param_str = params.join(", ")
                return "<fn {name}({param_str})>".to_string()

            case RuntimeValue.Closure(_):
                return "<closure>".to_string()

            case RuntimeValue.Object(class_name, fields):
                return format_object(class_name, fields)

    # ------------------------------------------------------------------------
    # Debug support (for DAP integration)
    # ------------------------------------------------------------------------

    fn to_debug_string() -> String:
        """Convert value to debugger-friendly string representation."""
        match self.data:
            case RuntimeValue.Nil:
                return "nil"
            case RuntimeValue.Bool(b):
                return if b: "true" else: "false"
            case RuntimeValue.Int(i):
                return i.to_string()
            case RuntimeValue.Float(f):
                return f.to_string()
            case RuntimeValue.String(s):
                # Quote strings for clarity in debugger
                return "\"" + s + "\""
            case RuntimeValue.Array(items):
                if items.len() > 10:
                    return "[... {items.len()} items]"
                val item_strs = items.map(\v: v.to_debug_string())
                return "[" + item_strs.join(", ") + "]"
            case RuntimeValue.Dict(map):
                if map.len() > 5:
                    return "{{ ... {map.len()} entries }}"
                var parts: [String] = []
                var count = 0
                for (key, value) in map:
                    if count >= 5:
                        break
                    parts = parts.push(key.to_debug_string() + ": " + value.to_debug_string())
                    count = count + 1
                return "{" + parts.join(", ") + "}"
            case RuntimeValue.Tuple(items):
                val item_strs = items.map(\v: v.to_debug_string())
                return "(" + item_strs.join(", ") + ")"
            case RuntimeValue.Struct(name, fields):
                if fields.is_empty():
                    return name + " {}"
                var parts: [String] = []
                for (key, value) in fields:
                    parts = parts.push(key + ": " + value.to_debug_string())
                return name + " { " + parts.join(", ") + " }"
            case RuntimeValue.Enum(variant, data):
                match data:
                    case Some(box_val):
                        return variant + "(" + box_val.to_debug_string() + ")"
                    case nil:
                        return variant
            case RuntimeValue.Function(name, params, _):
                return "<function {name}>"
            case RuntimeValue.Closure(_):
                return "<closure>"
            case RuntimeValue.Object(class_name, _):
                return "<{class_name} instance>"

# Helper: Format array values
fn format_array(arr: Array<Value>) -> String:
    if arr.is_empty():
        return "[]"

    var parts = []
    var i = 0
    while i < arr.len():
        # Limit to first 5 elements for large arrays
        if i >= 5 and arr.len() > 6:
            val remaining = arr.len() - 5
            parts.push("... {remaining} more")
            break
        parts.push(arr[i].fmt())
        i = i + 1
    "[" + parts.join(", ") + "]"

# Helper: Format tuple values
fn format_tuple(items: Array<Value>) -> String:
    if items.is_empty():
        return "()"

    if items.len() == 1:
        return "({items[0].fmt()},)"

    var parts = []
    var i = 0
    while i < items.len():
        parts.push(items[i].fmt())
        i = i + 1
    "(" + parts.join(", ") + ")"

# Helper: Format dictionary
fn format_dict(d: Dict<Value, Value>) -> String:
    if d.is_empty():
        return "{}"

    var parts = []
    var count = 0
    for (key, value) in d:
        # Limit to first 5 entries
        if count >= 5:
            parts.push("...")
            break
        parts.push(key.fmt() + ": " + value.fmt())
        count = count + 1
    "{" + parts.join(", ") + "}"

# Helper: Format struct
fn format_struct(name: String, fields: Dict<String, Value>) -> String:
    if fields.is_empty():
        return "{name} {{}}"

    var parts = []
    for (key, value) in fields:
        parts.push(key + ": " + value.fmt())
    "{name} {{ " + parts.join(", ") + " }"

# Helper: Format enum
fn format_enum(variant: String, data: Option<Box<Value>>) -> String:
    match data:
        case Some(box_val):
            return "{variant}({box_value.fmt()})"
        case nil:
            return variant

# Helper: Format object
fn format_object(class_name: String, fields: Dict<String, Value>) -> String:
    if fields.is_empty():
        return "<{class_name} instance>"

    var parts = []
    var count = 0
    for (key, value) in fields:
        # Limit to first 3 fields
        if count >= 3:
            parts.push("...")
            break
        parts.push(key + ": " + value.fmt())
        count = count + 1
    "<{class_name} {{ " + parts.join(", ") + " }>"
