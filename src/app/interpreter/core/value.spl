# Runtime Values
#
# Value representation for the interpreter.

export Value, ValueKind, RuntimeValue

# Value kinds
enum ValueKind:
    Nil
    Bool
    Int
    Float
    String
    Array
    Dict
    Tuple
    Struct
    Enum
    Function
    Closure
    Object

# Main value type
struct Value:
    kind: ValueKind
    data: RuntimeValue

# Runtime value variants
enum RuntimeValue:
    Nil
    Bool(bool)
    Int(i64)
    Float(f64)
    String(String)
    Array(Array<Value>)
    Dict(Dict<Value, Value>)
    Tuple(Array<Value>)
    Struct { name: String, fields: Dict<String, Value> }
    Enum { variant: String, data: Option<Box<Value>> }
    Function { name: String, params: Array<String>, body: Box<Block> }
    Closure { func: Box<RuntimeValue>, env: Box<Environment> }
    Object { class: String, fields: Dict<String, Value> }

impl Value:
    # Constructors
    fn nil() -> Value:
        return Value { kind: ValueKind.Nil, data: RuntimeValue.Nil }

    fn bool(b: bool) -> Value:
        return Value { kind: ValueKind.Bool, data: RuntimeValue.Bool(b) }

    fn int(n: i64) -> Value:
        return Value { kind: ValueKind.Int, data: RuntimeValue.Int(n) }

    fn float(f: f64) -> Value:
        return Value { kind: ValueKind.Float, data: RuntimeValue.Float(f) }

    fn string(s: String) -> Value:
        return Value { kind: ValueKind.String, data: RuntimeValue.String(s) }

    fn array(arr: Array<Value>) -> Value:
        return Value { kind: ValueKind.Array, data: RuntimeValue.Array(arr) }

    fn dict(d: Dict<Value, Value>) -> Value:
        return Value { kind: ValueKind.Dict, data: RuntimeValue.Dict(d) }

    fn tuple(items: Array<Value>) -> Value:
        return Value { kind: ValueKind.Tuple, data: RuntimeValue.Tuple(items) }

    # Type checks
    fn is_nil() -> bool:
        return self.kind == ValueKind.Nil

    fn is_bool() -> bool:
        return self.kind == ValueKind.Bool

    fn is_int() -> bool:
        return self.kind == ValueKind.Int

    fn is_float() -> bool:
        return self.kind == ValueKind.Float

    fn is_string() -> bool:
        return self.kind == ValueKind.String

    fn is_array() -> bool:
        return self.kind == ValueKind.Array

    fn is_truthy() -> bool:
        match self.data:
            case RuntimeValue.Nil: return false
            case RuntimeValue.Bool(b): return b
            case RuntimeValue.Int(n): return n != 0
            case RuntimeValue.Float(f): return f != 0.0
            case RuntimeValue.String(s): return not s.is_empty()
            case RuntimeValue.Array(arr): return not arr.is_empty()
            case _: return true

    # Type conversions
    fn as_bool() -> Option<bool>:
        match self.data:
            case RuntimeValue.Bool(b): return Some(b)
            case _: return None

    fn as_int() -> Option<i64>:
        match self.data:
            case RuntimeValue.Int(n): return Some(n)
            case _: return None

    fn as_float() -> Option<f64>:
        match self.data:
            case RuntimeValue.Float(f): return Some(f)
            case RuntimeValue.Int(n): return Some(n as f64)
            case _: return None

    fn as_string() -> Option<&String>:
        match self.data:
            case RuntimeValue.String(ref s): return Some(s)
            case _: return None

    fn as_array() -> Option<&Array<Value>>:
        match self.data:
            case RuntimeValue.Array(ref arr): return Some(arr)
            case _: return None

impl Clone for Value:
    fn clone() -> Value:
        # Deep clone is handled by RuntimeValue.clone()
        # which recursively clones all nested values
        return Value { kind: self.kind.clone(), data: self.data.clone() }

impl Display for Value:
    fn fmt() -> String:
        match self.data:
            case RuntimeValue.Nil:
                return "nil".to_string()

            case RuntimeValue.Bool(b):
                return "{b}".to_string()

            case RuntimeValue.Int(n):
                return "{n}".to_string()

            case RuntimeValue.Float(f):
                return "{f}".to_string()

            case RuntimeValue.String(s):
                return "\"{s}\"".to_string()

            case RuntimeValue.Array(arr):
                return format_array(arr)

            case RuntimeValue.Tuple(items):
                return format_tuple(items)

            case RuntimeValue.Dict(d):
                return format_dict(d)

            case RuntimeValue.Struct{name, fields}:
                return format_struct(name, fields)

            case RuntimeValue.Enum{variant, data}:
                return format_enum(variant, data)

            case RuntimeValue.Function{name, params, ..}:
                val param_str = params.join(", ")
                return "<fn {name}({param_str})>".to_string()

            case RuntimeValue.Closure{..}:
                return "<closure>".to_string()

            case RuntimeValue.Object{class, fields}:
                return format_object(class, fields)

# Helper: Format array values
fn format_array(arr: Array<Value>) -> String:
    if arr.is_empty():
        return "[]"

    var result = "["
    var i = 0
    while i < arr.len():
        if i > 0:
            result = result + ", "
        # Limit to first 5 elements for large arrays
        if i >= 5 and arr.len() > 6:
            val remaining = arr.len() - 5
            result = result + "... {remaining} more"
            break
        result = result + arr[i].fmt()
        i = i + 1
    result + "]"

# Helper: Format tuple values
fn format_tuple(items: Array<Value>) -> String:
    if items.is_empty():
        return "()"

    if items.len() == 1:
        return "({items[0].fmt()},)"

    var result = "("
    var i = 0
    while i < items.len():
        if i > 0:
            result = result + ", "
        result = result + items[i].fmt()
        i = i + 1
    result + ")"

# Helper: Format dictionary
fn format_dict(d: Dict<Value, Value>) -> String:
    if d.is_empty():
        return "{}"

    var result = "{"
    var count = 0
    for (key, val) in d:
        if count > 0:
            result = result + ", "
        # Limit to first 5 entries
        if count >= 5:
            result = result + "..."
            break
        result = result + key.fmt() + ": " + val.fmt()
        count = count + 1
    result + "}"

# Helper: Format struct
fn format_struct(name: String, fields: Dict<String, Value>) -> String:
    if fields.is_empty():
        return "{name} {{}}"

    var result = "{name} {{ "
    var count = 0
    for (key, val) in fields:
        if count > 0:
            result = result + ", "
        result = result + key + ": " + val.fmt()
        count = count + 1
    result + " }"

# Helper: Format enum
fn format_enum(variant: String, data: Option<Box<Value>>) -> String:
    match data:
        case Some(box_val):
            return "{variant}({box_val.fmt()})"
        case None:
            return variant

# Helper: Format object
fn format_object(class: String, fields: Dict<String, Value>) -> String:
    if fields.is_empty():
        return "<{class} instance>"

    var result = "<{class} {{ "
    var count = 0
    for (key, val) in fields:
        if count > 0:
            result = result + ", "
        # Limit to first 3 fields
        if count >= 3:
            result = result + "..."
            break
        result = result + key + ": " + val.fmt()
        count = count + 1
    result + " }>"
