# Performance Statistics
#
# Unified statistics collection across all performance subsystems.
# Provides aggregated metrics for monitoring and tuning.

from ../core/symbol import {GLOBAL_INTERNER}
from ../memory import {get_shared_heap, SharedHeapStats}
from ../lazy import {get_lazy_stats, LazyStats}

export PerfStats, ComponentStats, collect_stats, reset_all_stats
export format_stats, format_stats_json

# ============================================================================
# Component Statistics
# ============================================================================

struct ComponentStats:
    """Statistics for a single component."""
    name: text
    enabled: bool
    metrics: Dict<text, f64>

impl ComponentStats:
    static fn new(name: text, enabled: bool) -> ComponentStats:
        ComponentStats(
            name: name,
            enabled: enabled,
            metrics: {}
        )

    me add_metric(key: text, value: f64):
        """Add a metric."""
        self.metrics[key] = value

    fn get_metric(key: text) -> f64?:
        """Get a metric value."""
        self.metrics.get(key)

    fn metric_count() -> i64:
        """Number of metrics."""
        self.metrics.len()

impl Display for ComponentStats:
    fn fmt() -> text:
        if not self.enabled:
            "{self.name}: disabled"
        else:
            var parts: [text] = []
            for (key, value) in self.metrics.entries():
                parts = parts.push("{key}={value}")
            "{self.name}: {parts.join(\", \")}"

# ============================================================================
# Aggregated Performance Statistics
# ============================================================================

struct PerfStats:
    """Aggregated performance statistics.

    Collects metrics from all performance subsystems:
    - Symbol interning
    - Persistent collections
    - Actor heaps
    - Message transfer
    - Lazy evaluation

    Example:
        val stats = collect_stats()
        print(stats.summary())

        # Access specific component
        val lazy = stats.lazy_stats
        print("Cache hit rate: {lazy.get_metric(\"hit_rate\")}")
    """
    # Collection timestamp
    collected_at: i64

    # Component statistics
    symbol_stats: ComponentStats
    collection_stats: ComponentStats
    actor_heap_stats: ComponentStats
    mailbox_stats: ComponentStats
    scheduler_stats: ComponentStats
    shared_heap_stats: ComponentStats
    message_transfer_stats: ComponentStats
    lazy_stats: ComponentStats

    # Aggregated metrics
    total_memory_bytes: i64
    total_allocations: i64
    total_gc_count: i64
    total_gc_time_ms: i64

impl PerfStats:
    static fn empty() -> PerfStats:
        """Create empty stats."""
        PerfStats(
            collected_at: current_time_ms(),
            symbol_stats: ComponentStats.new("symbols", true),
            collection_stats: ComponentStats.new("collections", true),
            actor_heap_stats: ComponentStats.new("actor_heaps", true),
            mailbox_stats: ComponentStats.new("mailboxes", true),
            scheduler_stats: ComponentStats.new("scheduler", true),
            shared_heap_stats: ComponentStats.new("shared_heap", true),
            message_transfer_stats: ComponentStats.new("message_transfer", true),
            lazy_stats: ComponentStats.new("lazy", true),
            total_memory_bytes: 0,
            total_allocations: 0,
            total_gc_count: 0,
            total_gc_time_ms: 0
        )

    fn summary() -> text:
        """Generate a summary of all statistics."""
        var lines: [text] = []
        lines = lines.push("=== Performance Statistics ===")
        lines = lines.push("")

        # Symbol interning
        lines = lines.push("Symbol Interning:")
        lines = lines.push("  {self.symbol_stats}")
        lines = lines.push("")

        # Collections
        lines = lines.push("Persistent Collections:")
        lines = lines.push("  {self.collection_stats}")
        lines = lines.push("")

        # Actor heaps
        lines = lines.push("Actor Heaps:")
        lines = lines.push("  {self.actor_heap_stats}")
        lines = lines.push("")

        # Mailboxes
        lines = lines.push("Mailboxes:")
        lines = lines.push("  {self.mailbox_stats}")
        lines = lines.push("")

        # Scheduler
        lines = lines.push("Scheduler:")
        lines = lines.push("  {self.scheduler_stats}")
        lines = lines.push("")

        # Shared heap
        lines = lines.push("Shared Heap:")
        lines = lines.push("  {self.shared_heap_stats}")
        lines = lines.push("")

        # Message transfer
        lines = lines.push("Message Transfer:")
        lines = lines.push("  {self.message_transfer_stats}")
        lines = lines.push("")

        # Lazy evaluation
        lines = lines.push("Lazy Evaluation:")
        lines = lines.push("  {self.lazy_stats}")
        lines = lines.push("")

        # Totals
        lines = lines.push("Totals:")
        lines = lines.push("  Memory: {format_bytes(self.total_memory_bytes)}")
        lines = lines.push("  Allocations: {self.total_allocations}")
        lines = lines.push("  GC runs: {self.total_gc_count}")
        lines = lines.push("  GC time: {self.total_gc_time_ms}ms")

        lines.join("\n")

    fn component_names() -> [text]:
        """Get list of component names."""
        [
            "symbols",
            "collections",
            "actor_heaps",
            "mailboxes",
            "scheduler",
            "shared_heap",
            "message_transfer",
            "lazy"
        ]

    fn get_component(name: text) -> ComponentStats?:
        """Get stats for a specific component."""
        match name:
            case "symbols": Some(self.symbol_stats)
            case "collections": Some(self.collection_stats)
            case "actor_heaps": Some(self.actor_heap_stats)
            case "mailboxes": Some(self.mailbox_stats)
            case "scheduler": Some(self.scheduler_stats)
            case "shared_heap": Some(self.shared_heap_stats)
            case "message_transfer": Some(self.message_transfer_stats)
            case "lazy": Some(self.lazy_stats)
            case _: nil

impl Display for PerfStats:
    fn fmt() -> text:
        "PerfStats(memory={format_bytes(self.total_memory_bytes)}, gc={self.total_gc_count})"

# ============================================================================
# Statistics Collection
# ============================================================================

fn collect_stats() -> PerfStats:
    """Collect statistics from all performance subsystems."""
    var stats = PerfStats.empty()

    # Collect symbol interning stats
    collect_symbol_stats(stats)

    # Collect shared heap stats
    collect_shared_heap_stats(stats)

    # Collect lazy evaluation stats
    collect_lazy_stats(stats)

    # Calculate totals
    calculate_totals(stats)

    stats

fn collect_symbol_stats(stats: PerfStats):
    """Collect symbol interning statistics."""
    val interner = GLOBAL_INTERNER
    stats.symbol_stats.add_metric("interned_count", interner.count() as f64)
    stats.symbol_stats.add_metric("total_bytes", interner.total_bytes() as f64)

fn collect_shared_heap_stats(stats: PerfStats):
    """Collect shared heap statistics."""
    val heap = get_shared_heap()
    val heap_stats = heap.get_stats()

    stats.shared_heap_stats.add_metric("total_size", heap_stats.total_size as f64)
    stats.shared_heap_stats.add_metric("used_size", heap_stats.used_size as f64)
    stats.shared_heap_stats.add_metric("binary_count", heap_stats.binary_count as f64)
    stats.shared_heap_stats.add_metric("utilization", heap_stats.utilization())
    stats.shared_heap_stats.add_metric("gc_count", heap_stats.gc_count as f64)
    stats.shared_heap_stats.add_metric("gc_bytes_reclaimed", heap_stats.gc_bytes_reclaimed as f64)

    stats.total_memory_bytes = stats.total_memory_bytes + heap_stats.used_size
    stats.total_allocations = stats.total_allocations + heap_stats.total_allocations
    stats.total_gc_count = stats.total_gc_count + heap_stats.gc_count

fn collect_lazy_stats(stats: PerfStats):
    """Collect lazy evaluation statistics."""
    val lazy_stats = get_lazy_stats()

    stats.lazy_stats.add_metric("total_created", lazy_stats.total_created as f64)
    stats.lazy_stats.add_metric("total_forced", lazy_stats.total_forced as f64)
    stats.lazy_stats.add_metric("cache_hits", lazy_stats.cache_hits as f64)
    stats.lazy_stats.add_metric("cache_misses", lazy_stats.cache_misses as f64)
    stats.lazy_stats.add_metric("hit_rate", lazy_stats.hit_rate())
    stats.lazy_stats.add_metric("cycles_detected", lazy_stats.cycles_detected as f64)

fn calculate_totals(stats: PerfStats):
    """Calculate total metrics across components."""
    # Memory is already accumulated
    # Additional totals can be calculated here
    pass

fn reset_all_stats():
    """Reset statistics in all subsystems."""
    from ../lazy import {reset_lazy_stats}
    reset_lazy_stats()

    # Note: Other subsystems would need similar reset functions

# ============================================================================
# Formatting Utilities
# ============================================================================

fn format_stats(stats: PerfStats) -> text:
    """Format statistics as human-readable text."""
    stats.summary()

fn format_stats_json(stats: PerfStats) -> text:
    """Format statistics as JSON."""
    var parts: [text] = []
    parts = parts.push("{")
    parts = parts.push("  \"collected_at\": {stats.collected_at},")
    parts = parts.push("  \"total_memory_bytes\": {stats.total_memory_bytes},")
    parts = parts.push("  \"total_allocations\": {stats.total_allocations},")
    parts = parts.push("  \"total_gc_count\": {stats.total_gc_count},")
    parts = parts.push("  \"total_gc_time_ms\": {stats.total_gc_time_ms},")

    # Components
    parts = parts.push("  \"components\": {")
    parts = parts.push("    \"lazy\": {")
    parts = parts.push("      \"hit_rate\": {stats.lazy_stats.get_metric(\"hit_rate\") ?? 0.0}")
    parts = parts.push("    }")
    parts = parts.push("  }")

    parts = parts.push("}")
    parts.join("\n")

fn format_bytes(bytes: i64) -> text:
    """Format bytes as human-readable string."""
    if bytes < 1024:
        "{bytes} B"
    else if bytes < 1024 * 1024:
        val kb = (bytes as f64) / 1024.0
        "{kb:.1} KB"
    else if bytes < 1024 * 1024 * 1024:
        val mb = (bytes as f64) / (1024.0 * 1024.0)
        "{mb:.1} MB"
    else:
        val gb = (bytes as f64) / (1024.0 * 1024.0 * 1024.0)
        "{gb:.2} GB"

# ============================================================================
# Helper Functions
# ============================================================================

fn current_time_ms() -> i64:
    """Get current time in milliseconds (placeholder)."""
    0
