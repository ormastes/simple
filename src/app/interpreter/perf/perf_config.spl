# Performance Configuration
#
# Unified configuration for all performance optimizations.
# Provides predefined profiles for different use cases.

from ../async_runtime import {HeapConfig, MailboxConfig, SchedulerConfig}
from ../memory import {SharedHeapConfig}

export PerfConfig, PerfProfile, OptimizationLevel
export get_config, set_config, GLOBAL_PERF_CONFIG

# ============================================================================
# Optimization Level
# ============================================================================

enum OptimizationLevel:
    """Level of optimization aggressiveness."""
    Minimal     # Minimal optimizations, easier debugging
    Balanced    # Balance between performance and simplicity
    Aggressive  # Maximum performance, higher complexity
    Custom      # User-defined settings

impl OptimizationLevel:
    fn description() -> text:
        match self:
            case Minimal: "Minimal optimizations for debugging"
            case Balanced: "Balanced performance and simplicity"
            case Aggressive: "Maximum performance"
            case Custom: "Custom user settings"

# ============================================================================
# Performance Profile
# ============================================================================

enum PerfProfile:
    """Predefined performance profiles for common use cases."""
    Development     # Fast compilation, easy debugging
    Testing         # Deterministic, reproducible
    Production      # Optimized for throughput
    LowLatency      # Optimized for response time
    HighThroughput  # Optimized for batch processing
    MemoryConstrained  # Minimize memory usage
    ActorHeavy      # Many actors, message-intensive

impl PerfProfile:
    fn to_config() -> PerfConfig:
        """Convert profile to configuration."""
        match self:
            case Development:
                PerfConfig.development()
            case Testing:
                PerfConfig.testing()
            case Production:
                PerfConfig.production()
            case LowLatency:
                PerfConfig.low_latency()
            case HighThroughput:
                PerfConfig.high_throughput()
            case MemoryConstrained:
                PerfConfig.memory_constrained()
            case ActorHeavy:
                PerfConfig.actor_heavy()

    fn description() -> text:
        match self:
            case Development: "Fast iteration, easy debugging"
            case Testing: "Deterministic, reproducible behavior"
            case Production: "Balanced production settings"
            case LowLatency: "Minimize response latency"
            case HighThroughput: "Maximize batch throughput"
            case MemoryConstrained: "Minimize memory footprint"
            case ActorHeavy: "Optimized for many actors"

# ============================================================================
# Performance Configuration
# ============================================================================

struct PerfConfig:
    """Unified performance configuration.

    Controls all optimization subsystems:
    - Symbol interning
    - Persistent collections
    - Actor heaps
    - Message passing
    - Lazy evaluation

    Example:
        # Use predefined profile
        value config = PerfProfile.Production.to_config()

        # Or customize
        value config = PerfConfig.default()
            .with_actor_heap_size(1024 * 1024)
            .with_reductions(4000)
    """
    # Optimization level
    level: OptimizationLevel

    # Symbol interning
    symbol_interning_enabled: bool
    initial_intern_capacity: i64

    # Persistent collections
    persistent_collections_enabled: bool
    hamt_branch_factor: i64  # 32 for standard HAMT

    # Actor heap
    actor_heap_config: HeapConfig
    per_actor_gc_enabled: bool

    # Mailbox
    mailbox_config: MailboxConfig
    off_heap_messages_enabled: bool

    # Scheduler
    scheduler_config: SchedulerConfig

    # Shared heap (for large binaries)
    shared_heap_config: SharedHeapConfig
    large_binary_threshold: i64

    # Lazy evaluation
    lazy_evaluation_enabled: bool
    lazy_cache_size: i64

    # Debugging
    stats_collection_enabled: bool
    detailed_stats: bool

impl PerfConfig:
    # --------------------------------------------------------------------------
    # Predefined Configurations
    # --------------------------------------------------------------------------

    static fn default() -> PerfConfig:
        """Default balanced configuration."""
        PerfConfig(
            level: OptimizationLevel.Balanced,
            symbol_interning_enabled: true,
            initial_intern_capacity: 1024,
            persistent_collections_enabled: true,
            hamt_branch_factor: 32,
            actor_heap_config: HeapConfig.default(),
            per_actor_gc_enabled: true,
            mailbox_config: MailboxConfig.default(),
            off_heap_messages_enabled: true,
            scheduler_config: SchedulerConfig.default(),
            shared_heap_config: SharedHeapConfig.default(),
            large_binary_threshold: 64,
            lazy_evaluation_enabled: true,
            lazy_cache_size: 10000,
            stats_collection_enabled: true,
            detailed_stats: false
        )

    static fn development() -> PerfConfig:
        """Configuration for development - easy debugging."""
        PerfConfig(
            level: OptimizationLevel.Minimal,
            symbol_interning_enabled: true,
            initial_intern_capacity: 256,
            persistent_collections_enabled: false,  # Simpler debugging
            hamt_branch_factor: 32,
            actor_heap_config: HeapConfig.small(),
            per_actor_gc_enabled: false,  # Global GC easier to debug
            mailbox_config: MailboxConfig.default(),
            off_heap_messages_enabled: false,  # Simpler message flow
            scheduler_config: SchedulerConfig.single_threaded(),
            shared_heap_config: SharedHeapConfig.small(),
            large_binary_threshold: 64,
            lazy_evaluation_enabled: true,
            lazy_cache_size: 1000,
            stats_collection_enabled: true,
            detailed_stats: true  # More debugging info
        )

    static fn testing() -> PerfConfig:
        """Configuration for testing - deterministic behavior."""
        PerfConfig(
            level: OptimizationLevel.Minimal,
            symbol_interning_enabled: true,
            initial_intern_capacity: 512,
            persistent_collections_enabled: true,
            hamt_branch_factor: 32,
            actor_heap_config: HeapConfig.default(),
            per_actor_gc_enabled: true,
            mailbox_config: MailboxConfig.bounded(100),  # Bounded for testing
            off_heap_messages_enabled: true,
            scheduler_config: SchedulerConfig.single_threaded(),  # Deterministic
            shared_heap_config: SharedHeapConfig.small(),
            large_binary_threshold: 64,
            lazy_evaluation_enabled: true,
            lazy_cache_size: 1000,
            stats_collection_enabled: true,
            detailed_stats: true
        )

    static fn production() -> PerfConfig:
        """Configuration for production - balanced performance."""
        PerfConfig(
            level: OptimizationLevel.Balanced,
            symbol_interning_enabled: true,
            initial_intern_capacity: 4096,
            persistent_collections_enabled: true,
            hamt_branch_factor: 32,
            actor_heap_config: HeapConfig.default(),
            per_actor_gc_enabled: true,
            mailbox_config: MailboxConfig.default(),
            off_heap_messages_enabled: true,
            scheduler_config: SchedulerConfig.default(),
            shared_heap_config: SharedHeapConfig.default(),
            large_binary_threshold: 64,
            lazy_evaluation_enabled: true,
            lazy_cache_size: 50000,
            stats_collection_enabled: false,  # Reduce overhead
            detailed_stats: false
        )

    static fn low_latency() -> PerfConfig:
        """Configuration for low latency - minimize response time."""
        PerfConfig(
            level: OptimizationLevel.Aggressive,
            symbol_interning_enabled: true,
            initial_intern_capacity: 8192,
            persistent_collections_enabled: true,
            hamt_branch_factor: 32,
            actor_heap_config: HeapConfig.small(),  # Smaller heaps = faster GC
            per_actor_gc_enabled: true,
            mailbox_config: MailboxConfig.with_priority(),  # Priority support
            off_heap_messages_enabled: true,
            scheduler_config: SchedulerConfig.low_latency(),
            shared_heap_config: SharedHeapConfig.default(),
            large_binary_threshold: 32,  # More aggressive sharing
            lazy_evaluation_enabled: true,
            lazy_cache_size: 100000,
            stats_collection_enabled: false,
            detailed_stats: false
        )

    static fn high_throughput() -> PerfConfig:
        """Configuration for high throughput - batch processing."""
        PerfConfig(
            level: OptimizationLevel.Aggressive,
            symbol_interning_enabled: true,
            initial_intern_capacity: 16384,
            persistent_collections_enabled: true,
            hamt_branch_factor: 32,
            actor_heap_config: HeapConfig.large(),  # Larger heaps = less GC
            per_actor_gc_enabled: true,
            mailbox_config: MailboxConfig.unlimited(),  # No backpressure
            off_heap_messages_enabled: true,
            scheduler_config: SchedulerConfig.high_throughput(),
            shared_heap_config: SharedHeapConfig.large(),
            large_binary_threshold: 128,  # Higher threshold
            lazy_evaluation_enabled: true,
            lazy_cache_size: 200000,
            stats_collection_enabled: false,
            detailed_stats: false
        )

    static fn memory_constrained() -> PerfConfig:
        """Configuration for memory-constrained environments."""
        PerfConfig(
            level: OptimizationLevel.Balanced,
            symbol_interning_enabled: true,  # Saves memory via deduplication
            initial_intern_capacity: 512,
            persistent_collections_enabled: true,  # Structural sharing saves memory
            hamt_branch_factor: 32,
            actor_heap_config: HeapConfig.small(),
            per_actor_gc_enabled: true,
            mailbox_config: MailboxConfig.bounded(50),  # Small mailboxes
            off_heap_messages_enabled: false,  # Reduce memory pools
            scheduler_config: SchedulerConfig.single_threaded(),
            shared_heap_config: SharedHeapConfig.small(),
            large_binary_threshold: 32,  # More sharing
            lazy_evaluation_enabled: true,  # Deferred allocation
            lazy_cache_size: 1000,  # Small cache
            stats_collection_enabled: false,
            detailed_stats: false
        )

    static fn actor_heavy() -> PerfConfig:
        """Configuration for actor-heavy workloads."""
        PerfConfig(
            level: OptimizationLevel.Aggressive,
            symbol_interning_enabled: true,
            initial_intern_capacity: 4096,
            persistent_collections_enabled: true,
            hamt_branch_factor: 32,
            actor_heap_config: HeapConfig.small(),  # Many small heaps
            per_actor_gc_enabled: true,  # Critical for many actors
            mailbox_config: MailboxConfig.with_priority(),
            off_heap_messages_enabled: true,  # Critical for message throughput
            scheduler_config: SchedulerConfig.default(),
            shared_heap_config: SharedHeapConfig.large(),  # Shared data
            large_binary_threshold: 64,
            lazy_evaluation_enabled: true,
            lazy_cache_size: 50000,
            stats_collection_enabled: false,
            detailed_stats: false
        )

    # --------------------------------------------------------------------------
    # Builder Methods
    # --------------------------------------------------------------------------

    fn with_optimization_level(level: OptimizationLevel) -> PerfConfig:
        PerfConfig(
            level: level,
            symbol_interning_enabled: self.symbol_interning_enabled,
            initial_intern_capacity: self.initial_intern_capacity,
            persistent_collections_enabled: self.persistent_collections_enabled,
            hamt_branch_factor: self.hamt_branch_factor,
            actor_heap_config: self.actor_heap_config,
            per_actor_gc_enabled: self.per_actor_gc_enabled,
            mailbox_config: self.mailbox_config,
            off_heap_messages_enabled: self.off_heap_messages_enabled,
            scheduler_config: self.scheduler_config,
            shared_heap_config: self.shared_heap_config,
            large_binary_threshold: self.large_binary_threshold,
            lazy_evaluation_enabled: self.lazy_evaluation_enabled,
            lazy_cache_size: self.lazy_cache_size,
            stats_collection_enabled: self.stats_collection_enabled,
            detailed_stats: self.detailed_stats
        )

    fn with_actor_heap_size(size: i64) -> PerfConfig:
        value new_heap_config = HeapConfig(
            initial_size: size,
            max_size: size * 4,
            gc_enabled: self.actor_heap_config.gc_enabled,
            generational: self.actor_heap_config.generational,
            pretenure_threshold: self.actor_heap_config.pretenure_threshold
        )
        PerfConfig(
            level: self.level,
            symbol_interning_enabled: self.symbol_interning_enabled,
            initial_intern_capacity: self.initial_intern_capacity,
            persistent_collections_enabled: self.persistent_collections_enabled,
            hamt_branch_factor: self.hamt_branch_factor,
            actor_heap_config: new_heap_config,
            per_actor_gc_enabled: self.per_actor_gc_enabled,
            mailbox_config: self.mailbox_config,
            off_heap_messages_enabled: self.off_heap_messages_enabled,
            scheduler_config: self.scheduler_config,
            shared_heap_config: self.shared_heap_config,
            large_binary_threshold: self.large_binary_threshold,
            lazy_evaluation_enabled: self.lazy_evaluation_enabled,
            lazy_cache_size: self.lazy_cache_size,
            stats_collection_enabled: self.stats_collection_enabled,
            detailed_stats: self.detailed_stats
        )

    fn with_reductions(reductions: i64) -> PerfConfig:
        value new_scheduler = SchedulerConfig(
            reductions_per_timeslice: reductions,
            max_run_queue_length: self.scheduler_config.max_run_queue_length,
            scheduler_count: self.scheduler_config.scheduler_count,
            work_stealing_enabled: self.scheduler_config.work_stealing_enabled,
            priority_scheduling: self.scheduler_config.priority_scheduling
        )
        PerfConfig(
            level: self.level,
            symbol_interning_enabled: self.symbol_interning_enabled,
            initial_intern_capacity: self.initial_intern_capacity,
            persistent_collections_enabled: self.persistent_collections_enabled,
            hamt_branch_factor: self.hamt_branch_factor,
            actor_heap_config: self.actor_heap_config,
            per_actor_gc_enabled: self.per_actor_gc_enabled,
            mailbox_config: self.mailbox_config,
            off_heap_messages_enabled: self.off_heap_messages_enabled,
            scheduler_config: new_scheduler,
            shared_heap_config: self.shared_heap_config,
            large_binary_threshold: self.large_binary_threshold,
            lazy_evaluation_enabled: self.lazy_evaluation_enabled,
            lazy_cache_size: self.lazy_cache_size,
            stats_collection_enabled: self.stats_collection_enabled,
            detailed_stats: self.detailed_stats
        )

    fn with_stats_enabled(enabled: bool) -> PerfConfig:
        PerfConfig(
            level: self.level,
            symbol_interning_enabled: self.symbol_interning_enabled,
            initial_intern_capacity: self.initial_intern_capacity,
            persistent_collections_enabled: self.persistent_collections_enabled,
            hamt_branch_factor: self.hamt_branch_factor,
            actor_heap_config: self.actor_heap_config,
            per_actor_gc_enabled: self.per_actor_gc_enabled,
            mailbox_config: self.mailbox_config,
            off_heap_messages_enabled: self.off_heap_messages_enabled,
            scheduler_config: self.scheduler_config,
            shared_heap_config: self.shared_heap_config,
            large_binary_threshold: self.large_binary_threshold,
            lazy_evaluation_enabled: self.lazy_evaluation_enabled,
            lazy_cache_size: self.lazy_cache_size,
            stats_collection_enabled: enabled,
            detailed_stats: self.detailed_stats
        )

    fn with_large_binary_threshold(threshold: i64) -> PerfConfig:
        PerfConfig(
            level: self.level,
            symbol_interning_enabled: self.symbol_interning_enabled,
            initial_intern_capacity: self.initial_intern_capacity,
            persistent_collections_enabled: self.persistent_collections_enabled,
            hamt_branch_factor: self.hamt_branch_factor,
            actor_heap_config: self.actor_heap_config,
            per_actor_gc_enabled: self.per_actor_gc_enabled,
            mailbox_config: self.mailbox_config,
            off_heap_messages_enabled: self.off_heap_messages_enabled,
            scheduler_config: self.scheduler_config,
            shared_heap_config: self.shared_heap_config,
            large_binary_threshold: threshold,
            lazy_evaluation_enabled: self.lazy_evaluation_enabled,
            lazy_cache_size: self.lazy_cache_size,
            stats_collection_enabled: self.stats_collection_enabled,
            detailed_stats: self.detailed_stats
        )

impl Display for PerfConfig:
    fn fmt() -> text:
        "PerfConfig(level={self.level}, actors={self.per_actor_gc_enabled}, lazy={self.lazy_evaluation_enabled})"

# ============================================================================
# Global Configuration
# ============================================================================

var GLOBAL_PERF_CONFIG: PerfConfig = PerfConfig.default()

fn get_config() -> PerfConfig:
    """Get the current global performance configuration."""
    GLOBAL_PERF_CONFIG

fn set_config(config: PerfConfig):
    """Set the global performance configuration."""
    GLOBAL_PERF_CONFIG = config

fn apply_profile(profile: PerfProfile):
    """Apply a predefined performance profile."""
    GLOBAL_PERF_CONFIG = profile.to_config()
