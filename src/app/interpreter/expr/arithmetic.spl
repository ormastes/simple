# Arithmetic Operations
#
# Binary operators: +, -, *, /, %, **
# Unary operators: -, +, not

from ..core import {Value, InterpreterError}
from shared.operators import {eval_int_int, eval_float_float, eval_string_string, int_pow}
from shared.operators import {TruthinessRules, TypeCoercion, NumericType}

export eval_binary_op, eval_unary_op

# Binary operation evaluation
fn eval_binary_op(op: &BinOp, left: Value, right: Value) -> Result<Value, InterpreterError>:
    match op:
        case BinOp.Add:
            return eval_add(left, right)
        case BinOp.Sub:
            return eval_sub(left, right)
        case BinOp.Mul:
            return eval_mul(left, right)
        case BinOp.Div:
            return eval_div(left, right)
        case BinOp.Mod:
            return eval_mod(left, right)
        case BinOp.Pow:
            return eval_pow(left, right)
        case BinOp.Eq:
            return eval_eq(left, right)
        case BinOp.Ne:
            return eval_ne(left, right)
        case BinOp.Lt:
            return eval_lt(left, right)
        case BinOp.Le:
            return eval_le(left, right)
        case BinOp.Gt:
            return eval_gt(left, right)
        case BinOp.Ge:
            return eval_ge(left, right)
        case BinOp.And:
            return eval_and(left, right)
        case BinOp.Or:
            return eval_or(left, right)
        case _:
            return Err(InterpreterError.NotImplemented("binary op".to_string()))

# Unary operation evaluation
fn eval_unary_op(op: &UnaryOp, value: Value) -> Result<Value, InterpreterError>:
    match op:
        case UnaryOp.Neg:
            return eval_neg(value)
        case UnaryOp.Not:
            return eval_not(value)
        case UnaryOp.Pos:
            return Ok(value)
        case UnaryOp.Move:
            # Move is a semantic marker for explicit ownership transfer
            # In the interpreter, it's a no-op - ownership tracking happens elsewhere
            return Ok(value)
        case _:
            return Err(InterpreterError.NotImplemented("unary op".to_string()))

# Addition
fn eval_add(left: Value, right: Value) -> Result<Value, InterpreterError>:
    match (left.as_int(), right.as_int()):
        case (Some(l), Some(r)):
            return Ok(Value.int(l + r))
        case _:
            pass

    match (left.as_float(), right.as_float()):
        case (Some(l), Some(r)):
            return Ok(Value.float(l + r))
        case _:
            pass

    match (left.as_string(), right.as_string()):
        case (Some(l), Some(r)):
            return Ok(Value.string(l.clone() + r))
        case _:
            pass

    return Err(InterpreterError.TypeError("cannot add these types".to_string()))

# Subtraction
fn eval_sub(left: Value, right: Value) -> Result<Value, InterpreterError>:
    match (left.as_int(), right.as_int()):
        case (Some(l), Some(r)):
            return Ok(Value.int(l - r))
        case _:
            pass

    match (left.as_float(), right.as_float()):
        case (Some(l), Some(r)):
            return Ok(Value.float(l - r))
        case _:
            pass

    return Err(InterpreterError.TypeError("cannot subtract these types".to_string()))

# Multiplication
fn eval_mul(left: Value, right: Value) -> Result<Value, InterpreterError>:
    match (left.as_int(), right.as_int()):
        case (Some(l), Some(r)):
            return Ok(Value.int(l * r))
        case _:
            pass

    match (left.as_float(), right.as_float()):
        case (Some(l), Some(r)):
            return Ok(Value.float(l * r))
        case _:
            pass

    return Err(InterpreterError.TypeError("cannot multiply these types".to_string()))

# Division
fn eval_div(left: Value, right: Value) -> Result<Value, InterpreterError>:
    match (left.as_int(), right.as_int()):
        case (Some(l), Some(r)):
            if r == 0:
                return Err(InterpreterError.DivisionByZero)
            return Ok(Value.int(l / r))
        case _:
            pass

    match (left.as_float(), right.as_float()):
        case (Some(l), Some(r)):
            if r == 0.0:
                return Err(InterpreterError.DivisionByZero)
            return Ok(Value.float(l / r))
        case _:
            pass

    return Err(InterpreterError.TypeError("cannot divide these types".to_string()))

# Modulo
fn eval_mod(left: Value, right: Value) -> Result<Value, InterpreterError>:
    match (left.as_int(), right.as_int()):
        case (Some(l), Some(r)):
            if r == 0:
                return Err(InterpreterError.DivisionByZero)
            return Ok(Value.int(l % r))
        case _:
            return Err(InterpreterError.TypeError("modulo requires integers".to_string()))

# Power
fn eval_pow(left: Value, right: Value) -> Result<Value, InterpreterError>:
    match (left.as_float(), right.as_float()):
        case (Some(l), Some(r)):
            return Ok(Value.float(l.pow(r)))
        case _:
            return Err(InterpreterError.TypeError("power requires numbers".to_string()))

# Negation
fn eval_neg(value: Value) -> Result<Value, InterpreterError>:
    match value.as_int():
        case Some(n):
            return Ok(Value.int(-n))
        case _:
            pass

    match value.as_float():
        case Some(f):
            return Ok(Value.float(-f))
        case _:
            pass

    return Err(InterpreterError.TypeError("cannot negate this type".to_string()))

# Logical not
fn eval_not(value: Value) -> Result<Value, InterpreterError>:
    return Ok(Value.bool(not value.is_truthy()))

# Comparison operations
fn eval_eq(left: Value, right: Value) -> Result<Value, InterpreterError>:
    # Deep equality comparison for all value types
    val is_equal = values_equal(left, right)
    return Ok(Value.bool(is_equal))

# Deep equality helper
fn values_equal(left: Value, right: Value) -> bool:
    # Different kinds are not equal
    if left.kind != right.kind:
        return false

    match (left.data, right.data):
        # Nil
        case (RuntimeValue.Nil, RuntimeValue.Nil):
            return true

        # Bool
        case (RuntimeValue.Bool(l), RuntimeValue.Bool(r)):
            return l == r

        # Int
        case (RuntimeValue.Int(l), RuntimeValue.Int(r)):
            return l == r

        # Float
        case (RuntimeValue.Float(l), RuntimeValue.Float(r)):
            return l == r

        # String
        case (RuntimeValue.String(l), RuntimeValue.String(r)):
            return l == r

        # Array - deep comparison
        case (RuntimeValue.Array(l_arr), RuntimeValue.Array(r_arr)):
            if l_arr.len() != r_arr.len():
                return false
            var i = 0
            while i < l_arr.len():
                if not values_equal(l_arr[i], r_arr[i]):
                    return false
                i = i + 1
            return true

        # Tuple - deep comparison
        case (RuntimeValue.Tuple(l_items), RuntimeValue.Tuple(r_items)):
            if l_items.len() != r_items.len():
                return false
            var i = 0
            while i < l_items.len():
                if not values_equal(l_items[i], r_items[i]):
                    return false
                i = i + 1
            return true

        # Struct - compare name and fields
        case (RuntimeValue.Struct(l_name, l_fields),
              RuntimeValue.Struct(r_name, r_fields)):
            if l_name != r_name:
                return false
            if l_fields.len() != r_fields.len():
                return false
            # Compare all fields
            for (key, l_val) in l_fields:
                match r_fields.get(key):
                    case Some(r_val):
                        if not values_equal(l_val, r_val):
                            return false
                    case nil:
                        return false
            return true

        # Enum - compare variant and data
        case (RuntimeValue.Enum(l_var, l_data),
              RuntimeValue.Enum(r_var, r_data)):
            if l_var != r_var:
                return false
            match (l_data, r_data):
                case (Some(l_box), Some(r_box)):
                    return values_equal(*l_box, *r_box)
                case (nil, nil):
                    return true
                case _:
                    return false

        # Function - compare by name (reference equality)
        case (RuntimeValue.Function(l_name, _, _),
              RuntimeValue.Function(r_name, _, _)):
            return l_name == r_name

        # Object - compare class and fields
        case (RuntimeValue.Object(l_class, l_fields),
              RuntimeValue.Object(r_class, r_fields)):
            if l_class != r_class:
                return false
            if l_fields.len() != r_fields.len():
                return false
            for (key, l_val) in l_fields:
                match r_fields.get(key):
                    case Some(r_val):
                        if not values_equal(l_val, r_val):
                            return false
                    case nil:
                        return false
            return true

        # Dict - deep comparison of key-value pairs
        case (RuntimeValue.Dict(l_dict), RuntimeValue.Dict(r_dict)):
            if l_dict.len() != r_dict.len():
                return false
            # Note: This is a simplified comparison
            # Full dict comparison would need to compare keys and values
            # For now, we compare string representations
            return l_dict.to_string() == r_dict.to_string()

        # Closure - compare by reference (not deep equality)
        case (RuntimeValue.Closure(_, _), RuntimeValue.Closure(_, _)):
            # Closures are compared by reference, not value
            return false

        # Default: not equal
        case _:
            return false

fn eval_ne(left: Value, right: Value) -> Result<Value, InterpreterError>:
    val eq = eval_eq(left, right)?
    return eval_not(eq)

fn eval_lt(left: Value, right: Value) -> Result<Value, InterpreterError>:
    match (left.as_int(), right.as_int()):
        case (Some(l), Some(r)):
            return Ok(Value.bool(l < r))
        case _:
            pass
    match (left.as_float(), right.as_float()):
        case (Some(l), Some(r)):
            return Ok(Value.bool(l < r))
        case _:
            pass
    return Err(InterpreterError.TypeError("cannot compare these types".to_string()))

fn eval_le(left: Value, right: Value) -> Result<Value, InterpreterError>:
    match (left.as_int(), right.as_int()):
        case (Some(l), Some(r)):
            return Ok(Value.bool(l <= r))
        case _:
            pass
    match (left.as_float(), right.as_float()):
        case (Some(l), Some(r)):
            return Ok(Value.bool(l <= r))
        case _:
            pass
    return Err(InterpreterError.TypeError("cannot compare these types".to_string()))

fn eval_gt(left: Value, right: Value) -> Result<Value, InterpreterError>:
    match (left.as_int(), right.as_int()):
        case (Some(l), Some(r)):
            return Ok(Value.bool(l > r))
        case _:
            pass
    match (left.as_float(), right.as_float()):
        case (Some(l), Some(r)):
            return Ok(Value.bool(l > r))
        case _:
            pass
    return Err(InterpreterError.TypeError("cannot compare these types".to_string()))

fn eval_ge(left: Value, right: Value) -> Result<Value, InterpreterError>:
    match (left.as_int(), right.as_int()):
        case (Some(l), Some(r)):
            return Ok(Value.bool(l >= r))
        case _:
            pass
    match (left.as_float(), right.as_float()):
        case (Some(l), Some(r)):
            return Ok(Value.bool(l >= r))
        case _:
            pass
    return Err(InterpreterError.TypeError("cannot compare these types".to_string()))

# Logical operations
fn eval_and(left: Value, right: Value) -> Result<Value, InterpreterError>:
    if not left.is_truthy():
        return Ok(left)
    return Ok(right)

fn eval_or(left: Value, right: Value) -> Result<Value, InterpreterError>:
    if left.is_truthy():
        return Ok(left)
    return Ok(right)
