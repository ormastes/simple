# Function and Method Calls
#
# Call evaluation, argument binding, method dispatch.

import ..core.{Interpreter, Value, InterpreterError, RuntimeValue}
from ..core.symbol import {intern}
from . import {evaluate}

export eval_call, eval_method_call

# Evaluate a function call
fn eval_call(interp: &Interpreter, callee: &Expr, args: &Array<Expr>) -> Result<Value, InterpreterError>:
    # Evaluate the callee
    value func = evaluate(interp, callee)?

    # Evaluate arguments
    value arg_values: Array<Value> = []
    for arg in args:
        value value = evaluate(interp, arg)?
        arg_values.push(value)

    # Call the function
    return call_value(interp, func, arg_values)

# Evaluate a method call
fn eval_method_call(interp: &Interpreter, obj_expr: &Expr, method: &str, args: &Array<Expr>) -> Result<Value, InterpreterError>:
    # Evaluate the object
    value obj = evaluate(interp, obj_expr)?

    # Evaluate arguments
    value arg_values: Array<Value> = []
    for arg in args:
        value value = evaluate(interp, arg)?
        arg_values.push(value)

    # Dispatch the method
    return call_method(interp, obj, method, arg_values)

# Call a value as a function
fn call_value(interp: &Interpreter, func: Value, args: Array<Value>) -> Result<Value, InterpreterError>:
    match func.data:
        case RuntimeValue.Function { name, params, body }:
            return call_function(interp, &name, &params, &body, args)

        case RuntimeValue.Closure { func, env }:
            return call_closure(interp, &func, &env, args)

        case _:
            return Err(InterpreterError.TypeError("not callable".to_string()))

# Call a user-defined function
fn call_function(interp: &Interpreter, name: &str, params: &Array<String>, body: &Block, args: Array<Value>) -> Result<Value, InterpreterError>:
    # Check arity
    if args.len() != params.len():
        return Err(InterpreterError.ArityError {
            expected: params.len(),
            got: args.len()
        })

    # Create new scope
    interp.env.push_scope()

    # Bind parameters (use interned symbols for performance)
    for i in 0..params.len():
        interp.env.define_str(params[i], args[i].clone())

    # Execute body
    value result = interp.eval_block(body)

    # Pop scope
    interp.env.pop_scope()

    return result

# Call a closure
fn call_closure(interp: &Interpreter, func: &RuntimeValue, captured_env: &Environment, args: Array<Value>) -> Result<Value, InterpreterError>:
    match func:
        case RuntimeValue.Closure { params, body, env: _ }:
            # Check arity
            if args.len() != params.len():
                return Err(InterpreterError.ArityError {
                    expected: params.len(),
                    got: args.len()
                })

            # Save current environment
            value saved_env = interp.env.clone()

            # Restore captured environment
            interp.env = captured_env.clone()

            # Create new scope for parameters
            interp.env.push_scope()

            # Bind parameters (use interned symbols for performance)
            for i in 0..params.len():
                interp.env.define_str(params[i], args[i].clone())

            # Execute body
            value result = evaluate(interp, body)

            # Restore original environment
            interp.env.pop_scope()
            interp.env = saved_env

            return result

        case _:
            return Err(InterpreterError.TypeError("expected closure".to_string()))

# Call a method on an object
fn call_method(interp: &Interpreter, obj: Value, method: &str, args: Array<Value>) -> Result<Value, InterpreterError>:
    match obj.data:
        case RuntimeValue.Object { class, fields }:
            return call_object_method(interp, &class, &fields, method, args)

        case RuntimeValue.Array(arr):
            return call_array_method(interp, &arr, method, args)

        case RuntimeValue.String(s):
            return call_string_method(interp, &s, method, args)

        case RuntimeValue.Dict(d):
            return call_dict_method(interp, &d, method, args)

        case _:
            return Err(InterpreterError.TypeError("no methods on this type".to_string()))

# Built-in array methods
fn call_array_method(interp: &Interpreter, arr: &Array<Value>, method: &str, args: Array<Value>) -> Result<Value, InterpreterError>:
    match method:
        case "len":
            return Ok(Value.int(arr.len() as i64))

        case "push":
            if args.len() != 1:
                return Err(InterpreterError.ArityError { expected: 1, got: args.len() })
            # Note: Would need mutable reference
            return Err(InterpreterError.NotImplemented("array.push".to_string()))

        case "pop":
            return Err(InterpreterError.NotImplemented("array.pop".to_string()))

        case "is_empty":
            return Ok(Value.bool(arr.is_empty()))

        case _:
            return Err(InterpreterError.AttributeError(method.to_string()))

# Built-in string methods
fn call_string_method(interp: &Interpreter, s: &String, method: &str, args: Array<Value>) -> Result<Value, InterpreterError>:
    match method:
        case "len":
            return Ok(Value.int(s.len() as i64))

        case "is_empty":
            return Ok(Value.bool(s.is_empty()))

        case "contains":
            if args.len() != 1:
                return Err(InterpreterError.ArityError { expected: 1, got: args.len() })
            match args[0].as_string():
                case Some(sub):
                    return Ok(Value.bool(s.contains(sub)))
                case _:
                    return Err(InterpreterError.TypeError("contains requires string".to_string()))

        case "starts_with":
            if args.len() != 1:
                return Err(InterpreterError.ArityError { expected: 1, got: args.len() })
            match args[0].as_string():
                case Some(prefix):
                    return Ok(Value.bool(s.starts_with(prefix)))
                case _:
                    return Err(InterpreterError.TypeError("starts_with requires string".to_string()))

        case "ends_with":
            if args.len() != 1:
                return Err(InterpreterError.ArityError { expected: 1, got: args.len() })
            match args[0].as_string():
                case Some(suffix):
                    return Ok(Value.bool(s.ends_with(suffix)))
                case _:
                    return Err(InterpreterError.TypeError("ends_with requires string".to_string()))

        case "to_upper":
            return Ok(Value.string(s.upper()))

        case "to_lower":
            return Ok(Value.string(s.lower()))

        case "trim":
            return Ok(Value.string(s.trim().to_string()))

        case "split":
            if args.len() != 1:
                return Err(InterpreterError.ArityError { expected: 1, got: args.len() })
            match args[0].as_string():
                case Some(sep):
                    value parts: Array<Value> = s.split(sep).map(|p| Value.string(p.to_string())).collect()
                    return Ok(Value.array(parts))
                case _:
                    return Err(InterpreterError.TypeError("split requires string".to_string()))

        case _:
            return Err(InterpreterError.AttributeError(method.to_string()))

# Built-in dict methods
fn call_dict_method(interp: &Interpreter, d: &Dict<Value, Value>, method: &str, args: Array<Value>) -> Result<Value, InterpreterError>:
    match method:
        case "len":
            return Ok(Value.int(d.len() as i64))

        case "is_empty":
            return Ok(Value.bool(d.is_empty()))

        case "contains_key":
            if args.len() != 1:
                return Err(InterpreterError.ArityError { expected: 1, got: args.len() })
            return Ok(Value.bool(d.contains_key(&args[0])))

        case "keys":
            value keys: Array<Value> = d.keys().cloned().collect()
            return Ok(Value.array(keys))

        case "values":
            value values: Array<Value> = d.values().cloned().collect()
            return Ok(Value.array(values))

        case _:
            return Err(InterpreterError.AttributeError(method.to_string()))

# Call method on object instance
fn call_object_method(interp: &Interpreter, class: &str, fields: &Dict<String, Value>, method: &str, args: Array<Value>) -> Result<Value, InterpreterError>:
    # Look up method in class definition from environment
    value class_name = class.to_string()
    value method_key = "{class_name}.{method}"

    # Try to find method in environment (class methods are stored as "ClassName.method_name")
    match interp.env.get(&method_key):
        case Some(func_value):
            # Create self object
            value self_obj = Value {
                kind: ValueKind.Object,
                data: RuntimeValue.Object {
                    class: class_name.clone(),
                    fields: fields.clone()
                }
            }
            # Prepend self to arguments
            var full_args = [self_obj]
            for arg in args:
                full_args.push(arg)
            # Call the method
            return call_value(interp, func_value, full_args)

        case None:
            # Try builtin methods for common operations
            match method:
                case "to_string":
                    value s = format_object(class, fields)
                    return Ok(Value.string(s))
                case "clone":
                    return Ok(Value {
                        kind: ValueKind.Object,
                        data: RuntimeValue.Object {
                            class: class_name,
                            fields: fields.clone()
                        }
                    })
                case _:
                    return Err(InterpreterError.AttributeError(
                        "method '{method}' not found on class '{class}'".to_string()
                    ))

# Format object for display
fn format_object(class: &str, fields: &Dict<String, Value>) -> String:
    var parts: Array<String> = []
    for (key, value) in fields.iter():
        parts.push("{key}: {value.to_debug_string()}")
    return "{class} {{ {parts.join(\", \")} }}"
