# Advanced Expression Evaluation
#
# FString, Range, Slice, Comprehension, OptionalChaining,
# NullCoalescing, Await, Spawn, Ternary, TypeCheck, Assignment,
# Pipe, Compose operators.
# Port of expression cases from rust/compiler/src/interpreter*.rs

from ..core import {Interpreter, Value, InterpreterError}
from . import {evaluate}

export eval_fstring, eval_range, eval_slice, eval_comprehension
export eval_optional_chain, eval_null_coalesce
export eval_await, eval_spawn, eval_ternary
export eval_type_check, eval_type_cast
export eval_pipe, eval_compose
export eval_set, eval_assignment
export eval_enum_variant, eval_struct_literal

# ================================================================
# Format Strings
# ================================================================

# Evaluate an f-string with interpolated expressions
fn eval_fstring(interp: Interpreter, parts: [FStringPart]) -> Result<Value, InterpreterError>:
    var result = ""
    for part in parts:
        match part:
            case FStringPart.Literal(s):
                result = result + s
            case FStringPart.Expr(expr):
                val value = evaluate(interp, expr)?
                result = result + value.to_display_string()
            case FStringPart.ExprFormatted(expr, format_spec):
                val value = evaluate(interp, expr)?
                result = result + format_value(value, format_spec)
    Ok(Value.string(result))

# Format a value with a format specifier
fn format_value(value: Value, spec: text) -> text:
    # Basic format specs: d=int, f=float, s=string, x=hex, o=octal, b=binary
    match spec:
        case "d": value.to_int_string()
        case "s": value.to_display_string()
        case "x": value.to_hex_string()
        case "o": value.to_octal_string()
        case "b": value.to_binary_string()
        case _:
            # Check for precision format like ".2f"
            if spec.ends_with("f") and spec.starts_with("."):
                val precision = spec[1:-1].parse_int() ?? 6
                value.to_float_string(precision)
            else:
                value.to_display_string()

# ================================================================
# Ranges
# ================================================================

# Evaluate a range expression (start..end or start..=end)
fn eval_range(interp: Interpreter, start: Expr, end: Expr, inclusive: bool) -> Result<Value, InterpreterError>:
    val start_val = evaluate(interp, start)?
    val end_val = evaluate(interp, end)?

    match (start_val.as_int(), end_val.as_int()):
        case (Some(s), Some(e)):
            if inclusive:
                val items = [for i in s..=e: Value.int(i)]
                Ok(Value.array(items))
            else:
                val items = [for i in s..e: Value.int(i)]
                Ok(Value.array(items))
        case _:
            Err(InterpreterError.TypeError("range requires integer bounds"))

# ================================================================
# Slicing
# ================================================================

# Evaluate a slice expression: collection[start:end:step]
fn eval_slice(interp: Interpreter, collection: Value, start: Value?, end: Value?, step: Value?) -> Result<Value, InterpreterError>:
    val len = collection.len_or_error()?

    # Resolve start index
    val s = if start.?:
        val sv = start.unwrap().as_int() ?? 0
        normalize_index(sv, len)
    else:
        0

    # Resolve end index
    val e = if end.?:
        val ev = end.unwrap().as_int() ?? len
        normalize_index(ev, len)
    else:
        len

    # Resolve step
    val st = if step.?:
        step.unwrap().as_int() ?? 1
    else:
        1

    if st == 0:
        return Err(InterpreterError.ValueError("slice step cannot be zero"))

    collection.slice(s, e, st)

# Normalize a negative index
fn normalize_index(index: i64, length: i64) -> i64:
    if index < 0:
        val normalized = length + index
        if normalized < 0: 0 else: normalized
    else:
        if index > length: length else: index

# ================================================================
# Comprehensions
# ================================================================

# Evaluate a list comprehension: [for x in iter if cond: expr]
fn eval_comprehension(interp: Interpreter, binding: text, iterable: Expr,
                      filter: Expr?, body: Expr) -> Result<Value, InterpreterError>:
    val iter_val = evaluate(interp, iterable)?
    val items = iter_val.to_iterable()?
    var result = []

    for item in items:
        interp.env.push_scope()
        interp.env.define(binding, item)

        val include = if filter.?:
            val cond = evaluate(interp, filter.unwrap())?
            cond.is_truthy()
        else:
            true

        if include:
            val value = evaluate(interp, body)?
            result.push(value)

        interp.env.pop_scope()

    Ok(Value.array(result))

# ================================================================
# Optional Chaining and Null Coalescing
# ================================================================

# Evaluate optional chaining: expr?.field or expr?.method()
fn eval_optional_chain(interp: Interpreter, base: Expr, chain: text) -> Result<Value, InterpreterError>:
    val base_val = evaluate(interp, base)?
    if base_val.is_nil():
        Ok(Value.nil())
    else:
        # Delegate to field access
        base_val.get_field(chain)

# Evaluate null coalescing: expr ?? default
fn eval_null_coalesce(interp: Interpreter, expr: Expr, default: Expr) -> Result<Value, InterpreterError>:
    val value = evaluate(interp, expr)?
    if value.is_nil() or value.is_none():
        evaluate(interp, default)
    else:
        Ok(value)

# ================================================================
# Async: Await and Spawn
# ================================================================

# Evaluate an await expression
fn eval_await(interp: Interpreter, expr: Expr) -> Result<Value, InterpreterError>:
    val promise = evaluate(interp, expr)?
    match promise:
        case Value.Promise(p):
            p.await_result()
        case _:
            # If not a promise, return as-is (like awaiting a resolved value)
            Ok(promise)

# Evaluate spawn expression (creates a future/promise)
fn eval_spawn(interp: Interpreter, expr: Expr) -> Result<Value, InterpreterError>:
    # In interpreter mode, spawn creates a deferred computation
    # The actual threading is handled by the runtime
    val thunk = Value.thunk(expr, interp.env.clone())
    Ok(Value.promise(thunk))

# ================================================================
# Ternary Expression
# ================================================================

# Evaluate ternary: condition ? then_expr : else_expr
fn eval_ternary(interp: Interpreter, condition: Expr, then_expr: Expr, else_expr: Expr) -> Result<Value, InterpreterError>:
    val cond = evaluate(interp, condition)?
    if cond.is_truthy():
        evaluate(interp, then_expr)
    else:
        evaluate(interp, else_expr)

# ================================================================
# Type Checking and Casting
# ================================================================

# Evaluate type check: value is Type
fn eval_type_check(interp: Interpreter, expr: Expr, type_name: text) -> Result<Value, InterpreterError>:
    if type_name == "Any":
        evaluate(interp, expr)?
        return Ok(Value.bool(true))
    val value = evaluate(interp, expr)?
    val matches = value.matches_type(type_name)
    Ok(Value.bool(matches))

# Evaluate type cast: value as Type
fn eval_type_cast(interp: Interpreter, expr: Expr, type_name: text) -> Result<Value, InterpreterError>:
    val value = evaluate(interp, expr)?
    if type_name == "Any" or type_name.contains("Any"):
        return Ok(value)
    value.cast_to(type_name)

# ================================================================
# Pipeline Operators
# ================================================================

# Evaluate pipe forward: value |> function
fn eval_pipe(interp: Interpreter, value: Expr, func: Expr) -> Result<Value, InterpreterError>:
    val v = evaluate(interp, value)?
    val f = evaluate(interp, func)?
    # Call f with v as the single argument
    interp.call_value(f, [v])

# Evaluate compose: f >> g (forward composition)
fn eval_compose(interp: Interpreter, f_expr: Expr, g_expr: Expr) -> Result<Value, InterpreterError>:
    val f = evaluate(interp, f_expr)?
    val g = evaluate(interp, g_expr)?
    # Return a new function that applies f then g
    Ok(Value.composed_function(f, g))

# ================================================================
# Set Literal
# ================================================================

fn eval_set(interp: Interpreter, elements: [Expr]) -> Result<Value, InterpreterError>:
    var values = []
    for elem in elements:
        val value = evaluate(interp, elem)?
        values.push(value)
    Ok(Value.set(values))

# ================================================================
# Assignment Expression
# ================================================================

# Evaluate assignment: name = value (returns unit)
fn eval_assignment(interp: Interpreter, target: Expr, value: Expr) -> Result<Value, InterpreterError>:
    val rhs = evaluate(interp, value)?
    match target:
        case Expr.Identifier(name):
            interp.env.set(name, rhs)
            Ok(Value.nil())
        case Expr.Field(obj_expr, field):
            val obj = evaluate(interp, obj_expr)?
            obj.set_field(field, rhs)?
            Ok(Value.nil())
        case Expr.Index(coll_expr, idx_expr):
            val coll = evaluate(interp, coll_expr)?
            val idx = evaluate(interp, idx_expr)?
            coll.set_index(idx, rhs)?
            Ok(Value.nil())
        case _:
            Err(InterpreterError.TypeError("invalid assignment target"))

# ================================================================
# Enum Variant Construction
# ================================================================

# Evaluate EnumName.VariantName or EnumName.VariantName(payload)
fn eval_enum_variant(interp: Interpreter, enum_name: text, variant_name: text,
                     args: [Expr]?) -> Result<Value, InterpreterError>:
    if args.? and args.unwrap().len() > 0:
        val arg_vals = args.unwrap().map(\a: evaluate(interp, a))
        var payload_values = []
        for r in arg_vals:
            payload_values.push(r?)
        if payload_values.len() == 1:
            Ok(Value.enum_value(enum_name, variant_name, Some(payload_values[0])))
        else:
            Ok(Value.enum_value(enum_name, variant_name, Some(Value.tuple(payload_values))))
    else:
        Ok(Value.enum_value(enum_name, variant_name, nil))

# ================================================================
# Struct/Class Literal Construction
# ================================================================

# Evaluate StructName(field1: val1, field2: val2)
fn eval_struct_literal(interp: Interpreter, name: text,
                       fields: [(text, Expr)]) -> Result<Value, InterpreterError>:
    var field_values = {}
    for (field_name, field_expr) in fields:
        val value = evaluate(interp, field_expr)?
        field_values[field_name] = value
    Ok(Value.object(name, field_values))
