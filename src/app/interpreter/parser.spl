# Parser Wrapper
#
# Wraps the tree-sitter parser with a simpler interface for the interpreter.

import parser.treesitter.parser.{TreeSitterParser}
import parser.treesitter.tree.{Tree}

export SimpleParser, ParseError

# Error type for parsing
enum ParseError:
    LexerError(String)
    SyntaxError(String)
    UnsupportedLanguage(String)

impl Display for ParseError:
    fn fmt() -> String:
        match self:
            case ParseError.LexerError(msg): return "Lexer error: {msg}"
            case ParseError.SyntaxError(msg): return "Syntax error: {msg}"
            case ParseError.UnsupportedLanguage(msg): return "Unsupported language: {msg}"

# Simple parser wrapper
struct SimpleParser:
    inner: Option<TreeSitterParser>

impl SimpleParser:
    static fn new() -> SimpleParser:
        match TreeSitterParser.new("simple"):
            case Ok(parser):
                return SimpleParser { inner: Some(parser) }
            case Err(_):
                return SimpleParser { inner: None }

    # Parse a complete module/file
    fn parse(source: String) -> Result<Tree, ParseError>:
        match &mut self.inner:
            case Some(parser):
                match parser.parse(source):
                    case Ok(tree): return Ok(tree)
                    case Err(msg): return Err(ParseError.SyntaxError(msg))
            case None:
                return Err(ParseError.UnsupportedLanguage("simple"))

    # Parse a single expression
    fn parse_expression(source: String) -> Result<Tree, ParseError>:
        # Wrap in a minimal context for parsing
        val wrapped = source
        match &mut self.inner:
            case Some(parser):
                match parser.parse(wrapped):
                    case Ok(tree): return Ok(tree)
                    case Err(msg): return Err(ParseError.SyntaxError(msg))
            case None:
                return Err(ParseError.UnsupportedLanguage("simple"))

    # Parse a single statement
    fn parse_statement(source: String) -> Result<Tree, ParseError>:
        match &mut self.inner:
            case Some(parser):
                match parser.parse(source):
                    case Ok(tree): return Ok(tree)
                    case Err(msg): return Err(ParseError.SyntaxError(msg))
            case None:
                return Err(ParseError.UnsupportedLanguage("simple"))
