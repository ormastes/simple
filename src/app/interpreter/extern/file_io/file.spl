# File I/O - File Handle Operations
#
# Wrapper functions for file handle operations.

from ..core import {Value, InterpreterError}
from file_io.ffi_file import {
    rt_file_read, rt_file_write, rt_file_flush,
    rt_file_seek, rt_file_sync, rt_file_close
}

fn file_read(args: [Value]) -> Result<Value, InterpreterError>:
    """Read from file handle.

    Args:
        handle: File handle from fs_open
        buf_len: Buffer length (default 4096)

    Returns:
        Result<[byte], IoError>
    """
    if args.len() < 1:
        return Err(InterpreterError.ArityError("file_read expects at least 1 argument"))

    val handle = args[0].as_int() ?? return Err(InterpreterError.TypeError("file_read expects integer handle"))
    val buf_len = if args.len() > 1: args[1].as_int() ?? 4096 else: 4096

    Ok(rt_file_read(handle, buf_len))

fn file_write(args: [Value]) -> Result<Value, InterpreterError>:
    """Write to file handle.

    Args:
        handle: File handle from fs_open
        data: Byte array to write

    Returns:
        Result<bytes_written, IoError>
    """
    if args.len() != 2:
        return Err(InterpreterError.ArityError("file_write expects 2 arguments"))

    val handle = args[0].as_int() ?? return Err(InterpreterError.TypeError("file_write expects integer handle"))
    val data = args[1].as_array() ?? return Err(InterpreterError.TypeError("file_write expects byte array"))

    # Convert Value array to i64 array
    var byte_array: [i64] = []
    for val in data:
        val byte = val.as_int() ?? return Err(InterpreterError.TypeError("file_write expects byte array"))
        byte_array.push(byte)

    Ok(rt_file_write(handle, byte_array))

fn file_flush(args: [Value]) -> Result<Value, InterpreterError>:
    """Flush file handle write buffer.

    Args:
        handle: File handle from fs_open

    Returns:
        Result<(), IoError>
    """
    if args.len() != 1:
        return Err(InterpreterError.ArityError("file_flush expects 1 argument"))

    val handle = args[0].as_int() ?? return Err(InterpreterError.TypeError("file_flush expects integer handle"))

    Ok(rt_file_flush(handle))

fn file_seek(args: [Value]) -> Result<Value, InterpreterError>:
    """Seek to position in file.

    Args:
        handle: File handle from fs_open
        position: Byte offset
        whence: Seek mode (0=Start, 1=Current, 2=End)

    Returns:
        Result<new_position, IoError>
    """
    if args.len() != 3:
        return Err(InterpreterError.ArityError("file_seek expects 3 arguments"))

    val handle = args[0].as_int() ?? return Err(InterpreterError.TypeError("file_seek expects integer handle"))
    val position = args[1].as_int() ?? return Err(InterpreterError.TypeError("file_seek expects integer position"))
    val whence = args[2].as_int() ?? 0

    Ok(rt_file_seek(handle, position, whence))

fn file_sync(args: [Value]) -> Result<Value, InterpreterError>:
    """Sync file data to disk.

    Args:
        handle: File handle from fs_open

    Returns:
        Result<(), IoError>
    """
    if args.len() != 1:
        return Err(InterpreterError.ArityError("file_sync expects 1 argument"))

    val handle = args[0].as_int() ?? return Err(InterpreterError.TypeError("file_sync expects integer handle"))

    Ok(rt_file_sync(handle))

fn file_close(args: [Value]) -> Result<Value, InterpreterError>:
    """Close file handle.

    Args:
        handle: File handle from fs_open

    Returns:
        Result<(), IoError>
    """
    if args.len() != 1:
        return Err(InterpreterError.ArityError("file_close expects 1 argument"))

    val handle = args[0].as_int() ?? return Err(InterpreterError.TypeError("file_close expects integer handle"))

    Ok(rt_file_close(handle))

export file_read, file_write, file_flush, file_seek, file_sync, file_close
