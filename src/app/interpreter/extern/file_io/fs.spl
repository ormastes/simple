# File I/O - Filesystem Operations
#
# Wrapper functions for filesystem operations.

from ..core import {Value, InterpreterError}
from file_io.ffi_fs import {
    rt_fs_exists, rt_fs_read, rt_fs_read_string, rt_fs_write_string,
    rt_fs_write, rt_fs_append, rt_fs_create_dir, rt_fs_remove_file,
    rt_fs_remove_dir, rt_fs_rename, rt_fs_copy, rt_fs_metadata,
    rt_fs_read_dir, rt_fs_open
}

fn fs_exists(args: [Value]) -> Result<Value, InterpreterError>:
    """Check if a file or directory exists.

    Args:
        path: File or directory path

    Returns:
        Boolean indicating existence
    """
    if args.len() != 1:
        return Err(InterpreterError.ArityError("fs_exists expects 1 argument"))

    val path = args[0].as_str() ?? return Err(InterpreterError.TypeError("fs_exists expects string path"))

    Ok(Value.bool(rt_fs_exists(path)))

fn fs_read(args: [Value]) -> Result<Value, InterpreterError>:
    """Read entire file as byte array.

    Args:
        path: File path

    Returns:
        Result<[byte], IoError>
    """
    if args.len() != 1:
        return Err(InterpreterError.ArityError("fs_read expects 1 argument"))

    val path = args[0].as_str() ?? return Err(InterpreterError.TypeError("fs_read expects string path"))

    Ok(rt_fs_read(path))

fn fs_read_string(args: [Value]) -> Result<Value, InterpreterError>:
    """Read entire file as UTF-8 string.

    Args:
        path: File path

    Returns:
        Result<text, IoError>
    """
    if args.len() != 1:
        return Err(InterpreterError.ArityError("fs_read_string expects 1 argument"))

    val path = args[0].as_str() ?? return Err(InterpreterError.TypeError("fs_read_string expects string path"))

    Ok(rt_fs_read_string(path))

fn fs_write_string(args: [Value]) -> Result<Value, InterpreterError>:
    """Write string to file (overwrites existing).

    Args:
        path: File path
        content: String content to write

    Returns:
        Result<bytes_written, IoError>
    """
    if args.len() != 2:
        return Err(InterpreterError.ArityError("fs_write_string expects 2 arguments"))

    val path = args[0].as_str() ?? return Err(InterpreterError.TypeError("fs_write_string expects string path"))
    val content = args[1].as_str() ?? return Err(InterpreterError.TypeError("fs_write_string expects string content"))

    Ok(rt_fs_write_string(path, content))

fn fs_write(args: [Value]) -> Result<Value, InterpreterError>:
    """Write byte array to file (overwrites existing).

    Args:
        path: File path
        data: Byte array to write

    Returns:
        Result<bytes_written, IoError>
    """
    if args.len() != 2:
        return Err(InterpreterError.ArityError("fs_write expects 2 arguments"))

    val path = args[0].as_str() ?? return Err(InterpreterError.TypeError("fs_write expects string path"))
    val data = args[1].as_array() ?? return Err(InterpreterError.TypeError("fs_write expects byte array"))

    # Convert Value array to i64 array
    var byte_array: [i64] = []
    for val in data:
        val byte = val.as_int() ?? return Err(InterpreterError.TypeError("fs_write expects byte array"))
        byte_array.push(byte)

    Ok(rt_fs_write(path, byte_array))

fn fs_append(args: [Value]) -> Result<Value, InterpreterError>:
    """Append byte array to file.

    Args:
        path: File path
        data: Byte array to append

    Returns:
        Result<bytes_written, IoError>
    """
    if args.len() != 2:
        return Err(InterpreterError.ArityError("fs_append expects 2 arguments"))

    val path = args[0].as_str() ?? return Err(InterpreterError.TypeError("fs_append expects string path"))
    val data = args[1].as_array() ?? return Err(InterpreterError.TypeError("fs_append expects byte array"))

    # Convert Value array to i64 array
    var byte_array: [i64] = []
    for val in data:
        val byte = val.as_int() ?? return Err(InterpreterError.TypeError("fs_append expects byte array"))
        byte_array.push(byte)

    Ok(rt_fs_append(path, byte_array))

fn fs_create_dir(args: [Value]) -> Result<Value, InterpreterError>:
    """Create directory.

    Args:
        path: Directory path
        recursive: If true, create parent directories (default false)

    Returns:
        Result<(), IoError>
    """
    if args.len() < 1:
        return Err(InterpreterError.ArityError("fs_create_dir expects at least 1 argument"))

    val path = args[0].as_str() ?? return Err(InterpreterError.TypeError("fs_create_dir expects string path"))
    val recursive = if args.len() > 1: args[1].as_bool() ?? false else: false

    Ok(rt_fs_create_dir(path, recursive))

fn fs_remove_file(args: [Value]) -> Result<Value, InterpreterError>:
    """Remove a file.

    Args:
        path: File path

    Returns:
        Result<(), IoError>
    """
    if args.len() != 1:
        return Err(InterpreterError.ArityError("fs_remove_file expects 1 argument"))

    val path = args[0].as_str() ?? return Err(InterpreterError.TypeError("fs_remove_file expects string path"))

    Ok(rt_fs_remove_file(path))

fn fs_remove_dir(args: [Value]) -> Result<Value, InterpreterError>:
    """Remove a directory.

    Args:
        path: Directory path
        recursive: If true, remove directory and contents (default false)

    Returns:
        Result<(), IoError>
    """
    if args.len() < 1:
        return Err(InterpreterError.ArityError("fs_remove_dir expects at least 1 argument"))

    val path = args[0].as_str() ?? return Err(InterpreterError.TypeError("fs_remove_dir expects string path"))
    val recursive = if args.len() > 1: args[1].as_bool() ?? false else: false

    Ok(rt_fs_remove_dir(path, recursive))

fn fs_rename(args: [Value]) -> Result<Value, InterpreterError>:
    """Rename or move a file or directory.

    Args:
        from: Source path
        to: Destination path

    Returns:
        Result<(), IoError>
    """
    if args.len() != 2:
        return Err(InterpreterError.ArityError("fs_rename expects 2 arguments"))

    val from = args[0].as_str() ?? return Err(InterpreterError.TypeError("fs_rename expects string paths"))
    val to = args[1].as_str() ?? return Err(InterpreterError.TypeError("fs_rename expects string paths"))

    Ok(rt_fs_rename(from, to))

fn fs_copy(args: [Value]) -> Result<Value, InterpreterError>:
    """Copy a file.

    Args:
        from: Source file path
        to: Destination file path

    Returns:
        Result<bytes_copied, IoError>
    """
    if args.len() != 2:
        return Err(InterpreterError.ArityError("fs_copy expects 2 arguments"))

    val from = args[0].as_str() ?? return Err(InterpreterError.TypeError("fs_copy expects string paths"))
    val to = args[1].as_str() ?? return Err(InterpreterError.TypeError("fs_copy expects string paths"))

    Ok(rt_fs_copy(from, to))

fn fs_metadata(args: [Value]) -> Result<Value, InterpreterError>:
    """Get file or directory metadata.

    Args:
        path: File or directory path

    Returns:
        Result<Metadata{size, is_file, is_dir, modified, ...}, IoError>
    """
    if args.len() != 1:
        return Err(InterpreterError.ArityError("fs_metadata expects 1 argument"))

    val path = args[0].as_str() ?? return Err(InterpreterError.TypeError("fs_metadata expects string path"))

    Ok(rt_fs_metadata(path))

fn fs_read_dir(args: [Value]) -> Result<Value, InterpreterError>:
    """List directory contents.

    Args:
        path: Directory path

    Returns:
        Result<[DirEntry{name, path, is_file, is_dir}], IoError>
    """
    if args.len() != 1:
        return Err(InterpreterError.ArityError("fs_read_dir expects 1 argument"))

    val path = args[0].as_str() ?? return Err(InterpreterError.TypeError("fs_read_dir expects string path"))

    Ok(rt_fs_read_dir(path))

fn fs_open(args: [Value]) -> Result<Value, InterpreterError>:
    """Open file and return handle.

    Args:
        path: File path
        mode: Open mode enum (Read, Write, Append, ReadWrite, etc.)

    Returns:
        Result<handle, IoError>
    """
    if args.len() != 2:
        return Err(InterpreterError.ArityError("fs_open expects 2 arguments"))

    val path = args[0].as_str() ?? return Err(InterpreterError.TypeError("fs_open expects string path"))
    val mode = args[1]  # Can be enum or string

    Ok(rt_fs_open(path, mode))

#==============================================================================
# File Handle Wrapper Functions
#==============================================================================

export fs_exists, fs_read, fs_read_string, fs_write_string, fs_write, fs_append
export fs_create_dir, fs_remove_file, fs_remove_dir, fs_rename, fs_copy
export fs_metadata, fs_read_dir, fs_open
