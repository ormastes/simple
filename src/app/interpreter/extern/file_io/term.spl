# File I/O - Terminal Operations
#
# Wrapper functions for terminal I/O operations.

from ..core import {Value, InterpreterError}
from file_io.ffi_term import {
    rt_stdin, rt_stdout, rt_stderr, rt_is_tty,
    rt_enable_raw_mode, rt_disable_raw_mode, rt_get_term_size,
    rt_term_write, rt_term_read, rt_term_read_timeout,
    rt_term_flush, rt_term_poll
}

fn stdin(args: [Value]) -> Result<Value, InterpreterError>:
    """Get stdin file handle.

    Returns:
        Handle for standard input (0)
    """
    if args.len() != 0:
        return Err(InterpreterError.ArityError("stdin expects 0 arguments"))

    Ok(Value.int(rt_stdin()))

fn stdout(args: [Value]) -> Result<Value, InterpreterError>:
    """Get stdout file handle.

    Returns:
        Handle for standard output (1)
    """
    if args.len() != 0:
        return Err(InterpreterError.ArityError("stdout expects 0 arguments"))

    Ok(Value.int(rt_stdout()))

fn stderr(args: [Value]) -> Result<Value, InterpreterError>:
    """Get stderr file handle.

    Returns:
        Handle for standard error (2)
    """
    if args.len() != 0:
        return Err(InterpreterError.ArityError("stderr expects 0 arguments"))

    Ok(Value.int(rt_stderr()))

fn is_tty(args: [Value]) -> Result<Value, InterpreterError>:
    """Check if file handle is a TTY (terminal).

    Args:
        handle: File handle to check

    Returns:
        Boolean indicating TTY status
    """
    if args.len() != 1:
        return Err(InterpreterError.ArityError("is_tty expects 1 argument"))

    val handle = args[0].as_int() ?? return Err(InterpreterError.TypeError("is_tty expects integer handle"))

    Ok(Value.bool(rt_is_tty(handle)))

fn enable_raw_mode(args: [Value]) -> Result<Value, InterpreterError>:
    """Enable terminal raw mode (disable line buffering, echo).

    Args:
        handle: Terminal file handle

    Returns:
        Result<(), IoError>
    """
    if args.len() != 1:
        return Err(InterpreterError.ArityError("enable_raw_mode expects 1 argument"))

    val handle = args[0].as_int() ?? return Err(InterpreterError.TypeError("enable_raw_mode expects integer handle"))

    Ok(rt_enable_raw_mode(handle))

fn disable_raw_mode(args: [Value]) -> Result<Value, InterpreterError>:
    """Disable terminal raw mode (restore normal mode).

    Args:
        handle: Terminal file handle

    Returns:
        Result<(), IoError>
    """
    if args.len() != 1:
        return Err(InterpreterError.ArityError("disable_raw_mode expects 1 argument"))

    val handle = args[0].as_int() ?? return Err(InterpreterError.TypeError("disable_raw_mode expects integer handle"))

    Ok(rt_disable_raw_mode(handle))

fn get_term_size(args: [Value]) -> Result<Value, InterpreterError>:
    """Get terminal size (columns and rows).

    Args:
        handle: Terminal file handle

    Returns:
        Result<(cols, rows), IoError>
    """
    if args.len() != 1:
        return Err(InterpreterError.ArityError("get_term_size expects 1 argument"))

    val handle = args[0].as_int() ?? return Err(InterpreterError.TypeError("get_term_size expects integer handle"))

    Ok(rt_get_term_size(handle))

fn term_write(args: [Value]) -> Result<Value, InterpreterError>:
    """Write to terminal.

    Args:
        handle: Terminal file handle
        data: Byte array to write

    Returns:
        Result<bytes_written, IoError>
    """
    if args.len() != 2:
        return Err(InterpreterError.ArityError("term_write expects 2 arguments"))

    val handle = args[0].as_int() ?? return Err(InterpreterError.TypeError("term_write expects integer handle"))
    val data = args[1].as_array() ?? return Err(InterpreterError.TypeError("term_write expects byte array"))

    # Convert Value array to i64 array
    var byte_array: [i64] = []
    for val in data:
        val byte = val.as_int() ?? return Err(InterpreterError.TypeError("term_write expects byte array"))
        byte_array.push(byte)

    Ok(rt_term_write(handle, byte_array))

fn term_read(args: [Value]) -> Result<Value, InterpreterError>:
    """Read from terminal.

    Args:
        handle: Terminal file handle
        buf_len: Buffer length (default 1024)

    Returns:
        Result<[byte], IoError>
    """
    if args.len() < 1:
        return Err(InterpreterError.ArityError("term_read expects at least 1 argument"))

    val handle = args[0].as_int() ?? return Err(InterpreterError.TypeError("term_read expects integer handle"))
    val buf_len = if args.len() > 1: args[1].as_int() ?? 1024 else: 1024

    Ok(rt_term_read(handle, buf_len))

fn term_read_timeout(args: [Value]) -> Result<Value, InterpreterError>:
    """Read from terminal with timeout.

    Args:
        handle: Terminal file handle
        buf_len: Buffer length (default 1024)
        timeout_ms: Timeout in milliseconds

    Returns:
        Result<[byte], IoError>
    """
    if args.len() < 2:
        return Err(InterpreterError.ArityError("term_read_timeout expects at least 2 arguments"))

    val handle = args[0].as_int() ?? return Err(InterpreterError.TypeError("term_read_timeout expects integer handle"))
    val buf_len = if args.len() > 2: args[2].as_int() ?? 1024 else: 1024
    val timeout = args[1].as_int() ?? return Err(InterpreterError.TypeError("term_read_timeout expects integer timeout"))

    Ok(rt_term_read_timeout(handle, buf_len, timeout))

fn term_flush(args: [Value]) -> Result<Value, InterpreterError>:
    """Flush terminal output buffer.

    Args:
        handle: Terminal file handle

    Returns:
        Result<(), IoError>
    """
    if args.len() != 1:
        return Err(InterpreterError.ArityError("term_flush expects 1 argument"))

    val handle = args[0].as_int() ?? return Err(InterpreterError.TypeError("term_flush expects integer handle"))

    Ok(rt_term_flush(handle))

fn term_poll(args: [Value]) -> Result<Value, InterpreterError>:
    """Poll terminal for input availability.

    Args:
        handle: Terminal file handle
        timeout_ms: Timeout in milliseconds (0 for immediate)

    Returns:
        Result<bool, IoError> - true if input available
    """
    if args.len() != 2:
        return Err(InterpreterError.ArityError("term_poll expects 2 arguments"))

    val handle = args[0].as_int() ?? return Err(InterpreterError.TypeError("term_poll expects integer handle"))
    val timeout = args[1].as_int() ?? 0

    Ok(rt_term_poll(handle, timeout))

export stdin, stdout, stderr, is_tty
export enable_raw_mode, disable_raw_mode, get_term_size
export term_write, term_read, term_read_timeout, term_flush, term_poll
