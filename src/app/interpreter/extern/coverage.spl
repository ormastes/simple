# Coverage Extern Functions
#
# FFI wrappers for coverage analysis operations.
# Port of rust/compiler/src/interpreter_extern/coverage.rs

from ..core import {Value, InterpreterError}

export coverage_scan, coverage_class, coverage_func
export coverage_report, coverage_generate, coverage_check, coverage_summary
export rt_coverage_enabled, rt_coverage_clear
export rt_coverage_dump_sdn, rt_coverage_free_sdn, rt_cstring_to_text

# FFI declarations - these call into the Rust coverage infrastructure
@extern("coverage_scan")
fn _coverage_scan(source: text, output: text) -> i64

@extern("coverage_class")
fn _coverage_class(coverage_json: text, source: text, filter: text) -> i64

@extern("coverage_func")
fn _coverage_func(coverage_json: text, source: text, filter: text) -> i64

@extern("coverage_report")
fn _coverage_report(coverage_json: text, public_api: text, filter: text) -> i64

@extern("coverage_generate")
fn _coverage_generate(llvm_cov: text, api: text, output_dir: text, report_type: text) -> i64

@extern("coverage_check")
fn _coverage_check(coverage: text, threshold: f64) -> i64

@extern("coverage_summary")
fn _coverage_summary(coverage: text) -> i64

@extern("rt_coverage_enabled")
fn _rt_coverage_enabled() -> bool

@extern("rt_coverage_clear")
fn _rt_coverage_clear()

@extern("rt_coverage_dump_sdn")
fn _rt_coverage_dump_sdn() -> text

fn _get_str(args: [Value], idx: i64) -> text:
    if idx < args.len():
        args[idx].as_string() ?? ""
    else:
        ""

fn _get_f64(args: [Value], idx: i64, default: f64) -> f64:
    if idx < args.len():
        match args[idx].type_name():
            case "Float": args[idx].as_float() ?? default
            case "Int": (args[idx].as_int() ?? 0).to_float()
            case _: default
    else:
        default

fn coverage_scan(args: [Value]) -> Result<Value, InterpreterError>:
    Ok(Value.int(_coverage_scan(_get_str(args, 0), _get_str(args, 1))))

fn coverage_class(args: [Value]) -> Result<Value, InterpreterError>:
    Ok(Value.int(_coverage_class(_get_str(args, 0), _get_str(args, 1), _get_str(args, 2))))

fn coverage_func(args: [Value]) -> Result<Value, InterpreterError>:
    Ok(Value.int(_coverage_func(_get_str(args, 0), _get_str(args, 1), _get_str(args, 2))))

fn coverage_report(args: [Value]) -> Result<Value, InterpreterError>:
    Ok(Value.int(_coverage_report(_get_str(args, 0), _get_str(args, 1), _get_str(args, 2))))

fn coverage_generate(args: [Value]) -> Result<Value, InterpreterError>:
    Ok(Value.int(_coverage_generate(
        _get_str(args, 0), _get_str(args, 1), _get_str(args, 2), _get_str(args, 3))))

fn coverage_check(args: [Value]) -> Result<Value, InterpreterError>:
    Ok(Value.int(_coverage_check(_get_str(args, 0), _get_f64(args, 1, 80.0))))

fn coverage_summary(args: [Value]) -> Result<Value, InterpreterError>:
    Ok(Value.int(_coverage_summary(_get_str(args, 0))))

# TODO: Replace direct FFI call with wrapper (coverage_enabled) from app.io or compiler.ffi
fn rt_coverage_enabled(args: [Value]) -> Result<Value, InterpreterError>:
    Ok(Value.bool(_rt_coverage_enabled()))

# TODO: Replace direct FFI call with wrapper (coverage_clear) from app.io or compiler.ffi
fn rt_coverage_clear(args: [Value]) -> Result<Value, InterpreterError>:
    _rt_coverage_clear()
    Ok(Value.nil())

# TODO: Replace direct FFI call with wrapper (coverage_dump_sdn) from app.io or compiler.ffi
fn rt_coverage_dump_sdn(args: [Value]) -> Result<Value, InterpreterError>:
    Ok(Value.string(_rt_coverage_dump_sdn()))

# TODO: Replace direct FFI call with wrapper (coverage_free_sdn) from app.io or compiler.ffi
fn rt_coverage_free_sdn(args: [Value]) -> Result<Value, InterpreterError>:
    # No-op in interpreter - GC handles memory
    Ok(Value.nil())

# TODO: Replace direct FFI call with wrapper (cstring_to_text) from app.io or compiler.ffi
fn rt_cstring_to_text(args: [Value]) -> Result<Value, InterpreterError>:
    # In interpreter, strings are already managed
    match args[0].type_name():
        case "String": Ok(args[0])
        case "Int":
            if args[0].as_int() ?? 0 == 0:
                Ok(Value.string(""))
            else:
                Ok(Value.string(""))
        case _: Ok(Value.string(""))
