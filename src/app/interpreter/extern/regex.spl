# Regex Extern Functions
#
# FFI wrappers for regex operations via runtime.
# Port of rust/compiler/src/interpreter_extern/regex.rs

from ..core import {Value, InterpreterError}

export regex_is_match, regex_find, regex_find_all
export regex_captures, regex_replace, regex_replace_all
export regex_split, regex_split_n

# FFI declarations to runtime regex functions
@extern("ffi_regex_is_match")
fn _ffi_regex_is_match(pattern: text, text: text) -> bool

@extern("ffi_regex_find")
fn _ffi_regex_find(pattern: text, text: text) -> [text]

@extern("ffi_regex_find_all")
fn _ffi_regex_find_all(pattern: text, text: text) -> [[text]]

@extern("ffi_regex_captures")
fn _ffi_regex_captures(pattern: text, text: text) -> [text]

@extern("ffi_regex_replace")
fn _ffi_regex_replace(pattern: text, text: text, replacement: text) -> text

@extern("ffi_regex_replace_all")
fn _ffi_regex_replace_all(pattern: text, text: text, replacement: text) -> text

@extern("ffi_regex_split")
fn _ffi_regex_split(pattern: text, text: text) -> [text]

@extern("ffi_regex_split_n")
fn _ffi_regex_split_n(pattern: text, text: text, limit: i64) -> [text]

fn regex_is_match(args: [Value]) -> Result<Value, InterpreterError>:
    val pattern = args[0].as_string() ?? ""
    val text = args[1].as_string() ?? ""
    Ok(Value.bool(_ffi_regex_is_match(pattern, text)))

fn regex_find(args: [Value]) -> Result<Value, InterpreterError>:
    val pattern = args[0].as_string() ?? ""
    val text = args[1].as_string() ?? ""
    val result = _ffi_regex_find(pattern, text)
    Ok(Value.array(result.map(\s: Value.string(s))))

fn regex_find_all(args: [Value]) -> Result<Value, InterpreterError>:
    val pattern = args[0].as_string() ?? ""
    val text = args[1].as_string() ?? ""
    val result = _ffi_regex_find_all(pattern, text)
    Ok(Value.array(result.map(\group: Value.array(group.map(\s: Value.string(s))))))

fn regex_captures(args: [Value]) -> Result<Value, InterpreterError>:
    val pattern = args[0].as_string() ?? ""
    val text = args[1].as_string() ?? ""
    val result = _ffi_regex_captures(pattern, text)
    Ok(Value.array(result.map(\s: Value.string(s))))

fn regex_replace(args: [Value]) -> Result<Value, InterpreterError>:
    val pattern = args[0].as_string() ?? ""
    val text = args[1].as_string() ?? ""
    val replacement = args[2].as_string() ?? ""
    Ok(Value.string(_ffi_regex_replace(pattern, text, replacement)))

fn regex_replace_all(args: [Value]) -> Result<Value, InterpreterError>:
    val pattern = args[0].as_string() ?? ""
    val text = args[1].as_string() ?? ""
    val replacement = args[2].as_string() ?? ""
    Ok(Value.string(_ffi_regex_replace_all(pattern, text, replacement)))

fn regex_split(args: [Value]) -> Result<Value, InterpreterError>:
    val pattern = args[0].as_string() ?? ""
    val text = args[1].as_string() ?? ""
    val result = _ffi_regex_split(pattern, text)
    Ok(Value.array(result.map(\s: Value.string(s))))

fn regex_split_n(args: [Value]) -> Result<Value, InterpreterError>:
    val pattern = args[0].as_string() ?? ""
    val text = args[1].as_string() ?? ""
    val limit = args[2].as_int() ?? 0
    val result = _ffi_regex_split_n(pattern, text, limit)
    Ok(Value.array(result.map(\s: Value.string(s))))
