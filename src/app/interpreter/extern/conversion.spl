# Type Conversion Extern Functions
#
# Provides conversion between Simple language types (int, string, bool).
# Port of rust/compiler/src/interpreter_extern/conversion.rs

from ..core import {Value, InterpreterError}

export to_string_extern, to_int_extern, to_float_extern, to_bool_extern
export type_of_extern, is_int_extern, is_float_extern, is_string_extern
export is_bool_extern, is_nil_extern, is_array_extern, is_dict_extern

# Convert a value to string representation
fn to_string_extern(args: [Value]) -> Result<Value, InterpreterError>:
    if args.len() != 1:
        return Err(InterpreterError.ArityError("to_string expects 1 argument"))
    Ok(Value.string(args[0].to_display_string()))

# Convert a value to integer
# Supports: Int→Int, String→Int (parse), Bool→Int (true=1, false=0), Float→Int (truncate)
fn to_int_extern(args: [Value]) -> Result<Value, InterpreterError>:
    if args.len() != 1:
        return Err(InterpreterError.ArityError("to_int expects 1 argument"))
    val v = args[0]
    match v.type_name():
        case "Int":
            Ok(v)
        case "Float":
            val f = v.as_float() ?? 0.0
            Ok(Value.int(f.to_int()))
        case "String":
            val s = v.as_string() ?? ""
            val parsed = s.parse_int()
            if parsed.?:
                Ok(Value.int(parsed.unwrap()))
            else:
                Err(InterpreterError.TypeError("cannot convert '{s}' to int"))
        case "Bool":
            Ok(Value.int(if v.is_truthy(): 1 else: 0))
        case _:
            Err(InterpreterError.TypeError("to_int expects string, int, float, or bool"))

# Convert a value to float
# Supports: Float→Float, Int→Float, String→Float (parse), Bool→Float
fn to_float_extern(args: [Value]) -> Result<Value, InterpreterError>:
    if args.len() != 1:
        return Err(InterpreterError.ArityError("to_float expects 1 argument"))
    val v = args[0]
    match v.type_name():
        case "Float":
            Ok(v)
        case "Int":
            val n = v.as_int() ?? 0
            Ok(Value.float(n.to_float()))
        case "String":
            val s = v.as_string() ?? ""
            val parsed = s.parse_float()
            if parsed.?:
                Ok(Value.float(parsed.unwrap()))
            else:
                Err(InterpreterError.TypeError("cannot convert '{s}' to float"))
        case "Bool":
            Ok(Value.float(if v.is_truthy(): 1.0 else: 0.0))
        case _:
            Err(InterpreterError.TypeError("to_float expects string, int, float, or bool"))

# Convert a value to bool
# Truthy: non-zero int, non-empty string, non-empty collections, true
# Falsy: 0, "", empty collections, nil, false
fn to_bool_extern(args: [Value]) -> Result<Value, InterpreterError>:
    if args.len() != 1:
        return Err(InterpreterError.ArityError("to_bool expects 1 argument"))
    Ok(Value.bool(args[0].is_truthy()))

# Get the type name of a value
fn type_of_extern(args: [Value]) -> Result<Value, InterpreterError>:
    if args.len() != 1:
        return Err(InterpreterError.ArityError("type expects 1 argument"))
    Ok(Value.string(args[0].type_name()))

# Type predicate functions
fn is_int_extern(args: [Value]) -> Result<Value, InterpreterError>:
    if args.len() != 1: return Err(InterpreterError.ArityError("is_int expects 1 argument"))
    Ok(Value.bool(args[0].type_name() == "Int"))

fn is_float_extern(args: [Value]) -> Result<Value, InterpreterError>:
    if args.len() != 1: return Err(InterpreterError.ArityError("is_float expects 1 argument"))
    Ok(Value.bool(args[0].type_name() == "Float"))

fn is_string_extern(args: [Value]) -> Result<Value, InterpreterError>:
    if args.len() != 1: return Err(InterpreterError.ArityError("is_string expects 1 argument"))
    Ok(Value.bool(args[0].type_name() == "String"))

fn is_bool_extern(args: [Value]) -> Result<Value, InterpreterError>:
    if args.len() != 1: return Err(InterpreterError.ArityError("is_bool expects 1 argument"))
    Ok(Value.bool(args[0].type_name() == "Bool"))

fn is_nil_extern(args: [Value]) -> Result<Value, InterpreterError>:
    if args.len() != 1: return Err(InterpreterError.ArityError("is_nil expects 1 argument"))
    Ok(Value.bool(args[0].is_nil()))

fn is_array_extern(args: [Value]) -> Result<Value, InterpreterError>:
    if args.len() != 1: return Err(InterpreterError.ArityError("is_array expects 1 argument"))
    Ok(Value.bool(args[0].type_name() == "Array"))

fn is_dict_extern(args: [Value]) -> Result<Value, InterpreterError>:
    if args.len() != 1: return Err(InterpreterError.ArityError("is_dict expects 1 argument"))
    Ok(Value.bool(args[0].type_name() == "Dict"))
