# I18n (Internationalization) Extern Functions
#
# Simple HashMap-based message context for localization.
# Port of rust/compiler/src/interpreter_extern/i18n.rs
# Note: No actual localization - returns messages as-is.

from ..core import {Value, InterpreterError}

export MessageContext, i18n_context_new, i18n_context_insert
export i18n_context_free, i18n_get_message, i18n_severity_name
export MessageCatalog, load_catalog, get_localized_message
export CATALOG_EN, CATALOG_JA, CATALOG_KO, CATALOG_ZH

# Simple message context (replaces opaque handle pattern)
class MessageContext:
    values: Dict<text, text>

impl MessageContext:
    static fn empty() -> MessageContext:
        MessageContext(values: {})

    me insert(key: text, value: text):
        self.values[key] = value

    fn get(key: text) -> text?:
        self.values.get(key)

# Global registry for contexts (replaces raw pointer handles)
var _contexts: Dict<i64, MessageContext> = {}
var _next_handle: i64 = 1

fn i18n_context_new(args: [Value]) -> Result<Value, InterpreterError>:
    val handle = _next_handle
    _next_handle = _next_handle + 1
    _contexts[handle] = MessageContext.empty()
    Ok(Value.int(handle))

fn i18n_context_insert(args: [Value]) -> Result<Value, InterpreterError>:
    if args.len() != 3:
        return Err(InterpreterError.ArityError(
            "rt_i18n_context_insert: expected 3 arguments (handle, key, value)"))
    val handle = args[0].as_int() ?? return Err(
        InterpreterError.TypeError("first argument must be Int (handle)"))
    val key = args[1].as_string() ?? return Err(
        InterpreterError.TypeError("second argument must be String (key)"))
    val value = args[2].as_string() ?? return Err(
        InterpreterError.TypeError("third argument must be String (value)"))
    val ctx = _contexts.get(handle) ?? return Err(
        InterpreterError.RuntimeError("invalid context handle"))
    ctx.insert(key, value)
    Ok(Value.nil())

fn i18n_context_free(args: [Value]) -> Result<Value, InterpreterError>:
    if args.len() != 1:
        return Err(InterpreterError.ArityError(
            "rt_i18n_context_free: expected 1 argument (handle)"))
    val handle = args[0].as_int() ?? return Err(
        InterpreterError.TypeError("argument must be Int (handle)"))
    _contexts.remove(handle)
    Ok(Value.nil())

fn i18n_get_message(args: [Value]) -> Result<Value, InterpreterError>:
    if args.len() != 3:
        return Err(InterpreterError.ArityError(
            "rt_i18n_get_message: expected 3 arguments (domain, id, ctx_handle)"))
    val domain = args[0].as_string() ?? return Err(
        InterpreterError.TypeError("first argument must be String (domain)"))
    val id = args[1].as_string() ?? return Err(
        InterpreterError.TypeError("second argument must be String (id)"))
    # Return domain.id as message (no localization)
    Ok(Value.string("{domain}.{id}"))

fn i18n_severity_name(args: [Value]) -> Result<Value, InterpreterError>:
    if args.len() != 1:
        return Err(InterpreterError.ArityError(
            "rt_i18n_severity_name: expected 1 argument (severity)"))
    val severity = args[0].as_string() ?? return Err(
        InterpreterError.TypeError("argument must be String"))
    Ok(Value.string(severity))

# ============================================================================
# Message Catalog (multi-language support)
# ============================================================================

class MessageCatalog:
    """Localized message catalog with interpolation support.

    Messages are keyed by (domain, id) and can contain {key} placeholders
    that are substituted from a MessageContext.
    """
    locale: text
    messages: Dict<text, text>  # "domain.id" -> localized message template

impl MessageCatalog:
    static fn empty(locale: text) -> MessageCatalog:
        MessageCatalog(locale: locale, messages: {})

    me add(domain: text, id: text, template: text):
        self.messages["{domain}.{id}"] = template

    fn get(domain: text, id: text) -> text?:
        self.messages.get("{domain}.{id}")

    fn format(domain: text, id: text, ctx: MessageContext) -> text:
        """Get a message and interpolate context values."""
        val template = self.get(domain, id) ?? "{domain}.{id}"
        var result = template
        for (key, value) in ctx.values:
            result = result.replace("{{{key}}}", value)
        result

# Pre-built catalogs for error/diagnostic messages
var _catalogs: Dict<text, MessageCatalog> = {}

fn load_catalog(locale: text, catalog: MessageCatalog):
    """Register a catalog for a locale."""
    _catalogs[locale] = catalog

fn get_localized_message(locale: text, domain: text, id: text, ctx: MessageContext) -> text:
    """Get a localized message with interpolation. Falls back to en."""
    val catalog = _catalogs.get(locale) ?? _catalogs.get("en")
    if catalog.?:
        catalog.unwrap().format(domain, id, ctx)
    else:
        "{domain}.{id}"

# ============================================================================
# Default English Catalog (compiler diagnostics)
# ============================================================================

fn _build_en_catalog() -> MessageCatalog:
    var c = MessageCatalog.empty("en")
    # Type errors
    c.add("type", "mismatch", "expected {expected}, found {found}")
    c.add("type", "undefined", "undefined variable '{name}'")
    c.add("type", "not_callable", "'{name}' is not callable")
    c.add("type", "arity", "expected {expected} arguments, got {found}")
    c.add("type", "no_field", "type '{type}' has no field '{field}'")
    c.add("type", "no_method", "no method '{method}' on type '{type}'")
    # Contract errors
    c.add("contract", "precondition", "precondition violated in '{func}': {message}")
    c.add("contract", "postcondition", "postcondition violated in '{func}': {message}")
    c.add("contract", "invariant", "{phase} invariant violated in '{func}'")
    # Runtime errors
    c.add("runtime", "stack_overflow", "stack overflow: depth {depth} exceeds limit {limit}")
    c.add("runtime", "timeout", "execution timed out after {seconds} seconds")
    c.add("runtime", "division_by_zero", "division by zero")
    c.add("runtime", "index_out_of_bounds", "index {index} out of bounds for length {length}")
    c

fn _build_ja_catalog() -> MessageCatalog:
    var c = MessageCatalog.empty("ja")
    c.add("type", "mismatch", "型の不一致: {expected}が期待されましたが、{found}が見つかりました")
    c.add("type", "undefined", "未定義の変数: '{name}'")
    c.add("type", "arity", "引数の数が一致しません: {expected}個の引数が期待されましたが、{found}個が渡されました")
    c.add("runtime", "stack_overflow", "スタックオーバーフロー: 深さ{depth}が制限{limit}を超えました")
    c.add("runtime", "timeout", "実行がタイムアウトしました ({seconds}秒)")
    c.add("runtime", "division_by_zero", "ゼロ除算")
    c

fn _build_ko_catalog() -> MessageCatalog:
    var c = MessageCatalog.empty("ko")
    c.add("type", "mismatch", "타입 불일치: {expected}이(가) 예상되었으나 {found}이(가) 발견됨")
    c.add("type", "undefined", "정의되지 않은 변수: '{name}'")
    c.add("runtime", "stack_overflow", "스택 오버플로: 깊이 {depth}이(가) 제한 {limit}을(를) 초과함")
    c.add("runtime", "timeout", "실행 시간 초과 ({seconds}초)")
    c

fn _build_zh_catalog() -> MessageCatalog:
    var c = MessageCatalog.empty("zh")
    c.add("type", "mismatch", "类型不匹配：期望 {expected}，实际为 {found}")
    c.add("type", "undefined", "未定义变量：'{name}'")
    c.add("runtime", "stack_overflow", "栈溢出：深度 {depth} 超过限制 {limit}")
    c.add("runtime", "timeout", "执行超时（{seconds}秒）")
    c

# Constants for locale names
val CATALOG_EN = "en"
val CATALOG_JA = "ja"
val CATALOG_KO = "ko"
val CATALOG_ZH = "zh"

# Register default catalogs
load_catalog("en", _build_en_catalog())
load_catalog("ja", _build_ja_catalog())
load_catalog("ko", _build_ko_catalog())
load_catalog("zh", _build_zh_catalog())
