# Math Extern Functions
#
# Integer math operations + float math FFI wrappers.
# Port of rust/compiler/src/interpreter_extern/math.rs

from ..core import {Value, InterpreterError}

export abs_extern, min_extern, max_extern, sqrt_extern
export floor_extern, ceil_extern, pow_extern
export rt_math_pow_extern, rt_math_log_extern, rt_math_log10_extern
export rt_math_log2_extern, rt_math_exp_extern, rt_math_sqrt_extern
export rt_math_cbrt_extern, rt_math_sin_extern, rt_math_cos_extern
export rt_math_tan_extern, rt_math_asin_extern, rt_math_acos_extern
export rt_math_atan_extern, rt_math_atan2_extern
export rt_math_sinh_extern, rt_math_cosh_extern, rt_math_tanh_extern
export rt_math_floor_extern, rt_math_ceil_extern
export rt_math_nan_extern, rt_math_inf_extern
export rt_math_is_nan_extern, rt_math_is_inf_extern, rt_math_is_finite_extern
export rt_math_round_extern, rt_math_trunc_extern, rt_math_abs_extern
export rt_math_hypot_extern, rt_math_gcd_extern, rt_math_lcm_extern
export rt_math_min_f_extern, rt_math_max_f_extern, rt_math_clamp_extern
export rt_math_sign_extern, rt_math_fract_extern, rt_math_rem_extern
export gcd_pure, lcm_pure, clamp_int, sign_int

# === Integer Math (pure logic) ===

fn abs_extern(args: [Value]) -> Result<Value, InterpreterError>:
    if args.len() != 1:
        return Err(InterpreterError.ArityError("abs expects 1 argument"))
    val n = args[0].as_int() ?? return Err(InterpreterError.TypeError("abs expects integer"))
    Ok(Value.int(if n < 0: -n else: n))

fn min_extern(args: [Value]) -> Result<Value, InterpreterError>:
    if args.len() != 2:
        return Err(InterpreterError.ArityError("min expects 2 arguments"))
    val a = args[0].as_int() ?? return Err(InterpreterError.TypeError("min expects integers"))
    val b = args[1].as_int() ?? return Err(InterpreterError.TypeError("min expects integers"))
    Ok(Value.int(if a < b: a else: b))

fn max_extern(args: [Value]) -> Result<Value, InterpreterError>:
    if args.len() != 2:
        return Err(InterpreterError.ArityError("max expects 2 arguments"))
    val a = args[0].as_int() ?? return Err(InterpreterError.TypeError("max expects integers"))
    val b = args[1].as_int() ?? return Err(InterpreterError.TypeError("max expects integers"))
    Ok(Value.int(if a > b: a else: b))

fn sqrt_extern(args: [Value]) -> Result<Value, InterpreterError>:
    if args.len() != 1:
        return Err(InterpreterError.ArityError("sqrt expects 1 argument"))
    val n = args[0].as_int() ?? return Err(InterpreterError.TypeError("sqrt expects integer"))
    # Integer sqrt via float conversion
    Ok(Value.int(rt_math_sqrt(n.to_float()).to_int()))

fn floor_extern(args: [Value]) -> Result<Value, InterpreterError>:
    if args.len() != 1:
        return Err(InterpreterError.ArityError("floor expects 1 argument"))
    val n = args[0].as_int() ?? return Err(InterpreterError.TypeError("floor expects integer"))
    Ok(Value.int(n))

fn ceil_extern(args: [Value]) -> Result<Value, InterpreterError>:
    if args.len() != 1:
        return Err(InterpreterError.ArityError("ceil expects 1 argument"))
    val n = args[0].as_int() ?? return Err(InterpreterError.TypeError("ceil expects integer"))
    Ok(Value.int(n))

fn pow_extern(args: [Value]) -> Result<Value, InterpreterError>:
    if args.len() != 2:
        return Err(InterpreterError.ArityError("pow expects 2 arguments"))
    val base = args[0].as_int() ?? return Err(InterpreterError.TypeError("pow expects integers"))
    val exp = args[1].as_int() ?? return Err(InterpreterError.TypeError("pow expects integers"))
    var result = 1
    for _ in 0..exp:
        result = result * base
    Ok(Value.int(result))

# === Float Math (FFI wrappers - call into runtime) ===

@extern("rt_math_pow")
fn rt_math_pow(base: f64, exp: f64) -> f64

@extern("rt_math_log")
fn rt_math_log(x: f64) -> f64

@extern("rt_math_log10")
fn rt_math_log10(x: f64) -> f64

@extern("rt_math_log2")
fn rt_math_log2(x: f64) -> f64

@extern("rt_math_exp")
fn rt_math_exp(x: f64) -> f64

@extern("rt_math_sqrt")
fn rt_math_sqrt(x: f64) -> f64

@extern("rt_math_cbrt")
fn rt_math_cbrt(x: f64) -> f64

@extern("rt_math_sin")
fn rt_math_sin(x: f64) -> f64

@extern("rt_math_cos")
fn rt_math_cos(x: f64) -> f64

@extern("rt_math_tan")
fn rt_math_tan(x: f64) -> f64

@extern("rt_math_asin")
fn rt_math_asin(x: f64) -> f64

@extern("rt_math_acos")
fn rt_math_acos(x: f64) -> f64

@extern("rt_math_atan")
fn rt_math_atan(x: f64) -> f64

@extern("rt_math_atan2")
fn rt_math_atan2(y: f64, x: f64) -> f64

@extern("rt_math_sinh")
fn rt_math_sinh(x: f64) -> f64

@extern("rt_math_cosh")
fn rt_math_cosh(x: f64) -> f64

@extern("rt_math_tanh")
fn rt_math_tanh(x: f64) -> f64

@extern("rt_math_floor")
fn rt_math_floor_f(x: f64) -> f64

@extern("rt_math_ceil")
fn rt_math_ceil_f(x: f64) -> f64

@extern("rt_math_nan")
fn rt_math_nan() -> f64

@extern("rt_math_inf")
fn rt_math_inf() -> f64

@extern("rt_math_is_nan")
fn rt_math_is_nan(x: f64) -> bool

@extern("rt_math_is_inf")
fn rt_math_is_inf(x: f64) -> bool

@extern("rt_math_is_finite")
fn rt_math_is_finite(x: f64) -> bool

@extern("rt_math_round")
fn rt_math_round(x: f64) -> f64

@extern("rt_math_trunc")
fn rt_math_trunc(x: f64) -> f64

@extern("rt_math_abs")
fn rt_math_abs(x: f64) -> f64

@extern("rt_math_hypot")
fn rt_math_hypot(x: f64, y: f64) -> f64

@extern("rt_math_gcd")
fn rt_math_gcd(a: i64, b: i64) -> i64

@extern("rt_math_lcm")
fn rt_math_lcm(a: i64, b: i64) -> i64

@extern("rt_math_min")
fn rt_math_min_f(x: f64, y: f64) -> f64

@extern("rt_math_max")
fn rt_math_max_f(x: f64, y: f64) -> f64

@extern("rt_math_clamp")
fn rt_math_clamp(x: f64, min_val: f64, max_val: f64) -> f64

@extern("rt_math_sign")
fn rt_math_sign(x: f64) -> f64

@extern("rt_math_fract")
fn rt_math_fract(x: f64) -> f64

@extern("rt_math_rem")
fn rt_math_rem(x: f64, y: f64) -> f64

# Float math wrapper functions that take Value args

fn _get_float_arg(args: [Value], idx: i64) -> Result<f64, InterpreterError>:
    if idx >= args.len():
        return Err(InterpreterError.ArityError("expected more arguments"))
    args[idx].as_float() ?? Err(InterpreterError.TypeError("expected float argument"))

fn rt_math_pow_extern(args: [Value]) -> Result<Value, InterpreterError>:
    Ok(Value.float(rt_math_pow(_get_float_arg(args, 0)?, _get_float_arg(args, 1)?)))

fn rt_math_log_extern(args: [Value]) -> Result<Value, InterpreterError>:
    Ok(Value.float(rt_math_log(_get_float_arg(args, 0)?)))

fn rt_math_log10_extern(args: [Value]) -> Result<Value, InterpreterError>:
    Ok(Value.float(rt_math_log10(_get_float_arg(args, 0)?)))

fn rt_math_log2_extern(args: [Value]) -> Result<Value, InterpreterError>:
    Ok(Value.float(rt_math_log2(_get_float_arg(args, 0)?)))

fn rt_math_exp_extern(args: [Value]) -> Result<Value, InterpreterError>:
    Ok(Value.float(rt_math_exp(_get_float_arg(args, 0)?)))

fn rt_math_sqrt_extern(args: [Value]) -> Result<Value, InterpreterError>:
    Ok(Value.float(rt_math_sqrt(_get_float_arg(args, 0)?)))

fn rt_math_cbrt_extern(args: [Value]) -> Result<Value, InterpreterError>:
    Ok(Value.float(rt_math_cbrt(_get_float_arg(args, 0)?)))

fn rt_math_sin_extern(args: [Value]) -> Result<Value, InterpreterError>:
    Ok(Value.float(rt_math_sin(_get_float_arg(args, 0)?)))

fn rt_math_cos_extern(args: [Value]) -> Result<Value, InterpreterError>:
    Ok(Value.float(rt_math_cos(_get_float_arg(args, 0)?)))

fn rt_math_tan_extern(args: [Value]) -> Result<Value, InterpreterError>:
    Ok(Value.float(rt_math_tan(_get_float_arg(args, 0)?)))

fn rt_math_asin_extern(args: [Value]) -> Result<Value, InterpreterError>:
    Ok(Value.float(rt_math_asin(_get_float_arg(args, 0)?)))

fn rt_math_acos_extern(args: [Value]) -> Result<Value, InterpreterError>:
    Ok(Value.float(rt_math_acos(_get_float_arg(args, 0)?)))

fn rt_math_atan_extern(args: [Value]) -> Result<Value, InterpreterError>:
    Ok(Value.float(rt_math_atan(_get_float_arg(args, 0)?)))

fn rt_math_atan2_extern(args: [Value]) -> Result<Value, InterpreterError>:
    Ok(Value.float(rt_math_atan2(_get_float_arg(args, 0)?, _get_float_arg(args, 1)?)))

fn rt_math_sinh_extern(args: [Value]) -> Result<Value, InterpreterError>:
    Ok(Value.float(rt_math_sinh(_get_float_arg(args, 0)?)))

fn rt_math_cosh_extern(args: [Value]) -> Result<Value, InterpreterError>:
    Ok(Value.float(rt_math_cosh(_get_float_arg(args, 0)?)))

fn rt_math_tanh_extern(args: [Value]) -> Result<Value, InterpreterError>:
    Ok(Value.float(rt_math_tanh(_get_float_arg(args, 0)?)))

fn rt_math_floor_extern(args: [Value]) -> Result<Value, InterpreterError>:
    Ok(Value.float(rt_math_floor_f(_get_float_arg(args, 0)?)))

fn rt_math_ceil_extern(args: [Value]) -> Result<Value, InterpreterError>:
    Ok(Value.float(rt_math_ceil_f(_get_float_arg(args, 0)?)))

fn rt_math_nan_extern(args: [Value]) -> Result<Value, InterpreterError>:
    Ok(Value.float(rt_math_nan()))

fn rt_math_inf_extern(args: [Value]) -> Result<Value, InterpreterError>:
    Ok(Value.float(rt_math_inf()))

fn rt_math_is_nan_extern(args: [Value]) -> Result<Value, InterpreterError>:
    Ok(Value.bool(rt_math_is_nan(_get_float_arg(args, 0)?)))

fn rt_math_is_inf_extern(args: [Value]) -> Result<Value, InterpreterError>:
    Ok(Value.bool(rt_math_is_inf(_get_float_arg(args, 0)?)))

fn rt_math_is_finite_extern(args: [Value]) -> Result<Value, InterpreterError>:
    Ok(Value.bool(rt_math_is_finite(_get_float_arg(args, 0)?)))

fn rt_math_round_extern(args: [Value]) -> Result<Value, InterpreterError>:
    Ok(Value.float(rt_math_round(_get_float_arg(args, 0)?)))

fn rt_math_trunc_extern(args: [Value]) -> Result<Value, InterpreterError>:
    Ok(Value.float(rt_math_trunc(_get_float_arg(args, 0)?)))

fn rt_math_abs_extern(args: [Value]) -> Result<Value, InterpreterError>:
    Ok(Value.float(rt_math_abs(_get_float_arg(args, 0)?)))

fn rt_math_hypot_extern(args: [Value]) -> Result<Value, InterpreterError>:
    Ok(Value.float(rt_math_hypot(_get_float_arg(args, 0)?, _get_float_arg(args, 1)?)))

fn _get_int_arg(args: [Value], idx: i64) -> Result<i64, InterpreterError>:
    if idx >= args.len():
        return Err(InterpreterError.ArityError("expected more arguments"))
    args[idx].as_int() ?? Err(InterpreterError.TypeError("expected integer argument"))

fn rt_math_gcd_extern(args: [Value]) -> Result<Value, InterpreterError>:
    Ok(Value.int(rt_math_gcd(_get_int_arg(args, 0)?, _get_int_arg(args, 1)?)))

fn rt_math_lcm_extern(args: [Value]) -> Result<Value, InterpreterError>:
    Ok(Value.int(rt_math_lcm(_get_int_arg(args, 0)?, _get_int_arg(args, 1)?)))

fn rt_math_min_f_extern(args: [Value]) -> Result<Value, InterpreterError>:
    Ok(Value.float(rt_math_min_f(_get_float_arg(args, 0)?, _get_float_arg(args, 1)?)))

fn rt_math_max_f_extern(args: [Value]) -> Result<Value, InterpreterError>:
    Ok(Value.float(rt_math_max_f(_get_float_arg(args, 0)?, _get_float_arg(args, 1)?)))

fn rt_math_clamp_extern(args: [Value]) -> Result<Value, InterpreterError>:
    Ok(Value.float(rt_math_clamp(_get_float_arg(args, 0)?, _get_float_arg(args, 1)?, _get_float_arg(args, 2)?)))

fn rt_math_sign_extern(args: [Value]) -> Result<Value, InterpreterError>:
    Ok(Value.float(rt_math_sign(_get_float_arg(args, 0)?)))

fn rt_math_fract_extern(args: [Value]) -> Result<Value, InterpreterError>:
    Ok(Value.float(rt_math_fract(_get_float_arg(args, 0)?)))

fn rt_math_rem_extern(args: [Value]) -> Result<Value, InterpreterError>:
    Ok(Value.float(rt_math_rem(_get_float_arg(args, 0)?, _get_float_arg(args, 1)?)))

# === Pure Simple implementations (no FFI needed) ===

fn gcd_pure(a: i64, b: i64) -> i64:
    var x = if a < 0: -a else: a
    var y = if b < 0: -b else: b
    while y != 0:
        val t = y
        y = x % y
        x = t
    x

fn lcm_pure(a: i64, b: i64) -> i64:
    if a == 0 or b == 0:
        return 0
    val g = gcd_pure(a, b)
    val abs_a = if a < 0: -a else: a
    val abs_b = if b < 0: -b else: b
    (abs_a / g) * abs_b

fn clamp_int(x: i64, min_val: i64, max_val: i64) -> i64:
    if x < min_val: min_val
    elif x > max_val: max_val
    else: x

fn sign_int(x: i64) -> i64:
    if x > 0: 1
    elif x < 0: -1
    else: 0
