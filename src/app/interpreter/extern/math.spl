# Math Extern Functions
#
# Integer math operations + float math FFI wrappers.
# Port of rust/compiler/src/interpreter_extern/math.rs

from ..core import {Value, InterpreterError}

export abs_extern, min_extern, max_extern, sqrt_extern
export floor_extern, ceil_extern, pow_extern
export rt_math_pow_extern, rt_math_log_extern, rt_math_log10_extern
export rt_math_log2_extern, rt_math_exp_extern, rt_math_sqrt_extern
export rt_math_cbrt_extern, rt_math_sin_extern, rt_math_cos_extern
export rt_math_tan_extern, rt_math_asin_extern, rt_math_acos_extern
export rt_math_atan_extern, rt_math_atan2_extern
export rt_math_sinh_extern, rt_math_cosh_extern, rt_math_tanh_extern
export rt_math_floor_extern, rt_math_ceil_extern
export rt_math_nan_extern, rt_math_inf_extern
export rt_math_is_nan_extern, rt_math_is_inf_extern, rt_math_is_finite_extern
export rt_math_round_extern, rt_math_trunc_extern, rt_math_abs_extern
export rt_math_hypot_extern, rt_math_gcd_extern, rt_math_lcm_extern
export rt_math_min_f_extern, rt_math_max_f_extern, rt_math_clamp_extern
export rt_math_sign_extern, rt_math_fract_extern, rt_math_rem_extern
export gcd_pure, lcm_pure, clamp_int, sign_int

# === Integer Math (pure logic) ===

fn _get_int_arg(args: [Value], idx: i64) -> Result<i64, InterpreterError>:
    if idx >= args.len():
        return Err(InterpreterError.ArityError("expected more arguments"))
    args[idx].as_int() ?? Err(InterpreterError.TypeError("expected integer argument"))

fn abs_extern(args: [Value]) -> Result<Value, InterpreterError>:
    val n = _get_int_arg(args, 0)?
    Ok(Value.int(if n < 0: -n else: n))

fn min_extern(args: [Value]) -> Result<Value, InterpreterError>:
    val a = _get_int_arg(args, 0)?
    val b = _get_int_arg(args, 1)?
    Ok(Value.int(if a < b: a else: b))

fn max_extern(args: [Value]) -> Result<Value, InterpreterError>:
    val a = _get_int_arg(args, 0)?
    val b = _get_int_arg(args, 1)?
    Ok(Value.int(if a > b: a else: b))

fn sqrt_extern(args: [Value]) -> Result<Value, InterpreterError>:
    val n = _get_int_arg(args, 0)?
    # Integer sqrt via float conversion
    Ok(Value.int(rt_math_sqrt(n.to_float()).to_int()))

fn floor_extern(args: [Value]) -> Result<Value, InterpreterError>:
    val n = _get_int_arg(args, 0)?
    Ok(Value.int(n))

fn ceil_extern(args: [Value]) -> Result<Value, InterpreterError>:
    val n = _get_int_arg(args, 0)?
    Ok(Value.int(n))

fn pow_extern(args: [Value]) -> Result<Value, InterpreterError>:
    val base = _get_int_arg(args, 0)?
    val exp = _get_int_arg(args, 1)?
    var result = 1
    for _ in 0..exp:
        result = result * base
    Ok(Value.int(result))

# === Float Math (FFI wrappers - call into runtime) ===

@extern("rt_math_pow")
fn rt_math_pow(base: f64, exp: f64) -> f64

@extern("rt_math_log")
fn rt_math_log(x: f64) -> f64

@extern("rt_math_log10")
fn rt_math_log10(x: f64) -> f64

@extern("rt_math_log2")
fn rt_math_log2(x: f64) -> f64

@extern("rt_math_exp")
fn rt_math_exp(x: f64) -> f64

@extern("rt_math_sqrt")
fn rt_math_sqrt(x: f64) -> f64

@extern("rt_math_cbrt")
fn rt_math_cbrt(x: f64) -> f64

@extern("rt_math_sin")
fn rt_math_sin(x: f64) -> f64

@extern("rt_math_cos")
fn rt_math_cos(x: f64) -> f64

@extern("rt_math_tan")
fn rt_math_tan(x: f64) -> f64

@extern("rt_math_asin")
fn rt_math_asin(x: f64) -> f64

@extern("rt_math_acos")
fn rt_math_acos(x: f64) -> f64

@extern("rt_math_atan")
fn rt_math_atan(x: f64) -> f64

@extern("rt_math_atan2")
fn rt_math_atan2(y: f64, x: f64) -> f64

@extern("rt_math_sinh")
fn rt_math_sinh(x: f64) -> f64

@extern("rt_math_cosh")
fn rt_math_cosh(x: f64) -> f64

@extern("rt_math_tanh")
fn rt_math_tanh(x: f64) -> f64

@extern("rt_math_floor")
fn rt_math_floor_f(x: f64) -> f64

@extern("rt_math_ceil")
fn rt_math_ceil_f(x: f64) -> f64

@extern("rt_math_nan")
fn rt_math_nan() -> f64

@extern("rt_math_inf")
fn rt_math_inf() -> f64

@extern("rt_math_is_nan")
fn rt_math_is_nan(x: f64) -> bool

@extern("rt_math_is_inf")
fn rt_math_is_inf(x: f64) -> bool

@extern("rt_math_is_finite")
fn rt_math_is_finite(x: f64) -> bool

@extern("rt_math_round")
fn rt_math_round(x: f64) -> f64

@extern("rt_math_trunc")
fn rt_math_trunc(x: f64) -> f64

@extern("rt_math_abs")
fn rt_math_abs(x: f64) -> f64

@extern("rt_math_hypot")
fn rt_math_hypot(x: f64, y: f64) -> f64

@extern("rt_math_gcd")
fn rt_math_gcd(a: i64, b: i64) -> i64

@extern("rt_math_lcm")
fn rt_math_lcm(a: i64, b: i64) -> i64

@extern("rt_math_min")
fn rt_math_min_f(x: f64, y: f64) -> f64

@extern("rt_math_max")
fn rt_math_max_f(x: f64, y: f64) -> f64

@extern("rt_math_clamp")
fn rt_math_clamp(x: f64, min_val: f64, max_val: f64) -> f64

@extern("rt_math_sign")
fn rt_math_sign(x: f64) -> f64

@extern("rt_math_fract")
fn rt_math_fract(x: f64) -> f64

@extern("rt_math_rem")
fn rt_math_rem(x: f64, y: f64) -> f64

# Float math wrapper functions that take Value args

fn _get_float_arg(args: [Value], idx: i64) -> Result<f64, InterpreterError>:
    if idx >= args.len():
        return Err(InterpreterError.ArityError("expected more arguments"))
    args[idx].as_float() ?? Err(InterpreterError.TypeError("expected float argument"))

# Helper: wrap a unary f64->f64 function
fn _wrap_unary_float(args: [Value], func: fn(f64) -> f64) -> Result<Value, InterpreterError>:
    Ok(Value.float(func(_get_float_arg(args, 0)?)))

# Helper: wrap a binary (f64, f64)->f64 function
fn _wrap_binary_float(args: [Value], func: fn(f64, f64) -> f64) -> Result<Value, InterpreterError>:
    Ok(Value.float(func(_get_float_arg(args, 0)?, _get_float_arg(args, 1)?)))

# Helper: wrap a unary f64->bool function
fn _wrap_unary_float_to_bool(args: [Value], func: fn(f64) -> bool) -> Result<Value, InterpreterError>:
    Ok(Value.bool(func(_get_float_arg(args, 0)?)))

# Helper: wrap a binary (i64, i64)->i64 function
fn _wrap_binary_int(args: [Value], func: fn(i64, i64) -> i64) -> Result<Value, InterpreterError>:
    Ok(Value.int(func(_get_int_arg(args, 0)?, _get_int_arg(args, 1)?)))

# Unary float wrappers (f64 -> f64)
fn rt_math_log_extern(args: [Value]) -> Result<Value, InterpreterError>:
    _wrap_unary_float(args, rt_math_log)

fn rt_math_log10_extern(args: [Value]) -> Result<Value, InterpreterError>:
    _wrap_unary_float(args, rt_math_log10)

fn rt_math_log2_extern(args: [Value]) -> Result<Value, InterpreterError>:
    _wrap_unary_float(args, rt_math_log2)

fn rt_math_exp_extern(args: [Value]) -> Result<Value, InterpreterError>:
    _wrap_unary_float(args, rt_math_exp)

fn rt_math_sqrt_extern(args: [Value]) -> Result<Value, InterpreterError>:
    _wrap_unary_float(args, rt_math_sqrt)

fn rt_math_cbrt_extern(args: [Value]) -> Result<Value, InterpreterError>:
    _wrap_unary_float(args, rt_math_cbrt)

fn rt_math_sin_extern(args: [Value]) -> Result<Value, InterpreterError>:
    _wrap_unary_float(args, rt_math_sin)

fn rt_math_cos_extern(args: [Value]) -> Result<Value, InterpreterError>:
    _wrap_unary_float(args, rt_math_cos)

fn rt_math_tan_extern(args: [Value]) -> Result<Value, InterpreterError>:
    _wrap_unary_float(args, rt_math_tan)

fn rt_math_asin_extern(args: [Value]) -> Result<Value, InterpreterError>:
    _wrap_unary_float(args, rt_math_asin)

fn rt_math_acos_extern(args: [Value]) -> Result<Value, InterpreterError>:
    _wrap_unary_float(args, rt_math_acos)

fn rt_math_atan_extern(args: [Value]) -> Result<Value, InterpreterError>:
    _wrap_unary_float(args, rt_math_atan)

fn rt_math_sinh_extern(args: [Value]) -> Result<Value, InterpreterError>:
    _wrap_unary_float(args, rt_math_sinh)

fn rt_math_cosh_extern(args: [Value]) -> Result<Value, InterpreterError>:
    _wrap_unary_float(args, rt_math_cosh)

fn rt_math_tanh_extern(args: [Value]) -> Result<Value, InterpreterError>:
    _wrap_unary_float(args, rt_math_tanh)

fn rt_math_floor_extern(args: [Value]) -> Result<Value, InterpreterError>:
    _wrap_unary_float(args, rt_math_floor_f)

fn rt_math_ceil_extern(args: [Value]) -> Result<Value, InterpreterError>:
    _wrap_unary_float(args, rt_math_ceil_f)

fn rt_math_round_extern(args: [Value]) -> Result<Value, InterpreterError>:
    _wrap_unary_float(args, rt_math_round)

fn rt_math_trunc_extern(args: [Value]) -> Result<Value, InterpreterError>:
    _wrap_unary_float(args, rt_math_trunc)

fn rt_math_abs_extern(args: [Value]) -> Result<Value, InterpreterError>:
    _wrap_unary_float(args, rt_math_abs)

fn rt_math_sign_extern(args: [Value]) -> Result<Value, InterpreterError>:
    _wrap_unary_float(args, rt_math_sign)

fn rt_math_fract_extern(args: [Value]) -> Result<Value, InterpreterError>:
    _wrap_unary_float(args, rt_math_fract)

# Binary float wrappers (f64, f64 -> f64)
fn rt_math_pow_extern(args: [Value]) -> Result<Value, InterpreterError>:
    _wrap_binary_float(args, rt_math_pow)

fn rt_math_atan2_extern(args: [Value]) -> Result<Value, InterpreterError>:
    _wrap_binary_float(args, rt_math_atan2)

fn rt_math_hypot_extern(args: [Value]) -> Result<Value, InterpreterError>:
    _wrap_binary_float(args, rt_math_hypot)

fn rt_math_min_f_extern(args: [Value]) -> Result<Value, InterpreterError>:
    _wrap_binary_float(args, rt_math_min_f)

fn rt_math_max_f_extern(args: [Value]) -> Result<Value, InterpreterError>:
    _wrap_binary_float(args, rt_math_max_f)

fn rt_math_rem_extern(args: [Value]) -> Result<Value, InterpreterError>:
    _wrap_binary_float(args, rt_math_rem)

# Float-to-bool wrappers (f64 -> bool)
fn rt_math_is_nan_extern(args: [Value]) -> Result<Value, InterpreterError>:
    _wrap_unary_float_to_bool(args, rt_math_is_nan)

fn rt_math_is_inf_extern(args: [Value]) -> Result<Value, InterpreterError>:
    _wrap_unary_float_to_bool(args, rt_math_is_inf)

fn rt_math_is_finite_extern(args: [Value]) -> Result<Value, InterpreterError>:
    _wrap_unary_float_to_bool(args, rt_math_is_finite)

# Binary int wrappers (i64, i64 -> i64)
fn rt_math_gcd_extern(args: [Value]) -> Result<Value, InterpreterError>:
    _wrap_binary_int(args, rt_math_gcd)

fn rt_math_lcm_extern(args: [Value]) -> Result<Value, InterpreterError>:
    _wrap_binary_int(args, rt_math_lcm)

# Zero-arg wrappers
fn rt_math_nan_extern(args: [Value]) -> Result<Value, InterpreterError>:
    Ok(Value.float(rt_math_nan()))

fn rt_math_inf_extern(args: [Value]) -> Result<Value, InterpreterError>:
    Ok(Value.float(rt_math_inf()))

# Ternary float wrapper (special case: 3 args)
fn rt_math_clamp_extern(args: [Value]) -> Result<Value, InterpreterError>:
    Ok(Value.float(rt_math_clamp(_get_float_arg(args, 0)?, _get_float_arg(args, 1)?, _get_float_arg(args, 2)?)))

# === Pure Simple implementations (no FFI needed) ===

fn gcd_pure(a: i64, b: i64) -> i64:
    var x = if a < 0: -a else: a
    var y = if b < 0: -b else: b
    while y != 0:
        val t = y
        y = x % y
        x = t
    x

fn lcm_pure(a: i64, b: i64) -> i64:
    if a == 0 or b == 0:
        return 0
    val g = gcd_pure(a, b)
    val abs_a = if a < 0: -a else: a
    val abs_b = if b < 0: -b else: b
    (abs_a / g) * abs_b

fn clamp_int(x: i64, min_val: i64, max_val: i64) -> i64:
    if x < min_val: min_val
    elif x > max_val: max_val
    else: x

fn sign_int(x: i64) -> i64:
    if x > 0: 1
    elif x < 0: -1
    else: 0
