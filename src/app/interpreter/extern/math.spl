# Math Extern Functions
#
# Integer math operations + float math FFI wrappers.
# Port of rust/compiler/src/interpreter_extern/math.rs

from ..core import {Value, InterpreterError}

export abs_extern, min_extern, max_extern, sqrt_extern
export floor_extern, ceil_extern, pow_extern
export rt_math_pow_extern, rt_math_log_extern, rt_math_log10_extern
export rt_math_log2_extern, rt_math_exp_extern, rt_math_sqrt_extern
export rt_math_cbrt_extern, rt_math_sin_extern, rt_math_cos_extern
export rt_math_tan_extern, rt_math_asin_extern, rt_math_acos_extern
export rt_math_atan_extern, rt_math_atan2_extern
export rt_math_sinh_extern, rt_math_cosh_extern, rt_math_tanh_extern
export rt_math_floor_extern, rt_math_ceil_extern
export rt_math_nan_extern, rt_math_inf_extern
export rt_math_is_nan_extern, rt_math_is_inf_extern, rt_math_is_finite_extern
export rt_math_round_extern, rt_math_trunc_extern, rt_math_abs_extern
export rt_math_hypot_extern, rt_math_gcd_extern, rt_math_lcm_extern
export rt_math_min_f_extern, rt_math_max_f_extern, rt_math_clamp_extern
export rt_math_sign_extern, rt_math_fract_extern, rt_math_rem_extern
export gcd_pure, lcm_pure, clamp_int, sign_int

# === Integer Math (pure logic) ===

fn _get_int_arg(args: [Value], idx: i64) -> Result<i64, InterpreterError>:
    if idx >= args.len():
        return Err(InterpreterError.ArityError("expected more arguments"))
    args[idx].as_int() ?? Err(InterpreterError.TypeError("expected integer argument"))

fn abs_extern(args: [Value]) -> Result<Value, InterpreterError>:
    val n = _get_int_arg(args, 0)?
    Ok(Value.int(if n < 0: -n else: n))

fn min_extern(args: [Value]) -> Result<Value, InterpreterError>:
    val a = _get_int_arg(args, 0)?
    val b = _get_int_arg(args, 1)?
    Ok(Value.int(if a < b: a else: b))

fn max_extern(args: [Value]) -> Result<Value, InterpreterError>:
    val a = _get_int_arg(args, 0)?
    val b = _get_int_arg(args, 1)?
    Ok(Value.int(if a > b: a else: b))

fn sqrt_extern(args: [Value]) -> Result<Value, InterpreterError>:
    val n = _get_int_arg(args, 0)?
    # Integer sqrt via float conversion
    # TODO: Replace direct FFI call with wrapper (math_sqrt) from app.io or compiler.ffi
    Ok(Value.int(rt_math_sqrt(n.to_float()).to_int()))

fn floor_extern(args: [Value]) -> Result<Value, InterpreterError>:
    val n = _get_int_arg(args, 0)?
    Ok(Value.int(n))

fn ceil_extern(args: [Value]) -> Result<Value, InterpreterError>:
    val n = _get_int_arg(args, 0)?
    Ok(Value.int(n))

fn pow_extern(args: [Value]) -> Result<Value, InterpreterError>:
    val base = _get_int_arg(args, 0)?
    val exp = _get_int_arg(args, 1)?
    var result = 1
    for _ in 0..exp:
        result = result * base
    Ok(Value.int(result))

# === Float Math (FFI wrappers - call into runtime) ===

@extern("rt_math_pow")
# TODO: Replace direct FFI call with wrapper (math_pow) from app.io or compiler.ffi
fn rt_math_pow(base: f64, exp: f64) -> f64

@extern("rt_math_log")
# TODO: Replace direct FFI call with wrapper (math_log) from app.io or compiler.ffi
fn rt_math_log(x: f64) -> f64

@extern("rt_math_log10")
fn rt_math_log10(x: f64) -> f64

@extern("rt_math_log2")
fn rt_math_log2(x: f64) -> f64

@extern("rt_math_exp")
# TODO: Replace direct FFI call with wrapper (math_exp) from app.io or compiler.ffi
fn rt_math_exp(x: f64) -> f64

@extern("rt_math_sqrt")
# TODO: Replace direct FFI call with wrapper (math_sqrt) from app.io or compiler.ffi
fn rt_math_sqrt(x: f64) -> f64

@extern("rt_math_cbrt")
# TODO: Replace direct FFI call with wrapper (math_cbrt) from app.io or compiler.ffi
fn rt_math_cbrt(x: f64) -> f64

@extern("rt_math_sin")
# TODO: Replace direct FFI call with wrapper (math_sin) from app.io or compiler.ffi
fn rt_math_sin(x: f64) -> f64

@extern("rt_math_cos")
# TODO: Replace direct FFI call with wrapper (math_cos) from app.io or compiler.ffi
fn rt_math_cos(x: f64) -> f64

@extern("rt_math_tan")
# TODO: Replace direct FFI call with wrapper (math_tan) from app.io or compiler.ffi
fn rt_math_tan(x: f64) -> f64

@extern("rt_math_asin")
# TODO: Replace direct FFI call with wrapper (math_asin) from app.io or compiler.ffi
fn rt_math_asin(x: f64) -> f64

@extern("rt_math_acos")
# TODO: Replace direct FFI call with wrapper (math_acos) from app.io or compiler.ffi
fn rt_math_acos(x: f64) -> f64

@extern("rt_math_atan")
# TODO: Replace direct FFI call with wrapper (math_atan) from app.io or compiler.ffi
fn rt_math_atan(x: f64) -> f64

@extern("rt_math_atan2")
fn rt_math_atan2(y: f64, x: f64) -> f64

@extern("rt_math_sinh")
# TODO: Replace direct FFI call with wrapper (math_sinh) from app.io or compiler.ffi
fn rt_math_sinh(x: f64) -> f64

@extern("rt_math_cosh")
# TODO: Replace direct FFI call with wrapper (math_cosh) from app.io or compiler.ffi
fn rt_math_cosh(x: f64) -> f64

@extern("rt_math_tanh")
# TODO: Replace direct FFI call with wrapper (math_tanh) from app.io or compiler.ffi
fn rt_math_tanh(x: f64) -> f64

@extern("rt_math_floor")
# TODO: Replace direct FFI call with wrapper (math_floor_f) from app.io or compiler.ffi
fn rt_math_floor_f(x: f64) -> f64

@extern("rt_math_ceil")
# TODO: Replace direct FFI call with wrapper (math_ceil_f) from app.io or compiler.ffi
fn rt_math_ceil_f(x: f64) -> f64

@extern("rt_math_nan")
# TODO: Replace direct FFI call with wrapper (math_nan) from app.io or compiler.ffi
fn rt_math_nan() -> f64

@extern("rt_math_inf")
fn rt_math_inf() -> f64

@extern("rt_math_is_nan")
fn rt_math_is_nan(x: f64) -> bool

@extern("rt_math_is_inf")
fn rt_math_is_inf(x: f64) -> bool

@extern("rt_math_is_finite")
fn rt_math_is_finite(x: f64) -> bool

@extern("rt_math_round")
# TODO: Replace direct FFI call with wrapper (math_round) from app.io or compiler.ffi
fn rt_math_round(x: f64) -> f64

@extern("rt_math_trunc")
# TODO: Replace direct FFI call with wrapper (math_trunc) from app.io or compiler.ffi
fn rt_math_trunc(x: f64) -> f64

@extern("rt_math_abs")
# TODO: Replace direct FFI call with wrapper (math_abs) from app.io or compiler.ffi
fn rt_math_abs(x: f64) -> f64

@extern("rt_math_hypot")
# TODO: Replace direct FFI call with wrapper (math_hypot) from app.io or compiler.ffi
fn rt_math_hypot(x: f64, y: f64) -> f64

@extern("rt_math_gcd")
# TODO: Replace direct FFI call with wrapper (math_gcd) from app.io or compiler.ffi
fn rt_math_gcd(a: i64, b: i64) -> i64

@extern("rt_math_lcm")
# TODO: Replace direct FFI call with wrapper (math_lcm) from app.io or compiler.ffi
fn rt_math_lcm(a: i64, b: i64) -> i64

@extern("rt_math_min")
# TODO: Replace direct FFI call with wrapper (math_min_f) from app.io or compiler.ffi
fn rt_math_min_f(x: f64, y: f64) -> f64

@extern("rt_math_max")
# TODO: Replace direct FFI call with wrapper (math_max_f) from app.io or compiler.ffi
fn rt_math_max_f(x: f64, y: f64) -> f64

@extern("rt_math_clamp")
# TODO: Replace direct FFI call with wrapper (math_clamp) from app.io or compiler.ffi
fn rt_math_clamp(x: f64, min_val: f64, max_val: f64) -> f64

@extern("rt_math_sign")
# TODO: Replace direct FFI call with wrapper (math_sign) from app.io or compiler.ffi
fn rt_math_sign(x: f64) -> f64

@extern("rt_math_fract")
# TODO: Replace direct FFI call with wrapper (math_fract) from app.io or compiler.ffi
fn rt_math_fract(x: f64) -> f64

@extern("rt_math_rem")
# TODO: Replace direct FFI call with wrapper (math_rem) from app.io or compiler.ffi
fn rt_math_rem(x: f64, y: f64) -> f64

# Float math wrapper functions that take Value args

fn _get_float_arg(args: [Value], idx: i64) -> Result<f64, InterpreterError>:
    if idx >= args.len():
        return Err(InterpreterError.ArityError("expected more arguments"))
    args[idx].as_float() ?? Err(InterpreterError.TypeError("expected float argument"))

# TODO: Replace direct FFI call with wrapper (math_pow_extern) from app.io or compiler.ffi
fn rt_math_pow_extern(args: [Value]) -> Result<Value, InterpreterError>:
    # TODO: Replace direct FFI call with wrapper (math_pow) from app.io or compiler.ffi
    Ok(Value.float(rt_math_pow(_get_float_arg(args, 0)?, _get_float_arg(args, 1)?)))

# TODO: Replace direct FFI call with wrapper (math_log_extern) from app.io or compiler.ffi
fn rt_math_log_extern(args: [Value]) -> Result<Value, InterpreterError>:
    # TODO: Replace direct FFI call with wrapper (math_log) from app.io or compiler.ffi
    Ok(Value.float(rt_math_log(_get_float_arg(args, 0)?)))

fn rt_math_log10_extern(args: [Value]) -> Result<Value, InterpreterError>:
    Ok(Value.float(rt_math_log10(_get_float_arg(args, 0)?)))

fn rt_math_log2_extern(args: [Value]) -> Result<Value, InterpreterError>:
    Ok(Value.float(rt_math_log2(_get_float_arg(args, 0)?)))

# TODO: Replace direct FFI call with wrapper (math_exp_extern) from app.io or compiler.ffi
fn rt_math_exp_extern(args: [Value]) -> Result<Value, InterpreterError>:
    # TODO: Replace direct FFI call with wrapper (math_exp) from app.io or compiler.ffi
    Ok(Value.float(rt_math_exp(_get_float_arg(args, 0)?)))

# TODO: Replace direct FFI call with wrapper (math_sqextern) from app.io or compiler.ffi
fn rt_math_sqrt_extern(args: [Value]) -> Result<Value, InterpreterError>:
    # TODO: Replace direct FFI call with wrapper (math_sqrt) from app.io or compiler.ffi
    Ok(Value.float(rt_math_sqrt(_get_float_arg(args, 0)?)))

# TODO: Replace direct FFI call with wrapper (math_cbextern) from app.io or compiler.ffi
fn rt_math_cbrt_extern(args: [Value]) -> Result<Value, InterpreterError>:
    # TODO: Replace direct FFI call with wrapper (math_cbrt) from app.io or compiler.ffi
    Ok(Value.float(rt_math_cbrt(_get_float_arg(args, 0)?)))

# TODO: Replace direct FFI call with wrapper (math_sin_extern) from app.io or compiler.ffi
fn rt_math_sin_extern(args: [Value]) -> Result<Value, InterpreterError>:
    # TODO: Replace direct FFI call with wrapper (math_sin) from app.io or compiler.ffi
    Ok(Value.float(rt_math_sin(_get_float_arg(args, 0)?)))

# TODO: Replace direct FFI call with wrapper (math_cos_extern) from app.io or compiler.ffi
fn rt_math_cos_extern(args: [Value]) -> Result<Value, InterpreterError>:
    # TODO: Replace direct FFI call with wrapper (math_cos) from app.io or compiler.ffi
    Ok(Value.float(rt_math_cos(_get_float_arg(args, 0)?)))

# TODO: Replace direct FFI call with wrapper (math_tan_extern) from app.io or compiler.ffi
fn rt_math_tan_extern(args: [Value]) -> Result<Value, InterpreterError>:
    # TODO: Replace direct FFI call with wrapper (math_tan) from app.io or compiler.ffi
    Ok(Value.float(rt_math_tan(_get_float_arg(args, 0)?)))

# TODO: Replace direct FFI call with wrapper (math_asin_extern) from app.io or compiler.ffi
fn rt_math_asin_extern(args: [Value]) -> Result<Value, InterpreterError>:
    # TODO: Replace direct FFI call with wrapper (math_asin) from app.io or compiler.ffi
    Ok(Value.float(rt_math_asin(_get_float_arg(args, 0)?)))

# TODO: Replace direct FFI call with wrapper (math_acos_extern) from app.io or compiler.ffi
fn rt_math_acos_extern(args: [Value]) -> Result<Value, InterpreterError>:
    # TODO: Replace direct FFI call with wrapper (math_acos) from app.io or compiler.ffi
    Ok(Value.float(rt_math_acos(_get_float_arg(args, 0)?)))

# TODO: Replace direct FFI call with wrapper (math_atan_extern) from app.io or compiler.ffi
fn rt_math_atan_extern(args: [Value]) -> Result<Value, InterpreterError>:
    # TODO: Replace direct FFI call with wrapper (math_atan) from app.io or compiler.ffi
    Ok(Value.float(rt_math_atan(_get_float_arg(args, 0)?)))

fn rt_math_atan2_extern(args: [Value]) -> Result<Value, InterpreterError>:
    Ok(Value.float(rt_math_atan2(_get_float_arg(args, 0)?, _get_float_arg(args, 1)?)))

# TODO: Replace direct FFI call with wrapper (math_sinh_extern) from app.io or compiler.ffi
fn rt_math_sinh_extern(args: [Value]) -> Result<Value, InterpreterError>:
    # TODO: Replace direct FFI call with wrapper (math_sinh) from app.io or compiler.ffi
    Ok(Value.float(rt_math_sinh(_get_float_arg(args, 0)?)))

# TODO: Replace direct FFI call with wrapper (math_cosh_extern) from app.io or compiler.ffi
fn rt_math_cosh_extern(args: [Value]) -> Result<Value, InterpreterError>:
    # TODO: Replace direct FFI call with wrapper (math_cosh) from app.io or compiler.ffi
    Ok(Value.float(rt_math_cosh(_get_float_arg(args, 0)?)))

# TODO: Replace direct FFI call with wrapper (math_tanh_extern) from app.io or compiler.ffi
fn rt_math_tanh_extern(args: [Value]) -> Result<Value, InterpreterError>:
    # TODO: Replace direct FFI call with wrapper (math_tanh) from app.io or compiler.ffi
    Ok(Value.float(rt_math_tanh(_get_float_arg(args, 0)?)))

# TODO: Replace direct FFI call with wrapper (math_floor_extern) from app.io or compiler.ffi
fn rt_math_floor_extern(args: [Value]) -> Result<Value, InterpreterError>:
    # TODO: Replace direct FFI call with wrapper (math_floor_f) from app.io or compiler.ffi
    Ok(Value.float(rt_math_floor_f(_get_float_arg(args, 0)?)))

# TODO: Replace direct FFI call with wrapper (math_ceil_extern) from app.io or compiler.ffi
fn rt_math_ceil_extern(args: [Value]) -> Result<Value, InterpreterError>:
    # TODO: Replace direct FFI call with wrapper (math_ceil_f) from app.io or compiler.ffi
    Ok(Value.float(rt_math_ceil_f(_get_float_arg(args, 0)?)))

# TODO: Replace direct FFI call with wrapper (math_nan_extern) from app.io or compiler.ffi
fn rt_math_nan_extern(args: [Value]) -> Result<Value, InterpreterError>:
    # TODO: Replace direct FFI call with wrapper (math_nan) from app.io or compiler.ffi
    Ok(Value.float(rt_math_nan()))

# TODO: Replace direct FFI call with wrapper (math_inf_extern) from app.io or compiler.ffi
fn rt_math_inf_extern(args: [Value]) -> Result<Value, InterpreterError>:
    # TODO: Replace direct FFI call with wrapper (math_inf) from app.io or compiler.ffi
    Ok(Value.float(rt_math_inf()))

# TODO: Replace direct FFI call with wrapper (math_is_nan_extern) from app.io or compiler.ffi
fn rt_math_is_nan_extern(args: [Value]) -> Result<Value, InterpreterError>:
    # TODO: Replace direct FFI call with wrapper (math_is_nan) from app.io or compiler.ffi
    Ok(Value.bool(rt_math_is_nan(_get_float_arg(args, 0)?)))

# TODO: Replace direct FFI call with wrapper (math_is_inf_extern) from app.io or compiler.ffi
fn rt_math_is_inf_extern(args: [Value]) -> Result<Value, InterpreterError>:
    # TODO: Replace direct FFI call with wrapper (math_is_inf) from app.io or compiler.ffi
    Ok(Value.bool(rt_math_is_inf(_get_float_arg(args, 0)?)))

# TODO: Replace direct FFI call with wrapper (math_is_finite_extern) from app.io or compiler.ffi
fn rt_math_is_finite_extern(args: [Value]) -> Result<Value, InterpreterError>:
    # TODO: Replace direct FFI call with wrapper (math_is_finite) from app.io or compiler.ffi
    Ok(Value.bool(rt_math_is_finite(_get_float_arg(args, 0)?)))

# TODO: Replace direct FFI call with wrapper (math_round_extern) from app.io or compiler.ffi
fn rt_math_round_extern(args: [Value]) -> Result<Value, InterpreterError>:
    # TODO: Replace direct FFI call with wrapper (math_round) from app.io or compiler.ffi
    Ok(Value.float(rt_math_round(_get_float_arg(args, 0)?)))

# TODO: Replace direct FFI call with wrapper (math_trunc_extern) from app.io or compiler.ffi
fn rt_math_trunc_extern(args: [Value]) -> Result<Value, InterpreterError>:
    # TODO: Replace direct FFI call with wrapper (math_trunc) from app.io or compiler.ffi
    Ok(Value.float(rt_math_trunc(_get_float_arg(args, 0)?)))

# TODO: Replace direct FFI call with wrapper (math_abs_extern) from app.io or compiler.ffi
fn rt_math_abs_extern(args: [Value]) -> Result<Value, InterpreterError>:
    # TODO: Replace direct FFI call with wrapper (math_abs) from app.io or compiler.ffi
    Ok(Value.float(rt_math_abs(_get_float_arg(args, 0)?)))

# TODO: Replace direct FFI call with wrapper (math_hypot_extern) from app.io or compiler.ffi
fn rt_math_hypot_extern(args: [Value]) -> Result<Value, InterpreterError>:
    # TODO: Replace direct FFI call with wrapper (math_hypot) from app.io or compiler.ffi
    Ok(Value.float(rt_math_hypot(_get_float_arg(args, 0)?, _get_float_arg(args, 1)?)))

# TODO: Replace direct FFI call with wrapper (math_gcd_extern) from app.io or compiler.ffi
fn rt_math_gcd_extern(args: [Value]) -> Result<Value, InterpreterError>:
    # TODO: Replace direct FFI call with wrapper (math_gcd) from app.io or compiler.ffi
    Ok(Value.int(rt_math_gcd(_get_int_arg(args, 0)?, _get_int_arg(args, 1)?)))

# TODO: Replace direct FFI call with wrapper (math_lcm_extern) from app.io or compiler.ffi
fn rt_math_lcm_extern(args: [Value]) -> Result<Value, InterpreterError>:
    # TODO: Replace direct FFI call with wrapper (math_lcm) from app.io or compiler.ffi
    Ok(Value.int(rt_math_lcm(_get_int_arg(args, 0)?, _get_int_arg(args, 1)?)))

# TODO: Replace direct FFI call with wrapper (math_min_f_extern) from app.io or compiler.ffi
fn rt_math_min_f_extern(args: [Value]) -> Result<Value, InterpreterError>:
    # TODO: Replace direct FFI call with wrapper (math_min_f) from app.io or compiler.ffi
    Ok(Value.float(rt_math_min_f(_get_float_arg(args, 0)?, _get_float_arg(args, 1)?)))

# TODO: Replace direct FFI call with wrapper (math_max_f_extern) from app.io or compiler.ffi
fn rt_math_max_f_extern(args: [Value]) -> Result<Value, InterpreterError>:
    # TODO: Replace direct FFI call with wrapper (math_max_f) from app.io or compiler.ffi
    Ok(Value.float(rt_math_max_f(_get_float_arg(args, 0)?, _get_float_arg(args, 1)?)))

# TODO: Replace direct FFI call with wrapper (math_clamp_extern) from app.io or compiler.ffi
fn rt_math_clamp_extern(args: [Value]) -> Result<Value, InterpreterError>:
    # TODO: Replace direct FFI call with wrapper (math_clamp) from app.io or compiler.ffi
    Ok(Value.float(rt_math_clamp(_get_float_arg(args, 0)?, _get_float_arg(args, 1)?, _get_float_arg(args, 2)?)))

# TODO: Replace direct FFI call with wrapper (math_sign_extern) from app.io or compiler.ffi
fn rt_math_sign_extern(args: [Value]) -> Result<Value, InterpreterError>:
    # TODO: Replace direct FFI call with wrapper (math_sign) from app.io or compiler.ffi
    Ok(Value.float(rt_math_sign(_get_float_arg(args, 0)?)))

# TODO: Replace direct FFI call with wrapper (math_fract_extern) from app.io or compiler.ffi
fn rt_math_fract_extern(args: [Value]) -> Result<Value, InterpreterError>:
    # TODO: Replace direct FFI call with wrapper (math_fract) from app.io or compiler.ffi
    Ok(Value.float(rt_math_fract(_get_float_arg(args, 0)?)))

# TODO: Replace direct FFI call with wrapper (math_rem_extern) from app.io or compiler.ffi
fn rt_math_rem_extern(args: [Value]) -> Result<Value, InterpreterError>:
    # TODO: Replace direct FFI call with wrapper (math_rem) from app.io or compiler.ffi
    Ok(Value.float(rt_math_rem(_get_float_arg(args, 0)?, _get_float_arg(args, 1)?)))

# === Pure Simple implementations (no FFI needed) ===

fn gcd_pure(a: i64, b: i64) -> i64:
    var x = if a < 0: -a else: a
    var y = if b < 0: -b else: b
    while y != 0:
        val t = y
        y = x % y
        x = t
    x

fn lcm_pure(a: i64, b: i64) -> i64:
    if a == 0 or b == 0:
        return 0
    val g = gcd_pure(a, b)
    val abs_a = if a < 0: -a else: a
    val abs_b = if b < 0: -b else: b
    (abs_a / g) * abs_b

fn clamp_int(x: i64, min_val: i64, max_val: i64) -> i64:
    if x < min_val: min_val
    elif x > max_val: max_val
    else: x

fn sign_int(x: i64) -> i64:
    if x > 0: 1
    elif x < 0: -1
    else: 0
