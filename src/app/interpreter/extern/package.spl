# Package Management Extern Functions
#
# FFI wrappers for package operations (sha256, tarball, filesystem).
# Port of rust/compiler/src/interpreter_extern/package.rs

from ..core import {Value, InterpreterError}

export package_sha256, package_create_tarball, package_extract_tarball
export package_file_size, package_copy_file, package_mkdir_all
export package_remove_dir_all, package_create_symlink, package_chmod
export package_exists, package_is_dir

# FFI declarations
@extern("rt_package_sha256")
fn _sha256(path: text) -> text

@extern("rt_package_create_tarball")
fn _create_tarball(source: text, output: text) -> i32

@extern("rt_package_extract_tarball")
fn _extract_tarball(tarball: text, dest: text) -> i32

@extern("rt_package_file_size")
fn _file_size(path: text) -> i64

@extern("rt_package_copy_file")
fn _copy_file(src: text, dst: text) -> i32

@extern("rt_package_mkdir_all")
fn _mkdir_all(path: text) -> i32

@extern("rt_package_remove_dir_all")
fn _remove_dir_all(path: text) -> i32

@extern("rt_package_create_symlink")
fn _create_symlink(target: text, link: text) -> i32

@extern("rt_package_chmod")
fn _chmod(path: text, mode: i32) -> i32

@extern("rt_package_exists")
fn _exists(path: text) -> i32

@extern("rt_package_is_dir")
fn _is_dir(path: text) -> i32

fn _get_text_arg(args: [Value], idx: i64, name: text) -> Result<text, InterpreterError>:
    if idx >= args.len():
        return Err(InterpreterError.ArityError("expected more arguments"))
    args[idx].as_string() ?? Err(InterpreterError.TypeError("expected text, got {args[idx].type_name()}"))

fn package_sha256(args: [Value]) -> Result<Value, InterpreterError>:
    if args.len() != 1:
        return Err(InterpreterError.ArityError("rt_package_sha256 expects 1 argument"))
    Ok(Value.string(_sha256(_get_text_arg(args, 0, "path")?)))

fn package_create_tarball(args: [Value]) -> Result<Value, InterpreterError>:
    if args.len() != 2:
        return Err(InterpreterError.ArityError("rt_package_create_tarball expects 2 arguments"))
    Ok(Value.int(_create_tarball(
        _get_text_arg(args, 0, "source")?, _get_text_arg(args, 1, "output")?).to_i64()))

fn package_extract_tarball(args: [Value]) -> Result<Value, InterpreterError>:
    if args.len() != 2:
        return Err(InterpreterError.ArityError("rt_package_extract_tarball expects 2 arguments"))
    Ok(Value.int(_extract_tarball(
        _get_text_arg(args, 0, "tarball")?, _get_text_arg(args, 1, "dest")?).to_i64()))

fn package_file_size(args: [Value]) -> Result<Value, InterpreterError>:
    if args.len() != 1:
        return Err(InterpreterError.ArityError("rt_package_file_size expects 1 argument"))
    Ok(Value.int(_file_size(_get_text_arg(args, 0, "path")?)))

fn package_copy_file(args: [Value]) -> Result<Value, InterpreterError>:
    if args.len() != 2:
        return Err(InterpreterError.ArityError("rt_package_copy_file expects 2 arguments"))
    Ok(Value.int(_copy_file(
        _get_text_arg(args, 0, "src")?, _get_text_arg(args, 1, "dst")?).to_i64()))

fn package_mkdir_all(args: [Value]) -> Result<Value, InterpreterError>:
    if args.len() != 1:
        return Err(InterpreterError.ArityError("rt_package_mkdir_all expects 1 argument"))
    Ok(Value.int(_mkdir_all(_get_text_arg(args, 0, "path")?).to_i64()))

fn package_remove_dir_all(args: [Value]) -> Result<Value, InterpreterError>:
    if args.len() != 1:
        return Err(InterpreterError.ArityError("rt_package_remove_dir_all expects 1 argument"))
    Ok(Value.int(_remove_dir_all(_get_text_arg(args, 0, "path")?).to_i64()))

fn package_create_symlink(args: [Value]) -> Result<Value, InterpreterError>:
    if args.len() != 2:
        return Err(InterpreterError.ArityError("rt_package_create_symlink expects 2 arguments"))
    Ok(Value.int(_create_symlink(
        _get_text_arg(args, 0, "target")?, _get_text_arg(args, 1, "link")?).to_i64()))

fn package_chmod(args: [Value]) -> Result<Value, InterpreterError>:
    if args.len() != 2:
        return Err(InterpreterError.ArityError("rt_package_chmod expects 2 arguments"))
    val path = _get_text_arg(args, 0, "path")?
    val mode = args[1].as_int() ?? return Err(InterpreterError.TypeError("mode must be integer"))
    Ok(Value.int(_chmod(path, mode.to_i32()).to_i64()))

fn package_exists(args: [Value]) -> Result<Value, InterpreterError>:
    if args.len() != 1:
        return Err(InterpreterError.ArityError("rt_package_exists expects 1 argument"))
    Ok(Value.int(_exists(_get_text_arg(args, 0, "path")?).to_i64()))

fn package_is_dir(args: [Value]) -> Result<Value, InterpreterError>:
    if args.len() != 1:
        return Err(InterpreterError.ArityError("rt_package_is_dir expects 1 argument"))
    Ok(Value.int(_is_dir(_get_text_arg(args, 0, "path")?).to_i64()))
