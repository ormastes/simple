# Interpreter Debug Backend
# Implements DebugBackend trait for the tree-walking interpreter.
# Delegates to rt_debug_* FFI functions for breakpoint/step state,
# and to the interpreter for execution.

use core.*
use app.debug.coordinator.{DebugBackend, FrameInfo, VarInfo, LocationInfo}

# FFI declarations for debug runtime functions
extern fn rt_debug_set_active(active: i64)
extern fn rt_debug_is_active() -> i64
extern fn rt_debug_add_breakpoint(file_ptr: i64, file_len: i64, line: i64) -> i64
extern fn rt_debug_remove_breakpoint(file_ptr: i64, file_len: i64, line: i64) -> i64
extern fn rt_debug_remove_all_breakpoints()
extern fn rt_debug_list_breakpoints() -> [String]
extern fn rt_debug_set_step_mode(mode: i64)
extern fn rt_debug_pause()
extern fn rt_debug_continue()
extern fn rt_debug_stack_depth() -> i64
extern fn rt_debug_stack_trace() -> [String]
extern fn rt_debug_locals() -> [String]
extern fn rt_debug_current_file() -> String
extern fn rt_debug_current_line() -> i64

# FFI for running code
extern fn rt_cli_run_file(path: String, args: [String], debug: Bool, verbose: Bool) -> i64

# Interpreter debug backend
class InterpreterBackend:
    program_path: String
    args: [String]
    attached: Bool

    static fn create() -> InterpreterBackend:
        InterpreterBackend(
            program_path: "",
            args: [],
            attached: false
        )

impl DebugBackend for InterpreterBackend:
    fn name() -> String:
        "interpreter"

    me attach(program_path: String, args: [String]) -> Result<Nil, String>:
        self.program_path = program_path
        self.args = args
        self.attached = true
        # TODO: Replace direct FFI call with wrapper (debug_set_active) from app.io or compiler.ffi
        rt_debug_set_active(1)
        Ok(nil)

    me detach() -> Result<Nil, String>:
        # TODO: Replace direct FFI call with wrapper (debug_set_active) from app.io or compiler.ffi
        rt_debug_set_active(0)
        # TODO: Replace direct FFI call with wrapper (debug_remove_all_breakpoints) from app.io or compiler.ffi
        rt_debug_remove_all_breakpoints()
        self.attached = false
        Ok(nil)

    fn run() -> Result<Nil, String>:
        if not self.attached:
            return Err("Not attached to a program")
        # TODO: Replace direct FFI call with wrapper (debug_set_active) from app.io or compiler.ffi
        rt_debug_set_active(1)
        # The interpreter will check debug hooks via should_stop()
        # on each statement execution.
        # TODO: Replace direct FFI call with wrapper (cli_run_file) from app.io or compiler.ffi
        rt_cli_run_file(self.program_path, self.args, true, false)
        Ok(nil)

    fn pause() -> Result<Nil, String>:
        # TODO: Replace direct FFI call with wrapper (debug_pause) from app.io or compiler.ffi
        rt_debug_pause()
        Ok(nil)

    fn resume() -> Result<Nil, String>:
        # TODO: Replace direct FFI call with wrapper (debug_continue) from app.io or compiler.ffi
        rt_debug_continue()
        Ok(nil)

    fn step_over() -> Result<Nil, String>:
        # TODO: Replace direct FFI call with wrapper (debug_set_step_mode) from app.io or compiler.ffi
        rt_debug_set_step_mode(1)  # StepOver
        Ok(nil)

    fn step_in() -> Result<Nil, String>:
        # TODO: Replace direct FFI call with wrapper (debug_set_step_mode) from app.io or compiler.ffi
        rt_debug_set_step_mode(2)  # StepIn
        Ok(nil)

    fn step_out() -> Result<Nil, String>:
        # TODO: Replace direct FFI call with wrapper (debug_set_step_mode) from app.io or compiler.ffi
        rt_debug_set_step_mode(3)  # StepOut
        Ok(nil)

    fn add_breakpoint(file: String, line: Int) -> Result<Int, String>:
        # TODO: Replace direct FFI call with wrapper (debug_add_breakpoint) from app.io or compiler.ffi
        val bp_id = rt_debug_add_breakpoint(file.ptr(), file.len(), line)
        Ok(bp_id)

    fn remove_breakpoint(file: String, line: Int) -> Result<Nil, String>:
        # TODO: Replace direct FFI call with wrapper (debug_remove_breakpoint) from app.io or compiler.ffi
        rt_debug_remove_breakpoint(file.ptr(), file.len(), line)
        Ok(nil)

    fn stack_trace() -> Result<[FrameInfo], String>:
        # TODO: Replace direct FFI call with wrapper (debug_stack_trace) from app.io or compiler.ffi
        val raw_frames = rt_debug_stack_trace()
        var frames: [FrameInfo] = []
        var idx = 0
        for raw in raw_frames:
            # Format: "#0 func_name at file:line"
            frames.push(FrameInfo.of(idx, raw, "", 0))
            idx = idx + 1
        Ok(frames)

    fn locals() -> Result<[VarInfo], String>:
        # TODO: Replace direct FFI call with wrapper (debug_locals) from app.io or compiler.ffi
        val raw_locals = rt_debug_locals()
        var vars: [VarInfo] = []
        for raw in raw_locals:
            # Format: "name = value : type"
            val parts = raw.split(" = ")
            if parts.len() >= 2:
                val name = parts[0]
                val rest = parts[1]
                val type_parts = rest.split(" : ")
                val value = type_parts[0]
                val type_name = if type_parts.len() >= 2 then type_parts[1] else "unknown"
                vars.push(VarInfo.of(name, value, type_name))
            else:
                vars.push(VarInfo.of(raw, "", "unknown"))
        Ok(vars)

    fn evaluate(expr: String) -> Result<String, String>:
        # Expression evaluation in current debug context
        # Delegates to interpreter's eval_expression_string via FFI
        # For now, return the expression as-is (placeholder)
        Ok("(eval not yet connected: {expr})")

    fn current_location() -> Result<LocationInfo, String>:
        # TODO: Replace direct FFI call with wrapper (debug_current_file) from app.io or compiler.ffi
        val file = rt_debug_current_file()
        # TODO: Replace direct FFI call with wrapper (debug_current_line) from app.io or compiler.ffi
        val line = rt_debug_current_line()
        Ok(LocationInfo.at(file, line, ""))
