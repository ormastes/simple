# SMF Debug Agent
# Implements DebugBackend for debugging SMF (Simple Module Format) bytecode.
# Uses ptrace FFI for process control and SMF source maps for line mapping.

use core.*
use app.debug.coordinator.{DebugBackend, FrameInfo, VarInfo, LocationInfo}

# Ptrace FFI declarations (platform-abstracted in Rust)
extern fn rt_ptrace_attach(pid: i64) -> i64
extern fn rt_ptrace_detach(pid: i64) -> i64
extern fn rt_ptrace_continue(pid: i64) -> i64
extern fn rt_ptrace_single_step(pid: i64) -> i64
extern fn rt_ptrace_read_memory(pid: i64, addr: i64, size: i64) -> [i64]
extern fn rt_ptrace_write_memory(pid: i64, addr: i64, data: i64) -> i64
extern fn rt_ptrace_get_registers(pid: i64) -> Dict<String, i64>
extern fn rt_ptrace_wait_stop(pid: i64) -> i64

# SMF source map entry
class SourceMapEntry:
    bytecode_offset: Int
    source_file: String
    source_line: Int
    function_name: String

    static fn of(offset: Int, file: String, line: Int, func: String) -> SourceMapEntry:
        SourceMapEntry(
            bytecode_offset: offset,
            source_file: file,
            source_line: line,
            function_name: func
        )

# SMF Debug Backend
class SmfBackend:
    pid: Int                           # Process ID of the SMF runner
    program_path: String
    args: [String]
    attached: Bool
    source_map: [SourceMapEntry]   # Loaded from SMF debug info
    breakpoint_addrs: Dict<String, i64>  # "file:line" -> bytecode address
    original_bytes: Dict<i64, i64>     # addr -> original byte (for INT3 restore)

    static fn create() -> SmfBackend:
        SmfBackend(
            pid: 0,
            program_path: "",
            args: [],
            attached: false,
            source_map: [],
            breakpoint_addrs: {},
            original_bytes: {}
        )

impl DebugBackend for SmfBackend:
    fn name() -> String:
        "smf"

    fn attach(program_path: String, args: [String]) -> Result<Nil, String>:
        self.program_path = program_path
        self.args = args
        # Launch SMF runner as subprocess, get PID
        # Load source map from SMF file debug section
        # Attach via ptrace
        self.attached = true
        Ok(nil)

    fn detach() -> Result<Nil, String>:
        if self.pid > 0:
            rt_ptrace_detach(self.pid)
        self.attached = false
        Ok(nil)

    fn run() -> Result<Nil, String>:
        if not self.attached:
            return Err("Not attached")
        if self.pid > 0:
            rt_ptrace_continue(self.pid)
        Ok(nil)

    fn pause() -> Result<Nil, String>:
        # Send SIGSTOP to the process
        Ok(nil)

    fn resume() -> Result<Nil, String>:
        if self.pid > 0:
            rt_ptrace_continue(self.pid)
        Ok(nil)

    fn step_over() -> Result<Nil, String>:
        # Set temp breakpoint at next source line, then continue
        Ok(nil)

    fn step_in() -> Result<Nil, String>:
        if self.pid > 0:
            rt_ptrace_single_step(self.pid)
        Ok(nil)

    fn step_out() -> Result<Nil, String>:
        # Set temp breakpoint at return address, then continue
        Ok(nil)

    fn add_breakpoint(file: String, line: Int) -> Result<Int, String>:
        # Look up bytecode address from source map
        val key = "{file}:{line}"
        for entry in self.source_map:
            if entry.source_file == file and entry.source_line == line:
                val addr = entry.bytecode_offset
                # Save original byte and write INT3
                val orig = rt_ptrace_read_memory(self.pid, addr, 1)
                if orig.len() > 0:
                    self.original_bytes[addr] = orig[0]
                rt_ptrace_write_memory(self.pid, addr, 0xCC)  # INT3
                self.breakpoint_addrs[key] = addr
                return Ok(addr)
        Err("No source map entry for {key}")

    fn remove_breakpoint(file: String, line: Int) -> Result<Nil, String>:
        val key = "{file}:{line}"
        match self.breakpoint_addrs.get(key):
            case Some(addr):
                # Restore original byte
                match self.original_bytes.get(addr):
                    case Some(orig):
                        rt_ptrace_write_memory(self.pid, addr, orig)
                    case None:
                        pass
                self.breakpoint_addrs.remove(key)
                Ok(nil)
            case None:
                Err("No breakpoint at {key}")

    fn stack_trace() -> Result<[FrameInfo], String>:
        # Read registers, walk stack frames using SMF frame layout
        var frames: [FrameInfo] = []
        # Map instruction pointer back to source using source_map
        Ok(frames)

    fn locals() -> Result<[VarInfo], String>:
        # Read local variable slots from SMF stack frame
        var vars: [VarInfo] = []
        Ok(vars)

    fn evaluate(expr: String) -> Result<String, String>:
        Err("Expression evaluation not supported in SMF mode")

    fn current_location() -> Result<LocationInfo, String>:
        # Read instruction pointer, map to source
        Ok(LocationInfo.at("", 0, ""))
