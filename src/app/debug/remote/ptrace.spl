# Linux Ptrace Support
# Provides process tracing via ptrace syscall for native debugging.
# Two-tier SFFI: extern fn rt_ptrace_* -> fn ptrace_*() wrappers
# Uses Option pattern for error handling (nil = error, value = success).

use std.ffi.debug.{rt_ptrace_attach, rt_ptrace_detach, rt_ptrace_continue,
    rt_ptrace_single_step, rt_ptrace_wait_stop,
    rt_ptrace_read_memory, rt_ptrace_write_memory}

# Status codes returned by ptrace operations
# 0 = success, negative = error
val PTRACE_OK = 0
val PTRACE_ERROR = -1

# Ptrace session tracking a traced process
class PtraceSession:
    pid: i64
    attached: bool
    last_stop_status: i64

    static fn create(pid: i64) -> PtraceSession:
        PtraceSession(
            pid: pid,
            attached: false,
            last_stop_status: 0
        )

impl PtraceSession:
    # Attach to a running process by PID.
    # Returns error text on failure, nil on success.
    me attach() -> text:
        if self.attached:
            return ""

        val result = rt_ptrace_attach(self.pid)
        if result < 0:
            return "ptrace_attach failed for pid {self.pid}: error code {result}"

        # Wait for the process to stop after attach
        val wait_result = rt_ptrace_wait_stop(self.pid)
        if wait_result < 0:
            return "ptrace_wait_stop failed after attach for pid {self.pid}"

        self.attached = true
        self.last_stop_status = wait_result
        ""

    # Detach from the traced process.
    # Returns error text on failure, nil on success.
    me detach() -> text:
        if not self.attached:
            return "not attached to pid {self.pid}"

        val result = rt_ptrace_detach(self.pid)
        if result < 0:
            return "ptrace_detach failed for pid {self.pid}: error code {result}"

        self.attached = false
        ""

    # Continue execution of the traced process.
    # Returns error text on failure, empty string on success.
    fn continue_exec() -> text:
        if not self.attached:
            return "not attached to pid {self.pid}"

        val result = rt_ptrace_continue(self.pid)
        if result < 0:
            return "ptrace_continue failed for pid {self.pid}: error code {result}"
        ""

    # Execute a single instruction in the traced process.
    # Returns error text on failure, empty string on success.
    fn single_step() -> text:
        if not self.attached:
            return "not attached to pid {self.pid}"

        val result = rt_ptrace_single_step(self.pid)
        if result < 0:
            return "ptrace_single_step failed for pid {self.pid}: error code {result}"
        ""

    # Wait for the traced process to stop (after continue or single_step).
    # Returns the stop status, or -1 on error.
    me wait_stop() -> i64:
        if not self.attached:
            return -1

        val result = rt_ptrace_wait_stop(self.pid)
        if result >= 0:
            self.last_stop_status = result
        result

    # Read memory from the traced process address space.
    # Returns empty array on error.
    fn read_memory(addr: i64, size: i64) -> [i64]:
        if not self.attached:
            return []

        rt_ptrace_read_memory(self.pid, addr, size)

    # Write data to the traced process address space.
    # Returns 0 on success, negative on error.
    fn write_memory(addr: i64, data: [i64]) -> i64:
        if not self.attached:
            return PTRACE_ERROR

        # Write each word individually
        var offset = 0
        for word in data:
            val result = rt_ptrace_write_memory(self.pid, addr + offset * 8, word)
            if result < 0:
                return result
            offset = offset + 1
        PTRACE_OK

    # Check if we are attached to the process
    fn is_attached() -> bool:
        self.attached

    # Get the PID of the traced process
    fn get_pid() -> i64:
        self.pid

    # Get the last stop status
    fn get_last_stop_status() -> i64:
        self.last_stop_status

# --- Standalone convenience functions ---
# These wrap the raw FFI calls with error checking.

# Attach to a process. Returns 0 on success, negative on error.
fn ptrace_attach(pid: i64) -> i64:
    rt_ptrace_attach(pid)

# Detach from a process. Returns 0 on success, negative on error.
fn ptrace_detach(pid: i64) -> i64:
    rt_ptrace_detach(pid)

# Continue a traced process. Returns 0 on success, negative on error.
fn ptrace_continue(pid: i64) -> i64:
    rt_ptrace_continue(pid)

# Single-step a traced process. Returns 0 on success, negative on error.
fn ptrace_single_step(pid: i64) -> i64:
    rt_ptrace_single_step(pid)

# Wait for a traced process to stop. Returns stop status or negative on error.
fn ptrace_wait_stop(pid: i64) -> i64:
    rt_ptrace_wait_stop(pid)

# Read memory from a traced process. Returns byte array or empty on error.
fn ptrace_read_memory(pid: i64, addr: i64, size: i64) -> [i64]:
    rt_ptrace_read_memory(pid, addr, size)

# Write a word to a traced process's memory. Returns 0 on success, negative on error.
fn ptrace_write_memory(pid: i64, addr: i64, data: [i64]) -> i64:
    var offset = 0
    for word in data:
        val result = rt_ptrace_write_memory(pid, addr + offset * 8, word)
        if result < 0:
            return result
        offset = offset + 1
    PTRACE_OK

# --- Exports ---

export PTRACE_OK, PTRACE_ERROR
export PtraceSession
export ptrace_attach, ptrace_detach, ptrace_continue
export ptrace_single_step, ptrace_wait_stop
export ptrace_read_memory, ptrace_write_memory
