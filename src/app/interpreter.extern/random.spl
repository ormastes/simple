# Random Number Generation Extern Functions
#
# FFI wrappers for random number generation via runtime.
# Port of rust/compiler/src/interpreter_extern/random.rs

from ..core import {Value, InterpreterError}

export random_seed, random_getstate, random_setstate
export random_next, random_randint, random_random, random_uniform

# FFI declarations to runtime
@extern("rt_random_seed")
fn _rt_random_seed(seed: i64)

@extern("rt_random_getstate")
fn _rt_random_getstate() -> i64

@extern("rt_random_setstate")
fn _rt_random_setstate(state: i64)

@extern("rt_random_next")
fn _rt_random_next() -> i64

@extern("rt_random_randint")
fn _rt_random_randint(min: i64, max: i64) -> i64

@extern("rt_random_random")
fn _rt_random_random() -> f64

@extern("rt_random_uniform")
fn _rt_random_uniform(min: f64, max: f64) -> f64

fn random_seed(args: [Value]) -> Result<Value, InterpreterError>:
    if args.len() != 1:
        return Err(InterpreterError.ArityError("rt_random_seed expects 1 argument"))
    val seed = args[0].as_int() ?? return Err(InterpreterError.TypeError("seed must be integer"))
    _rt_random_seed(seed)
    Ok(Value.nil())

fn random_getstate(args: [Value]) -> Result<Value, InterpreterError>:
    Ok(Value.int(_rt_random_getstate()))

fn random_setstate(args: [Value]) -> Result<Value, InterpreterError>:
    if args.len() != 1:
        return Err(InterpreterError.ArityError("rt_random_setstate expects 1 argument"))
    val state = args[0].as_int() ?? return Err(InterpreterError.TypeError("state must be integer"))
    _rt_random_setstate(state)
    Ok(Value.nil())

fn random_next(args: [Value]) -> Result<Value, InterpreterError>:
    Ok(Value.int(_rt_random_next()))

fn random_randint(args: [Value]) -> Result<Value, InterpreterError>:
    if args.len() != 2:
        return Err(InterpreterError.ArityError("rt_random_randint expects 2 arguments"))
    val min = args[0].as_int() ?? return Err(InterpreterError.TypeError("min must be integer"))
    val max = args[1].as_int() ?? return Err(InterpreterError.TypeError("max must be integer"))
    Ok(Value.int(_rt_random_randint(min, max)))

fn random_random(args: [Value]) -> Result<Value, InterpreterError>:
    Ok(Value.float(_rt_random_random()))

fn random_uniform(args: [Value]) -> Result<Value, InterpreterError>:
    if args.len() != 2:
        return Err(InterpreterError.ArityError("rt_random_uniform expects 2 arguments"))
    val min = args[0].as_float() ?? return Err(InterpreterError.TypeError("min must be float"))
    val max = args[1].as_float() ?? return Err(InterpreterError.TypeError("max must be float"))
    Ok(Value.float(_rt_random_uniform(min, max)))
