# Diagram Tracing Extern Functions
#
# FFI wrappers for diagram recording + pure Mermaid generation logic.
# Port of rust/compiler/src/interpreter_extern/diagram.rs

from ..core import {Value, InterpreterError}

export diagram_enable, diagram_disable, diagram_clear, diagram_is_enabled
export diagram_trace_method, diagram_trace_method_with_args
export diagram_trace_return, diagram_mark_architectural
export diagram_generate_sequence, diagram_generate_class, diagram_generate_arch

# FFI declarations
@extern("rt_diagram_enable")
fn _enable()

@extern("rt_diagram_disable")
fn _disable()

@extern("rt_diagram_clear")
fn _clear()

@extern("rt_diagram_is_enabled")
fn _is_enabled() -> bool

@extern("rt_diagram_trace_method")
fn _trace_method(class_name: text, method_name: text)

@extern("rt_diagram_trace_method_with_args")
fn _trace_method_with_args(class_name: text, method_name: text, args: text)

@extern("rt_diagram_trace_return")
fn _trace_return(value: text?)

@extern("rt_diagram_mark_architectural")
fn _mark_architectural(entity: text)

@extern("rt_diagram_generate_sequence")
fn _generate_sequence() -> text

@extern("rt_diagram_generate_class")
fn _generate_class() -> text

@extern("rt_diagram_generate_arch")
fn _generate_arch() -> text

fn diagram_enable(args: [Value]) -> Result<Value, InterpreterError>:
    _enable()
    Ok(Value.nil())

fn diagram_disable(args: [Value]) -> Result<Value, InterpreterError>:
    _disable()
    Ok(Value.nil())

fn diagram_clear(args: [Value]) -> Result<Value, InterpreterError>:
    _clear()
    Ok(Value.nil())

fn diagram_is_enabled(args: [Value]) -> Result<Value, InterpreterError>:
    Ok(Value.bool(_is_enabled()))

fn diagram_trace_method(args: [Value]) -> Result<Value, InterpreterError>:
    if args.len() < 2:
        return Err(InterpreterError.ArityError(
            "rt_diagram_trace_method requires 2 arguments: class_name, method_name"))
    val class_name = args[0].as_string() ?? return Err(
        InterpreterError.TypeError("class_name must be a string"))
    val method_name = args[1].as_string() ?? return Err(
        InterpreterError.TypeError("method_name must be a string"))
    _trace_method(class_name, method_name)
    Ok(Value.nil())

fn diagram_trace_method_with_args(args: [Value]) -> Result<Value, InterpreterError>:
    if args.len() < 3:
        return Err(InterpreterError.ArityError(
            "rt_diagram_trace_method_with_args requires 3 arguments"))
    val class_name = args[0].as_string() ?? return Err(
        InterpreterError.TypeError("class_name must be a string"))
    val method_name = args[1].as_string() ?? return Err(
        InterpreterError.TypeError("method_name must be a string"))
    # Convert args to comma-separated string
    val arg_str = match args[2].type_name():
        case "String": args[2].as_string() ?? ""
        case "Array":
            val items = args[2].to_iterable() ?? []
            items.map(\v: v.as_string() ?? "").join(", ")
        case _: ""
    _trace_method_with_args(class_name, method_name, arg_str)
    Ok(Value.nil())

fn diagram_trace_return(args: [Value]) -> Result<Value, InterpreterError>:
    val value = if args.len() > 0:
        args[0].as_string()
    else:
        None
    _trace_return(value)
    Ok(Value.nil())

fn diagram_mark_architectural(args: [Value]) -> Result<Value, InterpreterError>:
    if args.len() < 1:
        return Err(InterpreterError.ArityError(
            "rt_diagram_mark_architectural requires 1 argument: entity"))
    val entity = args[0].as_string() ?? return Err(
        InterpreterError.TypeError("entity must be a string"))
    _mark_architectural(entity)
    Ok(Value.nil())

fn diagram_generate_sequence(args: [Value]) -> Result<Value, InterpreterError>:
    Ok(Value.string(_generate_sequence()))

fn diagram_generate_class(args: [Value]) -> Result<Value, InterpreterError>:
    Ok(Value.string(_generate_class()))

fn diagram_generate_arch(args: [Value]) -> Result<Value, InterpreterError>:
    Ok(Value.string(_generate_arch()))
