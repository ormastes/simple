# Collections Extern Functions
#
# Simple-side wrappers for high-performance Rust collection types.
# Uses opaque handle pattern: Simple holds i64 handles into Rust registries.
#
# Port of rust/compiler/src/interpreter_extern/collections.rs
# (HashMap, HashSet, BTreeMap, BTreeSet, Vec operations)

from ..core import {Value, InterpreterError}

export hashmap_new, hashmap_insert, hashmap_get, hashmap_remove
export hashmap_contains, hashmap_len, hashmap_keys, hashmap_values
export hashmap_entries, hashmap_clear, hashmap_free
export hashset_new, hashset_insert, hashset_contains, hashset_remove
export hashset_len, hashset_to_array, hashset_clear, hashset_free
export btreemap_new, btreemap_insert, btreemap_get, btreemap_remove
export btreemap_contains, btreemap_len, btreemap_keys, btreemap_free
export vec_new, vec_push, vec_pop, vec_get, vec_set
export vec_len, vec_clear, vec_to_array, vec_free

# ============================================================================
# FFI to Rust collection registries
# ============================================================================

extern fn __rt_hashmap_new() -> i64
extern fn __rt_hashmap_insert(handle: i64, key: text, value: i64) -> bool
extern fn __rt_hashmap_get(handle: i64, key: text) -> i64?
extern fn __rt_hashmap_remove(handle: i64, key: text) -> bool
extern fn __rt_hashmap_contains(handle: i64, key: text) -> bool
extern fn __rt_hashmap_len(handle: i64) -> i64
extern fn __rt_hashmap_keys(handle: i64) -> [text]
extern fn __rt_hashmap_values(handle: i64) -> [i64]
extern fn __rt_hashmap_clear(handle: i64)
extern fn __rt_hashmap_free(handle: i64)

extern fn __rt_hashset_new() -> i64
extern fn __rt_hashset_insert(handle: i64, key: text) -> bool
extern fn __rt_hashset_contains(handle: i64, key: text) -> bool
extern fn __rt_hashset_remove(handle: i64, key: text) -> bool
extern fn __rt_hashset_len(handle: i64) -> i64
extern fn __rt_hashset_to_array(handle: i64) -> [text]
extern fn __rt_hashset_clear(handle: i64)
extern fn __rt_hashset_free(handle: i64)

extern fn __rt_btreemap_new() -> i64
extern fn __rt_btreemap_insert(handle: i64, key: text, value: i64) -> bool
extern fn __rt_btreemap_get(handle: i64, key: text) -> i64?
extern fn __rt_btreemap_remove(handle: i64, key: text) -> bool
extern fn __rt_btreemap_contains(handle: i64, key: text) -> bool
extern fn __rt_btreemap_len(handle: i64) -> i64
extern fn __rt_btreemap_keys(handle: i64) -> [text]
extern fn __rt_btreemap_free(handle: i64)

extern fn __rt_vec_new() -> i64
extern fn __rt_vec_push(handle: i64, value: i64)
extern fn __rt_vec_pop(handle: i64) -> i64?
extern fn __rt_vec_get(handle: i64, idx: i64) -> i64?
extern fn __rt_vec_set(handle: i64, idx: i64, value: i64)
extern fn __rt_vec_len(handle: i64) -> i64
extern fn __rt_vec_clear(handle: i64)
extern fn __rt_vec_to_array(handle: i64) -> [i64]
extern fn __rt_vec_free(handle: i64)

# ============================================================================
# Helper: extract handle from first arg
# ============================================================================

fn _handle(args: [Value], name: text) -> Result<i64, InterpreterError>:
    if not args.?:
        return Err(InterpreterError.ArityError("{name}: expected handle argument"))
    args[0].as_int() ?? Err(InterpreterError.TypeError("{name}: handle must be Int"))

fn _key(args: [Value], idx: i64, name: text) -> Result<text, InterpreterError>:
    if idx >= args.len():
        return Err(InterpreterError.ArityError("{name}: expected key argument"))
    args[idx].as_string() ?? Err(InterpreterError.TypeError("{name}: key must be String"))

# ============================================================================
# HashMap
# ============================================================================

fn hashmap_new(args: [Value]) -> Result<Value, InterpreterError>:
    Ok(Value.int(__rt_hashmap_new()))

fn hashmap_insert(args: [Value]) -> Result<Value, InterpreterError>:
    if args.len() != 3:
        return Err(InterpreterError.ArityError("hashmap_insert expects 3 arguments"))
    val h = _handle(args, "hashmap_insert")?
    val k = _key(args, 1, "hashmap_insert")?
    Ok(Value.bool(__rt_hashmap_insert(h, k, args[2].to_handle())))

fn hashmap_get(args: [Value]) -> Result<Value, InterpreterError>:
    if args.len() != 2:
        return Err(InterpreterError.ArityError("hashmap_get expects 2 arguments"))
    val h = _handle(args, "hashmap_get")?
    val k = _key(args, 1, "hashmap_get")?
    val result = __rt_hashmap_get(h, k)
    if result.?:
        Ok(Value.from_handle(result.unwrap()))
    else:
        Ok(Value.nil())

fn hashmap_remove(args: [Value]) -> Result<Value, InterpreterError>:
    if args.len() != 2:
        return Err(InterpreterError.ArityError("hashmap_remove expects 2 arguments"))
    val h = _handle(args, "hashmap_remove")?
    val k = _key(args, 1, "hashmap_remove")?
    Ok(Value.bool(__rt_hashmap_remove(h, k)))

fn hashmap_contains(args: [Value]) -> Result<Value, InterpreterError>:
    if args.len() != 2:
        return Err(InterpreterError.ArityError("hashmap_contains expects 2 arguments"))
    val h = _handle(args, "hashmap_contains")?
    val k = _key(args, 1, "hashmap_contains")?
    Ok(Value.bool(__rt_hashmap_contains(h, k)))

fn hashmap_len(args: [Value]) -> Result<Value, InterpreterError>:
    val h = _handle(args, "hashmap_len")?
    Ok(Value.int(__rt_hashmap_len(h)))

fn hashmap_keys(args: [Value]) -> Result<Value, InterpreterError>:
    val h = _handle(args, "hashmap_keys")?
    Ok(Value.array(__rt_hashmap_keys(h).map(\k: Value.string(k))))

fn hashmap_values(args: [Value]) -> Result<Value, InterpreterError>:
    val h = _handle(args, "hashmap_values")?
    Ok(Value.array(__rt_hashmap_values(h).map(\v: Value.from_handle(v))))

fn hashmap_entries(args: [Value]) -> Result<Value, InterpreterError>:
    val h = _handle(args, "hashmap_entries")?
    val keys = __rt_hashmap_keys(h)
    val values = __rt_hashmap_values(h)
    val entries = [for i in 0..keys.len(): Value.tuple([Value.string(keys[i]), Value.from_handle(values[i])])]
    Ok(Value.array(entries))

fn hashmap_clear(args: [Value]) -> Result<Value, InterpreterError>:
    val h = _handle(args, "hashmap_clear")?
    __rt_hashmap_clear(h)
    Ok(Value.nil())

fn hashmap_free(args: [Value]) -> Result<Value, InterpreterError>:
    val h = _handle(args, "hashmap_free")?
    __rt_hashmap_free(h)
    Ok(Value.nil())

# ============================================================================
# HashSet
# ============================================================================

fn hashset_new(args: [Value]) -> Result<Value, InterpreterError>:
    Ok(Value.int(__rt_hashset_new()))

fn hashset_insert(args: [Value]) -> Result<Value, InterpreterError>:
    if args.len() != 2:
        return Err(InterpreterError.ArityError("hashset_insert expects 2 arguments"))
    val h = _handle(args, "hashset_insert")?
    val k = _key(args, 1, "hashset_insert")?
    Ok(Value.bool(__rt_hashset_insert(h, k)))

fn hashset_contains(args: [Value]) -> Result<Value, InterpreterError>:
    if args.len() != 2:
        return Err(InterpreterError.ArityError("hashset_contains expects 2 arguments"))
    val h = _handle(args, "hashset_contains")?
    val k = _key(args, 1, "hashset_contains")?
    Ok(Value.bool(__rt_hashset_contains(h, k)))

fn hashset_remove(args: [Value]) -> Result<Value, InterpreterError>:
    if args.len() != 2:
        return Err(InterpreterError.ArityError("hashset_remove expects 2 arguments"))
    val h = _handle(args, "hashset_remove")?
    val k = _key(args, 1, "hashset_remove")?
    Ok(Value.bool(__rt_hashset_remove(h, k)))

fn hashset_len(args: [Value]) -> Result<Value, InterpreterError>:
    val h = _handle(args, "hashset_len")?
    Ok(Value.int(__rt_hashset_len(h)))

fn hashset_to_array(args: [Value]) -> Result<Value, InterpreterError>:
    val h = _handle(args, "hashset_to_array")?
    Ok(Value.array(__rt_hashset_to_array(h).map(\k: Value.string(k))))

fn hashset_clear(args: [Value]) -> Result<Value, InterpreterError>:
    val h = _handle(args, "hashset_clear")?
    __rt_hashset_clear(h)
    Ok(Value.nil())

fn hashset_free(args: [Value]) -> Result<Value, InterpreterError>:
    val h = _handle(args, "hashset_free")?
    __rt_hashset_free(h)
    Ok(Value.nil())

# ============================================================================
# BTreeMap (sorted map)
# ============================================================================

fn btreemap_new(args: [Value]) -> Result<Value, InterpreterError>:
    Ok(Value.int(__rt_btreemap_new()))

fn btreemap_insert(args: [Value]) -> Result<Value, InterpreterError>:
    if args.len() != 3:
        return Err(InterpreterError.ArityError("btreemap_insert expects 3 arguments"))
    val h = _handle(args, "btreemap_insert")?
    val k = _key(args, 1, "btreemap_insert")?
    Ok(Value.bool(__rt_btreemap_insert(h, k, args[2].to_handle())))

fn btreemap_get(args: [Value]) -> Result<Value, InterpreterError>:
    if args.len() != 2:
        return Err(InterpreterError.ArityError("btreemap_get expects 2 arguments"))
    val h = _handle(args, "btreemap_get")?
    val k = _key(args, 1, "btreemap_get")?
    val result = __rt_btreemap_get(h, k)
    if result.?:
        Ok(Value.from_handle(result.unwrap()))
    else:
        Ok(Value.nil())

fn btreemap_remove(args: [Value]) -> Result<Value, InterpreterError>:
    if args.len() != 2:
        return Err(InterpreterError.ArityError("btreemap_remove expects 2 arguments"))
    val h = _handle(args, "btreemap_remove")?
    val k = _key(args, 1, "btreemap_remove")?
    Ok(Value.bool(__rt_btreemap_remove(h, k)))

fn btreemap_contains(args: [Value]) -> Result<Value, InterpreterError>:
    if args.len() != 2:
        return Err(InterpreterError.ArityError("btreemap_contains expects 2 arguments"))
    val h = _handle(args, "btreemap_contains")?
    val k = _key(args, 1, "btreemap_contains")?
    Ok(Value.bool(__rt_btreemap_contains(h, k)))

fn btreemap_len(args: [Value]) -> Result<Value, InterpreterError>:
    val h = _handle(args, "btreemap_len")?
    Ok(Value.int(__rt_btreemap_len(h)))

fn btreemap_keys(args: [Value]) -> Result<Value, InterpreterError>:
    val h = _handle(args, "btreemap_keys")?
    Ok(Value.array(__rt_btreemap_keys(h).map(\k: Value.string(k))))

fn btreemap_free(args: [Value]) -> Result<Value, InterpreterError>:
    val h = _handle(args, "btreemap_free")?
    __rt_btreemap_free(h)
    Ok(Value.nil())

# ============================================================================
# Vec (growable array via Rust)
# ============================================================================

fn vec_new(args: [Value]) -> Result<Value, InterpreterError>:
    Ok(Value.int(__rt_vec_new()))

fn vec_push(args: [Value]) -> Result<Value, InterpreterError>:
    if args.len() != 2:
        return Err(InterpreterError.ArityError("vec_push expects 2 arguments"))
    val h = _handle(args, "vec_push")?
    __rt_vec_push(h, args[1].to_handle())
    Ok(Value.nil())

fn vec_pop(args: [Value]) -> Result<Value, InterpreterError>:
    val h = _handle(args, "vec_pop")?
    val result = __rt_vec_pop(h)
    if result.?:
        Ok(Value.from_handle(result.unwrap()))
    else:
        Ok(Value.nil())

fn vec_get(args: [Value]) -> Result<Value, InterpreterError>:
    if args.len() != 2:
        return Err(InterpreterError.ArityError("vec_get expects 2 arguments"))
    val h = _handle(args, "vec_get")?
    val idx = args[1].as_int() ?? return Err(InterpreterError.TypeError("vec_get: index must be Int"))
    val result = __rt_vec_get(h, idx)
    if result.?:
        Ok(Value.from_handle(result.unwrap()))
    else:
        Err(InterpreterError.IndexError("vec index {idx} out of bounds"))

fn vec_set(args: [Value]) -> Result<Value, InterpreterError>:
    if args.len() != 3:
        return Err(InterpreterError.ArityError("vec_set expects 3 arguments"))
    val h = _handle(args, "vec_set")?
    val idx = args[1].as_int() ?? return Err(InterpreterError.TypeError("vec_set: index must be Int"))
    __rt_vec_set(h, idx, args[2].to_handle())
    Ok(Value.nil())

fn vec_len(args: [Value]) -> Result<Value, InterpreterError>:
    val h = _handle(args, "vec_len")?
    Ok(Value.int(__rt_vec_len(h)))

fn vec_clear(args: [Value]) -> Result<Value, InterpreterError>:
    val h = _handle(args, "vec_clear")?
    __rt_vec_clear(h)
    Ok(Value.nil())

fn vec_to_array(args: [Value]) -> Result<Value, InterpreterError>:
    val h = _handle(args, "vec_to_array")?
    Ok(Value.array(__rt_vec_to_array(h).map(\v: Value.from_handle(v))))

fn vec_free(args: [Value]) -> Result<Value, InterpreterError>:
    val h = _handle(args, "vec_free")?
    __rt_vec_free(h)
    Ok(Value.nil())
