# Tier Check CLI â€” Standalone entry point for `simple check --tier=X file.spl`
#
# Invoked by the CLI dispatcher when `check --tier=...` is detected.
# All state management inlined into main() due to runtime limitation
# where module-level var modifications don't persist across function calls.

extern fn rt_file_read_text(path: text) -> text
extern fn rt_cli_get_args() -> [text]

# Pure helper: extract words (identifiers) from a line of code
fn extract_words(line: text) -> [text]:
    var words: [text] = []
    var current = ""
    for ch in line:
        val is_letter = (ch >= "a" and ch <= "z") or (ch >= "A" and ch <= "Z") or ch == "_"
        val is_digit = ch >= "0" and ch <= "9"
        if is_letter or is_digit:
            current = current + ch
        else:
            if current != "":
                words.push(current)
                current = ""
    if current != "":
        words.push(current)
    words

# Pure helper: find column of a word in a line
fn find_word_col(line: text, word: text) -> i64:
    val idx = line.index_of(word) ?? -1
    if idx >= 0: return idx + 1
    1

fn main() -> i64:
    val all_args = rt_cli_get_args()
    # Skip program name and script path
    var start_idx = 1
    if all_args.len() > 1:
        if all_args[1].ends_with(".spl"):
            start_idx = 2
    var args: [text] = []
    var arg_idx = 0
    for a in all_args:
        if arg_idx >= start_idx:
            args.push(a)
        arg_idx = arg_idx + 1

    # Parse --tier=X and file paths
    var tier = ""
    var files: [text] = []

    for arg in args:
        if arg.starts_with("--tier="):
            tier = arg.slice(7, arg.len())
        elif not arg.starts_with("--"):
            files.push(arg)

    if tier == "":
        print "Error: --tier=<seed|core|full> required"
        print "Usage: simple check --tier=seed file.spl"
        return 1

    if files.len() == 0:
        print "Error: no input files"
        print "Usage: simple check --tier=seed file.spl"
        return 1

    # ---- Load tier keywords from SDN (inlined) ----
    val sdn_path = "doc/spec/grammar/tier_keywords.sdn"
    val sdn_content = rt_file_read_text(sdn_path) ?? ""
    if sdn_content == "":
        print "Error: could not load {sdn_path}"
        return 1

    var seed_keywords: [text] = []
    var core_keywords: [text] = []
    var full_keywords: [text] = []

    var current_section = ""
    val sdn_lines = sdn_content.split("\n")
    for sdn_line in sdn_lines:
        val st = sdn_line.trim()
        if st == "": continue
        if st.starts_with("#"): continue

        if st.starts_with("["):
            var hdr = st.replace("[", "")
            hdr = hdr.replace("]", "")
            val hdr_parts = hdr.split(".")
            current_section = hdr_parts[0]
            continue

        if current_section != "keywords": continue

        if st.contains("="):
            val eq_idx = st.index_of("=") ?? -1
            if eq_idx > 0:
                val key = st.slice(0, eq_idx).trim()
                var value_part = st.slice(eq_idx + 1, st.len()).trim()
                value_part = value_part.replace("\"", "")

                if value_part == "seed":
                    seed_keywords.push(key)
                elif value_part == "core":
                    core_keywords.push(key)
                elif value_part == "full":
                    full_keywords.push(key)

    print "Checking {files.len()} file(s) against {tier} tier..."
    print "Allowed: seed={seed_keywords.len()}, core={core_keywords.len()}, full={full_keywords.len()} keywords"
    print ""

    # ---- Check each file (inlined) ----
    var total_violations = 0
    for file_path in files:
        val source = rt_file_read_text(file_path) ?? ""
        if source == "":
            print "Error: could not read {file_path}"
            return 1

        var file_violations = 0
        var line_num = 1
        val src_lines = source.split("\n")

        for src_line in src_lines:
            val trimmed = src_line.trim()
            if trimmed == "":
                line_num = line_num + 1
                continue
            if trimmed.starts_with("#"):
                line_num = line_num + 1
                continue

            val words = extract_words(trimmed)
            for word in words:
                # Check if it's any keyword at all
                var is_any_keyword = false
                for kw in seed_keywords:
                    if kw == word: is_any_keyword = true
                for kw in core_keywords:
                    if kw == word: is_any_keyword = true
                for kw in full_keywords:
                    if kw == word: is_any_keyword = true

                if is_any_keyword:
                    # Check tier allowance (inline is_allowed_in_tier)
                    var allowed = false
                    for kw in seed_keywords:
                        if kw == word: allowed = true
                    if not allowed:
                        if tier != "seed":
                            for kw in core_keywords:
                                if kw == word: allowed = true
                    if not allowed:
                        if tier == "full":
                            for kw in full_keywords:
                                if kw == word: allowed = true

                    if not allowed:
                        val word_col = find_word_col(src_line, word)
                        print "{file_path}:{line_num}:{word_col}: error: '{word}' not available in {tier} tier"
                        file_violations = file_violations + 1

            line_num = line_num + 1

        if file_violations == 0:
            print "{file_path}: OK ({tier} tier)"
        total_violations = total_violations + file_violations

    print ""
    if total_violations > 0:
        print "Found {total_violations} tier violation(s)"
        return 1
    else:
        print "All files pass {tier} tier check"
        return 0
