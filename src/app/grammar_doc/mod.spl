# Grammar Doc Generator — Reads tier_keywords.sdn and generates grammar docs
#
# Generates:
#   doc/spec/grammar/seed_grammar.md   — Seed-tier grammar reference
#   doc/spec/grammar/core_grammar.md   — Core-tier grammar reference
#   doc/spec/grammar/full_grammar.md   — Full grammar reference
#   doc/spec/grammar/keyword_reference.md — All keywords in one table
#   doc/spec/grammar/treesitter_status.md — Tree-sitter consistency report
#
# CLI:
#   bin/simple grammar-doc                  — Generate all docs
#   bin/simple grammar-doc --tier=seed      — Single tier
#   bin/simple grammar-doc --treesitter     — Tree-sitter status report
#   bin/simple grammar-doc --format=json    — JSON output

extern fn rt_file_read_text(path: text) -> text
extern fn rt_file_write_text(path: text, content: text) -> bool
extern fn rt_file_exists(path: text) -> bool
extern fn rt_cli_get_args() -> [text]

# =========================================================================
# Pure helper functions (no module state access)
# =========================================================================

fn get_operator_symbol(name: text) -> text:
    if name == "plus": return "+"
    if name == "minus": return "-"
    if name == "star": return "*"
    if name == "slash": return "/"
    if name == "percent": return "%"
    if name == "star_star": return "**"
    if name == "shl": return "<<"
    if name == "shr": return ">>"
    if name == "eq": return "=="
    if name == "not_eq": return "!="
    if name == "lt": return "<"
    if name == "gt": return ">"
    if name == "lt_eq": return "<="
    if name == "gt_eq": return ">="
    if name == "assign": return "="
    if name == "plus_eq": return "+="
    if name == "minus_eq": return "-="
    if name == "star_eq": return "*="
    if name == "slash_eq": return "/="
    if name == "percent_eq": return "%="
    if name == "walrus": return ":="
    if name == "ampersand": return "&"
    if name == "pipe": return "|"
    if name == "caret": return "^"
    if name == "tilde": return "~"
    if name == "question": return "?"
    if name == "question_dot": return "?."
    if name == "question_question": return "??"
    if name == "dot_question": return ".?"
    if name == "pipe_forward": return "|>"
    if name == "compose": return ">>"
    if name == "dot_dot": return ".."
    if name == "dot_dot_eq": return "..="
    if name == "dot_plus": return ".+"
    if name == "dot_minus": return ".-"
    if name == "dot_star": return ".*"
    if name == "dot_slash": return "./"
    if name == "dot_caret": return ".^"
    if name == "at": return "@"
    if name == "triple_less": return "<<<"
    if name == "triple_greater": return ">>>"
    if name == "layer_connect": return "~>"
    return name

fn get_keyword_description(name: text) -> text:
    if name == "fn": return "Function definition"
    if name == "val": return "Immutable binding"
    if name == "var": return "Mutable binding"
    if name == "struct": return "Struct definition"
    if name == "enum": return "Enum definition"
    if name == "class": return "Class definition (struct with methods)"
    if name == "impl": return "Method implementation block"
    if name == "extern": return "External function declaration (FFI)"
    if name == "use": return "Module import"
    if name == "export": return "Symbol export"
    if name == "import": return "Module import (deprecated, use use)"
    if name == "trait": return "Trait definition"
    if name == "pub": return "Public visibility modifier"
    if name == "static": return "Static method or binding"
    if name == "me": return "Mutable self method"
    if name == "type": return "Type alias"
    if name == "asm": return "Inline assembly block"
    if name == "implements": return "Trait implementation declaration"
    if name == "mod": return "Module definition"
    if name == "const": return "Compile-time constant"
    if name == "bitfield": return "Packed bit struct"
    if name == "kernel": return "GPU kernel function"
    if name == "shared": return "GPU shared memory"
    if name == "unsafe": return "Unsafe block"
    if name == "actor": return "Actor definition (concurrency)"
    if name == "unit": return "Unit type definition"
    if name == "if": return "Conditional branch"
    if name == "elif": return "Else-if branch"
    if name == "else": return "Else branch"
    if name == "for": return "For loop"
    if name == "while": return "While loop"
    if name == "match": return "Pattern match expression"
    if name == "case": return "Match arm"
    if name == "return": return "Return from function"
    if name == "break": return "Break out of loop"
    if name == "continue": return "Skip to next iteration"
    if name == "in": return "Membership / iteration operator"
    if name == "loop": return "Infinite loop"
    if name == "pass": return "No-op placeholder"
    if name == "pass_todo": return "Unimplemented placeholder (TODO)"
    if name == "pass_do_nothing": return "Intentional no-op"
    if name == "pass_dn": return "Alias for pass_do_nothing"
    if name == "and": return "Logical AND"
    if name == "or": return "Logical OR"
    if name == "not": return "Logical NOT"
    if name == "self": return "Current instance reference"
    if name == "is": return "Type check operator"
    if name == "async": return "Async function modifier"
    if name == "await": return "Await async expression"
    if name == "yield": return "Yield from generator"
    if name == "spawn": return "Spawn actor/task"
    if name == "try": return "Try block (error handling)"
    if name == "catch": return "Catch block (error handling)"
    if name == "throw": return "Throw exception"
    if name == "with": return "Context manager block"
    if name == "finally": return "Finally block (always runs)"
    if name == "panic": return "Panic / unrecoverable error"
    if name == "true": return "Boolean true literal"
    if name == "false": return "Boolean false literal"
    if name == "nil": return "Null/none value"
    if name == "as": return "Type cast operator"
    if name == "xor": return "Bitwise XOR operator"
    if name == "from": return "Import source specifier"
    if name == "super": return "Parent module reference"
    if name == "Some": return "Option type wrapper"
    if name == "Ok": return "Result success wrapper"
    if name == "Err": return "Result error wrapper"
    if name == "None": return "Option empty value"
    if name == "loss": return "Neural network loss block"
    if name == "nograd": return "Disable gradient computation"
    return ""

fn get_keyword_example(name: text) -> text:
    if name == "fn": return "`fn square(x: i64) -> i64: x * x`"
    if name == "val": return "`val name = \"Alice\"`"
    if name == "var": return "`var count = 0`"
    if name == "struct": return "`struct Point: x: i64; y: i64`"
    if name == "enum": return "`enum Color: Red; Green; Blue`"
    if name == "class": return "`class Dog: name: text`"
    if name == "impl": return "`impl Point: fn len(): ...`"
    if name == "extern": return "`extern fn rt_print(s: text)`"
    if name == "use": return "`use std.math.{sqrt, abs}`"
    if name == "export": return "`export my_fn, MyType`"
    if name == "trait": return "`trait Printable: fn print():`"
    if name == "if": return "`if x > 0: print \"positive\"`"
    if name == "for": return "`for item in items: print item`"
    if name == "match": return "`match value: case 1: ...`"
    if name == "return": return "`return result`"
    if name == "and": return "`if a and b: ...`"
    if name == "true": return "`val done = true`"
    if name == "nil": return "`var result = nil`"
    if name == "async": return "`async fn fetch():`"
    if name == "spawn": return "`spawn worker()`"
    return ""

fn get_asm_description(name: text) -> text:
    if name == "asm_single_line": return "Single-line asm statement (`asm \"nop\"`)"
    if name == "asm_indented_block": return "Indented asm block (`asm:\\n    \"nop\"`)"
    if name == "asm_braced_block": return "Braced asm block (`asm { \"nop\" }`)"
    if name == "asm_match": return "Target-conditional asm (`asm match: case [x86_64]: ...`)"
    if name == "asm_assert": return "Target assertion (`asm assert [x86_64, linux]`)"
    if name == "asm_operands": return "Register operands (`in(reg) var, out(reg) var`)"
    if name == "asm_clobbers": return "Clobber lists (`clobbers: [\"eax\"]`)"
    if name == "asm_options": return "Asm options (`options: [volatile, noreturn]`)"
    if name == "asm_register_alloc": return "Compiler register allocation"
    if name == "asm_target_validation": return "Per-arch instruction validation"
    return name

fn get_asm_kind(name: text) -> text:
    if name == "asm_single_line": return "clang-depend"
    if name == "asm_indented_block": return "clang-depend"
    if name == "asm_braced_block": return "clang-depend"
    if name == "asm_match": return "clang-depend"
    if name == "asm_assert": return "clang-depend"
    return "compiler-depend"

fn get_llf_description(name: text) -> text:
    if name == "bitfield": return "Packed bit-level struct declarations"
    if name == "union_type_operator": return "Union type operator (`A | B | C`)"
    if name == "union_declaration": return "C-style `union {}` declaration"
    if name == "packed_attr": return "`@packed` attribute for struct layout"
    if name == "repr_attr": return "`@repr(C)` representation attribute"
    if name == "align_attr": return "`@align(N)` alignment attribute"
    if name == "volatile_asm": return "Volatile asm via C passthrough"
    if name == "volatile_attr": return "`@volatile` attribute for MMIO"
    return name

fn tier_allowed(target_tier: text, kw_tier: text) -> bool:
    if target_tier == "full": return true
    if target_tier == "core":
        if kw_tier == "seed": return true
        if kw_tier == "core": return true
        return false
    if target_tier == "seed":
        if kw_tier == "seed": return true
        return false
    false

# =========================================================================
# Main entry point — all state managed inline
# =========================================================================

fn main() -> i64:
    val all_args = rt_cli_get_args()
    var start_idx = 1
    if all_args.len() > 1:
        if all_args[1].ends_with(".spl"):
            start_idx = 2
    var args: [text] = []
    var arg_idx = 0
    for a in all_args:
        if arg_idx >= start_idx:
            args.push(a)
        arg_idx = arg_idx + 1

    val sdn_path = "doc/spec/grammar/tier_keywords.sdn"
    val out_dir = "doc/spec/grammar"

    # Parse flags
    var tier_filter = ""
    var do_treesitter = false
    var format = "md"
    for arg in args:
        if arg.starts_with("--tier="):
            tier_filter = arg.slice(7, arg.len())
        elif arg == "--treesitter":
            do_treesitter = true
        elif arg.starts_with("--format="):
            format = arg.slice(9, arg.len())

    # Read and parse SDN source of truth — all state local to main
    val sdn_text = rt_file_read_text(sdn_path) ?? ""
    if sdn_text == "":
        print "Error: could not read {sdn_path}"
        return 1

    # Parse SDN inline (module var writes don't persist across function calls)
    var kw_names: [text] = []
    var kw_tiers: [text] = []
    var kw_categories: [text] = []
    var op_names: [text] = []
    var op_tiers: [text] = []
    var op_symbols: [text] = []
    var ct_names: [text] = []
    var ct_tiers: [text] = []
    var aspirational_keywords: [text] = []
    var asm_names: [text] = []
    var asm_tiers: [text] = []
    var llf_names: [text] = []
    var llf_tiers: [text] = []

    var current_section = ""
    var current_subsection = ""
    val sdn_lines = sdn_text.split("\n")
    for sdn_line in sdn_lines:
        val trimmed = sdn_line.trim()
        if trimmed == "": continue
        if trimmed.starts_with("#"): continue
        if trimmed.starts_with("["):
            var header = trimmed.replace("[", "")
            header = header.replace("]", "")
            val parts = header.split(".")
            current_section = parts[0]
            if parts.len() > 1:
                current_subsection = parts[1]
            else:
                current_subsection = ""
            continue
        if trimmed.contains("="):
            val eq_idx = trimmed.index_of("=") ?? -1
            if eq_idx > 0:
                val key = trimmed.slice(0, eq_idx).trim()
                var value_part = trimmed.slice(eq_idx + 1, trimmed.len()).trim()
                value_part = value_part.replace("\"", "")
                if current_section == "keywords":
                    kw_names.push(key)
                    kw_tiers.push(value_part)
                    kw_categories.push(current_subsection)
                elif current_section == "operators":
                    op_names.push(key)
                    op_tiers.push(value_part)
                    op_symbols.push(get_operator_symbol(key))
                elif current_section == "constructs":
                    ct_names.push(key)
                    ct_tiers.push(value_part)
                elif current_section == "asm_capabilities":
                    asm_names.push(key)
                    asm_tiers.push(value_part)
                elif current_section == "low_level_features":
                    llf_names.push(key)
                    llf_tiers.push(value_part)
                elif current_section == "treesitter_aspirational":
                    if key == "keywords":
                        val kw_list = value_part.split(", ")
                        for kw in kw_list:
                            val cleaned = kw.trim()
                            if cleaned != "":
                                aspirational_keywords.push(cleaned)

    print "Parsed {kw_names.len()} keywords, {op_names.len()} operators, {ct_names.len()} constructs, {asm_names.len()} asm capabilities, {llf_names.len()} low-level features"

    # JSON output mode
    if format == "json":
        var json_out = "{\n  \"keywords\": [\n"
        var ki = 0
        for kw_name in kw_names:
            var comma = ","
            if ki == kw_names.len() - 1: comma = ""
            val cat = kw_categories[ki]
            val tier = kw_tiers[ki]
            val desc = get_keyword_description(kw_name)
            json_out = json_out + "    {\"name\": \"{kw_name}\", \"tier\": \"{tier}\", \"category\": \"{cat}\"}{comma}\n"
            ki = ki + 1
        json_out = json_out + "  ]\n}\n"
        print json_out
        return 0

    # Tree-sitter mode
    if do_treesitter:
        val ts_path = "src/compiler/parser/treesitter/queries/highlights.scm"
        val ts_text = rt_file_read_text(ts_path) ?? ""
        if ts_text == "":
            print "Error: could not read {ts_path}"
            return 1
        # Parse highlights.scm for keywords
        var ts_keywords: [text] = []
        val ts_lines = ts_text.split("\n")
        for ts_line in ts_lines:
            val ts_trimmed = ts_line.trim()
            if ts_trimmed.starts_with("\""):
                val after_first = ts_trimmed.slice(1, ts_trimmed.len())
                val end_in_rest = after_first.index_of("\"") ?? -1
                if end_in_rest > 0:
                    val ts_kw = after_first.slice(0, end_in_rest)
                    # Skip operators/punctuation (non-alpha)
                    var is_alpha = false
                    if ts_kw.len() > 0:
                        val first_ch = ts_kw.slice(0, 1)
                        if first_ch >= "a" and first_ch <= "z": is_alpha = true
                        if first_ch >= "A" and first_ch <= "Z": is_alpha = true
                    if is_alpha:
                        var already = false
                        for existing in ts_keywords:
                            if existing == ts_kw:
                                already = true
                                break
                        if not already:
                            ts_keywords.push(ts_kw)
        # Generate status report
        var status = "# Tree-sitter Keyword Status\n\n"
        status = status + "*Cross-reference between `highlights.scm` and `tier_keywords.sdn`.*\n\n"
        status = status + "*Generated by `bin/simple grammar-doc --treesitter`.*\n\n---\n\n"
        # Cross-reference
        var impl_kws: [text] = []
        var impl_tiers: [text] = []
        var asp_kws: [text] = []
        var miss_kws: [text] = []
        var miss_tiers: [text] = []
        for ts_kw in ts_keywords:
            var found_tier = ""
            var ki2 = 0
            for kn in kw_names:
                if kn == ts_kw:
                    found_tier = kw_tiers[ki2]
                    break
                ki2 = ki2 + 1
            if found_tier != "":
                impl_kws.push(ts_kw)
                impl_tiers.push(found_tier)
            else:
                asp_kws.push(ts_kw)
        var ki3 = 0
        for kn in kw_names:
            var in_ts = false
            for ts_kw in ts_keywords:
                if ts_kw == kn:
                    in_ts = true
                    break
            if not in_ts:
                miss_kws.push(kn)
                miss_tiers.push(kw_tiers[ki3])
            ki3 = ki3 + 1
        status = status + "## Implemented ({impl_kws.len()} keywords)\n\n"
        status = status + "| Keyword | Tier |\n|---------|------|\n"
        var ii = 0
        for imp in impl_kws:
            status = status + "| `{imp}` | {impl_tiers[ii]} |\n"
            ii = ii + 1
        status = status + "\n## Aspirational ({asp_kws.len()} keywords)\n\n"
        status = status + "| Keyword | Notes |\n|---------|-------|\n"
        for asp in asp_kws:
            status = status + "| `{asp}` | In highlights.scm only |\n"
        status = status + "\n## Missing from highlights.scm ({miss_kws.len()} keywords)\n\n"
        status = status + "| Keyword | Tier |\n|---------|------|\n"
        var mi = 0
        for miss in miss_kws:
            status = status + "| `{miss}` | {miss_tiers[mi]} |\n"
            mi = mi + 1
        val status_path = "{out_dir}/treesitter_status.md"
        rt_file_write_text(status_path, status)
        print "Generated {status_path} ({ts_keywords.len()} tree-sitter keywords analyzed)"
        return 0

    # Generate tier docs
    var tiers_to_gen: [text] = ["seed", "core", "full"]
    if tier_filter != "":
        tiers_to_gen = [tier_filter]
    for tier in tiers_to_gen:
        var out = "# Simple Language Grammar - "
        if tier == "seed":
            out = out + "Seed Tier\n\n"
            out = out + "> **Seed tier**: The C++ bootstrap compiler (`src/compiler_seed/seed.cpp`). Minimal subset\n"
            out = out + "> of Simple needed to compile the core compiler.\n\n"
        elif tier == "core":
            out = out + "Core Tier\n\n"
            out = out + "> **Core tier**: The Simple-in-Simple compiler (`src/core/`). Includes seed tier\n"
            out = out + "> plus additional language features for self-hosting.\n\n"
        else:
            out = out + "Full Tier\n\n"
            out = out + "> **Full tier**: The complete runtime (`bin/simple`). All language features.\n\n"
        out = out + "*Generated by `bin/simple grammar-doc` from `doc/spec/grammar/tier_keywords.sdn`.*\n\n---\n\n"
        # Keywords table
        out = out + "## Keywords\n\n"
        out = out + "| Keyword | Category | Tier | Description | Example |\n"
        out = out + "|---------|----------|------|-------------|---------|\n"
        var ki4 = 0
        for kw_name in kw_names:
            val kw_tier = kw_tiers[ki4]
            if tier_allowed(tier, kw_tier):
                val cat = kw_categories[ki4]
                val desc = get_keyword_description(kw_name)
                val example = get_keyword_example(kw_name)
                out = out + "| `{kw_name}` | {cat} | {kw_tier} | {desc} | {example} |\n"
            ki4 = ki4 + 1
        out = out + "\n## Operators\n\n"
        out = out + "| Operator | Symbol | Tier |\n|----------|--------|------|\n"
        var oi = 0
        for op_name in op_names:
            val op_tier = op_tiers[oi]
            if tier_allowed(tier, op_tier):
                val symbol = op_symbols[oi]
                out = out + "| {op_name} | `{symbol}` | {op_tier} |\n"
            oi = oi + 1
        out = out + "\n## Constructs\n\n"
        out = out + "| Construct | Tier |\n|-----------|------|\n"
        var ci = 0
        for ct_name in ct_names:
            val ct_tier = ct_tiers[ci]
            if tier_allowed(tier, ct_tier):
                out = out + "| {ct_name} | {ct_tier} |\n"
            ci = ci + 1
        # Asm capabilities table
        var has_asm = false
        var ai = 0
        for an in asm_names:
            if tier_allowed(tier, asm_tiers[ai]):
                has_asm = true
                break
            ai = ai + 1
        if has_asm:
            out = out + "\n## Assembly Capabilities\n\n"
            out = out + "| Capability | Kind | Tier | Description |\n"
            out = out + "|------------|------|------|-------------|\n"
            var ai2 = 0
            for an in asm_names:
                val at = asm_tiers[ai2]
                if tier_allowed(tier, at):
                    val ad = get_asm_description(an)
                    val ak = get_asm_kind(an)
                    out = out + "| {an} | {ak} | {at} | {ad} |\n"
                ai2 = ai2 + 1

        # Low-level features table
        var has_llf = false
        var li = 0
        for ln in llf_names:
            val lt = llf_tiers[li]
            if lt != "none" and tier_allowed(tier, lt):
                has_llf = true
                break
            li = li + 1
        if has_llf:
            out = out + "\n## Low-Level Features\n\n"
            out = out + "| Feature | Tier | Description |\n"
            out = out + "|---------|------|-------------|\n"
            var li2 = 0
            for ln in llf_names:
                val lt = llf_tiers[li2]
                if lt != "none" and tier_allowed(tier, lt):
                    val ld = get_llf_description(ln)
                    out = out + "| {ln} | {lt} | {ld} |\n"
                li2 = li2 + 1

        # Also show "none" features as not-implemented markers in full tier
        if tier == "full":
            var has_none = false
            var ni = 0
            for ln in llf_names:
                if llf_tiers[ni] == "none":
                    has_none = true
                    break
                ni = ni + 1
            if has_none:
                out = out + "\n### Not Yet Implemented\n\n"
                out = out + "| Feature | Status | Description |\n"
                out = out + "|---------|--------|-------------|\n"
                var ni2 = 0
                for ln in llf_names:
                    if llf_tiers[ni2] == "none":
                        val ld = get_llf_description(ln)
                        out = out + "| {ln} | not implemented | {ld} |\n"
                    ni2 = ni2 + 1

        # Count
        var kw_count = 0
        var ki5 = 0
        for kn in kw_names:
            if tier_allowed(tier, kw_tiers[ki5]):
                kw_count = kw_count + 1
            ki5 = ki5 + 1
        var op_count = 0
        var oi2 = 0
        for op_n in op_names:
            if tier_allowed(tier, op_tiers[oi2]):
                op_count = op_count + 1
            oi2 = oi2 + 1
        var ct_count = 0
        var ci2 = 0
        for cn in ct_names:
            if tier_allowed(tier, ct_tiers[ci2]):
                ct_count = ct_count + 1
            ci2 = ci2 + 1
        out = out + "\n---\n\n**Summary:** {kw_count} keywords, {op_count} operators, {ct_count} constructs\n"

        # Preserve hand-maintained sections from existing file
        val tier_path = "{out_dir}/{tier}_grammar.md"
        val existing = rt_file_read_text(tier_path) ?? ""
        if existing != "":
            val gap_marker = "## Conditional Compilation"
            val gap_idx = existing.index_of(gap_marker) ?? -1
            if gap_idx >= 0:
                val preserved = existing.slice(gap_idx, existing.len())
                out = out + "\n" + preserved

        rt_file_write_text(tier_path, out)
        print "Generated {tier_path}"

    # Generate keyword reference (only when generating all)
    if tier_filter == "":
        var ref_out = "# Simple Language - Keyword Reference\n\n"
        ref_out = ref_out + "*All keywords across all tiers, sorted by category.*\n\n"
        ref_out = ref_out + "*Generated by `bin/simple grammar-doc` from `doc/spec/grammar/tier_keywords.sdn`.*\n\n---\n\n"
        ref_out = ref_out + "## Keywords\n\n"
        ref_out = ref_out + "| Keyword | Category | Tier | Description |\n"
        ref_out = ref_out + "|---------|----------|------|-------------|\n"
        var ki6 = 0
        for kw_name in kw_names:
            val cat = kw_categories[ki6]
            val kw_tier = kw_tiers[ki6]
            val desc = get_keyword_description(kw_name)
            ref_out = ref_out + "| `{kw_name}` | {cat} | {kw_tier} | {desc} |\n"
            ki6 = ki6 + 1
        ref_out = ref_out + "\n## Operators\n\n"
        ref_out = ref_out + "| Name | Symbol | Tier |\n|------|--------|------|\n"
        var oi3 = 0
        for op_name in op_names:
            val symbol = op_symbols[oi3]
            val op_tier = op_tiers[oi3]
            ref_out = ref_out + "| {op_name} | `{symbol}` | {op_tier} |\n"
            oi3 = oi3 + 1
        ref_out = ref_out + "\n## Constructs\n\n"
        ref_out = ref_out + "| Construct | Tier |\n|-----------|------|\n"
        var ci3 = 0
        for ct_name in ct_names:
            val ct_tier = ct_tiers[ci3]
            ref_out = ref_out + "| {ct_name} | {ct_tier} |\n"
            ci3 = ci3 + 1
        # Tier summary
        var seed_count = 0
        var core_count = 0
        var full_count = 0
        var ki7 = 0
        for kn in kw_names:
            val t = kw_tiers[ki7]
            if t == "seed":
                seed_count = seed_count + 1
            elif t == "core":
                core_count = core_count + 1
            else:
                full_count = full_count + 1
            ki7 = ki7 + 1
        ref_out = ref_out + "\n---\n\n## Tier Summary\n\n"
        ref_out = ref_out + "| Tier | Keywords | Description |\n"
        ref_out = ref_out + "|------|----------|-------------|\n"
        ref_out = ref_out + "| seed | {seed_count} | C++ bootstrap compiler |\n"
        ref_out = ref_out + "| core | {core_count} | Simple-in-Simple compiler |\n"
        ref_out = ref_out + "| full | {full_count} | Complete runtime |\n"
        ref_out = ref_out + "| **Total** | **{kw_names.len()}** | |\n"
        val ref_path = "{out_dir}/keyword_reference.md"
        rt_file_write_text(ref_path, ref_out)
        print "Generated {ref_path}"

        # Also generate treesitter status
        val ts_path2 = "src/compiler/parser/treesitter/queries/highlights.scm"
        val ts_text2 = rt_file_read_text(ts_path2) ?? ""
        if ts_text2 != "":
            var ts_kws: [text] = []
            val ts_lines2 = ts_text2.split("\n")
            for ts_line2 in ts_lines2:
                val ts_tr = ts_line2.trim()
                if ts_tr.starts_with("\""):
                    val af = ts_tr.slice(1, ts_tr.len())
                    val ei = af.index_of("\"") ?? -1
                    if ei > 0:
                        val tw = af.slice(0, ei)
                        var is_alpha2 = false
                        if tw.len() > 0:
                            val fc = tw.slice(0, 1)
                            if fc >= "a" and fc <= "z": is_alpha2 = true
                            if fc >= "A" and fc <= "Z": is_alpha2 = true
                        if is_alpha2:
                            var dup = false
                            for ex in ts_kws:
                                if ex == tw:
                                    dup = true
                                    break
                            if not dup:
                                ts_kws.push(tw)
            var st = "# Tree-sitter Keyword Status\n\n"
            st = st + "*Cross-reference between `highlights.scm` and `tier_keywords.sdn`.*\n\n"
            st = st + "*Generated by `bin/simple grammar-doc`.*\n\n---\n\n"
            var imp2: [text] = []
            var imp2_t: [text] = []
            var asp2: [text] = []
            var mis2: [text] = []
            var mis2_t: [text] = []
            for tw in ts_kws:
                var ft = ""
                var ki8 = 0
                for kn in kw_names:
                    if kn == tw:
                        ft = kw_tiers[ki8]
                        break
                    ki8 = ki8 + 1
                if ft != "":
                    imp2.push(tw)
                    imp2_t.push(ft)
                else:
                    asp2.push(tw)
            var ki9 = 0
            for kn in kw_names:
                var found_in_ts = false
                for tw in ts_kws:
                    if tw == kn:
                        found_in_ts = true
                        break
                if not found_in_ts:
                    mis2.push(kn)
                    mis2_t.push(kw_tiers[ki9])
                ki9 = ki9 + 1
            st = st + "## Implemented ({imp2.len()} keywords)\n\n"
            st = st + "| Keyword | Tier |\n|---------|------|\n"
            var ix = 0
            for iw in imp2:
                st = st + "| `{iw}` | {imp2_t[ix]} |\n"
                ix = ix + 1
            st = st + "\n## Aspirational ({asp2.len()} keywords)\n\n"
            st = st + "| Keyword | Notes |\n|---------|-------|\n"
            for aw in asp2:
                st = st + "| `{aw}` | In highlights.scm only |\n"
            st = st + "\n## Missing from highlights.scm ({mis2.len()} keywords)\n\n"
            st = st + "| Keyword | Tier |\n|---------|------|\n"
            var mx = 0
            for mw in mis2:
                st = st + "| `{mw}` | {mis2_t[mx]} |\n"
                mx = mx + 1
            val st_path = "{out_dir}/treesitter_status.md"
            rt_file_write_text(st_path, st)
            print "Generated {st_path}"

    print "Done."
    0

export main
