# Docstring Checker - Find and validate docstrings for exported types
#
# Searches source files for type definitions (enum, struct, class, fn) and checks
# if they have associated docstrings (triple-quoted strings or # comments).

# External dependencies (runtime FFI)
extern fn rt_file_read_text(path: text) -> text
extern fn rt_file_exists(path: text) -> bool
extern fn rt_dir_exists(path: text) -> bool
extern fn rt_dir_list(path: text) -> [text]

# Represents docstring information for an exported type
struct DocstringInfo:
    type_name: text
    type_kind: text        # "enum", "struct", "class", "fn"
    module_path: text
    source_file: text
    has_docstring: bool
    docstring: text
    line_number: i64

# Check a module for docstrings on exported types
fn check_module_docstrings(module_path: text, export_names: [text]) -> [DocstringInfo]:
    """
    Check docstrings for all exported types in a module.

    Args:
        module_path: Path to module directory (e.g., "src/lib/array")
        export_names: List of exported type names

    Returns:
        List of DocstringInfo structs, one per exported type
    """
    var results = []

    for export_name in export_names:
        # Find source file containing the type definition
        val source_file = find_type_source_file(module_path, export_name)

        if source_file.len() == 0:
            # Type not found in any source file
            val info = DocstringInfo(
                type_name: export_name,
                type_kind: "unknown",
                module_path: module_path,
                source_file: "",
                has_docstring: false,
                docstring: "",
                line_number: 0
            )
            results = results + [info]
            continue

        # Extract docstring from source file
        val docstring = extract_docstring(source_file, export_name)
        val type_kind = detect_type_kind(source_file, export_name)
        val line_num = find_type_line_number(source_file, export_name)

        val info = DocstringInfo(
            type_name: export_name,
            type_kind: type_kind,
            module_path: module_path,
            source_file: source_file,
            has_docstring: docstring.len() > 0,
            docstring: docstring,
            line_number: line_num
        )
        results = results + [info]

    results

# Find source file containing a type definition
fn find_type_source_file(module_path: text, type_name: text) -> text:
    """
    Search for the source file containing a type definition.

    Search order:
    1. types.spl (common pattern for type definitions)
    2. {type_name}.spl (dedicated file for the type)
    3. mod.spl (module entry point)
    4. All other .spl files in the module directory

    Args:
        module_path: Path to module directory
        type_name: Name of the type to find

    Returns:
        Full path to source file, or empty string if not found
    """
    # Priority 1: types.spl
    val types_file = module_path + "/types.spl"
    if rt_file_exists(types_file) and contains_type_def(types_file, type_name):
        return types_file

    # Priority 2: {type_name}.spl
    val snake_name = camel_to_snake(type_name)
    val dedicated_file = module_path + "/" + snake_name + ".spl"
    if rt_file_exists(dedicated_file) and contains_type_def(dedicated_file, type_name):
        return dedicated_file

    # Priority 3: mod.spl
    val mod_file = module_path + "/mod.spl"
    if rt_file_exists(mod_file) and contains_type_def(mod_file, type_name):
        return mod_file

    # Priority 4: Scan all .spl files
    if not rt_dir_exists(module_path):
        return ""

    val files = rt_dir_list(module_path)
    for filename in files:
        if filename.ends_with(".spl"):
            val filepath = module_path + "/" + filename
            if contains_type_def(filepath, type_name):
                return filepath

    ""

# Check if a file contains a type definition
fn contains_type_def(filepath: text, type_name: text) -> bool:
    """
    Check if a file contains the definition of a type.

    Looks for patterns like:
    - struct TypeName:
    - class TypeName:
    - enum TypeName:
    - fn type_name(
    """
    if not rt_file_exists(filepath):
        return false

    val content = rt_file_read_text(filepath) ?? ""
    val lines = content.split("\n")

    for line in lines:
        val trimmed = line
        # Check for struct/class/enum
        if (trimmed.starts_with("struct " + type_name + ":") or
            trimmed.starts_with("class " + type_name + ":") or
            trimmed.starts_with("enum " + type_name + ":")):
            return true

        # Check for function (convert to snake_case)
        val snake_name = camel_to_snake(type_name)
        if trimmed.starts_with("fn " + snake_name + "("):
            return true

    false

# Extract docstring for a type
fn extract_docstring(filepath: text, type_name: text) -> text:
    """
    Extract the docstring associated with a type definition.

    Looks for:
    1. Triple-quoted string immediately after type declaration
    2. # comments immediately before type declaration

    Returns the docstring text, or empty string if none found.
    """
    if not rt_file_exists(filepath):
        return ""

    val content = rt_file_read_text(filepath) ?? ""

    # Try triple-quoted docstring after declaration
    val after_docstring = extract_triple_quoted_after(content, type_name)
    if after_docstring.len() > 0:
        return after_docstring

    # Try # comments before declaration
    val before_docstring = extract_hash_comments_before(content, type_name)
    if before_docstring.len() > 0:
        return before_docstring

    ""

# Extract triple-quoted docstring after type declaration
fn extract_triple_quoted_after(content: text, type_name: text) -> text:
    # Find triple-quoted docstring immediately after type declaration
    val lines = content.split("\n")
    var i = 0

    while i < lines.len():
        val line = trim(lines[i])

        # Check if this line declares our type
        val is_type_decl = (
            line.starts_with("struct " + type_name + ":") or
            line.starts_with("class " + type_name + ":") or
            line.starts_with("enum " + type_name + ":")
        )

        val snake_name = camel_to_snake(type_name)
        val is_fn_decl = line.starts_with("fn " + snake_name + "(")

        if is_type_decl or is_fn_decl:
            # Look for """ on next line or after
            var j = i + 1

            # Skip blank lines and opening brace
            while j < lines.len():
                val next_line = trim(lines[j])

                if next_line.starts_with("\"\"\""):
                    # Found start of docstring
                    var docstring_lines = []
                    j = j + 1

                    # Collect lines until closing """
                    while j < lines.len():
                        val doc_line = lines[j]
                        if trim(doc_line).starts_with("\"\"\""):
                            # Found end
                            return trim(join_lines(docstring_lines))
                        docstring_lines = docstring_lines + [doc_line]
                        j = j + 1

                    # No closing found
                    return trim(join_lines(docstring_lines))
                # Stop if we hit another declaration
                if (next_line.starts_with("fn ") or
                    next_line.starts_with("struct ") or
                    next_line.starts_with("class ") or
                    next_line.starts_with("enum ") or
                    next_line.starts_with("impl ")):
                    break

                # Skip blank lines and fields
                if next_line.len() == 0 or next_line.contains(":"):
                    j = j + 1
                    continue

                break

        i = i + 1

    ""

# Extract # comment docstring before type declaration
fn extract_hash_comments_before(content: text, type_name: text) -> text:
    """Find # comments immediately before type declaration"""
    val lines = content.split("\n")
    var i = 0

    while i < lines.len():
        val line = lines[i]
        # Check if this line declares our type
        val is_type_decl = (
            line.starts_with("struct " + type_name + ":") or
            line.starts_with("class " + type_name + ":") or
            line.starts_with("enum " + type_name + ":")
        )

        val snake_name = camel_to_snake(type_name)
        val is_fn_decl = line.starts_with("fn " + snake_name + "(")

        if is_type_decl or is_fn_decl:
            # Look backwards for # comments
            var comment_lines = []
            var j = i - 1

            while j >= 0:
                val prev_line = lines[j]
                if prev_line.starts_with("#"):
                    # Remove # prefix and add to beginning
                    val comment_text = prev_line.substring(1, prev_line.len())
                    comment_lines = [comment_text] + comment_lines
                    j = j - 1
                    continue

                # Stop at blank line or non-comment
                if prev_line.len() == 0:
                    j = j - 1
                    continue

                break

            if comment_lines.len() > 0:
                return join_lines(comment_lines)
        i = i + 1

    ""

# Detect the kind of type (enum, struct, class, fn)
fn detect_type_kind(filepath: text, type_name: text) -> text:
    """Determine if type is enum, struct, class, or fn"""
    if not rt_file_exists(filepath):
        return "unknown"

    val content = rt_file_read_text(filepath) ?? ""
    val lines = content.split("\n")

    for line in lines:
        val trimmed = line
        if trimmed.starts_with("struct " + type_name + ":"):
            return "struct"
        if trimmed.starts_with("class " + type_name + ":"):
            return "class"
        if trimmed.starts_with("enum " + type_name + ":"):
            return "enum"

        val snake_name = camel_to_snake(type_name)
        if trimmed.starts_with("fn " + snake_name + "("):
            return "fn"

    "unknown"

# Find line number where type is defined
fn find_type_line_number(filepath: text, type_name: text) -> i64:
    """Find the line number where a type is defined"""
    if not rt_file_exists(filepath):
        return 0

    val content = rt_file_read_text(filepath) ?? ""
    val lines = content.split("\n")
    var line_num = 1

    for line in lines:
        val trimmed = line
        # Check for type declaration
        if (trimmed.starts_with("struct " + type_name + ":") or
            trimmed.starts_with("class " + type_name + ":") or
            trimmed.starts_with("enum " + type_name + ":")):
            return line_num

        val snake_name = camel_to_snake(type_name)
        if trimmed.starts_with("fn " + snake_name + "("):
            return line_num

        line_num = line_num + 1

    0

# Helper: Join lines with newline
fn join_lines(lines: [text]) -> text:
    """Join array of text lines with newline separator"""
    if lines.len() == 0:
        return ""

    var result = lines[0]
    var i = 1
    while i < lines.len():
        result = result + "\n" + lines[i]
        i = i + 1
    result

# Helper: Trim whitespace from both ends
fn trim(s: text) -> text:
    """Remove leading and trailing whitespace"""
    if s.len() == 0:
        return s

    # Find first non-whitespace
    var start = 0
    var i = 0
    while i < s.len():
        val ch = s[i]
        if ch != " " and ch != "\t" and ch != "\n" and ch != "\r":
            start = i
            break
        i = i + 1

    # All whitespace
    if i == s.len():
        return ""

    # Find last non-whitespace
    var end_pos = s.len()
    var j = s.len() - 1
    while j >= 0:
        val ch = s[j]
        if ch != " " and ch != "\t" and ch != "\n" and ch != "\r":
            end_pos = j + 1
            break
        j = j - 1

    # Extract substring
    if start < end_pos:
        return s.substring(start, end_pos)

    ""

# Convert CamelCase to snake_case
fn camel_to_snake(name: text) -> text:
    """Convert CamelCase identifier to snake_case"""
    if name.len() == 0:
        return name

    var result = ""
    var i = 0

    while i < name.len():
        val ch = name[i]

        # Check if uppercase
        if ch >= "A" and ch <= "Z":
            # Add underscore before uppercase (except at start)
            if i > 0:
                result = result + "_"
            # Convert to lowercase
            val lower_code = char_code(ch) + 32
            result = result + char_from_code(lower_code)
        else:
            result = result + ch

        i = i + 1

    result

# Helper: Get character code
fn char_code(ch: text) -> i64:
    """Get ASCII code for single character"""
    # This is a simplified version - use std.text.char_code in practice
    if ch == "A": return 65
    if ch == "B": return 66
    if ch == "C": return 67
    if ch == "D": return 68
    if ch == "E": return 69
    if ch == "F": return 70
    if ch == "G": return 71
    if ch == "H": return 72
    if ch == "I": return 73
    if ch == "J": return 74
    if ch == "K": return 75
    if ch == "L": return 76
    if ch == "M": return 77
    if ch == "N": return 78
    if ch == "O": return 79
    if ch == "P": return 80
    if ch == "Q": return 81
    if ch == "R": return 82
    if ch == "S": return 83
    if ch == "T": return 84
    if ch == "U": return 85
    if ch == "V": return 86
    if ch == "W": return 87
    if ch == "X": return 88
    if ch == "Y": return 89
    if ch == "Z": return 90
    if ch == "_": return 95
    0  # Default for lowercase/other

# Helper: Get character from code
fn char_from_code(code: i64) -> text:
    """Get character from ASCII code"""
    # This is a simplified version - use std.text.char_from_code in practice
    if code == 97: return "a"
    if code == 98: return "b"
    if code == 99: return "c"
    if code == 100: return "d"
    if code == 101: return "e"
    if code == 102: return "f"
    if code == 103: return "g"
    if code == 104: return "h"
    if code == 105: return "i"
    if code == 106: return "j"
    if code == 107: return "k"
    if code == 108: return "l"
    if code == 109: return "m"
    if code == 110: return "n"
    if code == 111: return "o"
    if code == 112: return "p"
    if code == 113: return "q"
    if code == 114: return "r"
    if code == 115: return "s"
    if code == 116: return "t"
    if code == 117: return "u"
    if code == 118: return "v"
    if code == 119: return "w"
    if code == 120: return "x"
    if code == 121: return "y"
    if code == 122: return "z"
    if code == 95: return "_"
    ""  # Default

export DocstringInfo
export check_module_docstrings
export find_type_source_file
export extract_docstring
export contains_type_def
export detect_type_kind
export find_type_line_number
export camel_to_snake
