# Public Documentation Check - Warning System
#
# Generates compiler-style warnings for missing docstrings on public exports.
# Emits warnings in standard format: file:line: warning: message

use app.io
use std.text.{NL}

export PublicWarning
export check_public_comments
export format_warning
export emit_warnings
export warnings_to_json

# Warning for missing public docstring
struct PublicWarning:
    module_path: text
    symbol_name: text
    symbol_type: text
    source_file: text
    line_number: i64
    message: text

impl PublicWarning:
    static fn new(
        module_path: text,
        symbol_name: text,
        symbol_type: text,
        source_file: text,
        line_number: i64
    ) -> PublicWarning:
        val message = "Public {symbol_type} '{symbol_name}' lacks docstring"
        PublicWarning(
            module_path: module_path,
            symbol_name: symbol_name,
            symbol_type: symbol_type,
            source_file: source_file,
            line_number: line_number,
            message: message
        )

fn check_public_comments(module_path: text) -> [PublicWarning]:
    """Check a module for missing public docstrings.

    Scans source file for export statements and verifies each exported
    symbol has a docstring.

    Args:
        module_path: Path to .spl source file

    Returns:
        List of PublicWarning for undocumented exports
    """
    if not file_exists(module_path):
        return []

    val content = file_read(module_path)
    val lines = content.split(NL)

    var warnings = []
    var exports = extract_exports(lines)

    # Check each export for docstring
    for export_info in exports:
        val has_docstring = check_symbol_has_docstring(
            lines,
            export_info.0,  # symbol name
            export_info.1,  # line number
            export_info.2   # symbol type
        )

        if not has_docstring:
            val warning = PublicWarning.new(
                module_path,
                export_info.0,  # symbol_name
                export_info.2,  # symbol_type
                module_path,
                export_info.1   # line_number
            )
            warnings = warnings + [warning]

    warnings

fn extract_exports(lines: [text]) -> [(text, i64, text)]:
    """Extract all export statements from source lines.

    Returns list of (symbol_name, line_number, symbol_type) tuples.
    """
    var exports = []
    var i = 0

    while i < lines.len():
        val line = lines[i]
        val trimmed = line.trim()

        # Pattern: export symbol_name
        if trimmed.starts_with("export "):
            val export_part = trimmed.substring(7, trimmed.len()).trim()

            # Handle comma-separated exports
            val symbols = export_part.split(",")
            for symbol in symbols:
                val clean_symbol = symbol.trim()
                if clean_symbol.len() > 0:
                    # Determine symbol type from definition
                    val symbol_type = find_symbol_type(lines, clean_symbol, i)
                    exports = exports + [(clean_symbol, i + 1, symbol_type)]

        i = i + 1

    exports

fn find_symbol_type(lines: [text], symbol_name: text, export_line: i64) -> text:
    """Determine the type of an exported symbol (fn, struct, class, enum).

    Searches backwards and forwards from export line to find definition.
    """
    # Search backwards from export line
    var i = export_line - 1
    while i >= 0:
        val line = lines[i].trim()

        if line.starts_with("fn {symbol_name}(") or line.starts_with("fn {symbol_name} "):
            return "function"
        if line.starts_with("struct {symbol_name}:") or line.starts_with("struct {symbol_name} "):
            return "struct"
        if line.starts_with("class {symbol_name}:") or line.starts_with("class {symbol_name} "):
            return "class"
        if line.starts_with("enum {symbol_name}:") or line.starts_with("enum {symbol_name} "):
            return "enum"
        if line.starts_with("type {symbol_name} ="):
            return "type"

        i = i - 1

    # Search forwards from export line (exports can come before definitions)
    i = export_line + 1
    while i < lines.len():
        val line = lines[i].trim()

        if line.starts_with("fn {symbol_name}(") or line.starts_with("fn {symbol_name} "):
            return "function"
        if line.starts_with("struct {symbol_name}:") or line.starts_with("struct {symbol_name} "):
            return "struct"
        if line.starts_with("class {symbol_name}:") or line.starts_with("class {symbol_name} "):
            return "class"
        if line.starts_with("enum {symbol_name}:") or line.starts_with("enum {symbol_name} "):
            return "enum"
        if line.starts_with("type {symbol_name} ="):
            return "type"

        # Stop searching if we hit another export or major definition
        if line.starts_with("export ") or line.starts_with("fn ") or line.starts_with("struct ") or line.starts_with("class "):
            break

        i = i + 1

    "symbol"

fn check_symbol_has_docstring(
    lines: [text],
    symbol_name: text,
    export_line: i64,
    symbol_type: text
) -> bool:
    """Check if a symbol has a docstring before its definition.

    A docstring is a triple-quoted string immediately before the definition.
    """
    # Find the definition line
    var def_line = -1
    var i = 0

    while i < lines.len():
        val line = lines[i].trim()

        # Match function definition
        if symbol_type == "function":
            if line.starts_with("fn {symbol_name}(") or line.starts_with("fn {symbol_name} "):
                def_line = i
                break

        # Match struct/class/enum definition
        if line.starts_with("{symbol_type} {symbol_name}:") or line.starts_with("{symbol_type} {symbol_name} "):
            def_line = i
            break

        # Match type alias
        if symbol_type == "type" and line.starts_with("type {symbol_name} ="):
            def_line = i
            break

        i = i + 1

    if def_line < 0:
        # Symbol not found, can't verify
        return true

    # Check previous lines for triple-quoted docstring
    var j = def_line - 1
    while j >= 0:
        val line = lines[j].trim()

        # Skip blank lines and comments
        if line == "" or line.starts_with("#"):
            j = j - 1
            continue

        # Found docstring
        if line.contains("\"\"\""):
            return true

        # Hit another definition or export without finding docstring
        if (line.starts_with("fn ") or
            line.starts_with("struct ") or
            line.starts_with("class ") or
            line.starts_with("enum ") or
            line.starts_with("export ")):
            return false

        j = j - 1

    false

fn format_warning(warning: PublicWarning) -> text:
    """Format a warning in compiler-style format.

    Output format: file:line: warning: message
    """
    "{warning.source_file}:{str(warning.line_number)}: warning: {warning.message}"

fn emit_warnings(warnings: [PublicWarning]):
    """Emit warnings to stdout in compiler format.

    Prints each warning on a separate line.
    """
    for warning in warnings:
        print format_warning(warning)

fn warnings_to_json(warnings: [PublicWarning]) -> text:
    """Convert warnings to JSON format for IDE integration.

    Returns JSON array of warning objects.
    """
    if warnings.len() == 0:
        return "[]"

    var json = "[\n"
    var i = 0

    while i < warnings.len():
        val w = warnings[i]

        json = json + "  {{\n"
        json = json + "    \"module_path\": \"{escape_json(w.module_path)}\",\n"
        json = json + "    \"symbol_name\": \"{escape_json(w.symbol_name)}\",\n"
        json = json + "    \"symbol_type\": \"{escape_json(w.symbol_type)}\",\n"
        json = json + "    \"source_file\": \"{escape_json(w.source_file)}\",\n"
        json = json + "    \"line_number\": {str(w.line_number)},\n"
        json = json + "    \"message\": \"{escape_json(w.message)}\"\n"
        json = json + "  }}"

        if i < warnings.len() - 1:
            json = json + ","

        json = json + "\n"
        i = i + 1

    json + "]"

fn escape_json(s: text) -> text:
    """Escape special characters for JSON strings."""
    var result = s
    result = result.replace("\\", "\\\\")
    result = result.replace("\"", "\\\"")
    result = result.replace("\n", "\\n")
    result = result.replace("\r", "\\r")
    result = result.replace("\t", "\\t")
    result
