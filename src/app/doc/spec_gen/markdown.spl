# Spec Generator - Markdown Generation Module
# Generates formatted markdown documentation from parsed specs

use app.io
use app.utils.markdown (MarkdownBuilder)
use app.doc.spec_gen.types (SpecFile, TestCase)
use std.text.{NL}

export generate_markdown, generate_quick_toc, generate_symbol_table

fn generate_markdown(spec: SpecFile, output_path: text) -> bool:
    """Generate markdown documentation from parsed spec"""
    var md = MarkdownBuilder(content: "")

    # Header
    val title = spec.title()
    md.h1(title)
    md.append(NL)

    # Warning banner
    md.append("> **⚠️ GENERATED FILE** - Do not edit directly!{NL}")
    md.append("> **Source:** `{spec.path}`{NL}")
    md.append("> **Generated:** {current_timestamp()}{NL}")
    md.append(">{NL}")
    md.append("> To update this file, edit the source _spec.spl file and run:{NL}")
    md.append("> ```bash{NL}")
    md.append("> simple doc/spec_gen {spec.path}{NL}")
    md.append("> ```{NL}")
    md.append(NL)

    # Metadata
    if spec.metadata.len() > 0:
        for meta in spec.metadata:
            val key = meta.0
            val value = meta.1
            # Skip internal metadata
            if key != "Migrated From" and key != "Source" and key != "Type":
                md.append("**{key}:** {value}{NL}")
        md.append(NL)

    # Quick navigation TOC
    md.append(generate_quick_toc(spec))

    # Overview from header
    if spec.header_docstring.contains("## Overview"):
        md.h2("Overview")
        md.append(NL)
        val overview = extract_section(spec.header_docstring, "Overview")
        md.append(overview)
        md.append(NL)

    # Related specifications
    if spec.header_docstring.contains("## Related Specifications"):
        md.h2("Related Specifications")
        md.append(NL)
        val related = extract_section(spec.header_docstring, "Related Specifications")
        md.append(related)
        md.append(NL)

    md.append("---{NL}{NL}")

    # Symbol table
    val symbol_table = generate_symbol_table(spec)
    if symbol_table.len() > 0:
        md.append(symbol_table)
        md.append("---{NL}{NL}")

    # Test cases summary
    if spec.test_cases.len() > 0:
        md.h2("Test Cases ({spec.test_cases.len()} total)")
        md.append(NL)
        md.append("| # | Test | Section | Symbols |{NL}")
        md.append("|---|------|---------|---------||{NL}")

        var i = 1
        for tc in spec.test_cases:
            val desc = tc.short_description()
            val symbols_str = format_symbols(tc.symbols, 3)
            md.append("| {i} | [{tc.name}](#{tc.name}) | {tc.section} | {symbols_str} |{NL}")
            i = i + 1

        md.append(NL)
        md.append("---{NL}{NL}")

    # Detailed test cases
    var test_num = 1
    for tc in spec.test_cases:
        md.h3("Test {test_num}: {tc.section} {{#{tc.name}}}")
        md.append(NL)

        if tc.line_number > 0:
            md.append("*Source line: ~{tc.line_number}*{NL}{NL}")

        md.append("**Test name:** `{tc.name}`{NL}{NL}")

        if tc.docstring.len() > 0:
            md.append("**Description:**{NL}{NL}")
            md.append(tc.docstring)
            md.append("{NL}{NL}")

        # Linked symbols
        if tc.symbols.len() > 0:
            md.append("**Linked Symbols:**{NL}")
            val limit = if tc.symbols.len() > 10: 10 else: tc.symbols.len()
            for j in 0..limit:
                md.append("- `{tc.symbols[j]}`{NL}")
            if tc.symbols.len() > 10:
                val more = tc.symbols.len() - 10
                md.append("- ... and {more} more{NL}")
            md.append(NL)

        # Related tests
        if tc.related_tests.len() > 0:
            md.append("**Related Tests:**{NL}")
            for related in tc.related_tests:
                md.append("- [{related}](#{related}){NL}")
            md.append(NL)

        # Code
        md.append("**Code:**{NL}{NL}")
        md.code_block(tc.code, "simple")
        md.append(NL)

        test_num = test_num + 1

    # Source code section
    md.append("---{NL}{NL}")
    md.h2("Source Code")
    md.append(NL)
    md.append("**View full specification:** [{extract_filename(spec.path)}]({spec.path}){NL}{NL}")

    # Footer
    md.append("---{NL}{NL}")
    md.append("*This file was auto-generated from the executable specification.*{NL}")
    md.append("*Source: `{spec.path}`*{NL}{NL}")

    # Write to file
    if output_path.len() > 0:
        file_write(output_path, md.to_string())
        print "✅ Generated: {output_path}"
        return true

    false

fn generate_quick_toc(spec: SpecFile) -> text:
    """Generate quick navigation TOC"""
    if spec.test_cases.len() == 0:
        return ""

    var toc = "## Quick Navigation{NL}{NL}"

    var i = 1
    for tc in spec.test_cases:
        toc = toc + "{i}. [{tc.section}](#{tc.name}){NL}"
        i = i + 1

    toc + NL

fn generate_symbol_table(spec: SpecFile) -> text:
    """Generate symbol index table showing which tests use which symbols"""
    # Build symbol -> tests mapping
    var symbol_map = []

    for tc in spec.test_cases:
        for symbol in tc.symbols:
            # Check if symbol already in map
            var found = false
            for i in 0..symbol_map.len():
                if symbol_map[i].0 == symbol:
                    # Add test to this symbol's list
                    symbol_map[i].1 = symbol_map[i].1 + [tc.name]
                    found = true
                    break

            if not found:
                symbol_map = symbol_map + [(symbol, [tc.name])]

    if symbol_map.len() == 0:
        return ""

    var table = "## Symbol Index{NL}{NL}"
    table = table + "| Symbol | Used in Tests |{NL}"
    table = table + "|--------|---------------|{NL}"

    for entry in symbol_map:
        val symbol = entry.0
        val tests = entry.1
        val test_links = format_test_links(tests)
        table = table + "| `{symbol}` | {test_links} |{NL}"

    table + NL

fn extract_section(docstring: text, section_name: text) -> text:
    """Extract content of a section from docstring"""
    val marker = "## {section_name}"
    val start = docstring.find(marker)
    if start < 0:
        return ""

    val after_marker = docstring.substring(start + marker.len(), docstring.len())

    # Find next ## or end of string
    val next_section = after_marker.find("{NL}##")
    if next_section > 0:
        return after_marker.substring(0, next_section).trim()

    after_marker.trim()

fn format_symbols(symbols: [text], limit: i64) -> text:
    """Format symbol list with limit"""
    if symbols.len() == 0:
        return ""

    var result = ""
    val actual_limit = if symbols.len() < limit: symbols.len() else: limit

    for i in 0..actual_limit:
        if i > 0:
            result = result + ", "
        result = result + "`{symbols[i]}`"

    if symbols.len() > limit:
        val more = symbols.len() - limit
        result = result + " +{more}"

    result

fn format_test_links(tests: [text]) -> text:
    """Format test names as links"""
    if tests.len() == 0:
        return ""

    var result = ""
    for i in 0..tests.len():
        if i > 0:
            result = result + ", "
        result = result + "[{tests[i]}](#{tests[i]})"

    result

fn extract_filename(path: text) -> text:
    """Extract filename from path"""
    val parts = path.split("/")
    if parts.len() > 0:
        return parts[parts.len() - 1]
    path

fn current_timestamp() -> text:
    """Get current timestamp"""
    val year = timestamp_year()
    val month = timestamp_month()
    val day = timestamp_day()
    val hour = timestamp_hour()
    val minute = timestamp_minute()
    val second = timestamp_second()

    "{year}-{month:02}-{day:02} {hour:02}:{minute:02}:{second:02}"
