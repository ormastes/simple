#!/usr/bin/env simple
# Spec Generator - Main Entry Point
# Generate markdown documentation from _spec.spl files
#
# Usage:
#   spec_gen --input tests/specs/syntax_spec.spl
#   spec_gen --all
#   spec_gen --all --output doc/spec/generated/
#
# Migrated from scripts/build/spec_gen.py

use app.io
use app.utils.colors.{success, error, warning, info}
use app.doc.spec_gen.types.{SpecFile, categorize_spec}
use app.doc.spec_gen.parser.{parse_spec_file}
use app.doc.spec_gen.symbols.{extract_symbols_hybrid}
use app.doc.spec_gen.markdown.{generate_markdown}

export main, spec_gen

struct Config:
    input_file: text
    output_dir: text
    process_all: bool
    generate_index: bool

fn main():
    val args = get_args()
    val config = parse_args(args)

    if config.generate_index:
        generate_index(config.output_dir)
    elif config.process_all:
        process_all_specs(config)
    elif config.input_file.len() > 0:
        process_single_spec(config)
    else:
        show_usage()

fn spec_gen():
    """Main entry point"""
    main()

fn parse_args(args: [text]) -> Config:
    """Parse command line arguments"""
    var input_file = ""
    var output_dir = "doc/spec/generated"
    var process_all = false
    var generate_index = false

    var i = 0
    while i < args.len():
        val arg = args[i]

        if arg == "--input" or arg == "-i":
            if i + 1 < args.len():
                input_file = args[i + 1]
                i = i + 2
            else:
                print error("--input requires a file path")
                exit(1)
        elif arg == "--output" or arg == "-o":
            if i + 1 < args.len():
                output_dir = args[i + 1]
                i = i + 2
            else:
                print error("--output requires a directory path")
                exit(1)
        elif arg == "--all" or arg == "-a":
            process_all = true
            i = i + 1
        elif arg == "--index":
            generate_index = true
            i = i + 1
        elif arg == "--help" or arg == "-h":
            show_usage()
            exit(0)
        else:
            print error("Unknown option: {arg}")
            show_usage()
            exit(1)

    Config(
        input_file: input_file,
        output_dir: output_dir,
        process_all: process_all,
        generate_index: generate_index
    )

fn show_usage():
    """Show usage information"""
    print "Spec Generator - Generate markdown documentation from _spec.spl files"
    print ""
    print "Usage:"
    print "  spec_gen --input <file>              Process single spec file"
    print "  spec_gen --all [--output <dir>]      Process all spec files"
    print "  spec_gen --index [--output <dir>]    Generate root TOC"
    print "  spec_gen --help                      Show this help"
    print ""
    print "Options:"
    print "  -i, --input FILE    Input spec file path"
    print "  -o, --output DIR    Output directory (default: doc/spec/generated)"
    print "  -a, --all           Process all _spec.spl files"
    print "  --index             Generate root index/TOC"
    print "  -h, --help          Show help"
    print ""
    print "Examples:"
    print "  spec_gen --input tests/specs/syntax_spec.spl"
    print "  spec_gen --all"
    print "  spec_gen --all --output doc/spec/generated/"
    print "  spec_gen --index"

fn process_single_spec(config: Config):
    """Process a single spec file"""
    if not file_exists(config.input_file):
        print error("File not found: {config.input_file}")
        exit(1)

    print "Processing: {config.input_file}"

    # Parse spec file
    val spec = parse_spec_file(config.input_file)

    # Generate output path
    val output_path = generate_output_path(config.input_file, config.output_dir)

    # Create output directory
    ensure_dir(output_path)

    # Generate markdown
    if generate_markdown(spec, output_path):
        print success("✅ Generated: {output_path}")
    else:
        print error("❌ Failed to generate: {output_path}")

fn process_all_specs(config: Config):
    """Process all _spec.spl files"""
    print "Searching for spec files..."

    val spec_files = find_spec_files()

    if spec_files.len() == 0:
        print warning("No spec files found")
        return

    print "Found {spec_files.len()} spec files"
    print ""

    var processed = 0
    var failed = 0

    for spec_file in spec_files:
        print "Processing: {spec_file}"

        val spec = parse_spec_file(spec_file)

        # Generate output
        val output_path = generate_output_path(spec_file, config.output_dir)
        ensure_dir(output_path)

        if generate_markdown(spec, output_path):
            processed = processed + 1
        else:
            failed = failed + 1

    print ""
    print success("✅ Processed: {processed} files")
    if failed > 0:
        print error("❌ Failed: {failed} files")

fn generate_index(output_dir: text):
    """Generate root index/TOC"""
    print "Generating root index..."

    val spec_files = find_spec_files()

    if spec_files.len() == 0:
        print warning("No spec files found")
        return

    # Group by category - use parallel arrays
    var cat_names = []
    var cat_specs = []

    for spec_file in spec_files:
        val category = categorize_spec(spec_file)
        val spec = parse_spec_file(spec_file)

        # Add to category
        var found = false
        var found_idx = 0
        var i = 0
        while i < cat_names.len():
            if cat_names[i] == category:
                found = true
                found_idx = i
                i = cat_names.len()
            i = i + 1

        if found:
            cat_specs[found_idx] = cat_specs[found_idx] + [spec]
        else:
            cat_names = cat_names + [category]
            cat_specs = cat_specs + [[spec]]

    # Generate TOC markdown
    var toc = "# Specification Index\n\n"
    toc = toc + "**Generated:** {current_timestamp()}\n\n"
    toc = toc + "## Categories\n\n"

    var ci = 0
    while ci < cat_names.len():
        val category = cat_names[ci]
        val specs = cat_specs[ci]

        toc = toc + "### {category}\n\n"

        for spec in specs:
            val title = spec.title()
            val rel_path = spec.path.replace("tests/specs/", "").replace("_spec.spl", ".md")
            toc = toc + "- [{title}]({rel_path}) ({spec.test_cases.len()} tests)\n"

        toc = toc + "\n"
        ci = ci + 1

    # Write index
    val index_path = "{output_dir}/INDEX.md"
    ensure_dir(index_path)
    file_write(index_path, toc)

    print success("✅ Generated index: {index_path}")

fn find_spec_files() -> [text]:
    """Find all _spec.spl files"""
    val search_dirs = ["tests/specs", "test"]

    var spec_files = []

    for dir in search_dirs:
        if is_dir(dir):
            val (stdout, _, code) = process_run("find", [dir, "-name", "*_spec.spl", "-type", "f"])

            if code == 0:
                val lines = stdout.split("\n")
                for line in lines:
                    val trimmed = line.trim()
                    if trimmed.len() > 0:
                        spec_files = spec_files + [trimmed]

    spec_files

fn generate_output_path(input_path: text, output_dir: text) -> text:
    """Generate output markdown path from input path"""
    val filename = extract_filename(input_path)
    val md_filename = filename.replace("_spec.spl", ".md")
    "{output_dir}/{md_filename}"

fn extract_filename(path: text) -> text:
    """Extract filename from path"""
    val parts = path.split("/")
    if parts.len() > 0:
        return parts[parts.len() - 1]
    path

fn ensure_dir(file_path: text):
    """Ensure directory exists for file path"""
    val parts = file_path.split("/")
    if parts.len() > 1:
        var dir_parts = []
        for i in 0..(parts.len() - 1):
            dir_parts = dir_parts + [parts[i]]
        val dir = dir_parts.join("/")

        if not is_dir(dir):
            dir_create(dir, recursive: true)

fn current_timestamp() -> text:
    """Get current timestamp"""
    val year = timestamp_year()
    val month = timestamp_month()
    val day = timestamp_day()
    val hour = timestamp_hour()
    val minute = timestamp_minute()

    "{year}-{month}-{day} {hour}:{minute}"
