# Simple Language EasyFix Module
# Provides machine-applicable fix data structures and application engine.
# Usage: simple fix <file.spl> [--dry-run] [--fix-all] [--fix-interactive]

extern fn native_fs_read_string(path: String) -> Any
extern fn native_fs_write_string(path: String, content: String) -> Any
extern fn native_fs_exists(path: String) -> Bool
extern fn sys_get_args() -> List<String>

# ============================================================================
# Fix Confidence Levels
# ============================================================================

enum FixConfidence:
    Safe       # Auto-apply without review
    Likely     # Probably correct, review recommended
    Uncertain  # May change semantics, needs human review

# ============================================================================
# Replacement: a single text substitution
# ============================================================================

class Replacement:
    file: String
    start: Int
    end: Int
    line: Int
    column: Int
    new_text: String

    static fn create(file: String, start: Int, end: Int, line: Int, column: Int, new_text: String) -> Replacement:
        Replacement(file: file, start: start, end: end, line: line, column: column, new_text: new_text)

    fn format() -> String:
        "{self.file}:{self.line}:{self.column} [{self.start}..{self.end}] -> \"{self.new_text}\""

# ============================================================================
# EasyFix: a machine-applicable fix for a diagnostic
# ============================================================================

class EasyFix:
    id: String
    description: String
    replacements: List<Replacement>
    confidence: FixConfidence

    static fn create(id: String, description: String, confidence: FixConfidence) -> EasyFix:
        EasyFix(id: id, description: description, replacements: [], confidence: confidence)

    me add_replacement(replacement: Replacement):
        self.replacements.push(replacement)

    fn is_safe() -> Bool:
        match self.confidence:
            case Safe: true
            case _: false

    fn is_likely() -> Bool:
        match self.confidence:
            case Safe: true
            case Likely: true
            case _: false

    fn format() -> String:
        var result = "[{self.id}] {self.description} (confidence: {self.confidence_str()})"
        for rep in self.replacements:
            result = result + "\n  " + rep.format()
        result

    fn confidence_str() -> String:
        match self.confidence:
            case Safe: "safe"
            case Likely: "likely"
            case Uncertain: "uncertain"

# ============================================================================
# FixReport: result of applying fixes
# ============================================================================

class FixReport:
    applied: Int
    skipped: Int
    modified_files: List<String>
    details: List<String>

    static fn empty() -> FixReport:
        FixReport(applied: 0, skipped: 0, modified_files: [], details: [])

    fn format(dry_run: Bool) -> String:
        val prefix = if dry_run then "Would apply" else "Applied"
        var result = "{prefix} {self.applied} fix(es):"
        for detail in self.details:
            result = result + "\n  " + detail
        if not self.modified_files.is_empty():
            val verb = if dry_run then "Would modify" else "Modified"
            result = result + "\n{verb} {self.modified_files.len()} file(s):"
            for file in self.modified_files:
                result = result + "\n  " + file
        result

# ============================================================================
# FixApplicator: applies fixes to source files
# ============================================================================

class FixApplicator:
    static fn apply(fixes: List<EasyFix>, sources: Dict<String, String>) -> Result<Dict<String, String>, String>:
        # Group replacements by file
        var by_file: Dict<String, List<Replacement>> = {}

        for fix in fixes:
            for rep in fix.replacements:
                if not by_file.contains_key(rep.file):
                    by_file[rep.file] = []
                by_file[rep.file].push(rep)

        var results: Dict<String, String> = {}

        for file in by_file.keys():
            if not sources.contains_key(file):
                return Err("File not found in sources: {file}")

            val source = sources[file]
            var replacements = by_file[file]

            # Sort by start position descending (apply from end to avoid offset shifts)
            replacements = replacements.sort_by(\a, b: b.start - a.start)

            # Check for overlapping spans
            var i = 0
            while i < replacements.len() - 1:
                val curr = replacements[i]
                val next = replacements[i + 1]
                # curr.start >= next.start (sorted descending)
                if next.end > curr.start:
                    return Err("Conflicting replacements in {file}: spans [{next.start}..{next.end}] and [{curr.start}..{curr.end}] overlap")
                i = i + 1

            # Apply replacements from end to start
            var new_source = source
            for rep in replacements:
                if rep.start <= new_source.len() and rep.end <= new_source.len():
                    new_source = new_source.slice(0, rep.start) + rep.new_text + new_source.slice(rep.end)

            results[file] = new_source

        Ok(results)

    static fn apply_to_disk(fixes: List<EasyFix>, sources: Dict<String, String>, dry_run: Bool) -> Result<FixReport, String>:
        val result = FixApplicator.apply(fixes, sources)
        match result:
            case Err(e):
                return Err(e)
            case Ok(new_contents):
                var report = FixReport.empty()
                report.applied = fixes.len()

                for file in new_contents.keys():
                    report.modified_files.push(file)
                    if not dry_run:
                        native_fs_write_string(file, new_contents[file])

                for fix in fixes:
                    report.details.push("[{fix.id}] {fix.description}")

                Ok(report)

    static fn filter_by_confidence(fixes: List<EasyFix>, min_confidence: FixConfidence) -> List<EasyFix>:
        match min_confidence:
            case Safe:
                fixes.filter(\f: f.is_safe())
            case Likely:
                fixes.filter(\f: f.is_likely())
            case Uncertain:
                fixes

    static fn filter_by_id(fixes: List<EasyFix>, id_prefix: String) -> List<EasyFix>:
        fixes.filter(\f: f.id.starts_with(id_prefix))

# ============================================================================
# InteractiveFix: prompts user for each fix
# ============================================================================

class InteractiveFix:
    static fn prompt_fixes(fixes: List<EasyFix>) -> List<EasyFix>:
        var accepted: List<EasyFix> = []
        var i = 0

        for fix in fixes:
            print("")
            print("Fix {i + 1}/{fixes.len()}: {fix.format()}")
            print("  [y]es / [n]o / [a]ll / [q]uit > ")

            val input = input_line().trim().lower()

            match input:
                case "y":
                    accepted.push(fix)
                case "yes":
                    accepted.push(fix)
                case "a":
                    accepted.push(fix)
                    # Accept all remaining
                    var j = i + 1
                    while j < fixes.len():
                        accepted.push(fixes[j])
                        j = j + 1
                    return accepted
                case "all":
                    accepted.push(fix)
                    var j = i + 1
                    while j < fixes.len():
                        accepted.push(fixes[j])
                        j = j + 1
                    return accepted
                case "q":
                    return accepted
                case "quit":
                    return accepted
                case _:
                    val _ = 0  # Skip

            i = i + 1

        accepted

# ============================================================================
# CLI Entry Point
# ============================================================================

async fn main() -> Int:
    val args = sys_get_args()

    if args.len() < 2:
        print("Usage: simple fix <file.spl> [options]")
        print("")
        print("Options:")
        print("  --dry-run         Show what would be fixed without applying")
        print("  --fix-all         Apply all fixes regardless of confidence")
        print("  --fix-interactive Prompt for each fix")
        print("  --fix-id=ID       Apply only fixes matching ID prefix")
        print("")
        print("Applies machine-applicable fixes from lint diagnostics.")
        return 1

    val file_path = args[1]
    val dry_run = args.contains("--dry-run") or args.contains("--fix-dry-run")
    val fix_all = args.contains("--fix-all")
    val fix_interactive = args.contains("--fix-interactive")

    var fix_id: Option<String> = None
    for arg in args:
        if arg.starts_with("--fix-id="):
            fix_id = Some(arg.slice(9))

    # Verify file exists
    if not native_fs_exists(file_path):
        print("Error: File not found: {file_path}")
        return 1

    # Read source
    val source_result = native_fs_read_string(file_path)
    match source_result:
        case Err(e):
            print("Error reading file: {e}")
            return 1
        case Ok(source):
            # Build source registry
            var sources: Dict<String, String> = {}
            sources[file_path] = source

            # Collect fixes from lint diagnostics
            # (In production, this would call the lint checker; here we demonstrate the structure)
            val fixes = collect_fixes_from_source(file_path, source)

            if fixes.is_empty():
                print("No fixes available for {file_path}")
                return 0

            # Filter fixes
            var filtered = fixes
            if not fix_all:
                filtered = FixApplicator.filter_by_confidence(filtered, FixConfidence.Safe)

            match fix_id:
                case Some(prefix):
                    filtered = FixApplicator.filter_by_id(filtered, prefix)
                case None:
                    val _ = 0

            if filtered.is_empty():
                print("No applicable fixes found.")
                return 0

            # Interactive mode
            if fix_interactive:
                filtered = InteractiveFix.prompt_fixes(filtered)
                if filtered.is_empty():
                    print("No fixes applied.")
                    return 0

            # Apply fixes
            val apply_result = FixApplicator.apply_to_disk(filtered, sources, dry_run)
            match apply_result:
                case Ok(report):
                    print(report.format(dry_run))
                    return 0
                case Err(e):
                    print("Error applying fixes: {e}")
                    return 1

    return 0

# Collect EasyFix instances from source analysis using shared rules
fn collect_fixes_from_source(file_path: String, source: String) -> List<EasyFix>:
    # Use shared rules module for all text-scanning rules
    var fixes = check_all_rules(source, file_path)

    # Also run the original todo_format check for backward compat
    val todo_fixes = _check_todo_format_legacy(file_path, source)
    for f in todo_fixes:
        fixes.push(f)

    fixes

fn _check_todo_format_legacy(file_path: String, source: String) -> List<EasyFix>:
    var fixes: List<EasyFix> = []
    val lines = source.split("\n")
    var line_num = 0
    var byte_offset = 0

    for line in lines:
        line_num = line_num + 1
        val trimmed = line.trim()

        # Check for TODO/FIXME without proper format
        if trimmed.starts_with("#"):
            val comment = trimmed.slice(1).trim()
            if comment.starts_with("TODO:") or comment.starts_with("FIXME:"):
                val keyword = if comment.starts_with("TODO:") then "TODO" else "FIXME"
                val after_colon = comment.slice(keyword.len() + 1).trim()

                if not after_colon.starts_with("["):
                    val keyword_pos = line.find(keyword)
                    val colon_pos = keyword_pos + keyword.len() + 1
                    val insert_pos = byte_offset + colon_pos + 1

                    var fix = EasyFix.create(
                        id: "L:todo_format:{line_num}",
                        description: "add [area][priority] format to {keyword} comment",
                        confidence: FixConfidence.Uncertain
                    )
                    fix.add_replacement(Replacement.create(
                        file: file_path,
                        start: insert_pos,
                        end: insert_pos,
                        line: line_num,
                        column: colon_pos + 2,
                        new_text: "[runtime][P2] "
                    ))
                    fixes.push(fix)

        byte_offset = byte_offset + line.len() + 1

    fixes
