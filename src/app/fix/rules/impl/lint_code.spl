# EasyFix Rules - Code Quality Lint Rules
#
# General code quality rules:
#   L:unnamed_duplicate_typed_args — Add distinct param names for duplicate types
#   L:resource_leak              — Wrap resource in `with` block
#   L:non_exhaustive_match       — Add missing match arms with todo()

use std.tooling.easy_fix.*
use super.super.helpers.*
use std.text.{NL}

# ============================================================================
# Rule 2: unnamed_duplicate_typed_args
# Detects fn signatures with duplicate types that lack distinct names.
# Confidence: Uncertain
# ============================================================================

fn check_unnamed_duplicate_typed_args(source: String, file: String) -> [EasyFix]:
    for_each_line(source, \ctx:
        var line_fixes: [EasyFix] = []

        # Simple heuristic: detect fn with params like (Int, Int) without names
        if (ctx.trimmed.starts_with("fn ") or ctx.trimmed.starts_with("me ") or ctx.trimmed.starts_with("static fn ")) and ctx.trimmed.contains("("):
            val paren_start = ctx.trimmed.find("(")
            val paren_end = ctx.trimmed.find(")")
            if paren_start >= 0 and paren_end > paren_start:
                val params_str = ctx.trimmed.slice(paren_start + 1, paren_end)
                val params = params_str.split(",")

                # Check if any param is just a type (no colon = no name)
                var type_only_params: [String] = []
                var has_unnamed = false
                for param in params:
                    val p = param.trim()
                    if p.len() > 0 and not p.contains(":"):
                        type_only_params.push(p)
                        has_unnamed = true

                # Check for duplicates among type-only params
                if has_unnamed and type_only_params.len() >= 2:
                    var seen: Dict<String, Int> = {}
                    var has_dup = false
                    for t in type_only_params:
                        if seen.contains_key(t):
                            has_dup = true
                        else:
                            seen[t] = 1

                    if has_dup:
                        # Build a replacement with named params
                        val abs_paren_start = ctx.byte_offset + ctx.indent + paren_start + 1
                        val abs_paren_end = ctx.byte_offset + ctx.indent + paren_end

                        var new_params: [String] = []
                        var counters: Dict<String, Int> = {}
                        for param in params:
                            val p = param.trim()
                            if p.len() > 0 and not p.contains(":"):
                                if not counters.contains_key(p):
                                    counters[p] = 0
                                counters[p] = counters[p] + 1
                                val name = "{p.lower()}{counters[p]}"
                                new_params.push("{name}: {p}")
                            else:
                                new_params.push(p)

                        val new_params_str = new_params.join(", ")

                        var fix = EasyFix.create(
                            id: "L:unnamed_duplicate_typed_args:{ctx.line_num}",
                            description: "add distinct parameter names for duplicate types",
                            confidence: FixConfidence.Uncertain
                        )
                        fix.add_replacement(Replacement.create(
                            file: file,
                            start: abs_paren_start,
                            end: abs_paren_end,
                            line: ctx.line_num,
                            column: paren_start + 2,
                            new_text: new_params_str
                        ))
                        line_fixes.push(fix)

        line_fixes
    )

# ============================================================================
# Rule 3: resource_leak
# Detects open()/connect() calls not wrapped in `with` blocks.
# Confidence: Uncertain
# ============================================================================

fn check_resource_leak(source: String, file: String) -> [EasyFix]:
    for_each_line(source, \ctx:
        var line_fixes: [EasyFix] = []

        # Detect val x = open(...) or val x = connect(...) not inside with
        val is_resource_open = ctx.trimmed.contains("= open(") or ctx.trimmed.contains("= connect(") or ctx.trimmed.contains("= File.open(")
        if is_resource_open and ctx.trimmed.starts_with("val ") and not ctx.trimmed.starts_with("with"):
            # Check previous lines for `with` block context (simple heuristic)

            # Extract variable name and expression
            val eq_pos = ctx.trimmed.find("=")
            if eq_pos > 4:
                val var_name = ctx.trimmed.slice(4, eq_pos).trim()
                val expr = ctx.trimmed.slice(eq_pos + 1).trim()

                val start = ctx.byte_offset + ctx.indent
                val end = ctx.byte_offset + ctx.line.len()

                val spaces = " ".repeat(ctx.indent)
                val inner_spaces = " ".repeat(ctx.indent + 4)
                val new_text = "{spaces}with {var_name} = {expr}:{NL}{inner_spaces}# TODO: use {var_name} here"

                var fix = EasyFix.create(
                    id: "L:resource_leak:{ctx.line_num}",
                    description: "wrap resource in `with` block to ensure cleanup",
                    confidence: FixConfidence.Uncertain
                )
                fix.add_replacement(Replacement.create(
                    file: file,
                    start: start,
                    end: end,
                    line: ctx.line_num,
                    column: ctx.indent + 1,
                    new_text: new_text
                ))
                line_fixes.push(fix)

        line_fixes
    )

# ============================================================================
# Rule 6: non_exhaustive_match
# Detects match blocks without a catch-all `case _:` arm.
# Confidence: Safe
# ============================================================================

fn check_non_exhaustive_match(source: String, file: String) -> [EasyFix]:
    var fixes: [EasyFix] = []
    val lines = source.split(NL)
    var line_num = 0
    var byte_offset = 0
    var in_match = false
    var match_indent = 0
    var has_catch_all = false
    var match_end_line = 0
    var match_end_offset = 0
    var last_case_indent = 0

    for line in lines:
        line_num = line_num + 1
        val trimmed = line.trim()
        val indent = line.len() - trimmed.len()

        if trimmed.starts_with("match ") and trimmed.ends_with(":"):
            # Start of match block
            if in_match and not has_catch_all:
                # Previous match was non-exhaustive — emit fix
                _emit_non_exhaustive_fix(fixes, file, match_end_line, match_end_offset, last_case_indent)
            in_match = true
            match_indent = indent
            has_catch_all = false
            match_end_line = line_num
            match_end_offset = byte_offset + line.len()

        if in_match and trimmed.starts_with("case "):
            last_case_indent = indent
            match_end_line = line_num
            match_end_offset = byte_offset + line.len()

            if trimmed.starts_with("case _:") or trimmed.starts_with("case _"):
                has_catch_all = true

        # Detect end of match block (dedent)
        if in_match and line.len() > 0 and indent <= match_indent and not trimmed.starts_with("match ") and not trimmed.starts_with("case "):
            if not has_catch_all:
                _emit_non_exhaustive_fix(fixes, file, match_end_line, match_end_offset, last_case_indent)
            in_match = false

        byte_offset = byte_offset + line.len() + 1

    # Handle match at end of file
    if in_match and not has_catch_all:
        _emit_non_exhaustive_fix(fixes, file, match_end_line, match_end_offset, last_case_indent)

    fixes

fn _emit_non_exhaustive_fix(fixes: [EasyFix], file: String, after_line: Int, after_offset: Int, case_indent: Int):
    val spaces = " ".repeat(case_indent)
    val inner_spaces = " ".repeat(case_indent + 4)
    val new_arm = "{NL}{spaces}case _:{NL}{inner_spaces}todo(\"handle remaining cases\")"
    var fix = EasyFix.create(
        id: "L:non_exhaustive_match:{after_line}",
        description: "add missing catch-all arm with todo()",
        confidence: FixConfidence.Safe
    )
    fix.add_replacement(Replacement.create(
        file: file,
        start: after_offset,
        end: after_offset,
        line: after_line,
        column: 1,
        new_text: new_arm
    ))
    fixes.push(fix)

export check_unnamed_duplicate_typed_args, check_resource_leak, check_non_exhaustive_match
