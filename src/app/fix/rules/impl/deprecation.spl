# EasyFix Rules - Deprecation Rules
#
# Rules that fix deprecated syntax:
#   L:deprecated_if_let          — Replace `if let` with `if val`
#   L:struct_construction_parens — Replace ClassName(field: val) with ClassName { field: val }

use std.tooling.easy_fix.*
use super.super.helpers.*

# ============================================================================
# Rule 10: deprecated_if_let
# Detects `if let`, `while let`, `elif let` and replaces `let` with `val`.
# Confidence: Safe
# ============================================================================

fn check_deprecated_if_let(source: String, file: String) -> [EasyFix]:
    for_each_line(source, \ctx:
        var line_fixes: [EasyFix] = []

        for keyword in ["if let ", "while let ", "elif let "]:
            val idx = ctx.trimmed.find(keyword)
            if idx.? :
                val pos = idx.unwrap()
                # Calculate byte position of "let" within the keyword match
                val keyword_prefix_len = keyword.len() - 4  # length before "let "
                val let_start = ctx.byte_offset + ctx.indent + pos + keyword_prefix_len
                val let_end = let_start + 3  # "let" is 3 chars

                var fix = EasyFix.create(
                    id: "L:deprecated_if_let:{ctx.line_num}",
                    description: "replace deprecated `let` with `val` in pattern binding",
                    confidence: FixConfidence.Safe
                )
                fix.add_replacement(Replacement.create(
                    file: file,
                    start: let_start,
                    end: let_end,
                    line: ctx.line_num,
                    column: ctx.indent + pos + keyword_prefix_len + 1,
                    new_text: "val"
                ))
                line_fixes.push(fix)

        line_fixes
    )

# ============================================================================
# Rule 11: struct_construction_parens
# Detects struct construction with parentheses ClassName(field: value)
# and converts to curly brace syntax ClassName { field: value }.
# Confidence: Likely
# ============================================================================

fn check_struct_construction_parens(source: String, file: String) -> [EasyFix]:
    """
    Detects patterns like ClassName(field: value, ...) and converts to
    ClassName { field: value, ... }.

    This fixes parse errors where struct construction with named parameters
    is mistaken for function calls.
    """
    for_each_line(source, \ctx:
        var line_fixes: [EasyFix] = []

        # Look for common struct construction patterns
        # These are capitalized identifiers followed by ( with : inside
        val common_structs = [
            "CatchAllPattern", "SourceLocation", "FileAnalysisResult",
            "ExhaustivenessValidator", "GenericTemplate", "ConcreteType",
            "TemplateInstantiator", "LineContext", "EasyFix", "Replacement",
            "MockResource", "TrackedMockResource", "MockContextManager",
            "CatchAllSeverity", "FixConfidence", "BuildConfig", "BuildProfile",
            "StageResult", "BootstrapStage", "BuildResult"
        ]

        for struct_name in common_structs:
            # Look for pattern: StructName(
            val pattern = "{struct_name}("
            val idx = ctx.line.find(pattern)

            if idx >= 0:
                # Found the pattern, now check if there's a : inside the parens
                val open_paren = idx + struct_name.len()

                # Find matching closing paren
                var depth = 0
                var close_paren = -1
                var pos = open_paren
                while pos < ctx.line.len():
                    val char = ctx.line.slice(pos, pos + 1)
                    if char == "(":
                        depth = depth + 1
                    if char == ")":
                        depth = depth - 1
                        if depth == 0:
                            close_paren = pos
                            break
                    pos = pos + 1

                if close_paren > open_paren:
                    # Extract the content between parens
                    val content = ctx.line.slice(open_paren + 1, close_paren)

                    # Check if there's a : indicating named parameters
                    # Skip :: (double colon for namespacing)
                    val has_colon = content.contains(": ") or (content.contains(":") and not content.contains("::"))

                    if has_colon:
                        # This looks like struct construction - create fix
                        var fix = EasyFix.create(
                            id: "L:struct_construction_parens:{ctx.line_num}:{open_paren}",
                            description: "replace `{struct_name}(...)` with `{struct_name} {{ ... }}` for struct construction",
                            confidence: FixConfidence.Likely
                        )

                        # Replace opening (
                        val open_byte = ctx.byte_offset + open_paren
                        fix.add_replacement(Replacement.create(
                            file: file,
                            start: open_byte,
                            end: open_byte + 1,
                            line: ctx.line_num,
                            column: open_paren + 1,
                            new_text: " {"
                        ))

                        # Replace closing )
                        val close_byte = ctx.byte_offset + close_paren
                        fix.add_replacement(Replacement.create(
                            file: file,
                            start: close_byte,
                            end: close_byte + 1,
                            line: ctx.line_num,
                            column: close_paren + 1,
                            new_text: "}"
                        ))

                        line_fixes.push(fix)

        line_fixes
    )

export check_deprecated_if_let, check_struct_construction_parens
