# EasyFix Rules - Helper Functions
# Shared utilities for rule implementations.

use std.tooling.easy_fix.*
use std.text.{NL}

# ============================================================================
# Helper: Line Iteration with Context
# ============================================================================

struct LineContext:
    """Context information for processing a source line."""
    line: text
    line_num: i64
    byte_offset: i64
    trimmed: text
    indent: i64

fn for_each_line(source: text, callback: fn(LineContext) -> [EasyFix]) -> [EasyFix]:
    """
    Iterate over source lines and collect fixes from callback.

    Handles the common pattern of splitting source, tracking line numbers/offsets,
    and collecting fixes. Reduces duplication in rule implementations.
    """
    val lines = source.split(NL)
    var line_num = 0
    var byte_offset = 0
    var all_fixes: [EasyFix] = []

    for line in lines:
        line_num = line_num + 1
        val trimmed = line.trim()
        val indent = line.len() - trimmed.len()

        val context = LineContext(
            line: line,
            line_num: line_num,
            byte_offset: byte_offset,
            trimmed: trimmed,
            indent: indent
        )

        val line_fixes = callback(context)
        all_fixes = all_fixes.concat(line_fixes)

        byte_offset = byte_offset + line.len() + 1

    all_fixes

# ============================================================================
# Helper: compute byte offset for a given line/column (1-based)
# ============================================================================

fn byte_offset_of(source: String, target_line: Int, target_col: Int) -> Int:
    val lines = source.split(NL)
    var offset = 0
    var line_num = 1
    for line in lines:
        if line_num == target_line:
            return offset + target_col - 1
        offset = offset + line.len() + 1  # +1 for \n
        line_num = line_num + 1
    offset

fn line_start_offset(source: String, target_line: Int) -> Int:
    byte_offset_of(source, target_line, 1)

fn line_end_offset(source: String, target_line: Int) -> Int:
    val lines = source.split(NL)
    var offset = 0
    var line_num = 1
    for line in lines:
        if line_num == target_line:
            return offset + line.len()
        offset = offset + line.len() + 1
        line_num = line_num + 1
    offset

# ============================================================================
# Helper: Levenshtein distance for typo suggestions
# ============================================================================

fn levenshtein(a: String, b: String) -> Int:
    val m = a.len()
    val n = b.len()
    if m == 0:
        return n
    if n == 0:
        return m

    # Use single-row DP
    var prev: [Int] = []
    var i = 0
    while i <= n:
        prev.push(i)
        i = i + 1

    i = 1
    while i <= m:
        var curr: [Int] = [i]
        var j = 1
        while j <= n:
            val cost = if a[i - 1] == b[j - 1] then 0 else 1
            val del = prev[j] + 1
            val ins = curr[j - 1] + 1
            val sub = prev[j - 1] + cost
            var min_val = del
            if ins < min_val:
                min_val = ins
            if sub < min_val:
                min_val = sub
            curr.push(min_val)
            j = j + 1
        prev = curr
        i = i + 1

    prev[n]
