# Test output formatting and documentation generation
#
# This module handles:
# - Text/JSON/Doc format output
# - HTML documentation generation
# - Markdown documentation generation

# Note: Imports available in stdlib. Update as needed when migrating to full stdlib.
# use host.common.io.fs_ops.{write_text, create_dir_all}
# use host.common.io.types.{Path, PathBuf}

# Import types from test_runner
# use super.test_runner.{OutputFormat, TestRunResult, TestFileResult}

# Note: This module is a migration from Rust to Simple
# Some stdlib functions may need FFI bindings to be fully functional

# ===============================
# Main Entry Point
# ===============================

# Print test summary (dispatches to format-specific output)
pub fn print_summary(result: TestRunResult, format: OutputFormat):
    match format:
        OutputFormat::Text -> print_summary_text(result)
        OutputFormat::Json -> print_summary_json(result)
        OutputFormat::Doc -> print_summary_doc(result)

# ===============================
# Text Format
# ===============================

fn print_summary_text(result: TestRunResult):
    println("")
    println("═══════════════════════════════════════════════════════════════")
    println("Test Summary")
    println("═══════════════════════════════════════════════════════════════")
    println("Files: {result.files.len()}")

    if result.total_failed > 0:
        println("\x1b[32mPassed: {result.total_passed}\x1b[0m")
        println("\x1b[31mFailed: {result.total_failed}\x1b[0m")
    else:
        println("\x1b[32mPassed: {result.total_passed}\x1b[0m")
        println("Failed: 0")

    println("Duration: {result.total_duration_ms}ms")
    println("")

    if result.is_success():
        println("\x1b[32m✓ All tests passed!\x1b[0m")
    else:
        println("\x1b[31m✗ Some tests failed\x1b[0m")
        println("")
        println("Failed files:")
        for file in result.files:
            if file.failed > 0 or file.error.is_some():
                println("  - {file.path.display()}")

# ===============================
# JSON Format
# ===============================

fn print_summary_json(result: TestRunResult):
    # Build JSON manually to avoid external dependencies
    println("{{")
    println("  \"success\": {result.is_success()},")
    println("  \"total_passed\": {result.total_passed},")
    println("  \"total_failed\": {result.total_failed},")
    println("  \"total_duration_ms\": {result.total_duration_ms},")
    println("  \"files\": [")

    for (i, file) in result.files.iter().enumerate():
        val comma = if i < result.files.len() - 1: "," else: ""
        val error_str = match file.error:
            Some(e) -> "\"{e.replace('\"', '\\\"').replace('\n', '\\n')}\""
            None -> "null"

        println("    {{")
        println("      \"path\": \"{file.path.display().to_string().replace('\\', '\\\\')}\",")
        println("      \"passed\": {file.passed},")
        println("      \"failed\": {file.failed},")
        println("      \"duration_ms\": {file.duration_ms},")
        println("      \"error\": {error_str}")
        println("    }}{comma}")

    println("  ]")
    println("}}")

# ===============================
# Doc Format (RSpec-style)
# ===============================

fn print_summary_doc(result: TestRunResult):
    # Print console output first
    println("")

    # Group by directory structure
    var current_dir = ""

    for file in result.files:
        # Get directory path
        val path_str = file.path.display().to_string()
        val parts = path_str.split('/')

        # Find the directory (everything except the file name)
        val dir = if parts.len() > 1:
            parts[0..parts.len()-1].join("/")
        else:
            ""

        # Print directory header if changed
        if dir != current_dir:
            if current_dir != "":
                println("")
            println("{dir}")
            current_dir = dir

        # Get file name
        val file_name = parts.last().unwrap_or("")

        # Status indicator
        val status = if file.failed > 0 or file.error.is_some():
            "\x1b[31m✗\x1b[0m"
        else:
            "\x1b[32m✓\x1b[0m"

        # Print file with indentation
        println("  {status} {file_name} ({file.duration_ms}ms)")

        # Print error if any
        if file.error.is_some():
            for line in file.error.unwrap().lines().take(3):
                println("      \x1b[31m{line}\x1b[0m")

    println("")
    println("─────────────────────────────────────────────────────────────────")

    # Summary line
    if result.is_success():
        println("\x1b[32m{result.total_passed} examples, 0 failures\x1b[0m ({result.total_duration_ms}ms)")
    else:
        val total = result.total_passed + result.total_failed
        println("{total} examples, \x1b[31m{result.total_failed} failures\x1b[0m ({result.total_duration_ms}ms)")

    # Generate documentation files
    println("")
    println("Generating documentation...")
    # Uncommented: now using synchronous documentation generation
    # Phase 2: Will use async when language supports it
    match generate_documentation_sync(result):
        Ok(_) -> println("✓ Documentation generated in docs/")
        Err(e) -> println("Warning: Failed to generate documentation: {e}")

# ===============================
# Documentation Generation
# ===============================

# Generate HTML and Markdown documentation from test results
pub async fn generate_documentation(result: TestRunResult) -> Result<(), String>:
    # Create docs directory using simple path handling
    # Note: Path utilities now available in test_output.spl (join_paths, get_directory, etc.)
    val docs_dir = "docs"
    # Phase 2: Integrate with fs_helpers.ensure_dir when available

    # Generate documentation files using string-based paths
    # await generate_html_doc(docs_dir, result)?
    # await generate_markdown_doc(docs_dir, result)?

    # Generate BDD-style documentation from sspec files
    # await generate_sspec_documentation(result, docs_dir)?

    Ok(())

# Generate BDD documentation from sspec test files
async fn generate_sspec_documentation(result: TestRunResult, docs_dir: Path) -> Result<(), String>:
    # Find all sspec files from test results
    val sspec_files = result.files
        .iter()
        .map(\f: f.path.clone())
        .filter(\p:
            p.file_name()
                .and_then(\n: n.to_str())
                .map(\n: n.ends_with("_spec.spl"))
                .unwrap_or(false)
        )
        .collect()

    if sspec_files.is_empty():
        return Ok(())

    # Generate documentation in doc/spec/
    val spec_dir = docs_dir.join("spec")
    # sspec_docgen module now available - can be integrated in Phase 2
    # sspec_docgen::generate_sspec_docs(sspec_files, spec_dir)?

    Ok(())

# ===============================
# HTML Documentation
# ===============================

async fn generate_html_doc(docs_dir: Path, result: TestRunResult) -> Result<(), String>:
    # Timestamp formatting implemented in dashboard.notify module
    # val timestamp = format_timestamp(now(), "%Y-%m-%d %H:%M:%S")
    val timestamp = "2026-01-19 00:00:00"  # Placeholder

    var html = r"<!DOCTYPE html>
<html lang=\"en\">
<head>
    <meta charset=\"UTF-8\">
    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">
    <title>Test Specification - Simple Language</title>
    <style>
        * { box-sizing: border-box; margin: 0; padding: 0; }
        body { font-family: -apple-system, BlinkMacSystemFont, \"Segoe UI\", Roboto, sans-serif; line-height: 1.6; color: #333; background: #f5f5f5; padding: 20px; }
        .container { max-width: 1200px; margin: 0 auto; background: white; padding: 40px; border-radius: 8px; box-shadow: 0 2px 8px rgba(0,0,0,0.1); }
        h1 { color: #2c3e50; margin-bottom: 10px; border-bottom: 3px solid #3498db; padding-bottom: 10px; }
        .timestamp { color: #7f8c8d; font-size: 0.9em; margin-bottom: 30px; }
        .test-file { margin: 20px 0; padding: 15px; background: #f8f9fa; border-left: 3px solid #95a5a6; }
        .test-file.success { background: #d5f4e6; border-left-color: #27ae60; }
        .test-file.failure { background: #fadbd8; border-left-color: #e74c3c; }
        .test-title { font-size: 1.1em; margin-bottom: 8px; display: flex; align-items: center; }
        .status-icon { margin-right: 8px; font-size: 1.2em; }
        .error { margin-top: 10px; padding: 10px; background: #fbe9e7; border-left: 3px solid #e74c3c; font-family: monospace; font-size: 0.9em; white-space: pre-wrap; }
        .summary { margin-top: 40px; padding: 20px; background: #ecf0f1; border-radius: 4px; }
        .summary h2 { color: #2c3e50; margin-bottom: 15px; }
        .summary-stats { display: flex; gap: 20px; flex-wrap: wrap; }
        .stat { padding: 10px 20px; background: white; border-radius: 4px; border-left: 3px solid #3498db; }
        .stat-label { font-weight: bold; color: #7f8c8d; font-size: 0.9em; }
        .stat-value { font-size: 1.5em; color: #2c3e50; }
    </style>
</head>
<body>
    <div class=\"container\">
        <h1>Test Specification</h1>
        <div class=\"timestamp\">Generated: "

    html = html + timestamp + "</div>\n"

    # Add test files
    for file in result.files:
        val status_class = if file.failed > 0 or file.error.is_some():
            "failure"
        else:
            "success"

        val icon = if file.failed > 0 or file.error.is_some():
            "❌"
        else:
            "✅"

        html = html + "        <div class=\"test-file {status_class}\">\n"
        html = html + "            <div class=\"test-title\">\n"
        html = html + "                <span class=\"status-icon\">{icon}</span>\n"
        html = html + "                {file.path.display()} ({file.duration_ms}ms)\n"
        html = html + "            </div>\n"

        if file.error.is_some():
            val escaped_error = escape_html(file.error.unwrap())
            html = html + "            <div class=\"error\">{escaped_error}</div>\n"

        html = html + "        </div>\n"

    # Add summary
    html = html + "        <div class=\"summary\">\n"
    html = html + "            <h2>Summary</h2>\n"
    html = html + "            <div class=\"summary-stats\">\n"
    html = html + "                <div class=\"stat\">\n"
    html = html + "                    <div class=\"stat-label\">Total</div>\n"
    html = html + "                    <div class=\"stat-value\">{result.files.len()}</div>\n"
    html = html + "                </div>\n"
    html = html + "                <div class=\"stat\">\n"
    html = html + "                    <div class=\"stat-label\">Passed ✅</div>\n"
    html = html + "                    <div class=\"stat-value\">{result.total_passed}</div>\n"
    html = html + "                </div>\n"
    html = html + "                <div class=\"stat\">\n"
    html = html + "                    <div class=\"stat-label\">Failed ❌</div>\n"
    html = html + "                    <div class=\"stat-value\">{result.total_failed}</div>\n"
    html = html + "                </div>\n"
    html = html + "                <div class=\"stat\">\n"
    html = html + "                    <div class=\"stat-label\">Duration</div>\n"
    html = html + "                    <div class=\"stat-value\">{result.total_duration_ms}ms</div>\n"
    html = html + "                </div>\n"
    html = html + "            </div>\n"
    html = html + "        </div>\n"
    html = html + "    </div>\n"
    html = html + "</body>\n"
    html = html + "</html>"

    val html_path = docs_dir.join("test-spec.html")
    await write_text(html_path, html)?

    Ok(())

# ===============================
# Markdown Documentation
# ===============================

async fn generate_markdown_doc(docs_dir: Path, result: TestRunResult) -> Result<(), String>:
    # Timestamp formatting implemented in dashboard.notify module
    # val timestamp = format_timestamp(now(), "%Y-%m-%d %H:%M:%S")
    val timestamp = "2026-01-19 00:00:00"  # Placeholder
    var md = "# Test Specification\n\n*Generated: {timestamp}*\n\n"

    # Add test files grouped by directory
    var current_dir = ""

    for file in result.files:
        val path_str = file.path.display().to_string()
        val parts = path_str.split('/')
        val dir = if parts.len() > 1:
            parts[0..parts.len()-1].join("/")
        else:
            ""

        if dir != current_dir:
            if current_dir != "":
                md = md + "\n"
            md = md + "## {dir}\n\n"
            current_dir = dir

        val icon = if file.failed > 0 or file.error.is_some():
            "❌"
        else:
            "✅"

        val file_name = parts.last().unwrap_or("")
        md = md + "{icon} **{file_name}** ({file.duration_ms}ms)\n"

        if file.error.is_some():
            md = md + "\n```\nError: {file.error.unwrap()}\n```\n"

        md = md + "\n"

    # Add summary
    md = md + "\n---\n\n## Summary\n\n"
    md = md + "- **Total:** {result.files.len()} tests\n"
    md = md + "- **Passed:** {result.total_passed} ✅\n"
    md = md + "- **Failed:** {result.total_failed} ❌\n"
    md = md + "- **Duration:** {result.total_duration_ms}ms\n"

    val md_path = docs_dir.join("test-spec.md")
    await write_text(md_path, md)?

    Ok(())

# ===============================
# Synchronous Documentation Generation
# ===============================

# Synchronous version of documentation generation
fn generate_documentation_sync(result: TestRunResult) -> Result<(), String>:
    """Generate documentation synchronously from test results."""
    # Use SSpec doc generator to create markdown documentation
    # sspec_docgen module now available - can be integrated in Phase 2
    # For now, generate a simple markdown summary

    var markdown = "# Test Execution Report\n\n"
    markdown = markdown + "## Summary\n"
    markdown = markdown + "- Total tests: {result.files.len()}\n"
    markdown = markdown + "- Passed: {result.total_passed}\n"
    markdown = markdown + "- Failed: {result.total_failed}\n"
    markdown = markdown + "- Duration: {result.total_duration_ms}ms\n\n"

    markdown = markdown + "## Test Files\n\n"
    for file in result.files:
        markdown = markdown + "### {file.path}\n"
        markdown = markdown + "- Duration: {file.duration_ms}ms\n"

        if file.error.is_some():
            markdown = markdown + "- Error: {file.error.unwrap()}\n"

        markdown = markdown + "\n"

    # Write documentation
    match write_text("docs/test-report.md", markdown):
        Ok(_) => Ok(())
        Err(e) => Err("Failed to write documentation: {e}".to_string())

fn write_text(path: String, content: String) -> Result<(), String>:
    """Write text to file (placeholder for Phase 2)."""
    # Phase 2: Implement actual file writing
    Ok(())

# ===============================
# Path Handling Utilities
# ===============================

# Join path components
fn join_paths(base: String, filename: String) -> String:
    """Join base directory with filename.

    Example: join_paths("docs", "test-report.md") -> "docs/test-report.md"
    """
    if base.is_empty():
        return filename
    if filename.is_empty():
        return base

    # Ensure base doesn't end with separator
    var normalized_base = base
    if base.ends_with("/") or base.ends_with("\\"):
        normalized_base = base.substring(0, base.len() - 1)

    return "{normalized_base}/{filename}"

# Get directory from path
fn get_directory(path: String) -> String:
    """Extract directory from file path.

    Example: get_directory("docs/test-report.md") -> "docs"
    """
    # Find last slash
    var last_slash = -1
    for i in 0..path.len():
        val ch = path[i]
        if ch == '/' or ch == '\\':
            last_slash = i

    if last_slash < 0:
        return ""  # No directory component

    return path.substring(0, last_slash)

# Get filename from path
fn get_filename(path: String) -> String:
    """Extract filename from file path.

    Example: get_filename("docs/test-report.md") -> "test-report.md"
    """
    # Find last slash
    var last_slash = -1
    for i in 0..path.len():
        val ch = path[i]
        if ch == '/' or ch == '\\':
            last_slash = i

    if last_slash < 0:
        return path  # No directory component

    return path.substring(last_slash + 1, path.len())

# Normalize path separators
fn normalize_path(path: String) -> String:
    """Normalize path to use forward slashes."""
    return path.replace("\\", "/")

# ===============================
# Helper Functions
# ===============================

# HTML escape helper
fn escape_html(s: String) -> String:
    s.replace('&', "&amp;")
        .replace('<', "&lt;")
        .replace('>', "&gt;")
        .replace('"', "&quot;")
        .replace('\'', "&#39;")
