///
Simple Build System

Self-hosted build script for Simple development tools.
Reads configuration from simple.sdn and builds all targets.

Usage:
    simple build.spl                  # Build all targets
    simple build.spl --target=fmt     # Build specific target
    simple build.spl --clean          # Clean build artifacts
    simple build.spl --watch          # Watch and rebuild on changes
///

use std.io
use std.fs
use std.process
use std.args
use std.time
use sdn.document.SdnDocument

fn main():
    io.println("=== Simple Build System ===")
    io.println("")

    # Parse command-line arguments
    val argv = args.get_args()
    val config = parse_args(argv)

    # Load project configuration
    val project_config = load_config("simple.sdn")

    match config.mode:
        case BuildMode.Clean:
            clean_build(project_config)
        case BuildMode.BuildAll:
            build_all(project_config)
        case BuildMode.BuildTarget(target):
            build_target(project_config, target)
        case BuildMode.Watch:
            watch_and_build(project_config)

enum BuildMode:
    Clean
    BuildAll
    BuildTarget(String)
    Watch

struct BuildConfig:
    mode: BuildMode
    verbose: Bool
    parallel: Bool

struct ProjectConfig:
    name: String
    targets: Dict<String, TargetConfig>
    build: BuildSettings
    paths: PathConfig

struct TargetConfig:
    source: String
    output: String
    build_dir: String
    type: String
    description: String

struct BuildSettings:
    parallel: Bool
    max_jobs: Int
    incremental: Bool

struct PathConfig:
    bin: String
    build: String
    source: String

### Command-line argument parsing

fn parse_args(argv: [String]) -> BuildConfig:
    var mode = BuildMode.BuildAll
    var verbose = false
    var parallel = true

    for arg in argv[1..]:
        match arg:
            case "--clean":
                mode = BuildMode.Clean
            case "--watch":
                mode = BuildMode.Watch
            case "--verbose":
                verbose = true
            case "--no-parallel":
                parallel = false
            case arg if arg.starts_with("--target="):
                val target = arg.split("=")[1]
                mode = BuildMode.BuildTarget(target)
            case "--help":
                print_help()
                process.exit(0)
            case _:
                io.eprintln("Unknown argument: ${arg}")
                print_help()
                process.exit(1)

    return BuildConfig(mode: mode, verbose: verbose, parallel: parallel)

fn print_help():
    io.println("Simple Build System")
    io.println("")
    io.println("USAGE:")
    io.println("    simple build.spl [OPTIONS]")
    io.println("")
    io.println("OPTIONS:")
    io.println("    --clean              Clean build artifacts")
    io.println("    --target=<name>      Build specific target (fmt, lint, sdn, lsp, dap)")
    io.println("    --watch              Watch files and rebuild on changes")
    io.println("    --verbose            Verbose output")
    io.println("    --no-parallel        Disable parallel builds")
    io.println("    --help               Print this help message")
    io.println("")
    io.println("EXAMPLES:")
    io.println("    simple build.spl                  # Build all targets")
    io.println("    simple build.spl --target=fmt     # Build formatter only")
    io.println("    simple build.spl --clean          # Clean build artifacts")
    io.println("    simple build.spl --watch          # Watch and auto-rebuild")

### Configuration loading

fn load_config(path: String) -> ProjectConfig:
    """Load project configuration from simple.sdn"""
    io.println("Loading configuration from ${path}...")

    match SdnDocument.from_file(path):
        case Ok(doc):
            # Extract project info
            val name = doc.get("project.name")
                .flatmap(|v| v.as_str())
                .unwrap_or("Simple")

            # Extract targets
            var targets = {}
            val target_names = ["formatter", "linter", "sdn", "lsp", "dap"]

            for target_name in target_names:
                val source = doc.get("targets.${target_name}.source")
                    .flatmap(|v| v.as_str())
                    .unwrap_or("")

                val output = doc.get("targets.${target_name}.output")
                    .flatmap(|v| v.as_str())
                    .unwrap_or("")

                val build_dir = doc.get("targets.${target_name}.build_dir")
                    .flatmap(|v| v.as_str())
                    .unwrap_or("")

                val target_type = doc.get("targets.${target_name}.type")
                    .flatmap(|v| v.as_str())
                    .unwrap_or("executable")

                val description = doc.get("targets.${target_name}.description")
                    .flatmap(|v| v.as_str())
                    .unwrap_or("")

                targets[target_name] = TargetConfig(
                    source: source,
                    output: output,
                    build_dir: build_dir,
                    type: target_type,
                    description: description
                )

            # Extract build settings
            val parallel = doc.get("build.parallel")
                .flatmap(|v| v.as_bool())
                .unwrap_or(true)

            val max_jobs = doc.get("build.max_jobs")
                .flatmap(|v| v.as_i64())
                .unwrap_or(4)

            val incremental = doc.get("build.incremental")
                .flatmap(|v| v.as_bool())
                .unwrap_or(true)

            val build = BuildSettings(
                parallel: parallel,
                max_jobs: max_jobs,
                incremental: incremental
            )

            # Extract paths
            val bin = doc.get("paths.bin")
                .flatmap(|v| v.as_str())
                .unwrap_or("simple/bin_simple")

            val build_path = doc.get("paths.build")
                .flatmap(|v| v.as_str())
                .unwrap_or("simple/build")

            val source = doc.get("paths.source")
                .flatmap(|v| v.as_str())
                .unwrap_or("simple/app")

            val paths = PathConfig(
                bin: bin,
                build: build_path,
                source: source
            )

            return ProjectConfig(
                name: name,
                targets: targets,
                build: build,
                paths: paths
            )

        case Err(e):
            io.eprintln("Failed to load config: ${e}")
            process.exit(1)

### Build operations

fn build_all(config: ProjectConfig):
    """Build all targets"""
    io.println("Building all targets...")
    io.println("")

    # Create output directories
    create_build_dirs(config)

    # Build each target
    val target_order = ["formatter", "linter", "sdn", "lsp", "dap"]

    for target_name in target_order:
        match config.targets.get(target_name):
            case Some(target):
                build_target_impl(target_name, target)
            case nil:
                io.println("⚠ Target ${target_name} not found in config")

    io.println("")
    io.println("=== Build Complete ===")
    print_summary(config)

fn build_target(config: ProjectConfig, target_name: String):
    """Build specific target"""
    io.println("Building target: ${target_name}...")
    io.println("")

    create_build_dirs(config)

    match config.targets.get(target_name):
        case Some(target):
            build_target_impl(target_name, target)
            io.println("")
            io.println("=== Build Complete ===")
        case nil:
            io.eprintln("Error: Target '${target_name}' not found")
            io.eprintln("")
            io.eprintln("Available targets: formatter, linter, sdn, lsp, dap")
            process.exit(1)

fn build_target_impl(name: String, target: TargetConfig):
    """Build a single target"""
    io.println("Building ${name}...")
    io.println("  Source: ${target.source}")
    io.println("  Output: ${target.output}")

    # Find compiler
    val compiler = find_compiler()

    match compiler:
        case Some(compiler_path):
            # Build command
            val result = process.run_command(
                compiler_path,
                [
                    "compile",
                    target.source,
                    "--output",
                    target.output,
                    "--build-dir",
                    target.build_dir
                ]
            )

            match result:
                case Ok(output):
                    if output.exit_code == 0:
                        io.println("✓ ${name} built successfully: ${target.output}")
                    else:
                        io.eprintln("✗ ${name} build failed:")
                        io.eprintln(output.stderr)
                        process.exit(1)
                case Err(e):
                    io.eprintln("✗ Failed to run compiler: ${e}")
                    process.exit(1)
        case nil:
            io.eprintln("Error: Simple compiler not found")
            io.eprintln("Please build the compiler first: cargo build")
            process.exit(1)

fn clean_build(config: ProjectConfig):
    """Clean build artifacts"""
    io.println("Cleaning build artifacts...")

    # Remove build directory
    if fs.exists(config.paths.build):
        match fs.remove_dir_all(config.paths.build):
            case Ok(_):
                io.println("✓ Removed ${config.paths.build}")
            case Err(e):
                io.eprintln("Failed to remove build dir: ${e}")

    # Remove binaries
    if fs.exists(config.paths.bin):
        match fs.remove_dir_all(config.paths.bin):
            case Ok(_):
                io.println("✓ Removed ${config.paths.bin}")
            case Err(e):
                io.eprintln("Failed to remove bin dir: ${e}")

    io.println("")
    io.println("=== Clean Complete ===")

# Track file modification times for watching
var watched_file_mtimes: Dict<String, Int> = {}
var last_build_time: Int = 0

fn watch_and_build(config: ProjectConfig):
    """Watch files and rebuild on changes using mtime polling."""
    io.println("Watch mode enabled")
    io.println("Watching for changes in ${config.paths.source}...")
    io.println("")

    # Initial build
    build_all(config)
    last_build_time = time.now_ms()

    # Initialize file mtimes
    initialize_file_watching(config)

    io.println("")
    io.println("Watching for changes... (Press Ctrl+C to exit)")

    val debounce_ms = 500  # Debounce delay

    loop:
        # Sleep to avoid busy-waiting
        process.sleep(100)

        # Check for file changes
        val changed_files = check_file_changes(config)

        if changed_files.len() > 0:
            val current_time = time.now_ms()

            # Debounce: only rebuild if enough time has passed
            if current_time - last_build_time > debounce_ms:
                io.println("")
                io.println("Changes detected:")
                for file_path in changed_files:
                    io.println("  - ${file_path}")
                io.println("")

                # Determine which targets need rebuilding
                val targets_to_build = get_affected_targets(config, changed_files)

                if targets_to_build.len() > 0:
                    io.println("Rebuilding affected targets...")
                    for target_name in targets_to_build:
                        match config.targets.get(target_name):
                            case Some(target):
                                build_target_impl(target_name, target)
                            case nil:
                                pass
                else:
                    # Rebuild all if can't determine affected targets
                    build_all(config)

                last_build_time = time.now_ms()
                io.println("")
                io.println("Watching for changes... (Press Ctrl+C to exit)")

fn initialize_file_watching(config: ProjectConfig):
    """Initialize file modification time tracking."""
    use shell

    # Find all .spl files in source directory
    val source_files = shell.file.find(config.paths.source, "*.spl", recursive: true)

    for file_path in source_files:
        watched_file_mtimes[file_path] = get_file_modification_time(file_path)

    io.println("  Watching ${source_files.len()} source files")

fn check_file_changes(config: ProjectConfig) -> [String]:
    """Check for changed files and return list of changed paths."""
    use shell
    var changed: [String] = []

    # Find all .spl files in source directory
    val source_files = shell.file.find(config.paths.source, "*.spl", recursive: true)

    for file_path in source_files:
        val current_mtime = get_file_modification_time(file_path)

        match watched_file_mtimes.get(file_path):
            case Some(old_mtime):
                if current_mtime > old_mtime:
                    changed.push(file_path)
                    watched_file_mtimes[file_path] = current_mtime
            case nil:
                # New file
                watched_file_mtimes[file_path] = current_mtime
                changed.push(file_path)

    return changed

fn get_file_modification_time(path: String) -> Int:
    """Get file modification time in milliseconds."""
    match fs.stat(path):
        case Ok(stat_info):
            return stat_info.mtime_ms
        case Err(_):
            return 0

fn get_affected_targets(config: ProjectConfig, changed_files: [String]) -> [String]:
    """Determine which targets are affected by changed files."""
    var affected: [String] = []

    for (target_name, target) in config.targets.items():
        # Check if any changed file is in this target's source
        for changed_path in changed_files:
            if changed_path.starts_with(target.source) or
               target.source.contains(changed_path):
                if not affected.contains(target_name):
                    affected.push(target_name)
                break

    return affected

### Helper functions

fn create_build_dirs(config: ProjectConfig):
    """Create build directories"""
    fs.create_dir_all(config.paths.bin)
    fs.create_dir_all(config.paths.build)

    for (name, target) in config.targets.items():
        fs.create_dir_all(target.build_dir)

fn find_compiler() -> Option<String>:
    """Find Simple compiler binary"""
    val candidates = [
        "target/debug/simple",
        "./target/debug/simple",
        "simple/bin/simple"
    ]

    for path in candidates:
        if fs.exists(path):
            return Some(path)

    return nil

fn print_summary(config: ProjectConfig):
    """Print build summary"""
    io.println("")
    io.println("Built executables:")

    for (name, target) in config.targets.items():
        io.println("  ${target.output} - ${target.description}")

    io.println("")
    io.println("Usage:")
    io.println("  Formatter:  ${config.paths.bin}/simple_fmt <file.spl> [--check|--write]")
    io.println("  Linter:     ${config.paths.bin}/simple_lint <file.spl> [--deny-all]")
    io.println("  SDN CLI:    ${config.paths.bin}/simple_sdn <command> <args>")
    io.println("  LSP Server: ${config.paths.bin}/simple_lsp")
    io.println("  DAP Server: ${config.paths.bin}/simple_dap")
