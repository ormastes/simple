# Core Simple — Recursive Descent Parser
#
# Shared core library: parses tokens into an AST stored in the arena.
# Handles function/struct/enum declarations, val/var bindings, use/export,
# expressions, statements, and indentation-based blocks.
#
# Design: All state in module-level vars. Functions modify state.
# Works when compiled to C; NOT in the interpreter (closure bug).

use compiler.core.tokens.{tok_kind_name, tok_precedence, tok_is_right_assoc}
use compiler.core.tokens.{TOK_INT_LIT, TOK_FLOAT_LIT, TOK_STRING_LIT}
use compiler.core.tokens.{TOK_BOOL_LIT, TOK_NIL_LIT, TOK_IDENT}
use compiler.core.tokens.{TOK_KW_FN, TOK_KW_VAL, TOK_KW_VAR}
use compiler.core.tokens.{TOK_KW_IF, TOK_KW_ELIF, TOK_KW_ELSE}
use compiler.core.tokens.{TOK_KW_FOR, TOK_KW_WHILE, TOK_KW_IN}
use compiler.core.tokens.{TOK_KW_MATCH, TOK_KW_CASE}
use compiler.core.tokens.{TOK_KW_RETURN, TOK_KW_BREAK, TOK_KW_CONTINUE}
use compiler.core.tokens.{TOK_KW_STRUCT, TOK_KW_ENUM}
use compiler.core.tokens.{TOK_KW_EXTERN, TOK_KW_USE, TOK_KW_EXPORT, TOK_KW_IMPORT, TOK_KW_TRAIT}
use compiler.core.tokens.{TOK_KW_TYPE, TOK_KW_ASM}
use compiler.core.tokens.{TOK_KW_AND, TOK_KW_OR, TOK_KW_NOT}
use compiler.core.tokens.{TOK_KW_TRUE, TOK_KW_FALSE, TOK_KW_NIL}
use compiler.core.tokens.{TOK_KW_PASS, TOK_KW_PASS_TODO, TOK_KW_PASS_DO_NOTHING, TOK_KW_PASS_DN, TOK_KW_IS}
use compiler.core.tokens.{TOK_KW_SELF, TOK_KW_CLASS, TOK_KW_IMPL, TOK_KW_STATIC, TOK_KW_ME}
use compiler.core.tokens.{TOK_KW_ASYNC, TOK_KW_AWAIT, TOK_KW_YIELD, TOK_KW_SPAWN}
use compiler.core.tokens.{TOK_PLUS, TOK_MINUS, TOK_STAR, TOK_SLASH, TOK_PERCENT}
use compiler.core.tokens.{TOK_EQ, TOK_NEQ, TOK_LT, TOK_GT, TOK_LEQ, TOK_GEQ, TOK_LT_GENERIC}
use compiler.core.tokens.{TOK_ASSIGN, TOK_PLUS_ASSIGN, TOK_MINUS_ASSIGN, TOK_WALRUS}
use compiler.core.tokens.{TOK_STAR_ASSIGN, TOK_SLASH_ASSIGN}
use compiler.core.tokens.{TOK_AND, TOK_OR, TOK_NOT}
use compiler.core.tokens.{TOK_LPAREN, TOK_RPAREN, TOK_LBRACKET, TOK_RBRACKET}
use compiler.core.tokens.{TOK_LBRACE, TOK_RBRACE}
use compiler.core.tokens.{TOK_COLON, TOK_COMMA, TOK_DOT, TOK_DOTDOT}
use compiler.core.tokens.{TOK_ARROW, TOK_PIPE}
use compiler.core.tokens.{TOK_QUESTION, TOK_QUESTION_DOT, TOK_DOUBLE_QUESTION}
use compiler.core.tokens.{TOK_NEWLINE, TOK_INDENT, TOK_DEDENT, TOK_EOF, TOK_ERROR}
use compiler.core.tokens.{TOK_DOTDOT_EQ, TOK_DOUBLE_STAR, TOK_UNDERSCORE}
use compiler.core.tokens.{TOK_PIPE_FORWARD, TOK_SEMICOLON}
use compiler.core.tokens.{TOK_SUFFIXED_INT, TOK_SUFFIXED_FLOAT}
use compiler.core.tokens.{TOK_KW_DEFER, TOK_KW_ERRDEFER, TOK_KW_CONST, TOK_KW_WHERE}
use compiler.core.tokens.{TOK_KW_LAZY, TOK_KW_DO, TOK_KW_EXTEND, TOK_KW_NEWTYPE, TOK_KW_DYN}
use compiler.core.tokens.{TOK_LABEL, TOK_BACKTICK_IDENT}
use compiler.core.tokens.{TOK_AT, TOK_KW_KEYOF, TOK_KW_STATIC_FOR, TOK_KW_COMPTIME, TOK_KW_MIXIN}
use compiler.core.tokens.{TOK_KW_BIND, TOK_KW_CE, TOK_KW_RECEIVE, TOK_KW_AFTER}
use compiler.core.lexer.{lex_init, lex_next, lex_cur_kind, lex_cur_text, lex_cur_line, lex_cur_col, lex_cur_suffix}
use compiler.core.ast.{EXPR_INT_LIT, EXPR_FLOAT_LIT, EXPR_STRING_LIT}
use compiler.core.ast.{EXPR_BOOL_LIT, EXPR_NIL_LIT, EXPR_IDENT}
use compiler.core.ast.{EXPR_BINARY, EXPR_UNARY, EXPR_CALL, EXPR_INDEX}
use compiler.core.ast.{EXPR_FIELD_ACCESS, EXPR_METHOD_CALL, EXPR_ARRAY_LIT}
use compiler.core.ast.{EXPR_IF, EXPR_MATCH, EXPR_FOR, EXPR_WHILE}
use compiler.core.ast.{EXPR_RETURN, EXPR_BREAK, EXPR_CONTINUE, EXPR_RANGE}
use compiler.core.ast.{EXPR_ASSIGN, EXPR_COMPOUND_ASSIGN, EXPR_UNIT, EXPR_PASS, EXPR_PASS_TODO, EXPR_PASS_DO_NOTHING, EXPR_PASS_DN}
use compiler.core.ast.{EXPR_NULL_COALESCE, EXPR_SLICE, EXPR_INTERPOLATED_STRING}
use compiler.core.ast.{EXPR_AWAIT, EXPR_YIELD, EXPR_SPAWN, EXPR_DO_BLOCK, EXPR_ATOM}
use compiler.core.ast.{expr_int_lit, expr_float_lit, expr_string_lit}
use compiler.core.ast.{expr_bool_lit, expr_nil_lit, expr_ident}
use compiler.core.ast.{expr_binary, expr_unary, expr_call, expr_index}
use compiler.core.ast.{expr_field_access, expr_method_call, expr_array_lit}
use compiler.core.ast.{expr_if_expr, expr_for_expr, expr_while_expr}
use compiler.core.ast.{expr_return_expr, expr_break_expr, expr_continue_expr}
use compiler.core.ast.{expr_range, expr_assign, expr_compound_assign}
use compiler.core.ast.{expr_unit, expr_pass, expr_pass_with_msg, expr_pass_todo, expr_pass_do_nothing, expr_pass_dn, expr_null_coalesce, expr_slice}
use compiler.core.ast.{expr_dict_lit}
use compiler.core.ast.{expr_suffixed_int, expr_suffixed_float, expr_suffixed_bool}
use compiler.core.ast.{expr_match_expr, expr_block}
use compiler.core.ast.{expr_await, expr_yield, expr_spawn, expr_do_block, expr_atom, expr_spread, expr_asm, expr_asm_match, expr_asm_assert, EXPR_SPREAD}
use compiler.core.ast.{asm_arm_new, asm_arm_is_compile_error, asm_arm_error_msg, asm_arm_asm_text}
use compiler.core.ast.{STMT_ASM_ASSERT, stmt_asm_assert}
use compiler.core.ast.{expr_get_tag, expr_get_str, expr_get_left}
use compiler.core.ast.{STMT_EXPR, STMT_VAL_DECL, STMT_VAR_DECL, STMT_LAZY_VAL_DECL}
use compiler.core.ast.{STMT_RETURN, STMT_IF, STMT_FOR, STMT_WHILE}
use compiler.core.ast.{STMT_MATCH, STMT_BREAK, STMT_CONTINUE, STMT_COMPOUND_ASSIGN, STMT_DEFER, STMT_ERRDEFER}
use compiler.core.ast.{stmt_expr_stmt, stmt_val_decl, stmt_lazy_val_decl, stmt_var_decl}
use compiler.core.ast.{stmt_return_stmt, stmt_if_stmt, stmt_for_stmt, stmt_while_stmt, stmt_block_stmt}
use compiler.core.ast.{stmt_match_stmt, stmt_break_stmt, stmt_continue_stmt, stmt_break_labeled, stmt_continue_labeled, stmt_labeled_loop, STMT_LABELED_LOOP}
use compiler.core.ast.{STMT_STATIC_FOR, stmt_static_for_stmt}
use compiler.core.ast.{STMT_COMPTIME, stmt_comptime_block, decl_set_comptime}
use compiler.core.ast.{STMT_RECEIVE, stmt_receive_stmt, STMT_BIND, stmt_bind_stmt}
use compiler.core.ast.{DECL_CE, decl_ce_block}
use compiler.core.ast.{stmt_assign_stmt, stmt_compound_assign_stmt, stmt_defer_stmt, stmt_errdefer_stmt}
use compiler.core.ast.{DECL_FN, DECL_EXTERN_FN, DECL_STRUCT, DECL_USE, DECL_EXPORT}
use compiler.core.ast.{DECL_VAL, DECL_VAR, DECL_ENUM, DECL_LAZY_VAL}
use compiler.core.ast.{decl_fn, decl_extern_fn, decl_struct_def}
use compiler.core.ast.{decl_val_binding, decl_lazy_val_binding, decl_var_binding}
use compiler.core.ast.{decl_use_import, decl_export_names, decl_enum_def, decl_set_lazy}
use compiler.core.ast.{decl_impl_block}
use compiler.core.ast.{arm_new, arm_new_with_binding}
use compiler.core.ast.{elif_new}
use compiler.core.ast.{module_set_path, module_add_decl}
use compiler.core.ast.{ast_reset}
use compiler.core.types.{TYPE_I64, TYPE_F64, TYPE_TEXT, TYPE_BOOL, TYPE_VOID}
use compiler.core.types.{TYPE_ARRAY_I64, TYPE_ARRAY_TEXT, TYPE_ARRAY_BOOL, TYPE_ARRAY_ANY}
use compiler.core.types.{TYPE_NIL}
use compiler.core.types.{TYPE_OPTION, TYPE_OPTION_I64, TYPE_OPTION_F64, TYPE_OPTION_TEXT, TYPE_OPTION_BOOL}
use compiler.core.types.{TYPE_RESULT, TYPE_NAMED_BASE, TYPE_DICT, TYPE_FN, TYPE_ANY}
use compiler.core.types.{TYPE_UNION}
use compiler.core.types.{int_to_str}
use compiler.core.types.{named_type_register, named_type_find}
use compiler.core.types.{union_type_register}

extern fn rt_env_get(key: text) -> text

# ===== Parser State =====

var par_kind: i64 = 0
var par_text: text = ""
var par_line: i64 = 0
var par_col: i64 = 0
var par_errors: [text] = []
var par_had_error: bool = false
var par_struct_names: [text] = []

# ===== Conditional Compilation (@when/@elif/@else/@end and @cfg) =====

var _pp_tokens: [text] = []
var _pp_pos: i64 = 0

fn _pp_env(key: text) -> text:
    val value = rt_env_get(key)
    if value == nil:
        return ""
    value

fn _pp_strip_quotes(value: text) -> text:
    val trimmed = value.trim()
    if trimmed.len() >= 2:
        val first = trimmed[0:1]
        val last = trimmed[trimmed.len() - 1:trimmed.len()]
        val is_double = first == "\"" and last == "\""
        val is_single = first == "'" and last == "'"
        if is_double or is_single:
            return trimmed[1:trimmed.len() - 1]
    trimmed

fn _pp_normalize_os(raw: text) -> text:
    val value = _pp_strip_quotes(raw).trim()
    if value == "":
        return ""

    val is_win = value == "win" or value == "WIN"
    val is_win2 = value == "windows" or value == "Windows"
    val is_win3 = value == "Windows_NT" or value.contains("Windows")
    if is_win or is_win2 or is_win3:
        return "windows"

    val is_linux = value == "linux" or value == "Linux"
    val is_linux2 = value.contains("linux") or value.contains("Linux")
    if is_linux or is_linux2:
        return "linux"

    val is_macos = value == "mac" or value == "macos"
    val is_macos2 = value == "MacOS" or value == "darwin" or value == "Darwin"
    val is_macos3 = value.contains("darwin") or value.contains("Darwin")
    val is_macos4 = value.contains("macOS") or value.contains("Mac")
    if is_macos or is_macos2 or is_macos3 or is_macos4:
        return "macos"

    val is_freebsd = value == "freebsd" or value == "FreeBSD"
    val is_freebsd2 = value.contains("freebsd") or value.contains("FreeBSD")
    if is_freebsd or is_freebsd2:
        return "freebsd"

    val is_openbsd = value == "openbsd" or value == "OpenBSD"
    val is_openbsd2 = value.contains("openbsd") or value.contains("OpenBSD")
    if is_openbsd or is_openbsd2:
        return "openbsd"

    val is_netbsd = value == "netbsd" or value == "NetBSD"
    val is_netbsd2 = value.contains("netbsd") or value.contains("NetBSD")
    if is_netbsd or is_netbsd2:
        return "netbsd"

    val is_android = value == "android" or value == "Android"
    val is_android2 = value.contains("android") or value.contains("Android")
    if is_android or is_android2:
        return "android"

    val is_unix = value == "unix" or value == "Unix"
    val is_unix2 = value.contains("unix") or value.contains("Unix")
    if is_unix or is_unix2:
        return "unix"

    ""

fn _pp_normalize_arch(raw: text) -> text:
    val value = _pp_strip_quotes(raw).trim()
    if value == "":
        return ""

    val is_x64 = value == "x86_64" or value == "amd64" or value == "AMD64"
    val is_x64_2 = value == "x64" or value == "X64"
    val is_x64_3 = value.contains("x86_64") or value.contains("amd64") or value.contains("AMD64")
    if is_x64 or is_x64_2 or is_x64_3:
        return "x86_64"

    val is_x86 = value == "x86" or value == "X86"
    val is_x86_2 = value == "i386" or value == "i686"
    val is_x86_3 = value.contains("i386") or value.contains("i686")
    if is_x86 or is_x86_2 or is_x86_3:
        return "x86"

    val is_aarch64 = value == "aarch64" or value == "arm64" or value == "ARM64"
    val is_aarch64_2 = value.contains("aarch64") or value.contains("arm64")
    if is_aarch64 or is_aarch64_2:
        return "aarch64"

    val is_arm = value == "arm" or value == "ARM"
    val is_arm2 = value == "armv7" or value == "armv6"
    val is_arm3 = value.contains("armv7") or value.contains("armv6")
    if is_arm or is_arm2 or is_arm3:
        return "arm"

    val is_riscv64 = value == "riscv64" or value.contains("riscv64")
    if is_riscv64:
        return "riscv64"

    val is_riscv32 = value == "riscv32" or value.contains("riscv32")
    if is_riscv32:
        return "riscv32"

    val is_ppc64le = value == "ppc64le" or value == "ppc64el"
    val is_ppc64le2 = value == "powerpc64le"
    val is_ppc64le3 = value.contains("ppc64le") or value.contains("powerpc64le")
    if is_ppc64le or is_ppc64le2 or is_ppc64le3:
        return "ppc64le"

    ""

fn _pp_detect_os() -> text:
    val forced = _pp_normalize_os(_pp_env("SIMPLE_TARGET_OS"))
    if forced != "":
        return forced

    val from_os = _pp_normalize_os(_pp_env("OS"))
    if from_os != "":
        return from_os

    val from_ostype = _pp_normalize_os(_pp_env("OSTYPE"))
    if from_ostype != "":
        return from_ostype

    val from_platform = _pp_normalize_os(_pp_env("PLATFORM"))
    if from_platform != "":
        return from_platform

    val from_uname = _pp_normalize_os(_pp_env("UNAME"))
    if from_uname != "":
        return from_uname

    "unknown"

fn _pp_detect_arch() -> text:
    val forced = _pp_normalize_arch(_pp_env("SIMPLE_TARGET_ARCH"))
    if forced != "":
        return forced

    val from_arch = _pp_normalize_arch(_pp_env("PROCESSOR_ARCHITECTURE"))
    if from_arch != "":
        return from_arch

    val from_hosttype = _pp_normalize_arch(_pp_env("HOSTTYPE"))
    if from_hosttype != "":
        return from_hosttype

    val from_machtype = _pp_normalize_arch(_pp_env("MACHTYPE"))
    if from_machtype != "":
        return from_machtype

    val from_cpu = _pp_normalize_arch(_pp_env("CPU"))
    if from_cpu != "":
        return from_cpu

    "unknown"

fn _pp_detect_cpu() -> text:
    val forced = _pp_normalize_arch(_pp_env("SIMPLE_TARGET_CPU"))
    if forced != "":
        return forced

    val from_id = _pp_normalize_arch(_pp_env("PROCESSOR_IDENTIFIER"))
    if from_id != "":
        return from_id

    _pp_detect_arch()

fn _pp_eval_key_value(key_raw: text, value_raw: text) -> bool:
    val key = _pp_strip_quotes(key_raw).trim()
    val value = _pp_strip_quotes(value_raw).trim()

    if key == "os":
        val expected = _pp_normalize_os(value)
        if expected == "unix":
            val os = _pp_detect_os()
            val is_unix = os == "linux" or os == "macos"
            val is_unix2 = os == "freebsd" or os == "openbsd"
            val is_unix3 = os == "netbsd" or os == "android"
            return is_unix or is_unix2 or is_unix3 or os == "unix"
        return expected != "" and _pp_detect_os() == expected
    if key == "platform":
        val expected = _pp_normalize_os(value)
        if expected == "unix":
            val os = _pp_detect_os()
            val is_unix = os == "linux" or os == "macos"
            val is_unix2 = os == "freebsd" or os == "openbsd"
            val is_unix3 = os == "netbsd" or os == "android"
            return is_unix or is_unix2 or is_unix3 or os == "unix"
        return expected != "" and _pp_detect_os() == expected
    if key == "arch":
        val expected = _pp_normalize_arch(value)
        return expected != "" and _pp_detect_arch() == expected
    if key == "cpu":
        val expected = _pp_normalize_arch(value)
        return expected != "" and _pp_detect_cpu() == expected
    if key == "feature":
        # Feature-gated conditionals are unset in core parser mode.
        return false

    false

fn _pp_eval_atom(token: text) -> bool:
    val t = _pp_strip_quotes(token).trim()
    if t == "":
        return false
    if t == "true":
        return true
    if t == "false":
        return false
    if t == "debug":
        return true
    if t == "release":
        return false
    if t == "compiled":
        return true
    if t == "interpreter":
        return false

    if t == "win" or t == "windows":
        return _pp_detect_os() == "windows"
    if t == "linux":
        return _pp_detect_os() == "linux"
    if t == "mac" or t == "macos" or t == "darwin":
        return _pp_detect_os() == "macos"
    if t == "freebsd":
        return _pp_detect_os() == "freebsd"
    if t == "openbsd":
        return _pp_detect_os() == "openbsd"
    if t == "netbsd":
        return _pp_detect_os() == "netbsd"
    if t == "android":
        return _pp_detect_os() == "android"
    if t == "unix":
        val os = _pp_detect_os()
        val is_unix = os == "linux" or os == "macos"
        val is_unix2 = os == "freebsd" or os == "openbsd"
        val is_unix3 = os == "netbsd" or os == "android"
        return is_unix or is_unix2 or is_unix3 or os == "unix"

    if t == "x86_64" or t == "amd64" or t == "x64":
        return _pp_detect_arch() == "x86_64"
    if t == "x86" or t == "i386" or t == "i686":
        return _pp_detect_arch() == "x86"
    if t == "aarch64" or t == "arm64":
        return _pp_detect_arch() == "aarch64"
    if t == "arm" or t == "armv7" or t == "armv6":
        return _pp_detect_arch() == "arm"
    if t == "riscv64":
        return _pp_detect_arch() == "riscv64"
    if t == "riscv32":
        return _pp_detect_arch() == "riscv32"
    if t == "ppc64le" or t == "ppc64el" or t == "powerpc64le":
        return _pp_detect_arch() == "ppc64le"

    if t.contains("=="):
        val parts = t.split("==")
        if parts.len() >= 2:
            return _pp_eval_key_value(parts[0], parts[1])
    if t.contains("="):
        val parts = t.split("=")
        if parts.len() >= 2:
            return _pp_eval_key_value(parts[0], parts[1])

    false

fn _pp_tokenize_condition(condition: text) -> [text]:
    var tokens: [text] = []
    var current: [text] = []
    var i: i64 = 0

    for _ in condition:
        if i >= condition.len():
            break
        val ch = condition[i]

        val is_ws = ch == " " or ch == "\t" or ch == "\r"
        if is_ws:
            if current.len() > 0:
                tokens.push(current.join(""))
                current = []
            i = i + 1
            continue

        val is_paren = ch == "(" or ch == ")"
        if is_paren:
            if current.len() > 0:
                tokens.push(current.join(""))
                current = []
            tokens.push(ch)
            i = i + 1
            continue

        if ch == "&" and i + 1 < condition.len() and condition[i + 1] == "&":
            if current.len() > 0:
                tokens.push(current.join(""))
                current = []
            tokens.push("&&")
            i = i + 2
            continue

        if ch == "|" and i + 1 < condition.len() and condition[i + 1] == "|":
            if current.len() > 0:
                tokens.push(current.join(""))
                current = []
            tokens.push("||")
            i = i + 2
            continue

        if ch == "!":
            if current.len() > 0:
                tokens.push(current.join(""))
                current = []
            tokens.push("!")
            i = i + 1
            continue

        current.push(ch)
        i = i + 1

    if current.len() > 0:
        tokens.push(current.join(""))

    tokens

fn _pp_peek() -> text:
    if _pp_pos >= _pp_tokens.len():
        return ""
    _pp_tokens[_pp_pos]

fn _pp_take() -> text:
    val token = _pp_peek()
    if token != "":
        _pp_pos = _pp_pos + 1
    token

fn _pp_parse_or() -> bool:
    var left = _pp_parse_and()
    for _ in 0..1024:
        val tok = _pp_peek()
        val is_or = tok == "or" or tok == "||"
        if not is_or:
            break
        _pp_take()
        val right = _pp_parse_and()
        left = left or right
    left

fn _pp_parse_and() -> bool:
    var left = _pp_parse_not()
    for _ in 0..1024:
        val tok = _pp_peek()
        val is_and = tok == "and" or tok == "&&"
        if not is_and:
            break
        _pp_take()
        val right = _pp_parse_not()
        left = left and right
    left

fn _pp_parse_not() -> bool:
    val tok = _pp_peek()
    val is_not = tok == "not" or tok == "!"
    if is_not:
        _pp_take()
        return not _pp_parse_not()
    _pp_parse_primary()

fn _pp_parse_primary() -> bool:
    val tok = _pp_peek()
    if tok == "(":
        _pp_take()
        val value = _pp_parse_or()
        if _pp_peek() == ")":
            _pp_take()
        return value

    val atom = _pp_take()
    _pp_eval_atom(atom)

fn _pp_eval_condition(condition: text) -> bool:
    _pp_tokens = _pp_tokenize_condition(condition)
    _pp_pos = 0
    if _pp_tokens.len() == 0:
        return false
    _pp_parse_or()

fn _pp_extract_paren_condition(line: text) -> text:
    # Extract condition from @when(condition): or @cfg(condition) etc.
    # Finds '(' and reads until matching ')'.
    var start: i64 = -1
    var i: i64 = 0
    for _ in line:
        if i >= line.len(): break
        if line[i] == "(":
            start = i + 1
            break
        i = i + 1
    if start < 0:
        return ""
    var depth: i64 = 1
    var chars: [text] = []
    var j: i64 = start
    for _ in line:
        if j >= line.len(): break
        val ch = line[j]
        if ch == "(":
            depth = depth + 1
        if ch == ")":
            depth = depth - 1
            if depth == 0: break
        chars.push(ch)
        j = j + 1
    chars.join("").trim()

fn _pp_extract_cfg_condition(line: text) -> text:
    # Extract from @cfg(condition) or @cfg("key", "value")
    # For key-value form, convert to key=value for eval
    val raw = _pp_extract_paren_condition(line)
    if raw.contains(","):
        val parts = raw.split(",")
        if parts.len() >= 2:
            val key = _pp_strip_quotes(parts[0].trim())
            val value = _pp_strip_quotes(parts[1].trim())
            return "{key}={value}"
    raw

fn _pp_split_lines(source: text) -> [text]:
    var lines: [text] = []
    var line_chars: [text] = []
    var i: i64 = 0
    for _ in source:
        if i >= source.len():
            break
        val ch = source[i]
        if ch == "\n":
            lines.push(line_chars.join(""))
            line_chars = []
        else:
            line_chars.push(ch)
        i = i + 1
    lines.push(line_chars.join(""))
    lines

fn _pp_preprocess_conditionals(source: text) -> text:
    val lines = _pp_split_lines(source)
    var out_lines: [text] = []

    var stack_parent_active: [bool] = []
    var stack_branch_taken: [bool] = []
    var stack_branch_active: [bool] = []
    var depth: i64 = 0
    var active: bool = true

    for line in lines:
        val trimmed = line.trim()

        val is_when = trimmed.starts_with("@when(")
        if is_when:
            val cond = _pp_extract_paren_condition(trimmed)
            val parent = active
            val cond_ok = _pp_eval_condition(cond)
            val current = parent and cond_ok

            if depth >= stack_parent_active.len():
                stack_parent_active.push(parent)
                stack_branch_taken.push(current)
                stack_branch_active.push(current)
            else:
                stack_parent_active[depth] = parent
                stack_branch_taken[depth] = current
                stack_branch_active[depth] = current
            depth = depth + 1
            active = current
            out_lines.push("")
            continue

        val is_elif = trimmed.starts_with("@elif(")
        if is_elif:
            if depth > 0:
                val idx = depth - 1
                val parent = stack_parent_active[idx]
                var taken = stack_branch_taken[idx]
                var current = false
                if parent and not taken:
                    val cond = _pp_extract_paren_condition(trimmed)
                    current = _pp_eval_condition(cond)
                    if current:
                        taken = true
                stack_branch_taken[idx] = taken
                stack_branch_active[idx] = current
                active = current
            out_lines.push("")
            continue

        val is_else = trimmed == "@else" or trimmed == "@else:"
        if is_else:
            if depth > 0:
                val idx = depth - 1
                val parent = stack_parent_active[idx]
                val taken = stack_branch_taken[idx]
                val current = parent and (not taken)
                stack_branch_taken[idx] = taken or current
                stack_branch_active[idx] = current
                active = current
            out_lines.push("")
            continue

        val is_end = trimmed == "@end"
        if is_end:
            if depth > 0:
                depth = depth - 1
            if depth <= 0:
                active = true
            else:
                active = stack_branch_active[depth - 1]
            out_lines.push("")
            continue

        if active:
            out_lines.push(line)
        else:
            # Keep line count stable for diagnostics.
            out_lines.push("")

    # Second pass: @cfg(condition) per-declaration conditionals
    var final_lines: [text] = []
    var skip_until_dedent: bool = false
    var skip_indent: i64 = -1
    var i: i64 = 0
    for _ in out_lines:
        if i >= out_lines.len(): break
        val ol = out_lines[i]
        val ot = ol.trim()

        if skip_until_dedent:
            if ot == "":
                final_lines.push("")
                skip_until_dedent = false
                skip_indent = -1
                i = i + 1
                continue
            var cur_indent: i64 = 0
            var ci: i64 = 0
            for _ in ol:
                if ci >= ol.len(): break
                val c = ol[ci]
                if c == " ":
                    cur_indent = cur_indent + 1
                elif c == "\t":
                    cur_indent = cur_indent + 4
                else:
                    break
                ci = ci + 1
            if cur_indent > skip_indent:
                final_lines.push("")
                i = i + 1
                continue
            else:
                skip_until_dedent = false
                skip_indent = -1

        if ot.starts_with("@cfg("):
            val cfg_cond = _pp_extract_cfg_condition(ot)
            val cfg_ok = _pp_eval_condition(cfg_cond)
            if cfg_ok:
                # Condition true: blank @cfg line, keep declaration
                final_lines.push("")
            else:
                # Condition false: blank @cfg line + following declaration
                final_lines.push("")
                # Calculate indent of the next declaration line
                if i + 1 < out_lines.len():
                    val next_line = out_lines[i + 1]
                    val next_trimmed = next_line.trim()
                    var next_indent: i64 = 0
                    var ni: i64 = 0
                    for _ in next_line:
                        if ni >= next_line.len(): break
                        val nc = next_line[ni]
                        if nc == " ":
                            next_indent = next_indent + 1
                        elif nc == "\t":
                            next_indent = next_indent + 4
                        else:
                            break
                        ni = ni + 1
                    # Blank the declaration line
                    i = i + 1
                    final_lines.push("")
                    # If declaration ends with ':', blank its body too
                    if next_trimmed.ends_with(":"):
                        skip_until_dedent = true
                        skip_indent = next_indent
            i = i + 1
            continue

        final_lines.push(ol)
        i = i + 1

    final_lines.join("\n")

# ===== Parser Init =====

fn parser_init(source: text):
    lex_init(source)
    ast_reset()
    par_errors = []
    par_had_error = false
    parser_advance()

fn parser_advance():
    par_kind = lex_next()
    par_text = lex_cur_text
    par_line = lex_cur_line
    par_col = lex_cur_col

# ===== Token Checking =====

fn parser_check(expected: i64) -> bool:
    par_kind == expected

fn parser_match_tok(expected: i64) -> bool:
    if par_kind != expected:
        return false
    parser_advance()
    true

fn parser_expect(expected: i64) -> bool:
    if par_kind == expected:
        parser_advance()
        return true
    val msg = "line " + int_to_str(par_line) + ":" + int_to_str(par_col) + ": expected " + tok_kind_name(expected) + ", got " + tok_kind_name(par_kind) + " '" + par_text + "'"
    par_errors.push(msg)
    par_had_error = true
    false

fn parser_error(msg: text):
    val full = "line " + int_to_str(par_line) + ":" + int_to_str(par_col) + ": " + msg
    par_errors.push(full)
    par_had_error = true

# ===== Skip Newlines =====

fn parser_skip_newlines():
    for i in 0..10000:
        if par_kind != TOK_NEWLINE:
            break
        parser_advance()

fn parser_skip_newlines_and_semicolons():
    for i in 0..10000:
        val is_nl = par_kind == TOK_NEWLINE
        val is_semi = par_kind == TOK_SEMICOLON
        val should_skip = is_nl or is_semi
        if not should_skip:
            break
        parser_advance()

# ===== Type Annotation Parsing =====

fn parser_parse_type() -> i64:
    # dyn Trait — dynamic dispatch type (parsed as named type)
    if par_kind == TOK_KW_DYN:
        parser_advance()
        # Parse the trait name
        val dyn_name = par_text
        if par_kind == TOK_IDENT:
            parser_advance()
        # Return as named type (interpreter uses structural subtyping anyway)
        val dyn_id = named_type_find(dyn_name)
        if dyn_id >= 0:
            return TYPE_NAMED_BASE + dyn_id
        return TYPE_ANY
    val type_name = par_text
    if par_kind == TOK_IDENT:
        parser_advance()
        # Check for generic type: Option<T>, Result<T, E>, Dict<K,V>, etc.
        val has_lt: bool = par_kind == TOK_LT
        val has_lt_gen: bool = par_kind == TOK_LT_GENERIC
        val has_generic: bool = has_lt or has_lt_gen
        if has_generic:
            parser_advance()
            val inner_type = parser_parse_type()
            # Handle multi-param generics: Dict<K, V>, Result<T, E>
            for i in 0..10:
                if par_kind != TOK_COMMA:
                    break
                parser_advance()
                val extra_type = parser_parse_type()
            parser_expect(TOK_GT)
            # Handle Option<T>
            if type_name == "Option":
                if inner_type == TYPE_I64:
                    return TYPE_OPTION_I64
                if inner_type == TYPE_F64:
                    return TYPE_OPTION_F64
                if inner_type == TYPE_TEXT:
                    return TYPE_OPTION_TEXT
                if inner_type == TYPE_BOOL:
                    return TYPE_OPTION_BOOL
                return TYPE_OPTION
            # Handle Result<T, E> (simplified - just return TYPE_RESULT)
            if type_name == "Result":
                return TYPE_RESULT
            # Dict<K,V> -> TYPE_DICT
            if type_name == "Dict":
                return TYPE_DICT
            # Unknown generic type - check if base is a named struct
            val gid = named_type_find(type_name)
            if gid >= 0:
                return TYPE_NAMED_BASE + gid
            return TYPE_VOID
        # Check for postfix ? for Option shorthand: i64? -> Option<i64>
        if par_kind == TOK_QUESTION:
            parser_advance()
            if type_name == "i64":
                return TYPE_OPTION_I64
            if type_name == "f64":
                return TYPE_OPTION_F64
            if type_name == "text":
                return TYPE_OPTION_TEXT
            if type_name == "bool":
                return TYPE_OPTION_BOOL
            return TYPE_OPTION
        # Simple primitive types
        if type_name == "i64":
            return TYPE_I64
        if type_name == "f64":
            return TYPE_F64
        if type_name == "text":
            return TYPE_TEXT
        if type_name == "bool":
            return TYPE_BOOL
        if type_name == "Option":
            return TYPE_OPTION
        if type_name == "Result":
            return TYPE_RESULT
        # Check for struct type
        val sid = named_type_find(type_name)
        if sid >= 0:
            return TYPE_NAMED_BASE + sid
        return TYPE_VOID
    if par_kind == TOK_LBRACKET:
        # Array type: [i64], [text], etc.
        parser_advance()
        val elem_type = parser_parse_type()
        parser_expect(TOK_RBRACKET)
        # Nested array types [[T]] -> TYPE_ARRAY_ANY
        val is_nested = elem_type == TYPE_ARRAY_I64
        val is_nested2 = elem_type == TYPE_ARRAY_TEXT
        val is_nested3 = elem_type == TYPE_ARRAY_BOOL
        val is_nested4 = elem_type == TYPE_ARRAY_ANY
        val any_nested = is_nested or is_nested2
        val any_nested2 = any_nested or is_nested3
        val any_nested3 = any_nested2 or is_nested4
        if any_nested3:
            return TYPE_ARRAY_ANY
        if elem_type == TYPE_I64:
            return TYPE_ARRAY_I64
        if elem_type == TYPE_TEXT:
            return TYPE_ARRAY_TEXT
        if elem_type == TYPE_BOOL:
            return TYPE_ARRAY_BOOL
        return TYPE_ARRAY_I64
    # Function type: fn(T, T) -> T
    if par_kind == TOK_KW_FN:
        parser_advance()
        parser_expect(TOK_LPAREN)
        if par_kind != TOK_RPAREN:
            parser_parse_type()
            for i in 0..100:
                if par_kind != TOK_COMMA:
                    break
                parser_advance()
                if par_kind == TOK_RPAREN:
                    break
                parser_parse_type()
        parser_expect(TOK_RPAREN)
        if par_kind == TOK_ARROW:
            parser_advance()
            parser_parse_type()
        return TYPE_FN
    # Tuple type: (T, T)
    if par_kind == TOK_LPAREN:
        parser_advance()
        if par_kind != TOK_RPAREN:
            parser_parse_type()
            for i in 0..100:
                if par_kind != TOK_COMMA:
                    break
                parser_advance()
                if par_kind == TOK_RPAREN:
                    break
                parser_parse_type()
        parser_expect(TOK_RPAREN)
        return TYPE_ANY
    # Dict type: {K: V}
    if par_kind == TOK_LBRACE:
        parser_advance()
        if par_kind != TOK_RBRACE:
            parser_parse_type()
            if par_kind == TOK_COLON:
                parser_advance()
                parser_parse_type()
        parser_expect(TOK_RBRACE)
        return TYPE_DICT
    parser_error("expected type annotation")
    TYPE_VOID

# Parses a type that may be a union: A | B | C
fn parser_parse_type_with_union() -> i64:
    val base = parser_parse_type()
    if par_kind != TOK_PIPE:
        return base
    # Check that the pipe isn't a |> pipe-forward
    var members: [i64] = []
    members.push(base)
    while par_kind == TOK_PIPE:
        parser_advance()
        val next = parser_parse_type()
        members.push(next)
    union_type_register(members)

# ===== Expression Parsing =====

fn parse_expr() -> i64:
    parse_assignment()

fn parse_assignment() -> i64:
    val left = parse_or()
    if par_kind == TOK_WALRUS:
        parser_advance()
        val right = parse_assignment()
        # Walrus is treated as assignment for now
        # Semantically it means "val" instead of reassignment
        return expr_assign(left, right, 0)
    if par_kind == TOK_ASSIGN:
        parser_advance()
        val right = parse_assignment()
        return expr_assign(left, right, 0)
    if par_kind == TOK_PLUS_ASSIGN:
        parser_advance()
        val right = parse_assignment()
        return expr_compound_assign(TOK_PLUS, left, right, 0)
    if par_kind == TOK_MINUS_ASSIGN:
        parser_advance()
        val right = parse_assignment()
        return expr_compound_assign(TOK_MINUS, left, right, 0)
    if par_kind == TOK_STAR_ASSIGN:
        parser_advance()
        val right = parse_assignment()
        return expr_compound_assign(TOK_STAR, left, right, 0)
    if par_kind == TOK_SLASH_ASSIGN:
        parser_advance()
        val right = parse_assignment()
        return expr_compound_assign(TOK_SLASH, left, right, 0)
    left

fn parse_or() -> i64:
    var left = parse_and()
    for i in 0..1000:
        val is_or = par_kind == TOK_KW_OR
        val is_or2 = par_kind == TOK_OR
        val match_or = is_or or is_or2
        if not match_or:
            break
        parser_advance()
        val right = parse_and()
        left = expr_binary(TOK_OR, left, right, 0)
    left

fn parse_and() -> i64:
    var left = parse_not()
    for i in 0..1000:
        val is_and = par_kind == TOK_KW_AND
        val is_and2 = par_kind == TOK_AND
        val match_and = is_and or is_and2
        if not match_and:
            break
        parser_advance()
        val right = parse_not()
        left = expr_binary(TOK_AND, left, right, 0)
    left

fn parse_not() -> i64:
    val is_not = par_kind == TOK_KW_NOT
    val is_not2 = par_kind == TOK_NOT
    val match_not = is_not or is_not2
    if match_not:
        parser_advance()
        val operand = parse_not()
        return expr_unary(TOK_NOT, operand, 0)
    parse_comparison()

fn parse_comparison() -> i64:
    var left = parse_null_coalesce()
    for i in 0..100:
        if par_kind == TOK_EQ:
            parser_advance()
            val right = parse_null_coalesce()
            left = expr_binary(TOK_EQ, left, right, 0)
        elif par_kind == TOK_NEQ:
            parser_advance()
            val right = parse_null_coalesce()
            left = expr_binary(TOK_NEQ, left, right, 0)
        elif par_kind == TOK_LT:
            parser_advance()
            val right = parse_null_coalesce()
            left = expr_binary(TOK_LT, left, right, 0)
        elif par_kind == TOK_GT:
            parser_advance()
            val right = parse_null_coalesce()
            left = expr_binary(TOK_GT, left, right, 0)
        elif par_kind == TOK_LEQ:
            parser_advance()
            val right = parse_null_coalesce()
            left = expr_binary(TOK_LEQ, left, right, 0)
        elif par_kind == TOK_GEQ:
            parser_advance()
            val right = parse_null_coalesce()
            left = expr_binary(TOK_GEQ, left, right, 0)
        else:
            break
    left

fn parse_null_coalesce() -> i64:
    var left = parse_range()
    for i in 0..100:
        if par_kind == TOK_DOUBLE_QUESTION:
            parser_advance()
            val right = parse_range()
            left = expr_null_coalesce(left, right, 0)
        else:
            break
    left

fn parse_range() -> i64:
    val left = parse_addition()
    if par_kind == TOK_DOTDOT:
        parser_advance()
        val right = parse_addition()
        return expr_range(left, right, 0, 0)
    if par_kind == TOK_DOTDOT_EQ:
        parser_advance()
        val right = parse_addition()
        return expr_range(left, right, 1, 0)
    left

fn parse_addition() -> i64:
    var left = parse_multiplication()
    for i in 0..1000:
        if par_kind == TOK_PLUS:
            parser_advance()
            val right = parse_multiplication()
            left = expr_binary(TOK_PLUS, left, right, 0)
        elif par_kind == TOK_MINUS:
            parser_advance()
            val right = parse_multiplication()
            left = expr_binary(TOK_MINUS, left, right, 0)
        else:
            break
    left

fn parse_multiplication() -> i64:
    var left = parse_unary()
    for i in 0..1000:
        if par_kind == TOK_STAR:
            parser_advance()
            val right = parse_unary()
            left = expr_binary(TOK_STAR, left, right, 0)
        elif par_kind == TOK_SLASH:
            parser_advance()
            val right = parse_unary()
            left = expr_binary(TOK_SLASH, left, right, 0)
        elif par_kind == TOK_PERCENT:
            parser_advance()
            val right = parse_unary()
            left = expr_binary(TOK_PERCENT, left, right, 0)
        elif par_kind == TOK_DOUBLE_STAR:
            parser_advance()
            val right = parse_unary()
            left = expr_binary(TOK_DOUBLE_STAR, left, right, 0)
        else:
            break
    left

fn parse_unary() -> i64:
    if par_kind == TOK_MINUS:
        parser_advance()
        val operand = parse_unary()
        return expr_unary(TOK_MINUS, operand, 0)
    if par_kind == TOK_KW_NOT:
        parser_advance()
        val operand = parse_unary()
        return expr_unary(TOK_NOT, operand, 0)
    parse_postfix()

fn parse_binary_from(base: i64) -> i64:
    # Continue binary expression parsing from an already-parsed base.
    # Used by parse_call_arg when ident is already consumed.
    # Handles: *, /, %, **, +, -, .., ..=, ??, comparisons, and, or
    var left = base
    # Multiplication level
    for i in 0..1000:
        if par_kind == TOK_STAR:
            parser_advance()
            val right = parse_unary()
            left = expr_binary(TOK_STAR, left, right, 0)
        elif par_kind == TOK_SLASH:
            parser_advance()
            val right = parse_unary()
            left = expr_binary(TOK_SLASH, left, right, 0)
        elif par_kind == TOK_PERCENT:
            parser_advance()
            val right = parse_unary()
            left = expr_binary(TOK_PERCENT, left, right, 0)
        elif par_kind == TOK_DOUBLE_STAR:
            parser_advance()
            val right = parse_unary()
            left = expr_binary(TOK_DOUBLE_STAR, left, right, 0)
        elif par_kind == TOK_PIPE:
            parser_advance()
            val right = parse_unary()
            left = expr_binary(TOK_PIPE, left, right, 0)
        else:
            break
    # Addition level
    var add_left = left
    for i in 0..1000:
        if par_kind == TOK_PLUS:
            parser_advance()
            val right = parse_multiplication()
            add_left = expr_binary(TOK_PLUS, add_left, right, 0)
        elif par_kind == TOK_MINUS:
            parser_advance()
            val right = parse_multiplication()
            add_left = expr_binary(TOK_MINUS, add_left, right, 0)
        else:
            break
    left = add_left
    # Range
    if par_kind == TOK_DOTDOT:
        parser_advance()
        val right = parse_addition()
        left = expr_range(left, right, 0, 0)
    if par_kind == TOK_DOTDOT_EQ:
        parser_advance()
        val right = parse_addition()
        left = expr_range(left, right, 1, 0)
    # Null coalesce
    for i in 0..100:
        if par_kind == TOK_DOUBLE_QUESTION:
            parser_advance()
            val right = parse_range()
            left = expr_null_coalesce(left, right, 0)
        else:
            break
    # Comparisons
    for i in 0..100:
        if par_kind == TOK_EQ:
            parser_advance()
            val right = parse_null_coalesce()
            left = expr_binary(TOK_EQ, left, right, 0)
        elif par_kind == TOK_NEQ:
            parser_advance()
            val right = parse_null_coalesce()
            left = expr_binary(TOK_NEQ, left, right, 0)
        elif par_kind == TOK_LT:
            parser_advance()
            if par_kind == TOK_LT:
                parser_advance()
                val lshift_right = parse_null_coalesce()
                left = expr_binary(TOK_LT, left, lshift_right, 0)
            else:
                val right = parse_null_coalesce()
                left = expr_binary(TOK_LT, left, right, 0)
        elif par_kind == TOK_GT:
            parser_advance()
            if par_kind == TOK_GT:
                parser_advance()
                val rshift_right = parse_null_coalesce()
                left = expr_binary(TOK_GT, left, rshift_right, 0)
            else:
                val right = parse_null_coalesce()
                left = expr_binary(TOK_GT, left, right, 0)
        elif par_kind == TOK_LEQ:
            parser_advance()
            val right = parse_null_coalesce()
            left = expr_binary(TOK_LEQ, left, right, 0)
        elif par_kind == TOK_GEQ:
            parser_advance()
            val right = parse_null_coalesce()
            left = expr_binary(TOK_GEQ, left, right, 0)
        elif par_kind == TOK_KW_IN:
            parser_advance()
            val right = parse_null_coalesce()
            left = expr_method_call(right, "contains", [], 0)
        elif par_kind == TOK_KW_IS:
            parser_advance()
            val cast_type = parser_parse_type()
            val dummy_bf = cast_type
        else:
            break
    # And
    for i in 0..1000:
        val is_and = par_kind == TOK_KW_AND
        val is_and2 = par_kind == TOK_AND
        val match_and = is_and or is_and2
        if not match_and:
            break
        parser_advance()
        val right = parse_not()
        left = expr_binary(TOK_AND, left, right, 0)
    # Or
    for i in 0..1000:
        val is_or = par_kind == TOK_KW_OR
        val is_or2 = par_kind == TOK_OR
        val match_or = is_or or is_or2
        if not match_or:
            break
        parser_advance()
        val right = parse_and()
        left = expr_binary(TOK_OR, left, right, 0)
    left

fn parse_call_arg() -> i64:
    # Struct update spread: ..base_expr
    if par_kind == TOK_DOTDOT:
        parser_advance()
        val spread_inner = parse_expr()
        return expr_spread(spread_inner, 0)
    # Check for bool-suffixed identifiers: true_abs, false_mut
    if par_kind == TOK_IDENT:
        val ident = par_text
        val ident_len = ident.len()
        if ident_len > 5:
            val prefix5 = ident[0:5]
            if prefix5 == "true_":
                val suffix = ident[5:]
                parser_advance()
                return expr_suffixed_bool(1, suffix, 0)
        if ident_len > 6:
            val prefix6 = ident[0:6]
            if prefix6 == "false_":
                val suffix = ident[6:]
                parser_advance()
                return expr_suffixed_bool(0, suffix, 0)
        # Named argument: ident COLON expr -> strip name, return value
        parser_advance()
        if par_kind == TOK_COLON:
            parser_advance()
            return parse_expr()
        # Not a named arg: already consumed ident, continue with postfix+binary
        val ident_node = expr_ident(ident, 0)
        val postfix_result = parse_postfix_on(ident_node)
        return parse_binary_from(postfix_result)
    parse_expr()

fn extract_dotted_path(eid: i64) -> text:
    val ep_tag = expr_get_tag(eid)
    if ep_tag == EXPR_IDENT:
        return expr_get_str(eid)
    if ep_tag == EXPR_FIELD_ACCESS:
        val ep_base_path = extract_dotted_path(expr_get_left(eid))
        if ep_base_path != "":
            return ep_base_path + "." + expr_get_str(eid)
    ""

fn parse_postfix_on(base_expr: i64) -> i64:
    # Continue postfix parsing from an already-parsed base expression
    var base = base_expr
    for i in 0..1000:
        if par_kind == TOK_DOT:
            parser_advance()

            # --- .FILE → __traits("module_file", "dotted.path") ---
            if par_kind == TOK_IDENT and par_text == "FILE":
                val ppo_dotted = extract_dotted_path(base)
                if ppo_dotted != "":
                    parser_advance()
                    var ppo_mf_args: [i64] = []
                    ppo_mf_args.push(expr_string_lit("module_file", 0))
                    ppo_mf_args.push(expr_string_lit(ppo_dotted, 0))
                    val ppo_mf_callee = expr_ident("__traits", 0)
                    base = expr_call(ppo_mf_callee, ppo_mf_args, 0)
                    continue

            # --- .class → __traits("class_info", "TypeName") ---
            if par_kind == TOK_KW_CLASS:
                val ppo_type_name = extract_dotted_path(base)
                if ppo_type_name != "":
                    parser_advance()
                    var ppo_ci_args: [i64] = []
                    ppo_ci_args.push(expr_string_lit("class_info", 0))
                    ppo_ci_args.push(expr_string_lit(ppo_type_name, 0))
                    val ppo_ci_callee = expr_ident("__traits", 0)
                    base = expr_call(ppo_ci_callee, ppo_ci_args, 0)
                    continue

            # --- .* → __traits("module_wildcard", "dotted.prefix") ---
            if par_kind == TOK_STAR:
                val ppo_prefix = extract_dotted_path(base)
                if ppo_prefix != "":
                    parser_advance()
                    var ppo_mw_args: [i64] = []
                    ppo_mw_args.push(expr_string_lit("module_wildcard", 0))
                    ppo_mw_args.push(expr_string_lit(ppo_prefix, 0))
                    val ppo_mw_callee = expr_ident("__traits", 0)
                    base = expr_call(ppo_mw_callee, ppo_mw_args, 0)
                    continue

            val field_name = par_text
            if par_kind != TOK_IDENT:
                parser_error("expected field name after '.'")
                break
            parser_advance()
            if par_kind == TOK_LPAREN:
                parser_advance()
                var call_args: [i64] = []
                if par_kind != TOK_RPAREN:
                    call_args.push(parse_call_arg())
                    for j in 0..100:
                        if par_kind != TOK_COMMA:
                            break
                        parser_advance()
                        call_args.push(parse_call_arg())
                parser_expect(TOK_RPAREN)
                base = expr_method_call(base, field_name, call_args, 0)
            else:
                base = expr_field_access(base, field_name, 0)
        elif par_kind == TOK_LBRACKET:
            parser_advance()
            if par_kind == TOK_COLON:
                parser_advance()
                val end_idx = parse_expr()
                parser_expect(TOK_RBRACKET)
                val zero = expr_int_lit(0, 0)
                base = expr_slice(base, zero, end_idx, 0)
            else:
                val index_expr = parse_expr()
                if par_kind == TOK_COLON:
                    parser_advance()
                    if par_kind == TOK_RBRACKET:
                        parser_advance()
                        val neg1 = expr_int_lit(-1, 0)
                        base = expr_slice(base, index_expr, neg1, 0)
                    else:
                        val end_idx = parse_expr()
                        parser_expect(TOK_RBRACKET)
                        base = expr_slice(base, index_expr, end_idx, 0)
                else:
                    parser_expect(TOK_RBRACKET)
                    base = expr_index(base, index_expr, 0)
        elif par_kind == TOK_LPAREN:
            parser_advance()
            var call_args: [i64] = []
            if par_kind != TOK_RPAREN:
                call_args.push(parse_call_arg())
                for j in 0..100:
                    if par_kind != TOK_COMMA:
                        break
                    parser_advance()
                    call_args.push(parse_call_arg())
            parser_expect(TOK_RPAREN)
            base = expr_call(base, call_args, 0)
        elif par_kind == TOK_QUESTION_DOT:
            parser_advance()
            val field_name = par_text
            parser_expect(TOK_IDENT)
            base = expr_field_access(base, field_name, 0)
        else:
            break
    # Continue with assignment operators
    if par_kind == TOK_ASSIGN:
        parser_advance()
        val right = parse_assignment()
        return expr_assign(base, right, 0)
    if par_kind == TOK_PLUS_ASSIGN:
        parser_advance()
        val right = parse_assignment()
        return expr_compound_assign(TOK_PLUS, base, right, 0)
    if par_kind == TOK_MINUS_ASSIGN:
        parser_advance()
        val right = parse_assignment()
        return expr_compound_assign(TOK_MINUS, base, right, 0)
    base

fn parse_postfix() -> i64:
    var base = parse_primary()
    for i in 0..1000:
        if par_kind == TOK_DOT:
            parser_advance()

            # --- .FILE → __traits("module_file", "dotted.path") ---
            if par_kind == TOK_IDENT and par_text == "FILE":
                val pp_dotted = extract_dotted_path(base)
                if pp_dotted != "":
                    parser_advance()
                    var pp_mf_args: [i64] = []
                    pp_mf_args.push(expr_string_lit("module_file", 0))
                    pp_mf_args.push(expr_string_lit(pp_dotted, 0))
                    val pp_mf_callee = expr_ident("__traits", 0)
                    base = expr_call(pp_mf_callee, pp_mf_args, 0)
                    continue

            # --- .class → __traits("class_info", "TypeName") ---
            if par_kind == TOK_KW_CLASS:
                val pp_type_name = extract_dotted_path(base)
                if pp_type_name != "":
                    parser_advance()
                    var pp_ci_args: [i64] = []
                    pp_ci_args.push(expr_string_lit("class_info", 0))
                    pp_ci_args.push(expr_string_lit(pp_type_name, 0))
                    val pp_ci_callee = expr_ident("__traits", 0)
                    base = expr_call(pp_ci_callee, pp_ci_args, 0)
                    continue

            # --- .* → __traits("module_wildcard", "dotted.prefix") ---
            if par_kind == TOK_STAR:
                val pp_prefix = extract_dotted_path(base)
                if pp_prefix != "":
                    parser_advance()
                    var pp_mw_args: [i64] = []
                    pp_mw_args.push(expr_string_lit("module_wildcard", 0))
                    pp_mw_args.push(expr_string_lit(pp_prefix, 0))
                    val pp_mw_callee = expr_ident("__traits", 0)
                    base = expr_call(pp_mw_callee, pp_mw_args, 0)
                    continue

            val field_name = par_text
            if par_kind != TOK_IDENT:
                parser_error("expected field name after '.'")
                break
            parser_advance()
            # Check for method call: obj.method(args)
            if par_kind == TOK_LPAREN:
                parser_advance()
                var call_args: [i64] = []
                if par_kind != TOK_RPAREN:
                    call_args.push(parse_call_arg())
                    for j in 0..100:
                        if par_kind != TOK_COMMA:
                            break
                        parser_advance()
                        call_args.push(parse_call_arg())
                parser_expect(TOK_RPAREN)
                base = expr_method_call(base, field_name, call_args, 0)
            else:
                base = expr_field_access(base, field_name, 0)
        elif par_kind == TOK_LBRACKET:
            parser_advance()
            # Check for slice: a[start:end]
            if par_kind == TOK_COLON:
                parser_advance()
                val end_idx = parse_expr()
                parser_expect(TOK_RBRACKET)
                val zero = expr_int_lit(0, 0)
                base = expr_slice(base, zero, end_idx, 0)
            else:
                val index_expr = parse_expr()
                if par_kind == TOK_COLON:
                    # Slice: a[start:end]
                    parser_advance()
                    if par_kind == TOK_RBRACKET:
                        # a[start:] — open-ended
                        parser_advance()
                        val neg1 = expr_int_lit(-1, 0)
                        base = expr_slice(base, index_expr, neg1, 0)
                    else:
                        val end_idx = parse_expr()
                        parser_expect(TOK_RBRACKET)
                        base = expr_slice(base, index_expr, end_idx, 0)
                else:
                    parser_expect(TOK_RBRACKET)
                    base = expr_index(base, index_expr, 0)
        elif par_kind == TOK_LPAREN:
            # Function call: f(args)
            parser_advance()
            var call_args: [i64] = []
            if par_kind != TOK_RPAREN:
                call_args.push(parse_call_arg())
                for j in 0..100:
                    if par_kind != TOK_COMMA:
                        break
                    parser_advance()
                    call_args.push(parse_call_arg())
            parser_expect(TOK_RPAREN)
            base = expr_call(base, call_args, 0)
        elif par_kind == TOK_QUESTION_DOT:
            # Optional chaining: x?.field
            parser_advance()
            val field_name = par_text
            parser_expect(TOK_IDENT)
            base = expr_field_access(base, field_name, 0)
        else:
            break
    base

fn parse_primary() -> i64:
    # @annotation(...) — compile-time introspection built-ins
    # @traits(query, T, ...) desugars to __traits("query", "T", ...)
    # @file, @line, @function desugar to __builtin_file etc.
    if par_kind == TOK_AT:
        parser_advance()
        val ann_name = par_text
        if par_kind == TOK_IDENT:
            parser_advance()
        if par_kind == TOK_LPAREN:
            parser_advance()
            var at_args: [i64] = []
            # First argument: the annotation name as a string literal
            at_args.push(expr_string_lit(ann_name, 0))
            for at_i in 0..20:
                if par_kind == TOK_RPAREN:
                    break
                if par_kind == TOK_COMMA:
                    parser_advance()
                    continue
                if par_kind == TOK_EOF:
                    break
                # Identifier args (type names) become string literals
                if par_kind == TOK_IDENT:
                    val id_arg = par_text
                    parser_advance()
                    at_args.push(expr_string_lit(id_arg, 0))
                else:
                    val expr_arg = parse_expr()
                    at_args.push(expr_arg)
            parser_expect(TOK_RPAREN)
            val at_callee = expr_ident("__traits", 0)
            return expr_call(at_callee, at_args, 0)
        # Simple @identifier (no parens): @file, @line, @function
        val at_builtin_name = "__builtin_" + ann_name
        return expr_ident(at_builtin_name, 0)

    # keyof T — compile-time field name list (sugar for @traits("fields", "T"))
    if par_kind == TOK_KW_KEYOF:
        parser_advance()
        val keyof_type = par_text
        if par_kind == TOK_IDENT:
            parser_advance()
        var keyof_args: [i64] = []
        keyof_args.push(expr_string_lit("fields", 0))
        keyof_args.push(expr_string_lit(keyof_type, 0))
        val keyof_callee = expr_ident("__traits", 0)
        return expr_call(keyof_callee, keyof_args, 0)

    # mixin(code_text) — compile-time code generation
    # Desugars to __mixin(code_text) builtin call
    if par_kind == TOK_KW_MIXIN:
        parser_advance()
        parser_expect(TOK_LPAREN)
        val mixin_arg = parse_expr()
        parser_expect(TOK_RPAREN)
        var mixin_args_list: [i64] = []
        mixin_args_list.push(mixin_arg)
        val mixin_callee = expr_ident("__mixin", 0)
        return expr_call(mixin_callee, mixin_args_list, 0)

    # asm "..." | asm: "..." | asm { "..." } | asm match: | asm assert [...]
    if par_kind == TOK_KW_ASM:
        parser_advance()

        # asm match: — multi-target dispatch
        if par_kind == TOK_KW_MATCH:
            parser_advance()
            parser_expect(TOK_COLON)
            return parse_asm_match()

        # asm assert [...] — compile-time target guard (parsed as expression, handled as stmt)
        if par_kind == TOK_IDENT and par_text == "assert":
            parser_advance()
            return parse_asm_assert_expr()

        if par_kind == TOK_STRING_LIT:
            val inline_asm = par_text
            parser_advance()
            return expr_asm(inline_asm, 0)

        if par_kind == TOK_COLON:
            parser_advance()
            parser_skip_newlines()
            if par_kind != TOK_INDENT:
                parser_error("expected indented asm block after 'asm:'")
                return expr_asm("", 0)
            parser_advance()
            var asm_lines: [text] = []
            for ai in 0..100000:
                parser_skip_newlines()
                if par_kind == TOK_DEDENT:
                    parser_advance()
                    break
                if par_kind == TOK_EOF:
                    break
                if par_kind == TOK_STRING_LIT:
                    asm_lines.push(par_text)
                    parser_advance()
                    continue
                parser_error("expected string literal in asm block")
                for aj in 0..10000:
                    val is_nl = par_kind == TOK_NEWLINE
                    val is_ded = par_kind == TOK_DEDENT
                    val is_eof = par_kind == TOK_EOF
                    if is_nl or is_ded or is_eof:
                        break
                    parser_advance()
            return expr_asm(asm_lines.join("\n"), 0)

        if par_kind == TOK_LBRACE:
            parser_advance()
            var asm_parts: [text] = []
            for ai in 0..100000:
                if par_kind == TOK_RBRACE:
                    parser_advance()
                    break
                if par_kind == TOK_EOF:
                    parser_error("unterminated asm { ... } block")
                    break
                if par_kind == TOK_NEWLINE or par_kind == TOK_COMMA or par_kind == TOK_SEMICOLON:
                    parser_advance()
                    continue
                if par_kind == TOK_STRING_LIT:
                    asm_parts.push(par_text)
                    parser_advance()
                    continue
                parser_error("expected string literal in asm { ... } block")
                parser_advance()
            return expr_asm(asm_parts.join("\n"), 0)

        parser_error("expected string literal, ':' block, or '{...}' after 'asm'")
        return expr_asm("", 0)

    if par_kind == TOK_INT_LIT:
        val int_text = par_text
        parser_advance()
        # Parse integer from text (supporting _ separators and 0x/0b/0o prefixes)
        var int_val = 0
        if int_text.len() > 2:
            val prefix = int_text[0:2]
            if prefix == "0x":
                # Hex literal: parse digit by digit
                val hex_digits = int_text[2:]
                var hex_val = 0
                var hi = 0
                while hi < hex_digits.len():
                    val hc = hex_digits[hi:hi+1]
                    if hc != "_":
                        var hd = 0
                        if hc >= "0" and hc <= "9":
                            hd = int(hc)
                        elif hc >= "a" and hc <= "f":
                            hd = int(hc) - int("a") + 10
                        elif hc >= "A" and hc <= "F":
                            hd = int(hc) - int("A") + 10
                        hex_val = hex_val * 16 + hd
                    hi = hi + 1
                return expr_int_lit(hex_val, 0)
            if prefix == "0b":
                # Binary literal: parse digit by digit
                val bin_digits = int_text[2:]
                var bin_val = 0
                var bi = 0
                while bi < bin_digits.len():
                    val bc = bin_digits[bi:bi+1]
                    if bc == "1":
                        bin_val = bin_val * 2 + 1
                    elif bc == "0":
                        bin_val = bin_val * 2
                    bi = bi + 1
                return expr_int_lit(bin_val, 0)
            if prefix == "0o":
                # Octal literal: parse digit by digit
                val oct_digits = int_text[2:]
                var oct_val = 0
                var oi = 0
                while oi < oct_digits.len():
                    val oc = oct_digits[oi:oi+1]
                    if oc != "_":
                        oct_val = oct_val * 8 + int(oc)
                    oi = oi + 1
                return expr_int_lit(oct_val, 0)
        # Decimal — strip _ separators then parse
        var stripped: text = ""
        var si = 0
        while si < int_text.len():
            val sc = int_text[si:si+1]
            if sc != "_":
                stripped = stripped + sc
            si = si + 1
        if stripped.len() > 0:
            int_val = int(stripped)
        return expr_int_lit(int_val, 0)

    if par_kind == TOK_FLOAT_LIT:
        val float_text = par_text
        parser_advance()
        return expr_float_lit(float_text, 0)

    if par_kind == TOK_SUFFIXED_INT:
        val suf_text = par_text
        val suf_name = lex_cur_suffix
        parser_advance()
        val int_val = int(suf_text)
        return expr_suffixed_int(int_val, suf_name, 0)

    if par_kind == TOK_SUFFIXED_FLOAT:
        val suf_text = par_text
        val suf_name = lex_cur_suffix
        parser_advance()
        return expr_suffixed_float(suf_text, suf_name, 0)

    if par_kind == TOK_STRING_LIT:
        val str_text = par_text
        parser_advance()
        return expr_string_lit(str_text, 0)

    if par_kind == TOK_BOOL_LIT:
        val bool_text = par_text
        parser_advance()
        if bool_text == "true":
            return expr_bool_lit(1, 0)
        return expr_bool_lit(0, 0)

    if par_kind == TOK_NIL_LIT:
        parser_advance()
        return expr_nil_lit(0)

    if par_kind == TOK_IDENT:
        val id_name = par_text
        parser_advance()
        return expr_ident(id_name, 0)

    if par_kind == TOK_KW_SELF:
        parser_advance()
        return expr_ident("self", 0)

    if par_kind == TOK_KW_AWAIT:
        parser_advance()
        val future_expr = parse_expr()
        return expr_await(future_expr, 0)

    if par_kind == TOK_KW_YIELD:
        parser_advance()
        val value_expr = parse_expr()
        return expr_yield(value_expr, 0)

    if par_kind == TOK_KW_SPAWN:
        parser_advance()
        val call_expr = parse_expr()
        return expr_spawn(call_expr, 0)

    if par_kind == TOK_KW_DO:
        parser_advance()
        parser_expect(TOK_COLON)
        val do_body = parse_block()
        return expr_do_block(do_body, 0)

    if par_kind == TOK_KW_CE:
        # ce NAME: block as expression — returns last value like do:
        parser_advance()
        var ce_builder_name = par_text
        parser_expect(TOK_IDENT)
        parser_expect(TOK_COLON)
        val ce_body = parse_block()
        return expr_do_block(ce_body, 0)

    if par_kind == TOK_BACKTICK_IDENT:
        val atom_name = par_text
        parser_advance()
        return expr_atom(atom_name, 0)

    if par_kind == TOK_LPAREN:
        parser_advance()
        if par_kind == TOK_RPAREN:
            parser_advance()
            return expr_unit(0)
        val inner = parse_expr()
        parser_expect(TOK_RPAREN)
        return inner

    if par_kind == TOK_LBRACKET:
        # Array literal: [1, 2, 3]
        parser_advance()
        var elements: [i64] = []
        if par_kind != TOK_RBRACKET:
            elements.push(parse_expr())
            for i in 0..10000:
                if par_kind != TOK_COMMA:
                    break
                parser_advance()
                if par_kind == TOK_RBRACKET:
                    break
                elements.push(parse_expr())
        parser_expect(TOK_RBRACKET)
        return expr_array_lit(elements, 0)

    if par_kind == TOK_KW_RETURN:
        parser_advance()
        val is_nl = par_kind == TOK_NEWLINE
        val is_ded = par_kind == TOK_DEDENT
        val is_eof = par_kind == TOK_EOF
        val no_value = is_nl or is_ded
        val no_val2 = no_value or is_eof
        if no_val2:
            return expr_return_expr(-1, 0)
        val ret_val = parse_expr()
        return expr_return_expr(ret_val, 0)

    if par_kind == TOK_KW_BREAK:
        parser_advance()
        return expr_break_expr(0)

    if par_kind == TOK_KW_CONTINUE:
        parser_advance()
        return expr_continue_expr(0)

    if par_kind == TOK_KW_PASS:
        parser_advance()
        var msg = ""
        if par_kind == TOK_LPAREN:
            parser_advance()
            if par_kind == TOK_STRING_LIT:
                msg = par_text
                parser_advance()
            parser_expect(TOK_RPAREN)
        if msg == "":
            return expr_pass(0)
        return expr_pass_with_msg(msg, 0)

    if par_kind == TOK_KW_PASS_TODO:
        parser_advance()
        var msg = ""
        if par_kind == TOK_LPAREN:
            parser_advance()
            if par_kind == TOK_STRING_LIT:
                msg = par_text
                parser_advance()
            parser_expect(TOK_RPAREN)
        return expr_pass_todo(msg, 0)

    if par_kind == TOK_KW_PASS_DO_NOTHING:
        parser_advance()
        var msg = ""
        if par_kind == TOK_LPAREN:
            parser_advance()
            if par_kind == TOK_STRING_LIT:
                msg = par_text
                parser_advance()
            parser_expect(TOK_RPAREN)
        return expr_pass_do_nothing(msg, 0)

    if par_kind == TOK_KW_PASS_DN:
        parser_advance()
        var msg = ""
        if par_kind == TOK_LPAREN:
            parser_advance()
            if par_kind == TOK_STRING_LIT:
                msg = par_text
                parser_advance()
            parser_expect(TOK_RPAREN)
        return expr_pass_dn(msg, 0)

    if par_kind == TOK_KW_NOT:
        parser_advance()
        val operand = parse_not()
        return expr_unary(TOK_NOT, operand, 0)

    if par_kind == TOK_MINUS:
        parser_advance()
        val operand = parse_unary()
        return expr_unary(TOK_MINUS, operand, 0)

    if par_kind == TOK_UNDERSCORE:
        parser_advance()
        return expr_ident("_", 0)

    # Dict literal: {key: value, ...} or empty {}
    if par_kind == TOK_LBRACE:
        parser_advance()
        var key_exprs: [i64] = []
        var value_exprs: [i64] = []

        # Check for empty dict {}
        if par_kind == TOK_RBRACE:
            parser_advance()
            return expr_dict_lit(key_exprs, value_exprs, 0)

        # Parse key-value pairs
        for i in 0..10000:
            # Parse key
            val key = parse_expr()
            key_exprs.push(key)

            # Expect colon
            parser_expect(TOK_COLON)

            # Parse value
            val value = parse_expr()
            value_exprs.push(value)

            # Check for comma or closing brace
            if par_kind == TOK_COMMA:
                parser_advance()
                # Allow trailing comma before }
                if par_kind == TOK_RBRACE:
                    parser_advance()
                    break
            elif par_kind == TOK_RBRACE:
                parser_advance()
                break
            else:
                parser_error("expected , or } in dict literal")
                break

        return expr_dict_lit(key_exprs, value_exprs, 0)

    # Lambda: \x: expr or \x, y: expr
    if par_kind == TOK_ERROR:
        if par_text == "unexpected character: \\":
            parser_advance()
            # Skip lambda params
            for i in 0..100:
                if par_kind == TOK_COLON:
                    parser_advance()
                    break
                if par_kind == TOK_EOF:
                    break
                if par_kind == TOK_NEWLINE:
                    break
                parser_advance()
            val lbody = parse_expr()
            return lbody

    # Handle keywords that may appear in expression position
    if par_kind == TOK_KW_MATCH:
        return parse_match_stmt()
    if par_kind == TOK_KW_IF:
        return parse_if_expr()

    parser_error("unexpected token in expression: " + tok_kind_name(par_kind) + " '" + par_text + "'")
    parser_advance()
    expr_nil_lit(0)

# ===== Asm Match/Assert Parsing =====

fn parse_asm_target_spec() -> i64:
    """Parse target spec: [arch | arch2, os, abi, backend >= ver]
    Returns index into asm_arm_* arena (as spec, not full arm).
    """
    parser_expect(TOK_LBRACKET)
    # Parse arch(es) with pipe grouping
    var archs: [text] = []
    if par_kind == TOK_IDENT:
        archs.push(par_text)
        parser_advance()
        # Check for pipe groups: arch | arch2
        for pi in 0..20:
            if par_kind == TOK_PIPE:
                parser_advance()
                if par_kind == TOK_IDENT:
                    archs.push(par_text)
                    parser_advance()
                else:
                    parser_error("expected architecture name after '|'")
            else:
                break
    else:
        parser_error("expected architecture name in target spec")

    # Parse optional os, abi, backend (comma-separated)
    var os_val = ""
    var abi_val = ""
    var backend_val = ""
    var ver_ops: [text] = []
    var ver_vals: [i64] = []
    var field_pos = 1  # 1=os, 2=abi, 3=backend

    for fi in 0..3:
        if par_kind != TOK_COMMA:
            break
        parser_advance()
        if par_kind == TOK_UNDERSCORE:
            # Wildcard _
            parser_advance()
            field_pos = field_pos + 1
            continue
        if par_kind == TOK_IDENT:
            val field_text = par_text
            parser_advance()
            if field_pos == 1:
                os_val = field_text
            elif field_pos == 2:
                abi_val = field_text
            elif field_pos == 3:
                backend_val = field_text
                # Check for version constraints after backend
                for vi in 0..4:
                    if par_kind == TOK_GEQ:
                        parser_advance()
                        if par_kind == TOK_INT_LIT:
                            ver_ops.push(">=")
                            ver_vals.push(parse_int_text(par_text))
                            parser_advance()
                        else:
                            parser_error("expected version number after '>='")
                    elif par_kind == TOK_EQ:
                        # Could be == (two tokens) or a single ==
                        parser_advance()
                        if par_kind == TOK_EQ:
                            parser_advance()
                        if par_kind == TOK_INT_LIT:
                            ver_ops.push("==")
                            ver_vals.push(parse_int_text(par_text))
                            parser_advance()
                        else:
                            parser_error("expected version number after '=='")
                    elif par_kind == TOK_LT:
                        parser_advance()
                        if par_kind == TOK_INT_LIT:
                            ver_ops.push("<")
                            ver_vals.push(parse_int_text(par_text))
                            parser_advance()
                        else:
                            parser_error("expected version number after '<'")
                    elif par_kind == TOK_IDENT and par_text == "~=":
                        parser_advance()
                        if par_kind == TOK_INT_LIT:
                            ver_ops.push("~=")
                            ver_vals.push(parse_int_text(par_text))
                            parser_advance()
                        else:
                            parser_error("expected version number after '~='")
                    else:
                        break
            field_pos = field_pos + 1
        else:
            parser_error("expected identifier or '_' in target spec")
            break

    parser_expect(TOK_RBRACKET)

    val arm_idx = asm_arm_new(archs, os_val, abi_val, backend_val,
                              ver_ops, ver_vals, "", false, "", false)
    arm_idx

fn parse_int_text(txt: text) -> i64:
    """Parse integer from text (simple decimal)."""
    var result = 0
    for i in 0..txt.len():
        val ch = txt[i]
        if ch >= "0" and ch <= "9":
            result = result * 10 + (ch.ord() - 48)
    result

fn parse_asm_match() -> i64:
    """Parse asm match: block with case arms.

    Syntax:
        asm match:
            case [spec]: asm_body
            case _: compile_error("msg")
    """
    parser_skip_newlines()
    if par_kind != TOK_INDENT:
        parser_error("expected indented block after 'asm match:'")
        return expr_asm("", 0)
    parser_advance()

    var arm_indices: [i64] = []
    for mi in 0..100:
        parser_skip_newlines()
        if par_kind == TOK_DEDENT:
            parser_advance()
            break
        if par_kind == TOK_EOF:
            break

        # Each arm starts with 'case'
        if par_kind != TOK_KW_CASE:
            parser_error("expected 'case' in asm match arm")
            parser_advance()
            continue

        parser_advance()  # consume 'case'

        # Check for wildcard: case _:
        if par_kind == TOK_UNDERSCORE:
            parser_advance()
            parser_expect(TOK_COLON)

            # Parse body: either compile_error("msg") or asm lines
            parser_skip_newlines()
            if par_kind == TOK_INDENT:
                parser_advance()
                parser_skip_newlines()

            if par_kind == TOK_IDENT and par_text == "compile_error":
                parser_advance()
                parser_expect(TOK_LPAREN)
                var err_msg = ""
                if par_kind == TOK_STRING_LIT:
                    err_msg = par_text
                    parser_advance()
                parser_expect(TOK_RPAREN)
                val arm_idx = asm_arm_new([], "", "", "", [], [], "", true, err_msg, true)
                arm_indices.push(arm_idx)
                # Skip to end of arm
                parser_skip_newlines()
                if par_kind == TOK_DEDENT:
                    parser_advance()
            else:
                # Wildcard with asm body
                var asm_lines: [text] = []
                for ai in 0..10000:
                    parser_skip_newlines()
                    if par_kind == TOK_DEDENT or par_kind == TOK_EOF:
                        break
                    if par_kind == TOK_KW_CASE:
                        break
                    if par_kind == TOK_STRING_LIT:
                        asm_lines.push(par_text)
                        parser_advance()
                    else:
                        parser_advance()
                val asm_text = asm_lines.join("\n")
                val arm_idx = asm_arm_new([], "", "", "", [], [], asm_text, false, "", true)
                arm_indices.push(arm_idx)
                if par_kind == TOK_DEDENT:
                    parser_advance()
            continue

        # case [spec]:
        val spec_idx = parse_asm_target_spec()
        parser_expect(TOK_COLON)

        # Parse body: either compile_error("msg") or asm lines
        parser_skip_newlines()
        if par_kind == TOK_INDENT:
            parser_advance()
            parser_skip_newlines()

        if par_kind == TOK_IDENT and par_text == "compile_error":
            parser_advance()
            parser_expect(TOK_LPAREN)
            var err_msg = ""
            if par_kind == TOK_STRING_LIT:
                err_msg = par_text
                parser_advance()
            parser_expect(TOK_RPAREN)
            # Update the arm to be compile_error
            asm_arm_is_compile_error[spec_idx] = true
            asm_arm_error_msg[spec_idx] = err_msg
            arm_indices.push(spec_idx)
            parser_skip_newlines()
            if par_kind == TOK_DEDENT:
                parser_advance()
        else:
            # Collect asm body lines
            var asm_lines: [text] = []
            for ai in 0..10000:
                parser_skip_newlines()
                if par_kind == TOK_DEDENT or par_kind == TOK_EOF:
                    break
                if par_kind == TOK_KW_CASE:
                    break
                if par_kind == TOK_STRING_LIT:
                    asm_lines.push(par_text)
                    parser_advance()
                else:
                    parser_advance()
            val asm_text = asm_lines.join("\n")
            asm_arm_asm_text[spec_idx] = asm_text
            arm_indices.push(spec_idx)
            if par_kind == TOK_DEDENT:
                parser_advance()

    return expr_asm_match(arm_indices, 0)

fn parse_asm_assert_expr() -> i64:
    """Parse asm assert [spec] — compile-time target guard.

    Returns an expression (value is 0/unit in interpreter).
    Uses EXPR_ASM_MATCH with i_val=1 to distinguish from asm match.
    """
    val spec_idx = parse_asm_target_spec()
    return expr_asm_assert(spec_idx, 0)

# ===== Statement Parsing =====

fn parse_block() -> [i64]:
    var stmts: [i64] = []
    parser_skip_newlines()
    if par_kind == TOK_INDENT:
        # Multi-line indented block
        parser_advance()
        for i in 0..100000:
            parser_skip_newlines()
            if par_kind == TOK_DEDENT:
                parser_advance()
                break
            if par_kind == TOK_EOF:
                break
            val s = parse_statement()
            stmts.push(s)
            parser_skip_newlines_and_semicolons()
        return stmts
    # Single-line body (no indent): parse one statement
    val s = parse_statement()
    stmts.push(s)
    stmts

fn parse_statement() -> i64:
    if par_kind == TOK_KW_VAL:
        return parse_val_decl_stmt()

    if par_kind == TOK_KW_LAZY:
        parser_advance()
        return parse_lazy_val_decl_stmt()

    if par_kind == TOK_KW_VAR:
        return parse_var_decl_stmt()

    if par_kind == TOK_KW_RETURN:
        parser_advance()
        val is_nl = par_kind == TOK_NEWLINE
        val is_ded = par_kind == TOK_DEDENT
        val no_value = is_nl or is_ded
        if no_value:
            return stmt_return_stmt(-1, 0)
        val ret_val = parse_expr()
        return stmt_return_stmt(ret_val, 0)

    if par_kind == TOK_KW_IF:
        return parse_if_stmt()

    # Labeled loop: 'label: for/while
    if par_kind == TOK_LABEL:
        val loop_label = par_text
        parser_advance()
        # Expect colon after label
        parser_expect(TOK_COLON)
        # Then parse the loop and wrap in labeled_loop stmt
        if par_kind == TOK_KW_FOR:
            val for_s = parse_for_stmt()
            return stmt_labeled_loop(loop_label, for_s, 0)
        if par_kind == TOK_KW_WHILE:
            val while_s = parse_while_stmt()
            return stmt_labeled_loop(loop_label, while_s, 0)
        # Fallthrough: ignore label if not followed by loop
        return parse_statement()

    if par_kind == TOK_KW_FOR:
        return parse_for_stmt()

    if par_kind == TOK_KW_STATIC_FOR:
        return parse_static_for_stmt()

    if par_kind == TOK_KW_COMPTIME:
        parser_advance()
        if par_kind == TOK_COLON:
            parser_advance()
            val ct_body = parse_block()
            return stmt_comptime_block(ct_body, 0)
        # comptime fn inside a block: parse the fn as expression statement
        val ct_expr = parse_expr()
        return stmt_expr_stmt(ct_expr, 0)

    if par_kind == TOK_KW_WHILE:
        return parse_while_stmt()

    if par_kind == TOK_KW_MATCH:
        return parse_match_stmt()

    if par_kind == TOK_KW_BREAK:
        parser_advance()
        # Check for labeled break: break 'label
        if par_kind == TOK_LABEL:
            val lbl = par_text
            parser_advance()
            return stmt_break_labeled(lbl, 0)
        return stmt_break_stmt(0)

    if par_kind == TOK_KW_CONTINUE:
        parser_advance()
        # Check for labeled continue: continue 'label
        if par_kind == TOK_LABEL:
            val lbl = par_text
            parser_advance()
            return stmt_continue_labeled(lbl, 0)
        return stmt_continue_stmt(0)

    if par_kind == TOK_KW_RECEIVE:
        parser_advance()
        return parse_receive_stmt()

    if par_kind == TOK_KW_BIND:
        parser_advance()
        return parse_bind_stmt()

    if par_kind == TOK_KW_DEFER:
        parser_advance()
        val deferred = parse_expr()
        return stmt_defer_stmt(deferred, 0)

    if par_kind == TOK_KW_ERRDEFER:
        parser_advance()
        val err_deferred = parse_expr()
        return stmt_errdefer_stmt(err_deferred, 0)

    if par_kind == TOK_KW_PASS:
        parser_advance()
        var msg = ""
        if par_kind == TOK_LPAREN:
            parser_advance()
            if par_kind == TOK_STRING_LIT:
                msg = par_text
                parser_advance()
            parser_expect(TOK_RPAREN)
        if msg == "":
            return stmt_expr_stmt(expr_pass(0), 0)
        return stmt_expr_stmt(expr_pass_with_msg(msg, 0), 0)

    if par_kind == TOK_KW_PASS_TODO:
        parser_advance()
        var msg = ""
        if par_kind == TOK_LPAREN:
            parser_advance()
            if par_kind == TOK_STRING_LIT:
                msg = par_text
                parser_advance()
            parser_expect(TOK_RPAREN)
        return stmt_expr_stmt(expr_pass_todo(msg, 0), 0)

    if par_kind == TOK_KW_PASS_DO_NOTHING:
        parser_advance()
        var msg = ""
        if par_kind == TOK_LPAREN:
            parser_advance()
            if par_kind == TOK_STRING_LIT:
                msg = par_text
                parser_advance()
            parser_expect(TOK_RPAREN)
        return stmt_expr_stmt(expr_pass_do_nothing(msg, 0), 0)

    if par_kind == TOK_KW_PASS_DN:
        parser_advance()
        var msg = ""
        if par_kind == TOK_LPAREN:
            parser_advance()
            if par_kind == TOK_STRING_LIT:
                msg = par_text
                parser_advance()
            parser_expect(TOK_RPAREN)
        return stmt_expr_stmt(expr_pass_dn(msg, 0), 0)

    # Handle bare 'print' keyword (print expr — no parens)
    if par_kind == TOK_IDENT:
        if par_text == "print":
            parser_advance()
            val is_nl = par_kind == TOK_NEWLINE
            val is_ded = par_kind == TOK_DEDENT
            val is_eof = par_kind == TOK_EOF
            val no_arg = is_nl or is_ded
            val no_arg2 = no_arg or is_eof
            if no_arg2:
                val callee0 = expr_ident("print", 0)
                var args0: [i64] = []
                val call0 = expr_call(callee0, args0, 0)
                return stmt_expr_stmt(call0, 0)
            val print_arg = parse_expr()
            val callee1 = expr_ident("print", 0)
            var args1: [i64] = []
            args1.push(print_arg)
            val call1 = expr_call(callee1, args1, 0)
            return stmt_expr_stmt(call1, 0)

    # Expression statement (including assignment and walrus)
    # Note: Walrus operator handled inline during expression parsing
    val expression = parse_expr()
    stmt_expr_stmt(expression, 0)

# ===== Type Inference Support =====

fn infer_expr_type_from_parse(expr_id: i64) -> i64:
    # Simple type inference based on expression kind
    # Returns TYPE_VOID (0) if type cannot be inferred
    if expr_id < 0:
        return 0
    val e = expr_get(expr_id)
    val tag = e.tag

    # Literal types
    if tag == EXPR_INT_LIT:
        return TYPE_I64
    if tag == EXPR_FLOAT_LIT:
        return TYPE_F64
    if tag == EXPR_STRING_LIT:
        return TYPE_TEXT
    if tag == EXPR_BOOL_LIT:
        return TYPE_BOOL
    if tag == EXPR_NIL_LIT:
        return TYPE_NIL
    if tag == EXPR_ARRAY_LIT:
        return TYPE_ARRAY_ANY

    # Binary operations - infer from operator
    if tag == EXPR_BINARY:
        val op = e.s_val
        if op == "+" or op == "-" or op == "*" or op == "/":
            # Could be i64 or f64, default to i64
            return TYPE_I64
        if (op == "==" or op == "!=" or op == "<" or op == ">" or
            op == "<=" or op == ">=" or op == "and" or op == "or"):
            return TYPE_BOOL
        return 0

    # Unary operations
    if tag == EXPR_UNARY:
        val op = e.s_val
        if op == "not":
            return TYPE_BOOL
        if op == "-":
            return TYPE_I64
        return 0

    # Function calls - cannot infer without function signature
    if tag == EXPR_CALL:
        return 0

    # Default: cannot infer
    0

fn parse_val_decl_stmt() -> i64:
    parser_advance()
    val name = par_text
    parser_expect(TOK_IDENT)

    # Optional type annotation: val x: i64 = ...
    var type_tag = 0
    if par_kind == TOK_COLON:
        parser_advance()
        type_tag = parser_parse_type()

    parser_expect(TOK_ASSIGN)
    val init = parse_expr()

    # Type inference: if no explicit type, try to infer from initializer
    if type_tag == 0:
        type_tag = infer_expr_type_from_parse(init)

    stmt_val_decl(name, type_tag, init, 0)

fn parse_lazy_val_decl_stmt() -> i64:
    parser_advance()
    val name = par_text
    parser_expect(TOK_IDENT)

    var type_tag = 0
    if par_kind == TOK_COLON:
        parser_advance()
        type_tag = parser_parse_type()

    parser_expect(TOK_ASSIGN)
    val init = parse_expr()

    if type_tag == 0:
        type_tag = infer_expr_type_from_parse(init)

    stmt_lazy_val_decl(name, type_tag, init, 0)

fn parse_var_decl_stmt() -> i64:
    parser_advance()
    val name = par_text
    parser_expect(TOK_IDENT)

    var type_tag = 0
    if par_kind == TOK_COLON:
        parser_advance()
        type_tag = parser_parse_type()

    # Type inference for var declarations handled after initialization

    parser_expect(TOK_ASSIGN)
    val init = parse_expr()
    stmt_var_decl(name, type_tag, init, 0)

fn parse_if_stmt() -> i64:
    parser_advance()
    val cond = parse_expr()
    parser_expect(TOK_COLON)
    val then_body = parse_block()

    # Handle elif/else
    parser_skip_newlines()
    var else_body: [i64] = []

    if par_kind == TOK_KW_ELIF:
        # Elif is parsed as nested if in else
        val nested_if = parse_if_stmt()
        else_body.push(nested_if)
    elif par_kind == TOK_KW_ELSE:
        parser_advance()
        parser_expect(TOK_COLON)
        else_body = parse_block()

    # Store elif chain using elif arena
    val elif_idx = elif_new(cond, then_body, else_body)
    stmt_if_stmt(cond, then_body, elif_idx, 0)

fn parse_for_stmt() -> i64:
    parser_advance()
    val iter_name = par_text
    parser_expect(TOK_IDENT)
    parser_expect(TOK_KW_IN)
    val iterable = parse_expr()
    parser_expect(TOK_COLON)
    val body = parse_block()
    stmt_for_stmt(iter_name, iterable, body, 0)

fn parse_static_for_stmt() -> i64:
    parser_advance()
    val iter_name = par_text
    parser_expect(TOK_IDENT)
    parser_expect(TOK_KW_IN)
    val iterable = parse_expr()
    parser_expect(TOK_COLON)
    val body = parse_block()
    stmt_static_for_stmt(iter_name, iterable, body, 0)

fn parse_while_stmt() -> i64:
    parser_advance()
    val cond = parse_expr()
    parser_expect(TOK_COLON)
    val body = parse_block()
    stmt_while_stmt(cond, body, 0)

fn parse_match_stmt() -> i64:
    parser_advance()
    val scrutinee = parse_expr()
    parser_expect(TOK_COLON)
    parser_skip_newlines()
    parser_expect(TOK_INDENT)

    var arm_indices: [i64] = []
    for i in 0..1000:
        parser_skip_newlines()
        if par_kind == TOK_DEDENT:
            parser_advance()
            break
        if par_kind == TOK_EOF:
            break

        if par_kind == TOK_KW_CASE:
            parser_advance()

            # Support multi-pattern: case X | Y | Z:
            # Parse first pattern
            var patterns: [i64] = []
            patterns.push(parse_expr())

            # Check for pipe separator and collect additional patterns
            # Support multi-line patterns by skipping newlines/indents before pipes
            for skip_idx in 0..100:
                val is_nl = par_kind == TOK_NEWLINE
                val is_indent = par_kind == TOK_INDENT
                val should_skip = is_nl or is_indent
                if not should_skip:
                    break
                parser_advance()

            while par_kind == TOK_PIPE:
                parser_advance()
                # Skip newlines/indents after pipe
                for skip_idx in 0..100:
                    val is_nl = par_kind == TOK_NEWLINE
                    val is_indent = par_kind == TOK_INDENT
                    val should_skip = is_nl or is_indent
                    if not should_skip:
                        break
                    parser_advance()
                patterns.push(parse_expr())
                # Skip newlines/indents after pattern
                for skip_idx in 0..100:
                    val is_nl = par_kind == TOK_NEWLINE
                    val is_indent = par_kind == TOK_INDENT
                    val should_skip = is_nl or is_indent
                    if not should_skip:
                        break
                    parser_advance()

            # Check for guard clause: case X if guard_expr:
            var guard_expr_idx: i64 = -1
            if par_kind == TOK_KW_IF:
                parser_advance()
                guard_expr_idx = parse_expr()

            # Check for pattern binding: case X as binding_name:
            var pattern_binding = ""
            if par_kind == TOK_IDENT:
                if par_text == "as":
                    parser_advance()
                    pattern_binding = par_text
                    parser_expect(TOK_IDENT)

            # Expect colon after all patterns
            parser_expect(TOK_COLON)
            val arm_body = parse_block()

            # Create an arm for each pattern (they share the same body and guard)
            for i in 0..patterns.len():
                val pattern_idx = patterns[i]
                val arm_idx = arm_new_with_binding(pattern_idx, guard_expr_idx, arm_body, pattern_binding)
                arm_indices.push(arm_idx)
        else:
            parser_error("expected 'case' in match block")
            parser_advance()

    stmt_match_stmt(scrutinee, arm_indices, 0)

fn parse_receive_stmt() -> i64:
    # Already consumed 'receive' keyword
    parser_expect(TOK_COLON)
    parser_skip_newlines()
    parser_expect(TOK_INDENT)

    var arm_indices: [i64] = []
    var timeout_expr: i64 = -1
    var timeout_body_idx: i64 = -1

    for i in 0..1000:
        parser_skip_newlines()
        if par_kind == TOK_DEDENT:
            parser_advance()
            break
        if par_kind == TOK_EOF:
            break

        if par_kind == TOK_KW_AFTER:
            # after TIMEOUT: body — timeout arm
            parser_advance()
            timeout_expr = parse_expr()
            parser_expect(TOK_COLON)
            val after_body = parse_block()
            val after_body_stmt_idx = stmt_block_stmt(after_body, 0)
            timeout_body_idx = after_body_stmt_idx
        elif par_kind == TOK_KW_CASE:
            parser_advance()
            var patterns: [i64] = []
            patterns.push(parse_expr())
            for skip_idx in 0..100:
                val is_nl = par_kind == TOK_NEWLINE
                val is_indent = par_kind == TOK_INDENT
                val should_skip = is_nl or is_indent
                if not should_skip:
                    break
                parser_advance()
            while par_kind == TOK_PIPE:
                parser_advance()
                for skip_idx in 0..100:
                    val is_nl = par_kind == TOK_NEWLINE
                    val is_indent = par_kind == TOK_INDENT
                    val should_skip = is_nl or is_indent
                    if not should_skip:
                        break
                    parser_advance()
                patterns.push(parse_expr())
            var guard_expr_idx: i64 = -1
            if par_kind == TOK_KW_IF:
                parser_advance()
                guard_expr_idx = parse_expr()
            parser_expect(TOK_COLON)
            val arm_body = parse_block()
            for j in 0..patterns.len():
                val pattern_idx = patterns[j]
                val arm_idx = arm_new_with_binding(pattern_idx, guard_expr_idx, arm_body, "")
                arm_indices.push(arm_idx)
        else:
            parser_error("expected 'case' or 'after' in receive block")
            parser_advance()

    stmt_receive_stmt(arm_indices, timeout_expr, timeout_body_idx, 0)

fn parse_bind_stmt() -> i64:
    # Already consumed 'bind' keyword
    val var_name = par_text
    parser_expect(TOK_IDENT)
    parser_expect(TOK_ASSIGN)
    val rhs = parse_expr()
    stmt_bind_stmt(var_name, rhs, 0)

fn parse_ce_decl() -> i64:
    # Already consumed 'ce' keyword
    val builder_name = par_text
    parser_expect(TOK_IDENT)
    parser_expect(TOK_COLON)
    val body = parse_block()
    decl_ce_block(builder_name, body, 0)

# ===== Declaration Parsing =====

fn parser_skip_tilde_if_present():
    # Skip ~ prefix for keyword-only parameter marker
    if par_kind == TOK_TILDE:
        parser_advance()

fn parser_expect_param_name():
    # Accept IDENT or SELF as parameter name
    val is_ident: bool = par_kind == TOK_IDENT
    val is_self: bool = par_kind == TOK_KW_SELF
    val is_valid: bool = is_ident or is_self
    if is_valid:
        parser_advance()
    else:
        parser_error("expected parameter name")
        parser_advance()

# ===== Generic Type Parameter Parsing =====

fn parse_type_params() -> [text]:
    # Parses <T>, <T, U>, etc. after function/class/struct name
    # Returns list of type parameter names (e.g., ["T", "U"])
    var type_params: [text] = []

    # Check for < token (either TOK_LT or TOK_LT_GENERIC)
    val has_lt: bool = par_kind == TOK_LT
    val has_lt_gen: bool = par_kind == TOK_LT_GENERIC
    val has_generic: bool = has_lt or has_lt_gen
    if not has_generic:
        return type_params

    parser_advance()

    # Parse first type parameter
    if par_kind != TOK_IDENT:
        parser_error("expected type parameter name")
        return type_params

    type_params.push(par_text)
    parser_advance()

    # Parse additional type parameters
    for i in 0..100:
        if par_kind != TOK_COMMA:
            break
        parser_advance()
        if par_kind != TOK_IDENT:
            parser_error("expected type parameter name")
            break
        type_params.push(par_text)
        parser_advance()

    # Expect closing >
    parser_expect(TOK_GT)

    type_params

fn parse_fn_decl(is_async: i64) -> i64:
    parser_advance()
    val fn_name = par_text
    parser_expect(TOK_IDENT)

    # Parse optional type parameters: fn name<T, U>(...)
    val type_params = parse_type_params()

    parser_expect(TOK_LPAREN)

    var param_names: [text] = []
    var param_types: [i64] = []

    if par_kind != TOK_RPAREN:
        # First parameter (skip ~ keyword-only marker if present)
        parser_skip_tilde_if_present()
        val pname = par_text
        parser_expect_param_name()
        param_names.push(pname)
        var ptype = 0
        if par_kind == TOK_COLON:
            parser_advance()
            ptype = parser_parse_type_with_union()
        param_types.push(ptype)

        for i in 0..100:
            if par_kind != TOK_COMMA:
                break
            parser_advance()
            if par_kind == TOK_RPAREN:
                break
            parser_skip_tilde_if_present()
            val pn = par_text
            parser_expect_param_name()
            param_names.push(pn)
            var pt = 0
            if par_kind == TOK_COLON:
                parser_advance()
                pt = parser_parse_type_with_union()
            param_types.push(pt)

    parser_expect(TOK_RPAREN)

    # Return type
    var ret_type = TYPE_VOID
    if par_kind == TOK_ARROW:
        parser_advance()
        ret_type = parser_parse_type_with_union()

    # Skip optional where clause: where T: Bound
    if par_kind == TOK_KW_WHERE:
        parser_advance()
        # Skip until the body colon
        for where_i in 0..200:
            val at_colon: bool = par_kind == TOK_COLON
            val at_eof: bool = par_kind == TOK_EOF
            if at_colon or at_eof:
                break
            parser_advance()

    # Function body
    parser_expect(TOK_COLON)
    val body = parse_block()

    decl_fn(fn_name, param_names, param_types, ret_type, body, is_async, type_params, 0)

fn parse_extern_fn_decl() -> i64:
    # Already consumed 'extern'
    parser_expect(TOK_KW_FN)
    val fn_name = par_text
    parser_expect(TOK_IDENT)

    # Parse optional type parameters: extern fn name<T>(...)
    val type_params = parse_type_params()

    parser_expect(TOK_LPAREN)

    var param_names: [text] = []
    var param_types: [i64] = []

    if par_kind != TOK_RPAREN:
        val pname = par_text
        parser_expect_param_name()
        param_names.push(pname)
        var ptype = 0
        if par_kind == TOK_COLON:
            parser_advance()
            ptype = parser_parse_type()
        param_types.push(ptype)

        for i in 0..100:
            if par_kind != TOK_COMMA:
                break
            parser_advance()
            if par_kind == TOK_RPAREN:
                break
            val pn = par_text
            parser_expect_param_name()
            param_names.push(pn)
            var pt = 0
            if par_kind == TOK_COLON:
                parser_advance()
                pt = parser_parse_type()
            param_types.push(pt)

    parser_expect(TOK_RPAREN)

    var ret_type = TYPE_VOID
    if par_kind == TOK_ARROW:
        parser_advance()
        ret_type = parser_parse_type()

    decl_extern_fn(fn_name, param_names, param_types, ret_type, type_params, 0)

fn parse_struct_decl() -> i64:
    parser_advance()
    val struct_name = par_text
    parser_expect(TOK_IDENT)
    par_struct_names.push(struct_name)

    # Parse optional type parameters: class Box<T>:, struct Node<T>:
    val type_params = parse_type_params()

    # Pre-register struct name so type references resolve during parsing
    named_type_register(struct_name, [], [])
    # Handle struct inheritance: struct X(Parent):
    if par_kind == TOK_LPAREN:
        parser_advance()
        # Skip parent type name(s)
        for i in 0..10:
            if par_kind == TOK_RPAREN:
                break
            parser_advance()
        parser_expect(TOK_RPAREN)
    # Handle "with" mixin: struct X with Y:
    if par_kind == TOK_IDENT:
        if par_text == "with":
            parser_advance()
            parser_expect(TOK_IDENT)
    parser_expect(TOK_COLON)
    parser_skip_newlines()
    parser_expect(TOK_INDENT)

    var field_names: [text] = []
    var field_types: [i64] = []
    var field_defaults: [i64] = []
    var class_method_ids: [i64] = []

    for i in 0..1000:
        parser_skip_newlines()
        if par_kind == TOK_DEDENT:
            parser_advance()
            break
        if par_kind == TOK_EOF:
            break

        # Skip docstrings in class/struct body
        if par_kind == TOK_STRING_LIT:
            parser_advance()
            parser_skip_newlines_and_semicolons()
            continue

        # Associated types: type Item = T (skip for now, just parse and ignore)
        if par_kind == TOK_KW_TYPE:
            parser_advance()
            # Skip: 'type IDENT' or 'type IDENT = Type'
            if par_kind == TOK_IDENT:
                parser_advance()
            if par_kind == TOK_ASSIGN:
                parser_advance()
                parser_parse_type()
            parser_skip_newlines_and_semicolons()
            continue

        # Handle methods in class/struct body
        if par_kind == TOK_KW_STATIC:
            val sm_id = parse_class_body_method(struct_name, true, false)
            if sm_id >= 0:
                class_method_ids.push(sm_id)
            continue
        if par_kind == TOK_KW_FN:
            val fm_id = parse_class_body_method(struct_name, false, false)
            if fm_id >= 0:
                class_method_ids.push(fm_id)
            continue
        if par_kind == TOK_KW_ME:
            val mm_id = parse_class_body_method(struct_name, false, true)
            if mm_id >= 0:
                class_method_ids.push(mm_id)
            continue

        val fname = par_text
        parser_expect(TOK_IDENT)
        parser_expect(TOK_COLON)
        val ftype = parser_parse_type()
        field_names.push(fname)
        field_types.push(ftype)
        var fdefault: i64 = -1
        if par_kind == TOK_ASSIGN:
            parser_advance()
            fdefault = parse_expr()
        field_defaults.push(fdefault)
        parser_skip_newlines_and_semicolons()

    val struct_d = decl_struct_def(struct_name, field_names, field_types, field_defaults, 0)

    # If class had methods, create an impl block for them
    if class_method_ids.len() > 0:
        val impl_d = decl_impl_block(struct_name, class_method_ids, 0)
        module_add_decl(impl_d)

    struct_d

fn parse_enum_decl() -> i64:
    parser_advance()
    val enum_name = par_text
    parser_expect(TOK_IDENT)

    # Parse optional type parameters: enum Result<T, E>:
    val type_params = parse_type_params()

    parser_expect(TOK_COLON)
    parser_skip_newlines()
    parser_expect(TOK_INDENT)

    var variant_names: [text] = []

    for i in 0..1000:
        parser_skip_newlines()
        if par_kind == TOK_DEDENT:
            parser_advance()
            break
        if par_kind == TOK_EOF:
            break

        # Skip docstrings in enum body
        if par_kind == TOK_STRING_LIT:
            parser_advance()
            parser_skip_newlines_and_semicolons()
            continue

        # Skip comments that may appear as idents
        val vname = par_text
        parser_expect(TOK_IDENT)
        # Handle enum variant data: Variant(field: type, ...)
        if par_kind == TOK_LPAREN:
            parser_advance()
            for j in 0..100:
                if par_kind == TOK_RPAREN:
                    break
                if par_kind == TOK_EOF:
                    break
                # Skip field_name: type pairs
                if par_kind == TOK_IDENT:
                    parser_advance()
                    if par_kind == TOK_COLON:
                        parser_advance()
                        parser_parse_type()
                        # Handle optional ? after type
                        if par_kind == TOK_QUESTION:
                            parser_advance()
                elif par_kind == TOK_LBRACKET:
                    parser_parse_type()
                else:
                    parser_advance()
                if par_kind == TOK_COMMA:
                    parser_advance()
            parser_expect(TOK_RPAREN)
        variant_names.push(vname)
        parser_skip_newlines_and_semicolons()

    decl_enum_def(enum_name, variant_names, 0)

fn parse_use_decl() -> i64:
    parser_advance()
    # Check for 'use lazy' modifier
    var is_lazy = 0
    if par_kind == TOK_KW_LAZY:
        is_lazy = 1
        parser_advance()
    # Handle relative imports: use .X or use ..X
    var module_path: text = ""
    if par_kind == TOK_DOTDOT:
        parser_advance()
        module_path = ".."
        if par_kind == TOK_DOT:
            parser_advance()
            module_path = "..."
    elif par_kind == TOK_DOT:
        parser_advance()
        module_path = "."

    # Parse module path: a.b.c
    if par_kind == TOK_IDENT:
        if module_path != "":
            module_path = module_path + par_text
        else:
            module_path = par_text
        parser_advance()
    for i in 0..100:
        if par_kind != TOK_DOT:
            break
        parser_advance()
        # Check for {name1, name2} import list
        if par_kind == TOK_LBRACE:
            break
        if par_kind == TOK_LPAREN:
            break
        # Wildcard import: use X.*
        if par_kind == TOK_STAR:
            parser_advance()
            val wc_result = decl_use_import(module_path, [], 0)
            if is_lazy == 1:
                decl_set_lazy(wc_result)
            return wc_result
        module_path = module_path + "." + par_text
        parser_expect(TOK_IDENT)
        # Check for trailing * without dot: use ffi.io*
        if par_kind == TOK_STAR:
            parser_advance()
            val wc2_result = decl_use_import(module_path, [], 0)
            if is_lazy == 1:
                decl_set_lazy(wc2_result)
            return wc2_result

    # Optional import list: .{name1, name2} or .(name1, name2)
    var imported_names: [text] = []
    val has_brace: bool = par_kind == TOK_LBRACE
    val has_paren: bool = par_kind == TOK_LPAREN
    val has_import_list: bool = has_brace or has_paren
    if has_import_list:
        parser_advance()
        for i in 0..100:
            val at_c1: bool = par_kind == TOK_RBRACE
            val at_c2: bool = par_kind == TOK_RPAREN
            val at_c: bool = at_c1 or at_c2
            if at_c:
                break
            if par_kind == TOK_EOF:
                break
            if par_kind == TOK_IDENT:
                val orig_name = par_text
                parser_advance()
                # Support aliasing: name as alias
                val is_as: bool = par_kind == TOK_IDENT
                val as_text: bool = par_text == "as"
                val has_as: bool = is_as and as_text
                if has_as:
                    parser_advance()  # consume "as"
                    val alias_name = par_text
                    parser_advance()  # consume alias
                    imported_names.push(orig_name + ":" + alias_name)
                else:
                    imported_names.push(orig_name)
            if par_kind == TOK_COMMA:
                parser_advance()
        # Consume closing ) or }
        val is_rb: bool = par_kind == TOK_RBRACE
        val is_rp: bool = par_kind == TOK_RPAREN
        val is_close: bool = is_rb or is_rp
        if is_close:
            parser_advance()

    val use_result = decl_use_import(module_path, imported_names, 0)
    if is_lazy == 1:
        decl_set_lazy(use_result)
    use_result

fn parse_export_decl() -> i64:
    parser_advance()
    var names: [text] = []
    val first_name = par_text
    parser_expect(TOK_IDENT)
    # Support aliasing: name as alias
    val first_is_as: bool = (par_kind == TOK_IDENT) and (par_text == "as")
    if first_is_as:
        parser_advance()  # consume "as"
        val first_alias = par_text
        parser_advance()  # consume alias
        names.push(first_name + ":" + first_alias)
    else:
        names.push(first_name)
    for i in 0..100:
        if par_kind != TOK_COMMA:
            break
        parser_advance()
        val loop_name = par_text
        parser_expect(TOK_IDENT)
        # Support aliasing: name as alias
        val loop_is_as: bool = (par_kind == TOK_IDENT) and (par_text == "as")
        if loop_is_as:
            parser_advance()  # consume "as"
            val loop_alias = par_text
            parser_advance()  # consume alias
            names.push(loop_name + ":" + loop_alias)
        else:
            names.push(loop_name)
    decl_export_names(names, 0)

fn parse_val_decl() -> i64:
    parser_advance()
    val name = par_text
    parser_expect(TOK_IDENT)

    var type_tag = 0
    if par_kind == TOK_COLON:
        parser_advance()
        type_tag = parser_parse_type_with_union()

    parser_expect(TOK_ASSIGN)
    val init = parse_expr()
    decl_val_binding(name, type_tag, init, 0)

fn parse_lazy_val_decl() -> i64:
    parser_advance()
    val name = par_text
    parser_expect(TOK_IDENT)

    var type_tag = 0
    if par_kind == TOK_COLON:
        parser_advance()
        type_tag = parser_parse_type_with_union()

    parser_expect(TOK_ASSIGN)
    val init = parse_expr()
    decl_lazy_val_binding(name, type_tag, init, 0)

fn parse_var_decl() -> i64:
    parser_advance()
    val name = par_text
    parser_expect(TOK_IDENT)

    var type_tag = 0
    if par_kind == TOK_COLON:
        parser_advance()
        type_tag = parser_parse_type_with_union()

    parser_expect(TOK_ASSIGN)
    val init = parse_expr()
    decl_var_binding(name, type_tag, init, 0)

# ===== Expression-Level Control Flow (for module-level statements) =====

fn parse_if_expr() -> i64:
    parser_advance()
    val cond = parse_expr()
    parser_expect(TOK_COLON)
    val then_body = parse_block()
    val then_expr = expr_block(then_body, -1, 0)
    parser_skip_newlines()
    var else_expr: i64 = expr_unit(0)
    if par_kind == TOK_KW_ELIF:
        else_expr = parse_if_expr()
    elif par_kind == TOK_KW_ELSE:
        parser_advance()
        parser_expect(TOK_COLON)
        val else_body = parse_block()
        else_expr = expr_block(else_body, -1, 0)
    expr_if_expr(cond, then_expr, else_expr, 0)

fn parse_for_expr() -> i64:
    parser_advance()
    val iter_name = par_text
    parser_expect(TOK_IDENT)
    parser_expect(TOK_KW_IN)
    val iterable = parse_expr()
    parser_expect(TOK_COLON)
    val body = parse_block()
    expr_for_expr(iter_name, iterable, body, 0)

fn parse_while_expr() -> i64:
    parser_advance()
    val cond = parse_expr()
    parser_expect(TOK_COLON)
    val body = parse_block()
    expr_while_expr(cond, body, 0)

# ===== Class/Impl Method Parsing =====

fn parse_class_body_method(struct_name: text, is_static: bool, is_me: bool) -> i64:
    # Advance past leading keyword (static fn / fn / me)
    if is_static:
        if par_kind == TOK_KW_STATIC:
            parser_advance()
        if par_kind == TOK_KW_FN:
            parser_advance()
    elif is_me:
        parser_advance()
    else:
        if par_kind == TOK_KW_FN:
            parser_advance()

    val method_name = par_text
    parser_expect(TOK_IDENT)

    # Parse optional type parameters: fn map<U>(...)
    val type_params = parse_type_params()

    parser_expect(TOK_LPAREN)

    var param_names: [text] = []
    var param_types: [i64] = []

    if par_kind != TOK_RPAREN:
        val pname = par_text
        parser_expect(TOK_IDENT)
        param_names.push(pname)
        var ptype = 0
        if par_kind == TOK_COLON:
            parser_advance()
            ptype = parser_parse_type()
        param_types.push(ptype)

        for i in 0..100:
            if par_kind != TOK_COMMA:
                break
            parser_advance()
            val pn = par_text
            parser_expect(TOK_IDENT)
            param_names.push(pn)
            var pt = 0
            if par_kind == TOK_COLON:
                parser_advance()
                pt = parser_parse_type()
            param_types.push(pt)

    parser_expect(TOK_RPAREN)

    var ret_type = TYPE_VOID
    if par_kind == TOK_ARROW:
        parser_advance()
        ret_type = parser_parse_type()

    parser_expect(TOK_COLON)
    val body = parse_block()

    val mangled_name: text = struct_name + "__" + method_name
    # static_flag: 0=fn (immutable self), 1=static (no self), 2=me (mutable self)
    var static_flag: i64 = 0
    if is_static:
        static_flag = 1
    if is_me:
        static_flag = 2
    val mid = decl_fn(mangled_name, param_names, param_types, ret_type, body, static_flag, type_params, 0)
    return mid

fn parse_impl_decl() -> i64:
    # impl StructName:
    parser_advance()
    val target_name = par_text
    parser_expect(TOK_IDENT)
    parser_expect(TOK_COLON)
    parser_skip_newlines()
    parser_expect(TOK_INDENT)

    var method_ids: [i64] = []

    for i in 0..1000:
        parser_skip_newlines()
        if par_kind == TOK_DEDENT:
            parser_advance()
            break
        if par_kind == TOK_EOF:
            break

        # Skip docstrings in impl body
        if par_kind == TOK_STRING_LIT:
            parser_advance()
            parser_skip_newlines_and_semicolons()
            continue
        if par_kind == TOK_KW_STATIC:
            val sm_id = parse_class_body_method(target_name, true, false)
            if sm_id >= 0:
                method_ids.push(sm_id)
        elif par_kind == TOK_KW_FN:
            val fm_id = parse_class_body_method(target_name, false, false)
            if fm_id >= 0:
                method_ids.push(fm_id)
        elif par_kind == TOK_KW_ME:
            val mm_id = parse_class_body_method(target_name, false, true)
            if mm_id >= 0:
                method_ids.push(mm_id)
        else:
            # Skip unknown tokens in impl body gracefully
            parser_advance()

    decl_impl_block(target_name, method_ids, 0)

# ===== Top-Level Module Parsing =====

fn parse_module_body():
    for i in 0..100000:
        parser_skip_newlines_and_semicolons()
        if par_kind == TOK_EOF:
            break
        if par_kind == TOK_DEDENT:
            # Stray dedent at module level — skip it
            parser_advance()
        elif par_kind == TOK_KW_ASYNC:
            # Async function: async fn name()
            parser_advance()
            if par_kind == TOK_KW_FN:
                val d = parse_fn_decl(1)  # 1 = is_async
                module_add_decl(d)
            else:
                parser_error("expected 'fn' after 'async'")
        elif par_kind == TOK_KW_FN:
            val d = parse_fn_decl(0)  # 0 = not async
            module_add_decl(d)
        elif par_kind == TOK_KW_EXTERN:
            parser_advance()
            val d = parse_extern_fn_decl()
            module_add_decl(d)
        elif par_kind == TOK_KW_STRUCT:
            val d = parse_struct_decl()
            module_add_decl(d)
        elif par_kind == TOK_KW_ENUM:
            val d = parse_enum_decl()
            module_add_decl(d)
        elif par_kind == TOK_KW_CLASS:
            # class is treated like struct (fields + methods)
            val d = parse_struct_decl()
            module_add_decl(d)
        elif par_kind == TOK_KW_IMPL:
            val d = parse_impl_decl()
            module_add_decl(d)
        elif par_kind == TOK_KW_USE:
            val d = parse_use_decl()
            module_add_decl(d)
        elif par_kind == TOK_KW_EXPORT:
            val d = parse_export_decl()
            module_add_decl(d)
        elif par_kind == TOK_KW_VAL:
            val d = parse_val_decl()
            module_add_decl(d)
        elif par_kind == TOK_KW_LAZY:
            parser_advance()
            val d = parse_lazy_val_decl()
            module_add_decl(d)
        elif par_kind == TOK_KW_VAR:
            val d = parse_var_decl()
            module_add_decl(d)
        elif par_kind == TOK_KW_CONST:
            # const fn name(): or const binding: same as val/fn at module level
            parser_advance()
            if par_kind == TOK_KW_FN:
                # const fn — parse as normal function
                val cfd = parse_fn_decl(0)
                module_add_decl(cfd)
            else:
                val const_name = par_text
                parser_expect(TOK_IDENT)
                var const_type = 0
                if par_kind == TOK_COLON:
                    parser_advance()
                    const_type = parser_parse_type_with_union()
                parser_expect(TOK_ASSIGN)
                val const_init = parse_expr()
                val cd = decl_val_binding(const_name, const_type, const_init, 0)
                module_add_decl(cd)
        elif par_kind == TOK_KW_IF:
            val if_expr = parse_if_expr()
            val d = decl_val_binding("_if_" + int_to_str(i), -1, if_expr, 0)
            module_add_decl(d)
        elif par_kind == TOK_KW_FOR:
            val for_expr = parse_for_expr()
            val d = decl_val_binding("_for_" + int_to_str(i), -1, for_expr, 0)
            module_add_decl(d)
        elif par_kind == TOK_KW_WHILE:
            val while_expr = parse_while_expr()
            val d = decl_val_binding("_while_" + int_to_str(i), -1, while_expr, 0)
            module_add_decl(d)
        elif par_kind == TOK_KW_IMPORT:
            # import X.{Y, Z} — treat like use
            val d = parse_use_decl()
            module_add_decl(d)
        elif par_kind == TOK_KW_TRAIT:
            # trait is parsed like struct (skip body)
            val d = parse_struct_decl()
            module_add_decl(d)
        elif par_kind == TOK_KW_EXTEND:
            # extend TypeName: adds methods to an existing type
            val d = parse_impl_decl()
            module_add_decl(d)
        elif par_kind == TOK_KW_CE:
            # ce NAME: computation expression block at module level
            parser_advance()
            val ce_d = parse_ce_decl()
            module_add_decl(ce_d)
        elif par_kind == TOK_KW_NEWTYPE:
            # newtype Meters = i64 — wrapper struct with single 'value' field
            parser_advance()
            val nt_name = par_text
            parser_expect(TOK_IDENT)
            parser_expect(TOK_ASSIGN)
            val inner_type = parser_parse_type()
            val nt_field_names: [text] = ["value"]
            val nt_field_types: [i64] = [inner_type]
            val nt_field_defaults: [i64] = [-1]
            val nt_d = decl_struct_def(nt_name, nt_field_names, nt_field_types, nt_field_defaults, 0)
            module_add_decl(nt_d)
            parser_skip_newlines_and_semicolons()
        elif par_kind == TOK_STRING_LIT:
            # Skip module-level docstrings
            parser_advance()
            parser_skip_newlines_and_semicolons()
        elif par_kind == TOK_KW_TYPE:
            # Type alias: type X = Y — skip it
            parser_advance()
            # Skip until newline
            for j in 0..1000:
                val type_is_nl: bool = par_kind == TOK_NEWLINE
                val type_is_ded: bool = par_kind == TOK_DEDENT
                val type_is_eof: bool = par_kind == TOK_EOF
                val type_done: bool = type_is_nl or type_is_ded
                val type_done2: bool = type_done or type_is_eof
                if type_done2:
                    break
                parser_advance()
            parser_skip_newlines_and_semicolons()
        elif par_kind == TOK_KW_ASM:
            val asm_expr = parse_expr()
            val d = decl_val_binding("_asm_" + int_to_str(i), -1, asm_expr, 0)
            module_add_decl(d)
            parser_skip_newlines_and_semicolons()
        elif par_kind == TOK_INDENT:
            # Stray indent at module level — skip it
            parser_advance()
        else:
            # Handle bare 'print' and 'from' at module level
            if par_kind == TOK_IDENT:
                if par_text == "from":
                    # from X import {Y, Z}
                    parser_advance()
                    var from_path: text = ""
                    if par_kind == TOK_IDENT:
                        from_path = par_text
                        parser_advance()
                    for j in 0..100:
                        if par_kind != TOK_DOT:
                            break
                        parser_advance()
                        if par_kind == TOK_IDENT:
                            from_path = from_path + "." + par_text
                            parser_advance()
                        else:
                            break
                    # Expect 'import' keyword
                    if par_kind == TOK_KW_IMPORT:
                        parser_advance()
                    # Parse import list {name1, name2}
                    var from_names: [text] = []
                    val from_has_brace: bool = par_kind == TOK_LBRACE
                    val from_has_paren: bool = par_kind == TOK_LPAREN
                    val from_has_list: bool = from_has_brace or from_has_paren
                    if from_has_list:
                        parser_advance()
                        for j in 0..100:
                            val from_at_end1: bool = par_kind == TOK_RBRACE
                            val from_at_end2: bool = par_kind == TOK_RPAREN
                            val from_at_end: bool = from_at_end1 or from_at_end2
                            if from_at_end:
                                break
                            if par_kind == TOK_EOF:
                                break
                            if par_kind == TOK_IDENT:
                                from_names.push(par_text)
                                parser_advance()
                            if par_kind == TOK_COMMA:
                                parser_advance()
                        parser_advance()
                    val fd = decl_use_import(from_path, from_names, 0)
                    module_add_decl(fd)
                    parser_skip_newlines_and_semicolons()
                elif par_text == "comptime":
                    # comptime val name = expr — evaluated eagerly (treat like val)
                    parser_advance()
                    if par_kind == TOK_KW_VAL or par_kind == TOK_KW_VAR:
                        val d = parse_val_decl()
                        module_add_decl(d)
                    elif par_kind == TOK_KW_FN:
                        val ctfd = parse_fn_decl(0)
                        decl_set_comptime(ctfd)
                        module_add_decl(ctfd)
                    elif par_kind == TOK_COLON:
                        # comptime: block at module level — wrap body stmts in an expr_block
                        parser_advance()
                        val ct_blk_body = parse_block()
                        val ct_blk_unit = expr_unit(0)
                        val ct_blk_expr = expr_block(ct_blk_body, ct_blk_unit, 0)
                        val ctbd = decl_val_binding("_ct_blk_" + int_to_str(i), -1, ct_blk_expr, 0)
                        module_add_decl(ctbd)
                    else:
                        val ct_expr = parse_expr()
                        val ctd = decl_val_binding("_ct_" + int_to_str(i), -1, ct_expr, 0)
                        module_add_decl(ctd)
                    parser_skip_newlines_and_semicolons()
                elif par_text == "print":
                    parser_advance()
                    val is_nl = par_kind == TOK_NEWLINE
                    val is_ded = par_kind == TOK_DEDENT
                    val is_eof = par_kind == TOK_EOF
                    val no_arg = is_nl or is_ded
                    val no_arg2 = no_arg or is_eof
                    var print_call: i64 = 0
                    if no_arg2:
                        val callee0 = expr_ident("print", 0)
                        var args0: [i64] = []
                        print_call = expr_call(callee0, args0, 0)
                    else:
                        val print_arg = parse_expr()
                        val callee1 = expr_ident("print", 0)
                        var args1: [i64] = []
                        args1.push(print_arg)
                        print_call = expr_call(callee1, args1, 0)
                    val d = decl_val_binding("_expr_" + int_to_str(i), -1, print_call, 0)
                    module_add_decl(d)
                    parser_skip_newlines_and_semicolons()
                else:
                    val expression = parse_expr()
                    val d = decl_val_binding("_expr_" + int_to_str(i), -1, expression, 0)
                    module_add_decl(d)
                    parser_skip_newlines_and_semicolons()
            else:
                # Module-level expression/statement
                val expression = parse_expr()
                val d = decl_val_binding("_expr_" + int_to_str(i), -1, expression, 0)
                module_add_decl(d)
                parser_skip_newlines_and_semicolons()

fn parse_module(source: text, path: text):
    val preprocessed = _pp_preprocess_conditionals(source)
    parser_init(preprocessed)
    module_set_path(path)
    parse_module_body()

fn parse_module_file(source: text, path: text):
    # Parse additional file without resetting AST
    val preprocessed = _pp_preprocess_conditionals(source)
    lex_init(preprocessed)
    par_errors = []
    par_had_error = false
    parser_advance()
    module_set_path(path)
    parse_module_body()

fn preprocess_conditionals(source: text) -> text:
    _pp_preprocess_conditionals(source)

fn parser_has_errors() -> bool:
    par_had_error

fn parser_get_errors() -> [text]:
    par_errors

fn parser_error_count() -> i64:
    par_errors.len()

# ===== Exports =====

export parser_init, parser_advance, parser_check, parser_match_tok, parser_expect
export parser_error, parser_skip_newlines, parser_skip_newlines_and_semicolons
export parser_parse_type
export parse_expr, parse_assignment, parse_or, parse_and, parse_not
export parse_comparison, parse_null_coalesce, parse_range
export parse_addition, parse_multiplication, parse_unary, parse_postfix, parse_primary
export parse_call_arg, parse_postfix_on, parse_binary_from
export parse_block, parse_statement
export parse_val_decl_stmt, parse_lazy_val_decl_stmt, parse_var_decl_stmt
export parse_if_stmt, parse_for_stmt, parse_while_stmt, parse_match_stmt
export parse_receive_stmt, parse_bind_stmt, parse_ce_decl
export parse_if_expr, parse_for_expr, parse_while_expr
export parse_fn_decl, parse_extern_fn_decl, parse_struct_decl, parse_enum_decl
export parse_impl_decl, parse_class_body_method
export parse_use_decl, parse_export_decl, parse_val_decl, parse_lazy_val_decl, parse_var_decl
export parse_module, parse_module_file, parse_module_body
export preprocess_conditionals
export parser_has_errors, parser_get_errors, parser_error_count
export par_kind, par_text, par_line, par_col, par_errors, par_had_error
