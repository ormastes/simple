# Interpreter Resource Tracker — per-module name tracking for selective unload.
#
# Tracks which functions, structs, enums, and globals belong to each loaded
# module.  When a module is unloaded, all its names are removed from the
# interpreter's function table, struct table, enum registry, and global env.
#
# Uses parallel arrays (arena pattern) to stay seed-compilable.

# ============================================================================
# Tracking Arrays
# ============================================================================

# Each index corresponds to one loaded module.
var irt_paths: [text] = []         # module paths (key)
var irt_funcs: [[text]] = []       # per-module function names
var irt_structs: [[text]] = []     # per-module struct names
var irt_enums: [[text]] = []       # per-module enum names
var irt_globals: [[text]] = []     # per-module global var names

# ============================================================================
# Init / Reset
# ============================================================================

fn irt_init():
    irt_paths = []
    irt_funcs = []
    irt_structs = []
    irt_enums = []
    irt_globals = []

# ============================================================================
# Module Registration
# ============================================================================

fn irt_begin_module(module_path: text):
    """Start tracking a new module. Call before registering its names."""
    # Check if already tracked (idempotent)
    var i: i64 = 0
    for p in irt_paths:
        if p == module_path:
            return
        i = i + 1
    irt_paths.push(module_path)
    irt_funcs.push([])
    irt_structs.push([])
    irt_enums.push([])
    irt_globals.push([])

fn irt_find_index(module_path: text) -> i64:
    """Find the index for a module path. Returns -1 if not tracked."""
    var i: i64 = 0
    for p in irt_paths:
        if p == module_path:
            return i
        i = i + 1
    -1

# ============================================================================
# Name Registration Hooks
# ============================================================================

fn irt_track_func(module_path: text, name: text):
    """Record that a function was registered for a module."""
    val idx = irt_find_index(module_path)
    if idx < 0: return
    var names = irt_funcs[idx]
    names.push(name)
    irt_funcs[idx] = names

fn irt_track_struct(module_path: text, name: text):
    """Record that a struct was registered for a module."""
    val idx = irt_find_index(module_path)
    if idx < 0: return
    var names = irt_structs[idx]
    names.push(name)
    irt_structs[idx] = names

fn irt_track_enum(module_path: text, name: text):
    """Record that an enum was registered for a module."""
    val idx = irt_find_index(module_path)
    if idx < 0: return
    var names = irt_enums[idx]
    names.push(name)
    irt_enums[idx] = names

fn irt_track_global(module_path: text, name: text):
    """Record that a global variable was defined for a module."""
    val idx = irt_find_index(module_path)
    if idx < 0: return
    var names = irt_globals[idx]
    names.push(name)
    irt_globals[idx] = names

# ============================================================================
# Unload — selective cleanup
# ============================================================================

fn irt_unload_module(module_path: text) -> i64:
    """Remove all names registered by a module.

    Calls func_table_remove, struct_table_remove, enum_table_remove,
    and env_remove_global for each tracked name.

    Returns the total number of names removed, or 0 if module not tracked.
    """
    val idx = irt_find_index(module_path)
    if idx < 0: return 0

    var removed: i64 = 0

    # Remove functions
    val funcs = irt_funcs[idx]
    for name in funcs:
        if func_table_remove(name):
            removed = removed + 1
        func_remove_return_type(name)

    # Remove structs
    val structs = irt_structs[idx]
    for name in structs:
        if struct_table_remove(name):
            removed = removed + 1

    # Remove enums
    val enums = irt_enums[idx]
    for name in enums:
        if enum_table_remove(name):
            removed = removed + 1

    # Remove globals
    val globals = irt_globals[idx]
    for name in globals:
        if env_remove_global(name):
            removed = removed + 1

    # Tombstone this slot (don't shift arrays)
    irt_paths[idx] = ""
    irt_funcs[idx] = []
    irt_structs[idx] = []
    irt_enums[idx] = []
    irt_globals[idx] = []

    removed

# ============================================================================
# Query
# ============================================================================

fn irt_is_tracked(module_path: text) -> bool:
    irt_find_index(module_path) >= 0

fn irt_tracked_count() -> i64:
    """Number of actively tracked modules (excludes tombstones)."""
    var count: i64 = 0
    for p in irt_paths:
        if p != "":
            count = count + 1
    count

fn irt_get_func_count(module_path: text) -> i64:
    val idx = irt_find_index(module_path)
    if idx < 0: return 0
    irt_funcs[idx].len()

fn irt_get_struct_count(module_path: text) -> i64:
    val idx = irt_find_index(module_path)
    if idx < 0: return 0
    irt_structs[idx].len()

# ============================================================================
# Exports
# ============================================================================

export irt_init
export irt_begin_module, irt_find_index
export irt_track_func, irt_track_struct, irt_track_enum, irt_track_global
export irt_unload_module
export irt_is_tracked, irt_tracked_count
export irt_get_func_count, irt_get_struct_count
