# Core Interpreter — Tree-Walking Evaluator
#
# Seed-compilable evaluator for core.ast arena-based AST.
# Dispatches on expr/stmt/decl tags to evaluate the program.
#
# All evaluation returns a value_id (i64). Errors indicated by -1 (VAL_NONE).
#
# Control flow (return/break/continue) uses global flags since we cannot
# use exceptions or Result types in seed-compiled code.

# ===== Coverage Instrumentation =====
extern fn rt_coverage_enabled() -> bool
extern fn rt_coverage_decision_probe(file: text, line: i64, decision_id: i64, taken: bool)
extern fn rt_env_get(key: text) -> text

var coverage_counter: i64 = 0

fn record_decision(file: text, line: i64, taken: bool):
    if rt_coverage_enabled():
        coverage_counter = coverage_counter + 1
        rt_coverage_decision_probe(file, line, coverage_counter, taken)

# ===== Type Checking Integration =====
# Basic runtime type checking for function parameters

use compiler.core.types.{TYPE_VOID, TYPE_BOOL, TYPE_I64, TYPE_F64, TYPE_TEXT, TYPE_ANY}
use compiler.core.types.{TYPE_NAMED_BASE, TYPE_STRUCT, named_type_name, type_tag_name}

# ===== Structural Subtyping =====
# Check if a struct value has all the fields declared in a named struct type.
# This implements Go-style structural subtyping / duck typing:
# if struct A has all fields of struct B, then A satisfies B.
#
# Parameters:
#   vid           - value_id of the struct value being checked
#   expected_name - name of the expected struct type (e.g. "OrderRepoPort")
#
# Returns true if the value has all required fields, false otherwise.
fn struct_satisfies(vid: i64, expected_name: text) -> bool:
    # Look up the expected struct declaration by name
    val decl_id = struct_table_lookup(expected_name)
    if decl_id < 0:
        # Unknown expected type — allow (cannot validate)
        return true
    # Get the field names that the expected type requires
    val required_fields = decl_get_fields(decl_id)
    if required_fields.len() == 0:
        # No required fields — any struct satisfies an empty struct
        return true
    # Check that the actual struct value has each required field
    for fname in required_fields:
        val fi = val_struct_find_field_idx(vid, fname)
        if fi < 0:
            return false
    true

fn type_check_value(value_id: i64, expected_type: i64) -> bool:
    # TYPE_ANY or TYPE_VOID means no constraint
    if expected_type == TYPE_ANY or expected_type == TYPE_VOID:
        return true

    # Get actual type from value
    val kind = val_kind(value_id)

    # Value kind constants (from value.spl)
    val VAL_NIL: i64 = 0
    val VAL_BOOL: i64 = 1
    val VAL_INT: i64 = 2
    val VAL_FLOAT: i64 = 3
    val VAL_TEXT: i64 = 4

    # Check type match
    if expected_type == TYPE_BOOL:
        return kind == VAL_BOOL
    if expected_type == TYPE_I64:
        return kind == VAL_INT
    if expected_type == TYPE_F64:
        return kind == VAL_FLOAT
    if expected_type == TYPE_TEXT:
        return kind == VAL_TEXT

    # Structural subtyping for named struct types (TYPE_NAMED_BASE + id)
    # If expected type is a named struct, check structural compatibility:
    # the actual value must be a struct with all required fields.
    if expected_type >= TYPE_NAMED_BASE:
        if kind != VAL_STRUCT:
            # Non-struct value cannot satisfy a struct type
            return false
        val nid = expected_type - TYPE_NAMED_BASE
        val expected_name = named_type_name(nid)
        if expected_name == "":
            return true
        # Same type name — exact match, always compatible
        val actual_name = val_get_struct_name(value_id)
        if actual_name == expected_name:
            return true
        # Different type name — apply structural subtyping check
        return struct_satisfies(value_id, expected_name)

    # TYPE_STRUCT (generic struct tag) — any struct satisfies
    if expected_type == TYPE_STRUCT:
        return kind == VAL_STRUCT

    # Default: allow if we don't recognize the type
    true

# ===== Type Erasure / Monomorphization Support =====
# Cache and specialization logic live in core.monomorphize (shared module).
# Interpreter-specific type inference from runtime values stays here.
use compiler.core.monomorphize.{mono_cache_init, mono_cache_lookup, mono_cache_register, mono_specialize}

fn infer_type_args_from_values(arg_values: [i64]) -> text:
    # Infer type arguments from runtime values
    # Simple approach: concatenate type kinds
    var type_str: text = ""
    for av in arg_values:
        val kind = val_kind(av)
        if type_str != "":
            type_str = type_str + "_"
        type_str = type_str + str(kind)
    type_str

fn infer_type_tags_from_values(arg_values: [i64]) -> [i64]:
    """Infer concrete type tags from runtime argument values

    Maps value kinds to type tags:
    - VAL_INT (2) → TYPE_I64 (2)
    - VAL_FLOAT (3) → TYPE_F64 (3)
    - VAL_TEXT (4) → TYPE_TEXT (4)
    - VAL_BOOL (1) → TYPE_BOOL (1)
    - Others → TYPE_ANY (12)
    """
    var type_tags: [i64] = []
    for av in arg_values:
        val kind = val_kind(av)
        # Value kinds align with type tags for primitives
        if kind == 1:  # VAL_BOOL
            type_tags.push(TYPE_BOOL)
        elif kind == 2:  # VAL_INT
            type_tags.push(TYPE_I64)
        elif kind == 3:  # VAL_FLOAT
            type_tags.push(TYPE_F64)
        elif kind == 4:  # VAL_TEXT
            type_tags.push(TYPE_TEXT)
        else:
            type_tags.push(TYPE_ANY)
    type_tags

# ===== Local AST Constants for static_for and comptime =====
# STMT_STATIC_FOR = 17 (from ast.spl, avoids import dependency)
val EVAL_STMT_STATIC_FOR: i64 = 17
# STMT_COMPTIME = 18 (from ast.spl, avoids import dependency)
val EVAL_STMT_COMPTIME: i64 = 18
# STMT_BIND = 20 (from ast.spl, avoids import dependency)
val EVAL_STMT_BIND: i64 = 20
# STMT_LAZY_VAL_DECL = 21 (from ast.spl, avoids import dependency)
val EVAL_STMT_LAZY_VAL_DECL: i64 = 21
# DECL_LAZY_VAL = 12 (from ast.spl, avoids import dependency)
val EVAL_DECL_LAZY_VAL: i64 = 12

# ===== Control Flow Flags =====
var eval_returning: bool = false
var eval_return_value: i64 = -1
var eval_breaking: bool = false
var eval_continuing: bool = false
var eval_had_error: bool = false
var eval_error_msg: text = ""
# Labeled break/continue: target label name (empty = unlabeled)
var eval_break_label: text = ""
var eval_continue_label: text = ""
# Label stack: names of currently active loop labels (innermost last)
var eval_label_stack: [text] = []

# ===== Defer Stack =====
# Flat parallel arrays: expression IDs and their block scope depth.
var eval_defer_eids: [i64] = []
var eval_defer_depths: [i64] = []
var eval_defer_depth: i64 = 0

# ===== Yield Accumulator Stack =====
var eval_yield_stack: [[i64]] = []

# ===== LOAD_FAST: Current Function Tracking =====
var eval_current_decl_id: i64 = -1

# ===== Warning Tracking =====
var eval_warnings: [text] = []

fn eval_get_warnings() -> [text]:
    eval_warnings

fn eval_reset():
    eval_returning = false
    eval_return_value = -1
    eval_breaking = false
    eval_continuing = false
    eval_had_error = false
    eval_error_msg = ""
    eval_warnings = []
    eval_break_label = ""
    eval_continue_label = ""
    eval_label_stack = []
    init_functions = []
    teardown_functions = []
    when_disabled_decls = []
    eval_current_decl_id = -1
    eval_defer_eids = []
    eval_defer_depths = []
    eval_defer_depth = 0
    eval_yield_stack = []
    enum_reg_names = []
    enum_reg_variants = []

fn eval_set_error(msg: text):
    eval_had_error = true
    eval_error_msg = msg

fn eval_get_error() -> text:
    eval_error_msg

fn eval_has_error() -> bool:
    eval_had_error

# ===== Function Table (Hash Map) =====
# Maps function name -> decl_id for call resolution
var ft_keys: [text] = []
var ft_vals: [i64] = []
var ft_buckets: [i64] = []
var ft_nexts: [i64] = []

# ===== Function Return Types (Hash Map) =====
var frt_keys: [text] = []
var frt_vals: [i64] = []
var frt_buckets: [i64] = []
var frt_nexts: [i64] = []

# ===== Must-Use Function Registry (Hash Map, R9) =====
var mu_keys: [text] = []
var mu_reasons: [text] = []
var mu_buckets: [i64] = []
var mu_nexts: [i64] = []
var must_use_critical_mode: bool = false

# @init and @teardown function name lists
var init_functions: [text] = []
var teardown_functions: [text] = []

# @when conditional compilation — skipped decl names
var when_disabled_decls: [text] = []

fn when_env(key: text) -> text:
    val value = rt_env_get(key)
    if value == nil:
        return ""
    value

fn when_strip_quotes(value: text) -> text:
    val trimmed = value.trim()
    if trimmed.len() >= 2:
        val first = trimmed[0:1]
        val last = trimmed[trimmed.len() - 1:trimmed.len()]
        val is_double = first == "\"" and last == "\""
        val is_single = first == "'" and last == "'"
        if is_double or is_single:
            return trimmed[1:trimmed.len() - 1]
    trimmed

fn when_normalize_os(raw: text) -> text:
    val value = when_strip_quotes(raw).trim()
    if value == "":
        return ""

    if value == "win" or value == "windows" or value == "Windows" or value == "Windows_NT":
        return "windows"
    if value.contains("windows") or value.contains("Windows"):
        return "windows"

    if value == "linux" or value == "Linux":
        return "linux"
    if value.contains("linux") or value.contains("Linux"):
        return "linux"

    if value == "mac" or value == "macos" or value == "darwin" or value == "Darwin":
        return "macos"
    if value.contains("darwin") or value.contains("Darwin"):
        return "macos"
    if value.contains("macOS") or value.contains("Mac"):
        return "macos"

    if value == "freebsd" or value == "FreeBSD":
        return "freebsd"
    if value.contains("freebsd") or value.contains("FreeBSD"):
        return "freebsd"

    if value == "openbsd" or value == "OpenBSD":
        return "openbsd"
    if value.contains("openbsd") or value.contains("OpenBSD"):
        return "openbsd"

    if value == "netbsd" or value == "NetBSD":
        return "netbsd"
    if value.contains("netbsd") or value.contains("NetBSD"):
        return "netbsd"

    if value == "android" or value == "Android":
        return "android"
    if value.contains("android") or value.contains("Android"):
        return "android"

    if value == "unix" or value == "Unix":
        return "unix"
    if value.contains("unix") or value.contains("Unix"):
        return "unix"

    ""

fn when_normalize_arch(raw: text) -> text:
    val value = when_strip_quotes(raw).trim()
    if value == "":
        return ""

    val is_x64 = value == "x86_64" or value == "amd64" or value == "AMD64"
    val is_x64_2 = value == "x64" or value == "X64"
    val is_x64_3 = value.contains("x86_64") or value.contains("amd64") or value.contains("AMD64")
    if is_x64 or is_x64_2 or is_x64_3:
        return "x86_64"

    val is_x86 = value == "x86" or value == "X86"
    val is_x86_2 = value == "i386" or value == "i686"
    val is_x86_3 = value.contains("i386") or value.contains("i686")
    if is_x86 or is_x86_2 or is_x86_3:
        return "x86"

    val is_aarch64 = value == "aarch64" or value == "arm64" or value == "ARM64"
    val is_aarch64_2 = value.contains("aarch64") or value.contains("arm64")
    if is_aarch64 or is_aarch64_2:
        return "aarch64"

    val is_arm = value == "arm" or value == "ARM"
    val is_arm2 = value == "armv7" or value == "armv6"
    val is_arm3 = value.contains("armv7") or value.contains("armv6")
    if is_arm or is_arm2 or is_arm3:
        return "arm"

    if value == "riscv64" or value.contains("riscv64"):
        return "riscv64"
    if value == "riscv32" or value.contains("riscv32"):
        return "riscv32"

    val is_ppc64le = value == "ppc64le" or value == "ppc64el"
    val is_ppc64le2 = value == "powerpc64le"
    val is_ppc64le3 = value.contains("ppc64le") or value.contains("powerpc64le")
    if is_ppc64le or is_ppc64le2 or is_ppc64le3:
        return "ppc64le"

    ""

fn when_detect_os() -> text:
    val forced = when_normalize_os(when_env("SIMPLE_TARGET_OS"))
    if forced != "":
        return forced

    val from_os = when_normalize_os(when_env("OS"))
    if from_os != "":
        return from_os

    val from_ostype = when_normalize_os(when_env("OSTYPE"))
    if from_ostype != "":
        return from_ostype

    val from_platform = when_normalize_os(when_env("PLATFORM"))
    if from_platform != "":
        return from_platform

    val from_uname = when_normalize_os(when_env("UNAME"))
    if from_uname != "":
        return from_uname

    "unknown"

fn when_detect_arch() -> text:
    val forced = when_normalize_arch(when_env("SIMPLE_TARGET_ARCH"))
    if forced != "":
        return forced

    val from_arch = when_normalize_arch(when_env("PROCESSOR_ARCHITECTURE"))
    if from_arch != "":
        return from_arch

    val from_hosttype = when_normalize_arch(when_env("HOSTTYPE"))
    if from_hosttype != "":
        return from_hosttype

    val from_machtype = when_normalize_arch(when_env("MACHTYPE"))
    if from_machtype != "":
        return from_machtype

    val from_cpu = when_normalize_arch(when_env("CPU"))
    if from_cpu != "":
        return from_cpu

    "unknown"

fn when_detect_cpu() -> text:
    val forced = when_normalize_arch(when_env("SIMPLE_TARGET_CPU"))
    if forced != "":
        return forced

    val from_id = when_normalize_arch(when_env("PROCESSOR_IDENTIFIER"))
    if from_id != "":
        return from_id

    when_detect_arch()

fn when_eval_key_value(key_raw: text, value_raw: text) -> bool:
    val key = when_strip_quotes(key_raw).trim()
    val value = when_strip_quotes(value_raw).trim()

    if key == "os":
        val expected = when_normalize_os(value)
        if expected == "unix":
            val os = when_detect_os()
            val is_unix = os == "linux" or os == "macos"
            val is_unix2 = os == "freebsd" or os == "openbsd"
            val is_unix3 = os == "netbsd" or os == "android"
            return is_unix or is_unix2 or is_unix3 or os == "unix"
        return expected != "" and when_detect_os() == expected
    if key == "platform":
        val expected = when_normalize_os(value)
        if expected == "unix":
            val os = when_detect_os()
            val is_unix = os == "linux" or os == "macos"
            val is_unix2 = os == "freebsd" or os == "openbsd"
            val is_unix3 = os == "netbsd" or os == "android"
            return is_unix or is_unix2 or is_unix3 or os == "unix"
        return expected != "" and when_detect_os() == expected
    if key == "arch":
        val expected = when_normalize_arch(value)
        return expected != "" and when_detect_arch() == expected
    if key == "cpu":
        val expected = when_normalize_arch(value)
        return expected != "" and when_detect_cpu() == expected
    if key == "feature":
        return false

    false

fn when_check_condition(condition: text) -> bool:
    # Evaluate @when condition for build/profile and target predicates.
    val cond = condition.trim()

    if cond == "true": return true
    if cond == "false": return false
    if cond == "debug": return true     # Always true in interpreter mode
    if cond == "release": return false  # False in interpreter mode
    if cond == "interpreter": return true
    if cond == "compiled": return false

    # Platform shorthands
    if cond == "win" or cond == "windows":
        return when_detect_os() == "windows"
    if cond == "linux":
        return when_detect_os() == "linux"
    if cond == "mac" or cond == "macos" or cond == "darwin":
        return when_detect_os() == "macos"
    if cond == "freebsd":
        return when_detect_os() == "freebsd"
    if cond == "openbsd":
        return when_detect_os() == "openbsd"
    if cond == "netbsd":
        return when_detect_os() == "netbsd"
    if cond == "android":
        return when_detect_os() == "android"
    if cond == "unix":
        val os = when_detect_os()
        val is_unix = os == "linux" or os == "macos"
        val is_unix2 = os == "freebsd" or os == "openbsd"
        val is_unix3 = os == "netbsd" or os == "android"
        return is_unix or is_unix2 or is_unix3 or os == "unix"

    # CPU/arch shorthands
    if cond == "x86_64" or cond == "amd64" or cond == "x64":
        return when_detect_arch() == "x86_64"
    if cond == "x86" or cond == "i386" or cond == "i686":
        return when_detect_arch() == "x86"
    if cond == "aarch64" or cond == "arm64":
        return when_detect_arch() == "aarch64"
    if cond == "arm" or cond == "armv7" or cond == "armv6":
        return when_detect_arch() == "arm"
    if cond == "riscv64":
        return when_detect_arch() == "riscv64"
    if cond == "riscv32":
        return when_detect_arch() == "riscv32"
    if cond == "ppc64le" or cond == "ppc64el" or cond == "powerpc64le":
        return when_detect_arch() == "ppc64le"

    # Key-value forms: os=linux, os=="linux", arch=x86_64, cpu=arm64, feature=foo.
    if cond.contains("=="):
        val parts = cond.split("==")
        if parts.len() >= 2:
            return when_eval_key_value(parts[0], parts[1])
    if cond.contains("="):
        val parts = cond.split("=")
        if parts.len() >= 2:
            return when_eval_key_value(parts[0], parts[1])

    # Unknown condition: default to true (don't skip existing code silently).
    true

fn func_table_reset():
    ft_keys = []
    ft_vals = []
    ft_buckets = hm_make_global_buckets()
    ft_nexts = []
    frt_keys = []
    frt_vals = []
    frt_buckets = hm_make_global_buckets()
    frt_nexts = []
    mu_keys = []
    mu_reasons = []
    mu_buckets = hm_make_global_buckets()
    mu_nexts = []
    must_use_critical_mode = false

fn func_table_register(name: text, decl_id: i64):
    val bucket = hm_hash_text(name) % HM_SIZE
    var idx = ft_buckets[bucket]
    while idx != -1:
        if ft_keys[idx] == name:
            ft_vals[idx] = decl_id
            return
        idx = ft_nexts[idx]
    # New entry
    val new_idx = ft_keys.len()
    ft_keys.push(name)
    ft_vals.push(decl_id)
    ft_nexts.push(ft_buckets[bucket])
    ft_buckets[bucket] = new_idx

fn func_table_lookup(name: text) -> i64:
    val bucket = hm_hash_text(name) % HM_SIZE
    var idx = ft_buckets[bucket]
    while idx != -1:
        if ft_keys[idx] == name:
            return ft_vals[idx]
        idx = ft_nexts[idx]
    -1

fn func_register_return_type(name: text, ret_type: i64):
    val bucket = hm_hash_text(name) % HM_SIZE
    var idx = frt_buckets[bucket]
    while idx != -1:
        if frt_keys[idx] == name:
            frt_vals[idx] = ret_type
            return
        idx = frt_nexts[idx]
    val new_idx = frt_keys.len()
    frt_keys.push(name)
    frt_vals.push(ret_type)
    frt_nexts.push(frt_buckets[bucket])
    frt_buckets[bucket] = new_idx

fn func_lookup_return_type(name: text) -> i64:
    val bucket = hm_hash_text(name) % HM_SIZE
    var idx = frt_buckets[bucket]
    while idx != -1:
        if frt_keys[idx] == name:
            return frt_vals[idx]
        idx = frt_nexts[idx]
    -1

# ===== Must-Use Registry Functions (R9) =====

fn must_use_register(name: text, reason: text):
    val bucket = hm_hash_text(name) % HM_SIZE
    var idx = mu_buckets[bucket]
    while idx != -1:
        if mu_keys[idx] == name:
            mu_reasons[idx] = reason
            return
        idx = mu_nexts[idx]
    val new_idx = mu_keys.len()
    mu_keys.push(name)
    mu_reasons.push(reason)
    mu_nexts.push(mu_buckets[bucket])
    mu_buckets[bucket] = new_idx

fn must_use_is_registered(name: text) -> bool:
    val bucket = hm_hash_text(name) % HM_SIZE
    var idx = mu_buckets[bucket]
    while idx != -1:
        if mu_keys[idx] == name: return true
        idx = mu_nexts[idx]
    false

fn must_use_get_reason(name: text) -> text:
    val bucket = hm_hash_text(name) % HM_SIZE
    var idx = mu_buckets[bucket]
    while idx != -1:
        if mu_keys[idx] == name: return mu_reasons[idx]
        idx = mu_nexts[idx]
    ""

fn must_use_is_critical() -> bool:
    must_use_critical_mode

fn must_use_scan_source(source: text):
    mu_keys = []
    mu_reasons = []
    mu_buckets = hm_make_global_buckets()
    mu_nexts = []
    must_use_critical_mode = false
    # Split source into lines and scan for comment annotations
    var lines: [text] = []
    var line_chars: [text] = []
    var ci: i64 = 0
    for _unused in source:
        if ci >= source.len(): break
        val ch = source[ci]
        if ch == "\n":
            lines.push(line_chars.join(""))
            line_chars = []
        else:
            line_chars.push(ch)
        ci = ci + 1
    if line_chars.len() > 0:
        lines.push(line_chars.join(""))
    # Scan for annotations
    var pending_must_use: bool = false
    var pending_reason: text = ""
    var pending_init: bool = false
    var pending_teardown: bool = false
    var pending_when: text = ""
    var li: i64 = 0
    for line in lines:
        # Trim leading spaces
        var trimmed_chars: [text] = []
        var started: bool = false
        var ti: i64 = 0
        for _c in line:
            if ti >= line.len(): break
            val lc = line[ti]
            if started:
                trimmed_chars.push(lc)
            elif lc != " " and lc != "\t":
                started = true
                trimmed_chars.push(lc)
            ti = ti + 1
        val trimmed = trimmed_chars.join("")
        # Check for @profile(critical)
        if trimmed.starts_with("# @profile(critical)"):
            must_use_critical_mode = true
        # Check for @tailrec annotation — marks function for tail-call optimization
        if trimmed.starts_with("# @tailrec"):
            pending_init = false  # @tailrec isn't @init
            pending_teardown = false
            # Simply note the next fn as tailrec-annotated for warning purposes

        # Check for @init annotation
        if trimmed.starts_with("# @init"):
            pending_init = true
        # Check for @teardown annotation
        if trimmed.starts_with("# @teardown"):
            pending_teardown = true
        # Check for @when(condition) conditional compilation (comment form: backward compat)
        if trimmed.starts_with("# @when("):
            # Extract condition: "# @when(condition)"
            var when_cond_chars: [text] = []
            var wci: i64 = 8
            for _wc in trimmed:
                if wci >= trimmed.len(): break
                val wch = trimmed[wci]
                if wch == ")": break
                when_cond_chars.push(wch)
                wci = wci + 1
            val when_cond = when_cond_chars.join("")
            pending_when = when_cond
        # Check for @cfg(condition) — new proper syntax (no # prefix)
        if trimmed.starts_with("@cfg("):
            var cfg_chars: [text] = []
            var cci: i64 = 5
            var cfg_depth: i64 = 1
            for _cc in trimmed:
                if cci >= trimmed.len(): break
                val cch = trimmed[cci]
                if cch == "(":
                    cfg_depth = cfg_depth + 1
                if cch == ")":
                    cfg_depth = cfg_depth - 1
                    if cfg_depth == 0: break
                cfg_chars.push(cch)
                cci = cci + 1
            var cfg_cond = cfg_chars.join("").trim()
            # Convert @cfg("key", "value") to key=value form
            if cfg_cond.contains(","):
                val cfg_parts = cfg_cond.split(",")
                if cfg_parts.len() >= 2:
                    var cfg_key = cfg_parts[0].trim()
                    var cfg_val = cfg_parts[1].trim()
                    # Strip quotes
                    if cfg_key.len() >= 2 and cfg_key.starts_with("\"") and cfg_key.ends_with("\""):
                        cfg_key = cfg_key[1:cfg_key.len() - 1]
                    if cfg_val.len() >= 2 and cfg_val.starts_with("\"") and cfg_val.ends_with("\""):
                        cfg_val = cfg_val[1:cfg_val.len() - 1]
                    cfg_cond = "{cfg_key}={cfg_val}"
            pending_when = cfg_cond
        # Check for @must_use
        if trimmed.starts_with("# @must_use"):
            pending_must_use = true
            # Extract reason from @must_use("reason")
            pending_reason = ""
            if trimmed.contains("(\""):
                # Find text between (" and ")
                var in_reason: bool = false
                var reason_chars: [text] = []
                var ri: i64 = 0
                for _rc in trimmed:
                    if ri >= trimmed.len(): break
                    if in_reason:
                        val rc2 = trimmed[ri]
                        if rc2 == "\"":
                            in_reason = false
                        else:
                            reason_chars.push(rc2)
                    elif ri + 1 < trimmed.len():
                        val rc3 = trimmed[ri]
                        val rc4 = trimmed[ri + 1]
                        if rc3 == "(" and rc4 == "\"":
                            in_reason = true
                            ri = ri + 1
                    ri = ri + 1
                pending_reason = reason_chars.join("")
        # Check if line declares a function (and we have a pending annotation)
        if pending_must_use:
            if trimmed.starts_with("fn "):
                # Extract function name
                var fname_chars: [text] = []
                var fi: i64 = 3
                for _fc in trimmed:
                    if fi >= trimmed.len(): break
                    val fc2 = trimmed[fi]
                    if fc2 == "(" or fc2 == " " or fc2 == ":": break
                    fname_chars.push(fc2)
                    fi = fi + 1
                val fname = fname_chars.join("")
                if fname != "":
                    must_use_register(fname, pending_reason)
                pending_must_use = false
                pending_reason = ""
            elif trimmed.starts_with("# ") == false and trimmed != "":
                # Non-comment, non-empty line without fn => cancel pending
                pending_must_use = false
                pending_reason = ""
        # Handle @init and @teardown function registration
        if pending_init or pending_teardown or pending_when != "":
            if trimmed.starts_with("fn ") or trimmed.starts_with("val ") or trimmed.starts_with("var "):
                # Extract declaration name
                var anno_fname_chars: [text] = []
                var anno_fi: i64 = 3
                if trimmed.starts_with("val ") or trimmed.starts_with("var "):
                    anno_fi = 4
                for _afc in trimmed:
                    if anno_fi >= trimmed.len(): break
                    val afc2 = trimmed[anno_fi]
                    if afc2 == "(" or afc2 == " " or afc2 == ":" or afc2 == "=": break
                    anno_fname_chars.push(afc2)
                    anno_fi = anno_fi + 1
                val anno_fname = anno_fname_chars.join("")
                if anno_fname != "":
                    if pending_init:
                        init_functions.push(anno_fname)
                    if pending_teardown:
                        teardown_functions.push(anno_fname)
                    if pending_when != "":
                        val when_ok = when_check_condition(pending_when)
                        if when_ok == false:
                            when_disabled_decls.push(anno_fname)
                pending_init = false
                pending_teardown = false
                pending_when = ""
            elif trimmed.starts_with("# ") == false and trimmed != "":
                pending_init = false
                pending_teardown = false
                pending_when = ""
        li = li + 1

# ===== Struct Definition Table (Hash Map) =====
# Maps struct name -> decl_id for constructor resolution
var st_keys: [text] = []
var st_vals: [i64] = []
var st_buckets: [i64] = []
var st_nexts: [i64] = []
var st_module_paths: [text] = []

fn struct_table_reset():
    st_keys = []
    st_vals = []
    st_buckets = hm_make_global_buckets()
    st_nexts = []
    st_module_paths = []

fn struct_table_register(name: text, decl_id: i64):
    val bucket = hm_hash_text(name) % HM_SIZE
    var idx = st_buckets[bucket]
    while idx != -1:
        if st_keys[idx] == name:
            st_vals[idx] = decl_id
            st_module_paths[idx] = module_get_path()
            return
        idx = st_nexts[idx]
    val new_idx = st_keys.len()
    st_keys.push(name)
    st_vals.push(decl_id)
    st_nexts.push(st_buckets[bucket])
    st_buckets[bucket] = new_idx
    st_module_paths.push(module_get_path())

fn struct_table_lookup(name: text) -> i64:
    val bucket = hm_hash_text(name) % HM_SIZE
    var idx = st_buckets[bucket]
    while idx != -1:
        if st_keys[idx] == name:
            return st_vals[idx]
        idx = st_nexts[idx]
    -1

fn struct_table_get_module(name: text) -> text:
    val bucket = hm_hash_text(name) % HM_SIZE
    var idx = st_buckets[bucket]
    while idx != -1:
        if st_keys[idx] == name:
            return st_module_paths[idx]
        idx = st_nexts[idx]
    ""

# ===== Enum Type Registry =====
# Tracks enum type names and their variants for exhaustiveness checking.
# Variants stored as comma-separated text to avoid [[text]] arrays.
var enum_reg_names: [text] = []
var enum_reg_variants: [text] = []

fn enum_table_reset():
    enum_reg_names = []
    enum_reg_variants = []

fn enum_table_register(name: text, variants: [text]):
    # Check if already registered
    var i: i64 = 0
    for existing in enum_reg_names:
        if existing == name:
            return
        i = i + 1
    enum_reg_names.push(name)
    enum_reg_variants.push(variants.join(","))

fn enum_table_lookup(name: text) -> text:
    # Returns comma-separated variants, or "" if not found
    var i: i64 = 0
    for ename in enum_reg_names:
        if ename == name:
            return enum_reg_variants[i]
        i = i + 1
    ""

# ===== Phantom Struct Registry =====
# Tracks struct names explicitly registered as phantom types.
var phantom_reg_names: [text] = []

fn phantom_struct_register(name: text):
    # Register a struct name as a phantom type marker
    for existing in phantom_reg_names:
        if existing == name: return
    phantom_reg_names.push(name)

fn phantom_struct_is_registered(name: text) -> bool:
    for pname in phantom_reg_names:
        if pname == name: return true
    false

fn phantom_reg_reset():
    phantom_reg_names = []

# ===== Match Exhaustiveness Helpers =====

fn match_arm_is_wildcard(pattern_eid: i64) -> bool:
    # Returns true if pattern_eid is a wildcard (_) or bare identifier (binding)
    # A pattern_eid < 0 means unconditional match
    if pattern_eid < 0: return true
    val e_node = expr_get(pattern_eid)
    val tag = e_node.tag
    if tag == EXPR_IDENT:
        val pname = e_node.s_val
        if pname == "_": return true
        # A bare identifier is a binding pattern — also catches all
        return true
    false

fn match_arm_get_enum_type(pattern_eid: i64) -> text:
    # Extracts enum type name from a pattern like Status.Ok (EXPR_FIELD_ACCESS)
    # Returns "" if pattern is not an enum variant pattern
    if pattern_eid < 0: return ""
    val e_node = expr_get(pattern_eid)
    val tag = e_node.tag
    if tag == EXPR_FIELD_ACCESS:
        val base_eid = e_node.left
        if base_eid >= 0:
            val base_node = expr_get(base_eid)
            if base_node.tag == EXPR_IDENT:
                return base_node.s_val
    ""

fn match_arm_get_variant_name(pattern_eid: i64) -> text:
    # Extracts variant name from a pattern like Status.Ok -> "Ok"
    if pattern_eid < 0: return ""
    val e_node = expr_get(pattern_eid)
    val tag = e_node.tag
    if tag == EXPR_FIELD_ACCESS:
        return e_node.s_val
    ""

fn check_match_exhaustive(arm_ids: [i64], type_name: text):
    # Check if match arms cover all variants of the given enum type.
    # Emits a warning if variants are missing and no wildcard present.
    if type_name == "": return
    val variants_csv = enum_table_lookup(type_name)
    if variants_csv == "": return

    # Check if any arm is a wildcard (catches all)
    var has_wildcard: bool = false
    for arm_id in arm_ids:
        val pattern_eid = arm_get_pattern(arm_id)
        if match_arm_is_wildcard(pattern_eid):
            has_wildcard = true
    if has_wildcard: return

    # Collect covered variant names from arms
    var covered: [text] = []
    for arm_id in arm_ids:
        val pattern_eid = arm_get_pattern(arm_id)
        val variant = match_arm_get_variant_name(pattern_eid)
        if variant != "":
            covered.push(variant)

    # Split variants_csv into individual variants
    var all_variants: [text] = []
    var chars: [text] = []
    var ci2: i64 = 0
    for _c2 in variants_csv:
        if ci2 >= variants_csv.len(): break
        val ch2 = variants_csv[ci2]
        if ch2 == ",":
            if chars.len() > 0:
                all_variants.push(chars.join(""))
                chars = []
        else:
            chars.push(ch2)
        ci2 = ci2 + 1
    if chars.len() > 0:
        all_variants.push(chars.join(""))

    # Find missing variants
    var missing: [text] = []
    for variant in all_variants:
        var found: bool = false
        for cov in covered:
            if cov == variant:
                found = true
        if found == false:
            missing.push(variant)

    if missing.len() > 0:
        var msg = "warning: non-exhaustive match on '" + type_name + "' — missing: "
        var mi: i64 = 0
        for mv in missing:
            if mi > 0:
                msg = msg + ", "
            msg = msg + mv
            mi = mi + 1
        eval_warnings.push(msg)

fn infer_match_enum_type(arm_ids: [i64]) -> text:
    # Try to infer enum type from match arms by looking for EXPR_FIELD_ACCESS patterns
    for arm_id in arm_ids:
        val pattern_eid = arm_get_pattern(arm_id)
        val etype = match_arm_get_enum_type(pattern_eid)
        if etype != "":
            return etype
    ""

# ===== Expression Evaluation =====

fn eval_expr(eid: i64) -> i64:
    if eid < 0: return val_make_nil()
    if eval_had_error: return -1
    if eval_returning: return eval_return_value

    val tag = expr_get(eid).tag

    # Literals
    if tag == EXPR_INT_LIT: return eval_int_lit(eid)
    if tag == EXPR_FLOAT_LIT: return eval_float_lit(eid)
    if tag == EXPR_STRING_LIT: return eval_string_lit(eid)
    if tag == EXPR_BOOL_LIT: return eval_bool_lit(eid)
    if tag == EXPR_NIL_LIT: return val_make_nil()
    if tag == EXPR_UNIT: return val_make_nil()
    if tag == EXPR_PASS: return val_make_nil()
    if tag == EXPR_PASS_TODO: return val_make_nil()
    if tag == EXPR_PASS_DO_NOTHING: return val_make_nil()
    if tag == EXPR_PASS_DN: return val_make_nil()
    if tag == EXPR_ASM: return val_make_int(0)
    if tag == EXPR_ASM_MATCH: return val_make_int(0)

    # Identifier
    if tag == EXPR_IDENT: return eval_ident(eid)

    # Operations
    if tag == EXPR_BINARY: return eval_binary(eid)
    if tag == EXPR_UNARY: return eval_unary(eid)

    # Control flow
    if tag == EXPR_IF: return eval_if_expr(eid)
    if tag == EXPR_BLOCK: return eval_block_expr(eid)
    if tag == EXPR_FOR: return eval_for_expr(eid)
    if tag == EXPR_WHILE: return eval_while_expr(eid)
    if tag == EXPR_MATCH: return eval_match_expr(eid)

    # Calls
    if tag == EXPR_CALL: return eval_call(eid)
    if tag == EXPR_METHOD_CALL: return eval_method_call(eid)

    # Access
    if tag == EXPR_FIELD_ACCESS: return eval_field_access(eid)
    if tag == EXPR_INDEX: return eval_index_expr(eid)
    if tag == EXPR_SLICE: return eval_slice_expr(eid)

    # Collections
    if tag == EXPR_ARRAY_LIT: return eval_array_lit(eid)
    if tag == EXPR_STRUCT_LIT: return eval_struct_lit(eid)

    # Assignment (as expression)
    if tag == EXPR_ASSIGN: return eval_assign_expr(eid)
    if tag == EXPR_COMPOUND_ASSIGN: return eval_compound_assign_expr(eid)

    # Control
    if tag == EXPR_RETURN: return eval_return_expr(eid)
    if tag == EXPR_BREAK:
        eval_breaking = true
        return val_make_nil()
    if tag == EXPR_CONTINUE:
        eval_continuing = true
        return val_make_nil()

    # Async/await (basic stubs - full state machine support TODO)
    if tag == EXPR_AWAIT: return eval_await_expr(eid)
    if tag == EXPR_YIELD: return eval_yield_expr(eid)
    if tag == EXPR_SPAWN: return eval_spawn_expr(eid)
    if tag == EXPR_DO_BLOCK: return eval_do_block(eid)
    if tag == EXPR_ATOM: return eval_atom_expr(eid)

    # String interpolation
    if tag == EXPR_INTERPOLATED_STRING: return eval_interpolated_string(eid)

    # Null coalesce
    if tag == EXPR_NULL_COALESCE: return eval_null_coalesce(eid)

    # Range (used in for loops, not directly evaluatable)
    if tag == EXPR_RANGE: return eval_range(eid)

    eval_set_error("unsupported expression kind: " + expr_kind_name(tag))
    -1

# ===== Literal Evaluation =====

fn eval_int_lit(eid: i64) -> i64:
    val_make_int(expr_get(eid).i_val)

fn eval_float_lit(eid: i64) -> i64:
    val float_text = expr_get(eid).f_val
    val_make_float(parse_float_text(float_text))

fn parse_float_text(s: text) -> f64:
    """Parse a float from text representation (e.g. '3.14', '-2.5', '1e3')."""
    var result: f64 = 0.0
    var negative = false
    var i = 0
    # Handle sign
    if s.len() > 0 and s[0] == "-":
        negative = true
        i = 1
    elif s.len() > 0 and s[0] == "+":
        i = 1
    # Parse integer part
    while i < s.len():
        val c = s[i]
        if c == ".": break
        if c == "e" or c == "E": break
        if c != "_":
            val d = char_digit(c)
            if d >= 0.0:
                result = result * 10.0 + d
        i = i + 1
    # Parse fractional part
    if i < s.len() and s[i] == ".":
        i = i + 1
        var frac: f64 = 0.0
        var frac_div: f64 = 1.0
        while i < s.len():
            val c = s[i]
            if c == "e" or c == "E": break
            if c != "_":
                val d = char_digit(c)
                if d >= 0.0:
                    frac = frac * 10.0 + d
                    frac_div = frac_div * 10.0
            i = i + 1
        result = result + frac / frac_div
    # Parse exponent
    if i < s.len() and (s[i] == "e" or s[i] == "E"):
        i = i + 1
        var exp_neg = false
        if i < s.len() and s[i] == "-":
            exp_neg = true
            i = i + 1
        elif i < s.len() and s[i] == "+":
            i = i + 1
        var exp_val: f64 = 0.0
        while i < s.len():
            val c = s[i]
            if c != "_":
                val d = char_digit(c)
                if d >= 0.0:
                    exp_val = exp_val * 10.0 + d
            i = i + 1
        var power: f64 = 1.0
        var ei = 0
        while ei < int(exp_val):
            power = power * 10.0
            ei = ei + 1
        if exp_neg:
            result = result / power
        else:
            result = result * power
    if negative:
        0.0 - result
    else:
        result

fn char_digit(c: text) -> f64:
    """Convert single-char text to digit value, or -1.0 if not a digit."""
    if c == "0": 0.0
    elif c == "1": 1.0
    elif c == "2": 2.0
    elif c == "3": 3.0
    elif c == "4": 4.0
    elif c == "5": 5.0
    elif c == "6": 6.0
    elif c == "7": 7.0
    elif c == "8": 8.0
    elif c == "9": 9.0
    else: -1.0

fn eval_string_lit(eid: i64) -> i64:
    val_make_text(expr_get(eid).s_val)

fn eval_bool_lit(eid: i64) -> i64:
    val_make_bool(expr_get(eid).i_val != 0)

# ===== Identifier Evaluation =====

fn eval_ident(eid: i64) -> i64:
    # Fast path: LOAD_FAST via pre-resolved local index
    val local_idx = expr_i_val[eid]
    if local_idx >= 0:
        if env_has_frame():
            val fast_val = env_get_local(local_idx)
            if fast_val >= 0:
                if val_is_thunk(fast_val):
                    val forced = eval_expr(val_thunk_get_expr(fast_val))
                    if eval_had_error: return -1
                    env_set_local(local_idx, forced)
                    env_assign(expr_s_val[eid], forced)
                    return forced
                return fast_val
    # Slow path: hash map lookup
    val name = expr_get(eid).s_val
    # Annotation intrinsics: @file, @line, @function
    if name == "@file":
        return val_make_text(module_get_path())
    if name == "__builtin_file":
        return val_make_text(module_get_path())
    if name == "@line":
        # Best-effort: return 1 (line info not preserved in current AST)
        return val_make_int(1)
    if name == "__builtin_line":
        return val_make_int(1)
    if name == "@function":
        if eval_current_decl_id >= 0:
            val fn_decl_node = decl_get(eval_current_decl_id)
            return val_make_text(fn_decl_node.name)
        return val_make_text("<module>")
    if name == "__builtin_function":
        if eval_current_decl_id >= 0:
            val bi_fn_node = decl_get(eval_current_decl_id)
            return val_make_text(bi_fn_node.name)
        return val_make_text("<module>")
    if name == "__builtin_test_mode":
        return val_make_bool(false)
    if name == "@test_mode":
        return val_make_bool(false)
    if name == "__builtin_debug_mode":
        return val_make_bool(false)
    if name == "@debug_mode":
        return val_make_bool(false)
    val vid = env_lookup(name)
    if vid >= 0:
        if val_is_thunk(vid):
            val forced = eval_expr(val_thunk_get_expr(vid))
            if eval_had_error: return -1
            env_assign(name, forced)
            return forced
        return vid
    # Check function table
    val decl_id = func_table_lookup(name)
    if decl_id >= 0:
        return val_make_function(name, decl_id)
    # Try deferred (lazy) modules before giving up
    val forced_ok = try_force_any_deferred_for(name)
    if forced_ok == 1:
        val decl_id2 = func_table_lookup(name)
        if decl_id2 >= 0:
            return val_make_function(name, decl_id2)
        val vid2 = env_lookup(name)
        if vid2 >= 0: return vid2
    eval_set_error("undefined variable: " + name)
    -1

# ===== Binary/Unary =====

fn eval_binary(eid: i64) -> i64:
    val e_node = expr_get(eid)
    val op = e_node.i_val
    val left = eval_expr(e_node.left)
    if eval_had_error: return -1
    val right = eval_expr(e_node.right)
    if eval_had_error: return -1
    val result = val_binary_op(op, left, right)
    if result < 0:
        val err = ops_get_error()
        if err != "":
            eval_set_error(err)
    result

fn eval_unary(eid: i64) -> i64:
    val e_node = expr_get(eid)
    val op = e_node.i_val
    val operand = eval_expr(e_node.left)
    if eval_had_error: return -1
    val result = val_unary_op(op, operand)
    if result < 0:
        val err = ops_get_error()
        if err != "":
            eval_set_error(err)
    result

# ===== If Expression =====

fn eval_if_expr(eid: i64) -> i64:
    val e_node = expr_get(eid)
    val cond_id = e_node.left
    val then_id = e_node.right
    val else_id = e_node.extra

    val cond_val = eval_expr(cond_id)
    if eval_had_error: return -1

    val taken = val_is_truthy(cond_val)
    record_decision("eval", eid, taken)

    if taken:
        return eval_expr(then_id)
    if else_id >= 0:
        return eval_expr(else_id)
    val_make_nil()

# ===== Block Expression =====

fn eval_block_expr(eid: i64) -> i64:
    val e_node = expr_get(eid)
    val stmts = e_node.stmts
    val value_expr = e_node.left
    eval_block(stmts, value_expr)

fn eval_block(stmts: [i64], value_expr: i64) -> i64:
    env_push_scope()
    eval_defer_depth = eval_defer_depth + 1
    val my_depth = eval_defer_depth

    var last_val = val_make_nil()

    for sid in stmts:
        if eval_had_error: break
        if eval_returning: break
        if eval_breaking: break
        if eval_continuing: break
        last_val = eval_stmt(sid)

    if value_expr >= 0:
        val ctrl_interrupted = eval_had_error or eval_returning or eval_breaking or eval_continuing
        if ctrl_interrupted == false:
            last_val = eval_expr(value_expr)

    # Execute deferred expressions at this depth in reverse order (LIFO)
    val saved_returning = eval_returning
    val saved_had_error = eval_had_error
    eval_returning = false
    eval_had_error = false
    val total_deferred = eval_defer_eids.len()
    # Collect indices to run (those at my_depth)
    var defer_to_run: [i64] = []
    for di in 0..total_deferred:
        if eval_defer_depths[di] == my_depth:
            defer_to_run.push(eval_defer_eids[di])
    # Execute in reverse
    val run_count = defer_to_run.len()
    for ri in 0..run_count:
        val ridx = run_count - 1 - ri
        eval_expr(defer_to_run[ridx])
    eval_returning = saved_returning
    eval_had_error = saved_had_error

    # Remove all defer entries at this depth
    var new_eids: [i64] = []
    var new_depths: [i64] = []
    for di in 0..total_deferred:
        if eval_defer_depths[di] != my_depth:
            new_eids.push(eval_defer_eids[di])
            new_depths.push(eval_defer_depths[di])
    eval_defer_eids = new_eids
    eval_defer_depths = new_depths
    eval_defer_depth = eval_defer_depth - 1

    env_pop_scope()
    last_val

# ===== For Expression =====

fn eval_for_expr(eid: i64) -> i64:
    val e_node = expr_get(eid)
    val iter_name = e_node.s_val
    val iterable_eid = e_node.left
    val body_stmts = e_node.stmts

    val iterable = eval_expr(iterable_eid)
    if eval_had_error: return -1

    val kind = val_get_kind(iterable)
    var last_val = val_make_nil()

    # Iterate over array
    if kind == VAL_ARRAY:
        val elements = val_get_array(iterable)
        for elem_vid in elements:
            if eval_breaking: break
            if eval_returning: break
            if eval_had_error: break
            eval_continuing = false
            env_push_scope()
            env_define(iter_name, elem_vid)
            for sid in body_stmts:
                if eval_had_error: break
                if eval_returning: break
                if eval_breaking: break
                if eval_continuing: break
                last_val = eval_stmt(sid)
            env_pop_scope()
        eval_breaking = false
        eval_continuing = false
        return last_val

    # Iterate over range (check if iterable is a range pair)
    # Range is stored as: left=start, right=end, i_val=inclusive
    if kind == VAL_INT:
        # Check if iterable_eid is a RANGE expression
        val iterable_tag = expr_get(iterable_eid).tag
        if iterable_tag == EXPR_RANGE:
            val range_node = expr_get(iterable_eid)
            val start_val = eval_expr(range_node.left)
            if eval_had_error: return -1
            val end_val = eval_expr(range_node.right)
            if eval_had_error: return -1
            val inclusive = range_node.i_val
            val start_n = val_get_int(start_val)
            val end_n = val_get_int(end_val)
            var current = start_n
            val limit = end_n
            var _range_iter: i64 = 0
            while _range_iter < 1000001:
                if eval_breaking: break
                if eval_returning: break
                if eval_had_error: break
                val should_stop = current > limit
                val at_limit = current == limit
                if inclusive != 0:
                    if should_stop: break
                else:
                    if at_limit: break
                    if should_stop: break
                eval_continuing = false
                env_push_scope()
                env_define(iter_name, val_make_int(current))
                for sid in body_stmts:
                    if eval_had_error: break
                    if eval_returning: break
                    if eval_breaking: break
                    if eval_continuing: break
                    last_val = eval_stmt(sid)
                env_pop_scope()
                current = current + 1
                _range_iter = _range_iter + 1
            eval_breaking = false
            eval_continuing = false
            return last_val

    eval_set_error("cannot iterate over " + val_kind_name(kind))
    -1

# ===== Range Expression =====
# Range creates an array of integers for now
fn eval_range(eid: i64) -> i64:
    val e_node = expr_get(eid)
    val start_val = eval_expr(e_node.left)
    if eval_had_error: return -1
    val end_val = eval_expr(e_node.right)
    if eval_had_error: return -1
    val inclusive = e_node.i_val
    val start_n = val_get_int(start_val)
    val end_n = val_get_int(end_val)
    var elements: [i64] = []
    var current = start_n
    var _range_iter2: i64 = 0
    while _range_iter2 < 10001:
        val should_stop = current > end_n
        val at_limit = current == end_n
        if inclusive != 0:
            if should_stop: break
        else:
            if at_limit: break
            if should_stop: break
        elements.push(val_make_int(current))
        current = current + 1
        _range_iter2 = _range_iter2 + 1
    val_make_array(elements)

# ===== While Expression =====

fn eval_while_expr(eid: i64) -> i64:
    val e_node = expr_get(eid)
    val cond_eid = e_node.left
    val body_stmts = e_node.stmts
    var last_val = val_make_nil()
    var iterations: i64 = 0
    val max_iterations: i64 = 1000000

    while iterations < max_iterations:
        if eval_had_error: break
        if eval_returning: break
        if eval_breaking: break
        val cond_val = eval_expr(cond_eid)
        if eval_had_error: break
        if val_is_truthy(cond_val) == false: break
        eval_continuing = false
        for sid in body_stmts:
            if eval_had_error: break
            if eval_returning: break
            if eval_breaking: break
            if eval_continuing: break
            last_val = eval_stmt(sid)
        iterations = iterations + 1

    if iterations >= max_iterations:
        eval_set_error("while loop exceeded maximum iterations")

    eval_breaking = false
    eval_continuing = false
    last_val

# ===== Match Expression =====

fn eval_match_expr(eid: i64) -> i64:
    val e_node = expr_get(eid)
    val scrutinee = eval_expr(e_node.left)
    if eval_had_error: return -1
    val arm_ids = e_node.args

    # Exhaustiveness check: warn if enum variants are not all covered
    val inferred_type = infer_match_enum_type(arm_ids)
    check_match_exhaustive(arm_ids, inferred_type)

    for arm_id in arm_ids:
        val pattern_eid = arm_get_pattern(arm_id)
        val guard_eid = arm_get_guard(arm_id)
        val body_stmts = arm_get_body(arm_id)

        val matched = match_pattern(scrutinee, pattern_eid)
        if matched:
            # Check guard
            if guard_eid >= 0:
                val guard_val = eval_expr(guard_eid)
                if eval_had_error: return -1
                if val_is_truthy(guard_val) == false:
                    continue
            # Execute arm body
            env_push_scope()
            # Pattern binding: case X as name: — bind scrutinee to name
            val binding_name = arm_get_binding(arm_id)
            if binding_name != "":
                env_define(binding_name, scrutinee)
            var last_val = val_make_nil()
            for sid in body_stmts:
                if eval_had_error: break
                if eval_returning: break
                last_val = eval_stmt(sid)
            env_pop_scope()
            return last_val

    # No arm matched — emit exhaustiveness warning
    val kind = val_get_kind(scrutinee)
    val val_name = val_kind_name(kind)
    eval_warnings.push("warning: non-exhaustive match - no arm matched value of type " + val_name)
    val_make_nil()

fn match_pattern(value_id: i64, pattern_eid: i64) -> bool:
    if pattern_eid < 0: return true
    val e_node = expr_get(pattern_eid)
    val tag = e_node.tag

    # Wildcard: _ matches anything
    if tag == EXPR_IDENT:
        val name = e_node.s_val
        if name == "_": return true
        # Binding: bind value to name
        env_define(name, value_id)
        return true

    # Literal patterns: compare values
    if tag == EXPR_INT_LIT:
        val pattern_val = eval_int_lit(pattern_eid)
        return val_equals(value_id, pattern_val)

    if tag == EXPR_STRING_LIT:
        val pattern_val = eval_string_lit(pattern_eid)
        return val_equals(value_id, pattern_val)

    if tag == EXPR_BOOL_LIT:
        val pattern_val = eval_bool_lit(pattern_eid)
        return val_equals(value_id, pattern_val)

    if tag == EXPR_NIL_LIT:
        return val_is_nil(value_id)

    # Default: try equality comparison
    val pattern_val = eval_expr(pattern_eid)
    if eval_had_error: return false
    val_equals(value_id, pattern_val)

# ===== Call Expression =====

fn eval_call(eid: i64) -> i64:
    val e_node = expr_get(eid)
    val callee_eid = e_node.left
    val arg_eids = e_node.args

    # Evaluate callee
    val callee_node = expr_get(callee_eid)
    val callee_tag = callee_node.tag

    # Direct function call by name
    if callee_tag == EXPR_IDENT:
        val name = callee_node.s_val

        # Check for struct constructor
        val struct_decl = struct_table_lookup(name)
        if struct_decl >= 0:
            return eval_struct_constructor(name, struct_decl, arg_eids)

        # Check for builtin
        val builtin_result = eval_builtin_call(name, arg_eids)
        if builtin_result >= -1:
            return builtin_result

        # Check function table
        val decl_id = func_table_lookup(name)
        if decl_id >= 0:
            return eval_function_call(decl_id, arg_eids)

        # Check environment for function value
        val fn_vid = env_lookup(name)
        if fn_vid >= 0:
            if val_is_function(fn_vid):
                val fn_decl = val_get_func_decl(fn_vid)
                return eval_function_call(fn_decl, arg_eids)

        eval_set_error("undefined function: " + name)
        return -1

    # Indirect call (call on expression result)
    val callee_val = eval_expr(callee_eid)
    if eval_had_error: return -1
    if val_is_function(callee_val):
        val fn_decl = val_get_func_decl(callee_val)
        return eval_function_call(fn_decl, arg_eids)

    eval_set_error("value is not callable")
    -1

fn eval_function_call(decl_id: i64, arg_eids: [i64]) -> i64:
    val d_node = decl_get(decl_id)
    val fn_name = d_node.name
    val param_names = d_node.param_names
    val param_types = d_node.param_types
    val type_params = d_node.type_params
    val body_stmts = d_node.body_stmts

    # Record call for JIT threshold tracking
    jit_record_call(fn_name)

    # Evaluate arguments
    var arg_values: [i64] = []
    for aeid in arg_eids:
        val av = eval_expr(aeid)
        if eval_had_error: return -1
        arg_values.push(av)

    # Check if function is generic (has type parameters)
    # If so, look up or create monomorphic instance
    var actual_decl_id = decl_id
    if type_params.len() > 0:
        val type_args_str = infer_type_args_from_values(arg_values)
        val cache_key = fn_name + "__" + type_args_str
        val cached_decl = mono_cache_lookup(cache_key)
        if cached_decl >= 0:
            actual_decl_id = cached_decl
        else:
            val type_tags = infer_type_tags_from_values(arg_values)
            val specialized_decl = mono_specialize(decl_id, type_params, type_tags)
            mono_cache_register(cache_key, specialized_decl)
            actual_decl_id = specialized_decl

    # Type check arguments if parameter types are specified
    if param_types.len() > 0:
        var pi: i64 = 0
        for av in arg_values:
            if pi < param_types.len():
                val expected_type = param_types[pi]
                if expected_type != 0:  # 0 = TYPE_VOID means no type annotation
                    val type_matches = type_check_value(av, expected_type)
                    if not type_matches:
                        val param_name = param_names[pi]
                        eval_set_error("type error: argument '" + param_name + "' in function '" + fn_name + "' type mismatch")
                        return -1
            pi = pi + 1

    # Try JIT execution if function is compiled
    if jit_is_compiled(fn_name):
        # Convert value_ids to raw i64s for JIT calling convention
        var raw_args: [i64] = []
        for av in arg_values:
            if val_is_int(av):
                raw_args.push(val_get_int(av))
            else:
                raw_args.push(av)
        val jit_result = jit_try_execute(fn_name, raw_args)
        if jit_result != -1:
            return val_make_int(jit_result)

    # Fall back to tree-walking
    val local_count = resolve_cached_local_count(actual_decl_id)
    val prev_decl_id = eval_current_decl_id
    eval_current_decl_id = actual_decl_id
    if local_count > 0:
        env_push_frame(local_count)
    env_push_scope()
    var pi: i64 = 0
    for pname in param_names:
        var pval = val_make_nil()
        if pi < arg_values.len():
            pval = arg_values[pi]
        env_define(pname, pval)
        # LOAD_FAST: set fast local for non-shadowed params
        if local_count > 0:
            val is_shadowed = resolve_is_slot_shadowed(actual_decl_id, pi)
            if is_shadowed == false:
                env_set_local(pi, pval)
        pi = pi + 1

    # Generator detection: push yield accumulator if body contains yield
    val is_gen = stmts_contain_yield(body_stmts)
    if is_gen:
        eval_yield_stack.push([])

    # Execute body
    var last_val = val_make_nil()
    for sid in body_stmts:
        if eval_had_error: break
        if eval_returning: break
        last_val = eval_stmt(sid)

    # Handle return
    var had_explicit_return = false
    if eval_returning:
        last_val = eval_return_value
        eval_returning = false
        eval_return_value = -1
        had_explicit_return = true

    # Generator: pop accumulator and return collected array
    if is_gen:
        val ys_len = eval_yield_stack.len()
        val yielded = eval_yield_stack[ys_len - 1]
        eval_yield_stack = eval_yield_stack[0:ys_len - 1]
        if had_explicit_return == false:
            last_val = val_make_array(yielded)

    env_pop_scope()
    if local_count > 0:
        env_pop_frame()
    eval_current_decl_id = prev_decl_id
    last_val

fn eval_struct_constructor(name: text, decl_id: i64, arg_eids: [i64]) -> i64:
    val d_node = decl_get(decl_id)
    val field_names = d_node.field_names
    val field_defaults = d_node.field_defaults
    var field_values: [i64] = []

    # Check for struct update spread (..base) - usually the last arg
    var base_struct: i64 = -1
    var spread_at: i64 = -1
    var spread_idx: i64 = 0
    for aeid in arg_eids:
        val etag = expr_get_tag(aeid)
        if etag == EXPR_SPREAD:
            spread_at = spread_idx
        spread_idx = spread_idx + 1

    # Evaluate non-spread arguments (positional mapping to fields)
    var explicit_pos: i64 = 0
    for aeid in arg_eids:
        val etag = expr_get_tag(aeid)
        if etag == EXPR_SPREAD:
            # Evaluate base struct for spread
            val inner_eid = expr_get_left(aeid)
            base_struct = eval_expr(inner_eid)
            if eval_had_error: return -1
        else:
            val av = eval_expr(aeid)
            if eval_had_error: return -1
            field_values.push(av)

    # Fill remaining fields: use base struct then defaults then nil
    val num_filled = field_values.len()
    var i: i64 = 0
    for fname in field_names:
        if i >= num_filled:
            var fv: i64 = -1
            # Try base struct field
            if base_struct >= 0:
                val bfv = val_struct_get_field(base_struct, fname)
                if bfv >= 0:
                    fv = bfv
            # Try declared default
            if fv < 0:
                if i < field_defaults.len():
                    val def_eid = field_defaults[i]
                    if def_eid >= 0:
                        fv = eval_expr(def_eid)
                        if eval_had_error: return -1
            if fv < 0:
                fv = val_make_nil()
            field_values.push(fv)
        i = i + 1

    val_make_struct(name, field_names, field_values)

# ===== Method Call =====

fn eval_method_call(eid: i64) -> i64:
    val e_node = expr_get(eid)
    val receiver_eid = e_node.left
    val method_name = e_node.s_val
    val arg_eids = e_node.args

    val receiver = eval_expr(receiver_eid)
    if eval_had_error: return -1

    # Built-in methods on types
    val kind = val_get_kind(receiver)

    # Array methods
    if kind == VAL_ARRAY:
        return eval_array_method(receiver, method_name, arg_eids)

    # Text methods
    if kind == VAL_TEXT:
        return eval_text_method(receiver, method_name, arg_eids)

    # Struct methods — look up Type__method in function table
    if kind == VAL_STRUCT:
        val type_name = val_get_struct_name(receiver)
        val full_name = type_name + "__" + method_name
        val decl_id = func_table_lookup(full_name)
        if decl_id >= 0:
            # Prepend receiver as first arg
            var all_arg_eids: [i64] = []
            for aeid in arg_eids:
                all_arg_eids.push(aeid)
            # Evaluate args, then call with receiver prepended
            var arg_values: [i64] = []
            arg_values.push(receiver)
            for aeid in all_arg_eids:
                val av = eval_expr(aeid)
                if eval_had_error: return -1
                arg_values.push(av)
            return eval_method_with_args(decl_id, arg_values)

    eval_set_error("no method '" + method_name + "' on " + val_kind_name(kind))
    -1

fn eval_method_with_args(decl_id: i64, arg_values: [i64]) -> i64:
    val d_node = decl_get(decl_id)
    val param_names = d_node.param_names
    val body_stmts = d_node.body_stmts

    env_push_scope()
    # Bind self + params
    var pi: i64 = 0
    for pname in param_names:
        if pi < arg_values.len():
            env_define(pname, arg_values[pi])
        else:
            env_define(pname, val_make_nil())
        pi = pi + 1

    var last_val = val_make_nil()
    for sid in body_stmts:
        if eval_had_error: break
        if eval_returning: break
        last_val = eval_stmt(sid)

    if eval_returning:
        last_val = eval_return_value
        eval_returning = false
        eval_return_value = -1

    env_pop_scope()
    last_val

# ===== Array Methods =====

fn eval_array_method(receiver: i64, method_name: text, arg_eids: [i64]) -> i64:
    val elements = val_get_array(receiver)

    if method_name == "len":
        return val_make_int(elements.len())

    if method_name == "push":
        if arg_eids.len() > 0:
            val new_elem = eval_expr(arg_eids[0])
            if eval_had_error: return -1
            var new_elems: [i64] = []
            for e in elements:
                new_elems.push(e)
            new_elems.push(new_elem)
            return val_make_array(new_elems)
        return receiver

    if method_name == "contains":
        if arg_eids.len() > 0:
            val target = eval_expr(arg_eids[0])
            if eval_had_error: return -1
            for e in elements:
                if val_equals(e, target): return val_make_bool(true)
            return val_make_bool(false)
        return val_make_bool(false)

    eval_set_error("no method '" + method_name + "' on array")
    -1

# ===== Text Methods =====

fn eval_text_method(receiver: i64, method_name: text, arg_eids: [i64]) -> i64:
    val s = val_get_text(receiver)

    if method_name == "len":
        return val_make_int(s.len())

    if method_name == "contains":
        if arg_eids.len() > 0:
            val target = eval_expr(arg_eids[0])
            if eval_had_error: return -1
            val t = val_get_text(target)
            return val_make_bool(s.contains(t))
        return val_make_bool(false)

    eval_set_error("no method '" + method_name + "' on text")
    -1

# ===== Field Access =====

fn eval_field_access(eid: i64) -> i64:
    val e_node = expr_get(eid)
    val base_eid = e_node.left
    val field_name = e_node.s_val

    val base_val = eval_expr(base_eid)
    if eval_had_error: return -1

    if val_is_struct(base_val):
        # Fast path: cached field index from previous access
        val cached_idx = expr_i_val[eid]
        if cached_idx >= 0:
            val ok = val_struct_check_field_idx(base_val, cached_idx, field_name)
            if ok:
                return val_struct_get_field_idx(base_val, cached_idx)
        # Slow path: linear search + cache index
        val fi = val_struct_find_field_idx(base_val, field_name)
        if fi >= 0:
            expr_i_val[eid] = fi
            return val_struct_get_field_idx(base_val, fi)
        eval_set_error("no field '" + field_name + "' on struct " + val_get_struct_name(base_val))
        return -1

    eval_set_error("cannot access field on " + val_kind_name(val_get_kind(base_val)))
    -1

# ===== Index Expression =====

fn eval_index_expr(eid: i64) -> i64:
    val e_node = expr_get(eid)
    val base_eid = e_node.left
    val index_eid = e_node.right

    val base_val = eval_expr(base_eid)
    if eval_had_error: return -1
    val index_val = eval_expr(index_eid)
    if eval_had_error: return -1

    if val_is_array(base_val):
        val elements = val_get_array(base_val)
        if val_is_int(index_val):
            val idx = val_get_int(index_val)
            if idx >= 0:
                val len = elements.len()
                if idx < len:
                    return elements[idx]
            eval_set_error("array index out of bounds: " + "{idx}")
            return -1

    if val_is_text(base_val):
        val s = val_get_text(base_val)
        if val_is_int(index_val):
            val idx = val_get_int(index_val)
            if idx >= 0:
                if idx < s.len():
                    return val_make_text(s[idx])
            eval_set_error("string index out of bounds: " + "{idx}")
            return -1

    eval_set_error("cannot index " + val_kind_name(val_get_kind(base_val)))
    -1

# ===== Slice Expression =====

fn eval_slice_expr(eid: i64) -> i64:
    """Evaluate slice expression: base[start:end]

    Handles string and array slicing with support for:
    - [:end] - slice from start (start=0)
    - [start:] - slice to end (end=-1 means len)
    - [start:end] - explicit range
    """
    val e_node = expr_get(eid)
    val base_eid = e_node.left
    val start_eid = e_node.right
    val end_eid = e_node.extra

    val base_val = eval_expr(base_eid)
    if eval_had_error: return -1
    val start_val = eval_expr(start_eid)
    if eval_had_error: return -1
    val end_val = eval_expr(end_eid)
    if eval_had_error: return -1

    if val_is_text(base_val):
        val s = val_get_text(base_val)
        val slen = s.len()

        # Get start index (default 0)
        var start_idx = 0
        if val_is_int(start_val):
            start_idx = val_get_int(start_val)
            if start_idx < 0:
                start_idx = 0

        # Get end index (default slen, -1 means slen)
        var end_idx = slen
        if val_is_int(end_val):
            end_idx = val_get_int(end_val)
            if end_idx < 0:
                end_idx = slen
            if end_idx > slen:
                end_idx = slen

        # Slice the string
        if start_idx >= slen:
            return val_make_text("")
        if end_idx <= start_idx:
            return val_make_text("")

        return val_make_text(s[start_idx:end_idx])

    if val_is_array(base_val):
        val elements = val_get_array(base_val)
        val alen = elements.len()

        # Get start index (default 0)
        var start_idx = 0
        if val_is_int(start_val):
            start_idx = val_get_int(start_val)
            if start_idx < 0:
                start_idx = 0

        # Get end index (default alen, -1 means alen)
        var end_idx = alen
        if val_is_int(end_val):
            end_idx = val_get_int(end_val)
            if end_idx < 0:
                end_idx = alen
            if end_idx > alen:
                end_idx = alen

        # Slice the array
        var result: [i64] = []
        if start_idx < alen and end_idx > start_idx:
            for i in start_idx..end_idx:
                result.push(elements[i])

        return val_make_array(result)

    eval_set_error("cannot slice " + val_kind_name(val_get_kind(base_val)))
    -1

# ===== Array Literal =====

fn eval_array_lit(eid: i64) -> i64:
    val elem_eids = expr_get(eid).args
    var elements: [i64] = []
    for e_eid in elem_eids:
        val ev = eval_expr(e_eid)
        if eval_had_error: return -1
        elements.push(ev)
    val_make_array(elements)

# ===== Struct Literal =====

fn eval_struct_lit(eid: i64) -> i64:
    val e_node = expr_get(eid)
    val type_name = e_node.s_val
    val field_name_eids = e_node.args
    val field_value_eids = e_node.stmts

    # Field names stored as ident expressions
    var field_names: [text] = []
    for fn_eid in field_name_eids:
        field_names.push(expr_get(fn_eid).s_val)

    var field_values: [i64] = []
    for fv_eid in field_value_eids:
        val fv = eval_expr(fv_eid)
        if eval_had_error: return -1
        field_values.push(fv)

    val_make_struct(type_name, field_names, field_values)

# ===== Assignment Expression =====

fn eval_assign_expr(eid: i64) -> i64:
    val e_node = expr_get(eid)
    val target_eid = e_node.left
    val value_eid = e_node.right

    val new_val = eval_expr(value_eid)
    if eval_had_error: return -1

    val target_node = expr_get(target_eid)
    val target_tag = target_node.tag
    if target_tag == EXPR_IDENT:
        val name = target_node.s_val
        val ok = env_assign(name, new_val)
        if ok == false:
            eval_set_error("undefined variable: " + name)
            return -1
        return new_val

    if target_tag == EXPR_FIELD_ACCESS:
        val base_eid2 = target_node.left
        val field_name = target_node.s_val
        val base_val = eval_expr(base_eid2)
        if eval_had_error: return -1
        if val_is_struct(base_val):
            # Fast path: cached field index
            val cached_idx = expr_i_val[target_eid]
            if cached_idx >= 0:
                val ok = val_struct_check_field_idx(base_val, cached_idx, field_name)
                if ok:
                    val_struct_set_field_idx(base_val, cached_idx, new_val)
                    return new_val
            # Slow path: find + set + cache
            val fi = val_struct_find_field_idx(base_val, field_name)
            if fi >= 0:
                val_struct_set_field_idx(base_val, fi, new_val)
                expr_i_val[target_eid] = fi
                return new_val
            eval_set_error("no field '" + field_name + "' on struct " + val_get_struct_name(base_val))
            return -1
        eval_set_error("cannot set field on " + val_kind_name(val_get_kind(base_val)))
        return -1

    eval_set_error("invalid assignment target")
    -1

fn eval_compound_assign_expr(eid: i64) -> i64:
    val e_node = expr_get(eid)
    val op = e_node.i_val
    val target_eid = e_node.left
    val value_eid = e_node.right

    val target_node = expr_get(target_eid)
    val target_tag = target_node.tag
    if target_tag == EXPR_IDENT:
        val name = target_node.s_val
        val old_val = env_lookup(name)
        if old_val < 0:
            eval_set_error("undefined variable: " + name)
            return -1
        val rhs_val = eval_expr(value_eid)
        if eval_had_error: return -1
        val new_val = val_compound_op(op, old_val, rhs_val)
        if new_val < 0:
            val err = ops_get_error()
            if err != "":
                eval_set_error(err)
            return -1
        env_assign(name, new_val)
        return new_val

    eval_set_error("invalid compound assignment target")
    -1

# ===== Return Expression =====

fn eval_return_expr(eid: i64) -> i64:
    val value_eid = expr_get(eid).left
    var ret_val = val_make_nil()
    if value_eid >= 0:
        ret_val = eval_expr(value_eid)
        if eval_had_error: return -1
    eval_returning = true
    eval_return_value = ret_val
    ret_val

# ===== Interpolated String =====

fn eval_interpolated_string(eid: i64) -> i64:
    val parts = expr_get(eid).args
    var parts_text: [text] = []
    for part_eid in parts:
        val part_val = eval_expr(part_eid)
        if eval_had_error: return -1
        parts_text = parts_text + [val_to_text(part_val)]
    val result = parts_text.join("")
    val_make_text(result)

# ===== Null Coalesce =====

fn eval_null_coalesce(eid: i64) -> i64:
    val e_node = expr_get(eid)
    val left = eval_expr(e_node.left)
    if eval_had_error: return -1
    if val_is_nil(left) == false: return left
    eval_expr(e_node.right)

# ===== Builtin Functions =====
# Returns >= -1 if handled (value_id or -1 for error), returns -2 if not a builtin

fn eval_builtin_call(name: text, arg_eids: [i64]) -> i64:
    if name == "print":
        if arg_eids.len() > 0:
            val arg_val = eval_expr(arg_eids[0])
            if eval_had_error: return -1
            print val_to_text(arg_val)
        else:
            print ""
        return val_make_nil()

    if name == "println":
        if arg_eids.len() > 0:
            val arg_val = eval_expr(arg_eids[0])
            if eval_had_error: return -1
            print val_to_text(arg_val)
        else:
            print ""
        return val_make_nil()

    # __mixin(code_text) — compile-time code generation
    # Parses code_text as Simple source and registers new declarations into the
    # current module's function/struct tables so they can be called immediately.
    if name == "__mixin":
        if arg_eids.len() >= 1:
            val mx_code_val = eval_expr(arg_eids[0])
            if eval_had_error: return -1
            val mx_code = val_to_text(mx_code_val)
            val mx_old_count = module_get_decls().len()
            parse_module_file(mx_code, "mixin_generated.spl")
            val mx_all_decls = module_get_decls()
            val mx_new_count = mx_all_decls.len()
            var mx_i = mx_old_count
            while mx_i < mx_new_count:
                val mx_did = mx_all_decls[mx_i]
                val mx_tag = decl_get(mx_did).tag
                if mx_tag == DECL_FN:
                    val mx_fn_name = decl_get(mx_did).name
                    func_table_register(mx_fn_name, mx_did)
                    func_register_return_type(mx_fn_name, decl_get(mx_did).ret_type)
                if mx_tag == DECL_STRUCT:
                    val mx_struct_name = decl_get(mx_did).name
                    struct_table_register(mx_struct_name, mx_did)
                mx_i = mx_i + 1
            mx_i = mx_old_count
            while mx_i < mx_new_count:
                if eval_had_error: break
                val mx_did2 = mx_all_decls[mx_i]
                val mx_tag2 = decl_get(mx_did2).tag
                if mx_tag2 == DECL_VAL or mx_tag2 == DECL_VAR or mx_tag2 == DECL_ENUM or mx_tag2 == EVAL_DECL_LAZY_VAL:
                    eval_decl(mx_did2)
                mx_i = mx_i + 1
            return val_make_nil()
        return val_make_nil()

    # pragma_msg(expr) — prints expr value at eval time (compile-time diagnostic)
    if name == "pragma_msg":
        if arg_eids.len() > 0:
            val pm_val = eval_expr(arg_eids[0])
            if eval_had_error: return -1
            print val_to_text(pm_val)
        return val_make_nil()

    if name == "int":
        if arg_eids.len() > 0:
            val arg_val = eval_expr(arg_eids[0])
            if eval_had_error: return -1
            val kind = val_get_kind(arg_val)
            if kind == VAL_INT: return arg_val
            if kind == VAL_FLOAT:
                # Truncate float to int
                return val_make_int(int(val_get_float(arg_val)))
            if kind == VAL_TEXT:
                return val_make_int(int(val_get_text(arg_val)))
            if kind == VAL_BOOL:
                if val_get_bool(arg_val): return val_make_int(1)
                return val_make_int(0)
        return val_make_int(0)

    if name == "type_of":
        if arg_eids.len() > 0:
            val arg_val = eval_expr(arg_eids[0])
            if eval_had_error: return -1
            return val_make_text(val_kind_name(val_get_kind(arg_val)))
        return val_make_text("nil")

    if name == "len":
        if arg_eids.len() > 0:
            val arg_val = eval_expr(arg_eids[0])
            if eval_had_error: return -1
            val kind = val_get_kind(arg_val)
            if kind == VAL_ARRAY: return val_make_int(val_get_array(arg_val).len())
            if kind == VAL_TEXT: return val_make_int(val_get_text(arg_val).len())
        return val_make_int(0)

    if name == "to_text":
        if arg_eids.len() > 0:
            val arg_val = eval_expr(arg_eids[0])
            if eval_had_error: return -1
            return val_make_text(val_to_text(arg_val))
        return val_make_text("")

    # Annotation intrinsic: @static_assert(condition, message)
    # Evaluates condition at module load time; panics if false
    if name == "@static_assert":
        if arg_eids.len() >= 2:
            val sa_cond = eval_expr(arg_eids[0])
            if eval_had_error: return -1
            if val_is_truthy(sa_cond) == false:
                val sa_msg_val = eval_expr(arg_eids[1])
                if eval_had_error: return -1
                val sa_msg = val_to_text(sa_msg_val)
                eval_set_error("static_assert failed: " + sa_msg)
                return -1
        elif arg_eids.len() == 1:
            val sa_cond2 = eval_expr(arg_eids[0])
            if eval_had_error: return -1
            if val_is_truthy(sa_cond2) == false:
                eval_set_error("static_assert failed")
                return -1
        return val_make_nil()

    # @traits(query, T, ...) — compile-time introspection built-in
    if name == "__traits":
        if arg_eids.len() < 1:
            return val_make_array([])
        val tr_query_val = eval_expr(arg_eids[0])
        if eval_had_error: return -1
        val tr_query = val_to_text(tr_query_val)

        # @traits("fields", "TypeName") — returns [text] of field names
        if tr_query == "fields":
            if arg_eids.len() >= 2:
                val tr_type_val = eval_expr(arg_eids[1])
                if eval_had_error: return -1
                val tr_type_name = val_to_text(tr_type_val)
                val tr_struct_decl = struct_table_lookup(tr_type_name)
                if tr_struct_decl >= 0:
                    val tr_field_names = decl_get_fields(tr_struct_decl)
                    var tr_result: [i64] = []
                    for tr_fname in tr_field_names:
                        tr_result.push(val_make_text(tr_fname))
                    return val_make_array(tr_result)
            return val_make_array([])

        # @traits("has_member", "TypeName", "fieldName") — bool
        if tr_query == "has_member":
            if arg_eids.len() >= 3:
                val tr_type_val2 = eval_expr(arg_eids[1])
                if eval_had_error: return -1
                val tr_member_val = eval_expr(arg_eids[2])
                if eval_had_error: return -1
                val tr_type_name2 = val_to_text(tr_type_val2)
                val tr_member_name = val_to_text(tr_member_val)
                val tr_struct_decl2 = struct_table_lookup(tr_type_name2)
                if tr_struct_decl2 >= 0:
                    val tr_fields2 = decl_get_fields(tr_struct_decl2)
                    for tr_f2 in tr_fields2:
                        if tr_f2 == tr_member_name:
                            return val_make_bool(true)
                return val_make_bool(false)
            return val_make_bool(false)

        # @traits("enum_members", "EnumName") — returns [text] of variant names
        if tr_query == "enum_members":
            if arg_eids.len() >= 2:
                val tr_enum_type_val = eval_expr(arg_eids[1])
                if eval_had_error: return -1
                val tr_enum_name = val_to_text(tr_enum_type_val)
                val tr_variants_csv = enum_table_lookup(tr_enum_name)
                if tr_variants_csv != "":
                    var tr_enum_result: [i64] = []
                    var tr_vi = 0
                    var tr_vstart = 0
                    while tr_vi <= tr_variants_csv.len():
                        val tr_at_end = tr_vi == tr_variants_csv.len()
                        var tr_is_comma = false
                        if tr_at_end == false:
                            val tr_ch = tr_variants_csv[tr_vi:tr_vi+1]
                            tr_is_comma = tr_ch == ","
                        val tr_split = tr_at_end or tr_is_comma
                        if tr_split:
                            if tr_vi > tr_vstart:
                                val tr_variant = tr_variants_csv[tr_vstart:tr_vi]
                                tr_enum_result.push(val_make_text(tr_variant))
                            tr_vstart = tr_vi + 1
                        tr_vi = tr_vi + 1
                    return val_make_array(tr_enum_result)
            return val_make_array([])

        # @traits("is_struct", "TypeName") — bool
        if tr_query == "is_struct":
            if arg_eids.len() >= 2:
                val tr_is_type_val = eval_expr(arg_eids[1])
                if eval_had_error: return -1
                val tr_is_type_name = val_to_text(tr_is_type_val)
                val tr_is_struct_decl = struct_table_lookup(tr_is_type_name)
                return val_make_bool(tr_is_struct_decl >= 0)
            return val_make_bool(false)

        # @traits("is_enum", "TypeName") — bool
        if tr_query == "is_enum":
            if arg_eids.len() >= 2:
                val tr_ie_type_val = eval_expr(arg_eids[1])
                if eval_had_error: return -1
                val tr_ie_type_name = val_to_text(tr_ie_type_val)
                val tr_ie_variants = enum_table_lookup(tr_ie_type_name)
                return val_make_bool(tr_ie_variants != "")
            return val_make_bool(false)

        # @traits("is_phantom", "TypeName") — bool: true if struct is registered as phantom
        if tr_query == "is_phantom":
            if arg_eids.len() >= 2:
                val tr_ip_type_val = eval_expr(arg_eids[1])
                if eval_had_error: return -1
                val tr_ip_type_name = val_to_text(tr_ip_type_val)
                return val_make_bool(phantom_struct_is_registered(tr_ip_type_name))
            return val_make_bool(false)

        # @traits("get_member", obj, "fieldName") — value of field by name
        if tr_query == "get_member":
            if arg_eids.len() >= 3:
                val tr_gm_obj = eval_expr(arg_eids[1])
                if eval_had_error: return -1
                val tr_gm_field_val = eval_expr(arg_eids[2])
                if eval_had_error: return -1
                val tr_gm_field = val_to_text(tr_gm_field_val)
                val tr_gm_fields = val_get_struct_fields(tr_gm_obj)
                val tr_gm_values = val_get_struct_values(tr_gm_obj)
                var tr_gm_i = 0
                for tr_gm_f in tr_gm_fields:
                    if tr_gm_f == tr_gm_field:
                        if tr_gm_i < tr_gm_values.len():
                            return tr_gm_values[tr_gm_i]
                    tr_gm_i = tr_gm_i + 1
            return val_make_nil()

        # @traits("type_name", "TypeName") — returns type name as text
        if tr_query == "type_name":
            if arg_eids.len() >= 2:
                val tr_tn_val = eval_expr(arg_eids[1])
                if eval_had_error: return -1
                return val_make_text(val_to_text(tr_tn_val))
            return val_make_text("unknown")

        # @traits("file"), @traits("line"), @traits("function") — source location
        if tr_query == "file":
            return val_make_text(module_get_path())
        if tr_query == "line":
            return val_make_int(1)
        if tr_query == "function":
            if eval_current_decl_id >= 0:
                val tr_fn_node = decl_get(eval_current_decl_id)
                return val_make_text(tr_fn_node.name)
            return val_make_text("<module>")

        # @static_assert(cond, msg) — compile-time assertion
        # Desugared by parser to __traits("static_assert", cond, msg)
        if tr_query == "static_assert":
            if arg_eids.len() >= 3:
                val sa_tr_cond = eval_expr(arg_eids[1])
                if eval_had_error: return -1
                if val_is_truthy(sa_tr_cond) == false:
                    val sa_tr_msg_val = eval_expr(arg_eids[2])
                    if eval_had_error: return -1
                    val sa_tr_msg = val_to_text(sa_tr_msg_val)
                    eval_set_error("static_assert failed: " + sa_tr_msg)
                    return -1
            elif arg_eids.len() == 2:
                val sa_tr_cond2 = eval_expr(arg_eids[1])
                if eval_had_error: return -1
                if val_is_truthy(sa_tr_cond2) == false:
                    eval_set_error("static_assert failed")
                    return -1
            return val_make_nil()

        # @traits("methods", "TypeName") — return method names for a struct type
        # Methods are registered in func_table as "TypeName__methodName"
        if tr_query == "methods":
            if arg_eids.len() >= 2:
                val tr_mth_type_val = eval_expr(arg_eids[1])
                if eval_had_error: return -1
                val tr_mth_type_name = val_to_text(tr_mth_type_val)
                val tr_mth_prefix = tr_mth_type_name + "__"
                val tr_mth_prefix_len = tr_mth_prefix.len()
                var tr_mth_result: [i64] = []
                for tr_mth_key in ft_keys:
                    if tr_mth_key.len() > tr_mth_prefix_len:
                        val tr_mth_kpfx = tr_mth_key[0:tr_mth_prefix_len]
                        if tr_mth_kpfx == tr_mth_prefix:
                            val tr_mth_mname = tr_mth_key[tr_mth_prefix_len:tr_mth_key.len()]
                            tr_mth_result.push(val_make_text(tr_mth_mname))
                return val_make_array(tr_mth_result)
            return val_make_array([])

        # @traits("all_members", "TypeName") — fields + methods combined
        if tr_query == "all_members":
            if arg_eids.len() >= 2:
                val tr_am_type_val = eval_expr(arg_eids[1])
                if eval_had_error: return -1
                val tr_am_type_name = val_to_text(tr_am_type_val)
                var tr_am_result: [i64] = []
                # Add fields
                val tr_am_struct_decl = struct_table_lookup(tr_am_type_name)
                if tr_am_struct_decl >= 0:
                    val tr_am_field_names = decl_get_fields(tr_am_struct_decl)
                    for tr_am_fname in tr_am_field_names:
                        tr_am_result.push(val_make_text(tr_am_fname))
                # Add methods
                val tr_am_prefix = tr_am_type_name + "__"
                val tr_am_prefix_len = tr_am_prefix.len()
                for tr_am_key in ft_keys:
                    if tr_am_key.len() > tr_am_prefix_len:
                        val tr_am_kpfx = tr_am_key[0:tr_am_prefix_len]
                        if tr_am_kpfx == tr_am_prefix:
                            val tr_am_mname = tr_am_key[tr_am_prefix_len:tr_am_key.len()]
                            tr_am_result.push(val_make_text(tr_am_mname))
                return val_make_array(tr_am_result)
            return val_make_array([])

        # @traits("enum_count", "EnumName") — count of enum variants
        if tr_query == "enum_count":
            if arg_eids.len() >= 2:
                val tr_ec_type_val = eval_expr(arg_eids[1])
                if eval_had_error: return -1
                val tr_ec_type_name = val_to_text(tr_ec_type_val)
                val tr_ec_variants_csv = enum_table_lookup(tr_ec_type_name)
                if tr_ec_variants_csv == "":
                    return val_make_int(0)
                var tr_ec_count = 1
                var tr_ec_i = 0
                while tr_ec_i < tr_ec_variants_csv.len():
                    val tr_ec_ch = tr_ec_variants_csv[tr_ec_i:tr_ec_i+1]
                    if tr_ec_ch == ",":
                        tr_ec_count = tr_ec_count + 1
                    tr_ec_i = tr_ec_i + 1
                return val_make_int(tr_ec_count)
            return val_make_int(0)

        # @traits("is_class", "TypeName") — true if type has struct decl AND registered methods
        if tr_query == "is_class":
            if arg_eids.len() >= 2:
                val tr_ic_type_val = eval_expr(arg_eids[1])
                if eval_had_error: return -1
                val tr_ic_type_name = val_to_text(tr_ic_type_val)
                val tr_ic_struct_decl = struct_table_lookup(tr_ic_type_name)
                if tr_ic_struct_decl < 0:
                    return val_make_bool(false)
                val tr_ic_prefix = tr_ic_type_name + "__"
                val tr_ic_prefix_len = tr_ic_prefix.len()
                for tr_ic_key in ft_keys:
                    if tr_ic_key.len() > tr_ic_prefix_len:
                        val tr_ic_kpfx = tr_ic_key[0:tr_ic_prefix_len]
                        if tr_ic_kpfx == tr_ic_prefix:
                            return val_make_bool(true)
                return val_make_bool(false)
            return val_make_bool(false)

        # @traits("is_fn", "funcName") — true if function name exists in func_table
        if tr_query == "is_fn":
            if arg_eids.len() >= 2:
                val tr_if_val = eval_expr(arg_eids[1])
                if eval_had_error: return -1
                val tr_if_name = val_to_text(tr_if_val)
                val tr_if_decl = func_table_lookup(tr_if_name)
                return val_make_bool(tr_if_decl >= 0)
            return val_make_bool(false)

        # @traits("is_integral", "typeName") — true if integral numeric type
        if tr_query == "is_integral":
            if arg_eids.len() >= 2:
                val tr_ii_val = eval_expr(arg_eids[1])
                if eval_had_error: return -1
                val tr_ii_name = val_to_text(tr_ii_val)
                if tr_ii_name == "i64": return val_make_bool(true)
                if tr_ii_name == "i32": return val_make_bool(true)
                if tr_ii_name == "i16": return val_make_bool(true)
                if tr_ii_name == "i8": return val_make_bool(true)
                if tr_ii_name == "u64": return val_make_bool(true)
                if tr_ii_name == "u32": return val_make_bool(true)
                if tr_ii_name == "u16": return val_make_bool(true)
                if tr_ii_name == "u8": return val_make_bool(true)
                if tr_ii_name == "isize": return val_make_bool(true)
                if tr_ii_name == "usize": return val_make_bool(true)
                return val_make_bool(false)
            return val_make_bool(false)

        # @traits("is_float", "typeName") — true if floating-point type
        if tr_query == "is_float":
            if arg_eids.len() >= 2:
                val tr_ifl_val = eval_expr(arg_eids[1])
                if eval_had_error: return -1
                val tr_ifl_name = val_to_text(tr_ifl_val)
                if tr_ifl_name == "f64": return val_make_bool(true)
                if tr_ifl_name == "f32": return val_make_bool(true)
                return val_make_bool(false)
            return val_make_bool(false)

        # @traits("is_numeric", "typeName") — true if integral or float
        if tr_query == "is_numeric":
            if arg_eids.len() >= 2:
                val tr_in_val = eval_expr(arg_eids[1])
                if eval_had_error: return -1
                val tr_in_name = val_to_text(tr_in_val)
                if tr_in_name == "i64": return val_make_bool(true)
                if tr_in_name == "i32": return val_make_bool(true)
                if tr_in_name == "i16": return val_make_bool(true)
                if tr_in_name == "i8": return val_make_bool(true)
                if tr_in_name == "u64": return val_make_bool(true)
                if tr_in_name == "u32": return val_make_bool(true)
                if tr_in_name == "u16": return val_make_bool(true)
                if tr_in_name == "u8": return val_make_bool(true)
                if tr_in_name == "isize": return val_make_bool(true)
                if tr_in_name == "usize": return val_make_bool(true)
                if tr_in_name == "f64": return val_make_bool(true)
                if tr_in_name == "f32": return val_make_bool(true)
                return val_make_bool(false)
            return val_make_bool(false)

        # @traits("is_array", "typeName") — true if type name starts with "["
        if tr_query == "is_array":
            if arg_eids.len() >= 2:
                val tr_ia_val = eval_expr(arg_eids[1])
                if eval_had_error: return -1
                val tr_ia_name = val_to_text(tr_ia_val)
                if tr_ia_name.len() >= 2:
                    val tr_ia_first = tr_ia_name[0:1]
                    return val_make_bool(tr_ia_first == "[")
                return val_make_bool(false)
            return val_make_bool(false)

        # @traits("is_dict", "typeName") — true if type name starts with "{"
        if tr_query == "is_dict":
            if arg_eids.len() >= 2:
                val tr_id_val = eval_expr(arg_eids[1])
                if eval_had_error: return -1
                val tr_id_name = val_to_text(tr_id_val)
                if tr_id_name.len() >= 2:
                    val tr_id_first = tr_id_name[0:1]
                    return val_make_bool(tr_id_first == "{")
                return val_make_bool(false)
            return val_make_bool(false)

        # @traits("member_type", "TypeName", "fieldName") — field type as text from struct decl
        if tr_query == "member_type":
            if arg_eids.len() >= 3:
                val tr_mt_type_val = eval_expr(arg_eids[1])
                if eval_had_error: return -1
                val tr_mt_field_val = eval_expr(arg_eids[2])
                if eval_had_error: return -1
                val tr_mt_type_name = val_to_text(tr_mt_type_val)
                val tr_mt_field_name = val_to_text(tr_mt_field_val)
                val tr_mt_struct_decl = struct_table_lookup(tr_mt_type_name)
                if tr_mt_struct_decl >= 0:
                    val tr_mt_field_names = decl_get_fields(tr_mt_struct_decl)
                    val tr_mt_field_types = decl_get_field_types(tr_mt_struct_decl)
                    var tr_mt_i = 0
                    for tr_mt_fname in tr_mt_field_names:
                        if tr_mt_fname == tr_mt_field_name:
                            if tr_mt_i < tr_mt_field_types.len():
                                return val_make_text(tr_mt_field_types[tr_mt_i])
                            return val_make_text("unknown")
                        tr_mt_i = tr_mt_i + 1
                return val_make_text("")
            return val_make_text("")

        # @traits("set_member", obj, "fieldName", value) — set struct field by name
        if tr_query == "set_member":
            if arg_eids.len() >= 4:
                val tr_sm_obj = eval_expr(arg_eids[1])
                if eval_had_error: return -1
                val tr_sm_field_val = eval_expr(arg_eids[2])
                if eval_had_error: return -1
                val tr_sm_new_val = eval_expr(arg_eids[3])
                if eval_had_error: return -1
                val tr_sm_field = val_to_text(tr_sm_field_val)
                val_struct_set_field(tr_sm_obj, tr_sm_field, tr_sm_new_val)
                return val_make_nil()
            return val_make_nil()

        # @traits("compiles", expr) — returns bool true if expr evaluates without error
        if tr_query == "compiles":
            if arg_eids.len() >= 2:
                val old_had_error = eval_had_error
                val old_error_msg = eval_error_msg
                eval_had_error = false
                eval_error_msg = ""
                val comp_eid = arg_eids[1]
                eval_expr(comp_eid)
                val compiled_ok = not eval_had_error
                eval_had_error = old_had_error
                eval_error_msg = old_error_msg
                return val_make_bool(compiled_ok)
            return val_make_bool(false)

        # @traits("get_annotations", "sym_name") — returns [text] of known annotations
        if tr_query == "get_annotations":
            if arg_eids.len() >= 2:
                val ann_sym = val_to_text(eval_expr(arg_eids[1]))
                if eval_had_error: return -1
                var ann_list: [i64] = []
                if must_use_is_registered(ann_sym):
                    ann_list.push(val_make_text("must_use"))
                return val_make_array(ann_list)
            return val_make_array([])

        # @traits("has_annotation", "sym_name", "ann_name") — returns bool
        if tr_query == "has_annotation":
            if arg_eids.len() >= 3:
                val ha_sym = val_to_text(eval_expr(arg_eids[1]))
                if eval_had_error: return -1
                val ha_ann = val_to_text(eval_expr(arg_eids[2]))
                if eval_had_error: return -1
                if ha_ann == "must_use":
                    return val_make_bool(must_use_is_registered(ha_sym))
                return val_make_bool(false)
            return val_make_bool(false)

        # @traits("module_name") — returns current module path as text
        if tr_query == "module_name":
            return val_make_text(module_get_path())

        # @traits("identifier", sym_expr) — returns the text name of a symbol
        if tr_query == "identifier":
            if arg_eids.len() >= 2:
                val id_eid = arg_eids[1]
                if expr_get(id_eid).tag == 6:
                    return val_make_text(expr_get(id_eid).s_val)
                val id_val = eval_expr(id_eid)
                if eval_had_error: return -1
                return val_make_text(val_to_text(id_val))
            return val_make_text("")

        # @traits("module_file", "dotted.module.name") → File struct
        if tr_query == "module_file":
            if arg_eids.len() >= 2:
                val mf_mod_val = eval_expr(arg_eids[1])
                if eval_had_error: return -1
                val mf_mod_name = val_to_text(mf_mod_val)
                val mf_file_path = module_get_file_path(mf_mod_name)
                val mf_exists = mf_file_path != ""
                var mf_fields: [text] = ["path", "module_name", "exists"]
                var mf_vals: [i64] = []
                mf_vals.push(val_make_text(mf_file_path))
                mf_vals.push(val_make_text(mf_mod_name))
                mf_vals.push(val_make_bool(mf_exists))
                return val_make_struct("File", mf_fields, mf_vals)
            return val_make_nil()

        # @traits("class_info", "TypeName") → Class struct
        if tr_query == "class_info":
            if arg_eids.len() >= 2:
                val ci_type_val = eval_expr(arg_eids[1])
                if eval_had_error: return -1
                val ci_type_name = val_to_text(ci_type_val)
                val ci_struct_decl = struct_table_lookup(ci_type_name)
                if ci_struct_decl < 0:
                    return val_make_nil()
                val ci_field_names = decl_get_fields(ci_struct_decl)
                var ci_fields_arr: [i64] = []
                for ci_fn in ci_field_names:
                    ci_fields_arr.push(val_make_text(ci_fn))
                val ci_prefix = ci_type_name + "__"
                val ci_prefix_len = ci_prefix.len()
                var ci_methods_arr: [i64] = []
                for ci_key in ft_keys:
                    if ci_key.len() > ci_prefix_len:
                        val ci_kpfx = ci_key[0:ci_prefix_len]
                        if ci_kpfx == ci_prefix:
                            val ci_mname = ci_key[ci_prefix_len:ci_key.len()]
                            ci_methods_arr.push(val_make_text(ci_mname))
                val ci_mod = struct_table_get_module(ci_type_name)
                val ci_file = module_get_file_path(ci_mod)
                var ci_s_fields: [text] = ["name", "module_name", "file_path", "fields", "methods", "field_count", "method_count"]
                var ci_s_vals: [i64] = []
                ci_s_vals.push(val_make_text(ci_type_name))
                ci_s_vals.push(val_make_text(ci_mod))
                ci_s_vals.push(val_make_text(ci_file))
                ci_s_vals.push(val_make_array(ci_fields_arr))
                ci_s_vals.push(val_make_array(ci_methods_arr))
                ci_s_vals.push(val_make_int(ci_field_names.len()))
                ci_s_vals.push(val_make_int(ci_methods_arr.len()))
                return val_make_struct("Class", ci_s_fields, ci_s_vals)
            return val_make_nil()

        # @traits("module_wildcard", "dotted.prefix") → [File]
        if tr_query == "module_wildcard":
            if arg_eids.len() >= 2:
                val mw_prefix_val = eval_expr(arg_eids[1])
                if eval_had_error: return -1
                val mw_prefix = val_to_text(mw_prefix_val) + "."
                var mw_result: [i64] = []
                var mw_i: i64 = 0
                for mw_path in loaded_module_paths:
                    if mw_path.starts_with(mw_prefix):
                        val mw_fp = loaded_module_file_paths[mw_i]
                        var mw_f_fields: [text] = ["path", "module_name", "exists"]
                        var mw_f_vals: [i64] = []
                        mw_f_vals.push(val_make_text(mw_fp))
                        mw_f_vals.push(val_make_text(mw_path))
                        mw_f_vals.push(val_make_bool(true))
                        mw_result.push(val_make_struct("File", mw_f_fields, mw_f_vals))
                    mw_i = mw_i + 1
                return val_make_array(mw_result)
            return val_make_array([])

        # Unknown query — return nil
        return val_make_nil()

    # Not a builtin
    -2

# ===== Statement Evaluation =====

fn eval_stmt(sid: i64) -> i64:
    if sid < 0: return val_make_nil()
    if eval_had_error: return -1
    if eval_returning: return eval_return_value
    if eval_breaking: return val_make_nil()
    if eval_continuing: return val_make_nil()

    val tag = stmt_get(sid).tag

    if tag == STMT_EXPR: return eval_stmt_expr(sid)
    if tag == STMT_VAL_DECL: return eval_stmt_val_decl(sid)
    if tag == EVAL_STMT_LAZY_VAL_DECL: return eval_stmt_lazy_val_decl(sid)
    if tag == STMT_VAR_DECL: return eval_stmt_var_decl(sid)
    if tag == STMT_ASSIGN: return eval_stmt_assign(sid)
    if tag == STMT_COMPOUND_ASSIGN: return eval_stmt_compound_assign(sid)
    if tag == STMT_RETURN: return eval_stmt_return(sid)
    if tag == STMT_IF: return eval_stmt_if(sid)
    if tag == STMT_FOR: return eval_stmt_for(sid)
    if tag == EVAL_STMT_STATIC_FOR: return eval_stmt_static_for(sid)
    if tag == EVAL_STMT_COMPTIME: return eval_stmt_comptime(sid)
    if tag == STMT_WHILE: return eval_stmt_while(sid)
    if tag == STMT_MATCH: return eval_stmt_match(sid)
    if tag == STMT_BLOCK: return eval_stmt_block(sid)
    if tag == STMT_BREAK:
        eval_breaking = true
        val break_lbl = stmt_get(sid).name
        eval_break_label = break_lbl
        return val_make_nil()
    if tag == STMT_CONTINUE:
        eval_continuing = true
        val cont_lbl = stmt_get(sid).name
        eval_continue_label = cont_lbl
        return val_make_nil()
    if tag == STMT_LABELED_LOOP:
        return eval_labeled_loop(sid)
    if tag == STMT_DEFER:
        # Add deferred expression to flat defer arrays with current depth
        val defer_eid = stmt_get(sid).expr_idx
        eval_defer_eids.push(defer_eid)
        eval_defer_depths.push(eval_defer_depth)
        return val_make_nil()
    if tag == STMT_ERRDEFER:
        # errdefer: same as defer for now (full error tracking not yet implemented)
        val errdefer_eid = stmt_get(sid).expr_idx
        eval_defer_eids.push(errdefer_eid)
        eval_defer_depths.push(eval_defer_depth)
        return val_make_nil()

    if tag == STMT_RECEIVE:
        # Interpreter stub: no real mailbox. If after arm exists, run it.
        # Otherwise run first arm's body stmts if any arms exist.
        val s_node_recv = stmt_get(sid)
        val recv_timeout_body = s_node_recv.type_tag   # after body stmt index, or -1
        if recv_timeout_body >= 0:
            return eval_stmt(recv_timeout_body)
        val recv_arms = s_node_recv.body               # arm pool indices
        if recv_arms.len() > 0:
            val first_arm_body = arm_get_body(recv_arms[0])
            var recv_last: i64 = val_make_nil()
            for recv_sid in first_arm_body:
                if eval_had_error: break
                if eval_returning: break
                recv_last = eval_stmt(recv_sid)
            return recv_last
        return val_make_nil()

    if tag == STMT_BIND:
        # bind x = expr inside ce: block — treat like val declaration
        # Short-circuits (returns nil) if RHS evaluates to nil
        val s_node_bind = stmt_get(sid)
        val bind_name = s_node_bind.name
        val bind_rhs_idx = s_node_bind.expr_idx
        val bind_rhs_val = eval_expr(bind_rhs_idx)
        if eval_had_error: return -1
        val bind_is_nil = val_kind(bind_rhs_val) == 0   # VAL_NIL = 0
        if bind_is_nil:
            return bind_rhs_val
        env_define(bind_name, bind_rhs_val)
        return bind_rhs_val

    eval_set_error("unsupported statement kind: " + "{tag}")
    -1

fn eval_stmt_expr(sid: i64) -> i64:
    val eid = stmt_get(sid).expr_idx

    # Check if this is a function call with ignored return value
    if eid >= 0:
        val e_node = expr_get(eid)
        val e_tag = e_node.tag
        if e_tag == EXPR_CALL:
            val callee_eid = e_node.left
            val callee_node = expr_get(callee_eid)
            val callee_tag = callee_node.tag
            if callee_tag == EXPR_IDENT:
                val fn_name = callee_node.s_val
                val ret_type = func_lookup_return_type(fn_name)
                val is_void = ret_type == 0
                val is_unknown = ret_type == -1
                if is_void == false and is_unknown == false:
                    if must_use_is_registered(fn_name):
                        val reason = must_use_get_reason(fn_name)
                        val msg = "error[R9]: return value of function '" + fn_name + "' must be used"
                        eval_warnings.push(msg)
                        if reason != "":
                            eval_warnings.push("  = note: " + reason)
                        eval_warnings.push("  = help: assign to variable or use 'val _ = ...' to discard")
                    elif must_use_critical_mode:
                        val type_name = type_tag_name(ret_type)
                        val msg = "error[R9]: return value of '" + fn_name + "' (" + type_name + ") discarded in @profile(critical)"
                        eval_warnings.push(msg)
                        eval_warnings.push("  = help: assign to variable or use 'val _ = ...' to discard")
                    else:
                        val type_name = type_tag_name(ret_type)
                        val warning = "warning: return value of type '" + type_name + "' from function '" + fn_name + "' is ignored"
                        eval_warnings.push(warning)

    eval_expr(eid)

fn eval_stmt_val_decl(sid: i64) -> i64:
    val s_node = stmt_get(sid)
    val name = s_node.name
    val init_eid = s_node.expr_idx
    var init_val = val_make_nil()
    if init_eid >= 0:
        init_val = eval_expr(init_eid)
        if eval_had_error: return -1
    env_define(name, init_val)
    # LOAD_FAST: also set fast local slot
    if eval_current_decl_id >= 0:
        val slot = resolve_is_fast_local(eval_current_decl_id, name)
        if slot >= 0:
            env_set_local(slot, init_val)
    init_val

fn eval_stmt_lazy_val_decl(sid: i64) -> i64:
    val s_node = stmt_get(sid)
    val name = s_node.name
    val init_eid = s_node.expr_idx
    var thunk_val = val_make_nil()
    if init_eid >= 0:
        thunk_val = val_make_thunk(init_eid)
    env_define(name, thunk_val)
    # LOAD_FAST: also set fast local slot with the thunk
    if eval_current_decl_id >= 0:
        val slot = resolve_is_fast_local(eval_current_decl_id, name)
        if slot >= 0:
            env_set_local(slot, thunk_val)
    thunk_val

fn eval_stmt_var_decl(sid: i64) -> i64:
    val s_node = stmt_get(sid)
    val name = s_node.name
    val init_eid = s_node.expr_idx
    var init_val = val_make_nil()
    if init_eid >= 0:
        init_val = eval_expr(init_eid)
        if eval_had_error: return -1
    env_define(name, init_val)
    # LOAD_FAST: also set fast local slot
    if eval_current_decl_id >= 0:
        val slot = resolve_is_fast_local(eval_current_decl_id, name)
        if slot >= 0:
            env_set_local(slot, init_val)
    init_val

fn eval_stmt_assign(sid: i64) -> i64:
    val s_node = stmt_get(sid)
    val target_eid = s_node.expr_idx
    val value_stmts = s_node.body
    if value_stmts.len() == 0:
        eval_set_error("assignment missing value")
        return -1
    val value_eid = value_stmts[0]

    val new_val = eval_expr(value_eid)
    if eval_had_error: return -1

    val target_node = expr_get(target_eid)
    val target_tag = target_node.tag
    if target_tag == EXPR_IDENT:
        val name = target_node.s_val
        val ok = env_assign(name, new_val)
        if ok == false:
            eval_set_error("undefined variable: " + name)
            return -1
        # LOAD_FAST: also update fast local slot
        if eval_current_decl_id >= 0:
            val slot = resolve_is_fast_local(eval_current_decl_id, name)
            if slot >= 0:
                env_set_local(slot, new_val)
        return new_val

    if target_tag == EXPR_FIELD_ACCESS:
        val base_eid = target_node.left
        val field_name = target_node.s_val
        val base_val = eval_expr(base_eid)
        if eval_had_error: return -1
        if val_is_struct(base_val):
            # Fast path: cached field index
            val cached_idx2 = expr_i_val[target_eid]
            if cached_idx2 >= 0:
                val ok2 = val_struct_check_field_idx(base_val, cached_idx2, field_name)
                if ok2:
                    val_struct_set_field_idx(base_val, cached_idx2, new_val)
                    return new_val
            # Slow path: find + set + cache
            val fi2 = val_struct_find_field_idx(base_val, field_name)
            if fi2 >= 0:
                val_struct_set_field_idx(base_val, fi2, new_val)
                expr_i_val[target_eid] = fi2
                return new_val
            eval_set_error("no field '" + field_name + "' on struct " + val_get_struct_name(base_val))
            return new_val

    if target_tag == EXPR_INDEX:
        val base_eid2 = target_node.left
        val idx_eid = target_node.right
        val base_val2 = eval_expr(base_eid2)
        if eval_had_error: return -1
        val idx_val = eval_expr(idx_eid)
        if eval_had_error: return -1
        if val_is_array(base_val2):
            if val_is_int(idx_val):
                val idx = val_get_int(idx_val)
                var elements = val_get_array(base_val2)
                if idx >= 0:
                    if idx < elements.len():
                        elements[idx] = new_val
                        val_arrays[base_val2] = elements
                        return new_val
        eval_set_error("invalid index assignment")
        return -1

    eval_set_error("invalid assignment target")
    -1

fn eval_stmt_compound_assign(sid: i64) -> i64:
    val s_node = stmt_get(sid)
    val target_eid = s_node.expr_idx
    val op = s_node.type_tag
    val value_stmts = s_node.body
    if value_stmts.len() == 0:
        eval_set_error("compound assignment missing value")
        return -1
    val value_eid = value_stmts[0]

    val target_node = expr_get(target_eid)
    val target_tag = target_node.tag
    if target_tag == EXPR_IDENT:
        val name = target_node.s_val
        val old_val = env_lookup(name)
        if old_val < 0:
            eval_set_error("undefined variable: " + name)
            return -1
        val rhs_val = eval_expr(value_eid)
        if eval_had_error: return -1
        val new_val = val_compound_op(op, old_val, rhs_val)
        if new_val < 0:
            val err = ops_get_error()
            if err != "":
                eval_set_error(err)
            return -1
        env_assign(name, new_val)
        return new_val

    eval_set_error("invalid compound assignment target")
    -1

fn eval_stmt_return(sid: i64) -> i64:
    val value_eid = stmt_get(sid).expr_idx
    var ret_val = val_make_nil()
    if value_eid >= 0:
        ret_val = eval_expr(value_eid)
        if eval_had_error: return -1
    eval_returning = true
    eval_return_value = ret_val
    ret_val

fn eval_stmt_if(sid: i64) -> i64:
    val elif_idx = stmt_get(sid).type_tag
    val cond_eid = elif_get_cond(elif_idx)
    val then_stmts = elif_get_body(elif_idx)
    val else_stmts = elif_get_else(elif_idx)

    val cond_val = eval_expr(cond_eid)
    if eval_had_error: return -1

    if val_is_truthy(cond_val):
        env_push_scope()
        var last_val = val_make_nil()
        for sid2 in then_stmts:
            if eval_had_error: break
            if eval_returning: break
            if eval_breaking: break
            if eval_continuing: break
            last_val = eval_stmt(sid2)
        env_pop_scope()
        return last_val
    if else_stmts.len() > 0:
        env_push_scope()
        var last_val2 = val_make_nil()
        for sid2 in else_stmts:
            if eval_had_error: break
            if eval_returning: break
            if eval_breaking: break
            if eval_continuing: break
            last_val2 = eval_stmt(sid2)
        env_pop_scope()
        return last_val2
    val_make_nil()

fn eval_stmt_for(sid: i64) -> i64:
    val s_node = stmt_get(sid)
    val iter_name = s_node.name
    val iterable_eid = s_node.expr_idx
    val body_stmts = s_node.body

    # Check if iterable is a range expression
    val iterable_tag = expr_get(iterable_eid).tag
    if iterable_tag == EXPR_RANGE:
        val range_node = expr_get(iterable_eid)
        val start_val = eval_expr(range_node.left)
        if eval_had_error: return -1
        val end_val = eval_expr(range_node.right)
        if eval_had_error: return -1
        val inclusive = range_node.i_val
        val start_n = val_get_int(start_val)
        val end_n = val_get_int(end_val)

        var current = start_n
        var last_val = val_make_nil()
        var iterations: i64 = 0
        while iterations < 1000001:
            if eval_had_error: break
            if eval_returning: break
            if eval_breaking: break
            val should_stop = current > end_n
            val at_limit = current == end_n
            if inclusive != 0:
                if should_stop: break
            else:
                if at_limit: break
                if should_stop: break
            eval_continuing = false
            env_push_scope()
            env_define(iter_name, val_make_int(current))
            for sid2 in body_stmts:
                if eval_had_error: break
                if eval_returning: break
                if eval_breaking: break
                if eval_continuing: break
                last_val = eval_stmt(sid2)
            env_pop_scope()
            current = current + 1
            iterations = iterations + 1
        eval_breaking = false
        eval_continuing = false
        return last_val

    # Otherwise evaluate the iterable
    val iterable = eval_expr(iterable_eid)
    if eval_had_error: return -1

    if val_is_array(iterable):
        val elements = val_get_array(iterable)
        var last_val2 = val_make_nil()
        for elem_vid in elements:
            if eval_had_error: break
            if eval_returning: break
            if eval_breaking: break
            eval_continuing = false
            env_push_scope()
            env_define(iter_name, elem_vid)
            for sid2 in body_stmts:
                if eval_had_error: break
                if eval_returning: break
                if eval_breaking: break
                if eval_continuing: break
                last_val2 = eval_stmt(sid2)
            env_pop_scope()
        eval_breaking = false
        eval_continuing = false
        return last_val2

    eval_set_error("cannot iterate over " + val_kind_name(val_get_kind(iterable)))
    -1

# static_for — at interpreter level behaves like a regular for loop.
# Compile-time unrolling is a future compiler-phase optimization.
fn eval_stmt_static_for(sid: i64) -> i64:
    val sf_node = stmt_get(sid)
    val sf_iter_name = sf_node.name
    val sf_iterable_eid = sf_node.expr_idx
    val sf_body_stmts = sf_node.body

    val sf_iterable = eval_expr(sf_iterable_eid)
    if eval_had_error: return -1

    if val_is_array(sf_iterable):
        val sf_elements = val_get_array(sf_iterable)
        var sf_last_val = val_make_nil()
        for sf_elem_vid in sf_elements:
            if eval_had_error: break
            if eval_returning: break
            if eval_breaking: break
            eval_continuing = false
            env_push_scope()
            env_define(sf_iter_name, sf_elem_vid)
            for sf_sid in sf_body_stmts:
                if eval_had_error: break
                if eval_returning: break
                if eval_breaking: break
                if eval_continuing: break
                sf_last_val = eval_stmt(sf_sid)
            env_pop_scope()
        eval_breaking = false
        eval_continuing = false
        return sf_last_val

    eval_set_error("static_for: cannot iterate over " + val_kind_name(val_get_kind(sf_iterable)))
    -1

fn eval_stmt_comptime(sid: i64) -> i64:
    # Execute the body statements immediately (they run at module-load time)
    val ct_node = stmt_get(sid)
    val ct_body = ct_node.body
    var ct_last = val_make_nil()
    for ct_sid in ct_body:
        if eval_had_error: break
        ct_last = eval_stmt(ct_sid)
    ct_last

fn eval_stmt_while(sid: i64) -> i64:
    val s_node = stmt_get(sid)
    val cond_eid = s_node.expr_idx
    val body_stmts = s_node.body
    var last_val = val_make_nil()
    var iterations: i64 = 0

    while iterations < 1000000:
        if eval_had_error: break
        if eval_returning: break
        if eval_breaking: break
        val cond_val = eval_expr(cond_eid)
        if eval_had_error: break
        if val_is_truthy(cond_val) == false: break
        eval_continuing = false
        for sid2 in body_stmts:
            if eval_had_error: break
            if eval_returning: break
            if eval_breaking: break
            if eval_continuing: break
            last_val = eval_stmt(sid2)
        iterations = iterations + 1

    if iterations >= 1000000:
        eval_set_error("while loop exceeded maximum iterations")

    eval_breaking = false
    eval_continuing = false
    last_val

fn eval_stmt_match(sid: i64) -> i64:
    val s_node = stmt_get(sid)
    val scrutinee_eid = s_node.expr_idx
    val arm_ids = s_node.body

    val scrutinee = eval_expr(scrutinee_eid)
    if eval_had_error: return -1

    # Exhaustiveness check: warn if enum variants are not all covered
    val inferred_type2 = infer_match_enum_type(arm_ids)
    check_match_exhaustive(arm_ids, inferred_type2)

    for arm_id in arm_ids:
        val pattern_eid = arm_get_pattern(arm_id)
        val guard_eid = arm_get_guard(arm_id)
        val body_stmts = arm_get_body(arm_id)

        env_push_scope()
        val matched = match_pattern(scrutinee, pattern_eid)
        if matched:
            if guard_eid >= 0:
                val guard_val = eval_expr(guard_eid)
                if eval_had_error:
                    env_pop_scope()
                    return -1
                if val_is_truthy(guard_val) == false:
                    env_pop_scope()
                    continue
            var last_val = val_make_nil()
            for sid2 in body_stmts:
                if eval_had_error: break
                if eval_returning: break
                last_val = eval_stmt(sid2)
            env_pop_scope()
            return last_val
        env_pop_scope()

    val_make_nil()

fn eval_stmt_block(sid: i64) -> i64:
    val body_stmts = stmt_get(sid).body
    eval_block(body_stmts, -1)

# ===== Declaration Evaluation =====

fn eval_decl(did: i64) -> i64:
    if did < 0: return val_make_nil()
    if eval_had_error: return -1

    val d_node = decl_get(did)
    val tag = d_node.tag

    # Check @when conditional compilation: skip disabled decls
    val decl_name = d_node.name
    for disabled_name in when_disabled_decls:
        if disabled_name == decl_name:
            return val_make_nil()

    if tag == DECL_FN:
        val name = d_node.name
        val ret_type = d_node.ret_type
        func_table_register(name, did)
        func_register_return_type(name, ret_type)
        return val_make_nil()

    if tag == DECL_STRUCT:
        val name = d_node.name
        struct_table_register(name, did)
        return val_make_nil()

    if tag == DECL_VAL:
        val name = d_node.name
        val body = d_node.body_stmts
        var init_val = val_make_nil()
        if body.len() > 0:
            init_val = eval_expr(body[0])
            if eval_had_error: return -1
        env_define_global(name, init_val)
        return init_val

    if tag == EVAL_DECL_LAZY_VAL:
        val lv_name = d_node.name
        val lv_body = d_node.body_stmts
        var thunk_val = val_make_nil()
        if lv_body.len() > 0:
            thunk_val = val_make_thunk(lv_body[0])
        env_define_global(lv_name, thunk_val)
        return thunk_val

    if tag == DECL_VAR:
        val name = d_node.name
        val body = d_node.body_stmts
        var init_val = val_make_nil()
        if body.len() > 0:
            init_val = eval_expr(body[0])
            if eval_had_error: return -1
        env_define_global(name, init_val)
        return init_val

    if tag == DECL_ENUM:
        # Register enum variants as constants
        val name = d_node.name
        val variants = d_node.field_names
        var vi: i64 = 0
        for variant_name in variants:
            env_define_global(variant_name, val_make_int(vi))
            vi = vi + 1
        # Register enum in registry for exhaustiveness checking
        enum_table_register(name, variants)
        return val_make_nil()

    if tag == DECL_USE:
        # Load module and register its exports
        val module_path = d_node.name
        val imported_names = d_node.imports
        val current_file = module_get_path()

        # Check if this is a lazy import — defer loading
        val is_lazy = decl_get_is_lazy(did)
        if is_lazy == 1:
            register_deferred_module(module_path, current_file, imported_names)
            return val_make_nil()

        # If imports list is empty, load full module
        # Otherwise, load selective imports
        var load_result: i64 = 0
        if imported_names.len() == 0:
            load_result = load_module(module_path, current_file)
        else:
            load_result = load_module_selective(module_path, imported_names, current_file)

        if load_result == 0:
            eval_set_error("failed to load module: " + module_path)
            return -1

        return val_make_nil()

    if tag == DECL_EXPORT:
        # Export declarations - handled during module loading
        # No runtime action needed
        return val_make_nil()

    if tag == DECL_CE:
        # ce NAME: block — evaluate with appropriate CE semantics.
        # For seq/seq_ce builders: collect yield values into array.
        # For other builders: monadic bind with nil short-circuit.
        val ce_builder = d_node.name
        val ce_body = d_node.body_stmts
        env_push_scope()
        var ce_last: i64 = val_make_nil()
        var ce_short_circuit: bool = false
        val ce_is_seq = (ce_builder == "seq" or ce_builder == "seq_ce")
        if ce_is_seq:
            val new_acc: [i64] = []
            eval_yield_stack.push(new_acc)
        for ce_sid in ce_body:
            if eval_had_error: break
            if eval_returning: break
            if ce_short_circuit: break
            val ce_stmt_tag = stmt_get(ce_sid).tag
            if ce_stmt_tag == EVAL_STMT_BIND and not ce_is_seq:
                # Monadic bind: eval rhs, short-circuit on nil
                val ce_bind_node = stmt_get(ce_sid)
                val ce_bind_name = ce_bind_node.name
                val ce_bind_rhs = eval_expr(ce_bind_node.expr_idx)
                if eval_had_error:
                    ce_last = -1
                else:
                    val ce_bind_is_nil = val_kind(ce_bind_rhs) == 0
                    if ce_bind_is_nil:
                        ce_last = ce_bind_rhs
                        ce_short_circuit = true
                    else:
                        env_define(ce_bind_name, ce_bind_rhs)
                        ce_last = ce_bind_rhs
            else:
                ce_last = eval_stmt(ce_sid)
        if ce_is_seq:
            val ys_len = eval_yield_stack.len()
            if ys_len > 0:
                val collected = eval_yield_stack[ys_len - 1]
                eval_yield_stack = eval_yield_stack[0:ys_len - 1]
                env_pop_scope()
                return val_make_array(collected)
        env_pop_scope()
        return ce_last

    # DECL_EXTERN_FN, DECL_IMPL, DECL_CLASS — skip for now
    val_make_nil()

# ===== Module Evaluation =====

fn eval_module() -> i64:
    val decls = module_get_decls()

    # Phase 1: Register all functions and structs
    for did in decls:
        val d_node = decl_get(did)
        val tag = d_node.tag
        if tag == DECL_FN:
            func_table_register(d_node.name, did)
            func_register_return_type(d_node.name, d_node.ret_type)
        if tag == DECL_EXTERN_FN:
            func_register_return_type(d_node.name, d_node.ret_type)
        if tag == DECL_STRUCT:
            struct_table_register(d_node.name, did)

    # Phase 2: Evaluate declarations (val/var bindings, enums)
    var last_val = val_make_nil()
    for did in decls:
        if eval_had_error: break
        val tag = decl_get(did).tag
        if tag == DECL_VAL:
            eval_decl(did)
        if tag == EVAL_DECL_LAZY_VAL:
            eval_decl(did)
        if tag == DECL_VAR:
            eval_decl(did)
        if tag == DECL_ENUM:
            eval_decl(did)

    # Phase 3: Call @init functions in order (before main)
    for init_fn_name in init_functions:
        if eval_had_error: break
        val init_decl = func_table_lookup(init_fn_name)
        if init_decl >= 0:
            var init_args: [i64] = []
            eval_function_call(init_decl, init_args)

    # Phase 4: Call main() if it exists
    val main_decl = func_table_lookup("main")
    if main_decl >= 0:
        var empty_args: [i64] = []
        last_val = eval_function_call(main_decl, empty_args)

    # Phase 5: Call @teardown functions in reverse order (after main)
    val teardown_len = teardown_functions.len()
    var tdi: i64 = teardown_len - 1
    while tdi >= 0:
        val td_fn_name = teardown_functions[tdi]
        val td_decl = func_table_lookup(td_fn_name)
        if td_decl >= 0:
            var td_args: [i64] = []
            eval_function_call(td_decl, td_args)
        tdi = tdi - 1

    last_val

# ===== Full Initialization =====

fn eval_init():
    val_reset()
    env_init()
    func_table_reset()
    struct_table_reset()
    mono_cache_init()
    eval_reset()
    module_loader_init()

# ===== Async/Await Expressions (Basic Stubs) =====
# TODO: Full state machine support requires desugaring to state machines
# For now, these are minimal implementations to avoid crashes

fn eval_await_expr(eid: i64) -> i64:
    """Evaluate an await expression: await future_expr

    Basic stub: evaluates the future expression and returns it immediately.
    Full async support requires state machine transformation.
    """
    val e_node = expr_get(eid)
    val future_eid = e_node.left
    # For now, just evaluate the future synchronously
    val result = eval_expr(future_eid)
    if eval_had_error: return -1
    result

fn eval_yield_expr(eid: i64) -> i64:
    val e_node = expr_get(eid)
    val value_eid = e_node.left
    val result = eval_expr(value_eid)
    if eval_had_error: return -1
    if eval_yield_stack.len() > 0:
        val top_idx = eval_yield_stack.len() - 1
        eval_yield_stack[top_idx].push(result)
    result

fn eval_spawn_expr(eid: i64) -> i64:
    """Evaluate a spawn expression: spawn fn_call

    Basic stub: evaluates the call synchronously.
    Full actor support requires async runtime integration.
    """
    val e_node = expr_get(eid)
    val call_eid = e_node.left
    # For now, just evaluate the call synchronously
    val result = eval_expr(call_eid)
    if eval_had_error: return -1
    result

fn eval_labeled_loop(sid: i64) -> i64:
    # Evaluate a labeled loop: push label, run inner loop, pop label
    # If break/continue targets this label, consume the break state
    val s_node = stmt_get(sid)
    val my_label = s_node.name
    val body_stmts = s_node.body
    eval_label_stack.push(my_label)
    # Execute the inner loop stmt
    var result = val_make_nil()
    if body_stmts.len() > 0:
        val inner_sid = body_stmts[0]
        result = eval_stmt(inner_sid)
    # Pop label
    val stack_len = eval_label_stack.len()
    if stack_len > 0:
        val new_stack: [text] = eval_label_stack[0:stack_len - 1]
        eval_label_stack = new_stack
    # If break targeted this label, consume it
    if eval_breaking:
        if eval_break_label == my_label:
            eval_breaking = false
            eval_break_label = ""
    # If continue targeted this label, consume it (already consumed by loop)
    if eval_continuing:
        if eval_continue_label == my_label:
            eval_continuing = false
            eval_continue_label = ""
    result

fn eval_do_block(eid: i64) -> i64:
    # Evaluates a do: block expression, returning the value of the last statement
    val e_node = expr_get(eid)
    val body_stmts = e_node.stmts
    env_push_scope()
    var last_val = val_make_nil()
    for sid in body_stmts:
        if eval_had_error: break
        if eval_returning: break
        last_val = eval_stmt(sid)
    env_pop_scope()
    last_val

fn eval_atom_expr(eid: i64) -> i64:
    # Evaluates an atom literal `symbol — stored as an interned text value
    val e_node = expr_get(eid)
    val atom_name = e_node.s_val
    # Atoms are represented as text with a special prefix for identity comparison
    val_make_text("`" + atom_name)

export eval_reset, eval_set_error, eval_get_error, eval_has_error, eval_get_warnings
export eval_returning, eval_return_value, eval_breaking, eval_continuing
export func_table_reset, func_table_register, func_table_lookup
export struct_table_reset, struct_table_register, struct_table_lookup, struct_table_get_module
export eval_expr, eval_stmt, eval_decl, eval_module
export eval_block, eval_function_call, eval_builtin_call
export eval_init
export must_use_scan_source, must_use_register, must_use_is_registered
export must_use_get_reason, must_use_is_critical
export phantom_struct_register, phantom_struct_is_registered, phantom_reg_reset
