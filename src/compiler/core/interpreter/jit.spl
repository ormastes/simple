# Runtime-compatible JIT state (file-backed to survive module import limitations)

extern fn rt_file_write_text(path: text, content: text) -> bool
extern fn rt_file_read_text(path: text) -> text

fn _read(path: text) -> text:
    rt_file_read_text(path) ?? ""

fn _write(path: text, content: text):
    rt_file_write_text(path, content)

fn _session_path() -> text:
    "/tmp/simple_jit_session.txt"

fn _threshold_path() -> text:
    "/tmp/simple_jit_threshold.txt"

fn _enabled_path() -> text:
    "/tmp/simple_jit_enabled.txt"

fn _epoch_path() -> text:
    "/tmp/simple_jit_epoch.txt"

fn _fn_list_path() -> text:
    "/tmp/simple_jit_functions.txt"

fn _compiled_path() -> text:
    "/tmp/simple_jit_compiled.txt"

fn _session() -> text:
    val s = _read(_session_path())
    if s == "":
        return "0"
    s

fn _prefix() -> text:
    "/tmp/simple_jit_" + _session() + "_"

fn _call_path(name: text) -> text:
    _prefix() + "call_" + name + ".txt"

fn _used_path(name: text) -> text:
    _prefix() + "used_" + name + ".txt"

fn _to_i64(s: text) -> i64:
    if s == "":
        return 0
    s.to_int()

fn _list_contains(csv: text, name: text) -> bool:
    if csv == "":
        return false
    for p in csv.split(","):
        if p == name:
            return true
    false

fn _list_add_unique(csv: text, name: text) -> text:
    if name == "":
        return csv
    if _list_contains(csv, name):
        return csv
    if csv == "":
        return name
    csv + "," + name

fn _list_remove(csv: text, name: text) -> text:
    if csv == "":
        return ""
    var out = ""
    for p in csv.split(","):
        if p != "" and p != name:
            if out == "":
                out = p
            else:
                out = out + "," + p
    out

fn _list_count(csv: text) -> i64:
    if csv == "":
        return 0
    var n: i64 = 0
    for p in csv.split(","):
        if p != "":
            n = n + 1
    n

fn jit_init(threshold: i64, verbose: i64):
    val old = _to_i64(_read(_session_path()))
    val next = old + 1
    _write(_session_path(), next.to_string())
    _write(_threshold_path(), threshold.to_string())
    if threshold < 999999:
        _write(_enabled_path(), "1")
    else:
        _write(_enabled_path(), "0")
    _write(_epoch_path(), "0")
    _write(_fn_list_path(), "")
    _write(_compiled_path(), "")

fn jit_init_with_backend(threshold: i64, verbose: i64, backend: text):
    jit_init(threshold, verbose)

fn jit_cleanup():
    _write(_enabled_path(), "0")
    _write(_threshold_path(), "10")
    _write(_epoch_path(), "0")
    _write(_fn_list_path(), "")
    _write(_compiled_path(), "")

fn jit_record_call(fn_name: text):
    if not jit_is_enabled():
        return
    val cur = _to_i64(_read(_call_path(fn_name)))
    _write(_call_path(fn_name), (cur + 1).to_string())
    val fns = _read(_fn_list_path())
    _write(_fn_list_path(), _list_add_unique(fns, fn_name))
    jit_mark_symbol_used(fn_name)

fn jit_get_call_count(fn_name: text) -> i64:
    _to_i64(_read(_call_path(fn_name)))

fn jit_should_compile(fn_name: text) -> bool:
    if not jit_is_enabled():
        return false
    val threshold = _to_i64(_read(_threshold_path()))
    jit_get_call_count(fn_name) >= threshold

fn jit_is_compiled(fn_name: text) -> bool:
    _list_contains(_read(_compiled_path()), fn_name)

fn jit_mark_compiled(fn_name: text):
    val csv = _read(_compiled_path())
    _write(_compiled_path(), _list_add_unique(csv, fn_name))

fn jit_try_compile(fn_name: text, mir_data: text) -> bool:
    if jit_should_compile(fn_name):
        jit_mark_compiled(fn_name)
        return true
    false

fn jit_try_execute(fn_name: text, args: [i64]) -> i64:
    if jit_is_compiled(fn_name):
        return 0
    -1

fn jit_is_enabled() -> bool:
    _to_i64(_read(_enabled_path())) == 1

fn jit_compiled_count() -> i64:
    _list_count(_read(_compiled_path()))

fn jit_total_tracked() -> i64:
    _list_count(_read(_fn_list_path()))

fn jit_mark_symbol_used(fn_name: text):
    val epoch = _to_i64(_read(_epoch_path()))
    _write(_used_path(fn_name), epoch.to_string())

fn jit_advance_epoch() -> i64:
    val e = _to_i64(_read(_epoch_path())) + 1
    _write(_epoch_path(), e.to_string())
    e

fn jit_get_epoch() -> i64:
    _to_i64(_read(_epoch_path()))

fn jit_sweep_stale(max_age: i64) -> i64:
    val threshold = jit_get_epoch() - max_age
    val compiled = _read(_compiled_path())
    var out = ""
    var removed: i64 = 0
    for name in compiled.split(","):
        if name == "":
            continue
        val used = _to_i64(_read(_used_path(name)))
        if used < threshold:
            removed = removed + 1
        else:
            if out == "":
                out = name
            else:
                out = out + "," + name
    _write(_compiled_path(), out)
    removed

fn jit_cleanup_symbol(fn_name: text):
    _write(_compiled_path(), _list_remove(_read(_compiled_path()), fn_name))

fn jit_sweep_tracked_count() -> i64:
    jit_total_tracked()

export jit_init, jit_init_with_backend, jit_cleanup
export jit_record_call, jit_get_call_count
export jit_should_compile, jit_is_compiled, jit_mark_compiled
export jit_try_compile, jit_try_execute
export jit_is_enabled, jit_compiled_count, jit_total_tracked
export jit_mark_symbol_used, jit_advance_epoch, jit_get_epoch
export jit_sweep_stale, jit_cleanup_symbol, jit_sweep_tracked_count
