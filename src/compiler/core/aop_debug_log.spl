# Compatibility AOP debug log implementation.

struct DebugLogEntry:
    entry_id: i64
    group_id: i64
    parent_group_id: i64
    depth: i64
    entry_type: text
    package_path: text
    class_name: text
    function_name: text
    line_number: i64
    timestamp_ms: i64
    duration_ms: i64
    params_text: text
    message: text

var _enabled: bool = false
var _pattern: text = "*"
var _entries: [DebugLogEntry] = []
var _next_entry_id: i64 = 1
var _next_group_id: i64 = 1
var _stack: [i64] = []

extern fn rt_time_now_unix_micros() -> i64

fn _now_ms() -> i64:
    rt_time_now_unix_micros() / 1000

fn _is_match(pattern: text, fn_name: text, pkg: text) -> bool:
    if pattern == "" or pattern == "*":
        return true
    if pattern.ends_with("*"):
        val prefix = pattern.substring(0, pattern.len() - 1)
        return fn_name.starts_with(prefix) or pkg.starts_with(prefix)
    if pattern.contains("*"):
        return fn_name.contains(pattern.replace("*", "")) or pkg.contains(pattern.replace("*", ""))
    fn_name == pattern or pkg == pattern

fn _next_id() -> i64:
    val id = _next_entry_id
    _next_entry_id = _next_entry_id + 1
    id

fn _next_group() -> i64:
    val gid = _next_group_id
    _next_group_id = _next_group_id + 1
    gid

fn _find_enter_idx(group_id: i64) -> i64:
    var idx: i64 = _entries.len() - 1
    while idx >= 0:
        val e = _entries[idx]
        if e.group_id == group_id and e.entry_type == "enter":
            return idx
        idx = idx - 1
    -1

fn debug_log_enable(pattern: text):
    _enabled = true
    if pattern != "":
        _pattern = pattern
    else:
        _pattern = "*"

fn debug_log_disable():
    _enabled = false

fn debug_log_clear():
    _entries = []
    _stack = []
    _next_entry_id = 1
    _next_group_id = 1

fn debug_log_enter(function_name: text, package_path: text, class_name: text, line_number: i64, params_text: text) -> i64:
    if not _enabled:
        return 0
    if not _is_match(_pattern, function_name, package_path):
        return 0
    val gid = _next_group()
    var parent: i64 = 0
    if _stack.len() > 0:
        parent = _stack[_stack.len() - 1]
    val depth = _stack.len() as i64
    val entry = DebugLogEntry(
        entry_id: _next_id(),
        group_id: gid,
        parent_group_id: parent,
        depth: depth,
        entry_type: "enter",
        package_path: package_path,
        class_name: class_name,
        function_name: function_name,
        line_number: line_number,
        timestamp_ms: _now_ms(),
        duration_ms: 0,
        params_text: params_text,
        message: ""
    )
    _entries = _entries + [entry]
    _stack = _stack + [gid]
    gid

fn debug_log_exit(function_name: text, package_path: text, group_id: i64, status_code: i64):
    if not _enabled or group_id == 0:
        return
    val idx = _find_enter_idx(group_id)
    var duration: i64 = 0
    if idx >= 0:
        val start = _entries[idx].timestamp_ms
        duration = _now_ms() - start
    val depth = if _stack.len() > 0: (_stack.len() - 1) as i64 else: 0
    val exit_entry = DebugLogEntry(
        entry_id: _next_id(),
        group_id: group_id,
        parent_group_id: 0,
        depth: depth,
        entry_type: "exit",
        package_path: package_path,
        class_name: "",
        function_name: function_name,
        line_number: 0,
        timestamp_ms: _now_ms(),
        duration_ms: duration,
        params_text: "",
        message: ""
    )
    _entries = _entries + [exit_entry]
    var popped = false
    var next_stack: [i64] = []
    for i in range(0, _stack.len()):
        val gid = _stack[i]
        if not popped and gid == group_id:
            popped = true
        else:
            next_stack = next_stack + [gid]
    _stack = next_stack

fn debug_log_get_entries() -> [DebugLogEntry]:
    _entries

fn debug_log_get_entries_since(since_id: i64) -> [DebugLogEntry]:
    var out: [DebugLogEntry] = []
    for e in _entries:
        if e.entry_id > since_id:
            out = out + [e]
    out

fn debug_log_get_status() -> (bool, text, i64, i64):
    (_enabled, _pattern, _entries.len() as i64, _stack.len() as i64)

fn debug_log_is_enabled() -> bool:
    _enabled

fn debug_log_set_max_entries(max_entries: i64):
    if max_entries <= 0:
        return
    if _entries.len() as i64 <= max_entries:
        return
    val start = (_entries.len() as i64 - max_entries) as i64
    var kept: [DebugLogEntry] = []
    for i in range(start, _entries.len() as i64):
        kept = kept + [_entries[i]]
    _entries = kept

export DebugLogEntry
export debug_log_enable, debug_log_disable, debug_log_clear
export debug_log_enter, debug_log_exit
export debug_log_get_entries, debug_log_get_entries_since
export debug_log_get_status, debug_log_is_enabled
export debug_log_set_max_entries
