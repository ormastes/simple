# Parser â€” Preprocessor Module
#
# Conditional compilation: @when/@elif/@else/@end directives
# and @cfg per-declaration conditionals.
# Extracted from parser.spl.

use compiler.core.cfg_platform.{cfg_strip_quotes, cfg_detect_os, cfg_detect_arch, cfg_detect_cpu, cfg_eval_key_value}

# ===== Preprocessor State =====

var _pp_tokens: [text] = []
var _pp_pos: i64 = 0

fn _pp_eval_atom(token: text) -> bool:
    val t = cfg_strip_quotes(token).trim()
    if t == "":
        return false
    if t == "true":
        return true
    if t == "false":
        return false
    if t == "debug":
        return true
    if t == "release":
        return false
    if t == "compiled":
        return true
    if t == "interpreter":
        return false

    if t == "win" or t == "windows":
        return cfg_detect_os() == "windows"
    if t == "linux":
        return cfg_detect_os() == "linux"
    if t == "mac" or t == "macos" or t == "darwin":
        return cfg_detect_os() == "macos"
    if t == "freebsd":
        return cfg_detect_os() == "freebsd"
    if t == "openbsd":
        return cfg_detect_os() == "openbsd"
    if t == "netbsd":
        return cfg_detect_os() == "netbsd"
    if t == "android":
        return cfg_detect_os() == "android"
    if t == "unix":
        val os = cfg_detect_os()
        val is_unix = os == "linux" or os == "macos"
        val is_unix2 = os == "freebsd" or os == "openbsd"
        val is_unix3 = os == "netbsd" or os == "android"
        return is_unix or is_unix2 or is_unix3 or os == "unix"

    if t == "x86_64" or t == "amd64" or t == "x64":
        return cfg_detect_arch() == "x86_64"
    if t == "x86" or t == "i386" or t == "i686":
        return cfg_detect_arch() == "x86"
    if t == "aarch64" or t == "arm64":
        return cfg_detect_arch() == "aarch64"
    if t == "arm" or t == "armv7" or t == "armv6":
        return cfg_detect_arch() == "arm"
    if t == "riscv64":
        return cfg_detect_arch() == "riscv64"
    if t == "riscv32":
        return cfg_detect_arch() == "riscv32"
    if t == "ppc64le" or t == "ppc64el" or t == "powerpc64le":
        return cfg_detect_arch() == "ppc64le"

    if t.contains("=="):
        val parts = t.split("==")
        if parts.len() >= 2:
            return cfg_eval_key_value(parts[0], parts[1])
    if t.contains("="):
        val parts = t.split("=")
        if parts.len() >= 2:
            return cfg_eval_key_value(parts[0], parts[1])

    false

fn _pp_tokenize_condition(condition: text) -> [text]:
    var tokens: [text] = []
    var current: [text] = []
    var i: i64 = 0

    for _ in condition:
        if i >= condition.len():
            break
        val ch = condition[i]

        val is_ws = ch == " " or ch == "\t" or ch == "\r"
        if is_ws:
            if current.len() > 0:
                tokens.push(current.join(""))
                current = []
            i = i + 1
            continue

        val is_paren = ch == "(" or ch == ")"
        if is_paren:
            if current.len() > 0:
                tokens.push(current.join(""))
                current = []
            tokens.push(ch)
            i = i + 1
            continue

        if ch == "&" and i + 1 < condition.len() and condition[i + 1] == "&":
            if current.len() > 0:
                tokens.push(current.join(""))
                current = []
            tokens.push("&&")
            i = i + 2
            continue

        if ch == "|" and i + 1 < condition.len() and condition[i + 1] == "|":
            if current.len() > 0:
                tokens.push(current.join(""))
                current = []
            tokens.push("||")
            i = i + 2
            continue

        if ch == "!":
            if current.len() > 0:
                tokens.push(current.join(""))
                current = []
            tokens.push("!")
            i = i + 1
            continue

        current.push(ch)
        i = i + 1

    if current.len() > 0:
        tokens.push(current.join(""))

    tokens

fn _pp_peek() -> text:
    if _pp_pos >= _pp_tokens.len():
        return ""
    _pp_tokens[_pp_pos]

fn _pp_take() -> text:
    val token = _pp_peek()
    if token != "":
        _pp_pos = _pp_pos + 1
    token

fn _pp_parse_or() -> bool:
    var left = _pp_parse_and()
    for _ in 0..1024:
        val tok = _pp_peek()
        val is_or = tok == "or" or tok == "||"
        if not is_or:
            break
        _pp_take()
        val right = _pp_parse_and()
        left = left or right
    left

fn _pp_parse_and() -> bool:
    var left = _pp_parse_not()
    for _ in 0..1024:
        val tok = _pp_peek()
        val is_and = tok == "and" or tok == "&&"
        if not is_and:
            break
        _pp_take()
        val right = _pp_parse_not()
        left = left and right
    left

fn _pp_parse_not() -> bool:
    val tok = _pp_peek()
    val is_not = tok == "not" or tok == "!"
    if is_not:
        _pp_take()
        return not _pp_parse_not()
    _pp_parse_primary()

fn _pp_parse_primary() -> bool:
    val tok = _pp_peek()
    if tok == "(":
        _pp_take()
        val value = _pp_parse_or()
        if _pp_peek() == ")":
            _pp_take()
        return value

    val atom = _pp_take()
    _pp_eval_atom(atom)

fn _pp_eval_condition(condition: text) -> bool:
    _pp_tokens = _pp_tokenize_condition(condition)
    _pp_pos = 0
    if _pp_tokens.len() == 0:
        return false
    _pp_parse_or()

fn _pp_extract_paren_condition(line: text) -> text:
    # Extract condition from @when(condition): or @cfg(condition) etc.
    # Finds '(' and reads until matching ')'.
    var start: i64 = -1
    var i: i64 = 0
    for _ in line:
        if i >= line.len(): break
        if line[i] == "(":
            start = i + 1
            break
        i = i + 1
    if start < 0:
        return ""
    var depth: i64 = 1
    var chars: [text] = []
    var j: i64 = start
    for _ in line:
        if j >= line.len(): break
        val ch = line[j]
        if ch == "(":
            depth = depth + 1
        if ch == ")":
            depth = depth - 1
            if depth == 0: break
        chars.push(ch)
        j = j + 1
    chars.join("").trim()

fn _pp_extract_cfg_condition(line: text) -> text:
    # Extract from @cfg(condition) or @cfg("key", "value")
    # For key-value form, convert to key=value for eval
    val raw = _pp_extract_paren_condition(line)
    if raw.contains(","):
        val parts = raw.split(",")
        if parts.len() >= 2:
            val key = cfg_strip_quotes(parts[0].trim())
            val value = cfg_strip_quotes(parts[1].trim())
            return "{key}={value}"
    raw

fn _pp_split_lines(source: text) -> [text]:
    var lines: [text] = []
    var line_chars: [text] = []
    var i: i64 = 0
    for _ in source:
        if i >= source.len():
            break
        val ch = source[i]
        if ch == "\n":
            lines.push(line_chars.join(""))
            line_chars = []
        else:
            line_chars.push(ch)
        i = i + 1
    lines.push(line_chars.join(""))
    lines

fn _pp_preprocess_conditionals(source: text) -> text:
    val lines = _pp_split_lines(source)
    var out_lines: [text] = []

    var stack_parent_active: [bool] = []
    var stack_branch_taken: [bool] = []
    var stack_branch_active: [bool] = []
    var depth: i64 = 0
    var active: bool = true

    for line in lines:
        val trimmed = line.trim()

        val is_when = trimmed.starts_with("@when(")
        if is_when:
            val cond = _pp_extract_paren_condition(trimmed)
            val parent = active
            val cond_ok = _pp_eval_condition(cond)
            val current = parent and cond_ok

            if depth >= stack_parent_active.len():
                stack_parent_active.push(parent)
                stack_branch_taken.push(current)
                stack_branch_active.push(current)
            else:
                stack_parent_active[depth] = parent
                stack_branch_taken[depth] = current
                stack_branch_active[depth] = current
            depth = depth + 1
            active = current
            out_lines.push("")
            continue

        val is_elif = trimmed.starts_with("@elif(")
        if is_elif:
            if depth > 0:
                val idx = depth - 1
                val parent = stack_parent_active[idx]
                var taken = stack_branch_taken[idx]
                var current = false
                if parent and not taken:
                    val cond = _pp_extract_paren_condition(trimmed)
                    current = _pp_eval_condition(cond)
                    if current:
                        taken = true
                stack_branch_taken[idx] = taken
                stack_branch_active[idx] = current
                active = current
            out_lines.push("")
            continue

        val is_else = trimmed == "@else" or trimmed == "@else:"
        if is_else:
            if depth > 0:
                val idx = depth - 1
                val parent = stack_parent_active[idx]
                val taken = stack_branch_taken[idx]
                val current = parent and (not taken)
                stack_branch_taken[idx] = taken or current
                stack_branch_active[idx] = current
                active = current
            out_lines.push("")
            continue

        val is_end = trimmed == "@end"
        if is_end:
            if depth > 0:
                depth = depth - 1
            if depth <= 0:
                active = true
            else:
                active = stack_branch_active[depth - 1]
            out_lines.push("")
            continue

        if active:
            out_lines.push(line)
        else:
            # Keep line count stable for diagnostics.
            out_lines.push("")

    # Second pass: @cfg(condition) per-declaration conditionals
    var final_lines: [text] = []
    var skip_until_dedent: bool = false
    var skip_indent: i64 = -1
    var i: i64 = 0
    for _ in out_lines:
        if i >= out_lines.len(): break
        val ol = out_lines[i]
        val ot = ol.trim()

        if skip_until_dedent:
            if ot == "":
                final_lines.push("")
                skip_until_dedent = false
                skip_indent = -1
                i = i + 1
                continue
            var cur_indent: i64 = 0
            var ci: i64 = 0
            for _ in ol:
                if ci >= ol.len(): break
                val c = ol[ci]
                if c == " ":
                    cur_indent = cur_indent + 1
                elif c == "\t":
                    cur_indent = cur_indent + 4
                else:
                    break
                ci = ci + 1
            if cur_indent > skip_indent:
                final_lines.push("")
                i = i + 1
                continue
            else:
                skip_until_dedent = false
                skip_indent = -1

        if ot.starts_with("@cfg("):
            val cfg_cond = _pp_extract_cfg_condition(ot)
            val cfg_ok = _pp_eval_condition(cfg_cond)
            if cfg_ok:
                # Condition true: blank @cfg line, keep declaration
                final_lines.push("")
            else:
                # Condition false: blank @cfg line + following declaration
                final_lines.push("")
                # Calculate indent of the next declaration line
                if i + 1 < out_lines.len():
                    val next_line = out_lines[i + 1]
                    val next_trimmed = next_line.trim()
                    var next_indent: i64 = 0
                    var ni: i64 = 0
                    for _ in next_line:
                        if ni >= next_line.len(): break
                        val nc = next_line[ni]
                        if nc == " ":
                            next_indent = next_indent + 1
                        elif nc == "\t":
                            next_indent = next_indent + 4
                        else:
                            break
                        ni = ni + 1
                    # Blank the declaration line
                    i = i + 1
                    final_lines.push("")
                    # If declaration ends with ':', blank its body too
                    if next_trimmed.ends_with(":"):
                        skip_until_dedent = true
                        skip_indent = next_indent
            i = i + 1
            continue

        final_lines.push(ol)
        i = i + 1

    final_lines.join("\n")

# ===== Public API =====

fn preprocess_conditionals(source: text) -> text:
    _pp_preprocess_conditionals(source)

# ===== Exports =====

export _pp_preprocess_conditionals
export preprocess_conditionals
