# Type Checker
#
# Type checker for Simple language with bidirectional type checking.
#
# This module implements:
# - Promise auto-wrapping for async functions
# - Function signature validation
# - Return type checking
#
# Architecture:
# The type checker operates in multiple passes:
# 1. Collect function signatures (already done in HIR lowering)
# 2. Check function bodies match signatures
# 3. Apply Promise auto-wrapping for async functions
#
# Promise Auto-Wrapping:
# Functions with suspension operators (`~=`, `if~`, etc.) are async.
# If such a function declares return type `T`, the type checker
# automatically wraps it to `Promise<T>`.
#
# Example:
# ```simple
# fn fetch_user(id: i64) -> User:  # Declared as User
#     val resp ~= http.get(url)
#     return parse(resp)
# # Auto-wrapped to: -> Promise<User>
# ```
#
# Port of rust/compiler/src/type_check/mod.rs (208 lines)

export TypeChecker

use hir (HirFunction, HirModule, HirType, TypeId, TypeRegistry)
use hir (LowerError, LowerResult)

# ============================================================================
# Type Checker
# ============================================================================

struct TypeChecker:
    """Type checker context.

    Tracks function return types for checking calls.
    """
    function_types: {text: TypeId}

impl TypeChecker:
    static fn new() -> TypeChecker:
        """Create a new type checker."""
        TypeChecker(function_types: {})

    me register_function(name: text, return_type: TypeId):
        """Register a function's signature."""
        self.function_types[name] = return_type

    fn needs_promise_wrapping(func: HirFunction, types: TypeRegistry) -> bool:
        """Check if a function needs Promise wrapping.

        A function needs Promise wrapping if:
        1. It has suspension operators (has_suspension = true)
        2. Its return type is NOT already a Promise
        3. Its return type is NOT void

        CRITICAL: All 3 conditions must be checked in order.
        Early returns preserve short-circuit evaluation.
        """
        # Only async functions need wrapping
        if not func.has_suspension:
            return false

        # Check if return type is already a Promise
        if val Some(ty) = types.get(func.return_type):
            if ty.is_promise():
                return false  # Already wrapped

        # Void functions don't need wrapping (they return Promise<()> implicitly)
        if func.return_type == TypeId.VOID:
            return false

        true

    fn wrap_return_in_promise(func: HirFunction, types: TypeRegistry) -> LowerResult<()>:
        """Wrap a function's return type in Promise<T>.

        Transforms: fn() -> T  to  fn() -> Promise<T>

        CRITICAL: Mutates both func and types registry.
        """
        val inner_type = func.return_type
        val promise_type = types.register(HirType.promise(inner_type))
        func.return_type = promise_type
        Ok(())

    me apply_promise_wrapping(module: HirModule) -> LowerResult<()>:
        """Apply Promise auto-wrapping to all async functions in a module.

        This is the main entry point for the type checker.
        Called after HIR lowering to auto-wrap async function returns.

        CRITICAL: Two-pass algorithm:
        Pass 1: Collect all function signatures
        Pass 2: Apply Promise wrapping where needed
        """
        # Pass 1: Collect all function signatures first
        for func in module.functions:
            self.register_function(func.name.clone(), func.return_type)

        # Pass 2: Apply Promise wrapping where needed
        for func in module.functions:
            if self.needs_promise_wrapping(func, module.types):
                self.wrap_return_in_promise(func, module.types)?

        Ok(())
