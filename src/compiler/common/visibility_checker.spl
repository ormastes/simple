# Visibility Checker - Warnings for Non-Public Access
#
# Emits W0401 warnings when code accesses private items from other modules.
# Extended with friend access control: supports Internal, Package, and
# friend-based visibility checks.

use hir_types.{Symbol, SymbolId, SymbolTable}
use lexer.Span
use compiler.common.dependency.visibility.{Visibility, DirManifest, check_friend_access}

# Warning for accessing a private symbol
struct VisibilityWarning:
    message: text
    symbol_name: text
    accessing_module: text
    defining_module: text
    span: Span
    code: text  # "W0401" for private, "W0402" for friend, "W0403" for package


# ============================================================================
# VisibilityWarning Methods (was: impl VisibilityWarning:)
# ============================================================================

# Visibility checker for cross-module access
class VisibilityChecker:
    """Checks visibility and emits warnings for private access.

    Extended to support 4-level visibility (Public/Internal/Package/Private)
    and friend-based access control.

    Usage:
        val checker = VisibilityChecker__new("current_module.spl", "current_package")
        val warnings = checker_check_symbol_access(checker, symbol, symbol_table, access_span)
    """
    current_module: text        # Module doing the accessing
    current_package: text       # Package of the accessing module
    warnings: [VisibilityWarning]

    static fn new(current_module: text) -> VisibilityChecker:
        VisibilityChecker(
            current_module: current_module,
            current_package: "",
            warnings: []
        )

    static fn with_package(current_module: text, current_package: text) -> VisibilityChecker:
        VisibilityChecker(
            current_module: current_module,
            current_package: current_package,
            warnings: []
        )

    fn check_symbol_access(
        symbol: Symbol,
        symbol_module: text,
        access_span: Span
    ) -> has_VisibilityWarning:
        """Check if accessing a symbol from another module is allowed.

        Returns warning if accessing a private symbol from another module.
        Returns nil if access is allowed (public symbol or same module).
        """
        # Same module? Always allowed
        if symbol_module == self.current_module:
            return nil

        # Public symbol? Allowed from any module
        if symbol.is_public:
            return nil

        # Private symbol from another module - emit warning
        VisibilityWarning__new(
            symbol.name,
            self.current_module,
            symbol_module,
            access_span
        )

    fn check_symbol_access_with_friends(
        symbol_name: text,
        symbol_visibility: Visibility,
        symbol_module: text,
        symbol_package: text,
        target_manifest: DirManifest?,
        access_span: Span
    ) -> VisibilityWarning?:
        """Check symbol access considering friend relationships.

        Uses the 4-level visibility model:
        - Public: always allowed
        - Internal: allowed for same package or declared friends
        - Package: allowed for same package only
        - Private: allowed for same file only
        """
        # Same module? Always allowed
        if symbol_module == self.current_module:
            return nil

        match symbol_visibility:
            case Visibility.Public:
                return nil
            case Visibility.Internal:
                # Same package? Allowed
                if self.current_package == symbol_package:
                    return nil
                # Friend check if manifest available
                if target_manifest.?:
                    val manifest = target_manifest ?? DirManifest__new("")
                    if manifest.is_friend(self.current_package):
                        return nil
                # Not a friend — warning
                return Some(VisibilityWarning(
                    message: "accessing internal symbol `{symbol_name}` from non-friend package `{self.current_package}` (target package: `{symbol_package}`)",
                    symbol_name: symbol_name,
                    accessing_module: self.current_module,
                    defining_module: symbol_module,
                    span: access_span,
                    code: "W0402"
                ))
            case Visibility.Package:
                # Same package? Allowed
                if self.current_package == symbol_package:
                    return nil
                return Some(VisibilityWarning(
                    message: "accessing package-private symbol `{symbol_name}` from outside package `{symbol_package}`",
                    symbol_name: symbol_name,
                    accessing_module: self.current_module,
                    defining_module: symbol_module,
                    span: access_span,
                    code: "W0403"
                ))
            case Visibility.Private:
                return Some(VisibilityWarning(
                    message: "accessing private symbol `{symbol_name}` from `{self.current_module}`",
                    symbol_name: symbol_name,
                    accessing_module: self.current_module,
                    defining_module: symbol_module,
                    span: access_span,
                    code: "W0401"
                ))

    me record_warning(warning: VisibilityWarning):
        """Record a visibility warning."""
        self.warnings = self.warnings_push(warnings, warning)

    fn get_warnings() -> [VisibilityWarning]:
        """Get all recorded warnings."""
        self.warnings

    fn warning_count() -> i64:
        """Get count of warnings."""
        self.warnings_len(warnings)

# Integration helper for symbol lookup
fn check_and_warn(
    checker: VisibilityChecker,
    symbol: Symbol,
    symbol_module: text,
    access_span: Span
):
    """Check visibility and record warning if needed.

    This should be called after each symbol lookup that crosses module boundaries.

    Example integration:
        val sym = symbol_table_lookup(symbol_table, name)
        if has_sym:
            val symbol = symbol_table_get(symbol_table, sym_value).unwrap()
            check_and_warn(visibility_checker, symbol, defining_module, current_span)
    """
    val warning = checker_check_symbol_access(checker, symbol, symbol_module, access_span)
    if has_warning:
        checker_record_warning(checker, warning_value)

# Export public API

# Desugared static methods for bootstrap interpreter compatibility

fn VisibilityChecker__new(current_module: text) -> VisibilityChecker:
    VisibilityChecker(
        current_module: current_module,
        current_package: "",
        warnings: []
    )



fn VisibilityChecker__with_package(current_module: text, current_package: text) -> VisibilityChecker:
        VisibilityChecker(
            current_module: current_module,
            current_package: current_package,
            warnings: []
        )

    fn check_symbol_access(
        symbol: Symbol,
        symbol_module: text,
        access_span: Span
    ) -> has_VisibilityWarning:
        """Check if accessing a symbol from another module is allowed.

        Returns warning if accessing a private symbol from another module.
        Returns nil if access is allowed (public symbol or same module).
        """
        # Same module? Always allowed
        if symbol_module == self.current_module:
            return nil

        # Public symbol? Allowed from any module
        if symbol.is_public:
            return nil

        # Private symbol from another module - emit warning
        VisibilityWarning__new(
            symbol.name,
            self.current_module,
            symbol_module,
            access_span
        )

    fn check_symbol_access_with_friends(
        symbol_name: text,
        symbol_visibility: Visibility,
        symbol_module: text,
        symbol_package: text,
        target_manifest: DirManifest?,
        access_span: Span
    ) -> VisibilityWarning?:
        """Check symbol access considering friend relationships.

        Uses the 4-level visibility model:
        - Public: always allowed
        - Internal: allowed for same package or declared friends
        - Package: allowed for same package only
        - Private: allowed for same file only
        """
        # Same module? Always allowed
        if symbol_module == self.current_module:
            return nil

        match symbol_visibility:
            case Visibility.Public:
                return nil
            case Visibility.Internal:
                # Same package? Allowed
                if self.current_package == symbol_package:
                    return nil
                # Friend check if manifest available
                if target_manifest.?:
                    val manifest = target_manifest ?? DirManifest__new("")
                    if manifest.is_friend(self.current_package):
                        return nil
                # Not a friend — warning
                return Some(VisibilityWarning(
                    message: "accessing internal symbol `{symbol_name}` from non-friend package `{self.current_package}` (target package: `{symbol_package}`)",
                    symbol_name: symbol_name,
                    accessing_module: self.current_module,
                    defining_module: symbol_module,
                    span: access_span,
                    code: "W0402"
                ))
            case Visibility.Package:
                # Same package? Allowed
                if self.current_package == symbol_package:
                    return nil
                return Some(VisibilityWarning(
                    message: "accessing package-private symbol `{symbol_name}` from outside package `{symbol_package}`",
                    symbol_name: symbol_name,
                    accessing_module: self.current_module,
                    defining_module: symbol_module,
                    span: access_span,
                    code: "W0403"
                ))
            case Visibility.Private:
                return Some(VisibilityWarning(
                    message: "accessing private symbol `{symbol_name}` from `{self.current_module}`",
                    symbol_name: symbol_name,
                    accessing_module: self.current_module,
                    defining_module: symbol_module,
                    span: access_span,
                    code: "W0401"
                ))

    me record_warning(warning: VisibilityWarning):
        """Record a visibility warning."""
        self.warnings = self.warnings_push(warnings, warning)

    fn get_warnings() -> [VisibilityWarning]:
        """Get all recorded warnings."""
        self.warnings

    fn warning_count() -> i64:
        """Get count of warnings."""
        self.warnings_len(warnings)


export VisibilityWarning
export VisibilityChecker
export check_and_warn
