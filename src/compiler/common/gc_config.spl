# GC/NoGC Configuration
#
# Core types for configuring garbage collection mode per-file/module.
# Simple has a two-domain memory model:
# - GC domain (default): bare T = GC-managed reference
# - Manual domain (opt-in): bare T = unique_pointer (&T)
#
# Configuration hierarchy:
#   simple.sdn (project default)
#     └── __init__.spl  #[no_gc]    (directory override)
#           └── file.spl  #[no_gc]  (file override)
#
# Child modules inherit parent GC mode unless explicitly overridden.

from parser_types import {Span}


# Auto-generated desugared static method wrappers
fn GcConfig__from_module(mode: GcMode) -> GcConfig:
    """Create a module-level GC configuration (from __init__.spl attribute)."""
    GcConfig(mode: mode, source: "module", explicit: true)


export GcMode, GcConfig, GcMismatchWarning

# ============================================================================
# GC Mode
# ============================================================================

enum GcMode:
    """Garbage collection mode for a compilation unit.

    Determines how bare type references (T) are resolved:
    - Gc: T is a GC-managed reference (shared pointer)
    - NoGc: T is a unique pointer (ownership-based)
    """
    # Default: GC-managed references
    Gc

    # Ownership: unique pointers
    NoGc

impl GcMode:
    fn to_string() -> text:
        match self:
            GcMode.Gc: "gc"
            GcMode.NoGc: "nogc"

    fn eq(other: GcMode) -> bool:
        self.to_string() == other.to_string()

    fn default_pointer_kind() -> text:
        """Map GC mode to the default pointer kind for bare types.

        - Gc: Shared (GC-managed, multiple readers)
        - NoGc: Unique (single owner, RAII)
        """
        match self:
            GcMode.Gc: "Shared"
            GcMode.NoGc: "Unique"

    fn default_capability() -> text:
        """Map GC mode to the default reference capability.

        - Gc: Shared (immutable access)
        - NoGc: Isolated (owns the data, no aliasing)
        """
        match self:
            GcMode.Gc: "Shared"
            GcMode.NoGc: "Isolated"

# ============================================================================
# GC Configuration
# ============================================================================

struct GcConfig:
    """Configuration for GC mode with provenance tracking.

    Tracks both the mode and where it was set, enabling
    clear diagnostics when cross-mode boundaries are detected.
    """
    # The GC mode
    mode: GcMode

    # Where this config was set: "default", "project", "module", "file"
    source: text

    # true if user declared explicitly, false if inherited from parent
    explicit: bool

impl GcConfig:
    static fn default_gc() -> GcConfig:
        """Create the default GC configuration (GC mode, inherited)."""
        GcConfig(mode: GcMode.Gc, source: "default", explicit: false)

    static fn from_project(mode: GcMode) -> GcConfig:
        """Create a project-level GC configuration."""
        GcConfig(mode: mode, source: "project", explicit: true)

    static fn from_module(mode: GcMode) -> GcConfig:
        """Create a module-level GC configuration (from __init__.spl attribute)."""
        GcConfig(mode: mode, source: "module", explicit: true)

    static fn from_file(mode: GcMode) -> GcConfig:
        """Create a file-level GC configuration (from file attribute)."""
        GcConfig(mode: mode, source: "file", explicit: true)

    fn effective_gc_config(parent: GcConfig) -> GcConfig:
        """Compute effective GC config by inheriting from parent when not explicit.

        - If this config is explicit, use it (overrides parent)
        - If this config is inherited, use parent's mode
        """
        if self.explicit:
            return self
        GcConfig(mode: parent.mode, source: parent.source, explicit: false)

    fn is_gc() -> bool:
        """Check if this config is in GC mode."""
        match self.mode:
            GcMode.Gc: true
            GcMode.NoGc: false

    fn is_nogc() -> bool:
        """Check if this config is in NoGC mode."""
        match self.mode:
            GcMode.NoGc: true
            GcMode.Gc: false

# ============================================================================
# GC Mismatch Warning
# ============================================================================

enum GcMismatchWarning:
    """Warnings emitted when crossing GC mode boundaries.

    These are warnings (not errors) - compilation continues.
    They alert developers to potential ownership/lifetime issues
    at GC mode boundaries.
    """
    # Calling a function in a different GC mode
    CrossModeCall(caller_mode: GcMode, callee_mode: GcMode, callee_name: text, span: Span)

    # Returning a value whose GC mode differs from the function's mode
    CrossModeReturn(fn_mode: GcMode, return_mode: GcMode, fn_name: text, span: Span)

    # Implicit conversion between GC modes (e.g., assigning GC ref to NoGC var)
    ImplicitConversion(from_mode: GcMode, to_mode: GcMode, span: Span)

impl GcMismatchWarning:
    fn message() -> text:
        """Generate a human-readable warning message."""
        match self:
            GcMismatchWarning.CrossModeCall(caller_mode, callee_mode, callee_name, _):
                "cross-mode call: calling `{callee_name}` ({callee_mode.to_string()}) from {caller_mode.to_string()} context"

            GcMismatchWarning.CrossModeReturn(fn_mode, return_mode, fn_name, _):
                "cross-mode return: function `{fn_name}` ({fn_mode.to_string()}) returns value from {return_mode.to_string()} context"

            GcMismatchWarning.ImplicitConversion(from_mode, to_mode, _):
                "implicit GC mode conversion: {from_mode.to_string()} to {to_mode.to_string()}"

    fn span() -> Span:
        """Get the source span for this warning."""
        match self:
            GcMismatchWarning.CrossModeCall(_, _, _, span): span
            GcMismatchWarning.CrossModeReturn(_, _, _, span): span
            GcMismatchWarning.ImplicitConversion(_, _, span): span
