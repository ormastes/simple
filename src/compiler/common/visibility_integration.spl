# Visibility Integration - HIR Walker for Visibility Checking
#
# Walks HIR modules to find cross-module symbol accesses and check visibility.

use hir_types.{HirModule, Symbol, SymbolId, SymbolTable}
use hir_definitions.{HirExpr, HirExprKind, HirStmt, HirStmtKind, HirBlock, HirFunction}
use visibility_checker.{VisibilityChecker, VisibilityWarning}
use lexer.Span

# Check visibility for all cross-module accesses in a HIR module
fn check_module_visibility(
    hir_module: HirModule,
    current_module_name: text
) -> [VisibilityWarning]:
    """Walk HIR module and collect visibility warnings for cross-module accesses."""

    val checker = visibilitychecker_new(current_module_name)
    val symbols = hir_module.symbols

    # Check all functions
    for func_id in hir_module.functions_keys(functions):
        val func = hir_module.functions[func_id]
        if has_func:
            check_function_visibility(func_value, symbols, checker)

    # Check classes (method bodies)
    for class_id in hir_module.classes_keys(classes):
        val cls = hir_module.classes[class_id]
        if has_cls:
            val class_def = cls_value
            for method in class_def.methods:
                check_function_visibility(method, symbols, checker)

    # Check impl blocks (method bodies)
    for impl_id in hir_module.impls_keys(impls):
        val impl_block = hir_module.impls[impl_id]
        if has_impl_block:
            val impl_def = impl_block_value
            for method in impl_def.methods:
                check_function_visibility(method, symbols, checker)

    checker_get_warnings(checker)

fn check_function_visibility(
    func: HirFunction,
    symbols: SymbolTable,
    checker: VisibilityChecker
):
    """Check visibility in a single function."""
    check_block_visibility(func.body, symbols, checker)

fn check_block_visibility(
    block: HirBlock,
    symbols: SymbolTable,
    checker: VisibilityChecker
):
    """Check visibility in a block."""
    for stmt in block.stmts:
        check_stmt_visibility(stmt, symbols, checker)

    if block.has_expr:
        check_expr_visibility(block.expr_value, symbols, checker)

fn check_stmt_visibility(
    stmt: HirStmt,
    symbols: SymbolTable,
    checker: VisibilityChecker
):
    """Check visibility in a statement."""
    match stmt.kind:
        case hirstmtkind_Let(_, _, init, _):
            if has_init:
                check_expr_visibility(init_value, symbols, checker)
        case hirstmtkind_Assign(target, value):
            check_expr_visibility(target, symbols, checker)
            check_expr_visibility(value, symbols, checker)
        case hirstmtkind_Expr(expr):
            check_expr_visibility(expr, symbols, checker)
        case hirstmtkind_Return(value):
            if has_value:
                check_expr_visibility(value_value, symbols, checker)
        default:
            pass_do_nothing

fn check_expr_visibility(
    expr: HirExpr,
    symbols: SymbolTable,
    checker: VisibilityChecker
):
    """Check visibility in an expression.

    This is where we detect cross-module symbol accesses and check visibility.
    """
    match expr.kind:
        case hirexprkind_Var(symbol_id):
            # Variable/function/class reference - check visibility
            check_symbol_visibility(symbol_id, symbols, checker, expr.span)

        case hirexprkind_Field(base, field, resolved):
            check_expr_visibility(base, symbols, checker)
            if has_resolved:
                check_symbol_visibility(resolved_value, symbols, checker, expr.span)

        case hirexprkind_Call(callee, args, _):
            check_expr_visibility(callee, symbols, checker)
            for arg in args:
                check_expr_visibility(arg.value, symbols, checker)

        case hirexprkind_MethodCall(receiver, method, args, resolution):
            check_expr_visibility(receiver, symbols, checker)
            for arg in args:
                check_expr_visibility(arg.value, symbols, checker)

        case hirexprkind_Binary(op, left, right):
            check_expr_visibility(left, symbols, checker)
            check_expr_visibility(right, symbols, checker)

        case hirexprkind_Unary(op, operand):
            check_expr_visibility(operand, symbols, checker)

        case hirexprkind_If(cond, then_block, else_block):
            check_expr_visibility(cond, symbols, checker)
            check_block_visibility(then_block, symbols, checker)
            if has_else_block:
                check_block_visibility(else_block_value, symbols, checker)

        case hirexprkind_Block(block):
            check_block_visibility(block, symbols, checker)

        case hirexprkind_ArrayLit(elements, _):
            for elem in elements:
                check_expr_visibility(elem, symbols, checker)

        case hirexprkind_TupleLit(elements):
            for elem in elements:
                check_expr_visibility(elem, symbols, checker)

        case hirexprkind_Match(subject, arms):
            check_expr_visibility(subject, symbols, checker)
            for arm in arms:
                check_expr_visibility(arm.body, symbols, checker)

        case hirexprkind_Return(value):
            if has_value:
                check_expr_visibility(value_value, symbols, checker)

        case hirexprkind_Index(base, index):
            check_expr_visibility(base, symbols, checker)
            check_expr_visibility(index, symbols, checker)

        case hirexprkind_Lambda(params, body):
            check_expr_visibility(body, symbols, checker)

        case hirexprkind_Assign(target, value):
            check_expr_visibility(target, symbols, checker)
            check_expr_visibility(value, symbols, checker)

        default:
            pass_do_nothing

fn check_symbol_visibility(
    symbol_id: SymbolId,
    symbols: SymbolTable,
    checker: VisibilityChecker,
    access_span: Span
):
    """Check if accessing this symbol violates visibility rules."""
    val symbol_opt = symbols_get(symbols, symbol_id)
    if not has_symbol_opt:
        return  # Symbol not found, likely an error elsewhere

    val symbol = symbol_opt_value

    # Check if symbol has a defining module
    if not symbol.has_defining_module:
        return  # Local symbol, no visibility check needed

    val defining_module = symbol.defining_module_value

    # Check visibility and record warning if needed
    val warning = checker_check_symbol_access(checker, symbol, defining_module, access_span)
    if has_warning:
        checker_record_warning(checker, warning_value)

# Export public API
export check_module_visibility
