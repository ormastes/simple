# Parser Types - Expression, Type, Pattern, Statement, and Operator AST
#
# Split from parser_types.spl.
# Contains all mutually-recursive expression-level AST types:
# - Type system (Type, TypeKind)
# - Tensor suffix types (DType, Device, Backend, TensorSuffix)
# - Expressions (Expr, ExprKind) and helper structs
# - Patterns (Pattern, PatternKind)
# - Statements (Stmt, StmtKind, Block)
# - Operators (BinOp, UnaryOp)
# - Inline assembly types

use lexer.Span

# ============================================================================
# Type AST
# ============================================================================

struct Type:
    """Type expression."""
    kind: TypeKind
    span: Span

"""Type expression kind."""
enum TypeKind:
    Named(text, [Type])
    Tuple([Type])
    Array(Type, Expr?)
    Function([Type], Type)
    Optional(Type)
    Reference(Type, bool)
    Atomic(Type)                # @T (Arc - atomic ref-counted)
    Isolated(Type)              # bitwise_not(T) (iso - isolated capability)
    Infer
    Error

# ============================================================================
# Tensor Suffix
# ============================================================================

"""Data type for tensors."""
enum DType:
    F16
    F32
    F64
    BF16
    I8
    I16
    I32
    I64
    U8
    U16
    U32
    U64

"""Device for tensor computation."""
enum Device:
    CPU
    CUDA(i32)   # CUDA device (0=1st GPU, 1=2nd GPU, etc.)

"""Tensor backend."""
enum Backend:
    Native
    PyTorch

struct TensorSuffix:
    """Suffix for array/tensor literals specifying dtype, device, etc.

    Examples:
    - f32        -> dtype=F32
    - _f32_gpu   -> dtype=F32, device=CUDA(0)  (gpu = default GPU)
    - f32_tr_cuda -> dtype=F32, trainable=true, device=CUDA(0)
    """
    # # DESUGARED: dtype: DType
    has_dtype: bool
    dtype: DType
    # # DESUGARED: device: Device
    has_device: bool
    device: Device
    trainable: bool
    pinned: bool
    # # DESUGARED: backend: Backend
    has_backend: bool
    backend: Backend
    raw: text       # Original suffix string


# ============================================================================
# TensorSuffix Methods (was: impl TensorSuffix:)
# ============================================================================

fn tensorsuffix_from_string(text) -> TensorSuffix:
        """Parse a suffix string into TensorSuffix."""
        var suffix = TensorSuffix(nil, nil, false, false, nil, s)

        # Split by underscore and parse each part
        var parts = s.split("_")
        for part in parts:
            if part == "":
                continue

            # Check dtype
            match part:
                case "f16": suffix.dtype = DType.F16
                case "f32": suffix.dtype = DType.F32
                case "f64": suffix.dtype = DType.F64
                case "bf16": suffix.dtype = DType.BF16
                case "i8": suffix.dtype = DType.I8
                case "i16": suffix.dtype = DType.I16
                case "i32": suffix.dtype = DType.I32
                case "i64": suffix.dtype = DType.I64
                case "u8": suffix.dtype = DType.U8
                case "u16": suffix.dtype = DType.U16
                case "u32": suffix.dtype = DType.U32
                case "u64": suffix.dtype = DType.U64
                # Check device
                case "cpu": suffix.device = Device.CPU
                case "gpu": suffix.device = Device.CUDA(0)  # gpu = default GPU (1st GPU)
                case "cuda": suffix.device = Device.CUDA(0)
                case "cuda0": suffix.device = Device.CUDA(0)
                case "cuda1": suffix.device = Device.CUDA(1)
                case "cuda2": suffix.device = Device.CUDA(2)
                case "cuda3": suffix.device = Device.CUDA(3)
                # Check modifiers
                case "tr": suffix.trainable = true
                case "pin": suffix.pinned = true
                # Check backend
                case "native": suffix.backend = Backend.Native
                case "torch": suffix.backend = Backend.PyTorch
                case _:
                    # Unknown part - could be cudaN for N > 3
                    if part.starts_with("cuda"):
                        val id_str = part[4:]
                        if id_str_len(id_str) > 0:
                            # Parse the numeric ID
                            val id = parse_int_literal(id_str)
                            suffix.device = device_CUDA(id, )

        suffix


# ============================================================================
# Expression AST
# ============================================================================

struct Expr:
    """Expression."""
    kind: ExprKind
    span: Span

"""Expression kind."""
enum ExprKind:
    # Literals
    IntLit(i64)
    FloatLit(f64)
    StringLit(text, [Interpolation]?)
    BoolLit(bool)
    NilLit
    ArrayLit([Expr])
    TupleLit([Expr])
    DictLit([(Expr, Expr)])
    SetLit([Expr])              # Set literal: s{1, 2, 3}

    # Identifiers and access
    Ident(text)
    Field(Expr, text)
    Index(Expr, Expr)
    OptionalChain(Expr, text)  # ?.
    NullCoalesce(Expr, Expr)    # ??
    ExistsCheck(Expr)                   #

    # Operators
    Binary(BinOp, Expr, Expr)
    Unary(UnaryOp, Expr)
    Range(Expr?, Expr?, bool, Expr?)

    # Function calls
    Call(Expr, [CallArg])
    MethodCall(Expr, text, [CallArg])

    # Control flow expressions
    If(Expr, Block, Block?)
    MatchCase(Expr, [MatchArm])
    Try(Expr)                           # expr
    TryCatch(Block, [CatchClause], Block?)

    # Closures
    Lambda([LambdaParam], Expr)
    Block(Block)

    # Comprehensions
    ListComprehension(Expr, [ComprehensionClause])
    DictComprehension(Expr, Expr, [ComprehensionClause])

    # Special
    Await(Expr)
    Spawn(Expr)                     # spawn expr - actor creation
    Yield(Expr?)
    Return(Expr?)
    Break(text?)
    Continue(text?)
    Throw(Expr)

    # Object construction
    StructLit(text, [(text, Expr)])
    EnumLit(text, text, EnumPayload?)

    # Math/DL blocks
    LossBlock(Block)            # loss{ ... } - enables autograd, auto-backward
    NogradBlock(Block)          # nograd{ ... } - disables gradient tracking

    # Unsafe block - allows raw pointer ops, FFI, inline assembly
    UnsafeBlock(Block)          # unsafe: ... - unsafe operations

    # Inline assembly - must be within unsafe block
    AsmBlock(AsmExpr)            # asm "mov eax, ebx" or asm volatile(...)

    # Target-qualified inline assembly - multi-target dispatch
    AsmMatch([AsmMatchArm])      # asm match: case [spec]: ...

    # Generic custom block (user-defined blocks like sh{}, sql{}, re{})
    CustomBlock(text, BlockValue)

    # Tensor literals with suffix
    ArrayLitSuffix([Expr], TensorSuffix)

    # GPU kernel launch: kernel<<<grid, block>>>(args)
    KernelLaunch(Expr, Expr, Expr, [CallArg])

    # GPU intrinsic functions
    GpuIntrinsic(GpuIntrinsicKind, [Expr])

    # Error recovery
    Error

"""GPU intrinsic function kinds."""
enum GpuIntrinsicKind:
    # Thread ID accessors
    GlobalId(i64)      # gpu_global_id(dim)
    LocalId(i64)       # gpu_local_id(dim)
    BlockId(i64)       # gpu_block_id(dim)
    BlockDim(i64)      # gpu_block_dim(dim)
    GridDim(i64)       # gpu_grid_dim(dim)

    # Synchronization
    Sync                    # gpu_sync()
    Barrier                 # gpu_barrier()
    MemFence                # gpu_mem_fence()

    # Atomic operations
    AtomicAdd               # gpu_atomic_add(ptr, val)
    AtomicSub               # gpu_atomic_sub(ptr, val)
    AtomicMin               # gpu_atomic_min(ptr, val)
    AtomicMax               # gpu_atomic_max(ptr, val)
    AtomicAnd               # gpu_atomic_and(ptr, val)
    AtomicOr                # gpu_atomic_or(ptr, val)
    AtomicXor               # gpu_atomic_xor(ptr, val)
    AtomicExchange          # gpu_atomic_exchange(ptr, val)
    AtomicCas               # gpu_atomic_cas(ptr, expected, desired)

struct Interpolation:
    """String interpolation."""
    expr: Expr
    # # DESUGARED: format: text
    has_format: bool
    format: text
    span: Span

struct CallArg:
    """Function call argument."""
    # # DESUGARED: name: text
    has_name: bool
    name: text
    value: Expr
    span: Span

struct MatchArm:
    """Match arm."""
    pattern: Pattern
    # # DESUGARED: guard: Expr
    has_guard: bool
    guard: Expr
    body: Block
    span: Span

struct CatchClause:
    """Catch clause in try-catch."""
    # # DESUGARED: pattern: Pattern
    has_pattern: bool
    pattern: Pattern
    # # DESUGARED: type_: Type
    has_type_: bool
    type_: Type
    body: Block
    span: Span

struct LambdaParam:
    """Lambda parameter."""
    name: text
    # # DESUGARED: type_: Type
    has_type_: bool
    type_: Type
    span: Span

struct ComprehensionClause:
    """Comprehension clause."""
    kind: ComprehensionKind
    span: Span

enum ComprehensionKind:
    For(text, Expr)
    If(Expr)

enum EnumPayload:
    Tuple([Expr])
    Struct([(text, Expr)])

# ============================================================================
# Pattern AST
# ============================================================================

struct Pattern:
    """Pattern for matching."""
    kind: PatternKind
    span: Span

"""Pattern kind."""
enum PatternKind:
    Wildcard                                  # _
    Literal(Expr)                      # 42, "hello", true
    Binding(text, bool)        # x, var x
    Tuple([Pattern])                # (a, b, c)
    Array([Pattern], text?)   # [a, b, ..rest]
    Struct(text, [(text, Pattern)]) # Point { x, y }
    Enum(text, text, EnumPatternPayload?)
    Or([Pattern])                   # a | b | c
    Guard(Pattern, Expr)      # p if cond
    As(Pattern, text)          # p as name
    Range(Expr?, Expr?, bool) # 1..10, 1..=10
    Error

enum EnumPatternPayload:
    Tuple([Pattern])
    Struct([(text, Pattern)])

# ============================================================================
# Statement AST
# ============================================================================

struct Stmt:
    """Statement."""
    kind: StmtKind
    span: Span

"""Statement kind."""
enum StmtKind:
    Expr(Expr)
    Val(text, Type?, Expr)
    Var(text, Type?, Expr?)
    SharedVal(text, Type, Expr?)    # GPU shared memory (immutable)
    SharedVar(text, Type, Expr?)    # GPU shared memory (mutable)
    Assign(Expr, AssignOp?, Expr)
    For(text, Expr, Block)
    While(Expr, Block)
    Loop(Block)
    Break(text?)
    Continue(text?)
    Return(Expr?)
    Yield(Expr?)
    Throw(Expr)
    With([WithItem], Block)         # with statement - context managers
    AsmAssert(AsmTargetSpec)        # asm assert [spec] - compile-time target guard

"""Assignment operator."""
enum AssignOp:
    Add     # +=
    Sub     # -=
    Mul     # *=
    Div     # /=
    Mod     # %=

struct Block:
    """Block of statements."""
    stmts: [Stmt]
    span: Span

struct WithItem:
    """Context manager item in with statement."""
    context_expr: Expr      # Expression that produces context manager
    # # DESUGARED: target: text
    has_target: bool
    target: text
    span: Span

# ============================================================================
# Operators
# ============================================================================

"""Binary operator."""
enum BinOp:
    # Arithmetic
    Add
    Sub
    Mul
    Div
    Mod
    Pow

    # Matrix operations
    MatMul              # @

    # Comparison
    Eq
    NotEq
    Lt
    LtEq
    Gt
    GtEq

    # Logical
    And
    Or

    # Bitwise
    BitAnd
    BitOr
    BitXor
    Shl
    Shr

    # Broadcast operations (dotted operators)
    BroadcastAdd        # .+
    BroadcastSub        # .-
    BroadcastMul        # .*
    BroadcastDiv        # ./
    BroadcastPow        # .^

    # Pipeline/Composition operators
    PipeForward         # |>
    Compose             # >>
    ComposeBack         # <<
    Parallel            # //
    LayerConnect        # ~>

    # Other
    In
    NotIn
    Is
    IsNot

"""Unary operator."""
enum UnaryOp:
    Neg         # -
    Not         # not, !
    BitNot      # ~
    Ref         # &
    Deref       # *
    Transpose   # ' (postfix, m{} only)

# ============================================================================
# Inline Assembly
# ============================================================================

struct AsmExpr:
    """Inline assembly expression.

    Supports two syntaxes:
    1. Simple: asm "mov eax, ebx"
    2. Full: asm volatile("mov r0, {op}", op = in(reg) value, clobber_abi("C"))
    """
    asm_template: text              # Assembly asm_template string
    is_volatile: bool           # volatile flag (prevent optimization)
    constraints: [AsmConstraint]  # Register/memory constraints
    clobbers: [text]            # Clobbered registers
    span: Span

struct AsmConstraint:
    """Assembly operand constraint.

    Examples:
    - op = in(reg) value        # Input register
    - result = out(reg) var     # Output register
    - ptr = inout(reg) addr     # Input/output register
    """
    name: text                  # Operand name (e.g., "op", "result")
    kind: AsmConstraintKind     # in, out, inout
    location: AsmLocation       # reg, mem, etc.
    value: Expr                 # Expression for operand
    span: Span

enum AsmConstraintKind:
    In          # Input operand
    Out         # Output operand
    InOut       # Input/output operand
    LateOut     # Late output (clobbers after inputs read)

enum AsmLocation:
    Reg         # General register
    RegSpec(text)  # Specific register (e.g., "eax", "r0")
    Mem         # Memory location
    Imm         # Immediate value

# ============================================================================
# Target-Qualified ASM Types
# ============================================================================

struct AsmTargetSpec:
    """Target specifier for asm match/assert.

    Format: [arch, os, abi, backend version_constraint]
    All fields after arch are optional (nil = wildcard).
    """
    archs: [text]                          # ["x86_64"] or ["x86_64", "x86"]
    # # DESUGARED: os: text
    has_os: bool
    os: text                               # "linux" or nil (wildcard)
    # # DESUGARED: abi: text
    has_abi: bool
    abi: text                              # "gnu" or nil (wildcard)
    # # DESUGARED: backend: text
    has_backend: bool
    backend: text                          # "llvm" or nil (wildcard)
    version_constraints: [AsmVersionConstraint]
    span: Span

struct AsmVersionConstraint:
    """Version constraint for backend in asm target spec.

    Examples: >= 15, == 17, < 18, ~= 17
    """
    op: text                               # ">=", "==", "<", "~="
    version: i64

struct AsmMatchArm:
    """Single arm in an asm match expression.

    Either a target-qualified asm body or a compile_error.
    """
    # # DESUGARED: spec: AsmTargetSpec
    has_spec: bool
    spec: AsmTargetSpec                    # nil = wildcard (_)
    is_wildcard: bool
    # # DESUGARED: asm_body: AsmExpr
    has_asm_body: bool
    asm_body: AsmExpr                      # nil if compile_error
    is_compile_error: bool
    error_message: text
    span: Span

# ============================================================================
# Exports
# ============================================================================

export Type, TypeKind
export DType, Device, Backend, TensorSuffix
export Expr, ExprKind, Interpolation, CallArg, MatchArm, CatchClause
export LambdaParam, ComprehensionClause, ComprehensionKind, EnumPayload
export GpuIntrinsicKind
export Pattern, PatternKind, EnumPatternPayload
export Stmt, StmtKind, AssignOp, Block, WithItem
export BinOp, UnaryOp
export AsmExpr, AsmConstraint, AsmConstraintKind, AsmLocation
export AsmTargetSpec, AsmVersionConstraint, AsmMatchArm
