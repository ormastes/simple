# Shared executable object mapper for loader and JIT paths.
#
# Centralizes executable memory allocation and symbol ownership tracking so
# loader/module and JIT flows do not duplicate mmap/write/protect lifecycle.

use .smf_mmap_native.{
    native_alloc_exec_memory,
    native_write_exec_memory,
    native_make_executable,
    native_flush_icache,
    native_get_function_pointer,
    native_free_exec_memory
}

struct SharedExecMapperConfig:
    verbose: bool

impl SharedExecMapperConfig:
    static fn default() -> SharedExecMapperConfig:
        SharedExecMapperConfig(verbose: false)

struct SharedExecRecord:
    owner_id: text
    symbol: text
    address: i64
    size: i64
    generation: i32

struct SharedExecMapperStats:
    mapped_symbols: i32
    owner_count: i32
    total_bytes: i64
    generation: i32

struct SharedExecMapper:
    config: SharedExecMapperConfig
    records: Dict<text, SharedExecRecord>
    total_bytes: i64
    generation: i32

impl SharedExecMapper:
    static fn new(config: SharedExecMapperConfig) -> SharedExecMapper:
        SharedExecMapper(
            config: config,
            records: {},
            total_bytes: 0,
            generation: 0
        )

    me map_symbol(owner_id: text, symbol: text, code: [u8], allow_replace: bool) -> Result<i64, text>:
        val code_size = code.len() as i64
        if code_size <= 0:
            return Err("Cannot map empty code for symbol {symbol}")

        # Replace path is allowed for JIT re-instantiation and hot-reload flows.
        if self.records.contains_key(symbol):
            if not allow_replace:
                return Err("Symbol already mapped: {symbol}")
            val old = self.records[symbol]
            val old_freed = native_free_exec_memory(old.address, old.size)
            if not old_freed:
                return Err("Failed to free existing mapping for {symbol}")
            self.total_bytes = self.total_bytes - old.size
            self.records = self.records.remove(symbol)

        val addr = native_alloc_exec_memory(code_size)
        if addr == 0:
            return Err("Executable allocation failed for {symbol} ({code_size} bytes)")

        val written = native_write_exec_memory(addr, code, 0)
        if written != code_size:
            _ = native_free_exec_memory(addr, code_size)
            return Err("Failed to copy executable bytes for {symbol}")

        val executable = native_make_executable(addr, code_size)
        if not executable:
            _ = native_free_exec_memory(addr, code_size)
            return Err("Failed to switch RW->RX for {symbol}")

        native_flush_icache(addr, code_size)
        val fn_ptr = native_get_function_pointer(addr)

        self.generation = self.generation + 1
        self.records[symbol] = SharedExecRecord(
            owner_id: owner_id,
            symbol: symbol,
            address: fn_ptr,
            size: code_size,
            generation: self.generation
        )
        self.total_bytes = self.total_bytes + code_size

        if self.config.verbose:
            print "[exec-mapper] mapped {symbol} owner={owner_id} addr=0x{fn_ptr} size={code_size}"

        Ok(fn_ptr)

    fn lookup(symbol: text) -> i64?:
        if self.records.contains_key(symbol):
            return Some(self.records[symbol].address)
        nil

    fn get_record(symbol: text) -> SharedExecRecord?:
        if self.records.contains_key(symbol):
            return Some(self.records[symbol])
        nil

    me unmap_symbol(symbol: text) -> bool:
        if not self.records.contains_key(symbol):
            return false

        val rec = self.records[symbol]
        val freed = native_free_exec_memory(rec.address, rec.size)
        if not freed:
            return false

        self.total_bytes = self.total_bytes - rec.size
        self.records = self.records.remove(symbol)
        true

    me unmap_owner(owner_id: text) -> i32:
        var symbols: [text] = []
        for (symbol, rec) in self.records:
            if rec.owner_id == owner_id:
                symbols.push(symbol)

        var removed = 0
        for symbol in symbols:
            if self.unmap_symbol(symbol):
                removed = removed + 1

        removed

    me clear():
        var symbols: [text] = []
        for (symbol, _) in self.records:
            symbols.push(symbol)

        for symbol in symbols:
            _ = self.unmap_symbol(symbol)

    fn stats() -> SharedExecMapperStats:
        var owners: Set<text> = {}
        for (_, rec) in self.records:
            owners = owners.insert(rec.owner_id)

        SharedExecMapperStats(
            mapped_symbols: self.records.len(),
            owner_count: owners.len(),
            total_bytes: self.total_bytes,
            generation: self.generation
        )

# ============================================================================
# Policy wrappers
# ============================================================================

struct LoaderMapperConfig:
    allow_replace_on_reload: bool

impl LoaderMapperConfig:
    static fn default() -> LoaderMapperConfig:
        LoaderMapperConfig(allow_replace_on_reload: false)

struct LoaderMapper:
    config: LoaderMapperConfig

impl LoaderMapper:
    static fn new(config: LoaderMapperConfig) -> LoaderMapper:
        LoaderMapper(config: config)

    me map(exec_mapper: SharedExecMapper, owner_id: text, symbol: text, code: [u8], allow_replace_request: bool) -> Result<i64, text>:
        if allow_replace_request and not self.config.allow_replace_on_reload:
            return Err("Loader replace is disabled for symbol {symbol}")
        exec_mapper.map_symbol(owner_id, symbol, code, allow_replace_request)

    me unmap_owner(exec_mapper: SharedExecMapper, owner_id: text) -> i32:
        exec_mapper.unmap_owner(owner_id)

struct JitMapperConfig:
    default_owner: text
    allow_replace: bool

impl JitMapperConfig:
    static fn default() -> JitMapperConfig:
        JitMapperConfig(
            default_owner: "__jit__",
            allow_replace: true
        )

struct JitMapper:
    config: JitMapperConfig

impl JitMapper:
    static fn new(config: JitMapperConfig) -> JitMapper:
        JitMapper(config: config)

    me map(exec_mapper: SharedExecMapper, owner_id: text, symbol: text, code: [u8]) -> Result<i64, text>:
        val effective_owner = if owner_id == "":
            self.config.default_owner
        else:
            owner_id
        exec_mapper.map_symbol(effective_owner, symbol, code, self.config.allow_replace)

    me unmap_owner(exec_mapper: SharedExecMapper, owner_id: text) -> i32:
        exec_mapper.unmap_owner(owner_id)

# ============================================================================
# Exports
# ============================================================================

export SharedExecMapperConfig
export SharedExecRecord
export SharedExecMapperStats
export SharedExecMapper
export LoaderMapperConfig
export LoaderMapper
export JitMapperConfig
export JitMapper
