# JIT instantiation at load-time.
#
# This module handles on-demand instantiation of generic templates
# when resolving missing symbols during runtime loading.
#
# Phase 5: Load-Time JIT Instantiation

# NOTE: compiler_ffi functions are registered as FFI in Rust runtime - no import needed
# use compiler.loader.compiler_ffi.*
# TODO: Re-enable when mmap functions are available in app.io.mod
# use compiler.loader.smf_cache (SmfCache, MappedSmf)
# TODO: Add these functions to app.io.mod when implementing executable memory support
# use app.io.io (alloc_exec_memory, write_exec_memory, flush_icache, get_function_pointer)

# ============================================================================
# Compiler Context FFI (Simple stubs - TODO: Replace with full implementation)
# ============================================================================

# NOTE: These are stub implementations that return dummy values for testing.
# Real implementations would interact with the compiler for type inference
# and template instantiation.

fn compiler_create_context() -> i64:
    """Create a new compiler context (stub implementation)."""
    # Stub: Just return a dummy handle
    # Real implementation would allocate actual compiler context
    1

fn compiler_destroy_context(handle: i64) -> bool:
    """Destroy a compiler context (stub implementation)."""
    # Stub: Always return success
    true

fn compiler_infer_types(handle: i64, template_json: text, hints_json: text) -> text:
    """Infer types for a template (stub implementation)."""
    # Stub: Return empty type array
    "[]"

fn compiler_check_types(handle: i64, types_json: text, constraints_json: text) -> bool:
    """Check types against constraints (stub implementation)."""
    # Stub: Always pass type checking
    true

fn compiler_instantiate_template(handle: i64, template_json: text, types_json: text) -> text:
    """Instantiate a template (stub implementation)."""
    # Stub: Return success with empty bytecode
    "{\"status\":\"success\",\"bytecode\":\"\"}"

fn compiler_get_stats(handle: i64) -> text:
    """Get compiler statistics (stub implementation)."""
    # Stub: Return zero stats
    "{\"type_inferences\":0,\"template_instantiations\":0}"

# ============================================================================
# Result Types
# ============================================================================

enum JitInstantiationResult:
    """Result of JIT instantiation attempt."""
    Success(code: [u8], symbol: text, address: i64?)
    NotFound(symbol: text)
    CircularDependency(cycle: [text])
    CompilationError(message: text)
    UpdateFailed(symbol: text, error: text)

impl JitInstantiationResult:
    fn is_success() -> bool:
        match self:
            case Success(_, _, _): true
            case _: false

    fn is_error() -> bool:
        match self:
            case CompilationError(_): true
            case CircularDependency(_): true
            case UpdateFailed(_, _): true
            case _: false

# ============================================================================
# Configuration
# ============================================================================

struct JitInstantiatorConfig:
    """Configuration for JIT instantiation."""
    update_smf: bool
    max_depth: i32
    enabled: bool
    verbose: bool

impl JitInstantiatorConfig:
    static fn default() -> JitInstantiatorConfig:
        JitInstantiatorConfig(
            update_smf: true,
            max_depth: 50,
            enabled: true,
            verbose: false
        )

# ============================================================================
# Simplified Metadata Types (FFI-friendly)
# ============================================================================

struct LoadedMetadata:
    """Simplified metadata for FFI (no complex compiler types)."""
    possible: [PossibleInstantiation]
    instantiations: [InstantiationRecord]

struct PossibleInstantiation:
    """A possible generic instantiation."""
    template_name: text
    type_args: text
    mangled_name: text

struct InstantiationRecord:
    """A recorded instantiation."""
    id: i32
    template_name: text
    type_args: text
    mangled_name: text
    from_file: text
    from_loc: text
    to_obj: text
    status: text

# ============================================================================
# Stub Types (TODO: Replace with real implementations when infrastructure is ready)
# ============================================================================

# Note.sdn metadata structures (stub versions)
struct NoteSdnPossible:
    template: text
    type_args: text
    mangled_name: text

struct NoteSdnInstantiation:
    template: text
    type_args: text
    mangled_name: text
    from_file: text
    from_loc: text
    output_file: text
    status: InstantiationStatus

enum InstantiationStatus:
    Pending
    Success
    Failed

impl InstantiationStatus:
    fn as_str() -> text:
        match self:
            case Pending: "pending"
            case Success: "success"
            case Failed: "failed"

struct NoteSdnMetadata:
    possible: [NoteSdnPossible]
    instantiations: [NoteSdnInstantiation]

struct SmfCache:
    """Stub for SMF cache (requires mmap infrastructure)."""
    cached_files: Dict<text, i32>
    enabled: bool
    stats: CacheStats

impl SmfCache:
    me get(path: text) -> Result<MappedSmf, text>:
        """Stub: Returns empty MappedSmf for testing."""
        # Track that we accessed this file
        if not self.cached_files.contains_key(path):
            self.cached_files[path] = 1
        Ok(MappedSmf(path: path))

    fn get_stats() -> CacheStats:
        CacheStats(
            total_files: self.cached_files.len(),
            total_memory: 0,
            cache_hits: 0,
            cache_misses: 0
        )

struct MappedSmf:
    """Stub for mapped SMF file."""
    path: text

impl MappedSmf:
    fn read_note_sdn() -> Result<NoteSdnMetadata, text>:
        """Stub: Returns empty metadata for testing."""
        Ok(NoteSdnMetadata(
            possible: [],
            instantiations: []
        ))

struct CacheStats:
    """Cache statistics."""
    total_files: i32
    total_memory: i64
    cache_hits: i32
    cache_misses: i32

# ============================================================================
# JIT Instantiator
# ============================================================================

struct JitInstantiator:
    """JIT instantiator for load-time template instantiation."""
    config: JitInstantiatorConfig
    compiler_ctx_handle: i64  # Compiler context handle (i64, not CompilerContext to avoid constructor issues)
    loaded_metadata: Dict<text, LoadedMetadata>  # Simplified metadata
    in_progress: Set<text>
    depth: i32
    jit_cache: Dict<text, ([u8], i64)>
    symbol_table: Dict<text, i64>
    smf_cache: SmfCache  # Memory-mapped SMF file cache

impl JitInstantiator:
    static fn new(config: JitInstantiatorConfig) -> JitInstantiator:
        """Create a new JIT instantiator."""
        JitInstantiator(
            config: config,
            compiler_ctx_handle: compiler_create_context(),  # Direct i64 handle
            loaded_metadata: {},
            in_progress: {},
            depth: 0,
            jit_cache: {},
            symbol_table: {},
            smf_cache: SmfCache(
                cached_files: {},
                enabled: true,
                stats: CacheStats(
                    total_files: 0,
                    total_memory: 0,
                    cache_hits: 0,
                    cache_misses: 0
                )
            )
        )

    me load_smf_metadata(smf_path: text) -> Result<(), text>:
        """Load note.sdn metadata from an SMF file."""
        val metadata = self.read_note_sdn_from_file(smf_path)?
        self.loaded_metadata[smf_path] = metadata
        Ok(())

    me set_metadata_for_test(smf_path: text, metadata: LoadedMetadata):
        """Set metadata directly (for testing only)."""
        self.loaded_metadata[smf_path] = metadata

    me set_cache_for_test(symbol: text, code: [u8], address: i64):
        """Set cache entry directly (for testing only)."""
        self.jit_cache[symbol] = (code, address)
        self.symbol_table[symbol] = address

    me read_note_sdn_from_file(smf_path: text) -> Result<LoadedMetadata, text>:
        """Read note.sdn section from SMF file using mmap cache."""
        # Get mapped SMF file from cache (auto-loads if not cached)
        var mapped_smf = self.smf_cache.get(smf_path)?

        # Read note.sdn metadata
        val metadata = mapped_smf.read_note_sdn()?

        # Convert NoteSdnMetadata to LoadedMetadata
        var possible: [PossibleInstantiation] = []
        for entry in metadata.possible:
            possible = possible.push(PossibleInstantiation(
                template_name: entry.template,
                type_args: entry.type_args,
                mangled_name: entry.mangled_name
            ))

        var instantiations: [InstantiationRecord] = []
        var id = 0
        for entry in metadata.instantiations:
            instantiations = instantiations.push(InstantiationRecord(
                id: id,
                template_name: entry.template,
                type_args: entry.type_args,
                mangled_name: entry.mangled_name,
                from_file: entry.from_file,
                from_loc: entry.from_loc,
                to_obj: entry.output_file,
                status: entry.status.as_str()
            ))
            id = id + 1

        Ok(LoadedMetadata(possible: possible, instantiations: instantiations))

    fn can_jit_instantiate(symbol: text) -> bool:
        """Check if a symbol can be JIT-instantiated."""
        if not self.config.enabled:
            return false

        for (_, metadata) in self.loaded_metadata:
            for poss in metadata.possible:
                if poss.mangled_name == symbol:
                    return true
        false

    fn find_possible(symbol: text) -> (text, PossibleInstantiation)?:
        """Find possible instantiation for a symbol."""
        for (path, metadata) in self.loaded_metadata:
            for entry in metadata.possible:
                if entry.mangled_name == symbol:
                    return Some((path, entry))
        nil

    me try_jit_instantiate(symbol: text) -> JitInstantiationResult:
        """Try to JIT-instantiate a missing symbol."""
        if not self.config.enabled:
            return JitInstantiationResult.NotFound(symbol)

        # Check depth limit
        if self.depth >= self.config.max_depth:
            return JitInstantiationResult.CompilationError(
                "Maximum JIT depth ({self.config.max_depth}) exceeded"
            )

        # Check cache
        if self.jit_cache.contains_key(symbol):
            val (code, address) = self.jit_cache[symbol]
            return JitInstantiationResult.Success(
                code: code,
                symbol: symbol,
                address: Some(address)
            )

        # Check for cycle
        if self.in_progress.contains(symbol):
            # Convert set to list by iterating
            var cycle: [text] = []
            for sym in self.in_progress:
                cycle = cycle.push(sym)
            cycle = cycle.push(symbol)  # Add current symbol to show cycle
            return JitInstantiationResult.CircularDependency(cycle)

        # Find possible entry
        val found = self.find_possible(symbol)
        if not found.?:
            return JitInstantiationResult.NotFound(symbol)

        val (smf_path, entry) = found.unwrap()

        # Start JIT compilation
        self.in_progress = self.in_progress.insert(symbol)
        self.depth = self.depth + 1

        if self.config.verbose:
            print "[jit] JIT-compiling {symbol} from {smf_path}"

        val result = self.do_jit_compile(entry, smf_path)

        # Cleanup
        self.in_progress = self.in_progress.remove(symbol)
        self.depth = self.depth - 1

        result

    me do_jit_compile(entry: PossibleInstantiation, smf_path: text) -> JitInstantiationResult:
        """Perform JIT compilation via FFI."""
        # TODO: Load actual template bytes from SMF TemplateCode section
        # For now, placeholder with empty template bytes
        val tmpl_bytes = TemplateBytes(
            bytes: [],  # TODO: Load from SMF
            name: entry.template_name,
            param_count: entry.type_args.split(",").len() as i32
        )

        # Parse type args from string to TypeInfo
        val type_args = entry.type_args.split(",")
            .map(\s: type_from_string(s.trim()))

        # TODO: Compile via FFI (stub for now - actual implementation needs JSON serialization)
        # val result_json = compiler_instantiate_template(self.compiler_ctx_handle, template_json, types_json)
        # For now, return error
        val code_result: Result<[u8], text> = Err("JIT compilation not yet implemented")

        match code_result:
            case Ok(compiled_code):
                # Allocate executable memory
                val code_size = compiled_code.len() as i64
                val exec_address = alloc_exec_memory(code_size)

                if exec_address == 0:
                    return JitInstantiationResult.CompilationError(
                        "Failed to allocate executable memory"
                    )

                # Write code to executable memory
                val bytes_written = write_exec_memory(exec_address, compiled_code, 0)
                if bytes_written != code_size:
                    return JitInstantiationResult.CompilationError(
                        "Failed to write code to executable memory"
                    )

                # Flush instruction cache (required on ARM/RISC-V)
                flush_icache(exec_address, code_size)

                # Get function pointer
                val fn_pointer = get_function_pointer(exec_address)

                # Cache the result
                self.jit_cache[entry.mangled_name] = (compiled_code, fn_pointer)

                # Register in symbol table
                self.symbol_table[entry.mangled_name] = fn_pointer

                # Update SMF file if configured
                if self.config.update_smf:
                    val update_result = self.update_smf_note_sdn(smf_path, entry)
                    if update_result.is_err():
                        return JitInstantiationResult.UpdateFailed(
                            symbol: entry.mangled_name,
                            error: update_result.unwrap_err()
                        )

                JitInstantiationResult.Success(
                    code: compiled_code,
                    symbol: entry.mangled_name,
                    address: Some(fn_pointer)
                )

            case Err(msg):
                JitInstantiationResult.CompilationError(msg)

    me update_smf_note_sdn(smf_path: text, entry: PossibleInstantiation) -> Result<(), text>:
        """Update note.sdn in SMF file after JIT compilation."""
        # TODO: Implement proper SMF update
        if self.config.verbose:
            print "[jit] Would update {smf_path}: {entry.mangled_name} moved to instantiations"

        # Update local metadata
        if self.loaded_metadata.contains_key(smf_path):
            var metadata = self.loaded_metadata[smf_path]

            # Remove from possible
            metadata.possible = metadata.possible.filter(\p: p.mangled_name != entry.mangled_name)

            # Add to instantiations
            val new_inst = InstantiationRecord(
                id: metadata.instantiations.len() as i32,
                template_name: entry.template_name,
                type_args: entry.type_args,
                mangled_name: entry.mangled_name,
                from_file: smf_path,
                from_loc: "{smf_path}:0:0:jit",
                to_obj: "jit_memory",
                status: "jit_compiled"
            )
            metadata.instantiations = metadata.instantiations.push(new_inst)

            self.loaded_metadata[smf_path] = metadata

        Ok(())

    fn stats() -> JitStats:
        """Get JIT statistics."""
        val cache_stats = self.smf_cache.get_stats()
        JitStats(
            cached_count: self.jit_cache.len(),
            loaded_smf_count: self.loaded_metadata.len(),
            smf_cache_hits: cache_stats.cache_hits,
            smf_cache_misses: cache_stats.cache_misses,
            smf_files_mapped: cache_stats.total_files,
            smf_memory_mapped: cache_stats.total_memory
        )

# ============================================================================
# Statistics
# ============================================================================

struct JitStats:
    """JIT instantiation statistics."""
    cached_count: i32
    loaded_smf_count: i32
    smf_cache_hits: i32
    smf_cache_misses: i32
    smf_files_mapped: i32
    smf_memory_mapped: i64

# ============================================================================
# Symbol Resolver
# ============================================================================

struct JitSymbolResolver:
    """Symbol resolver that integrates JIT instantiation."""
    jit: JitInstantiator
    symbols: Dict<text, i64>

impl JitSymbolResolver:
    static fn new(config: JitInstantiatorConfig) -> JitSymbolResolver:
        """Create a new JIT symbol resolver."""
        JitSymbolResolver(
            jit: JitInstantiator.new(config),
            symbols: {}
        )

    me register(name: text, address: i64):
        """Register a symbol."""
        self.symbols[name] = address

    me resolve(name: text) -> i64?:
        """Resolve a symbol, JIT-compiling if necessary."""
        # Check primary table first
        if self.symbols.contains_key(name):
            return Some(self.symbols[name])

        # Try JIT instantiation
        val result = self.jit.try_jit_instantiate(name)
        match result:
            case Success(_, symbol, address):
                if address.?:
                    self.symbols[symbol] = address.unwrap()
                    return address
                nil
            case _:
                nil

    me load_smf(path: text) -> Result<(), text>:
        """Load metadata from SMF file."""
        self.jit.load_smf_metadata(path)

    me set_jit_cache_for_test(symbol: text, code: [u8], address: i64):
        """Set JIT cache entry directly (for testing only)."""
        self.jit.set_cache_for_test(symbol, code, address)

# ============================================================================
# Exports
# ============================================================================

export JitInstantiationResult
export JitInstantiatorConfig
export JitInstantiator
export JitStats
export JitSymbolResolver
export LoadedMetadata
export PossibleInstantiation
export InstantiationRecord
