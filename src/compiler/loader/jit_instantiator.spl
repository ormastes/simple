# JIT instantiation at load-time.
#
# This module handles on-demand instantiation of generic templates
# when resolving missing symbols during runtime loading.
#
# Phase 5: Load-Time JIT Instantiation

# NOTE: compiler_ffi functions are registered as FFI in Rust runtime - no import needed
# use compiler.loader.compiler_ffi.*
# mmap functions not yet available in app.io.mod; SmfCache/MappedSmf stubbed locally
# use compiler.loader.smf_cache (SmfCache, MappedSmf)
# Executable memory functions not yet available in app.io.mod; stubs used below
# use app.io.mod (alloc_exec_memory, write_exec_memory, flush_icache, get_function_pointer)

# ============================================================================
# Compiler Context FFI
# ============================================================================

# These functions bridge to the compiler runtime for type inference and
# template instantiation. They are called during JIT compilation to
# produce specialized code from generic templates.
#
# FFI Protocol:
# - Context handles are i64 opaque references
# - Data is exchanged as SDN-encoded text (not JSON)
# - Results include a "status" field: "success" or "error"
# - On error, a "message" field describes the failure

fn compiler_create_context() -> i64:
    """Create a new compiler context for JIT compilation.

    Returns an opaque handle to a compiler context that maintains
    type inference state and template caches across instantiations.
    Returns 0 on failure.
    """
    # When the compiler FFI is registered in the runtime, this will
    # call: extern fn rt_compiler_create_context() -> i64
    # For now, return a valid dummy handle
    1

fn compiler_destroy_context(handle: i64) -> bool:
    """Destroy a compiler context and free associated resources.

    Must be called when the JIT instantiator is done to prevent leaks.
    """
    if handle == 0:
        return false
    # When FFI is available: extern fn rt_compiler_destroy_context(handle: i64) -> bool
    true

fn compiler_infer_types(handle: i64, template_sdn: text, hints_sdn: text) -> text:
    """Infer concrete types for a generic template.

    Uses call-site type hints (argument types, return type context) to
    determine the concrete type arguments for instantiation.

    Args:
        handle: Compiler context handle
        template_sdn: SDN-encoded template definition
        hints_sdn: SDN-encoded type hints from call site

    Returns: SDN-encoded array of inferred type strings, or error.
    """
    if handle == 0:
        return "status: error\nmessage: invalid context handle"
    # When FFI is available: extern fn rt_compiler_infer_types(...)
    "status: success\ntypes: []"

fn compiler_check_types(handle: i64, types_sdn: text, constraints_sdn: text) -> bool:
    """Check inferred types against template constraints.

    Validates that the concrete types satisfy all trait bounds,
    where clauses, and other constraints on the generic parameters.
    """
    if handle == 0:
        return false
    # When FFI is available: extern fn rt_compiler_check_types(...)
    true

fn compiler_instantiate_template(handle: i64, template_sdn: text, types_sdn: text) -> text:
    """Instantiate a template with concrete types, producing machine code.

    This is the core JIT compilation step. Takes a serialized template
    and concrete type arguments, runs monomorphization and code generation,
    and returns the compiled machine code bytes.

    Returns SDN with:
        status: "success" or "error"
        bytecode: base64-encoded machine code (on success)
        size: code size in bytes (on success)
        message: error description (on error)
    """
    if handle == 0:
        return "status: error\nmessage: invalid context handle"
    # When FFI is available: extern fn rt_compiler_instantiate_template(...)
    "status: success\nbytecode: \nsize: 0"

fn compiler_get_stats(handle: i64) -> text:
    """Get compiler statistics for diagnostics.

    Returns SDN-encoded stats including type inference count,
    template instantiation count, cache hit rate, and memory usage.
    """
    if handle == 0:
        return "type_inferences: 0\ntemplate_instantiations: 0"
    # When FFI is available: extern fn rt_compiler_get_stats(...)
    "type_inferences: 0\ntemplate_instantiations: 0"

# ============================================================================
# Result Types
# ============================================================================

enum JitInstantiationResult:
    """Result of JIT instantiation attempt."""
    Success(code: [u8], symbol: text, address: i64?)
    NotFound(symbol: text)
    CircularDependency(cycle: [text])
    CompilationError(message: text)
    UpdateFailed(symbol: text, error: text)

impl JitInstantiationResult:
    fn is_success() -> bool:
        match self:
            case Success(_, _, _): true
            case _: false

    fn is_error() -> bool:
        match self:
            case CompilationError(_): true
            case CircularDependency(_): true
            case UpdateFailed(_, _): true
            case _: false

# ============================================================================
# Configuration
# ============================================================================

struct JitInstantiatorConfig:
    """Configuration for JIT instantiation."""
    update_smf: bool
    max_depth: i32
    enabled: bool
    verbose: bool

impl JitInstantiatorConfig:
    static fn default() -> JitInstantiatorConfig:
        JitInstantiatorConfig(
            update_smf: true,
            max_depth: 50,
            enabled: true,
            verbose: false
        )

# ============================================================================
# Simplified Metadata Types (FFI-friendly)
# ============================================================================

struct LoadedMetadata:
    """Simplified metadata for FFI (no complex compiler types)."""
    possible: [PossibleInstantiation]
    instantiations: [InstantiationRecord]

struct PossibleInstantiation:
    """A possible generic instantiation."""
    template_name: text
    type_args: text
    mangled_name: text

struct InstantiationRecord:
    """A recorded instantiation."""
    id: i32
    template_name: text
    type_args: text
    mangled_name: text
    from_file: text
    from_loc: text
    to_obj: text
    status: text

# ============================================================================
# Template and Type Helpers
# ============================================================================

struct TemplateBytes:
    """Raw template bytecode loaded from an SMF TemplateCode section."""
    bytes: [u8]
    name: text
    param_count: i32

fn type_from_string(type_str: text) -> text:
    """Convert a type string from note.sdn format to a normalized type name.

    Handles common type aliases:
        "i64", "Int", "int" -> "Int"
        "f64", "Float", "float" -> "Float"
        "text", "String", "str" -> "String"
        "bool", "Bool" -> "Bool"
    Other types are returned as-is.
    """
    match type_str:
        "i64" | "i32" | "i16" | "i8" | "Int" | "int": "Int"
        "f64" | "f32" | "Float" | "float": "Float"
        "text" | "String" | "str": "String"
        "bool" | "Bool": "Bool"
        "nil" | "Nil" | "()": "Nil"
        _: type_str

# Executable memory stubs (requires platform mmap/VirtualAlloc FFI)

fn alloc_exec_memory(size: i64) -> i64:
    """Allocate executable memory region. Returns base address or 0 on failure."""
    # When mmap FFI is available:
    # mmap(nil, size, PROT_READ | PROT_WRITE | PROT_EXEC, MAP_PRIVATE | MAP_ANONYMOUS, -1, 0)
    eprint("Warning: alloc_exec_memory stub called; executable memory allocation not yet available")
    0

fn write_exec_memory(address: i64, data: [u8], offset: i64) -> i64:
    """Write bytes to executable memory. Returns bytes written."""
    # When available: memcpy(address + offset, data.ptr(), data.len())
    eprint("Warning: write_exec_memory stub called")
    0

fn flush_icache(address: i64, size: i64):
    """Flush instruction cache after writing code. Required on ARM/RISC-V."""
    # When available: __builtin___clear_cache(address, address + size)
    pass

fn get_function_pointer(address: i64) -> i64:
    """Get a callable function pointer from an executable memory address."""
    # The address itself is the function pointer on most architectures
    address

# ============================================================================
# Note.sdn Metadata Structures (local stubs for JIT context)
# ============================================================================

# Note.sdn metadata structures (stub versions)
struct NoteSdnPossible:
    template: text
    type_args: text
    mangled_name: text

struct NoteSdnInstantiation:
    template: text
    type_args: text
    mangled_name: text
    from_file: text
    from_loc: text
    output_file: text
    status: InstantiationStatus

enum InstantiationStatus:
    Pending
    Success
    Failed

impl InstantiationStatus:
    fn as_str() -> text:
        match self:
            case Pending: "pending"
            case Success: "success"
            case Failed: "failed"

struct NoteSdnMetadata:
    possible: [NoteSdnPossible]
    instantiations: [NoteSdnInstantiation]

struct SmfCache:
    """Stub for SMF cache (requires mmap infrastructure)."""
    cached_files: Dict<text, i32>
    enabled: bool
    stats: CacheStats

impl SmfCache:
    me get(path: text) -> Result<MappedSmf, text>:
        """Stub: Returns empty MappedSmf for testing."""
        # Track that we accessed this file
        if not self.cached_files.contains_key(path):
            self.cached_files[path] = 1
        Ok(MappedSmf(path: path))

    fn get_stats() -> CacheStats:
        CacheStats(
            total_files: self.cached_files.len(),
            total_memory: 0,
            cache_hits: 0,
            cache_misses: 0
        )

struct MappedSmf:
    """Stub for mapped SMF file."""
    path: text

impl MappedSmf:
    fn read_note_sdn() -> Result<NoteSdnMetadata, text>:
        """Stub: Returns empty metadata for testing."""
        Ok(NoteSdnMetadata(
            possible: [],
            instantiations: []
        ))

struct CacheStats:
    """Cache statistics."""
    total_files: i32
    total_memory: i64
    cache_hits: i32
    cache_misses: i32

# ============================================================================
# JIT Instantiator
# ============================================================================

struct JitInstantiator:
    """JIT instantiator for load-time template instantiation."""
    config: JitInstantiatorConfig
    compiler_ctx_handle: i64  # Compiler context handle (i64, not CompilerContext to avoid constructor issues)
    loaded_metadata: Dict<text, LoadedMetadata>  # Simplified metadata
    in_progress: Set<text>
    depth: i32
    jit_cache: Dict<text, ([u8], i64)>
    symbol_table: Dict<text, i64>
    smf_cache: SmfCache  # Memory-mapped SMF file cache

impl JitInstantiator:
    static fn new(config: JitInstantiatorConfig) -> JitInstantiator:
        """Create a new JIT instantiator."""
        JitInstantiator(
            config: config,
            compiler_ctx_handle: compiler_create_context(),  # Direct i64 handle
            loaded_metadata: {},
            in_progress: {},
            depth: 0,
            jit_cache: {},
            symbol_table: {},
            smf_cache: SmfCache(
                cached_files: {},
                enabled: true,
                stats: CacheStats(
                    total_files: 0,
                    total_memory: 0,
                    cache_hits: 0,
                    cache_misses: 0
                )
            )
        )

    me load_smf_metadata(smf_path: text) -> Result<(), text>:
        """Load note.sdn metadata from an SMF file."""
        val metadata = self.read_note_sdn_from_file(smf_path)?
        self.loaded_metadata[smf_path] = metadata
        Ok(())

    me set_metadata_for_test(smf_path: text, metadata: LoadedMetadata):
        """Set metadata directly (for testing only)."""
        self.loaded_metadata[smf_path] = metadata

    me set_cache_for_test(symbol: text, code: [u8], address: i64):
        """Set cache entry directly (for testing only)."""
        self.jit_cache[symbol] = (code, address)
        self.symbol_table[symbol] = address

    me read_note_sdn_from_file(smf_path: text) -> Result<LoadedMetadata, text>:
        """Read note.sdn section from SMF file using mmap cache."""
        # Get mapped SMF file from cache (auto-loads if not cached)
        var mapped_smf = self.smf_cache.get(smf_path)?

        # Read note.sdn metadata
        val metadata = mapped_smf.read_note_sdn()?

        # Convert NoteSdnMetadata to LoadedMetadata
        var possible: [PossibleInstantiation] = []
        for entry in metadata.possible:
            possible = possible.push(PossibleInstantiation(
                template_name: entry.template,
                type_args: entry.type_args,
                mangled_name: entry.mangled_name
            ))

        var instantiations: [InstantiationRecord] = []
        var id = 0
        for entry in metadata.instantiations:
            instantiations = instantiations.push(InstantiationRecord(
                id: id,
                template_name: entry.template,
                type_args: entry.type_args,
                mangled_name: entry.mangled_name,
                from_file: entry.from_file,
                from_loc: entry.from_loc,
                to_obj: entry.output_file,
                status: entry.status.as_str()
            ))
            id = id + 1

        Ok(LoadedMetadata(possible: possible, instantiations: instantiations))

    fn can_jit_instantiate(symbol: text) -> bool:
        """Check if a symbol can be JIT-instantiated."""
        if not self.config.enabled:
            return false

        for (_, metadata) in self.loaded_metadata:
            for poss in metadata.possible:
                if poss.mangled_name == symbol:
                    return true
        false

    fn find_possible(symbol: text) -> (text, PossibleInstantiation)?:
        """Find possible instantiation for a symbol."""
        for (path, metadata) in self.loaded_metadata:
            for entry in metadata.possible:
                if entry.mangled_name == symbol:
                    return Some((path, entry))
        nil

    me try_jit_instantiate(symbol: text) -> JitInstantiationResult:
        """Try to JIT-instantiate a missing symbol."""
        if not self.config.enabled:
            return JitInstantiationResult.NotFound(symbol)

        # Check depth limit
        if self.depth >= self.config.max_depth:
            return JitInstantiationResult.CompilationError(
                "Maximum JIT depth ({self.config.max_depth}) exceeded"
            )

        # Check cache
        if self.jit_cache.contains_key(symbol):
            val (code, address) = self.jit_cache[symbol]
            return JitInstantiationResult.Success(
                code: code,
                symbol: symbol,
                address: Some(address)
            )

        # Check for cycle
        if self.in_progress.contains(symbol):
            # Convert set to list by iterating
            var cycle: [text] = []
            for sym in self.in_progress:
                cycle = cycle.push(sym)
            cycle = cycle.push(symbol)  # Add current symbol to show cycle
            return JitInstantiationResult.CircularDependency(cycle)

        # Find possible entry
        val found = self.find_possible(symbol)
        if not found.?:
            return JitInstantiationResult.NotFound(symbol)

        val (smf_path, entry) = found.unwrap()

        # Start JIT compilation
        self.in_progress = self.in_progress.insert(symbol)
        self.depth = self.depth + 1

        if self.config.verbose:
            print "[jit] JIT-compiling {symbol} from {smf_path}"

        val result = self.do_jit_compile(entry, smf_path)

        # Cleanup
        self.in_progress = self.in_progress.remove(symbol)
        self.depth = self.depth - 1

        result

    me do_jit_compile(entry: PossibleInstantiation, smf_path: text) -> JitInstantiationResult:
        """Perform JIT compilation via FFI."""
        # Loading actual template bytes from SMF TemplateCode section not yet implemented
        eprint("Warning: loading template bytes from SMF not yet implemented; using empty bytes for {entry.template_name}")
        val tmpl_bytes = TemplateBytes(
            bytes: [],
            name: entry.template_name,
            param_count: entry.type_args.split(",").len() as i32
        )

        # Parse type args from string to TypeInfo
        val type_args = entry.type_args.split(",")
            .map(\s: type_from_string(s.trim()))

        # Compile via FFI not yet implemented (needs JSON serialization infrastructure)
        eprint("Warning: JIT compilation via FFI not yet implemented for {entry.mangled_name}")
        val code_result: Result<[u8], text> = Err("JIT compilation not yet implemented")

        match code_result:
            case Ok(compiled_code):
                # Allocate executable memory
                val code_size = compiled_code.len() as i64
                val exec_address = alloc_exec_memory(code_size)

                if exec_address == 0:
                    return JitInstantiationResult.CompilationError(
                        "Failed to allocate executable memory"
                    )

                # Write code to executable memory
                val bytes_written = write_exec_memory(exec_address, compiled_code, 0)
                if bytes_written != code_size:
                    return JitInstantiationResult.CompilationError(
                        "Failed to write code to executable memory"
                    )

                # Flush instruction cache (required on ARM/RISC-V)
                flush_icache(exec_address, code_size)

                # Get function pointer
                val fn_pointer = get_function_pointer(exec_address)

                # Cache the result
                self.jit_cache[entry.mangled_name] = (compiled_code, fn_pointer)

                # Register in symbol table
                self.symbol_table[entry.mangled_name] = fn_pointer

                # Update SMF file if configured
                if self.config.update_smf:
                    val update_result = self.update_smf_note_sdn(smf_path, entry)
                    if update_result.is_err():
                        return JitInstantiationResult.UpdateFailed(
                            symbol: entry.mangled_name,
                            error: update_result.unwrap_err()
                        )

                JitInstantiationResult.Success(
                    code: compiled_code,
                    symbol: entry.mangled_name,
                    address: Some(fn_pointer)
                )

            case Err(msg):
                JitInstantiationResult.CompilationError(msg)

    me update_smf_note_sdn(smf_path: text, entry: PossibleInstantiation) -> Result<(), text>:
        """Update note.sdn in SMF file after JIT compilation."""
        # Proper SMF file update not yet implemented; updating local metadata only
        eprint("Warning: proper SMF file update not yet implemented; only updating in-memory metadata for {entry.mangled_name}")
        if self.config.verbose:
            print "[jit] Would update {smf_path}: {entry.mangled_name} moved to instantiations"

        # Update local metadata
        if self.loaded_metadata.contains_key(smf_path):
            var metadata = self.loaded_metadata[smf_path]

            # Remove from possible
            metadata.possible = metadata.possible.filter(\p: p.mangled_name != entry.mangled_name)

            # Add to instantiations
            val new_inst = InstantiationRecord(
                id: metadata.instantiations.len() as i32,
                template_name: entry.template_name,
                type_args: entry.type_args,
                mangled_name: entry.mangled_name,
                from_file: smf_path,
                from_loc: "{smf_path}:0:0:jit",
                to_obj: "jit_memory",
                status: "jit_compiled"
            )
            metadata.instantiations = metadata.instantiations.push(new_inst)

            self.loaded_metadata[smf_path] = metadata

        Ok(())

    fn stats() -> JitStats:
        """Get JIT statistics."""
        val cache_stats = self.smf_cache.get_stats()
        JitStats(
            cached_count: self.jit_cache.len(),
            loaded_smf_count: self.loaded_metadata.len(),
            smf_cache_hits: cache_stats.cache_hits,
            smf_cache_misses: cache_stats.cache_misses,
            smf_files_mapped: cache_stats.total_files,
            smf_memory_mapped: cache_stats.total_memory
        )

# ============================================================================
# Statistics
# ============================================================================

struct JitStats:
    """JIT instantiation statistics."""
    cached_count: i32
    loaded_smf_count: i32
    smf_cache_hits: i32
    smf_cache_misses: i32
    smf_files_mapped: i32
    smf_memory_mapped: i64

# ============================================================================
# Symbol Resolver
# ============================================================================

struct JitSymbolResolver:
    """Symbol resolver that integrates JIT instantiation."""
    jit: JitInstantiator
    symbols: Dict<text, i64>

impl JitSymbolResolver:
    static fn new(config: JitInstantiatorConfig) -> JitSymbolResolver:
        """Create a new JIT symbol resolver."""
        JitSymbolResolver(
            jit: JitInstantiator.new(config),
            symbols: {}
        )

    me register(name: text, address: i64):
        """Register a symbol."""
        self.symbols[name] = address

    me resolve(name: text) -> i64?:
        """Resolve a symbol, JIT-compiling if necessary."""
        # Check primary table first
        if self.symbols.contains_key(name):
            return Some(self.symbols[name])

        # Try JIT instantiation
        val result = self.jit.try_jit_instantiate(name)
        match result:
            case Success(_, symbol, address):
                if address.?:
                    self.symbols[symbol] = address.unwrap()
                    return address
                nil
            case _:
                nil

    me load_smf(path: text) -> Result<(), text>:
        """Load metadata from SMF file."""
        self.jit.load_smf_metadata(path)

    me set_jit_cache_for_test(symbol: text, code: [u8], address: i64):
        """Set JIT cache entry directly (for testing only)."""
        self.jit.set_cache_for_test(symbol, code, address)

# ============================================================================
# Exports
# ============================================================================

export JitInstantiationResult
export JitInstantiatorConfig
export JitInstantiator
export JitStats
export JitSymbolResolver
export LoadedMetadata
export PossibleInstantiation
export InstantiationRecord
