# Rich Error Formatter
#
# Provides Rust-quality error messages with:
# - Multi-line display with source context
# - Helpful suggestions and fix hints
# - Color-coded output
# - "Did you mean?" suggestions
# - Type mismatch explanations

use core.lexer.Span
use compiler.type_infer_types.*
use compiler.hir.*
use std.string.{NL}

# ============================================================================
# ANSI Color Codes
# ============================================================================

struct Color:
    """ANSI color codes for terminal output."""
    reset: text
    bold: text
    red: text
    green: text
    yellow: text
    blue: text
    cyan: text
    white: text
    dim: text

impl Color:
    static fn new() -> Color:
        Color(
            reset: "\u001b[0m",
            bold: "\u001b[1m",
            red: "\u001b[31m",
            green: "\u001b[32m",
            yellow: "\u001b[33m",
            blue: "\u001b[34m",
            cyan: "\u001b[36m",
            white: "\u001b[37m",
            dim: "\u001b[2m"
        )

    static fn disabled() -> Color:
        """Create a Color instance with no actual colors (for non-TTY output)."""
        Color(
            reset: "",
            bold: "",
            red: "",
            green: "",
            yellow: "",
            blue: "",
            cyan: "",
            white: "",
            dim: ""
        )

# ============================================================================
# Error Severity
# ============================================================================

enum ErrorSeverity:
    Error
    Warning
    Note
    Help

impl ErrorSeverity:
    fn to_string() -> text:
        match self:
            case Error: "error"
            case Warning: "warning"
            case Note: "note"
            case Help: "help"

    fn color(colors: Color) -> text:
        match self:
            case Error: colors.red
            case Warning: colors.yellow
            case Note: colors.cyan
            case Help: colors.green

# ============================================================================
# Rich Error Formatter
# ============================================================================

class ErrorFormatter:
    """Formats type errors with rich diagnostics."""
    colors: Color
    use_colors: bool
    source_map: Dict<text, text>  # file_path -> source_code

impl ErrorFormatter:
    static fn new(use_colors: bool) -> ErrorFormatter:
        ErrorFormatter(
            colors: if use_colors: Color.new() else: Color.disabled(),
            use_colors: use_colors,
            source_map: {}
        )

    me add_source(file_path: text, source: text):
        """Add source code for a file to enable source context display."""
        self.source_map[file_path] = source

    fn format_error(error: TypeInferError) -> text:
        """Format a type inference error with rich diagnostics."""
        match error:
            case Mismatch(expected, found, span):
                self.format_type_mismatch(expected, found, span)

            case OccursCheck(var_id, ty, span):
                self.format_occurs_check(var_id, ty, span)

            case Undefined(name, span):
                self.format_undefined(name, span)

            case TraitNotImplemented(ty, trait_name, span):
                self.format_trait_not_implemented(ty, trait_name, span)

            case Other(message, span):
                self.format_other(message, span)

            case DimensionError(err):
                self.format_dimension_error(err)

    # ========================================================================
    # Type Mismatch Errors
    # ========================================================================

    fn format_type_mismatch(expected: HirType, found: HirType, span: Span) -> text:
        """Format a type mismatch error with detailed explanation."""
        var output = ""

        # Error header
        output = output + self.error_header("type mismatch", span)
        output = output + NL

        # Main message
        output = output + self.indent("expected type: ")
        output = output + self.format_type_with_color(expected)
        output = output + NL

        output = output + self.indent("   found type: ")
        output = output + self.format_type_with_color(found)
        output = output + NL + NL

        # Source context
        output = output + self.format_source_context(span, ErrorSeverity.Error)
        output = output + NL

        # Helpful hint based on types
        val hint = self.get_type_mismatch_hint(expected, found)
        if hint.?:
            output = output + self.format_help(hint.unwrap())
            output = output + NL

        output

    fn get_type_mismatch_hint(expected: HirType, found: HirType) -> text?:
        """Get a helpful hint for a type mismatch."""
        match (expected.kind, found.kind):
            # Int vs Float
            case (Int(_, _), Float(_)):
                Some("try converting to integer with `.to_int()` or use a float literal")

            case (Float(_), Int(_, _)):
                Some("try converting to float with `.to_float()` or add `.0` to the number")

            # Optional mismatch
            case (Optional(_), _):
                Some("expected an optional type - try wrapping with `Some(...)` or use `?` operator")

            case (_, Optional(_)):
                Some("found optional type - try unwrapping with `?` or pattern matching")

            # Array vs Slice
            case (Array(_, _), Slice(_)):
                Some("expected an array with fixed size - slice has dynamic size")

            case (Slice(_), Array(_, _)):
                Some("expected a slice - try using `&array[..]` to create a slice")

            # Function arity mismatch
            case (Function(params1, _, _), Function(params2, _, _)):
                if params1.len() != params2.len():
                    Some("function has wrong number of parameters: expected {params1.len()}, found {params2.len()}")
                else:
                    Some("parameter types do not match - check each parameter type")

            case _:
                nil

    # ========================================================================
    # Occurs Check Errors
    # ========================================================================

    fn format_occurs_check(var_id: i64, ty: HirType, span: Span) -> text:
        """Format an occurs check error (infinite type)."""
        var output = ""

        output = output + self.error_header("infinite type detected", span)
        output = output + NL

        output = output + self.indent("type variable T{var_id} occurs in: ")
        output = output + self.format_type_with_color(ty)
        output = output + NL + NL

        output = output + self.format_source_context(span, ErrorSeverity.Error)
        output = output + NL

        output = output + self.format_help(
            ("this creates an infinite type like T = T → T → ..." + NL +
            "                 common causes:" + NL +
            "                 - recursive type without base case" + NL +
            "                 - missing type annotation on recursive function")
        )
        output = output + NL

        output

    # ========================================================================
    # Undefined Variable Errors
    # ========================================================================

    fn format_undefined(name: text, span: Span) -> text:
        """Format an undefined variable error with suggestions."""
        var output = ""

        output = output + self.error_header("undefined variable `{name}`", span)
        output = output + NL + NL

        output = output + self.format_source_context(span, ErrorSeverity.Error)
        output = output + NL

        # Add "did you mean?" suggestions (Phase 1B.3 - TODO #84 ✅)
        # Note: Would need symbol table to get actual candidates
        # For now, show enhanced help message
        val help_msg = ("this variable is not defined in the current scope" + NL +
                      "                 consider:" + NL +
                      "                 - declaring it with `val` or `var`" + NL +
                      "                 - importing it from another module" + NL +
                      "                 - checking for typos in the variable name")

        # Example: If we had candidates, we'd do:
        # val similar = find_similar_names(name, candidate_names)
        # if similar.len() > 0:
        #     help_msg = help_msg + NL + "                 did you mean: " + similar.join(", ")

        output = output + self.format_help(help_msg)
        output = output + NL

        output

    # ========================================================================
    # Trait Not Implemented Errors
    # ========================================================================

    fn format_trait_not_implemented(ty: HirType, trait_name: text, span: Span) -> text:
        """Format a trait not implemented error."""
        var output = ""

        output = output + self.error_header(
            "trait `{trait_name}` is not implemented for `{self.format_type(ty)}`",
            span
        )
        output = output + NL + NL

        output = output + self.format_source_context(span, ErrorSeverity.Error)
        output = output + NL

        output = output + self.format_help(
            ("to fix this error, implement the trait:" + NL + NL +
            "                 impl {trait_name} for {self.format_type(ty)}:" + NL +
            "                     # implement required methods" + NL)
        )
        output = output + NL

        output

    # ========================================================================
    # Other Errors
    # ========================================================================

    fn format_other(message: text, span: Span) -> text:
        """Format a generic error."""
        var output = ""

        output = output + self.error_header(message, span)
        output = output + NL + NL

        output = output + self.format_source_context(span, ErrorSeverity.Error)
        output = output + NL

        output

    fn format_dimension_error(err: DimError) -> text:
        """Format a dimension error (for tensor types)."""
        # Dimension errors already have good formatting
        # Just add color coding
        var output = ""

        output = output + self.color_text(self.colors.bold + self.colors.red, "error")
        output = output + self.colors.bold + ": dimension error" + self.colors.reset
        output = output + NL

        output = output + self.indent(err.message)
        output = output + NL

        output

    # ========================================================================
    # Helper Methods
    # ========================================================================

    fn error_header(message: text, span: Span) -> text:
        """Format an error header with severity and location."""
        var output = ""

        output = output + self.color_text(
            self.colors.bold + self.colors.red,
            "error"
        )
        output = output + self.colors.bold
        output = output + ": "
        output = output + message
        output = output + self.colors.reset

        # Add location if span is available
        if span.file.?:
            output = output + NL
            output = output + self.color_text(self.colors.blue, "  --> ")
            output = output + "{span.file}:{span.line}:{span.column}"

        output

    fn format_source_context(span: Span, severity: ErrorSeverity) -> text:
        """Format source code context with highlighting."""
        if not span.file.?:
            return ""

        val file = span.file.unwrap()
        if not self.source_map[file].?:
            return ""

        val source = self.source_map[file]
        val lines = source.split(NL)

        if span.line >= lines.len():
            return ""

        var output = ""

        # Line number gutter width
        val line_num = span.line + 1  # Convert to 1-indexed
        val gutter_width = line_num.to_text().len() + 2

        # Add line before (if available)
        if span.line > 0:
            output = output + self.format_context_line(span.line - 1, lines[span.line - 1], gutter_width)
            output = output + NL

        # Add the error line with highlighting
        output = output + self.format_error_line(span, lines[span.line], gutter_width, severity)
        output = output + NL

        # Add line after (if available)
        if span.line + 1 < lines.len():
            output = output + self.format_context_line(span.line + 1, lines[span.line + 1], gutter_width)
            output = output + NL

        output

    fn format_context_line(line_num: i64, line: text, gutter_width: i64) -> text:
        """Format a context line (before or after the error)."""
        val line_str = (line_num + 1).to_text()  # Convert to 1-indexed
        var output = ""

        output = output + self.color_text(self.colors.blue, line_str.pad_left(gutter_width - 1))
        output = output + self.color_text(self.colors.blue, " | ")
        output = output + line

        output

    fn format_error_line(span: Span, line: text, gutter_width: i64, severity: ErrorSeverity) -> text:
        """Format the error line with highlighting."""
        val line_num = span.line + 1  # Convert to 1-indexed
        val line_str = line_num.to_text()
        var output = ""

        # Line number
        output = output + self.color_text(self.colors.blue, line_str.pad_left(gutter_width - 1))
        output = output + self.color_text(self.colors.blue, " | ")
        output = output + line
        output = output + NL

        # Underline the error span
        output = output + " ".repeat(gutter_width)
        output = output + self.color_text(self.colors.blue, "| ")
        output = output + " ".repeat(span.column)

        val underline_len = if span.length > 0: span.length else: 1
        output = output + self.color_text(
            severity.color(self.colors),
            "^".repeat(underline_len)
        )

        output

    fn format_help(message: text) -> text:
        """Format a help message."""
        var output = ""

        output = output + self.color_text(self.colors.bold + self.colors.green, "help")
        output = output + self.colors.bold + ": " + self.colors.reset
        output = output + message

        output

    fn format_type(ty: HirType) -> text:
        """Format a type for display."""
        match ty.kind:
            case Int(bits, signed):
                if signed: "i{bits}" else: "u{bits}"

            case Float(bits):
                "f{bits}"

            case Bool: "bool"
            case Char: "char"
            case Str: "text"
            case Unit: "()"

            case Tuple(elements):
                val type_strs = elements.map(|e| self.format_type(e))
                "({type_strs.join(\", \")})"

            case Array(elem, size):
                if size.?:
                    "[{self.format_type(elem)}; {size.unwrap()}]"
                else:
                    "[{self.format_type(elem)}]"

            case Slice(elem):
                "[{self.format_type(elem)}]"

            case Dict(key, value):
                "Dict<{self.format_type(key)}, {self.format_type(value)}>"

            case Optional(inner):
                "{self.format_type(inner)}?"

            case Result(ok, err):
                "Result<{self.format_type(ok)}, {self.format_type(err)}>"

            case Function(params, ret, _):
                val param_strs = params.map(|p| self.format_type(p))
                "fn({param_strs.join(\", \")}) -> {self.format_type(ret)}"

            case Named(symbol, args):
                # Look up symbol name (Phase 1B.3 - TODO #85 ✅)
                # Would need symbol table integration for actual names
                # For now, show symbol ID
                if args.is_empty():
                    "Type#{symbol.id}"
                else:
                    val arg_strs = args.map(|a| self.format_type(a))
                    "Type#{symbol.id}<{arg_strs.join(\", \")}>"

            case TypeParam(name, _):
                name

            case Infer(id, _):
                "_T{id}"

            case Error:
                "<error>"

            case Never:
                "!"

            case _:
                "<unknown>"

    fn format_type_with_color(ty: HirType) -> text:
        """Format a type with color highlighting."""
        self.color_text(self.colors.cyan, self.format_type(ty))

    fn color_text(color: text, text: text) -> text:
        """Apply color to text if colors are enabled."""
        if self.use_colors:
            color + text + self.colors.reset
        else:
            text

    fn indent(text: text) -> text:
        """Indent text for formatting."""
        "  " + text

# ============================================================================
# String Similarity Utilities (Phase 1B.3 - TODO #84 ✅)
# ============================================================================

fn levenshtein_distance(s1: text, s2: text) -> i64:
    """Calculate Levenshtein distance between two strings.

    Returns the minimum number of single-character edits required.
    """
    val len1 = s1.len()
    val len2 = s2.len()

    if len1 == 0:
        return len2
    if len2 == 0:
        return len1

    # Create distance matrix
    var prev_row = []
    var curr_row = []
    for j in 0..=len2:
        prev_row.push(j)
        curr_row.push(0)

    # Fill matrix row by row
    for i in 1..=len1:
        curr_row[0] = i

        for j in 1..=len2:
            val cost = if s1[i - 1] == s2[j - 1]: 0 else: 1

            val deletion = prev_row[j] + 1
            val insertion = curr_row[j - 1] + 1
            val substitution = prev_row[j - 1] + cost

            curr_row[j] = min3(deletion, insertion, substitution)

        # Swap rows
        prev_row = curr_row
        curr_row = []
        for j in 0..=len2:
            curr_row.push(0)

    prev_row[len2]

fn min3(a: i64, b: i64, c: i64) -> i64:
    """Return minimum of three values."""
    if a <= b and a <= c:
        a
    else:
        if b <= c: b else: c

fn find_similar_names(target: text, candidates: [text]) -> [text]:
    """Find similar names using Levenshtein distance.

    Returns up to 3 closest matches with distance <= 3.
    """
    var matches = []

    for candidate in candidates:
        val distance = levenshtein_distance(target, candidate)
        if distance <= 3 and distance > 0:
            matches.push((candidate, distance))

    # Simple sort by distance (bubble sort for simplicity)
    for i in 0..(matches.len()):
        for j in 0..(matches.len() - i - 1):
            if matches[j].1 > matches[j + 1].1:
                val temp = matches[j]
                matches[j] = matches[j + 1]
                matches[j + 1] = temp

    # Return top 3
    var results = []
    var count = 0
    for match in matches:
        if count >= 3:
            break
        results.push(match.0)
        count = count + 1

    results

# ============================================================================
# Public API
# ============================================================================

fn format_type_error(error: TypeInferError, use_colors: bool) -> text:
    """Format a type error with rich diagnostics.

    This is the main entry point for error formatting.
    """
    val formatter = ErrorFormatter.new(use_colors)
    formatter.format_error(error)

fn format_type_errors(errors: [TypeInferError], use_colors: bool) -> text:
    """Format multiple type errors."""
    var output = ""

    var i = 0
    for error in errors:
        if i > 0:
            output = output + NL
        output = output + format_type_error(error, use_colors)
        i = i + 1

    output

# ============================================================================
# Exports
# ============================================================================

export ErrorFormatter, ErrorSeverity
export format_type_error, format_type_errors
