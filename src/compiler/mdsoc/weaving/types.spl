# Weaving Types
#
# Type definitions for AOP (Aspect-Oriented Programming) weaving.
#
# Port of rust/compiler/src/weaving/types.rs (231 lines)

export AdviceForm, JoinPointKind, JoinPoint, JoinPointContext
export MatchedAdvice, WeavingConfig, WeavingRule, WeavingResult

use mir (BlockId)
use predicate (MatchContext)
use aop_config (AopConfig)
use compiler.hir.hir.{HirAopAdvice}
use weaving.diagnostics (WeavingDiagnostic, DiagnosticLevel)

# ============================================================================
# Advice Form
# ============================================================================

enum AdviceForm:
    """Advice form determines when and how advice is executed."""
    Before          # Execute before the join point
    AfterSuccess    # Execute after successful completion
    AfterError      # Execute after error
    Around          # Wrap the join point (can control execution via proceed)


# ============================================================================
# AdviceForm Methods (was: impl AdviceForm:)
# ============================================================================

# ============================================================================
# Join Point Types
# ============================================================================

enum JoinPointKind:
    """Join point types in the program."""
    Execution(function_name: text, signature: text)  # Function execution
    Decision(location: text)                          # Decision point (if/match)
    Condition(location: text)                         # Condition evaluation
    Error(location: text, error_type: text)          # Error handling point

struct JoinPoint:
    """A detected join point in the MIR."""
    kind: JoinPointKind
    block_id: BlockId
    instruction_index: usize
    context: JoinPointContext

struct JoinPointContext:
    """Context information for join point matching."""
    function_name: text
    module_path: text
    signature: text
    attributes: [text]
    effects: [text]


# ============================================================================
# JoinPointContext Methods (was: impl JoinPointContext:)
# ============================================================================

# ============================================================================
# Matched Advice
# ============================================================================

struct MatchedAdvice:
    """Matched advice for a join point."""
    advice_function: text
    form: AdviceForm
    priority: i64
    specificity: i32

# ============================================================================
# Weaving Configuration
# ============================================================================

struct WeavingRule:
    """A single weaving rule (predicate + advice)."""
    predicate_text: text
    advice_function: text
    form: AdviceForm
    priority: i64

struct WeavingConfig:
    """Weaving configuration loaded from TOML."""
    enabled: bool
    before_advices: [WeavingRule]
    after_success_advices: [WeavingRule]
    after_error_advices: [WeavingRule]
    around_advices: [WeavingRule]


# ============================================================================
# WeavingConfig Methods (was: impl WeavingConfig:)
# ============================================================================

fn weavingconfig_disabled() -> WeavingConfig:
        """Create an empty configuration (weaving disabled)."""
        WeavingConfig(
            enabled: false,
            before_advices: [],
            after_success_advices: [],
            after_error_advices: [],
            around_advices: []
        )


fn weavingconfig_from_aop_config(aop_config: AopConfig) -> WeavingConfig:
        """Load from AOP configuration.

        For now, treat runtime around as compile-time around.
        In the future, we'll have separate compile-time config.
        """
        val around_advices = aop_config.around.map(\rule:
            WeavingRule(
                predicate_text: rule.raw_predicate_clone(raw_predicate),
                advice_function: rule.advice_clone(advice),
                form: AdviceForm.Around,
                priority: rule.priority
            )
        )

        WeavingConfig(
            enabled: aop_config.runtime_enabled,
            before_advices: [],
            after_success_advices: [],
            after_error_advices: [],
            around_advices: around_advices
        )


fn weavingconfig_from_hir_advices(advices: [HirAopAdvice]) -> WeavingConfig:
        """Load from HIR AOP advices (parsed from Simple source code)."""
        var before_advices: [WeavingRule] = []
        var after_success_advices: [WeavingRule] = []
        var after_error_advices: [WeavingRule] = []
        var around_advices: [WeavingRule] = []

        for advice in advices:
            val form = adviceform_from_str(advice.form) ?? AdviceForm.Before
            val rule = WeavingRule(
                predicate_text: advice.predicate_text,
                advice_function: advice.advice_function,
                form: form,
                priority: advice.priority
            )

            match form:
                case Before: before_advices = before_advices.push(rule)
                case AfterSuccess: after_success_advices = after_success_advices.push(rule)
                case AfterError: after_error_advices = after_error_advices.push(rule)
                case Around: around_advices = around_advices.push(rule)

        WeavingConfig(
            enabled: not advices.is_empty(),
            before_advices: before_advices,
            after_success_advices: after_success_advices,
            after_error_advices: after_error_advices,
            around_advices: around_advices
        )


# ============================================================================
# Weaving Result
# ============================================================================

struct WeavingResult:
    """Result of weaving a function."""
    join_points_woven: usize        # Number of join points that had advice woven
    advices_inserted: usize         # Total number of advice calls inserted
    advice_calls: [(JoinPointKind, text)]  # List of (join point, advice) pairs for debugging
    diagnostics: [WeavingDiagnostic]       # Diagnostic messages generated during weaving


# ============================================================================
# WeavingResult Methods (was: impl WeavingResult:)
# ============================================================================

fn weavingresult_new() -> WeavingResult:
        """Create empty weaving result."""
        WeavingResult(
            join_points_woven: 0,
            advices_inserted: 0,
            advice_calls: [],
            diagnostics: []
        )

