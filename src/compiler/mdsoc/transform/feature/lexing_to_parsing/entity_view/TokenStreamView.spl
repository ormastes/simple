# TokenStreamView - bridges LexerOutputPort to ParserInputPort
# Minimal mismatch (Phase 3f - LOW priority)
# Wraps the token stream from lexer output for parser consumption.

struct TokenStreamView:
    """Adapts lexer token arrays for parser input."""
    token_tags: [i64]
    token_texts: [text]
    token_lines: [i64]
    token_cols: [i64]
    token_count: i64
    source_text: text  # Original source (parser may need it for error messages)

    fn is_empty() -> bool:
        self.token_count == 0

    fn get_token_text(idx: i64) -> text:
        var result = ""
        if idx < 0:
            result = ""
        else:
            if idx >= self.token_count:
                result = ""
            else:
                result = self.token_texts[idx]
        result

    static fn from_lexer_output(output_token_tags: [i64], output_token_texts: [text], output_token_lines: [i64], output_token_cols: [i64], output_token_count: i64, src: text) -> TokenStreamView:
        TokenStreamView(
            token_tags: output_token_tags,
            token_texts: output_token_texts,
            token_lines: output_token_lines,
            token_cols: output_token_cols,
            token_count: output_token_count,
            source_text: src
        )


# Desugared static methods for bootstrap interpreter compatibility

fn None__from_lexer_output(output_token_tags: [i64], output_token_texts: [text], output_token_lines: [i64], output_token_cols: [i64], output_token_count: i64, src: text) -> TokenStreamView:
    TokenStreamView(
        token_tags: output_token_tags,
        token_texts: output_token_texts,
        token_lines: output_token_lines,
        token_cols: output_token_cols,
        token_count: output_token_count,
        source_text: src
    )


export TokenStreamView
