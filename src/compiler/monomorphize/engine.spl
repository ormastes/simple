# Monomorphization Engine
#
# Creates specialized versions of generic functions, structs, and classes
# by substituting concrete type arguments. Iteratively processes pending
# specializations until all are resolved.
#
# Port of rust/compiler/src/monomorphize/engine.rs (300+ lines)

export ConcreteType, SpecializationKey, MonomorphizationTable, Monomorphizer

# ============================================================================
# Concrete Types
# ============================================================================

enum ConcreteType:
    Int
    Float
    Bool
    String
    Nil
    Named(text)
    Array(ConcreteType)
    Tuple([ConcreteType])
    Dict(ConcreteType, ConcreteType)
    Function([ConcreteType], ConcreteType)
    Optional(ConcreteType)
    Specialized(text, [ConcreteType])

fn concrete_type_to_text(ty: ConcreteType) -> text:
    match ty:
        case Int: "Int"
        case Float: "Float"
        case Bool: "Bool"
        case String: "String"
        case Nil: "Nil"
        case Named(n): n
        case Array(elem): "Array_{concrete_type_to_text(elem)}"
        case Tuple(elems): "Tuple_{elems.map(\e: concrete_type_to_text(e)).join(\"_\")}"
        case Dict(k, v): "Dict_{concrete_type_to_text(k)}_{concrete_type_to_text(v)}"
        case Function(params, ret):
            "Fn_{params.map(\p: concrete_type_to_text(p)).join(\"_\")}_{concrete_type_to_text(ret)}"
        case Optional(inner): "Opt_{concrete_type_to_text(inner)}"
        case Specialized(name, args): "{name}_{args.map(\a: concrete_type_to_text(a)).join(\"_\")}"

# ============================================================================
# Specialization Key
# ============================================================================

struct SpecializationKey:
    name: text
    type_args: [ConcreteType]

impl SpecializationKey:
    fn mangled_name() -> text:
        if not self.type_args.?:
            self.name
        else:
            val args_str = self.type_args.map(\t: concrete_type_to_text(t)).join("_")
            "{self.name}${args_str}"

# ============================================================================
# Monomorphization Table
# ============================================================================

class MonomorphizationTable:
    """Tracks pending and completed specializations."""
    pending_functions: [(SpecializationKey, Any)]
    pending_structs: [(SpecializationKey, Any)]
    pending_classes: [(SpecializationKey, Any)]
    specialized_functions: {text: Any}
    specialized_structs: {text: Any}
    specialized_classes: {text: Any}
    processed: [text]

impl MonomorphizationTable:
    static fn create() -> MonomorphizationTable:
        MonomorphizationTable(
            pending_functions: [], pending_structs: [], pending_classes: [],
            specialized_functions: {}, specialized_structs: {}, specialized_classes: {},
            processed: [])

    fn has_pending() -> bool:
        self.pending_functions.? or self.pending_structs.? or self.pending_classes.?

    me request_function(name: text, type_args: [ConcreteType], func: Any) -> text:
        val key = SpecializationKey(name: name, type_args: type_args)
        val mangled = key.mangled_name()
        if not self.processed.contains(mangled):
            self.pending_functions = self.pending_functions.push((key, func))
        mangled

    me pop_pending_function() -> (SpecializationKey, Any)?:
        if self.pending_functions.?:
            val item = self.pending_functions[0]
            self.pending_functions = self.pending_functions[1:]
            Some(item)
        else:
            nil

    me mark_processed(key: SpecializationKey):
        val mangled = key.mangled_name()
        if not self.processed.contains(mangled):
            self.processed = self.processed.push(mangled)

    me add_specialized_function(key: SpecializationKey, func: Any):
        self.specialized_functions[key.mangled_name()] = func

    me add_specialized_struct(key: SpecializationKey, s: Any):
        self.specialized_structs[key.mangled_name()] = s

    me add_specialized_class(key: SpecializationKey, c: Any):
        self.specialized_classes[key.mangled_name()] = c

# ============================================================================
# Monomorphizer
# ============================================================================

class Monomorphizer:
    """Monomorphization engine that creates specialized versions of generics."""
    generic_functions: {text: Any}
    generic_structs: {text: Any}
    generic_classes: {text: Any}
    table: MonomorphizationTable

impl Monomorphizer:
    static fn create() -> Monomorphizer:
        Monomorphizer(generic_functions: {}, generic_structs: {},
                      generic_classes: {}, table: MonomorphizationTable.create())

    me register_generic_function(name: text, func: Any):
        self.generic_functions[name] = func

    me register_generic_struct(name: text, s: Any):
        self.generic_structs[name] = s

    me register_generic_class(name: text, c: Any):
        self.generic_classes[name] = c

    fn is_generic_function(name: text) -> bool:
        self.generic_functions.contains_key(name)

    fn is_generic_struct(name: text) -> bool:
        self.generic_structs.contains_key(name)

    fn is_generic_class(name: text) -> bool:
        self.generic_classes.contains_key(name)

    me specialize_function_call(name: text, type_args: [ConcreteType]) -> text?:
        if not self.generic_functions.contains_key(name):
            return nil
        val func = self.generic_functions[name]
        Some(self.table.request_function(name, type_args, func))

    me process_pending():
        """Iteratively process all pending specializations."""
        while self.table.has_pending():
            while true:
                val item = self.table.pop_pending_function()
                if not item.?:
                    break
                val (key, func) = item.unwrap()
                if self.table.processed.contains(key.mangled_name()):
                    continue
                # TODO: Actually specialize the function body
                self.table.mark_processed(key)
                self.table.add_specialized_function(key, func)
