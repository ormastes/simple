# Type Substitution
#
# Performs type parameter substitution during monomorphization.
# Takes a mapping from type parameter names to HirTypes and recursively
# rewrites types throughout the HIR tree.
#
# Example:
#   fn identity<T>(x: T) -> T
#   With substitution {T -> Int}
#   Becomes: fn identity$Int(x: Int) -> Int

export TypeSubstitution, substitute_type, substitute_expr, substitute_function

use hir_types.*
use hir_definitions.*
use monomorphize.engine.ConcreteType
use lexer.Span

# ============================================================================
# Type Substitution Map
# ============================================================================

class TypeSubstitution:
    """Maps type parameter names to concrete HirTypes."""
    mapping: Dict<text, HirType>

impl TypeSubstitution:
    static fn empty() -> TypeSubstitution:
        TypeSubstitution(mapping: {})

    static fn from_params(type_params: [HirTypeParam], type_args: [HirType]) -> TypeSubstitution:
        """Create substitution from type parameters and their concrete arguments."""
        var map: Dict<text, HirType> = {}
        var i = 0
        for param in type_params:
            if i < type_args.len():
                map[param.name] = type_args[i]
            i = i + 1
        TypeSubstitution(mapping: map)

    static fn from_concrete(type_params: [HirTypeParam], type_args: [ConcreteType]) -> TypeSubstitution:
        """Create substitution from type parameters and ConcreteType arguments."""
        var map: Dict<text, HirType> = {}
        var i = 0
        for param in type_params:
            if i < type_args.len():
                map[param.name] = concrete_to_hir_type(type_args[i], param.span)
            i = i + 1
        TypeSubstitution(mapping: map)

    me add(name: text, ty: HirType):
        """Add a type parameter mapping."""
        self.mapping[name] = ty

    fn get(name: text) -> HirType?:
        """Look up a type parameter."""
        if self.mapping.contains_key(name):
            Some(self.mapping[name])
        else:
            nil

    fn is_empty() -> bool:
        not self.mapping.?

# ============================================================================
# Convert ConcreteType to HirType
# ============================================================================

fn concrete_to_hir_type(ct: ConcreteType, span: Span) -> HirType:
    """Convert a ConcreteType to HirType."""
    val kind = match ct:
        case Int: HirTypeKind.Int(64, true)
        case Float: HirTypeKind.Float(64)
        case Bool: HirTypeKind.Bool
        case String: HirTypeKind.Str
        case Nil: HirTypeKind.Unit
        case Named(name):
            HirTypeKind.Named(SymbolId(id: -1), [])  # Placeholder symbol
        case Array(elem):
            HirTypeKind.Array(concrete_to_hir_type(elem, span), nil)
        case Tuple(elems):
            HirTypeKind.Tuple(elems.map(\e: concrete_to_hir_type(e, span)))
        case Dict(k, v):
            HirTypeKind.Dict(concrete_to_hir_type(k, span), concrete_to_hir_type(v, span))
        case Function(params, ret):
            val p_types = params.map(\p: concrete_to_hir_type(p, span))
            HirTypeKind.Function(p_types, concrete_to_hir_type(ret, span), [])
        case Optional(inner):
            HirTypeKind.Optional(concrete_to_hir_type(inner, span))
        case Specialized(name, args):
            val hir_args = args.map(\a: concrete_to_hir_type(a, span))
            HirTypeKind.Named(SymbolId(id: -1), hir_args)
    HirType(kind: kind, span: span)

# ============================================================================
# Type Substitution
# ============================================================================

fn substitute_type(ty: HirType, subst: TypeSubstitution) -> HirType:
    """Recursively substitute type parameters in a type."""
    val new_kind = match ty.kind:
        # Type parameter - look up in substitution
        case TypeParam(name, bounds):
            val replacement = subst.get(name)
            if replacement.?:
                return replacement.unwrap()
            else:
                ty.kind  # Keep as-is if not in substitution

        # Primitives - no change
        case Int(_, _): ty.kind
        case Float(_): ty.kind
        case Bool: ty.kind
        case Char: ty.kind
        case Str: ty.kind
        case Unit: ty.kind
        case Never: ty.kind
        case Error: ty.kind

        # Composite types - recurse into components
        case Tuple(elements):
            HirTypeKind.Tuple(elements.map(\e: substitute_type(e, subst)))

        case Array(element, size):
            HirTypeKind.Array(substitute_type(element, subst), size)

        case Slice(element):
            HirTypeKind.Slice(substitute_type(element, subst))

        case Dict(key, value):
            HirTypeKind.Dict(substitute_type(key, subst), substitute_type(value, subst))

        # Reference types
        case Ref(inner, mutable):
            HirTypeKind.Ref(substitute_type(inner, subst), mutable)

        case Ptr(inner, mutable):
            HirTypeKind.Ptr(substitute_type(inner, subst), mutable)

        case Optional(inner):
            HirTypeKind.Optional(substitute_type(inner, subst))

        case Result(ok, err):
            HirTypeKind.Result(substitute_type(ok, subst), substitute_type(err, subst))

        # Named types - substitute type arguments
        case Named(symbol, args):
            val new_args = args.map(\a: substitute_type(a, subst))
            HirTypeKind.Named(symbol, new_args)

        # Function types
        case Function(params, ret, effects):
            val new_params = params.map(\p: substitute_type(p, subst))
            val new_ret = substitute_type(ret, subst)
            HirTypeKind.Function(new_params, new_ret, effects)

        # Trait types
        case DynTrait(trait_):
            ty.kind  # Keep as-is

        # Inference variables (should be resolved before monomorphization)
        case Infer(_, _):
            ty.kind

        # Tensor types
        case Tensor(element, dims, device):
            HirTypeKind.Tensor(substitute_type(element, subst), dims, device)

        case Layer(input, output):
            ty.kind  # Dimensions don't change

    HirType(kind: new_kind, span: ty.span)

# ============================================================================
# Expression Substitution
# ============================================================================

fn substitute_expr(expr: HirExpr, subst: TypeSubstitution) -> HirExpr:
    """Recursively substitute type parameters in an expression."""
    # First substitute the expression's type annotation if present
    val new_type = if expr.type_.?:
        Some(substitute_type(expr.type_.unwrap(), subst))
    else:
        nil

    val new_kind = match expr.kind:
        # Literals - substitute type annotations
        case IntLit(value, suffix): expr.kind
        case FloatLit(value, suffix): expr.kind
        case StringLit(value, interps): expr.kind
        case BoolLit(value): expr.kind
        case CharLit(value): expr.kind
        case UnitLit: expr.kind
        case NilLit: expr.kind

        # Collections
        case ArrayLit(elements, ty):
            val new_elems = elements.map(\e: substitute_expr(e, subst))
            val new_ty = if ty.?: Some(substitute_type(ty.unwrap(), subst)) else: nil
            HirExprKind.ArrayLit(new_elems, new_ty)

        case TupleLit(elements):
            HirExprKind.TupleLit(elements.map(\e: substitute_expr(e, subst)))

        case DictLit(entries, key_ty, val_ty):
            val new_entries = entries.map(\kv: (substitute_expr(kv.0, subst), substitute_expr(kv.1, subst)))
            val new_key_ty = if key_ty.?: Some(substitute_type(key_ty.unwrap(), subst)) else: nil
            val new_val_ty = if val_ty.?: Some(substitute_type(val_ty.unwrap(), subst)) else: nil
            HirExprKind.DictLit(new_entries, new_key_ty, new_val_ty)

        # Variables and access
        case Var(_): expr.kind

        case Field(base, field, resolved):
            HirExprKind.Field(substitute_expr(base, subst), field, resolved)

        case Index(base, index):
            HirExprKind.Index(substitute_expr(base, subst), substitute_expr(index, subst))

        case TupleIndex(base, index):
            HirExprKind.TupleIndex(substitute_expr(base, subst), index)

        # Optional operations
        case OptionalChain(base, field):
            HirExprKind.OptionalChain(substitute_expr(base, subst), field)

        case NullCoalesce(left, right):
            HirExprKind.NullCoalesce(substitute_expr(left, subst), substitute_expr(right, subst))

        case ExistsCheck(base):
            HirExprKind.ExistsCheck(substitute_expr(base, subst))

        case Unwrap(base):
            HirExprKind.Unwrap(substitute_expr(base, subst))

        # Operators
        case Binary(op, left, right):
            HirExprKind.Binary(op, substitute_expr(left, subst), substitute_expr(right, subst))

        case Unary(op, operand):
            HirExprKind.Unary(op, substitute_expr(operand, subst))

        # Calls - substitute type arguments
        case Call(callee, args, type_args):
            val new_callee = substitute_expr(callee, subst)
            val new_args = args.map(\a: substitute_call_arg(a, subst))
            val new_type_args = type_args.map(\t: substitute_type(t, subst))
            HirExprKind.Call(new_callee, new_args, new_type_args)

        case MethodCall(receiver, method, args, resolution):
            val new_recv = substitute_expr(receiver, subst)
            val new_args = args.map(\a: substitute_call_arg(a, subst))
            HirExprKind.MethodCall(new_recv, method, new_args, resolution)

        case StaticCall(ty, method, args, resolution):
            val new_ty = substitute_type(ty, subst)
            val new_args = args.map(\a: substitute_call_arg(a, subst))
            HirExprKind.StaticCall(new_ty, method, new_args, resolution)

        # Control flow
        case If(cond, then_, else_):
            val new_cond = substitute_expr(cond, subst)
            val new_then = substitute_block(then_, subst)
            val new_else = if else_.?: Some(substitute_block(else_.unwrap(), subst)) else: nil
            HirExprKind.If(new_cond, new_then, new_else)

        case MatchExpr(scrutinee, arms):
            val new_scrut = substitute_expr(scrutinee, subst)
            val new_arms = arms.map(\a: substitute_match_arm(a, subst))
            HirExprKind.MatchExpr(new_scrut, new_arms)

        case Loop(body, label):
            HirExprKind.Loop(substitute_block(body, subst), label)

        case While(cond, body, label):
            HirExprKind.While(substitute_expr(cond, subst), substitute_block(body, subst), label)

        case For(var_, iter, body, label):
            HirExprKind.For(var_, substitute_expr(iter, subst), substitute_block(body, subst), label)

        # Closures
        case Lambda(params, body, captures):
            val new_params = params.map(\p: substitute_param(p, subst))
            val new_body = substitute_expr(body, subst)
            HirExprKind.Lambda(new_params, new_body, captures)

        case Block(block):
            HirExprKind.Block(substitute_block(block, subst))

        # Control transfer
        case Return(value):
            val new_val = if value.?: Some(substitute_expr(value.unwrap(), subst)) else: nil
            HirExprKind.Return(new_val)

        case Break(label, value):
            val new_val = if value.?: Some(substitute_expr(value.unwrap(), subst)) else: nil
            HirExprKind.Break(label, new_val)

        case Continue(label): expr.kind

        case Throw(value):
            HirExprKind.Throw(substitute_expr(value, subst))

        case Try(e):
            HirExprKind.Try(substitute_expr(e, subst))

        # Async
        case Await(e):
            HirExprKind.Await(substitute_expr(e, subst))

        case Yield(value):
            val new_val = if value.?: Some(substitute_expr(value.unwrap(), subst)) else: nil
            HirExprKind.Yield(new_val)

        # Construction
        case StructLit(ty, fields):
            val new_ty = substitute_type(ty, subst)
            val new_fields = fields.map(\f: (f.0, substitute_expr(f.1, subst)))
            HirExprKind.StructLit(new_ty, new_fields)

        case EnumLit(ty, variant, payload):
            val new_ty = substitute_type(ty, subst)
            val new_payload = if payload.?: Some(substitute_enum_payload(payload.unwrap(), subst)) else: nil
            HirExprKind.EnumLit(new_ty, variant, new_payload)

        # Casts
        case Cast(e, target):
            HirExprKind.Cast(substitute_expr(e, subst), substitute_type(target, subst))

        case As(e, target):
            HirExprKind.As(substitute_expr(e, subst), substitute_type(target, subst))

        # Range
        case Range(start, end, inclusive, step):
            val new_start = if start.?: Some(substitute_expr(start.unwrap(), subst)) else: nil
            val new_end = if end.?: Some(substitute_expr(end.unwrap(), subst)) else: nil
            val new_step = if step.?: Some(substitute_expr(step.unwrap(), subst)) else: nil
            HirExprKind.Range(new_start, new_end, inclusive, new_step)

        # Comprehension
        case Comprehension(kind, e, clauses):
            val new_e = substitute_expr(e, subst)
            val new_clauses = clauses.map(\c: substitute_comp_clause(c, subst))
            HirExprKind.Comprehension(kind, new_e, new_clauses)

        # Custom blocks
        case CustomBlock(_, _): expr.kind
        case LossBlock(body):
            HirExprKind.LossBlock(substitute_block(body, subst))
        case NogradBlock(body):
            HirExprKind.NogradBlock(substitute_block(body, subst))

        case Error: expr.kind

    HirExpr(kind: new_kind, type_: new_type, span: expr.span)

# ============================================================================
# Helper Substitution Functions
# ============================================================================

fn substitute_call_arg(arg: HirCallArg, subst: TypeSubstitution) -> HirCallArg:
    HirCallArg(name: arg.name, value: substitute_expr(arg.value, subst), span: arg.span)

fn substitute_match_arm(arm: HirMatchArm, subst: TypeSubstitution) -> HirMatchArm:
    val new_pattern = substitute_pattern(arm.pattern, subst)
    val new_guard = if arm.guard.?: Some(substitute_expr(arm.guard.unwrap(), subst)) else: nil
    val new_body = substitute_block(arm.body, subst)
    HirMatchArm(pattern: new_pattern, guard: new_guard, body: new_body, span: arm.span)

fn substitute_pattern(pat: HirPattern, subst: TypeSubstitution) -> HirPattern:
    val new_type = if pat.type_.?: Some(substitute_type(pat.type_.unwrap(), subst)) else: nil
    val new_kind = match pat.kind:
        case Wildcard: pat.kind
        case Literal(value): HirPatternKind.Literal(substitute_expr(value, subst))
        case Binding(_, _): pat.kind
        case Tuple(elements):
            HirPatternKind.Tuple(elements.map(\e: substitute_pattern(e, subst)))
        case Array(elements, rest):
            HirPatternKind.Array(elements.map(\e: substitute_pattern(e, subst)), rest)
        case Struct(ty, fields):
            val new_ty = substitute_type(ty, subst)
            val new_fields = fields.map(\f: (f.0, substitute_pattern(f.1, subst)))
            HirPatternKind.Struct(new_ty, new_fields)
        case Enum(ty, variant, payload):
            val new_ty = substitute_type(ty, subst)
            val new_payload = if payload.?: Some(substitute_pattern_payload(payload.unwrap(), subst)) else: nil
            HirPatternKind.Enum(new_ty, variant, new_payload)
        case Or(patterns):
            HirPatternKind.Or(patterns.map(\p: substitute_pattern(p, subst)))
        case Range(start, end, inclusive):
            val new_start = if start.?: Some(substitute_expr(start.unwrap(), subst)) else: nil
            val new_end = if end.?: Some(substitute_expr(end.unwrap(), subst)) else: nil
            HirPatternKind.Range(new_start, new_end, inclusive)
        case Error: pat.kind
    HirPattern(kind: new_kind, type_: new_type, span: pat.span)

fn substitute_pattern_payload(payload: HirPatternPayload, subst: TypeSubstitution) -> HirPatternPayload:
    match payload:
        case Tuple(patterns):
            HirPatternPayload.Tuple(patterns.map(\p: substitute_pattern(p, subst)))
        case Struct(fields):
            HirPatternPayload.Struct(fields.map(\f: (f.0, substitute_pattern(f.1, subst))))

fn substitute_enum_payload(payload: HirEnumPayload, subst: TypeSubstitution) -> HirEnumPayload:
    match payload:
        case Tuple(values):
            HirEnumPayload.Tuple(values.map(\v: substitute_expr(v, subst)))
        case Struct(fields):
            HirEnumPayload.Struct(fields.map(\f: (f.0, substitute_expr(f.1, subst))))

fn substitute_comp_clause(clause: HirCompClause, subst: TypeSubstitution) -> HirCompClause:
    val new_kind = match clause.kind:
        case For(var_, iter):
            HirCompClauseKind.For(var_, substitute_expr(iter, subst))
        case If(cond):
            HirCompClauseKind.If(substitute_expr(cond, subst))
    HirCompClause(kind: new_kind, span: clause.span)

fn substitute_block(block: HirBlock, subst: TypeSubstitution) -> HirBlock:
    val new_stmts = block.stmts.map(\s: substitute_stmt(s, subst))
    val new_value = if block.value.?: Some(substitute_expr(block.value.unwrap(), subst)) else: nil
    HirBlock(stmts: new_stmts, value: new_value, span: block.span)

fn substitute_stmt(stmt: HirStmt, subst: TypeSubstitution) -> HirStmt:
    val new_kind = match stmt.kind:
        case Expr(e):
            HirStmtKind.Expr(substitute_expr(e, subst))
        case Let(symbol, ty, init):
            val new_ty = if ty.?: Some(substitute_type(ty.unwrap(), subst)) else: nil
            HirStmtKind.Let(symbol, new_ty, substitute_expr(init, subst))
        case Assign(target, op, value):
            HirStmtKind.Assign(substitute_expr(target, subst), op, substitute_expr(value, subst))
        case Block(b):
            HirStmtKind.Block(substitute_block(b, subst))
    HirStmt(kind: new_kind, span: stmt.span)

fn substitute_param(param: HirParam, subst: TypeSubstitution) -> HirParam:
    val new_type = substitute_type(param.type_, subst)
    val new_default = if param.default.?: Some(substitute_expr(param.default.unwrap(), subst)) else: nil
    HirParam(symbol: param.symbol, name: param.name, type_: new_type, default: new_default, span: param.span)

# ============================================================================
# Function Substitution
# ============================================================================

fn substitute_function(func: HirFunction, subst: TypeSubstitution, mangled_name: text) -> HirFunction:
    """Create a specialized version of a function with type substitution applied."""
    # Substitute parameter types
    val new_params = func.params.map(\p: substitute_param(p, subst))

    # Substitute return type
    val new_return_type = substitute_type(func.return_type, subst)

    # Substitute body
    val new_body = substitute_block(func.body, subst)

    # Create specialized function (no type parameters after specialization)
    HirFunction(
        symbol: func.symbol,  # Keep original symbol for now
        name: mangled_name,
        type_params: [],  # Specialized - no type params
        params: new_params,
        return_type: new_return_type,
        body: new_body,
        effects: func.effects,
        is_async: func.is_async,
        is_static: func.is_static,
        is_public: func.is_public,
        is_method: func.is_method,
        is_mutable: func.is_mutable,
        doc_comment: func.doc_comment,
        span: func.span
    )
