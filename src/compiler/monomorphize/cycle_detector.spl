# Circular Dependency Detection for Template Instantiations
#
# This module analyzes the dependency graph from note.sdn to detect:
# - Hard cycles (E0420): Direct circular dependencies that are not allowed
# - Soft cycles (warning): Cycles broken by indirection (e.g., through Option<T>)
#
# Phase 6: Circular Dependency Detection
#
# Port of: rust/compiler/src/monomorphize/cycle_detector.rs (413 lines)

export CycleDetectionResult
export detect_cycles
export detect_type_inference_cycles
export analyze_and_update_cycles
export would_create_cycle
export topological_sort

use .note_sdn (NoteSdnMetadata, DependencyEdge, DependencyKind)
use .note_sdn (CircularError, CircularWarning)

# ============================================================================
# Cycle Detection Result
# ============================================================================

struct CycleDetectionResult:
    """Result of cycle detection analysis."""
    errors: [CircularError]          # Hard circular dependencies (errors)
    warnings: [CircularWarning]      # Soft circular dependencies (warnings)
    all_cycles: [[text]]             # All detected cycles (including soft ones)

impl CycleDetectionResult:
    static fn new() -> CycleDetectionResult:
        """Create a new empty result."""
        CycleDetectionResult(
            errors: [],
            warnings: [],
            all_cycles: []
        )

    fn has_errors() -> bool:
        """Check if there are any hard cycle errors."""
        self.errors.len() > 0

    fn has_warnings() -> bool:
        """Check if there are any soft cycle warnings."""
        self.warnings.len() > 0

    fn is_clean() -> bool:
        """Check if no cycles were detected."""
        self.errors.is_empty() and self.warnings.is_empty()

# ============================================================================
# Cycle Detection
# ============================================================================

fn detect_cycles(metadata: NoteSdnMetadata) -> CycleDetectionResult:
    """Detect circular dependencies in the instantiation graph.

    Returns a result containing all detected cycles, classified as
    hard errors or soft warnings.
    """
    var result = CycleDetectionResult.new()

    # Build adjacency list from dependencies
    val graph = build_graph(metadata.dependencies)

    # Find all cycles using DFS
    val cycles = find_all_cycles(graph)

    # Classify each cycle as hard error or soft warning
    for cycle in cycles:
        val cycle_path = cycle.join("->")

        if is_hard_cycle(cycle, metadata.dependencies):
            result.errors.push(CircularError(
                cycle_path: cycle_path.clone(),
                error_code: "E0420"
            ))
        else:
            result.warnings.push(CircularWarning(
                cycle_path: cycle_path.clone(),
                warning_code: "warning"
            ))

        result.all_cycles.push(cycle)

    result

# ============================================================================
# Graph Building
# ============================================================================

fn build_graph(dependencies: [DependencyEdge]) -> {text: [text]}:
    """Build adjacency list from dependency edges.

    Returns a dictionary mapping each node to its list of neighbors.
    """
    var graph: {text: [text]} = {}

    for dep in dependencies:
        if not graph.contains_key(dep.from_inst):
            graph[dep.from_inst] = []

        graph[dep.from_inst].push(dep.to_inst.clone())

    graph

# ============================================================================
# Cycle Finding (DFS)
# ============================================================================

fn find_all_cycles(graph: {text: [text]}) -> [[text]]:
    """Find all cycles in the graph using DFS.

    Returns a list of cycles, where each cycle is a list of node names.
    """
    var cycles: [[text]] = []
    var visited: {text: bool} = {}
    var rec_stack: {text: bool} = {}
    var path: [text] = []

    # Get all nodes (both keys and values)
    var all_nodes: {text: bool} = {}
    for node in graph.keys():
        all_nodes[node] = true

    for edges in graph.values():
        for edge in edges:
            all_nodes[edge] = true

    # DFS from each node
    for node in all_nodes.keys():
        if not visited.get(node, false):
            find_cycles_dfs(node, graph, visited, rec_stack, path, cycles)

    cycles

fn find_cycles_dfs(
    node: text,
    graph: {text: [text]},
    visited: {text: bool},
    rec_stack: {text: bool},
    path: [text],
    cycles: [[text]]
):
    """DFS helper to find cycles.

    ROBUSTNESS:
    - visited: Tracks all visited nodes (prevents re-processing)
    - rec_stack: Tracks nodes in current recursion path (detects cycles)
    - path: Current path for cycle extraction
    """
    visited[node] = true
    rec_stack[node] = true
    path.push(node.clone())

    if val Some(neighbors) = graph.get(node):
        for neighbor in neighbors:
            if not visited.get(neighbor, false):
                # Unvisited - recurse
                find_cycles_dfs(neighbor, graph, visited, rec_stack, path, cycles)
            elif rec_stack.get(neighbor, false):
                # Found a cycle! Extract it from the path
                var cycle_start = 0
                for i in 0..path.len():
                    if path[i] == neighbor:
                        cycle_start = i
                        break

                # Extract cycle from path[cycle_start..]
                var cycle: [text] = []
                for i in cycle_start..path.len():
                    cycle.push(path[i].clone())
                cycle.push(neighbor.clone())  # Complete the cycle

                cycles.push(cycle)

    path.pop()
    rec_stack.remove(node)

# ============================================================================
# Cycle Classification
# ============================================================================

fn is_hard_cycle(cycle: [text], dependencies: [DependencyEdge]) -> bool:
    """Determine if a cycle is a "hard" cycle (error) or "soft" cycle (warning).

    A cycle is "soft" if it's broken by an indirection type like Option<T>,
    which allows the cycle to exist at runtime through null/nil values.

    ROBUSTNESS: Checks each edge in the cycle for indirection types.
    """
    # Check if any edge in the cycle goes through an indirection type
    for i in 0..(cycle.len() - 1):
        val from = cycle[i]
        val to = cycle[i + 1]

        # Find the dependency edge
        for dep in dependencies:
            if dep.from_inst == from and dep.to_inst == to:
                # InnerType dependency through Option/Result breaks the cycle
                if dep.dep_kind == DependencyKind.InnerType:
                    # Check if it's through an Option or similar nullable type
                    if from.contains("Option") or from.contains("Result") or from.contains("Nullable"):
                        return false  # Soft cycle

    # No indirection found - hard cycle
    true

# ============================================================================
# Type Inference Cycle Detection
# ============================================================================

fn detect_type_inference_cycles(inference_deps: [(text, text)]) -> [CircularError]:
    """Detect cycles specifically for type inference dependencies.

    Args:
        inference_deps: List of (from_expr, to_expr) dependencies

    Returns:
        List of circular errors (all type inference cycles are errors E0421)

    ROBUSTNESS: All type inference cycles are hard errors (no indirection).
    """
    var errors: [CircularError] = []

    # Build graph
    var graph: {text: [text]} = {}
    for (from, to) in inference_deps:
        if not graph.contains_key(from):
            graph[from] = []
        graph[from].push(to.clone())

    # Find cycles
    val cycles = find_all_cycles(graph)

    # All type inference cycles are errors (E0421)
    for cycle in cycles:
        val cycle_path = cycle.join("->")
        errors.push(CircularError(
            cycle_path: cycle_path,
            error_code: "E0421"
        ))

    errors

# ============================================================================
# Metadata Update
# ============================================================================

fn analyze_and_update_cycles(metadata: NoteSdnMetadata):
    """Analyze metadata and update it with detected cycles.

    Side effects:
    - Adds detected errors to metadata.circular_errors
    - Adds detected warnings to metadata.circular_warnings

    ROBUSTNESS: Mutates metadata in place to preserve references.
    """
    val result = detect_cycles(metadata)

    # Add detected errors and warnings to metadata
    for error in result.errors:
        metadata.add_circular_error(error)

    for warning in result.warnings:
        metadata.add_circular_warning(warning)

# ============================================================================
# Cycle Prevention
# ============================================================================

fn would_create_cycle(metadata: NoteSdnMetadata, new_from: text, new_to: text) -> [text]?:
    """Check if adding a new dependency would create a cycle.

    Args:
        metadata: Current metadata with existing dependencies
        new_from: Source node of new dependency
        new_to: Target node of new dependency

    Returns:
        Some(path) if adding the edge would create a cycle (path shows the cycle)
        nil if no cycle would be created

    ROBUSTNESS: Checks before adding edge to prevent creating cycles.
    """
    # Build graph with the new edge
    var graph = build_graph(metadata.dependencies)
    if not graph.contains_key(new_from):
        graph[new_from] = []
    graph[new_from].push(new_to.clone())

    # Check for path from new_to back to new_from (which would create cycle)
    var visited: {text: bool} = {}
    var path = [new_to.clone()]

    if has_path_dfs(new_to, new_from, graph, visited, path):
        Some(path)
    else:
        nil

fn has_path_dfs(
    current: text,
    target: text,
    graph: {text: [text]},
    visited: {text: bool},
    path: [text]
) -> bool:
    """Check if there's a path from start to target.

    ROBUSTNESS: Uses visited set to prevent infinite loops.
    """
    if current == target:
        return true

    if visited.get(current, false):
        return false

    visited[current] = true

    if val Some(neighbors) = graph.get(current):
        for neighbor in neighbors:
            path.push(neighbor.clone())
            if has_path_dfs(neighbor, target, graph, visited, path):
                return true
            path.pop()

    false

# ============================================================================
# Topological Sort
# ============================================================================

fn topological_sort(metadata: NoteSdnMetadata) -> [text]?:
    """Topological sort of the dependency graph.

    Returns:
        Some(sorted) if the graph has no cycles (nodes in dependency order)
        nil if the graph has cycles

    Algorithm: Kahn's algorithm (in-degree based)

    ROBUSTNESS: Returns nil on cycles instead of panicking.
    """
    val graph = build_graph(metadata.dependencies)

    # Calculate in-degrees
    var in_degree: {text: i64} = {}
    var all_nodes: {text: bool} = {}

    # Collect all nodes
    for node in graph.keys():
        all_nodes[node] = true

    for edges in graph.values():
        for edge in edges:
            all_nodes[edge] = true
            val current = in_degree.get(edge, 0)
            in_degree[edge] = current + 1

    # Initialize in-degrees for nodes with no incoming edges
    for node in all_nodes.keys():
        if not in_degree.contains_key(node):
            in_degree[node] = 0

    # Kahn's algorithm
    var queue: [text] = []
    for (node, deg) in in_degree.items():
        if deg == 0:
            queue.push(node.clone())

    var result: [text] = []

    while queue.len() > 0:
        val node = queue.pop().unwrap()  # Safe: queue.len() > 0
        result.push(node.clone())

        if val Some(neighbors) = graph.get(node):
            for neighbor in neighbors:
                if val Some(deg) = in_degree.get(neighbor):
                    in_degree[neighbor] = deg - 1
                    if deg - 1 == 0:
                        queue.push(neighbor.clone())

    # If we processed all nodes, no cycle exists
    if result.len() == all_nodes.keys().len():
        Some(result)
    else:
        nil  # Cycle detected

# ============================================================================
# Performance Notes
# ============================================================================
#
# - build_graph: O(E) where E = number of edges
# - find_all_cycles: O(V + E) DFS traversal, V = nodes, E = edges
# - is_hard_cycle: O(cycle_length * E) - can be optimized with edge map
# - would_create_cycle: O(V + E) DFS path search
# - topological_sort: O(V + E) Kahn's algorithm
#
# Expected performance: Same as Rust (same algorithms)
#
# ============================================================================
# Robustness Checklist
# ============================================================================
#
# Memory Safety:
# - [x] No buffer overflows (Simple arrays are bounds-checked)
# - [x] No null pointers (uses Option<T>)
#
# Error Handling:
# - [x] Returns Option for cycle detection (not panics)
# - [x] Validates input (checks visited set)
#
# Logic Correctness:
# - [x] DFS correctly detects cycles (rec_stack tracking)
# - [x] Handles self-cycles
# - [x] Handles disconnected graphs (iterates all nodes)
# - [x] Kahn's algorithm returns None on cycles
#
# Edge Cases:
# - [x] Empty graph (returns clean result)
# - [x] Single node (no cycle)
# - [x] Self-loop (detected as hard cycle)
# - [x] Multiple disconnected cycles
# - [x] Soft cycles through Option<T>
