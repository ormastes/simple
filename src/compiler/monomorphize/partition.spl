# Partitioning of Generic Templates and Specialized Instances
#
# This module separates a monomorphized module into:
# - Generic templates (for later instantiation, stored in .smf)
# - Specialized instances (compiled to native code)
#
# Supports .smf template storage for deferred monomorphization.
#
# Port of: rust/compiler/src/monomorphize/partition.rs (449 lines)

export GenericTemplates
export SpecializedInstances
export partition_generic_constructs
export build_monomorphization_metadata
export build_monomorphization_metadata_from_constructs

use ..ast (Module, Node, FunctionDef, StructDef, ClassDef, EnumDef, TraitDef)
use .metadata (MonomorphizationMetadata, GenericFunctionMeta, GenericStructMeta)
use .metadata (GenericClassMeta, GenericEnumMeta, GenericTraitMeta)
use .metadata (SpecializationEntry)
use .types (ConcreteType, TypeBindings)

# ============================================================================
# Generic Templates
# ============================================================================

struct GenericTemplates:
    """Complete set of generic templates extracted from a module.

    Templates are stored in .smf files for later instantiation
    (deferred monomorphization).
    """
    functions: [FunctionDef]
    structs: [StructDef]
    classes: [ClassDef]
    enums: [EnumDef]
    traits: [TraitDef]

impl GenericTemplates:
    static fn new() -> GenericTemplates:
        """Create an empty template set."""
        GenericTemplates(
            functions: [],
            structs: [],
            classes: [],
            enums: [],
            traits: []
        )

    static fn empty() -> GenericTemplates:
        """Create an empty template set (alias for new)."""
        GenericTemplates.new()

    fn is_empty() -> bool:
        """Check if there are no templates."""
        (self.functions.is_empty() and
        self.structs.is_empty() and
        self.classes.is_empty() and
        self.enums.is_empty() and
        self.traits.is_empty())

    fn total_count() -> i64:
        """Total number of templates."""
        (self.functions.len() +
        self.structs.len() +
        self.classes.len() +
        self.enums.len() +
        self.traits.len())

    fn count() -> i64:
        """Total number of templates (alias for total_count)."""
        self.total_count()

# ============================================================================
# Specialized Instances
# ============================================================================

struct SpecializedInstances:
    """Complete set of specialized instances.

    These are compiled to native code and included in the final binary.
    """
    functions: [FunctionDef]
    structs: [StructDef]
    classes: [ClassDef]
    enums: [EnumDef]
    # Note: Trait implementations are tracked in metadata, not as instances

impl SpecializedInstances:
    static fn new() -> SpecializedInstances:
        """Create an empty instance set."""
        SpecializedInstances(
            functions: [],
            structs: [],
            classes: [],
            enums: []
        )

    static fn empty() -> SpecializedInstances:
        """Create an empty instance set (alias for new)."""
        SpecializedInstances.new()

    fn total_count() -> i64:
        """Total number of specialized instances."""
        (self.functions.len() +
        self.structs.len() +
        self.classes.len() +
        self.enums.len())

    fn count() -> i64:
        """Total number of specialized instances (alias for total_count)."""
        self.total_count()

# ============================================================================
# Partition Generic Constructs
# ============================================================================

fn partition_generic_constructs(module: Module) -> (GenericTemplates, SpecializedInstances, MonomorphizationMetadata):
    """Partition a module into generic templates and specialized instances.

    This is used during compilation to separate:
    - Templates (stored in .smf for later instantiation)
    - Specializations (compiled to native code)

    Returns:
        (templates, specialized_instances, metadata)

    ROBUSTNESS:
    - Categorizes each AST node correctly
    - Updates metadata for tracking
    - Handles non-generic items
    """
    var templates = GenericTemplates.new()
    var specialized = SpecializedInstances.new()
    var metadata = MonomorphizationMetadata.new()

    for item in module.items:
        match item:
            Node.Function(f):
                partition_function(f, templates, specialized, metadata)

            Node.Struct(s):
                partition_struct(s, templates, specialized, metadata)

            Node.Class(c):
                partition_class(c, templates, specialized, metadata)

            Node.Enum(e):
                partition_enum(e, templates, specialized, metadata)

            Node.Trait(t):
                partition_trait(t, templates, metadata)

            _:
                # Other node types (imports, etc.) - skip
                ()

    (templates, specialized, metadata)

# ============================================================================
# Partition Individual Constructs
# ============================================================================

fn partition_function(
    f: FunctionDef,
    templates: GenericTemplates,
    specialized: SpecializedInstances,
    metadata: MonomorphizationMetadata
):
    """Partition a function into template or specialized instance.

    Categories:
    1. is_generic_template=true -> Template
    2. specialization_of=Some(base) -> Specialized instance
    3. Otherwise -> Non-generic function (goes to specialized)

    ROBUSTNESS: Updates metadata for both templates and specializations.
    """
    if f.is_generic_template:
        # Generic template
        templates.functions.push(f.clone())

        # Create metadata entry if not exists
        if not metadata.functions.contains_key(f.name):
            metadata.functions[f.name] = GenericFunctionMeta.new(
                f.name.clone(),
                f.generic_params.clone()
            )

    elif val Some(base_name) = f.specialization_of:
        # Specialized instance
        specialized.functions.push(f.clone())

        # Add to metadata (create entry if needed)
        if not metadata.functions.contains_key(base_name):
            metadata.functions[base_name] = GenericFunctionMeta.new(base_name.clone(), [])

        val meta = metadata.functions[base_name]

        # Extract type args from bindings using type name conversion
        var type_args: [ConcreteType] = []
        for (_, ast_type) in f.type_bindings.items():
            val type_str = ast_type.to_string()
            val concrete = match type_str:
                case "i32" | "i64" | "u32" | "u64": ConcreteType.Int
                case "f32" | "f64": ConcreteType.Float
                case "bool": ConcreteType.Bool
                case "text" | "str": ConcreteType.String
                case _: ConcreteType.Named(type_str)
            type_args.push(concrete)

        # Convert type bindings
        var concrete_bindings: TypeBindings = {}
        for (param, ast_type) in f.type_bindings.items():
            val type_str = ast_type.to_string()
            val concrete = match type_str:
                case "i32" | "i64" | "u32" | "u64": ConcreteType.Int
                case "f32" | "f64": ConcreteType.Float
                case "bool": ConcreteType.Bool
                case "text" | "str": ConcreteType.String
                case _: ConcreteType.Named(type_str)
            concrete_bindings[param] = concrete

        # Add specialization entry
        meta.specializations.push(SpecializationEntry.new(
            type_args,
            f.name.clone(),
            concrete_bindings
        ))

    else:
        # Non-generic function
        specialized.functions.push(f.clone())

fn partition_struct(
    s: StructDef,
    templates: GenericTemplates,
    specialized: SpecializedInstances,
    metadata: MonomorphizationMetadata
):
    """Partition a struct into template or specialized instance."""
    if s.is_generic_template:
        templates.structs.push(s.clone())

        if not metadata.structs.contains_key(s.name):
            metadata.structs[s.name] = GenericStructMeta.new(
                s.name.clone(),
                s.generic_params.clone()
            )

    elif val Some(base_name) = s.specialization_of:
        specialized.structs.push(s.clone())

        if not metadata.structs.contains_key(base_name):
            metadata.structs[base_name] = GenericStructMeta.new(base_name.clone(), [])

        val meta = metadata.structs[base_name]

        # Extract type args
        var type_args: [ConcreteType] = []
        for (_, ast_type) in s.type_bindings.items():
            type_args.push(ConcreteType.Named(ast_type.to_string()))

        # Convert bindings
        var concrete_bindings: TypeBindings = {}
        for (param, ast_type) in s.type_bindings.items():
            concrete_bindings[param] = ConcreteType.Named(ast_type.to_string())

        meta.specializations.push(SpecializationEntry.new(
            type_args,
            s.name.clone(),
            concrete_bindings
        ))

    else:
        specialized.structs.push(s.clone())

fn partition_class(
    c: ClassDef,
    templates: GenericTemplates,
    specialized: SpecializedInstances,
    metadata: MonomorphizationMetadata
):
    """Partition a class into template or specialized instance."""
    if c.is_generic_template:
        templates.classes.push(c.clone())

        if not metadata.classes.contains_key(c.name):
            metadata.classes[c.name] = GenericClassMeta.new(
                c.name.clone(),
                c.generic_params.clone()
            )

    elif val Some(base_name) = c.specialization_of:
        specialized.classes.push(c.clone())

        if not metadata.classes.contains_key(base_name):
            metadata.classes[base_name] = GenericClassMeta.new(base_name.clone(), [])

        val meta = metadata.classes[base_name]

        # Extract type args
        var type_args: [ConcreteType] = []
        for (_, ast_type) in c.type_bindings.items():
            type_args.push(ConcreteType.Named(ast_type.to_string()))

        # Convert bindings
        var concrete_bindings: TypeBindings = {}
        for (param, ast_type) in c.type_bindings.items():
            concrete_bindings[param] = ConcreteType.Named(ast_type.to_string())

        meta.specializations.push(SpecializationEntry.new(
            type_args,
            c.name.clone(),
            concrete_bindings
        ))

    else:
        specialized.classes.push(c.clone())

fn partition_enum(
    e: EnumDef,
    templates: GenericTemplates,
    specialized: SpecializedInstances,
    metadata: MonomorphizationMetadata
):
    """Partition an enum into template or specialized instance."""
    if e.is_generic_template:
        templates.enums.push(e.clone())

        if not metadata.enums.contains_key(e.name):
            metadata.enums[e.name] = GenericEnumMeta.new(
                e.name.clone(),
                e.generic_params.clone()
            )

    elif val Some(base_name) = e.specialization_of:
        specialized.enums.push(e.clone())

        if not metadata.enums.contains_key(base_name):
            metadata.enums[base_name] = GenericEnumMeta.new(base_name.clone(), [])

        val meta = metadata.enums[base_name]

        # Extract type args
        var type_args: [ConcreteType] = []
        for (_, ast_type) in e.type_bindings.items():
            type_args.push(ConcreteType.Named(ast_type.to_string()))

        # Convert bindings
        var concrete_bindings: TypeBindings = {}
        for (param, ast_type) in e.type_bindings.items():
            concrete_bindings[param] = ConcreteType.Named(ast_type.to_string())

        meta.specializations.push(SpecializationEntry.new(
            type_args,
            e.name.clone(),
            concrete_bindings
        ))

    else:
        specialized.enums.push(e.clone())

fn partition_trait(
    t: TraitDef,
    templates: GenericTemplates,
    metadata: MonomorphizationMetadata
):
    """Partition a trait (always goes to templates).

    Note: Traits are not specialized - implementations are specialized.
    """
    if t.is_generic_template or not t.generic_params.is_empty():
        templates.traits.push(t.clone())

        if not metadata.traits.contains_key(t.name):
            metadata.traits[t.name] = GenericTraitMeta.new(
                t.name.clone(),
                t.generic_params.clone()
            )

# ============================================================================
# Build Monomorphization Metadata
# ============================================================================

fn build_monomorphization_metadata(module: Module) -> MonomorphizationMetadata:
    """Build monomorphization metadata from a module.

    Extracts all generic templates and specializations and builds metadata
    for tracking instantiation relationships.

    Returns:
        Metadata with all generic constructs and their specializations

    ROBUSTNESS: Complete metadata for all constructs.
    """
    val (_, _, metadata) = partition_generic_constructs(module)
    metadata

fn build_monomorphization_metadata_from_constructs(
    templates: GenericTemplates,
    specialized: SpecializedInstances
) -> MonomorphizationMetadata:
    """Build monomorphization metadata from pre-partitioned constructs.

    Takes already-separated templates and specialized instances and builds
    metadata tracking their relationships.

    Args:
        templates: Generic template constructs
        specialized: Specialized instance constructs

    Returns:
        Metadata with tracking information

    ROBUSTNESS: Processes all constructs and builds complete metadata.
    """
    var metadata = MonomorphizationMetadata.new()

    # Process templates
    for func in templates.functions:
        if not metadata.functions.contains_key(func.name):
            metadata.functions[func.name] = GenericFunctionMeta.new(
                func.name.clone(),
                func.generic_params.clone()
            )

    for struct_def in templates.structs:
        if not metadata.structs.contains_key(struct_def.name):
            metadata.structs[struct_def.name] = GenericStructMeta.new(
                struct_def.name.clone(),
                struct_def.generic_params.clone()
            )

    for class_def in templates.classes:
        if not metadata.classes.contains_key(class_def.name):
            metadata.classes[class_def.name] = GenericClassMeta.new(
                class_def.name.clone(),
                class_def.generic_params.clone()
            )

    for enum_def in templates.enums:
        if not metadata.enums.contains_key(enum_def.name):
            metadata.enums[enum_def.name] = GenericEnumMeta.new(
                enum_def.name.clone(),
                enum_def.generic_params.clone()
            )

    for trait_def in templates.traits:
        if not metadata.traits.contains_key(trait_def.name):
            metadata.traits[trait_def.name] = GenericTraitMeta.new(
                trait_def.name.clone(),
                trait_def.generic_params.clone()
            )

    # Process specializations
    for func in specialized.functions:
        if val Some(base_name) = func.specialization_of:
            # Ensure base template exists in metadata
            if not metadata.functions.contains_key(base_name):
                metadata.functions[base_name] = GenericFunctionMeta.new(base_name.clone(), [])

            val meta = metadata.functions[base_name]

            # Extract type args from bindings
            var type_args: [ConcreteType] = []
            for (_, ast_type) in func.type_bindings.items():
                type_args.push(ConcreteType.Named(ast_type.to_string()))

            # Convert type bindings
            var concrete_bindings: TypeBindings = {}
            for (param, ast_type) in func.type_bindings.items():
                concrete_bindings[param] = ConcreteType.Named(ast_type.to_string())

            # Add specialization entry
            meta.specializations.push(SpecializationEntry.new(
                type_args,
                func.name.clone(),
                concrete_bindings
            ))

    for struct_def in specialized.structs:
        if val Some(base_name) = struct_def.specialization_of:
            if not metadata.structs.contains_key(base_name):
                metadata.structs[base_name] = GenericStructMeta.new(base_name.clone(), [])

            val meta = metadata.structs[base_name]

            var type_args: [ConcreteType] = []
            for (_, ast_type) in struct_def.type_bindings.items():
                type_args.push(ConcreteType.Named(ast_type.to_string()))

            var concrete_bindings: TypeBindings = {}
            for (param, ast_type) in struct_def.type_bindings.items():
                concrete_bindings[param] = ConcreteType.Named(ast_type.to_string())

            meta.specializations.push(SpecializationEntry.new(
                type_args,
                struct_def.name.clone(),
                concrete_bindings
            ))

    for class_def in specialized.classes:
        if val Some(base_name) = class_def.specialization_of:
            if not metadata.classes.contains_key(base_name):
                metadata.classes[base_name] = GenericClassMeta.new(base_name.clone(), [])

            val meta = metadata.classes[base_name]

            var type_args: [ConcreteType] = []
            for (_, ast_type) in class_def.type_bindings.items():
                type_args.push(ConcreteType.Named(ast_type.to_string()))

            var concrete_bindings: TypeBindings = {}
            for (param, ast_type) in class_def.type_bindings.items():
                concrete_bindings[param] = ConcreteType.Named(ast_type.to_string())

            meta.specializations.push(SpecializationEntry.new(
                type_args,
                class_def.name.clone(),
                concrete_bindings
            ))

    for enum_def in specialized.enums:
        if val Some(base_name) = enum_def.specialization_of:
            if not metadata.enums.contains_key(base_name):
                metadata.enums[base_name] = GenericEnumMeta.new(base_name.clone(), [])

            val meta = metadata.enums[base_name]

            var type_args: [ConcreteType] = []
            for (_, ast_type) in enum_def.type_bindings.items():
                type_args.push(ConcreteType.Named(ast_type.to_string()))

            var concrete_bindings: TypeBindings = {}
            for (param, ast_type) in enum_def.type_bindings.items():
                concrete_bindings[param] = ConcreteType.Named(ast_type.to_string())

            meta.specializations.push(SpecializationEntry.new(
                type_args,
                enum_def.name.clone(),
                concrete_bindings
            ))

    metadata

# ============================================================================
# Usage Example
# ============================================================================
#
# # Partition a module
# val (templates, specialized, metadata) = partition_generic_constructs(module)
#
# print "Templates:"
# print "  Functions: {templates.functions.len()}"
# print "  Structs: {templates.structs.len()}"
# print "  Classes: {templates.classes.len()}"
# print "  Enums: {templates.enums.len()}"
# print "  Traits: {templates.traits.len()}"
#
# print "Specialized:"
# print "  Functions: {specialized.functions.len()}"
# print "  Structs: {specialized.structs.len()}"
# print "  Classes: {specialized.classes.len()}"
# print "  Enums: {specialized.enums.len()}"
#
# # Save templates to .smf file
# smf_writer.write_templates(templates)?
#
# # Compile specialized instances to native code
# codegen.compile_instances(specialized)?
#
# ============================================================================
# Partitioning Logic
# ============================================================================
#
# For each AST node:
#
# 1. is_generic_template = true
#    -> Add to templates (for .smf storage)
#    -> Create metadata entry
#
# 2. specialization_of = Some(base_name)
#    -> Add to specialized instances (for native code)
#    -> Add specialization entry to metadata
#
# 3. Otherwise (non-generic)
#    -> Add to specialized instances (normal code)
#
# Metadata tracks:
# - Generic templates (name, generic params)
# - All specializations (type args, mangled name, bindings)
# - Dependencies between templates
#
# ============================================================================
# Performance Notes
# ============================================================================
#
# - partition_generic_constructs: O(n) where n = number of AST nodes
# - Per-node partition: O(1) classification + O(1) metadata update
# - Type arg extraction: O(k) where k = number of type parameters
#
# Expected performance: Same as Rust (same algorithm, linear traversal)
#
# ============================================================================
# Robustness Checklist
# ============================================================================
#
# Logic Correctness:
# - [x] All generic templates identified
# - [x] All specializations identified
# - [x] Non-generic items handled
# - [x] Metadata updated correctly
# - [x] Type bindings preserved
#
# Edge Cases:
# - [x] Empty module (returns empty sets)
# - [x] No generics (all goes to specialized)
# - [x] Only templates (specialized is empty)
# - [x] Mixed generic and non-generic
#
# Memory Safety:
# - [x] No buffer overflows (Simple arrays safe)
# - [x] No use-after-free (clone() creates copies)
#
# Remaining work:
# - [ ] Implement ast_type_to_concrete conversion (currently placeholder)
# - [ ] Add support for trait implementations
# - [ ] Add incremental partitioning (delta updates)
