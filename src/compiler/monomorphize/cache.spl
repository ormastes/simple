# Monomorphization Cache
#
# Caches specialized function/struct/class definitions by specialization key.
# Content-based keys derived from definition hash + type arguments + mtime.
# Supports LRU eviction and optional disk persistence.
#
# Port of rust/compiler/src/monomorphize/cache.rs (100+ lines)

export MonoCacheConfig, MonoCacheStats, MonoCache

# ============================================================================
# Configuration
# ============================================================================

struct MonoCacheConfig:
    max_entries: i64
    validate_timestamps: bool
    persist_to_disk: bool
    cache_dir: text?

impl MonoCacheConfig:
    static fn default_config() -> MonoCacheConfig:
        MonoCacheConfig(max_entries: 10000, validate_timestamps: true,
                        persist_to_disk: false, cache_dir: nil)

    static fn memory_only() -> MonoCacheConfig:
        MonoCacheConfig(max_entries: 10000, validate_timestamps: true,
                        persist_to_disk: false, cache_dir: nil)

    static fn persistent(cache_dir: text) -> MonoCacheConfig:
        MonoCacheConfig(max_entries: 50000, validate_timestamps: true,
                        persist_to_disk: true, cache_dir: Some(cache_dir))

# ============================================================================
# Statistics
# ============================================================================

struct MonoCacheStats:
    hits: i64
    misses: i64
    evictions: i64
    invalidations: i64
    function_entries: i64
    struct_entries: i64
    class_entries: i64

impl MonoCacheStats:
    static fn empty() -> MonoCacheStats:
        MonoCacheStats(hits: 0, misses: 0, evictions: 0, invalidations: 0,
                       function_entries: 0, struct_entries: 0, class_entries: 0)

    fn hit_ratio() -> f64:
        val total = self.hits + self.misses
        if total == 0: 0.0
        else: self.hits.to_f64() / total.to_f64()

    fn total_entries() -> i64:
        self.function_entries + self.struct_entries + self.class_entries

# ============================================================================
# Cache Entry
# ============================================================================

struct CacheEntry:
    key: text
    value: Any
    last_access: i64
    content_hash: i64

# ============================================================================
# Mono Cache
# ============================================================================

class MonoCache:
    """Cache for monomorphization results."""
    config: MonoCacheConfig
    entries: {text: CacheEntry}
    stats: MonoCacheStats

impl MonoCache:
    static fn create(config: MonoCacheConfig) -> MonoCache:
        MonoCache(config: config, entries: {}, stats: MonoCacheStats.empty())

    fn lookup(key: text) -> Any?:
        if self.entries.contains_key(key):
            self.stats = MonoCacheStats(
                hits: self.stats.hits + 1, misses: self.stats.misses,
                evictions: self.stats.evictions, invalidations: self.stats.invalidations,
                function_entries: self.stats.function_entries,
                struct_entries: self.stats.struct_entries,
                class_entries: self.stats.class_entries)
            Some(self.entries[key].value)
        else:
            self.stats = MonoCacheStats(
                hits: self.stats.hits, misses: self.stats.misses + 1,
                evictions: self.stats.evictions, invalidations: self.stats.invalidations,
                function_entries: self.stats.function_entries,
                struct_entries: self.stats.struct_entries,
                class_entries: self.stats.class_entries)
            nil

    me store(key: text, value: Any, content_hash: i64):
        extern fn rt_time_millis() -> i64
        if self.entries.len() >= self.config.max_entries:
            self.evict_oldest()
        self.entries[key] = CacheEntry(key: key, value: value,
            # TODO: Replace direct FFI call with wrapper (time_millis) from app.io or compiler.ffi
            last_access: rt_time_millis(), content_hash: content_hash)

    me evict_oldest():
        """Evict the least recently accessed entry."""
        if not self.entries.?:
            return
        var oldest_key = ""
        var oldest_time: i64 = 9223372036854775807  # i64 max
        for (k, entry) in self.entries:
            if entry.last_access < oldest_time:
                oldest_time = entry.last_access
                oldest_key = k
        if oldest_key.?:
            self.entries = self.entries.remove(oldest_key)
            self.stats = MonoCacheStats(
                hits: self.stats.hits, misses: self.stats.misses,
                evictions: self.stats.evictions + 1,
                invalidations: self.stats.invalidations,
                function_entries: self.stats.function_entries,
                struct_entries: self.stats.struct_entries,
                class_entries: self.stats.class_entries)

    me clear():
        self.entries = {}

    fn get_stats() -> MonoCacheStats:
        self.stats
