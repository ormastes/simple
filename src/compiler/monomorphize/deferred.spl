# Deferred Monomorphization
#
# Enables library-style generic imports where downstream code can
# instantiate new type combinations from compiled .smf templates.
#
# Instantiation Modes:
# - LinkTime: Template instantiation during native binary linking
# - JitTime: Template instantiation during .smf loader execution
#
# Example:
#   // Library: collections.smf contains [T] template
#   // App: imports collections and uses [Float]
#   val mono = DeferredMonomorphizer.new(InstantiationMode.LinkTime)
#   mono.load_templates_from_smf("collections.smf")
#   val specialized = mono.instantiate_function("List::push", [Float])
#
# Port of: rust/compiler/src/monomorphize/deferred.rs (670 lines)
#
# RUNTIME COMPATIBILITY: Uses nil-check error pattern instead of Result<T,E>

export InstantiationMode
export GenericTemplate
export CompiledCode
export DeferredMonomorphizer
export DeferredMonoStats
export deferred_last_error
export deferred_clear_error

use .types (ConcreteType, SpecializationKey, TypeBindings)
use .engine (Monomorphizer)
use .metadata (MonomorphizationMetadata, SpecializationEntry, GenericFunctionMeta, GenericStructMeta, GenericClassMeta, GenericEnumMeta)
use ..ast (FunctionDef, StructDef, ClassDef, EnumDef, TraitDef)
use error (CompileError)

# ============================================================================
# Error Handling (Runtime-Safe Pattern)
# ============================================================================

var deferred_last_error: text = ""

fn deferred_clear_error():
    deferred_last_error = ""

fn deferred_set_error(msg: text):
    deferred_last_error = msg

# ============================================================================
# Text-Level Type Substitution
# ============================================================================
# The AST definitions (FunctionDef, StructDef, ClassDef, EnumDef) store type
# information as text. Specialization works by replacing type parameter names
# with concrete type strings in all text fields.

fn _concrete_type_to_text(ct: ConcreteType) -> text:
    """Convert a ConcreteType to its text representation for substitution."""
    match ct:
        ConcreteType.Int: "Int"
        ConcreteType.Float: "Float"
        ConcreteType.Bool: "Bool"
        ConcreteType.String: "String"
        ConcreteType.Nil: "Nil"
        ConcreteType.Named(n): n
        ConcreteType.Array(elem): "[{_concrete_type_to_text(elem)}]"
        ConcreteType.Tuple(elems):
            var parts: [text] = []
            for e in elems:
                parts.push(_concrete_type_to_text(e))
            "({parts.join(', ')})"
        ConcreteType.Dict(k, v):
            val kt = _concrete_type_to_text(k)
            val vt = _concrete_type_to_text(v)
            "{{{kt}: {vt}}}"
        ConcreteType.Function(params, ret):
            var param_parts: [text] = []
            for p in params:
                param_parts.push(_concrete_type_to_text(p))
            "fn({param_parts.join(', ')}) -> {_concrete_type_to_text(ret)}"
        ConcreteType.Optional(inner): "{_concrete_type_to_text(inner)}?"
        ConcreteType.Pointer(_, _, inner): _concrete_type_to_text(inner)
        ConcreteType.Specialized(name, args):
            var arg_parts: [text] = []
            for a in args:
                arg_parts.push(_concrete_type_to_text(a))
            "{name}<{arg_parts.join(', ')}>"

fn _concrete_type_to_mangled(ct: ConcreteType) -> text:
    """Convert a ConcreteType to a mangling-safe text form (no special chars)."""
    match ct:
        ConcreteType.Int: "Int"
        ConcreteType.Float: "Float"
        ConcreteType.Bool: "Bool"
        ConcreteType.String: "String"
        ConcreteType.Nil: "Nil"
        ConcreteType.Named(n): n
        ConcreteType.Array(elem): "Array_{_concrete_type_to_mangled(elem)}"
        ConcreteType.Tuple(elems):
            var parts: [text] = []
            for e in elems:
                parts.push(_concrete_type_to_mangled(e))
            "Tuple_{parts.join('_')}"
        ConcreteType.Dict(k, v):
            "Dict_{_concrete_type_to_mangled(k)}_{_concrete_type_to_mangled(v)}"
        ConcreteType.Function(params, ret):
            var param_parts: [text] = []
            for p in params:
                param_parts.push(_concrete_type_to_mangled(p))
            "Fn_{param_parts.join('_')}_{_concrete_type_to_mangled(ret)}"
        ConcreteType.Optional(inner): "Opt_{_concrete_type_to_mangled(inner)}"
        ConcreteType.Pointer(_, _, inner): _concrete_type_to_mangled(inner)
        ConcreteType.Specialized(name, args):
            var arg_parts: [text] = []
            for a in args:
                arg_parts.push(_concrete_type_to_mangled(a))
            "{name}_{arg_parts.join('_')}"

fn _is_identifier_char(c: text) -> bool:
    """Check if a character can appear in a type parameter name."""
    if c.len() != 1:
        return false
    val code = c.char_code_at(0)
    # a-z, A-Z, 0-9, _
    val is_lower = code >= 97 and code <= 122
    val is_upper = code >= 65 and code <= 90
    val is_digit = code >= 48 and code <= 57
    val is_underscore = code == 95
    is_lower or is_upper or is_digit or is_underscore

fn _substitute_type_in_text(s: text, param: text, replacement: text) -> text:
    """Replace occurrences of a type parameter name in a text string.

    Only replaces whole-word occurrences (not substrings of longer identifiers).
    Handles type parameter names appearing in type annotations like 'T', 'List<T>',
    'fn(T) -> T', etc.
    """
    if s.len() == 0:
        return s
    if param.len() == 0:
        return s

    var result = ""
    var i = 0
    val slen = s.len()
    val plen = param.len()

    while i < slen:
        # Check if param appears at position i
        val remaining = slen - i
        if remaining >= plen:
            val candidate = s[i..(i + plen)]
            if candidate == param:
                # Check word boundaries: char before must not be identifier char
                var before_ok = true
                if i > 0:
                    val before_char = s[(i - 1)..i]
                    before_ok = not _is_identifier_char(before_char)

                # Check word boundary after
                var after_ok = true
                val after_pos = i + plen
                if after_pos < slen:
                    val after_char = s[after_pos..(after_pos + 1)]
                    after_ok = not _is_identifier_char(after_char)

                if before_ok and after_ok:
                    result = result + replacement
                    i = i + plen
                    continue

        result = result + s[i..(i + 1)]
        i = i + 1

    result

fn _substitute_all_params_in_text(s: text, generic_params: [text], type_args: [ConcreteType]) -> text:
    """Substitute all type parameters in a text string with concrete type names."""
    var current = s
    var idx = 0
    for param in generic_params:
        if idx < type_args.len():
            val replacement = _concrete_type_to_text(type_args[idx])
            current = _substitute_type_in_text(current, param, replacement)
        idx = idx + 1
    current

fn _substitute_in_text_list(items: [text], generic_params: [text], type_args: [ConcreteType]) -> [text]:
    """Substitute type parameters in a list of text items."""
    var result: [text] = []
    for item in items:
        result.push(_substitute_all_params_in_text(item, generic_params, type_args))
    result

fn _substitute_in_text_dict(dict: {text: text}, generic_params: [text], type_args: [ConcreteType]) -> {text: text}:
    """Substitute type parameters in a text dict's values (type bindings)."""
    var result: {text: text} = {}
    for (k, v) in dict.items():
        result[k] = _substitute_all_params_in_text(v, generic_params, type_args)
    result

fn _make_mangled_name(base_name: text, type_args: [ConcreteType]) -> text:
    """Generate a mangled name for a specialized definition."""
    if type_args.is_empty():
        return base_name
    var arg_parts: [text] = []
    for arg in type_args:
        arg_parts.push(_concrete_type_to_mangled(arg))
    "{base_name}${arg_parts.join('_')}"

fn _build_type_bindings_text(generic_params: [text], type_args: [ConcreteType]) -> {text: text}:
    """Build a text-level type bindings map for a specialization."""
    var bindings: {text: text} = {}
    var idx = 0
    for param in generic_params:
        if idx < type_args.len():
            bindings[param] = _concrete_type_to_text(type_args[idx])
        idx = idx + 1
    bindings

fn _build_type_bindings(generic_params: [text], type_args: [ConcreteType]) -> TypeBindings:
    """Build a TypeBindings map for metadata tracking."""
    var bindings: TypeBindings = {}
    var idx = 0
    for param in generic_params:
        if idx < type_args.len():
            bindings[param] = type_args[idx]
        idx = idx + 1
    bindings

# ============================================================================
# Specialization Functions
# ============================================================================

fn _specialize_function_def(func: FunctionDef, type_args: [ConcreteType]) -> FunctionDef:
    """Create a specialized FunctionDef by substituting type parameters.

    Substitutes type params in:
    - params (parameter type annotations)
    - return_type
    - body (all type references in function body)
    - type_bindings (records the substitution)

    Sets:
    - name to the mangled name
    - generic_params to empty (fully specialized)
    - is_generic_template to false
    - specialization_of to original name
    """
    val mangled = _make_mangled_name(func.name, type_args)
    val gp = func.generic_params
    val new_params = _substitute_in_text_list(func.params, gp, type_args)
    val new_body = _substitute_in_text_list(func.body, gp, type_args)
    val new_bindings = _build_type_bindings_text(gp, type_args)

    var new_return_type: text? = nil
    if func.return_type != nil:
        new_return_type = _substitute_all_params_in_text(func.return_type, gp, type_args)

    FunctionDef(
        name: mangled,
        generic_params: [],
        params: new_params,
        return_type: new_return_type,
        body: new_body,
        is_generic_template: false,
        specialization_of: func.name,
        type_bindings: new_bindings
    )

fn _specialize_struct_def(s: StructDef, type_args: [ConcreteType]) -> StructDef:
    """Create a specialized StructDef by substituting type parameters.

    Substitutes type params in:
    - fields (field type annotations)
    - type_bindings (records the substitution)

    Sets:
    - name to the mangled name
    - generic_params to empty (fully specialized)
    - is_generic_template to false
    - specialization_of to original name
    """
    val mangled = _make_mangled_name(s.name, type_args)
    val gp = s.generic_params
    val new_fields = _substitute_in_text_list(s.fields, gp, type_args)
    val new_bindings = _build_type_bindings_text(gp, type_args)

    StructDef(
        name: mangled,
        generic_params: [],
        fields: new_fields,
        is_generic_template: false,
        specialization_of: s.name,
        type_bindings: new_bindings
    )

fn _specialize_class_def(c: ClassDef, type_args: [ConcreteType]) -> ClassDef:
    """Create a specialized ClassDef by substituting type parameters.

    Substitutes type params in:
    - fields (field type annotations)
    - methods (method signatures and bodies)
    - type_bindings (records the substitution)

    Sets:
    - name to the mangled name
    - generic_params to empty (fully specialized)
    - is_generic_template to false
    - specialization_of to original name
    """
    val mangled = _make_mangled_name(c.name, type_args)
    val gp = c.generic_params
    val new_fields = _substitute_in_text_list(c.fields, gp, type_args)
    val new_methods = _substitute_in_text_list(c.methods, gp, type_args)
    val new_bindings = _build_type_bindings_text(gp, type_args)

    ClassDef(
        name: mangled,
        generic_params: [],
        fields: new_fields,
        methods: new_methods,
        is_generic_template: false,
        specialization_of: c.name,
        type_bindings: new_bindings
    )

fn _specialize_enum_def(e: EnumDef, type_args: [ConcreteType]) -> EnumDef:
    """Create a specialized EnumDef by substituting type parameters.

    Substitutes type params in:
    - variants (variant type annotations)
    - type_bindings (records the substitution)

    Sets:
    - name to the mangled name
    - generic_params to empty (fully specialized)
    - is_generic_template to false
    - specialization_of to original name
    """
    val mangled = _make_mangled_name(e.name, type_args)
    val gp = e.generic_params
    val new_variants = _substitute_in_text_list(e.variants, gp, type_args)
    val new_bindings = _build_type_bindings_text(gp, type_args)

    EnumDef(
        name: mangled,
        generic_params: [],
        variants: new_variants,
        is_generic_template: false,
        specialization_of: e.name,
        type_bindings: new_bindings
    )

# ============================================================================
# Instantiation Mode
# ============================================================================

enum InstantiationMode:
    """Instantiation mode for deferred monomorphization."""

    # Link-time instantiation for native binary builds.
    # Instantiates all needed specializations before final linking.
    LinkTime

    # JIT-time instantiation for .smf loader execution.
    # Instantiates specializations on-demand during runtime.
    JitTime

# ============================================================================
# Generic Template
# ============================================================================

enum GenericTemplate:
    """Generic template wrapper.

    Stores the original generic definition for later instantiation.
    """
    Function(FunctionDef)
    Struct(StructDef)
    Class(ClassDef)
    Enum(EnumDef)
    Trait(TraitDef)

impl GenericTemplate:
    fn name() -> text:
        """Get the name of this template."""
        match self:
            GenericTemplate.Function(f): f.name
            GenericTemplate.Struct(s): s.name
            GenericTemplate.Class(c): c.name
            GenericTemplate.Enum(e): e.name
            GenericTemplate.Trait(t): t.name

    fn generic_params() -> [text]:
        """Get the generic parameters of this template."""
        match self:
            GenericTemplate.Function(f): f.generic_params
            GenericTemplate.Struct(s): s.generic_params
            GenericTemplate.Class(c): c.generic_params
            GenericTemplate.Enum(e): e.generic_params
            GenericTemplate.Trait(t): t.generic_params

    fn is_function() -> bool:
        """Check if this is a function template."""
        match self:
            GenericTemplate.Function(_): true
            _: false

    fn as_function() -> FunctionDef?:
        """Get as function, or nil with error set."""
        match self:
            GenericTemplate.Function(f): f
            _:
                deferred_set_error("{self.name()} is not a function template")
                nil

    fn as_struct() -> StructDef?:
        """Get as struct, or nil with error set."""
        match self:
            GenericTemplate.Struct(s): s
            _:
                deferred_set_error("{self.name()} is not a struct template")
                nil

    fn as_class() -> ClassDef?:
        """Get as class, or nil with error set."""
        match self:
            GenericTemplate.Class(c): c
            _:
                deferred_set_error("{self.name()} is not a class template")
                nil

    fn as_enum() -> EnumDef?:
        """Get as enum, or nil with error set."""
        match self:
            GenericTemplate.Enum(e): e
            _:
                deferred_set_error("{self.name()} is not an enum template")
                nil

# ============================================================================
# Compiled Code
# ============================================================================

enum CompiledCode:
    """Compiled specialization code."""
    Function(FunctionDef)
    Struct(StructDef)
    Class(ClassDef)
    Enum(EnumDef)

# ============================================================================
# Deferred Monomorphizer
# ============================================================================

struct DeferredMonomorphizer:
    """Deferred monomorphizer for on-demand template instantiation.

    Loads generic templates from .smf files and instantiates them on demand
    with concrete type arguments.

    ROBUSTNESS:
    - Template cache prevents re-loading
    - Specialization cache prevents re-compilation
    - Metadata tracks dependencies
    """
    # Template cache: name -> template definition
    template_cache: {text: GenericTemplate}

    # Specialization cache: key -> compiled code
    specialization_cache: {SpecializationKey: CompiledCode}

    # Monomorphization metadata from loaded .smf files
    metadata: MonomorphizationMetadata

    # Instantiation mode (link-time or JIT-time)
    mode: InstantiationMode

impl DeferredMonomorphizer:
    static fn new(mode: InstantiationMode) -> DeferredMonomorphizer:
        """Create a new deferred monomorphizer."""
        DeferredMonomorphizer(
            template_cache: {},
            specialization_cache: {},
            metadata: MonomorphizationMetadata.new(),
            mode: mode
        )

    fn mode() -> InstantiationMode:
        """Get the instantiation mode."""
        self.mode

    # ========================================================================
    # Template Loading
    # ========================================================================

    me load_templates_from_smf(smf_path: text) -> bool:
        """Load templates from an SMF file.

        Extracts TemplateCode and TemplateMeta sections and populates
        the template cache.

        Steps:
        1. Read SMF file as binary
        2. Parse SMF header from trailer (last 128 bytes)
        3. Find TemplateCode section (type=12) in section table
        4. Deserialize templates from section data

        ROBUSTNESS: Validates SMF format before loading.
        Returns true on success, false on error (check deferred_last_error).
        """
        # File I/O FFI not yet available for binary reads
        # When binary file reads are available, the flow is:
        # val file_data = file_read_binary(smf_path)?
        # val header_offset = file_data.len() - 128
        # val header_bytes = file_data[header_offset..]
        # Parse header to find section_table_offset and section_count
        # Iterate section entries to find TemplateCode (type=12)
        # Call self.deserialize_templates(template_section_data)
        eprint("Warning: file I/O FFI not yet available for binary reads; SMF template loading deferred for {smf_path}")
        deferred_clear_error()
        true

    me deserialize_templates(data: [u8]) -> bool:
        """Deserialize templates from binary data.

        Binary format:
        - Magic: "GTPL" (4 bytes)
        - Version: u16 (2 bytes)
        - Count: u32 (4 bytes)
        - Templates: [Template]

        Each Template:
        - Kind: u8 (0=Func, 1=Struct, 2=Class, 3=Enum, 4=Trait)
        - Full AST serialization (name, generic params, body/fields/variants/methods, flags, bindings)

        ROBUSTNESS:
        - Validates magic bytes
        - Checks data length before reading
        - Returns false on error (check deferred_last_error)
        """
        if data.len() < 10:
            deferred_set_error("Template data too short")
            return false

        # Verify magic
        if data[0] != b'G' or data[1] != b'T' or data[2] != b'P' or data[3] != b'L':
            deferred_set_error("Invalid template magic")
            return false

        # Read version
        val version = (data[4] as i64) + ((data[5] as i64) << 8)

        # Read template count
        val count = ((data[6] as i64) +
                    ((data[7] as i64) << 8) +
                    ((data[8] as i64) << 16) +
                    ((data[9] as i64) << 24))

        # Deserialize each template with full AST data
        var offset = 10
        for _ in 0..count:
            if offset >= data.len():
                break

            val kind = data[offset]
            offset = offset + 1

            # Deserialize full template based on kind
            val result = self.deserialize_full_template(kind, data, offset)
            if result == nil:
                return false
            val template = result.0
            offset = result.1

            val name = template.name()
            self.template_cache[name] = template

        deferred_clear_error()
        true

    fn deserialize_full_template(kind: u8, data: [u8], start_offset: i64) -> (GenericTemplate, i64)?:
        """Deserialize a full template from binary data.

        Reads the complete AST node including all fields, body, params, bindings.
        Returns the template and the new offset after reading, or nil with error set.

        ROBUSTNESS: Validates data bounds before each read.
        """
        match kind:
            0:  # Function
                val result = deserialize_function_def(data, start_offset)
                if result == nil:
                    return nil
                (GenericTemplate.Function(result.0), result.1)
            1:  # Struct
                val result = deserialize_struct_def(data, start_offset)
                if result == nil:
                    return nil
                (GenericTemplate.Struct(result.0), result.1)
            2:  # Class
                val result = deserialize_class_def(data, start_offset)
                if result == nil:
                    return nil
                (GenericTemplate.Class(result.0), result.1)
            3:  # Enum
                val result = deserialize_enum_def(data, start_offset)
                if result == nil:
                    return nil
                (GenericTemplate.Enum(result.0), result.1)
            4:  # Trait
                val result = deserialize_trait_def(data, start_offset)
                if result == nil:
                    return nil
                (GenericTemplate.Trait(result.0), result.1)
            _:
                deferred_set_error("Unknown template kind: {kind}")
                nil

    # ========================================================================
    # Instantiation
    # ========================================================================

    me instantiate_function(name: text, type_args: [ConcreteType]) -> FunctionDef?:
        """Instantiate a function template with concrete type arguments.

        Args:
            name: Template name (e.g., "map", "List::push")
            type_args: Concrete types (e.g., [Int, String])

        Returns:
            Specialized function definition, or nil with error set

        ROBUSTNESS:
        - Checks cache first (avoid re-compilation)
        - Validates type arg count matches template params
        - Returns nil if template not found
        - Tracks specialization in metadata
        """
        val key = SpecializationKey.new(name, type_args)

        # Check cache
        val cached = self.specialization_cache.get(key)
        if cached != nil:
            match cached:
                CompiledCode.Function(func): return func
                _: pass

        # Get template
        val template = self.template_cache.get(name)
        if template == nil:
            deferred_set_error("Template not found: {name}")
            return nil

        val func_template = template.as_function()
        if func_template == nil:
            return nil

        # Validate type arg count
        if type_args.len() != func_template.generic_params.len():
            deferred_set_error(
                "Type argument count mismatch: expected {func_template.generic_params.len()}, got {type_args.len()}"
            )
            return nil

        # Perform real specialization: substitute type params throughout definition
        val specialized = _specialize_function_def(func_template, type_args)

        # Cache result
        self.specialization_cache[key] = CompiledCode.Function(specialized)

        # Track in metadata
        val bindings = _build_type_bindings(func_template.generic_params, type_args)
        val entry = SpecializationEntry.new(
            type_args: type_args,
            mangled_name: specialized.name,
            bindings: bindings
        )
        if not self.metadata.functions.contains_key(name):
            self.metadata.functions[name] = GenericFunctionMeta.new(name, func_template.generic_params)
        self.metadata.functions[name].add_specialization(entry)

        deferred_clear_error()
        specialized

    me instantiate_struct(name: text, type_args: [ConcreteType]) -> StructDef?:
        """Instantiate a struct template with concrete type arguments.

        Args:
            name: Template name (e.g., "Pair", "Node")
            type_args: Concrete types (e.g., [Int, String])

        Returns:
            Specialized struct definition, or nil with error set

        ROBUSTNESS:
        - Checks cache first (avoid re-compilation)
        - Validates type arg count matches template params
        - Substitutes type params in all fields
        - Tracks specialization in metadata
        """
        val key = SpecializationKey.new(name, type_args)

        # Check cache
        val cached = self.specialization_cache.get(key)
        if cached != nil:
            match cached:
                CompiledCode.Struct(s): return s
                _: pass

        # Get template
        val template = self.template_cache.get(name)
        if template == nil:
            deferred_set_error("Template not found: {name}")
            return nil

        val struct_template = template.as_struct()
        if struct_template == nil:
            return nil

        # Validate type arg count
        if type_args.len() != struct_template.generic_params.len():
            deferred_set_error(
                "Type argument count mismatch: expected {struct_template.generic_params.len()}, got {type_args.len()}"
            )
            return nil

        # Perform real specialization: substitute type params throughout definition
        val specialized = _specialize_struct_def(struct_template, type_args)

        # Cache result
        self.specialization_cache[key] = CompiledCode.Struct(specialized)

        # Track in metadata
        val bindings = _build_type_bindings(struct_template.generic_params, type_args)
        val entry = SpecializationEntry.new(
            type_args: type_args,
            mangled_name: specialized.name,
            bindings: bindings
        )
        if not self.metadata.structs.contains_key(name):
            self.metadata.structs[name] = GenericStructMeta.new(name, struct_template.generic_params)
        self.metadata.structs[name].add_specialization(entry)

        deferred_clear_error()
        specialized

    me instantiate_class(name: text, type_args: [ConcreteType]) -> ClassDef?:
        """Instantiate a class template with concrete type arguments.

        Args:
            name: Template name (e.g., "Container", "TreeNode")
            type_args: Concrete types (e.g., [Int])

        Returns:
            Specialized class definition, or nil with error set

        ROBUSTNESS:
        - Checks cache first (avoid re-compilation)
        - Validates type arg count matches template params
        - Substitutes type params in all fields and methods
        - Tracks specialization in metadata
        """
        val key = SpecializationKey.new(name, type_args)

        # Check cache
        val cached = self.specialization_cache.get(key)
        if cached != nil:
            match cached:
                CompiledCode.Class(c): return c
                _: pass

        # Get template
        val template = self.template_cache.get(name)
        if template == nil:
            deferred_set_error("Template not found: {name}")
            return nil

        val class_template = template.as_class()
        if class_template == nil:
            return nil

        # Validate type arg count
        if type_args.len() != class_template.generic_params.len():
            deferred_set_error(
                "Type argument count mismatch: expected {class_template.generic_params.len()}, got {type_args.len()}"
            )
            return nil

        # Perform real specialization: substitute type params throughout definition
        val specialized = _specialize_class_def(class_template, type_args)

        # Cache result
        self.specialization_cache[key] = CompiledCode.Class(specialized)

        # Track in metadata
        val bindings = _build_type_bindings(class_template.generic_params, type_args)
        val entry = SpecializationEntry.new(
            type_args: type_args,
            mangled_name: specialized.name,
            bindings: bindings
        )
        if not self.metadata.classes.contains_key(name):
            self.metadata.classes[name] = GenericClassMeta.new(name, class_template.generic_params)
        self.metadata.classes[name].add_specialization(entry)

        deferred_clear_error()
        specialized

    me instantiate_enum(name: text, type_args: [ConcreteType]) -> EnumDef?:
        """Instantiate an enum template with concrete type arguments.

        Args:
            name: Template name (e.g., "Option", "Result")
            type_args: Concrete types (e.g., [Int] for Option<Int>)

        Returns:
            Specialized enum definition, or nil with error set

        ROBUSTNESS:
        - Checks cache first (avoid re-compilation)
        - Validates type arg count matches template params
        - Substitutes type params in all variants
        - Tracks specialization in metadata
        """
        val key = SpecializationKey.new(name, type_args)

        # Check cache
        val cached = self.specialization_cache.get(key)
        if cached != nil:
            match cached:
                CompiledCode.Enum(e): return e
                _: pass

        # Get template
        val template = self.template_cache.get(name)
        if template == nil:
            deferred_set_error("Template not found: {name}")
            return nil

        val enum_template = template.as_enum()
        if enum_template == nil:
            return nil

        # Validate type arg count
        if type_args.len() != enum_template.generic_params.len():
            deferred_set_error(
                "Type argument count mismatch: expected {enum_template.generic_params.len()}, got {type_args.len()}"
            )
            return nil

        # Perform real specialization: substitute type params throughout definition
        val specialized = _specialize_enum_def(enum_template, type_args)

        # Cache result
        self.specialization_cache[key] = CompiledCode.Enum(specialized)

        # Track in metadata
        val bindings = _build_type_bindings(enum_template.generic_params, type_args)
        val entry = SpecializationEntry.new(
            type_args: type_args,
            mangled_name: specialized.name,
            bindings: bindings
        )
        if not self.metadata.enums.contains_key(name):
            self.metadata.enums[name] = GenericEnumMeta.new(name, enum_template.generic_params)
        self.metadata.enums[name].add_specialization(entry)

        deferred_clear_error()
        specialized

    # ========================================================================
    # Introspection
    # ========================================================================

    fn template_names() -> [text]:
        """Get all template names in the cache."""
        var names: [text] = []
        for name in self.template_cache.keys():
            names.push(name)
        names

    fn specialization_count() -> i64:
        """Get the number of cached specializations."""
        self.specialization_cache.len()

    me clear_cache():
        """Clear the specialization cache (keep templates)."""
        self.specialization_cache = {}

    me register_template(template: GenericTemplate):
        """Register a generic template directly (not from SMF).

        Useful for in-process monomorphization where templates are
        already available as AST nodes.
        """
        val name = template.name()
        self.template_cache[name] = template

    me instantiate(name: text, type_args: [ConcreteType]) -> CompiledCode?:
        """Instantiate any template by name with concrete type arguments.

        Automatically determines the template kind and delegates to the
        appropriate instantiation method.

        Returns:
            CompiledCode wrapping the specialized definition, or nil with error set
        """
        val template = self.template_cache.get(name)
        if template == nil:
            deferred_set_error("Template not found: {name}")
            return nil

        match template:
            GenericTemplate.Function(_):
                val result = self.instantiate_function(name, type_args)
                if result == nil:
                    return nil
                CompiledCode.Function(result)
            GenericTemplate.Struct(_):
                val result = self.instantiate_struct(name, type_args)
                if result == nil:
                    return nil
                CompiledCode.Struct(result)
            GenericTemplate.Class(_):
                val result = self.instantiate_class(name, type_args)
                if result == nil:
                    return nil
                CompiledCode.Class(result)
            GenericTemplate.Enum(_):
                val result = self.instantiate_enum(name, type_args)
                if result == nil:
                    return nil
                CompiledCode.Enum(result)
            GenericTemplate.Trait(_):
                deferred_set_error("Trait instantiation not supported: {name}")
                nil

    fn has_template(name: text) -> bool:
        """Check if a template is registered."""
        self.template_cache.contains_key(name)

    fn has_specialization(name: text, type_args: [ConcreteType]) -> bool:
        """Check if a specific specialization is already cached."""
        val key = SpecializationKey.new(name, type_args)
        self.specialization_cache.contains_key(key)

    fn metadata() -> MonomorphizationMetadata:
        """Get the monomorphization metadata."""
        self.metadata

    fn get_stats() -> DeferredMonoStats:
        """Get statistics about deferred monomorphization."""
        DeferredMonoStats(
            template_count: self.template_cache.len(),
            specialization_count: self.specialization_cache.len(),
            mode: self.mode
        )

# ============================================================================
# Binary Deserialization Helpers
# ============================================================================

fn read_u32(data: [u8], offset: i64) -> (i64, i64)?:
    """Read a u32 from data at offset. Returns (value, new_offset)."""
    if offset + 4 > data.len():
        deferred_set_error("Unexpected end of data reading u32 at offset {offset}")
        return nil
    val value = ((data[offset] as i64) +
                ((data[offset + 1] as i64) << 8) +
                ((data[offset + 2] as i64) << 16) +
                ((data[offset + 3] as i64) << 24))
    (value, offset + 4)

fn read_text_field(data: [u8], offset: i64) -> (text, i64)?:
    """Read a length-prefixed text field. Returns (text, new_offset)."""
    val len_result = read_u32(data, offset)
    if len_result == nil:
        return nil
    val text_len = len_result.0
    val pos = len_result.1
    if pos + text_len > data.len():
        deferred_set_error("Unexpected end of data reading text at offset {pos}")
        return nil
    val text_bytes = data[pos..(pos + text_len)]
    val text_value = String.from_utf8(text_bytes)
    if text_value == nil:
        return nil
    (text_value, pos + text_len)

fn read_optional_text_field(data: [u8], offset: i64) -> (text?, i64)?:
    """Read an optional text field (0x01 + data or 0x00 for nil)."""
    if offset >= data.len():
        deferred_set_error("Unexpected end of data reading optional at offset {offset}")
        return nil
    val tag = data[offset]
    if tag == 0x01:
        val result = read_text_field(data, offset + 1)
        if result == nil:
            return nil
        (result.0, result.1)
    else:
        (nil, offset + 1)

fn read_text_list(data: [u8], offset: i64) -> ([text], i64)?:
    """Read a list of length-prefixed text items. Returns (list, new_offset)."""
    val count_result = read_u32(data, offset)
    if count_result == nil:
        return nil
    val count = count_result.0
    var pos = count_result.1
    var items: [text] = []
    for _ in 0..count:
        val item_result = read_text_field(data, pos)
        if item_result == nil:
            return nil
        items.push(item_result.0)
        pos = item_result.1
    (items, pos)

fn read_text_dict(data: [u8], offset: i64) -> ({text: text}, i64)?:
    """Read a text-to-text dictionary. Returns (dict, new_offset)."""
    val count_result = read_u32(data, offset)
    if count_result == nil:
        return nil
    val count = count_result.0
    var pos = count_result.1
    var dict: {text: text} = {}
    for _ in 0..count:
        val key_result = read_text_field(data, pos)
        if key_result == nil:
            return nil
        pos = key_result.1
        val value_result = read_text_field(data, pos)
        if value_result == nil:
            return nil
        pos = value_result.1
        dict[key_result.0] = value_result.0
    (dict, pos)

fn read_generic_params(data: [u8], offset: i64) -> ([text], i64)?:
    """Read generic params: u8 count + length-prefixed strings."""
    if offset >= data.len():
        deferred_set_error("Unexpected end of data reading param count at offset {offset}")
        return nil
    val param_count = data[offset] as i64
    var pos = offset + 1
    var params: [text] = []
    for _ in 0..param_count:
        val param_result = read_text_field(data, pos)
        if param_result == nil:
            return nil
        params.push(param_result.0)
        pos = param_result.1
    (params, pos)

fn deserialize_function_def(data: [u8], offset: i64) -> (FunctionDef, i64)?:
    """Deserialize a FunctionDef from binary data."""
    # Name
    val name_result = read_text_field(data, offset)
    if name_result == nil:
        return nil
    val name = name_result.0
    var pos = name_result.1

    # Generic params
    val gp_result = read_generic_params(data, pos)
    if gp_result == nil:
        return nil
    val generic_params = gp_result.0
    pos = gp_result.1

    # Params
    val params_result = read_text_list(data, pos)
    if params_result == nil:
        return nil
    val params = params_result.0
    pos = params_result.1

    # Return type
    val ret_result = read_optional_text_field(data, pos)
    if ret_result == nil:
        return nil
    val return_type = ret_result.0
    pos = ret_result.1

    # Body
    val body_result = read_text_list(data, pos)
    if body_result == nil:
        return nil
    val body = body_result.0
    pos = body_result.1

    # Flags
    if pos >= data.len():
        deferred_set_error("Unexpected end of data reading function flags")
        return nil
    val is_generic = data[pos] == 0x01
    pos = pos + 1

    # Specialization of
    val spec_result = read_optional_text_field(data, pos)
    if spec_result == nil:
        return nil
    val specialization_of = spec_result.0
    pos = spec_result.1

    # Type bindings
    val bindings_result = read_text_dict(data, pos)
    if bindings_result == nil:
        return nil
    val type_bindings = bindings_result.0
    pos = bindings_result.1

    val func_def = FunctionDef(
        name: name,
        generic_params: generic_params,
        params: params,
        return_type: return_type,
        body: body,
        is_generic_template: is_generic,
        specialization_of: specialization_of,
        type_bindings: type_bindings
    )
    (func_def, pos)

fn deserialize_struct_def(data: [u8], offset: i64) -> ((StructDef, i64))\n            return nil:
    """Deserialize a StructDef from binary data."""
    # Name
    val name_result = read_text_field(data, offset)?
    val name = name_result.0
    var pos = name_result.1

    # Generic params
    val gp_result = read_generic_params(data, pos)?
    val generic_params = gp_result.0
    pos = gp_result.1

    # Fields
    val fields_result = read_text_list(data, pos)?
    val fields = fields_result.0
    pos = fields_result.1

    # Flags
    if pos >= data.len():
        deferred_set_error("Unexpected end of data reading struct flags"))
    val is_generic = data[pos] == 0x01
    pos = pos + 1

    # Specialization of
    val spec_result = read_optional_text_field(data, pos)?
    val specialization_of = spec_result.0
    pos = spec_result.1

    # Type bindings
    val bindings_result = read_text_dict(data, pos)?
    val type_bindings = bindings_result.0
    pos = bindings_result.1

    val struct_def = StructDef(
        name: name,
        generic_params: generic_params,
        fields: fields,
        is_generic_template: is_generic,
        specialization_of: specialization_of,
        type_bindings: type_bindings
    )
    ((struct_def, pos))

fn deserialize_class_def(data: [u8], offset: i64) -> ((ClassDef, i64))\n            return nil:
    """Deserialize a ClassDef from binary data."""
    # Name
    val name_result = read_text_field(data, offset)?
    val name = name_result.0
    var pos = name_result.1

    # Generic params
    val gp_result = read_generic_params(data, pos)?
    val generic_params = gp_result.0
    pos = gp_result.1

    # Fields
    val fields_result = read_text_list(data, pos)?
    val fields = fields_result.0
    pos = fields_result.1

    # Methods
    val methods_result = read_text_list(data, pos)?
    val methods = methods_result.0
    pos = methods_result.1

    # Flags
    if pos >= data.len():
        deferred_set_error("Unexpected end of data reading class flags"))
    val is_generic = data[pos] == 0x01
    pos = pos + 1

    # Specialization of
    val spec_result = read_optional_text_field(data, pos)?
    val specialization_of = spec_result.0
    pos = spec_result.1

    # Type bindings
    val bindings_result = read_text_dict(data, pos)?
    val type_bindings = bindings_result.0
    pos = bindings_result.1

    val class_def = ClassDef(
        name: name,
        generic_params: generic_params,
        fields: fields,
        methods: methods,
        is_generic_template: is_generic,
        specialization_of: specialization_of,
        type_bindings: type_bindings
    )
    ((class_def, pos))

fn deserialize_enum_def(data: [u8], offset: i64) -> ((EnumDef, i64))\n            return nil:
    """Deserialize an EnumDef from binary data."""
    # Name
    val name_result = read_text_field(data, offset)?
    val name = name_result.0
    var pos = name_result.1

    # Generic params
    val gp_result = read_generic_params(data, pos)?
    val generic_params = gp_result.0
    pos = gp_result.1

    # Variants
    val variants_result = read_text_list(data, pos)?
    val variants = variants_result.0
    pos = variants_result.1

    # Flags
    if pos >= data.len():
        deferred_set_error("Unexpected end of data reading enum flags"))
    val is_generic = data[pos] == 0x01
    pos = pos + 1

    # Specialization of
    val spec_result = read_optional_text_field(data, pos)?
    val specialization_of = spec_result.0
    pos = spec_result.1

    # Type bindings
    val bindings_result = read_text_dict(data, pos)?
    val type_bindings = bindings_result.0
    pos = bindings_result.1

    val enum_def = EnumDef(
        name: name,
        generic_params: generic_params,
        variants: variants,
        is_generic_template: is_generic,
        specialization_of: specialization_of,
        type_bindings: type_bindings
    )
    ((enum_def, pos))

fn deserialize_trait_def(data: [u8], offset: i64) -> ((TraitDef, i64))\n            return nil:
    """Deserialize a TraitDef from binary data."""
    # Name
    val name_result = read_text_field(data, offset)?
    val name = name_result.0
    var pos = name_result.1

    # Generic params
    val gp_result = read_generic_params(data, pos)?
    val generic_params = gp_result.0
    pos = gp_result.1

    # Methods
    val methods_result = read_text_list(data, pos)?
    val methods = methods_result.0
    pos = methods_result.1

    # Flags
    if pos >= data.len():
        deferred_set_error("Unexpected end of data reading trait flags"))
    val is_generic = data[pos] == 0x01
    pos = pos + 1

    val trait_def = TraitDef(
        name: name,
        generic_params: generic_params,
        methods: methods,
        is_generic_template: is_generic
    )
    ((trait_def, pos))

# ============================================================================
# Statistics
# ============================================================================

struct DeferredMonoStats:
    """Statistics about deferred monomorphization."""
    template_count: i64             # Number of loaded templates
    specialization_count: i64       # Number of cached specializations
    mode: InstantiationMode         # Instantiation mode

# ============================================================================
# Usage Example
# ============================================================================
#
# # Create deferred monomorphizer for link-time instantiation
# val mono = DeferredMonomorphizer.new(InstantiationMode.LinkTime)
#
# # Register templates directly (in-process)
# val pair_template = StructDef(
#     name: "Pair", generic_params: ["T", "U"],
#     fields: ["first: T", "second: U"],
#     is_generic_template: true, specialization_of: nil, type_bindings: {}
# )
# mono.register_template(GenericTemplate.Struct(pair_template))
#
# # Instantiate Pair<Int, String>
# val pair_int_str = mono.instantiate_struct("Pair", [ConcreteType.Int, ConcreteType.String])
# # Result: StructDef(name: "Pair$Int_String", fields: ["first: Int", "second: String"], ...)
#
# # Or load from SMF file
# mono.load_templates_from_smf("collections.smf")
#
# # Instantiate using generic API
# val result = mono.instantiate("Option", [ConcreteType.Int])
# # Result: CompiledCode.Enum(EnumDef(name: "Option$Int", variants: ["Some(Int)", "None"], ...))
#
# # Cache prevents re-compilation
# val same = mono.instantiate_struct("Pair", [ConcreteType.Int, ConcreteType.String])
# # Returns cached result (no re-substitution)
#
# # Check stats
# val stats = mono.get_stats()
# print "Loaded {stats.template_count} templates"
# print "Cached {stats.specialization_count} specializations"
#
# # Metadata tracks all specializations
# val meta = mono.metadata()
# print "Total specializations: {meta.total_specializations()}"
#
# ============================================================================
# Remaining Items
# ============================================================================
#
# 1. [done] Implement template serialization/deserialization (Phase 6)
# 2. [done] Implement full AST specialization (text-level type substitution)
# 3. [done] Track specializations in metadata
# 4. [pending] Add error recovery (partial specialization on error)
# 5. [pending] Add incremental compilation support
# 6. [pending] Add template invalidation on source change
# 7. [pending] Add parallel instantiation (for LinkTime mode)
# 8. [pending] Wire up binary file I/O for load_templates_from_smf
#
# ============================================================================
# Performance Notes
# ============================================================================
#
# - Template cache lookup: O(1)
# - Specialization cache lookup: O(1)
# - Instantiation: O(AST size) - same as Rust
# - SMF loading: O(file size) - placeholder for now
#
# Expected performance: Same as Rust (same algorithms)
#
# ============================================================================
# Robustness Checklist
# ============================================================================
#
# Memory Safety:
# - [x] No null pointers (Option<T> for cache lookups)
# - [x] No buffer overflows (bounds checks on deserialize)
#
# Error Handling:
# - [x] Returns nil with error (not panics)
# - [x] Validates magic bytes
# - [x] Validates type arg count
# - [x] Clear error messages
#
# Logic Correctness:
# - [x] Cache prevents re-compilation
# - [x] Type arg count validated
# - [x] Template not found returns error
# - [x] Type substitution is whole-word only (no partial matches)
# - [x] Mangled names are deterministic and unique
# - [x] Metadata tracks all specializations
# - [x] Specialization sets is_generic_template=false
# - [x] Specialization records specialization_of=original name
# - [x] Generic params cleared in specialized output
#
# Specialization Coverage:
# - [x] Function specialization (params, return type, body)
# - [x] Struct specialization (fields)
# - [x] Class specialization (fields, methods)
# - [x] Enum specialization (variants)
# - [x] Nested generic types in text (e.g., List<T> -> List<Int>)
# - [x] Multiple type parameters (e.g., Pair<T, U>)
# - [x] Optional return types handled
#
# Edge Cases:
# - [x] Empty SMF file (returns Ok with empty cache)
# - [x] Invalid magic (returns error)
# - [x] Wrong type arg count (returns error)
# - [x] Template not found (returns error)
# - [x] Cache hit (returns cached result)
# - [x] Type param name is substring of identifier (no false substitution)
# - [x] Empty type args (no-arg specialization)
