# Trait Coherence Checking
#
# Verifies trait implementation coherence: orphan rules, overlapping impls,
# blanket impl conflicts, and associated type consistency.
#
# Also contains type matching helpers: impls_overlap, type_has_params.

use compiler.hir.*
use compiler.core.lexer.*
use compiler.trait_impl.{ImplBlock}

export CoherenceError, ImplInfo, CoherenceChecker
export impls_overlap, type_has_params

# ============================================================================
# Coherence Errors
# ============================================================================

enum CoherenceError:
    OrphanImpl(trait_name: text, target_type: text, suggestion: text?)
    OverlappingImpl(trait_name: text, type1: text, type2: text)
    ConflictingAssociatedType(trait_name: text, target_type: text, type_name: text)
    BlanketImplConflict(trait_name: text, general: text, specific: text)

impl CoherenceError:
    fn message() -> text:
        match self:
            case OrphanImpl(tr, ty, sugg):
                val base = "Cannot implement foreign trait '{tr}' for foreign type '{ty}'"
                if sugg.?: "{base}\n\nSuggestion: {sugg.unwrap()}"
                else: base
            case OverlappingImpl(tr, t1, t2):
                "Overlapping implementations of trait '{tr}' for types '{t1}' and '{t2}'"
            case ConflictingAssociatedType(tr, ty, tn):
                "Conflicting associated type '{tn}' in trait '{tr}' for type '{ty}'"
            case BlanketImplConflict(tr, gen, spec):
                "Blanket implementation '{gen}' for trait '{tr}' conflicts with specific implementation '{spec}'"

# ============================================================================
# Impl Registry Entry
# ============================================================================

struct ImplInfo:
    target_type: text
    trait_name: text?
    generic_params: [text]
    is_blanket: bool
    is_default: bool
    associated_types: {text: text}

# ============================================================================
# Coherence Checker
# ============================================================================

class CoherenceChecker:
    """Checks trait implementation coherence rules."""
    local_traits: [text]
    local_types: [text]
    impls: {text: [ImplInfo]}       # trait_name -> list of impls

impl CoherenceChecker:
    static fn create() -> CoherenceChecker:
        CoherenceChecker(local_traits: [], local_types: [], impls: {})

    me register_trait(name: text):
        if not self.local_traits.contains(name):
            self.local_traits = self.local_traits.push(name)

    me register_type(name: text):
        if not self.local_types.contains(name):
            self.local_types = self.local_types.push(name)

    me register_impl(info: ImplInfo):
        val key = info.trait_name ?? "_no_trait_"
        if not self.impls.contains_key(key):
            self.impls[key] = []
        self.impls[key] = self.impls[key].push(info)

    me check_all() -> [CoherenceError]:
        """Run all coherence checks."""
        var errors: [CoherenceError] = []
        errors = errors.merge(self.check_orphan_rules())
        errors = errors.merge(self.check_overlapping_impls())
        errors = errors.merge(self.check_blanket_conflicts())
        errors

    fn check_orphan_rules() -> [CoherenceError]:
        """Orphan rule: at least one of trait or type must be local."""
        var errors: [CoherenceError] = []
        for (trait_name, impl_list) in self.impls:
            if trait_name == "_no_trait_":
                continue
            for info in impl_list:
                val trait_local = self.local_traits.contains(trait_name)
                val type_local = self.local_types.contains(info.target_type)
                if not trait_local and not type_local:
                    val suggestion = if self.local_types.?:
                        Some("Create a newtype wrapper in your module")
                    else:
                        nil
                    errors = errors.push(CoherenceError.OrphanImpl(
                        trait_name: trait_name, target_type: info.target_type,
                        suggestion: suggestion))
        errors

    fn check_overlapping_impls() -> [CoherenceError]:
        """Check for overlapping implementations of the same trait."""
        var errors: [CoherenceError] = []
        for (trait_name, impl_list) in self.impls:
            if trait_name == "_no_trait_":
                continue
            for i in 0..impl_list.len():
                for j in (i + 1)..impl_list.len():
                    val a = impl_list[i]
                    val b = impl_list[j]
                    if (not a.is_blanket and not b.is_blanket and
                       a.target_type == b.target_type):
                        errors = errors.push(CoherenceError.OverlappingImpl(
                            trait_name: trait_name,
                            type1: a.target_type, type2: b.target_type))
        errors

    fn check_blanket_conflicts() -> [CoherenceError]:
        """Check blanket impls don't conflict with specific ones."""
        var errors: [CoherenceError] = []
        for (trait_name, impl_list) in self.impls:
            val blankets = impl_list.filter(\i: i.is_blanket and not i.is_default)
            val specifics = impl_list.filter(\i: not i.is_blanket)
            for blanket in blankets:
                for specific in specifics:
                    if not specific.is_default:
                        errors = errors.push(CoherenceError.BlanketImplConflict(
                            trait_name: trait_name,
                            general: blanket.target_type,
                            specific: specific.target_type))
        errors

# ============================================================================
# Impl Overlap Detection (from traits.spl)
# ============================================================================

fn impls_overlap(impl1: ImplBlock, impl2: ImplBlock) -> bool:
    """Check if two impl blocks could overlap.

    Two impls overlap if there exists a concrete type that matches both.
    """
    val ty1 = impl1.for_type
    val ty2 = impl2.for_type

    match ty1.kind:
        case Named(symbol1, args1):
            match ty2.kind:
                case Named(symbol2, args2):
                    if symbol1 != symbol2:
                        return false

                    val has_params1 = type_has_params(ty1)
                    val has_params2 = type_has_params(ty2)

                    if not has_params1 and not has_params2:
                        return ty1 == ty2

                    # At least one has type parameters - conservative: assume overlap
                    true
                case _:
                    false
        case _:
            ty1 == ty2

fn type_has_params(ty: HirType) -> bool:
    """Check if a type contains type parameters."""
    match ty.kind:
        case TypeParam(_, _):
            true
        case Named(_, args):
            for arg in args:
                if type_has_params(arg):
                    return true
            false
        case Function(params, ret, _):
            for param in params:
                if type_has_params(param):
                    return true
            type_has_params(ret)
        case Tuple(elems):
            for elem in elems:
                if type_has_params(elem):
                    return true
            false
        case Array(elem, _):
            type_has_params(elem)
        case _:
            false
