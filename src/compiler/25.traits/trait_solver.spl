# Trait Solver
#
# Obligation-based trait constraint solving with associated type support.
# Split from traits.spl for modularity.

use compiler.hir.hir.*
use compiler.core.lexer.*
use compiler.traits.trait_def.{TraitDef, TraitBound, AssocTypeDef}
use compiler.traits.trait_impl.{ImplBlock}
use compiler.traits.trait_coherence.{impls_overlap}
use compiler.traits.trait_validation.{TraitError}
use compiler.traits.associated_types.{AssocTypeProjection, AssocTypeResolver}

# ============================================================================
# Obligation
# ============================================================================

struct Obligation:
    """A trait bound that must be proven during type checking.

    Created when:
    - Calling a function with trait bounds
    - Using a method that requires a trait
    - Satisfying a where clause

    Must be satisfied by finding an impl block.
    Optionally includes associated type constraints (e.g., Iterator<Item=i64>).
    """
    type_: HirType                  # The type that must implement the trait
    trait_: Symbol                  # The trait that must be implemented
    cause: ObligationCause          # Why this obligation was created
    span: Span                      # Source location
    assoc_type_constraints: Dict<text, HirType>  # Associated type constraints

impl Obligation:
    static fn create(ty: HirType, trait_: Symbol, cause: ObligationCause, span: Span) -> Obligation:
        """Create a new obligation without associated type constraints."""
        Obligation(
            type_: ty,
            trait_: trait_,
            cause: cause,
            span: span,
            assoc_type_constraints: {}
        )

    static fn with_assoc_constraints(ty: HirType, trait_: Symbol, cause: ObligationCause, span: Span, constraints: Dict<text, HirType>) -> Obligation:
        """Create an obligation with associated type constraints.

        Example: I: Iterator<Item=i64> creates an obligation with
        assoc_type_constraints = {"Item": i64}.
        """
        Obligation(
            type_: ty,
            trait_: trait_,
            cause: cause,
            span: span,
            assoc_type_constraints: constraints
        )

    fn has_assoc_constraints() -> bool:
        """Check if this obligation has associated type constraints."""
        not self.assoc_type_constraints.is_empty()

    fn description() -> text:
        """Get human-readable description."""
        var desc = "require {self.type_} : {self.trait_}"
        if self.has_assoc_constraints():
            var constraints: [text] = []
            for (name, _) in self.assoc_type_constraints:
                constraints = constraints.push("{name}=<type>")
            desc = "{desc}<{constraints.join(", ")}>"
        desc

enum ObligationCause:
    """Why an obligation was created (for error messages)."""
    FunctionCall(Symbol)            # From calling fn<T: Trait>
    MethodCall(Symbol, text)        # From calling method
    TraitBound(Symbol)              # From where clause
    FieldAccess(Symbol, text)       # From accessing field
    BuiltIn                         # From built-in constraint

impl ObligationCause:
    fn description() -> text:
        match self:
            case FunctionCall(name):
                "function call to {name}"
            case MethodCall(receiver, method):
                "method call {receiver}.{method}"
            case TraitBound(param):
                "trait bound on {param}"
            case FieldAccess(ty, field):
                "field access {ty}.{field}"
            case BuiltIn:
                "built-in constraint"

# ============================================================================
# Trait Solver
# ============================================================================

class TraitSolver:
    """Solves trait obligations by searching impl blocks.

    Algorithm (simplified Rust trait solver):
    1. Collect obligations from function calls and method calls
    2. For each obligation T: Trait:
       a. Search for impl Trait for T
       b. Check where clauses recursively
       c. Check associated type constraints if present
       d. Report error if no impl found
    3. Cache results to avoid duplicate work
    """
    # All known trait definitions
    traits: Dict<Symbol, TraitDef>

    # All known impl blocks (indexed by trait name)
    impls: Dict<Symbol, [ImplBlock]>

    # All known impl blocks (indexed by target type symbol)
    impls_by_type: Dict<Symbol, [ImplBlock]>

    # Cache of solved obligations: (type, trait) -> success
    cache: Dict<(HirType, Symbol), bool>

    # Current obligations to solve
    obligations: [Obligation]

    # Errors encountered during solving
    errors: [TraitError]

    # Associated type resolver
    assoc_resolver: AssocTypeResolver

impl TraitSolver:
    static fn create() -> TraitSolver:
        """Create a new trait solver."""
        TraitSolver(
            traits: {},
            impls: {},
            impls_by_type: {},
            cache: {},
            obligations: [],
            errors: [],
            assoc_resolver: AssocTypeResolver.create()
        )

    me add_trait(trait_def: TraitDef):
        """Register a trait definition."""
        self.traits[trait_def.name] = trait_def
        self.assoc_resolver.add_trait(trait_def)

    me add_impl(impl_block: ImplBlock):
        """Register an impl block.

        Indexes by both trait name and target type for efficient lookup.
        Also registers with the associated type resolver.
        """
        val trait_name = impl_block.trait_name

        # Index by trait name
        var impl_list_by_trait = if self.impls[trait_name].?:
            self.impls[trait_name]
        else:
            []
        impl_list_by_trait = impl_list_by_trait.push(impl_block)
        self.impls[trait_name] = impl_list_by_trait

        # Index by target type (extract symbol from Named type)
        match impl_block.for_type.kind:
            case Named(type_symbol, _):
                var impl_list_by_type = if self.impls_by_type[type_symbol].?:
                    self.impls_by_type[type_symbol]
                else:
                    []
                impl_list_by_type = impl_list_by_type.push(impl_block)
                self.impls_by_type[type_symbol] = impl_list_by_type
            case _: pass  # Skip non-named types for now

        # Register with associated type resolver
        self.assoc_resolver.add_impl(impl_block)

    me add_obligation(ty: HirType, trait_: Symbol, cause: ObligationCause, span: Span):
        """Add an obligation to solve."""
        val obligation = Obligation.create(ty, trait_, cause, span)
        self.obligations = self.obligations.push(obligation)

    fn has_obligations() -> bool:
        """Check if there are pending obligations."""
        not self.obligations.is_empty()

    me solve_all() -> Result<(), [TraitError]>:
        """Solve all pending obligations.

        Returns Ok if all obligations satisfied, Err with errors otherwise.
        """
        for obligation in self.obligations:
            match self.solve_obligation(obligation):
                case Err(err):
                    self.errors = self.errors.push(err)
                case _: pass

        # Clear obligations after solving
        self.obligations = []

        if self.errors.is_empty():
            Ok(())
        else:
            val errors = self.errors
            self.errors = []  # Clear for next round
            Err(errors)

    me solve_obligation(obligation: Obligation) -> Result<(), TraitError>:
        """Solve a single obligation."""
        val ty = obligation.type_
        val trait_ = obligation.trait_

        # Check cache (only for obligations without assoc constraints)
        val cache_key = (ty, trait_)
        if not obligation.has_assoc_constraints():
            if self.cache[cache_key].?:
                if self.cache[cache_key]:
                    return Ok(())
                else:
                    return Err(TraitError.Unsatisfied(obligation))

        # Search for impl
        match self.find_impl(ty, trait_):
            case Some(impl_block):
                # Check where clauses recursively
                for bound in impl_block.where_clause:
                    match self.solve_trait_bound(bound, obligation.span):
                        case Err(e):
                            self.cache[cache_key] = false
                            return Err(e)
                        case _: pass

                # Check supertrait obligations
                match self.check_supertraits(ty, trait_, obligation.span):
                    case Err(e):
                        self.cache[cache_key] = false
                        return Err(e)
                    case _: pass

                # Check associated type constraints
                if obligation.has_assoc_constraints():
                    match self.check_assoc_type_constraints(obligation, impl_block):
                        case Err(e):
                            self.cache[cache_key] = false
                            return Err(e)
                        case _: pass

                # Success - cache it
                self.cache[cache_key] = true
                Ok(())

            case nil:
                # No impl found - cache failure
                self.cache[cache_key] = false
                Err(TraitError.Unsatisfied(obligation))

    fn find_impl(ty: HirType, trait_: Symbol) -> ImplBlock?:
        """Find impl block for type and trait."""
        if not self.impls[trait_].?:
            return nil

        val impl_list = self.impls[trait_]
        for impl_block in impl_list:
            if impl_block.matches_type(ty):
                return Some(impl_block)

        nil

    me solve_trait_bound(bound: TraitBound, span: Span) -> Result<(), TraitError>:
        """Solve a trait bound from a where clause."""
        val ty = HirType(
            kind: HirTypeKind.TypeParam(bound.type_param, []),
            span: bound.span
        )

        val cause = ObligationCause.TraitBound(bound.type_param)
        self.add_obligation(ty, bound.trait_name, cause, span)

        Ok(())

    me check_supertraits(ty: HirType, trait_: Symbol, span: Span) -> Result<(), TraitError>:
        """Check that type implements all supertraits of the given trait."""
        if not self.traits[trait_].?:
            return Ok(())

        val trait_def = self.traits[trait_]

        for supertrait_symbol in trait_def.supertraits:
            val cause = ObligationCause.TraitBound(trait_)
            val supertrait_obligation = Obligation.create(ty, supertrait_symbol, cause, span)

            match self.solve_obligation(supertrait_obligation):
                case Err(e):
                    return Err(e)
                case _: pass

        Ok(())

    me check_assoc_type_constraints(obligation: Obligation, impl_block: ImplBlock) -> Result<(), TraitError>:
        """Check that an impl block satisfies associated type constraints.

        For an obligation like T: Iterator<Item=i64>, verifies that
        the impl's associated type for 'Item' matches i64.
        """
        for (assoc_name, expected_type) in obligation.assoc_type_constraints:
            val actual_type = impl_block.get_assoc_type_impl(assoc_name)
            if not actual_type.?:
                # Associated type not specified in impl - check for default
                return Err(TraitError.Unsatisfied(obligation))

            # Compare the actual type with the expected type
            val actual = actual_type.unwrap()
            if actual.kind != expected_type.kind:
                return Err(TraitError.Unsatisfied(obligation))

        Ok(())

    me add_obligation_with_assoc(ty: HirType, trait_: Symbol, cause: ObligationCause, span: Span, constraints: Dict<text, HirType>):
        """Add an obligation with associated type constraints."""
        val obligation = Obligation.with_assoc_constraints(ty, trait_, cause, span, constraints)
        self.obligations = self.obligations.push(obligation)

    fn resolve_assoc_type(ty: HirType, trait_: Symbol, assoc_name: text) -> HirType?:
        """Resolve an associated type for a concrete type and trait.

        Example: resolve_assoc_type(Range, Iterator, "Item") -> i64
        """
        match self.find_impl(ty, trait_):
            case Some(impl_block):
                impl_block.get_assoc_type_impl(assoc_name)
            case nil:
                nil

    fn get_assoc_resolver() -> AssocTypeResolver:
        """Get the associated type resolver for external use."""
        self.assoc_resolver

    fn normalize_type(ty: HirType) -> HirType:
        """Normalize a type by resolving all associated type projections."""
        self.assoc_resolver.normalize(ty)

    fn get_trait(name: Symbol) -> TraitDef?:
        """Get trait definition by name."""
        self.traits[name]

    fn get_impls_for_type(type_symbol: Symbol) -> [ImplBlock]:
        """Get all impl blocks for a given type."""
        if self.impls_by_type[type_symbol].?:
            self.impls_by_type[type_symbol]
        else:
            []

    fn get_impls_for_trait(trait_name: Symbol) -> [ImplBlock]:
        """Get all impl blocks for a given trait."""
        if self.impls[trait_name].?:
            self.impls[trait_name]
        else:
            []

    fn find_impl_for_type_and_trait(type_symbol: Symbol, trait_name: Symbol) -> ImplBlock?:
        """Find specific impl block for (type, trait) pair."""
        val impls_for_type = self.get_impls_for_type(type_symbol)
        for impl_block in impls_for_type:
            if impl_block.trait_name == trait_name:
                return Some(impl_block)
        nil

    me check_coherence():
        """Check coherence rules (no overlapping impls)."""
        for (trait_name, impl_list) in self.impls:
            for i in 0..impl_list.len():
                for j in (i + 1)..impl_list.len():
                    val impl1 = impl_list[i]
                    val impl2 = impl_list[j]

                    if impls_overlap(impl1, impl2):
                        val error = TraitError.Overlapping(
                            trait_name,
                            impl1.for_type,
                            impl2.span
                        )
                        self.errors = self.errors.push(error)

export Obligation, ObligationCause, TraitSolver

