# Trait Impl Blocks
#
# Implementation blocks for traits and type matching.
# Split from traits.spl for modularity.

use compiler.hir.hir.*
use compiler.core.lexer.*
use compiler.traits.trait_def.{TraitBound, TraitDef, AssocTypeDef}

# ============================================================================
# Associated Type Implementation
# ============================================================================

struct AssocTypeImpl:
    """Implementation of an associated type in an impl block.

    Example:
        impl Iterator for Range:
            type Item = i64  # AssocTypeImpl(name: "Item", concrete_type: i64)
    """
    name: text                      # Associated type name (e.g., "Item")
    concrete_type: HirType          # The concrete type assigned (e.g., i64)

impl AssocTypeImpl:
    static fn create(name: text, concrete_type: HirType) -> AssocTypeImpl:
        """Create a new associated type implementation."""
        AssocTypeImpl(
            name: name,
            concrete_type: concrete_type
        )

    fn to_string() -> text:
        """Get string representation."""
        "type {self.name} = <type>"

# ============================================================================
# Impl Block
# ============================================================================

struct ImplBlock:
    """Implementation of a trait for a specific type.

    Example:
        impl Iterator for Range:
            type Item = i64
            fn next() -> i64?:
                ...
    """
    trait_name: Symbol              # Which trait is being implemented
    for_type: HirType               # Which type is implementing the trait
    type_params: [Symbol]           # Generic parameters (impl<T> Trait for Vec<T>)
    where_clause: [TraitBound]      # Where T: Trait constraints
    methods: [HirFunction]          # Method implementations
    assoc_type_impls: Dict<text, AssocTypeImpl>  # Associated type implementations
    span: Span

impl ImplBlock:
    static fn create(trait_name: Symbol, for_type: HirType, span: Span) -> ImplBlock:
        """Create a new impl block."""
        ImplBlock(
            trait_name: trait_name,
            for_type: for_type,
            type_params: [],
            where_clause: [],
            methods: [],
            assoc_type_impls: {},
            span: span
        )

    fn has_method(method_name: text) -> bool:
        """Check if impl has a method with given name."""
        for method in self.methods:
            if method.name == method_name:
                return true
        false

    fn get_method(method_name: text) -> HirFunction?:
        """Get method implementation by name."""
        for method in self.methods:
            if method.name == method_name:
                return Some(method)
        nil

    fn matches_type(ty: HirType) -> bool:
        """Check if this impl matches the given type.

        Handles generic matching:
        - impl<T> Display for Vec<T> matches Vec<i64>
        - impl Display for Point matches Point

        Returns true if the impl can be instantiated to match ty.
        """
        match_types(self.for_type, ty)

    me add_assoc_type_impl(name: text, concrete_type: HirType):
        """Add an associated type implementation.

        Example:
            impl_block.add_assoc_type_impl("Item", int_type)
        """
        val assoc_impl = AssocTypeImpl.create(name, concrete_type)
        self.assoc_type_impls[name] = assoc_impl

    fn get_assoc_type_impl(name: text) -> HirType?:
        """Get the concrete type for an associated type implementation.

        Returns the concrete type if this impl specifies the associated type,
        nil otherwise.
        """
        if self.assoc_type_impls.contains_key(name):
            Some(self.assoc_type_impls[name].concrete_type)
        else:
            nil

    fn has_assoc_type_impl(name: text) -> bool:
        """Check if this impl specifies an associated type."""
        self.assoc_type_impls.contains_key(name)

    fn validate_assoc_types(trait_def: TraitDef) -> [text]:
        """Validate that all required associated types are implemented.

        Returns a list of error messages. Empty list means validation passed.

        Checks:
        1. All non-default associated types in the trait must be specified
        2. No associated types that don't exist in the trait
        """
        var errors: [text] = []

        # Check that all required associated types are implemented
        val required = trait_def.required_assoc_types()
        for assoc in required:
            if not self.has_assoc_type_impl(assoc.name):
                errors = errors.push(
                    "missing associated type '{assoc.name}' in impl of '{trait_def.name.name}' for type"
                )

        # Check that no extra associated types are specified
        for (name, _) in self.assoc_type_impls:
            if not trait_def.has_assoc_type(name):
                errors = errors.push(
                    "associated type '{name}' does not exist in trait '{trait_def.name.name}'"
                )

        errors

# ============================================================================
# Generic Type Matching (Phase B.3.1)
# ============================================================================

fn match_types(pattern: HirType, concrete: HirType) -> bool:
    """Check if a type pattern matches a concrete type.

    Handles generic matching where pattern may contain type parameters.

    Examples:
    - match_types(Vec<T>, Vec<i64>) -> true (T can be i64)
    - match_types(Point, Point) -> true
    - match_types(Vec<T>, Point) -> false

    Algorithm:
    - If pattern is TypeParam, always matches (can be anything)
    - If both are Named, check name matches and recursively check args
    - Otherwise, check structural equality
    """
    match pattern.kind:
        case TypeParam(_, _):
            # Type parameter matches any concrete type
            true

        case Named(pattern_symbol, pattern_args):
            match concrete.kind:
                case Named(concrete_symbol, concrete_args):
                    # Check if symbols match
                    if pattern_symbol != concrete_symbol:
                        return false

                    # Check if argument counts match
                    if pattern_args.len() != concrete_args.len():
                        return false

                    # Recursively check each type argument
                    for i in 0..pattern_args.len():
                        if not match_types(pattern_args[i], concrete_args[i]):
                            return false

                    true
                case _:
                    false

        case Function(pattern_params, pattern_ret, _):
            match concrete.kind:
                case Function(concrete_params, concrete_ret, _):
                    # Check parameter count
                    if pattern_params.len() != concrete_params.len():
                        return false

                    # Check each parameter
                    for i in 0..pattern_params.len():
                        if not match_types(pattern_params[i], concrete_params[i]):
                            return false

                    # Check return type
                    match_types(pattern_ret, concrete_ret)
                case _:
                    false

        case Tuple(pattern_elems):
            match concrete.kind:
                case Tuple(concrete_elems):
                    if pattern_elems.len() != concrete_elems.len():
                        return false

                    for i in 0..pattern_elems.len():
                        if not match_types(pattern_elems[i], concrete_elems[i]):
                            return false

                    true
                case _:
                    false

        case Array(pattern_elem, pattern_size):
            match concrete.kind:
                case Array(concrete_elem, concrete_size):
                    # Check sizes match (if both specified)
                    if pattern_size.? and concrete_size.?:
                        if pattern_size.unwrap() != concrete_size.unwrap():
                            return false

                    # Check element types match
                    match_types(pattern_elem, concrete_elem)
                case _:
                    false

        case Projection(pattern_base, pattern_assoc):
            match concrete.kind:
                case Projection(concrete_base, concrete_assoc):
                    if pattern_assoc != concrete_assoc:
                        return false
                    match_types(pattern_base, concrete_base)
                case _:
                    false

        case _:
            # For other types, use structural equality
            pattern.kind == concrete.kind

export AssocTypeImpl, ImplBlock, match_types
