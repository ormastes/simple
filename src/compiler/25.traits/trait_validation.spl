# Trait Validation & Built-in Traits
#
# Trait error types and built-in trait definitions.
# Split from traits.spl for modularity.

use compiler.hir.*
use compiler.core.lexer.*
use compiler.trait_def.{TraitDef, MethodSignature}

# ============================================================================
# Trait Errors
# ============================================================================

enum TraitError:
    """Errors from trait resolution."""
    Unsatisfied(obligation: Obligation)
    Ambiguous(type_: HirType, trait_: Symbol, candidates: [ImplBlock])
    Overlapping(trait_: Symbol, type_: HirType, span: Span)
    MissingMethod(trait_: Symbol, method: text, type_: HirType, span: Span)
    CyclicBound(type_param: Symbol, span: Span)
    UndefinedTrait(name: Symbol, span: Span)

impl TraitError:
    fn message() -> text:
        """Get human-readable error message."""
        match self:
            case Unsatisfied(obligation):
                "trait bound not satisfied: {obligation.type_} does not implement {obligation.trait_}\n  required by {obligation.cause.description()}"

            case Ambiguous(ty, trait_, candidates):
                "ambiguous trait impl: {candidates.len()} candidates for {ty} : {trait_}"

            case Overlapping(trait_, ty, _):
                "overlapping impls for {trait_} for {ty}"

            case MissingMethod(trait_, method, ty, _):
                "missing method '{method}' in impl {trait_} for {ty}"

            case CyclicBound(param, _):
                "cyclic trait bound on type parameter {param}"

            case UndefinedTrait(name, _):
                "undefined trait: {name}"

    fn span() -> Span:
        """Get source span for error."""
        match self:
            case Unsatisfied(obligation): obligation.span
            case Ambiguous(ty, _, _): ty.span
            case Overlapping(_, _, span): span
            case MissingMethod(_, _, _, span): span
            case CyclicBound(_, span): span
            case UndefinedTrait(_, span): span

# ============================================================================
# Built-in Traits
# ============================================================================

fn create_builtin_traits() -> [TraitDef]:
    """Create definitions for built-in traits.

    Built-in traits:
    - Clone: fn clone() -> Self
    - Copy: marker trait (Clone + trivial bitwise copy)
    - Debug: fn debug() -> text
    - Default: fn default() -> Self
    - Drop: fn drop()
    - Eq: fn eq(other: Self) -> bool
    - Ord: fn cmp(other: Self) -> Ordering (requires Eq)
    """
    var traits: [TraitDef] = []
    val dummy_span = Span(start: 0, end: 0, line: 0, col: 0)

    val self_type = HirType(kind: HirTypeKind.TypeParam(name: "Self", bounds: []), span: dummy_span)
    val bool_type = HirType(kind: HirTypeKind.Bool, span: dummy_span)
    val text_type = HirType(kind: HirTypeKind.Str, span: dummy_span)
    val unit_type = HirType(kind: HirTypeKind.Unit, span: dummy_span)
    val i32_type = HirType(kind: HirTypeKind.Int(bits: 32, signed: true), span: dummy_span)

    # Clone trait: fn clone() -> Self
    var clone_trait = TraitDef.create(Symbol(id: 1, name: "Clone"), dummy_span)
    clone_trait.methods = [MethodSignature(name: "clone", params: [], return_type: self_type, effects: [], span: dummy_span)]
    traits = traits.push(clone_trait)

    # Copy trait (marker, no methods - just requires Clone)
    var copy_trait = TraitDef.create(Symbol(id: 2, name: "Copy"), dummy_span)
    copy_trait.supertraits = [Symbol(id: 1, name: "Clone")]  # Copy: Clone
    traits = traits.push(copy_trait)

    # Debug trait: fn debug() -> text
    var debug_trait = TraitDef.create(Symbol(id: 3, name: "Debug"), dummy_span)
    debug_trait.methods = [MethodSignature(name: "debug", params: [], return_type: text_type, effects: [], span: dummy_span)]
    traits = traits.push(debug_trait)

    # Default trait: fn default() -> Self (static)
    var default_trait = TraitDef.create(Symbol(id: 4, name: "Default"), dummy_span)
    default_trait.methods = [MethodSignature(name: "default", params: [], return_type: self_type, effects: [], span: dummy_span)]
    traits = traits.push(default_trait)

    # Drop trait: fn drop()
    var drop_trait = TraitDef.create(Symbol(id: 5, name: "Drop"), dummy_span)
    drop_trait.methods = [MethodSignature(name: "drop", params: [], return_type: unit_type, effects: [], span: dummy_span)]
    traits = traits.push(drop_trait)

    # Eq trait: fn eq(other: Self) -> bool
    var eq_trait = TraitDef.create(Symbol(id: 6, name: "Eq"), dummy_span)
    eq_trait.methods = [MethodSignature(name: "eq", params: [self_type], return_type: bool_type, effects: [], span: dummy_span)]
    traits = traits.push(eq_trait)

    # Ord trait: fn cmp(other: Self) -> i32 (requires Eq)
    var ord_trait = TraitDef.create(Symbol(id: 7, name: "Ord"), dummy_span)
    ord_trait.supertraits = [Symbol(id: 6, name: "Eq")]  # Ord: Eq
    ord_trait.methods = [MethodSignature(name: "cmp", params: [self_type], return_type: i32_type, effects: [], span: dummy_span)]
    traits = traits.push(ord_trait)

    traits

export TraitError, create_builtin_traits
