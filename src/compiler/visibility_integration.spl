# Visibility Integration - HIR Walker for Visibility Checking
#
# Walks HIR modules to find cross-module symbol accesses and check visibility.

use hir_types.{HirModule, Symbol, SymbolId, SymbolTable}
use hir_definitions.{HirExpr, HirExprKind, HirStmt, HirStmtKind, HirBlock, HirFunction}
use visibility_checker.{VisibilityChecker, VisibilityWarning}
use lexer.Span

# Check visibility for all cross-module accesses in a HIR module
fn check_module_visibility(
    hir_module: HirModule,
    current_module_name: text
) -> [VisibilityWarning]:
    """Walk HIR module and collect visibility warnings for cross-module accesses."""

    val checker = VisibilityChecker.new(current_module_name)
    val symbols = hir_module.symbols

    # Check all functions
    for func_id in hir_module.functions.keys():
        val func = hir_module.functions[func_id]
        if func.?:
            check_function_visibility(func.unwrap(), symbols, checker)

    # TODO: Check classes, structs, enums, traits, impls
    # For now, just checking functions is a good start

    checker.get_warnings()

fn check_function_visibility(
    func: HirFunction,
    symbols: SymbolTable,
    checker: VisibilityChecker
):
    """Check visibility in a single function."""
    check_block_visibility(func.body, symbols, checker)

fn check_block_visibility(
    block: HirBlock,
    symbols: SymbolTable,
    checker: VisibilityChecker
):
    """Check visibility in a block."""
    for stmt in block.stmts:
        check_stmt_visibility(stmt, symbols, checker)

    if block.expr.?:
        check_expr_visibility(block.expr.unwrap(), symbols, checker)

fn check_stmt_visibility(
    stmt: HirStmt,
    symbols: SymbolTable,
    checker: VisibilityChecker
):
    """Check visibility in a statement."""
    match stmt.kind:
        case HirStmtKind.Let(_, _, init, _):
            if init.?:
                check_expr_visibility(init.unwrap(), symbols, checker)
        case HirStmtKind.Assign(target, value):
            check_expr_visibility(target, symbols, checker)
            check_expr_visibility(value, symbols, checker)
        case HirStmtKind.Expr(expr):
            check_expr_visibility(expr, symbols, checker)
        case HirStmtKind.Return(value):
            if value.?:
                check_expr_visibility(value.unwrap(), symbols, checker)
        default:
            # Other statement types don't have expressions to check
            pass

fn check_expr_visibility(
    expr: HirExpr,
    symbols: SymbolTable,
    checker: VisibilityChecker
):
    """Check visibility in an expression.

    This is where we detect cross-module symbol accesses and check visibility.
    """
    match expr.kind:
        case HirExprKind.Var(symbol_id):
            # Variable/function/class reference - check visibility
            check_symbol_visibility(symbol_id, symbols, checker, expr.span)

        case HirExprKind.Field(base, field, resolved):
            check_expr_visibility(base, symbols, checker)
            if resolved.?:
                check_symbol_visibility(resolved.unwrap(), symbols, checker, expr.span)

        case HirExprKind.Call(callee, args, _):
            check_expr_visibility(callee, symbols, checker)
            for arg in args:
                check_expr_visibility(arg.value, symbols, checker)

        case HirExprKind.MethodCall(receiver, method, args, resolution):
            check_expr_visibility(receiver, symbols, checker)
            for arg in args:
                check_expr_visibility(arg.value, symbols, checker)

        case HirExprKind.Binary(op, left, right):
            check_expr_visibility(left, symbols, checker)
            check_expr_visibility(right, symbols, checker)

        case HirExprKind.Unary(op, operand):
            check_expr_visibility(operand, symbols, checker)

        case HirExprKind.If(cond, then_block, else_block):
            check_expr_visibility(cond, symbols, checker)
            check_block_visibility(then_block, symbols, checker)
            if else_block.?:
                check_block_visibility(else_block.unwrap(), symbols, checker)

        case HirExprKind.Block(block):
            check_block_visibility(block, symbols, checker)

        case HirExprKind.ArrayLit(elements, _):
            for elem in elements:
                check_expr_visibility(elem, symbols, checker)

        case HirExprKind.TupleLit(elements):
            for elem in elements:
                check_expr_visibility(elem, symbols, checker)

        # TODO: Add more expression types as needed
        default:
            # Other expression types don't reference symbols
            pass

fn check_symbol_visibility(
    symbol_id: SymbolId,
    symbols: SymbolTable,
    checker: VisibilityChecker,
    access_span: Span
):
    """Check if accessing this symbol violates visibility rules."""
    val symbol_opt = symbols.get(symbol_id)
    if not symbol_opt.?:
        return  # Symbol not found, likely an error elsewhere

    val symbol = symbol_opt.unwrap()

    # Check if symbol has a defining module
    if not symbol.defining_module.?:
        return  # Local symbol, no visibility check needed

    val defining_module = symbol.defining_module.unwrap()

    # Check visibility and record warning if needed
    val warning = checker.check_symbol_access(symbol, defining_module, access_span)
    if warning.?:
        checker.record_warning(warning.unwrap())

# Export public API
export check_module_visibility
