# Test: MirBuilder API -> Native Backend
#
# Tests the MirBuilder API (used by MirLowering) to verify it produces
# correct MIR that the native backend can compile.
#
# Equivalent C program:
#   #include <stdio.h>
#   int main() {
#       int x = 10;
#       int y = 20;
#       int z = x + y;  // 30
#       if (z == 30) {
#           puts("30");
#       } else {
#           puts("fail");
#       }
#       return 0;
#   }

extern fn rt_process_run(cmd: text, args: [text]) -> (text, text, i64)

fn shell(command: text) -> (text, text, i64):
    rt_process_run("sh", ["-c", command])

use compiler.mir_data.*
use compiler.backend.native.isel_x86_64.{isel_module}
use compiler.backend.native.regalloc.{regalloc_module}
use compiler.backend.native.encode_x86_64.{encode_module}
use compiler.backend.native.mach_inst.{MachModule, EncodedFunction}
use compiler.backend.native.elf_writer.{ElfWriter, ElfReloc, ElfRelocType, ElfSymbol, ElfSymbolBind, ElfSymbolType, elf_writer_x86_64, elf_add_section, elf_add_symbol, new_text_section, new_rodata_section, section_add_reloc, new_func_symbol, new_extern_symbol, write_elf64}

print "=== MirBuilder API -> Native Backend Test ==="

# Try using MirBuilder API
var builder = MirBuilder.new()
print "  Builder created"

val i64_type = MirType(kind: MirTypeKind.I64)
val bool_type = MirType(kind: MirTypeKind.Bool)
val unit_type = MirType(kind: MirTypeKind.Unit)
val main_sig = MirSignature(params: [], return_type: i64_type, is_variadic: false)

val dummy_span = Span(start: 0, end: 0, line: 0, col: 0)

# Begin building main function
builder.begin_function(SymbolId.new(0), "main", main_sig, dummy_span)
print "  Function begun"

# Create blocks for control flow
val then_block = builder.new_block(Some("then"))
val else_block = builder.new_block(Some("else"))
val exit_block = builder.new_block(Some("exit"))

print "  Blocks created: then={then_block.id} else={else_block.id} exit={exit_block.id}"

# Entry block: x=10, y=20, z=x+y, if z==30 goto then else goto else
val x_local = builder.new_temp(i64_type)
builder.emit_const(x_local, MirConstValue.Int(10), i64_type)

val y_local = builder.new_temp(i64_type)
builder.emit_const(y_local, MirConstValue.Int(20), i64_type)

# emit_binop creates its own dest and returns it
val z_local = builder.emit_binop(MirBinOp.Add,
    MirOperand(kind: MirOperandKind.Copy(x_local)),
    MirOperand(kind: MirOperandKind.Copy(y_local)),
    i64_type)

val cond_local = builder.emit_binop(MirBinOp.Eq,
    MirOperand(kind: MirOperandKind.Copy(z_local)),
    MirOperand(kind: MirOperandKind.Const(MirConstValue.Int(30), i64_type)),
    bool_type)

builder.terminate_if(
    MirOperand(kind: MirOperandKind.Copy(cond_local)),
    then_block, else_block)

print "  Entry block done"

# Then block: puts("30")
builder.switch_to_block(then_block)
val str_then = builder.new_temp(i64_type)
builder.emit_const(str_then, MirConstValue.Str("30"), i64_type)
builder.emit_call(
    MirOperand(kind: MirOperandKind.Const(MirConstValue.Str("puts"), i64_type)),
    [MirOperand(kind: MirOperandKind.Copy(str_then))],
    unit_type)
builder.terminate_goto(exit_block)

print "  Then block done"

# Else block: puts("fail")
builder.switch_to_block(else_block)
val str_else = builder.new_temp(i64_type)
builder.emit_const(str_else, MirConstValue.Str("fail"), i64_type)
builder.emit_call(
    MirOperand(kind: MirOperandKind.Const(MirConstValue.Str("puts"), i64_type)),
    [MirOperand(kind: MirOperandKind.Copy(str_else))],
    unit_type)
builder.terminate_goto(exit_block)

print "  Else block done"

# Exit block: return 0
builder.switch_to_block(exit_block)
val ret_local = builder.new_temp(i64_type)
builder.emit_const(ret_local, MirConstValue.Int(0), i64_type)
builder.terminate_return(Some(MirOperand(kind: MirOperandKind.Copy(ret_local))))

print "  Exit block done"

val main_func = builder.end_function()
builder.add_function(main_func)

print "  Function built: {main_func.name}, {main_func.blocks.len()} blocks, {main_func.locals.len()} locals"

var module_out = builder.module
module_out.name = "builder_test"
val module = module_out

# Run native pipeline
print "  ISel..."
val mach_module = isel_module(module)
print "  RegAlloc..."
val allocated = regalloc_module(mach_module)
print "  Encode..."
val encoded_funcs = encode_module(allocated)
for ef in encoded_funcs:
    print "    {ef.name}: {ef.code.len()} bytes, {ef.relocations.len()} reloc(s)"

# Emit ELF
fn emit_elf(encoded: [EncodedFunction], mach_mod: MachModule) -> [i64]:
    var writer = elf_writer_x86_64()
    var all_code: [i64] = []
    var func_offsets: Dict<text, i64> = {}
    var all_relocs: [ElfReloc] = []
    var sym_names: [text] = []
    var sym_name_to_idx: Dict<text, i64> = {}

    var rodata_off = 0
    var data_label_off: Dict<text, i64> = {}
    for entry in mach_mod.data_sections:
        if entry.is_readonly:
            if not sym_name_to_idx.contains(entry.name):
                val idx = sym_names.len()
                sym_names = sym_names + [entry.name]
                sym_name_to_idx[entry.name] = idx
                data_label_off[entry.name] = rodata_off
            rodata_off = rodata_off + entry.data.len()

    for ext_sym in mach_mod.extern_symbols:
        if not sym_name_to_idx.contains(ext_sym):
            val idx = sym_names.len()
            sym_names = sym_names + [ext_sym]
            sym_name_to_idx[ext_sym] = idx

    for func in encoded:
        if not sym_name_to_idx.contains(func.name):
            val idx = sym_names.len()
            sym_names = sym_names + [func.name]
            sym_name_to_idx[func.name] = idx

    var num_cs = 1
    var has_ro = false
    for entry in mach_mod.data_sections:
        if entry.is_readonly:
            has_ro = true
    if has_ro:
        num_cs = num_cs + 1
    val sym_base = 1 + num_cs

    for func in encoded:
        var padding = all_code.len() % 16
        if padding != 0:
            padding = 16 - padding
        var pi = 0
        while pi < padding:
            all_code = all_code + [0xcc]
            pi = pi + 1
        func_offsets[func.name] = all_code.len()
        val code_start = all_code.len()
        all_code = all_code + func.code
        for reloc in func.relocations:
            var reloc_type = ElfRelocType.X86_64_PLT32
            if reloc.reloc_type == 2:
                reloc_type = ElfRelocType.X86_64_PC32
            elif reloc.reloc_type == 1:
                reloc_type = ElfRelocType.X86_64_64
            var sym_idx = 0
            if sym_name_to_idx.contains(reloc.symbol_name):
                sym_idx = sym_name_to_idx[reloc.symbol_name]
            all_relocs = all_relocs + [ElfReloc(
                offset: code_start + reloc.offset,
                reloc_type: reloc_type,
                symbol_index: sym_base + sym_idx,
                addend: reloc.addend
            )]

    var text_section = new_text_section(all_code)
    for reloc in all_relocs:
        text_section = section_add_reloc(text_section, reloc)
    writer = elf_add_section(writer, text_section)

    var rodata_bytes: [i64] = []
    for entry in mach_mod.data_sections:
        if entry.is_readonly:
            rodata_bytes = rodata_bytes + entry.data
    if rodata_bytes.len() > 0:
        writer = elf_add_section(writer, new_rodata_section(rodata_bytes))

    for entry in mach_mod.data_sections:
        if entry.is_readonly:
            if data_label_off.contains(entry.name):
                writer = elf_add_symbol(writer, ElfSymbol(
                    name: entry.name,
                    sym_bind: ElfSymbolBind.Local,
                    sym_type: ElfSymbolType.Object,
                    section_index: 2,
                    value: data_label_off[entry.name],
                    size: entry.data.len()
                ))

    for ext_sym in mach_mod.extern_symbols:
        writer = elf_add_symbol(writer, new_extern_symbol(ext_sym))
    for func in encoded:
        var fo = 0
        if func_offsets.contains(func.name):
            fo = func_offsets[func.name]
        writer = elf_add_symbol(writer, new_func_symbol(func.name, 1, fo, func.code.len()))
    write_elf64(writer)

print "  ELF..."
val elf_bytes = emit_elf(encoded_funcs, allocated)
print "  ELF size: {elf_bytes.len()} bytes"

# Write to disk
fn byte_to_hex(b: i64) -> text:
    val digits = "0123456789abcdef"
    "{digits[b / 16]}{digits[b % 16]}"

var offset = 0
while offset < elf_bytes.len():
    var chunk = ""
    var end_idx = offset + 800
    if end_idx > elf_bytes.len():
        end_idx = elf_bytes.len()
    var j = offset
    while j < end_idx:
        chunk = chunk + byte_to_hex(elf_bytes[j])
        j = j + 1
    if offset == 0:
        shell("echo -n '{chunk}' > /tmp/mir_builder.hex")
    else:
        shell("echo -n '{chunk}' >> /tmp/mir_builder.hex")
    offset = end_idx

shell("xxd -r -p /tmp/mir_builder.hex /tmp/mir_builder.o")
shell("rm -f /tmp/mir_builder.hex")

# Link and run
val link_r = rt_process_run("cc", ["-o", "/tmp/mir_builder", "/tmp/mir_builder.o", "-no-pie"])
if link_r[2] != 0:
    print "  Link FAILED: {link_r[1]}"
else:
    print "  Linked!"
    val run_r = rt_process_run("/tmp/mir_builder", [])
    val output = run_r[0].trim()
    print "  Output: '{output}'"
    print "  Exit: {run_r[2]}"
    if output == "30":
        print ""
        print "=== SUCCESS: MirBuilder API -> Native Backend ==="
    else:
        print "=== PARTIAL: output mismatch ==="

print "=== Done ==="
