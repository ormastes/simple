# Leak Check - Main Entry Point
#
# Unified memory leak detection tool.
#
# Usage:
#     simple leak-check [options] <source.spl>
#
# Supports:
#   - Internal mode: Process-level memory monitoring via /proc/meminfo
#   - External mode: ASan or Valgrind via C backend
#   - Both mode: Run both internal and external checks
#   - Runtime mode: Built-in C runtime memtrack (SIMPLE_MEMTRACK=1)

extern fn rt_time_now_unix_micros() -> i64
extern fn rt_shell_output(cmd: text) -> text
extern fn rt_cli_get_args() -> [str]
extern fn rt_env_set(key: text, value: text) -> bool

use types
use config
use internal_runner
use external_runner
use reporter
use std.mem_tracker.{mem_enable, mem_disable, mem_snapshot, mem_dump_leaks, parse_leak_dump}
use compiler.driver.driver.{interpret_file}
use compiler.driver.driver_types.{CompileResult}

# Main entry point for leak-check command
fn _collect_leak_check_args() -> [text]:
    val all_args = rt_cli_get_args()
    var args: [text] = []
    var start_idx = 1
    # Skip script path (first arg is the entry point .spl path)
    if all_args.len() > 1 and all_args[1].ends_with("leak_check_entry.spl"):
        start_idx = 2
    # Skip "leak-check" command if present
    if all_args.len() > start_idx and all_args[start_idx] == "leak-check":
        start_idx = start_idx + 1
    var i = start_idx
    while i < all_args.len():
        args.push(all_args[i])
        i = i + 1
    args

# Main entry point for leak-check command
fn run_leak_check() -> i64:
    val args = _collect_leak_check_args()
    val cfg = parse_leak_check_args(args)

    # Handle help (source_file will be empty if --help was printed)
    if cfg.source_file == "":
        return 0

    if cfg.verbose:
        print "Leak check configuration:"
        print "  Mode: {leak_check_mode_to_string(cfg.mode)}"
        print "  Source: {cfg.source_file}"
        if cfg.mode == LeakCheckMode.External or cfg.mode == LeakCheckMode.Both:
            print "  External tool: {external_tool_to_string(cfg.external_tool)}"
        print "  Report format: {report_format_to_string(cfg.report_format)}"
        print "  Timeout: {cfg.timeout_seconds}s"
        print ""

    val start_us = rt_time_now_unix_micros()
    var result = empty_leak_check_result()

    match cfg.mode:
        case LeakCheckMode.Internal:
            result = run_internal_check(cfg)
        case LeakCheckMode.External:
            result = run_external_check(cfg)
        case LeakCheckMode.Both:
            # Run internal check first
            val internal_result = run_internal_check(cfg)
            # Then external check
            val external_result = run_external_check(cfg)
            # Merge results
            result.mode = "both"
            result.internal_leaks = internal_result.internal_leaks
            result.external_report = external_result.external_report
            val has_internal = internal_result.internal_leaks.len() > 0
            val has_external = (external_result.external_report.definitely_lost_bytes > 0 or external_result.external_report.indirectly_lost_bytes > 0 or external_result.external_report.possibly_lost_bytes > 0)
            if has_internal or has_external:
                result.exit_code = 1
            else:
                result.exit_code = 0
        case LeakCheckMode.Runtime:
            result = run_runtime_check(cfg)

    val end_us = rt_time_now_unix_micros()
    result.duration_ms = (end_us - start_us) / 1000

    # Write report
    write_report(result, cfg)

    result.exit_code

# Runtime mode: uses built-in C memtrack to run target and report leaks
fn run_runtime_check(cfg: LeakCheckConfig) -> LeakCheckResult:
    # Enable memtrack, take snapshot, run program, dump leaks
    mem_enable()
    val snap_id = mem_snapshot()

    # Run the target program with SIMPLE_MEMTRACK=1 (in-process)
    rt_env_set("SIMPLE_MEMTRACK", "1")
    val interp_result = interpret_file(cfg.source_file)
    match interp_result:
        case CompileResult.Success(_):
            if cfg.verbose:
                print "Program executed successfully"
        case _:
            if cfg.verbose:
                val errors = interp_result.get_errors()
                for err in errors:
                    print err

    # Dump and parse leaks
    val dump_path = "/tmp/simple_leak_check_runtime.txt"
    mem_dump_leaks(snap_id, dump_path)
    val leaks = parse_leak_dump(dump_path)

    mem_disable()

    # Convert to AllocationRecords for compatibility
    var alloc_records: [AllocationRecord] = []
    for entry in leaks:
        alloc_records.push(AllocationRecord(
            address: entry.alloc_id,
            size: entry.size,
            type_id: entry.tag,
            source_file: "",
            source_line: 0,
            source_function: "",
            timestamp_us: 0,
            freed: false
        ))

    var exit_code: i64 = 0
    if leaks.len() > 0:
        exit_code = 1

    LeakCheckResult(
        mode: "runtime",
        internal_leaks: alloc_records,
        external_report: empty_external_leak_report(),
        duration_ms: 0,
        exit_code: exit_code
    )

export run_leak_check
