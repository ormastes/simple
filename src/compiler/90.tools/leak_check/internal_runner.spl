# Leak Check - Internal Runner
#
# Runs the internal leak check by comparing /proc/meminfo MemAvailable
# before and after subprocess execution. The previous in-process tracker
# approach was broken because cli_run_file() spawns a separate subprocess.

extern fn rt_file_exists(path: text) -> bool
extern fn rt_file_read_text(path: text) -> text

use app.io.mod (cli_run_file)
use types

# Read MemAvailable from /proc/meminfo, returns KB or -1 on failure
fn read_mem_available_kb() -> i64:
    val raw = rt_file_read_text("/proc/meminfo")
    val content = raw ?? ""
    if content == "":
        return -1
    val lines = content.split("\n")
    var i = 0
    while i < lines.len():
        val line = lines[i]
        if line.starts_with("MemAvailable:"):
            val after = line.substring(13).trim()
            # Extract leading digits
            var num_str = ""
            var j = 0
            while j < after.len():
                val ch = after.substring(j, j + 1)
                if (ch == "0" or ch == "1" or ch == "2" or ch == "3" or ch == "4" or ch == "5" or ch == "6" or ch == "7" or ch == "8" or ch == "9"):
                    num_str = num_str + ch
                else:
                    break
                j = j + 1
            if num_str.len() > 0:
                return num_str.to_int()
            return -1
        i = i + 1
    -1

# Run an internal leak check on the given source file
fn run_internal_check(cfg: LeakCheckConfig) -> LeakCheckResult:
    var result = empty_leak_check_result()
    result.mode = "internal"

    if cfg.source_file == "":
        print "Error: no source file specified"
        result.exit_code = 1
        return result

    if not rt_file_exists(cfg.source_file):
        print "Error: source file not found: {cfg.source_file}"
        result.exit_code = 1
        return result

    if cfg.verbose:
        print "Running internal leak check on: {cfg.source_file}"
        print "GC leak window: {cfg.gc_leak_window}"

    # Snapshot memory before running the target
    val mem_before_kb = read_mem_available_kb()
    if cfg.verbose:
        if mem_before_kb > 0:
            print "MemAvailable before: {mem_before_kb} KB"
        else:
            print "Warning: could not read /proc/meminfo"

    # Run the target file through the interpreter
    val run_args: [text] = [cfg.source_file]
    val run_exit = cli_run_file(cfg.source_file, run_args, false, false)

    # Snapshot memory after running the target
    val mem_after_kb = read_mem_available_kb()

    if cfg.verbose:
        print "Program exited with code: {run_exit}"
        if mem_after_kb > 0:
            print "MemAvailable after: {mem_after_kb} KB"

    # Detect process-level leak if delta exceeds gc_leak_window (in KB)
    if mem_before_kb > 0 and mem_after_kb > 0:
        val delta_kb = mem_before_kb - mem_after_kb
        if cfg.verbose:
            print "Memory delta: {delta_kb} KB"
        if delta_kb > cfg.gc_leak_window:
            val leak_record = AllocationRecord(
                address: 0,
                size: delta_kb * 1024,
                type_id: "process_memory",
                source_file: cfg.source_file,
                source_line: 0,
                source_function: "",
                timestamp_us: 0,
                freed: false
            )
            result.internal_leaks = [leak_record]
            result.exit_code = 1
            return result

    result.exit_code = 0
    result

export run_internal_check, read_mem_available_kb
