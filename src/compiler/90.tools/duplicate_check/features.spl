# Feature extraction and cosine similarity for fuzzy duplicate detection

use app.duplicate_check.tokenizer.{SimpleToken, token_to_string}
use app.duplicate_check.debug.{debug_log}

extern fn rt_math_sqrt(x: f64) -> f64

struct TokenFeature:
    token_string: text
    frequency: i64
    weight: f64

struct FeatureVec:
    block_id: i64
    features: {text: f64}
    magnitude: f64

fn math_sqrt(x: f64) -> f64:
    """Compute square root using runtime extern function."""
    rt_math_sqrt(x)

fn extract_token_frequencies(tokens: [SimpleToken], start: i64, end: i64) -> {text: i64}:
    """Extract token frequency map from a token range."""
    var freq_map = {}

    var i = start
    while i < end and i < tokens.len():
        val token = tokens[i]
        val token_str = token_to_string(token)

        val current_freq = freq_map[token_str] ?? 0
        freq_map[token_str] = current_freq + 1

        i = i + 1

    freq_map

fn build_feature_vector(block_id: i64, freq_map: {text: i64}) -> FeatureVec:
    """Convert frequency map to normalized feature vector."""
    var total = 0
    for token_str in freq_map.keys():
        total = total + freq_map[token_str]

    var features = {}
    var sum_squares = 0.0

    for token_str in freq_map.keys():
        val freq = freq_map[token_str]
        val freq_f64 = freq * 1.0
        val total_f64 = total * 1.0
        val weight = freq_f64 / total_f64

        features[token_str] = weight
        sum_squares = sum_squares + (weight * weight)

    val magnitude = rt_math_sqrt(sum_squares)

    FeatureVec(
        block_id: block_id,
        features: features,
        magnitude: magnitude
    )

fn cosine_similarity(vector1: FeatureVec, vector2: FeatureVec) -> f64:
    """Compute cosine similarity between two feature vectors."""
    var dot_product = 0.0

    for token in vector1.features.keys():
        if vector2.features.contains_key(token):
            val w1 = vector1.features[token]
            val w2 = vector2.features[token]
            dot_product = dot_product + (w1 * w2)

    val mag1_zero = vector1.magnitude == 0.0
    val mag2_zero = vector2.magnitude == 0.0
    val either_zero = mag1_zero or mag2_zero

    if either_zero:
        return 0.0

    val similarity = dot_product / (vector1.magnitude * vector2.magnitude)

    var clamped = similarity
    if similarity < 0.0:
        clamped = 0.0
    if similarity > 1.0:
        clamped = 1.0

    clamped

export TokenFeature, FeatureVec, extract_token_frequencies, build_feature_vector, cosine_similarity
