# File-level token caching with timestamp-based invalidation

use app.duplicate_check.tokenizer.{SimpleToken}
use app.io.mod.{file_exists, file_stat}

struct TokenCache:
    file_path: text
    mtime: i64
    tokens: [SimpleToken]

struct TokenCacheManager:
    cache: {text: TokenCache}

fn new_token_cache_manager() -> TokenCacheManager:
    TokenCacheManager(cache: {})

fn get_file_mtime(file_path: text) -> i64:
    """Get file modification time in seconds since epoch.

    Uses direct SFFI syscall (no subprocess spawning) for performance.
    Returns 0 if file doesn't exist or on error.
    """
    file_stat(file_path)

fn get_tokens_cached(manager: TokenCacheManager, file_path: text, tokenize_fn: fn(text) -> [SimpleToken]) -> [SimpleToken]:
    """Get tokens with caching. Returns cached tokens if file hasn't changed."""
    val current_mtime = get_file_mtime(file_path)

    if manager.cache.contains_key(file_path):
        val cached = manager.cache[file_path]
        if cached.mtime == current_mtime:
            return cached.tokens

    # Cache miss or invalidated - re-tokenize
    val tokens = tokenize_fn(file_path)

    # Update cache
    manager.cache[file_path] = TokenCache(
        file_path: file_path,
        mtime: current_mtime,
        tokens: tokens
    )

    tokens

fn get_cached_tokens(manager: TokenCacheManager, file_path: text):
    """Get cached tokens for a file, or nil if not cached or stale."""
    val current_mtime = get_file_mtime(file_path)

    if manager.cache.contains_key(file_path):
        val cached = manager.cache[file_path]
        if cached.mtime == current_mtime:
            return cached.tokens

    nil

fn set_cached_tokens(manager: TokenCacheManager, file_path: text, tokens: [SimpleToken]):
    """Store tokens in cache for a file."""
    val current_mtime = get_file_mtime(file_path)
    manager.cache[file_path] = TokenCache(
        file_path: file_path,
        mtime: current_mtime,
        tokens: tokens
    )

fn invalidate_file(manager: TokenCacheManager, file_path: text):
    """Explicitly invalidate cache entry for a file."""
    if manager.cache.contains_key(file_path):
        var new_cache = {}
        for key in manager.cache.keys():
            if key != file_path:
                new_cache[key] = manager.cache[key]
        manager.cache = new_cache

fn clear_cache(manager: TokenCacheManager):
    """Clear all cached entries."""
    manager.cache = {}

fn get_cache_stats(manager: TokenCacheManager) -> text:
    """Get cache statistics as formatted string."""
    val entries = manager.cache.keys().len()

    var total_tokens = 0
    for key in manager.cache.keys():
        total_tokens = total_tokens + manager.cache[key].tokens.len()

    "Cache: {entries} files, {total_tokens} tokens"

export TokenCache, TokenCacheManager, new_token_cache_manager, get_tokens_cached, get_cached_tokens, set_cached_tokens, invalidate_file, clear_cache, get_cache_stats, get_file_mtime
