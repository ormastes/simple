# Cranelift Core Module - Complete Specification
#
# Complete specification for generating cranelift_ffi.rs with:
# - Module management (JIT and AOT)
# - Function signatures and building
# - Block management and control flow
# - Value creation and arithmetic operations
# - Memory operations and stack management
# - Function calls and type conversions
#
# Refactored: Functions split into submodules:
# - cranelift_codegen.spl: Module mgmt, signatures, function building, blocks, values
# - cranelift_ops.spl: Arithmetic, comparison, memory, control flow
# - cranelift_advanced.spl: Function calls, conversions, block params, JIT, AOT, helpers
#
# Usage: simple ffi-gen --gen-module specs/cranelift_core.spl

use app.ffi_gen.types*
use app.ffi_gen.module_gen (ModuleBuilder)

# Import from submodules
use app.ffi_gen.specs.cranelift_codegen.{add_module_management_fns, add_signature_fns, add_function_building_fns, add_block_management_fns, add_value_creation_fns}
use app.ffi_gen.specs.cranelift_ops.{add_arithmetic_fns, add_comparison_fns, add_memory_fns, add_control_flow_fns}
use app.ffi_gen.specs.cranelift_advanced.{add_function_call_fns, add_conversion_fns, add_block_param_fns, add_jit_execution_fns, add_aot_fns, add_impl_helpers}

# ============================================================================
# Module Specification
# ============================================================================

fn cranelift_module() -> ModuleSpec:
    var builder = ModuleBuilder__start("cranelift_ffi")
        .doc("Cranelift FFI for Self-Hosting Simple Compiler\n\nThis module provides FFI functions that expose Cranelift code generation\ncapabilities to Simple code. This enables the self-hosting compiler\n(simple/compiler/*.spl) to generate native code.")

    # Imports
    builder = add_cranelift_imports(builder)

    # Constants and helper functions (raw code section)
    builder = builder.add_raw(generate_constants_and_helpers())

    # FFI functions by category (46 total)
    builder = add_module_management_fns(builder)      # 4 functions
    builder = add_signature_fns(builder)              # 3 functions
    builder = add_function_building_fns(builder)      # 4 functions
    builder = add_block_management_fns(builder)       # 4 functions
    builder = add_value_creation_fns(builder)         # 4 functions
    builder = add_arithmetic_fns(builder)             # 18 functions (17 binops + 1 unop)
    builder = add_comparison_fns(builder)             # 2 functions
    builder = add_memory_fns(builder)                 # 4 functions
    builder = add_control_flow_fns(builder)           # 5 functions
    builder = add_function_call_fns(builder)          # 3 functions
    builder = add_conversion_fns(builder)             # 8 functions
    builder = add_block_param_fns(builder)            # 2 functions
    builder = add_jit_execution_fns(builder)          # 2 functions
    builder = add_aot_fns(builder)                    # 3 functions

    builder.build()

# ============================================================================
# Imports
# ============================================================================

fn add_cranelift_imports(builder: ModuleBuilder) -> ModuleBuilder:
    builder
        .add_import_items("std::collections", ["HashMap"])
        .add_import_items("std::sync", ["Mutex"])
        .add_import_items("cranelift_codegen::ir", [
            "types", "AbiParam", "Block", "Function", "InstBuilder",
            "MemFlags", "Signature", "StackSlotData", "StackSlotKind", "Value"
        ])
        .add_import("cranelift_codegen::isa::CallConv")
        .add_import_items("cranelift_codegen::settings", ["self", "Configurable"])
        .add_import("cranelift_codegen::Context")
        .add_import_items("cranelift_frontend", ["FunctionBuilder", "FunctionBuilderContext", "Variable"])
        .add_import_items("cranelift_jit", ["JITBuilder", "JITModule"])
        .add_import_items("cranelift_module", ["Linkage", "Module"])
        .add_import_items("cranelift_object", ["ObjectBuilder", "ObjectModule"])
        .add_import("target_lexicon::Triple")
        .add_import("lazy_static::lazy_static")
        .add_import("simple_runtime::RuntimeValue")
        .add_import("simple_runtime::value::{rt_string_len, rt_string_data, rt_string_new}")

# ============================================================================
# Constants and Helper Functions
# ============================================================================

fn generate_constants_and_helpers() -> text:
    "// ============================================================================\n" +
    "// Handle Management\n" +
    "// ============================================================================\n" +
    "\n" +
    "/// Unique handle counter for resources\n" +
    "static HANDLE_COUNTER: std::sync::atomic::AtomicI64 = std::sync::atomic::AtomicI64::new(1);\n" +
    "\n" +
    "fn next_handle() -> i64 {\n" +
    "    HANDLE_COUNTER.fetch_add(1, std::sync::atomic::Ordering::Relaxed)\n" +
    "}\n" +
    "\n" +
    "lazy_static! {\n" +
    "    /// Global registry of JIT modules\n" +
    "    static ref JIT_MODULES: Mutex<HashMap<i64, JITModuleContext>> = Mutex::new(HashMap::new());\n" +
    "\n" +
    "    /// Global registry of AOT modules\n" +
    "    static ref AOT_MODULES: Mutex<HashMap<i64, ObjectModuleContext>> = Mutex::new(HashMap::new());\n" +
    "\n" +
    "    /// Global registry of function builder contexts\n" +
    "    static ref FUNC_CONTEXTS: Mutex<HashMap<i64, FuncBuildContext>> = Mutex::new(HashMap::new());\n" +
    "\n" +
    "    /// Global registry of signatures\n" +
    "    static ref SIGNATURES: Mutex<HashMap<i64, Signature>> = Mutex::new(HashMap::new());\n" +
    "}\n" +
    "\n" +
    "// ============================================================================\n" +
    "// Module Context Types\n" +
    "// ============================================================================\n" +
    "\n" +
    "/// Context for JIT compilation\n" +
    "struct JITModuleContext {\n" +
    "    module: JITModule,\n" +
    "    func_ids: HashMap<String, cranelift_module::FuncId>,\n" +
    "}\n" +
    "\n" +
    "/// Context for AOT compilation\n" +
    "struct ObjectModuleContext {\n" +
    "    module: ObjectModule,\n" +
    "    func_ids: HashMap<String, cranelift_module::FuncId>,\n" +
    "}\n" +
    "\n" +
    "/// Context for building a single function\n" +
    "struct FuncBuildContext {\n" +
    "    module_handle: i64,\n" +
    "    is_jit: bool,\n" +
    "    ctx: Context,\n" +
    "    func_builder_ctx: FunctionBuilderContext,\n" +
    "    blocks: HashMap<i64, Block>,\n" +
    "    values: HashMap<i64, Value>,\n" +
    "    next_block_id: i64,\n" +
    "    next_value_id: i64,\n" +
    "}\n" +
    "\n" +
    "// ============================================================================\n" +
    "// Type Constants\n" +
    "// ============================================================================\n" +
    "\n" +
    "const CL_TYPE_I8: i64 = 1;\n" +
    "const CL_TYPE_I16: i64 = 2;\n" +
    "const CL_TYPE_I32: i64 = 3;\n" +
    "const CL_TYPE_I64: i64 = 4;\n" +
    "const CL_TYPE_F32: i64 = 5;\n" +
    "const CL_TYPE_F64: i64 = 6;\n" +
    "const CL_TYPE_B1: i64 = 7;\n" +
    "const CL_TYPE_PTR: i64 = 8;\n" +
    "\n" +
    "const CL_TARGET_X86_64: i64 = 0;\n" +
    "const CL_TARGET_AARCH64: i64 = 1;\n" +
    "const CL_TARGET_RISCV64: i64 = 2;\n" +
    "\n" +
    "const CL_CMP_EQ: i64 = 0;\n" +
    "const CL_CMP_NE: i64 = 1;\n" +
    "const CL_CMP_SLT: i64 = 2;\n" +
    "const CL_CMP_SLE: i64 = 3;\n" +
    "const CL_CMP_SGT: i64 = 4;\n" +
    "const CL_CMP_SGE: i64 = 5;\n" +
    "const CL_CMP_ULT: i64 = 6;\n" +
    "const CL_CMP_ULE: i64 = 7;\n" +
    "const CL_CMP_UGT: i64 = 8;\n" +
    "const CL_CMP_UGE: i64 = 9;\n" +
    "\n" +
    "fn type_from_code(code: i64) -> types::Type {\n" +
    "    match code {\n" +
    "        CL_TYPE_I8 => types::I8,\n" +
    "        CL_TYPE_I16 => types::I16,\n" +
    "        CL_TYPE_I32 => types::I32,\n" +
    "        CL_TYPE_I64 => types::I64,\n" +
    "        CL_TYPE_F32 => types::F32,\n" +
    "        CL_TYPE_F64 => types::F64,\n" +
    "        CL_TYPE_B1 => types::I8,   // Booleans as i8\n" +
    "        CL_TYPE_PTR => types::I64, // Pointers as i64\n" +
    "        _ => types::I64,\n" +
    "    }\n" +
    "}\n" +
    "\n" +
    "fn int_cc_from_code(code: i64) -> cranelift_codegen::ir::condcodes::IntCC {\n" +
    "    use cranelift_codegen::ir::condcodes::IntCC;\n" +
    "    match code {\n" +
    "        CL_CMP_EQ => IntCC::Equal,\n" +
    "        CL_CMP_NE => IntCC::NotEqual,\n" +
    "        CL_CMP_SLT => IntCC::SignedLessThan,\n" +
    "        CL_CMP_SLE => IntCC::SignedLessThanOrEqual,\n" +
    "        CL_CMP_SGT => IntCC::SignedGreaterThan,\n" +
    "        CL_CMP_SGE => IntCC::SignedGreaterThanOrEqual,\n" +
    "        CL_CMP_ULT => IntCC::UnsignedLessThan,\n" +
    "        CL_CMP_ULE => IntCC::UnsignedLessThanOrEqual,\n" +
    "        CL_CMP_UGT => IntCC::UnsignedGreaterThan,\n" +
    "        CL_CMP_UGE => IntCC::UnsignedGreaterThanOrEqual,\n" +
    "        _ => IntCC::Equal,\n" +
    "    }\n" +
    "}\n" +
    "\n" +
    "fn float_cc_from_code(code: i64) -> cranelift_codegen::ir::condcodes::FloatCC {\n" +
    "    use cranelift_codegen::ir::condcodes::FloatCC;\n" +
    "    match code {\n" +
    "        0 => FloatCC::Equal,\n" +
    "        1 => FloatCC::NotEqual,\n" +
    "        2 => FloatCC::LessThan,\n" +
    "        3 => FloatCC::LessThanOrEqual,\n" +
    "        4 => FloatCC::GreaterThan,\n" +
    "        5 => FloatCC::GreaterThanOrEqual,\n" +
    "        _ => FloatCC::Equal,\n" +
    "    }\n" +
    "}\n" +
    "\n" +
    "// ============================================================================\n" +
    "// Helper Functions\n" +
    "// ============================================================================\n" +
    "\n" +
    "unsafe fn string_from_ptr(ptr: i64, len: i64) -> String {\n" +
    "    if ptr == 0 || len <= 0 {\n" +
    "        return String::new();\n" +
    "    }\n" +
    "    let slice = std::slice::from_raw_parts(ptr as *const u8, len as usize);\n" +
    "    String::from_utf8_lossy(slice).to_string()\n" +
    "}\n" +
    "\n" +
    "/// Extract string from RuntimeValue\n" +
    "fn extract_string(val: RuntimeValue) -> Option<String> {\n" +
    "    let len = rt_string_len(val);\n" +
    "    if len <= 0 {\n" +
    "        return None;\n" +
    "    }\n" +
    "    let data = rt_string_data(val);\n" +
    "    if data.is_null() {\n" +
    "        return None;\n" +
    "    }\n" +
    "    unsafe {\n" +
    "        let slice = std::slice::from_raw_parts(data, len as usize);\n" +
    "        Some(String::from_utf8_lossy(slice).to_string())\n" +
    "    }\n" +
    "}\n" +
    "\n"

export cranelift_module
