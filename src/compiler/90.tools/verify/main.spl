# Simple Verification Tool
# CLI for regenerating and validating Lean verification code.
#
# Usage:
#   simple verify regenerate     - Regenerate Lean files from models
#   simple verify check          - Check all proof obligations
#   simple verify status         - Show verification status
#   simple verify list           - List all proof obligations

import io.fs as fs
import io.args as args
import verification.lean.codegen as codegen
import verification.lean.emitter as emitter
import verification.proofs.checker as checker
import verification.proofs.obligations as obligations

use compiler.backend.lean_backend.{LeanBackend, VerificationLevel, mir_type_to_lean}

# Command handlers

fn cmd_regenerate() -> Int:
    print("Regenerating Lean verification files...")

    val options = codegen.LeanCodegenOptions__new()
        .with_output_dir("verification/generated")

    # Generate memory capabilities module
    regenerate_memory_capabilities(options)?

    # Generate contracts module
    regenerate_contracts(options)?

    # Generate memory model DRF module
    regenerate_memory_model(options)?

    print("Done! Generated files in verification/generated/")
    0

fn regenerate_memory_capabilities(options: codegen.LeanCodegenOptions) -> Result<Nil, String>:
    val gen = codegen.LeanCodegen__new(
        options.with_module_name("MemoryCapabilities")
    )

    # Add RefCapability inductive
    val ref_cap = codegen.LeanInductive__new("RefCapability")
        .add_constructor("Mut", [])
        .add_constructor("Iso", [])
        .add_constructor("Imm", [])

    gen.add_inductive(ref_cap)

    # Add capability conversion function
    val can_convert = codegen.LeanFunction__new("canConvert")
        .add_param("from_cap", "RefCapability")
        .add_param("to_cap", "RefCapability")
        .with_return_type("Bool")
        .with_body("""match from_cap, to_cap with
| RefCapability.Mut, _ => true
| RefCapability.Iso, RefCapability.Iso => true
| RefCapability.Iso, RefCapability.Imm => true
| RefCapability.Imm, RefCapability.Imm => true
| _, _ => false""")

    gen.add_function(can_convert)

    # Write file
    gen.write_to_file("MemoryCapabilities")

fn regenerate_contracts(options: codegen.LeanCodegenOptions) -> Result<Nil, String>:
    val gen = codegen.LeanCodegen__new(
        options.with_module_name("Contracts")
    )

    # Add ContractExprKind inductive
    val expr_kind = codegen.LeanInductive__new("ContractExprKind")
        .add_constructor("True_", [])
        .add_constructor("False_", [])
        .add_constructor("Var", [])
        .add_constructor("Old", [])
        .add_constructor("Result", [])
        .add_constructor("And", [])
        .add_constructor("Or", [])
        .add_constructor("Not", [])
        .add_constructor("Implies", [])
        .add_constructor("Forall", [])
        .add_constructor("Exists", [])
        .add_constructor("Eq", [])
        .add_constructor("Ne", [])
        .add_constructor("Lt", [])
        .add_constructor("Le", [])
        .add_constructor("Gt", [])
        .add_constructor("Ge", [])
        .add_constructor("Call", [])

    gen.add_inductive(expr_kind)

    # Add ContractExpr structure
    val contract_expr = codegen.LeanStructure__new("ContractExpr")
        .add_field("kind", "ContractExprKind")
        .add_field("children", "List ContractExpr")
        .add_field("name", "Option String")
        .add_field("typeName", "Option String")

    gen.add_structure(contract_expr)

    # Write file
    gen.write_to_file("Contracts")

fn regenerate_memory_model(options: codegen.LeanCodegenOptions) -> Result<Nil, String>:
    val gen = codegen.LeanCodegen__new(
        options.with_module_name("MemoryModelDRF")
    )

    # Add MemoryOrder inductive
    val mem_order = codegen.LeanInductive__new("MemoryOrder")
        .add_constructor("Relaxed", [])
        .add_constructor("Acquire", [])
        .add_constructor("Release", [])
        .add_constructor("AcqRel", [])
        .add_constructor("SeqCst", [])

    gen.add_inductive(mem_order)

    # Add AccessType inductive
    val access_type = codegen.LeanInductive__new("AccessType")
        .add_constructor("Read", [])
        .add_constructor("Write", [])
        .add_constructor("Atomic", [])

    gen.add_inductive(access_type)

    # Add SC-DRF theorem (as sorry)
    val sc_drf_theorem = codegen.LeanTheorem__new(
        "sc_drf_guarantee",
        "data_race_free program -> sequentially_consistent (execute program)"
    )

    gen.add_theorem(sc_drf_theorem)

    # Write file
    gen.write_to_file("MemoryModelDRF")

fn cmd_check() -> Int:
    print("Checking proof obligations...")

    val config = checker.CheckerConfig__create()
        .with_project_dir("verification")

    val proof_checker = checker.ProofChecker__create(config)
    val result = proof_checker.check_verification_dir()

    print(result.summary())

    if result.failure_count() > 0:
        print("")
        print("Failed checks:")
        for file_result in result.file_results:
            if not file_result.result.is_success():
                print("  {file_result.file_path}: {file_result.result.to_string()}")
        1
    else:
        0

fn cmd_status() -> Int:
    print("Verification Status")
    print("===================")
    print("")

    # Check Lean availability
    val lean_available = is_lean_available()
    if lean_available:
        print("Lean 4: Available")
    else:
        print("Lean 4: Not found (install with: elan install leanprover/lean4:stable)")

    print("")

    # List verification projects
    val projects = [
        ("memory_capabilities", "Reference capability verification"),
        ("memory_model_drf", "SC-DRF memory model verification"),
        ("type_inference_compile", "Type inference proofs"),
        ("async_compile", "Async effect tracking"),
        ("gc_manual_borrow", "GC safety proofs"),
        ("nogc_compile", "NoGC instruction verification"),
        ("module_resolution", "Module resolution verification"),
        ("visibility_export", "Visibility and export verification")
    ]

    print("Verification Projects:")
    for (name, description) in projects:
        val dir = "verification/{name}"
        val exists = fs.exists(dir)
        val status = if exists: "OK" else: "MISSING"
        print("  [{status}] {name} - {description}")

    0

fn cmd_list() -> Int:
    print("Proof Obligations")
    print("=================")
    print("")

    # Load obligations from source files
    val source_dir = args.get_flag("--dir").unwrap_or(".")
    val obls = load_obligations_from_dir(source_dir)

    if obls.is_empty():
        print("No proof obligations found in {source_dir}")
        print("")
        print("Add verification annotations to your code:")
        print("  @requires(condition)  - Precondition")
        print("  @ensures(condition)   - Postcondition")
        print("  @invariant(condition) - Invariant")
        print("  @decreases(expr)      - Termination measure")
    else:
        # Group by category
        var preconditions: [Obligation] = []
        var postconditions: [Obligation] = []
        var invariants: [Obligation] = []
        var termination: [Obligation] = []
        var safety: [Obligation] = []

        for obl in obls:
            match obl.category:
                case ObligationCategory.Precondition: preconditions.push(obl)
                case ObligationCategory.Postcondition: postconditions.push(obl)
                case ObligationCategory.Invariant: invariants.push(obl)
                case ObligationCategory.Termination: termination.push(obl)
                case ObligationCategory.Safety: safety.push(obl)

        print("Found {obls.len()} proof obligations:")
        print("")

        if not preconditions.is_empty():
            print("Preconditions ({preconditions.len()}):")
            for obl in preconditions:
                print("  {obl.location}: {obl.description}")
            print("")

        if not postconditions.is_empty():
            print("Postconditions ({postconditions.len()}):")
            for obl in postconditions:
                print("  {obl.location}: {obl.description}")
            print("")

        if not invariants.is_empty():
            print("Invariants ({invariants.len()}):")
            for obl in invariants:
                print("  {obl.location}: {obl.description}")
            print("")

        if not termination.is_empty():
            print("Termination ({termination.len()}):")
            for obl in termination:
                print("  {obl.location}: {obl.description}")
            print("")

        if not safety.is_empty():
            print("Safety ({safety.len()}):")
            for obl in safety:
                print("  {obl.location}: {obl.description}")
            print("")

    0

# Obligation data structure
struct Obligation:
    location: String      # file:line
    category: ObligationCategory
    description: String
    condition: String

enum ObligationCategory:
    Precondition
    Postcondition
    Invariant
    Termination
    Safety

# Load obligations from all Simple files in a directory
fn load_obligations_from_dir(dir: String) -> [Obligation]:
    var all_obls: [Obligation] = []

    # Find all .spl files
    match fs.glob(dir, "**/*.spl"):
        case Ok(files):
            for file in files:
                val file_obls = load_obligations_from_file(file)
                all_obls.extend(file_obls)
        case Err(_):
            pass

    return all_obls

# Load obligations from a single file
fn load_obligations_from_file(path: String) -> [Obligation]:
    var obls: [Obligation] = []

    match fs.read_text(path):
        case Ok(content):
            val lines = content.split("\n")
            var line_num = 1

            for line in lines:
                val trimmed = line.trim()

                # Check for @requires annotation
                if trimmed.starts_with("@requires("):
                    val cond = extract_annotation(trimmed, "@requires(")
                    obls.push(Obligation {
                        location: "{path}:{line_num}",
                        category: ObligationCategory.Precondition,
                        description: "requires {cond}",
                        condition: cond
                    })

                # Check for @ensures annotation
                else if trimmed.starts_with("@ensures("):
                    val cond = extract_annotation(trimmed, "@ensures(")
                    obls.push(Obligation {
                        location: "{path}:{line_num}",
                        category: ObligationCategory.Postcondition,
                        description: "ensures {cond}",
                        condition: cond
                    })

                # Check for @invariant annotation
                else if trimmed.starts_with("@invariant("):
                    val cond = extract_annotation(trimmed, "@invariant(")
                    obls.push(Obligation {
                        location: "{path}:{line_num}",
                        category: ObligationCategory.Invariant,
                        description: "invariant {cond}",
                        condition: cond
                    })

                # Check for @decreases annotation
                else if trimmed.starts_with("@decreases("):
                    val expr = extract_annotation(trimmed, "@decreases(")
                    obls.push(Obligation {
                        location: "{path}:{line_num}",
                        category: ObligationCategory.Termination,
                        description: "decreases {expr}",
                        condition: expr
                    })

                # Check for @safe annotation
                else if trimmed.starts_with("@safe("):
                    val prop = extract_annotation(trimmed, "@safe(")
                    obls.push(Obligation {
                        location: "{path}:{line_num}",
                        category: ObligationCategory.Safety,
                        description: "safe {prop}",
                        condition: prop
                    })

                line_num = line_num + 1

        case Err(_):
            pass

    return obls

# Extract content from annotation like @requires(condition)
fn extract_annotation(line: String, prefix: String) -> String:
    val start = prefix.len()
    val end = line.rfind(")")
    if end > start:
        return line.slice(start, end)
    return line.slice(start)

fn is_lean_available() -> Bool:
    # Try to run lean --version
    match fs.exec("lean", ["--version"]):
        case Ok(_): true
        case Err(_): false

fn print_help():
    print("Simple Verification Tool")
    print("")
    print("Usage: simple verify <command>")
    print("")
    print("Commands:")
    print("  regenerate    Regenerate Lean files from verification models")
    print("  check         Check all proof obligations")
    print("  status        Show verification status")
    print("  list          List all proof obligations")
    print("  help          Show this help message")
    print("")
    print("Examples:")
    print("  simple verify regenerate")
    print("  simple verify check")
    print("  simple verify status")

fn main() -> Int:
    val argv = args.get_args()

    if argv.len() < 2:
        print_help()
        return 0

    val command = argv[1]

    match command:
        case "regenerate":
            cmd_regenerate()
        case "check":
            cmd_check()
        case "status":
            cmd_status()
        case "list":
            cmd_list()
        case "help":
            print_help()
            0
        case "--help":
            print_help()
            0
        case "-h":
            print_help()
            0
        case _:
            print("Unknown command: {command}")
            print("Run 'simple verify help' for usage information.")
            1
