# Symbol Analyzer
#
# Analyzes symbol usage in AST for context pack generation and
# LLM-friendly IR export. Extracts used functions, types, and
# required imports with transitive dependency tracking.
#
# Port of rust/compiler/src/symbol_analyzer.rs (374 lines)


# Auto-generated desugared static method wrappers
fn SymbolUsageResult__empty() -> SymbolUsageResult:
    SymbolUsageResult(used_functions: [], used_types: [], required_imports: [])


export SymbolUsageAnalyzer, SymbolUsageResult

# ============================================================================
# Types
# ============================================================================

struct SymbolUsageResult:
    """Tracks which symbols are used by a target."""
    used_functions: [text]
    used_types: [text]
    required_imports: [text]

impl SymbolUsageResult:
    static fn empty() -> SymbolUsageResult:
        SymbolUsageResult(used_functions: [], used_types: [], required_imports: [])

    fn merge(other: SymbolUsageResult) -> SymbolUsageResult:
        SymbolUsageResult(
            used_functions: self.used_functions.merge(other.used_functions),
            used_types: self.used_types.merge(other.used_types),
            required_imports: self.required_imports.merge(other.required_imports))

    fn add_function(name: text) -> SymbolUsageResult:
        if self.used_functions.contains(name): self
        else: SymbolUsageResult(
            used_functions: self.used_functions.push(name),
            used_types: self.used_types,
            required_imports: self.required_imports)

    fn add_type(name: text) -> SymbolUsageResult:
        if self.used_types.contains(name): self
        else: SymbolUsageResult(
            used_functions: self.used_functions,
            used_types: self.used_types.push(name),
            required_imports: self.required_imports)

    fn add_import(name: text) -> SymbolUsageResult:
        if self.required_imports.contains(name): self
        else: SymbolUsageResult(
            used_functions: self.used_functions,
            used_types: self.used_types,
            required_imports: self.required_imports.push(name))

# ============================================================================
# Node/Expression Representations (for analysis input)
# ============================================================================

enum NodeKind:
    Function
    Class
    Struct
    Enum
    Import
    Expression

struct AnalysisNode:
    kind: NodeKind
    name: text
    is_public: bool
    param_types: [text]
    return_type: text?
    body_calls: [text]          # Function/constructor calls in body
    body_type_refs: [text]      # Type references in body
    field_types: [text]         # For struct/class: field type names
    method_names: [text]        # For class: method names
    import_path: text?          # For imports

# ============================================================================
# Symbol Usage Analyzer
# ============================================================================

class SymbolUsageAnalyzer:
    """Analyzes AST nodes to extract symbol dependencies."""
    minimal: bool       # Only direct references, no transitive deps

impl SymbolUsageAnalyzer:
    static fn create() -> SymbolUsageAnalyzer:
        SymbolUsageAnalyzer(minimal: false)

    static fn minimal_mode() -> SymbolUsageAnalyzer:
        SymbolUsageAnalyzer(minimal: true)

    fn analyze(nodes: [AnalysisNode], target: text) -> SymbolUsageResult:
        """Analyze symbol usage for a specific target."""
        var usage = SymbolUsageResult__empty()

        # Find target node
        var found = false
        for node in nodes:
            if node.name == target:
                usage = self.collect_from_node(node, usage)
                found = true

        # If no target specified, analyze all public nodes
        if not found and target == "":
            for node in nodes:
                if node.is_public:
                    usage = self.collect_from_node(node, usage)

        # Collect transitive deps from called function signatures
        if not self.minimal:
            val called = usage.used_functions
            for func_name in called:
                for node in nodes:
                    if node.kind == NodeKind.Function and node.name == func_name:
                        for ty in node.param_types:
                            usage = usage.add_type(ty)
                        if node.return_type.?:
                            usage = usage.add_type(node.return_type.unwrap())

        usage

    fn collect_from_node(node: AnalysisNode, usage: SymbolUsageResult) -> SymbolUsageResult:
        var result = usage

        match node.kind:
            case Function:
                for ty in node.param_types:
                    result = result.add_type(ty)
                if node.return_type.?:
                    result = result.add_type(node.return_type.unwrap())
                for call in node.body_calls:
                    result = result.add_function(call)
                    # Uppercase names might be constructors
                    if call.chars().first.?.is_upper():
                        result = result.add_type(call)
                for ty in node.body_type_refs:
                    result = result.add_type(ty)

            case Class:
                for ty in node.field_types:
                    result = result.add_type(ty)
                for method in node.method_names:
                    result = result.add_function(method)

            case Struct:
                for ty in node.field_types:
                    result = result.add_type(ty)

            case Import:
                if node.import_path.?:
                    result = result.add_import(node.import_path.unwrap())

            case _: ()

        result

    fn analyze_all_imports(nodes: [AnalysisNode]) -> [text]:
        """Extract all import paths from nodes."""
        var imports: [text] = []
        for node in nodes:
            if node.kind == NodeKind.Import and node.import_path.?:
                val path = node.import_path.unwrap()
                if not imports.contains(path):
                    imports = imports.push(path)
        imports
