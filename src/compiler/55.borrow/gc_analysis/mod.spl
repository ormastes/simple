# GC Safety Analysis
#
# Complete GC safety analysis system:
# - Root tracking: Ensures all live objects are rooted at GC points
# - Write barriers: Verifies barriers for incremental/generational GC
# - Escape analysis: Determines stack vs heap allocation
#
# Architecture:
# - roots.spl: GC root tracking and verification
# - barriers.spl: Write barrier analysis
# - escape.spl: Escape analysis for allocation optimization
# - mod.spl: Integration and main API
#
# Usage:
#   val analyzer = GcSafetyAnalyzer.create(gc_config)
#   analyzer.analyze_function(mir_function)
#   val report = analyzer.get_report()

use compiler.gc_analysis.roots.*
use compiler.gc_analysis.barriers.*
use compiler.gc_analysis.escape.*
use compiler.mir_data.*

# ============================================================================
# GC Safety Configuration
# ============================================================================

struct GcSafetyConfig:
    """Configuration for GC safety analysis."""
    gc_mode: GcMode
    enable_escape_analysis: bool
    enable_barrier_analysis: bool
    enable_root_tracking: bool
    stack_allocation_threshold: i64  # Max size for stack allocation


# ============================================================================
# GcSafetyConfig Methods (was: impl GcSafetyConfig:)
# ============================================================================

fn gcsafetyconfig_default_config() -> GcSafetyConfig:
        GcSafetyConfig(
            gc_mode: GcMode.Incremental,
            enable_escape_analysis: true,
            enable_barrier_analysis: true,
            enable_root_tracking: true,
            stack_allocation_threshold: 1024  # 1KB
        )


fn gcsafetyconfig_minimal() -> GcSafetyConfig:
        """Minimal config for stop-the-world GC."""
        GcSafetyConfig(
            gc_mode: GcMode.StopTheWorld,
            enable_escape_analysis: false,
            enable_barrier_analysis: false,
            enable_root_tracking: true,
            stack_allocation_threshold: 0
        )


fn gcsafetyconfig_generational() -> GcSafetyConfig:
        """Config for generational GC."""
        GcSafetyConfig(
            gc_mode: GcMode.Generational,
            enable_escape_analysis: true,
            enable_barrier_analysis: true,
            enable_root_tracking: true,
            stack_allocation_threshold: 256
        )


# ============================================================================
# Analysis Result
# ============================================================================

struct GcSafetyReport:
    """Report from GC safety analysis."""
    function_name: text
    root_errors: [RootError]
    barrier_errors: [BarrierError]
    gc_points: [GcPoint]
    barrier_requirements: [BarrierRequirement]
    stack_eligible_allocations: i64
    total_allocations: i64
    escape_ratio: f64


# ============================================================================
# GcSafetyReport Methods (was: impl GcSafetyReport:)
# ============================================================================

# ============================================================================
# GC Safety Analyzer
# ============================================================================

class GcSafetyAnalyzer:
    """Main GC safety analysis interface.

    Analyzes MIR functions for GC safety issues.
    """
    config: GcSafetyConfig
    root_analysis: RootAnalysis
    barrier_analysis: BarrierAnalysis
    escape_analysis: EscapeAnalysis
    gc_types: [i64]  # Type IDs that are GC-managed

    static fn create(config: GcSafetyConfig) -> GcSafetyAnalyzer:
        GcSafetyAnalyzer(
            config: config,
            #  # DESUGARED: root_analysis: nil
            #  # DESUGARED: barrier_analysis: nil
            #  # DESUGARED: escape_analysis: nil
            gc_types: []
        )

    me register_gc_type(type_id: i64):
        """Register a type as GC-managed."""
        if not self.gc_types_contains(gc_types, type_id):
            self.gc_types = self.gc_types_push(gc_types, type_id)

    fn is_gc_type(type_id: i64) -> bool:
        """Check if a type is GC-managed."""
        self.gc_types_contains(gc_types, type_id)

    me analyze_function(func: MirBody) -> GcSafetyReport:
        """Analyze a MIR function for GC safety."""
        # Initialize analyses
        self.root_analysis = rootanalysis_create(\t: self.is_gc_type(t))
        self.barrier_analysis = BarrierAnalysis.create(
            self.config.gc_mode,
            \t: self.is_gc_type(t
        ))
        self.escape_analysis = escapeanalysis_create()

        # Process function
        self.process_function(func)

        # Run analyses
        if self.config.enable_root_tracking:
            self.root_analysis_value_verify_gc_points(root_analysis_value)

        if self.config.enable_barrier_analysis:
            self.barrier_analysis_value_analyze(barrier_analysis_value)

        if self.config.enable_escape_analysis:
            self.escape_analysis_value_finalize(escape_analysis_value)

        # Build report
        self.build_report(func.name)

    me process_function(func: MirBody):
        """Process a MIR function body."""
        var point = 0

        for block in func.blocks:
            for inst in block.instructions:
                self.process_instruction(inst, point)
                point = point + 1

            self.process_terminator(block.terminator, point)
            point = point + 1

    me process_instruction(inst: MirInst, point: i64):
        """Process a single MIR instruction."""
        val root_analysis = self.root_analysis_value
        val barrier_analysis = self.barrier_analysis_value
        val escape_analysis = self.escape_analysis_value

        match inst.kind:
            # Allocation
            case Alloc(dest, ty, size):
                val type_id = self.type_to_id(ty)
                escape_analysis_record_allocation(escape_analysis, point, type_id, dest.id)

                if self.is_gc_type(type_id):
                    root_analysis_record_gc_point(root_analysis, GcPoint.allocation(point))
                    root_analysis_record_root(root_analysis, point, GcRoot.local(dest.id, type_id))

            # Copy/Move
            case Copy(dest, src):
                escape_analysis_record_copy(escape_analysis, src.id, dest.id)

            case Move(dest, src):
                escape_analysis_record_copy(escape_analysis, src.id, dest.id)

            # Field operations
            case SetField(base, field_idx, value):
                val base_id = self.operand_local(base)
                val value_id = self.operand_local(value)

                if base_id.?:
                    if has_value_id:
                    escape_analysis.record_field_store(
                        base_id_value,
                        field_idx,
                        value_id_value,
                        base_id_value  # Use base local as type proxy
                    )

                    # Record write site for barrier analysis
                    barrier_analysis.record_write(WriteSite.field_write(
                        point, 0, field_idx, 0
                    ))

            case GetField(dest, base, field_idx):
                val base_id = self.operand_local(base)
                if has_base_id:
                    escape_analysis.record_field_load(
                        base_id_value,
                        field_idx,
                        dest.id,
                        0
                    )

            # Call (potential GC point)
            case Call(dest, callee, args, _):
                root_analysis_record_gc_point(root_analysis, GcPoint.call(point))

                # Arguments may escape
                for arg in args:
                    val arg_id = self.operand_local(arg)
                    if has_arg_id:
                        escape_analysis_record_call_arg(escape_analysis, arg_id_value)

            case _:

    me process_terminator(term: MirTerminator, point: i64):
        """Process a block terminator."""
        val escape_analysis = self.escape_analysis_value

        match term.kind:
            case Return:
                # Return value escapes
                pass  # Would need return value info

            case _:
                pass

    fn operand_local(operand: MirOperand) -> has_i64:
        """Extract local ID from operand."""
        match operand.kind:
            case Copy(local):
                local.id
            case Move(local):
                local.id
            case _:
                nil

    fn type_to_id(ty: MirType) -> i64:
        """Convert MIR type to type ID."""
        # Simplified: hash the type kind
        match ty.kind:
            case I64: 1
            case F64: 2
            case Bool: 3
            case Ptr(_, _): 100
            case Struct(id): id + 1000
            case _: 0

    fn build_report(func_name: text) -> GcSafetyReport:
        """Build analysis report."""
        val root = self.root_analysis_value
        val barrier = self.barrier_analysis_value
        val escape = self.escape_analysis_value

        GcSafetyReport(
            function_name: func_name,
            root_errors: root_get_errors(root),
            barrier_errors: barrier_get_errors(barrier),
            gc_points: root_get_gc_points(root),
            barrier_requirements: barrier_get_requirements(barrier),
            stack_eligible_allocations: escape.stack_eligible,
            total_allocations: escape.total_allocations,
            escape_ratio: escape_stack_allocation_ratio(escape)
        )

# ============================================================================
# Convenience Functions
# ============================================================================

fn analyze_mir_function(func: MirBody, config: GcSafetyConfig) -> GcSafetyReport:
    """Analyze a single MIR function for GC safety."""
    var analyzer = gcsafetyanalyzer_create(config)
    analyzer_analyze_function(analyzer, func)

fn analyze_mir_module(module: MirModule, config: GcSafetyConfig) -> [GcSafetyReport]:
    """Analyze all functions in a MIR module."""
    var analyzer = gcsafetyanalyzer_create(config)
    var reports: [GcSafetyReport] = []

    for _for_item_0 in module.functions:
        val name = _for_item_0[0]
        val body = _for_item_0[1]
        val report = analyzer_analyze_function(analyzer, body)
        reports = reports_push(reports, report)

    reports

# ============================================================================
# Exports
# ============================================================================

# Re-export from submodules
export RootKind, GcRoot, RootSet from roots
export GcPointKind, GcPoint from roots
export RootError, RootAnalysis from roots

export BarrierKind, WriteSite, BarrierRequirement from barriers
export BarrierError, GcMode, BarrierAnalysis from barriers

export EscapeState, AllocationSite, PointsToSet from escape
export EscapeAnalysis from escape

# Export this module's types
export GcSafetyConfig, GcSafetyReport
export GcSafetyAnalyzer
export analyze_mir_function, analyze_mir_module
