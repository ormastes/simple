# Borrow Graph
#
# Tracks borrows and their relationships for borrow checking.
# The borrow graph represents:
# - Active borrows at each program point
# - Conflicts between borrows
# - Invalidation of borrows
#
# Based on Rust's MIR borrow checker.

use compiler.borrow.borrow_check.lifetime.*

# ============================================================================
# Borrow Graph - Manual Desugaring
# ============================================================================

# Manual desugaring of static methods for bootstrap runtime compatibility
fn Place__local(id: i64) -> Place:
    Place(base: placebase_Local(id), projections: [])

fn Place__static_var(name: text) -> Place:
    Place(base: placebase_Static(name), projections: [])

fn Borrow__create(id: i64, place: Place, kind: BorrowKind, lifetime: Lifetime, point: i64) -> Borrow:
    Borrow(
        id: id,
        place: place,
        kind: kind,
        lifetime: lifetime,
        borrow_point: point,
        activated: true
    )

fn Borrow__two_phase(id: i64, place: Place, kind: BorrowKind, lifetime: Lifetime, point: i64) -> Borrow:
    Borrow(
        id: id,
        place: place,
        kind: kind,
        lifetime: lifetime,
        borrow_point: point,
        activated: false
    )

fn BorrowSet__create() -> BorrowSet:
    BorrowSet(borrows: {}, next_id: 0)

fn BorrowGraph__create() -> BorrowGraph:
    BorrowGraph(
        point_borrows: {},
        moved_places: {},
        errors: [],
        lifetimes: LifetimeEnv__create()
    )

# ============================================================================
# Place (Memory Location)
# ============================================================================

enum PlaceBase:
    """Base of a memory place."""
    Local(id: i64)       # Local variable
    Static(name: text)   # Static variable
    Promoted(id: i64)    # Promoted constant

enum PlaceElem:
    """Element in a place projection."""
    Deref                      # *place
    Field(idx: i64)            # place.field
    Index(local: i64)          # place[idx]
    ConstantIndex(idx: i64)    # place[constant]
    Downcast(variant: i64)     # (place, )

struct Place:
    """A memory location (lvalue).

    Places are paths to memory: local, local.field, *local, etc.
    """
    base: PlaceBase
    projections: [PlaceElem]


# ============================================================================
# Place/Kind Conflict Detection
# ============================================================================

fn place_base_equals(a: PlaceBase, b: PlaceBase) -> bool:
    """Check if two place bases are equal."""
    match a:
        case Local(a_id):
            match b:
                case Local(b_id): a_id == b_id
                case _: false
        case Static(a_name):
            match b:
                case Static(b_name): a_name == b_name
                case _: false
        case Promoted(a_id):
            match b:
                case Promoted(b_id): a_id == b_id
                case _: false

fn place_elem_equals(a: PlaceElem, b: PlaceElem) -> bool:
    """Check if two place projection elements are equal."""
    match a:
        case Deref:
            match b:
                case Deref: true
                case _: false
        case Field(a_idx):
            match b:
                case Field(b_idx): a_idx == b_idx
                case _: false
        case Index(a_local):
            match b:
                case Index(b_local): a_local == b_local
                case _: false
        case ConstantIndex(a_idx):
            match b:
                case ConstantIndex(b_idx): a_idx == b_idx
                case _: false
        case Downcast(a_v):
            match b:
                case Downcast(b_v): a_v == b_v
                case _: false

fn place_conflicts_with(a: Place, b: Place) -> bool:
    """Check if two places conflict (one is a prefix of the other).

    Two places conflict when they refer to overlapping memory.
    Examples: x conflicts with x.field, x[0] conflicts with x.
    """
    val same_base = place_base_equals(a.base, b.base)
    if not same_base:
        return false
    # One is prefix of the other (e.g., x vs x.field)
    val a_len = a.projections.len()
    val b_len = b.projections.len()
    val min_len = if a_len < b_len: a_len else: b_len
    var i = 0
    while i < min_len:
        if not place_elem_equals(a.projections[i], b.projections[i]):
            return false
        i = i + 1
    true

fn kind_conflicts_with(a: BorrowKind, b: BorrowKind) -> bool:
    """Check if two borrow kinds conflict.

    Shared+Shared is OK, anything else conflicts.
    """
    match a:
        case Shared:
            match b:
                case Shared: false
                case _: true
        case _: true

fn kind_is_mutable(kind: BorrowKind) -> bool:
    """Check if a borrow kind is mutable."""
    match kind:
        case Mutable: true
        case Unique: true
        case Shared: false

# ============================================================================
# Place Methods (was: impl Place:)
# ============================================================================

fn place_local(id: i64) -> Place:
        """Create place for local variable."""
        Place(base: placebase_Local(id), projections: [])


fn place_static_var(name: text) -> Place:
        """Create place for static variable."""
        Place(base: placebase_Static(name), projections: [])


fn place_deref(self: Place) -> Place:
        """Add dereference projection."""
        Place(
            base: self.base,
            projections: self.projections_push(projections, PlaceElem.Deref)
        )


fn place_field(self: Place, idx: i64) -> Place:
        """Add field projection."""
        Place(
            base: self.base,
            projections: self.projections_push(projections, PlaceElem.Field(idx))
        )


fn place_index(self: Place, local: i64) -> Place:
        """Add index projection."""
        Place(
            base: self.base,
            projections: self.projections_push(projections, PlaceElem.Index(local))
        )


# ============================================================================
# Borrow Kind
# ============================================================================

enum BorrowKind:
    """Kind of borrow."""
    Shared      # &T - immutable borrow
    Mutable     # &mut T - mutable borrow
    Unique      # Unique borrow (for closures)


# ============================================================================
# BorrowKind Methods (was: impl BorrowKind:)
# ============================================================================

# ============================================================================
# Borrow
# ============================================================================

struct Borrow:
    """A borrow of a place.

    Tracks where, what kind, and for how long.
    """
    id: i64
    place: Place
    kind: BorrowKind
    lifetime: Lifetime
    borrow_point: i64    # Where borrow was created
    activated: bool      # Two-phase borrow: activated yet


# ============================================================================
# Borrow Methods (was: impl Borrow:)
# ============================================================================

fn borrow_create(id: i64, place: Place, kind: BorrowKind, lifetime: Lifetime, point: i64) -> Borrow:
        Borrow(
            id: id,
            place: place,
            kind: kind,
            lifetime: lifetime,
            borrow_point: point,
            activated: true
        )


fn borrow_two_phase(id: i64, place: Place, kind: BorrowKind, lifetime: Lifetime, point: i64) -> Borrow:
        """Create two-phase borrow (not yet activated)."""
        Borrow(
            id: id,
            place: place,
            kind: kind,
            lifetime: lifetime,
            borrow_point: point,
            activated: false
        )


# ============================================================================
# Borrow Set
# ============================================================================

class BorrowSet:
    """Set of active borrows at a program point."""
    borrows: Dict<i64, Borrow>
    next_id: i64

    static fn create() -> BorrowSet:
        BorrowSet(borrows: {}, next_id: 0)

    me add_borrow(place: Place, kind: BorrowKind, lifetime: Lifetime, point: i64) -> Borrow:
        """Add a new borrow."""
        val id = self.next_id
        self.next_id = self.next_id + 1

        val borrow = borrow_create(id, place, kind, lifetime, point)
        self.borrows[id] = borrow
        borrow

    me remove_borrow(id: i64):
        """Remove a borrow."""
        self.borrows_remove(borrows, id)

    fn get_borrow(id: i64) -> has_Borrow:
        """Get a borrow by ID."""
        self.borrows_get(borrows, id)

    fn active_borrows() -> [Borrow]:
        """Get all active borrows."""
        var result: [Borrow] = []
        for id in self.borrows_keys(borrows):
            val borrow = self.borrows[id]
            result = result_push(result, borrow)
        result

    fn borrows_of(place: Place) -> [Borrow]:
        """Get all borrows of a place (or prefix/suffix)."""
        var result: [Borrow] = []
        for id in self.borrows_keys(borrows):
            val borrow = self.borrows[id]
            if place_conflicts_with(borrow.place, place):
                result = result_push(result, borrow)
        result

    fn has_conflicting_borrow(place: Place, kind: BorrowKind) -> has_Borrow:
        """Check if there's a conflicting borrow."""
        for id in self.borrows_keys(borrows):
            val borrow = self.borrows[id]
            if place_conflicts_with(borrow.place, place):
                if kind_conflicts_with(borrow.kind, kind):
                    return borrow
        nil

# ============================================================================
# Borrow Graph
# ============================================================================

struct BorrowError:
    """Borrow checking error."""
    message: text
    # # DESUGARED: borrow: Borrow
    has_borrow: bool
    borrow: Borrow
    # # DESUGARED: conflicting: Borrow
    has_conflicting: bool
    conflicting: Borrow
    point: i64


# ============================================================================
# BorrowError Methods (was: impl BorrowError:)
# ============================================================================

fn borrowerror_conflict(borrow: Borrow, conflicting: Borrow, point: i64) -> BorrowError:
        BorrowError(
            message: "Conflicting borrows",
            # # DESUGARED: borrow: Some(borrow)
            borrow: borrow,
            # # DESUGARED: conflicting: Some(conflicting)
            conflicting: conflicting,
            point: point
        )


fn borrowerror_use_after_move(place: Place, point: i64) -> BorrowError:
        BorrowError(
            message: "Use of moved value: {place.to_text()}",
            #  # DESUGARED: borrow: nil
            #  # DESUGARED: conflicting: nil
            point: point
        )


fn borrowerror_borrow_of_moved(place: Place, point: i64) -> BorrowError:
        BorrowError(
            message: "Borrow of moved value: {place.to_text()}",
            #  # DESUGARED: borrow: nil
            #  # DESUGARED: conflicting: nil
            point: point
        )


class BorrowGraph:
    """Graph tracking borrows throughout a function.

    Nodes are program points, edges represent borrow flow.
    """
    # Borrows active at each program point
    point_borrows: Dict<i64, BorrowSet>

    # Places that have been moved
    moved_places: Dict<i64, [Place]>

    # Accumulated errors
    errors: [BorrowError]

    # Lifetime environment
    lifetimes: LifetimeEnv

    static fn create() -> BorrowGraph:
        BorrowGraph(
            point_borrows: {},
            moved_places: {},
            errors: [],
            lifetimes: lifetimeenv_create()
        )

    me get_or_create_borrows(point: i64) -> BorrowSet:
        """Get or create borrow set for a program point."""
        match self.point_borrows_get(point_borrows, point):
            case set: set
            case nil:
                val set = borrowset_create()
                self.point_borrows[point] = set
                set

    me record_borrow(point: i64, place: Place, kind: BorrowKind) -> has_Borrow:
        """Record a borrow at a program point.

        Returns the borrow if successful, nil if conflicting.
        """
        var borrow_set = self.get_or_create_borrows(point)

        # Check for conflicts
        match borrow_set_has_conflicting_borrow(borrow_set, place, kind):
            case conflict:
                val new_borrow = borrow_create(0, place, kind, self.lifetimes.fresh_lifetime(), point)
                self.errors = self.errors_push(errors, BorrowError.conflict(new_borrow, conflict, point))
                return nil
            case nil:
                pass

        # Check if place was moved
        val moved = self.moved_places_get(moved_places, point) ?? []
        for moved_place in moved:
            if place_conflicts_with(place, moved_place):
                self.errors = self.errors_push(errors, BorrowError.borrow_of_moved(place, point))
                return nil

        # Create the borrow
        val lifetime = self.lifetimes_fresh_lifetime(lifetimes)
        val borrow = borrow_set_add_borrow(borrow_set, place, kind, lifetime, point)
        self.point_borrows[point] = borrow_set

        borrow

    me record_use(point: i64, place: Place):
        """Record a use of a place.

        Checks that place hasn't been moved.
        """
        val moved = self.moved_places_get(moved_places, point) ?? []
        for moved_place in moved:
            if place_conflicts_with(place, moved_place):
                self.errors = self.errors_push(errors, BorrowError.use_after_move(place, point))
                return

    me record_move(point: i64, place: Place):
        """Record a move of a place."""
        var moved = self.moved_places_get(moved_places, point) ?? []
        moved = moved_push(moved, place)
        self.moved_places[point] = moved

    me record_assign(point: i64, place: Place):
        """Record an assignment to a place.

        This may invalidate borrows of the place.
        """
        var borrow_set = self.get_or_create_borrows(point)

        # Find conflicting borrows
        val conflicts = borrow_set_borrows_of(borrow_set, place)
        for borrow in conflicts:
            if kind_is_mutable(borrow.kind):
                self.errors = self.errors.push(BorrowError(
                    message: "Assignment while mutably borrowed: {place.to_text()}",
                    # # DESUGARED: borrow: Some(borrow)
            borrow: borrow,
                    conflicting: nil,
                    point: point
                ))

    me end_borrow(point: i64, borrow_id: i64):
        """End a borrow at a program point."""
        var borrow_set = self.get_or_create_borrows(point)
        borrow_set_remove_borrow(borrow_set, borrow_id)
        self.point_borrows[point] = borrow_set

    me propagate_borrows(from_point: i64, to_point: i64):
        """Propagate borrows from one point to another (control flow)."""
        val from_set = self.get_or_create_borrows(from_point)
        var to_set = self.get_or_create_borrows(to_point)

        for id in from_set.borrows_keys(borrows):
            val borrow = from_set.borrows[id]
            # Check if borrow is still live at to_point
            # (simplified: copy all borrows)
            to_set.borrows[borrow.id] = borrow

        self.point_borrows[to_point] = to_set

    fn get_errors() -> [BorrowError]:
        """Get all borrow errors."""
        self.errors

    fn has_errors() -> bool:
        """Check if there are borrow errors."""
        not self.errors_is_empty(errors)

# ============================================================================
# Exports
# ============================================================================

export PlaceBase, PlaceElem, Place
export BorrowKind, Borrow, BorrowSet
export BorrowError, BorrowGraph
export place_base_equals, place_elem_equals, place_conflicts_with
export kind_conflicts_with, kind_is_mutable

# Export desugared static methods
export Place__local
export Place__static_var
export Borrow__create
export Borrow__two_phase
export BorrowSet__create
export BorrowGraph__create
