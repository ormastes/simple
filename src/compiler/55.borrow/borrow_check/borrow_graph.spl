# Borrow Graph
#
# Tracks borrows and their relationships for borrow checking.
# The borrow graph represents:
# - Active borrows at each program point
# - Conflicts between borrows
# - Invalidation of borrows
#
# Based on Rust's MIR borrow checker.

use compiler.borrow_check.lifetime.*

# ============================================================================
# Borrow Graph - Manual Desugaring
# ============================================================================

# Manual desugaring of static methods for bootstrap runtime compatibility
fn Place__local(id: i64) -> Place:
    Place(base: placebase_Local(id), projections: [])

fn Place__static_var(name: text) -> Place:
    Place(base: placebase_Static(name), projections: [])

fn Borrow__create(id: i64, place: Place, kind: BorrowKind, lifetime: Lifetime, point: i64) -> Borrow:
    Borrow(
        id: id,
        place: place,
        kind: kind,
        lifetime: lifetime,
        borrow_point: point,
        activated: true
    )

fn Borrow__two_phase(id: i64, place: Place, kind: BorrowKind, lifetime: Lifetime, point: i64) -> Borrow:
    Borrow(
        id: id,
        place: place,
        kind: kind,
        lifetime: lifetime,
        borrow_point: point,
        activated: false
    )

fn BorrowSet__create() -> BorrowSet:
    BorrowSet(borrows: {}, next_id: 0)

fn BorrowGraph__create() -> BorrowGraph:
    BorrowGraph(
        point_borrows: {},
        moved_places: {},
        errors: [],
        lifetimes: LifetimeEnv__create()
    )

# ============================================================================
# Place (Memory Location)
# ============================================================================

enum PlaceBase:
    """Base of a memory place."""
    Local(id: i64)       # Local variable
    Static(name: text)   # Static variable
    Promoted(id: i64)    # Promoted constant

enum PlaceElem:
    """Element in a place projection."""
    Deref                      # *place
    Field(idx: i64)            # place.field
    Index(local: i64)          # place[idx]
    ConstantIndex(idx: i64)    # place[constant]
    Downcast(variant: i64)     # (place, )

struct Place:
    """A memory location (lvalue).

    Places are paths to memory: local, local.field, *local, etc.
    """
    base: PlaceBase
    projections: [PlaceElem]


# ============================================================================
# Place Methods (was: impl Place:)
# ============================================================================

fn place_local(id: i64) -> Place:
        """Create place for local variable."""
        Place(base: placebase_Local(id), projections: [])


fn place_static_var(name: text) -> Place:
        """Create place for static variable."""
        Place(base: placebase_Static(name), projections: [])


fn place_deref(self: Place) -> Place:
        """Add dereference projection."""
        Place(
            base: self.base,
            projections: self.projections_push(projections, PlaceElem.Deref)
        )


fn place_field(self: Place, idx: i64) -> Place:
        """Add field projection."""
        Place(
            base: self.base,
            projections: self.projections_push(projections, PlaceElem.Field(idx))
        )


fn place_index(self: Place, local: i64) -> Place:
        """Add index projection."""
        Place(
            base: self.base,
            projections: self.projections_push(projections, PlaceElem.Index(local))
        )


# ============================================================================
# Borrow Kind
# ============================================================================

enum BorrowKind:
    """Kind of borrow."""
    Shared      # &T - immutable borrow
    Mutable     # &mut T - mutable borrow
    Unique      # Unique borrow (for closures)


# ============================================================================
# BorrowKind Methods (was: impl BorrowKind:)
# ============================================================================

# ============================================================================
# Borrow
# ============================================================================

struct Borrow:
    """A borrow of a place.

    Tracks where, what kind, and for how long.
    """
    id: i64
    place: Place
    kind: BorrowKind
    lifetime: Lifetime
    borrow_point: i64    # Where borrow was created
    activated: bool      # Two-phase borrow: activated yet


# ============================================================================
# Borrow Methods (was: impl Borrow:)
# ============================================================================

fn borrow_create(id: i64, place: Place, kind: BorrowKind, lifetime: Lifetime, point: i64) -> Borrow:
        Borrow(
            id: id,
            place: place,
            kind: kind,
            lifetime: lifetime,
            borrow_point: point,
            activated: true
        )


fn borrow_two_phase(id: i64, place: Place, kind: BorrowKind, lifetime: Lifetime, point: i64) -> Borrow:
        """Create two-phase borrow (not yet activated)."""
        Borrow(
            id: id,
            place: place,
            kind: kind,
            lifetime: lifetime,
            borrow_point: point,
            activated: false
        )


# ============================================================================
# Borrow Set
# ============================================================================

class BorrowSet:
    """Set of active borrows at a program point."""
    borrows: Dict<i64, Borrow>
    next_id: i64

    static fn create() -> BorrowSet:
        BorrowSet(borrows: {}, next_id: 0)

    me add_borrow(place: Place, kind: BorrowKind, lifetime: Lifetime, point: i64) -> Borrow:
        """Add a new borrow."""
        val id = self.next_id
        self.next_id = self.next_id + 1

        val borrow = borrow_create(id, place, kind, lifetime, point)
        self.borrows[id] = borrow
        borrow

    me remove_borrow(id: i64):
        """Remove a borrow."""
        self.borrows_remove(borrows, id)

    fn get_borrow(id: i64) -> has_Borrow:
        """Get a borrow by ID."""
        self.borrows_get(borrows, id)

    fn active_borrows() -> [Borrow]:
        """Get all active borrows."""
        var result: [Borrow] = []
        for id in self.borrows_keys(borrows):
            val borrow = self.borrows[id]
            result = result_push(result, borrow)
        result

    fn borrows_of(place: Place) -> [Borrow]:
        """Get all borrows of a place (or prefix/suffix)."""
        var result: [Borrow] = []
        for id in self.borrows_keys(borrows):
            val borrow = self.borrows[id]
            if borrow.place_conflicts_with(place, place):
                result = result_push(result, borrow)
        result

    fn has_conflicting_borrow(place: Place, kind: BorrowKind) -> has_Borrow:
        """Check if there's a conflicting borrow."""
        for id in self.borrows_keys(borrows):
            val borrow = self.borrows[id]
            if borrow.place_conflicts_with(place, place):
                if borrow.kind_conflicts_with(kind, kind):
                    return borrow
        nil

# ============================================================================
# Borrow Graph
# ============================================================================

struct BorrowError:
    """Borrow checking error."""
    message: text
    # # DESUGARED: borrow: Borrow
    has_borrow: bool
    borrow: Borrow
    # # DESUGARED: conflicting: Borrow
    has_conflicting: bool
    conflicting: Borrow
    point: i64


# ============================================================================
# BorrowError Methods (was: impl BorrowError:)
# ============================================================================

fn borrowerror_conflict(borrow: Borrow, conflicting: Borrow, point: i64) -> BorrowError:
        BorrowError(
            message: "Conflicting borrows",
            # # DESUGARED: borrow: Some(borrow)
            borrow: borrow,
            # # DESUGARED: conflicting: Some(conflicting)
            conflicting: conflicting,
            point: point
        )


fn borrowerror_use_after_move(place: Place, point: i64) -> BorrowError:
        BorrowError(
            message: "Use of moved value: {place.to_text()}",
            #  # DESUGARED: borrow: nil
            #  # DESUGARED: conflicting: nil
            point: point
        )


fn borrowerror_borrow_of_moved(place: Place, point: i64) -> BorrowError:
        BorrowError(
            message: "Borrow of moved value: {place.to_text()}",
            #  # DESUGARED: borrow: nil
            #  # DESUGARED: conflicting: nil
            point: point
        )


class BorrowGraph:
    """Graph tracking borrows throughout a function.

    Nodes are program points, edges represent borrow flow.
    """
    # Borrows active at each program point
    point_borrows: Dict<i64, BorrowSet>

    # Places that have been moved
    moved_places: Dict<i64, [Place]>

    # Accumulated errors
    errors: [BorrowError]

    # Lifetime environment
    lifetimes: LifetimeEnv

    static fn create() -> BorrowGraph:
        BorrowGraph(
            point_borrows: {},
            moved_places: {},
            errors: [],
            lifetimes: lifetimeenv_create()
        )

    me get_or_create_borrows(point: i64) -> BorrowSet:
        """Get or create borrow set for a program point."""
        match self.point_borrows_get(point_borrows, point):
            case set: set
            case nil:
                val set = borrowset_create()
                self.point_borrows[point] = set
                set

    me record_borrow(point: i64, place: Place, kind: BorrowKind) -> has_Borrow:
        """Record a borrow at a program point.

        Returns the borrow if successful, nil if conflicting.
        """
        var borrow_set = self.get_or_create_borrows(point)

        # Check for conflicts
        match borrow_set_has_conflicting_borrow(borrow_set, place, kind):
            case conflict:
                val new_borrow = borrow_create(0, place, kind, self.lifetimes.fresh_lifetime(), point)
                self.errors = self.errors_push(errors, BorrowError.conflict(new_borrow, conflict, point))
                return nil
            case nil:
                pass

        # Check if place was moved
        val moved = self.moved_places_get(moved_places, point) ?? []
        for moved_place in moved:
            if place_conflicts_with(place, moved_place):
                self.errors = self.errors_push(errors, BorrowError.borrow_of_moved(place, point))
                return nil

        # Create the borrow
        val lifetime = self.lifetimes_fresh_lifetime(lifetimes)
        val borrow = borrow_set_add_borrow(borrow_set, place, kind, lifetime, point)
        self.point_borrows[point] = borrow_set

        borrow

    me record_use(point: i64, place: Place):
        """Record a use of a place.

        Checks that place hasn't been moved.
        """
        val moved = self.moved_places_get(moved_places, point) ?? []
        for moved_place in moved:
            if place_conflicts_with(place, moved_place):
                self.errors = self.errors_push(errors, BorrowError.use_after_move(place, point))
                return

    me record_move(point: i64, place: Place):
        """Record a move of a place."""
        var moved = self.moved_places_get(moved_places, point) ?? []
        moved = moved_push(moved, place)
        self.moved_places[point] = moved

    me record_assign(point: i64, place: Place):
        """Record an assignment to a place.

        This may invalidate borrows of the place.
        """
        var borrow_set = self.get_or_create_borrows(point)

        # Find conflicting borrows
        val conflicts = borrow_set_borrows_of(borrow_set, place)
        for borrow in conflicts:
            if borrow.kind_is_mutable(kind):
                self.errors = self.errors.push(BorrowError(
                    message: "Assignment while mutably borrowed: {place.to_text()}",
                    # # DESUGARED: borrow: Some(borrow)
            borrow: borrow,
                    conflicting: nil,
                    point: point
                ))

    me end_borrow(point: i64, borrow_id: i64):
        """End a borrow at a program point."""
        var borrow_set = self.get_or_create_borrows(point)
        borrow_set_remove_borrow(borrow_set, borrow_id)
        self.point_borrows[point] = borrow_set

    me propagate_borrows(from_point: i64, to_point: i64):
        """Propagate borrows from one point to another (control flow)."""
        val from_set = self.get_or_create_borrows(from_point)
        var to_set = self.get_or_create_borrows(to_point)

        for id in from_set.borrows_keys(borrows):
            val borrow = from_set.borrows[id]
            # Check if borrow is still live at to_point
            # (simplified: copy all borrows)
            to_set.borrows[borrow.id] = borrow

        self.point_borrows[to_point] = to_set

    fn get_errors() -> [BorrowError]:
        """Get all borrow errors."""
        self.errors

    fn has_errors() -> bool:
        """Check if there are borrow errors."""
        not self.errors_is_empty(errors)

# ============================================================================
# Exports
# ============================================================================

export PlaceBase, PlaceElem, Place
export BorrowKind, Borrow, BorrowSet
export BorrowError, BorrowGraph

# Export desugared static methods
export Place__local
export Place__static_var
export Borrow__create
export Borrow__two_phase
export BorrowSet__create
export BorrowGraph__create
