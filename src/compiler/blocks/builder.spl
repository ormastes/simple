# Block Builder API - Fluent Builder Pattern
#
# Declarative, fluent API for creating custom blocks with features.
# Progressive disclosure: start simple, add features as needed.

use blocks.definition.{BlockDefinition, ConstValue, HighlightToken, Completion, HoverInfo, BlockExample}
use blocks.value.{BlockValue}
use blocks.context.{BlockContext, BlockError}
use blocks.modes.{LexerMode, SyntaxFeatures}

# ============================================================================
# Block Builder
# ============================================================================

struct BlockBuilder:
    """Fluent builder for custom blocks.

    Provides a declarative, chainable API for block configuration:

    Example:
    ```simple
    val sql = BlockBuilder("sql")
        .raw_text()
        .simple_parser(\text: parse_sql(text))
        .simple_validator(\val: validate_sql(val))
        .build()
    ```

    Features:
    - Fluent method chaining
    - Smart defaults
    - Feature presets (enable_all_math, enable_pipelines)
    - Simple parser/validator signatures
    - IDE support (highlight, completions, hover)
    """

    # Core configuration
    _kind: text
    _mode: LexerMode
    _features: SyntaxFeatures

    # Parser (required)
    _parser: fn(text, BlockContext) -> Result<BlockValue, BlockError>?

    # Optional hooks
    _validator: fn(BlockValue, BlockContext) -> [BlockError]?
    _const_eval: fn(BlockValue) -> ConstValue?

    # IDE support hooks
    _highlighter: fn(text) -> [HighlightToken]?
    _completer: fn(text, i64) -> [Completion]?
    _hover: fn(text, i64) -> HoverInfo?

    # Documentation
    _description: text
    _examples: [BlockExample]

impl BlockBuilder:
    # ========================================================================
    # Constructor
    # ========================================================================

    static fn new(kind: text) -> BlockBuilder:
        """Create a new builder for a block type.

        Args:
            kind: Block keyword (e.g., "sql", "json", "tensor")

        Returns:
            Builder with smart defaults
        """
        BlockBuilder(
            _kind: kind,
            _mode: LexerMode.Raw,  # Safest default
            _features: SyntaxFeatures.default(),  # No features by default
            _parser: nil,  # Required - must be set
            _validator: nil,
            _const_eval: nil,
            _highlighter: nil,
            _completer: nil,
            _hover: nil,
            _description: "",
            _examples: []
        )

    # ========================================================================
    # Lexer Mode Configuration
    # ========================================================================

    me lexer_mode(mode: LexerMode) -> BlockBuilder:
        """Set the lexer mode explicitly.

        Args:
            mode: LexerMode (Raw, Math, Normal, or Custom)

        Returns:
            Self for chaining
        """
        self._mode = mode
        self

    me raw_text() -> BlockBuilder:
        """Use raw text mode (no tokenization).

        Shortcut for `.lexer_mode(LexerMode.Raw)`.
        Best for DSLs, JSON, SQL, shell commands.

        Returns:
            Self for chaining
        """
        self._mode = LexerMode.Raw
        self

    me math_mode() -> BlockBuilder:
        """Use math mode (enable math operators).

        Shortcut for `.lexer_mode(LexerMode.Math)`.
        Enables: ^, ', implicit multiplication.

        Returns:
            Self for chaining
        """
        self._mode = LexerMode.Math
        self

    me normal_mode() -> BlockBuilder:
        """Use normal Simple tokenization.

        Shortcut for `.lexer_mode(LexerMode.Normal)`.
        Use for blocks with Simple syntax + custom features.

        Returns:
            Self for chaining
        """
        self._mode = LexerMode.Normal
        self

    # ========================================================================
    # Syntax Features
    # ========================================================================

    me enable_feature(name: text) -> BlockBuilder:
        """Enable a syntax feature by name.

        Available features:
        - Math: "power_caret", "transpose_quote", "implicit_multiplication", "broadcast_ops", "matrix_mul"
        - Pipeline: "pipe_forward", "composition"
        - ML: "auto_backward", "disable_grad"

        Args:
            name: Feature name

        Returns:
            Self for chaining
        """
        match name:
            # Math features
            case "power_caret":
                self._features.power_caret = true
            case "transpose_quote":
                self._features.transpose_quote = true
            case "implicit_multiplication":
                self._features.implicit_multiplication = true
            case "broadcast_ops":
                self._features.broadcast_ops = true
            case "matrix_mul":
                self._features.matrix_mul = true

            # ML features
            case "auto_backward":
                self._features.auto_backward = true
            case "disable_grad":
                self._features.disable_grad = true

            # Pipeline features
            case "pipe_forward":
                self._features.pipe_forward = true
            case "composition":
                self._features.composition = true

            case _:
                # Unknown feature - could log warning
                pass

        self

    me disable_feature(name: text) -> BlockBuilder:
        """Disable a syntax feature by name.

        Args:
            name: Feature name

        Returns:
            Self for chaining
        """
        match name:
            case "power_caret":
                self._features.power_caret = false
            case "transpose_quote":
                self._features.transpose_quote = false
            case "implicit_multiplication":
                self._features.implicit_multiplication = false
            case "broadcast_ops":
                self._features.broadcast_ops = false
            case "matrix_mul":
                self._features.matrix_mul = false
            case "auto_backward":
                self._features.auto_backward = false
            case "disable_grad":
                self._features.disable_grad = false
            case "pipe_forward":
                self._features.pipe_forward = false
            case "composition":
                self._features.composition = false
            case _:
                pass

        self

    me enable_all_math() -> BlockBuilder:
        """Enable all math features at once.

        Enables: power_caret, transpose_quote, implicit_multiplication, broadcast_ops, matrix_mul

        Returns:
            Self for chaining
        """
        self._features = SyntaxFeatures.math()
        self

    me enable_pipelines() -> BlockBuilder:
        """Enable all pipeline operators.

        Enables: pipe_forward, composition

        Returns:
            Self for chaining
        """
        self._features.pipe_forward = true
        self._features.composition = true
        self

    me enable_deep_learning() -> BlockBuilder:
        """Enable deep learning features.

        Enables: auto_backward (for loss blocks)

        Returns:
            Self for chaining
        """
        self._features.auto_backward = true
        self

    # ========================================================================
    # Parser Configuration
    # ========================================================================

    me simple_parser(parser_fn: fn(text) -> Result<BlockValue, text>) -> BlockBuilder:
        """Set parser with simple signature.

        Args:
            fn: Parser function (text -> Result<BlockValue, text>)

        Returns:
            Self for chaining

        Example:
        ```simple
        .simple_parser(\text:
            parse_json(text)
        )
        ```
        """
        # Wrap simple parser to match full signature
        self._parser = Some(\payload, ctx:
            match parser_fn(payload):
                case Ok(value): Ok(value)
                case Err(message): Err(BlockError.parse(message))
        )
        self

    me parser(parser_fn: fn(text, BlockContext) -> Result<BlockValue, BlockError>) -> BlockBuilder:
        """Set parser with full signature.

        Args:
            parser_fn: Parser function with full context

        Returns:
            Self for chaining

        Example:
        ```simple
        .parser(\payload, ctx:
            parse_sql(payload, ctx.file_path)
        )
        ```
        """
        self._parser = Some(parser_fn)
        self

    # ========================================================================
    # Validation Configuration
    # ========================================================================

    me simple_validator(validator_fn: fn(BlockValue) -> [text]) -> BlockBuilder:
        """Set validator with simple signature.

        Args:
            fn: Validator function (BlockValue -> [text])

        Returns:
            Self for chaining

        Example:
        ```simple
        .simple_validator(\value:
            match value:
                case Sql(query): validate_sql_syntax(query)
                case _: ["Expected SQL query"]
        )
        ```
        """
        # Wrap simple validator to match full signature
        self._validator = Some(\value, ctx:
            val messages = validator_fn(value)
            messages.map(\msg: BlockError.validation(msg))
        )
        self

    me validator(validator_fn: fn(BlockValue, BlockContext) -> [BlockError]) -> BlockBuilder:
        """Set validator with full signature.

        Args:
            fn: Validator function with full context

        Returns:
            Self for chaining
        """
        self._validator = Some(validator_fn)
        self

    # ========================================================================
    # Compile-Time Evaluation
    # ========================================================================

    me const_eval(eval_fn: fn(BlockValue) -> ConstValue?) -> BlockBuilder:
        """Set compile-time evaluation function.

        Args:
            fn: Function to evaluate block at compile time

        Returns:
            Self for chaining

        Example:
        ```simple
        .const_eval(\value:
            match value:
                case Regex(p): Some(ConstValue.String(p.raw))
                case _: nil
        )
        ```
        """
        self._const_eval = Some(eval_fn)
        self

    # ========================================================================
    # IDE Support
    # ========================================================================

    me highlighter(highlighter_fn: fn(text) -> [HighlightToken]) -> BlockBuilder:
        """Set syntax highlighting function.

        Args:
            fn: Function to produce highlight tokens

        Returns:
            Self for chaining
        """
        self._highlighter = Some(highlighter_fn)
        self

    me completer(completer_fn: fn(text, i64) -> [Completion]) -> BlockBuilder:
        """Set completion function.

        Args:
            fn: Function to provide completions at cursor

        Returns:
            Self for chaining
        """
        self._completer = Some(completer_fn)
        self

    me hover_provider(hover_fn: fn(text, i64) -> HoverInfo?) -> BlockBuilder:
        """Set hover information provider.

        Args:
            fn: Function to provide hover info at cursor

        Returns:
            Self for chaining
        """
        self._hover = Some(hover_fn)
        self

    # ========================================================================
    # Documentation
    # ========================================================================

    me doc(description: text) -> BlockBuilder:
        """Set block description.

        Args:
            description: Human-readable description

        Returns:
            Self for chaining
        """
        self._description = description
        self

    me example(code: text, description: text, output: text? = nil) -> BlockBuilder:
        """Add an example.

        Args:
            code: Example code
            description: What it demonstrates
            output: Expected output (optional)

        Returns:
            Self for chaining
        """
        val ex = BlockExample(
            code: code,
            description: description,
            output: output
        )
        self._examples = self._examples.push(ex)
        self

    # ========================================================================
    # Build
    # ========================================================================

    fn build() -> BlockDefinition:
        """Build the final BlockDefinition.

        Validates configuration and returns a BlockDefinition ready
        to register.

        Panics:
            If parser is not set (required)

        Returns:
            BlockDefinition
        """
        # Validate required fields
        if not self._parser.?:
            panic("BlockBuilder: parser is required. Use .simple_parser() or .parser()")

        # Build the definition
        BuiltBlockDef(
            _kind: self._kind,
            _mode: self._mode,
            _features: self._features,
            _parser: self._parser.unwrap(),
            _validator: self._validator,
            _const_eval: self._const_eval,
            _highlighter: self._highlighter,
            _completer: self._completer,
            _hover: self._hover,
            _description: self._description,
            _examples: self._examples
        )

# ============================================================================
# Implementation: Built Block Definition
# ============================================================================

struct BuiltBlockDef(BlockDefinition):
    """BlockDefinition built from BlockBuilder.

    Implements all methods using captured builder state.
    """

    # Configuration from builder
    _kind: text
    _mode: LexerMode
    _features: SyntaxFeatures

    # Required
    _parser: fn(text, BlockContext) -> Result<BlockValue, BlockError>

    # Optional
    _validator: fn(BlockValue, BlockContext) -> [BlockError]?
    _const_eval: fn(BlockValue) -> ConstValue?
    _highlighter: fn(text) -> [HighlightToken]?
    _completer: fn(text, i64) -> [Completion]?
    _hover: fn(text, i64) -> HoverInfo?

    # Documentation
    _description: text
    _examples: [BlockExample]

    # --- Required Methods ---

    fn kind() -> text:
        self._kind

    fn parse_payload(payload: text, ctx: BlockContext) -> Result<BlockValue, BlockError>:
        (self._parser)(payload, ctx)

    # --- Optional Methods ---

    fn lexer_mode() -> LexerMode:
        self._mode

    fn syntax_features() -> SyntaxFeatures:
        self._features

    fn validate(value: BlockValue, ctx: BlockContext) -> [BlockError]:
        match self._validator:
            case Some(validator):
                validator(value, ctx)
            case None:
                []

    fn eval_const(value: BlockValue) -> ConstValue?:
        match self._const_eval:
            case Some(eval):
                eval(value)
            case None:
                nil

    fn highlight(payload: text) -> [HighlightToken]:
        match self._highlighter:
            case Some(highlighter):
                highlighter(payload)
            case None:
                []

    fn completions(payload: text, cursor: i64) -> [Completion]:
        match self._completer:
            case Some(completer):
                completer(payload, cursor)
            case None:
                []

    fn hover(payload: text, cursor: i64) -> HoverInfo?:
        match self._hover:
            case Some(hover_fn):
                hover_fn(payload, cursor)
            case None:
                nil

    fn description() -> text:
        if self._description.?:
            self._description
        else:
            "Custom block: {self._kind}"

    fn examples() -> [BlockExample]:
        self._examples

# ============================================================================
# Exports
# ============================================================================

export BlockBuilder
