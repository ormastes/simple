# Builtin Math Block Definitions
#
# Math-mode block types:
# - Math blocks (m{...}): Mathematical notation
# - Loss blocks (loss{...}): Automatic differentiation
# - Nograd blocks (nograd{...}): Gradient-free zones

use blocks.{BlockDefinition, BlockValue, BlockRegistry}
use blocks.modes.{PreLexInfo, BlockSkipPolicy, BlockOutlineInfo, BlockToken, BlockTokenKind, TextSpan}
use blocks.context.{BlockContext, BlockError}
use compiler.hir.HirType
use value.ConstValue

struct MathBlockDef(BlockDefinition):
    r"""Math block: enables math-like syntax.

    Features:
    - ^ as power operator (x^2)
    - ' as transpose operator (A')
    - Implicit multiplication (2x, (a)(b))
    - Broadcast operators (.+ .- .* ./ .^)
    - Matrix multiplication (@)

    Example:
        val result = m{ x^2 + 2*x*y + y^2 }
        val norm = m{ sqrt(x'x) }
    """

impl MathBlockDef:
    fn kind() -> text:
        "m"

    fn parse_payload(payload: text, ctx: BlockContext) -> Result<BlockValue, BlockError>:
        # Math blocks return raw payload - parsed with math mode by parser
        Ok(BlockValue.Raw(payload))

    fn lexer_mode() -> LexerMode:
        LexerMode.Math

    fn syntax_features() -> SyntaxFeatures:
        SyntaxFeatures.math()

    fn description() -> text:
        "Math block with power (^), transpose ('), and implicit multiplication"

    fn examples() -> [BlockExample]:
        [
            BlockExample(
                code: "m\{ x^2 + y^2 }",
                description: "Power operator",
                output: nil
            ),
            BlockExample(
                code: "m\{ A' @ A }",
                description: "Transpose and matrix multiply",
                output: nil
            ),
            BlockExample(
                code: "m\{ 2x + 3y }",
                description: "Implicit multiplication",
                output: nil
            )
        ]

    fn highlight(payload: text) -> [HighlightToken]:
        # Basic highlighting for math expressions
        var tokens: [HighlightToken] = []
        var i = 0
        while i < payload.len():
            val c = payload[i]
            match c:
                case '^' | '\'' | '@' | '+' | '-' | '*' | '/':
                    tokens = tokens.push(HighlightToken(
                        start: i,
                        end: i + 1,
                        kind: HighlightKind.Operator
                    ))
                case '0' | '1' | '2' | '3' | '4' | '5' | '6' | '7' | '8' | '9':
                    val start = i
                    while i < payload.len() and payload[i].is_digit():
                        i = i + 1
                    tokens = tokens.push(HighlightToken(
                        start: start,
                        end: i,
                        kind: HighlightKind.Number
                    ))
                    continue
                case _:
                    pass
            i = i + 1
        tokens

    # --- Three-level interface (reference implementation) ---

    fn lex(payload: text, pre_lex: PreLexInfo, ctx: BlockContext) -> Result<[BlockToken], BlockError>:
        """Sub-lexer for math blocks. Tokenizes identifiers, numbers, operators."""
        var tokens: [BlockToken] = []
        var i = 0
        while i < payload.len():
            # Skip whitespace
            if payload[i].is_whitespace():
                val start = i
                while i < payload.len() and payload[i].is_whitespace():
                    i = i + 1
                tokens = tokens.push(BlockToken.new(BlockTokenKind.Whitespace, start, i, payload[start:i]))
                continue

            # Skip positions inside pre-scanned comments
            if pre_lex.is_in_comment(i):
                val start = i
                while i < payload.len() and pre_lex.is_in_comment(i):
                    i = i + 1
                tokens = tokens.push(BlockToken.new(BlockTokenKind.Comment, start, i, payload[start:i]))
                continue

            # Numbers
            if payload[i].is_digit():
                val start = i
                while i < payload.len() and (payload[i].is_digit() or payload[i] == '.'):
                    i = i + 1
                tokens = tokens.push(BlockToken.new(BlockTokenKind.Number, start, i, payload[start:i]))
                continue

            # Identifiers
            if payload[i].is_alphabetic() or payload[i] == '_':
                val start = i
                while i < payload.len() and (payload[i].is_alphanumeric() or payload[i] == '_'):
                    i = i + 1
                tokens = tokens.push(BlockToken.new(BlockTokenKind.Identifier, start, i, payload[start:i]))
                continue

            # Operators: ^ ' @ + - * / . = < > ! ( )
            val c = payload[i]
            if c == '^' or c == '\'' or c == '@' or c == '+' or c == '-' or c == '*' or c == '/':
                tokens = tokens.push(BlockToken.new(BlockTokenKind.Operator, i, i + 1, payload[i:i+1]))
                i = i + 1
                continue

            # Punctuation: ( ) , ;
            if c == '(' or c == ')' or c == ',' or c == ';':
                tokens = tokens.push(BlockToken.new(BlockTokenKind.Punctuation, i, i + 1, payload[i:i+1]))
                i = i + 1
                continue

            # Everything else
            tokens = tokens.push(BlockToken.new(BlockTokenKind.Error, i, i + 1, payload[i:i+1]))
            i = i + 1

        Ok(tokens)

    fn treesitter_outline(payload: text, pre_lex: PreLexInfo) -> BlockOutlineInfo:
        """Extract identifiers from math expressions for outline."""
        var identifiers: [text] = []
        var i = 0
        while i < payload.len():
            # Skip protected regions
            if pre_lex.is_protected(i):
                i = i + 1
                continue

            if payload[i].is_alphabetic() or payload[i] == '_':
                val start = i
                while i < payload.len() and (payload[i].is_alphanumeric() or payload[i] == '_'):
                    i = i + 1
                val ident = payload[start:i]
                if not (ident in identifiers):
                    identifiers = identifiers.push(ident)
                continue

            i = i + 1

        BlockOutlineInfo(
            kind: "m",
            identifiers: identifiers,
            external_refs: [],
            structure_kind: Some("expression"),
            is_opaque: false
        )

    fn parse_full(payload: text, pre_lex: PreLexInfo, ctx: BlockContext) -> Result<BlockValue, BlockError>:
        """Full parse using pre-lex info. Delegates to parse_payload for now."""
        self.parse_payload(payload, ctx)

    fn skip_policy() -> BlockSkipPolicy:
        """Math blocks need outline for IDE features."""
        BlockSkipPolicy.OutlineRequired

# ============================================================================
# Loss Block (loss{})
# ============================================================================

struct LossBlockDef(BlockDefinition):
    r"""Loss block: math mode with automatic backward pass.

    Inherits all math block features plus:
    - Automatic gradient tracking
    - Calls .backward() on the result

    Example:
        loss{
            pred = model(x)
            cross_entropy(pred, y)
        }
    """

impl LossBlockDef:
    fn kind() -> text:
        "loss"

    fn parse_payload(payload: text, ctx: BlockContext) -> Result<BlockValue, BlockError>:
        # Loss blocks return raw payload - converted to LossBlock by parser
        Ok(BlockValue.Raw(payload))

    fn lexer_mode() -> LexerMode:
        LexerMode.Math

    fn syntax_features() -> SyntaxFeatures:
        SyntaxFeatures.loss()

    fn description() -> text:
        "Loss computation with auto-backward"

    fn examples() -> [BlockExample]:
        [
            BlockExample(
                code: "loss\{ mse(pred, target) }",
                description: "MSE loss with auto-backward",
                output: nil
            ),
            BlockExample(
                code: "loss\{\n    logits = model(x)\n    cross_entropy(logits, y)\n}",
                description: "Multi-line loss computation",
                output: nil
            )
        ]

# ============================================================================
# Nograd Block (nograd{})
# ============================================================================

struct NogradBlockDef(BlockDefinition):
    r"""Nograd block: math mode with gradient tracking disabled.

    Inherits all math block features plus:
    - Disables gradient tracking
    - Used for inference/evaluation

    Example:
        nograd{
            val pred = model(x)
            accuracy(pred, y)
        }
    """

impl NogradBlockDef:
    fn kind() -> text:
        "nograd"

    fn parse_payload(payload: text, ctx: BlockContext) -> Result<BlockValue, BlockError>:
        # Nograd blocks return raw payload - converted to NogradBlock by parser
        Ok(BlockValue.Raw(payload))

    fn lexer_mode() -> LexerMode:
        LexerMode.Math

    fn syntax_features() -> SyntaxFeatures:
        SyntaxFeatures.nograd()

    fn description() -> text:
        "Computation with gradient tracking disabled"

    fn examples() -> [BlockExample]:
        [
            BlockExample(
                code: "nograd\{ model(test_data) }",
                description: "Inference without gradients",
                output: nil
            )
        ]

export MathBlockDef, LossBlockDef, NogradBlockDef
