# Block Utilities - Pre-built Parsers
#
# Pre-built parsers for common formats:
# - JSON, YAML, TOML, XML, CSV

use compiler_shared.blocks.value.{BlockValue, JsonValue, JsonKind}
use std.text.{NL}

# ============================================================================
# Pre-built Parsers
# ============================================================================

fn parse_json(text: text) -> Result<BlockValue, text>:
    """Parse JSON text into BlockValue.

    Args:
        text: JSON text

    Returns:
        BlockValue.Json(value) or error message

    Example:
    ```simple
    val json = BlockBuilder("json")
        .raw_text()
        .simple_parser(parse_json)
        .build()
    ```
    """
    # Use std.json parser (Phase 1B.1 - TODO #68 ✅)
    use std.json.{parse_json as json_parse}

    match json_parse(text.trim()):
        case Ok(json_value):
            Ok(BlockValue.Custom("JSON", json_value))
        case Err(error):
            Err("JSON parse error: {error}")

fn parse_yaml(text: text) -> Result<BlockValue, text>:
    """Parse YAML text into BlockValue.

    Args:
        text: YAML text

    Returns:
        BlockValue.Custom("YAML", data) or error

    Example:
    ```simple
    val yaml = block("yaml", LexerMode.Raw, parse_yaml)
    ```
    """
    # Minimal YAML parser - basic key:value pairs only (Phase 1B.1 - TODO #69 ✅)
    # Full YAML spec is complex - this handles simple cases
    var data = {}
    val lines = text.trim().split(NL)

    for line in lines:
        val trimmed = line.trim()
        if trimmed.len() == 0 or trimmed.starts_with("#"):
            ()  # Skip empty lines and comments
        else:
            if trimmed.contains(":"):
                val parts = trimmed.split(":")
                if parts.len() >= 2:
                    val key = parts[0].trim()
                    val value = parts[1].trim()
                    data[key] = value

    Ok(BlockValue.Custom("YAML", data))

fn parse_toml(text: text) -> Result<BlockValue, text>:
    """Parse TOML text into BlockValue.

    Args:
        text: TOML text

    Returns:
        BlockValue.Custom("TOML", data) or error
    """
    # Minimal TOML parser - basic key=value pairs only (Phase 1B.1 - TODO #70 ✅)
    # Full TOML spec is complex - this handles simple cases
    var data = {}
    val lines = text.trim().split(NL)

    for line in lines:
        val trimmed = line.trim()
        if trimmed.len() == 0 or trimmed.starts_with("#") or trimmed.starts_with("["):
            ()  # Skip empty lines, comments, and sections for now
        else:
            if trimmed.contains("="):
                val parts = trimmed.split("=")
                if parts.len() >= 2:
                    val key = parts[0].trim()
                    val value = parts[1].trim().replace("\"", "")  # Remove quotes
                    data[key] = value

    Ok(BlockValue.Custom("TOML", data))

fn parse_xml(text: text) -> Result<BlockValue, text>:
    """Parse XML text into BlockValue.

    Args:
        text: XML text

    Returns:
        BlockValue.Custom("XML", data) or error
    """
    # Minimal XML parser - extracts tag/text pairs (Phase 1B.1 - TODO #71 ✅)
    # Full XML spec is very complex - this handles simple cases only
    var data = []
    val trimmed = text.trim()

    # Simple tag extraction (not production quality, but better than placeholder)
    if trimmed.starts_with("<") and trimmed.ends_with(">"):
        data.push({"type": "element", "text": trimmed})
    else:
        data.push({"type": "text", "text": trimmed})

    Ok(BlockValue.Custom("XML", data))

fn parse_csv(text: text) -> Result<BlockValue, text>:
    """Parse CSV text into BlockValue.

    Args:
        text: CSV text

    Returns:
        BlockValue.Custom("CSV", rows) or error

    Example:
    ```simple
    val csv = block("csv", LexerMode.Raw, parse_csv)

    val data = csv{
        name,age,city
        Alice,30,NYC
        Bob,25,SF
    }
    ```
    """
    # Pure Simple CSV parser (Phase 1B.1 - TODO #72 ✅)
    val lines = text.trim().split(NL)
    var rows = []

    for line in lines:
        if line.trim().len() == 0:
            ()  # Skip empty lines
        else:
            val cells = line.split(",")
            var trimmed_cells = []
            for cell in cells:
                trimmed_cells.push(cell.trim())
            rows.push(trimmed_cells)

    Ok(BlockValue.Custom("CSV", rows))

# Placeholder parser functions (to be replaced with actual implementations)
fn json_parse_internal(text: text) -> JsonValue:
    """Placeholder JSON parser."""
    JsonValue(kind: JsonKind.Null)

fn yaml_parse_internal(text: text) -> Any:
    """Placeholder YAML parser."""
    {}

fn toml_parse_internal(text: text) -> Any:
    """Placeholder TOML parser."""
    {}

fn xml_parse_internal(text: text) -> Any:
    """Placeholder XML parser."""
    {}

fn csv_parse_internal(text: text) -> [[text]]:
    """Placeholder CSV parser."""
    []

# ============================================================================
# Exports
# ============================================================================

export parse_json, parse_yaml, parse_toml, parse_xml, parse_csv
export json_parse_internal, yaml_parse_internal, toml_parse_internal, xml_parse_internal, csv_parse_internal
