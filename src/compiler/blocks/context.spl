# Block Context and Error Types
#
# Context passed to block handlers during parsing.

use blocks.modes.{Span, PreLexInfo}

# ============================================================================
# Block Context
# ============================================================================

struct BlockContext:
    """Context provided to block handlers during parsing.

    Contains information about the block's location in source,
    the surrounding scope, and access to compiler services.
    """

    # Source information
    payload: text           # Raw payload text
    payload_span: Span      # Span of payload in source
    block_span: Span        # Span of entire block (including keyword and braces)

    # Source file info
    file_path: text?        # Path to source file (if known)
    module_name: text?      # Module name (if known)

    # Pre-lex info from main lexer
    pre_lex_info: PreLexInfo?  # String/comment/escape spans from Tier 1+2

    # Compilation context
    is_top_level: bool      # Block at module level vs inside function
    parent_block: text?     # Kind of enclosing block (if nested)

impl BlockContext:
    static fn new(payload: text, payload_span: Span, block_span: Span) -> BlockContext:
        BlockContext(
            payload: payload,
            payload_span: payload_span,
            block_span: block_span,
            file_path: nil,
            module_name: nil,
            pre_lex_info: nil,
            is_top_level: false,
            parent_block: nil
        )

    static fn test(payload: text) -> BlockContext:
        """Create a test context with minimal info."""
        BlockContext(
            payload: payload,
            payload_span: Span.empty(),
            block_span: Span.empty(),
            file_path: nil,
            module_name: nil,
            pre_lex_info: nil,
            is_top_level: false,
            parent_block: nil
        )

    me with_pre_lex(info: PreLexInfo) -> BlockContext:
        self.pre_lex_info = Some(info)
        self

    me with_file(path: text) -> BlockContext:
        self.file_path = Some(path)
        self

    me with_module(name: text) -> BlockContext:
        self.module_name = Some(name)
        self

    me at_top_level() -> BlockContext:
        self.is_top_level = true
        self

    me inside_block(kind: text) -> BlockContext:
        self.parent_block = Some(kind)
        self

    fn source_location() -> text:
        """Return human-readable source location."""
        val file = self.file_path ?? "<unknown>"
        val line = self.payload_span.line
        val col = self.payload_span.col
        "{file}:{line}:{col}"

# ============================================================================
# Block Errors
# ============================================================================

"""Kind of block error."""
enum BlockErrorKind:
    ParseError          # Syntax error in payload
    ValidationError     # Semantic error (e.g., invalid SQL)
    TypeError           # Type mismatch in payload
    RuntimeError        # Error during compile-time evaluation
    UnsupportedFeature  # Feature not supported by block

struct BlockError:
    """Error from block parsing or validation.

    Contains enough information for accurate diagnostics.
    """

    kind: BlockErrorKind
    message: text
    span: Span?             # Span within payload (for precise location)
    notes: [text]           # Additional context
    suggestions: [text]     # Possible fixes

impl BlockError:
    static fn parse(message: text) -> BlockError:
        BlockError(
            kind: BlockErrorKind.ParseError,
            message: message,
            span: nil,
            notes: [],
            suggestions: []
        )

    static fn parse_at(message: text, span: Span) -> BlockError:
        BlockError(
            kind: BlockErrorKind.ParseError,
            message: message,
            span: Some(span),
            notes: [],
            suggestions: []
        )

    static fn validation(message: text) -> BlockError:
        BlockError(
            kind: BlockErrorKind.ValidationError,
            message: message,
            span: nil,
            notes: [],
            suggestions: []
        )

    static fn type_error(message: text) -> BlockError:
        BlockError(
            kind: BlockErrorKind.TypeError,
            message: message,
            span: nil,
            notes: [],
            suggestions: []
        )

    static fn unsupported(feature: text) -> BlockError:
        BlockError(
            kind: BlockErrorKind.UnsupportedFeature,
            message: "Unsupported feature: {feature}",
            span: nil,
            notes: [],
            suggestions: []
        )

    me with_span(s: Span) -> BlockError:
        self.span = Some(s)
        self

    me with_note(note: text) -> BlockError:
        self.notes = self.notes.push(note)
        self

    me with_suggestion(suggestion: text) -> BlockError:
        self.suggestions = self.suggestions.push(suggestion)
        self

    fn to_diagnostic(ctx: BlockContext) -> Diagnostic:
        """Convert to compiler diagnostic."""
        val span = self.span ?? ctx.payload_span

        var diag = Diagnostic(
            level: DiagnosticLevel.Error,
            message: self.message,
            span: span,
            notes: self.notes
        )

        for suggestion in self.suggestions:
            diag.suggestions = diag.suggestions.push(suggestion)

        diag

# ============================================================================
# Diagnostic Types (for integration)
# ============================================================================

enum DiagnosticLevel:
    Error
    Warning
    Info
    Hint

struct Diagnostic:
    """Compiler diagnostic message."""
    level: DiagnosticLevel
    message: text
    span: Span
    notes: [text]
    suggestions: [text]

impl Diagnostic:
    static fn error(message: text, span: Span) -> Diagnostic:
        Diagnostic(
            level: DiagnosticLevel.Error,
            message: message,
            span: span,
            notes: [],
            suggestions: []
        )

    static fn warning(message: text, span: Span) -> Diagnostic:
        Diagnostic(
            level: DiagnosticLevel.Warning,
            message: message,
            span: span,
            notes: [],
            suggestions: []
        )

    fn is_error() -> bool:
        match self.level:
            case Error: true
            case _: false

# ============================================================================
# Exports
# ============================================================================

export BlockContext, BlockError, BlockErrorKind
export Diagnostic, DiagnosticLevel
