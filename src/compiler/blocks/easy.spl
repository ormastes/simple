# Easy Block API - Minimal Boilerplate
#
# Simplified API for creating custom blocks with 3 lines of code.
# Wraps the BlockDefinition trait with smart defaults.

use blocks.definition.{BlockDefinition, ConstValue, BlockExample}
use blocks.value.{BlockValue}
use blocks.context.{BlockContext, BlockError}
use blocks.modes.{LexerMode, SyntaxFeatures}

# ============================================================================
# Tier 1: Minimal API
# ============================================================================

fn define_block(
    kind: text,
    mode: LexerMode,
    parser: fn(text) -> Result<BlockValue, text>
):
    """Define a new custom block type with minimal configuration.

    This is the simplest way to define a custom block. Just provide:
    - A keyword (e.g., "heredoc", "color", "port")
    - A lexer mode (usually LexerMode.Raw)
    - A parser function that returns Result<BlockValue, text>

    All optional methods use smart defaults.

    Example:
    ```simple
    val heredoc = define_block("heredoc", LexerMode.Raw, \text:
        Ok(BlockValue.Raw(text.trim()))
    )
    register_block(heredoc)

    val content = heredoc{
        Line 1
        Line 2
    }
    ```

    Args:
        kind: Block keyword (e.g., "heredoc")
        mode: Lexer mode (Raw, Math, or Normal)
        parser: Function to parse payload text

    Returns:
        BlockDefinition ready to register
    """
    SimpleBlockDef(kind: kind, mode: mode, parser: parser)

fn validated_block(
    kind: text,
    mode: LexerMode,
    parser: fn(text) -> Result<BlockValue, text>,
    validator: fn(BlockValue) -> [text]
):
    """Define a block with validation after parsing.

    Like block(), but adds post-parse validation that can return
    multiple error messages.

    Example:
    ```simple
    val port = validated_block("port", LexerMode.Raw,
        \text:
            val num = text.trim().parse_int()?
            Ok(BlockValue.Custom("Port", num))
        ,
        \value:
            match value:
                case Custom("Port", num):
                    if num < 1 or num > 65535:
                        ["Port must be between 1 and 65535"]
                    else:
                        []
                case _:
                    ["Invalid port value"]
    )
    ```

    Args:
        kind: Block keyword
        mode: Lexer mode
        parser: Function to parse payload
        validator: Function to validate parsed value, returns error strings

    Returns:
        BlockDefinition with validation
    """
    ValidatedBlockDef(
        kind: kind,
        mode: mode,
        parser: parser,
        validator: validator
    )

fn define_const_block(
    kind: text,
    mode: LexerMode,
    parser: fn(text) -> Result<BlockValue, text>,
    eval: fn(BlockValue) -> ConstValue?
):
    """Define a block with compile-time evaluation.

    Like block(), but the block can be evaluated at compile time
    if it contains only constant values. This enables optimizations.

    Example:
    ```simple
    val re = define_const_block("re", LexerMode.Raw,
        \pattern:
            val compiled = compile_regex(pattern.trim())?
            Ok(BlockValue.Regex(compiled))
        ,
        \value:
            match value:
                case Regex(pattern): Some(ConstValue.String(pattern.raw))
                case _: nil
    )

    # Pattern compiled at compile time:
    val email = re{ ^[a-z]+@[a-z]+\.[a-z]+$ }
    ```

    Args:
        kind: Block keyword
        mode: Lexer mode
        parser: Function to parse payload
        eval: Function to evaluate at compile time (returns None for runtime-only)

    Returns:
        BlockDefinition with compile-time evaluation
    """
    ConstBlockDef(
        kind: kind,
        mode: mode,
        parser: parser,
        eval: eval
    )

# ============================================================================
# Implementation: Simple Block
# ============================================================================

struct SimpleBlockDef(BlockDefinition):
    """Simple block definition with minimal boilerplate.

    Wraps user-provided parser with smart defaults for all optional methods.
    """

    _kind: text
    _mode: LexerMode
    _parser: fn(text) -> Result<BlockValue, text>

    # --- Required Methods ---

    fn kind() -> text:
        self._kind

    fn parse_payload(payload: text, ctx: BlockContext) -> Result<BlockValue, BlockError>:
        # Call user's simple parser
        match (self._parser)(payload):
            case Ok(value):
                Ok(value)
            case Err(message):
                # Convert string error to BlockError
                Err(BlockError.parse(message))

    # --- Optional Methods with Smart Defaults ---

    fn lexer_mode() -> LexerMode:
        self._mode

    fn syntax_features() -> SyntaxFeatures:
        # Default: no special features
        SyntaxFeatures.default()

    fn validate(value: BlockValue, ctx: BlockContext) -> [BlockError]:
        # Default: no validation
        []

    fn eval_const(value: BlockValue) -> ConstValue?:
        # Default: no compile-time evaluation
        nil

    fn description() -> text:
        # Default: simple description
        "Custom block: {self._kind}"

    fn examples() -> [BlockExample]:
        # Default: no examples
        []

# ============================================================================
# Implementation: Validated Block
# ============================================================================

struct ValidatedBlockDef(BlockDefinition):
    """Block definition with post-parse validation."""

    _kind: text
    _mode: LexerMode
    _parser: fn(text) -> Result<BlockValue, text>
    _validator: fn(BlockValue) -> [text]

    fn kind() -> text:
        self._kind

    fn parse_payload(payload: text, ctx: BlockContext) -> Result<BlockValue, BlockError>:
        match (self._parser)(payload):
            case Ok(value):
                Ok(value)
            case Err(message):
                Err(BlockError.parse(message))

    fn lexer_mode() -> LexerMode:
        self._mode

    fn syntax_features() -> SyntaxFeatures:
        SyntaxFeatures.default()

    fn validate(value: BlockValue, ctx: BlockContext) -> [BlockError]:
        # Call user's validator and convert strings to BlockErrors
        val messages = (self._validator)(value)
        messages.map(\msg: BlockError.validation(msg))

    fn eval_const(value: BlockValue) -> ConstValue?:
        nil

    fn description() -> text:
        "Custom block with validation: {self._kind}"

    fn examples() -> [BlockExample]:
        []

# ============================================================================
# Implementation: Const Block
# ============================================================================

struct ConstBlockDef(BlockDefinition):
    """Block definition with compile-time evaluation."""

    _kind: text
    _mode: LexerMode
    _parser: fn(text) -> Result<BlockValue, text>
    _eval: fn(BlockValue) -> ConstValue?

    fn kind() -> text:
        self._kind

    fn parse_payload(payload: text, ctx: BlockContext) -> Result<BlockValue, BlockError>:
        match (self._parser)(payload):
            case Ok(value):
                Ok(value)
            case Err(message):
                Err(BlockError.parse(message))

    fn lexer_mode() -> LexerMode:
        self._mode

    fn syntax_features() -> SyntaxFeatures:
        SyntaxFeatures.default()

    fn validate(value: BlockValue, ctx: BlockContext) -> [BlockError]:
        []

    fn eval_const(value: BlockValue) -> ConstValue?:
        # Call user's eval function
        (self._eval)(value)

    fn description() -> text:
        "Custom block with compile-time evaluation: {self._kind}"

    fn examples() -> [BlockExample]:
        []

# ============================================================================
# Placeholder Import for BlockExample
# ============================================================================

# BlockExample imported from blocks.definition

# ============================================================================
# Exports
# ============================================================================

export block
export block_with_validation
export const_block
