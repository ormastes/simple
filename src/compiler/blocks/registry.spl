# Block Registry
#
# Central registry for block definitions.

use blocks.definition.{BlockDefinition}
use blocks.modes.{LexerMode, SyntaxFeatures}
use blocks.builtin.{MathBlockDef, LossBlockDef, NogradBlockDef, ShellBlockDef, SqlBlockDef, RegexBlockDef, JsonBlockDef, MarkdownBlockDef}

# ============================================================================
# Block Registry
# ============================================================================

struct BlockRegistry:
    """Central registry for block definitions.

    The registry maps block keywords to their definitions.
    Use `BlockRegistry__default()` to get a registry with built-in blocks.

    Example:
    ```simple
    val registry = BlockRegistry__default()

    # Check if a keyword is a block
    if registry.is_block_keyword("sql"):
        val blk = registry.lookup("sql").unwrap()
        val mode = blk.lexer_mode()
    ```
    """
    blocks: Dict<text, BlockDefinition>

impl BlockRegistry:
    static fn new() -> BlockRegistry:
        """Create an empty registry."""
        BlockRegistry(blocks: {})

    static fn default() -> BlockRegistry:
        """Create a registry with all built-in blocks.

        Built-in blocks:
        - Math/ML: m, loss, nograd
        - DSL: sh, sql, re, json, md

        Built-in blocks are registered in simple/compiler/blocks/builtin.spl.
        """
        var reg = BlockRegistry__new()

        # Register built-in blocks (imported at module level)
        # Math/ML blocks
        reg.register(MathBlockDef())
        reg.register(LossBlockDef())
        reg.register(NogradBlockDef())

        # DSL blocks
        reg.register(ShellBlockDef())
        reg.register(SqlBlockDef())
        reg.register(RegexBlockDef())
        reg.register(JsonBlockDef())
        reg.register(MarkdownBlockDef())

        reg

    me register(block_def: BlockDefinition):
        """Register a block definition.

        Args:
            block_def: The block definition to register

        Note: If a block with the same kind is already registered,
        it will be replaced.
        """
        self.blocks[block_def.kind()] = block_def

    me unregister(kind: text) -> bool:
        """Unregister a block by keyword.

        Returns true if the block was found and removed.
        """
        if self.blocks.contains_key(kind):
            self.blocks = self.blocks.remove(kind)
            true
        else:
            false

    fn lookup(kind: text) -> BlockDefinition?:
        """Look up a block definition by keyword.

        Returns nil if the keyword is not registered.
        """
        self.blocks.get(kind)

    fn is_block_keyword(word: text) -> bool:
        """Check if a word is a registered block keyword."""
        self.blocks.contains_key(word)

    fn all_keywords() -> [text]:
        """Return all registered block keywords."""
        self.blocks.keys()

    fn count() -> i64:
        """Return the number of registered blocks."""
        self.blocks.len()

    me clear():
        """Remove all registered blocks."""
        self.blocks = {}

    fn lexer_mode_for(kind: text) -> LexerMode:
        """Get the lexer mode for a block, or Normal if not found."""
        match self.lookup(kind):
            case Some(blk): blk.lexer_mode()
            case nil: LexerMode.Normal

    fn syntax_features_for(kind: text) -> SyntaxFeatures:
        """Get syntax features for a block, or default if not found."""
        match self.lookup(kind):
            case Some(blk): blk.syntax_features()
            case nil: SyntaxFeatures__default()

# ============================================================================
# Global Registry
# ============================================================================

# Global registry instance for convenience
# Use `block_registry()` to access
var _global_registry: BlockRegistry? = nil

fn block_registry() -> BlockRegistry:
    """Get the global block registry.

    Initializes with default blocks on first access.
    """
    if not _global_registry.?:
        _global_registry = Some(BlockRegistry__default())
    _global_registry.unwrap()

fn register_block(block_def: BlockDefinition):
    """Register a block in the global registry."""
    var reg = block_registry()
    reg.register(block_def)

fn unregister_block(kind: text) -> bool:
    """Unregister a block from the global registry."""
    var reg = block_registry()
    reg.unregister(kind)

fn is_block(kind: text) -> bool:
    """Check if a keyword is a registered block."""
    block_registry().is_block_keyword(kind)

fn get_block(kind: text):
    """Get a block definition from the global registry.

    Args:
        kind: Block keyword

    Returns:
        BlockDefinition if found, nil otherwise

    Example:
    ```simple
    if val Some(blk) = get_block("sql"):
        val mode = blk.lexer_mode()
    ```
    """
    block_registry().lookup(kind)

fn list_blocks() -> [text]:
    """List all registered block keywords.

    Returns:
        Array of block keywords

    Example:
    ```simple
    val blocks = list_blocks()
    print "Registered blocks: {blocks.join(", ")}"
    ```
    """
    block_registry().all_keywords()

fn is_block_registered(kind: text) -> bool:
    """Check if a block is registered (alias for is_block).

    Args:
        kind: Block keyword

    Returns:
        true if registered, false otherwise
    """
    is_block(kind)

fn with_block(block_def, body):
    """Execute body with a temporarily registered block.

    The block is automatically unregistered after body completes.

    Args:
        block_def: Block definition to register temporarily
        body: Function to execute with block registered

    Returns:
        Result of body()

    Example:
    ```simple
    # Register block for test scope only
    val result = with_block(my_test_block, \:
        val value = myblock{ test content }
        assert(value == expected)
        value
    )
    # Block automatically unregistered here
    ```
    """
    val kind = block_def.kind()

    # Register temporary block
    register_block(block_def)

    # Execute body
    val result = body()

    # Cleanup: unregister
    unregister_block(kind)

    result

# ============================================================================
# Registry Builder (for configuration)
# ============================================================================

struct RegistryBuilder:
    """Builder for creating a custom BlockRegistry.

    Example:
    ```simple
    val registry = RegistryBuilder__new()
        .with_builtin()
        .register(MyBlockDef())
        .without("nograd")
        .build()
    ```
    """
    registry: BlockRegistry
    include_builtin: bool

impl RegistryBuilder:
    static fn new() -> RegistryBuilder:
        RegistryBuilder(
            registry: BlockRegistry__new(),
            include_builtin: false
        )

    me with_builtin() -> RegistryBuilder:
        """Include built-in blocks (m, loss, nograd, sh, sql, re, json, md)."""
        self.include_builtin = true
        self

    me register(block_def: BlockDefinition) -> RegistryBuilder:
        """Register a block definition."""
        self.registry.register(block_def)
        self

    me without(kind: text) -> RegistryBuilder:
        """Exclude a block (useful after with_builtin)."""
        self.registry.unregister(kind)
        self

    fn build() -> BlockRegistry:
        """Build the final registry."""
        if self.include_builtin:
            # Register built-in blocks (imported at module level)
            # Math/ML blocks
            self.registry.register(MathBlockDef())
            self.registry.register(LossBlockDef())
            self.registry.register(NogradBlockDef())
            # DSL blocks
            self.registry.register(ShellBlockDef())
            self.registry.register(SqlBlockDef())
            self.registry.register(RegexBlockDef())
            self.registry.register(JsonBlockDef())
            self.registry.register(MarkdownBlockDef())

        self.registry

# ============================================================================
# Exports
# ============================================================================

export BlockRegistry, RegistryBuilder
export block_registry, register_block, unregister_block, is_block
export get_block, list_blocks, is_block_registered, with_block
