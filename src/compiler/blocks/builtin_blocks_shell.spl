# Builtin Shell & Markdown Block Definitions
#
# Raw-mode block types with simple payloads:
# - Shell blocks (sh{...}): Shell command execution
# - Markdown blocks (md{...}): Markdown content

use blocks.{BlockDefinition, BlockValue, BlockRegistry}
use blocks.modes.{PreLexInfo, BlockSkipPolicy, BlockOutlineInfo, BlockToken, BlockTokenKind, TextSpan}
use blocks.context.{BlockContext, BlockError}
use compiler.hir.HirType
use value.ConstValue

# ============================================================================
# Shell Block (sh{})
# ============================================================================

struct ShellBlockDef(BlockDefinition):
    r"""Shell command block: execute shell commands.

    Features:
    - Raw text capture (no tokenization)
    - Supports pipes, redirects, variables
    - Returns command output as text

    Example:
        val files = sh{ ls -la }
        val result = sh{ cat file.txt | grep pattern }
    """

impl ShellBlockDef:
    fn kind() -> text:
        "sh"

    fn parse_payload(payload: text, ctx: BlockContext) -> Result<BlockValue, BlockError>:
        val trimmed = payload.trim()
        if trimmed.is_empty():
            return Err(BlockError.parse("Empty shell command"))

        # Parse shell commands
        val commands = parse_shell_commands(trimmed)
        Ok(BlockValue.Shell(commands))

    fn lexer_mode() -> LexerMode:
        LexerMode.Raw

    fn syntax_features() -> SyntaxFeatures:
        SyntaxFeatures.default()

    fn description() -> text:
        "Shell command execution"

    fn examples() -> [BlockExample]:
        [
            BlockExample(
                code: "sh\{ ls -la }",
                description: "List files",
                output: nil
            ),
            BlockExample(
                code: "sh\{ cat file.txt | grep pattern | wc -l }",
                description: "Pipeline with pipes",
                output: nil
            ),
            BlockExample(
                code: "sh\{ echo \"hello\" > output.txt }",
                description: "Redirect to file",
                output: nil
            )
        ]

    fn validate(value: BlockValue, ctx: BlockContext) -> [BlockError]:
        # Check for dangerous commands
        match value:
            case Shell(commands):
                var errors: [BlockError] = []
                for cmd in commands.commands:
                    if cmd.program == "rm" and "-rf" in cmd.args:
                        errors = errors.push(
                            BlockError.validation("Potentially dangerous: rm -rf")
                                .with_suggestion("Consider using 'rm -i' for interactive deletion")
                        )
                errors
            case _:
                []

    fn highlight(payload: text) -> [HighlightToken]:
        var tokens: [HighlightToken] = []
        var i = 0
        var in_string = false
        var string_char = '"'

        while i < payload.len():
            val c = payload[i]

            # String handling
            if c == '"' or c == '\'':
                if not in_string:
                    in_string = true
                    string_char = c
                    val start = i
                    i = i + 1
                    while i < payload.len() and payload[i] != string_char:
                        i = i + 1
                    tokens = tokens.push(HighlightToken(
                        start: start,
                        end: i + 1,
                        kind: HighlightKind.String
                    ))
                    in_string = false
                i = i + 1
                continue

            # Operators
            if c == '|' or c == '>' or c == '<' or c == '&':
                tokens = tokens.push(HighlightToken(
                    start: i,
                    end: i + 1,
                    kind: HighlightKind.Operator
                ))
                i = i + 1
                continue

            # Variable
            if c == '$':
                val start = i
                i = i + 1
                while i < payload.len() and (payload[i].is_alphanumeric() or payload[i] == '_'):
                    i = i + 1
                tokens = tokens.push(HighlightToken(
                    start: start,
                    end: i,
                    kind: HighlightKind.Variable
                ))
                continue

            i = i + 1

        tokens

# ============================================================================
# Markdown Block (md{})
# ============================================================================

struct MarkdownBlockDef(BlockDefinition):
    r"""Markdown block: embed markdown text.

    Features:
    - Raw text capture
    - Markdown syntax highlighting
    - Can be rendered to HTML

    Example:
        val readme = md{
            # My Project

            A **simple** project with _markdown_ support.

            - Item 1
            - Item 2
        }
    """

impl MarkdownBlockDef:
    fn kind() -> text:
        "md"

    fn parse_payload(payload: text, ctx: BlockContext) -> Result<BlockValue, BlockError>:
        # Markdown is captured as raw text
        Ok(BlockValue.Raw(payload))

    fn lexer_mode() -> LexerMode:
        LexerMode.Raw

    fn syntax_features() -> SyntaxFeatures:
        SyntaxFeatures.default()

    fn description() -> text:
        "Markdown text"

    fn examples() -> [BlockExample]:
        [
            BlockExample(
                code: "md\{ # Heading }",
                description: "Markdown heading",
                output: nil
            )
        ]

export ShellBlockDef, MarkdownBlockDef
