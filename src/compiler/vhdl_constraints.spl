# VHDL Constraint Checker
#
# Two-layer verification constraint system for VHDL backend:
# - Layer 1: Numeric/width constraints delegated to DimSolver
# - Layer 2: Structural/graph constraints (CDC, latch, comb loops)
#
# All constraints are checked at compile time before VHDL emission.

use compiler.dim_constraints_types.{DimConstraint, DimError, DimErrorKind, DimNote, DimNoteKind}
use compiler.dim_constraints.DimSolver
use compiler.mir_data.{VhdlClockDomain, VhdlProcessKind}
use core.lexer.Span

# ============================================================================
# VHDL Constraint Definitions
# ============================================================================

"""VHDL-specific verification constraint."""
enum VhdlConstraint:
    # Width constraints (delegate to DimSolver)
    WidthEqual(signal1: text, signal2: text, width1: i64, width2: i64, span: Span)
    WidthSafe(operands: [i64], operator: text, result_width: i64, span: Span)

    # Clock domain constraints (graph coloring)
    SameClockDomain(signal1: text, signal2: text, span: Span)
    ClockDomainCrossing(source: text, dest: text, source_domain: text, dest_domain: text, span: Span)

    # Combinational constraints (set/graph analysis)
    SensitivityComplete(process_label: text, used_signals: [text], sensitivity: [text], span: Span)
    NoCombLoop(signals: [text], dependencies: [(text, text)], span: Span)
    NoLatchInference(process_label: text, assigned_signals: [text], branch_coverage: [(text, bool)], span: Span)

    # Loop constraints (DimSolver)
    LoopBounded(bound_expr: text, max_iterations: i64, span: Span)

    # Driver constraints
    SingleDriver(signal: text, drivers: [text], span: Span)

    # Type resolution constraints
    ResolvedType(signal: text, has_multiple_drivers: bool, span: Span)

# ============================================================================
# Tarjan SCC — Combinational Loop Detection
# ============================================================================

class TarjanSCC:
    """
    Tarjan's Strongly Connected Components algorithm for detecting
    combinational loops in signal dependency graphs.

    Any SCC with size > 1 indicates a multi-signal cycle (a -> b -> a).
    An SCC of size 1 with a self-edge indicates a self-loop (a -> a).
    """

    nodes: [text]
    adj: Dict<text, [text]>
    index_of: Dict<text, i64>
    lowlink: Dict<text, i64>
    on_stack: Dict<text, bool>
    stack: [text]
    next_index: i64
    result_sccs: [[text]]

    static fn from_edges(signals: [text], deps: [(text, text)]) -> TarjanSCC:
        """Build adjacency list from signal list and dependency edges."""
        var adj: Dict<text, [text]> = Dict()
        for sig in signals:
            adj = adj.set(sig, [])
        for dep in deps:
            var targets = adj.get(dep.0) ?? []
            targets = targets.push(dep.1)
            adj = adj.set(dep.0, targets)
        TarjanSCC(
            nodes: signals,
            adj: adj,
            index_of: Dict(),
            lowlink: Dict(),
            on_stack: Dict(),
            stack: [],
            next_index: 0,
            result_sccs: []
        )

    me find_cycles() -> [[text]]:
        """Run Tarjan's algorithm and return SCCs that form cycles."""
        for node in self.nodes:
            if not self.index_of.get(node).?:
                self.strongconnect(node)

        var cycles: [[text]] = []
        for scc in self.result_sccs:
            if scc.len() > 1:
                # Multi-node SCC is always a cycle
                cycles = cycles.push(scc)
            elif scc.len() == 1:
                # Single-node SCC: only a cycle if self-loop exists
                val node = scc[0]
                val neighbors = self.adj.get(node) ?? []
                var has_self_loop = false
                for n in neighbors:
                    if n == node:
                        has_self_loop = true
                        break
                if has_self_loop:
                    cycles = cycles.push(scc)
        cycles

    me strongconnect(v: text):
        """Recursive strongconnect for Tarjan's SCC algorithm."""
        self.index_of = self.index_of.set(v, self.next_index)
        self.lowlink = self.lowlink.set(v, self.next_index)
        self.next_index = self.next_index + 1
        self.stack = self.stack.push(v)
        self.on_stack = self.on_stack.set(v, true)

        val neighbors = self.adj.get(v) ?? []
        for w in neighbors:
            if not self.index_of.get(w).?:
                # w not yet visited — recurse
                self.strongconnect(w)
                val w_low = self.lowlink.get(w) ?? 0
                val v_low = self.lowlink.get(v) ?? 0
                if w_low < v_low:
                    self.lowlink = self.lowlink.set(v, w_low)
            elif self.on_stack.get(w) ?? false:
                # w is on stack — part of current SCC
                val w_idx = self.index_of.get(w) ?? 0
                val v_low = self.lowlink.get(v) ?? 0
                if w_idx < v_low:
                    self.lowlink = self.lowlink.set(v, w_idx)

        # If v is a root node of an SCC, pop the SCC from stack
        val v_idx = self.index_of.get(v) ?? 0
        val v_low = self.lowlink.get(v) ?? 0
        if v_low == v_idx:
            var scc: [text] = []
            var done = false
            while not done and self.stack.len() > 0:
                val top_idx = self.stack.len() - 1
                val w = self.stack[top_idx]
                # Pop last element by rebuilding without it
                var new_stack: [text] = []
                var i = 0
                while i < top_idx:
                    new_stack = new_stack.push(self.stack[i])
                    i = i + 1
                self.stack = new_stack
                self.on_stack = self.on_stack.set(w, false)
                scc = scc.push(w)
                if w == v:
                    done = true
            self.result_sccs = self.result_sccs.push(scc)

# ============================================================================
# VHDL Constraint Checker
# ============================================================================

class VhdlConstraintChecker:
    """
    Checks VHDL-specific verification constraints.

    Enforces:
    - Width matching for signal assignments
    - Clock domain crossing safety
    - Complete sensitivity lists
    - No combinational loops (Tarjan SCC)
    - No unintended latch inference
    - Bounded loops for synthesis
    - Single-driver enforcement for unresolved signals
    - Resolved type requirement for multi-driver nets
    """

    dim_solver: DimSolver
    constraints: [VhdlConstraint]
    clock_domains: Dict<text, VhdlClockDomain>
    signal_domains: Dict<text, text>
    signal_drivers: Dict<text, [text]>
    dependency_graph: Dict<text, [text]>
    errors: [VhdlConstraintError]

    static fn create() -> VhdlConstraintChecker:
        VhdlConstraintChecker(
            dim_solver: DimSolver__new(),
            constraints: [],
            clock_domains: Dict(),
            signal_domains: Dict(),
            signal_drivers: Dict(),
            dependency_graph: Dict(),
            errors: []
        )

    me add_constraint(c: VhdlConstraint):
        """Add a constraint to be checked."""
        self.constraints = self.constraints.push(c)

    me register_clock_domain(domain: VhdlClockDomain):
        """Register a clock domain."""
        self.clock_domains = self.clock_domains.set(domain.name, domain)

    me register_signal_domain(signal: text, domain: text):
        """Associate a signal with a clock domain."""
        self.signal_domains = self.signal_domains.set(signal, domain)

    me register_driver(signal: text, driver: text):
        """Register a driver for a signal."""
        var drivers = self.signal_drivers.get(signal) ?? []
        drivers = drivers.push(driver)
        self.signal_drivers = self.signal_drivers.set(signal, drivers)

    me register_dependency(source: text, dest: text):
        """Register a combinational dependency edge."""
        var deps = self.dependency_graph.get(source) ?? []
        deps = deps.push(dest)
        self.dependency_graph = self.dependency_graph.set(source, deps)

    fn check_all() -> Result<(), [VhdlConstraintError]>:
        """Run all registered constraints. Returns errors if any fail."""
        var all_errors: [VhdlConstraintError] = []

        for c in self.constraints:
            val result = self.check_constraint(c)
            if result.is_err():
                all_errors = all_errors.push(result.unwrap_err())

        if all_errors.len() > 0:
            Err(all_errors)
        else:
            Ok(())

    fn check_constraint(c: VhdlConstraint) -> Result<(), VhdlConstraintError>:
        """Check a single constraint."""
        match c:
            case WidthEqual(s1, s2, w1, w2, span):
                if w1 != w2:
                    Err(VhdlConstraintError(
                        code: "E0700",
                        message: "width mismatch: signal '{s1}' is {w1} bits, '{s2}' is {w2} bits",
                        span: span,
                        kind: VhdlConstraintErrorKind.WidthMismatch
                    ))
                else:
                    Ok(())

            case WidthSafe(operands, operator, result_width, span):
                var needed = 0
                var max_w = 0
                for w in operands:
                    if w > max_w:
                        max_w = w
                if operator == "+" or operator == "-":
                    needed = max_w + 1
                elif operator == "*":
                    var total = 0
                    for w in operands:
                        total = total + w
                    needed = total
                else:
                    needed = max_w
                if needed > result_width:
                    Err(VhdlConstraintError(
                        code: "E0701",
                        message: "width overflow: '{operator}' needs {needed} bits, result has {result_width}",
                        span: span,
                        kind: VhdlConstraintErrorKind.WidthOverflow
                    ))
                else:
                    Ok(())

            case SameClockDomain(s1, s2, span):
                val d1 = self.signal_domains.get(s1)
                val d2 = self.signal_domains.get(s2)
                if d1.? and d2.? and d1.unwrap() != d2.unwrap():
                    Err(VhdlConstraintError(
                        code: "E0710",
                        message: "clock domain crossing: '{s1}' ({d1.unwrap()}) and '{s2}' ({d2.unwrap()}) are in different domains",
                        span: span,
                        kind: VhdlConstraintErrorKind.ClockDomainCrossing
                    ))
                else:
                    Ok(())

            case ClockDomainCrossing(source, dest, src_domain, dst_domain, span):
                Err(VhdlConstraintError(
                    code: "E0710",
                    message: "unsynchronized clock domain crossing: '{source}' ({src_domain}) -> '{dest}' ({dst_domain})",
                    span: span,
                    kind: VhdlConstraintErrorKind.ClockDomainCrossing
                ))

            case SensitivityComplete(label, used, sensitivity, span):
                var missing: [text] = []
                for sig in used:
                    var found = false
                    for s in sensitivity:
                        if s == sig:
                            found = true
                            break
                    if not found:
                        missing = missing.push(sig)
                if missing.len() > 0:
                    Err(VhdlConstraintError(
                        code: "E0720",
                        message: "incomplete sensitivity list in process '{label}': missing {missing.join(', ')}",
                        span: span,
                        kind: VhdlConstraintErrorKind.IncompleteSensitivity
                    ))
                else:
                    Ok(())

            case NoCombLoop(signals, dependencies, span):
                # Full Tarjan SCC cycle detection
                var scc = TarjanSCC__from_edges(signals, dependencies)
                val cycles = scc.find_cycles()
                if cycles.len() > 0:
                    val cycle = cycles[0]
                    val cycle_path = cycle.join(" -> ")
                    Err(VhdlConstraintError(
                        code: "E0721",
                        message: "combinational loop detected: {cycle_path}",
                        span: span,
                        kind: VhdlConstraintErrorKind.CombinationalLoop
                    ))
                else:
                    Ok(())

            case NoLatchInference(label, assigned, branch_coverage, span):
                var incomplete: [text] = []
                for entry in branch_coverage:
                    if not entry.1:
                        incomplete = incomplete.push(entry.0)
                if incomplete.len() > 0:
                    Err(VhdlConstraintError(
                        code: "E0722",
                        message: "latch inferred in process '{label}': signals {incomplete.join(', ')} not assigned in all branches",
                        span: span,
                        kind: VhdlConstraintErrorKind.LatchInferred
                    ))
                else:
                    Ok(())

            case LoopBounded(bound_expr, max_iterations, span):
                # This delegates to DimSolver for the actual bound check
                # Here we just verify the max_iterations policy
                if max_iterations <= 0:
                    Err(VhdlConstraintError(
                        code: "E0730",
                        message: "loop bound must be positive: '{bound_expr}' evaluates to {max_iterations}",
                        span: span,
                        kind: VhdlConstraintErrorKind.UnboundedLoop
                    ))
                else:
                    Ok(())

            case SingleDriver(signal, drivers, span):
                if drivers.len() > 1:
                    Err(VhdlConstraintError(
                        code: "E0740",
                        message: "multiple drivers on unresolved signal '{signal}': driven by {drivers.join(', ')}",
                        span: span,
                        kind: VhdlConstraintErrorKind.MultipleDrivers
                    ))
                else:
                    Ok(())

            case ResolvedType(signal, has_multiple_drivers, span):
                if has_multiple_drivers:
                    # This is informational - signal should use std_logic
                    Ok(())
                else:
                    Ok(())

# ============================================================================
# VHDL Constraint Errors
# ============================================================================

struct VhdlConstraintError:
    """Error from VHDL constraint checking."""
    code: text
    message: text
    span: Span
    kind: VhdlConstraintErrorKind

enum VhdlConstraintErrorKind:
    WidthMismatch           # E0700
    WidthOverflow           # E0701
    ClockDomainCrossing     # E0710
    IncompleteSensitivity   # E0720
    CombinationalLoop       # E0721
    LatchInferred           # E0722
    UnboundedLoop           # E0730
    MultipleDrivers         # E0740
    UnsynthesizableConstruct # E0750

impl VhdlConstraintError:
    fn format() -> text:
        """Format error for display."""
        "error[{self.code}]: {self.message} (line {self.span.line}:{self.span.col})"

# ============================================================================
# Export
# ============================================================================

export VhdlConstraint, VhdlConstraintChecker
export VhdlConstraintError, VhdlConstraintErrorKind

