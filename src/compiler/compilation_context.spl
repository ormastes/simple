# Unified Compilation Context
#
# Shared trait for compiler, JIT, and linker so all three paths
# apply AOP, DI, contracts, and codegen through the same interface.
#
# Enhanced from 104 lines to include: CompiledUnit, Test contract mode,
# coverage integration, weaving pipeline, DI container, instantiation records.

# Note: backend_types, di, aop, monomorphize.note_sdn are used by
# implementations but not needed for the trait definition itself.

# ============================================================================
# Enums
# ============================================================================

enum InstantiationMode:
    """When instantiation occurs."""
    CompileTime
    LinkTime
    JitTime

impl InstantiationMode:
    fn to_string():
        match self:
            case CompileTime: "compile_time"
            case LinkTime: "link_time"
            case JitTime: "jit_time"

enum ContractMode:
    """How much contract checking to apply."""
    Off        # No contracts (CTR-040)
    Boundary   # Only at module boundaries (CTR-041)
    All        # All contracts (CTR-042)
    Test       # All contracts + rich diagnostics (CTR-043)

impl ContractMode:
    fn to_string():
        match self:
            case Off: "off"
            case Boundary: "boundary"
            case All: "all"
            case Test: "test"

    static fn from_text(s: text) -> ContractMode?:
        match s.lower():
            case "off" | "none": Some(ContractMode.Off)
            case "boundary" | "public": Some(ContractMode.Boundary)
            case "all" | "on": Some(ContractMode.All)
            case "test" | "debug": Some(ContractMode.Test)
            case _: nil

    fn checks_all() -> bool:
        match self: case All | Test: true; case _: false

    fn has_rich_diagnostics() -> bool:
        match self: case Test: true; case _: false

    fn should_check(is_public: bool) -> bool:
        match self:
            case Off: false
            case Boundary: is_public
            case All | Test: true

# ============================================================================
# GenericTemplate
# ============================================================================

struct GenericTemplate:
    """A generic template loaded from AST cache or SMF."""
    name: text
    type_params: [text]
    ast_data: Any

struct ConcreteType:
    """A concrete type used for instantiation."""
    name: text

impl ConcreteType:
    fn to_string():
        self.name

# ============================================================================
# TypeRegistry
# ============================================================================

struct TypeRegistry:
    """Registry of known types."""
    types: Dict<text, Any>

impl TypeRegistry:
    static fn empty():
        TypeRegistry(types: {})

    fn has_type(name: text) -> bool:
        self.types.contains_key(name)

    fn get_type(name: text) -> Any?:
        if self.types.contains_key(name):
            Some(self.types[name])
        else:
            nil

# ============================================================================
# CompiledUnit (output of compilation)
# ============================================================================

struct CompiledUnit:
    """Output of compiling a template or module."""
    name: text
    symbols: [text]             # Exported symbols
    code: Any                   # Generated code (backend-specific)
    effects: [text]             # Detected effects
    instantiation_mode: InstantiationMode

impl CompiledUnit:
    static fn empty(name: text, mode: InstantiationMode) -> CompiledUnit:
        CompiledUnit(name: name, symbols: [], code: nil,
                     effects: [], instantiation_mode: mode)

# ============================================================================
# Instantiation Record (tracking)
# ============================================================================

struct InstantiationRecord:
    """Records a generic instantiation for debugging and optimization."""
    template_name: text
    type_args: [text]
    mode: InstantiationMode
    source_module: text?

# ============================================================================
# CompilationContext Trait
# ============================================================================

trait CompilationContext:
    """Unified compilation interface for compiler, JIT, and linker.

    All three paths use this to ensure AOP/DI/contracts are applied
    consistently. The pipeline is:
      1. Load template
      2. Apply DI bindings
      3. Lower to HIR â†’ MIR
      4. Weave AOP advice at MIR level
      5. Insert contract checks
      6. Codegen
    """

    # Template management (source differs per context)
    fn load_template(name: text) -> GenericTemplate?
    fn has_template(name: text) -> bool

    # Type system
    fn type_registry() -> TypeRegistry

    # Pipeline configuration
    fn contract_mode() -> ContractMode
    fn di_container() -> Any
    fn aop_weaver() -> Any
    fn coverage_enabled() -> bool

    # Full pipeline: template -> compiled code
    fn compile_template(tmpl: GenericTemplate, type_args: [ConcreteType]) -> Result<CompiledUnit, text>

    # Metadata tracking
    fn instantiation_mode() -> InstantiationMode
    me record_instantiation(entry: InstantiationRecord)

    # Query recorded instantiations
    fn instantiation_count() -> i64

# ============================================================================
# Exports
# ============================================================================

export CompilationContext
export InstantiationMode, ContractMode
export GenericTemplate, ConcreteType, TypeRegistry
export CompiledUnit, InstantiationRecord
