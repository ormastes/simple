# Verification Constraint Checker
#
# Enforces verified subset rules for Lean verification mode.
# Rules: V-UNSAFE, V-EFFECT, V-REFLECT, V-GHOST, V-TRUSTED, V-PARTIAL
#
# Port of rust/compiler/src/verification_checker.rs (320 lines)

export VerificationRule, VerificationViolation, VerificationChecker

# ============================================================================
# Types
# ============================================================================

enum VerificationRule:
    VUnsafe     # No @unsafe in @verify code
    VEffect     # No impure effects in verified code
    VReflect    # No reflection in verified code
    VGhost      # Ghost code can only access ghost state
    VTrusted    # Trusted functions must have contracts
    VPartial    # Recursive functions need termination proof

impl VerificationRule:
    fn code() -> text:
        match self:
            case VUnsafe: "V-UNSAFE"
            case VEffect: "V-EFFECT"
            case VReflect: "V-REFLECT"
            case VGhost: "V-GHOST"
            case VTrusted: "V-TRUSTED"
            case VPartial: "V-PARTIAL"

    fn description() -> text:
        match self:
            case VUnsafe: "verified code cannot use unsafe operations"
            case VEffect: "verified code must be pure (no IO, Net, Fs effects)"
            case VReflect: "verified code cannot use reflection"
            case VGhost: "ghost code can only access ghost state"
            case VTrusted: "trusted boundary functions must have contracts"
            case VPartial: "recursive functions in verified code need termination proof"

struct VerificationViolation:
    rule: VerificationRule
    location: text
    message: text

impl VerificationViolation:
    fn to_text() -> text:
        "[{self.rule.code()}] {self.location}: {self.message}"

# ============================================================================
# Checker
# ============================================================================

struct FunctionInfo:
    """Minimal function info for verification checking."""
    name: text
    effects: [text]
    is_verified: bool
    is_trusted: bool
    has_contract: bool
    has_ghost_params: bool
    has_ghost_locals: bool
    is_recursive: bool
    has_termination_proof: bool
    uses_reflection: bool

class VerificationChecker:
    """Checks modules for verification constraint violations."""
    violations: [VerificationViolation]
    strict: bool

impl VerificationChecker:
    static fn create(strict: bool) -> VerificationChecker:
        VerificationChecker(violations: [], strict: strict)

    me check_function(func: FunctionInfo):
        """Check a function for verification violations."""
        # Only check verified functions (except trusted check)
        if not func.is_verified:
            if func.is_trusted:
                self.check_trusted_has_contract(func)
            return

        self.check_no_unsafe(func)
        self.check_pure_effects(func)
        self.check_no_reflection(func)

        if func.has_ghost_params or func.has_ghost_locals:
            self.check_ghost_constraints(func)

        if func.is_recursive:
            self.check_termination(func)

    me check_no_unsafe(func: FunctionInfo):
        """V-UNSAFE: Verified code cannot use @unsafe."""
        if func.effects.contains("unsafe"):
            self.add_violation(
                VerificationRule.VUnsafe, func.name,
                ("function '{func.name}' is marked @verify but uses @unsafe. " +
                "Remove @unsafe or change to @trusted if this is a boundary function."))

    me check_pure_effects(func: FunctionInfo):
        """V-EFFECT: Verified code must be pure."""
        val impure = ["io", "net", "fs", "async"]
        val found = func.effects.filter(\e: impure.contains(e))
        if found.?:
            self.add_violation(
                VerificationRule.VEffect, func.name,
                ("function '{func.name}' is marked @verify but has impure effects: [{found.join(\", \")}]. " +
                "Verified code must be @pure or have no effects."))

    me check_no_reflection(func: FunctionInfo):
        """V-REFLECT: Verified code cannot use reflection."""
        if func.uses_reflection:
            self.add_violation(
                VerificationRule.VReflect, func.name,
                "function '{func.name}' uses reflection which is not allowed in verified code.")

    me check_trusted_has_contract(func: FunctionInfo):
        """V-TRUSTED: Trusted boundary functions must have contracts."""
        if not func.has_contract:
            self.add_violation(
                VerificationRule.VTrusted, func.name,
                ("function '{func.name}' is marked @trusted but has no contract. " +
                "Trusted boundary functions must specify their contracts."))

    me check_ghost_constraints(func: FunctionInfo):
        """V-GHOST: Ghost code constraints."""
        # Placeholder â€” full implementation needs expression analysis
        ()

    me check_termination(func: FunctionInfo):
        """V-PARTIAL: Recursive functions need termination proof."""
        if not func.has_termination_proof:
            self.add_violation(
                VerificationRule.VPartial, func.name,
                "recursive function '{func.name}' in verified code needs a termination proof.")

    me add_violation(rule: VerificationRule, location: text, message: text):
        self.violations = self.violations.push(
            VerificationViolation(rule: rule, location: location, message: message))

    fn has_violations() -> bool:
        self.violations.?

    fn error_count() -> i64:
        self.violations.len()

    fn get_violations() -> [VerificationViolation]:
        self.violations
