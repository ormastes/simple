# Attribute Parsing - Parse and Validate Attributes
#
# Handles parsing of layout-related attributes:
# - @repr("C")         - C ABI compatible layout
# - @repr("packed")    - No padding between fields
# - @repr("transparent") - Single-field wrapper layout
# - @packed            - Shorthand for @repr("packed")
# - @align(N)          - Minimum alignment (must be power of 2)
#
# Returns a LayoutAttr for use in type layout computation.

use parser_types.{Attribute, Expr, ExprKind}
use type_layout.{LayoutAttr, LayoutKind}
use lexer.Span

export parse_layout_attrs, validate_alignment, is_power_of_two

# Parse layout attributes from a list of attributes
fn parse_layout_attrs(attrs: [Attribute]) -> LayoutAttr:
    """Extract layout attributes from a list of attributes.

    Handles:
    - @repr("C") -> LayoutKind.C
    - @repr("packed") -> LayoutKind.Packed, is_packed=true
    - @repr("transparent") -> LayoutKind.Transparent
    - @packed -> LayoutKind.Packed, is_packed=true
    - @align(N) -> explicit_align=N

    Returns default LayoutAttr if no layout attributes found.
    """
    var layout_kind = LayoutKind.Simple
    var explicit_align: i64? = None
    var is_packed = false

    for attr in attrs:
        match attr.name:
            case "repr":
                # @repr("C"), @repr("packed"), @repr("transparent")
                if attr.args.len() > 0:
                    val repr_kind = extract_string_arg(attr.args[0])
                    match repr_kind:
                        case "C":
                            layout_kind = LayoutKind.C
                        case "packed":
                            layout_kind = LayoutKind.Packed
                            is_packed = true
                        case "transparent":
                            layout_kind = LayoutKind.Transparent
                        case _:
                            # Unknown repr, keep default
                            pass

            case "packed":
                # @packed shorthand
                layout_kind = LayoutKind.Packed
                is_packed = true

            case "align":
                # @align(N) - alignment must be power of 2
                if attr.args.len() > 0:
                    val align_val = extract_int_arg(attr.args[0])
                    if align_val.? and is_power_of_two(align_val.unwrap()):
                        explicit_align = align_val

            case _:
                # Ignore other attributes
                pass

    LayoutAttr(
        layout_kind: layout_kind,
        explicit_align: explicit_align,
        is_packed: is_packed
    )

# Extract string value from an expression (for @repr("C"))
fn extract_string_arg(expr: Expr) -> text:
    match expr.kind:
        case ExprKind.StringLit(value, _):
            value
        case _:
            ""

# Extract integer value from an expression (for @align(16))
fn extract_int_arg(expr: Expr) -> i64?:
    match expr.kind:
        case ExprKind.IntLit(value):
            Some(value)
        case _:
            None

# Check if a number is a power of 2
fn is_power_of_two(n: i64) -> bool:
    """Check if n is a power of 2.

    Uses bitwise trick: n & (n-1) == 0 for powers of 2.
    """
    n > 0 and (n & (n - 1)) == 0

# Validate alignment value
fn validate_alignment(align: i64, span: Span) -> Result<i64, text>:
    """Validate that alignment is a positive power of 2.

    Returns the alignment if valid, or an error message.
    """
    if align <= 0:
        Err("alignment must be positive, got {align}")
    elif not is_power_of_two(align):
        Err("alignment must be a power of 2, got {align}")
    else:
        Ok(align)
