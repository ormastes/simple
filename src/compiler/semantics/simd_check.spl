# SIMD Type Checking and Auto-Vectorization
#
# Provides compile-time verification of SIMD operations and
# automatic vectorization of compatible loops.
#
# Features:
# - SIMD type validation (lane count, element types)
# - Vector operation type checking
# - Auto-vectorization analysis
# - Backend capability verification
#
# Supported vector types:
# - i8x16, i16x8, i32x4, i64x2
# - f32x4, f64x2
# - Custom widths based on target

# Note: SIMD core types also available in compiler.common.simd_types

# ============================================================================
# SIMD Element Type
# ============================================================================

enum SimdElementType:
    """Element type in a SIMD vector."""
    I8
    I16
    I32
    I64
    F32
    F64

impl SimdElementType:
    fn to_text() -> text:
        match self:
            case I8: "i8"
            case I16: "i16"
            case I32: "i32"
            case I64: "i64"
            case F32: "f32"
            case F64: "f64"

    fn bit_width() -> i64:
        """Get bit width of element type."""
        match self:
            case I8: 8
            case I16: 16
            case I32: 32
            case I64: 64
            case F32: 32
            case F64: 64

    fn is_integer() -> bool:
        match self:
            case I8 | I16 | I32 | I64: true
            case _: false

    fn is_float() -> bool:
        match self:
            case F32 | F64: true
            case _: false

# ============================================================================
# SIMD Vector Type
# ============================================================================

struct SimdVectorType:
    """A SIMD vector type."""
    element_type: SimdElementType
    lane_count: i64

impl SimdVectorType:
    static fn create(element: SimdElementType, lanes: i64) -> SimdVectorType:
        SimdVectorType(element_type: element, lane_count: lanes)

    # Standard vector types
    static fn i8x16() -> SimdVectorType:
        SimdVectorType__create(SimdElementType.I8, 16)

    static fn i16x8() -> SimdVectorType:
        SimdVectorType__create(SimdElementType.I16, 8)

    static fn i32x4() -> SimdVectorType:
        SimdVectorType__create(SimdElementType.I32, 4)

    static fn i64x2() -> SimdVectorType:
        SimdVectorType__create(SimdElementType.I64, 2)

    static fn f32x4() -> SimdVectorType:
        SimdVectorType__create(SimdElementType.F32, 4)

    static fn f64x2() -> SimdVectorType:
        SimdVectorType__create(SimdElementType.F64, 2)

    fn to_text() -> text:
        "{self.element_type.to_text()}x{self.lane_count}"

    fn total_bits() -> i64:
        """Get total bit width of vector."""
        self.element_type.bit_width() * self.lane_count

    fn is_valid_width() -> bool:
        """Check if vector width is valid (128, 256, or 512 bits)."""
        val bits = self.total_bits()
        bits == 128 or bits == 256 or bits == 512

    fn is_compatible_with(other: SimdVectorType) -> bool:
        """Check if two vector types are compatible for operations."""
        (self.lane_count == other.lane_count and
        self.element_type.bit_width() == other.element_type.bit_width())

# ============================================================================
# SIMD Operation
# ============================================================================

enum SimdOperation:
    """A SIMD operation type."""
    # Arithmetic
    Add
    Sub
    Mul
    Div

    # Bitwise
    And
    Or
    Xor
    Not

    # Comparison
    Eq
    Ne
    Lt
    Le
    Gt
    Ge

    # Reduction
    ReduceAdd
    ReduceMul
    ReduceMin
    ReduceMax

    # Shuffle/Permute
    Shuffle
    Splat
    Extract
    Insert

    # Conversion
    Widen
    Narrow
    Convert

impl SimdOperation:
    fn to_text() -> text:
        match self:
            case Add: "add"
            case Sub: "sub"
            case Mul: "mul"
            case Div: "div"
            case And: "and"
            case Or: "or"
            case Xor: "xor"
            case Not: "not"
            case Eq: "eq"
            case Ne: "ne"
            case Lt: "lt"
            case Le: "le"
            case Gt: "gt"
            case Ge: "ge"
            case ReduceAdd: "reduce_add"
            case ReduceMul: "reduce_mul"
            case ReduceMin: "reduce_min"
            case ReduceMax: "reduce_max"
            case Shuffle: "shuffle"
            case Splat: "splat"
            case Extract: "extract"
            case Insert: "insert"
            case Widen: "widen"
            case Narrow: "narrow"
            case Convert: "convert"

    fn is_binary() -> bool:
        match self:
            case Add | Sub | Mul | Div: true
            case And | Or | Xor: true
            case Eq | Ne | Lt | Le | Gt | Ge: true
            case _: false

    fn is_unary() -> bool:
        match self:
            case Not | ReduceAdd | ReduceMul | ReduceMin | ReduceMax: true
            case Splat | Widen | Narrow | Convert: true
            case _: false

    fn supports_float() -> bool:
        match self:
            case Add | Sub | Mul | Div: true
            case Eq | Ne | Lt | Le | Gt | Ge: true
            case ReduceAdd | ReduceMul | ReduceMin | ReduceMax: true
            case Splat | Extract | Insert: true
            case Convert: true
            case _: false

    fn supports_integer() -> bool:
        match self:
            case And | Or | Xor | Not: true
            case _: true  # Most ops support integers

# ============================================================================
# SIMD Check Error
# ============================================================================

enum SimdCheckError:
    """Error in SIMD type checking."""
    InvalidLaneCount(expected: i64, actual: i64)
    IncompatibleTypes(lhs: SimdVectorType, rhs: SimdVectorType)
    InvalidVectorWidth(bits: i64)
    UnsupportedOperation(op: SimdOperation, element_type: SimdElementType)
    LaneIndexOutOfBounds(index: i64, max_lanes: i64)
    ShuffleMaskInvalid(mask_len: i64, expected: i64)

impl SimdCheckError:
    fn to_text() -> text:
        match self:
            case InvalidLaneCount(expected, actual):
                "Invalid lane count: expected {expected}, got {actual}"
            case IncompatibleTypes(lhs, rhs):
                "Incompatible SIMD types: {lhs.to_text()} and {rhs.to_text()}"
            case InvalidVectorWidth(bits):
                "Invalid vector width: {bits} bits (must be 128, 256, or 512)"
            case UnsupportedOperation(op, elem):
                "Operation {op.to_text()} not supported for {elem.to_text()}"
            case LaneIndexOutOfBounds(idx, max):
                "Lane index {idx} out of bounds (max: {max})"
            case ShuffleMaskInvalid(len, expected):
                "Shuffle mask length {len} does not match expected {expected}"

# ============================================================================
# SIMD Type Checker
# ============================================================================

class SimdTypeChecker:
    """Type checker for SIMD operations."""
    errors: [SimdCheckError]
    target_max_width: i64  # Maximum vector width for target (128, 256, 512)

    static fn create(max_width: i64) -> SimdTypeChecker:
        SimdTypeChecker(errors: [], target_max_width: max_width)

    static fn for_sse() -> SimdTypeChecker:
        SimdTypeChecker__create(128)

    static fn for_avx() -> SimdTypeChecker:
        SimdTypeChecker__create(256)

    static fn for_avx512() -> SimdTypeChecker:
        SimdTypeChecker__create(512)

    me check_vector_type(ty: SimdVectorType) -> bool:
        """Check if a vector type is valid for the target."""
        if not ty.is_valid_width():
            self.errors = self.errors.push(SimdCheckError.InvalidVectorWidth(ty.total_bits()))
            return false

        if ty.total_bits() > self.target_max_width:
            self.errors = self.errors.push(SimdCheckError.InvalidVectorWidth(ty.total_bits()))
            return false

        true

    me check_binary_op(op: SimdOperation, lhs: SimdVectorType, rhs: SimdVectorType) -> bool:
        """Check a binary SIMD operation."""
        # Check types are compatible
        if not lhs.is_compatible_with(rhs):
            self.errors = self.errors.push(SimdCheckError.IncompatibleTypes(lhs, rhs))
            return false

        # Check operation supports element type
        if lhs.element_type.is_float() and not op.supports_float():
            self.errors = self.errors.push(SimdCheckError.UnsupportedOperation(op, lhs.element_type))
            return false

        true

    me check_lane_access(ty: SimdVectorType, lane_index: i64) -> bool:
        """Check a lane access is in bounds."""
        if lane_index < 0 or lane_index >= ty.lane_count:
            self.errors = self.errors.push(SimdCheckError.LaneIndexOutOfBounds(
                lane_index, ty.lane_count
            ))
            return false
        true

    me check_shuffle(ty: SimdVectorType, mask: [i64]) -> bool:
        """Check a shuffle operation."""
        if mask.len() != ty.lane_count:
            self.errors = self.errors.push(SimdCheckError.ShuffleMaskInvalid(
                mask.len(), ty.lane_count
            ))
            return false

        # Check each mask index is valid
        for idx in mask:
            if idx < 0 or idx >= ty.lane_count * 2:  # Can reference either source
                self.errors = self.errors.push(SimdCheckError.LaneIndexOutOfBounds(
                    idx, ty.lane_count * 2
                ))
                return false

        true

    fn get_errors() -> [SimdCheckError]:
        self.errors

    fn has_errors() -> bool:
        not self.errors.is_empty()

# ============================================================================
# Auto-Vectorization Analysis
# ============================================================================

enum VectorizationStatus:
    """Result of vectorization analysis."""
    Vectorizable(factor: i64)       # Can vectorize with given factor
    NotVectorizable(reason: text)   # Cannot vectorize, with reason
    PartiallyVectorizable(factor: i64, remainder: i64)

impl VectorizationStatus:
    fn can_vectorize() -> bool:
        match self:
            case Vectorizable(_) | PartiallyVectorizable(_, _): true
            case _: false

    fn to_text() -> text:
        match self:
            case Vectorizable(f):
                "vectorizable (factor: {f})"
            case NotVectorizable(reason):
                "not vectorizable: {reason}"
            case PartiallyVectorizable(f, r):
                "partially vectorizable (factor: {f}, remainder: {r})"

struct LoopInfo:
    """Information about a loop for vectorization."""
    iteration_count: i64?   # nil if unknown at compile time
    has_dependencies: bool
    has_function_calls: bool
    has_side_effects: bool
    stride: i64

impl LoopInfo:
    static fn simple_loop(iterations: i64) -> LoopInfo:
        LoopInfo(
            iteration_count: Some(iterations),
            has_dependencies: false,
            has_function_calls: false,
            has_side_effects: false,
            stride: 1
        )

    fn is_vectorization_candidate() -> bool:
        """Check if loop is a candidate for vectorization."""
        (not self.has_dependencies and
        not self.has_function_calls and
        self.stride == 1)

class AutoVectorizer:
    """Analyzes loops for auto-vectorization."""
    target_vector_width: i64  # In bits
    min_trip_count: i64       # Minimum iterations to vectorize

    static fn create(vector_width: i64) -> AutoVectorizer:
        AutoVectorizer(
            target_vector_width: vector_width,
            min_trip_count: 4
        )

    fn analyze_loop(info: LoopInfo, element_bits: i64) -> VectorizationStatus:
        """Analyze a loop for vectorization potential."""
        # Check basic requirements
        if not info.is_vectorization_candidate():
            if info.has_dependencies:
                return VectorizationStatus.NotVectorizable("loop has data dependencies")
            if info.has_function_calls:
                return VectorizationStatus.NotVectorizable("loop contains function calls")
            return VectorizationStatus.NotVectorizable("loop has side effects")

        # Calculate vectorization factor
        val factor = self.target_vector_width / element_bits

        # Check iteration count
        match info.iteration_count:
            case Some(count):
                if count < self.min_trip_count:
                    return VectorizationStatus.NotVectorizable("trip count too low")

                val remainder = count % factor
                if remainder == 0:
                    VectorizationStatus.Vectorizable(factor)
                else:
                    VectorizationStatus.PartiallyVectorizable(factor, remainder)

            case nil:
                # Unknown trip count - can still vectorize with runtime check
                VectorizationStatus.Vectorizable(factor)

    fn suggest_vector_type(element_type: SimdElementType) -> SimdVectorType:
        """Suggest vector type for element type based on target."""
        val elem_bits = element_type.bit_width()
        val lanes = self.target_vector_width / elem_bits
        SimdVectorType__create(element_type, lanes)

# ============================================================================
# SIMD Instruction Info
# ============================================================================

struct SimdInstructionInfo:
    """Information about a SIMD instruction."""
    operation: SimdOperation
    result_type: SimdVectorType
    operand_types: [SimdVectorType]
    latency: i64        # CPU cycles
    throughput: f64     # Instructions per cycle

impl SimdInstructionInfo:
    static fn binary(op: SimdOperation, ty: SimdVectorType) -> SimdInstructionInfo:
        SimdInstructionInfo(
            operation: op,
            result_type: ty,
            operand_types: [ty, ty],
            latency: 1,
            throughput: 1.0
        )

    static fn unary(op: SimdOperation, ty: SimdVectorType) -> SimdInstructionInfo:
        SimdInstructionInfo(
            operation: op,
            result_type: ty,
            operand_types: [ty],
            latency: 1,
            throughput: 1.0
        )

# ============================================================================
# Backend SIMD Capability
# ============================================================================

struct SimdCapability:
    """SIMD capabilities of a target backend."""
    max_vector_width: i64
    supported_types: [SimdVectorType]
    supported_ops: [SimdOperation]
    has_fma: bool       # Fused multiply-add
    has_gather: bool    # Gather loads
    has_scatter: bool   # Scatter stores

impl SimdCapability:
    static fn sse2() -> SimdCapability:
        SimdCapability(
            max_vector_width: 128,
            supported_types: [
                SimdVectorType__i8x16(),
                SimdVectorType__i16x8(),
                SimdVectorType__i32x4(),
                SimdVectorType__i64x2(),
                SimdVectorType__f32x4(),
                SimdVectorType__f64x2()
            ],
            supported_ops: [
                SimdOperation.Add,
                SimdOperation.Sub,
                SimdOperation.Mul,
                SimdOperation.And,
                SimdOperation.Or,
                SimdOperation.Xor
            ],
            has_fma: false,
            has_gather: false,
            has_scatter: false
        )

    static fn avx2() -> SimdCapability:
        SimdCapability(
            max_vector_width: 256,
            supported_types: [
                SimdVectorType__create(SimdElementType.I32, 8),
                SimdVectorType__create(SimdElementType.F32, 8),
                SimdVectorType__create(SimdElementType.F64, 4)
            ],
            supported_ops: [
                SimdOperation.Add,
                SimdOperation.Sub,
                SimdOperation.Mul,
                SimdOperation.Div,
                SimdOperation.And,
                SimdOperation.Or,
                SimdOperation.Xor,
                SimdOperation.Shuffle
            ],
            has_fma: true,
            has_gather: true,
            has_scatter: false
        )

    fn supports_type(ty: SimdVectorType) -> bool:
        ty.total_bits() <= self.max_vector_width

    fn supports_operation(op: SimdOperation) -> bool:
        self.supported_ops.contains(op)

# ============================================================================
# Convenience Functions
# ============================================================================

fn check_simd_binary(op: SimdOperation, lhs: SimdVectorType, rhs: SimdVectorType) -> Result<(), SimdCheckError>:
    """Check a binary SIMD operation."""
    var checker = SimdTypeChecker__for_avx()
    if checker.check_binary_op(op, lhs, rhs):
        Ok(())
    else:
        Err(checker.get_errors()[0])

fn can_vectorize_loop(iterations: i64, element_bits: i64) -> bool:
    """Check if a loop can be vectorized."""
    val info = LoopInfo__simple_loop(iterations)
    val vectorizer = AutoVectorizer__create(128)
    vectorizer.analyze_loop(info, element_bits).can_vectorize()

fn get_vector_type_for_scalar(scalar_type: text) -> SimdVectorType?:
    """Get appropriate vector type for a scalar type."""
    match scalar_type:
        case "i8": Some(SimdVectorType__i8x16())
        case "i16": Some(SimdVectorType__i16x8())
        case "i32": Some(SimdVectorType__i32x4())
        case "i64": Some(SimdVectorType__i64x2())
        case "f32": Some(SimdVectorType__f32x4())
        case "f64": Some(SimdVectorType__f64x2())
        case _: nil

# ============================================================================
# Exports
# ============================================================================


# Desugared static methods for bootstrap interpreter compatibility

fn SimdTypeChecker__create(max_width: i64) -> SimdTypeChecker:
    SimdTypeChecker(errors: [], target_max_width: max_width)



fn SimdTypeChecker__for_sse() -> SimdTypeChecker:
    SimdTypeChecker__create(128)



fn SimdTypeChecker__for_avx() -> SimdTypeChecker:
    SimdTypeChecker__create(256)



fn SimdTypeChecker__for_avx512() -> SimdTypeChecker:
        SimdTypeChecker__create(512)

    me check_vector_type(ty: SimdVectorType) -> bool:
        """Check if a vector type is valid for the target."""
        if not ty.is_valid_width():
            self.errors = self.errors.push(SimdCheckError.InvalidVectorWidth(ty.total_bits()))
            return false

        if ty.total_bits() > self.target_max_width:
            self.errors = self.errors.push(SimdCheckError.InvalidVectorWidth(ty.total_bits()))
            return false

        true

    me check_binary_op(op: SimdOperation, lhs: SimdVectorType, rhs: SimdVectorType) -> bool:
        """Check a binary SIMD operation."""
        # Check types are compatible
        if not lhs.is_compatible_with(rhs):
            self.errors = self.errors.push(SimdCheckError.IncompatibleTypes(lhs, rhs))
            return false

        # Check operation supports element type
        if lhs.element_type.is_float() and not op.supports_float():
            self.errors = self.errors.push(SimdCheckError.UnsupportedOperation(op, lhs.element_type))
            return false

        true

    me check_lane_access(ty: SimdVectorType, lane_index: i64) -> bool:
        """Check a lane access is in bounds."""
        if lane_index < 0 or lane_index >= ty.lane_count:
            self.errors = self.errors.push(SimdCheckError.LaneIndexOutOfBounds(
                lane_index, ty.lane_count
            ))
            return false
        true

    me check_shuffle(ty: SimdVectorType, mask: [i64]) -> bool:
        """Check a shuffle operation."""
        if mask.len() != ty.lane_count:
            self.errors = self.errors.push(SimdCheckError.ShuffleMaskInvalid(
                mask.len(), ty.lane_count
            ))
            return false

        # Check each mask index is valid
        for idx in mask:
            if idx < 0 or idx >= ty.lane_count * 2:  # Can reference either source
                self.errors = self.errors.push(SimdCheckError.LaneIndexOutOfBounds(
                    idx, ty.lane_count * 2
                ))
                return false

        true

    fn get_errors() -> [SimdCheckError]:
        self.errors

    fn has_errors() -> bool:
        not self.errors.is_empty()



fn AutoVectorizer__create(vector_width: i64) -> AutoVectorizer:
        AutoVectorizer(
            target_vector_width: vector_width,
            min_trip_count: 4
        )

    fn analyze_loop(info: LoopInfo, element_bits: i64) -> VectorizationStatus:
        """Analyze a loop for vectorization potential."""
        # Check basic requirements
        if not info.is_vectorization_candidate():
            if info.has_dependencies:
                return VectorizationStatus.NotVectorizable("loop has data dependencies")
            if info.has_function_calls:
                return VectorizationStatus.NotVectorizable("loop contains function calls")
            return VectorizationStatus.NotVectorizable("loop has side effects")

        # Calculate vectorization factor
        val factor = self.target_vector_width / element_bits

        # Check iteration count
        match info.iteration_count:
            case Some(count):
                if count < self.min_trip_count:
                    return VectorizationStatus.NotVectorizable("trip count too low")

                val remainder = count % factor
                if remainder == 0:
                    VectorizationStatus.Vectorizable(factor)
                else:
                    VectorizationStatus.PartiallyVectorizable(factor, remainder)

            case nil:
                # Unknown trip count - can still vectorize with runtime check
                VectorizationStatus.Vectorizable(factor)

    fn suggest_vector_type(element_type: SimdElementType) -> SimdVectorType:
        """Suggest vector type for element type based on target."""
        val elem_bits = element_type.bit_width()
        val lanes = self.target_vector_width / elem_bits
        SimdVectorType__create(element_type, lanes)



# Auto-generated desugared static method wrappers
fn LoopInfo__simple_loop(iterations: i64) -> LoopInfo:
    LoopInfo(
        iteration_count: Some(iterations),
        has_dependencies: false,
        has_function_calls: false,
        has_side_effects: false,
        stride: 1
    )


fn SimdVectorType__create(element: SimdElementType, lanes: i64) -> SimdVectorType:
        SimdVectorType(element_type: element, lane_count: lanes)

    # Standard vector types

fn SimdVectorType__f32x4() -> SimdVectorType:
    SimdVectorType__create(SimdElementType.F32, 4)


fn SimdVectorType__f64x2() -> SimdVectorType:
    SimdVectorType__create(SimdElementType.F64, 2)


fn SimdVectorType__i16x8() -> SimdVectorType:
    SimdVectorType__create(SimdElementType.I16, 8)


fn SimdVectorType__i32x4() -> SimdVectorType:
    SimdVectorType__create(SimdElementType.I32, 4)


fn SimdVectorType__i64x2() -> SimdVectorType:
    SimdVectorType__create(SimdElementType.I64, 2)


fn SimdVectorType__i8x16() -> SimdVectorType:
    SimdVectorType__create(SimdElementType.I8, 16)


export SimdElementType, SimdVectorType, SimdOperation
export SimdCheckError, SimdTypeChecker
export VectorizationStatus, LoopInfo, AutoVectorizer
export SimdInstructionInfo, SimdCapability
export check_simd_binary, can_vectorize_loop, get_vector_type_for_scalar
