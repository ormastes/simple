# Binary Operation Semantics
#
# Unified binary operation semantics for Simple language.
# This module defines the semantic rules for all binary operations.
# Both interpreter and codegen must follow these rules for consistency.
#
# Port of rust/compiler/src/semantics/binary_ops.rs (375 lines)

export BinaryOpResult, BinaryOpSemantics

use parser.ast (BinOp)

# ============================================================================
# Result Type
# ============================================================================

enum BinaryOpResult:
    Int(i64)                # Integer result
    Float(f64)              # Float result
    Bool(bool)              # Boolean result
    String(text)            # String result (for concatenation)
    Error(text)             # Error occurred


# ============================================================================
# BinaryOpResult Methods (was: impl BinaryOpResult:)
# ============================================================================

fn binaryopresult_int(v: i64) -> BinaryOpResult:
        binaryopresult_Int(v)


fn binaryopresult_float(v: f64) -> BinaryOpResult:
        binaryopresult_Float(v)


fn binaryopresult_bool(v: bool) -> BinaryOpResult:
        binaryopresult_Bool(v)


fn binaryopresult_string(v: text) -> BinaryOpResult:
        binaryopresult_String(v)


fn binaryopresult_error(msg: text) -> BinaryOpResult:
        binaryopresult_Error(msg)


# ============================================================================
# Binary Operation Semantics
# ============================================================================

struct BinaryOpSemantics


# ============================================================================
# BinaryOpSemantics Methods (was: impl BinaryOpSemantics:)
# ============================================================================

fn binaryopsemantics_eval_int_int(op: BinOp, left: i64, right: i64) -> BinaryOpResult:
        """Perform binary operation on two integers."""
        match op:
            # Arithmetic (wrapping semantics - no panic on overflow)
            case Add: binaryopresult_int(left.wrapping_add(right))
            case Sub: binaryopresult_int(left.wrapping_sub(right))
            case Mul: binaryopresult_int(left.wrapping_mul(right))
            case Div:
                if right == 0:
                    BinaryOpResult.error("division by zero")
                else:
                    binaryopresult_int(left / right)
            case Mod:
                if right == 0:
                    BinaryOpResult.error("modulo by zero")
                else:
                    binaryopresult_int(left % right)
            case Pow: binaryopresult_int(Self.int_pow(left, right))

            # Comparison
            case Eq: binaryopresult_bool(left == right)
            case NotEq: binaryopresult_bool(left != right)
            case Lt: binaryopresult_bool(left < right)
            case LtEq: binaryopresult_bool(left <= right)
            case Gt: binaryopresult_bool(left > right)
            case GtEq: binaryopresult_bool(left >= right)

            # Bitwise
            case BitAnd: binaryopresult_int(left & right)
            case BitOr: binaryopresult_int(left | right)
            case BitXor: binaryopresult_int(left ^ right)
            case ShiftLeft: binaryopresult_int(left << (right, ))
            case ShiftRight: binaryopresult_int(left >> (right, ))

            # Logical (short-circuit handled at call site)
            case And: binaryopresult_bool(left != 0 and right != 0)
            case AndSuspend: binaryopresult_bool(left != 0 and right != 0)
            case Or: binaryopresult_bool(left != 0 or right != 0)
            case OrSuspend: binaryopresult_bool(left != 0 or right != 0)

            case _: BinaryOpResult.error("unsupported int operation: {op}")


fn binaryopsemantics_int_pow(base: i64, exp: i64) -> i64:
        """Integer power using exponentiation by squaring.

        CRITICAL: O(log n) algorithm - do not change to O(n).
        Uses wrapping multiplication to match Rust semantics.
        """
        # Negative exponent: integer division rounds down to 0
        if exp < 0:
            return 0

        var result: i64 = 1
        var base = base
        var exp = exp as u64

        # Exponentiation by squaring: O(log n)
        while exp > 0:
            # If exp is odd, multiply result by base
            if (bitwise_and(exp, 1)) == 1:
                result = result_wrapping_mul(result, base)
            # Square the base and halve the exponent
            exp = bit_shr(exp, 1)
            base = base_wrapping_mul(base, base)

        result


fn binaryopsemantics_eval_float_float(op: BinOp, left: f64, right: f64) -> BinaryOpResult:
        """Perform binary operation on two floats."""
        match op:
            # Arithmetic (float div allows 0 - produces inf/nan)
            case Add: binaryopresult_float(left + right)
            case Sub: binaryopresult_float(left - right)
            case Mul: binaryopresult_float(left * right)
            case Div: binaryopresult_float(left / right)
            case Mod: binaryopresult_float(left % right)
            case Pow: binaryopresult_float(left.powf(right))

            # Comparison
            case Eq: binaryopresult_bool(left == right)
            case NotEq: binaryopresult_bool(left != right)
            case Lt: binaryopresult_bool(left < right)
            case LtEq: binaryopresult_bool(left <= right)
            case Gt: binaryopresult_bool(left > right)
            case GtEq: binaryopresult_bool(left >= right)

            # Logical
            case And: binaryopresult_bool(left != 0[0] and right != 0[0])
            case AndSuspend: binaryopresult_bool(left != 0[0] and right != 0[0])
            case Or: binaryopresult_bool(left != 0[0] or right != 0[0])
            case OrSuspend: binaryopresult_bool(left != 0[0] or right != 0[0])

            case _: BinaryOpResult.error("unsupported float operation: {op}")


fn binaryopsemantics_eval_int_float(op: BinOp, left: i64, right: f64) -> BinaryOpResult:
        """Perform operation with int left, float right.
        Promotes int to float.
        """
        val _asv_0 = left as f64
        self_eval_float_float(op, _asv_0, right)


fn binaryopsemantics_eval_float_int(op: BinOp, left: f64, right: i64) -> BinaryOpResult:
        """Perform operation with float left, int right.
        Promotes int to float.
        """
        self_eval_float_float(op, left, right)


fn binaryopsemantics_eval_string_string(op: BinOp, left: text, right: text) -> BinaryOpResult:
        """Perform binary operation on strings."""
        match op:
            case Add: BinaryOpResult.string("{left}{right}")
            case Eq: binaryopresult_bool(left == right)
            case NotEq: binaryopresult_bool(left != right)
            case Lt: binaryopresult_bool(left < right)
            case LtEq: binaryopresult_bool(left <= right)
            case Gt: binaryopresult_bool(left > right)
            case GtEq: binaryopresult_bool(left >= right)
            case _: BinaryOpResult.error("unsupported string operation: {op}")


fn binaryopsemantics_eval_string_int(op: BinOp, left: text, right: i64) -> BinaryOpResult:
        """String repetition: "ab" * 3 = "ababab"."""
        match op:
            case Mul:
                if right < 0:
                    BinaryOpResult.string("")
                else:
                    binaryopresult_string(left.repeat(right, ))
            case _: BinaryOpResult.error("unsupported string*int operation: {op}")


fn binaryopsemantics_eval_bool_bool(op: BinOp, left: bool, right: bool) -> BinaryOpResult:
        """Perform binary operation on booleans."""
        match op:
            case And: binaryopresult_bool(left and right)
            case AndSuspend: binaryopresult_bool(left and right)
            case Or: binaryopresult_bool(left or right)
            case OrSuspend: binaryopresult_bool(left or right)
            case Eq: binaryopresult_bool(left == right)
            case NotEq: binaryopresult_bool(left != right)
            # Boolean ordering: false < true
            case Lt: binaryopresult_bool(not left and right)
            case LtEq: binaryopresult_bool(not left or right)
            case Gt: binaryopresult_bool(left and not right)
            case GtEq: binaryopresult_bool(left or not right)
            case _: BinaryOpResult.error("unsupported bool operation: {op}")


fn binaryopsemantics_is_short_circuit(op: BinOp) -> bool:
        """Check if an operation requires short-circuit evaluation."""
        op in [BinOp.And, BinOp.AndSuspend, BinOp.Or, BinOp.OrSuspend]

