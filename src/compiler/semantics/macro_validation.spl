# Macro Validation
#
# Ordering constraints, shadowing detection, and validation rules
# for one-pass LL(1) macro compilation.
#
# Port of rust/compiler/src/macro_validation.rs (464 lines)


# Auto-generated desugared static method wrappers
fn ValidationResult__error(msg: text) -> ValidationResult:
    ValidationResult(is_valid: false, errors: [msg], warnings: [])


fn ValidationResult__ok() -> ValidationResult:
    ValidationResult(is_valid: true, errors: [], warnings: [])


export BlockPosition, BlockContext, MacroValidator, ValidationResult

# ============================================================================
# Block Position
# ============================================================================

enum BlockPosition:
    Head        # Before any non-macro statements
    Middle      # After some non-macro statements
    Tail        # After all non-macro statements

# ============================================================================
# Block Context
# ============================================================================

class BlockContext:
    """Context about current block during macro expansion."""
    has_non_macro_statements: bool
    current_position: BlockPosition

impl BlockContext:
    static fn create() -> BlockContext:
        BlockContext(has_non_macro_statements: false,
                     current_position: BlockPosition.Head)

    me mark_non_macro_statement():
        self.has_non_macro_statements = true
        self.current_position = BlockPosition.Middle

    me mark_block_end():
        self.current_position = BlockPosition.Tail

# ============================================================================
# Validation Result
# ============================================================================

struct ValidationResult:
    is_valid: bool
    errors: [text]
    warnings: [text]

impl ValidationResult:
    static fn ok() -> ValidationResult:
        ValidationResult(is_valid: true, errors: [], warnings: [])

    static fn error(msg: text) -> ValidationResult:
        ValidationResult(is_valid: false, errors: [msg], warnings: [])

    fn merge(other: ValidationResult) -> ValidationResult:
        ValidationResult(
            is_valid: self.is_valid and other.is_valid,
            errors: self.errors.merge(other.errors),
            warnings: self.warnings.merge(other.warnings))

# ============================================================================
# Macro Validator
# ============================================================================

class MacroValidator:
    """Validates macro definitions for one-pass compilation."""
    known_macros: [text]
    max_expansion_depth: i64

impl MacroValidator:
    static fn create() -> MacroValidator:
        MacroValidator(known_macros: [], max_expansion_depth: 64)

    me register_macro(name: text):
        if not self.known_macros.contains(name):
            self.known_macros = self.known_macros.push(name)

    fn validate_contract(contract_items: [text],
                         const_bindings: {text: text}) -> ValidationResult:
        """Validate macro contract items."""
        var result = ValidationResult__ok()

        # Check ordering: returns before intro before inject
        var seen_returns = false
        var seen_intro = false
        var seen_inject = false

        for item in contract_items:
            match item:
                case "returns":
                    if seen_intro or seen_inject:
                        result = result.merge(ValidationResult__error(
                            "returns must appear before intro and inject"))
                    seen_returns = true
                case "intro":
                    if seen_inject:
                        result = result.merge(ValidationResult__error(
                            "intro must appear before inject"))
                    seen_intro = true
                case "inject":
                    seen_inject = true
                case _: ()

        result

    fn validate_no_shadowing(name: text, scope: [text]) -> ValidationResult:
        """Check that a macro intro doesn't shadow existing symbols."""
        if scope.contains(name):
            ValidationResult__error("macro symbol '{name}' shadows existing definition")
        else:
            ValidationResult__ok()

    fn validate_expansion_depth(depth: i64) -> ValidationResult:
        if depth > self.max_expansion_depth:
            ValidationResult__error(
                "macro expansion depth {depth} exceeds limit {self.max_expansion_depth}")
        else:
            ValidationResult__ok()

    fn validate_const_binding(name: text, value: text,
                               const_bindings: {text: text}) -> ValidationResult:
        """Validate that a const binding references a valid const parameter."""
        if not const_bindings.contains_key(name):
            ValidationResult__error("unknown const parameter '{name}'")
        else:
            ValidationResult__ok()
