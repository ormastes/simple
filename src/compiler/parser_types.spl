# Parser Types - AST Type Definitions
#
# This module contains all AST (Abstract Syntax Tree) type definitions:
# - Module structure (Module, Import, Export, Function, Class, etc.)
# - Expression types (Expr, ExprKind)
# - Statement types (Stmt, StmtKind, Block)
# - Pattern types (Pattern, PatternKind)
# - Type system (Type, TypeKind)
# - Operators (BinOp, UnaryOp)

use lexer.Span

struct Module:
    """Complete parsed module."""
    name: text
    imports: [Import]
    exports: [Export]
    functions: Dict<text, Function>
    classes: Dict<text, Class>
    structs: Dict<text, Struct>
    enums: Dict<text, Enum>
    traits: Dict<text, Trait>
    impls: [Impl]
    type_aliases: Dict<text, TypeAlias>
    constants: Dict<text, Const>

struct Import:
    """Import declaration."""
    module: text
    items: [ImportItem]
    span: Span

struct ImportItem:
    """Single imported item."""
    name: text
    alias: text?

struct Export:
    """Export declaration."""
    items: [text]
    span: Span

struct Function:
    """Function definition."""
    name: text
    type_params: [TypeParam]
    params: [Param]
    return_type: Type?
    body: Block
    is_async: bool
    is_static: bool
    is_public: bool
    is_method: bool
    is_mutable: bool    # 'me' vs 'fn'
    doc_comment: text?
    span: Span

struct Param:
    """Function parameter."""
    name: text
    type_: Type?
    default: Expr?
    span: Span

struct TypeParam:
    """Generic type parameter."""
    name: text
    bounds: [Type]
    default: Type?
    span: Span

struct TraitBound:
    """Trait bound constraint: T: Trait

    Used in:
    - Function signatures: fn foo<T: Display>(x: T)
    - Where clauses: where T: Clone
    - Trait definitions: trait Ord: Eq
    - Impl blocks: impl<T: Clone> Clone for Vec<T>
    """
    type_param: text            # Type parameter name being constrained
    trait_: Type                # Trait that must be implemented
    span: Span

struct Class:
    """Class definition."""
    name: text
    type_params: [TypeParam]
    fields: [Field]
    methods: Dict<text, Function>
    is_public: bool
    doc_comment: text?
    span: Span

struct Struct:
    """Struct definition."""
    name: text
    type_params: [TypeParam]
    fields: [Field]
    is_public: bool
    doc_comment: text?
    span: Span

struct Field:
    """Struct/class field."""
    name: text
    type_: Type
    default: Expr?
    is_public: bool
    span: Span

struct Enum:
    """Enum definition."""
    name: text
    type_params: [TypeParam]
    variants: [Variant]
    is_public: bool
    doc_comment: text?
    span: Span

struct Variant:
    """Enum variant."""
    name: text
    kind: VariantKind
    span: Span

"""Enum variant kind."""
enum VariantKind:
    Unit
    Tuple(types: [Type])
    Struct(fields: [Field])

struct Trait:
    """Trait definition.

    Example:
        trait Display:
            fn to_string() -> text

        trait Ord: Eq:  # Supertrait
            fn cmp(other: Self) -> Ordering
            fn max(other: Self) -> Self:  # Default implementation
                if self.cmp(other) == Greater: self else: other
    """
    name: text
    type_params: [TypeParam]
    super_traits: [Type]         # Trait: Supertrait bounds (e.g., trait Ord: Eq)
    where_clause: [TraitBound]   # Where clauses on the trait
    methods: [Function]          # Both abstract and default method implementations
    is_public: bool
    doc_comment: text?
    span: Span

struct Impl:
    """Impl block.

    Examples:
        # Inherent impl (no trait)
        impl Point:
            fn new(x: i64, y: i64) -> Point: ...

        # Trait impl
        impl Display for Point:
            fn to_string() -> text: ...

        # Generic impl with where clause
        impl<T> Display for Vec<T> where T: Display:
            fn to_string() -> text: ...
    """
    type_: Type                 # Type being implemented for
    trait_: Type?               # Trait being implemented (None for inherent impl)
    type_params: [TypeParam]    # Generic parameters (impl<T>)
    where_clause: [TraitBound]  # Where T: Trait constraints
    methods: Dict<text, Function>
    span: Span

struct TypeAlias:
    """Type alias."""
    name: text
    type_params: [TypeParam]
    type_: Type
    is_public: bool
    span: Span

struct Const:
    """Module-level constant."""
    name: text
    type_: Type?
    value: Expr
    is_mutable: bool
    is_public: bool
    span: Span

# ============================================================================
# Type AST
# ============================================================================

struct Type:
    """Type expression."""
    kind: TypeKind
    span: Span

"""Type expression kind."""
enum TypeKind:
    Named(name: text, args: [Type])
    Tuple(elements: [Type])
    Array(element: Type, size: Expr?)
    Function(params: [Type], ret: Type)
    Optional(inner: Type)
    Reference(inner: Type, mutable: bool)
    Infer
    Error

# ============================================================================
# Tensor Suffix
# ============================================================================

"""Data type for tensors."""
enum DType:
    F16
    F32
    F64
    BF16
    I8
    I16
    I32
    I64
    U8
    U16
    U32
    U64

"""Device for tensor computation."""
enum Device:
    CPU
    GPU             # Default GPU
    CUDA(id: i32)   # Specific CUDA device

"""Tensor backend."""
enum Backend:
    Native
    PyTorch

struct TensorSuffix:
    """Suffix for array/tensor literals specifying dtype, device, etc.

    Examples:
    - f32        -> dtype=F32
    - _f32_gpu   -> dtype=F32, device=GPU
    - f32_tr_cuda -> dtype=F32, trainable=true, device=CUDA(0)
    """
    dtype: DType?
    device: Device?
    trainable: bool
    pinned: bool
    backend: Backend?
    raw: text       # Original suffix string

impl TensorSuffix:
    static fn from_string(s: text) -> TensorSuffix:
        """Parse a suffix string into TensorSuffix."""
        var suffix = TensorSuffix(
            dtype: nil,
            device: nil,
            trainable: false,
            pinned: false,
            backend: nil,
            raw: s
        )

        # Split by underscore and parse each part
        var parts = s.split("_")
        for part in parts:
            if part == "":
                continue

            # Check dtype
            match part:
                case "f16": suffix.dtype = Some(DType.F16)
                case "f32": suffix.dtype = Some(DType.F32)
                case "f64": suffix.dtype = Some(DType.F64)
                case "bf16": suffix.dtype = Some(DType.BF16)
                case "i8": suffix.dtype = Some(DType.I8)
                case "i16": suffix.dtype = Some(DType.I16)
                case "i32": suffix.dtype = Some(DType.I32)
                case "i64": suffix.dtype = Some(DType.I64)
                case "u8": suffix.dtype = Some(DType.U8)
                case "u16": suffix.dtype = Some(DType.U16)
                case "u32": suffix.dtype = Some(DType.U32)
                case "u64": suffix.dtype = Some(DType.U64)
                # Check device
                case "cpu": suffix.device = Some(Device.CPU)
                case "gpu": suffix.device = Some(Device.GPU)
                case "cuda": suffix.device = Some(Device.CUDA(0))
                case "cuda0": suffix.device = Some(Device.CUDA(0))
                case "cuda1": suffix.device = Some(Device.CUDA(1))
                case "cuda2": suffix.device = Some(Device.CUDA(2))
                case "cuda3": suffix.device = Some(Device.CUDA(3))
                # Check modifiers
                case "tr": suffix.trainable = true
                case "pin": suffix.pinned = true
                # Check backend
                case "native": suffix.backend = Some(Backend.Native)
                case "torch": suffix.backend = Some(Backend.PyTorch)
                case _:
                    # Unknown part - could be cudaN for N > 3
                    if part.starts_with("cuda"):
                        val id_str = part[4:]
                        if id_str.len() > 0:
                            # Parse the numeric ID
                            val id = parse_int_literal(id_str)
                            suffix.device = Some(Device.CUDA(id as i32))

        suffix

# ============================================================================
# Expression AST
# ============================================================================

struct Expr:
    """Expression."""
    kind: ExprKind
    span: Span

"""Expression kind."""
enum ExprKind:
    # Literals
    IntLit(value: i64)
    FloatLit(value: f64)
    StringLit(value: text, interpolations: [Interpolation]?)
    BoolLit(value: bool)
    NilLit
    ArrayLit(elements: [Expr])
    TupleLit(elements: [Expr])
    DictLit(entries: [(Expr, Expr)])

    # Identifiers and access
    Ident(name: text)
    Field(base: Expr, field: text)
    Index(base: Expr, index: Expr)
    OptionalChain(base: Expr, field: text)  # ?.
    NullCoalesce(left: Expr, right: Expr)    # ??
    ExistsCheck(base: Expr)                   # .?

    # Operators
    Binary(op: BinOp, left: Expr, right: Expr)
    Unary(op: UnaryOp, operand: Expr)
    Range(start: Expr?, end: Expr?, inclusive: bool, step: Expr?)

    # Function calls
    Call(callee: Expr, args: [CallArg])
    MethodCall(receiver: Expr, method: text, args: [CallArg])

    # Control flow expressions
    If(cond: Expr, then_: Block, else_: Block?)
    Match(scrutinee: Expr, arms: [MatchArm])
    Try(expr: Expr)                           # expr?
    TryCatch(body: Block, catches: [CatchClause], finally_: Block?)

    # Closures
    Lambda(params: [LambdaParam], body: Expr)
    Block(block: Block)

    # Comprehensions
    ListComprehension(expr: Expr, clauses: [ComprehensionClause])
    DictComprehension(key: Expr, value: Expr, clauses: [ComprehensionClause])

    # Special
    Await(expr: Expr)
    Yield(expr: Expr?)
    Return(expr: Expr?)
    Break(label: text?)
    Continue(label: text?)
    Throw(expr: Expr)

    # Object construction
    StructLit(type_: text, fields: [(text, Expr)])
    EnumLit(enum_: text, variant: text, payload: EnumPayload?)

    # Math/DL blocks
    LossBlock(body: Block)            # loss{ ... } - enables autograd, auto-backward
    NogradBlock(body: Block)          # nograd{ ... } - disables gradient tracking

    # Generic custom block (user-defined blocks like sh{}, sql{}, re{})
    CustomBlock(kind: text, value: BlockValue)

    # Tensor literals with suffix
    ArrayLitSuffix(elements: [Expr], suffix: TensorSuffix)

    # Error recovery
    Error

struct Interpolation:
    """String interpolation."""
    expr: Expr
    format: text?
    span: Span

struct CallArg:
    """Function call argument."""
    name: text?     # Named argument
    value: Expr
    span: Span

struct MatchArm:
    """Match arm."""
    pattern: Pattern
    guard: Expr?
    body: Block
    span: Span

struct CatchClause:
    """Catch clause in try-catch."""
    pattern: Pattern?
    type_: Type?
    body: Block
    span: Span

struct LambdaParam:
    """Lambda parameter."""
    name: text
    type_: Type?
    span: Span

struct ComprehensionClause:
    """Comprehension clause."""
    kind: ComprehensionKind
    span: Span

enum ComprehensionKind:
    For(var_: text, iter: Expr)
    If(cond: Expr)

enum EnumPayload:
    Tuple(values: [Expr])
    Struct(fields: [(text, Expr)])

# ============================================================================
# Pattern AST
# ============================================================================

struct Pattern:
    """Pattern for matching."""
    kind: PatternKind
    span: Span

"""Pattern kind."""
enum PatternKind:
    Wildcard                                  # _
    Literal(value: Expr)                      # 42, "hello", true
    Binding(name: text, mutable: bool)        # x, var x
    Tuple(elements: [Pattern])                # (a, b, c)
    Array(elements: [Pattern], rest: text?)   # [a, b, ..rest]
    Struct(type_: text, fields: [(text, Pattern)]) # Point { x, y }
    Enum(enum_: text, variant: text, payload: EnumPatternPayload?)
    Or(patterns: [Pattern])                   # a | b | c
    Guard(pattern: Pattern, guard: Expr)      # p if cond
    As(pattern: Pattern, name: text)          # p as name
    Range(start: Expr?, end: Expr?, inclusive: bool) # 1..10, 1..=10
    Error

enum EnumPatternPayload:
    Tuple(patterns: [Pattern])
    Struct(fields: [(text, Pattern)])

# ============================================================================
# Statement AST
# ============================================================================

struct Stmt:
    """Statement."""
    kind: StmtKind
    span: Span

"""Statement kind."""
enum StmtKind:
    Expr(expr: Expr)
    Val(name: text, type_: Type?, init: Expr)
    Var(name: text, type_: Type?, init: Expr?)
    Assign(target: Expr, op: AssignOp?, value: Expr)
    For(var_: text, iter: Expr, body: Block)
    While(cond: Expr, body: Block)
    Loop(body: Block)
    Break(label: text?)
    Continue(label: text?)
    Return(value: Expr?)
    Yield(value: Expr?)
    Throw(value: Expr)

"""Assignment operator."""
enum AssignOp:
    Add     # +=
    Sub     # -=
    Mul     # *=
    Div     # /=
    Mod     # %=

struct Block:
    """Block of statements."""
    stmts: [Stmt]
    span: Span

# ============================================================================
# Operators
# ============================================================================

"""Binary operator."""
enum BinOp:
    # Arithmetic
    Add, Sub, Mul, Div, Mod, Pow

    # Matrix operations
    MatMul              # @

    # Comparison
    Eq, NotEq, Lt, LtEq, Gt, GtEq

    # Logical
    And, Or

    # Bitwise
    BitAnd, BitOr, BitXor, Shl, Shr

    # Broadcast operations (dotted operators)
    BroadcastAdd        # .+
    BroadcastSub        # .-
    BroadcastMul        # .*
    BroadcastDiv        # ./
    BroadcastPow        # .^

    # Pipeline/Composition operators
    PipeForward         # |>
    Compose             # >>
    ComposeBack         # <<
    Parallel            # //
    LayerConnect        # ~>

    # Other
    In, NotIn, Is, IsNot

"""Unary operator."""
enum UnaryOp:
    Neg         # -
    Not         # not, !
    BitNot      # ~
    Ref         # &
    Deref       # *
    Transpose   # ' (postfix, m{} only)

# ============================================================================
# Parser
# ============================================================================

struct Parser:
    """Full AST parser using TreeSitter outline."""
    source: text
    lexer: Lexer
    current: Token
    previous: Token
    errors: [ParseError]
    outline: OutlineModule?
    resolved_blocks: ResolvedModule?  # Pre-resolved blocks from BlockResolver


# ============================================================================
# Exports
# ============================================================================

fn parse_float_literal(text: text) -> f64:
    """Parse float literal."""
    # TODO: Implement proper parsing
    0.0

# ============================================================================
# Exports
# ============================================================================

export Module, Import, ImportItem, Export
export Function, Param, TypeParam, TraitBound, Class, Struct, Field
export Enum, Variant, VariantKind, Trait, Impl, TypeAlias, Const
export Type, TypeKind
export Expr, ExprKind, Interpolation, CallArg, MatchArm, CatchClause
export LambdaParam, ComprehensionClause, ComprehensionKind, EnumPayload
export Pattern, PatternKind, EnumPatternPayload
export Stmt, StmtKind, AssignOp, Block
export BinOp, UnaryOp
export Parser
export DType, Device, Backend, TensorSuffix
