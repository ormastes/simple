# Parser Types - AST Type Definitions
#
# This module contains all AST (Abstract Syntax Tree) type definitions:
# - Module structure (Module, Import, Export, Function, Class, etc.)
# - Expression types (Expr, ExprKind)
# - Statement types (Stmt, StmtKind, Block)
# - Pattern types (Pattern, PatternKind)
# - Type system (Type, TypeKind)
# - Operators (BinOp, UnaryOp)

use lexer.Span

struct Module:
    """Complete parsed module."""
    name: text
    imports: [Import]
    exports: [Export]
    functions: Dict<text, Function>
    classes: Dict<text, Class>
    actors: Dict<text, ActorDef>
    structs: Dict<text, Struct>
    enums: Dict<text, Enum>
    bitfields: Dict<text, Bitfield>
    traits: Dict<text, Trait>
    impls: [Impl]
    type_aliases: Dict<text, TypeAlias>
    constants: Dict<text, Const>
    static_asserts: [StaticAssert]

struct Import:
    """Import declaration."""
    module: text
    items: [ImportItem]
    span: Span

struct ImportItem:
    """Single imported item."""
    name: text
    alias: text?

struct Export:
    """Export declaration."""
    items: [text]
    span: Span

struct Function:
    """Function definition."""
    name: text
    type_params: [TypeParam]
    params: [Param]
    return_type: Type?
    body: Block
    is_async: bool
    is_static: bool
    is_public: bool
    is_method: bool
    is_mutable: bool    # 'me' vs 'fn'
    is_const: bool      # 'const fn' - can be evaluated at compile time
    is_kernel: bool     # 'kernel fn' - GPU kernel function
    is_extern: bool     # 'extern fn' - external function (no body)
    attributes: [Attribute]  # Attribute annotations (Phase 3.3 - TODO âœ…)
    doc_comment: text?
    span: Span

struct Param:
    """Function parameter."""
    name: text
    type_: Type?
    default: Expr?
    span: Span

struct TypeParam:
    """Generic type parameter."""
    name: text
    bounds: [Type]
    default: Type?
    span: Span

struct TraitBound:
    """Trait bound constraint: T: Trait

    Used in:
    - Function signatures: fn foo<T: Display>(x: T)
    - Where clauses: where T: Clone
    - Trait definitions: trait Ord: Eq
    - Impl blocks: impl<T: Clone> Clone for Vec<T>
    """
    type_param: text            # Type parameter name being constrained
    trait_: Type                # Trait that must be implemented
    span: Span

struct Attribute:
    """Attribute annotation on a declaration.

    Syntax:
        @name                     # Simple attribute
        @name(value)              # Attribute with single argument
        @name(arg1, arg2, ...)    # Attribute with multiple arguments
        @name("string_value")     # Attribute with string argument

    Examples:
        @repr("C")
        @align(16)
        @packed
        @deprecated("Use X instead")
    """
    name: text              # Attribute name (e.g., "repr", "align", "packed")
    args: [Expr]            # Attribute arguments (may be empty)
    span: Span

struct Class:
    """Class definition."""
    name: text
    type_params: [TypeParam]
    fields: [Field]
    methods: Dict<text, Function>
    is_public: bool
    doc_comment: text?
    attributes: [Attribute]     # Attributes like @repr, @packed, @align
    span: Span

struct ActorDef:
    """Actor definition - message-based concurrent entity."""
    name: text
    type_params: [TypeParam]
    fields: [Field]
    methods: Dict<text, Function>    # Message handlers
    is_public: bool
    doc_comment: text?
    attributes: [Attribute]
    span: Span

struct Struct:
    """Struct definition."""
    name: text
    type_params: [TypeParam]
    fields: [Field]
    is_public: bool
    doc_comment: text?
    attributes: [Attribute]     # Attributes like @repr, @packed, @align
    span: Span

struct Field:
    """Struct/class field."""
    name: text
    type_: Type
    default: Expr?
    is_public: bool
    is_volatile: bool          # @volatile field
    fixed_address: i64?        # @ address (memory-mapped)
    span: Span

struct Enum:
    """Enum definition."""
    name: text
    type_params: [TypeParam]
    variants: [Variant]
    is_public: bool
    doc_comment: text?
    span: Span

struct Variant:
    """Enum variant."""
    name: text
    kind: VariantKind
    span: Span

"""Enum variant kind."""
enum VariantKind:
    Unit
    Tuple([Type])
    Struct([Field])

struct Bitfield:
    """Bitfield definition.

    Example:
        bitfield Flags(u32):
            enabled: bool       # 1 bit
            priority: u4        # 4 bits
            _reserved: 27       # 27 reserved bits
    """
    name: text
    backing_type: Type          # e.g., u32, u64
    fields: [BitfieldField]
    is_public: bool
    doc_comment: text?
    attributes: [Attribute]
    span: Span

struct BitfieldField:
    """Bitfield field."""
    name: text
    type_: Type?               # nil for reserved fields
    bits: i64?                 # Explicit bit count
    is_reserved: bool          # True if _reserved field
    span: Span

struct Trait:
    """Trait definition.

    Example:
        trait Display:
            fn to_string() -> text

        trait Ord: Eq:  # Supertrait
            fn cmp(Self) -> Ordering
            fn max(Self) -> Self:  # Default implementation
                if self.cmp(other) == Greater: self else: other
    """
    name: text
    type_params: [TypeParam]
    super_traits: [Type]         # Trait: Supertrait bounds (e.g., trait Ord: Eq)
    where_clause: [TraitBound]   # Where clauses on the trait
    methods: [Function]          # Both abstract and default method implementations
    is_public: bool
    doc_comment: text?
    span: Span

struct Impl:
    """Impl block.

    Examples:
        # Inherent impl (no trait)
        impl Point:
            fn new(i64, i64) -> Point: ...

        # Trait impl
        impl Display for Point:
            fn to_string() -> text: ...

        # Generic impl with where clause
        impl<T> Display for Vec<T> where T: Display:
            fn to_string() -> text: ...
    """
    type_: Type                 # Type being implemented for
    trait_: Type?               # Trait being implemented (nil for inherent impl)
    type_params: [TypeParam]    # Generic parameters (impl<T>)
    where_clause: [TraitBound]  # Where T: Trait constraints
    methods: Dict<text, Function>
    span: Span

struct TypeAlias:
    """Type alias."""
    name: text
    type_params: [TypeParam]
    type_: Type
    is_public: bool
    span: Span

struct Const:
    """Module-level constant."""
    name: text
    type_: Type?
    value: Expr
    is_mutable: bool
    is_public: bool
    is_volatile: bool          # @volatile variable
    fixed_address: i64?        # @ address (memory-mapped)
    span: Span

struct StaticAssert:
    """Static assertion - evaluated at compile time.

    Example:
        static assert size_of<u32>() == 4
        static assert align_of<Point>() >= 4, "Point must be 4-byte aligned"
    """
    condition: Expr             # Condition expression (must evaluate to bool at compile time)
    message: text?              # Optional error message on failure
    span: Span

# ============================================================================
# Type AST
# ============================================================================

struct Type:
    """Type expression."""
    kind: TypeKind
    span: Span

"""Type expression kind."""
enum TypeKind:
    Named(text, [Type])
    Tuple([Type])
    Array(Type, Expr?)
    Function([Type], Type)
    Optional(Type)
    Reference(Type, bool)
    Atomic(Type)                # @T (Arc - atomic ref-counted)
    Isolated(Type)              # ~T (iso - isolated capability)
    Infer
    Error

# ============================================================================
# Tensor Suffix
# ============================================================================

"""Data type for tensors."""
enum DType:
    F16
    F32
    F64
    BF16
    I8
    I16
    I32
    I64
    U8
    U16
    U32
    U64

"""Device for tensor computation."""
enum Device:
    CPU
    CUDA(i32)   # CUDA device (0=1st GPU, 1=2nd GPU, etc.)

"""Tensor backend."""
enum Backend:
    Native
    PyTorch

struct TensorSuffix:
    """Suffix for array/tensor literals specifying dtype, device, etc.

    Examples:
    - f32        -> dtype=F32
    - _f32_gpu   -> dtype=F32, device=CUDA(0)  (gpu = default GPU)
    - f32_tr_cuda -> dtype=F32, trainable=true, device=CUDA(0)
    """
    dtype: DType?
    device: Device?
    trainable: bool
    pinned: bool
    backend: Backend?
    raw: text       # Original suffix string

impl TensorSuffix:
    static fn from_string(text) -> TensorSuffix:
        """Parse a suffix string into TensorSuffix."""
        var suffix = TensorSuffix(nil, nil, false, false, nil, s)

        # Split by underscore and parse each part
        var parts = s.split("_")
        for part in parts:
            if part == "":
                continue

            # Check dtype
            match part:
                case "f16": suffix.dtype = Some(DType.F16)
                case "f32": suffix.dtype = Some(DType.F32)
                case "f64": suffix.dtype = Some(DType.F64)
                case "bf16": suffix.dtype = Some(DType.BF16)
                case "i8": suffix.dtype = Some(DType.I8)
                case "i16": suffix.dtype = Some(DType.I16)
                case "i32": suffix.dtype = Some(DType.I32)
                case "i64": suffix.dtype = Some(DType.I64)
                case "u8": suffix.dtype = Some(DType.U8)
                case "u16": suffix.dtype = Some(DType.U16)
                case "u32": suffix.dtype = Some(DType.U32)
                case "u64": suffix.dtype = Some(DType.U64)
                # Check device
                case "cpu": suffix.device = Some(Device.CPU)
                case "gpu": suffix.device = Some(Device.CUDA(0))  # gpu = default GPU (1st GPU)
                case "cuda": suffix.device = Some(Device.CUDA(0))
                case "cuda0": suffix.device = Some(Device.CUDA(0))
                case "cuda1": suffix.device = Some(Device.CUDA(1))
                case "cuda2": suffix.device = Some(Device.CUDA(2))
                case "cuda3": suffix.device = Some(Device.CUDA(3))
                # Check modifiers
                case "tr": suffix.trainable = true
                case "pin": suffix.pinned = true
                # Check backend
                case "native": suffix.backend = Some(Backend.Native)
                case "torch": suffix.backend = Some(Backend.PyTorch)
                case _:
                    # Unknown part - could be cudaN for N > 3
                    if part.starts_with("cuda"):
                        val id_str = part[4:]
                        if id_str.len() > 0:
                            # Parse the numeric ID
                            val id = parse_int_literal(id_str)
                            suffix.device = Some(Device.CUDA(id as i32))

        suffix

# ============================================================================
# Expression AST
# ============================================================================

struct Expr:
    """Expression."""
    kind: ExprKind
    span: Span

"""Expression kind."""
enum ExprKind:
    # Literals
    IntLit(i64)
    FloatLit(f64)
    StringLit(text, [Interpolation]?)
    BoolLit(bool)
    NilLit
    ArrayLit([Expr])
    TupleLit([Expr])
    DictLit([(Expr, Expr)])
    SetLit([Expr])              # Set literal: s{1, 2, 3}

    # Identifiers and access
    Ident(text)
    Field(Expr, text)
    Index(Expr, Expr)
    OptionalChain(Expr, text)  # ?.
    NullCoalesce(Expr, Expr)    # ??
    ExistsCheck(Expr)                   # .?

    # Operators
    Binary(BinOp, Expr, Expr)
    Unary(UnaryOp, Expr)
    Range(Expr?, Expr?, bool, Expr?)

    # Function calls
    Call(Expr, [CallArg])
    MethodCall(Expr, text, [CallArg])

    # Control flow expressions
    If(Expr, Block, Block?)
    MatchCase(Expr, [MatchArm])
    Try(Expr)                           # expr?
    TryCatch(Block, [CatchClause], Block?)

    # Closures
    Lambda([LambdaParam], Expr)
    Block(Block)

    # Comprehensions
    ListComprehension(Expr, [ComprehensionClause])
    DictComprehension(Expr, Expr, [ComprehensionClause])

    # Special
    Await(Expr)
    Spawn(Expr)                     # spawn expr - actor creation
    Yield(Expr?)
    Return(Expr?)
    Break(text?)
    Continue(text?)
    Throw(Expr)

    # Object construction
    StructLit(text, [(text, Expr)])
    EnumLit(text, text, EnumPayload?)

    # Math/DL blocks
    LossBlock(Block)            # loss{ ... } - enables autograd, auto-backward
    NogradBlock(Block)          # nograd{ ... } - disables gradient tracking

    # Unsafe block - allows raw pointer ops, FFI, inline assembly
    UnsafeBlock(Block)          # unsafe: ... - unsafe operations

    # Inline assembly - must be within unsafe block
    AsmBlock(AsmExpr)            # asm "mov eax, ebx" or asm volatile(...)

    # Generic custom block (user-defined blocks like sh{}, sql{}, re{})
    CustomBlock(text, BlockValue)

    # Tensor literals with suffix
    ArrayLitSuffix([Expr], TensorSuffix)

    # GPU kernel launch: kernel<<<grid, block>>>(args)
    KernelLaunch(Expr, Expr, Expr, [CallArg])

    # GPU intrinsic functions
    GpuIntrinsic(GpuIntrinsicKind, [Expr])

    # Error recovery
    Error

"""GPU intrinsic function kinds."""
enum GpuIntrinsicKind:
    # Thread ID accessors
    GlobalId(i64)      # gpu_global_id(dim)
    LocalId(i64)       # gpu_local_id(dim)
    BlockId(i64)       # gpu_block_id(dim)
    BlockDim(i64)      # gpu_block_dim(dim)
    GridDim(i64)       # gpu_grid_dim(dim)

    # Synchronization
    Sync                    # gpu_sync()
    Barrier                 # gpu_barrier()
    MemFence                # gpu_mem_fence()

    # Atomic operations
    AtomicAdd               # gpu_atomic_add(ptr, val)
    AtomicSub               # gpu_atomic_sub(ptr, val)
    AtomicMin               # gpu_atomic_min(ptr, val)
    AtomicMax               # gpu_atomic_max(ptr, val)
    AtomicAnd               # gpu_atomic_and(ptr, val)
    AtomicOr                # gpu_atomic_or(ptr, val)
    AtomicXor               # gpu_atomic_xor(ptr, val)
    AtomicExchange          # gpu_atomic_exchange(ptr, val)
    AtomicCas               # gpu_atomic_cas(ptr, expected, desired)

struct Interpolation:
    """String interpolation."""
    expr: Expr
    format: text?
    span: Span

struct CallArg:
    """Function call argument."""
    name: text?     # Named argument
    value: Expr
    span: Span

struct MatchArm:
    """Match arm."""
    pattern: Pattern
    guard: Expr?
    body: Block
    span: Span

struct CatchClause:
    """Catch clause in try-catch."""
    pattern: Pattern?
    type_: Type?
    body: Block
    span: Span

struct LambdaParam:
    """Lambda parameter."""
    name: text
    type_: Type?
    span: Span

struct ComprehensionClause:
    """Comprehension clause."""
    kind: ComprehensionKind
    span: Span

enum ComprehensionKind:
    For(text, Expr)
    If(Expr)

enum EnumPayload:
    Tuple([Expr])
    Struct([(text, Expr)])

# ============================================================================
# Pattern AST
# ============================================================================

struct Pattern:
    """Pattern for matching."""
    kind: PatternKind
    span: Span

"""Pattern kind."""
enum PatternKind:
    Wildcard                                  # _
    Literal(Expr)                      # 42, "hello", true
    Binding(text, bool)        # x, var x
    Tuple([Pattern])                # (a, b, c)
    Array([Pattern], text?)   # [a, b, ..rest]
    Struct(text, [(text, Pattern)]) # Point { x, y }
    Enum(text, text, EnumPatternPayload?)
    Or([Pattern])                   # a | b | c
    Guard(Pattern, Expr)      # p if cond
    As(Pattern, text)          # p as name
    Range(Expr?, Expr?, bool) # 1..10, 1..=10
    Error

enum EnumPatternPayload:
    Tuple([Pattern])
    Struct([(text, Pattern)])

# ============================================================================
# Statement AST
# ============================================================================

struct Stmt:
    """Statement."""
    kind: StmtKind
    span: Span

"""Statement kind."""
enum StmtKind:
    Expr(Expr)
    Val(text, Type?, Expr)
    Var(text, Type?, Expr?)
    SharedVal(text, Type, Expr?)    # GPU shared memory (immutable)
    SharedVar(text, Type, Expr?)    # GPU shared memory (mutable)
    Assign(Expr, AssignOp?, Expr)
    For(text, Expr, Block)
    While(Expr, Block)
    Loop(Block)
    Break(text?)
    Continue(text?)
    Return(Expr?)
    Yield(Expr?)
    Throw(Expr)
    With([WithItem], Block)         # with statement - context managers

"""Assignment operator."""
enum AssignOp:
    Add     # +=
    Sub     # -=
    Mul     # *=
    Div     # /=
    Mod     # %=

struct Block:
    """Block of statements."""
    stmts: [Stmt]
    span: Span

struct WithItem:
    """Context manager item in with statement."""
    context_expr: Expr      # Expression that produces context manager
    target: text?           # Optional variable binding (the "as" part)
    span: Span

# ============================================================================
# Operators
# ============================================================================

"""Binary operator."""
enum BinOp:
    # Arithmetic
    Add, Sub, Mul, Div, Mod, Pow

    # Matrix operations
    MatMul              # @

    # Comparison
    Eq, NotEq, Lt, LtEq, Gt, GtEq

    # Logical
    And, Or

    # Bitwise
    BitAnd, BitOr, BitXor, Shl, Shr

    # Broadcast operations (dotted operators)
    BroadcastAdd        # .+
    BroadcastSub        # .-
    BroadcastMul        # .*
    BroadcastDiv        # ./
    BroadcastPow        # .^

    # Pipeline/Composition operators
    PipeForward         # |>
    Compose             # >>
    ComposeBack         # <<
    Parallel            # //
    LayerConnect        # ~>

    # Other
    In, NotIn, Is, IsNot

"""Unary operator."""
enum UnaryOp:
    Neg         # -
    Not         # not, !
    BitNot      # ~
    Ref         # &
    Deref       # *
    Transpose   # ' (postfix, m{} only)

# ============================================================================
# Inline Assembly
# ============================================================================

struct AsmExpr:
    """Inline assembly expression.

    Supports two syntaxes:
    1. Simple: asm "mov eax, ebx"
    2. Full: asm volatile("mov r0, {op}", op = in(reg) value, clobber_abi("C"))
    """
    asm_template: text              # Assembly asm_template string
    is_volatile: bool           # volatile flag (prevent optimization)
    constraints: [AsmConstraint]  # Register/memory constraints
    clobbers: [text]            # Clobbered registers
    span: Span

struct AsmConstraint:
    """Assembly operand constraint.

    Examples:
    - op = in(reg) value        # Input register
    - result = out(reg) var     # Output register
    - ptr = inout(reg) addr     # Input/output register
    """
    name: text                  # Operand name (e.g., "op", "result")
    kind: AsmConstraintKind     # in, out, inout
    location: AsmLocation       # reg, mem, etc.
    value: Expr                 # Expression for operand
    span: Span

enum AsmConstraintKind:
    In          # Input operand
    Out         # Output operand
    InOut       # Input/output operand
    LateOut     # Late output (clobbers after inputs read)

enum AsmLocation:
    Reg         # General register
    RegSpec(text)  # Specific register (e.g., "eax", "r0")
    Mem         # Memory location
    Imm         # Immediate value

# ============================================================================
# Parser
# ============================================================================

struct Parser:
    """Full AST parser using TreeSitter outline."""
    source: text
    lexer: Lexer
    current: Token
    previous: Token
    errors: [ParseError]
    outline: OutlineModule?
    resolved_blocks: ResolvedModule?  # Pre-resolved blocks from BlockResolver


# ============================================================================
# Exports
# ============================================================================

fn parse_float_literal(text) -> f64:
    """Parse float literal."""
    # Split on decimal point
    val parts = text.split(".")
    if parts.len() == 2:
        val integer_part = parse_float_int_part(parts[0])
        val frac_text = parts[1]
        # Handle exponent in fractional part
        val exp_parts = split_exponent(frac_text)
        val frac_val = parse_fractional(exp_parts[0])
        val exponent = if exp_parts.len() > 1:
            parse_float_int_part(exp_parts[1])
        else:
            0.0
        val base_val = integer_part + frac_val
        if exponent != 0.0:
            base_val * pow10(exponent)
        else:
            base_val
    else:
        # No decimal point - may have exponent
        val exp_parts = split_exponent(text)
        val base_val = parse_float_int_part(exp_parts[0])
        if exp_parts.len() > 1:
            val exponent = parse_float_int_part(exp_parts[1])
            base_val * pow10(exponent)
        else:
            base_val

fn parse_float_int_part(s: text) -> f64:
    """Parse integer part of a float as f64."""
    var result: f64 = 0.0
    var negative = false
    var start = 0
    if s.len() > 0 and s[0] == "-":
        negative = true
        start = 1
    elif s.len() > 0 and s[0] == "+":
        start = 1
    var i = start
    while i < s.len():
        val ch = s[i]
        if ch != "_":
            val code = ch.ord()
            if code >= 48 and code <= 57:
                result = result * 10.0 + (code - 48) as f64
        i = i + 1
    if negative:
        -result
    else:
        result

fn parse_fractional(s: text) -> f64:
    """Parse fractional part (digits after decimal point)."""
    var result: f64 = 0.0
    var divisor: f64 = 10.0
    for ch in s:
        if ch != "_":
            val code = ch.ord()
            if code >= 48 and code <= 57:
                result = result + (code - 48) as f64 / divisor
                divisor = divisor * 10.0
    result

fn split_exponent(s: text) -> [text]:
    """Split string on 'e' or 'E' for scientific notation."""
    if s.contains("e"):
        s.split("e")
    elif s.contains("E"):
        s.split("E")
    else:
        [s]

fn pow10(exp: f64) -> f64:
    """Compute 10^exp for integer exponents."""
    var result: f64 = 1.0
    var n = exp
    if n < 0.0:
        n = -n
        var i: f64 = 0.0
        while i < n:
            result = result * 10.0
            i = i + 1.0
        1.0 / result
    else:
        var i: f64 = 0.0
        while i < n:
            result = result * 10.0
            i = i + 1.0
        result

# ============================================================================
# Exports
# ============================================================================

export Module, Import, ImportItem, Export
export Function, Param, TypeParam, TraitBound, Class, Struct, Field, Attribute
export Enum, Variant, VariantKind, Bitfield, BitfieldField
export Trait, Impl, TypeAlias, Const, StaticAssert
export Type, TypeKind
export Expr, ExprKind, Interpolation, CallArg, MatchArm, CatchClause
export LambdaParam, ComprehensionClause, ComprehensionKind, EnumPayload
export Pattern, PatternKind, EnumPatternPayload
export Stmt, StmtKind, AssignOp, Block
export BinOp, UnaryOp
export Parser
export DType, Device, Backend, TensorSuffix
export GpuIntrinsicKind
export AsmExpr, AsmConstraint, AsmConstraintKind, AsmLocation
