# Type Inference Serialization
#
# Serialize/deserialize inference hints to/from SDN format
# for the SMF note.sdn section (InferenceHints, type 14).

use compiler.inference.types.*
use compiler.inference.infer (DeferredHint)

# ============================================================================
# SDN Serialization
# ============================================================================

fn hints_to_sdn(hints: [DeferredHint]) -> text:
    """Serialize deferred hints to SDN table format.

    Output format:
    ```sdn
    inference_hints |var_id, source_module, fallback, constraints|
        0, "module_a", "i64", "Eq(t0, i64)"
        1, "module_b", "", "Callable([i32], bool)"
    ```
    """
    var lines: [text] = []
    lines = lines.push("inference_hints |var_id, source_module, fallback, constraints|")

    for hint in hints:
        val var_id = "{hint.type_var.id}"
        val source = "\"{hint.source_module}\""
        val fallback = if hint.fallback.?:
            "\"{type_to_text(hint.fallback.unwrap())}\""
        else:
            "\"\""
        val constraints = "\"{constraints_to_text(hint.constraints)}\""
        lines = lines.push("    {var_id}, {source}, {fallback}, {constraints}")

    lines.join("\n")

fn hints_from_sdn(content: text) -> [DeferredHint]:
    """Deserialize deferred hints from SDN table format."""
    var hints: [DeferredHint] = []

    var in_table = false
    for line in content.split("\n"):
        val trimmed = line.trim()
        if trimmed.starts_with("inference_hints"):
            in_table = true
            continue
        if not in_table:
            continue
        if trimmed.is_empty() or not trimmed[0].is_digit():
            # End of table data rows
            if in_table and trimmed.? and not trimmed.starts_with(" "):
                in_table = false
            continue

        val parts = trimmed.split(",")
        if parts.len() >= 4:
            val var_id = parts[0].trim().parse_int() ?? 0
            val source = parts[1].trim().trim_quotes()
            val fallback_str = parts[2].trim().trim_quotes()
            val fallback = if fallback_str.?:
                type_from_text(fallback_str)
            else:
                nil

            # Parse constraints from remaining CSV fields
            var parsed_constraints: [text] = []
            var ci = 3
            while ci < parts.len():
                val constraint_str = parts[ci].trim().trim_quotes()
                if constraint_str != "" and constraint_str != "nil":
                    parsed_constraints.push(constraint_str)
                ci = ci + 1

            hints = hints.push(DeferredHint(
                type_var: TypeVarId(id: var_id),
                constraints: parsed_constraints,
                source_module: source,
                fallback: fallback
            ))

    hints

# ============================================================================
# Type <-> Text Helpers
# ============================================================================

fn type_to_text(ty: Type) -> text:
    """Convert a type to its text representation."""
    match ty:
        case Int(bits, signed):
            if signed: "i{bits}" else: "u{bits}"
        case Float(bits): "f{bits}"
        case Bool: "bool"
        case Str: "text"
        case Nil: "nil"
        case Unit: "()"
        case Var(id): "t{id.id}"
        case Function(params, ret):
            val param_strs = params.map(\p: type_to_text(p))
            "fn({param_strs.join(\", \")}) -> {type_to_text(ret)}"
        case Array(elem, size):
            if size.?:
                "[{type_to_text(elem)}; {size.unwrap()}]"
            else:
                "[{type_to_text(elem)}]"
        case Optional(inner): "{type_to_text(inner)}?"
        case Generic(name, args):
            val arg_strs = args.map(\a: type_to_text(a))
            "{name}<{arg_strs.join(\", \")}>"
        case _: "unknown"

fn type_from_text(s: text) -> Type?:
    """Parse a simple type from text. Handles primitives and basic types."""
    match s:
        case "i8": Some(Type.Int(bits: 8, signed: true))
        case "i16": Some(Type.Int(bits: 16, signed: true))
        case "i32": Some(Type.Int(bits: 32, signed: true))
        case "i64": Some(Type.Int(bits: 64, signed: true))
        case "u8": Some(Type.Int(bits: 8, signed: false))
        case "u16": Some(Type.Int(bits: 16, signed: false))
        case "u32": Some(Type.Int(bits: 32, signed: false))
        case "u64": Some(Type.Int(bits: 64, signed: false))
        case "f32": Some(Type.Float(bits: 32))
        case "f64": Some(Type.Float(bits: 64))
        case "bool": Some(Type.Bool)
        case "text" | "string": Some(Type.Str)
        case "nil": Some(Type.Nil)
        case "()" | "unit": Some(Type.Unit)
        case _: nil

fn constraints_to_text(constraints: [Constraint]) -> text:
    """Serialize constraints to text."""
    val parts = constraints.map(\c:
        match c:
            case Eq(t1, t2): "Eq({type_to_text(t1)}, {type_to_text(t2)})"
            case HasField(name, ty): "HasField({name}, {type_to_text(ty)})"
            case Callable(params, ret):
                val p = params.map(\p: type_to_text(p))
                "Callable([{p.join(\", \")}], {type_to_text(ret)})"
            case Subtype(sub, super_):
                "Subtype({type_to_text(sub)}, {type_to_text(super_)})"
    )
    parts.join("; ")

# Helper for stripping quotes from SDN values
fn trim_quotes(s: text) -> text:
    if s.len() >= 2 and s.starts_with("\"") and s.ends_with("\""):
        s[1:s.len() - 1]
    else:
        s

export hints_to_sdn, hints_from_sdn
export type_to_text, type_from_text, constraints_to_text
