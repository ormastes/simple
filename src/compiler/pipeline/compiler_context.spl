# Compiler Compilation Context
#
# CompilationContext implementation for normal (AOT) compilation.
# Templates come from the parsed AST cache.

use ../compilation_context.{CompilationContext, InstantiationMode, ContractMode, GenericTemplate, ConcreteType, TypeRegistry}
use ../backend_types.CompiledUnit
use ../di.DiContainer
use ../aop.AopWeaver
use ../pipeline_fn.compile_specialized_template
use ../monomorphize/note_sdn.InstantiationEntry

# ============================================================================
# CompilerCompilationContext
# ============================================================================

class CompilerCompilationContext(CompilationContext):
    """Compiler uses parsed AST cache for templates."""
    ast_cache: Dict<text, GenericTemplate>
    type_reg: TypeRegistry
    di: DiContainer?
    aop: AopWeaver?
    contracts: ContractMode
    coverage: bool
    recorded: [InstantiationEntry]

    fn load_template(name: text) -> Result<GenericTemplate, text>:
        if self.ast_cache.contains_key(name):
            Ok(self.ast_cache[name])
        else:
            Err("Template not found: {name}")

    fn has_template(name: text) -> bool:
        self.ast_cache.contains_key(name)

    fn type_registry() -> TypeRegistry:
        self.type_reg

    fn contract_mode() -> ContractMode:
        self.contracts

    fn di_container() -> DiContainer?:
        self.di

    fn aop_weaver() -> AopWeaver?:
        self.aop

    fn coverage_enabled() -> bool:
        self.coverage

    fn compile_template(template: GenericTemplate, type_args: [ConcreteType]) -> Result<CompiledUnit, text>:
        compile_specialized_template(template, type_args, self.contracts, self.di, self.aop, self.coverage)

    fn instantiation_mode() -> InstantiationMode:
        InstantiationMode.CompileTime

    me record_instantiation(entry: InstantiationEntry):
        self.recorded = self.recorded.push(entry)

impl CompilerCompilationContext:
    static fn create(
        ast_cache: Dict<text, GenericTemplate>,
        di: DiContainer?,
        aop: AopWeaver?,
        contracts: ContractMode
    ) -> CompilerCompilationContext:
        CompilerCompilationContext(
            ast_cache: ast_cache,
            type_reg: TypeRegistry.empty(),
            di: di,
            aop: aop,
            contracts: contracts,
            coverage: false,
            recorded: []
        )

# ============================================================================
# Exports
# ============================================================================

export CompilerCompilationContext
