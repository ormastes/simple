# Inline Assembly Support
#
# Provides inline assembly for bare-metal programming.
#
# Syntax:
#   asm:
#       "instruction1"
#       "instruction2"
#       options: [volatile, noreturn]
#       in(reg) variable
#       out(reg) variable
#       clobbers: ["reg1", "reg2"]
#
# Examples:
#   # Simple assembly
#   asm:
#       "nop"
#
#   # With inputs/outputs
#   asm:
#       "add {0}, {1}"
#       out(eax) result
#       in(ebx) a
#       in(ecx) b
#
#   # Volatile (side effects)
#   asm:
#       "cli"           # Disable interrupts
#       options: [volatile]

use compiler.hir_definitions.{HirExpr, HirExprKind, HirStmt}
use compiler.core.lexer.Span
use std.common.target.{TargetArch}

# ===========================================================================
# Inline Assembly AST
# ===========================================================================

class InlineAsm:
    """Inline assembly block."""
    template: [text]            # Assembly template strings
    operands: [AsmOperand]      # Input/output operands
    clobbers: [text]            # Clobbered registers
    options: [AsmOption]        # Assembly options
    arch: TargetArch            # Target architecture
    span: Span

impl InlineAsm:
    static fn new(template: [text], span: Span) -> InlineAsm:
        InlineAsm(
            template: template,
            operands: [],
            clobbers: [],
            options: [],
            arch: TargetArch.host(),
            span: span
        )

    fn add_operand(operand: AsmOperand):
        me.operands.push(operand)

    fn add_clobber(reg: text):
        me.clobbers.push(reg)

    fn add_option(option: AsmOption):
        me.options.push(option)

    fn is_volatile() -> bool:
        self.options.contains(AsmOption.Volatile)

    fn is_noreturn() -> bool:
        self.options.contains(AsmOption.NoReturn)

    fn is_pure() -> bool:
        self.options.contains(AsmOption.Pure)

# ===========================================================================
# Assembly Operands
# ===========================================================================

enum AsmOperand:
    """Assembly operand (input/output)."""
    Input(reg: AsmRegister, expr: HirExpr)      # in(reg) expr
    Output(reg: AsmRegister, var_name: text)    # out(reg) var
    InOut(reg: AsmRegister, expr: HirExpr)      # inout(reg) expr

impl AsmOperand:
    fn register() -> AsmRegister:
        match self:
            case AsmOperand.Input(reg, _): reg
            case AsmOperand.Output(reg, _): reg
            case AsmOperand.InOut(reg, _): reg

    fn is_input() -> bool:
        match self:
            case AsmOperand.Input(_, _): true
            case _: false

    fn is_output() -> bool:
        match self:
            case AsmOperand.Output(_, _): true
            case _: false

# ===========================================================================
# Registers
# ===========================================================================

enum AsmRegister:
    """Assembly register specification."""
    # x86/x86_64 registers
    Rax | Rbx | Rcx | Rdx | Rsi | Rdi | Rbp | Rsp
    R8 | R9 | R10 | R11 | R12 | R13 | R14 | R15
    Eax | Ebx | Ecx | Edx | Esi | Edi | Ebp | Esp
    Al | Bl | Cl | Dl

    # ARM registers
    R0 | R1 | R2 | R3 | R4 | R5 | R6 | R7
    R8_arm | R9_arm | R10_arm | R11_arm | R12_arm | R13_arm | R14_arm | R15_arm
    Sp | Lr | Pc

    # RISC-V registers
    X0 | X1 | X2 | X3 | X4 | X5 | X6 | X7
    X8 | X9 | X10 | X11 | X12 | X13 | X14 | X15
    X16 | X17 | X18 | X19 | X20 | X21 | X22 | X23
    X24 | X25 | X26 | X27 | X28 | X29 | X30 | X31

    # Special: let compiler choose
    Any

impl AsmRegister:
    fn to_string() -> text:
        match self:
            # x86_64
            case AsmRegister.Rax: "rax"
            case AsmRegister.Rbx: "rbx"
            case AsmRegister.Rcx: "rcx"
            case AsmRegister.Rdx: "rdx"
            case AsmRegister.Rsi: "rsi"
            case AsmRegister.Rdi: "rdi"
            case AsmRegister.Rbp: "rbp"
            case AsmRegister.Rsp: "rsp"

            # x86 32-bit
            case AsmRegister.Eax: "eax"
            case AsmRegister.Ebx: "ebx"
            case AsmRegister.Ecx: "ecx"
            case AsmRegister.Edx: "edx"

            # ARM
            case AsmRegister.R0: "r0"
            case AsmRegister.R1: "r1"
            case AsmRegister.Sp: "sp"
            case AsmRegister.Lr: "lr"
            case AsmRegister.Pc: "pc"

            # RISC-V
            case AsmRegister.X0: "x0"
            case AsmRegister.X1: "x1"
            case AsmRegister.X2: "x2"

            # Special
            case AsmRegister.Any: "any"

            case _: "unknown"

    fn is_valid_for_arch(arch: TargetArch) -> bool:
        match (arch, self):
            # x86/x86_64 registers valid for X86 architectures
            case (TargetArch.X86, AsmRegister.Eax | AsmRegister.Ebx | AsmRegister.Ecx | AsmRegister.Edx):
                true
            case (TargetArch.X86_64, AsmRegister.Rax | AsmRegister.Rbx | AsmRegister.Rcx | AsmRegister.Rdx):
                true

            # ARM registers valid for ARM
            case (TargetArch.ARM, AsmRegister.R0 | AsmRegister.R1 | AsmRegister.Sp):
                true

            # RISC-V registers valid for RISC-V
            case (TargetArch.RiscV32 | TargetArch.RiscV64, AsmRegister.X0 | AsmRegister.X1):
                true

            # Any is valid for all
            case (_, AsmRegister.Any):
                true

            case _:
                false

# ===========================================================================
# Assembly Options
# ===========================================================================

enum AsmOption:
    """Assembly block options."""
    Volatile        # Has side effects (don't optimize away)
    NoReturn        # Never returns (e.g., infinite loop)
    Pure            # No side effects (can be optimized)
    NoStack         # Doesn't use stack

impl AsmOption:
    fn to_string() -> text:
        match self:
            case AsmOption.Volatile: "volatile"
            case AsmOption.NoReturn: "noreturn"
            case AsmOption.Pure: "pure"
            case AsmOption.NoStack: "nostack"

# ===========================================================================
# Assembly Template
# ===========================================================================

class AsmTemplate:
    """Parsed assembly template."""
    parts: [AsmTemplatePart]

enum AsmTemplatePart:
    """Part of assembly template."""
    Text(s: text)               # Literal assembly text
    Operand(index: i32)         # Operand reference {0}, {1}, etc.
    Register(reg: text)         # Named register {rax}, {r0}, etc.

impl AsmTemplate:
    static fn parse(template: text) -> AsmTemplate:
        var parts: [AsmTemplatePart] = []
        var current = ""
        var i = 0

        while i < template.len():
            if template[i] == '{':
                # Save accumulated text
                if current.len() > 0:
                    parts.push(AsmTemplatePart.Text(current))
                    current = ""

                # Parse placeholder
                i = i + 1
                var placeholder = ""
                while i < template.len() and template[i] != '}':
                    placeholder = placeholder + template[i]
                    i = i + 1

                # Check if numeric (operand index) or name (register)
                if placeholder.is_numeric():
                    val index = parse_i32(placeholder)
                    parts.push(AsmTemplatePart.Operand(index))
                else:
                    parts.push(AsmTemplatePart.Register(placeholder))

                i = i + 1  # Skip '}'
            else:
                current = current + template[i]
                i = i + 1

        # Add remaining text
        if current.len() > 0:
            parts.push(AsmTemplatePart.Text(current))

        AsmTemplate(parts: parts)

    fn substitute(operands: [text]) -> text:
        var result = ""

        for part in self.parts:
            match part:
                case AsmTemplatePart.Text(s):
                    result = result + s

                case AsmTemplatePart.Operand(index):
                    if index >= 0 and index < operands.len():
                        result = result + operands[index]
                    else:
                        result = result + "{invalid}"

                case AsmTemplatePart.Register(reg):
                    result = result + reg

        result

# ===========================================================================
# Code Generation
# ===========================================================================

class AsmCodegen:
    """Assembly code generator."""
    arch: TargetArch

impl AsmCodegen:
    static fn new(arch: TargetArch) -> AsmCodegen:
        AsmCodegen(arch: arch)

    fn generate(asm: InlineAsm) -> text:
        # Validate architecture compatibility
        for operand in asm.operands:
            val reg = operand.register()
            if not reg.is_valid_for_arch(self.arch):
                # Error: invalid register for architecture
                pass

        # Generate assembly code
        var code = ""

        # Add directives
        if asm.is_volatile():
            code = code + "  # volatile\n"

        # Process each template line
        for template_line in asm.template:
            val template = AsmTemplate.parse(template_line)

            # Build operand strings
            var operand_strs: [text] = []
            for operand in asm.operands:
                val reg_str = operand.register().to_string()
                operand_strs.push(reg_str)

            # Substitute and add
            val line = template.substitute(operand_strs)
            code = code + "  {line}\n"

        code

# ===========================================================================
# Helper Functions
# ===========================================================================

fn parse_i32(s: text) -> i32:
    var result: i32 = 0
    for c in s:
        if c >= '0' and c <= '9':
            result = result * 10 + (c.to_i32() - 48)
    result

fn is_numeric(s: text) -> bool:
    if s.len() == 0:
        return false
    for c in s:
        if c < '0' or c > '9':
            return false
    true

# ===========================================================================
# Exports
# ===========================================================================

export InlineAsm, AsmOperand, AsmRegister, AsmOption
export AsmTemplate, AsmTemplatePart
export AsmCodegen
