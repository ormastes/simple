# Weaving Types
#
# Type definitions for AOP (Aspect-Oriented Programming) weaving.
#
# Port of rust/compiler/src/weaving/types.rs (231 lines)

export AdviceForm, JoinPointKind, JoinPoint, JoinPointContext
export MatchedAdvice, WeavingConfig, WeavingRule, WeavingResult

use mir (BlockId)
use predicate (MatchContext)
use aop_config (AopConfig)
use hir (HirAopAdvice)
use weaving.diagnostics (WeavingDiagnostic, DiagnosticLevel)

# ============================================================================
# Advice Form
# ============================================================================

enum AdviceForm:
    """Advice form determines when and how advice is executed."""
    Before          # Execute before the join point
    AfterSuccess    # Execute after successful completion
    AfterError      # Execute after error
    Around          # Wrap the join point (can control execution via proceed)

impl AdviceForm:
    static fn from_str(s: text) -> AdviceForm?:
        """Parse string to AdviceForm (case-insensitive)."""
        match s.to_lowercase():
            case "before": Some(AdviceForm.Before)
            case "after_success": Some(AdviceForm.AfterSuccess)
            case "after-success": Some(AdviceForm.AfterSuccess)
            case "after_error": Some(AdviceForm.AfterError)
            case "after-error": Some(AdviceForm.AfterError)
            case "around": Some(AdviceForm.Around)
            case _: nil

# ============================================================================
# Join Point Types
# ============================================================================

enum JoinPointKind:
    """Join point types in the program."""
    Execution(function_name: text, signature: text)  # Function execution
    Decision(location: text)                          # Decision point (if/match)
    Condition(location: text)                         # Condition evaluation
    Error(location: text, error_type: text)          # Error handling point

struct JoinPoint:
    """A detected join point in the MIR."""
    kind: JoinPointKind
    block_id: BlockId
    instruction_index: usize
    context: JoinPointContext

struct JoinPointContext:
    """Context information for join point matching."""
    function_name: text
    module_path: text
    signature: text
    attributes: [text]
    effects: [text]

impl JoinPointContext:
    fn to_match_context() -> MatchContext:
        """Create a match context for predicate evaluation.

        Uses builder pattern to construct context.
        """
        MatchContext.new()
            .with_type_name(self.function_name)
            .with_module_path(self.module_path)
            .with_signature(self.signature)
            .with_attrs(self.attributes)
            .with_effects(self.effects)

# ============================================================================
# Matched Advice
# ============================================================================

struct MatchedAdvice:
    """Matched advice for a join point."""
    advice_function: text
    form: AdviceForm
    priority: i64
    specificity: i32

# ============================================================================
# Weaving Configuration
# ============================================================================

struct WeavingRule:
    """A single weaving rule (predicate + advice)."""
    predicate_text: text
    advice_function: text
    form: AdviceForm
    priority: i64

struct WeavingConfig:
    """Weaving configuration loaded from TOML."""
    enabled: bool
    before_advices: [WeavingRule]
    after_success_advices: [WeavingRule]
    after_error_advices: [WeavingRule]
    around_advices: [WeavingRule]

impl WeavingConfig:
    static fn disabled() -> WeavingConfig:
        """Create an empty configuration (weaving disabled)."""
        WeavingConfig(
            enabled: false,
            before_advices: [],
            after_success_advices: [],
            after_error_advices: [],
            around_advices: []
        )

    static fn from_aop_config(aop_config: AopConfig) -> WeavingConfig:
        """Load from AOP configuration.

        For now, treat runtime around as compile-time around.
        In the future, we'll have separate compile-time config.
        """
        val around_advices = aop_config.around.map(\rule:
            WeavingRule(
                predicate_text: rule.raw_predicate.clone(),
                advice_function: rule.advice.clone(),
                form: AdviceForm.Around,
                priority: rule.priority
            )
        )

        WeavingConfig(
            enabled: aop_config.runtime_enabled,
            before_advices: [],
            after_success_advices: [],
            after_error_advices: [],
            around_advices: around_advices
        )

    static fn from_hir_advices(advices: [HirAopAdvice]) -> WeavingConfig:
        """Load from HIR AOP advices (parsed from Simple source code)."""
        var before_advices: [WeavingRule] = []
        var after_success_advices: [WeavingRule] = []
        var after_error_advices: [WeavingRule] = []
        var around_advices: [WeavingRule] = []

        for advice in advices:
            val form = AdviceForm.from_str(advice.form) ?? AdviceForm.Before
            val rule = WeavingRule(
                predicate_text: advice.predicate_text.clone(),
                advice_function: advice.advice_function.clone(),
                form: form,
                priority: advice.priority
            )

            match form:
                case Before: before_advices = before_advices.push(rule)
                case AfterSuccess: after_success_advices = after_success_advices.push(rule)
                case AfterError: after_error_advices = after_error_advices.push(rule)
                case Around: around_advices = around_advices.push(rule)

        WeavingConfig(
            enabled: not advices.is_empty(),
            before_advices: before_advices,
            after_success_advices: after_success_advices,
            after_error_advices: after_error_advices,
            around_advices: around_advices
        )

    fn all_advices() -> [WeavingRule]:
        """Get all advice rules.

        CRITICAL: Returns iterator over all 4 advice lists.
        Order: before, after_success, after_error, around.
        """
        self.before_advices
            .concat(self.after_success_advices)
            .concat(self.after_error_advices)
            .concat(self.around_advices)

# ============================================================================
# Weaving Result
# ============================================================================

struct WeavingResult:
    """Result of weaving a function."""
    join_points_woven: usize        # Number of join points that had advice woven
    advices_inserted: usize         # Total number of advice calls inserted
    advice_calls: [(JoinPointKind, text)]  # List of (join point, advice) pairs for debugging
    diagnostics: [WeavingDiagnostic]       # Diagnostic messages generated during weaving

impl WeavingResult:
    static fn new() -> WeavingResult:
        """Create empty weaving result."""
        WeavingResult(
            join_points_woven: 0,
            advices_inserted: 0,
            advice_calls: [],
            diagnostics: []
        )

    me add_diagnostic(diagnostic: WeavingDiagnostic):
        """Add a diagnostic message."""
        self.diagnostics = self.diagnostics.push(diagnostic)

    fn has_errors() -> bool:
        """Check if there are any errors."""
        self.diagnostics.any(\d: d.level == DiagnosticLevel.Error)

    fn has_warnings() -> bool:
        """Check if there are any warnings."""
        self.diagnostics.any(\d: d.level == DiagnosticLevel.Warning)

    fn errors() -> [WeavingDiagnostic]:
        """Get all errors."""
        self.diagnostics.filter(\d: d.level == DiagnosticLevel.Error)

    fn warnings() -> [WeavingDiagnostic]:
        """Get all warnings."""
        self.diagnostics.filter(\d: d.level == DiagnosticLevel.Warning)
