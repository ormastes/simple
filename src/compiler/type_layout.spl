# Type Layout Computation
#
# Computes memory layout for types including:
# - Size in bytes
# - Alignment requirements
# - Field offsets
# - Padding
#
# Supports layout attributes:
# - @repr("C")   - C-compatible layout
# - @repr("packed") or @packed - No padding between fields
# - @repr("transparent") - Same layout as single field
# - @align(N)    - Minimum alignment (power of 2)
#
# Architecture-aware sizing:
# - usize/isize scale with pointer size (8/16/32/64-bit)
# - Alignment rules vary by architecture
#
# Example:
#   @repr("C")
#   @align(16)
#   struct AlignedData:
#       x: i32
#       y: i32

from hir_types import {HirType, SymbolId}
from hir_definitions import {HirStruct, HirClass, HirField}
from std.common.target import {TargetArch}

export TypeLayout, FieldLayout, LayoutAttr, LayoutKind
export compute_layout, compute_struct_layout, compute_field_offset
export size_of_type, align_of_type
export size_of_type_for_arch, align_of_type_for_arch
export primitive_size_for_arch, primitive_align_for_arch

# Layout kind (from @repr attribute)
enum LayoutKind:
    Simple      # Default Simple language layout (like Rust)
    C           # C ABI compatible layout
    Packed      # No padding (alignment = 1)
    Transparent # Same layout as inner type

impl LayoutKind:
    fn to_text() -> text:
        match self:
            case LayoutKind.Simple: "Simple"
            case LayoutKind.C: "C"
            case LayoutKind.Packed: "packed"
            case LayoutKind.Transparent: "transparent"

# Layout attributes for a type
struct LayoutAttr:
    layout_kind: LayoutKind   # Layout kind
    explicit_align: i64?    # @align(N) value if specified
    is_packed: bool         # @packed shorthand

impl LayoutAttr:
    static fn default_() -> LayoutAttr:
        LayoutAttr(
            layout_kind: LayoutKind.Simple,
            explicit_align: nil,
            is_packed: false
        )

    static fn c_repr() -> LayoutAttr:
        LayoutAttr(
            layout_kind: LayoutKind.C,
            explicit_align: nil,
            is_packed: false
        )

    static fn packed() -> LayoutAttr:
        LayoutAttr(
            layout_kind: LayoutKind.Packed,
            explicit_align: nil,
            is_packed: true
        )

    fn effective_align(natural_align: i64) -> i64:
        """Get effective alignment considering all attributes."""
        if self.is_packed or self.layout_kind == LayoutKind.Packed:
            return 1
        if self.explicit_align.?:
            val explicit = self.explicit_align.unwrap()
            # Explicit alignment must be >= natural alignment
            if explicit > natural_align:
                return explicit
        natural_align

# Single field layout information
struct FieldLayout:
    name: text
    type_: HirType
    offset: i64     # Byte offset from struct start
    size: i64       # Size of field in bytes
    align: i64      # Alignment of field

impl FieldLayout:
    fn end_offset() -> i64:
        self.offset + self.size

# Complete type layout
struct TypeLayout:
    size: i64               # Total size in bytes
    align: i64              # Required alignment
    fields: [FieldLayout]   # Field layouts (for struct/class)
    stride: i64             # Size when used in array (size rounded up to align)

impl TypeLayout:
    fn is_zero_sized() -> bool:
        self.size == 0

    fn padding_bytes() -> i64:
        """Calculate total padding in struct."""
        var field_sizes: i64 = 0
        for field in self.fields:
            field_sizes = field_sizes + field.size
        self.size - field_sizes

# Primitive type sizes (in bytes)
fn primitive_size(type_name: text) -> i64?:
    match type_name:
        case "i8" | "u8" | "bool": Some(1)
        case "i16" | "u16": Some(2)
        case "i32" | "u32" | "f32" | "char": Some(4)
        case "i64" | "u64" | "f64" | "isize" | "usize": Some(8)  # Assuming 64-bit
        case "i128" | "u128": Some(16)
        case "()" | "unit" | "void": Some(0)
        case _: nil

# Primitive type alignment (in bytes)
fn primitive_align(type_name: text) -> i64?:
    match type_name:
        case "i8" | "u8" | "bool": Some(1)
        case "i16" | "u16": Some(2)
        case "i32" | "u32" | "f32" | "char": Some(4)
        case "i64" | "u64" | "f64" | "isize" | "usize": Some(8)
        case "i128" | "u128": Some(16)
        case "()" | "unit" | "void": Some(1)  # ZST has alignment 1
        case _: nil

# Get size of a type
fn size_of_type(type_: HirType) -> i64:
    val name = type_.to_text()
    primitive_size(name) ?? 8  # Default to pointer size

# Get alignment of a type
fn align_of_type(type_: HirType) -> i64:
    val name = type_.to_text()
    primitive_align(name) ?? 8  # Default to pointer alignment

# Compute layout for a struct
fn compute_struct_layout(fields: [HirField], attr: LayoutAttr) -> TypeLayout:
    match attr.layout_kind:
        case LayoutKind.Packed:
            compute_packed_layout(fields)
        case LayoutKind.C:
            compute_c_layout(fields, attr)
        case LayoutKind.Transparent:
            compute_transparent_layout(fields)
        case LayoutKind.Simple:
            # Default layout (may reorder fields for optimization)
            compute_c_layout(fields, attr)  # Use C layout for now

# Packed layout: no padding, alignment = 1
fn compute_packed_layout(fields: [HirField]) -> TypeLayout:
    var field_layouts: [FieldLayout] = []
    var offset: i64 = 0

    for field in fields:
        val size = size_of_type(field.type_)
        field_layouts.push(FieldLayout(
            name: field.name,
            type_: field.type_,
            offset: offset,
            size: size,
            align: 1
        ))
        offset = offset + size

    TypeLayout(
        size: offset,
        align: 1,
        fields: field_layouts,
        stride: offset
    )

# C ABI layout: fields in order, each aligned
fn compute_c_layout(fields: [HirField], attr: LayoutAttr) -> TypeLayout:
    var field_layouts: [FieldLayout] = []
    var offset: i64 = 0
    var max_align: i64 = 1

    for field in fields:
        val size = size_of_type(field.type_)
        val align = align_of_type(field.type_)

        # Update max alignment
        if align > max_align:
            max_align = align

        # Align offset for this field
        offset = align_up(offset, align)

        field_layouts.push(FieldLayout(
            name: field.name,
            type_: field.type_,
            offset: offset,
            size: size,
            align: align
        ))

        offset = offset + size

    # Apply explicit alignment
    val final_align = attr.effective_align(max_align)

    # Pad struct size to alignment
    val final_size = align_up(offset, final_align)

    TypeLayout(
        size: final_size,
        align: final_align,
        fields: field_layouts,
        stride: final_size
    )

# Transparent layout: same as single field
fn compute_transparent_layout(fields: [HirField]) -> TypeLayout:
    if fields.len() != 1:
        # Transparent requires exactly one field
        # Fall back to default layout
        return compute_c_layout(fields, LayoutAttr.default_())

    val field = fields[0]
    val size = size_of_type(field.type_)
    val align = align_of_type(field.type_)

    TypeLayout(
        size: size,
        align: align,
        fields: [FieldLayout(
            name: field.name,
            type_: field.type_,
            offset: 0,
            size: size,
            align: align
        )],
        stride: size
    )

# Compute field offset in a struct
fn compute_field_offset(struct_fields: [HirField], field_name: text, attr: LayoutAttr) -> i64?:
    val layout = compute_struct_layout(struct_fields, attr)
    for field in layout.fields:
        if field.name == field_name:
            return Some(field.offset)
    nil

# General layout computation
fn compute_layout(type_: HirType, attr: LayoutAttr) -> TypeLayout:
    val size = size_of_type(type_)
    val align = attr.effective_align(align_of_type(type_))
    val stride = align_up(size, align)

    TypeLayout(
        size: size,
        align: align,
        fields: [],
        stride: stride
    )

# Align value up to alignment boundary
fn align_up(value: i64, align: i64) -> i64:
    (value + align - 1) & ~(align - 1)

# Check if value is aligned
fn is_aligned(value: i64, align: i64) -> bool:
    (value & (align - 1)) == 0

# Check if alignment is power of 2
fn is_power_of_two(n: i64) -> bool:
    n > 0 and (n & (n - 1)) == 0

# --- Architecture-Aware Type Sizing ---

# Primitive type sizes for a specific architecture
fn primitive_size_for_arch(type_name: text, arch: TargetArch) -> i64?:
    match type_name:
        # Fixed-size types (same on all architectures)
        case "i8" | "u8" | "bool": Some(1)
        case "i16" | "u16": Some(2)
        case "i32" | "u32" | "f32" | "char": Some(4)
        case "i64" | "u64" | "f64": Some(8)
        case "i128" | "u128": Some(16)
        case "()" | "unit" | "void": Some(0)

        # Pointer-sized types (vary by architecture)
        case "usize" | "isize":
            Some(arch.pointer_bytes())

        # Pointer types
        case _ if type_name.ends_with("*") or type_name.starts_with("&"):
            Some(arch.pointer_bytes())

        case _: nil

# Primitive type alignment for a specific architecture
fn primitive_align_for_arch(type_name: text, arch: TargetArch) -> i64?:
    match type_name:
        # Fixed-alignment types
        case "i8" | "u8" | "bool": Some(1)
        case "i16" | "u16": Some(2)
        case "i32" | "u32" | "f32" | "char": Some(4)
        case "()" | "unit" | "void": Some(1)

        # 64-bit types: alignment depends on architecture
        case "i64" | "u64" | "f64":
            match arch.bits():
                case 8: Some(1)     # 8-bit: byte aligned
                case 16: Some(2)    # 16-bit: word aligned
                case 32: Some(4)    # 32-bit: 4-byte aligned (x86 ABI)
                case 64: Some(8)    # 64-bit: natural alignment

        # 128-bit types
        case "i128" | "u128":
            match arch.bits():
                case 8 | 16: Some(2)
                case 32: Some(4)
                case 64: Some(16)

        # Pointer-sized types
        case "usize" | "isize":
            Some(arch.pointer_bytes())

        # Pointer types
        case _ if type_name.ends_with("*") or type_name.starts_with("&"):
            Some(arch.pointer_bytes())

        case _: nil

# Get size of a type for a specific architecture
fn size_of_type_for_arch(type_: HirType, arch: TargetArch) -> i64:
    val name = type_.to_text()
    primitive_size_for_arch(name, arch) ?? arch.pointer_bytes()

# Get alignment of a type for a specific architecture
fn align_of_type_for_arch(type_: HirType, arch: TargetArch) -> i64:
    val name = type_.to_text()
    primitive_align_for_arch(name, arch) ?? arch.pointer_bytes()

# --- Architecture-Aware Struct Layout ---

# Compute struct layout for a specific architecture
fn compute_struct_layout_for_arch(fields: [HirField], attr: LayoutAttr, arch: TargetArch) -> TypeLayout:
    match attr.layout_kind:
        case LayoutKind.Packed:
            compute_packed_layout_for_arch(fields, arch)
        case LayoutKind.C:
            compute_c_layout_for_arch(fields, attr, arch)
        case LayoutKind.Transparent:
            compute_transparent_layout_for_arch(fields, arch)
        case LayoutKind.Simple:
            compute_c_layout_for_arch(fields, attr, arch)

fn compute_packed_layout_for_arch(fields: [HirField], arch: TargetArch) -> TypeLayout:
    var field_layouts: [FieldLayout] = []
    var offset: i64 = 0

    for field in fields:
        val size = size_of_type_for_arch(field.type_, arch)
        field_layouts.push(FieldLayout(
            name: field.name,
            type_: field.type_,
            offset: offset,
            size: size,
            align: 1
        ))
        offset = offset + size

    TypeLayout(
        size: offset,
        align: 1,
        fields: field_layouts,
        stride: offset
    )

fn compute_c_layout_for_arch(fields: [HirField], attr: LayoutAttr, arch: TargetArch) -> TypeLayout:
    var field_layouts: [FieldLayout] = []
    var offset: i64 = 0
    var max_align: i64 = 1

    for field in fields:
        val size = size_of_type_for_arch(field.type_, arch)
        val align = align_of_type_for_arch(field.type_, arch)

        if align > max_align:
            max_align = align

        offset = align_up(offset, align)

        field_layouts.push(FieldLayout(
            name: field.name,
            type_: field.type_,
            offset: offset,
            size: size,
            align: align
        ))

        offset = offset + size

    val final_align = attr.effective_align(max_align)
    val final_size = align_up(offset, final_align)

    TypeLayout(
        size: final_size,
        align: final_align,
        fields: field_layouts,
        stride: final_size
    )

fn compute_transparent_layout_for_arch(fields: [HirField], arch: TargetArch) -> TypeLayout:
    if fields.len() != 1:
        return compute_c_layout_for_arch(fields, LayoutAttr.default_(), arch)

    val field = fields[0]
    val size = size_of_type_for_arch(field.type_, arch)
    val align = align_of_type_for_arch(field.type_, arch)

    TypeLayout(
        size: size,
        align: align,
        fields: [FieldLayout(
            name: field.name,
            type_: field.type_,
            offset: 0,
            size: size,
            align: align
        )],
        stride: size
    )

# --- Type Size Summary by Architecture ---

# Get a summary of sizes for a type across all architectures
struct TypeSizeSummary:
    type_name: text
    size_8bit: i64
    size_16bit: i64
    size_32bit: i64
    size_64bit: i64
    align_8bit: i64
    align_16bit: i64
    align_32bit: i64
    align_64bit: i64

fn get_type_size_summary(type_name: text) -> TypeSizeSummary:
    TypeSizeSummary(
        type_name: type_name,
        size_8bit: primitive_size_for_arch(type_name, TargetArch.AVR) ?? 1,
        size_16bit: primitive_size_for_arch(type_name, TargetArch.MSP430) ?? 2,
        size_32bit: primitive_size_for_arch(type_name, TargetArch.X86) ?? 4,
        size_64bit: primitive_size_for_arch(type_name, TargetArch.X86_64) ?? 8,
        align_8bit: primitive_align_for_arch(type_name, TargetArch.AVR) ?? 1,
        align_16bit: primitive_align_for_arch(type_name, TargetArch.MSP430) ?? 2,
        align_32bit: primitive_align_for_arch(type_name, TargetArch.X86) ?? 4,
        align_64bit: primitive_align_for_arch(type_name, TargetArch.X86_64) ?? 8
    )
