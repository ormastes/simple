"""
Higher-Rank Polymorphism - Phase 5C: Instantiation & Skolemization

Implements the core algorithms for handling forall quantifiers.

Status: Phase 5C In Progress
"""

type Symbol = text

# ============================================================================
# Kind System (from Phase 5A)
# ============================================================================

enum Kind:
    Star
    Arrow(from: Kind, to: Kind)

impl Kind:
    fn to_string() -> text:
        match self:
            case Star: "*"
            case Arrow(from, to):
                "({from.to_string()} -> {to.to_string()})"

# ============================================================================
# Type Variable (from Phase 5A)
# ============================================================================

class TypeVar:
    id: i64
    name: text
    kind: text

impl TypeVar:
    fn to_string() -> text:
        "{self.name}:{self.kind.to_string()}"

# ============================================================================
# Type System (from Phase 5A)
# ============================================================================

enum HirType:
    Int
    Str
    Bool
    Named(name: Symbol)
    Arrow(from: HirType, to: HirType)
    TypeVariable(id: i64)
    Forall(quantifiers: [TypeVar], body: HirType)
    Skolem(id: i64)
    Error

impl HirType:
    fn to_string() -> text:
        match self:
            case Int: "i32"
            case Str: "String"
            case Bool: "bool"
            case Named(name): name
            case Arrow(from, to):
                "({from.to_string()} -> {to.to_string()})"
            case TypeVariable(id): "?{id}"
            case Forall(quantifiers, body):
                "forall ... . {body.to_string()}"
            case Skolem(id): "sk_{id}"
            case Error: "<error>"

# ============================================================================
# Quantifier Context (from Phase 5B)
# ============================================================================

class QuantifierContext:
    bound_vars: text
    skolem_counter: i64
    scope_level: i64
    inference_counter: i64  # NEW: for generating inference variables

impl QuantifierContext:
    static fn new() -> QuantifierContext:
        QuantifierContext(
            bound_vars: {},
            skolem_counter: 0,
            scope_level: 0,
            inference_counter: 0
        )

    me fresh_skolem() -> i64:
        val id = self.skolem_counter
        self.skolem_counter = self.skolem_counter + 1
        id

    me fresh_inference_var() -> i64:
        """Generate a fresh inference variable"""
        val id = self.inference_counter
        self.inference_counter = self.inference_counter + 1
        id

# ============================================================================
# Type Substitution
# ============================================================================

class Substitution:
    """
    Type variable substitution

    Maps type variable ids to types
    """
    mapping: text  # Dict<i64, HirType>

impl Substitution:
    static fn new() -> Substitution:
        Substitution(mapping: {})

    me add(var_id: i64, ty: HirType):
        """Add a substitution"""
        self.mapping[var_id] = ty

    fn get(var_id: i64) -> HirType:
        """Get substitution for a variable"""
        if var_id in self.mapping:
            return self.mapping[var_id]
        HirType.Error

    fn has(var_id: i64) -> bool:
        """Check if variable has a substitution"""
        var_id in self.mapping

    fn apply(ty: HirType) -> HirType:
        """Apply substitution to a type"""
        match ty:
            case TypeVariable(id):
                if self.has(id):
                    return self.get(id)
                ty

            case Arrow(from, to):
                val from_subst = self.apply(from)
                val to_subst = self.apply(to)
                HirType.Arrow(from: from_subst, to: to_subst)

            case Forall(quantifiers, body):
                # Don't substitute under forall (bound variables)
                # In real impl, would check shadowing
                val body_subst = self.apply(body)
                HirType.Forall(quantifiers: quantifiers, body: body_subst)

            case _:
                ty

# ============================================================================
# Higher-Rank Unifier
# ============================================================================

class HigherRankUnifier:
    """
    Core algorithms for higher-rank polymorphism

    Instantiation: forall T. Ï„ ~> Ï„[T := ?Î±]
    - Replace quantified variables with fresh inference variables
    - Used when checking function arguments

    Skolemization: forall T. Ï„ ~> Ï„[T := sk_i]
    - Replace quantified variables with rigid constants
    - Used when checking expected types
    """
    ctx: text  # QuantifierContext

impl HigherRankUnifier:
    static fn new(ctx: QuantifierContext) -> HigherRankUnifier:
        HigherRankUnifier(ctx: ctx)

    me instantiate(ty: HirType) -> HirType:
        """
        Instantiate quantifiers with fresh inference variables

        Example:
            forall T. T -> T
            ~> ?0 -> ?0
        """
        match ty:
            case Forall(quantifiers, body):
                # Create substitution for quantified variables
                val subst = Substitution.new()

                for type_var in quantifiers:
                    val fresh_var = self.ctx.fresh_inference_var()
                    subst.add(type_var.id, HirType.TypeVariable(id: fresh_var))

                # Apply substitution to body
                subst.apply(body)

            case _:
                # Not a forall - return as is
                ty

    me skolemize(ty: HirType) -> HirType:
        """
        Skolemize quantifiers with rigid constants

        Example:
            forall T. T -> T
            ~> sk_0 -> sk_0
        """
        match ty:
            case Forall(quantifiers, body):
                # Create substitution for quantified variables
                val subst = Substitution.new()

                for type_var in quantifiers:
                    val skolem_id = self.ctx.fresh_skolem()
                    subst.add(type_var.id, HirType.Skolem(id: skolem_id))

                # Apply substitution to body
                subst.apply(body)

            case _:
                # Not a forall - return as is
                ty

    me deep_skolemize(ty: HirType) -> HirType:
        """
        Deep skolemization for rank-2+ types

        Skolemizes foralls in negative (contravariant) positions

        Example:
            (forall T. T -> T) -> i32
            ~> (sk_0 -> sk_0) -> i32
        """
        match ty:
            case Arrow(from, to):
                # from is contravariant (negative position)
                # to is covariant (positive position)
                val from_skolem = self.deep_skolemize(from)
                val to_inst = self.deep_instantiate(to)
                HirType.Arrow(from: from_skolem, to: to_inst)

            case Forall(quantifiers, body):
                # Forall in negative position - skolemize
                self.skolemize(ty)

            case _:
                ty

    me deep_instantiate(ty: HirType) -> HirType:
        """
        Deep instantiation for rank-2+ types

        Instantiates foralls in positive (covariant) positions
        """
        match ty:
            case Arrow(from, to):
                # from is contravariant
                # to is covariant
                val from_skolem = self.deep_skolemize(from)
                val to_inst = self.deep_instantiate(to)
                HirType.Arrow(from: from_skolem, to: to_inst)

            case Forall(quantifiers, body):
                # Forall in positive position - instantiate
                self.instantiate(ty)

            case _:
                ty

# ============================================================================
# Tests
# ============================================================================

fn test_instantiate_basic():
    """Test basic instantiation"""
    val ctx = QuantifierContext.new()
    val unifier = HigherRankUnifier.new(ctx)

    # forall T. T -> T
    val t_var = TypeVar(id: 0, name: "T", kind: Kind.Star)
    val forall_type = HirType.Forall(
        quantifiers: [t_var],
        body: HirType.Arrow(
            from: HirType.TypeVariable(id: 0),
            to: HirType.TypeVariable(id: 0)
        )
    )

    val inst = unifier.instantiate(forall_type)

    # Should be: ?0 -> ?0
    match inst:
        case Arrow(from, to):
            match from:
                case TypeVariable(from_id):
                    match to:
                        case TypeVariable(to_id):
                            assert from_id == to_id, "Same inference variable"
                        case _:
                            assert false, "to should be TypeVariable"
                case _:
                    assert false, "from should be TypeVariable"
        case _:
            assert false, "Should be Arrow"

    print "âœ… Basic instantiation"

fn test_instantiate_multiple():
    """Test instantiation with multiple quantifiers"""
    val ctx = QuantifierContext.new()
    val unifier = HigherRankUnifier.new(ctx)

    # forall T, U. T -> U
    val t_var = TypeVar(id: 0, name: "T", kind: Kind.Star)
    val u_var = TypeVar(id: 1, name: "U", kind: Kind.Star)

    val forall_type = HirType.Forall(
        quantifiers: [t_var, u_var],
        body: HirType.Arrow(
            from: HirType.TypeVariable(id: 0),
            to: HirType.TypeVariable(id: 1)
        )
    )

    val inst = unifier.instantiate(forall_type)

    # Should be: ?0 -> ?1
    match inst:
        case Arrow(from, to):
            match from:
                case TypeVariable(from_id):
                    match to:
                        case TypeVariable(to_id):
                            assert from_id != to_id, "Different inference variables"
                        case _:
                            assert false, "to should be TypeVariable"
                case _:
                    assert false, "from should be TypeVariable"
        case _:
            assert false, "Should be Arrow"

    print "âœ… Multiple quantifier instantiation"

fn test_skolemize_basic():
    """Test basic skolemization"""
    val ctx = QuantifierContext.new()
    val unifier = HigherRankUnifier.new(ctx)

    # forall T. T -> T
    val t_var = TypeVar(id: 0, name: "T", kind: Kind.Star)
    val forall_type = HirType.Forall(
        quantifiers: [t_var],
        body: HirType.Arrow(
            from: HirType.TypeVariable(id: 0),
            to: HirType.TypeVariable(id: 0)
        )
    )

    val skolem = unifier.skolemize(forall_type)

    # Should be: sk_0 -> sk_0
    match skolem:
        case Arrow(from, to):
            match from:
                case Skolem(from_id):
                    match to:
                        case Skolem(to_id):
                            assert from_id == to_id, "Same skolem"
                        case _:
                            assert false, "to should be Skolem"
                case _:
                    assert false, "from should be Skolem"
        case _:
            assert false, "Should be Arrow"

    print "âœ… Basic skolemization"

fn test_skolemize_rigidity():
    """Test that skolems are rigid (have unique ids)"""
    val ctx = QuantifierContext.new()
    val unifier = HigherRankUnifier.new(ctx)

    # forall T. T -> T
    val t_var = TypeVar(id: 0, name: "T", kind: Kind.Star)
    val forall_type = HirType.Forall(
        quantifiers: [t_var],
        body: HirType.Arrow(
            from: HirType.TypeVariable(id: 0),
            to: HirType.TypeVariable(id: 0)
        )
    )

    # Skolemize twice
    val skolem1 = unifier.skolemize(forall_type)
    val skolem2 = unifier.skolemize(forall_type)

    # Extract skolem ids
    var sk1_id = -1
    var sk2_id = -1

    match skolem1:
        case Arrow(from, _):
            match from:
                case Skolem(id):
                    sk1_id = id
                case _:
                    pass
        case _:
            pass

    match skolem2:
        case Arrow(from, _):
            match from:
                case Skolem(id):
                    sk2_id = id
                case _:
                    pass
        case _:
            pass

    assert sk1_id != sk2_id, "Different skolems"
    assert sk1_id == 0, "First is sk_0"
    assert sk2_id == 1, "Second is sk_1"

    print "âœ… Skolem rigidity"

fn test_deep_skolemize_rank2():
    """Test deep skolemization for rank-2 type"""
    val ctx = QuantifierContext.new()
    val unifier = HigherRankUnifier.new(ctx)

    # (forall T. T -> T) -> i32
    val t_var = TypeVar(id: 0, name: "T", kind: Kind.Star)
    val inner_forall = HirType.Forall(
        quantifiers: [t_var],
        body: HirType.Arrow(
            from: HirType.TypeVariable(id: 0),
            to: HirType.TypeVariable(id: 0)
        )
    )

    val rank2_type = HirType.Arrow(
        from: inner_forall,
        to: HirType.Int
    )

    val result = unifier.deep_skolemize(rank2_type)

    # Should be: (sk_0 -> sk_0) -> i32
    match result:
        case Arrow(from, to):
            match from:
                case Arrow(inner_from, inner_to):
                    match inner_from:
                        case Skolem(_):
                            match inner_to:
                                case Skolem(_):
                                    pass
                                case _:
                                    assert false, "inner_to should be Skolem"
                        case _:
                            assert false, "inner_from should be Skolem"
                case _:
                    assert false, "from should be Arrow"
            match to:
                case Int:
                    pass
                case _:
                    assert false, "to should be Int"
        case _:
            assert false, "Should be Arrow"

    print "âœ… Deep skolemization rank-2"

fn test_deep_skolemize_nested():
    """Test deep skolemization with nested foralls"""
    val ctx = QuantifierContext.new()
    val unifier = HigherRankUnifier.new(ctx)

    # Create a complex nested type
    # (forall T. T) -> (forall U. U)

    val t_var = TypeVar(id: 0, name: "T", kind: Kind.Star)
    val u_var = TypeVar(id: 1, name: "U", kind: Kind.Star)

    val forall_t = HirType.Forall(
        quantifiers: [t_var],
        body: HirType.TypeVariable(id: 0)
    )

    val forall_u = HirType.Forall(
        quantifiers: [u_var],
        body: HirType.TypeVariable(id: 1)
    )

    val nested_type = HirType.Arrow(
        from: forall_t,
        to: forall_u
    )

    val result = unifier.deep_skolemize(nested_type)

    # Should be: sk_0 -> ?0
    # (forall in negative position skolemized, forall in positive position instantiated)
    match result:
        case Arrow(from, to):
            match from:
                case Skolem(_):
                    pass
                case _:
                    assert false, "from should be Skolem"
            match to:
                case TypeVariable(_):
                    pass
                case _:
                    assert false, "to should be TypeVariable (instantiated)"
        case _:
            assert false, "Should be Arrow"

    print "âœ… Deep skolemization nested"

fn test_contravariance():
    """Test contravariance in function arguments"""
    val ctx = QuantifierContext.new()
    val unifier = HigherRankUnifier.new(ctx)

    # Test that function arguments (contravariant position) are skolemized
    # while return types (covariant position) are instantiated

    # forall T. T -> (forall U. U)
    val t_var = TypeVar(id: 0, name: "T", kind: Kind.Star)
    val u_var = TypeVar(id: 1, name: "U", kind: Kind.Star)

    val forall_u = HirType.Forall(
        quantifiers: [u_var],
        body: HirType.TypeVariable(id: 1)
    )

    val body = HirType.Arrow(
        from: HirType.TypeVariable(id: 0),
        to: forall_u
    )

    val outer_forall = HirType.Forall(
        quantifiers: [t_var],
        body: body
    )

    # Instantiate outer forall first
    val inst = unifier.instantiate(outer_forall)

    # Then deep process
    val result = unifier.deep_skolemize(inst)

    # Result should have inference var for T, inference var for U (both positive)
    match result:
        case Arrow(from, to):
            match from:
                case TypeVariable(_):
                    pass
                case _:
                    assert false, "from should be TypeVariable"
            match to:
                case TypeVariable(_):
                    pass
                case _:
                    assert false, "to should be TypeVariable"
        case _:
            assert false, "Should be Arrow"

    print "âœ… Contravariance"

fn main():
    print ""
    print "Higher-Rank Polymorphism Phase 5C Tests"
    print "========================================"

    test_instantiate_basic()
    test_instantiate_multiple()
    test_skolemize_basic()
    test_skolemize_rigidity()
    test_deep_skolemize_rank2()
    test_deep_skolemize_nested()
    test_contravariance()

    print ""
    print "ðŸŽ‰ Phase 5C Complete!"
    print ""
    print "Implemented:"
    print "  âœ… Substitution - type variable substitution"
    print "  âœ… HigherRankUnifier - core algorithms"
    print "  âœ… Instantiation (forall T. Ï„ â†’ Ï„[T := ?Î±])"
    print "  âœ… Skolemization (forall T. Ï„ â†’ Ï„[T := sk_i])"
    print "  âœ… Deep skolemization (rank-2+ types)"
    print "  âœ… Deep instantiation (positive positions)"
    print "  âœ… Contravariance handling (negative positions)"
    print ""
    print "Progress: 10/12 hours (83% of Phase 5)"
    print "Next: Phase 5D - Higher-Rank Unification (2h)"
