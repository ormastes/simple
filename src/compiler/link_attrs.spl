# Link Section and Address Space Annotations
#
# Parses @link_section and @addr_space annotations for data declarations.
# These annotations control where data is placed in the final binary.
#
# - @link_section("name") - place in named ELF section
# - @addr_space("region") - place in named address space
#
# Examples:
#   @link_section(".rodata.constants")
#   val LOOKUP_TABLE: [i64] = [...]
#
#   @link_section(".isr_vector")
#   @addr_space("flash")
#   val ISR_TABLE: [fn()] = [...]

# ============================================================================
# Types
# ============================================================================

struct LinkSectionAttr:
    # Parsed link section and address space annotation for a data declaration.
    section: text           # ELF section name (e.g., ".rodata", ".text.cold")
    has_section: bool       # Whether @link_section was present
    addr_space: text        # Address space name (e.g., "flash", "ram", "ccm")
    has_addr_space: bool    # Whether @addr_space was present

# ============================================================================
# Factory Functions
# ============================================================================

fn link_section_attr_default() -> LinkSectionAttr:
    # Create a default (no annotations) LinkSectionAttr.
    LinkSectionAttr(
        section: "",
        has_section: false,
        addr_space: "",
        has_addr_space: false
    )

fn link_section_attr_new(section: text, addr_space: text) -> LinkSectionAttr:
    # Create a LinkSectionAttr with both section and addr_space.
    val has_section = section.len() > 0
    val has_addr = addr_space.len() > 0
    LinkSectionAttr(
        section: section,
        has_section: has_section,
        addr_space: addr_space,
        has_addr_space: has_addr
    )

# ============================================================================
# Parsing
# ============================================================================

fn extract_link_string_arg(args: [text]) -> text:
    # Extract string argument from an attribute args list (pre-parsed text form).
    # Returns "" if no args.
    if args.len() == 0:
        return ""
    val arg = args[0]
    # Strip surrounding quotes if present
    val alen = arg.len()
    if alen >= 2:
        val first = arg[0:1]
        val last = arg[alen-1:alen]
        if first == "\"" and last == "\"":
            return arg[1:alen-1]
    arg

fn parse_link_attrs_from_names(attr_names: [text], attr_args: [[text]]) -> LinkSectionAttr:
    # Parse link section attributes from parallel name/args arrays.
    # This form is used when Attribute structs are not importable in all contexts.
    var section = ""
    var has_section = false
    var addr_space = ""
    var has_addr_space = false
    var i: i64 = 0
    while i < attr_names.len():
        val name = attr_names[i]
        val args = attr_args[i]
        if name == "link_section":
            val s = extract_link_string_arg(args)
            if s.len() > 0:
                section = s
                has_section = true
        elif name == "addr_space":
            val a = extract_link_string_arg(args)
            if a.len() > 0:
                addr_space = a
                has_addr_space = true
        i = i + 1
    LinkSectionAttr(
        section: section,
        has_section: has_section,
        addr_space: addr_space,
        has_addr_space: has_addr_space
    )

# ============================================================================
# Predicates
# ============================================================================

fn link_attr_has_placement(attr: LinkSectionAttr) -> bool:
    # True if any placement annotation is present.
    attr.has_section or attr.has_addr_space

fn link_attr_is_flash(attr: LinkSectionAttr) -> bool:
    # True if addr_space is "flash" (common for Cortex-M read-only data).
    attr.has_addr_space and attr.addr_space == "flash"

fn link_attr_is_ram(attr: LinkSectionAttr) -> bool:
    # True if addr_space is "ram" or "sram".
    if not attr.has_addr_space:
        return false
    attr.addr_space == "ram" or attr.addr_space == "sram"

fn link_attr_codegen_hint(attr: LinkSectionAttr) -> text:
    # Generate a codegen hint string for this attribute.
    if attr.has_section and attr.has_addr_space:
        return "section=" + attr.section + " addr_space=" + attr.addr_space
    elif attr.has_section:
        return "section=" + attr.section
    elif attr.has_addr_space:
        return "addr_space=" + attr.addr_space
    else:
        return ""

# ============================================================================
# Exports
# ============================================================================

export LinkSectionAttr
export link_section_attr_default, link_section_attr_new
export parse_link_attrs_from_names, extract_link_string_arg
export link_attr_has_placement, link_attr_is_flash, link_attr_is_ram
export link_attr_codegen_hint
