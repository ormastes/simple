# SMF Subset Parser
#
# Parses .smf files (SDN format) generated by string extractor.
# Produces structured metadata for table builder.

use app.io.{file_read, file_exists}

# Parsed SMF metadata
class SMFMetadata:
    version: i32
    format: text
    target: text
    source: text
    string_count: i32
    strings: [SMFStringEntry]

impl SMFMetadata:
    static fn empty() -> SMFMetadata:
        SMFMetadata(
            version: 1,
            format: "smf_subset",
            target: "",
            source: "",
            string_count: 0,
            strings: []
        )

# Individual string entry from SMF
class SMFStringEntry:
    id: i32
    text: text
    params: i32
    format_types: [i32]
    source_file: text
    source_line: i32

impl SMFStringEntry:
    static fn create(id: i32, text: text, params: i32) -> SMFStringEntry:
        SMFStringEntry(
            id: id,
            text: text,
            params: params,
            format_types: [],
            source_file: "",
            source_line: 0
        )

# Parse SMF subset file
fn parse_smf_file(path: text) -> SMFMetadata:
    # Check if file exists
    if not file_exists(path):
        print "Error: SMF file not found: {path}"
        return SMFMetadata.empty()

    # Read file content
    val content = file_read(path)
    if content.len() == 0:
        print "Error: Empty SMF file: {path}"
        return SMFMetadata.empty()

    # Parse SDN format
    parse_smf_sdn(content)

# Parse SMF content (SDN format)
fn parse_smf_sdn(content: text) -> SMFMetadata:
    var metadata = SMFMetadata.empty()
    var lines = content.split("\n")
    var in_metadata_section = false
    var in_strings_section = false
    var current_string: SMFStringEntry? = None
    var indent_level = 0

    for line in lines:
        # Skip comments and empty lines
        val trimmed = line.trim()
        if trimmed.len() == 0 or trimmed.starts_with("#"):
            continue

        # Determine indent level
        indent_level = count_leading_spaces(line)

        # Parse metadata section
        if trimmed == "metadata:":
            in_metadata_section = true
            in_strings_section = false
            continue

        # Parse strings section
        if trimmed == "strings:":
            in_metadata_section = false
            in_strings_section = true
            continue

        # Parse metadata fields
        if in_metadata_section:
            if trimmed.contains(":"):
                val parts = trimmed.split(":")
                if parts.len() >= 2:
                    val key = parts[0].trim()
                    val value = parts[1].trim().trim_quotes()

                    if key == "version":
                        metadata.version = parse_int(value)
                    elif key == "format":
                        metadata.format = value
                    elif key == "target":
                        metadata.target = value
                    elif key == "source":
                        metadata.source = value
                    elif key == "string_count":
                        metadata.string_count = parse_int(value)

        # Parse string entries
        if in_strings_section:
            # New entry starts with "- id:"
            if trimmed.starts_with("- id:"):
                # Save previous entry
                if current_string.is_some():
                    metadata.strings.push(current_string.unwrap())

                # Start new entry
                val id_value = extract_value_after_colon(trimmed)
                current_string = Some(SMFStringEntry.create(
                    parse_int(id_value),
                    "",
                    0
                ))

            # Parse entry fields
            elif indent_level >= 4 and current_string.is_some():
                var entry = current_string.unwrap()

                if trimmed.starts_with("text:"):
                    entry.text = extract_string_value(trimmed)
                elif trimmed.starts_with("params:"):
                    entry.params = parse_int(extract_value_after_colon(trimmed))
                elif trimmed.starts_with("source_file:"):
                    entry.source_file = extract_string_value(trimmed)
                elif trimmed.starts_with("source_line:"):
                    entry.source_line = parse_int(extract_value_after_colon(trimmed))

                current_string = Some(entry)

    # Save last entry
    if current_string.is_some():
        metadata.strings.push(current_string.unwrap())

    metadata

# Helper: Count leading spaces
fn count_leading_spaces(line: text) -> i32:
    var count = 0
    var i = 0

    while i < line.len():
        if line[i:i+1] == " ":
            count = count + 1
            i = i + 1
        else:
            break

    count

# Helper: Extract value after colon
fn extract_value_after_colon(line: text) -> text:
    val parts = line.split(":")
    if parts.len() >= 2:
        return parts[1].trim().trim_quotes()
    ""

# Helper: Extract string value (handles quotes and escapes)
fn extract_string_value(line: text) -> text:
    val parts = line.split(":")
    if parts.len() < 2:
        return ""

    var value = parts[1].trim()

    # Remove quotes
    value = value.trim_quotes()

    # Unescape string
    unescape_string(value)

# Helper: Unescape string (reverse of escape_string)
fn unescape_string(s: text) -> text:
    var result = ""
    var i = 0

    while i < s.len():
        if s[i:i+1] == "\\":
            # Escape sequence
            if i + 1 < s.len():
                val next_ch = s[i+1:i+2]
                if next_ch == "n":
                    result = result + "\n"
                    i = i + 2
                    continue
                elif next_ch == "t":
                    result = result + "\t"
                    i = i + 2
                    continue
                elif next_ch == "\"":
                    result = result + "\""
                    i = i + 2
                    continue
                elif next_ch == "\\":
                    result = result + "\\"
                    i = i + 2
                    continue

        result = result + s[i:i+1]
        i = i + 1

    result

# Helper: Parse integer
fn parse_int(s: text) -> i32:
    var result: i32 = 0
    var i = 0

    while i < s.len():
        val ch = s[i:i+1]
        if ch >= "0" and ch <= "9":
            val digit = char_to_digit(ch)
            result = result * 10 + digit
        i = i + 1

    result

fn char_to_digit(ch: text) -> i32:
    match ch:
        "0": 0
        "1": 1
        "2": 2
        "3": 3
        "4": 4
        "5": 5
        "6": 6
        "7": 7
        "8": 8
        "9": 9
        _: 0

# Helper: Trim quotes from string
fn trim_quotes(s: text) -> text:
    var result = s

    # Remove leading quote
    if result.len() > 0 and result[0:1] == "\"":
        result = result[1:]

    # Remove trailing quote
    if result.len() > 0 and result[result.len()-1:result.len()] == "\"":
        result = result[0:result.len()-1]

    result

# Test function
fn test_smf_parser():
    val metadata = parse_smf_file("hello_world.smf")

    print "SMF Metadata:"
    print "  Version: {metadata.version}"
    print "  Format: {metadata.format}"
    print "  Target: {metadata.target}"
    print "  Source: {metadata.source}"
    print "  String count: {metadata.string_count}"
    print ""
    print "Strings:"

    for entry in metadata.strings:
        print "  [{entry.id}] \"{entry.text}\" (params={entry.params})"
