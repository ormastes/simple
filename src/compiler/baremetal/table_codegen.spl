# String Table Assembly Code Generator
#
# Generates RISC-V assembly code for .smt section containing
# the full indexed string table.

use compiler.baremetal.table_builder.{FullStringTable, FullStringEntry}
use std.string.{NL}

# Generate complete .smt section assembly
fn generate_smt_section(table: FullStringTable) -> text:
    var asm = ""

    # Section header
    asm = asm + "# Auto-generated string table section" + NL
    asm = asm + "# DO NOT EDIT - Generated by Simple compiler" + NL
    asm = asm + NL

    # Define .smt section (read-only, allocated)
    asm = asm + ".section .smt, \"a\"" + NL
    asm = asm + ".align 4" + NL
    asm = asm + NL

    # Global symbol for table start
    asm = asm + ".global __simple_string_table" + NL
    asm = asm + ".global __simple_string_table_end" + NL
    asm = asm + NL

    # Table start
    asm = asm + "__simple_string_table:" + NL

    # Table header: entry count
    asm = asm + "    .word {table.count()}           # Entry count" + NL
    asm = asm + NL

    # Generate entries
    for entry in table.entries:
        asm = asm + generate_entry_asm(entry)

    # Table end marker
    asm = asm + NL
    asm = asm + "__simple_string_table_end:" + NL

    # Add size constant
    asm = asm + NL
    asm = asm + "# Table size: {table.total_size} bytes" + NL
    asm = asm + ".global __simple_string_table_size" + NL
    asm = asm + ".set __simple_string_table_size, {table.total_size}" + NL

    asm

# Generate assembly for single entry
fn generate_entry_asm(entry: FullStringEntry) -> text:
    var asm = ""

    # Comment with entry info
    asm = asm + "    # Entry {entry.id}: \"{escape_for_comment(entry.text)}\" "
    asm = asm + "({entry.length} bytes, {entry.param_count} params)" + NL

    # Entry header (3 words = 12 bytes)
    asm = asm + "    .word {entry.id}                # ID" + NL
    asm = asm + "    .word {entry.length}            # Length (with null)" + NL
    asm = asm + "    .word {entry.param_count}       # Parameter count" + NL

    # String data (null-terminated)
    asm = asm + "    .ascii \"{escape_for_asm(entry.text)}\\0\"" + NL

    # Alignment padding
    asm = asm + "    .align 4" + NL
    asm = asm + NL

    asm

# Escape string for assembly .ascii directive
fn escape_for_asm(s: text) -> text:
    var result = ""
    var i = 0

    while i < s.len():
        val ch = s[i:i+1]

        if ch == "\n":
            result = result + "\\n"
        elif ch == "\t":
            result = result + "\\t"
        elif ch == "\r":
            result = result + "\\r"
        elif ch == "\"":
            result = result + "\\\""
        elif ch == "\\":
            result = result + "\\\\"
        else:
            result = result + ch

        i = i + 1

    result

# Escape string for comments (truncate long strings)
fn escape_for_comment(s: text) -> text:
    val max_len = 40
    var escaped = escape_for_asm(s)

    if escaped.len() > max_len:
        escaped = escaped[0:max_len] + "..."

    escaped

# Generate linker script fragment for .smt section
fn generate_linker_script_fragment() -> text:
    var script = ""

    script = script + "/* String table section */" + NL
    script = script + ".smt : {" + NL
    script = script + "    . = ALIGN(4);" + NL
    script = script + "    __simple_string_table = .;" + NL
    script = script + "    *(.smt)" + NL
    script = script + "    __simple_string_table_end = .;" + NL
    script = script + "    . = ALIGN(4);" + NL
    script = script + "} > RAM" + NL

    script

# Generate metadata file (for debugging/inspection)
fn generate_metadata_json(table: FullStringTable) -> text:
    var json = ""

    json = json + "{" + NL
    json = json + "  \"version\": 1," + NL
    json = json + "  \"format\": \"simple_string_table\"," + NL
    json = json + "  \"entry_count\": {table.count()}," + NL
    json = json + "  \"total_size\": {table.total_size}," + NL
    json = json + "  \"entries\": [" + NL

    var first = true
    for entry in table.entries:
        if not first:
            json = json + "," + NL
        first = false

        json = json + "    {" + NL
        json = json + "      \"id\": {entry.id}," + NL
        json = json + "      \"text\": \"{escape_for_json(entry.text)}\"," + NL
        json = json + "      \"length\": {entry.length}," + NL
        json = json + "      \"param_count\": {entry.param_count}," + NL
        json = json + "      \"aligned_size\": {entry.aligned_size}" + NL
        json = json + "    }"

    json = json + NL + "  ]" + NL
    json = json + "}" + NL

    json

# Escape string for JSON
fn escape_for_json(s: text) -> text:
    var result = ""
    var i = 0

    while i < s.len():
        val ch = s[i:i+1]

        if ch == "\n":
            result = result + "\\n"
        elif ch == "\t":
            result = result + "\\t"
        elif ch == "\r":
            result = result + "\\r"
        elif ch == "\"":
            result = result + "\\\""
        elif ch == "\\":
            result = result + "\\\\"
        else:
            result = result + ch

        i = i + 1

    result

# Write assembly to file
fn write_asm_file(asm: text, output_path: text) -> bool:
    # Use FFI to write file
    file_write(output_path, asm)

# Write metadata to file
fn write_metadata_file(table: FullStringTable, output_path: text) -> bool:
    val json = generate_metadata_json(table)
    file_write(output_path, json)

# Helper: Write text to file
fn file_write(path: text, content: text) -> bool:
    # Import from app.io (Phase 1B.7 - TODO #65 âœ…)
    use app.io.{file_write as io_file_write}
    io_file_write(path, content)
    true

# Test function
fn test_codegen():
    # Parse and build table
    val metadata = parse_smf_file("hello_world.smf")
    val table = build_full_table(metadata)

    # Generate assembly
    val asm = generate_smt_section(table)

    print "Generated assembly:"
    print "===================="
    print asm
    print ""

    # Generate metadata
    val json = generate_metadata_json(table)
    print "Metadata JSON:"
    print "=============="
    print json

    # Write to files
    write_asm_file(asm, "string_table.s")
    write_metadata_file(table, "string_table.json")
