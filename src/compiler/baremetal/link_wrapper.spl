# String Table Link Wrapper
#
# Orchestrates the complete linking process with embedded string table:
# 1. Parse SMF subset file
# 2. Build full indexed table
# 3. Generate .smt section assembly
# 4. Compile table to object file
# 5. Link all objects together

use compiler.baremetal.smf_parser.parse_smf_file
use compiler.baremetal.table_builder.{build_full_table, validate_table, sort_table_by_id}
use compiler.baremetal.table_codegen.{generate_smt_section, write_asm_file}
use app.io.{process_run, file_exists, file_write}

# Link configuration
class LinkConfig:
    smf_file: text              # Input: SMF subset file
    object_files: [text]        # Input: Object files to link
    output_file: text           # Output: Final ELF binary
    target: text                # Target triple (e.g., "riscv32-unknown-none")
    linker_script: text         # Optional linker script
    entry_point: text           # Entry point symbol (default: "_start")
    text_addr: text             # Text section address (default: "0x80000000")
    embed_table: bool           # Whether to embed string table
    keep_temp_files: bool       # Keep intermediate files for debugging

impl LinkConfig:
    static fn default_riscv32(
        smf: text,
        objects: [text],
        output: text
    ) -> LinkConfig:
        LinkConfig(
            smf_file: smf,
            object_files: objects,
            output_file: output,
            target: "riscv32-unknown-none",
            linker_script: "",
            entry_point: "_start",
            text_addr: "0x80000000",
            embed_table: true,
            keep_temp_files: false
        )

# Link result
class LinkResult:
    success: bool
    output_file: text
    table_size: i32
    error_message: text

impl LinkResult:
    static fn ok(output: text, table_size: i32) -> LinkResult:
        LinkResult(
            success: true,
            output_file: output,
            table_size: table_size,
            error_message: ""
        )

    static fn error(message: text) -> LinkResult:
        LinkResult(
            success: false,
            output_file: "",
            table_size: 0,
            error_message: message
        )

# Main linking function
fn link_with_string_table(config: LinkConfig) -> LinkResult:
    print "╔════════════════════════════════════════════════════════════════╗"
    print "║  Linking with String Table                                    ║"
    print "╚════════════════════════════════════════════════════════════════╝"
    print ""

    # Step 1: Parse SMF file
    print "→ Parsing SMF file: {config.smf_file}"
    if not file_exists(config.smf_file):
        return LinkResult.error("SMF file not found: {config.smf_file}")

    val metadata = parse_smf_file(config.smf_file)
    if metadata.string_count == 0:
        return LinkResult.error("No strings found in SMF file")

    print "  ✓ Found {metadata.string_count} strings"
    print ""

    # Step 2: Build full table
    print "→ Building full indexed table..."
    var table = build_full_table(metadata)

    # Sort by ID for consistent layout
    table = sort_table_by_id(table)

    # Validate
    if not validate_table(table):
        return LinkResult.error("Table validation failed")

    print "  ✓ Table built ({table.total_size} bytes)"
    print ""

    # Step 3: Generate assembly
    print "→ Generating .smt section assembly..."
    val asm = generate_smt_section(table)
    val asm_file = "string_table.s"

    if not write_asm_file(asm, asm_file):
        return LinkResult.error("Failed to write assembly file")

    print "  ✓ Generated {asm_file}"
    print ""

    # Step 4: Compile assembly to object
    print "→ Compiling string table to object file..."
    val table_obj = "string_table.o"

    if not compile_table_to_object(asm_file, table_obj, config.target):
        return LinkResult.error("Failed to compile string table")

    print "  ✓ Compiled {table_obj}"
    print ""

    # Step 5: Link all objects
    print "→ Linking objects..."
    val all_objects = config.object_files.concat([table_obj])

    if not link_objects(all_objects, config):
        return LinkResult.error("Linking failed")

    print "  ✓ Linked {config.output_file}"
    print ""

    # Cleanup temp files
    if not config.keep_temp_files:
        cleanup_temp_files(asm_file, table_obj)

    print "╔════════════════════════════════════════════════════════════════╗"
    print "║  Link Complete!                                               ║"
    print "╚════════════════════════════════════════════════════════════════╝"
    print ""
    print "Output: {config.output_file}"
    print "String table size: {table.total_size} bytes"
    print "String count: {table.count()}"

    LinkResult.ok(config.output_file, table.total_size)

# Compile string table assembly to object file
fn compile_table_to_object(asm_file: text, obj_file: text, target: text) -> bool:
    # Detect assembler
    var assembler = ""
    var args: [text] = []

    # Try clang-16 first
    if command_exists("clang-16"):
        assembler = "clang-16"
        args = [
            "-target", target,
            "-march=rv32i",
            "-mabi=ilp32",
            "-c",
            asm_file,
            "-o", obj_file
        ]
    elif command_exists("clang"):
        assembler = "clang"
        args = [
            "-target", target,
            "-march=rv32i",
            "-mabi=ilp32",
            "-c",
            asm_file,
            "-o", obj_file
        ]
    else:
        print "Error: No assembler found (need clang or clang-16)"
        return false

    # Run assembler
    val (stdout, stderr, exit_code) = process_run(assembler, args)

    if exit_code != 0:
        print "Assembler error:"
        print stderr
        return false

    true

# Link all object files
fn link_objects(objects: [text], config: LinkConfig) -> bool:
    # Detect linker
    var linker = ""
    var args: [text] = []

    # Try lld (LLVM linker)
    if command_exists("ld.lld"):
        linker = "ld.lld"
    elif command_exists("riscv64-unknown-elf-ld"):
        linker = "riscv64-unknown-elf-ld"
    else:
        print "Error: No linker found (need ld.lld or riscv64-unknown-elf-ld)"
        return false

    # Build linker arguments
    args = [
        "-o", config.output_file,
        "-Ttext={config.text_addr}",
        "--no-relax"
    ]

    # Add linker script if specified
    if config.linker_script.len() > 0:
        args.push("-T")
        args.push(config.linker_script)

    # Add entry point
    args.push("-e")
    args.push(config.entry_point)

    # Add all object files
    for obj in objects:
        args.push(obj)

    # Run linker
    val (stdout, stderr, exit_code) = process_run(linker, args)

    if exit_code != 0:
        print "Linker error:"
        print stderr
        return false

    true

# Check if command exists
fn command_exists(cmd: text) -> bool:
    val (stdout, stderr, exit_code) = process_run("which", [cmd])
    exit_code == 0

# Cleanup temporary files
fn cleanup_temp_files(asm_file: text, obj_file: text):
    # Delete files
    process_run("rm", ["-f", asm_file, obj_file])

# Helper: Concatenate arrays
fn concat(arr1: [text], arr2: [text]) -> [text]:
    var result: [text] = []

    for item in arr1:
        result.push(item)

    for item in arr2:
        result.push(item)

    result

# CLI entry point
fn main():
    # Parse command-line arguments
    val args = get_cli_args()

    if args.len() < 3:
        print_usage()
        return

    # Extract arguments
    val smf_file = args[0]
    val output_file = args[1]
    var object_files: [text] = []

    var i = 2
    while i < args.len():
        object_files.push(args[i])
        i = i + 1

    # Create config
    val config = LinkConfig.default_riscv32(smf_file, object_files, output_file)

    # Run linker
    val result = link_with_string_table(config)

    if not result.success:
        print "Error: {result.error_message}"
        exit(1)

fn print_usage():
    print "Usage: link_wrapper <smf_file> <output.elf> <object_files...>"
    print ""
    print "Example:"
    print "  link_wrapper hello.smf hello.elf hello.o"

fn get_cli_args() -> [text]:
    # TODO: Use rt_cli_get_args()
    []

fn exit(code: i32):
    # TODO: Use rt_exit()
    pass
