# String Extractor for Baremetal Compilation
#
# Walks AST and extracts all print/semihosting strings for string interning.
# Generates SMF subset file (metadata only) for later table building.

use app.parser.ast

# Metadata for a single extracted string
class StringMetadata:
    id: i32
    text: text
    param_count: i32
    param_names: [text]      # NEW: Variable names from {name} patterns
    format_types: [i32]
    source_file: text
    source_line: i32

impl StringMetadata:
    static fn create(id: i32, text: text, params: i32) -> StringMetadata:
        StringMetadata(
            id: id,
            text: text,
            param_count: params,
            param_names: [],     # NEW: Empty by default
            format_types: [],
            source_file: "",
            source_line: 0
        )

# String extraction result
class StringExtractionResult:
    strings: [StringMetadata]
    count: i32

impl StringExtractionResult:
    static fn empty() -> StringExtractionResult:
        StringExtractionResult(strings: [], count: 0)

    me add(string_meta: StringMetadata):
        self.strings.push(string_meta)
        self.count = self.count + 1

# Main extractor class
class StringExtractor:
    next_id: i32
    result: StringExtractionResult

impl StringExtractor:
    static fn create() -> StringExtractor:
        StringExtractor(
            next_id: 1,
            result: StringExtractionResult.empty()
        )

    # Extract strings from AST
    fn extract(ast: AST) -> StringExtractionResult:
        self.walk_ast(ast)
        self.result

    # Walk AST and find print/semihosting calls
    me walk_ast(node: ASTNode):
        # Check if this node is a print call
        if self.is_print_call(node):
            val string_literal = self.extract_string_literal(node)

            # Extract parameter info (count, names, normalized text)
            val param_info = self.extract_format_params(string_literal)
            val param_count = param_info.0
            val param_names = param_info.1
            val normalized_text = param_info.2

            val metadata = StringMetadata.create(
                self.next_id,
                normalized_text,  # Use normalized {} format
                param_count
            )
            metadata.param_names = param_names  # Store parameter names
            metadata.source_file = node.source_file ?? ""
            metadata.source_line = node.source_line ?? 0

            self.result.add(metadata)
            self.next_id = self.next_id + 1

        # Recursively walk children
        for child in node.children():
            self.walk_ast(child)

    # Check if node is a print/semihosting call
    fn is_print_call(node: ASTNode) -> bool:
        # Check for function call
        if not node.is_call():
            return false

        # Get function name
        val fn_name = node.get_function_name()

        # Known print functions
        (fn_name == "print" or
        fn_name == "println" or
        fn_name == "semihost_write" or
        fn_name == "debug_print")

    # Extract string literal from call argument
    fn extract_string_literal(node: ASTNode) -> text:
        # Get first argument
        val args = node.get_arguments()
        if args.len() == 0:
            return ""

        val first_arg = args[0]

        # Check if it's a string literal
        if first_arg.is_string_literal():
            return first_arg.get_string_value()

        # Handle string interpolation
        if first_arg.is_interpolated_string():
            return first_arg.get_format_string()

        ""

    # Extract parameter names and count from format string
    # Supports both {} and {name} syntax
    # Returns: (param_count, param_names, normalized_text)
    fn extract_format_params(text: text) -> (i32, [text], text):
        var param_names = []
        var normalized = ""
        var i = 0

        while i < text.len():
            if text[i:i+1] == "{":
                # Find closing }
                var j = i + 1
                while j < text.len() and text[j:j+1] != "}":
                    j = j + 1

                if j < text.len():
                    # Extract parameter name (or empty for {})
                    val param_text = text[i+1:j]

                    if param_text.len() > 0:
                        # Named parameter: {name}
                        param_names.push(param_text)
                    else:
                        # Positional parameter: {}
                        param_names.push("")

                    # Normalize to {} for runtime
                    normalized = normalized + "{}"
                    i = j + 1
                    continue

            normalized = normalized + text[i:i+1]
            i = i + 1

        (param_names.len(), param_names, normalized)

    # Count format parameters in string (Simple uses {} syntax)
    fn count_format_params(text: text) -> i32:
        val result = self.extract_format_params(text)
        result.0  # Return count

# Generate SMF subset file from extraction result
fn generate_smf_subset(
    result: StringExtractionResult,
    output_path: text,
    source_file: text,
    target: text
) -> bool:
    var sdn = ""

    # Header
    sdn = sdn + "# String Metadata Subset (SMF format)\n"
    sdn = sdn + "# Generated by Simple compiler for baremetal target\n"
    sdn = sdn + "\n"

    # Metadata section
    sdn = sdn + "metadata:\n"
    sdn = sdn + "  version: 1\n"
    sdn = sdn + "  format: \"smf_subset\"\n"
    sdn = sdn + "  target: \"{target}\"\n"
    sdn = sdn + "  source: \"{source_file}\"\n"
    sdn = sdn + "  string_count: {result.count}\n"
    sdn = sdn + "\n"

    # Strings section
    sdn = sdn + "strings:\n"

    for string in result.strings:
        sdn = sdn + "  - id: {string.id}\n"
        sdn = sdn + "    text: \"{escape_string(string.text)}\"\n"
        sdn = sdn + "    params: {string.param_count}\n"

        # Add parameter names if any
        if string.param_names.len() > 0:
            sdn = sdn + "    param_names: ["
            var first = true
            for name in string.param_names:
                if not first:
                    sdn = sdn + ", "
                if name.len() > 0:
                    sdn = sdn + "\"{name}\""
                else:
                    sdn = sdn + "\"\""  # Empty string for positional {}
                first = false
            sdn = sdn + "]\n"

        sdn = sdn + "    format_types: []\n"

        if string.source_file.len() > 0:
            sdn = sdn + "    source_file: \"{string.source_file}\"\n"
            sdn = sdn + "    source_line: {string.source_line}\n"

        sdn = sdn + "\n"

    # Write to file
    file_write(output_path, sdn)

# Escape string for SDN format
fn escape_string(s: text) -> text:
    var result = ""
    var i = 0

    while i < s.len():
        val ch = s[i:i+1]

        if ch == "\n":
            result = result + "\\n"
        elif ch == "\t":
            result = result + "\\t"
        elif ch == "\"":
            result = result + "\\\""
        elif ch == "\\":
            result = result + "\\\\"
        else:
            result = result + ch

        i = i + 1

    result

# Helper function - writes text to file
fn file_write(path: text, content: text) -> bool:
    # Import from app.io (Phase 1B.7 - TODO #64 âœ…)
    use app.io.{file_write as io_file_write}
    io_file_write(path, content)
    true
