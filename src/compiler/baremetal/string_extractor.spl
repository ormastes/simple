# String Extractor for Baremetal Compilation
#
# Walks AST and extracts all print/semihosting strings for string interning.
# Generates SMF subset file (metadata only) for later table building.

use app.parser.ast

# Metadata for a single extracted string
class StringMetadata:
    id: i32
    text: text
    param_count: i32
    format_types: [i32]
    source_file: text
    source_line: i32

impl StringMetadata:
    static fn create(id: i32, text: text, params: i32) -> StringMetadata:
        StringMetadata(
            id: id,
            text: text,
            param_count: params,
            format_types: [],
            source_file: "",
            source_line: 0
        )

# String extraction result
class StringExtractionResult:
    strings: [StringMetadata]
    count: i32

impl StringExtractionResult:
    static fn empty() -> StringExtractionResult:
        StringExtractionResult(strings: [], count: 0)

    me add(string_meta: StringMetadata):
        self.strings.push(string_meta)
        self.count = self.count + 1

# Main extractor class
class StringExtractor:
    next_id: i32
    result: StringExtractionResult

impl StringExtractor:
    static fn create() -> StringExtractor:
        StringExtractor(
            next_id: 1,
            result: StringExtractionResult.empty()
        )

    # Extract strings from AST
    fn extract(ast: AST) -> StringExtractionResult:
        self.walk_ast(ast)
        self.result

    # Walk AST and find print/semihosting calls
    me walk_ast(node: ASTNode):
        # Check if this node is a print call
        if self.is_print_call(node):
            val string_literal = self.extract_string_literal(node)
            val params = self.count_format_params(string_literal)

            val metadata = StringMetadata.create(
                self.next_id,
                string_literal,
                params
            )
            metadata.source_file = node.source_file ?? ""
            metadata.source_line = node.source_line ?? 0

            self.result.add(metadata)
            self.next_id = self.next_id + 1

        # Recursively walk children
        for child in node.children():
            self.walk_ast(child)

    # Check if node is a print/semihosting call
    fn is_print_call(node: ASTNode) -> bool:
        # Check for function call
        if not node.is_call():
            return false

        # Get function name
        val fn_name = node.get_function_name()

        # Known print functions
        fn_name == "print" or
        fn_name == "println" or
        fn_name == "semihost_write" or
        fn_name == "debug_print"

    # Extract string literal from call argument
    fn extract_string_literal(node: ASTNode) -> text:
        # Get first argument
        val args = node.get_arguments()
        if args.len() == 0:
            return ""

        val first_arg = args[0]

        # Check if it's a string literal
        if first_arg.is_string_literal():
            return first_arg.get_string_value()

        # Handle string interpolation
        if first_arg.is_interpolated_string():
            return first_arg.get_format_string()

        ""

    # Count format parameters in string (Simple uses {} syntax)
    fn count_format_params(text: text) -> i32:
        var count = 0
        var i = 0

        while i < text.len():
            # Look for {} pairs
            if text[i:i+1] == "{":
                # Check next char
                if i + 1 < text.len():
                    if text[i+1:i+2] == "}":
                        count = count + 1
                        i = i + 2
                        continue

            i = i + 1

        count

# Generate SMF subset file from extraction result
fn generate_smf_subset(
    result: StringExtractionResult,
    output_path: text,
    source_file: text,
    target: text
) -> bool:
    var sdn = ""

    # Header
    sdn = sdn + "# String Metadata Subset (SMF format)\n"
    sdn = sdn + "# Generated by Simple compiler for baremetal target\n"
    sdn = sdn + "\n"

    # Metadata section
    sdn = sdn + "metadata:\n"
    sdn = sdn + "  version: 1\n"
    sdn = sdn + "  format: \"smf_subset\"\n"
    sdn = sdn + "  target: \"{target}\"\n"
    sdn = sdn + "  source: \"{source_file}\"\n"
    sdn = sdn + "  string_count: {result.count}\n"
    sdn = sdn + "\n"

    # Strings section
    sdn = sdn + "strings:\n"

    for string in result.strings:
        sdn = sdn + "  - id: {string.id}\n"
        sdn = sdn + "    text: \"{escape_string(string.text)}\"\n"
        sdn = sdn + "    params: {string.param_count}\n"
        sdn = sdn + "    format_types: []\n"

        if string.source_file.len() > 0:
            sdn = sdn + "    source_file: \"{string.source_file}\"\n"
            sdn = sdn + "    source_line: {string.source_line}\n"

        sdn = sdn + "\n"

    # Write to file
    file_write(output_path, sdn)

# Escape string for SDN format
fn escape_string(s: text) -> text:
    var result = ""
    var i = 0

    while i < s.len():
        val ch = s[i:i+1]

        if ch == "\n":
            result = result + "\\n"
        elif ch == "\t":
            result = result + "\\t"
        elif ch == "\"":
            result = result + "\\\""
        elif ch == "\\":
            result = result + "\\\\"
        else:
            result = result + ch

        i = i + 1

    result

# Helper function - writes text to file
fn file_write(path: text, content: text) -> bool:
    # Use FFI to write file
    # TODO: Import from app.io
    true
