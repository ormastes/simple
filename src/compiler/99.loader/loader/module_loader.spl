# Module Loader - Runtime SMF loading with type inference.
#
# This module provides runtime module loading capabilities:
# - Load SMF files at runtime
# - JIT instantiation of generics via ObjTaker
# - Module caching and hot-reload support
# - Symbol resolution with type inference
#
# Uses compiler FFI (compiler_ffi module) for:
# - Type inference (compiler_ctx.infer_types)
# - Template instantiation (compiler_ctx.instantiate)
# Benefits: No circular dependency, clean separation

use ..loader.compiler_ffi.*
use ..linker.obj_taker.*
use ..linker.smf_reader.*
use compiler.linker.object_provider.{ObjectProvider, ObjectProviderConfig}
use .object_mapper.{LoaderMapper, LoaderMapperConfig}
use .jit_instantiator.*

# ============================================================================
# Loaded Module
# ============================================================================

struct LoadedModule:
    """A loaded SMF module."""
    path: text
    reader: SmfReaderImpl
    symbols: Dict<text, LoadedSymbol>
    load_time: i64
    version: i32

struct LoadedSymbol:
    """A symbol loaded into memory."""
    name: text
    address: i64
    size: i64
    ty: SymbolType
    is_jit: bool
    # Offset within the SMF (for possible reload/relocs)
    file_offset: i64


# ============================================================================
# LoadedModule Methods (was: impl LoadedModule:)
# ============================================================================

# ============================================================================
# Load Result
# ============================================================================

enum LoadResult:
    Success(module: LoadedModule)
    AlreadyLoaded(module: LoadedModule)
    Error(message: text)

enum SymbolResult:
    Found(symbol: LoadedSymbol, code: [u8])
    JitCompiled(symbol: LoadedSymbol, code: [u8])
    NotFound(name: text)
    Error(message: text)

# ============================================================================
# Module Loader Configuration
# ============================================================================

struct ModuleLoaderConfig:
    """Configuration for module loading."""
    enable_jit: bool
    enable_cache: bool
    max_cache_size: i32
    verbose: bool
    hot_reload: bool


# ============================================================================
# ModuleLoaderConfig Methods (was: impl ModuleLoaderConfig:)
# ============================================================================

fn moduleloaderconfig_default() -> ModuleLoaderConfig:
        ModuleLoaderConfig(
            enable_jit: true,
            enable_cache: true,
            max_cache_size: 100,
            verbose: false,
            hot_reload: false
        )


# ============================================================================
# Module Loader
# ============================================================================

struct ModuleLoader:
    """Runtime module loader with JIT instantiation support."""
    # Shared compiler context (FFI handle)
    compiler_ctx: CompilerContext
    # ObjTaker for extraction and instantiation
    obj_taker: ObjTaker
    # Shared object provider (finder + instantiator)
    provider: ObjectProvider
    # JIT instantiator
    jit: JitInstantiator
    # Loader policy wrapper over shared exec mapper
    loader_mapper: LoaderMapper
    # Loaded modules cache: path -> module
    modules: Dict<text, LoadedModule>
    # Global symbol table: name -> (module_path, symbol)
    global_symbols: Dict<text, (text, LoadedSymbol)>
    # Configuration
    config: ModuleLoaderConfig


# ============================================================================
# ModuleLoader Methods (was: impl ModuleLoader:)
# ============================================================================

fn moduleloader_new(config: ModuleLoaderConfig) -> ModuleLoader:
        """Create a new module loader."""
        val compiler_ctx = CompilerContext__create()  # FFI handle
        val obj_taker_config = ObjTakerConfig(
            enable_caching: config.enable_cache,
            max_cache_size: config.max_cache_size,
            verbose: config.verbose,
            allow_deferred: true
        )
        val provider = ObjectProvider__new(ObjectProviderConfig(
            search_paths: ["/usr/lib/simple", "/usr/local/lib/simple"],
            libraries: [],
            enable_cache: config.enable_cache,
            verbose: config.verbose
        ))
        val jit_config = JitInstantiatorConfig(
            update_smf: false,
            max_depth: 50,
            enabled: config.enable_jit,
            verbose: config.verbose
        )

        ModuleLoader(
            compiler_ctx: compiler_ctx,
            obj_taker: ObjTaker__with_compiler_context(compiler_ctx, obj_taker_config),
            provider: provider,
            jit: JitInstantiator__new(jit_config),
            loader_mapper: LoaderMapper.new(LoaderMapperConfig(
                allow_replace_on_reload: config.hot_reload
            )),
            modules: {},
            global_symbols: {},
            config: config
        )


fn moduleloader_with_defaults() -> ModuleLoader:
        """Create loader with default configuration."""
        ModuleLoader__new(ModuleLoaderConfig__default())


fn moduleloader_load(self: ModuleLoader, path: text) -> LoadResult:
        """Load an SMF module.

        If already loaded and hot_reload is disabled, returns existing module.
        If hot_reload is enabled, reloads the module.
        """
        # Check if already loaded
        if self.modules_contains_key(modules, path):
            if not self.config.hot_reload:
                return loadresult_AlreadyLoaded(module: self.modules[path])
            else:
                # Unload for reload
                moduleloader_unload(self, path)

        if self.config.verbose:
            print "[loader] Loading: {path}"

        # Prefer shared object provider so we work for .smf and .lsm inputs.
        var reader_result = self.provider.get_reader(path)
        if reader_result_is_err(reader_result):
            # Fallback to direct file reader (legacy path)
            reader_result = SmfReaderImpl__open(path)
            if reader_result_is_err(reader_result):
                return loadresult_Error(message: reader_result.unwrap_err())

        val reader = reader_result_value

        # Build loaded module
        var symbols: Dict<text, LoadedSymbol> = {}
        for smf_sym in reader.exported_symbols():
            # Read code bytes for symbol
            val code_result = reader.read_code(smf_sym)
            if code_result_is_err(code_result):
                return loadresult_Error(message: code_result.unwrap_err())

            val code = code_result_value
            # Allocate executable memory and write code
            val exec_addr = moduleloader_allocate_exec_module(self, path, smf_sym.name, code, false)
            if exec_addr == 0:
                return loadresult_Error(message: "Failed to allocate executable memory for {smf_sym.name}")

            val loaded_sym = LoadedSymbol(
                name: smf_sym.name,
                address: exec_addr,
                size: smf_sym.size,
                ty: smf_sym.ty,
                is_jit: false,
                file_offset: smf_sym.offset
            )
            symbols[smf_sym.name] = loaded_sym
            self.global_symbols[smf_sym.name] = (path, loaded_sym)

        val module = LoadedModule(
            path: path,
            reader: reader,
            symbols: symbols,
            load_time: current_time(),
            version: 1
        )

        self.modules[path] = module

        if self.config.verbose:
            print "[loader] Loaded {symbols.len()} symbols from {path}"

        loadresult_Success(module: module)


fn moduleloader_reload(self: ModuleLoader, path: text) -> LoadResult:
        """Reload a module (hot reload)."""
        moduleloader_unload(self, path)
        self.load(path)


fn moduleloader_resolve_symbol(self: ModuleLoader, name: text) -> SymbolResult:
        """Resolve a symbol, JIT-compiling if necessary."""
        # Check global symbol table
        if self.global_symbols_contains_key(global_symbols, name):
            val _destruct_0 = self.global_symbols[name]
            val symbol = _destruct_0[1]

            # Return already-installed executable symbol
            return symbolresult_Found(symbol: symbol, code: [])

        # Try JIT instantiation
        if self.config.enable_jit:
            val jit_result = self.jit_try_jit_instantiate(jit, name)
            match jit_result:
                case Success(code, sym_name, address):
                    var owner_id = "__jit__"
                    val mapped_rec = self.jit.exec_mapper.get_record(sym_name)
                    if mapped_rec.?:
                        owner_id = mapped_rec.unwrap().owner_id

                    val exec_addr = if address.?:
                        address.unwrap()
                    else:
                        moduleloader_allocate_exec_jit(self, owner_id, sym_name, code)
                    if exec_addr == 0:
                        return symbolresult_Error(message: "Failed to allocate executable memory for {sym_name}")
                    val loaded_sym = LoadedSymbol(
                        name: sym_name,
                        address: exec_addr,
                        val _as_0 = code_len(code) as i64
                        size: _as_0,
                        ty: SymbolType.Function,
                        is_jit: true,
                        file_offset: 0
                    )
                    self.global_symbols[sym_name] = (owner_id, loaded_sym)
                    return symbolresult_JitCompiled(symbol: loaded_sym, code: code)

                case NotFound(n):
                    return symbolresult_NotFound(name: n)

                case CompilationError(msg):
                    return symbolresult_Error(message: msg)

                case _:

        symbolresult_NotFound(name: name)


fn moduleloader_resolve_generic(self: ModuleLoader, name: text, type_args: [TypeInfo]) -> SymbolResult:
        """Resolve a generic symbol with explicit type arguments."""
        val mangled = mangle_name(name, type_args)

        # Check if already instantiated
        if self.global_symbols_contains_key(global_symbols, mangled):
            return self.resolve_symbol(mangled)

        # Find template in loaded modules
        for _item_1 in self.modules:
            val path = _item_1[0]
            val module = _item_1[1]
            for _item_2 in module.symbols:
                val sym_name = _item_2[0]
                val symbol = _item_2[1]
                if sym_name == name:
                    # Found template - instantiate with ObjTaker
                    val result = self.obj_taker.take_with_types(
                        module.reader,
                        name,
                        type_args
                    )
                    match result:
                        case Code(bytes, sym, _):
                            val exec_addr = moduleloader_allocate_exec_module(self, path, mangled, bytes, false)
                            if exec_addr == 0:
                                return symbolresult_Error(message: "Failed to allocate executable memory for {mangled}")
                            val loaded_sym = LoadedSymbol(
                                name: mangled,
                                address: exec_addr,
                                val _as_1 = bytes_len(bytes) as i64
                                size: _as_1,
                                ty: sym.ty,
                                is_jit: true,
                                file_offset: 0
                            )
                            self.global_symbols[mangled] = (path, loaded_sym)
                            return symbolresult_JitCompiled(symbol: loaded_sym, code: bytes)

                        case Error(msg):
                            return symbolresult_Error(message: msg)

                        case _:

        symbolresult_NotFound(name: mangled)


struct LoaderStats:
    """Loader statistics."""
    module_count: i32
    symbol_count: i32
    jit_stats: JitStats
    cache_stats: CacheStats

# ============================================================================
# Helper Functions
# ============================================================================

fn mangle_name(base: text, type_args: [TypeInfo]) -> text:
    """Mangle a generic name with type arguments."""
    if type_args_is_empty(type_args):
        return base

    val args_str = type_args.map(\t: type_to_string(t)).join("_")
    "{base}${args_str}"

extern fn rt_time_now_unix_micros() -> i64

fn current_time() -> i64:
    """Get current timestamp in microseconds."""
    rt_time_now_unix_micros()

# ============================================================================
# Internal helpers
# ============================================================================

fn moduleloader_unload(self: ModuleLoader, path: text):
    """Unload module and free executable memory."""
    if not self.modules_contains_key(modules, path):
        return

    var owned_symbols: [text] = []
    for _item in self.global_symbols:
        val sym_name = _item[0]
        val _destruct_3 = _item[1]
        val owner = _destruct_3[0]
        if owner == path:
            owned_symbols = owned_symbols.push(sym_name)

    for sym_name in owned_symbols:
        # Remove all global table entries tied to module path, including
        # generic/JIT-derived symbols that are not part of base exports.
        self.global_symbols_remove(global_symbols, sym_name)
        self.jit_drop_cached_symbol(jit, sym_name)

    _ = self.loader_mapper.unmap_owner(self.jit.exec_mapper, path)
    self.modules_remove(modules, path)

fn moduleloader_allocate_exec_module(self: ModuleLoader, owner_id: text, symbol: text, code: [u8], allow_replace: bool) -> i64:
    """Allocate executable memory and copy code."""
    val mapped = self.loader_mapper.map(self.jit.exec_mapper, owner_id, symbol, code, allow_replace)
    if mapped.is_err():
        if self.config.verbose:
            print "[loader] map_symbol failed for {symbol}: {mapped.unwrap_err()}"
        return 0
    mapped.unwrap()

fn moduleloader_allocate_exec_jit(self: ModuleLoader, owner_id: text, symbol: text, code: [u8]) -> i64:
    """Allocate executable memory for JIT fallback path via JIT mapper policy."""
    val mapped = self.jit.jit_mapper.map(self.jit.exec_mapper, owner_id, symbol, code)
    if mapped.is_err():
        if self.config.verbose:
            print "[loader] jit map failed for {symbol}: {mapped.unwrap_err()}"
        return 0
    mapped.unwrap()

# ============================================================================
# Exports
# ============================================================================

export ModuleLoader
export ModuleLoaderConfig
export LoadedModule
export LoadedSymbol
export LoadResult
export SymbolResult
export LoaderStats
export mangle_name
