# Module Loader Library Support - SmfGetter integration
#
# This module extends ModuleLoader with support for loading SMF modules
# from library archives (.lsm) in addition to single files (.smf).
#
# Usage:
#   var loader = ModuleLoader.with_lib_support()
#   loader.add_library("/usr/lib/simple/libstd.lsm")
#   loader.load_module("std/io/mod")

use compiler.linker.smf_getter.{SmfGetter, SmfSourceType}
use compiler.linker.smf_reader_memory.{SmfReaderMemory}
use ..loader.compiler_ffi.*
use ..linker.obj_taker.*
use ..linker.smf_reader.*
use .jit_instantiator.*

# Import base module loader types
# Note: Can't use wildcard import, so we redefine what we need

# ============================================================================
# Enhanced Module Loader with Library Support
# ============================================================================

"""Configuration for library-aware module loader."""
struct ModuleLoaderLibConfig:
    enable_jit: bool
    enable_cache: bool
    max_cache_size: i32
    verbose: bool
    hot_reload: bool
    # Library-specific settings
    enable_libraries: bool
    library_search_paths: [text]
    auto_scan_libraries: bool

impl ModuleLoaderLibConfig:
    static fn default() -> ModuleLoaderLibConfig:
        ModuleLoaderLibConfig(
            enable_jit: true,
            enable_cache: true,
            max_cache_size: 100,
            verbose: false,
            hot_reload: false,
            enable_libraries: true,
            library_search_paths: [
                "/usr/lib/simple",
                "/usr/local/lib/simple"
            ],
            auto_scan_libraries: false
        )

    static fn with_libraries(search_paths: [text]) -> ModuleLoaderLibConfig:
        """Create config with custom library search paths."""
        var config = ModuleLoaderLibConfig__default()
        config.library_search_paths = search_paths
        config.enable_libraries = true
        config

"""Enhanced module loader with library support."""
struct ModuleLoaderWithLibs:
    # SMF getter for unified module loading
    smf_getter: SmfGetter
    # Shared compiler context (FFI handle)
    compiler_ctx: CompilerContext
    # ObjTaker for extraction and instantiation
    obj_taker: ObjTaker
    # JIT instantiator
    jit: JitInstantiator
    # Loaded modules cache: path -> (reader, symbols)
    modules: Dict<text, (SmfReaderMemory, Dict<text, SmfSymbol>)>
    # Configuration
    config: ModuleLoaderLibConfig

impl ModuleLoaderWithLibs:
    """Create a new library-aware module loader."""
    static fn new(config: ModuleLoaderLibConfig) -> ModuleLoaderWithLibs:
        # Create SMF getter
        var getter = SmfGetter__new()
        getter.set_verbose(config.verbose)

        # Add search paths
        for path in config.library_search_paths:
            getter.add_search_path(path)

        # Scan for libraries if enabled
        if config.auto_scan_libraries:
            var _ = getter.scan_search_paths()

        # Create compiler context
        val compiler_ctx = CompilerContext__create()

        # Create obj taker
        val obj_taker_config = ObjTakerConfig(
            enable_caching: config.enable_cache,
            max_cache_size: config.max_cache_size,
            verbose: config.verbose,
            allow_deferred: true
        )

        # Create JIT instantiator
        val jit_config = JitInstantiatorConfig(
            update_smf: false,
            max_depth: 50,
            enabled: config.enable_jit,
            verbose: config.verbose
        )

        ModuleLoaderWithLibs(
            smf_getter: getter,
            compiler_ctx: compiler_ctx,
            obj_taker: ObjTaker__with_compiler_context(compiler_ctx, obj_taker_config),
            jit: JitInstantiator__new(jit_config),
            modules: {},
            config: config
        )

    """Create loader with default configuration."""
    static fn with_defaults() -> ModuleLoaderWithLibs:
        ModuleLoaderWithLibs__new(ModuleLoaderLibConfig__default())

    # ========================================================================
    # Library Management
    # ========================================================================

    """Add a library archive to the loader.

    Args:
        lib_path: Path to .lsm library file

    Returns:
        Result indicating success or error
    """
    me add_library(lib_path: text) -> Result<(), text>:
        if self.config.verbose:
            print "[loader-lib] Adding library: {lib_path}"

        self.smf_getter.add_library(lib_path)

    """Add a search path for finding modules and libraries.

    Args:
        path: Directory path to search
    """
    me add_search_path(path: text):
        if self.config.verbose:
            print "[loader-lib] Adding search path: {path}"

        self.smf_getter.add_search_path(path)

    """List all available modules (from files and libraries)."""
    fn list_available_modules() -> [text]:
        self.smf_getter.list_modules()

    """Check if a module is available."""
    fn has_module(module_name: text) -> bool:
        self.smf_getter.has_module(module_name)

    # ========================================================================
    # Module Loading
    # ========================================================================

    """Load a module from single file or library.

    Args:
        module_name: Module path (e.g., "std/io/mod")

    Returns:
        Result with loaded module or error
    """
    me load_module(module_name: text) -> Result<SmfReaderMemory, text>:
        # Check if already loaded
        if self.modules.contains_key(module_name):
            if not self.config.hot_reload:
                val (reader, _) = self.modules[module_name]
                if self.config.verbose:
                    print "[loader-lib] Module already loaded: {module_name}"
                return Ok(reader)
            else:
                # Unload for hot reload
                self.unload_module(module_name)

        if self.config.verbose:
            print "[loader-lib] Loading module: {module_name}"

        # Get SMF data from getter (handles both files and libraries)
        val smf_data_result = self.smf_getter.get(module_name)
        if smf_data_result.is_err():
            return Err(smf_data_result.unwrap_err())

        val smf_data = smf_data_result.unwrap()

        # Get location info for logging
        val location_result = self.smf_getter.get_location(module_name)
        if location_result.is_ok():
            val location = location_result.unwrap()
            match location.source_type:
                case SmfSourceType.SingleFile:
                    if self.config.verbose:
                        print "[loader-lib] Loaded from file: {location.file_path}"
                case SmfSourceType.LibraryFile:
                    if self.config.verbose:
                        print "[loader-lib] Loaded from library: {location.file_path}"

        # Create reader from in-memory data
        val reader_result = SmfReaderMemory__from_data(smf_data)
        if reader_result.is_err():
            return Err(reader_result.unwrap_err())

        val reader = reader_result.unwrap()

        # Get symbols
        val symbols_dict = reader.symbols

        # Cache the loaded module
        self.modules[module_name] = (reader, symbols_dict)

        if self.config.verbose:
            print "[loader-lib] Loaded {symbols_dict.len()} symbols from {module_name}"

        Ok(reader)

    """Unload a module."""
    me unload_module(module_name: text):
        if self.modules.contains_key(module_name):
            # Memory reader doesn't need explicit close
            self.modules = self.modules.remove(module_name)

            if self.config.verbose:
                print "[loader-lib] Unloaded: {module_name}"

    # ========================================================================
    # Utility Methods
    # ========================================================================

    """Get module source information."""
    fn get_module_source(module_name: text) -> Result<text, text>:
        val location_result = self.smf_getter.get_location(module_name)
        if location_result.is_err():
            return Err("Module not found: {module_name}")

        val location = location_result.unwrap()
        match location.source_type:
            case SmfSourceType.SingleFile:
                Ok("file: {location.file_path}")
            case SmfSourceType.LibraryFile:
                Ok("library: {location.file_path} (offset: {location.offset})")

# ============================================================================
# Helper Functions
# ============================================================================

"""Create a loader with standard system libraries.

Returns:
    ModuleLoaderWithLibs configured with system libraries
"""
fn create_loader_with_stdlib() -> ModuleLoaderWithLibs:
    var config = ModuleLoaderLibConfig__default()
    config.library_search_paths = [
        "/usr/lib/simple",
        "/usr/local/lib/simple",
        "/opt/simple/lib"
    ]

    var loader = ModuleLoaderWithLibs__new(config)

    # Try to add standard library (ignore if not found)
    var _ = loader.add_library("/usr/lib/simple/libstd.lsm")
    var _ = loader.add_library("/usr/local/lib/simple/libstd.lsm")

    loader

# ============================================================================
# Exports
# ============================================================================

export ModuleLoaderWithLibs
export ModuleLoaderLibConfig
export create_loader_with_stdlib
