# HIR Definitions - HIR Node Definitions
#
# This module contains all HIR node type definitions:
# - Function, class, struct, enum, trait definitions
# - Expression types and operators
# - Pattern types
# - Statement types

use hir_types.*
use lexer.Span
use blocks.value.BlockValue
use type_layout.LayoutAttr

# ============================================================================
# HIR Definitions
# ============================================================================

struct HirFunction:
    """Function definition in HIR."""
    symbol: SymbolId
    name: text
    type_params: [HirTypeParam]
    params: [HirParam]
    return_type: HirType
    body: HirBlock
    effects: [Effect]
    is_async: bool
    is_static: bool
    is_public: bool
    is_method: bool
    is_mutable: bool        # 'me' method
    is_const: bool          # 'const fn' - can be evaluated at compile time
    doc_comment: text?
    span: Span

struct HirTypeParam:
    """Generic type parameter."""
    symbol: SymbolId
    name: text
    bounds: [HirType]
    default: HirType?
    span: Span

struct HirParam:
    """Function parameter."""
    symbol: SymbolId
    name: text
    type_: HirType
    default: HirExpr?
    span: Span

struct HirClass:
    """Class definition in HIR."""
    symbol: SymbolId
    name: text
    type_params: [HirTypeParam]
    fields: [HirField]
    methods: Dict<text, SymbolId>
    is_public: bool
    doc_comment: text?
    span: Span
    layout_attr: LayoutAttr?    # Memory layout attributes (@repr, @packed, @align)

    # Generic template metadata for .smf template storage
    is_generic_template: bool
    specialization_of: text?
    type_bindings: Dict<text, HirType>

struct HirStruct:
    """Struct definition in HIR."""
    symbol: SymbolId
    name: text
    type_params: [HirTypeParam]
    fields: [HirField]
    is_public: bool
    doc_comment: text?
    span: Span
    layout_attr: LayoutAttr?    # Memory layout attributes (@repr, @packed, @align)

    # Generic template metadata for .smf template storage
    is_generic_template: bool
    specialization_of: text?
    type_bindings: Dict<text, HirType>

struct HirField:
    """Struct/class field."""
    symbol: SymbolId
    name: text
    type_: HirType
    default: HirExpr?
    is_public: bool
    span: Span

struct HirEnum:
    """Enum definition in HIR."""
    symbol: SymbolId
    name: text
    type_params: [HirTypeParam]
    variants: [HirVariant]
    is_public: bool
    doc_comment: text?
    span: Span

    # Generic template metadata for .smf template storage
    is_generic_template: bool
    specialization_of: text?
    type_bindings: Dict<text, HirType>

struct HirVariant:
    """Enum variant."""
    symbol: SymbolId
    name: text
    kind: HirVariantKind
    span: Span

"""Enum variant kind."""
enum HirVariantKind:
    Unit
    Tuple(types: [HirType])
    Struct(fields: [HirField])

struct HirTraitBound:
    """Trait bound constraint: T: Trait

    Used in:
    - Function signatures: fn foo<T: Display>(x: T)
    - Where clauses: fn foo<T>(x: T) where T: Clone
    - Trait definitions: trait Ord: Eq
    - Impl blocks: impl<T: Clone> Clone for Vec<T>
    """
    type_param: SymbolId            # Type parameter being constrained
    trait_: HirType                 # Trait that must be implemented
    span: Span

struct HirTrait:
    """Trait definition in HIR.

    Example:
        trait Display:
            fn to_string() -> text

        trait Ord: Eq:  # Supertrait
            fn cmp(other: Self) -> Ordering
            fn max(other: Self) -> Self:  # Default implementation
                if self.cmp(other) == Greater: self else: other
    """
    symbol: SymbolId
    name: text
    type_params: [HirTypeParam]
    methods: [HirFunction]          # Required method signatures
    supertraits: [HirType]          # Trait: Supertrait bounds
    defaults: [HirFunction]         # Default method implementations
    where_clause: [HirTraitBound]   # Where clauses on the trait
    is_public: bool
    doc_comment: text?
    span: Span

    # Generic template metadata for .smf template storage
    is_generic_template: bool
    specialization_of: text?
    type_bindings: Dict<text, HirType>

struct HirImpl:
    """Impl block in HIR.

    Examples:
        # Inherent impl (no trait)
        impl Point:
            fn new(x: i64, y: i64) -> Point: ...

        # Trait impl
        impl Display for Point:
            fn to_string() -> text: ...

        # Generic impl with where clause
        impl<T> Display for Vec<T> where T: Display:
            fn to_string() -> text: ...
    """
    type_: HirType                  # Type being implemented for
    trait_: HirType?                # Trait being implemented (None for inherent impl)
    type_params: [HirTypeParam]     # Generic parameters (impl<T>)
    where_clause: [HirTraitBound]   # Where T: Trait constraints
    methods: Dict<text, SymbolId>   # Method name â†’ symbol
    span: Span

struct HirConst:
    """Module-level constant."""
    symbol: SymbolId
    name: text
    type_: HirType
    value: HirExpr
    is_mutable: bool
    is_public: bool
    span: Span

struct HirStaticAssert:
    """Static assertion - evaluated at compile time.

    Example:
        static assert size_of<u32>() == 4
        static assert align_of<Point>() >= 4, "Point must be 4-byte aligned"

    The condition must be a constant expression that evaluates to bool.
    If the condition is false, compilation fails with the optional message.
    """
    condition: HirExpr          # Must be a compile-time constant bool expression
    message: text?              # Optional error message on failure
    span: Span

# ============================================================================
# HIR Expressions
# ============================================================================

struct HirExpr:
    """Expression in HIR."""
    kind: HirExprKind
    type_: HirType?         # Resolved type (filled during type checking)
    span: Span

"""Expression kind."""
enum HirExprKind:
    # Literals
    IntLit(value: i64, suffix: text?)
    FloatLit(value: f64, suffix: text?)
    StringLit(value: text, interpolations: [HirInterpolation]?)
    BoolLit(value: bool)
    CharLit(value: char)
    UnitLit
    NilLit

    # Collections
    ArrayLit(elements: [HirExpr], type_: HirType?)
    TupleLit(elements: [HirExpr])
    DictLit(entries: [(HirExpr, HirExpr)], key_type: HirType?, value_type: HirType?)

    # Variables and access
    Var(symbol: SymbolId)
    Field(base: HirExpr, field: text, resolved: SymbolId?)
    Index(base: HirExpr, index: HirExpr)
    TupleIndex(base: HirExpr, index: i64)

    # Optional operations
    OptionalChain(base: HirExpr, field: text)
    NullCoalesce(left: HirExpr, right: HirExpr)
    ExistsCheck(base: HirExpr)
    Unwrap(base: HirExpr)           # expr!

    # Operators
    Binary(op: HirBinOp, left: HirExpr, right: HirExpr)
    Unary(op: HirUnaryOp, operand: HirExpr)

    # Calls
    Call(callee: HirExpr, args: [HirCallArg], type_args: [HirType])
    MethodCall(receiver: HirExpr, method: text, args: [HirCallArg], resolution: MethodResolution)
    StaticCall(type_: HirType, method: text, args: [HirCallArg], resolution: MethodResolution)

    # Control flow
    If(cond: HirExpr, then_: HirBlock, else_: HirBlock?)
    Match(scrutinee: HirExpr, arms: [HirMatchArm])
    Loop(body: HirBlock, label: text?)
    While(cond: HirExpr, body: HirBlock, label: text?)
    For(var_: SymbolId, iter: HirExpr, body: HirBlock, label: text?)

    # Closures
    Lambda(params: [HirParam], body: HirExpr, captures: [SymbolId])
    Block(block: HirBlock)

    # Control transfer
    Return(value: HirExpr?)
    Break(label: text?, value: HirExpr?)
    Continue(label: text?)
    Throw(value: HirExpr)
    Try(expr: HirExpr)              # expr?

    # Async
    Await(expr: HirExpr)
    Yield(value: HirExpr?)

    # Construction
    StructLit(type_: HirType, fields: [(text, HirExpr)])
    EnumLit(type_: HirType, variant: text, payload: HirEnumPayload?)

    # Casts and conversions
    Cast(expr: HirExpr, target: HirType)
    As(expr: HirExpr, target: HirType)      # Safe cast (returns Option)

    # Special
    Range(start: HirExpr?, end: HirExpr?, inclusive: bool, step: HirExpr?)
    Comprehension(kind: HirComprehensionKind, expr: HirExpr, clauses: [HirCompClause])

    # Custom blocks (user-defined: sh{}, sql{}, re{}, etc.)
    CustomBlock(kind: text, value: BlockValue)

    # Math/DL blocks (built-in with special semantics)
    LossBlock(body: HirBlock)           # loss{ ... } - autograd + auto-backward
    NogradBlock(body: HirBlock)         # nograd{ ... } - disable gradients

    # Error recovery
    Error

struct HirInterpolation:
    """String interpolation."""
    expr: HirExpr
    format: text?
    span: Span

struct HirCallArg:
    """Function call argument."""
    name: text?
    value: HirExpr
    span: Span

struct HirMatchArm:
    """Match arm."""
    pattern: HirPattern
    guard: HirExpr?
    body: HirBlock
    span: Span

"""Enum construction payload."""
enum HirEnumPayload:
    Tuple(values: [HirExpr])
    Struct(fields: [(text, HirExpr)])

"""Comprehension kind."""
enum HirComprehensionKind:
    List
    Dict
    Set
    Generator

struct HirCompClause:
    """Comprehension clause."""
    kind: HirCompClauseKind
    span: Span

"""Comprehension clause kind."""
enum HirCompClauseKind:
    For(var_: SymbolId, iter: HirExpr)
    If(cond: HirExpr)

# ============================================================================
# HIR Operators
# ============================================================================

"""Binary operator."""
enum HirBinOp:
    # Arithmetic
    Add, Sub, Mul, Div, Mod, Pow

    # Matrix operations
    MatMul              # @

    # Comparison
    Eq, NotEq, Lt, LtEq, Gt, GtEq

    # Logical
    And, Or

    # Bitwise
    BitAnd, BitOr, BitXor, Shl, Shr

    # Broadcast operations (dotted operators)
    BroadcastAdd        # .+
    BroadcastSub        # .-
    BroadcastMul        # .*
    BroadcastDiv        # ./
    BroadcastPow        # .^

    # Pipeline/Composition operators
    PipeForward         # |>
    Compose             # >>
    ComposeBack         # <<
    Parallel            # //
    LayerConnect        # ~>

    # Other
    In, NotIn
    Is, IsNot
    Concat         # ++

"""Unary operator."""
enum HirUnaryOp:
    Neg            # -
    Not            # not, !
    BitNot         # ~
    Ref            # &
    RefMut         # &mut
    Deref          # *
    Transpose      # ' (postfix, m{} only)

# ============================================================================
# HIR Patterns
# ============================================================================

struct HirPattern:
    """Pattern in HIR."""
    kind: HirPatternKind
    type_: HirType?
    span: Span

"""Pattern kind."""
enum HirPatternKind:
    Wildcard
    Literal(value: HirExpr)
    Binding(symbol: SymbolId, mutable: bool)
    Tuple(elements: [HirPattern])
    Array(elements: [HirPattern], rest: SymbolId?)
    Struct(type_: HirType, fields: [(text, HirPattern)])
    Enum(type_: HirType, variant: text, payload: HirPatternPayload?)
    Or(patterns: [HirPattern])
    Range(start: HirExpr?, end: HirExpr?, inclusive: bool)
    Error

"""Enum pattern payload."""
enum HirPatternPayload:
    Tuple(patterns: [HirPattern])
    Struct(fields: [(text, HirPattern)])

# ============================================================================
# HIR Statements
# ============================================================================

struct HirStmt:
    """Statement in HIR."""
    kind: HirStmtKind
    span: Span

"""Statement kind."""
enum HirStmtKind:
    Expr(expr: HirExpr)
    Let(symbol: SymbolId, type_: HirType?, init: HirExpr)
    Assign(target: HirExpr, op: HirAssignOp?, value: HirExpr)
    Block(block: HirBlock)

"""Compound assignment operator."""
enum HirAssignOp:
    Add, Sub, Mul, Div, Mod
    BitAnd, BitOr, BitXor, Shl, Shr

struct HirBlock:
    """Block of statements."""
    stmts: [HirStmt]
    value: HirExpr?     # Final expression (for block expressions)
    span: Span

# ============================================================================
# Exports
# ============================================================================

export HirFunction, HirTypeParam, HirParam
export HirClass, HirStruct, HirField
export HirEnum, HirVariant, HirVariantKind
export HirTrait, HirImpl, HirConst, HirStaticAssert
export HirExpr, HirExprKind, HirInterpolation, HirCallArg, HirMatchArm
export HirEnumPayload, HirComprehensionKind, HirCompClause, HirCompClauseKind
export HirBinOp, HirUnaryOp
export HirPattern, HirPatternKind, HirPatternPayload
export HirStmt, HirStmtKind, HirAssignOp, HirBlock
