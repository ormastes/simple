# Strength Reduction
#
# Replaces expensive operations with cheaper ones in loops.
#
# Example transformations:
#   - i * 4 -> i << 2 (multiply by power of 2)
#   - i * c -> i + i + ... (multiply by small constant)
#   - i / 2 -> i >> 1 (divide by power of 2)
#
# Most impactful in loop bodies where operation repeats.

use compiler.mir_data.*
use compiler.mir.*

# ============================================================================
# Strength Reduction
# ============================================================================

class StrengthReduction:
    """
    Replaces expensive operations with cheaper ones in loops.

    Example transformations:
    - i * 4 -> i << 2 (multiply by power of 2)
    - i * c -> i + i + ... (multiply by small constant)
    - i / 2 -> i >> 1 (divide by power of 2)

    Most impactful in loop bodies where operation repeats.
    """
    reduced_count: i64

impl StrengthReduction:
    static fn new() -> StrengthReduction:
        StrengthReduction(reduced_count: 0)

    me optimize_function(func: MirFunction) -> MirFunction:
        """Run strength reduction on function."""
        var optimized_blocks: [MirBlock] = []

        for block in func.blocks:
            val optimized = self.reduce_block(block)
            optimized_blocks = optimized_blocks.push(optimized)

        copy_mir_function_with_blocks(func, optimized_blocks)

    me reduce_block(block: MirBlock) -> MirBlock:
        """Apply strength reduction to block."""
        var reduced_instructions: [MirInst] = []

        for inst in block.instructions:
            val reduced = self.try_reduce_instruction(inst)
            reduced_instructions = reduced_instructions.push(reduced)

        MirBlock(
            id: block.id,
            label: block.label,
            instructions: reduced_instructions,
            terminator: block.terminator
        )

    me try_reduce_instruction(inst: MirInst) -> MirInst:
        """Try to apply strength reduction to instruction."""
        match inst.kind:
            case BinOp(dest, op, left, right):
                # Try to reduce expensive binary operations
                val reduced = self.try_reduce_binop(dest, op, left, right, inst.span)
                if reduced.?:
                    self.reduced_count = self.reduced_count + 1
                    return reduced.unwrap()
                inst

            case _:
                # No reduction possible
                inst

    fn try_reduce_binop(
        dest: LocalId,
        op: MirBinOp,
        left: MirOperand,
        right: MirOperand,
        span: Span
    ) -> MirInst?:
        """
        Try to reduce binary operation.

        Patterns:
        - x * 0 -> 0 (identity)
        - x * 1 -> x (identity)
        - x * 2^n -> x << n (shift)
        - x / 1 -> x (identity)
        - x / 2^n -> x >> n (shift, unsigned)
        - x % 1 -> 0 (identity)
        - x % 2^n -> x & (2^n - 1) (bitmask)
        - x + 0 -> x, x - 0 -> x (identity)
        """
        match op:
            case Mul:
                # Check for multiply by constant on right
                val right_const = self.operand_const_int_value(right)
                if right_const.?:
                    val rv = right_const.unwrap()
                    # x * 0 -> 0
                    if rv == 0:
                        return MirInst(
                            kind: MirInstKind.Const(dest, MirConstValue.Int(0), MirType.i64()),
                            span: span
                        )
                    # x * 1 -> x (copy)
                    if rv == 1:
                        return self.copy_operand_to_dest(dest, left, span)

                # Check for multiply by constant on left
                val left_const = self.operand_const_int_value(left)
                if left_const.?:
                    val lv = left_const.unwrap()
                    # 0 * x -> 0
                    if lv == 0:
                        return MirInst(
                            kind: MirInstKind.Const(dest, MirConstValue.Int(0), MirType.i64()),
                            span: span
                        )
                    # 1 * x -> x (copy)
                    if lv == 1:
                        return self.copy_operand_to_dest(dest, right, span)

                # Power-of-2 multiply -> shift left
                val shift = self.const_log2(right)
                if shift.?:
                    return MirInst(
                        kind: MirInstKind.BinOp(dest, MirBinOp.Shl, left, mir_operand_const_int(shift.unwrap())),
                        span: span
                    )
                val shift_l = self.const_log2(left)
                if shift_l.?:
                    return MirInst(
                        kind: MirInstKind.BinOp(dest, MirBinOp.Shl, right, mir_operand_const_int(shift_l.unwrap())),
                        span: span
                    )
                nil
            case Div:
                val right_const = self.operand_const_int_value(right)
                if right_const.?:
                    val rv = right_const.unwrap()
                    # x / 1 -> x
                    if rv == 1:
                        return self.copy_operand_to_dest(dest, left, span)

                # x / 2^n -> x >> n (for positive divisors)
                val shift = self.const_log2(right)
                if shift.?:
                    return MirInst(
                        kind: MirInstKind.BinOp(dest, MirBinOp.Shr, left, mir_operand_const_int(shift.unwrap())),
                        span: span
                    )
                nil
            case Rem:
                val right_const = self.operand_const_int_value(right)
                if right_const.?:
                    val rv = right_const.unwrap()
                    # x % 1 -> 0
                    if rv == 1:
                        return MirInst(
                            kind: MirInstKind.Const(dest, MirConstValue.Int(0), MirType.i64()),
                            span: span
                        )

                # x % 2^n -> x & (2^n - 1) (for positive values)
                val shift = self.const_log2(right)
                if shift.?:
                    val mask = (1 << shift.unwrap()) - 1
                    return MirInst(
                        kind: MirInstKind.BinOp(dest, MirBinOp.BitAnd, left, mir_operand_const_int(mask)),
                        span: span
                    )
                nil
            case Add:
                # x + 0 -> x
                val right_const = self.operand_const_int_value(right)
                if right_const.? and right_const.unwrap() == 0:
                    return self.copy_operand_to_dest(dest, left, span)
                val left_const = self.operand_const_int_value(left)
                if left_const.? and left_const.unwrap() == 0:
                    return self.copy_operand_to_dest(dest, right, span)
                nil
            case Sub:
                # x - 0 -> x
                val right_const = self.operand_const_int_value(right)
                if right_const.? and right_const.unwrap() == 0:
                    return self.copy_operand_to_dest(dest, left, span)
                nil
            case _:
                nil

    fn operand_const_int_value(op: MirOperand) -> i64?:
        """Extract constant integer value from operand."""
        match op.kind:
            case Const(value, _):
                match value:
                    case Int(n): Some(n)
                    case _: nil
            case _: nil

    fn copy_operand_to_dest(dest: LocalId, op: MirOperand, span: Span) -> MirInst?:
        """Create a copy/move/const instruction from operand to dest."""
        match op.kind:
            case Copy(src):
                Some(MirInst(kind: MirInstKind.Copy(dest, src), span: span))
            case Move(src):
                Some(MirInst(kind: MirInstKind.Move(dest, src), span: span))
            case Const(value, type_):
                Some(MirInst(kind: MirInstKind.Const(dest, value, type_), span: span))

    fn const_log2(operand: MirOperand) -> i64?:
        """Check if operand is a constant power of 2, return log2 if so."""
        match operand.kind:
            case Const(const_val, _):
                match const_val:
                    case Int(n):
                        if n > 0:
                            # Check if n is a power of 2: n & (n-1) == 0
                            val is_pow2 = (n & (n - 1)) == 0
                            if is_pow2:
                                # Calculate log2 by checking bit positions
                                var shift = 0
                                for bit in 0..31:
                                    if (1 << bit) == n:
                                        shift = bit
                                return shift
                            nil
                        else:
                            nil
                    case _: nil
            case _: nil

# ============================================================================
# Exports
# ============================================================================

export StrengthReduction
