# SIMD Lowering Pass
#
# Lowers high-level SIMD intrinsic calls to low-level MIR SIMD instructions.
# Transforms calls to std.simd functions into SimdXXX MIR instructions.
#
# Example transformation:
#   Call(dest: r1, func: rt_simd_add_f32x4, args: [a, b])
#   -> SimdAddF32x4(dest: r1, a: Copy(a), b: Copy(b))
#
# This pass runs after MIR construction but before optimization passes,
# allowing SIMD operations to participate in CSE, constant folding, etc.

use compiler.mir_data.{MirModule, MirFunction, MirBlock, MirInst, MirInstKind, MirOperand, MirOperandKind, LocalId, BlockId, copy_mir_function_with_blocks}

# ============================================================================
# SIMD Lowering Pass
# ============================================================================

fn run_simd_lowering(module: MirModule) -> MirModule:
    """
    Run SIMD lowering pass on entire module.
    Transforms intrinsic calls to SIMD MIR instructions.
    """
    var new_functions: Dict<SymbolId, MirFunction> = {}

    for symbol_id in module.functions.keys():
        val func = module.functions[symbol_id]
        val lowered_func = lower_function_simd(func)
        new_functions[symbol_id] = lowered_func

    MirModule(
        name: module.name,
        functions: new_functions,
        statics: module.statics,
        constants: module.constants,
        types: module.types
    )

fn lower_function_simd(func: MirFunction) -> MirFunction:
    """Lower SIMD intrinsics in a single function."""
    var new_blocks: [MirBlock] = []

    for block in func.blocks:
        val lowered_block = lower_block_simd(block)
        new_blocks = new_blocks + [lowered_block]

    copy_mir_function_with_blocks(func, new_blocks)

fn lower_block_simd(block: MirBlock) -> MirBlock:
    """Lower SIMD intrinsics in a single basic block."""
    var new_insts: [MirInst] = []

    for inst in block.instructions:
        match inst.kind:
            case Call(dest, func, args):
                # Check if this is a SIMD intrinsic call
                val lowered = try_lower_simd_call(dest, func, args)
                if lowered.is_some():
                    val simd_inst = MirInst(
                        kind: lowered.unwrap(),
                        span: inst.span
                    )
                    new_insts = new_insts + [simd_inst]
                else:
                    # Not a SIMD intrinsic, keep original
                    new_insts = new_insts + [inst]

            case _:
                # Not a call instruction, keep as-is
                new_insts = new_insts + [inst]

    MirBlock(
        id: block.id,
        label: block.label,
        instructions: new_insts,
        terminator: block.terminator
    )

fn try_lower_simd_call(dest: LocalId?, func: MirOperand, args: [MirOperand]) -> MirInstKind?:
    """
    Try to lower a function call to a SIMD MIR instruction.
    Returns nil if not a SIMD intrinsic.
    """
    # Extract function name from operand
    val func_name = extract_function_name(func)
    if func_name.is_none():
        return nil

    val name = func_name.unwrap()

    # Must have a destination for SIMD ops (they all return values)
    if dest.is_none():
        return nil

    val d = dest.unwrap()

    # Match SIMD intrinsic names and lower to appropriate MIR instruction
    # f32x4 (128-bit)
    if name == "rt_simd_add_f32x4" and args.len() == 2:
        return MirInstKind.SimdAddF32x4(d, args[0], args[1])
    elif name == "rt_simd_sub_f32x4" and args.len() == 2:
        return MirInstKind.SimdSubF32x4(d, args[0], args[1])
    elif name == "rt_simd_mul_f32x4" and args.len() == 2:
        return MirInstKind.SimdMulF32x4(d, args[0], args[1])
    elif name == "rt_simd_div_f32x4" and args.len() == 2:
        return MirInstKind.SimdDivF32x4(d, args[0], args[1])
    elif name == "rt_simd_fma_f32x4" and args.len() == 3:
        return MirInstKind.SimdFmaF32x4(d, args[0], args[1], args[2])

    # f32x8 (256-bit)
    elif name == "rt_simd_add_f32x8" and args.len() == 2:
        return MirInstKind.SimdAddF32x8(d, args[0], args[1])
    elif name == "rt_simd_sub_f32x8" and args.len() == 2:
        return MirInstKind.SimdSubF32x8(d, args[0], args[1])
    elif name == "rt_simd_mul_f32x8" and args.len() == 2:
        return MirInstKind.SimdMulF32x8(d, args[0], args[1])
    elif name == "rt_simd_div_f32x8" and args.len() == 2:
        return MirInstKind.SimdDivF32x8(d, args[0], args[1])
    elif name == "rt_simd_fma_f32x8" and args.len() == 3:
        return MirInstKind.SimdFmaF32x8(d, args[0], args[1], args[2])

    # f64x4 (256-bit)
    elif name == "rt_simd_add_f64x4" and args.len() == 2:
        return MirInstKind.SimdAddF64x4(d, args[0], args[1])
    elif name == "rt_simd_sub_f64x4" and args.len() == 2:
        return MirInstKind.SimdSubF64x4(d, args[0], args[1])
    elif name == "rt_simd_mul_f64x4" and args.len() == 2:
        return MirInstKind.SimdMulF64x4(d, args[0], args[1])
    elif name == "rt_simd_div_f64x4" and args.len() == 2:
        return MirInstKind.SimdDivF64x4(d, args[0], args[1])
    elif name == "rt_simd_fma_f64x4" and args.len() == 3:
        return MirInstKind.SimdFmaF64x4(d, args[0], args[1], args[2])

    # i32x4 (128-bit)
    elif name == "rt_simd_add_i32x4" and args.len() == 2:
        return MirInstKind.SimdAddI32x4(d, args[0], args[1])
    elif name == "rt_simd_sub_i32x4" and args.len() == 2:
        return MirInstKind.SimdSubI32x4(d, args[0], args[1])
    elif name == "rt_simd_mul_i32x4" and args.len() == 2:
        return MirInstKind.SimdMulI32x4(d, args[0], args[1])

    # i32x8 (256-bit)
    elif name == "rt_simd_add_i32x8" and args.len() == 2:
        return MirInstKind.SimdAddI32x8(d, args[0], args[1])
    elif name == "rt_simd_sub_i32x8" and args.len() == 2:
        return MirInstKind.SimdSubI32x8(d, args[0], args[1])
    elif name == "rt_simd_mul_i32x8" and args.len() == 2:
        return MirInstKind.SimdMulI32x8(d, args[0], args[1])

    # Horizontal operations
    elif name == "rt_simd_hadd_f32x4" and args.len() == 1:
        return MirInstKind.SimdHaddF32x4(d, args[0])
    elif name == "rt_simd_hmax_f32x4" and args.len() == 1:
        return MirInstKind.SimdHmaxF32x4(d, args[0])
    elif name == "rt_simd_hmin_f32x4" and args.len() == 1:
        return MirInstKind.SimdHminF32x4(d, args[0])

    # Not a SIMD intrinsic
    else:
        return nil

fn extract_function_name(operand: MirOperand) -> text?:
    """
    Extract function name from a MirOperand.
    Returns nil if operand doesn't represent a named function.
    """
    match operand.kind:
        case Const(value, _):
            # Check if constant is a function reference
            # This would need to inspect the constant value to extract name
            # For now, simplified implementation
            nil

        case Copy(local):
            # Local might be a function pointer, but we need symbol table
            # to resolve the name. Simplified for now.
            nil

        case _:
            nil

# Alternative: Pattern matching on Intrinsic instruction instead of Call
# This is cleaner if HIR->MIR lowering already marks SIMD calls as Intrinsic

fn try_lower_simd_intrinsic(dest: LocalId?, name: text, args: [MirOperand]) -> MirInstKind?:
    """
    Lower a MirInstKind.Intrinsic to a SIMD MIR instruction.
    Used if HIR lowering already identifies SIMD operations as intrinsics.
    """
    if dest.is_none():
        return nil

    val d = dest.unwrap()

    # Same matching logic as try_lower_simd_call
    if name == "simd_add_f32x4" and args.len() == 2:
        return MirInstKind.SimdAddF32x4(d, args[0], args[1])
    elif name == "simd_sub_f32x4" and args.len() == 2:
        return MirInstKind.SimdSubF32x4(d, args[0], args[1])
    elif name == "simd_mul_f32x4" and args.len() == 2:
        return MirInstKind.SimdMulF32x4(d, args[0], args[1])
    # ... (continue pattern for all SIMD ops)
    else:
        nil

# ============================================================================
# Exports
# ============================================================================

export run_simd_lowering
export lower_function_simd
export lower_block_simd
