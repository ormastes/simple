# Copy Propagation
#
# Replaces uses of copied values with the original source value.
#
# Transformation:
#   val x = 42
#   val y = x      # Copy
#   val z = y + 1  # Use of copy
#
# After:
#   val x = 42
#   val z = x + 1  # Direct use of original
#
# Benefits:
# - Eliminates redundant copies
# - Simplifies SSA chains
# - Enables further optimization (DCE can remove unused copies)
# - Reduces register pressure
#
# Algorithm:
# 1. Build copy chains (x -> y -> z)
# 2. For each use, replace with root of chain
# 3. Mark copies as dead (DCE will remove)

use compiler.mir.mir_data.*
use compiler.mir.mir.*
use compiler.mir_opt.mod.{MirPass}

# ============================================================================
# Copy Chain Analysis
# ============================================================================

class CopyChain:
    """
    Tracks copy relationships between locals.

    Example:
      val a = 42
      val b = a    # b copies a
      val c = b    # c copies b (transitively copies a)

    Chain: c -> b -> a (root: a)
    """
    # Maps each local to its copy source
    copy_map: Dict<i64, LocalId>  # LocalId.id -> source LocalId


# ============================================================================
# CopyChain Methods (was: impl CopyChain:)
# ============================================================================

fn copychain_new() -> CopyChain:
        CopyChain(copy_map: {})


# ============================================================================
# Copy Propagation Pass
# ============================================================================

class CopyPropagation:
    """
    Copy propagation optimization pass.

    Process:
    1. Scan for copy instructions (Copy, Move with same source)
    2. Build copy chains
    3. Replace uses with root values
    4. Let DCE eliminate dead copies
    """
    copy_chain: CopyChain
    propagated_uses: i64
    eliminated_copies: i64


# ============================================================================
# CopyPropagation Methods (was: impl CopyPropagation:)
# ============================================================================

fn copypropagation_new() -> CopyPropagation:
        CopyPropagation(
            copy_chain: copychain_new(),
            propagated_uses: 0,
            eliminated_copies: 0
        )


fn copypropagation_run_on_function(self: CopyPropagation, func: MirFunction) -> MirFunction:
        """
        Run copy propagation on a function.

        Steps:
        1. Build copy chains from all blocks
        2. Propagate copies in each block
        3. Return optimized function
        """
        # Phase 1: Build copy chains
        for block in func.blocks:
            self.analyze_block(block)

        # Phase 2: Propagate copies
        var optimized_blocks: [MirBlock] = []
        for block in func.blocks:
            val optimized = self.propagate_block(block)
            optimized_blocks_push(optimized_blocks, optimized)

        copy_mir_function_with_blocks(func, optimized_blocks)


fn copypropagation_propagate_block(self: CopyPropagation, block: MirBlock) -> MirBlock:
        """
        Propagate copies in a block.

        Replace all uses of copied values with root values.
        """
        var propagated_instructions: [MirInst] = []

        for inst in block.instructions:
            val propagated = self.propagate_instruction(inst)
            propagated_instructions_push(propagated_instructions, propagated)

        # Propagate in terminator
        val propagated_term = self.propagate_terminator(block.terminator)

        MirBlock(
            id: block.id,
            label: block.label,
            instructions: propagated_instructions,
            terminator: propagated_term
        )


fn copypropagation_propagate_instruction(self: CopyPropagation, inst: MirInst) -> MirInst:
        """
        Propagate copies in an instruction.

        Replace all operand uses with root values.
        """
        match inst.kind:
            case BinOp(dest, op, left, right):
                val new_left = self.propagate_operand(left)
                val new_right = self.propagate_operand(right)
                MirInst(
                    kind: mirinstkind_BinOp(dest, op, new_left, new_right),
                    span: inst.span
                )

            case UnaryOp(dest, op, operand):
                val new_operand = self.propagate_operand(operand)
                MirInst(
                    kind: mirinstkind_UnaryOp(dest, op, new_operand),
                    span: inst.span
                )

            case Load(dest, ptr):
                val new_ptr = self.propagate_operand(ptr)
                MirInst(
                    kind: mirinstkind_Load(dest, new_ptr),
                    span: inst.span
                )

            case Store(ptr, value):
                val new_ptr = self.propagate_operand(ptr)
                val new_value = self.propagate_operand(value)
                MirInst(
                    kind: mirinstkind_Store(new_ptr, new_value),
                    span: inst.span
                )

            case Call(dest, func, args):
                val new_func = self.propagate_operand(func)
                var new_args: [MirOperand] = []
                for arg in args:
                    new_args_push(new_args, self.propagate_operand(arg))
                MirInst(
                    kind: mirinstkind_Call(dest, new_func, new_args),
                    span: inst.span
                )

            case Copy(dest, src):
                # Keep copy instruction (DCE will remove if unused)
                val root = self.copy_chain_get_root(copy_chain, src)
                if root.id != src.id:
                    # Source is itself a copy - propagate
                    self.eliminated_copies = self.eliminated_copies + 1
                    MirInst(
                        kind: mirinstkind_Copy(dest, root),
                        span: inst.span
                    )
                else:
                    inst

            case Move(dest, src):
                # Propagate move source
                val root = self.copy_chain_get_root(copy_chain, src)
                if root.id != src.id:
                    self.eliminated_copies = self.eliminated_copies + 1
                    MirInst(
                        kind: mirinstkind_Move(dest, root),
                        span: inst.span
                    )
                else:
                    inst

            case _:
                # No propagation needed for this instruction
                inst


fn copypropagation_propagate_operand(self: CopyPropagation, operand: MirOperand) -> MirOperand:
        """
        Propagate copy in an operand.

        If operand uses a copied value, replace with root.
        """
        match operand.kind:
            case Copy(local):
                val root = self.copy_chain_get_root(copy_chain, local)
                if root.id != local.id:
                    # Propagate to root
                    self.propagated_uses = self.propagated_uses + 1
                    MirOperand(kind: miroperandkind_Copy(root))
                else:
                    operand

            case Move(local):
                val root = self.copy_chain_get_root(copy_chain, local)
                if root.id != local.id:
                    self.propagated_uses = self.propagated_uses + 1
                    MirOperand(kind: miroperandkind_Move(root))
                else:
                    operand

            case Const(_, _):
                # Constants don't need propagation
                operand


fn copypropagation_propagate_terminator(self: CopyPropagation, term: MirTerminator) -> MirTerminator:
        """Propagate copies in terminator."""
        match term:
            case Return(value):
                val new_value = self.propagate_operand(value)
                mirterminator_Return(new_value)

            case If(cond, then_, else_):
                val new_cond = self.propagate_operand(cond)
                mirterminator_If(new_cond, then_, else_)

            case Switch(value, targets, default):
                val new_value = self.propagate_operand(value)
                mirterminator_Switch(new_value, targets, default)

            case CallTerminator(dest, func, args, normal, unwind):
                val new_func = self.propagate_operand(func)
                var new_args: [MirOperand] = []
                for arg in args:
                    new_args_push(new_args, self.propagate_operand(arg))
                mirterminator_CallTerminator(dest, new_func, new_args, normal, unwind)

            case _:
                # Other terminators don't use operands
                term


# ============================================================================
# Factory Function
# ============================================================================

fn create_copy_prop_pass() -> CopyPropagation:
    """Create a new copy propagation pass instance."""
    copypropagation_new()

# ============================================================================
# Exports
# ============================================================================

export CopyPropagation, create_copy_prop_pass, copypropagation_run_on_function
export CopyChain
