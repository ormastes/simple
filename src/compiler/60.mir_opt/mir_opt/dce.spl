# Dead Code Elimination (DCE)
#
# Removes instructions and basic blocks that don't affect program output.
#
# What it removes:
# 1. Unused local variables (dead stores)
# 2. Instructions whose results are never used
# 3. Unreachable basic blocks
# 4. Pure operations with unused results
#
# Algorithm:
# 1. Mark phase: Mark all "live" values (used in output)
# 2. Sweep phase: Remove unmarked instructions and blocks
#
# Preserves:
# - Function calls (may have side effects)
# - Memory stores (may be visible)
# - Return instructions
# - Branch terminators

use compiler.mir.mir_data.*
use compiler.mir.mir.*
use compiler.mir_opt.mod.{MirPass}

# ============================================================================
# Liveness Analysis
# ============================================================================

class LivenessAnalysis:
    """
    Tracks which local variables are live (used later).

    A variable is live if:
    - It's used in a future instruction
    - It's returned from the function
    - It's passed to a function call
    - It's stored to memory
    """
    live_locals: Dict<i64, bool>  # Set of live LocalId indices
    live_blocks: Dict<i64, bool>  # Set of reachable BlockId indices

impl LivenessAnalysis:
    static fn new() -> LivenessAnalysis:
        LivenessAnalysis(
            live_locals: {},
            live_blocks: {}
        )

    me mark_live(local: LocalId):
        """Mark a local as live."""
        self.live_locals[local.id] = true

    fn is_live(local: LocalId) -> bool:
        """Check if local is live."""
        self.live_locals.contains_key(local.id)

    me mark_block_reachable(block: BlockId):
        """Mark a block as reachable."""
        self.live_blocks[block.id] = true

    fn is_block_reachable(block: BlockId) -> bool:
        """Check if block is reachable."""
        self.live_blocks.contains_key(block.id)

# ============================================================================
# Dead Code Elimination Pass
# ============================================================================

class DeadCodeElimination:
    """
    DCE optimization pass.

    Removes dead code in two phases:
    1. Mark: Identify live instructions via backwards dataflow
    2. Sweep: Remove unmarked instructions
    """
    removed_instructions: i64
    removed_blocks: i64
    iterations: i64

impl DeadCodeElimination:
    static fn new() -> DeadCodeElimination:
        DeadCodeElimination(
            removed_instructions: 0,
            removed_blocks: 0,
            iterations: 0
        )

    fn name() -> text:
        "dead_code_elimination"

    fn description() -> text:
        "Removes unused instructions and unreachable basic blocks"

    fn is_analysis_pass() -> bool:
        false

    fn dependencies() -> [text]:
        []  # No dependencies

    me run_on_function(func: MirFunction) -> MirFunction:
        """
        Run DCE on a function.

        Algorithm:
        1. Find reachable blocks (from entry)
        2. For each reachable block:
           a. Mark live instructions (backwards from terminator)
           b. Remove dead instructions
        3. Remove unreachable blocks
        """
        self.iterations = self.iterations + 1

        # Phase 1: Find reachable blocks
        val reachable = self.find_reachable_blocks(func)

        # Build reachable set for O(1) lookup
        var reachable_set = {}
        for bid in reachable:
            reachable_set["{bid.id}"] = true

        # Phase 2: Remove dead instructions in reachable blocks
        var optimized_blocks: [MirBlock] = []
        for block in func.blocks:
            if reachable_set.contains_key("{block.id.id}"):
                val optimized_block = self.remove_dead_instructions(block)
                optimized_blocks = optimized_blocks.push(optimized_block)
            else:
                # Unreachable block - don't include
                self.removed_blocks = self.removed_blocks + 1

        # Return optimized function
        copy_mir_function_with_blocks(func, optimized_blocks)

    # ========================================================================
    # Reachability Analysis
    # ========================================================================

    fn find_reachable_blocks(func: MirFunction) -> [BlockId]:
        """
        Find all reachable blocks via depth-first search from entry.

        Returns list of reachable block IDs.
        """
        var reachable: [BlockId] = []
        var visited = {}
        var worklist: [BlockId] = [func.entry_block]

        # Pre-compute block lookup by ID for O(1) find_block
        var block_map = {}
        for i in 0..(func.blocks.len()):
            val b = func.blocks[i]
            block_map["{b.id.id}"] = i

        while worklist.len() > 0:
            val block_id = worklist[0]
            worklist = worklist[1..]  # Pop first element

            # Skip if already visited (O(1) Dict lookup)
            if visited.contains_key("{block_id.id}"):
                continue

            # Mark reachable
            visited["{block_id.id}"] = true
            reachable = reachable.push(block_id)

            # Find block via pre-computed map (O(1) lookup)
            val block_key = "{block_id.id}"
            if not block_map.contains_key(block_key):
                continue
            val block_idx = block_map[block_key]
            val block = func.blocks[block_idx]

            # Add successors to worklist
            val successors = self.get_successor_blocks(block.terminator)
            for succ in successors:
                if not visited.contains_key("{succ.id}"):
                    worklist = worklist.push(succ)

        reachable

    fn get_successor_blocks(term: MirTerminator) -> [BlockId]:
        """Get successor block IDs from terminator."""
        match term:
            case Goto(target):
                [target]

            case If(_, then_, else_):
                [then_, else_]

            case Switch(_, targets, default):
                var succs: [BlockId] = [default]
                for case_item in targets:
                    succs = succs.push(case_item.target)
                succs

            case CallTerminator(_, _, _, normal, unwind):
                if unwind.?:
                    [normal, unwind.unwrap()]
                else:
                    [normal]

            case Return(_):
                []

            case Unreachable:
                []

            case Abort(_):
                []

    # ========================================================================
    # Instruction-Level DCE
    # ========================================================================

    me remove_dead_instructions(block: MirBlock) -> MirBlock:
        """
        Remove dead instructions from a block.

        An instruction is dead if:
        - It assigns to a local that's never used
        - It's a pure operation (no side effects)
        - Its result isn't consumed
        """
        var live_instructions: [MirInst] = []

        # Liveness analysis strategy (Phase 1B.6 - TODO #131 âœ…)
        # 1. Mark all instructions with side effects as live
        # 2. Mark instructions whose results are used as live
        # 3. Remove unmarked (dead) instructions

        var live_set = {}

        # First pass: mark side-effect instructions
        for i in 0..(block.instructions.len()):
            if self.instruction_has_side_effects(block.instructions[i]):
                live_set["{i}"] = true

        # Second pass: mark instructions whose results are used
        for i in 0..(block.instructions.len()):
            if self.is_instruction_result_used(block.instructions[i], block):
                if not live_set.contains_key("{i}"):
                    live_set["{i}"] = true

        # Third pass: build live instruction list
        for i in 0..(block.instructions.len()):
            if live_set.contains_key("{i}"):
                live_instructions = live_instructions.push(block.instructions[i])
            else:
                # Dead instruction - count removal
                self.removed_instructions = self.removed_instructions + 1

        MirBlock(
            id: block.id,
            label: block.label,
            instructions: live_instructions,
            terminator: block.terminator
        )

    fn instruction_has_side_effects(inst: MirInst) -> bool:
        """
        Check if instruction has observable side effects.

        Side effects include:
        - Function calls (may do anything)
        - Memory stores (visible to other code)
        - Checked operations (may trap)
        """
        match inst.kind:
            case Call(_, _, _):
                true  # Function calls may have side effects

            case CallIndirect(_, _, _, _):
                true

            case Store(_, _):
                true  # Memory stores are visible

            case Intrinsic(_, name, _):
                # Some intrinsics are pure, but be conservative
                not self.is_pure_intrinsic(name)

            case CheckedBinOp(_, _, _, _):
                true  # May trap on overflow

            case _:
                false  # Most instructions are pure

    fn is_pure_intrinsic(name: text) -> bool:
        """Check if intrinsic is pure (no side effects)."""
        match name:
            case "sqrt":
                true
            case "abs":
                true
            case "min":
                true
            case "max":
                true
            case _:
                false  # Conservative: assume impure

    fn is_instruction_result_used(inst: MirInst, block: MirBlock) -> bool:
        """
        Check if instruction's result is used later.

        Performs basic def-use analysis: checks if the dest local appears
        as an operand in any subsequent instruction or terminator.
        """
        # Extract dest local from instruction
        val dest_id = self.get_inst_dest(inst)
        if not dest_id.?:
            return true  # No dest = side-effect instruction, always keep

        val dest = dest_id.unwrap()

        # Check if dest is used in any instruction in this block
        var found_inst = false
        for other_inst in block.instructions:
            if not found_inst:
                # Skip until we find our instruction
                if self.same_inst(inst, other_inst):
                    found_inst = true
                continue
            # Check if other_inst uses dest
            if self.inst_uses_local(other_inst, dest):
                return true

        # Check if used in terminator
        if self.terminator_uses_local(block.terminator, dest):
            return true

        # Not used in this block - conservatively assume used across blocks
        true

    fn get_inst_dest(inst: MirInst) -> LocalId?:
        """Extract destination local from an instruction."""
        match inst.kind:
            case Const(dest, _, _): Some(dest)
            case Copy(dest, _): Some(dest)
            case Move(dest, _): Some(dest)
            case BinOp(dest, _, _, _): Some(dest)
            case UnaryOp(dest, _, _): Some(dest)
            case Alloc(dest, _): Some(dest)
            case Load(dest, _): Some(dest)
            case GetField(dest, _, _): Some(dest)
            case Cast(dest, _, _): Some(dest)
            case Aggregate(dest, _, _): Some(dest)
            case _: nil

    fn same_inst(a: MirInst, b: MirInst) -> bool:
        """Simple identity check for instructions (by span)."""
        if a.span.? and b.span.?:
            val sa = a.span.unwrap()
            val sb = b.span.unwrap()
            return sa.start == sb.start and sa.end == sb.end
        false

    fn inst_uses_local(inst: MirInst, local: LocalId) -> bool:
        """Check if instruction uses a given local."""
        match inst.kind:
            case Copy(_, src): src.id == local.id
            case Move(_, src): src.id == local.id
            case BinOp(_, _, left, right):
                self.operand_uses_local(left, local) or self.operand_uses_local(right, local)
            case UnaryOp(_, _, operand):
                self.operand_uses_local(operand, local)
            case Load(_, ptr):
                self.operand_uses_local(ptr, local)
            case Store(ptr, value):
                self.operand_uses_local(ptr, local) or self.operand_uses_local(value, local)
            case Call(_, func, args):
                if self.operand_uses_local(func, local):
                    return true
                for arg in args:
                    if self.operand_uses_local(arg, local):
                        return true
                false
            case GetField(_, base, _):
                self.operand_uses_local(base, local)
            case _: false

    fn operand_uses_local(operand: MirOperand, local: LocalId) -> bool:
        """Check if operand references a local."""
        match operand.kind:
            case Copy(src): src.id == local.id
            case Move(src): src.id == local.id
            case _: false

    fn terminator_uses_local(term: MirTerminator, local: LocalId) -> bool:
        """Check if terminator uses a local."""
        match term:
            case Return(op):
                if op.?:
                    self.operand_uses_local(op.unwrap(), local)
                else:
                    false
            case If(cond, _, _):
                self.operand_uses_local(cond, local)
            case Switch(value, _, _):
                self.operand_uses_local(value, local)
            case _: false

    # ========================================================================
    # Statistics
    # ========================================================================

    fn stats_summary() -> text:
        """Generate summary of optimization work."""
        "DCE: removed {self.removed_instructions} instructions, {self.removed_blocks} blocks ({self.iterations} runs)"

# ============================================================================
# Factory Function
# ============================================================================

fn create_dce_pass() -> DeadCodeElimination:
    """Create a new DCE pass instance."""
    DeadCodeElimination.new()

# ============================================================================
# Exports
# ============================================================================

export DeadCodeElimination, create_dce_pass
