# Auto-Vectorization Pass - Phase 1: Dependency Analysis
#
# Builds def-use chains, detects loop-carried dependencies,
# checks array aliasing, and performs complete dependency analysis.

use compiler.mir.mir_data.{MirModule, MirFunction, MirBlock, MirInst, MirInstKind, MirTerminator, MirOperand, MirOperandKind, MirBinOp, LocalId, BlockId}
use compiler.mir_opt.auto_vectorize_types.{LoopInfo, ArrayAccess}

# ============================================================================
# Dependency Types and Structures
# ============================================================================

"""Dependency type for loop-carried dependencies."""
enum DependencyType:
    RAW    # Read-after-write (true dependency)
    WAR    # Write-after-read (anti dependency)
    WAW    # Write-after-write (output dependency)

struct Dependency:
    """Represents a dependency between two instructions."""
    from_inst: i64      # Index in instruction list
    to_inst: i64        # Index in instruction list
    dep_type: DependencyType
    local: LocalId      # The local variable involved
    is_loop_carried: bool  # True if crosses iteration boundary

struct DefUseChain:
    """Def-use chain for a local variable within loop."""
    local: LocalId
    defs: [i64]        # Instruction indices that define this local
    uses: [i64]        # Instruction indices that use this local

struct DependencyAnalysisResult:
    """Result of dependency analysis."""
    vectorizable: bool
    dependencies: [Dependency]
    def_use_chains: [DefUseChain]
    array_accesses: [ArrayAccess]
    has_aliasing: bool
    loop_carried_count: i64

# ============================================================================
# Simple Dictionary (used for def-use chain building)
# ============================================================================

"""Simple dictionary implementation for local IDs."""
struct Dict<K, V>:
    keys_: [K]
    values_: [V]

impl Dict<K, V>:
    static fn new() -> Dict<K, V>:
        Dict(keys_: [], values_: [])

    fn contains_key(key: K) -> bool:
        var i = 0
        while i < self.keys_.len():
            if self.keys_[i] == key:
                return true
            i = i + 1
        false

    fn get(key: K) -> V?:
        var i = 0
        while i < self.keys_.len():
            if self.keys_[i] == key:
                return Some(self.values_[i])
            i = i + 1
        nil

    fn set(key: K, value: V):
        var i = 0
        while i < self.keys_.len():
            if self.keys_[i] == key:
                self.values_[i] = value
                return
            i = i + 1
        # Key not found, add it
        self.keys_ = self.keys_ + [key]
        self.values_ = self.values_ + [value]

    fn keys() -> [K]:
        self.keys_

# ============================================================================
# Def-Use Chain Construction
# ============================================================================

fn build_def_use_chains(body_blocks: [MirBlock]) -> [DefUseChain]:
    """
    Build def-use chains for all locals used in the loop body.
    Returns a chain for each local that's defined or used.
    """
    var chains_map = Dict.new()
    var inst_index = 0

    for block in body_blocks:
        for inst in block.instructions:
            # Check what this instruction defines
            val def_local = get_inst_def(inst)
            if def_local.?:
                val local = def_local.unwrap()
                val local_id = local.id
                if not dict_contains_key_i64(chains_map, local_id):
                    dict_set_i64(chains_map, local_id, DefUseChain(local: local, defs: [], uses: []))
                val chain_opt = dict_get_i64(chains_map, local_id)
                if chain_opt.?:
                    var chain = chain_opt.unwrap()
                    chain.defs = chain.defs + [inst_index]
                    dict_set_i64(chains_map, local_id, chain)

            # Check what this instruction uses
            val use_locals = get_inst_uses(inst)
            for local in use_locals:
                val local_id = local.id
                if not dict_contains_key_i64(chains_map, local_id):
                    dict_set_i64(chains_map, local_id, DefUseChain(local: local, defs: [], uses: []))
                val chain_opt = dict_get_i64(chains_map, local_id)
                if chain_opt.?:
                    var chain = chain_opt.unwrap()
                    chain.uses = chain.uses + [inst_index]
                    dict_set_i64(chains_map, local_id, chain)

            inst_index = inst_index + 1

    # Convert map to list
    var chains: [DefUseChain] = []
    for key in chains_map.keys():
        val chain_opt = dict_get_i64(chains_map, key)
        if chain_opt.?:
            chains = chains + [chain_opt.unwrap()]
    chains

# ============================================================================
# Instruction Def/Use Extraction
# ============================================================================

fn get_inst_def(inst: MirInst) -> LocalId?:
    """Get the local that this instruction defines, if any."""
    match inst.kind:
        case Const(dest, _, _): Some(dest)
        case Copy(dest, _): Some(dest)
        case Move(dest, _): Some(dest)
        case BinOp(dest, _, _, _): Some(dest)
        case UnaryOp(dest, _, _): Some(dest)
        case CheckedBinOp(dest, _, _, _): Some(dest)
        case Alloc(dest, _): Some(dest)
        case Load(dest, _): Some(dest)
        case GetElementPtr(dest, _, _): Some(dest)
        case Aggregate(dest, _, _): Some(dest)
        case GetField(dest, _, _): Some(dest)
        case Cast(dest, _, _): Some(dest)
        case Bitcast(dest, _, _): Some(dest)
        case Call(dest, _, _):
            if dest.?:
                dest
            else:
                nil
        case CallIndirect(dest, _, _, _):
            if dest.?:
                dest
            else:
                nil
        case Intrinsic(dest, _, _):
            if dest.?:
                dest
            else:
                nil
        case _: nil

fn get_inst_uses(inst: MirInst) -> [LocalId]:
    """Get all locals that this instruction uses."""
    var uses: [LocalId] = []

    match inst.kind:
        case Copy(_, src):
            uses = uses + [src]
        case Move(_, src):
            uses = uses + [src]
        case BinOp(_, _, left, right):
            uses = uses + (get_operand_locals(left))
            uses = uses + (get_operand_locals(right))
        case UnaryOp(_, _, operand):
            uses = uses + (get_operand_locals(operand))
        case CheckedBinOp(_, _, left, right):
            uses = uses + (get_operand_locals(left))
            uses = uses + (get_operand_locals(right))
        case Load(_, ptr):
            uses = uses + (get_operand_locals(ptr))
        case Store(ptr, value):
            uses = uses + (get_operand_locals(ptr))
            uses = uses + (get_operand_locals(value))
        case GetElementPtr(_, base, indices):
            uses = uses + (get_operand_locals(base))
            for idx in indices:
                uses = uses + (get_operand_locals(idx))
        case Aggregate(_, _, operands):
            for op in operands:
                uses = uses + (get_operand_locals(op))
        case GetField(_, base, _):
            uses = uses + (get_operand_locals(base))
        case SetField(base, _, value):
            uses = uses + (get_operand_locals(base))
            uses = uses + (get_operand_locals(value))
        case Cast(_, operand, _):
            uses = uses + (get_operand_locals(operand))
        case Bitcast(_, operand, _):
            uses = uses + (get_operand_locals(operand))
        case Call(_, func, args):
            uses = uses + (get_operand_locals(func))
            for arg in args:
                uses = uses + (get_operand_locals(arg))
        case CallIndirect(_, ptr, args, _):
            uses = uses + (get_operand_locals(ptr))
            for arg in args:
                uses = uses + (get_operand_locals(arg))
        case _:
            pass_do_nothing

    uses

fn get_operand_locals(op: MirOperand) -> [LocalId]:
    """Extract local ID from operand if it references a local."""
    match op.kind:
        case Copy(local): [local]
        case Move(local): [local]
        case Const(_, _): []

# ============================================================================
# Dependency Detection
# ============================================================================

fn detect_dependencies(body_blocks: [MirBlock], chains: [DefUseChain], induction: LocalId) -> [Dependency]:
    """
    Detect all dependencies within the loop body.
    Returns list of dependencies, marking which are loop-carried.
    """
    var deps: [Dependency] = []

    for chain in chains:
        # Skip induction variable (it's expected to have loop-carried dependency)
        if chain.local.id == induction.id:
            pass_do_nothing
        else:
            # Check for RAW (Read-After-Write) dependencies
            for def_idx in chain.defs:
                for use_idx in chain.uses:
                    if use_idx > def_idx:
                        # Use comes after def - potential RAW dependency
                        val is_carried = is_loop_carried_dependency(def_idx, use_idx, body_blocks)
                        deps = deps + [Dependency(
                            from_inst: def_idx,
                            to_inst: use_idx,
                            dep_type: DependencyType.RAW,
                            local: chain.local,
                            is_loop_carried: is_carried
                        )]

            # Check for WAR (Write-After-Read) dependencies
            for use_idx in chain.uses:
                for def_idx in chain.defs:
                    if def_idx > use_idx:
                        # Def comes after use - potential WAR dependency
                        val is_carried = is_loop_carried_dependency(use_idx, def_idx, body_blocks)
                        deps = deps + [Dependency(
                            from_inst: use_idx,
                            to_inst: def_idx,
                            dep_type: DependencyType.WAR,
                            local: chain.local,
                            is_loop_carried: is_carried
                        )]

            # Check for WAW (Write-After-Write) dependencies
            if chain.defs.len() >= 2:
                var i = 0
                while i < chain.defs.len() - 1:
                    val def1 = chain.defs[i]
                    val def2 = chain.defs[i + 1]
                    val is_carried = is_loop_carried_dependency(def1, def2, body_blocks)
                    deps = deps + [Dependency(
                        from_inst: def1,
                        to_inst: def2,
                        dep_type: DependencyType.WAW,
                        local: chain.local,
                        is_loop_carried: is_carried
                    )]
                    i = i + 1

    deps

fn is_loop_carried_dependency(from_idx: i64, to_idx: i64, body_blocks: [MirBlock]) -> bool:
    """
    Check if a dependency crosses iteration boundaries.
    For now, conservatively assume any backward dependency is loop-carried.
    A more sophisticated analysis would check actual control flow.
    """
    # If to_idx < from_idx, it's definitely loop-carried (backward in program order)
    if to_idx < from_idx:
        return true

    # For forward dependencies, check if they're in different blocks
    # that might execute in different iterations
    # Simplified: assume single-block loops don't have loop-carried deps
    if body_blocks.len() > 1:
        return true

    false

# ============================================================================
# Array Aliasing Analysis
# ============================================================================

fn check_array_aliasing(accesses: [ArrayAccess], induction: LocalId) -> bool:
    """
    Check if array accesses might alias (refer to same memory).
    Returns true if potential aliasing detected (prevents vectorization).
    """
    # Build list of writes
    var writes: [ArrayAccess] = []
    for access in accesses:
        if not access.is_load:
            writes = writes + [access]

    # Check each write against all other accesses
    for write in writes:
        for access in accesses:
            # Skip comparing write to itself
            if (write.base_array.id == access.base_array.id and
                write.index_expr.id == access.index_expr.id and
                write.is_load == access.is_load):
                pass_do_nothing
            else:
                # Different accesses to same base array
                if write.base_array.id == access.base_array.id:
                    # Check if indices are independent
                    if not are_indices_independent(write.index_expr, access.index_expr, induction):
                        return true

    false

fn are_indices_independent(idx1: LocalId, idx2: LocalId, induction: LocalId) -> bool:
    """
    Check if two index expressions are independent (don't alias across iterations).
    For simple loops, indices of form 'i' are independent if they're the induction var.
    """
    # Simple case: both are the induction variable
    if idx1.id == induction.id and idx2.id == induction.id:
        return true

    # Different index expressions might alias
    false

fn has_loop_carried_deps(body: [MirBlock], induction: LocalId) -> bool:
    """
    Check if loop has dependencies between iterations (other than induction var).
    Returns true if non-vectorizable dependencies exist.
    """
    # Build def-use chains
    val chains = build_def_use_chains(body)

    # Detect all dependencies
    val deps = detect_dependencies(body, chains, induction)

    # Check if any loop-carried dependency exists
    for dep in deps:
        if dep.is_loop_carried:
            return true

    false

# ============================================================================
# Complete Dependency Analysis
# ============================================================================

fn analyze_loop_dependencies(loop: LoopInfo, body_blocks: [MirBlock]) -> DependencyAnalysisResult:
    """
    Complete dependency analysis for a loop.
    Returns detailed results including vectorizability.
    """
    # Build def-use chains
    val chains = build_def_use_chains(body_blocks)

    # Detect dependencies
    val deps = detect_dependencies(body_blocks, chains, loop.induction_var)

    # Detect array accesses
    var all_accesses: [ArrayAccess] = []
    for block in body_blocks:
        val block_accesses = detect_array_accesses(block)
        all_accesses = all_accesses + block_accesses

    # Check for aliasing
    val has_aliasing = check_array_aliasing(all_accesses, loop.induction_var)

    # Count loop-carried dependencies
    var loop_carried_count = 0
    for dep in deps:
        if dep.is_loop_carried:
            loop_carried_count = loop_carried_count + 1

    # Determine vectorizability
    val vectorizable = loop_carried_count == 0 and not has_aliasing

    DependencyAnalysisResult(
        vectorizable: vectorizable,
        dependencies: deps,
        def_use_chains: chains,
        array_accesses: all_accesses,
        has_aliasing: has_aliasing,
        loop_carried_count: loop_carried_count
    )

# ============================================================================
# Array Access Detection
# ============================================================================

fn detect_array_accesses(block: MirBlock) -> [ArrayAccess]:
    """Detect array load/store operations in a block."""
    var accesses: [ArrayAccess] = []

    # Track GEP results to match with loads/stores
    var gep_results: Dict = {}

    for inst in block.instructions:
        match inst.kind:
            case GetElementPtr(dest, base, indices):
                # Extract base array and index from GEP
                if indices.len() > 0:
                    val base_local = get_operand_local(base)
                    val index_local = get_operand_local(indices[0])
                    if base_local.? and index_local.?:
                        val gep_pair = (base_local.unwrap(), index_local.unwrap())
                        gep_results.keys_ = gep_results.keys_ + [dest.id]
                        gep_results.values_ = gep_results.values_ + [gep_pair]

            case Load(dest, ptr):
                # Check if ptr is a GEP result
                val ptr_local = get_operand_local(ptr)
                if ptr_local.?:
                    val ptr_id = ptr_local.unwrap().id
                    if dict_contains_key_gep(gep_results, ptr_id):
                        val gep_info_opt = dict_get_gep(gep_results, ptr_id)
                        if gep_info_opt.?:
                            val gep_info = gep_info_opt.unwrap()
                            accesses = accesses + [ArrayAccess(
                                base_array: gep_info.0,
                                index_expr: gep_info.1,
                                is_load: true
                            )]

            case Store(ptr, value):
                # Check if ptr is a GEP result
                val ptr_local = get_operand_local(ptr)
                if ptr_local.?:
                    val ptr_id = ptr_local.unwrap().id
                    if dict_contains_key_gep(gep_results, ptr_id):
                        val gep_info_opt = dict_get_gep(gep_results, ptr_id)
                        if gep_info_opt.?:
                            val gep_info = gep_info_opt.unwrap()
                            accesses = accesses + [ArrayAccess(
                                base_array: gep_info.0,
                                index_expr: gep_info.1,
                                is_load: false
                            )]

            case _:
                pass_do_nothing

    accesses

fn get_operand_local(op: MirOperand) -> LocalId?:
    """Extract local ID from operand if it references a local."""
    match op.kind:
        case Copy(local): Some(local)
        case Move(local): Some(local)
        case Const(_, _): nil

# ============================================================================
# Loop Detection
# ============================================================================

fn is_simple_loop(func: MirFunction, header: BlockId) -> LoopInfo?:
    """
    Detect if a block is the header of a simple loop.
    Returns loop information if it matches vectorizable pattern.
    """
    # Find the block
    var header_block: MirBlock? = nil
    for block in func.blocks:
        if block.id.id == header.id:
            header_block = Some(block)

    if not header_block.?:
        return nil

    val block = header_block.unwrap()

    # Check terminator for loop back-edge
    val loop_info = match block.terminator:
        case If(cond, then_, else_):
            # Check if one branch goes back to header (loop) and one exits
            if then_.id == header.id:
                # then_ is back-edge, else_ is exit
                detect_loop_bounds(func, block, cond, else_)
            elif else_.id == header.id:
                # else_ is back-edge, then_ is exit
                detect_loop_bounds(func, block, cond, then_)
            else:
                nil
        case _:
            nil

    loop_info

fn detect_loop_bounds(func: MirFunction, header: MirBlock, cond: MirOperand, exit: BlockId) -> LoopInfo?:
    """
    Extract loop bounds from loop header.
    Simplified: looks for pattern like: i < N
    """
    # This would require more complex pattern matching
    # For now, return a simple default loop
    # Real implementation would analyze phi nodes and comparison operations
    nil

# ============================================================================
# Dictionary Helpers (for analysis)
# ============================================================================

fn dict_get_i64(d: Dict<i64, DefUseChain>, key: i64) -> DefUseChain?:
    """Get value from Dict<i64, DefUseChain>."""
    var i = 0
    while i < d.keys_.len():
        if d.keys_[i] == key:
            return Some(d.values_[i])
        i = i + 1
    nil

fn dict_set_i64(d: Dict<i64, DefUseChain>, key: i64, value: DefUseChain):
    """Set value in Dict<i64, DefUseChain>."""
    var i = 0
    while i < d.keys_.len():
        if d.keys_[i] == key:
            d.values_[i] = value
            return
        i = i + 1
    # Key not found, add it
    d.keys_ = d.keys_ + [key]
    d.values_ = d.values_ + [value]

fn dict_contains_key_i64(d: Dict<i64, DefUseChain>, key: i64) -> bool:
    """Check if Dict contains key."""
    var i = 0
    while i < d.keys_.len():
        if d.keys_[i] == key:
            return true
        i = i + 1
    false

fn dict_get_gep(d: Dict<i64, (LocalId, LocalId)>, key: i64) -> (LocalId, LocalId)?:
    """Get value from GEP results dict."""
    var i = 0
    while i < d.keys_.len():
        if d.keys_[i] == key:
            return Some(d.values_[i])
        i = i + 1
    nil

fn dict_contains_key_gep(d: Dict<i64, (LocalId, LocalId)>, key: i64) -> bool:
    """Check if GEP results dict contains key."""
    var i = 0
    while i < d.keys_.len():
        if d.keys_[i] == key:
            return true
        i = i + 1
    false

# ============================================================================
# Exports
# ============================================================================

export DependencyType, Dependency, DefUseChain, DependencyAnalysisResult
export build_def_use_chains, detect_dependencies, has_loop_carried_deps
export analyze_loop_dependencies
export detect_array_accesses, check_array_aliasing
export is_simple_loop, detect_loop_bounds
export get_inst_def, get_inst_uses, get_operand_locals, get_operand_local
