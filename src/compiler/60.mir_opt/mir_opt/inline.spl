# Function Inlining
#
# Replaces function calls with the function body.
#
# Transformation:
#   fn add_one(x: i64) -> i64:
#       x + 1
#
#   val y = add_one(5)
#
# After inlining:
#   val y = 5 + 1
#
# Benefits:
# - Eliminates call overhead (setup, jump, return)
# - Enables interprocedural optimization (const fold, CSE across call boundaries)
# - Improves instruction cache locality
# - Reduces stack pressure
#
# Costs:
# - Increases code size (trade-off)
# - May increase compile time
# - Can hurt I-cache if too aggressive
#
# Strategy:
# - Always inline: tiny functions (< 50 bytes)
# - Aggressively inline: hot functions (< 500 bytes)
# - Never inline: recursive functions, large functions
#
# Heuristics:
# - Size threshold (configurable)
# - Call site count (don't inline if called many times)
# - Recursion detection (prevent infinite inlining)

use compiler.mir.mir_data.*
use compiler.mir.mir.*
use compiler.mir_opt.mod.{MirPass}

# ============================================================================
# Inlining Policy
# ============================================================================

enum InlinePolicy:
    """
    Policy for deciding whether to inline a function.
    """
    Always          # Inline regardless of size (for tiny functions)
    Aggressive      # Inline if below threshold (for optimization)
    Conservative    # Only inline very small functions (for code size)
    Never           # Don't inline (for debugging, recursive functions)

impl InlinePolicy:
    fn should_inline(size: i64, threshold: i64) -> bool:
        """Check if function should be inlined given size."""
        match self:
            case Always: true
            case Aggressive: size <= threshold
            case Conservative: size <= threshold / 2
            case Never: false

# ============================================================================
# Inline Cost Analysis
# ============================================================================

class InlineCostAnalyzer:
    """
    Analyzes the cost/benefit of inlining a function.

    Cost factors:
    - Function body size (instruction count)
    - Number of call sites (code size multiplication)
    - Complexity (loops, branches increase cost)

    Benefit factors:
    - Call overhead saved
    - Optimization opportunities enabled
    - Hot path (frequently executed)
    """
    threshold: i64  # Size threshold in "instruction units"

impl InlineCostAnalyzer:
    static fn new(threshold: i64) -> InlineCostAnalyzer:
        InlineCostAnalyzer(threshold: threshold)

    fn estimate_function_size(func: MirFunction) -> i64:
        """
        Estimate function size in instruction units.

        Simple heuristic: count instructions + weight by complexity.
        """
        var size = 0

        for block in func.blocks:
            # Each instruction adds to size
            size = size + block.instructions.len()

            # Terminator cost
            match block.terminator:
                case Return(_): size = size + 1
                case Goto(_): size = size + 1
                case If(_, _, _): size = size + 2  # Branch is expensive
                case Switch(_, targets, _): size = size + targets.len()
                case _: size = size + 1

        size

    fn should_inline(func: MirFunction, policy: InlinePolicy) -> bool:
        """
        Decide if function should be inlined.

        Checks:
        1. Size threshold
        2. Recursion (never inline recursive)
        3. Policy
        """
        val size = self.estimate_function_size(func)

        # Never inline if too large
        if size > self.threshold * 2:
            return false

        # Check policy
        policy.should_inline(size, self.threshold)

    fn is_recursive(func: MirFunction) -> bool:
        """
        Check if function is recursive (calls itself).

        Conservative: returns true if any call matches function name.

        Phase 1B.6 - TODO #132 âœ…
        """
        # Check if function calls itself
        val func_name = func.name

        # Scan all instructions for calls to self
        for block in func.blocks:
            for instr in block.instructions:
                match instr:
                    case Call(target, args, dest):
                        # Check if target is same function
                        match target:
                            case Variable(name):
                                if name == func_name:
                                    return true
                            case _:
                                ()  # Other call types
                    case _:
                        ()  # Not a call

        false

# ============================================================================
# Function Inliner
# ============================================================================

class FunctionInliner:
    """
    Performs actual inlining transformation.

    Process:
    1. Find call instruction
    2. Copy function body
    3. Rename locals (avoid conflicts)
    4. Replace call with inlined body
    5. Connect control flow
    """
    next_local_id: i64
    inlined_count: i64

impl FunctionInliner:
    static fn new(next_local_id: i64) -> FunctionInliner:
        FunctionInliner(
            next_local_id: next_local_id,
            inlined_count: 0
        )

    me inline_call(
        caller_block: MirBlock,
        call_inst_idx: i64,
        callee: MirFunction,
        call_dest: LocalId?,
        args: [MirOperand]
    ) -> [MirBlock]:
        """
        Inline a function call.

        Returns new blocks (caller block split + inlined body).

        Strategy:
        1. Split caller block at call site
        2. Copy callee body blocks
        3. Bind arguments to parameters
        4. Connect control flow
        5. Handle return value
        """
        # For now, simple implementation:
        # Just replace call with function body (single-block functions only)

        # Check if callee is single-block
        if callee.blocks.len() != 1:
            # Can't inline multi-block functions yet
            return [caller_block]

        val callee_block = callee.blocks[0]

        # Build new instructions:
        # 1. Instructions before call
        # 2. Argument bindings
        # 3. Inlined body
        # 4. Instructions after call

        var new_instructions: [MirInst] = []

        # Copy instructions before call
        var i = 0
        while i < call_inst_idx:
            new_instructions = new_instructions.push(caller_block.instructions[i])
            i = i + 1

        # Bind arguments to parameters: emit Const/Copy for each arg
        for param_idx in 0..args.len():
            if param_idx < callee.locals.len():
                val param_local = callee.locals[param_idx]
                val dest = param_local.id
                match args[param_idx].kind:
                    case Copy(src):
                        new_instructions = new_instructions.push(MirInst(kind: MirInstKind.Copy(dest, src), span: nil))
                    case Move(src):
                        new_instructions = new_instructions.push(MirInst(kind: MirInstKind.Move(dest, src), span: nil))
                    case Const(cv, ct):
                        new_instructions = new_instructions.push(MirInst(kind: MirInstKind.Const(dest, cv, ct), span: nil))

        # Copy inlined body (rename locals)
        for inst in callee_block.instructions:
            val renamed = self.rename_instruction(inst)
            new_instructions = new_instructions.push(renamed)

        # Handle return value: check terminator for Return and assign to call_dest
        match callee_block.terminator:
            case Return(ret_op):
                if call_dest.? and ret_op.?:
                    val ret_operand = ret_op.unwrap()
                    match ret_operand.kind:
                        case Copy(src):
                            new_instructions = new_instructions.push(MirInst(kind: MirInstKind.Copy(call_dest.unwrap(), src), span: nil))
                        case Move(src):
                            new_instructions = new_instructions.push(MirInst(kind: MirInstKind.Move(call_dest.unwrap(), src), span: nil))
                        case Const(cv, ct):
                            new_instructions = new_instructions.push(MirInst(kind: MirInstKind.Const(call_dest.unwrap(), cv, ct), span: nil))
            case _: ()

        # Copy instructions after call
        i = call_inst_idx + 1
        while i < caller_block.instructions.len():
            new_instructions = new_instructions.push(caller_block.instructions[i])
            i = i + 1

        self.inlined_count = self.inlined_count + 1

        [MirBlock(
            id: caller_block.id,
            label: caller_block.label,
            instructions: new_instructions,
            terminator: caller_block.terminator
        )]

    me rename_instruction(inst: MirInst) -> MirInst:
        """
        Rename locals in instruction to avoid conflicts.

        Creates fresh local IDs for all definitions.
        For instructions that define a destination, allocate a fresh local ID
        and substitute it. Uses only local context (no global rename map needed
        since single-block functions have unique definitions per instruction).
        """
        # Rename dest locals in defining instructions to avoid conflicts
        match inst.kind:
            case Const(dest, value, type_):
                val new_dest = self.fresh_local()
                MirInst(kind: MirInstKind.Const(new_dest, value, type_), span: inst.span)
            case Copy(dest, src):
                val new_dest = self.fresh_local()
                MirInst(kind: MirInstKind.Copy(new_dest, src), span: inst.span)
            case Move(dest, src):
                val new_dest = self.fresh_local()
                MirInst(kind: MirInstKind.Move(new_dest, src), span: inst.span)
            case BinOp(dest, op, left, right):
                val new_dest = self.fresh_local()
                MirInst(kind: MirInstKind.BinOp(new_dest, op, left, right), span: inst.span)
            case UnaryOp(dest, op, operand):
                val new_dest = self.fresh_local()
                MirInst(kind: MirInstKind.UnaryOp(new_dest, op, operand), span: inst.span)
            case Alloc(dest, type_):
                val new_dest = self.fresh_local()
                MirInst(kind: MirInstKind.Alloc(new_dest, type_), span: inst.span)
            case Load(dest, ptr):
                val new_dest = self.fresh_local()
                MirInst(kind: MirInstKind.Load(new_dest, ptr), span: inst.span)
            case _:
                # Non-defining instructions (Store, Nop, etc.) pass through
                inst

    me fresh_local() -> LocalId:
        """Allocate a fresh local ID."""
        val id = self.next_local_id
        self.next_local_id = self.next_local_id + 1
        LocalId(id: id)

# ============================================================================
# Function Inlining Pass
# ============================================================================

class FunctionInlining:
    """
    Function inlining optimization pass.

    Configuration:
    - threshold: Maximum function size to inline (in instruction units)
    - policy: Inlining aggressiveness policy

    Algorithm:
    1. Analyze all functions (build call graph, compute sizes)
    2. For each function:
       a. Find inline candidates (call sites)
       b. Check inlining heuristics
       c. Perform inlining if beneficial
    3. Repeat until fixed point or max iterations

    The function_table maps function names to MirFunction definitions,
    allowing find_callee_function to resolve call targets for inlining.
    Populate it via set_function_table before running run_on_function.
    """
    threshold: i64
    policy: InlinePolicy
    cost_analyzer: InlineCostAnalyzer
    inlined_functions: i64
    inlined_call_sites: i64
    iterations: i64
    function_table: Dict<text, MirFunction>

impl FunctionInlining:
    static fn new(threshold: i64, policy: InlinePolicy) -> FunctionInlining:
        FunctionInlining(
            threshold: threshold,
            policy: policy,
            cost_analyzer: InlineCostAnalyzer.new(threshold),
            inlined_functions: 0,
            inlined_call_sites: 0,
            iterations: 0,
            function_table: {}
        )

    static fn small_functions() -> FunctionInlining:
        """Inline only very small functions (for code size)."""
        FunctionInlining.new(50, InlinePolicy.Conservative)

    static fn aggressive() -> FunctionInlining:
        """Aggressive inlining (for speed)."""
        FunctionInlining.new(500, InlinePolicy.Aggressive)

    static fn very_aggressive() -> FunctionInlining:
        """Very aggressive inlining (max speed, may increase code size)."""
        FunctionInlining.new(2000, InlinePolicy.Aggressive)

    me set_function_table(table: Dict<text, MirFunction>):
        """Set the function table for cross-function callee resolution.

        Call this before run_on_function to enable inlining of calls
        to functions defined in the same module. The table maps function
        names to their MirFunction definitions.
        """
        self.function_table = table

    fn name() -> text:
        "function_inlining"

    fn description() -> text:
        "Inlines small function calls to eliminate call overhead"

    fn is_analysis_pass() -> bool:
        false

    fn dependencies() -> [text]:
        ["dead_code_elimination", "constant_folding"]

    me run_on_function(func: MirFunction) -> MirFunction:
        """
        Run inlining on a function.

        Resolves call targets using the function_table (set via
        set_function_table). Only inlines small, non-recursive,
        single-block callees that pass the cost/policy check.
        """
        self.iterations = self.iterations + 1

        # Find call sites in this function
        var modified = false
        var optimized_blocks: [MirBlock] = []

        for block in func.blocks:
            val optimized = self.inline_calls_in_block(block, func)
            if optimized.id.id != block.id.id or optimized.instructions.len() != block.instructions.len():
                modified = true
            optimized_blocks = optimized_blocks.push(optimized)

        if modified:
            self.inlined_functions = self.inlined_functions + 1

        copy_mir_function_with_blocks(func, optimized_blocks)

    me inline_calls_in_block(block: MirBlock, func: MirFunction) -> MirBlock:
        """
        Inline eligible calls in a block.

        For each call instruction:
        1. Scan for Call instructions targeting small single-block functions
        2. Check if callee should be inlined via cost analyzer and policy
        3. Replace call with inlined body using FunctionInliner

        Note: Cross-function inlining requires module-level context.
        This pass handles intra-function patterns: calls to functions
        already visible in the current function's module context.
        """
        # Scan block instructions for Call instructions
        var new_instructions: [MirInst] = []
        var did_inline = false

        for inst in block.instructions:
            match inst.kind:
                case Call(dest, callee_op, args):
                    # Check if the callee references a function in the same module
                    # by looking for Const operand with FuncPtr type
                    val callee_func = self.find_callee_function(callee_op, func)
                    if callee_func.?:
                        val callee = callee_func.unwrap()
                        # Check if callee is worth inlining
                        val size = self.cost_analyzer.estimate_function_size(callee)
                        val should = self.cost_analyzer.should_inline(callee, self.policy)
                        val is_recursive = self.cost_analyzer.is_recursive(callee)

                        if should and not is_recursive and callee.blocks.len() == 1:
                            # Inline: create inliner and replace call with body
                            var inliner = FunctionInliner.new(func.locals.len() + 100)
                            val inlined_blocks = inliner.inline_call(
                                MirBlock(id: block.id, label: block.label, instructions: new_instructions, terminator: block.terminator),
                                new_instructions.len(),
                                callee,
                                dest,
                                args
                            )
                            # Take instructions from the inlined result
                            if inlined_blocks.len() > 0:
                                new_instructions = inlined_blocks[0].instructions
                                self.inlined_call_sites = self.inlined_call_sites + 1
                                did_inline = true
                                continue
                    # Not inlineable - keep original instruction
                    new_instructions = new_instructions.push(inst)
                case _:
                    new_instructions = new_instructions.push(inst)

        if did_inline:
            MirBlock(
                id: block.id,
                label: block.label,
                instructions: new_instructions,
                terminator: block.terminator
            )
        else:
            block

    fn find_callee_function(callee_op: MirOperand, caller: MirFunction) -> MirFunction?:
        """
        Try to resolve a callee operand to a function definition.

        Looks up the callee in the function_table by extracting the function
        name from the operand. Returns the MirFunction if found and it is
        not the caller itself (to avoid trivial self-inlining at this level).
        Returns nil if the callee cannot be resolved or is external.
        """
        # Extract function name from the callee operand
        val func_name = self.extract_callee_name(callee_op)
        if not func_name.?:
            return nil

        val name = func_name.unwrap()

        # Don't inline self (recursion is handled by is_recursive check,
        # but avoid even looking up self as a candidate)
        if name == caller.name:
            return nil

        # Look up in function table
        if self.function_table.has(name):
            return Some(self.function_table[name])

        nil

    fn extract_callee_name(op: MirOperand) -> text?:
        """Extract function name from a callee operand.

        Callee operands are typically Const with a Str value (function name)
        and FuncPtr type, or Const with Int value and FuncPtr type (symbol ID).
        """
        match op.kind:
            case Const(value, type_):
                # Check that this is a function pointer type
                match type_.kind:
                    case FuncPtr(_):
                        match value:
                            case Str(name): Some(name)
                            case _: nil
                    case _: nil
            case _: nil

    # ========================================================================
    # Statistics
    # ========================================================================

    fn stats_summary() -> text:
        """Generate summary of optimization work."""
        "Inline: inlined {self.inlined_call_sites} call sites in {self.inlined_functions} functions ({self.iterations} iterations)"

# ============================================================================
# Module-Level Inlining
# ============================================================================

class ModuleInliner:
    """
    Module-level inlining pass.

    Operates on entire module to inline cross-function calls.
    """
    threshold: i64
    policy: InlinePolicy
    inlined_total: i64

impl ModuleInliner:
    static fn new(threshold: i64, policy: InlinePolicy) -> ModuleInliner:
        ModuleInliner(
            threshold: threshold,
            policy: policy,
            inlined_total: 0
        )

    me inline_module(module: MirModule) -> MirModule:
        """
        Perform inlining across module.

        Strategy:
        1. Identify inline candidates (small, non-recursive, single-block)
        2. Build both symbol-ID and name-based lookup tables
        3. For each function in the module, inline eligible callees
        4. Return optimized module
        """
        val cost_analyzer = InlineCostAnalyzer.new(self.threshold)

        # Phase 1: Identify small single-block functions eligible for inlining
        # Build both ID-based and name-based candidate tables for lookup
        var inline_candidates: Dict<i64, MirFunction> = {}
        var inline_candidates_by_name: Dict<text, MirFunction> = {}
        for func_symbol in module.functions.keys():
            val func = module.functions[func_symbol]
            val size = cost_analyzer.estimate_function_size(func)
            val is_recursive = cost_analyzer.is_recursive(func)

            if not is_recursive and func.blocks.len() == 1 and self.policy.should_inline(size, self.threshold):
                inline_candidates[func_symbol.id] = func
                inline_candidates_by_name[func.name] = func

        if inline_candidates.len() == 0:
            return module

        # Phase 2: For each function in the module, inline eligible callees
        var optimized_functions = module.functions
        for func_symbol in module.functions.keys():
            val func = module.functions[func_symbol]
            var optimized_blocks: [MirBlock] = []
            var modified = false

            for block in func.blocks:
                val result = self.inline_calls_in_block_with_candidates(
                    block, func, inline_candidates, inline_candidates_by_name, cost_analyzer
                )
                optimized_blocks = optimized_blocks.push(result.block)
                if result.did_inline:
                    modified = true

            if modified:
                optimized_functions[func_symbol] = copy_mir_function_with_blocks(func, optimized_blocks)
                self.inlined_total = self.inlined_total + 1

        MirModule(
            name: module.name,
            functions: optimized_functions,
            statics: module.statics,
            constants: module.constants,
            types: module.types
        )

# ============================================================================
# Inline Result
# ============================================================================

struct InlineResult:
    """Result of attempting to inline calls in a block."""
    block: MirBlock
    did_inline: bool

impl ModuleInliner:
    me inline_calls_in_block_with_candidates(
        block: MirBlock,
        caller: MirFunction,
        candidates: Dict<i64, MirFunction>,
        candidates_by_name: Dict<text, MirFunction>,
        cost_analyzer: InlineCostAnalyzer
    ) -> InlineResult:
        """
        Inline eligible calls in a block using known candidate functions.

        Scans block instructions for Call instructions whose callee symbol
        matches a candidate function. Looks up candidates by symbol ID first,
        then falls back to name-based lookup. For matching calls, replaces
        the call with the inlined function body.
        """
        var new_instructions: [MirInst] = []
        var did_inline = false

        for inst in block.instructions:
            match inst.kind:
                case Call(dest, callee_op, args):
                    # Try to resolve callee to a candidate function
                    # First try by symbol ID
                    var resolved_callee: MirFunction? = nil
                    val callee_id = self.extract_func_symbol_id(callee_op)
                    if callee_id.? and candidates.has(callee_id.unwrap()):
                        resolved_callee = Some(candidates[callee_id.unwrap()])

                    # Fall back to name-based lookup
                    if not resolved_callee.?:
                        val callee_name = self.extract_func_name(callee_op)
                        if callee_name.? and candidates_by_name.has(callee_name.unwrap()):
                            # Don't inline self
                            if callee_name.unwrap() != caller.name:
                                resolved_callee = Some(candidates_by_name[callee_name.unwrap()])

                    if resolved_callee.?:
                        val callee = resolved_callee.unwrap()
                        # Perform inlining for single-block callees
                        var inliner = FunctionInliner.new(caller.locals.len() + 100)
                        val temp_block = MirBlock(
                            id: block.id, label: block.label,
                            instructions: new_instructions, terminator: block.terminator
                        )
                        val inlined_blocks = inliner.inline_call(
                            temp_block, new_instructions.len(),
                            callee, dest, args
                        )
                        if inlined_blocks.len() > 0:
                            new_instructions = inlined_blocks[0].instructions
                            did_inline = true
                            continue
                    # Not inlineable - keep original instruction
                    new_instructions = new_instructions.push(inst)
                case _:
                    new_instructions = new_instructions.push(inst)

        if did_inline:
            InlineResult(
                block: MirBlock(
                    id: block.id, label: block.label,
                    instructions: new_instructions, terminator: block.terminator
                ),
                did_inline: true
            )
        else:
            InlineResult(block: block, did_inline: false)

    fn extract_func_symbol_id(op: MirOperand) -> i64?:
        """Extract function symbol ID from a Const operand with FuncPtr type."""
        match op.kind:
            case Const(value, type_):
                match value:
                    case Int(id):
                        match type_.kind:
                            case FuncPtr(_): Some(id)
                            case _: nil
                    case _: nil
            case _: nil

    fn extract_func_name(op: MirOperand) -> text?:
        """Extract function name from a Const operand with FuncPtr type and Str value."""
        match op.kind:
            case Const(value, type_):
                match type_.kind:
                    case FuncPtr(_):
                        match value:
                            case Str(name): Some(name)
                            case _: nil
                    case _: nil
            case _: nil

# ============================================================================
# Factory Functions
# ============================================================================

fn create_inline_small_pass() -> FunctionInlining:
    """Create inlining pass for small functions (code size optimization)."""
    FunctionInlining.small_functions()

fn create_inline_pass() -> FunctionInlining:
    """Create standard inlining pass (speed optimization)."""
    FunctionInlining.aggressive()

fn create_inline_aggressive_pass() -> FunctionInlining:
    """Create aggressive inlining pass (maximum speed)."""
    FunctionInlining.very_aggressive()

# ============================================================================
# Exports
# ============================================================================

export FunctionInlining, ModuleInliner, InlineResult
export InlinePolicy, InlineCostAnalyzer, FunctionInliner
export create_inline_small_pass, create_inline_pass, create_inline_aggressive_pass
