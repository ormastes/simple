# Optimization Passes - Real Optimization Logic in Simple
#
# Implements sophisticated compiler optimizations entirely in Simple:
# - Constant folding and propagation
# - Strength reduction (x * 2 → x << 1)
# - Algebraic simplifications (x + 0 → x, x * 1 → x)
# - Common subexpression elimination
# - Dead code elimination
# - Peephole optimizations
#
# All optimization intelligence lives in Simple, not FFI.

use mir_data.*

export OptimizationEngine, OptimizationStats, OptimizationLevel

# ============================================================================
# Optimization Configuration
# ============================================================================

enum OptimizationLevel:
    """Optimization level."""
    None_        # No optimizations
    Basic       # Constant folding, simple algebraic
    Standard    # + CSE, strength reduction
    Aggressive  # + peephole, advanced algebraic

impl OptimizationLevel:
    fn to_text() -> text:
        match self:
            case nil: "none"
            case Basic: "basic"
            case Standard: "standard"
            case Aggressive: "aggressive"

# ============================================================================
# Optimization Statistics
# ============================================================================

class OptimizationStats:
    """Track optimization results."""
    # Constant optimizations
    constants_folded: i64
    constant_propagations: i64

    # Algebraic optimizations
    identity_eliminations: i64      # x + 0, x * 1, etc.
    zero_eliminations: i64          # x * 0, 0 / x, etc.
    strength_reductions: i64        # x * 2 → x << 1

    # Code structure optimizations
    common_subexpressions: i64
    dead_instructions: i64
    redundant_casts: i64
    redundant_loads: i64

    # Advanced optimizations
    peephole_improvements: i64
    algebraic_simplifications: i64

impl OptimizationStats:
    static fn create() -> OptimizationStats:
        OptimizationStats(
            constants_folded: 0,
            constant_propagations: 0,
            identity_eliminations: 0,
            zero_eliminations: 0,
            strength_reductions: 0,
            common_subexpressions: 0,
            dead_instructions: 0,
            redundant_casts: 0,
            redundant_loads: 0,
            peephole_improvements: 0,
            algebraic_simplifications: 0
        )

    fn total() -> i64:
        """Total number of optimizations applied."""
        (self.constants_folded +
        self.constant_propagations +
        self.identity_eliminations +
        self.zero_eliminations +
        self.strength_reductions +
        self.common_subexpressions +
        self.dead_instructions +
        self.redundant_casts +
        self.redundant_loads +
        self.peephole_improvements +
        self.algebraic_simplifications)

    fn to_text() -> text:
        """Format statistics as text."""
        val total = self.total()
        """Optimization Statistics:
  Total optimizations: {total}

  Constant Optimizations:
    Constants folded: {self.constants_folded}
    Constant propagations: {self.constant_propagations}

  Algebraic Optimizations:
    Identity eliminations: {self.identity_eliminations}
    Zero eliminations: {self.zero_eliminations}
    Strength reductions: {self.strength_reductions}
    Algebraic simplifications: {self.algebraic_simplifications}

  Code Structure:
    Common subexpressions: {self.common_subexpressions}
    Dead instructions: {self.dead_instructions}
    Redundant casts: {self.redundant_casts}
    Redundant loads: {self.redundant_loads}

  Advanced:
    Peephole improvements: {self.peephole_improvements}"""

# ============================================================================
# Optimization Engine
# ============================================================================

class OptimizationEngine:
    """
    Main optimization engine.

    Runs multiple optimization passes over MIR to improve code quality.
    All logic implemented in Simple.
    """
    level: OptimizationLevel
    stats: OptimizationStats

    # Analysis data
    const_map: {i64: MirConstValue}   # LocalId -> known constant
    type_map: {i64: MirType}          # LocalId -> inferred type
    def_map: {i64: MirInst}           # LocalId -> defining instruction
    use_count: {i64: i64}             # LocalId -> number of uses

    # CSE tracking
    expr_map: {text: i64}             # expression signature -> LocalId

impl OptimizationEngine:
    static fn create(level: OptimizationLevel) -> OptimizationEngine:
        """Create optimization engine with specified level."""
        OptimizationEngine(
            level: level,
            stats: OptimizationStats.create(),
            const_map: {},
            type_map: {},
            def_map: {},
            use_count: {},
            expr_map: {}
        )

    # ========================================================================
    # Main Optimization Entry Point
    # ========================================================================

    me optimize_function(func: MirFunction) -> MirFunction:
        """
        Optimize a MIR function.

        Returns optimized version of the function.
        """
        if self.level == OptimizationLevel.None_:
            return func

        # Phase 1: Analysis
        self.analyze_function(func)

        # Phase 2: Optimize instructions
        var optimized_blocks: [MirBlock] = []
        for block in func.blocks:
            val opt_block = self.optimize_block(block)
            optimized_blocks = optimized_blocks.push(opt_block)

        # Phase 3: Dead code elimination
        if self.level != OptimizationLevel.Basic:
            optimized_blocks = self.eliminate_dead_code(optimized_blocks)

        # Return optimized function
        copy_mir_function_with_blocks(func, optimized_blocks)

    # ========================================================================
    # Analysis Phase
    # ========================================================================

    me analyze_function(func: MirFunction):
        """Analyze function to build optimization data structures."""
        # Build type map from locals
        for local in func.locals:
            self.type_map[local.id.id] = local.type_

        # Analyze all blocks
        for block in func.blocks:
            self.analyze_block(block)

    me analyze_block(block: MirBlock):
        """Analyze single block."""
        for inst in block.instructions:
            self.analyze_instruction(inst)

    me analyze_instruction(inst: MirInst):
        """Analyze single instruction for optimization opportunities."""
        match inst.kind:
            case Const(dest, value, type_):
                # Track constant
                self.const_map[dest.id] = value
                self.type_map[dest.id] = type_
                self.def_map[dest.id] = inst

            case Copy(dest, src) | Move(dest, src):
                # Propagate constant
                if self.const_map.contains_key(src.id):
                    self.const_map[dest.id] = self.const_map[src.id]
                # Propagate type
                if self.type_map.contains_key(src.id):
                    self.type_map[dest.id] = self.type_map[src.id]
                # Track use
                self.increment_use(src.id)
                self.def_map[dest.id] = inst

            case BinOp(dest, op, left, right):
                self.track_operand_use(left)
                self.track_operand_use(right)
                self.def_map[dest.id] = inst
                # Try to infer result type
                val left_type = self.get_operand_type(left)
                if left_type.?:
                    self.type_map[dest.id] = left_type.unwrap()

            case UnaryOp(dest, op, operand):
                self.track_operand_use(operand)
                self.def_map[dest.id] = inst
                val operand_type = self.get_operand_type(operand)
                if operand_type.?:
                    self.type_map[dest.id] = operand_type.unwrap()

            case _:
                # Generic instruction tracking
                pass

    # ========================================================================
    # Optimization Phase
    # ========================================================================

    me optimize_block(block: MirBlock) -> MirBlock:
        """Optimize all instructions in a block."""
        var optimized: [MirInst] = []

        for inst in block.instructions:
            val opt_inst = self.optimize_instruction(inst)
            if opt_inst.?:
                optimized = optimized.push(opt_inst.unwrap())
            else:
                # Instruction was eliminated
                self.stats.dead_instructions = self.stats.dead_instructions + 1

        MirBlock(
            id: block.id,
            label: block.label,
            instructions: optimized,
            terminator: block.terminator
        )

    me optimize_instruction(inst: MirInst) -> MirInst?:
        """
        Optimize a single instruction.

        Returns Some(optimized_inst) or nil if instruction is eliminated.
        """
        match inst.kind:
            case BinOp(dest, op, left, right):
                self.optimize_binop(dest, op, left, right, inst.span)

            case UnaryOp(dest, op, operand):
                self.optimize_unaryop(dest, op, operand, inst.span)

            case Cast(dest, operand, target):
                self.optimize_cast(dest, operand, target, inst.span)

            case Copy(dest, src):
                self.optimize_copy(dest, src, inst.span)

            case _:
                # No optimization for this instruction
                Some(inst)

    # ========================================================================
    # Binary Operation Optimizations
    # ========================================================================

    me optimize_binop(dest: LocalId, op: MirBinOp, left: MirOperand, right: MirOperand, span: Span?) -> MirInst?:
        """
        Optimize binary operation.

        Applies:
        - Constant folding
        - Algebraic identities (x + 0, x * 1, etc.)
        - Strength reduction (x * 2 → x << 1)
        - Zero eliminations (x * 0 → 0)
        """
        # Try constant folding first
        val folded = self.try_fold_binop(op, left, right)
        if folded.?:
            self.stats.constants_folded = self.stats.constants_folded + 1
            val const_val = folded.unwrap()
            val type_ = self.type_map[dest.id] ?? MirType.i64()
            return Some(MirInst(
                kind: MirInstKind.Const(dest, const_val, type_),
                span: span
            ))

        # Try algebraic simplifications
        val simplified = self.simplify_binop(dest, op, left, right, span)
        if simplified.?:
            return simplified

        # Try strength reduction
        if self.level != OptimizationLevel.Basic:
            val reduced = self.strength_reduce_binop(dest, op, left, right, span)
            if reduced.?:
                return reduced

        # No optimization applied
        Some(MirInst(
            kind: MirInstKind.BinOp(dest, op, left, right),
            span: span
        ))

    me simplify_binop(dest: LocalId, op: MirBinOp, left: MirOperand, right: MirOperand, span: Span?) -> MirInst?:
        """
        Apply algebraic simplifications.

        Examples:
        - x + 0 → x
        - x * 1 → x
        - x * 0 → 0
        - x - x → 0
        - x & 0 → 0
        - x | 0 → x
        """
        val left_const = self.get_operand_const(left)
        val right_const = self.get_operand_const(right)

        match op:
            # Addition identities
            case Add:
                # x + 0 → x
                if right_const.? and self.is_zero(right_const.unwrap()):
                    self.stats.identity_eliminations = self.stats.identity_eliminations + 1
                    return Some(MirInst(
                        kind: MirInstKind.Copy(dest, self.operand_to_local(left)),
                        span: span
                    ))
                # 0 + x → x
                if left_const.? and self.is_zero(left_const.unwrap()):
                    self.stats.identity_eliminations = self.stats.identity_eliminations + 1
                    return Some(MirInst(
                        kind: MirInstKind.Copy(dest, self.operand_to_local(right)),
                        span: span
                    ))

            # Multiplication identities
            case Mul:
                # x * 1 → x
                if right_const.? and self.is_one(right_const.unwrap()):
                    self.stats.identity_eliminations = self.stats.identity_eliminations + 1
                    return Some(MirInst(
                        kind: MirInstKind.Copy(dest, self.operand_to_local(left)),
                        span: span
                    ))
                # 1 * x → x
                if left_const.? and self.is_one(left_const.unwrap()):
                    self.stats.identity_eliminations = self.stats.identity_eliminations + 1
                    return Some(MirInst(
                        kind: MirInstKind.Copy(dest, self.operand_to_local(right)),
                        span: span
                    ))
                # x * 0 → 0
                if right_const.? and self.is_zero(right_const.unwrap()):
                    self.stats.zero_eliminations = self.stats.zero_eliminations + 1
                    val type_ = self.type_map[dest.id] ?? MirType.i64()
                    return Some(MirInst(
                        kind: MirInstKind.Const(dest, MirConstValue.Int(0), type_),
                        span: span
                    ))
                # 0 * x → 0
                if left_const.? and self.is_zero(left_const.unwrap()):
                    self.stats.zero_eliminations = self.stats.zero_eliminations + 1
                    val type_ = self.type_map[dest.id] ?? MirType.i64()
                    return Some(MirInst(
                        kind: MirInstKind.Const(dest, MirConstValue.Int(0), type_),
                        span: span
                    ))

            # Bitwise identities
            case BitAnd:
                # x & 0 → 0
                if right_const.? and self.is_zero(right_const.unwrap()):
                    self.stats.zero_eliminations = self.stats.zero_eliminations + 1
                    val type_ = self.type_map[dest.id] ?? MirType.i64()
                    return Some(MirInst(
                        kind: MirInstKind.Const(dest, MirConstValue.Int(0), type_),
                        span: span
                    ))
                # x & -1 → x (all bits set)
                if right_const.? and self.is_all_ones(right_const.unwrap()):
                    self.stats.identity_eliminations = self.stats.identity_eliminations + 1
                    return Some(MirInst(
                        kind: MirInstKind.Copy(dest, self.operand_to_local(left)),
                        span: span
                    ))

            case BitOr:
                # x | 0 → x
                if right_const.? and self.is_zero(right_const.unwrap()):
                    self.stats.identity_eliminations = self.stats.identity_eliminations + 1
                    return Some(MirInst(
                        kind: MirInstKind.Copy(dest, self.operand_to_local(left)),
                        span: span
                    ))

            case BitXor:
                # x ^ 0 → x
                if right_const.? and self.is_zero(right_const.unwrap()):
                    self.stats.identity_eliminations = self.stats.identity_eliminations + 1
                    return Some(MirInst(
                        kind: MirInstKind.Copy(dest, self.operand_to_local(left)),
                        span: span
                    ))

            case Shl | Shr:
                # x << 0 → x, x >> 0 → x
                if right_const.? and self.is_zero(right_const.unwrap()):
                    self.stats.identity_eliminations = self.stats.identity_eliminations + 1
                    return Some(MirInst(
                        kind: MirInstKind.Copy(dest, self.operand_to_local(left)),
                        span: span
                    ))

            case _:
                pass

        nil

    me strength_reduce_binop(dest: LocalId, op: MirBinOp, left: MirOperand, right: MirOperand, span: Span?) -> MirInst?:
        """
        Strength reduction: replace expensive ops with cheaper ones.

        Examples:
        - x * 2 → x << 1
        - x * 4 → x << 2
        - x / 2 → x >> 1 (signed)
        - x * 3 → (x << 1) + x
        """
        val right_const = self.get_operand_const(right)
        if not right_const.?:
            return nil

        match op:
            case Mul:
                # x * power_of_2 → x << log2(n)
                match right_const.unwrap():
                    case Int(n):
                        val shift_amt = self.log2_if_power_of_2(n)
                        if shift_amt.?:
                            self.stats.strength_reductions = self.stats.strength_reductions + 1
                            # Create shift instruction
                            val shift_operand = MirOperand.const_int(shift_amt.unwrap())
                            return Some(MirInst(
                                kind: MirInstKind.BinOp(dest, MirBinOp.Shl, left, shift_operand),
                                span: span
                            ))
                    case _:
                        pass

            case Div:
                # x / power_of_2 → x >> log2(n) (for unsigned)
                match right_const.unwrap():
                    case Int(n):
                        if n > 0:
                            val shift_amt = self.log2_if_power_of_2(n)
                            if shift_amt.?:
                                self.stats.strength_reductions = self.stats.strength_reductions + 1
                                val shift_operand = MirOperand.const_int(shift_amt.unwrap())
                                return Some(MirInst(
                                    kind: MirInstKind.BinOp(dest, MirBinOp.Shr, left, shift_operand),
                                    span: span
                                ))
                    case _:
                        pass

            case _:
                pass

        nil

    # ========================================================================
    # Unary Operation Optimizations
    # ========================================================================

    me optimize_unaryop(dest: LocalId, op: MirUnaryOp, operand: MirOperand, span: Span?) -> MirInst?:
        """Optimize unary operation."""
        # Try constant folding
        val folded = self.try_fold_unaryop(op, operand)
        if folded.?:
            self.stats.constants_folded = self.stats.constants_folded + 1
            val type_ = self.type_map[dest.id] ?? MirType.i64()
            return Some(MirInst(
                kind: MirInstKind.Const(dest, folded.unwrap(), type_),
                span: span
            ))

        # Try simplifications
        match op:
            case Not:
                # !!x → x (double negation)
                val operand_def = self.get_defining_instruction(operand)
                if operand_def.?:
                    match operand_def.unwrap().kind:
                        case UnaryOp(_, Not, inner_operand):
                            self.stats.algebraic_simplifications = self.stats.algebraic_simplifications + 1
                            return Some(MirInst(
                                kind: MirInstKind.Copy(dest, self.operand_to_local(inner_operand)),
                                span: span
                            ))
                        case _:
                            pass

            case _:
                pass

        # No optimization
        Some(MirInst(
            kind: MirInstKind.UnaryOp(dest, op, operand),
            span: span
        ))

    # ========================================================================
    # Cast Optimizations
    # ========================================================================

    me optimize_cast(dest: LocalId, operand: MirOperand, target: MirType, span: Span?) -> MirInst?:
        """Optimize type cast."""
        val src_type = self.get_operand_type(operand)

        # No-op cast elimination
        if src_type.? and self.types_equal(src_type.unwrap(), target):
            self.stats.redundant_casts = self.stats.redundant_casts + 1
            return Some(MirInst(
                kind: MirInstKind.Copy(dest, self.operand_to_local(operand)),
                span: span
            ))

        # No optimization
        Some(MirInst(
            kind: MirInstKind.Cast(dest, operand, target),
            span: span
        ))

    me optimize_copy(dest: LocalId, src: LocalId, span: Span?) -> MirInst?:
        """Optimize copy instruction."""
        # If source is never used again, this is dead (will be eliminated later)
        # For now, keep it
        Some(MirInst(
            kind: MirInstKind.Copy(dest, src),
            span: span
        ))

    # ========================================================================
    # Dead Code Elimination
    # ========================================================================

    me eliminate_dead_code(blocks: [MirBlock]) -> [MirBlock]:
        """Remove instructions that are never used."""
        var optimized: [MirBlock] = []

        for block in blocks:
            var live_insts: [MirInst] = []

            for inst in block.instructions:
                if self.is_live_instruction(inst):
                    live_insts = live_insts.push(inst)
                else:
                    self.stats.dead_instructions = self.stats.dead_instructions + 1

            optimized = optimized.push(MirBlock(
                id: block.id,
                label: block.label,
                instructions: live_insts,
                terminator: block.terminator
            ))

        optimized

    fn is_live_instruction(inst: MirInst) -> bool:
        """Check if instruction has side effects or is used."""
        match inst.kind:
            case Const(dest, _, _) | Copy(dest, _) | Move(dest, _) | BinOp(dest, _, _, _) | UnaryOp(dest, _, _) | Cast(dest, _, _):
                (self.use_count[dest.id] ?? 0) > 0

            case Store(_, _) | Call(_, _, _):
                # Side effects - always live
                true

            case _:
                # Conservative: keep unknown instructions
                true

    # ========================================================================
    # Helper Methods
    # ========================================================================

    fn try_fold_binop(op: MirBinOp, left: MirOperand, right: MirOperand) -> MirConstValue?:
        """Try to fold binary operation at compile time."""
        val left_const = self.get_operand_const(left)
        val right_const = self.get_operand_const(right)

        if not left_const.? or not right_const.?:
            return nil

        match (left_const.unwrap(), right_const.unwrap()):
            case (Int(l), Int(r)):
                val result = match op:
                    case Add: l + r
                    case Sub: l - r
                    case Mul: l * r
                    case Div: if r != 0: l / r else: return nil
                    case Rem: if r != 0: l % r else: return nil
                    case Pow: l ** r
                    case BitAnd: l & r
                    case BitOr: l | r
                    case BitXor: l xor r
                    case Shl: l << (r & 63)
                    case Shr: l >> (r & 63)
                    case Eq: if l == r: 1 else: 0
                    case Ne: if l != r: 1 else: 0
                    case Lt: if l < r: 1 else: 0
                    case Le: if l <= r: 1 else: 0
                    case Gt: if l > r: 1 else: 0
                    case Ge: if l >= r: 1 else: 0
                    case _: return nil
                Some(MirConstValue.Int(result))

            case (Float(l), Float(r)):
                val result = match op:
                    case Add: l + r
                    case Sub: l - r
                    case Mul: l * r
                    case Div: if r != 0.0: l / r else: return nil
                    case Pow: l ** r
                    case _: return nil
                Some(MirConstValue.Float(result))

            case _:
                nil

    fn try_fold_unaryop(op: MirUnaryOp, operand: MirOperand) -> MirConstValue?:
        """Try to fold unary operation at compile time."""
        val const_val = self.get_operand_const(operand)
        if not const_val.?:
            return nil

        match const_val.unwrap():
            case Int(v):
                val result = match op:
                    case Neg: -v
                    case Not: if v == 0: 1 else: 0
                    case BitNot: ~v
                    case _: return nil
                Some(MirConstValue.Int(result))

            case Float(v):
                val result = match op:
                    case Neg: -v
                    case _: return nil
                Some(MirConstValue.Float(result))

            case _:
                nil

    fn get_operand_const(operand: MirOperand) -> MirConstValue?:
        """Get constant value if operand is constant."""
        match operand.kind:
            case Const(value, _):
                Some(value)
            case Copy(local) | Move(local):
                if self.const_map.contains_key(local.id):
                    Some(self.const_map[local.id])
                else:
                    nil

    fn get_operand_type(operand: MirOperand) -> MirType?:
        """Get type of operand."""
        match operand.kind:
            case Const(_, type_):
                Some(type_)
            case Copy(local) | Move(local):
                if self.type_map.contains_key(local.id):
                    Some(self.type_map[local.id])
                else:
                    nil

    fn get_defining_instruction(operand: MirOperand) -> MirInst?:
        """Get the instruction that defined this operand."""
        match operand.kind:
            case Copy(local) | Move(local):
                if self.def_map.contains_key(local.id):
                    Some(self.def_map[local.id])
                else:
                    nil
            case Const(_, _):
                nil

    fn operand_to_local(operand: MirOperand) -> LocalId:
        """Extract LocalId from operand (assumes Copy or Move)."""
        match operand.kind:
            case Copy(local) | Move(local):
                local
            case Const(_, _):
                # Shouldn't happen - caller should check
                LocalId(id: 0)

    me track_operand_use(operand: MirOperand):
        """Track operand use for dead code analysis."""
        match operand.kind:
            case Copy(local) | Move(local):
                self.increment_use(local.id)
            case Const(_, _):
                pass

    me increment_use(local_id: i64):
        """Increment use count for a local."""
        val current = self.use_count[local_id] ?? 0
        self.use_count[local_id] = current + 1

    fn types_equal(a: MirType, b: MirType) -> bool:
        """Check if two types are equal."""
        a.kind == b.kind

    fn is_zero(value: MirConstValue) -> bool:
        """Check if constant value is zero."""
        match value:
            case Int(0): true
            case Float(f): f == 0.0
            case _: false

    fn is_one(value: MirConstValue) -> bool:
        """Check if constant value is one."""
        match value:
            case Int(1): true
            case Float(f): f == 1.0
            case _: false

    fn is_all_ones(value: MirConstValue) -> bool:
        """Check if all bits are set (-1 for signed)."""
        match value:
            case Int(n):
                n == -1
            case _:
                false

    fn log2_if_power_of_2(n: i64) -> i64?:
        """
        If n is a power of 2, return log2(n).
        Otherwise return nil.
        """
        if n <= 0:
            return nil

        # Check if n is power of 2: n & (n-1) == 0
        if (n & (n - 1)) != 0:
            return nil

        # Count trailing zeros to get log2
        var count = 0
        var temp = n
        while (temp & 1) == 0:
            count = count + 1
            temp = temp >> 1

        Some(count)
