# Loop Optimization
#
# Optimizes loop structures for better performance.
#
# Transformations:
#   1. Loop-Invariant Code Motion (LICM)
#   2. Loop Unrolling
#   3. Strength Reduction
#
# Example - Loop-Invariant Code Motion:
#   for i in 0..100:
#       val x = a * b    # Invariant! (doesn't depend on i)
#       val y = x + i
#
# After LICM:
#   val x = a * b        # Hoisted out of loop
#   for i in 0..100:
#       val y = x + i
#
# Example - Loop Unrolling:
#   for i in 0..4:
#       process(i)
#
# After unrolling:
#   process(0)
#   process(1)
#   process(2)
#   process(3)
#
# Benefits:
# - LICM: Eliminates redundant computation in loops
# - Unrolling: Reduces loop overhead, enables more optimization
# - Strength reduction: Replaces expensive ops with cheaper ones
#
# Costs:
# - Increases code size (unrolling)
# - May hurt I-cache if too aggressive
# - Compile time overhead
#
# Strategy:
# - LICM: Always beneficial (moves invariant code out)
# - Unrolling: Only small loops (< 8 iterations)
# - Strength reduction: When profitable (mul -> add in loop)

use compiler.mir_data.*
use compiler.mir.*
use compiler.mir_opt.mod.{MirPass}

# ============================================================================
# Loop Detection
# ============================================================================

struct EdgePair:
    """Represents an edge between two blocks."""
    from: BlockId
    to: BlockId

class LoopInfo:
    """
    Information about a loop in the MIR.

    A loop is a set of basic blocks with:
    - Header: Entry point (dominates all blocks in loop)
    - Backedges: Edges that jump back to header
    - Body: All blocks in the loop
    - Exit edges: Edges leaving the loop
    - Trip count: Constant iteration count if determinable
    """
    header: BlockId
    body: [BlockId]
    backedges: [BlockId]  # Blocks that jump back to header
    exit_edges: [EdgePair]  # Edges leaving the loop
    trip_count: i64?       # Constant iteration count (if determinable)

impl LoopInfo:
    fn contains_block(block_id: BlockId) -> bool:
        """Check if block is in this loop."""
        if block_id.id == self.header.id:
            return true

        for body_block in self.body:
            if body_block.id == block_id.id:
                return true

        false

    fn iteration_count() -> i64?:
        """
        Try to determine constant iteration count.

        Returns Some(n) if loop has constant iteration count.
        The trip count is computed during loop detection by analyzing
        exit edge comparison instructions (e.g., i < N where N is constant).
        """
        self.trip_count

# ============================================================================
# Loop Detector
# ============================================================================

class LoopDetector:
    """
    Detects loops in MIR via backedge analysis.

    Algorithm:
    1. Build CFG (control flow graph)
    2. Find strongly connected components (SCCs)
    3. Identify natural loops (single-entry SCCs with backedges)
    """
    loops: [LoopInfo]

impl LoopDetector:
    static fn new() -> LoopDetector:
        LoopDetector(loops: [])

    me detect_loops(func: MirFunction):
        """
        Detect all loops in function.

        For now, simple heuristic:
        - Look for blocks that jump backwards (to earlier block)
        - These indicate potential loops
        """
        # Reset loops
        self.loops = []

        # Find potential loop headers (blocks jumped to from later blocks)
        var potential_headers: [BlockId] = []

        for block in func.blocks:
            val successors = self.get_successors(block.terminator)
            for succ in successors:
                # Check if successor appears earlier in block list
                if self.block_index(func, succ) <= self.block_index(func, block.id):
                    # Potential backedge
                    if not self.is_block_in_list(succ, potential_headers):
                        potential_headers.push(succ)

        # Build LoopInfo for each header
        for header in potential_headers:
            val loop_info = self.build_loop_info(func, header)
            self.loops.push(loop_info)

    # TEMPORARILY COMMENTED OUT - Testing parse error location
    # fn get_successors(term: MirTerminator) -> [BlockId]:
    #     """Get successor blocks from terminator."""
    #     match term:
    #         case Return(_): []
    #         case Unreachable: []
    #         case Goto(target): [target]
    #         case If(_, then_, else_): [then_, else_]
    #         case Switch(_, targets, default):
    #             var succs: [BlockId] = []
    #             for case_item in targets:
    #                 succs.push(case_item.target)
    #             succs.push(default)
    #             succs
    #         case CallTerminator(_, _, _, normal, unwind):
    #             if unwind.?:
    #                 [normal, unwind.unwrap()]
    #             else:
    #                 [normal]
    #         case _: []

    # WORKAROUND VERSION:
    fn get_successors(term: MirTerminator) -> [BlockId]:
        """Get successor blocks from terminator."""
        val empty: [BlockId] = []
        match term:
            case Return(_): empty
            case Unreachable: empty
            case Goto(target): [target]
            case If(_, then_, else_): [then_, else_]
            case Switch(_, targets, default):
                var succs: [BlockId] = []
                for case_item in targets:
                    succs.push(case_item.target)
                succs.push(default)
                succs
            case CallTerminator(_, _, _, normal, unwind):
                if unwind.?:
                    [normal, unwind.unwrap()]
                else:
                    [normal]
            case _: empty

    fn build_loop_info(func: MirFunction, header: BlockId) -> LoopInfo:
        """Build LoopInfo for loop with given header."""
        # Simple implementation: find all blocks that can reach header
        var body: [BlockId] = []
        var backedges: [BlockId] = []

        for block in func.blocks:
            if block.id.id == header.id:
                continue

            val successors = self.get_successors(block.terminator)
            for succ in successors:
                if succ.id == header.id:
                    # This block jumps to header
                    backedges.push(block.id)
                    if not self.is_block_in_list(block.id, body):
                        body.push(block.id)

        # Detect exit edges: edges from body blocks to non-body blocks
        var exit_edges: [BlockId] = []
        val all_body = [header] + body
        for block in func.blocks:
            if not self.is_block_in_list(block.id, all_body):
                continue
            val successors = self.get_successors(block.terminator)
            for succ in successors:
                if not self.is_block_in_list(succ, all_body):
                    if not self.is_block_in_list(succ, exit_edges):
                        exit_edges.push(succ)

        # Analyze iteration count from exit conditions
        # Look at conditional terminators in loop blocks that branch out
        val trip_count = self.analyze_trip_count(func, header, all_body)

        LoopInfo(
            header: header,
            body: body,
            backedges: backedges,
            exit_edges: exit_edges,
            trip_count: trip_count
        )

    fn analyze_trip_count(func: MirFunction, header: BlockId, loop_blocks: [BlockId]) -> i64?:
        """
        Analyze loop exit conditions to determine constant trip count.

        Looks for patterns like:
        - Header block has If terminator comparing a local against a constant
        - The comparison is Lt (i < N) where N is a constant integer
        - One branch exits the loop, the other stays in

        Returns Some(N) if a constant bound is found, nil otherwise.
        """
        # Check each block in the loop for conditional exits
        for block in func.blocks:
            if not self.is_block_in_list(block.id, loop_blocks):
                continue

            # Look for If terminators that compare against a constant
            match block.terminator:
                case If(cond, then_, else_):
                    # Check if one target exits the loop and the other stays
                    val then_in_loop = self.is_block_in_list(then_, loop_blocks)
                    val else_in_loop = self.is_block_in_list(else_, loop_blocks)

                    # Exactly one branch should exit for a counted loop
                    if then_in_loop and not else_in_loop:
                        # else_ is the exit branch; cond being true continues
                        val bound = self.extract_comparison_bound(block.instructions, cond)
                        if bound.?:
                            return bound
                    elif not then_in_loop and else_in_loop:
                        # then_ is the exit branch; cond being false continues
                        val bound = self.extract_comparison_bound(block.instructions, cond)
                        if bound.?:
                            return bound
                case _:
                    pass

        nil

    fn extract_comparison_bound(instructions: [MirInst], cond: MirOperand) -> i64?:
        """
        Extract constant bound from a comparison used as loop exit condition.

        Looks for BinOp instructions that define the condition operand and have
        a comparison op (Lt, Le, Gt, Ge) with a constant integer operand.

        For `i < N` returns N, for `i <= N` returns N + 1.
        """
        # Find which local the condition references
        val cond_local_id = match cond.kind:
            case Copy(local): Some(local.id)
            case Move(local): Some(local.id)
            case _: nil

        if not cond_local_id.?:
            return nil

        val target_id = cond_local_id.unwrap()

        # Scan instructions for the BinOp that defines this local
        for inst in instructions:
            match inst.kind:
                case BinOp(dest, op, left, right):
                    if dest.id == target_id:
                        # Found the comparison instruction
                        # Check if it's a comparison with a constant bound
                        val const_val = self.operand_const_int(right)
                        if const_val.?:
                            match op:
                                case Lt:
                                    # i < N -> trip count is N
                                    return const_val
                                case Le:
                                    # i <= N -> trip count is N + 1
                                    return Some(const_val.unwrap() + 1)
                                case _:
                                    pass

                        # Also check left operand (for reversed comparisons like N > i)
                        val const_val_l = self.operand_const_int(left)
                        if const_val_l.?:
                            match op:
                                case Gt:
                                    # N > i -> trip count is N
                                    return const_val_l
                                case Ge:
                                    # N >= i -> trip count is N + 1
                                    return Some(const_val_l.unwrap() + 1)
                                case _:
                                    pass
                case _:
                    pass

        nil

    fn operand_const_int(op: MirOperand) -> i64?:
        """Extract constant integer value from operand, if it is one."""
        match op.kind:
            case Const(value, _):
                match value:
                    case Int(n): Some(n)
                    case _: nil
            case _: nil

    fn block_index(func: MirFunction, block_id: BlockId) -> i64:
        """Find index of block in function."""
        var idx = 0
        for block in func.blocks:
            if block.id.id == block_id.id:
                return idx
            idx = idx + 1
        -1

    fn is_block_in_list(block_id: BlockId, list: [BlockId]) -> bool:
        """Check if block is in list."""
        for item in list:
            if item.id == block_id.id:
                return true
        false

    fn find_loop_for_block(block_id: BlockId) -> LoopInfo?:
        """Find innermost loop containing block."""
        for loop in self.loops:
            if loop.contains_block(block_id):
                return Some(loop)
        nil

# ============================================================================
# Loop-Invariant Code Motion (LICM)
# ============================================================================

class LoopInvariantMotion:
    """
    Moves loop-invariant code out of loops.

    An instruction is loop-invariant if:
    1. All operands are defined outside loop, OR
    2. All operands are themselves loop-invariant

    Algorithm:
    1. Identify loop-invariant instructions
    2. Hoist to loop preheader (block before loop)
    3. Update uses
    """
    detector: LoopDetector
    hoisted_count: i64

impl LoopInvariantMotion:
    static fn new() -> LoopInvariantMotion:
        LoopInvariantMotion(
            detector: LoopDetector.new(),
            hoisted_count: 0
        )

    me optimize_function(func: MirFunction) -> MirFunction:
        """Run LICM on function."""
        # Detect loops
        self.detector.detect_loops(func)

        if self.detector.loops.len() == 0:
            # No loops to optimize
            return func

        # For each loop, identify and hoist invariant code
        var optimized_blocks = func.blocks

        for loop in self.detector.loops:
            optimized_blocks = self.hoist_invariants(optimized_blocks, loop)

        copy_mir_function_with_blocks(func, optimized_blocks)

    me hoist_invariants(blocks: [MirBlock], loop: LoopInfo) -> [MirBlock]:
        """Hoist loop-invariant instructions out of loop."""
        # Build set of locals defined inside the loop
        var loop_defs: Dict<i64, bool> = {}
        for block in blocks:
            if loop.contains_block(block.id):
                for inst in block.instructions:
                    val dest = self.inst_dest(inst)
                    if dest.?:
                        loop_defs[dest.unwrap().id] = true

        # Find invariant instructions (all operands defined outside loop)
        var invariant_insts: [MirInst] = []
        var hoisted_ids: Dict<i64, bool> = {}

        for block in blocks:
            if loop.contains_block(block.id):
                for inst in block.instructions:
                    if self.is_loop_invariant(inst, loop_defs, hoisted_ids):
                        invariant_insts.push(inst)
                        val dest = self.inst_dest(inst)
                        if dest.?:
                            hoisted_ids[dest.unwrap().id] = true

        if invariant_insts.len() == 0:
            return blocks

        self.hoisted_count = self.hoisted_count + invariant_insts.len()

        # Build new blocks: add hoisted insts before header, remove from body
        var new_blocks: [MirBlock] = []
        var hoisted_to_preheader = false

        for block in blocks:
            if block.id.id == loop.header.id and not hoisted_to_preheader:
                # Insert hoisted instructions at start of header block
                var new_insts: [MirInst] = []
                for hinst in invariant_insts:
                    new_insts.push(hinst)
                for inst in block.instructions:
                    if not self.is_in_list(inst, invariant_insts):
                        new_insts.push(inst)
                new_blocks.push(MirBlock(
                    id: block.id, label: block.label,
                    instructions: new_insts, terminator: block.terminator
                ))
                hoisted_to_preheader = true
            elif loop.contains_block(block.id):
                # Remove hoisted instructions from loop body
                var kept: [MirInst] = []
                for inst in block.instructions:
                    if not self.is_in_list(inst, invariant_insts):
                        kept.push(inst)
                new_blocks.push(MirBlock(
                    id: block.id, label: block.label,
                    instructions: kept, terminator: block.terminator
                ))
            else:
                new_blocks.push(block)

        new_blocks

    fn is_loop_invariant(inst: MirInst, loop_defs: Dict<i64, bool>, hoisted: Dict<i64, bool>) -> bool:
        """Check if instruction is loop-invariant (operands defined outside loop or already hoisted)."""
        match inst.kind:
            case Const(_, _, _): true  # Constants are always invariant
            case BinOp(_, _, left, right):
                self.operand_invariant(left, loop_defs, hoisted) and self.operand_invariant(right, loop_defs, hoisted)
            case UnaryOp(_, _, operand):
                self.operand_invariant(operand, loop_defs, hoisted)
            case Copy(_, src):
                self.operand_invariant(mir_operand_copy(src), loop_defs, hoisted)
            case _: false  # Conservatively, don't hoist loads/stores/calls

    fn operand_invariant(op: MirOperand, loop_defs: Dict<i64, bool>, hoisted: Dict<i64, bool>) -> bool:
        """Check if operand is defined outside loop or already hoisted."""
        match op.kind:
            case Copy(local):
                val in_loop = loop_defs.has(local.id)
                val was_hoisted = hoisted.has(local.id)
                (not in_loop) or was_hoisted
            case Move(local):
                val in_loop = loop_defs.has(local.id)
                val was_hoisted = hoisted.has(local.id)
                (not in_loop) or was_hoisted
            case Const(_, _): true  # Constants are always invariant

    fn inst_dest(inst: MirInst) -> LocalId?:
        """Get destination local of instruction, if any."""
        match inst.kind:
            case Const(dest, _, _): dest
            case BinOp(dest, _, _, _): dest
            case UnaryOp(dest, _, _): dest
            case Copy(dest, _): dest
            case _: nil

    fn is_in_list(inst: MirInst, insts: [MirInst]) -> bool:
        """Check if instruction is in list (by span comparison)."""
        for other in insts:
            if inst.span.start == other.span.start and inst.span.end == other.span.end:
                val same_kind = self.inst_dest(inst).? and self.inst_dest(other).?
                if same_kind:
                    val d1 = self.inst_dest(inst).unwrap()
                    val d2 = self.inst_dest(other).unwrap()
                    if d1.id == d2.id:
                        return true
        false

# ============================================================================
# Loop Unrolling
# ============================================================================

class LoopUnroller:
    """
    Unrolls small loops to reduce overhead.

    Strategy:
    - Only unroll loops with constant iteration count
    - Only small loops (< 8 iterations)
    - Trade code size for reduced loop overhead

    Example:
      for i in 0..4:
          body(i)

    Becomes:
      body(0); body(1); body(2); body(3)
    """
    detector: LoopDetector
    unroll_threshold: i64
    unrolled_count: i64

impl LoopUnroller:
    static fn new(threshold: i64) -> LoopUnroller:
        LoopUnroller(
            detector: LoopDetector.new(),
            unroll_threshold: threshold,
            unrolled_count: 0
        )

    me optimize_function(func: MirFunction) -> MirFunction:
        """Run loop unrolling on function."""
        # Detect loops
        self.detector.detect_loops(func)

        if self.detector.loops.len() == 0:
            return func

        # For each loop, try to unroll if beneficial
        var optimized_blocks = func.blocks

        for loop in self.detector.loops:
            val iter_count = loop.iteration_count()
            if iter_count.? and iter_count.unwrap() <= self.unroll_threshold:
                # Small loop - unroll it
                optimized_blocks = self.unroll_loop(optimized_blocks, loop, iter_count.unwrap())
                self.unrolled_count = self.unrolled_count + 1

        copy_mir_function_with_blocks(func, optimized_blocks)

    me unroll_loop(blocks: [MirBlock], loop: LoopInfo, count: i64) -> [MirBlock]:
        """Unroll loop by duplicating body instructions count times.

        Strategy: Replace loop body with count copies of the body instructions
        in the header block, removing the backedge. This eliminates loop overhead
        (branch, counter increment) for small loops.
        """
        # Collect body instructions from all loop body blocks
        var body_insts: [MirInst] = []
        for block in blocks:
            if loop.contains_block(block.id):
                if block.id.id != loop.header.id:
                    for inst in block.instructions:
                        body_insts.push(inst)

        if body_insts.len() == 0:
            return blocks

        # Build unrolled instructions: duplicate body 'count' times
        var unrolled: [MirInst] = []
        for iteration in 0..count:
            for inst in body_insts:
                unrolled.push(inst)

        # Replace header block: keep header instructions + add unrolled body
        # Remove backedge (loop body blocks become empty)
        var new_blocks: [MirBlock] = []
        for block in blocks:
            if block.id.id == loop.header.id:
                # Header gets original instructions + unrolled body
                var combined: [MirInst] = []
                for inst in block.instructions:
                    combined.push(inst)
                for inst in unrolled:
                    combined.push(inst)
                new_blocks.push(MirBlock(
                    id: block.id, label: block.label,
                    instructions: combined, terminator: block.terminator
                ))
            elif loop.contains_block(block.id):
                # Body blocks become empty (instructions moved to header)
                new_blocks.push(MirBlock(
                    id: block.id, label: block.label,
                    instructions: [], terminator: block.terminator
                ))
            else:
                new_blocks.push(block)

        new_blocks

# ============================================================================
# Strength Reduction
# ============================================================================

class StrengthReduction:
    """
    Replaces expensive operations with cheaper ones in loops.

    Example transformations:
    - i * 4 -> i << 2 (multiply by power of 2)
    - i * c -> i + i + ... (multiply by small constant)
    - i / 2 -> i >> 1 (divide by power of 2)

    Most impactful in loop bodies where operation repeats.
    """
    reduced_count: i64

impl StrengthReduction:
    static fn new() -> StrengthReduction:
        StrengthReduction(reduced_count: 0)

    me optimize_function(func: MirFunction) -> MirFunction:
        """Run strength reduction on function."""
        var optimized_blocks: [MirBlock] = []

        for block in func.blocks:
            val optimized = self.reduce_block(block)
            optimized_blocks.push(optimized)

        copy_mir_function_with_blocks(func, optimized_blocks)

    me reduce_block(block: MirBlock) -> MirBlock:
        """Apply strength reduction to block."""
        var reduced_instructions: [MirInst] = []

        for inst in block.instructions:
            val reduced = self.try_reduce_instruction(inst)
            reduced_instructions.push(reduced)

        MirBlock(
            id: block.id,
            label: block.label,
            instructions: reduced_instructions,
            terminator: block.terminator
        )

    me try_reduce_instruction(inst: MirInst) -> MirInst:
        """Try to apply strength reduction to instruction."""
        match inst.kind:
            case BinOp(dest, op, left, right):
                # Try to reduce expensive binary operations
                val reduced = self.try_reduce_binop(dest, op, left, right, inst.span)
                if reduced.?:
                    self.reduced_count = self.reduced_count + 1
                    return reduced.unwrap()
                inst

            case _:
                # No reduction possible
                inst

    fn try_reduce_binop(
        dest: LocalId,
        op: MirBinOp,
        left: MirOperand,
        right: MirOperand,
        span: Span
    ) -> MirInst?:
        """
        Try to reduce binary operation.

        Patterns:
        - x * 2^n -> x << n
        - x / 2^n -> x >> n (unsigned)
        """
        # Strength reduction: multiply/divide by power of 2 â†’ shift
        match op:
            case Mul:
                # Check if right operand is a constant power of 2
                val shift = self.const_log2(right)
                if shift.?:
                    return MirInst(
                        kind: MirInstKind.BinOp(dest, MirBinOp.Shl, left, mir_operand_const_int(shift.unwrap())),
                        span: span
                    )
                # Also check left operand
                val shift_l = self.const_log2(left)
                if shift_l.?:
                    return MirInst(
                        kind: MirInstKind.BinOp(dest, MirBinOp.Shl, right, mir_operand_const_int(shift_l.unwrap())),
                        span: span
                    )
                nil
            case Div:
                # x / 2^n -> x >> n (for positive divisors)
                val shift = self.const_log2(right)
                if shift.?:
                    return MirInst(
                        kind: MirInstKind.BinOp(dest, MirBinOp.Shr, left, mir_operand_const_int(shift.unwrap())),
                        span: span
                    )
                nil
            case Rem:
                # x % 2^n -> x & (2^n - 1) (for positive values)
                val shift = self.const_log2(right)
                if shift.?:
                    val mask = (1 << shift.unwrap()) - 1
                    return MirInst(
                        kind: MirInstKind.BinOp(dest, MirBinOp.BitAnd, left, mir_operand_const_int(mask)),
                        span: span
                    )
                nil
            case _:
                nil

    fn const_log2(operand: MirOperand) -> i64?:
        """Check if operand is a constant power of 2, return log2 if so."""
        match operand.kind:
            case Const(const_val, _):
                match const_val:
                    case Int(n):
                        if n > 0:
                            # Check if n is a power of 2: n & (n-1) == 0
                            val is_pow2 = (n & (n - 1)) == 0
                            if is_pow2:
                                # Calculate log2 by checking bit positions
                                var shift = 0
                                for bit in 0..31:
                                    if (1 << bit) == n:
                                        shift = bit
                                return shift
                            nil
                        else:
                            nil
                    case _: nil
            case _: nil

# ============================================================================
# Combined Loop Optimization Pass
# ============================================================================

class LoopOptimization:
    """
    Combined loop optimization pass.

    Applies multiple loop optimizations:
    1. Loop-Invariant Code Motion (LICM)
    2. Strength Reduction (in loop bodies)
    3. Loop Unrolling (small loops)

    Run order matters:
    - LICM first (moves invariants out)
    - Strength reduction (simplifies remaining ops)
    - Unrolling last (duplicates simplified code)
    """
    licm: LoopInvariantMotion
    strength_reduction: StrengthReduction
    unroller: LoopUnroller
    enabled_licm: bool
    enabled_strength: bool
    enabled_unroll: bool

impl LoopOptimization:
    static fn new(
        enable_licm: bool,
        enable_strength: bool,
        enable_unroll: bool,
        unroll_threshold: i64
    ) -> LoopOptimization:
        LoopOptimization(
            licm: LoopInvariantMotion.new(),
            strength_reduction: StrengthReduction.new(),
            unroller: LoopUnroller.new(unroll_threshold),
            enabled_licm: enable_licm,
            enabled_strength: enable_strength,
            enabled_unroll: enable_unroll
        )

    static fn conservative() -> LoopOptimization:
        """Conservative loop optimization (LICM only)."""
        LoopOptimization.new(
            enable_licm: true,
            enable_strength: false,
            enable_unroll: false,
            unroll_threshold: 4
        )

    static fn aggressive() -> LoopOptimization:
        """Aggressive loop optimization (all passes)."""
        LoopOptimization.new(
            enable_licm: true,
            enable_strength: true,
            enable_unroll: true,
            unroll_threshold: 8
        )

    fn name() -> text:
        "loop_optimization"

    fn description() -> text:
        "Optimizes loops via LICM, strength reduction, and unrolling"

    fn is_analysis_pass() -> bool:
        false

    fn dependencies() -> [text]:
        ["constant_folding", "copy_propagation"]

    me run_on_function(func: MirFunction) -> MirFunction:
        """
        Run loop optimizations on function.

        Order:
        1. LICM (move invariants out)
        2. Strength reduction (simplify ops)
        3. Unrolling (duplicate small loops)
        """
        var current = func

        # Phase 1: Loop-Invariant Code Motion
        if self.enabled_licm:
            current = self.licm.optimize_function(current)

        # Phase 2: Strength Reduction
        if self.enabled_strength:
            current = self.strength_reduction.optimize_function(current)

        # Phase 3: Loop Unrolling
        if self.enabled_unroll:
            current = self.unroller.optimize_function(current)

        current

    # ========================================================================
    # Statistics
    # ========================================================================

    fn stats_summary() -> text:
        """Generate summary of optimization work."""
        val licm_count = self.licm.hoisted_count
        val reduced_count = self.strength_reduction.reduced_count
        val unrolled_count = self.unroller.unrolled_count

        "LoopOpt: hoisted {licm_count} invariants, reduced {reduced_count} ops, unrolled {unrolled_count} loops"

# ============================================================================
# Factory Functions
# ============================================================================

fn create_loop_opt_conservative() -> LoopOptimization:
    """Create conservative loop optimization pass (LICM only)."""
    LoopOptimization.conservative()

fn create_loop_opt_pass() -> LoopOptimization:
    """Create standard loop optimization pass."""
    LoopOptimization.aggressive()

# ============================================================================
# Exports
# ============================================================================

export LoopOptimization
export LoopInvariantMotion, LoopUnroller, StrengthReduction
export LoopDetector, LoopInfo
export create_loop_opt_conservative, create_loop_opt_pass
