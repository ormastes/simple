# Dead Code Elimination (DCE)
#
# Removes instructions and basic blocks that don't affect program output.
#
# What it removes:
# 1. Unused local variables (dead stores)
# 2. Instructions whose results are never used
# 3. Unreachable basic blocks
# 4. Pure operations with unused results
#
# Algorithm:
# 1. Mark phase: Mark all "live" values (used in output)
# 2. Sweep phase: Remove unmarked instructions and blocks
#
# Preserves:
# - Function calls (may have side effects)
# - Memory stores (may be visible)
# - Return instructions
# - Branch terminators

use compiler.mir_data.*
use compiler.mir.*
use compiler.mir_opt.mod.{MirPass}

# ============================================================================
# Liveness Analysis
# ============================================================================

class LivenessAnalysis:
    """
    Tracks which local variables are live (used later).

    A variable is live if:
    - It's used in a future instruction
    - It's returned from the function
    - It's passed to a function call
    - It's stored to memory
    """
    live_locals: text  # Set<LocalId> - placeholder for set type
    live_blocks: text  # Set<BlockId> - reachable blocks

impl LivenessAnalysis:
    static fn new() -> LivenessAnalysis:
        LivenessAnalysis(
            live_locals: "",  # Placeholder
            live_blocks: ""
        )

    me mark_live(local: LocalId):
        """Mark a local as live."""
        # TODO: Add to set when set type available
        pass

    fn is_live(local: LocalId) -> bool:
        """Check if local is live."""
        # TODO: Check set membership
        true  # Conservative: assume everything is live for now

    me mark_block_reachable(block: BlockId):
        """Mark a block as reachable."""
        # TODO: Add to set
        pass

    fn is_block_reachable(block: BlockId) -> bool:
        """Check if block is reachable."""
        # TODO: Check set membership
        true  # Conservative

# ============================================================================
# Dead Code Elimination Pass
# ============================================================================

class DeadCodeElimination:
    """
    DCE optimization pass.

    Removes dead code in two phases:
    1. Mark: Identify live instructions via backwards dataflow
    2. Sweep: Remove unmarked instructions
    """
    removed_instructions: i64
    removed_blocks: i64
    iterations: i64

impl DeadCodeElimination:
    static fn new() -> DeadCodeElimination:
        DeadCodeElimination(
            removed_instructions: 0,
            removed_blocks: 0,
            iterations: 0
        )

    fn name() -> text:
        "dead_code_elimination"

    fn description() -> text:
        "Removes unused instructions and unreachable basic blocks"

    fn is_analysis_pass() -> bool:
        false

    fn dependencies() -> [text]:
        []  # No dependencies

    me run_on_function(func: MirFunction) -> MirFunction:
        """
        Run DCE on a function.

        Algorithm:
        1. Find reachable blocks (from entry)
        2. For each reachable block:
           a. Mark live instructions (backwards from terminator)
           b. Remove dead instructions
        3. Remove unreachable blocks
        """
        self.iterations = self.iterations + 1

        # Phase 1: Find reachable blocks
        val reachable = self.find_reachable_blocks(func)

        # Phase 2: Remove dead instructions in reachable blocks
        var optimized_blocks: [MirBlock] = []
        for block in func.blocks:
            if self.is_block_in_set(block.id, reachable):
                val optimized_block = self.remove_dead_instructions(block)
                optimized_blocks.push(optimized_block)
            else:
                # Unreachable block - don't include
                self.removed_blocks = self.removed_blocks + 1

        # Return optimized function
        copy_mir_function_with_blocks(func, optimized_blocks)

    # ========================================================================
    # Reachability Analysis
    # ========================================================================

    fn find_reachable_blocks(func: MirFunction) -> [BlockId]:
        """
        Find all reachable blocks via depth-first search from entry.

        Returns list of reachable block IDs.
        """
        var reachable: [BlockId] = []
        var worklist: [BlockId] = [func.entry_block]

        while worklist.len() > 0:
            val block_id = worklist[0]
            worklist = worklist[1..]  # Pop first element

            # Skip if already visited
            if self.is_block_in_set(block_id, reachable):
                continue

            # Mark reachable
            reachable.push(block_id)

            # Find block
            val block = self.find_block(func, block_id)
            if not block.?:
                continue

            # Add successors to worklist
            val successors = self.get_successor_blocks(block.unwrap().terminator)
            for succ in successors:
                if not self.is_block_in_set(succ, reachable):
                    worklist.push(succ)

        reachable

    fn find_block(func: MirFunction, block_id: BlockId) -> MirBlock?:
        """Find block by ID."""
        for block in func.blocks:
            if block.id.id == block_id.id:
                return Some(block)
        nil

    fn is_block_in_set(block_id: BlockId, set: [BlockId]) -> bool:
        """Check if block ID is in set."""
        for id in set:
            if id.id == block_id.id:
                return true
        false

    fn get_successor_blocks(term: MirTerminator) -> [BlockId]:
        """Get successor block IDs from terminator."""
        match term:
            case Goto(target):
                [target]

            case If(_, then_, else_):
                [then_, else_]

            case Switch(_, targets, default):
                var succs: [BlockId] = [default]
                for case_item in targets:
                    succs.push(case_item.target)
                succs

            case CallTerminator(_, _, _, normal, unwind):
                if unwind.?:
                    [normal, unwind.unwrap()]
                else:
                    [normal]

            case Return(_):
                []

            case Unreachable:
                []

            case Abort(_):
                []

    # ========================================================================
    # Instruction-Level DCE
    # ========================================================================

    me remove_dead_instructions(block: MirBlock) -> MirBlock:
        """
        Remove dead instructions from a block.

        An instruction is dead if:
        - It assigns to a local that's never used
        - It's a pure operation (no side effects)
        - Its result isn't consumed
        """
        var live_instructions: [MirInst] = []

        # Simple strategy: Keep all instructions for now
        # TODO: Implement proper liveness analysis
        for inst in block.instructions:
            if self.instruction_has_side_effects(inst):
                # Keep instructions with side effects
                live_instructions.push(inst)
            else:
                # Check if result is used
                if self.is_instruction_result_used(inst, block):
                    live_instructions.push(inst)
                else:
                    # Dead instruction - don't include
                    self.removed_instructions = self.removed_instructions + 1

        MirBlock(
            id: block.id,
            label: block.label,
            instructions: live_instructions,
            terminator: block.terminator
        )

    fn instruction_has_side_effects(inst: MirInst) -> bool:
        """
        Check if instruction has observable side effects.

        Side effects include:
        - Function calls (may do anything)
        - Memory stores (visible to other code)
        - Checked operations (may trap)
        """
        match inst.kind:
            case Call(_, _, _):
                true  # Function calls may have side effects

            case CallIndirect(_, _, _, _):
                true

            case Store(_, _):
                true  # Memory stores are visible

            case Intrinsic(_, name, _):
                # Some intrinsics are pure, but be conservative
                not self.is_pure_intrinsic(name)

            case CheckedBinOp(_, _, _, _):
                true  # May trap on overflow

            case _:
                false  # Most instructions are pure

    fn is_pure_intrinsic(name: text) -> bool:
        """Check if intrinsic is pure (no side effects)."""
        match name:
            case "sqrt":
                true
            case "abs":
                true
            case "min":
                true
            case "max":
                true
            case _:
                false  # Conservative: assume impure

    fn is_instruction_result_used(inst: MirInst, block: MirBlock) -> bool:
        """
        Check if instruction's result is used later.

        For now, conservatively assume all results are used.
        TODO: Implement proper def-use analysis.
        """
        # Conservative: assume used
        true

    # ========================================================================
    # Statistics
    # ========================================================================

    fn stats_summary() -> text:
        """Generate summary of optimization work."""
        "DCE: removed {self.removed_instructions} instructions, {self.removed_blocks} blocks ({self.iterations} runs)"

# ============================================================================
# Factory Function
# ============================================================================

fn create_dce_pass() -> DeadCodeElimination:
    """Create a new DCE pass instance."""
    DeadCodeElimination.new()

# ============================================================================
# Exports
# ============================================================================

export DeadCodeElimination, create_dce_pass
