# Loop Detection
#
# Detects loops in MIR via backedge analysis.
#
# Provides:
#   - LoopInfo: Information about a detected loop
#   - LoopDetector: Finds loops in a MirFunction
#   - EdgePair: Represents an edge between two blocks
#
# Algorithm:
#   1. Build CFG (control flow graph)
#   2. Find backedges (edges to earlier blocks)
#   3. Identify natural loops (blocks reachable from backedge sources)

use compiler.mir.mir_data.*
use compiler.mir.mir.*

# ============================================================================
# Edge Pair
# ============================================================================

struct EdgePair:
    """Represents an edge between two blocks."""
    from: BlockId
    to: BlockId

# ============================================================================
# Loop Info
# ============================================================================

class LoopInfo:
    """
    Information about a loop in the MIR.

    A loop is a set of basic blocks with:
    - Header: Entry point (dominates all blocks in loop)
    - Backedges: Edges that jump back to header
    - Body: All blocks in the loop
    - Exit edges: Edges leaving the loop
    - Trip count: Constant iteration count if determinable
    """
    header: BlockId
    body: [BlockId]
    backedges: [BlockId]  # Blocks that jump back to header
    exit_edges: [EdgePair]  # Edges leaving the loop
    trip_count: i64?       # Constant iteration count (if determinable)

impl LoopInfo:
    fn contains_block(block_id: BlockId) -> bool:
        """Check if block is in this loop."""
        if block_id.id == self.header.id:
            return true

        for body_block in self.body:
            if body_block.id == block_id.id:
                return true

        false

    fn iteration_count() -> i64?:
        """
        Try to determine constant iteration count.

        Returns Some(n) if loop has constant iteration count.
        The trip count is computed during loop detection by analyzing
        exit edge comparison instructions (e.g., i < N where N is constant).
        """
        self.trip_count

# ============================================================================
# Loop Detector
# ============================================================================

class LoopDetector:
    """
    Detects loops in MIR via backedge analysis.

    Algorithm:
    1. Build CFG (control flow graph)
    2. Find strongly connected components (SCCs)
    3. Identify natural loops (single-entry SCCs with backedges)
    """
    loops: [LoopInfo]

impl LoopDetector:
    static fn new() -> LoopDetector:
        LoopDetector(loops: [])

    me detect_loops(func: MirFunction):
        """
        Detect all loops in function.

        For now, simple heuristic:
        - Look for blocks that jump backwards (to earlier block)
        - These indicate potential loops
        """
        # Reset loops
        self.loops = []

        # Pre-compute block index map for O(1) lookup
        var block_idx_map = {}
        for i in 0..(func.blocks.len()):
            val bid = "{func.blocks[i].id.id}"
            block_idx_map[bid] = i

        # Find potential loop headers (blocks jumped to from later blocks)
        var potential_headers: [BlockId] = []
        var header_set = {}

        for block in func.blocks:
            val successors = self.get_successors(block.terminator)
            for succ in successors:
                # Check if successor appears earlier in block list (O(1) lookup)
                val succ_idx = block_idx_map["{succ.id}"] ?? -1
                val block_idx = block_idx_map["{block.id.id}"] ?? -1
                if succ_idx <= block_idx:
                    # Potential backedge
                    if not header_set.contains_key("{succ.id}"):
                        header_set["{succ.id}"] = true
                        potential_headers = potential_headers.push(succ)

        # Build LoopInfo for each header
        for header in potential_headers:
            val loop_info = self.build_loop_info(func, header)
            self.loops = self.loops.push(loop_info)

    # WORKAROUND VERSION:
    fn get_successors(term: MirTerminator) -> [BlockId]:
        """Get successor blocks from terminator."""
        val empty: [BlockId] = []
        match term:
            case Return(_): empty
            case Unreachable: empty
            case Goto(target): [target]
            case If(_, then_, else_): [then_, else_]
            case Switch(_, targets, default):
                var succs: [BlockId] = []
                for case_item in targets:
                    succs = succs.push(case_item.target)
                succs = succs.push(default)
                succs
            case CallTerminator(_, _, _, normal, unwind):
                if unwind.?:
                    [normal, unwind.unwrap()]
                else:
                    [normal]
            case _: empty

    fn build_loop_info(func: MirFunction, header: BlockId) -> LoopInfo:
        """Build LoopInfo for loop with given header."""
        # Simple implementation: find all blocks that can reach header
        var body: [BlockId] = []
        var backedges: [BlockId] = []
        var body_set = {}

        for block in func.blocks:
            if block.id.id == header.id:
                continue

            val successors = self.get_successors(block.terminator)
            for succ in successors:
                if succ.id == header.id:
                    # This block jumps to header
                    backedges = backedges.push(block.id)
                    if not body_set.contains_key("{block.id.id}"):
                        body_set["{block.id.id}"] = true
                        body = body.push(block.id)

        # Build all_body set for O(1) membership checks
        var all_body_set = {}
        all_body_set["{header.id}"] = true
        for bid in body:
            all_body_set["{bid.id}"] = true

        # Detect exit edges: edges from body blocks to non-body blocks
        var exit_edges: [BlockId] = []
        var exit_set = {}
        val all_body = [header] + body
        for block in func.blocks:
            if not all_body_set.contains_key("{block.id.id}"):
                continue
            val successors = self.get_successors(block.terminator)
            for succ in successors:
                if not all_body_set.contains_key("{succ.id}"):
                    if not exit_set.contains_key("{succ.id}"):
                        exit_set["{succ.id}"] = true
                        exit_edges = exit_edges.push(succ)

        # Analyze iteration count from exit conditions
        # Look at conditional terminators in loop blocks that branch out
        val trip_count = self.analyze_trip_count(func, header, all_body)

        LoopInfo(
            header: header,
            body: body,
            backedges: backedges,
            exit_edges: exit_edges,
            trip_count: trip_count
        )

    fn analyze_trip_count(func: MirFunction, header: BlockId, loop_blocks: [BlockId]) -> i64?:
        """
        Analyze loop exit conditions to determine constant trip count.

        Looks for patterns like:
        - Header block has If terminator comparing a local against a constant
        - The comparison is Lt (i < N) where N is a constant integer
        - One branch exits the loop, the other stays in

        Returns Some(N) if a constant bound is found, nil otherwise.
        """
        # Build loop block set for O(1) lookup
        var loop_block_set = {}
        for lb in loop_blocks:
            loop_block_set["{lb.id}"] = true

        # Check each block in the loop for conditional exits
        for block in func.blocks:
            if not loop_block_set.contains_key("{block.id.id}"):
                continue

            # Look for If terminators that compare against a constant
            match block.terminator:
                case If(cond, then_, else_):
                    # Check if one target exits the loop and the other stays
                    val then_in_loop = loop_block_set.contains_key("{then_.id}")
                    val else_in_loop = loop_block_set.contains_key("{else_.id}")

                    # Exactly one branch should exit for a counted loop
                    if then_in_loop and not else_in_loop:
                        # else_ is the exit branch; cond being true continues
                        val bound = self.extract_comparison_bound(block.instructions, cond)
                        if bound.?:
                            return bound
                    elif not then_in_loop and else_in_loop:
                        # then_ is the exit branch; cond being false continues
                        val bound = self.extract_comparison_bound(block.instructions, cond)
                        if bound.?:
                            return bound
                case _:
                    pass

        nil

    fn extract_comparison_bound(instructions: [MirInst], cond: MirOperand) -> i64?:
        """
        Extract constant bound from a comparison used as loop exit condition.

        Looks for BinOp instructions that define the condition operand and have
        a comparison op (Lt, Le, Gt, Ge) with a constant integer operand.

        For `i < N` returns N, for `i <= N` returns N + 1.
        """
        # Find which local the condition references
        val cond_local_id = match cond.kind:
            case Copy(local): Some(local.id)
            case Move(local): Some(local.id)
            case _: nil

        if not cond_local_id.?:
            return nil

        val target_id = cond_local_id.unwrap()

        # Scan instructions for the BinOp that defines this local
        for inst in instructions:
            match inst.kind:
                case BinOp(dest, op, left, right):
                    if dest.id == target_id:
                        # Found the comparison instruction
                        # Check if it's a comparison with a constant bound
                        val const_val = self.operand_const_int(right)
                        if const_val.?:
                            match op:
                                case Lt:
                                    # i < N -> trip count is N
                                    return const_val
                                case Le:
                                    # i <= N -> trip count is N + 1
                                    return Some(const_val.unwrap() + 1)
                                case _:
                                    pass

                        # Also check left operand (for reversed comparisons like N > i)
                        val const_val_l = self.operand_const_int(left)
                        if const_val_l.?:
                            match op:
                                case Gt:
                                    # N > i -> trip count is N
                                    return const_val_l
                                case Ge:
                                    # N >= i -> trip count is N + 1
                                    return Some(const_val_l.unwrap() + 1)
                                case _:
                                    pass
                case _:
                    pass

        nil

    fn operand_const_int(op: MirOperand) -> i64?:
        """Extract constant integer value from operand, if it is one."""
        match op.kind:
            case Const(value, _):
                match value:
                    case Int(n): Some(n)
                    case _: nil
            case _: nil

    fn block_index(func: MirFunction, block_id: BlockId) -> i64:
        """Find index of block in function."""
        var idx = 0
        for block in func.blocks:
            if block.id.id == block_id.id:
                return idx
            idx = idx + 1
        -1

    fn is_block_in_list(block_id: BlockId, list: [BlockId]) -> bool:
        """Check if block is in list."""
        for item in list:
            if item.id == block_id.id:
                return true
        false

    fn find_loop_for_block(block_id: BlockId) -> LoopInfo?:
        """Find innermost loop containing block."""
        for loop in self.loops:
            if loop.contains_block(block_id):
                return Some(loop)
        nil

# ============================================================================
# Exports
# ============================================================================


# Auto-generated desugared static method wrappers
fn LoopDetector__new() -> LoopDetector:
    LoopDetector(loops: [])


export EdgePair, LoopInfo, LoopDetector
