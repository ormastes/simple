# Auto-Vectorization Pass
#
# Automatically vectorizes simple loops into SIMD operations.
# Detects vectorizable patterns and transforms scalar loops to use SIMD instructions.
#
# Vectorizable pattern:
#   for i in 0..n:
#       c[i] = a[i] + b[i]
#
# Transformed to:
#   var i = 0
#   while i + 8 <= n:
#       c_vec = simd_add_f32x8(load_vec(a, i), load_vec(b, i))
#       store_vec(c, i, c_vec)
#       i = i + 8
#   while i < n:  # Remainder loop
#       c[i] = a[i] + b[i]
#       i = i + 1
#
# Requirements for vectorization:
# - Simple loop with known bounds
# - Stride-1 array access (consecutive elements)
# - No loop-carried dependencies (except induction variable)
# - Operations that map to SIMD instructions (add, sub, mul, etc.)
#
# Architecture:
#   auto_vectorize.spl          - Shared types, main pass coordinator, re-exports
#   auto_vectorize_analysis.spl - Phase 1: dependency analysis
#   auto_vectorize_validate.spl - Phase 2: vectorizability validation
#   auto_vectorize_cost.spl     - Phase 3: cost model + decision
#   auto_vectorize_codegen.spl  - Phase 4: vector code generation

use compiler.mir.mir_data.{MirModule, MirFunction, MirBlock, MirInst, MirInstKind, MirTerminator, MirOperand, MirOperandKind, MirBinOp, LocalId, BlockId, copy_mir_function_with_blocks}

# Shared types (cycle-free base module)
use compiler.mir_opt.auto_vectorize_types.{LoopInfo, ArrayAccess}

# Re-import from sub-modules for coordinator use and re-export
use compiler.mir_opt.auto_vectorize_analysis.{DependencyAnalysisResult, analyze_loop_dependencies, is_simple_loop}
use compiler.mir_opt.auto_vectorize_validate.{VectorizabilityResult, check_vectorizability, get_vectorizable_type}
use compiler.mir_opt.auto_vectorize_cost.{CostEstimate, estimate_vectorization_cost, should_vectorize_loop}
use compiler.mir_opt.auto_vectorize_codegen.{VectorizeContext, VectorizedLoop, create_vector_loop}

# ============================================================================
# Main Auto-Vectorization Pass
# ============================================================================

fn run_auto_vectorization(module: MirModule) -> MirModule:
    """
    Run auto-vectorization pass on entire module.

    This is a simplified implementation showing the structure.
    A production version would:
    - Perform full loop detection and analysis
    - Build dependency graphs
    - Cost model for vectorization decisions
    - Handle reductions, conditionals, complex patterns
    """
    var new_functions: Dict<SymbolId, MirFunction> = {}

    for symbol_id in module.functions.keys():
        val func = module.functions[symbol_id]
        val vectorized = try_vectorize_function(func)
        new_functions[symbol_id] = vectorized

    MirModule(
        name: module.name,
        functions: new_functions,
        statics: module.statics,
        constants: module.constants,
        types: module.types
    )

fn try_vectorize_function(func: MirFunction) -> MirFunction:
    """
    Attempt to vectorize loops in a function.
    Returns modified function with vectorized loops.
    """
    # Step 1: Identify all loops
    val loops = identify_loops(func)

    if loops.len() == 0:
        return func

    # Step 2: Analyze and vectorize each loop
    var modified = false
    var new_blocks = func.blocks

    for loop in loops:
        # Get loop body blocks
        val body_blocks = get_loop_body_blocks(func, loop)

        # Phase 1: Dependency analysis
        val dep_result = analyze_loop_dependencies(loop, body_blocks)

        if not dep_result.vectorizable:
            pass_do_nothing
        else:
            # Phase 2: Vectorizability validation
            val vec_result = check_vectorizability(loop, body_blocks, dep_result)

            if not vec_result.can_vectorize:
                pass_do_nothing
            else:
                # Determine element type
                val elem_type = get_vectorizable_type(body_blocks)
                if not elem_type.?:
                    pass_do_nothing
                else:
                    val etype = elem_type.unwrap()

                    # Phase 3: Cost model
                    val vector_width = get_simd_width(etype)
                    val cost = estimate_vectorization_cost(loop, body_blocks, vector_width, etype)

                    if not cost.profitable:
                        pass_do_nothing
                    else:
                        # Phase 4: Code generation
                        val ctx = VectorizeContext(
                            vector_width: vector_width,
                            element_type: etype,
                            next_local: func.locals.len()
                        )

                        val vectorized = create_vector_loop(ctx, loop, body_blocks)

                        # Replace loop blocks with vectorized version
                        new_blocks = replace_loop_blocks(new_blocks, loop, vectorized)
                        modified = true

    if modified:
        copy_mir_function_with_blocks(func, new_blocks)
    else:
        func

# ============================================================================
# Loop Identification
# ============================================================================

fn identify_loops(func: MirFunction) -> [LoopInfo]:
    """
    Identify all loops in the function.
    Detects natural loops via back-edges in CFG.
    """
    var loops: [LoopInfo] = []

    # For each block, check if it's a loop header
    for block in func.blocks:
        val loop_info = is_simple_loop(func, block.id)
        if loop_info.?:
            loops = loops + [loop_info.unwrap()]

    loops

fn get_loop_body_blocks(func: MirFunction, loop: LoopInfo) -> [MirBlock]:
    """
    Get all blocks that are part of the loop body.
    """
    var body: [MirBlock] = []

    # Include header block
    for block in func.blocks:
        if block.id.id == loop.header_block.id:
            body = body + [block]

    # Include body blocks
    for body_id in loop.body_blocks:
        for block in func.blocks:
            if block.id.id == body_id.id:
                body = body + [block]

    body

fn replace_loop_blocks(blocks: [MirBlock], loop: LoopInfo, vectorized: VectorizedLoop) -> [MirBlock]:
    """
    Replace original loop blocks with vectorized version.
    """
    var new_blocks: [MirBlock] = []

    # Keep blocks before the loop
    for block in blocks:
        if block.id.id < loop.header_block.id:
            new_blocks = new_blocks + [block]

    # Add vectorized blocks
    new_blocks = new_blocks + vectorized.prologue_blocks
    new_blocks = new_blocks + vectorized.vector_blocks
    new_blocks = new_blocks + vectorized.epilogue_blocks

    # Keep blocks after the loop
    var max_loop_id = loop.header_block.id
    for body_id in loop.body_blocks:
        if body_id.id > max_loop_id:
            max_loop_id = body_id.id

    for block in blocks:
        if block.id.id > max_loop_id:
            new_blocks = new_blocks + [block]

    new_blocks

# ============================================================================
# Utility: Platform SIMD Width
# ============================================================================

fn get_simd_width(element_type: text) -> i64:
    """
    Get optimal SIMD width for target platform.
    This would query target features in real implementation.
    """
    # Simplified: assume AVX2 available
    if element_type == "f32":
        8  # 8x f32 = 256 bits
    elif element_type == "f64":
        4  # 4x f64 = 256 bits
    elif element_type == "i32":
        8  # 8x i32 = 256 bits
    else:
        4  # Conservative fallback

# ============================================================================
# Exports (re-export all public API for backward compatibility)
# ============================================================================

# Shared types
export LoopInfo, ArrayAccess

# Main pass
export run_auto_vectorization
export try_vectorize_function
export get_simd_width

# Re-exports from sub-modules
export should_vectorize_loop
export analyze_loop_dependencies
export check_vectorizability
export estimate_vectorization_cost
export DependencyAnalysisResult
export VectorizabilityResult
export CostEstimate
