# Copy Propagation
#
# Replaces uses of copied values with the original source value.
#
# Transformation:
#   val x = 42
#   val y = x      # Copy
#   val z = y + 1  # Use of copy
#
# After:
#   val x = 42
#   val z = x + 1  # Direct use of original
#
# Benefits:
# - Eliminates redundant copies
# - Simplifies SSA chains
# - Enables further optimization (DCE can remove unused copies)
# - Reduces register pressure
#
# Algorithm:
# 1. Build copy chains (x -> y -> z)
# 2. For each use, replace with root of chain
# 3. Mark copies as dead (DCE will remove)

use compiler.mir_data.*
use compiler.mir.*
use compiler.mir_opt.mod.{MirPass}

# ============================================================================
# Copy Chain Analysis
# ============================================================================

class CopyChain:
    """
    Tracks copy relationships between locals.

    Example:
      val a = 42
      val b = a    # b copies a
      val c = b    # c copies b (transitively copies a)

    Chain: c -> b -> a (root: a)
    """
    # Maps each local to its copy source
    copy_map: Dict<i64, LocalId>  # LocalId.id -> source LocalId

impl CopyChain:
    static fn new() -> CopyChain:
        CopyChain(copy_map: {})

    me add_copy(dest: LocalId, src: LocalId):
        """Record that dest is a copy of src."""
        self.copy_map[dest.id] = src

    fn get_root(local: LocalId) -> LocalId:
        """
        Follow copy chain to find root (original value).

        Example: c -> b -> a returns a
        """
        var current = local
        var visited: [i64] = []  # Detect cycles

        while true:
            # Detect cycle
            if self.is_in_list(current.id, visited):
                return local  # Cycle detected, return original

            visited.push(current.id)

            # Check if current is a copy
            if current.id in self.copy_map:
                current = self.copy_map[current.id]
            else:
                # Reached root
                return current

    fn is_in_list(id: i64, list: [i64]) -> bool:
        """Check if ID is in list."""
        for item in list:
            if item == id:
                return true
        false

    fn is_copy(local: LocalId) -> bool:
        """Check if local is a copy of something."""
        local.id in self.copy_map

# ============================================================================
# Copy Propagation Pass
# ============================================================================

class CopyPropagation:
    """
    Copy propagation optimization pass.

    Process:
    1. Scan for copy instructions (Copy, Move with same source)
    2. Build copy chains
    3. Replace uses with root values
    4. Let DCE eliminate dead copies
    """
    copy_chain: CopyChain
    propagated_uses: i64
    eliminated_copies: i64

impl CopyPropagation:
    static fn new() -> CopyPropagation:
        CopyPropagation(
            copy_chain: CopyChain.new(),
            propagated_uses: 0,
            eliminated_copies: 0
        )

    fn name() -> text:
        "copy_propagation"

    fn description() -> text:
        "Replaces uses of copied values with original sources"

    fn is_analysis_pass() -> bool:
        false

    fn requires() -> [text]:
        []  # No dependencies

    me run_on_function(func: MirFunction) -> MirFunction:
        """
        Run copy propagation on a function.

        Steps:
        1. Build copy chains from all blocks
        2. Propagate copies in each block
        3. Return optimized function
        """
        # Phase 1: Build copy chains
        for block in func.blocks:
            self.analyze_block(block)

        # Phase 2: Propagate copies
        var optimized_blocks: [MirBlock] = []
        for block in func.blocks:
            val optimized = self.propagate_block(block)
            optimized_blocks.push(optimized)

        MirFunction(
            symbol: func.symbol,
            name: func.name,
            signature: func.signature,
            locals: func.locals,
            blocks: optimized_blocks,
            entry_block: func.entry_block,
            span: func.span,
            generic_params: func.generic_params,
            is_generic_template: func.is_generic_template,
            specialization_of: func.specialization_of,
            type_bindings: func.type_bindings
        )

    # ========================================================================
    # Analysis Phase
    # ========================================================================

    me analyze_block(block: MirBlock):
        """
        Scan block for copy instructions and build chains.
        """
        for inst in block.instructions:
            match inst.kind:
                case Copy(dest, src):
                    self.copy_chain.add_copy(dest, src)

                case Move(dest, src):
                    # Treat move as copy for propagation
                    self.copy_chain.add_copy(dest, src)

                case _:
                    # Not a copy instruction
                    pass

    # ========================================================================
    # Propagation Phase
    # ========================================================================

    me propagate_block(block: MirBlock) -> MirBlock:
        """
        Propagate copies in a block.

        Replace all uses of copied values with root values.
        """
        var propagated_instructions: [MirInst] = []

        for inst in block.instructions:
            val propagated = self.propagate_instruction(inst)
            propagated_instructions.push(propagated)

        # Propagate in terminator
        val propagated_term = self.propagate_terminator(block.terminator)

        MirBlock(
            id: block.id,
            label: block.label,
            instructions: propagated_instructions,
            terminator: propagated_term
        )

    me propagate_instruction(inst: MirInst) -> MirInst:
        """
        Propagate copies in an instruction.

        Replace all operand uses with root values.
        """
        match inst.kind:
            case BinOp(dest, op, left, right):
                val new_left = self.propagate_operand(left)
                val new_right = self.propagate_operand(right)
                MirInst(
                    kind: MirInstKind.BinOp(dest, op, new_left, new_right),
                    span: inst.span
                )

            case UnaryOp(dest, op, operand):
                val new_operand = self.propagate_operand(operand)
                MirInst(
                    kind: MirInstKind.UnaryOp(dest, op, new_operand),
                    span: inst.span
                )

            case Load(dest, ptr):
                val new_ptr = self.propagate_operand(ptr)
                MirInst(
                    kind: MirInstKind.Load(dest, new_ptr),
                    span: inst.span
                )

            case Store(ptr, value):
                val new_ptr = self.propagate_operand(ptr)
                val new_value = self.propagate_operand(value)
                MirInst(
                    kind: MirInstKind.Store(new_ptr, new_value),
                    span: inst.span
                )

            case Call(dest, func, args):
                val new_func = self.propagate_operand(func)
                var new_args: [MirOperand] = []
                for arg in args:
                    new_args.push(self.propagate_operand(arg))
                MirInst(
                    kind: MirInstKind.Call(dest, new_func, new_args),
                    span: inst.span
                )

            case Copy(dest, src):
                # Keep copy instruction (DCE will remove if unused)
                val root = self.copy_chain.get_root(src)
                if root.id != src.id:
                    # Source is itself a copy - propagate
                    self.eliminated_copies = self.eliminated_copies + 1
                    MirInst(
                        kind: MirInstKind.Copy(dest, root),
                        span: inst.span
                    )
                else:
                    inst

            case Move(dest, src):
                # Propagate move source
                val root = self.copy_chain.get_root(src)
                if root.id != src.id:
                    self.eliminated_copies = self.eliminated_copies + 1
                    MirInst(
                        kind: MirInstKind.Move(dest, root),
                        span: inst.span
                    )
                else:
                    inst

            case _:
                # No propagation needed for this instruction
                inst

    me propagate_operand(operand: MirOperand) -> MirOperand:
        """
        Propagate copy in an operand.

        If operand uses a copied value, replace with root.
        """
        match operand.kind:
            case Copy(local):
                val root = self.copy_chain.get_root(local)
                if root.id != local.id:
                    # Propagate to root
                    self.propagated_uses = self.propagated_uses + 1
                    MirOperand(kind: MirOperandKind.Copy(root))
                else:
                    operand

            case Move(local):
                val root = self.copy_chain.get_root(local)
                if root.id != local.id:
                    self.propagated_uses = self.propagated_uses + 1
                    MirOperand(kind: MirOperandKind.Move(root))
                else:
                    operand

            case Const(_, _):
                # Constants don't need propagation
                operand

    me propagate_terminator(term: MirTerminator) -> MirTerminator:
        """Propagate copies in terminator."""
        match term:
            case Return(Some(value)):
                val new_value = self.propagate_operand(value)
                MirTerminator.Return(Some(new_value))

            case If(cond, then_, else_):
                val new_cond = self.propagate_operand(cond)
                MirTerminator.If(new_cond, then_, else_)

            case Switch(value, targets, default):
                val new_value = self.propagate_operand(value)
                MirTerminator.Switch(new_value, targets, default)

            case CallTerminator(dest, func, args, normal, unwind):
                val new_func = self.propagate_operand(func)
                var new_args: [MirOperand] = []
                for arg in args:
                    new_args.push(self.propagate_operand(arg))
                MirTerminator.CallTerminator(dest, new_func, new_args, normal, unwind)

            case _:
                # Other terminators don't use operands
                term

    # ========================================================================
    # Statistics
    # ========================================================================

    fn stats_summary() -> text:
        """Generate summary of optimization work."""
        "CopyProp: propagated {self.propagated_uses} uses, eliminated {self.eliminated_copies} copy chains"

# ============================================================================
# Factory Function
# ============================================================================

fn create_copy_prop_pass() -> CopyPropagation:
    """Create a new copy propagation pass instance."""
    CopyPropagation.new()

# ============================================================================
# Exports
# ============================================================================

export CopyPropagation, create_copy_prop_pass
export CopyChain
