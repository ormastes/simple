# Function Inlining
#
# Replaces function calls with the function body.
#
# Transformation:
#   fn add_one(x: i64) -> i64:
#       x + 1
#
#   val y = add_one(5)
#
# After inlining:
#   val y = 5 + 1
#
# Benefits:
# - Eliminates call overhead (setup, jump, return)
# - Enables interprocedural optimization (const fold, CSE across call boundaries)
# - Improves instruction cache locality
# - Reduces stack pressure
#
# Costs:
# - Increases code size (trade-off)
# - May increase compile time
# - Can hurt I-cache if too aggressive
#
# Strategy:
# - Always inline: tiny functions (< 50 bytes)
# - Aggressively inline: hot functions (< 500 bytes)
# - Never inline: recursive functions, large functions
#
# Heuristics:
# - Size threshold (configurable)
# - Call site count (don't inline if called many times)
# - Recursion detection (prevent infinite inlining)

use compiler.mir_data.*
use compiler.mir.*
use compiler.mir_opt.mod.{MirPass}

# ============================================================================
# Inlining Policy
# ============================================================================

enum InlinePolicy:
    """
    Policy for deciding whether to inline a function.
    """
    Always          # Inline regardless of size (for tiny functions)
    Aggressive      # Inline if below threshold (for optimization)
    Conservative    # Only inline very small functions (for code size)
    Never           # Don't inline (for debugging, recursive functions)

impl InlinePolicy:
    fn should_inline(size: i64, threshold: i64) -> bool:
        """Check if function should be inlined given size."""
        match self:
            case Always: true
            case Aggressive: size <= threshold
            case Conservative: size <= threshold / 2
            case Never: false

# ============================================================================
# Inline Cost Analysis
# ============================================================================

class InlineCostAnalyzer:
    """
    Analyzes the cost/benefit of inlining a function.

    Cost factors:
    - Function body size (instruction count)
    - Number of call sites (code size multiplication)
    - Complexity (loops, branches increase cost)

    Benefit factors:
    - Call overhead saved
    - Optimization opportunities enabled
    - Hot path (frequently executed)
    """
    threshold: i64  # Size threshold in "instruction units"

impl InlineCostAnalyzer:
    static fn new(threshold: i64) -> InlineCostAnalyzer:
        InlineCostAnalyzer(threshold: threshold)

    fn estimate_function_size(func: MirFunction) -> i64:
        """
        Estimate function size in instruction units.

        Simple heuristic: count instructions + weight by complexity.
        """
        var size = 0

        for block in func.blocks:
            # Each instruction adds to size
            size = size + block.instructions.len()

            # Terminator cost
            match block.terminator:
                case Return(_): size = size + 1
                case Goto(_): size = size + 1
                case If(_, _, _): size = size + 2  # Branch is expensive
                case Switch(_, targets, _): size = size + targets.len()
                case _: size = size + 1

        size

    fn should_inline(func: MirFunction, policy: InlinePolicy) -> bool:
        """
        Decide if function should be inlined.

        Checks:
        1. Size threshold
        2. Recursion (never inline recursive)
        3. Policy
        """
        val size = self.estimate_function_size(func)

        # Never inline if too large
        if size > self.threshold * 2:
            return false

        # Check policy
        policy.should_inline(size, self.threshold)

    fn is_recursive(func: MirFunction) -> bool:
        """
        Check if function is recursive (calls itself).

        Conservative: returns true if any call matches function name.

        Phase 1B.6 - TODO #132 âœ…
        """
        # Check if function calls itself
        val func_name = func.name

        # Scan all instructions for calls to self
        for block in func.blocks:
            for instr in block.instructions:
                match instr:
                    case Call(target, args, dest):
                        # Check if target is same function
                        match target:
                            case Variable(name):
                                if name == func_name:
                                    return true
                            case _:
                                ()  # Other call types
                    case _:
                        ()  # Not a call

        false

# ============================================================================
# Function Inliner
# ============================================================================

class FunctionInliner:
    """
    Performs actual inlining transformation.

    Process:
    1. Find call instruction
    2. Copy function body
    3. Rename locals (avoid conflicts)
    4. Replace call with inlined body
    5. Connect control flow
    """
    next_local_id: i64
    inlined_count: i64

impl FunctionInliner:
    static fn new(next_local_id: i64) -> FunctionInliner:
        FunctionInliner(
            next_local_id: next_local_id,
            inlined_count: 0
        )

    me inline_call(
        caller_block: MirBlock,
        call_inst_idx: i64,
        callee: MirFunction,
        call_dest: LocalId?,
        args: [MirOperand]
    ) -> [MirBlock]:
        """
        Inline a function call.

        Returns new blocks (caller block split + inlined body).

        Strategy:
        1. Split caller block at call site
        2. Copy callee body blocks
        3. Bind arguments to parameters
        4. Connect control flow
        5. Handle return value
        """
        # For now, simple implementation:
        # Just replace call with function body (single-block functions only)

        # Check if callee is single-block
        if callee.blocks.len() != 1:
            # Can't inline multi-block functions yet
            return [caller_block]

        val callee_block = callee.blocks[0]

        # Build new instructions:
        # 1. Instructions before call
        # 2. Argument bindings
        # 3. Inlined body
        # 4. Instructions after call

        var new_instructions: [MirInst] = []

        # Copy instructions before call
        var i = 0
        while i < call_inst_idx:
            new_instructions.push(caller_block.instructions[i])
            i = i + 1

        # Bind arguments to parameters: emit Const/Copy for each arg
        for param_idx in 0..args.len():
            if param_idx < callee.locals.len():
                val param_local = callee.locals[param_idx]
                val dest = param_local.id
                match args[param_idx].kind:
                    case Copy(src):
                        new_instructions.push(MirInst(kind: MirInstKind.Copy(dest, src), span: nil))
                    case Move(src):
                        new_instructions.push(MirInst(kind: MirInstKind.Move(dest, src), span: nil))
                    case Const(cv, ct):
                        new_instructions.push(MirInst(kind: MirInstKind.Const(dest, cv, ct), span: nil))

        # Copy inlined body (rename locals)
        for inst in callee_block.instructions:
            val renamed = self.rename_instruction(inst)
            new_instructions.push(renamed)

        # Handle return value: check terminator for Return and assign to call_dest
        match callee_block.terminator:
            case Return(ret_op):
                if call_dest.? and ret_op.?:
                    val ret_operand = ret_op.unwrap()
                    match ret_operand.kind:
                        case Copy(src):
                            new_instructions.push(MirInst(kind: MirInstKind.Copy(call_dest.unwrap(), src), span: nil))
                        case Move(src):
                            new_instructions.push(MirInst(kind: MirInstKind.Move(call_dest.unwrap(), src), span: nil))
                        case Const(cv, ct):
                            new_instructions.push(MirInst(kind: MirInstKind.Const(call_dest.unwrap(), cv, ct), span: nil))
            case _: ()

        # Copy instructions after call
        i = call_inst_idx + 1
        while i < caller_block.instructions.len():
            new_instructions.push(caller_block.instructions[i])
            i = i + 1

        self.inlined_count = self.inlined_count + 1

        [MirBlock(
            id: caller_block.id,
            label: caller_block.label,
            instructions: new_instructions,
            terminator: caller_block.terminator
        )]

    me rename_instruction(inst: MirInst) -> MirInst:
        """
        Rename locals in instruction to avoid conflicts.

        Creates fresh local IDs for all definitions.
        For instructions that define a destination, allocate a fresh local ID
        and substitute it. Uses only local context (no global rename map needed
        since single-block functions have unique definitions per instruction).
        """
        # Rename dest locals in defining instructions to avoid conflicts
        match inst.kind:
            case Const(dest, value, type_):
                val new_dest = self.fresh_local()
                MirInst(kind: MirInstKind.Const(new_dest, value, type_), span: inst.span)
            case Copy(dest, src):
                val new_dest = self.fresh_local()
                MirInst(kind: MirInstKind.Copy(new_dest, src), span: inst.span)
            case Move(dest, src):
                val new_dest = self.fresh_local()
                MirInst(kind: MirInstKind.Move(new_dest, src), span: inst.span)
            case BinOp(dest, op, left, right):
                val new_dest = self.fresh_local()
                MirInst(kind: MirInstKind.BinOp(new_dest, op, left, right), span: inst.span)
            case UnaryOp(dest, op, operand):
                val new_dest = self.fresh_local()
                MirInst(kind: MirInstKind.UnaryOp(new_dest, op, operand), span: inst.span)
            case Alloc(dest, type_):
                val new_dest = self.fresh_local()
                MirInst(kind: MirInstKind.Alloc(new_dest, type_), span: inst.span)
            case Load(dest, ptr):
                val new_dest = self.fresh_local()
                MirInst(kind: MirInstKind.Load(new_dest, ptr), span: inst.span)
            case _:
                # Non-defining instructions (Store, Nop, etc.) pass through
                inst

    me fresh_local() -> LocalId:
        """Allocate a fresh local ID."""
        val id = self.next_local_id
        self.next_local_id = self.next_local_id + 1
        LocalId(id: id)

# ============================================================================
# Function Inlining Pass
# ============================================================================

class FunctionInlining:
    """
    Function inlining optimization pass.

    Configuration:
    - threshold: Maximum function size to inline (in instruction units)
    - policy: Inlining aggressiveness policy

    Algorithm:
    1. Analyze all functions (build call graph, compute sizes)
    2. For each function:
       a. Find inline candidates (call sites)
       b. Check inlining heuristics
       c. Perform inlining if beneficial
    3. Repeat until fixed point or max iterations
    """
    threshold: i64
    policy: InlinePolicy
    cost_analyzer: InlineCostAnalyzer
    inlined_functions: i64
    inlined_call_sites: i64
    iterations: i64

impl FunctionInlining:
    static fn new(threshold: i64, policy: InlinePolicy) -> FunctionInlining:
        FunctionInlining(
            threshold: threshold,
            policy: policy,
            cost_analyzer: InlineCostAnalyzer.new(threshold),
            inlined_functions: 0,
            inlined_call_sites: 0,
            iterations: 0
        )

    static fn small_functions() -> FunctionInlining:
        """Inline only very small functions (for code size)."""
        FunctionInlining.new(50, InlinePolicy.Conservative)

    static fn aggressive() -> FunctionInlining:
        """Aggressive inlining (for speed)."""
        FunctionInlining.new(500, InlinePolicy.Aggressive)

    static fn very_aggressive() -> FunctionInlining:
        """Very aggressive inlining (max speed, may increase code size)."""
        FunctionInlining.new(2000, InlinePolicy.Aggressive)

    fn name() -> text:
        "function_inlining"

    fn description() -> text:
        "Inlines small function calls to eliminate call overhead"

    fn is_analysis_pass() -> bool:
        false

    fn dependencies() -> [text]:
        ["dead_code_elimination", "constant_folding"]

    me run_on_function(func: MirFunction) -> MirFunction:
        """
        Run inlining on a function.

        Note: This pass needs access to other functions in the module
        to perform inlining. For now, we implement a simplified version
        that only handles single-block functions.
        """
        self.iterations = self.iterations + 1

        # Find call sites in this function
        var modified = false
        var optimized_blocks: [MirBlock] = []

        for block in func.blocks:
            val optimized = self.inline_calls_in_block(block, func)
            if optimized.id.id != block.id.id or optimized.instructions.len() != block.instructions.len():
                modified = true
            optimized_blocks.push(optimized)

        if modified:
            self.inlined_functions = self.inlined_functions + 1

        copy_mir_function_with_blocks(func, optimized_blocks)

    me inline_calls_in_block(block: MirBlock, func: MirFunction) -> MirBlock:
        """
        Inline eligible calls in a block.

        For each call instruction:
        1. Check if callee should be inlined
        2. Perform inlining if beneficial
        """
        # For now, keep block as-is
        # TODO: Implement actual inlining logic

        # This would require:
        # - Access to other functions in module (need module-level pass)
        # - Local renaming
        # - Block splitting
        # - Control flow merging

        block

    # ========================================================================
    # Statistics
    # ========================================================================

    fn stats_summary() -> text:
        """Generate summary of optimization work."""
        "Inline: inlined {self.inlined_call_sites} call sites in {self.inlined_functions} functions ({self.iterations} iterations)"

# ============================================================================
# Module-Level Inlining
# ============================================================================

class ModuleInliner:
    """
    Module-level inlining pass.

    Operates on entire module to inline cross-function calls.
    """
    threshold: i64
    policy: InlinePolicy
    inlined_total: i64

impl ModuleInliner:
    static fn new(threshold: i64, policy: InlinePolicy) -> ModuleInliner:
        ModuleInliner(
            threshold: threshold,
            policy: policy,
            inlined_total: 0
        )

    me inline_module(module: MirModule) -> MirModule:
        """
        Perform inlining across module.

        Strategy:
        1. Build call graph
        2. Identify inline candidates (leaf functions first)
        3. Bottom-up inlining (inline callees into callers)
        4. Repeat until fixed point
        """
        # TODO: Implement full module-level inlining

        # For now, return module as-is
        module

# ============================================================================
# Factory Functions
# ============================================================================

fn create_inline_small_pass() -> FunctionInlining:
    """Create inlining pass for small functions (code size optimization)."""
    FunctionInlining.small_functions()

fn create_inline_pass() -> FunctionInlining:
    """Create standard inlining pass (speed optimization)."""
    FunctionInlining.aggressive()

fn create_inline_aggressive_pass() -> FunctionInlining:
    """Create aggressive inlining pass (maximum speed)."""
    FunctionInlining.very_aggressive()

# ============================================================================
# Exports
# ============================================================================

export FunctionInlining, ModuleInliner
export InlinePolicy, InlineCostAnalyzer, FunctionInliner
export create_inline_small_pass, create_inline_pass, create_inline_aggressive_pass
