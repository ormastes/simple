# Function Inlining
#
# Replaces function calls with the function body.
#
# Transformation:
#   fn add_one(x: i64) -> i64:
#       x + 1
#
#   val y = add_one(5)
#
# After inlining:
#   val y = 5 + 1
#
# Benefits:
# - Eliminates call overhead (setup, jump, return)
# - Enables interprocedural optimization (const fold, CSE across call boundaries)
# - Improves instruction cache locality
# - Reduces stack pressure
#
# Costs:
# - Increases code size (trade-off)
# - May increase compile time
# - Can hurt I-cache if too aggressive
#
# Strategy:
# - Always inline: tiny functions (< 50 bytes)
# - Aggressively inline: hot functions (< 500 bytes)
# - Never inline: recursive functions, large functions
#
# Heuristics:
# - Size threshold (configurable)
# - Call site count (don't inline if called many times)
# - Recursion detection (prevent infinite inlining)

use compiler.mir_data.*
use compiler.mir.*
use compiler.mir_opt.mod.{MirPass}

# ============================================================================
# Inlining Policy
# ============================================================================

enum InlinePolicy:
    """
    Policy for deciding whether to inline a function.
    """
    Always          # Inline regardless of size (for tiny functions)
    Aggressive      # Inline if below threshold (for optimization)
    Conservative    # Only inline very small functions (for code size)
    Never           # Don't inline (for debugging, recursive functions)

impl InlinePolicy:
    fn should_inline(size: i64, threshold: i64) -> bool:
        """Check if function should be inlined given size."""
        match self:
            case Always: true
            case Aggressive: size <= threshold
            case Conservative: size <= threshold / 2
            case Never: false

# ============================================================================
# Inline Cost Analysis
# ============================================================================

class InlineCostAnalyzer:
    """
    Analyzes the cost/benefit of inlining a function.

    Cost factors:
    - Function body size (instruction count)
    - Number of call sites (code size multiplication)
    - Complexity (loops, branches increase cost)

    Benefit factors:
    - Call overhead saved
    - Optimization opportunities enabled
    - Hot path (frequently executed)
    """
    threshold: i64  # Size threshold in "instruction units"

impl InlineCostAnalyzer:
    static fn new(threshold: i64) -> InlineCostAnalyzer:
        InlineCostAnalyzer(threshold: threshold)

    fn estimate_function_size(func: MirFunction) -> i64:
        """
        Estimate function size in instruction units.

        Simple heuristic: count instructions + weight by complexity.
        """
        var size = 0

        for block in func.blocks:
            # Each instruction adds to size
            size = size + block.instructions.len()

            # Terminator cost
            match block.terminator:
                case Return(_): size = size + 1
                case Goto(_): size = size + 1
                case If(_, _, _): size = size + 2  # Branch is expensive
                case Switch(_, targets, _): size = size + targets.len()
                case _: size = size + 1

        size

    fn should_inline(func: MirFunction, policy: InlinePolicy) -> bool:
        """
        Decide if function should be inlined.

        Checks:
        1. Size threshold
        2. Recursion (never inline recursive)
        3. Policy
        """
        val size = self.estimate_function_size(func)

        # Never inline if too large
        if size > self.threshold * 2:
            return false

        # Check policy
        policy.should_inline(size, self.threshold)

    fn is_recursive(func: MirFunction) -> bool:
        """
        Check if function is recursive (calls itself).

        Conservative: returns true if any call matches function name.
        """
        # TODO: Implement recursive detection
        # For now, conservatively assume non-recursive
        false

# ============================================================================
# Function Inliner
# ============================================================================

class FunctionInliner:
    """
    Performs actual inlining transformation.

    Process:
    1. Find call instruction
    2. Copy function body
    3. Rename locals (avoid conflicts)
    4. Replace call with inlined body
    5. Connect control flow
    """
    next_local_id: i64
    inlined_count: i64

impl FunctionInliner:
    static fn new(next_local_id: i64) -> FunctionInliner:
        FunctionInliner(
            next_local_id: next_local_id,
            inlined_count: 0
        )

    me inline_call(
        caller_block: MirBlock,
        call_inst_idx: i64,
        callee: MirFunction,
        call_dest: LocalId?,
        args: [MirOperand]
    ) -> [MirBlock]:
        """
        Inline a function call.

        Returns new blocks (caller block split + inlined body).

        Strategy:
        1. Split caller block at call site
        2. Copy callee body blocks
        3. Bind arguments to parameters
        4. Connect control flow
        5. Handle return value
        """
        # For now, simple implementation:
        # Just replace call with function body (single-block functions only)

        # Check if callee is single-block
        if callee.blocks.len() != 1:
            # Can't inline multi-block functions yet
            return [caller_block]

        val callee_block = callee.blocks[0]

        # Build new instructions:
        # 1. Instructions before call
        # 2. Argument bindings
        # 3. Inlined body
        # 4. Instructions after call

        var new_instructions: [MirInst] = []

        # Copy instructions before call
        var i = 0
        while i < call_inst_idx:
            new_instructions.push(caller_block.instructions[i])
            i = i + 1

        # Bind arguments to parameters
        # TODO: Create copy instructions for argument binding

        # Copy inlined body (rename locals)
        for inst in callee_block.instructions:
            val renamed = self.rename_instruction(inst)
            new_instructions.push(renamed)

        # Handle return value
        # TODO: Replace return with assignment to call_dest

        # Copy instructions after call
        i = call_inst_idx + 1
        while i < caller_block.instructions.len():
            new_instructions.push(caller_block.instructions[i])
            i = i + 1

        self.inlined_count = self.inlined_count + 1

        [MirBlock(
            id: caller_block.id,
            label: caller_block.label,
            instructions: new_instructions,
            terminator: caller_block.terminator
        )]

    me rename_instruction(inst: MirInst) -> MirInst:
        """
        Rename locals in instruction to avoid conflicts.

        Creates fresh local IDs for all definitions.
        """
        # TODO: Implement proper local renaming
        # For now, return as-is
        inst

    me fresh_local() -> LocalId:
        """Allocate a fresh local ID."""
        val id = self.next_local_id
        self.next_local_id = self.next_local_id + 1
        LocalId(id: id)

# ============================================================================
# Function Inlining Pass
# ============================================================================

class FunctionInlining:
    """
    Function inlining optimization pass.

    Configuration:
    - threshold: Maximum function size to inline (in instruction units)
    - policy: Inlining aggressiveness policy

    Algorithm:
    1. Analyze all functions (build call graph, compute sizes)
    2. For each function:
       a. Find inline candidates (call sites)
       b. Check inlining heuristics
       c. Perform inlining if beneficial
    3. Repeat until fixed point or max iterations
    """
    threshold: i64
    policy: InlinePolicy
    cost_analyzer: InlineCostAnalyzer
    inlined_functions: i64
    inlined_call_sites: i64
    iterations: i64

impl FunctionInlining:
    static fn new(threshold: i64, policy: InlinePolicy) -> FunctionInlining:
        FunctionInlining(
            threshold: threshold,
            policy: policy,
            cost_analyzer: InlineCostAnalyzer.new(threshold),
            inlined_functions: 0,
            inlined_call_sites: 0,
            iterations: 0
        )

    static fn small_functions() -> FunctionInlining:
        """Inline only very small functions (for code size)."""
        FunctionInlining.new(50, InlinePolicy.Conservative)

    static fn aggressive() -> FunctionInlining:
        """Aggressive inlining (for speed)."""
        FunctionInlining.new(500, InlinePolicy.Aggressive)

    static fn very_aggressive() -> FunctionInlining:
        """Very aggressive inlining (max speed, may increase code size)."""
        FunctionInlining.new(2000, InlinePolicy.Aggressive)

    fn name() -> text:
        "function_inlining"

    fn description() -> text:
        "Inlines small function calls to eliminate call overhead"

    fn is_analysis_pass() -> bool:
        false

    fn requires() -> [text]:
        ["dead_code_elimination", "constant_folding"]

    me run_on_function(func: MirFunction) -> MirFunction:
        """
        Run inlining on a function.

        Note: This pass needs access to other functions in the module
        to perform inlining. For now, we implement a simplified version
        that only handles single-block functions.
        """
        self.iterations = self.iterations + 1

        # Find call sites in this function
        var modified = false
        var optimized_blocks: [MirBlock] = []

        for block in func.blocks:
            val optimized = self.inline_calls_in_block(block, func)
            if optimized.id.id != block.id.id or optimized.instructions.len() != block.instructions.len():
                modified = true
            optimized_blocks.push(optimized)

        if modified:
            self.inlined_functions = self.inlined_functions + 1

        MirFunction(
            symbol: func.symbol,
            name: func.name,
            signature: func.signature,
            locals: func.locals,
            blocks: optimized_blocks,
            entry_block: func.entry_block,
            span: func.span,
            generic_params: func.generic_params,
            is_generic_template: func.is_generic_template,
            specialization_of: func.specialization_of,
            type_bindings: func.type_bindings
        )

    me inline_calls_in_block(block: MirBlock, func: MirFunction) -> MirBlock:
        """
        Inline eligible calls in a block.

        For each call instruction:
        1. Check if callee should be inlined
        2. Perform inlining if beneficial
        """
        # For now, keep block as-is
        # TODO: Implement actual inlining logic

        # This would require:
        # - Access to other functions in module (need module-level pass)
        # - Local renaming
        # - Block splitting
        # - Control flow merging

        block

    # ========================================================================
    # Statistics
    # ========================================================================

    fn stats_summary() -> text:
        """Generate summary of optimization work."""
        "Inline: inlined {self.inlined_call_sites} call sites in {self.inlined_functions} functions ({self.iterations} iterations)"

# ============================================================================
# Module-Level Inlining
# ============================================================================

class ModuleInliner:
    """
    Module-level inlining pass.

    Operates on entire module to inline cross-function calls.
    """
    threshold: i64
    policy: InlinePolicy
    inlined_total: i64

impl ModuleInliner:
    static fn new(threshold: i64, policy: InlinePolicy) -> ModuleInliner:
        ModuleInliner(
            threshold: threshold,
            policy: policy,
            inlined_total: 0
        )

    me inline_module(module: MirModule) -> MirModule:
        """
        Perform inlining across module.

        Strategy:
        1. Build call graph
        2. Identify inline candidates (leaf functions first)
        3. Bottom-up inlining (inline callees into callers)
        4. Repeat until fixed point
        """
        # TODO: Implement full module-level inlining

        # For now, return module as-is
        module

# ============================================================================
# Factory Functions
# ============================================================================

fn create_inline_small_pass() -> FunctionInlining:
    """Create inlining pass for small functions (code size optimization)."""
    FunctionInlining.small_functions()

fn create_inline_pass() -> FunctionInlining:
    """Create standard inlining pass (speed optimization)."""
    FunctionInlining.aggressive()

fn create_inline_aggressive_pass() -> FunctionInlining:
    """Create aggressive inlining pass (maximum speed)."""
    FunctionInlining.very_aggressive()

# ============================================================================
# Exports
# ============================================================================

export FunctionInlining, ModuleInliner
export InlinePolicy, InlineCostAnalyzer, FunctionInliner
export create_inline_small_pass, create_inline_pass, create_inline_aggressive_pass
