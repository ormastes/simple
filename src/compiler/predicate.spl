# Unified Predicate System
#
# Single predicate expression language reused across:
# - AOP weaving (compile-time, link-time, runtime)
# - DI binding selection
# - Test mocking selection
# - Architecture rules (static dependency validation)
#
# Port of rust/compiler/src/predicate.rs (649 lines)

export PredicateContext, Selector, SignaturePattern, ArgPatterns
export Predicate, MatchContext

# ============================================================================
# Predicate Context
# ============================================================================

enum PredicateContext:
    Weaving              # AOP weaving: execution, within, attr, effect, test, decision, condition, call
    DependencyInjection  # DI binding: type, within, attr
    Mock                 # Mock selection: type, within, attr (test-only)
    Architecture         # Arch rules: import, depend, use, export, config, within, attr

# ============================================================================
# Selector Types
# ============================================================================

enum ArgPatterns:
    Any                  # (..) matches any arguments
    Specific([text])     # Specific argument patterns

struct SignaturePattern:
    """Pattern for matching function signatures: ret_pat qname_pat(arg_pats)"""
    return_type: text
    qualified_name: text
    args: ArgPatterns

enum Selector:
    # Weaving selectors
    Execution(SignaturePattern)
    Within(text)
    Attr(text)
    Effect(text)
    Test(text)
    Decision
    Condition
    Call(SignaturePattern)
    # DI selectors
    Type(text)
    # AOP runtime selectors
    Init(text)
    # Architecture selectors
    Import(text, text)    # (from, to)
    Depend(text, text)    # (from, to)
    Use(text)
    Export(text)
    Config(text)

# ============================================================================
# Predicate Expression
# ============================================================================

enum Predicate:
    Sel(Selector)
    Not(Predicate)
    And(Predicate, Predicate)
    Or(Predicate, Predicate)

# ============================================================================
# Match Context
# ============================================================================

struct MatchContext:
    # # DESUGARED: type_name: text
    has_type_name: bool
    type_name: text
    # # DESUGARED: module_path: text
    has_module_path: bool
    module_path: text
    attrs: [text]
    # # DESUGARED: signature: text
    has_signature: bool
    signature: text
    effects: [text]


# ============================================================================
# MatchContext Methods (was: impl MatchContext:)
# ============================================================================

fn matchcontext_empty() -> MatchContext:
        MatchContext(type_name: nil, module_path: nil, attrs: [],
                     signature: nil, effects: [])


# ============================================================================
# Pattern Matching
# ============================================================================

fn match_pattern(pattern: text, target: text) -> bool:
    """Glob-style pattern matching: * matches segment, ** matches multiple."""
    if pattern == "*": return true
    if pattern == target: return true
    if pattern.ends_with("*"):
        return target_starts_with(target, pattern[:pattern.len() - 1])
    if pattern.starts_with("*"):
        return target_ends_with(target, pattern[1:])
    return false

fn match_selector(sel: Selector, ctx: MatchContext) -> bool:
    match sel:
        case Within(pattern):
            if ctx.has_module_path:
                return match_pattern(pattern, ctx.module_path_value)
            else:
                return false
        case Attr(name):
            return ctx.attrs_contains(attrs, name)
        case Effect(name):
            return ctx.effects_contains(effects, name)
        case Type(pattern):
            if ctx.has_type_name:
                return match_pattern(pattern, ctx.type_name_value)
            else:
                return false
        case Test(pattern):
            if ctx.has_signature:
                return match_pattern(pattern, ctx.signature_value)
            else:
                return false
        case _:
            return false

fn match_predicate(pred: Predicate, ctx: MatchContext) -> bool:
    match pred:
        case Sel(sel): match_selector(sel, ctx)
        case Not(inner): not match_predicate(inner, ctx)
        case And(lhs, rhs): match_predicate(lhs, ctx) and match_predicate(rhs, ctx)
        case Or(lhs, rhs): match_predicate(lhs, ctx) or match_predicate(rhs, ctx)

# ============================================================================
# Specificity
# ============================================================================

fn pattern_specificity(pattern: text) -> i64:
    """Calculate specificity of a pattern for tie-breaking."""
    if pattern == "**": return -2
    if pattern == "*": return 0
    if pattern.starts_with("*") or pattern.ends_with("*"): return 1
    2  # Literal match

fn selector_specificity(sel: Selector) -> i64:
    match sel:
        case Within(p): pattern_specificity(p)
        case Attr(_): 2
        case Effect(_): 2
        case Type(p): pattern_specificity(p)
        case Test(p): pattern_specificity(p)
        case _: 1

fn predicate_specificity(pred: Predicate) -> i64:
    match pred:
        case Sel(sel): selector_specificity(sel)
        case Not(inner): predicate_specificity(inner) - 1
        case And(lhs, rhs): predicate_specificity(lhs) + predicate_specificity(rhs)
        case Or(lhs, rhs):
            val l = predicate_specificity(lhs)
            val r = predicate_specificity(rhs)
            if l > r: l else: r

# ============================================================================
# Validation
# ============================================================================

fn validate_selector(sel: Selector, ctx: PredicateContext) -> text:
    """Validate that a selector is legal in the given context."""
    match ctx:
        case Weaving:
            match sel:
                case Type(_): Err("type() selector not valid in weaving context")
                case Import(_, _): Err("import() selector not valid in weaving context")
                case Depend(_, _): Err("depend() selector not valid in weaving context")
                case Use(_): Err("use() selector not valid in weaving context")
                case Export(_): Err("export() selector not valid in weaving context")
                case Config(_): Err("config() selector not valid in weaving context")
                case _: Ok(true)
        case DependencyInjection:
            match sel:
                case Type(_): Ok(true)
                case Within(_): Ok(true)
                case Attr(_): Ok(true)
                case _: Err("selector not valid in DI context")
        case Mock:
            match sel:
                case Type(_): Ok(true)
                case Within(_): Ok(true)
                case Attr(_): Ok(true)
                case _: Err("selector not valid in mock context")
        case Architecture:
            match sel:
                case Import(_, _): Ok(true)
                case Depend(_, _): Ok(true)
                case Use(_): Ok(true)
                case Export(_): Ok(true)
                case Config(_): Ok(true)
                case Within(_): Ok(true)
                case Attr(_): Ok(true)
                case _: Err("selector not valid in architecture context")
