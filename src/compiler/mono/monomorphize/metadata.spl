# Monomorphization Metadata
#
# This module provides data structures to track:
# - Generic template definitions (functions, structs, enums, traits)
# - Specialization instances and their type bindings
# - Mapping between templates and specialized instances
#
# Port of: rust/compiler/src/monomorphize/metadata.rs (190 lines)


# Auto-generated desugared static method wrappers
fn GenericClassMeta__new(base_name: text, generic_params: [text]) -> GenericClassMeta:
    """Create a new class metadata."""
    GenericClassMeta(
        base_name: base_name,
        generic_params: generic_params,
        specializations: []
    )


fn GenericEnumMeta__new(base_name: text, generic_params: [text]) -> GenericEnumMeta:
    """Create a new enum metadata."""
    GenericEnumMeta(
        base_name: base_name,
        generic_params: generic_params,
        specializations: []
    )


fn GenericFunctionMeta__new(base_name: text, generic_params: [text]) -> GenericFunctionMeta:
    """Create a new function metadata."""
    GenericFunctionMeta(
        base_name: base_name,
        generic_params: generic_params,
        specializations: []
    )


fn GenericStructMeta__new(base_name: text, generic_params: [text]) -> GenericStructMeta:
    """Create a new struct metadata."""
    GenericStructMeta(
        base_name: base_name,
        generic_params: generic_params,
        specializations: []
    )


fn GenericTraitMeta__new(base_name: text, generic_params: [text]) -> GenericTraitMeta:
    """Create a new trait metadata."""
    GenericTraitMeta(
        base_name: base_name,
        generic_params: generic_params,
        impl_specializations: []
    )


fn MonomorphizationMetadata__new() -> MonomorphizationMetadata:
    """Create a new empty metadata collection."""
    MonomorphizationMetadata(
        functions: {},
        structs: {},
        classes: {},
        enums: {},
        traits: {}
    )


fn SpecializationEntry__new(type_args: [ConcreteType], mangled_name: text, bindings: TypeBindings) -> SpecializationEntry:
    """Create a specialization entry with explicit bindings."""
    SpecializationEntry(
        type_args: type_args,
        mangled_name: mangled_name,
        bindings: bindings
    )


export MonomorphizationMetadata
export GenericFunctionMeta
export GenericStructMeta
export GenericClassMeta
export GenericEnumMeta
export GenericTraitMeta
export SpecializationEntry
export TraitImplEntry

use compiler.mono.monomorphize.types (ConcreteType, SpecializationKey, TypeBindings)
# ============================================================================
# Monomorphization Metadata
# ============================================================================

struct MonomorphizationMetadata:
    """Complete monomorphization metadata for a module.

    Stores all generic templates and their specializations for
    serialization to .smf files.

    ROBUSTNESS: Complete tracking of all generic constructs.
    """
    # Generic function templates and their specializations
    functions: {text: GenericFunctionMeta}

    # Generic struct templates and their specializations
    structs: {text: GenericStructMeta}

    # Generic class templates and their specializations
    classes: {text: GenericClassMeta}

    # Generic enum templates and their specializations
    enums: {text: GenericEnumMeta}

    # Generic trait templates and their implementations
    traits: {text: GenericTraitMeta}

impl MonomorphizationMetadata:
    static fn new() -> MonomorphizationMetadata:
        """Create a new empty metadata collection."""
        MonomorphizationMetadata(
            functions: {},
            structs: {},
            classes: {},
            enums: {},
            traits: {}
        )

    fn is_empty() -> bool:
        """Check if metadata is empty (no generic constructs)."""
        (self.functions.is_empty() and
        self.structs.is_empty() and
        self.classes.is_empty() and
        self.enums.is_empty() and
        self.traits.is_empty())

    fn total_templates() -> i64:
        """Total number of generic templates."""
        (self.functions.len() +
        self.structs.len() +
        self.classes.len() +
        self.enums.len() +
        self.traits.len())

    fn total_specializations() -> i64:
        """Total number of specializations across all templates."""
        var count = 0
        for (_, meta) in self.functions.items():
            count = count + meta.specializations.len()
        for (_, meta) in self.structs.items():
            count = count + meta.specializations.len()
        for (_, meta) in self.classes.items():
            count = count + meta.specializations.len()
        for (_, meta) in self.enums.items():
            count = count + meta.specializations.len()
        count

# ============================================================================
# Generic Function Metadata
# ============================================================================

struct GenericFunctionMeta:
    """Metadata for a generic function template."""
    base_name: text                        # Base name (before mangling)
    generic_params: [text]                 # Generic type parameter names (e.g., ["T", "U"])
    specializations: [SpecializationEntry] # All specializations generated

impl GenericFunctionMeta:
    static fn new(base_name: text, generic_params: [text]) -> GenericFunctionMeta:
        """Create a new function metadata."""
        GenericFunctionMeta(
            base_name: base_name,
            generic_params: generic_params,
            specializations: []
        )

    me add_specialization(entry: SpecializationEntry):
        """Add a specialization entry."""
        self.specializations.push(entry)

    fn specialization_count() -> i64:
        """Number of specializations."""
        self.specializations.len()

# ============================================================================
# Generic Struct Metadata
# ============================================================================

struct GenericStructMeta:
    """Metadata for a generic struct template."""
    base_name: text                        # Base name (before mangling)
    generic_params: [text]                 # Generic type parameter names
    specializations: [SpecializationEntry] # All specializations generated

impl GenericStructMeta:
    static fn new(base_name: text, generic_params: [text]) -> GenericStructMeta:
        """Create a new struct metadata."""
        GenericStructMeta(
            base_name: base_name,
            generic_params: generic_params,
            specializations: []
        )

    me add_specialization(entry: SpecializationEntry):
        """Add a specialization entry."""
        self.specializations.push(entry)

    fn specialization_count() -> i64:
        """Number of specializations."""
        self.specializations.len()

# ============================================================================
# Generic Class Metadata
# ============================================================================

struct GenericClassMeta:
    """Metadata for a generic class template."""
    base_name: text                        # Base name (before mangling)
    generic_params: [text]                 # Generic type parameter names
    specializations: [SpecializationEntry] # All specializations generated

impl GenericClassMeta:
    static fn new(base_name: text, generic_params: [text]) -> GenericClassMeta:
        """Create a new class metadata."""
        GenericClassMeta(
            base_name: base_name,
            generic_params: generic_params,
            specializations: []
        )

    me add_specialization(entry: SpecializationEntry):
        """Add a specialization entry."""
        self.specializations.push(entry)

    fn specialization_count() -> i64:
        """Number of specializations."""
        self.specializations.len()

# ============================================================================
# Generic Enum Metadata
# ============================================================================

struct GenericEnumMeta:
    """Metadata for a generic enum template."""
    base_name: text                        # Base name (before mangling)
    generic_params: [text]                 # Generic type parameter names (e.g., ["T", "E"])
    specializations: [SpecializationEntry] # All specializations generated

impl GenericEnumMeta:
    static fn new(base_name: text, generic_params: [text]) -> GenericEnumMeta:
        """Create a new enum metadata."""
        GenericEnumMeta(
            base_name: base_name,
            generic_params: generic_params,
            specializations: []
        )

    me add_specialization(entry: SpecializationEntry):
        """Add a specialization entry."""
        self.specializations.push(entry)

    fn specialization_count() -> i64:
        """Number of specializations."""
        self.specializations.len()

# ============================================================================
# Generic Trait Metadata
# ============================================================================

struct GenericTraitMeta:
    """Metadata for a generic trait template."""
    base_name: text                          # Base name (before mangling)
    generic_params: [text]                   # Generic type parameter names (e.g., ["T"])
    impl_specializations: [TraitImplEntry]   # All trait implementations

impl GenericTraitMeta:
    static fn new(base_name: text, generic_params: [text]) -> GenericTraitMeta:
        """Create a new trait metadata."""
        GenericTraitMeta(
            base_name: base_name,
            generic_params: generic_params,
            impl_specializations: []
        )

    me add_impl(entry: TraitImplEntry):
        """Add a trait implementation entry."""
        self.impl_specializations.push(entry)

    fn impl_count() -> i64:
        """Number of trait implementations."""
        self.impl_specializations.len()

# ============================================================================
# Specialization Entry
# ============================================================================

struct SpecializationEntry:
    """A single specialization instance.

    Tracks a specific instantiation of a generic template with concrete types.

    Example:
        identity<Int> has:
        - type_args: [Int]
        - mangled_name: "identity$Int"
        - bindings: {"T": Int}
    """
    type_args: [ConcreteType]       # Concrete type arguments (e.g., [Int, String])
    mangled_name: text              # Mangled name (e.g., "identity$Int")
    bindings: TypeBindings          # Type parameter bindings (e.g., T -> Int)

impl SpecializationEntry:
    static fn from_key(key: SpecializationKey) -> SpecializationEntry:
        """Create a new specialization entry from a key.

        Bindings will be empty and should be filled later.
        """
        SpecializationEntry(
            type_args: key.type_args.clone(),
            mangled_name: key.mangled_name(),
            bindings: {}
        )

    static fn new(type_args: [ConcreteType], mangled_name: text, bindings: TypeBindings) -> SpecializationEntry:
        """Create a specialization entry with explicit bindings."""
        SpecializationEntry(
            type_args: type_args,
            mangled_name: mangled_name,
            bindings: bindings
        )

    fn type_arg_count() -> i64:
        """Number of type arguments."""
        self.type_args.len()

    fn has_binding(param: text) -> bool:
        """Check if a type parameter has a binding."""
        self.bindings.contains_key(param)

    fn get_binding(param: text) -> ConcreteType?:
        """Get the concrete type for a type parameter."""
        self.bindings.get(param)

# ============================================================================
# Trait Implementation Entry
# ============================================================================

struct TraitImplEntry:
    """Trait implementation entry.

    Tracks a specific implementation of a generic trait for a concrete type.

    Example:
        impl Iterator<Int> for [Int] has:
        - trait_name: "Iterator"
        - type_args: [Int]
        - impl_for_type: "List$Int"
        - mangled_name: "Iterator$Int_impl_for_List$Int"
    """
    trait_name: text                # Trait name (e.g., "Iterator")
    type_args: [ConcreteType]       # Concrete type arguments for the trait (e.g., [Int])
    impl_for_type: text             # The type this trait is implemented for
    mangled_name: text              # Mangled name of the implementation

impl TraitImplEntry:
    static fn new(
        trait_name: text,
        type_args: [ConcreteType],
        impl_for_type: text,
        mangled_name: text
    ) -> TraitImplEntry:
        """Create a new trait implementation entry."""
        TraitImplEntry(
            trait_name: trait_name,
            type_args: type_args,
            impl_for_type: impl_for_type,
            mangled_name: mangled_name
        )

# ============================================================================
# Usage Example
# ============================================================================
#
# # Create metadata
# val metadata = MonomorphizationMetadata.new()
#
# # Add a generic function template
# metadata.functions["identity"] = GenericFunctionMeta.new("identity", ["T"])
#
# # Add a specialization
# val entry = SpecializationEntry.new(
#     type_args: [ConcreteType.Int],
#     mangled_name: "identity$Int",
#     bindings: {"T": ConcreteType.Int}
# )
# metadata.functions["identity"].add_specialization(entry)
#
# # Query metadata
# print "Total templates: {metadata.total_templates()}"
# print "Total specializations: {metadata.total_specializations()}"
#
# # Check specializations for a function
# val id_meta = metadata.functions["identity"]
# print "identity has {id_meta.specialization_count()} specializations"
#
# # Trait implementation
# val trait_impl = TraitImplEntry.new(
#     trait_name: "Iterator",
#     type_args: [ConcreteType.Int],
#     impl_for_type: "List$Int",
#     mangled_name: "Iterator$Int_impl_for_List$Int"
# )
# metadata.traits["Iterator"].add_impl(trait_impl)
#
# ============================================================================
# Serialization Format
# ============================================================================
#
# Binary layout when serializing to .smf TemplateMeta section:
#
# MonomorphizationMetadata:
#   magic: "META" (4 bytes)
#   version: u16 (2 bytes)
#   function_count: u32
#   struct_count: u32
#   class_count: u32
#   enum_count: u32
#   trait_count: u32
#   functions: [GenericFunctionMeta]
#   structs: [GenericStructMeta]
#   classes: [GenericClassMeta]
#   enums: [GenericEnumMeta]
#   traits: [GenericTraitMeta]
#
# GenericFunctionMeta / GenericStructMeta / GenericClassMeta / GenericEnumMeta:
#   name_len: u32
#   name: bytes
#   param_count: u8
#   params: [length-prefixed String]
#   spec_count: u32
#   specializations: [SpecializationEntry]
#
# GenericTraitMeta:
#   name_len: u32
#   name: bytes
#   param_count: u8
#   params: [length-prefixed String]
#   impl_count: u32
#   impl_specializations: [TraitImplEntry]
#
# SpecializationEntry:
#   arg_count: u8
#   type_args: [length-prefixed String (ConcreteType.to_string())]
#   mangled_name_len: u32
#   mangled_name: bytes
#   binding_count: u8
#   bindings: [(length-prefixed String key, length-prefixed String value)]
#
# TraitImplEntry:
#   trait_name_len: u32
#   trait_name: bytes
#   arg_count: u8
#   type_args: [length-prefixed String]
#   impl_for_type_len: u32
#   impl_for_type: bytes
#   mangled_name_len: u32
#   mangled_name: bytes
#

fn meta_u32_to_bytes(value: i64) -> [u8]:
    """Convert a value to 4 little-endian bytes."""
    [
        (value & 0xFF).to_u8(),
        ((value >> 8) & 0xFF).to_u8(),
        ((value >> 16) & 0xFF).to_u8(),
        ((value >> 24) & 0xFF).to_u8()
    ]

fn meta_serialize_text(buf: [u8], value: text) -> [u8]:
    """Serialize a text value as length-prefixed bytes."""
    var out = buf
    val bytes = value.to_bytes()
    out = out.concat(meta_u32_to_bytes(bytes.len()))
    out = out.concat(bytes)
    out

fn serialize_specialization_entry(buf: [u8], entry: SpecializationEntry) -> [u8]:
    """Serialize a single SpecializationEntry."""
    var out = buf

    # Type args count + serialized type strings
    out = out.push(entry.type_args.len().to_u8())
    for arg in entry.type_args:
        out = meta_serialize_text(out, arg.to_string())

    # Mangled name
    out = meta_serialize_text(out, entry.mangled_name)

    # Bindings count + key-value pairs
    out = out.push(entry.bindings.len().to_u8())
    for (key, value) in entry.bindings.items():
        out = meta_serialize_text(out, key)
        out = meta_serialize_text(out, value.to_string())

    out

fn serialize_trait_impl_entry(buf: [u8], entry: TraitImplEntry) -> [u8]:
    """Serialize a single TraitImplEntry."""
    var out = buf

    # Trait name
    out = meta_serialize_text(out, entry.trait_name)

    # Type args count + serialized type strings
    out = out.push(entry.type_args.len().to_u8())
    for arg in entry.type_args:
        out = meta_serialize_text(out, arg.to_string())

    # Impl for type
    out = meta_serialize_text(out, entry.impl_for_type)

    # Mangled name
    out = meta_serialize_text(out, entry.mangled_name)

    out

fn serialize_generic_meta(buf: [u8], base_name: text, generic_params: [text], specializations: [SpecializationEntry]) -> [u8]:
    """Serialize the common fields of a generic metadata entry."""
    var out = buf

    # Name
    out = meta_serialize_text(out, base_name)

    # Param count + param names
    out = out.push(generic_params.len().to_u8())
    for param in generic_params:
        out = meta_serialize_text(out, param)

    # Specialization count + entries
    out = out.concat(meta_u32_to_bytes(specializations.len()))
    for entry in specializations:
        out = serialize_specialization_entry(out, entry)

    out

impl MonomorphizationMetadata:
    fn serialize() -> [u8]:
        """Serialize the complete metadata to binary format.

        Produces the binary layout described in the Serialization Format section above.
        """
        var buf: [u8] = []

        # Magic: "META"
        buf = buf.concat([0x4D, 0x45, 0x54, 0x41])

        # Version: 1.0
        buf = buf.concat([0x01, 0x00])

        # Category counts
        buf = buf.concat(meta_u32_to_bytes(self.functions.len()))
        buf = buf.concat(meta_u32_to_bytes(self.structs.len()))
        buf = buf.concat(meta_u32_to_bytes(self.classes.len()))
        buf = buf.concat(meta_u32_to_bytes(self.enums.len()))
        buf = buf.concat(meta_u32_to_bytes(self.traits.len()))

        # Serialize function metadata entries
        for (name, func_meta) in self.functions.items():
            buf = serialize_generic_meta(buf, func_meta.base_name, func_meta.generic_params, func_meta.specializations)

        # Serialize struct metadata entries
        for (name, struct_meta) in self.structs.items():
            buf = serialize_generic_meta(buf, struct_meta.base_name, struct_meta.generic_params, struct_meta.specializations)

        # Serialize class metadata entries
        for (name, class_meta) in self.classes.items():
            buf = serialize_generic_meta(buf, class_meta.base_name, class_meta.generic_params, class_meta.specializations)

        # Serialize enum metadata entries
        for (name, enum_meta) in self.enums.items():
            buf = serialize_generic_meta(buf, enum_meta.base_name, enum_meta.generic_params, enum_meta.specializations)

        # Serialize trait metadata entries
        for (name, trait_meta) in self.traits.items():
            buf = meta_serialize_text(buf, trait_meta.base_name)
            buf = buf.push(trait_meta.generic_params.len().to_u8())
            for param in trait_meta.generic_params:
                buf = meta_serialize_text(buf, param)
            buf = buf.concat(meta_u32_to_bytes(trait_meta.impl_specializations.len()))
            for entry in trait_meta.impl_specializations:
                buf = serialize_trait_impl_entry(buf, entry)

        buf
#
# ============================================================================
# Performance Notes
# ============================================================================
#
# - Lookup by name: O(1) hash table
# - Add specialization: O(1) array append
# - Total count queries: O(n) where n = number of templates
# - Serialization: O(total size) linear scan
#
# Expected performance: Same as Rust (same data structures)
#
# ============================================================================
# Robustness Checklist
# ============================================================================
#
# Memory Safety:
# - [x] No buffer overflows (Simple arrays safe)
# - [x] No null pointers (all fields required)
# - [x] No use-after-free (Simple ownership)
#
# Logic Correctness:
# - [x] All generic constructs tracked
# - [x] Specializations properly linked to templates
# - [x] Type bindings preserved
# - [x] Mangled names unique
#
# Edge Cases:
# - [x] Empty metadata (is_empty() returns true)
# - [x] No specializations (empty lists)
# - [x] Multiple specializations (list grows)
# - [x] Trait implementations tracked separately
#
# Remaining work:
# - [x] Add serialization (Phase 6 - serialize() method)
# - [ ] Add deserialization (deserialize from bytes)
# - [ ] Add optimization level tracking
# - [ ] Add dependency tracking between specializations
# - [ ] Add incremental update support
