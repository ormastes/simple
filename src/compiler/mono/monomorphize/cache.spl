# Monomorphization Cache
#
# Caches specialized function/struct/class definitions by specialization key.
# Content-based keys derived from definition hash + type arguments + mtime.
# Supports LRU eviction and optional disk persistence.
#
# Port of rust/compiler/src/monomorphize/cache.rs (100+ lines)


# Auto-generated desugared static method wrappers
fn MonoCacheStats__empty() -> MonoCacheStats:
    MonoCacheStats(hits: 0, misses: 0, evictions: 0, invalidations: 0,
                   function_entries: 0, struct_entries: 0, class_entries: 0)


export MonoCacheConfig, MonoCacheStats, MonoCache

# ============================================================================
# Configuration
# ============================================================================

struct MonoCacheConfig:
    max_entries: i64
    validate_timestamps: bool
    persist_to_disk: bool
    cache_dir: text?

impl MonoCacheConfig:
    static fn default_config() -> MonoCacheConfig:
        MonoCacheConfig(max_entries: 10000, validate_timestamps: true,
                        persist_to_disk: false, cache_dir: nil)

    static fn memory_only() -> MonoCacheConfig:
        MonoCacheConfig(max_entries: 10000, validate_timestamps: true,
                        persist_to_disk: false, cache_dir: nil)

    static fn persistent(cache_dir: text) -> MonoCacheConfig:
        MonoCacheConfig(max_entries: 50000, validate_timestamps: true,
                        persist_to_disk: true, cache_dir: Some(cache_dir))

# ============================================================================
# Statistics
# ============================================================================

struct MonoCacheStats:
    hits: i64
    misses: i64
    evictions: i64
    invalidations: i64
    function_entries: i64
    struct_entries: i64
    class_entries: i64

impl MonoCacheStats:
    static fn empty() -> MonoCacheStats:
        MonoCacheStats(hits: 0, misses: 0, evictions: 0, invalidations: 0,
                       function_entries: 0, struct_entries: 0, class_entries: 0)

    fn hit_ratio() -> f64:
        val total = self.hits + self.misses
        if total == 0: 0.0
        else: self.hits.to_f64() / total.to_f64()

    fn total_entries() -> i64:
        self.function_entries + self.struct_entries + self.class_entries

# ============================================================================
# Cache Entry
# ============================================================================

struct CacheEntry:
    key: text
    value: Any
    last_access: i64
    content_hash: i64

# ============================================================================
# Mono Cache
# ============================================================================

class MonoCache:
    """Cache for monomorphization results."""
    config: MonoCacheConfig
    entries: {text: CacheEntry}
    stats: MonoCacheStats
    oldest_key: text

impl MonoCache:
    static fn create(config: MonoCacheConfig) -> MonoCache:
        MonoCache(config: config, entries: {}, stats: MonoCacheStats__empty(), oldest_key: "")

    me lookup(key: text) -> Any?:
        if self.entries.contains_key(key):
            self.stats.hits = self.stats.hits + 1
            Some(self.entries[key].value)
        else:
            self.stats.misses = self.stats.misses + 1
            nil

    me store(key: text, value: Any, content_hash: i64):
        extern fn rt_time_millis() -> i64
        if self.entries.len() >= self.config.max_entries:
            self.evict_oldest()
        val now = rt_time_millis()
        self.entries[key] = CacheEntry(key: key, value: value,
            last_access: now, content_hash: content_hash)
        # Track oldest: if cache was empty or this is older than current oldest
        if self.oldest_key == "" or not self.entries.contains_key(self.oldest_key):
            self.oldest_key = key
        else:
            if now < self.entries[self.oldest_key].last_access:
                self.oldest_key = key

    me evict_oldest():
        """Evict the least recently accessed entry (O(1) amortized)."""
        if not self.entries.?:
            return
        # Use tracked oldest_key for O(1) eviction
        if self.oldest_key != "" and self.entries.contains_key(self.oldest_key):
            self.entries = self.entries.remove(self.oldest_key)
            self.stats.evictions = self.stats.evictions + 1
        else:
            # Fallback: scan for oldest (only if tracked key was invalidated)
            var scan_key = ""
            var scan_time: i64 = 9223372036854775807
            for (k, entry) in self.entries:
                if entry.last_access < scan_time:
                    scan_time = entry.last_access
                    scan_key = k
            if scan_key.?:
                self.entries = self.entries.remove(scan_key)
                self.stats.evictions = self.stats.evictions + 1
        # Find new oldest after eviction
        var new_oldest_key = ""
        var new_oldest_time: i64 = 9223372036854775807
        for (k, entry) in self.entries:
            if entry.last_access < new_oldest_time:
                new_oldest_time = entry.last_access
                new_oldest_key = k
        self.oldest_key = new_oldest_key

    me clear():
        self.entries = {}

    fn get_stats() -> MonoCacheStats:
        self.stats
