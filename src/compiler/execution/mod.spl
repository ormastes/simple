# Execution Manager - Unified JIT Execution Interface
#
# Provides a Simple-side interface to the Rust ExecutionManager trait.
# Supports Cranelift and LLVM JIT backends through SFFI wrappers.
#
# Usage:
#   val em = LocalExecutionManager.auto()
#   val info = em.compile(mir_module)
#   val result = em.execute("main", [])
#   em.cleanup()

use app.io.io (rt_exec_manager_create, rt_exec_manager_compile,
    rt_exec_manager_execute, rt_exec_manager_has_function,
    rt_exec_manager_backend_name, rt_exec_manager_cleanup,
    rt_set_jit_backend, rt_get_jit_backend)

# ============================================================================
# ExecutionManager Trait
# ============================================================================

trait ExecutionManager:
    """Unified interface for JIT execution backends."""
    fn compile(mir_data: text) -> Result<text, text>
    fn execute(name: text, args: [i64]) -> Result<i64, text>
    fn has_function(name: text) -> bool
    fn backend_name() -> text
    fn cleanup()

# ============================================================================
# CodeInfo - Result of compilation
# ============================================================================

struct CodeInfo:
    """Information about a compiled module."""
    name: text
    entry_point: text
    symbol_names: [text]

# ============================================================================
# LocalExecutionManager - SFFI-backed JIT execution
# ============================================================================

class LocalExecutionManager:
    """Local JIT execution manager backed by Rust ExecutionManager.

    Wraps the Rust-side LocalExecutionManager via SFFI handle.
    Supports Cranelift and LLVM JIT backends.
    """
    handle: i64

    static fn cranelift() -> LocalExecutionManager:
        """Create with Cranelift JIT backend."""
        val h = rt_exec_manager_create("cranelift")
        LocalExecutionManager(handle: h)

    static fn llvm() -> LocalExecutionManager:
        """Create with LLVM JIT backend."""
        val h = rt_exec_manager_create("llvm")
        LocalExecutionManager(handle: h)

    static fn auto() -> LocalExecutionManager:
        """Create with auto-selected JIT backend."""
        val h = rt_exec_manager_create("auto")
        LocalExecutionManager(handle: h)

    fn compile(mir_data: text) -> Result<text, text>:
        """Compile MIR data. Returns Ok("") on success, Err(message) on failure."""
        val result = rt_exec_manager_compile(self.handle, mir_data)
        if result == "":
            Ok("")
        else:
            Err(result)

    fn execute(name: text, args: [i64]) -> Result<i64, text>:
        """Execute a compiled function by name."""
        val result = rt_exec_manager_execute(self.handle, name, args)
        Ok(result)

    fn has_function(name: text) -> bool:
        """Check if a function is available."""
        rt_exec_manager_has_function(self.handle, name)

    fn backend_name() -> text:
        """Get the name of the underlying JIT backend."""
        rt_exec_manager_backend_name(self.handle)

    fn cleanup():
        """Release all compiled code and free resources."""
        rt_exec_manager_cleanup(self.handle)

# ============================================================================
# Global JIT Backend Control
# ============================================================================

fn set_jit_backend(backend: text) -> bool:
    """Set the global JIT backend preference: 'auto', 'cranelift', or 'llvm'."""
    rt_set_jit_backend(backend)

fn get_jit_backend() -> text:
    """Get the current global JIT backend name."""
    rt_get_jit_backend()

# ============================================================================
# Exports
# ============================================================================

export ExecutionManager, CodeInfo, LocalExecutionManager
export set_jit_backend, get_jit_backend
