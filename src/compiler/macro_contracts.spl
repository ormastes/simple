# Macro Contract Processing
#
# Processes macro contracts: intro (symbol introduction), inject (code injection),
# and returns (return type declaration). Enables IDE autocomplete without expansion.
#
# Port of rust/compiler/src/macro_contracts.rs (535 lines)

export MacroContractResult, MacroAnchor, MacroIntroKind
export process_macro_contract

# ============================================================================
# Types
# ============================================================================

enum MacroAnchor:
    """Where injected code is placed."""
    Head        # Before any statements
    Tail        # After all statements
    Here        # At the callsite

enum MacroIntroKind:
    """Kind of symbol introduced by a macro."""
    Function
    Class
    TypeAlias
    Field
    Variable

struct IntroducedSymbol:
    name: text
    kind: MacroIntroKind
    type_annotation: text?
    is_const: bool

struct InjectionSpec:
    anchor: MacroAnchor
    label: text?

# ============================================================================
# Contract Result
# ============================================================================

struct MacroContractResult:
    """Result of processing macro contract items."""
    introduced_functions: {text: Any}
    introduced_classes: {text: Any}
    introduced_types: {text: text}
    introduced_fields: [IntroducedSymbol]
    introduced_vars: [(text, text, bool)]   # (name, type, is_const)
    injections: {text: [Any]}               # anchor_name -> blocks
    inject_labels: {text: MacroAnchor}
    intro_function_labels: {text: text}     # label -> public name
    return_type: text?
    return_label: text?

impl MacroContractResult:
    static fn empty() -> MacroContractResult:
        MacroContractResult(
            introduced_functions: {}, introduced_classes: {},
            introduced_types: {}, introduced_fields: [],
            introduced_vars: [], injections: {},
            inject_labels: {}, intro_function_labels: {},
            return_type: nil, return_label: nil)

    fn has_introductions() -> bool:
        (self.introduced_functions.? or self.introduced_classes.? or
        self.introduced_types.? or self.introduced_fields.? or
        self.introduced_vars.?)

    fn has_injections() -> bool:
        self.injections.?

# ============================================================================
# Contract Processing
# ============================================================================

fn process_macro_contract(contract_items: [MacroContractItem],
                          const_bindings: {text: text},
                          existing_symbols: SymbolScope) -> Result<MacroContractResult, text>:
    """Process all contract items in a macro definition."""
    var result = MacroContractResult.empty()
    var introduced_names: [text] = []

    for item in contract_items:
        match item.kind:
            case "returns":
                if item.type_name.?:
                    result = MacroContractResult(
                        introduced_functions: result.introduced_functions,
                        introduced_classes: result.introduced_classes,
                        introduced_types: result.introduced_types,
                        introduced_fields: result.introduced_fields,
                        introduced_vars: result.introduced_vars,
                        injections: result.injections,
                        inject_labels: result.inject_labels,
                        intro_function_labels: result.intro_function_labels,
                        return_type: item.type_name,
                        return_label: item.label)
            case "intro":
                # Check for shadowing
                if item.name.? and existing_symbols.contains(item.name.unwrap()):
                    return Err("macro intro '{item.name.unwrap()}' shadows existing symbol")
                if item.name.? and introduced_names.contains(item.name.unwrap()):
                    return Err("macro intro '{item.name.unwrap()}' already introduced")
                if item.name.?:
                    introduced_names = introduced_names.push(item.name.unwrap())
            case "inject":
                if item.anchor.? and item.label.?:
                    val anchor = match item.anchor.unwrap():
                        case "head": MacroAnchor.Head
                        case "tail": MacroAnchor.Tail
                        case _: MacroAnchor.Here
                    result = MacroContractResult(
                        introduced_functions: result.introduced_functions,
                        introduced_classes: result.introduced_classes,
                        introduced_types: result.introduced_types,
                        introduced_fields: result.introduced_fields,
                        introduced_vars: result.introduced_vars,
                        injections: result.injections,
                        inject_labels: result.inject_labels,
                        intro_function_labels: result.intro_function_labels,
                        return_type: result.return_type,
                        return_label: result.return_label)
            case _: ()

    Ok(result)

# ============================================================================
# Support Types
# ============================================================================

struct MacroContractItem:
    kind: text          # "returns", "intro", "inject"
    name: text?
    type_name: text?
    label: text?
    anchor: text?

struct SymbolScope:
    functions: [text]
    classes: [text]
    variables: [text]
    types: [text]

impl SymbolScope:
    static fn empty() -> SymbolScope:
        SymbolScope(functions: [], classes: [], variables: [], types: [])

    fn contains(name: text) -> bool:
        (self.functions.contains(name) or self.classes.contains(name) or
        self.variables.contains(name) or self.types.contains(name))

    fn get_namespace(name: text) -> text?:
        if self.functions.contains(name): Some("function")
        elif self.classes.contains(name): Some("class")
        elif self.variables.contains(name): Some("variable")
        elif self.types.contains(name): Some("type")
        else: nil
