# Lexer Types - Token and Span Definitions
#
# This module contains core lexer type definitions:
# - TokenKind: All token types (keywords, operators, literals, etc.)
# - Span: Source location tracking
# - Token: Token with kind and span
#
# The lexer implementation is in lexer.spl

enum TokenKind:
    # Literals
    IntLit          # 42, 0x2A, 0b101010, 0o52
    FloatLit        # 3.14, 1e10, 2.5e-3
    StringLit       # "hello", 'hello', """multiline"""
    RawStringLit    # r"raw\nstring"
    BoolLit         # true, false
    NilLit          # nil

    # Identifiers and Keywords
    Ident           # foo, bar, _private

    # Keywords - Declarations
    KwFn            # fn           # tier: seed
    KwVal           # val          # tier: seed
    KwVar           # var          # tier: seed
    KwStruct        # struct       # tier: seed
    KwClass         # class        # tier: seed
    KwEnum          # enum         # tier: seed
    KwTrait         # trait        # tier: core
    KwImpl          # impl         # tier: seed
    KwType          # type         # tier: core
    KwMod           # mod          # tier: full
    KwPub           # pub          # tier: core
    KwPri           # pri (private)  # tier: full
    KwStatic        # static       # tier: core
    KwMe            # me (mutable self method)  # tier: core
    KwExtern        # extern       # tier: seed
    KwConst         # const        # tier: full
    KwBitfield      # bitfield     # tier: full
    KwKernel        # kernel (GPU) # tier: full
    KwShared        # shared (GPU) # tier: full
    KwUnsafe        # unsafe       # tier: full
    KwAsm           # asm          # tier: core

    # Keywords - Control Flow
    KwIf            # if           # tier: seed
    KwElse          # else         # tier: seed
    KwElif          # elif         # tier: seed
    KwMatch         # match        # tier: seed
    KwCase          # case         # tier: seed
    KwFor           # for          # tier: seed
    KwWhile         # while        # tier: seed
    KwLoop          # loop         # tier: core
    KwBreak         # break        # tier: seed
    KwContinue      # continue     # tier: seed
    KwReturn        # return       # tier: seed
    KwYield         # yield        # tier: core
    KwAwait         # await        # tier: core
    KwAsync         # async        # tier: core
    KwSpawn         # spawn        # tier: core
    KwActor         # actor        # tier: full

    # Keywords - Expressions
    KwIn            # in           # tier: seed
    KwIs            # is           # tier: core
    KwAs            # as           # tier: full
    KwNot           # not          # tier: core
    KwAnd           # and          # tier: core
    KwOr            # or           # tier: core
    KwXor           # xor          # tier: full
    KwTry           # try          # tier: full
    KwCatch         # catch        # tier: full
    KwThrow         # throw        # tier: full
    KwWith          # with         # tier: full

    # Keywords - Imports
    KwImport        # import       # tier: seed
    KwExport        # export       # tier: seed
    KwFrom          # from         # tier: full

    # Keywords - Special
    KwSelf          # self         # tier: core
    KwSuper         # super        # tier: full
    KwNone          # nil          # tier: full
    KwSome          # Some         # tier: full
    KwOk            # Ok           # tier: full
    KwErr           # Err          # tier: full
    KwLoss          # loss         # tier: full
    KwNograd        # nograd       # tier: full

    # Operators - Arithmetic
    Plus            # +
    Minus           # -
    Star            # *
    Slash           # /
    Percent         # %
    StarStar        # **

    # Operators - Comparison
    Eq              # ==
    NotEq           # !=
    Lt              # <
    Gt              # >
    LtEq            # <=
    GtEq            # >=

    # Operators - Assignment
    Assign          # =
    PlusEq          # +=
    MinusEq         # -=
    StarEq          # *=
    SlashEq         # /=
    PercentEq       # %=

    # Operators - Logical (symbols)
    Ampersand       # &
    Pipe            # |
    Caret           # ^
    Tilde           # ~
    AmpAmp          # &&
    PipePipe        # ||

    # Operators - Special
    Question        # ?
    QuestionDot     # ?.
    QuestionQuestion # ??
    DotQuestion     # .?
    Bang            # !
    At              # @
    Hash            # #
    HashLBracket    # #[ (attribute start)
    Dollar          # $
    Backslash       # \
    Transpose       # ' (postfix transpose in m{} only)

    # Pipeline/Composition Operators
    PipeForward     # |>
    Compose         # >>
    ComposeBack     # <<
    Parallel        # //
    LayerConnect    # ~>

    # GPU Kernel Launch Operators
    TripleLess      # <<< (kernel launch start)
    TripleGreater   # >>> (kernel launch end)

    # Delimiters
    LParen          # (
    RParen          # )
    LBrace          # {
    RBrace          # }
    LBracket        # [
    RBracket        # ]

    # Punctuation
    Comma           # ,
    Colon           # :
    ColonColon      # ::
    Semicolon       # ;
    Dot             # .
    DotDot          # ..
    DotDotEq        # ..=
    DotPlus         # .+ (broadcast add)
    DotMinus        # .- (broadcast sub)
    DotStar         # .* (broadcast mul)
    DotSlash        # ./ (broadcast div)
    DotCaret        # .^ (broadcast pow)
    Ellipsis        # ... (axis slicing)
    Arrow           # ->
    FatArrow        # =>
    Underscore      # _

    # Indentation
    Newline         # End of line
    Indent          # Increase in indentation
    Dedent          # Decrease in indentation

    # Special
    Eof             # End of file
    Error           # Lexer error
    ImplicitMul     # Implicit multiplication (m{} only, e.g., 2x, Ax)
    ArraySuffix     # Suffix after ]: ]f32, ]_f32_gpu, ]f32_tr_gpu

    # Block Tokens (for user-definable blocks)
    BlockStart      # Block keyword detected (e.g., "m", "loss", "sh", "sql")
    BlockPayload    # Raw payload text (for Raw mode blocks)
    BlockEnd        # Closing brace of block

    # Literal Tokens (for collection literals)
    SetLitStart     # s{ - set literal prefix
    LiteralStart(text)  # Generic literal prefix (for custom types)

struct Span:
    """Source location span."""
    start: i64      # Start offset
    end: i64        # End offset (exclusive)
    line: i64       # Line number (1-based)
    col: i64        # Column number (1-based)

impl Span:
    static fn new(start: i64, end: i64, line: i64, col: i64) -> Span:
        Span(start: start, end: end, line: line, col: col)

    static fn empty() -> Span:
        Span(start: 0, end: 0, line: 0, col: 0)

    fn len() -> i64:
        self.end - self.start

    fn merge(other: Span) -> Span:
        val new_start = if self.start < other.start: self.start else: other.start
        val new_end = if self.end > other.end: self.end else: other.end
        val new_line = if self.line < other.line: self.line else: other.line
        val new_col = if self.line <= other.line: self.col else: other.col
        Span.new(new_start, new_end, new_line, new_col)

# Manually desugared static methods for bootstrap runtime compatibility
fn Span__new(start: i64, end: i64, line: i64, col: i64) -> Span:
    Span(start: start, end: end, line: line, col: col)

fn Span__empty() -> Span:
    Span(start: 0, end: 0, line: 0, col: 0)

struct Token:
    """A token with its kind, span, and text."""
    kind: TokenKind
    span: Span
    text: text

impl Token:
    static fn new(kind: TokenKind, span: Span, text: text) -> Token:
        Token(kind: kind, span: span, text: text)

    static fn eof(pos: i64, line: i64) -> Token:
        Token(
            kind: TokenKind.Eof,
            span: Span.new(pos, pos, line, 0),
            text: ""
        )

    fn is_keyword() -> bool:
        match self.kind:
            case KwFn | KwVal | KwVar | KwStruct | KwClass | KwEnum | KwTrait
               | KwImpl | KwType | KwMod | KwPub | KwPri | KwStatic | KwMe | KwExtern
               | KwIf | KwElse | KwElif | KwMatch | KwCase | KwFor | KwWhile
               | KwLoop | KwBreak | KwContinue | KwReturn | KwYield | KwAwait
               | KwAsync | KwSpawn | KwActor | KwIn | KwIs | KwAs | KwNot | KwAnd | KwOr | KwXor
               | KwTry | KwCatch | KwThrow | KwWith | KwImport | KwExport | KwFrom
               | KwSelf | KwSuper | KwNone | KwSome | KwOk | KwErr
               | KwLoss | KwNograd | KwKernel | KwShared:
                true
            case _:
                false

    fn is_operator() -> bool:
        match self.kind:
            case Plus | Minus | Star | Slash | Percent | StarStar
               | Eq | NotEq | Lt | Gt | LtEq | GtEq
               | Assign | PlusEq | MinusEq | StarEq | SlashEq | PercentEq
               | Ampersand | Pipe | Caret | Tilde | AmpAmp | PipePipe
               | Question | QuestionDot | QuestionQuestion | DotQuestion
               | Bang | At | Hash | Dollar | Backslash:
                true
            case _:
                false

    fn is_literal() -> bool:
        match self.kind:
            case IntLit | FloatLit | StringLit | RawStringLit | BoolLit | NilLit:
                true
            case _:
                false

# Manually desugared static methods for Token (bootstrap runtime compatibility)
fn Token__new(kind: TokenKind, span: Span, text: text) -> Token:
    Token(kind: kind, span: span, text: text)

fn Token__eof(pos: i64, line: i64) -> Token:
    Token(
        kind: TokenKind.Eof,
        span: Span__new(pos, pos, line, 0),
        text: ""
    )

# ============================================================================
# Lexer
# ============================================================================


# ============================================================================
# Exports
# ============================================================================

export TokenKind, Span, Span__new, Span__empty, Token, Token__new, Token__eof
