# Shared Operators
#
# Binary operation evaluation, truthiness rules, type coercion,
# and numeric cast rules for the Simple language.
#
# Used by:
#   - src/compiler/semantics.spl (re-exports)
#   - src/compiler/95.interp/interpreter/operators.spl (operator dispatch)
#
# Port of rust/compiler/src/semantics/ (binary_ops.rs, cast_rules.rs,
#   truthiness.rs, type_coercion.rs â€” ~600 lines total)


# Auto-generated desugared static method wrappers
fn TypeCoercion__coercion_rank(type_name: text) -> i64:
    """Rank for coercion (higher rank = wider type)."""
    match type_name:
        case "bool": 0
        case "i8": 1
        case "u8": 2
        case "i16": 3
        case "u16": 4
        case "i32": 5
        case "u32": 6
        case "i64": 7
        case "u64": 8
        case "f32": 9
        case "f64": 10
        case _: -1


export eval_int_int, eval_float_float, eval_string_string, int_pow
export TruthinessRules, TypeCoercion, NumericType, numeric_type_rank

# ============================================================================
# Binary Operations
# ============================================================================

fn eval_int_int(op: text, lhs: i64, rhs: i64) -> Result<Any, text>:
    """Evaluate binary operation on two integers."""
    match op:
        case "+": Ok(lhs + rhs)
        case "-": Ok(lhs - rhs)
        case "*": Ok(lhs * rhs)
        case "/":
            if rhs == 0: Err("division by zero")
            else: Ok(lhs / rhs)
        case "%":
            if rhs == 0: Err("modulo by zero")
            else: Ok(lhs % rhs)
        case "**": Ok(int_pow(lhs, rhs))
        case "==": Ok(lhs == rhs)
        case "!=": Ok(lhs != rhs)
        case "<": Ok(lhs < rhs)
        case "<=": Ok(lhs <= rhs)
        case ">": Ok(lhs > rhs)
        case ">=": Ok(lhs >= rhs)
        case "<<": Ok(lhs << rhs)
        case ">>": Ok(lhs >> rhs)
        case _: Err("unknown integer operator '{op}'")

fn eval_float_float(op: text, lhs: f64, rhs: f64) -> Result<Any, text>:
    match op:
        case "+": Ok(lhs + rhs)
        case "-": Ok(lhs - rhs)
        case "*": Ok(lhs * rhs)
        case "/":
            if rhs == 0.0: Err("division by zero")
            else: Ok(lhs / rhs)
        case "==": Ok(lhs == rhs)
        case "!=": Ok(lhs != rhs)
        case "<": Ok(lhs < rhs)
        case "<=": Ok(lhs <= rhs)
        case ">": Ok(lhs > rhs)
        case ">=": Ok(lhs >= rhs)
        case _: Err("unknown float operator '{op}'")

fn eval_string_string(op: text, lhs: text, rhs: text) -> Result<Any, text>:
    match op:
        case "+": Ok(lhs + rhs)
        case "==": Ok(lhs == rhs)
        case "!=": Ok(lhs != rhs)
        case "<": Ok(lhs < rhs)
        case "<=": Ok(lhs <= rhs)
        case ">": Ok(lhs > rhs)
        case ">=": Ok(lhs >= rhs)
        case _: Err("unknown string operator '{op}'")

fn int_pow(base: i64, exp: i64) -> i64:
    if exp < 0: return 0
    if exp == 0: return 1
    var result = 1
    var b = base
    var e = exp
    while e > 0:
        if e % 2 == 1:
            result = result * b
        b = b * b
        e = e / 2
    result

# ============================================================================
# Numeric Types
# ============================================================================

enum NumericType:
    I8
    I16
    I32
    I64
    U8
    U16
    U32
    U64
    F32
    F64

fn numeric_type_rank(ty: NumericType) -> i64:
    """Rank for numeric type promotion (higher wins)."""
    match ty:
        case I8: 1
        case U8: 2
        case I16: 3
        case U16: 4
        case I32: 5
        case U32: 6
        case I64: 7
        case U64: 8
        case F32: 9
        case F64: 10

# ============================================================================
# Truthiness Rules
# ============================================================================

struct TruthinessRules:
    """Defines which values are truthy/falsy in Simple."""

impl TruthinessRules:
    static fn is_truthy_bool(v: bool) -> bool:
        v

    static fn is_truthy_int(v: i64) -> bool:
        v != 0

    static fn is_truthy_float(v: f64) -> bool:
        v != 0.0

    static fn is_truthy_string(v: text) -> bool:
        v.?     # non-empty = truthy

    static fn is_always_truthy_type(type_name: text) -> bool:
        """Types that are always truthy (non-nullable value types)."""
        match type_name:
            case "struct": true
            case "class": true
            case "enum": true
            case _: false

# ============================================================================
# Type Coercion
# ============================================================================

struct TypeCoercion:
    """Rules for implicit type conversion."""

impl TypeCoercion:
    static fn coercion_rank(type_name: text) -> i64:
        """Rank for coercion (higher rank = wider type)."""
        match type_name:
            case "bool": 0
            case "i8": 1
            case "u8": 2
            case "i16": 3
            case "u16": 4
            case "i32": 5
            case "u32": 6
            case "i64": 7
            case "u64": 8
            case "f32": 9
            case "f64": 10
            case _: -1

    static fn can_coerce(from_type: text, to_type: text) -> bool:
        """Check if implicit coercion is allowed."""
        val from_rank = TypeCoercion__coercion_rank(from_type)
        val to_rank = TypeCoercion__coercion_rank(to_type)
        if from_rank < 0 or to_rank < 0: false
        else: from_rank <= to_rank

    static fn common_numeric_type(a: text, b: text) -> text:
        """Find the common type for binary operations."""
        val rank_a = TypeCoercion__coercion_rank(a)
        val rank_b = TypeCoercion__coercion_rank(b)
        if rank_a >= rank_b: a else: b
