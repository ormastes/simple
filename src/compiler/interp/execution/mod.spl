# Execution Manager - Unified JIT Execution Interface
#
# Provides a Simple-side interface to the Rust ExecutionManager trait.
# Supports Cranelift and LLVM JIT backends through SFFI wrappers.
#
# Usage:
#   val em = LocalExecutionManager__auto_select()
#   val info = em.compile(mir_module)
#   val result = em.execute("main", [])
#   em.cleanup()

# Interpreter-mode fix: declare extern fns directly (not available via app.io.mod)
extern fn rt_exec_manager_create(backend: text) -> i64
extern fn rt_exec_manager_compile(handle: i64, data: text) -> text
extern fn rt_exec_manager_execute(handle: i64, name: text, args: [i64]) -> i64
extern fn rt_exec_manager_has_function(handle: i64, name: text) -> bool
extern fn rt_exec_manager_backend_name(handle: i64) -> text
extern fn rt_exec_manager_cleanup(handle: i64) -> i64
extern fn rt_set_jit_backend(backend: text)
extern fn rt_get_jit_backend() -> text

# ============================================================================
# ExecutionManager Trait
# ============================================================================

trait ExecutionManager:
    """Unified interface for JIT execution backends."""
    fn compile(mir_data: text) -> text:
        pass
    fn execute(name: text, args: [i64]) -> text:
        pass
    fn has_function(name: text) -> bool:
        pass
    fn backend_name() -> text:
        pass
    fn cleanup():
        pass

# ============================================================================
# CodeInfo - Result of compilation
# ============================================================================

struct CodeInfo:
    """Information about a compiled module."""
    name: text
    entry_point: text
    symbol_names: [text]

# ============================================================================
# LocalExecutionManager - SFFI-backed JIT execution
# ============================================================================

class LocalExecutionManager:
    """Local JIT execution manager backed by Rust ExecutionManager.

    Wraps the Rust-side LocalExecutionManager via SFFI handle.
    Supports Cranelift and LLVM JIT backends.
    """
    handle: i64

    static fn cranelift() -> LocalExecutionManager:
        """Create with Cranelift JIT backend."""
        val h = rt_exec_manager_create("cranelift")
        LocalExecutionManager(handle: h)

    static fn llvm() -> LocalExecutionManager:
        """Create with LLVM JIT backend."""
        val h = rt_exec_manager_create("llvm")
        LocalExecutionManager(handle: h)

    static fn auto_select() -> LocalExecutionManager:
        """Create with auto-selected JIT backend."""
        val h = rt_exec_manager_create("auto")
        LocalExecutionManager(handle: h)

    fn compile(mir_data: text) -> text:
        """Compile MIR data. Returns Ok("") on success, Err(message) on failure."""
        val result = rt_exec_manager_compile(self.handle, mir_data)
        if result == "":
            Ok("")
        else:
            Err(result)

    fn execute(name: text, args: [i64]) -> text:
        """Execute a compiled function by name."""
        val result = rt_exec_manager_execute(self.handle, name, args)
        Ok(result)

    fn has_function(name: text) -> bool:
        """Check if a function is available."""
        rt_exec_manager_has_function(self.handle, name)

    fn backend_name() -> text:
        """Get the name of the underlying JIT backend."""
        rt_exec_manager_backend_name(self.handle)

    fn cleanup():
        """Release all compiled code and free resources."""
        rt_exec_manager_cleanup(self.handle)

# ============================================================================
# Global JIT Backend Control
# ============================================================================

fn set_jit_backend(backend: text) -> bool:
    """Set the global JIT backend preference: 'auto', 'cranelift', or 'llvm'."""
    rt_set_jit_backend(backend)

fn get_jit_backend() -> text:
    """Get the current global JIT backend name."""
    rt_get_jit_backend()

# ============================================================================
# Exports
# ============================================================================


# Desugared static methods for bootstrap interpreter compatibility

fn LocalExecutionManager__cranelift() -> LocalExecutionManager:
    """Create with Cranelift JIT backend."""
    val h = rt_exec_manager_create("cranelift")
    LocalExecutionManager(handle: h)



fn LocalExecutionManager__llvm() -> LocalExecutionManager:
    """Create with LLVM JIT backend."""
    val h = rt_exec_manager_create("llvm")
    LocalExecutionManager(handle: h)



fn LocalExecutionManager__auto_select() -> LocalExecutionManager:
        """Create with auto-selected JIT backend."""
        val h = rt_exec_manager_create("auto")
        LocalExecutionManager(handle: h)

    fn compile(mir_data: text) -> text:
        """Compile MIR data. Returns Ok("") on success, Err(message) on failure."""
        val result = rt_exec_manager_compile(self.handle, mir_data)
        if result == "":
            Ok("")
        else:
            Err(result)

    fn execute(name: text, args: [i64]) -> text:
        """Execute a compiled function by name."""
        val result = rt_exec_manager_execute(self.handle, name, args)
        Ok(result)

    fn has_function(name: text) -> bool:
        """Check if a function is available."""
        rt_exec_manager_has_function(self.handle, name)

    fn backend_name() -> text:
        """Get the name of the underlying JIT backend."""
        rt_exec_manager_backend_name(self.handle)

    fn cleanup():
        """Release all compiled code and free resources."""
        rt_exec_manager_cleanup(self.handle)


export ExecutionManager, CodeInfo, LocalExecutionManager
export set_jit_backend, get_jit_backend
