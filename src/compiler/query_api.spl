# Compiler Query API for IDE Integration
#
# This API provides query capabilities for Language Server Protocol (LSP)
# and other IDE tooling. It allows on-demand querying of compiler state,
# symbol information, type inference results, and diagnostics.
#
# Design Philosophy:
# - Incremental: Parse only what's needed
# - Fast: Cache results, avoid redundant computation
# - Resilient: Work with partial/broken code
# - Thread-safe: Multiple queries can run concurrently

import compiler.parser.parse_util
import compiler.type_system.checker
import compiler.inference.infer
import compiler.dependency.symbol
import app.io  # For FFI functions

# --- Core Types ---

# Position in a source file
struct Position:
    line: i64    # 0-based line number
    column: i64  # 0-based column (UTF-8 byte offset)

# Location in source code
struct Location:
    file: text
    start: Position
    end: Position

# Source range
struct Range:
    start: Position
    end: Position

# Symbol information
enum SymbolKind:
    Variable
    Function
    Method
    Class
    Struct
    Enum
    Trait
    Module
    Parameter
    Field
    EnumVariant

struct Symbol:
    name: text
    kind: SymbolKind
    location: Location
    type_info: Option<text>  # Human-readable type
    doc_comment: Option<text>
    is_public: bool
    is_mutable: bool

# Completion item
enum CompletionKind:
    Variable
    Function
    Method
    Keyword
    Module
    Type
    Field
    EnumVariant

struct Completion:
    label: text
    kind: CompletionKind
    detail: Option<text>  # Type signature or description
    documentation: Option<text>
    insert_text: text
    sort_priority: i64  # Lower = higher priority

# Diagnostic severity
enum DiagnosticSeverity:
    Error
    Warning
    Info
    Hint

# Diagnostic information
struct Diagnostic:
    range: Range
    severity: DiagnosticSeverity
    message: text
    code: Option<text>  # Error code like "E0001"
    source: text        # "simple-parser", "simple-type-checker", etc.

# Hover information
struct HoverInfo:
    range: Range
    contents: text  # Markdown-formatted content
    type_info: Option<text>

# Definition/reference result
struct DefinitionResult:
    locations: [Location]
    symbol: Option<Symbol>

# --- Compiler Query Context ---

# Main query context - maintains cached state for a project
class CompilerQueryContext:
    # Cached parse trees (file path -> AST)
    cached_asts: Dict<text, AST>

    # Cached symbol tables (file path -> symbol table)
    cached_symbols: Dict<text, SymbolTable>

    # Cached type inference results (file path -> type map)
    cached_types: Dict<text, TypeMap>

    # Cached diagnostics (file path -> diagnostics)
    cached_diagnostics: Dict<text, [Diagnostic]>

    # File modification times for cache invalidation
    file_mtimes: Dict<text, i64>

    # Project root directory
    project_root: text

    # Whether to enable incremental parsing
    incremental: bool

    # Initialize context for a project
    static fn create(project_root: text) -> CompilerQueryContext:
        CompilerQueryContext(
            cached_asts: {},
            cached_symbols: {},
            cached_types: {},
            cached_diagnostics: {},
            file_mtimes: {},
            project_root: project_root,
            incremental: true,
        )

    # --- Cache Management ---

    # Invalidate cache for a file (called when file changes)
    me invalidate_file(file_path: text):
        self.cached_asts.remove(file_path)
        self.cached_symbols.remove(file_path)
        self.cached_types.remove(file_path)
        self.cached_diagnostics.remove(file_path)
        self.file_mtimes.remove(file_path)

    # Check if cache is valid for a file
    fn is_cache_valid(file_path: text) -> bool:
        if not self.file_mtimes.contains(file_path):
            return false

        val cached_mtime = self.file_mtimes[file_path]
        val current_mtime = get_file_mtime(file_path)

        cached_mtime == current_mtime

    # --- Parsing ---

    # Parse a file and cache the result
    me parse_file(file_path: text) -> Result<AST, ParseError>:
        # Check cache
        if self.is_cache_valid(file_path) and self.cached_asts.contains(file_path):
            return Ok(self.cached_asts[file_path])

        # Parse file
        val source = file_read(file_path)
        val result = parse_source(source, file_path)

        # Update cache
        if result.ok.?:
            self.cached_asts[file_path] = result.unwrap()
            self.file_mtimes[file_path] = get_file_mtime(file_path)

        result

    # Parse source text (not from file)
    fn parse_source_text(source: text, file_path: text) -> Result<AST, ParseError>:
        parse_source(source, file_path)

    # --- Symbol Resolution ---

    # Get symbol table for a file
    me get_symbol_table(file_path: text) -> Result<SymbolTable, Error>:
        # Check cache
        if self.is_cache_valid(file_path) and self.cached_symbols.contains(file_path):
            return Ok(self.cached_symbols[file_path])

        # Parse first
        val ast_result = self.parse_file(file_path)
        if ast_result.err.?:
            return Err(Error("Failed to parse file"))

        val ast = ast_result.unwrap()

        # Build symbol table
        val symbol_table = build_symbol_table(ast)

        # Cache result
        self.cached_symbols[file_path] = symbol_table

        Ok(symbol_table)

    # Find symbol at a specific position
    fn symbol_at(file_path: text, pos: Position) -> Option<Symbol>:
        val symbol_table_result = self.get_symbol_table(file_path)
        if symbol_table_result.err.?:
            return None

        val symbol_table = symbol_table_result.unwrap()
        find_symbol_at_position(symbol_table, pos)

    # Find all references to a symbol
    fn find_references(file_path: text, symbol: Symbol) -> [Location]:
        # TODO: Implement multi-file reference search
        # For now, just search in the same file
        val symbol_table_result = self.get_symbol_table(file_path)
        if symbol_table_result.err.?:
            return []

        val symbol_table = symbol_table_result.unwrap()
        find_symbol_references(symbol_table, symbol.name)

    # Find definition of symbol at position
    fn find_definition(file_path: text, pos: Position) -> Option<DefinitionResult>:
        val symbol_opt = self.symbol_at(file_path, pos)
        if not symbol_opt.?:
            return None

        val symbol = symbol_opt.unwrap()

        # Return the definition location
        Some(DefinitionResult(
            locations: [symbol.location],
            symbol: Some(symbol),
        ))

    # --- Type Information ---

    # Get type information at a position
    fn type_at(file_path: text, pos: Position) -> Option<text>:
        # Check symbol first
        val symbol_opt = self.symbol_at(file_path, pos)
        if symbol_opt.?:
            return symbol_opt.unwrap().type_info

        # TODO: Implement expression type inference for arbitrary positions
        None

    # --- Completions ---

    # Get completions at a position
    fn completions_at(file_path: text, pos: Position) -> [Completion]:
        # Get symbol table for context
        val symbol_table_result = self.get_symbol_table(file_path)
        if symbol_table_result.err.?:
            return []

        val symbol_table = symbol_table_result.unwrap()

        # Get scope at position
        val scope = get_scope_at_position(symbol_table, pos)

        # Build completions from:
        # 1. Variables/functions in scope
        # 2. Keywords
        # 3. Imported modules
        # 4. Struct/enum members (if in member access context)

        val completions = []

        # Add visible symbols
        for sym in scope.visible_symbols:
            completions.push(symbol_to_completion(sym))

        # Add keywords
        for kw in get_context_keywords(pos, scope):
            completions.push(Completion(
                label: kw,
                kind: CompletionKind.Keyword,
                detail: None,
                documentation: None,
                insert_text: kw,
                sort_priority: 10,
            ))

        completions

    # --- Hover Information ---

    # Get hover information at a position
    fn hover_at(file_path: text, pos: Position) -> Option<HoverInfo>:
        val symbol_opt = self.symbol_at(file_path, pos)
        if not symbol_opt.?:
            return None

        val symbol = symbol_opt.unwrap()

        # Build markdown content
        var content = "```simple\n"
        content = content + symbol.name

        if symbol.type_info.?:
            content = content + ": " + symbol.type_info.unwrap()

        content = content + "\n```\n"

        if symbol.doc_comment.?:
            content = content + "\n" + symbol.doc_comment.unwrap()

        Some(HoverInfo(
            range: position_to_range(pos),
            contents: content,
            type_info: symbol.type_info,
        ))

    # --- Diagnostics ---

    # Get diagnostics for a file
    me get_diagnostics(file_path: text) -> [Diagnostic]:
        # Check cache
        if self.is_cache_valid(file_path) and self.cached_diagnostics.contains(file_path):
            return self.cached_diagnostics[file_path]

        var diagnostics = []

        # Parse and collect parse errors
        val ast_result = self.parse_file(file_path)
        if ast_result.err.?:
            val parse_error = ast_result.err.unwrap()
            diagnostics.push(parse_error_to_diagnostic(parse_error))

        # Type check and collect type errors
        if ast_result.ok.?:
            val ast = ast_result.unwrap()
            val type_errors = type_check_ast(ast)
            for err in type_errors:
                diagnostics.push(type_error_to_diagnostic(err))

        # Cache result
        self.cached_diagnostics[file_path] = diagnostics

        diagnostics

    # --- Document Symbols ---

    # Get all symbols in a document (for outline view)
    fn document_symbols(file_path: text) -> [Symbol]:
        val symbol_table_result = self.get_symbol_table(file_path)
        if symbol_table_result.err.?:
            return []

        val symbol_table = symbol_table_result.unwrap()
        extract_all_symbols(symbol_table)

    # --- Workspace Symbols ---

    # Search for symbols across the workspace
    fn workspace_symbols(query: text) -> [Symbol]:
        # TODO: Implement workspace-wide symbol search
        # This requires indexing all files in the project
        []

# --- Helper Functions ---

# Convert position to single-point range
fn position_to_range(pos: Position) -> Range:
    Range(start: pos, end: pos)

# Convert parse error to diagnostic
fn parse_error_to_diagnostic(error: ParseError) -> Diagnostic:
    Diagnostic(
        range: Range(
            start: Position(line: error.line, column: error.column),
            end: Position(line: error.line, column: error.column + 1),
        ),
        severity: DiagnosticSeverity.Error,
        message: error.message,
        code: Some("E001"),
        source: "simple-parser",
    )

# Convert type error to diagnostic
fn type_error_to_diagnostic(error: TypeError) -> Diagnostic:
    Diagnostic(
        range: Range(
            start: Position(line: error.line, column: error.column),
            end: Position(line: error.line, column: error.column + error.length),
        ),
        severity: DiagnosticSeverity.Error,
        message: error.message,
        code: Some(error.code),
        source: "simple-type-checker",
    )

# Convert symbol to completion item
fn symbol_to_completion(symbol: Symbol) -> Completion:
    val kind = match symbol.kind:
        SymbolKind.Variable: CompletionKind.Variable
        SymbolKind.Function: CompletionKind.Function
        SymbolKind.Method: CompletionKind.Method
        SymbolKind.Class, SymbolKind.Struct, SymbolKind.Enum, SymbolKind.Trait:
            CompletionKind.Type
        SymbolKind.Field: CompletionKind.Field
        SymbolKind.EnumVariant: CompletionKind.EnumVariant
        _: CompletionKind.Variable

    Completion(
        label: symbol.name,
        kind: kind,
        detail: symbol.type_info,
        documentation: symbol.doc_comment,
        insert_text: symbol.name,
        sort_priority: 5,
    )

# --- FFI Functions (imported from app.io) ---

# These functions are implemented in rust/compiler/src/query_ffi.rs
# and exposed through app.io module

fn get_file_mtime(path: text) -> i64:
    io.rt_get_file_mtime(path)

fn parse_source(source: text, file_path: text) -> Result<AST, ParseError>:
    io.rt_parse_source(source, file_path)

fn build_symbol_table(ast: AST) -> SymbolTable:
    io.rt_build_symbol_table(ast)

fn find_symbol_at_position(table: SymbolTable, pos: Position) -> Option<Symbol>:
    io.rt_find_symbol_at_position(table, pos)

fn find_symbol_references(table: SymbolTable, name: text) -> [Location]:
    io.rt_find_symbol_references(table, name)

fn get_scope_at_position(table: SymbolTable, pos: Position) -> Scope:
    io.rt_get_scope_at_position(table, pos)

fn get_context_keywords(pos: Position, scope: Scope) -> [text]:
    io.rt_get_context_keywords(pos, scope)

fn type_check_ast(ast: AST) -> [TypeError]:
    io.rt_type_check_ast(ast)

fn extract_all_symbols(table: SymbolTable) -> [Symbol]:
    io.rt_extract_all_symbols(table)

# --- Placeholder Types (to be defined properly) ---

# TODO: Import from actual compiler modules
struct AST:
    nodes: [Node]

struct ParseError:
    line: i64
    column: i64
    message: text

struct SymbolTable:
    symbols: Dict<text, Symbol>

struct TypeError:
    line: i64
    column: i64
    length: i64
    message: text
    code: text

struct Scope:
    visible_symbols: [Symbol]

struct TypeMap:
    types: Dict<text, text>

struct Node:
    # AST node placeholder
    data: text
