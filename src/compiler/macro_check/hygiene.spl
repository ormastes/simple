# Macro Hygiene
#
# Implements hygienic macro expansion to prevent accidental name capture.
# Based on "Macros That Work Together" (Flatt et al., 2012).
#
# Key concepts:
# - Syntax Mark: Unique identifier added during expansion
# - Scope: Binding context where names are introduced
# - Rename: Resolution of marked identifiers
#
# Example of hygiene problem:
#   macro_rules! define_x {
#       () => { let x = 1; x }
#   }
#   let x = 0;
#   define_x!()  // Should NOT capture outer x

# ============================================================================
# Syntax Mark
# ============================================================================

struct SyntaxMark:
    """Unique mark added during macro expansion.

    Each macro expansion adds a unique mark to identifiers in its body.
    This prevents accidental capture of names from the expansion context.
    """
    id: i64
    expansion_id: i64  # Which expansion created this mark

impl SyntaxMark:
    static fn create(expansion_id: i64) -> SyntaxMark:
        # Use expansion_id as mark id (simple scheme)
        SyntaxMark(id: expansion_id, expansion_id: expansion_id)

    fn to_text() -> text:
        "mark_{self.id}"

# ============================================================================
# Marked Identifier
# ============================================================================

struct MarkedIdent:
    """Identifier with hygiene marks.

    Each identifier carries a list of marks from expansions it passed through.
    Two identifiers are equal only if they have the same name AND marks.
    """
    name: text
    marks: [SyntaxMark]

impl MarkedIdent:
    static fn from_name(name: text) -> MarkedIdent:
        """Create unmarked identifier."""
        MarkedIdent(name: name, marks: [])

    me add_mark(mark: SyntaxMark) -> MarkedIdent:
        """Add a mark during expansion."""
        MarkedIdent(name: self.name, marks: self.marks.push(mark))

    me remove_mark(mark: SyntaxMark) -> MarkedIdent:
        """Remove a mark (for unhygienic escapes)."""
        var new_marks: [SyntaxMark] = []
        for m in self.marks:
            if m.id != mark.id:
                new_marks = new_marks.push(m)
        MarkedIdent(name: self.name, marks: new_marks)

    fn equals(other: MarkedIdent) -> bool:
        """Check hygiene-aware equality."""
        if self.name != other.name:
            return false
        if self.marks.len() != other.marks.len():
            return false
        var i = 0
        while i < self.marks.len():
            if self.marks[i].id != other.marks[i].id:
                return false
            i = i + 1
        true

    fn to_text() -> text:
        if self.marks.is_empty():
            self.name
        else:
            var mark_str = ""
            for m in self.marks:
                mark_str = "{mark_str}#{m.id}"
            "{self.name}{mark_str}"

# ============================================================================
# Hygiene Scope
# ============================================================================

enum ScopeKind:
    """Kind of binding scope."""
    Module          # Top-level module scope
    Function        # Function parameter scope
    Block           # Local block scope
    MacroExpansion  # Macro expansion scope
    Pattern         # Pattern binding scope

struct HygieneScope:
    """Binding scope with hygiene information.

    Tracks which names are bound in this scope and their marks.
    """
    id: i64
    kind: ScopeKind
    parent: i64?           # Parent scope id (nil for root)
    bindings: Dict<text, MarkedIdent>  # Name -> marked binding
    expansion_mark: SyntaxMark?  # Mark if this is a macro expansion scope

impl HygieneScope:
    static fn root() -> HygieneScope:
        """Create root module scope."""
        HygieneScope(
            id: 0,
            kind: ScopeKind.Module,
            parent: nil,
            bindings: {},
            expansion_mark: nil
        )

    static fn child(parent_id: i64, kind: ScopeKind, scope_id: i64) -> HygieneScope:
        """Create child scope."""
        HygieneScope(
            id: scope_id,
            kind: kind,
            parent: Some(parent_id),
            bindings: {},
            expansion_mark: nil
        )

    static fn expansion(parent_id: i64, mark: SyntaxMark, scope_id: i64) -> HygieneScope:
        """Create macro expansion scope with mark."""
        HygieneScope(
            id: scope_id,
            kind: ScopeKind.MacroExpansion,
            parent: Some(parent_id),
            bindings: {},
            expansion_mark: Some(mark)
        )

    me bind(name: text, ident: MarkedIdent):
        """Bind a name in this scope."""
        self.bindings[name] = ident

    fn lookup(name: text) -> MarkedIdent?:
        """Look up a binding in this scope only."""
        self.bindings.get(name)

# ============================================================================
# Hygiene Context
# ============================================================================

class HygieneContext:
    """Context for hygienic macro expansion.

    Manages scopes and marks during macro processing.
    """
    scopes: Dict<i64, HygieneScope>
    current_scope: i64
    next_scope_id: i64
    next_expansion_id: i64
    errors: [text]

    static fn create() -> HygieneContext:
        """Create new hygiene context with root scope."""
        var scopes: Dict<i64, HygieneScope> = {}
        scopes[0] = HygieneScope.root()

        HygieneContext(
            scopes: scopes,
            current_scope: 0,
            next_scope_id: 1,
            next_expansion_id: 1,
            errors: []
        )

    me enter_scope(kind: ScopeKind):
        """Enter a new scope."""
        val scope_id = self.next_scope_id
        self.next_scope_id = self.next_scope_id + 1

        val scope = HygieneScope.child(self.current_scope, kind, scope_id)
        self.scopes[scope_id] = scope
        self.current_scope = scope_id

    me exit_scope():
        """Exit current scope."""
        match self.scopes.get(self.current_scope):
            case Some(scope):
                match scope.parent:
                    case Some(parent_id):
                        self.current_scope = parent_id
                    case nil:
                        self.errors = self.errors.push("Cannot exit root scope")
            case nil:
                self.errors = self.errors.push("Invalid current scope")

    me enter_expansion() -> SyntaxMark:
        """Enter a macro expansion, creating a new mark."""
        val expansion_id = self.next_expansion_id
        self.next_expansion_id = self.next_expansion_id + 1

        val mark = SyntaxMark.create(expansion_id)
        val scope_id = self.next_scope_id
        self.next_scope_id = self.next_scope_id + 1

        val scope = HygieneScope.expansion(self.current_scope, mark, scope_id)
        self.scopes[scope_id] = scope
        self.current_scope = scope_id

        mark

    me bind_name(name: text, ident: MarkedIdent):
        """Bind a name in current scope."""
        match self.scopes.get(self.current_scope):
            case Some(scope):
                scope.bind(name, ident)
                self.scopes[self.current_scope] = scope
            case nil:
                self.errors = self.errors.push("Invalid current scope for binding")

    fn resolve(ident: MarkedIdent) -> MarkedIdent?:
        """Resolve an identifier through scope chain.

        Returns the binding that matches the identifier's marks.
        """
        var scope_id = self.current_scope

        while true:
            match self.scopes.get(scope_id):
                case Some(scope):
                    # Check for binding in this scope
                    match scope.lookup(ident.name):
                        case Some(bound):
                            # Check marks match for hygiene
                            if self.marks_compatible(ident, bound, scope):
                                return Some(bound)
                        case nil:
                            pass

                    # Move to parent scope
                    match scope.parent:
                        case Some(parent_id):
                            scope_id = parent_id
                        case nil:
                            return nil  # Not found in any scope
                case nil:
                    return nil  # Invalid scope chain

    fn marks_compatible(use_ident: MarkedIdent, def_ident: MarkedIdent, scope: HygieneScope) -> bool:
        """Check if marks are compatible for resolution.

        An identifier can reference a binding if:
        1. Both have the same marks (hygienic)
        2. The definition has no marks and use has expansion marks (escape)
        """
        # Same marks = hygienic reference
        if use_ident.marks.len() == def_ident.marks.len():
            var i = 0
            var all_match = true
            while i < use_ident.marks.len():
                if use_ident.marks[i].id != def_ident.marks[i].id:
                    all_match = false
                    break
                i = i + 1
            if all_match:
                return true

        # Definition in outer scope with no marks = intentional capture
        if def_ident.marks.is_empty():
            return true

        false

    fn check_shadowing(name: text) -> text?:
        """Check if binding would shadow an existing binding.

        Returns error message if shadowing detected.
        """
        var scope_id = self.current_scope

        while true:
            match self.scopes.get(scope_id):
                case Some(scope):
                    match scope.lookup(name):
                        case Some(existing):
                            # Check if same expansion scope
                            if scope.expansion_mark.?:
                                return Some("Macro binding '{name}' shadows existing binding")
                        case nil:
                            pass

                    match scope.parent:
                        case Some(parent_id):
                            scope_id = parent_id
                        case nil:
                            return nil  # No shadowing
                case nil:
                    return nil

# ============================================================================
# Hygiene Transformer
# ============================================================================

class HygieneTransformer:
    """Transforms AST with hygiene marks during macro expansion."""
    context: HygieneContext
    current_mark: SyntaxMark?

    static fn create() -> HygieneTransformer:
        HygieneTransformer(
            context: HygieneContext.create(),
            current_mark: nil
        )

    me start_expansion() -> SyntaxMark:
        """Begin a macro expansion."""
        val mark = self.context.enter_expansion()
        self.current_mark = Some(mark)
        mark

    me end_expansion():
        """End a macro expansion."""
        self.context.exit_scope()
        self.current_mark = nil

    me mark_identifier(name: text) -> MarkedIdent:
        """Mark an identifier with current expansion mark."""
        var ident = MarkedIdent.from_name(name)
        if self.current_mark.?:
            ident = ident.add_mark(self.current_mark.unwrap())
        ident

    me bind(name: text):
        """Bind a name in current scope."""
        val ident = self.mark_identifier(name)
        self.context.bind_name(name, ident)

    fn resolve(name: text) -> MarkedIdent?:
        """Resolve an identifier."""
        val ident = MarkedIdent.from_name(name)
        self.context.resolve(ident)

    fn check_hygiene_violation(name: text) -> text?:
        """Check for hygiene violations."""
        self.context.check_shadowing(name)

# ============================================================================
# Exports
# ============================================================================

export SyntaxMark, MarkedIdent
export ScopeKind, HygieneScope
export HygieneContext, HygieneTransformer
