# Macro Template Validation
#
# Validates macro templates for correctness:
# - Parameter usage checking
# - Type consistency in template patterns
# - Repetition validation
# - Well-formedness rules
#
# Based on Rust's macro_rules validation.

# ============================================================================
# Template Fragment Kind
# ============================================================================

enum FragmentKind:
    """Kind of macro template fragment.

    Different fragment kinds have different parsing/expansion rules.
    """
    Ident       # Identifier: $name:ident
    Expr        # Expression: $e:expr
    Ty          # Type: $t:ty
    Pat         # Pattern: $p:pat
    Stmt        # Statement: $s:stmt
    Block       # Block: $b:block
    Item        # Item: $i:item
    Meta        # Meta/attribute: $m:meta
    Tt          # Token tree: $t:tt
    Literal     # Literal: $l:literal
    Path        # Path: $p:path
    Lifetime    # Lifetime: $lt:lifetime
    Vis         # Visibility: $v:vis

impl FragmentKind:
    fn to_text() -> text:
        match self:
            case Ident: "ident"
            case Expr: "expr"
            case Ty: "ty"
            case Pat: "pat"
            case Stmt: "stmt"
            case Block: "block"
            case Item: "item"
            case Meta: "meta"
            case Tt: "tt"
            case Literal: "literal"
            case Path: "path"
            case Lifetime: "lifetime"
            case Vis: "vis"

    static fn from_text(s: text) -> FragmentKind?:
        match s:
            case "ident": Some(FragmentKind.Ident)
            case "expr": Some(FragmentKind.Expr)
            case "ty": Some(FragmentKind.Ty)
            case "pat": Some(FragmentKind.Pat)
            case "stmt": Some(FragmentKind.Stmt)
            case "block": Some(FragmentKind.Block)
            case "item": Some(FragmentKind.Item)
            case "meta": Some(FragmentKind.Meta)
            case "tt": Some(FragmentKind.Tt)
            case "literal": Some(FragmentKind.Literal)
            case "path": Some(FragmentKind.Path)
            case "lifetime": Some(FragmentKind.Lifetime)
            case "vis": Some(FragmentKind.Vis)
            case _: nil

    fn can_follow(prev: FragmentKind?) -> bool:
        """Check if this fragment can follow the previous one.

        Based on Rust's follow-set rules to ensure unambiguous parsing.
        """
        match prev:
            case nil:
                # First position - anything can start
                true
            case Some(prev_kind):
                match prev_kind:
                    case Expr | Stmt:
                        # After expr/stmt: only separators allowed
                        match self:
                            case Ident | Tt: true
                            case _: false
                    case Pat:
                        # After pat: => | if | = | , | ; allowed
                        true
                    case Ty | Path:
                        # After ty/path: various things
                        true
                    case _:
                        true

# ============================================================================
# Template Token
# ============================================================================

enum TemplateToken:
    """Token in a macro template."""
    # Literal tokens that must match exactly
    Literal(text: text)
    Punct(char: text)
    Keyword(kw: text)

    # Parameter capture
    Param(name: text, kind: FragmentKind)

    # Repetition
    Repetition(tokens: [TemplateToken], sep: text?, kind: RepetitionKind)

    # Grouping
    Group(delim: text, tokens: [TemplateToken])

impl TemplateToken:
    fn to_text() -> text:
        match self:
            case Literal(t): t
            case Punct(c): c
            case Keyword(kw): kw
            case Param(name, kind): "${name}:{kind.to_text()}"
            case Repetition(_, sep, kind):
                val sep_str = sep ?? ""
                "$( ... ){sep_str}{kind.to_text()}"
            case Group(delim, _):
                match delim:
                    case "(": "( ... )"
                    case "[": "[ ... ]"
                    case "{": "{ ... }"
                    case _: delim

enum RepetitionKind:
    """Kind of repetition in macro template."""
    ZeroOrMore   # $(...)*
    OneOrMore    # $(...)+
    ZeroOrOne    # $(...)?

impl RepetitionKind:
    fn to_text() -> text:
        match self:
            case ZeroOrMore: "*"
            case OneOrMore: "+"
            case ZeroOrOne: "?"

# ============================================================================
# Template Parameter
# ============================================================================

struct TemplateParam:
    """Parameter in a macro template."""
    name: text
    kind: FragmentKind
    repetition_depth: i64  # 0 = not in repetition, 1+ = nested depth

impl TemplateParam:
    static fn simple(name: text, kind: FragmentKind) -> TemplateParam:
        TemplateParam(name: name, kind: kind, repetition_depth: 0)

    static fn repeated(name: text, kind: FragmentKind, depth: i64) -> TemplateParam:
        TemplateParam(name: name, kind: kind, repetition_depth: depth)

# ============================================================================
# Template Validator
# ============================================================================

struct TemplateError:
    """Error in macro template."""
    message: text
    span: i64?  # Token position if available

impl TemplateError:
    static fn create(message: text) -> TemplateError:
        TemplateError(message: message, span: nil)

    static fn at(message: text, pos: i64) -> TemplateError:
        TemplateError(message: message, span: Some(pos))

class TemplateValidator:
    """Validates macro templates for correctness."""
    params: Dict<text, TemplateParam>
    errors: [TemplateError]
    current_rep_depth: i64

    static fn create() -> TemplateValidator:
        TemplateValidator(
            params: {},
            errors: [],
            current_rep_depth: 0
        )

    me validate_matcher(tokens: [TemplateToken]) -> bool:
        """Validate a macro matcher (left-hand side).

        Collects parameter declarations and checks well-formedness.
        """
        self.validate_tokens(tokens, true)

    me validate_transcriber(tokens: [TemplateToken]) -> bool:
        """Validate a macro transcriber (right-hand side).

        Checks that all parameter uses are valid.
        """
        self.validate_tokens(tokens, false)

    me validate_tokens(tokens: [TemplateToken], is_matcher: bool) -> bool:
        """Validate a sequence of template tokens."""
        var prev_kind: FragmentKind? = nil
        var i = 0

        for token in tokens:
            match token:
                case Param(name, kind):
                    if is_matcher:
                        # In matcher: declare parameter
                        self.declare_param(name, kind, i)
                    else:
                        # In transcriber: use parameter
                        self.use_param(name, kind, i)

                    # Check follow-set
                    if not kind.can_follow(prev_kind):
                        self.errors = self.errors.push(TemplateError.at(
                            "'{kind.to_text()}' cannot follow '{prev_kind.unwrap().to_text()}'",
                            i
                        ))

                    prev_kind = Some(kind)

                case Repetition(inner_tokens, sep, rep_kind):
                    self.current_rep_depth = self.current_rep_depth + 1
                    self.validate_tokens(inner_tokens, is_matcher)
                    self.current_rep_depth = self.current_rep_depth - 1

                    # Validate separator
                    if sep.?:
                        val s = sep.unwrap()
                        if s.len() > 1:
                            self.errors = self.errors.push(TemplateError.at(
                                "Separator must be a single token",
                                i
                            ))

                    prev_kind = nil  # Repetition resets follow context

                case Group(delim, inner_tokens):
                    self.validate_tokens(inner_tokens, is_matcher)
                    prev_kind = nil

                case Literal(_) | Punct(_) | Keyword(_):
                    prev_kind = nil

            i = i + 1

        self.errors.is_empty()

    me declare_param(name: text, kind: FragmentKind, pos: i64):
        """Declare a parameter in the matcher."""
        if self.params.contains_key(name):
            self.errors = self.errors.push(TemplateError.at(
                "Duplicate parameter '${name}'",
                pos
            ))
            return

        val param = if self.current_rep_depth > 0:
            TemplateParam.repeated(name, kind, self.current_rep_depth)
        else:
            TemplateParam.simple(name, kind)

        self.params[name] = param

    me use_param(name: text, kind: FragmentKind, pos: i64):
        """Use a parameter in the transcriber."""
        match self.params.get(name):
            case nil:
                self.errors = self.errors.push(TemplateError.at(
                    "Undefined parameter '${name}'",
                    pos
                ))
            case Some(param):
                # Check repetition depth matches
                if param.repetition_depth > 0 and self.current_rep_depth < param.repetition_depth:
                    self.errors = self.errors.push(TemplateError.at(
                        "Parameter '${name}' must be used inside repetition",
                        pos
                    ))

    fn get_errors() -> [TemplateError]:
        """Get validation errors."""
        self.errors

    fn has_errors() -> bool:
        """Check if validation produced errors."""
        not self.errors.is_empty()

# ============================================================================
# Template Type Checker
# ============================================================================

class TemplateTypeChecker:
    """Type checks macro templates.

    Ensures type consistency between matcher and transcriber.
    """
    validator: TemplateValidator
    type_env: Dict<text, text>  # Param name -> expected type

    static fn create() -> TemplateTypeChecker:
        TemplateTypeChecker(
            validator: TemplateValidator.create(),
            type_env: {}
        )

    me check_rule(matcher: [TemplateToken], transcriber: [TemplateToken]) -> bool:
        """Type check a macro rule (matcher => transcriber)."""
        # First validate matcher
        if not self.validator.validate_matcher(matcher):
            return false

        # Build type environment from matcher
        for name, param in self.validator.params:
            self.type_env[name] = param.kind.to_text()

        # Then validate transcriber
        if not self.validator.validate_transcriber(transcriber):
            return false

        true

    me infer_expansion_type(transcriber: [TemplateToken]) -> text?:
        """Infer the type produced by the transcriber.

        Returns the fragment kind that the transcriber produces.
        """
        # Look at the outermost structure
        if transcriber.is_empty():
            return Some("unit")

        # Simple heuristic: look at first significant token
        for token in transcriber:
            match token:
                case Param(name, kind):
                    # Single parameter produces its type
                    if transcriber.len() == 1:
                        return Some(kind.to_text())
                case Group("{", _):
                    return Some("block")
                case Keyword(kw):
                    match kw:
                        case "fn": return Some("item")
                        case "struct": return Some("item")
                        case "let": return Some("stmt")
                        case "if": return Some("expr")
                        case _: pass
                case _:
                    pass

        Some("tt")  # Default to token tree

    fn get_errors() -> [TemplateError]:
        """Get all type checking errors."""
        self.validator.get_errors()

# ============================================================================
# Exports
# ============================================================================

export FragmentKind, TemplateToken, RepetitionKind
export TemplateParam, TemplateError
export TemplateValidator, TemplateTypeChecker
