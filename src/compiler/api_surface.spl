# API Surface Analysis
#
# Generates a manifest of all public types, functions, and signatures.
# Prevents accidental API changes and makes diffs reviewable.
#
# Port of rust/compiler/src/api_surface.rs (481 lines)

export FunctionSignature, ParamSignature, FieldSignature
export StructSignature, ClassSignature, EnumSignature, TraitSignature
export ApiSurface

use std.string.{NL}

# ============================================================================
# Signature Types
# ============================================================================

struct ParamSignature:
    name: text
    type_name: text?

struct FieldSignature:
    name: text
    type_name: text?
    is_public: bool

struct FunctionSignature:
    name: text
    params: [ParamSignature]
    return_type: text?
    is_async: bool
    is_generator: bool

struct StructSignature:
    name: text
    fields: [FieldSignature]

struct ClassSignature:
    name: text
    fields: [FieldSignature]
    methods: [text]

struct EnumSignature:
    name: text
    variants: [text]

struct TraitSignature:
    name: text
    methods: [text]

# ============================================================================
# API Surface
# ============================================================================

class ApiSurface:
    """Public API surface of a module."""
    module: text
    functions: {text: FunctionSignature}
    structs: {text: StructSignature}
    classes: {text: ClassSignature}
    enums: {text: EnumSignature}
    traits: {text: TraitSignature}

impl ApiSurface:
    static fn create(module: text) -> ApiSurface:
        ApiSurface(module: module, functions: {}, structs: {},
                   classes: {}, enums: {}, traits: {})

    me add_function(sig: FunctionSignature):
        self.functions[sig.name] = sig

    me add_struct(sig: StructSignature):
        self.structs[sig.name] = sig

    me add_class(sig: ClassSignature):
        self.classes[sig.name] = sig

    me add_enum(sig: EnumSignature):
        self.enums[sig.name] = sig

    me add_trait(sig: TraitSignature):
        self.traits[sig.name] = sig

    fn diff(other: ApiSurface) -> [ApiChange]:
        """Compare two API surfaces and report changes."""
        var changes: [ApiChange] = []

        # Functions
        for (name, _) in self.functions:
            if not other.functions.contains_key(name):
                changes = changes.push(ApiChange(kind: ApiChangeKind.Removed,
                    symbol: name, category: "function", detail: nil))
        for (name, _) in other.functions:
            if not self.functions.contains_key(name):
                changes = changes.push(ApiChange(kind: ApiChangeKind.Added,
                    symbol: name, category: "function", detail: nil))

        # Structs
        for (name, _) in self.structs:
            if not other.structs.contains_key(name):
                changes = changes.push(ApiChange(kind: ApiChangeKind.Removed,
                    symbol: name, category: "struct", detail: nil))
        for (name, _) in other.structs:
            if not self.structs.contains_key(name):
                changes = changes.push(ApiChange(kind: ApiChangeKind.Added,
                    symbol: name, category: "struct", detail: nil))

        # Classes
        for (name, _) in self.classes:
            if not other.classes.contains_key(name):
                changes = changes.push(ApiChange(kind: ApiChangeKind.Removed,
                    symbol: name, category: "class", detail: nil))
        for (name, _) in other.classes:
            if not self.classes.contains_key(name):
                changes = changes.push(ApiChange(kind: ApiChangeKind.Added,
                    symbol: name, category: "class", detail: nil))

        # Enums
        for (name, _) in self.enums:
            if not other.enums.contains_key(name):
                changes = changes.push(ApiChange(kind: ApiChangeKind.Removed,
                    symbol: name, category: "enum", detail: nil))
        for (name, _) in other.enums:
            if not self.enums.contains_key(name):
                changes = changes.push(ApiChange(kind: ApiChangeKind.Added,
                    symbol: name, category: "enum", detail: nil))

        changes

    fn to_text() -> text:
        """Serialize to readable format for lock file."""
        var lines: [text] = ["# API Surface: {self.module}", ""]

        for (name, sig) in self.functions:
            val params = sig.params.map(\p:
                if p.type_name.?: "{p.name}: {p.type_name.unwrap()}"
                else: p.name
            ).join(", ")
            val ret = if sig.return_type.?: " -> {sig.return_type.unwrap()}" else: ""
            lines = lines.push("fn {name}({params}){ret}")

        for (name, sig) in self.structs:
            lines = lines.push("struct {name}")
            for f in sig.fields:
                lines = lines.push("  {f.name}: {f.type_name ?? \"Any\"}")

        for (name, sig) in self.enums:
            lines = lines.push("enum {name}: {sig.variants.join(\", \")}")

        for (name, sig) in self.traits:
            lines = lines.push("trait {name}: {sig.methods.join(\", \")}")

        lines.join(NL)

# ============================================================================
# API Change
# ============================================================================

enum ApiChangeKind:
    Added
    Removed
    Modified

struct ApiChange:
    kind: ApiChangeKind
    symbol: text
    category: text      # "function", "struct", "class", "enum", "trait"
    detail: text?

impl ApiChange:
    fn is_breaking() -> bool:
        match self.kind:
            case Removed | Modified: true
            case Added: false
